        BOOL* pbHide, 
                                     CNodeList* pNodeList);

	HRESULT SaveToStream(IStream* pStm);
	static HRESULT CreateFromStream(IStream* pStm, CADSIEditConnectionNode** ppConnectionNode);
	void SaveQueryListToStream(IStream* pStm);
	void LoadQueryListFromStream(IStream* pStm);
	void BuildQueryPath(const CString& sPath, CString& sRootPath);

	virtual LPCONTEXTMENUITEM2 OnGetContextMenuItemTable() 
			{ return CADSIEditConnectMenuHolder::GetContextMenuItem(); }

	CADSIEditConnectionNode* GetConnectionNode() { return this; }
	void SetConnectionNode(CADSIEditConnectionNode* pConnect) { m_pConnectData->SetConnectionNode(pConnect); }

  virtual BOOL HasPropertyPages(DATA_OBJECT_TYPES type, 
                                BOOL* pbHideVerb, 
                                CNodeList* pNodeList);

	int GetImageIndex(BOOL bOpenImage);
	void OnChangeState(CComponentDataObject* pComponentDataObject);

	virtual BOOL FindNode(LPCWSTR lpszPath, CList<CTreeNode*, CTreeNode*>& foundNodeList);

	virtual CADsObject* GetADsObject() { return m_pConnectData; }
	virtual CConnectionData* GetConnectionData() { return m_pConnectData; }

	// Accessors to query list
	void AddQueryToList(CADSIEditQueryData* pQueryData)
	{
		m_queryList.AddHead(pQueryData);
	}

	void RemoveQueryFromList(CADSIEditQueryData* pQueryData)
	{
		POSITION pos = m_queryList.Find(pQueryData);
		if (pos != NULL)
		{
			CADSIEditQueryData* pData = m_queryList.GetAt(pos);
			m_queryList.RemoveAt(pos);
			delete pData;
		}
	}

	void RemoveAndDeleteAllQueriesFromList()
	{
		POSITION pos = m_queryList.GetHeadPosition();
		while (pos != NULL)
		{
			CADSIEditQueryData* pQueryData = m_queryList.GetNext(pos);
			delete pQueryData;
		}
	}

	void RemoveAllQueriesFromList()
	{
		m_queryList.RemoveAll();
	}


	BOOL HasQueries()
	{
		return (m_queryList.GetCount() > 0);
	}

	CList<CADSIEditQueryData*, CADSIEditQueryData*>* GetQueryList() { return &m_queryList; }

  bool IsClassAContainer(CCredentialObject* pCredObject,
                         PCWSTR pszClass, 
                         PCWSTR pszSchemaPath);

private:
	CConnectionData* m_pConnectData;

	CList<CADSIEditQueryData*, CADSIEditQueryData*> m_queryList;
  CADSIEditSchemaCache m_SchemaCache;
};


#endif _CONNECTION_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\connectionui.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       connectionui.h
//
//--------------------------------------------------------------------------

#ifndef _CONNECTIONUI_H
#define _CONNECTIONUI_H

#include "snapdata.h"

/////////////////////////////////////////////////////////////////////////////
// CADSIEditConnectDialog

class CADSIEditConnectDialog : public CDialog
{

// Construction
public:
  CADSIEditConnectDialog(CContainerNode* pRootnode,
												 CTreeNode* pTreeNode,
												 CComponentDataObject* pComponentData,
												 CConnectionData* pConnectData
												 );
	~CADSIEditConnectDialog();

protected:

	virtual BOOL OnInitDialog();
	virtual void OnOK();
	virtual BOOL OnApply();
	afx_msg void OnSelChangeContextList();
	afx_msg void OnSelChangeDSList();
	afx_msg void OnSelChangeDNList();
	afx_msg void OnEditChangeDSList();
	afx_msg void OnEditChangeDNList();
	afx_msg void OnAdvanced();
	afx_msg void OnDNRadio();
	afx_msg void OnNCRadio();
	afx_msg void OnDSRadio();
	afx_msg void OnDefaultRadio();

	void SetAndDisplayPath();
	void LoadNamingContext();
	void SetupUI();
	void SetDirty()
	{
		m_bDirty = TRUE;
	}
	BOOL BuildPath(CString& s, BSTR bstrPath, IADs *pADs);
	BOOL BuildNamingContext(CComBSTR& bstrPath);
	void BuildRootDSE(CString& sRootDSE);
	BOOL DoDirty();

	void SaveMRUs();
	void LoadMRUs();

	BOOL m_bDirty;

	CConnectionData* m_pNewConnectData;
	CComponentDataObject* m_pComponentData;

	CADSIEditRootData* GetRootNode() 
	{ 
		CADSIEditRootData* pRoot = dynamic_cast<CADSIEditRootData*>(GetTreeNode());
		if (pRoot == NULL)
		{
			pRoot = dynamic_cast<CADSIEditRootData*>(GetContainerNode());
			ASSERT(pRoot != NULL);
		}
		return pRoot;
	}

	CTreeNode* GetTreeNode() { return m_pTreeNode; }
	CContainerNode* GetContainerNode() { return m_pContainerNode; }
	CComponentDataObject* GetComponentData() { return m_pComponentData; }
	CConnectionData* GetConnectionData() { return m_pNewConnectData; }

private:
	BOOL m_bNewConnect;
	CTreeNode* m_pTreeNode;
	CContainerNode* m_pContainerNode;
	CString m_szDisplayExtra;
	CString m_sDefaultServerName;

	CString m_szDomain;
	CString m_szConfigContainer;
	CString m_szRootDSE;
	CString m_szSchema;

	DECLARE_MESSAGE_MAP()
};


///////////////////////////////////////////////////////////////////////////////
// CADSIEditAdvancedConnectionPageHolder

class CADSIEditAdvancedConnectionDialog : public CDialog
{
public:
	CADSIEditAdvancedConnectionDialog(CContainerNode* pRootDataNode, CTreeNode* pContainerNode,
			CComponentDataObject* pComponentData, CConnectionData* pConnectData); 
	~CADSIEditAdvancedConnectionDialog();

protected:
	virtual BOOL OnInitDialog();
	virtual BOOL OnApply();
	virtual void OnOK();
	virtual void OnCredentials();

	// Member Data
	//
	CTreeNode* m_pTreeNode;
	CContainerNode* m_pContainerNode;
	CComponentDataObject* m_pComponentData;
	CConnectionData* m_pConnectData;

	DECLARE_MESSAGE_MAP()
};
#endif _CONNECTIONUI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\connectui.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       connectui.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#include <SnapBase.h>

#include "resource.h"
#include "connection.h"
#include "connectionui.h"
#include <aclpage.h>


#ifdef DEBUG_ALLOCATOR
    #ifdef _DEBUG
    #define new DEBUG_NEW
    #undef THIS_FILE
    static char THIS_FILE[] = __FILE__;
    #endif
#endif

////////////////////////////////////////////////////////////////////////////////

extern LPCWSTR g_lpszGC;
extern LPCWSTR g_lpszLDAP;
extern LPCWSTR g_lpszRootDSE;

///////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CADSIEditConnectDialog, CDialog)
    //{{AFX_MSG_MAP(CADsObjectDialog)
    ON_CBN_SELCHANGE(IDC_NC_BOX, OnSelChangeContextList)
    ON_CBN_SELCHANGE(IDC_DOMAIN_SERVER_BOX, OnSelChangeDSList)
    ON_CBN_SELCHANGE(IDC_DN_BOX, OnSelChangeDNList)
    ON_CBN_EDITCHANGE(IDC_DOMAIN_SERVER_BOX, OnEditChangeDSList)
    ON_CBN_EDITCHANGE(IDC_DN_BOX, OnEditChangeDNList)
    ON_BN_CLICKED(IDC_DN_RADIO, OnDNRadio)
    ON_BN_CLICKED(IDC_NC_RADIO, OnNCRadio)
    ON_BN_CLICKED(IDC_DOMAIN_SERVER_RADIO, OnDSRadio)
    ON_BN_CLICKED(IDC_DEFAULT_RADIO, OnDefaultRadio)
    ON_BN_CLICKED(IDC_ADVANCED_BUTTON, OnAdvanced)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

CADSIEditConnectDialog::CADSIEditConnectDialog(CContainerNode* pRootnode,
                                                              CTreeNode* pTreeNode,
                                                              CComponentDataObject* pComponentData,
                                                              CConnectionData* pConnectData
                                                             ) : CDialog(IDD_CONNECTION_DIALOG)
{
    m_pContainerNode = pRootnode;
    m_pTreeNode = pTreeNode;
    m_pComponentData = pComponentData;
    m_pNewConnectData = pConnectData;
    m_szDisplayExtra = L"";
    m_sDefaultServerName = L"";
}

CADSIEditConnectDialog::~CADSIEditConnectDialog()
{
  if (m_bNewConnect && m_pNewConnectData != NULL)
    delete m_pNewConnectData;
}


BOOL CADSIEditConnectDialog::OnInitDialog()
{
    CDialog::OnInitDialog();

    CConnectionData* pConnectData = GetConnectionData();

    if (pConnectData == NULL)
    {
        m_pNewConnectData = new CConnectionData();
    if (m_pNewConnectData)
    {
          m_bNewConnect = TRUE;

          CString sServerName;
          m_pNewConnectData->GetDomainServer(sServerName);

          if (sServerName == L"")
          {
              HRESULT hr = CConnectionData::GetServerNameFromDefault(m_pNewConnectData);
        if (SUCCEEDED(hr))
        {
                m_pNewConnectData->GetDomainServer(m_sDefaultServerName);
        }
          }
          m_pNewConnectData->GetDomainServer(m_szDisplayExtra);
    }
    }
    else
    {
        m_pNewConnectData = pConnectData;
        m_bNewConnect = FALSE;
    }

    LoadNamingContext();
    SetupUI();
    SetDirty();

    return TRUE;
}

void CADSIEditConnectDialog::LoadNamingContext()
{
    CComboBox* pcNCBox = (CComboBox*)GetDlgItem(IDC_NC_BOX);

    // NOTICE-2002/03/01-artm  CString can throw out of memory exception,
    // but that needs to be handled at a higher level so don't worry about
    // it here.
    m_szDomain.LoadString(IDS_DOMAIN_NC);
    m_szConfigContainer.LoadString(IDS_CONFIG_CONTAINER);
    m_szRootDSE.LoadString(IDS_ROOTDSE);
    m_szSchema.LoadString(IDS_SCHEMA);

    pcNCBox->AddString(m_szDomain);
    pcNCBox->AddString(m_szConfigContainer);
    pcNCBox->AddString(m_szRootDSE);
    pcNCBox->AddString(m_szSchema);
}

void CADSIEditConnectDialog::SetupUI()
{
    CComboBox* pcDNBox = (CComboBox*)GetDlgItem(IDC_DN_BOX);
    CComboBox* pcNCBox = (CComboBox*)GetDlgItem(IDC_NC_BOX);
    CComboBox* pcDomainServerBox = (CComboBox*)GetDlgItem(IDC_DOMAIN_SERVER_BOX);
    CButton* pcDNRadio = (CButton*)GetDlgItem(IDC_DN_RADIO);
    CButton* pcNCRadio = (CButton*)GetDlgItem(IDC_NC_RADIO);
    CButton* pcDSRadio  = (CButton*)GetDlgItem(IDC_DOMAIN_SERVER_RADIO);
    CButton* pcDefaultRadio = (CButton*)GetDlgItem(IDC_DEFAULT_RADIO);
    CEdit* pcNameBox = (CEdit*)GetDlgItem(IDC_CONNECTION_NAME);


    //Setup UI to reflect data
    LoadMRUs();

    CString  sDistinguishedName;
    m_pNewConnectData->GetDistinguishedName(sDistinguishedName);

    if (!sDistinguishedName.IsEmpty())
    {
        int iIndex = pcDNBox->FindStringExact(-1, sDistinguishedName);
        if (iIndex != CB_ERR)
        {
            pcDNBox->SetCurSel(iIndex);
        }
        else
        {
            int nIndex = pcDNBox->AddString(sDistinguishedName);
            pcDNBox->SetCurSel(nIndex);
        }
        OnSelChangeDNList();
        pcDNRadio->SetCheck(BST_CHECKED);
    }
    else
    {
        CString sNamingContext;
        m_pNewConnectData->GetNamingContext(sNamingContext);

        int iIndex = pcNCBox->FindStringExact(-1, sNamingContext);
        if (iIndex != CB_ERR)
        {
            pcNCBox->SetCurSel(iIndex);

        }
        else
        {
            pcNCBox->SetCurSel(0);
        }
        OnSelChangeContextList();
        pcNCRadio->SetCheck(BST_CHECKED);
    }

    CString sServer;
    m_pNewConnectData->GetDomainServer(sServer);

    BOOL bUserDefinedServer;
    bUserDefinedServer = m_pNewConnectData->GetUserDefinedServer();

    if (!sServer.IsEmpty() && bUserDefinedServer)
    {
        int iIndex = pcDomainServerBox->FindStringExact(-1, sServer);
        if (iIndex != CB_ERR)
        {
            pcDomainServerBox->SetCurSel(iIndex);
        }
        else
        {
            int nIndex = pcDomainServerBox->AddString(sServer);
            pcDomainServerBox->SetCurSel(nIndex);
        }
        OnSelChangeDSList();
        pcDSRadio->SetCheck(BST_CHECKED);
    }
    else
    {
        pcDefaultRadio->SetCheck(BST_CHECKED);
    }
    CString sName;
    m_pNewConnectData->GetName(sName);

    pcNameBox->SetLimitText(MAX_CONNECT_NAME_LENGTH);
    if (sName.IsEmpty())
    {
        if (pcNCRadio->GetCheck())
        {
            CString szNCName;
            pcNCBox->GetLBText(pcNCBox->GetCurSel(), szNCName);
            pcNameBox->SetWindowText(szNCName);
            m_pNewConnectData->GetDomainServer(m_szDisplayExtra);
        }
        else
        {
            CString szMyConnection;
            // NOTICE-2002/03/01-artm  CString can throw out of memory exception,
            // but that needs to be handled at a higher level so don't worry about
            // it here.
            szMyConnection.LoadString(IDS_MY_CONNECTION);
            pcNameBox->SetWindowText(szMyConnection);
        }
    }
    else
    {
        pcNameBox->SetWindowText(sName);
    }

    SetAndDisplayPath();
}

void CADSIEditConnectDialog::LoadMRUs()
{
    CComboBox* pcDomainServerBox = (CComboBox*)GetDlgItem(IDC_DOMAIN_SERVER_BOX);
    CComboBox* pcDNBox = (CComboBox*)GetDlgItem(IDC_DN_BOX);

    CADSIEditRootData* pRootNode = GetRootNode();
    CStringList sServerMRU, sDNMRU;
    pRootNode->GetServerMRU(&sServerMRU);
    pRootNode->GetDNMRU(&sDNMRU);

    POSITION pos = sServerMRU.GetHeadPosition();
    while (pos != NULL)
    {
        CString sMRU;
        sMRU = sServerMRU.GetNext(pos);
        pcDomainServerBox->AddString(sMRU);
    }

    pos = sDNMRU.GetHeadPosition();
    while (pos != NULL)
    {
        CString sMRU;
        sMRU = sDNMRU.GetNext(pos);
        pcDNBox->AddString(sMRU);
    }
}

void CADSIEditConnectDialog::SaveMRUs()
{
    CADSIEditRootData* pRootNode = GetRootNode();
    CStringList sDNMRU, sServerMRU;
    CString sDS, sDN;
    BOOL bFound = FALSE;

    m_pNewConnectData->GetDistinguishedName(sDN);
    m_pNewConnectData->GetDomainServer(sDS);

    pRootNode->GetServerMRU(&sServerMRU);
    pRootNode->GetDNMRU(&sDNMRU);

    POSITION pos = sServerMRU.GetHeadPosition();
    while (pos != NULL)
    {
        CString sServer;
        sServer = sServerMRU.GetNext(pos);
        if (sServer == sDS)
        {
            bFound = TRUE;
            break;
        }
    }

    if (!bFound && !sDS.IsEmpty())
    {
        sServerMRU.AddHead(sDS);
        pRootNode->SetServerMRU(&sServerMRU);
    }

    bFound = FALSE;
    pos = sDNMRU.GetHeadPosition();
    while (pos != NULL)
    {
        CString sDistinguishedName;
        sDistinguishedName = sDNMRU.GetNext(pos);
        if (sDistinguishedName == sDN)
        {
            bFound = TRUE;
            break;
        }
    }

    if (!bFound && !sDN.IsEmpty())
    {
        sDNMRU.AddHead(sDN);
        pRootNode->SetDNMRU(&sDNMRU);
    }
}

void CADSIEditConnectDialog::OnDNRadio()
{
    SetDirty();
    SetAndDisplayPath();
}

void CADSIEditConnectDialog::OnNCRadio()
{
    SetDirty();
    SetAndDisplayPath();
}

void CADSIEditConnectDialog::OnDSRadio()
{
    CComboBox* pcDomainServerBox = (CComboBox*)GetDlgItem(IDC_DOMAIN_SERVER_BOX);

    CString szDS;
    pcDomainServerBox->GetWindowText(szDS);
    m_pNewConnectData->SetDomainServer(szDS);
    m_pNewConnectData->SetUserDefinedServer(TRUE);

    SetDirty();
    SetAndDisplayPath();
}

void CADSIEditConnectDialog::OnDefaultRadio()
{
    m_pNewConnectData->SetUserDefinedServer(FALSE);

  if (m_pNewConnectData->IsGC())
  {
    m_pNewConnectData->SetDomainServer(L"");
  }
  else
  {
    m_pNewConnectData->SetDomainServer(m_sDefaultServerName);
  }

    SetDirty();
    SetAndDisplayPath();
}

void CADSIEditConnectDialog::SetAndDisplayPath()
{
    CEdit* pcPathBox = (CEdit*)GetDlgItem(IDC_FULLPATH_BOX);
    CButton* pcDSRadio  = (CButton*)GetDlgItem(IDC_DOMAIN_SERVER_RADIO);
    CButton* pcDNRadio = (CButton*)GetDlgItem(IDC_DN_RADIO);
    CComboBox* pcNCBox = (CComboBox*)GetDlgItem(IDC_NC_BOX);

    // Get data from connection node
    //
    CString szLDAP, sServer, sPort, sDistinguishedName, sNamingContext;
    m_pNewConnectData->GetLDAP(szLDAP);
    m_pNewConnectData->GetDomainServer(sServer);
    m_pNewConnectData->GetPort(sPort);
    m_pNewConnectData->GetDistinguishedName(sDistinguishedName);
    m_pNewConnectData->GetNamingContext(sNamingContext);
    m_pNewConnectData->SetRootDSE(FALSE);

    CString szFullPath;
    if (!sServer.IsEmpty())
    {
        szFullPath = szFullPath + sServer;
        if (!sPort.IsEmpty())
        {
            szFullPath = szFullPath + _T(":") + sPort + _T("/");
        }
        else
        {
            szFullPath = szFullPath + _T("/");
        }
    }

    if (pcDNRadio->GetCheck() && !sDistinguishedName.IsEmpty())
    {
        szFullPath = szFullPath + sDistinguishedName;
        // NOTICE-2002/03/01-artm  Both strings always null terminated, wcscmp() okay.
        // sDistinguishedName is a CString and g_lpszRootDSE is a constant.
        if (wcscmp(sDistinguishedName, g_lpszRootDSE) == 0)
        {
            m_pNewConnectData->SetRootDSE(TRUE);
        }
    }
    else
    {
        szFullPath = szFullPath + sNamingContext;
        // NOTICE-2002/03/01-artm  Both strings always null terminated, wcscmp() okay.
        // sNamingContext is a CString and g_lpszRootDSE is a constant.
        if (wcscmp(sNamingContext, g_lpszRootDSE) == 0)
        {
            m_pNewConnectData->SetRootDSE(TRUE);
        }
    }   

    m_pNewConnectData->GetDomainServer(m_szDisplayExtra);
    m_szDisplayExtra = L" [" + m_szDisplayExtra + L"]";

    szFullPath = szLDAP + szFullPath;
    pcPathBox->SetWindowText(szFullPath);
}

void CADSIEditConnectDialog::OnSelChangeContextList()
{
    CComboBox* pcNCBox = (CComboBox*)GetDlgItem(IDC_NC_BOX);
    CButton* pcDNRadio = (CButton*)GetDlgItem(IDC_DN_RADIO);
    CButton* pcNCRadio = (CButton*)GetDlgItem(IDC_NC_RADIO);
    CEdit* pcNameBox = (CEdit*)GetDlgItem(IDC_CONNECTION_NAME);

    CString szContext;
    SetDirty();
    pcNCBox->GetLBText(pcNCBox->GetCurSel(), szContext);
    m_pNewConnectData->SetNamingContext(szContext);
    pcNCRadio->SetCheck(BST_CHECKED);
    pcDNRadio->SetCheck(BST_UNCHECKED);

    CString sName;
    pcNCBox->GetLBText(pcNCBox->GetCurSel(), sName);
    pcNameBox->SetWindowText(sName);

    SetAndDisplayPath();
}

void CADSIEditConnectDialog::OnSelChangeDSList()
{
    CComboBox* pcDomainServerBox = (CComboBox*)GetDlgItem(IDC_DOMAIN_SERVER_BOX);
    CButton* pcDSRadio  = (CButton*)GetDlgItem(IDC_DOMAIN_SERVER_RADIO);
    CButton* pcDefaultRadio = (CButton*)GetDlgItem(IDC_DEFAULT_RADIO);

    SetDirty();
    if (pcDomainServerBox->GetCount() > 0)
    {
        CString sServer;
        pcDomainServerBox->GetLBText(pcDomainServerBox->GetCurSel(), sServer);
        m_pNewConnectData->SetDomainServer(sServer);
        m_pNewConnectData->SetUserDefinedServer(TRUE);
    }
    pcDSRadio->SetCheck(BST_CHECKED);
    pcDefaultRadio->SetCheck(BST_UNCHECKED);
    SetAndDisplayPath();
}

void CADSIEditConnectDialog::OnSelChangeDNList()
{
    CComboBox* pcDNBox = (CComboBox*)GetDlgItem(IDC_DN_BOX);
    CButton* pcDNRadio = (CButton*)GetDlgItem(IDC_DN_RADIO);
    CButton* pcNCRadio = (CButton*)GetDlgItem(IDC_NC_RADIO);

    SetDirty();
    if (pcDNBox->GetCount() > 0)
    {
        CString sDistinguishedName;
        pcDNBox->GetLBText(pcDNBox->GetCurSel(), sDistinguishedName);
        m_pNewConnectData->SetDistinguishedName(sDistinguishedName);
    }
    pcDNRadio->SetCheck(BST_CHECKED);
    pcNCRadio->SetCheck(BST_UNCHECKED);
    SetAndDisplayPath();
}


void CADSIEditConnectDialog::OnEditChangeDSList()
{
    CComboBox* pcDomainServerBox = (CComboBox*)GetDlgItem(IDC_DOMAIN_SERVER_BOX);
    CButton* pcDSRadio  = (CButton*)GetDlgItem(IDC_DOMAIN_SERVER_RADIO);
    CButton* pcDefaultRadio = (CButton*)GetDlgItem(IDC_DEFAULT_RADIO);

    SetDirty();
    CString szDS, sOldDS;

    pcDomainServerBox->GetWindowText(szDS);
    m_pNewConnectData->SetDomainServer(szDS);

    pcDSRadio->SetCheck(BST_CHECKED);
    pcDefaultRadio->SetCheck(BST_UNCHECKED);
    SetAndDisplayPath();
    m_pNewConnectData->SetUserDefinedServer(TRUE);
}

void CADSIEditConnectDialog::OnEditChangeDNList()
{
    CComboBox* pcDNBox = (CComboBox*)GetDlgItem(IDC_DN_BOX);
    CButton* pcDNRadio = (CButton*)GetDlgItem(IDC_DN_RADIO);
    CButton* pcNCRadio = (CButton*)GetDlgItem(IDC_NC_RADIO);

    SetDirty();
    CString s, sOldDN;

    pcDNBox->GetWindowText(s);
    m_pNewConnectData->SetDistinguishedName(s);

    pcDNRadio->SetCheck(BST_CHECKED);
    pcNCRadio->SetCheck(BST_UNCHECKED);
    SetAndDisplayPath();
}

void CADSIEditConnectDialog::OnAdvanced()
{
  CWaitCursor cursor;
   CThemeContextActivator activator;
    CADSIEditRootData* pRootNode = GetRootNode();
    
    CADSIEditAdvancedConnectionDialog AdvancedDialog(NULL, 
                                                                     pRootNode, 
                                                                     m_pComponentData, 
                                                                     m_pNewConnectData);
    if (AdvancedDialog.DoModal() == IDOK)
    {
    cursor.Restore();
    if (m_pNewConnectData->IsGC() && !m_pNewConnectData->GetUserDefinedServer())
    {
      m_pNewConnectData->SetDomainServer(L"");
    }
    else if (!m_pNewConnectData->IsGC())
    {
            CConnectionData::GetServerNameFromDefault(m_pNewConnectData);
    }

        SetDirty();
        SetAndDisplayPath();
    }
}

void CADSIEditConnectDialog::OnOK()
{
    if (OnApply())
    {
        CDialog::OnOK();
    }
}

BOOL CADSIEditConnectDialog::OnApply()
{
    CEdit* pcNameBox = (CEdit*)GetDlgItem(IDC_CONNECTION_NAME);

    CADSIEditRootData* pRootNode = GetRootNode();
    ASSERT(pRootNode != NULL);
    CComponentDataObject* pComponentData = GetComponentData();

    BSTR bstrPath;

    CString sName;
    pcNameBox->GetWindowText(sName);
    m_pNewConnectData->SetName(sName);

    if (m_bDirty)
    {
        if (!DoDirty())
        {
            return FALSE;
        }
    }
    else
    {
        if (pRootNode->GetDisplayName() != sName)
        {
            pRootNode->SetDisplayName(sName + m_szDisplayExtra);
        }
        else
        {
            ADSIEditMessageBox(IDS_MSG_CONNECTION_NAME, MB_OK);
            return FALSE;
        }
    }

    return TRUE;
}

BOOL CADSIEditConnectDialog::DoDirty()
{
    CEdit* pcNameBox = (CEdit*)GetDlgItem(IDC_CONNECTION_NAME);

    CADSIEditContainerNode* pTreeNode = dynamic_cast<CADSIEditContainerNode*>(GetTreeNode());

    CADSIEditRootData* pRootNode = GetRootNode();
    ASSERT(pRootNode != NULL);
    CComponentDataObject* pComponentData = GetComponentData();

    SaveMRUs();

    CString sRootDSE, s;
    BuildRootDSE(sRootDSE);

    CComPtr<IADs> spRootADs;
    HRESULT hr, hCredResult;
    hr = OpenObjectWithCredentials(
                                             m_pNewConnectData, 
                                             m_pNewConnectData->GetCredentialObject()->UseCredentials(),
                                             sRootDSE,
                                             IID_IADs, 
                                             (LPVOID*) &spRootADs,
                                             GetSafeHwnd(),
                                             hCredResult
                                             );
    if ( FAILED(hr) )
    {
        if (SUCCEEDED(hCredResult))
        {
            ADSIEditErrorMessage(hr);
        }
        return FALSE;
    }

    CString sNamingContext, sDistinguishedName, sServerName;
    m_pNewConnectData->GetNamingContext(sNamingContext);
    m_pNewConnectData->GetDistinguishedName(sDistinguishedName);

    if ( m_pNewConnectData->IsRootDSE())
    {
        s = g_lpszRootDSE;
        if (!m_bNewConnect)
        {
            CString sName;
            pcNameBox->GetWindowText(sName);
            m_pNewConnectData->SetName(sName);

      CString szProvider, sServer, sPort, sPath;
        m_pNewConnectData->GetDomainServer(sServer);
        m_pNewConnectData->GetPort(sPort);
      m_pNewConnectData->GetLDAP(szProvider);

      if (sServer != _T(""))
      {
        if (sPort != _T(""))
        {
          sPath = szProvider + sServer + _T(":") + sPort + _T("/") + CString(sName);
        }
        else
        {
          sPath = szProvider + sServer + _T("/") + CString(sName);
        }
      }
      else
      {
        sPath = szProvider + CString(sName);
      }
            m_pNewConnectData->SetPath(sPath);
            
            ASSERT(pTreeNode != NULL);
            pTreeNode->SetDisplayName(sName + m_szDisplayExtra);
            m_pNewConnectData->SetBasePath(_T(""));
        }
        else
        {
            // Name
            LPWSTR objectName;
            spRootADs->get_Name(&objectName);
            if (objectName == NULL)
            {
                ADSIEditMessageBox(IDS_MSG_ROOTDSE_ERROR, MB_OK);
                return FALSE;
            }
            m_pNewConnectData->SetName(objectName);

      CString szProvider, sServer, sPort, sPath;
        m_pNewConnectData->GetDomainServer(sServer);
        m_pNewConnectData->GetPort(sPort);
      m_pNewConnectData->GetLDAP(szProvider);

      if (sServer != _T(""))
      {
        if (sPort != _T(""))
        {
          sPath = szProvider + sServer + _T(":") + sPort + _T("/") + CString(objectName);
        }
        else
        {
          sPath = szProvider + sServer + _T("/") + CString(objectName);
        }
      }
      else
      {
        sPath = szProvider + CString(objectName);
      }
            m_pNewConnectData->SetPath(sPath);

      m_pNewConnectData->SetClass(_T(""));

            CString sName;
            pcNameBox->GetWindowText(sName);
            if (sName.GetLength() > 0)
            {
                //Create a connection node
                m_pNewConnectData->SetName(sName);
                CADSIEditConnectionNode *pConnectNode = new CADSIEditConnectionNode(m_pNewConnectData);
                pConnectNode->SetDisplayName(sName + m_szDisplayExtra);
                pConnectNode->GetConnectionData()->SetConnectionNode(pConnectNode);
                VERIFY(pRootNode->AddChildToListAndUI(pConnectNode, pComponentData));
        pComponentData->SetDescriptionBarText(pRootNode);
            }
    
            else
            {
                ADSIEditMessageBox(IDS_MSG_CONNECTION_NAME, MB_OK);
                return FALSE;
            }
        }
    }       //if RootDSE
    else
    {
        CComBSTR bstrPath;
        if (!BuildNamingContext(bstrPath))
        {
            return FALSE;
        }

      if (!bstrPath)
      {
         return FALSE;
      }

        if (!BuildPath(s, (BSTR)bstrPath, spRootADs))
        {
            return FALSE;
        }
        
        if (!m_bNewConnect)
        {
            CString sName;
            pcNameBox->GetWindowText(sName);
            m_pNewConnectData->SetName(sName);
            m_pNewConnectData->SetPath(s);

            ASSERT(pTreeNode != NULL);
            pTreeNode->SetDisplayName(sName + m_szDisplayExtra);

            if (!pTreeNode->OnEnumerate(pComponentData))
            {
                return FALSE;
            }

/*          if (!pTreeNode->OnRefresh(pComponentData))
            {
                return FALSE;
            }
            */
        }
        else
        {
            CComPtr<IDirectoryObject> spDirObject;

            hr = OpenObjectWithCredentials(
                                                     m_pNewConnectData, 
                                                     m_pNewConnectData->GetCredentialObject()->UseCredentials(),
                                                     s,
                                                     IID_IDirectoryObject, 
                                                     (LPVOID*) &spDirObject,
                                                     GetSafeHwnd(),
                                                     hCredResult
                                                    );
            if ( FAILED(hr) )
            {
                if (SUCCEEDED(hCredResult))
                {
                    ADSIEditErrorMessage(hr);
                }
                return FALSE;
            }

            ADS_OBJECT_INFO* pInfo;
            hr = spDirObject->GetObjectInformation(&pInfo);
            if (FAILED(hr))
            {
                ADSIEditErrorMessage(hr);
                return FALSE;
            }

            // Name
            m_pNewConnectData->SetName(pInfo->pszRDN);
            m_pNewConnectData->SetPath(s);

            // Class
            m_pNewConnectData->SetClass(pInfo->pszClassName);
            FreeADsMem(pInfo);

            CString sName;
            pcNameBox->GetWindowText(sName);
            if (sName.GetLength() > 0)
            {
                //Create a connection node
                m_pNewConnectData->SetName(sName);
                CADSIEditConnectionNode *pConnectNode = new CADSIEditConnectionNode(m_pNewConnectData);
                pConnectNode->SetDisplayName(sName + m_szDisplayExtra);
                pConnectNode->GetConnectionData()->SetConnectionNode(pConnectNode);
                VERIFY(pRootNode->AddChildToListAndUI(pConnectNode, pComponentData));
        pComponentData->SetDescriptionBarText(pRootNode);
            }
            else
            {
                ADSIEditMessageBox(IDS_MSG_CONNECTION_NAME, MB_OK);
                return FALSE;
            }
        }
    }       //else

    return TRUE;
}

BOOL CADSIEditConnectDialog::BuildPath(CString& s, BSTR bstrPath, IADs* pADs)
{
    CButton* pcDNRadio = (CButton*)GetDlgItem(IDC_DN_RADIO);
    CButton* pcNCRadio = (CButton*)GetDlgItem(IDC_NC_RADIO);

    HRESULT hr;
    CString szLDAP, basePath, sServer, sPort, sDistinguishedName;
    m_pNewConnectData->GetLDAP(szLDAP);
    m_pNewConnectData->GetDomainServer(sServer);
    m_pNewConnectData->GetPort(sPort);
    m_pNewConnectData->GetDistinguishedName(sDistinguishedName);

    if ( pcNCRadio->GetCheck())
    {
        VARIANT var;
        VariantInit(&var);
        hr = pADs->Get( bstrPath, &var );

        if ( FAILED(hr) )
        {
            VariantClear(&var);
            return FALSE;
        }

        if (!sServer.IsEmpty())
        {
            s = s + sServer;
            if (!sPort.IsEmpty())
            {
                s = s + _T(":") + sPort + _T("/");
            }
            else
            {
                s = s + _T("/");
            }
        }
        s = s  + V_BSTR(&var);
        basePath = V_BSTR(&var);
        VariantClear(&var);
    }
    else if(pcDNRadio->GetCheck())
    {
        if (!sServer.IsEmpty())
        {
            s = s + sServer;
            if (!sPort.IsEmpty())
            {
                s = s + _T(":") + sPort + _T("/");
            }
            else
            {
                s = s + _T("/");
            }
        }
        s = s + sDistinguishedName;
        basePath = sDistinguishedName;
    }

    m_pNewConnectData->SetBasePath(basePath);
    s = szLDAP + s;
    return TRUE;
}

BOOL CADSIEditConnectDialog::BuildNamingContext(CComBSTR& bstrPath)
{
    CButton* pcDNRadio = (CButton*)GetDlgItem(IDC_DN_RADIO);
    CButton* pcNCRadio = (CButton*)GetDlgItem(IDC_NC_RADIO);

    CString sNamingContext;
    m_pNewConnectData->GetNamingContext(sNamingContext);

    if ( pcNCRadio->GetCheck())
    {
        if ( sNamingContext == m_szDomain)
        {
            bstrPath = SysAllocString( L"defaultNamingContext");
        }
        else if ( sNamingContext == m_szSchema)
        {
            bstrPath = SysAllocString(L"schemaNamingContext");
        }
        else if ( sNamingContext == m_szConfigContainer)
        {
            bstrPath = SysAllocString(L"configurationNamingContext");
        }
        else
        {
            bstrPath = SysAllocString( L"defaultNamingContext");
        }   
        m_pNewConnectData->SetDistinguishedName(_T(""));
    }
    else if (pcDNRadio->GetCheck())
    {
        CString sDistinguishedName;
        m_pNewConnectData->GetDistinguishedName(sDistinguishedName);
        if (sDistinguishedName.Find(L'=') == -1)
        {
            int iResult = ADSIEditMessageBox(IDS_MSG_NOT_X500_PATH, MB_YESNO | MB_DEFBUTTON2);
            if (iResult ==  IDNO)
            {
                return FALSE;
            }
        }
        bstrPath = sDistinguishedName.AllocSysString();
        m_pNewConnectData->SetNamingContext(_T(""));
    }
    return TRUE;
}

void CADSIEditConnectDialog::BuildRootDSE(CString& sRootDSE)
{
    CButton* pDefaultRadio = (CButton*)GetDlgItem(IDC_DEFAULT_RADIO);

    CString sServer, sPort, sLDAP;
    m_pNewConnectData->GetDomainServer(sServer);
    m_pNewConnectData->GetPort(sPort);
    m_pNewConnectData->GetLDAP(sLDAP);

    if (!sServer.IsEmpty())
    {
        sRootDSE = sLDAP + sServer;
        if (!sPort.IsEmpty())
        {
            sRootDSE = sRootDSE + _T(":") + sPort + _T("/");
        }
        else
        {
            sRootDSE = sRootDSE + _T("/");
        }
        sRootDSE = sRootDSE + g_lpszRootDSE;
    }
    else
    {
        sRootDSE = sLDAP + g_lpszRootDSE;
    }
}


/////////////////////////////////////////////////////////////////////////////////////////////////
// CADSIEditAdvancedConnectionDialog :

BEGIN_MESSAGE_MAP(CADSIEditAdvancedConnectionDialog, CDialog)
    //{{AFX_MSG_MAP(CADsObjectDialog)
    ON_BN_CLICKED(IDC_CREDENTIALS_CHECK, OnCredentials)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


CADSIEditAdvancedConnectionDialog::CADSIEditAdvancedConnectionDialog(CContainerNode* pRootDataNode, 
            CTreeNode* pContainerNode, CComponentDataObject* pComponentData, CConnectionData* pConnectData) 
                : CDialog(IDD_CONNECTION_ADVANCED)
{
    // Get the local data
    //
    m_pTreeNode = pContainerNode;
    m_pContainerNode = pRootDataNode;
    ASSERT(pComponentData != NULL);
    m_pComponentData = pComponentData;
    ASSERT(pConnectData != NULL);
    m_pConnectData = pConnectData;
}

CADSIEditAdvancedConnectionDialog::~CADSIEditAdvancedConnectionDialog() 
{
}

BOOL CADSIEditAdvancedConnectionDialog::OnInitDialog()
{
    CDialog::OnInitDialog();

    // Attach all the controls
    //
    CEdit* pcPortBox = (CEdit*)GetDlgItem(IDC_PORT);
    CButton* pcLDAPRadio = (CButton*)GetDlgItem(IDC_LDAP_RADIO);
    CButton* pcGCRadio = (CButton*)GetDlgItem(IDC_GC_RADIO);
    CButton* pcCredCheck = (CButton*)GetDlgItem(IDC_CREDENTIALS_CHECK);
    CEdit* pcUsernameBox = (CEdit*)GetDlgItem(IDC_USERNAME);
    CEdit* pcPasswordBox = (CEdit*)GetDlgItem(IDC_PASSWORD);

  // disable IME support on numeric edit fields
  ImmAssociateContext(pcPortBox->GetSafeHwnd(), NULL);

    // Set the initial state of the controls
    //
    CString sLDAP;
    m_pConnectData->GetLDAP(sLDAP);

    // NOTICE-2002/03/01-artm  Both strings always null terminated, wcscmp() okay.
    // sLDAP is a CString and g_lpszLDAP is a constant.
    if (wcscmp(sLDAP, g_lpszLDAP) == 0)
    {
        pcLDAPRadio->SetCheck(BST_CHECKED);
    }
    else
    {
        pcGCRadio->SetCheck(BST_CHECKED);
    }

    CString sPort;
    m_pConnectData->GetPort(sPort);
    pcPortBox->SetWindowText(sPort);

    if (m_pConnectData->GetCredentialObject()->UseCredentials())
    {
        CString sUser;
        m_pConnectData->GetCredentialObject()->GetUsername(sUser);
        pcCredCheck->SetCheck(TRUE);
        OnCredentials();
        pcUsernameBox->SetWindowText(sUser);
    }

    pcPasswordBox->SetLimitText(MAX_PASSWORD_LENGTH);

    return TRUE;
}

void CADSIEditAdvancedConnectionDialog::OnOK()
{
    OnApply();
    CDialog::OnOK();
}

BOOL CADSIEditAdvancedConnectionDialog::OnApply()
{
    BOOL success = TRUE;
    CEdit* pcPortBox = (CEdit*)GetDlgItem(IDC_PORT);
    CButton* pcLDAPRadio = (CButton*)GetDlgItem(IDC_LDAP_RADIO);
    CButton* pcCredCheck = (CButton*)GetDlgItem(IDC_CREDENTIALS_CHECK);
    CEdit* pcUsernameBox = (CEdit*)GetDlgItem(IDC_USERNAME);

    // Make the connection data reflect the controls
    //
    CString sPort;
    pcPortBox->GetWindowText(sPort);
    m_pConnectData->SetPort(sPort);

    if (pcLDAPRadio->GetCheck())
    {
        m_pConnectData->SetLDAP(g_lpszLDAP);
    }
    else
    {
        m_pConnectData->SetLDAP(g_lpszGC);
    }

    if (pcCredCheck->GetCheck())
    {
        // Get user name and password
        //
        CString sUser;
        HRESULT hr;
        pcUsernameBox->GetWindowText(sUser);
        
        m_pConnectData->GetCredentialObject()->SetUsername(sUser);

        hr = m_pConnectData->GetCredentialObject()->SetPasswordFromHwnd(
            GetSafeHwnd(),
            IDC_PASSWORD);
        
        if (FAILED(hr))
        {
            success = FALSE;
        }

        m_pConnectData->GetCredentialObject()->SetUseCredentials(TRUE);
    }
    else
    {
        m_pConnectData->GetCredentialObject()->SetUseCredentials(FALSE);
    }

    return success;
}

void CADSIEditAdvancedConnectionDialog::OnCredentials()
{
    CButton* pcCredCheck = (CButton*)GetDlgItem(IDC_CREDENTIALS_CHECK);
    CButton* pcCredGroup = (CButton*)GetDlgItem(IDC_CREDENTIALS_GROUP);
    CStatic* pcCredUser = (CStatic*)GetDlgItem(IDC_CREDENTIALS_USER);
    CStatic* pcCredPassword = (CStatic*)GetDlgItem(IDC_CREDENTIALS_PASSWORD);
    CEdit* pcUsernameBox = (CEdit*)GetDlgItem(IDC_USERNAME);
    CEdit* pcPasswordBox = (CEdit*)GetDlgItem(IDC_PASSWORD);

    BOOL bResult = pcCredCheck->GetCheck();
    if (bResult)
    {
        // Enable Username and password fields
        //
        pcCredGroup->EnableWindow(bResult);
        pcCredUser->EnableWindow(bResult);
        pcCredPassword->EnableWindow(bResult);
        pcUsernameBox->EnableWindow(bResult);
        pcPasswordBox->EnableWindow(bResult);
    }
    else
    {
        // Enable Username and password fields
        //
        pcCredGroup->EnableWindow(FALSE);
        pcCredUser->EnableWindow(FALSE);
        pcCredPassword->EnableWindow(FALSE);
        pcUsernameBox->EnableWindow(FALSE);
        pcPasswordBox->EnableWindow(FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\createwiz.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       createwiz.cpp
//
//--------------------------------------------------------------------------

////////////////////////////////////////////////
// createwiz.cpp

#include "pch.h"
#include <SnapBase.h>

#include "createwiz.h"
#include "connection.h"
#include "editorui.h"
#include "query.h"
#include "resource.h"

#ifdef DEBUG_ALLOCATOR
    #ifdef _DEBUG
    #define new DEBUG_NEW
    #undef THIS_FILE
    static char THIS_FILE[] = __FILE__;
    #endif
#endif

//////////////////////////////////////////////////////////////////////////////////////
// CCreateClassPage

BEGIN_MESSAGE_MAP(CCreateClassPage, CPropertyPageBase)
    //{{AFX_MSG_MAP(CADsObjectDialog)
//  ON_CBN_SELCHANGE(IDC_CLASS_LIST, OnSelChangeClassList)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

CCreateClassPage::CCreateClassPage(CADSIEditContainerNode* pNode) : CPropertyPageBase(IDD_CREATE_CLASS_PAGE)
{
    m_pCurrentNode = pNode;
}

CCreateClassPage::~CCreateClassPage()
{

}

BOOL CCreateClassPage::OnInitDialog()
{
    CPropertyPageBase::OnInitDialog();

    CListBox* pClassList = (CListBox*)GetDlgItem(IDC_CLASS_LIST);

  // disable IME support on numeric edit fields
  ImmAssociateContext(::GetDlgItem(GetSafeHwnd(), IDC_NUMBER_VALUE_BOX), NULL);

    FillList();
    pClassList->SetCurSel(0);
    return TRUE;
}

void CCreateClassPage::FillList()
{
    CListBox* pClassList = (CListBox*)GetDlgItem(IDC_CLASS_LIST);

  HRESULT hr, hCredResult;
    
    CString sPath, schema;
    m_pCurrentNode->GetADsObject()->GetPath(sPath);

    CConnectionData* pConnectData = m_pCurrentNode->GetADsObject()->GetConnectionNode()->GetConnectionData();

    // bind to Container for IPropertyList
    CComPtr<IADsPropertyList> spDSObject;
    hr = OpenObjectWithCredentials(
                                             pConnectData, 
                                             pConnectData->GetCredentialObject()->UseCredentials(),
                                             sPath,
                                             IID_IADsPropertyList, 
                                             (LPVOID*) &spDSObject,
                                             GetSafeHwnd(),
                                             hCredResult
                                             );

  if (FAILED(hr))
    {
    TRACE(_T("Bind to Container for IPropertyList failed: %lx.\n"), hr);
    return;
  }

  // need to do this hack to load the cache
  CComPtr<IADs> spIADs;
  hr = spDSObject->QueryInterface (IID_IADs, (LPVOID*)&spIADs);
  if (FAILED(hr)) 
  {
    TRACE(_T("QI to Container for IADs failed: %lx.\n"), hr);
    return;
  }

    PWSTR g_wzAllowedChildClassesEffective = L"allowedChildClassesEffective";
  CComVariant varHints;
  ADsBuildVarArrayStr (&g_wzAllowedChildClassesEffective, 1, &varHints);
  spIADs->GetInfoEx(varHints, 0);


    // get allowed child classes as VARIANT
    CComVariant VarProp;
  hr = spDSObject->GetPropertyItem(CComBSTR(g_wzAllowedChildClassesEffective),
                                     ADSTYPE_CASE_IGNORE_STRING, &VarProp);
  if (FAILED(hr)) 
    {
        TRACE(_T("GetPropertyItem failed: %lx.\n"), hr);
        return;
  }

    // extract the IADsPropertyEntry interface pointer
    IDispatch* pDisp = V_DISPATCH(&VarProp);
    CComPtr<IADsPropertyEntry> spPropEntry;
  hr = pDisp->QueryInterface(IID_IADsPropertyEntry, (void **)&spPropEntry);
    if (FAILED(hr))
    {
        return;
    }

    // get SAFEARRAY out of IADsPropertyEntry pointer
    CComVariant Var;
  hr = spPropEntry->get_Values(&Var);
    if (FAILED(hr))
    {
        return;
    }

    long uBound, lBound;
  hr = ::SafeArrayGetUBound(V_ARRAY(&Var), 1, &uBound);
  hr = ::SafeArrayGetLBound(V_ARRAY(&Var), 1, &lBound);

    VARIANT* pNames;
  hr = ::SafeArrayAccessData(V_ARRAY(&Var), (void **)&pNames);
  if (FAILED(hr))
    {
        TRACE(_T("Accessing safearray data failed: %lx.\n"), hr);
        SafeArrayUnaccessData(V_ARRAY(&Var));
        return;
  }

    // now got the array of items, loop through them
  WCHAR szFrendlyName[1024];
  HRESULT hrName;
    
  long nChildClassesCount = uBound - lBound + 1;

  for (long index = lBound; index <= uBound; index++) 
    {
        CComPtr<IADsPropertyValue> spEntry;
        hr = (pNames[index].pdispVal)->QueryInterface (IID_IADsPropertyValue,
                                                     (void **)&spEntry);
        if (SUCCEEDED(hr)) 
        {
            BSTR bsObject = NULL;
            hr = spEntry->get_CaseIgnoreString(&bsObject);
            if (SUCCEEDED(hr))
            {
//        hrName = ::DsGetFriendlyClassName(bsObject, szFrendlyName, 1024);
//        ASSERT(SUCCEEDED(hrName));
                pClassList->AddString(bsObject);
            } // if
            ::SysFreeString(bsObject);
        } // if
    } // for
    
    ::SafeArrayUnaccessData(V_ARRAY(&Var));
}


BOOL CCreateClassPage::OnSetActive()
{   
    GetHolder()->SetWizardButtonsFirst(TRUE);

    return TRUE;
}


LRESULT CCreateClassPage::OnWizardNext()
{
    CListBox* pClassList = (CListBox*)GetDlgItem(IDC_CLASS_LIST);

    CCreatePageHolder* pHolder = dynamic_cast<CCreatePageHolder*>(GetHolder());
    ASSERT(pHolder != NULL);

    CString sClass;
    pClassList->GetText(pClassList->GetCurSel(), sClass);
    
    if (m_sClass != sClass)
    {
        m_sClass = sClass;
        pHolder->AddAttrPage(sClass);
    }

    return 0; //next page
}


/////////////////////////////////////////////////////////////////////////////////////////
// CCreateAttributePage

BEGIN_MESSAGE_MAP(CCreateAttributePage, CPropertyPageBase)
    //{{AFX_MSG_MAP(CADsObjectDialog)
    ON_EN_CHANGE(IDC_ATTR_VALUE_BOX, OnEditChangeValue)
    ON_EN_CHANGE(IDC_NUMBER_VALUE_BOX, OnEditChangeValue)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

CCreateAttributePage::CCreateAttributePage(UINT nID, CADSIAttr* pAttr) : CPropertyPageBase(nID)
{
    m_bInitialized = FALSE;
    m_bNumber = FALSE;
    m_pAttr = pAttr;
}

CCreateAttributePage::~CCreateAttributePage()
{
}

BOOL CCreateAttributePage::OnInitDialog()
{
    CPropertyPageBase::OnInitDialog();

    CEdit* pAttrBox = (CEdit*)GetDlgItem(IDC_ATTR_BOX);

  // disable IME support on numeric edit fields
  ImmAssociateContext(::GetDlgItem(GetSafeHwnd(), IDC_NUMBER_VALUE_BOX), NULL);

    CString sAttr;
    m_pAttr->GetProperty(sAttr);
    pAttrBox->SetWindowText(sAttr);

    SetSyntax(sAttr);
    m_bInitialized = TRUE;
    return TRUE;
}

void CCreateAttributePage::GetValue(CString& sVal)
{ 
    CEdit* pValueBox = (CEdit*)GetDlgItem(IDC_ATTR_VALUE_BOX);
    pValueBox->GetWindowText(sVal);
}

void CCreateAttributePage::SetSyntax(CString sAttr)
{
    CEdit* pValueBox = (CEdit*)GetDlgItem(IDC_ATTR_VALUE_BOX);
    CEdit* pNumberBox = (CEdit*)GetDlgItem(IDC_NUMBER_VALUE_BOX);
    CEdit* pSyntaxBox = (CEdit*)GetDlgItem(IDC_SYNTAX_BOX);

    CCreatePageHolder* pHolder = dynamic_cast<CCreatePageHolder*>(GetHolder());
    ASSERT(pHolder != NULL);
  if (pHolder != NULL)
  {
      CADSIEditContainerNode* pContNode = dynamic_cast<CADSIEditContainerNode*>(pHolder->GetTreeNode());
      ASSERT(pContNode != NULL);

    if (pContNode != NULL)
    {
        CConnectionData* pConnectData = pContNode->GetADsObject()->GetConnectionNode()->GetConnectionData();

        CString sPath, sSyntax;
        CComPtr<IADsProperty> pProp;

        pHolder->GetSchemaPath(sAttr, sPath);

        // bind to object with authentication
        //
        HRESULT hr, hCredResult;
        hr = OpenObjectWithCredentials(
                                                                     pConnectData, 
                                                                     pConnectData->GetCredentialObject()->UseCredentials(),
                                                                     sPath,
                                                                     IID_IADsProperty, 
                                                                     (LPVOID*) &pProp,
                                                                     GetSafeHwnd(),
                                                                     hCredResult
                                                                     );

        if ( FAILED(hr) )
        {
            if (SUCCEEDED(hCredResult))
            {
                ADSIEditErrorMessage(hr);
            }
            return;
        }
        
        BSTR bstr;

        hr = pProp->get_Syntax( &bstr );
        if ( SUCCEEDED(hr) )
        {
            sSyntax = bstr;
        }

        pSyntaxBox->SetWindowText(sSyntax);

        BOOL varType = VariantTypeFromSyntax(sSyntax);
        switch (varType)
        {
            case VT_BSTR :
                pNumberBox->ShowWindow(FALSE);
                pValueBox->ShowWindow(TRUE);
                m_bNumber = FALSE;
                break;
            case VT_I4 :
            case VT_I8 :
                pNumberBox->ShowWindow(TRUE);
                pValueBox->ShowWindow(FALSE);
                m_bNumber = TRUE;
                break;
            default :
                pNumberBox->ShowWindow(FALSE);
                pValueBox->ShowWindow(TRUE);
                m_bNumber = FALSE;
                break;
        }
        pProp->get_MaxRange(&m_lMaxRange);
        pProp->get_MinRange(&m_lMinRange);
        
        SetADsType(sAttr);
    }
  }
}

void CCreateAttributePage::SetADsType(CString sProp)
{
    CString schema, sServer;
    BOOL bResult = FALSE;

    CConnectionData* pConnectData;
    CADSIEditContainerNode* pContNode = dynamic_cast<CADSIEditContainerNode*>(GetHolder()->GetTreeNode());
    if (pContNode == NULL)
    {
        CADSIEditLeafNode* pLeafNode = dynamic_cast<CADSIEditLeafNode*>(GetHolder()->GetTreeNode());
        ASSERT(pLeafNode != NULL);
        bResult = pLeafNode->BuildSchemaPath(schema);

        pConnectData = pLeafNode->GetADsObject()->GetConnectionNode()->GetConnectionData();
    }
    else
    {
        bResult = pContNode->BuildSchemaPath(schema);
        pConnectData = pContNode->GetADsObject()->GetConnectionNode()->GetConnectionData();
    }

    if (!bResult)
    {
        return;
    }

    CADSIQueryObject schemaSearch;

    // Initialize search object with path, username and password
    //
    HRESULT hr = schemaSearch.Init(schema, pConnectData->GetCredentialObject());
    if (FAILED(hr))
    {
        ADSIEditErrorMessage(hr);
        return;
    }

    int cCols = 2;
  LPWSTR pszAttributes[] = {L"attributeSyntax", L"isSingleValued"};
    ADS_SEARCH_COLUMN ColumnData;
  hr = schemaSearch.SetSearchPrefs(ADS_SCOPE_ONELEVEL);
    if (FAILED(hr))
    {
        ADSIEditErrorMessage(hr);
        return;
    }

  CString csFilter = _T("(&(objectClass=attributeSchema)(lDAPDisplayName=") +
                                                sProp + _T("))");
  schemaSearch.SetFilterString((LPWSTR)(LPCWSTR)csFilter);
  schemaSearch.SetAttributeList (pszAttributes, cCols);
  hr = schemaSearch.DoQuery ();
  if (SUCCEEDED(hr)) 
    {
    hr = schemaSearch.GetNextRow();

    if (SUCCEEDED(hr)) 
        {

      hr = schemaSearch.GetColumn(pszAttributes[0],
                                      &ColumnData);
            if (SUCCEEDED(hr))
            {
                TRACE(_T("\t\tattributeSyntax: %s\n"), 
                     ColumnData.pADsValues->CaseIgnoreString);

            CString szSyntax;
                ADSTYPE dwType;
                dwType = GetADsTypeFromString(ColumnData.pADsValues->CaseIgnoreString, szSyntax);
                m_pAttr->SetADsType(dwType);
            m_pAttr->SetSyntax(szSyntax);
            }
            else
            {
                ADSIEditErrorMessage(hr);
            }

            hr = schemaSearch.GetColumn(pszAttributes[1], &ColumnData);
            if (SUCCEEDED(hr))
            {
                TRACE(_T("\t\tisSingleValued: %d\n"), 
                     ColumnData.pADsValues->Boolean);
                m_pAttr->SetMultivalued(!ColumnData.pADsValues->Boolean);
            }
            else
            {
                ADSIEditErrorMessage(hr);
            }
        }
    }
}


void CCreateAttributePage::OnEditChangeValue()
{
    CEdit* pValueBox = (CEdit*)GetDlgItem(IDC_ATTR_VALUE_BOX);
    CEdit* pNumberBox = (CEdit*)GetDlgItem(IDC_NUMBER_VALUE_BOX);

    CString sValue, sAttr;
    CEdit* pBox;

    if (m_bNumber)
    {
        pBox = pNumberBox;
    }
    else
    {
        pBox = pValueBox;
    }
    
    pBox->GetWindowText(sValue);
    
    CCreatePageHolder* pHolder = dynamic_cast<CCreatePageHolder*>(GetHolder());
    ASSERT(pHolder != NULL);
    m_pAttr->GetProperty(sAttr);

    CString sNamingAttr;
    pHolder->GetNamingAttribute(sNamingAttr);

    if (sAttr == sNamingAttr)
    {
        pHolder->SetName(sValue);
    }
    
    if (sValue == _T(""))
    {
        GetHolder()->SetWizardButtons(PSWIZB_BACK);
    }
    else
    {
        GetHolder()->SetWizardButtons(PSWIZB_BACK|PSWIZB_NEXT);
    }

}


BOOL CCreateAttributePage::OnSetActive()
{
    if (m_bInitialized)
    {
        OnEditChangeValue();
    }
    else
    {
        GetHolder()->SetWizardButtonsMiddle(FALSE);
    }
    
    return TRUE;
}

LRESULT CCreateAttributePage::OnWizardNext()
{
    CEdit* pValueBox = (CEdit*)GetDlgItem(IDC_ATTR_VALUE_BOX);
    CEdit* pNumberBox = (CEdit*)GetDlgItem(IDC_NUMBER_VALUE_BOX);

    m_pAttr->SetDirty(TRUE);

    CString sValue;
    CEdit* pBox;

    if (m_bNumber)
    {
        pBox = pNumberBox;
    }
    else
    {
        pBox = pValueBox;
    }
    
    pBox->GetWindowText(sValue);

    m_sAttrValue.RemoveAll();
    m_sAttrValue.AddTail(sValue);
    HRESULT hr = m_pAttr->SetValues(m_sAttrValue);
    if (FAILED(hr))
    {
        ADSIEditMessageBox(IDS_MSG_INCORRECT_FORMAT, MB_OK);
        return -1; //don't advance pages
    }
    return 0; //next page
}

/////////////////////////////////////////////////////////////////////////////////////////
// CCreateFinishPage

BEGIN_MESSAGE_MAP(CCreateFinishPage, CPropertyPageBase)
    //{{AFX_MSG_MAP(CADsObjectDialog)
    ON_BN_CLICKED(IDC_BUTTON_MORE, OnMore)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

CCreateFinishPage::CCreateFinishPage(UINT nID) : CPropertyPageBase(nID)
{
    m_bInitialized = FALSE;
}

CCreateFinishPage::~CCreateFinishPage()
{
}

BOOL CCreateFinishPage::OnInitDialog()
{
    CPropertyPageBase::OnInitDialog();

    GetHolder()->SetWizardButtons(PSWIZB_FINISH);
    m_bInitialized = TRUE;
    return TRUE;
}

void CCreateFinishPage::OnMore()
{
    CCreatePageHolder* pHolder = dynamic_cast<CCreatePageHolder*>(GetHolder());
    ASSERT(pHolder != NULL);
    pHolder->OnMore();
}

BOOL CCreateFinishPage::OnSetActive()
{
    GetHolder()->SetWizardButtons(PSWIZB_FINISH | PSWIZB_BACK);
    return TRUE;
}

BOOL CCreateFinishPage::OnWizardFinish()
{
    CCreatePageHolder* pHolder = dynamic_cast<CCreatePageHolder*>(GetHolder());
    ASSERT(pHolder != NULL);
    return pHolder->OnFinish();
}

////////////////////////////////////////////////////////////////////////////////////////
// CCreatePageHolder

CCreatePageHolder:: CCreatePageHolder(CContainerNode* pContNode, CADSIEditContainerNode* pNode, 
        CComponentDataObject* pComponentData) : CPropertyPageHolderBase(pContNode, pNode, pComponentData)
{
    ASSERT(pComponentData != NULL);
    ASSERT(pContNode != NULL);
    ASSERT(pContNode == GetContainerNode());
    m_pCurrentNode = pNode;
  m_pComponentData = pComponentData;

    m_bAutoDeletePages = FALSE; // we have the page as embedded member

    m_pClassPage = new CCreateClassPage(pNode);
    AddPageToList((CPropertyPageBase*)m_pClassPage);
}

CCreatePageHolder::~CCreatePageHolder()
{
    m_pageList.RemoveAll();
}

void CCreatePageHolder::AddAttrPage(CString sClass)
{
    RemoveAllPages();

    m_sClass = sClass;
    CStringList sMandList;
    GetMandatoryAttr(sClass, &sMandList);
    CString sAttr;

    if (!m_pCurrentNode->GetNamingAttribute(sClass, &m_sNamingAttr))
    {
        return;
    }

    // Remove attributes from list that do not need a page
    RemovePresetAttr(&sMandList);

    // find the naming attribute and put it first
    POSITION fpos = sMandList.Find(m_sNamingAttr.GetHead());
    if (fpos != NULL)
    {
        sMandList.AddHead(sMandList.GetAt(fpos));
        sMandList.RemoveAt(fpos);
    }
    else
    {
        sMandList.AddHead(m_sNamingAttr.GetHead());
    }

    POSITION pos = sMandList.GetHeadPosition();
    while (pos != NULL)
    {
        CCreateAttributePage* pAttrPage;
        sAttr = sMandList.GetNext(pos);

    // Maintain the list of attributes here so that we can pop up the prop page for more advanced editting
    CADSIAttr* pNewAttr = new CADSIAttr(sAttr);
    m_AttrList.AddTail(pNewAttr);
        pAttrPage = new CCreateAttributePage(IDD_CREATE_EMPTY_PAGE, pNewAttr);
        
    // Add the naming attribute as the first page so that they type the name first
        if (sAttr == m_sNamingAttr.GetHead())
        {
            m_pageList.AddHead(pAttrPage);
        }
        else
        {
            m_pageList.AddTail(pAttrPage);
        }
    }
  // Add the finish page to the end
  CCreateFinishPage* pFinishPage = new CCreateFinishPage(IDD_CREATE_LAST_PAGE);
  m_pageList.AddTail(pFinishPage);

  // Add the pages to the UI
    pos = m_pageList.GetHeadPosition();
    while (pos != NULL)
    {
        CPropertyPageBase* pAttrPage;
        pAttrPage = m_pageList.GetNext(pos);

        AddPageToList(pAttrPage);
        AddPageToSheet(pAttrPage);
    }
}

void CCreatePageHolder::RemovePresetAttr(CStringList* psMandList)
{
    // this is a hack to keep from trying to set properties that are not allowed to be set.
    POSITION fpos = psMandList->Find(_T("nTSecurityDescriptor"));
    if (fpos != NULL)
    {
        psMandList->RemoveAt(fpos);
    }
    fpos = psMandList->Find(_T("instanceType"));
    if (fpos != NULL)
    {
        psMandList->RemoveAt(fpos);
    }
    fpos = psMandList->Find(_T("objectClass"));
    if (fpos != NULL)
    {
        psMandList->RemoveAt(fpos);
    }
    fpos = psMandList->Find(_T("objectCategory"));
    if (fpos != NULL)
    {
        psMandList->RemoveAt(fpos);
    }
    fpos = psMandList->Find(_T("objectSid"));
    if (fpos != NULL)
    {
        psMandList->RemoveAt(fpos);
    }

    fpos = psMandList->Find(_T("objectClassCategory"));
    if (fpos != NULL)
    {
        psMandList->RemoveAt(fpos);
    }
    fpos = psMandList->Find(_T("schemaIDGUID"));
    if (fpos != NULL)
    {
        psMandList->RemoveAt(fpos);
    }
    fpos = psMandList->Find(_T("defaultObjectCategory"));
    if (fpos != NULL)
    {
        psMandList->RemoveAt(fpos);
    }
}

void CCreatePageHolder::GetSchemaPath(CString sClass, CString& schema)
{
    m_pCurrentNode->GetADsObject()->GetConnectionNode()->GetConnectionData()->GetAbstractSchemaPath(schema);
    schema += sClass;
}

void CCreatePageHolder::GetMandatoryAttr(CString sClass, CStringList* sMandList)
{
    CComPtr<IADsClass> pClass;
    CString schema;
    HRESULT hr, hCredResult;

    GetSchemaPath(sClass, schema);

    CADSIEditContainerNode* pContNode = dynamic_cast<CADSIEditContainerNode*>(GetTreeNode());
    CConnectionData* pConnectData = m_pCurrentNode->GetADsObject()->GetConnectionNode()->GetConnectionData();

    hr = OpenObjectWithCredentials(
                                                                 pConnectData, 
                                                                 pConnectData->GetCredentialObject()->UseCredentials(),
                                                                 schema,
                                                                 IID_IADsClass, 
                                                                 (LPVOID*) &pClass,
                                                                 NULL,
                                                                 hCredResult
                                                                 );

    if ( FAILED(hr) )
    {
        if (SUCCEEDED(hCredResult))
        {
            ADSIEditErrorMessage(hr);
        }
        return;
    }

    VARIANT var;
    VariantInit(&var);
    pClass->get_MandatoryProperties(&var);
    VariantToStringList( var, *sMandList );
    VariantClear(&var); 
}

void CCreatePageHolder::RemoveAllPages()
{
    while (!m_pageList.IsEmpty())
    {
        CPropertyPageBase* pPropPage = m_pageList.RemoveTail();
        RemovePageFromSheet(pPropPage);
        RemovePageFromList(pPropPage, FALSE);
        delete pPropPage;
    }
}

BOOL CCreatePageHolder::OnFinish()
{
    CWaitCursor cursor;

    CComPtr<IDirectoryObject> pDirObject;
    HRESULT hr, hCredResult;
    CString sContPath;
    
    m_pCurrentNode->GetADsObject()->GetPath(sContPath);

    CADSIEditContainerNode* pTreeNode = dynamic_cast<CADSIEditContainerNode*>(GetTreeNode());
    ASSERT(pTreeNode != NULL);
    CADSIEditConnectionNode* pConnectNode = pTreeNode->GetADsObject()->GetConnectionNode();
    CConnectionData* pConnectData = pConnectNode->GetConnectionData();

    hr = OpenObjectWithCredentials(
                                   pConnectData, 
                                   pConnectData->GetCredentialObject()->UseCredentials(),
                                   sContPath,
                                   IID_IDirectoryObject, 
                                   (LPVOID*) &pDirObject,
                                   NULL,
                                   hCredResult
                                   );
    if ( FAILED(hr) )
    {
        if (SUCCEEDED(hCredResult))
        {
            ADSIEditErrorMessage(hr);
        }
        return FALSE;
    }

    
    int iCount = m_AttrList.GetDirtyCount();
    ADS_ATTR_INFO* pAttrInfo;
    CComPtr<IDispatch> pDisp;

    do // false loop
    {
        pAttrInfo = new ADS_ATTR_INFO[iCount + 1];  // Add an extra to specify the class type
        if (NULL == pAttrInfo)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        int idx = 0;

        pAttrInfo[idx].pszAttrName = L"objectClass";
        pAttrInfo[idx].dwControlCode = ADS_ATTR_UPDATE;
        pAttrInfo[idx].dwADsType = ADSTYPE_CASE_IGNORE_STRING;

        pAttrInfo[idx].pADsValues = new ADSVALUE;
        if (NULL == pAttrInfo[idx].pADsValues)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        pAttrInfo[idx].pADsValues->dwType = ADSTYPE_CASE_IGNORE_STRING;

        int iLength = m_sClass.GetLength();

        // NOTICE-NTRAID#NTBUG9-562222-2002/03/04-artm  Need to check if mem. allocation succeeded.
        pAttrInfo[idx].pADsValues->CaseIgnoreString = new WCHAR[iLength + 1];
        if (NULL == pAttrInfo[idx].pADsValues->CaseIgnoreString)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        // NOTICE-2002/03/04-artm  wcscpy() used correctly
        // m_sClass will always be null terminated and has iLength characters
        // destination array has iLength + 1 space
        wcscpy(pAttrInfo[idx].pADsValues->CaseIgnoreString, m_sClass);
        
        pAttrInfo[idx].dwNumValues = 1;
        idx++;

        POSITION pos = m_AttrList.GetHeadPosition();
        while(pos != NULL)
        {
            CADSIAttr* pAttr = m_AttrList.GetNext(pos);
            if (pAttr->IsDirty())
            {
                pAttrInfo[idx] = *(pAttr->GetAttrInfo());
                idx++;
            }
        }

        // make the prefix uppercase
        CString sName(m_sName);
        int indx = sName.Find(L'=');

        if (indx != -1)
        {
            CString sPrefix, sRemaining;
            sPrefix = sName.Left(indx);
            sPrefix.MakeUpper();

            int iLen = sName.GetLength();
            sRemaining = sName.Right(iLen - indx);
            sName = sPrefix + sRemaining;
        }
        m_sName = sName;

        CString sEscapedName;
        hr = EscapePath(sEscapedName, sName);

        if (FAILED(hr))
        {
            break;
        }

        hr = pDirObject->CreateDSObject((LPWSTR)(LPCWSTR)sEscapedName, pAttrInfo, idx, &pDisp);
        if ( FAILED(hr) )
        {
            break;
        }

    }
    while (false);  // end false loop

    // Clean up temporary variables.
    if (pAttrInfo)
    {
        if (pAttrInfo[0].pADsValues)
        {
            if (pAttrInfo[0].pADsValues->CaseIgnoreString)
            {
                delete [] pAttrInfo[0].pADsValues->CaseIgnoreString;
            }
            delete pAttrInfo[0].pADsValues;
        }
        delete [] pAttrInfo;
        pAttrInfo = NULL;
    }

    if (FAILED(hr))
    {
        //  Format error message and pop up a dialog.
        ADSIEditErrorMessage(hr);
        return FALSE;
    }


    // Get the IDirectoryObject of the new node
    //
    CComPtr<IDirectoryObject> pNewDirObject;
    hr = pDisp->QueryInterface(IID_IDirectoryObject, (LPVOID*)&pNewDirObject);
   
    if ( FAILED(hr) )
    {
        //Format Error message and pop up a dialog
        ADSIEditErrorMessage(hr);
        return FALSE;
    }


    ADS_OBJECT_INFO* pInfo;
    hr = pNewDirObject->GetObjectInformation(&pInfo);
    if ( FAILED(hr) )
    { 
        //Format Error message and pop up a dialog
        ADSIEditErrorMessage(hr);
        return FALSE;
    }

    CADsObject* pObject = new CADsObject();
    if (NULL == pObject)
    {
        ADSIEditErrorMessage(E_OUTOFMEMORY);
        return FALSE;
    }

    // Name
    CString sDN;
    pObject->SetName(m_sName);
    GetDN(pInfo->pszObjectDN, sDN);
    pObject->SetDN(sDN);
    pObject->SetPath(pInfo->pszObjectDN);

    // Class
    pObject->SetClass(pInfo->pszClassName);

    //Get the class object so that we can get the properties
    //
    CString sServer, schema;
    pConnectNode->GetConnectionData()->GetAbstractSchemaPath(schema);
    schema += CString(pInfo->pszClassName);

    do // false loop
    {
        // bind to object with authentication
        //
        CComPtr<IADsClass> pClass;
        hr = OpenObjectWithCredentials(
                                       pConnectData, 
                                       pConnectData->GetCredentialObject()->UseCredentials(),
                                       schema,
                                       IID_IADsClass, 
                                       (LPVOID*) &pClass,
                                       NULL,
                                       hCredResult
                                       );
        if ( FAILED(hr) )
        {
            if (SUCCEEDED(hCredResult))
            {
                ADSIEditErrorMessage(hr);
            }
            break;
        }

        pObject->SetComplete(TRUE);

        short    bContainer;
        pClass->get_Container( &bContainer );
        if (bContainer == -1)
        {
            pObject->SetContainer(TRUE);
            CADSIEditContainerNode *pNewContNode = new CADSIEditContainerNode(pObject);
            if (pNewContNode)
            {
                // We don't want to free pObject since it was passed to a constructor.  That
                // object is responsible for deleting that memory.  Therefore, we set our
                // pointer to the memory to NULL so that we don't accidentally clean it
                // up.
                pObject = NULL;
            }
            else
            {
                hr = E_OUTOFMEMORY;
                ADSIEditErrorMessage(hr);
                break;
            }

            pNewContNode->SetDisplayName(m_sName);

            // Since we add pNewContNode to the list here we do not need to free
            // it before exiting function (it is freed when the list is freed).
            pNewContNode->GetADsObject()->SetConnectionNode(pConnectNode);
            VERIFY(pTreeNode->AddChildToListAndUI(pNewContNode, GetComponentData()));
            GetComponentData()->SetDescriptionBarText(pTreeNode);

            // Refresh any other subtrees of connections that contain this node
            //
            CList<CTreeNode*, CTreeNode*> foundNodeList;
            CADSIEditRootData* pRootNode = dynamic_cast<CADSIEditRootData*>(pTreeNode->GetRootContainer());
            if (pRootNode != NULL)
            {
                BOOL bFound = pRootNode->FindNode(sContPath, foundNodeList);
                if (bFound)
                {
                    POSITION posList = foundNodeList.GetHeadPosition();
                    while (posList != NULL && SUCCEEDED(hr))
                    {
                        CADSIEditContainerNode* pFoundContNode = dynamic_cast<CADSIEditContainerNode*>(foundNodeList.GetNext(posList));
                        if (pFoundContNode != NULL && pFoundContNode != pTreeNode && pFoundContNode != pConnectNode)
                        {
                            // Make a copy of the new container node and plug it into the list.
                            CADSIEditContainerNode* pNewFoundNode = new CADSIEditContainerNode(pNewContNode);

                            if (pNewFoundNode)
                            {
                                pNewFoundNode->GetADsObject()->SetConnectionNode(pFoundContNode->GetADsObject()->GetConnectionNode());
                                VERIFY(pFoundContNode->AddChildToListAndUI(pNewFoundNode, GetComponentData()));
                                GetComponentData()->SetDescriptionBarText(pFoundContNode);
                            }
                            else
                            {
                                hr = E_OUTOFMEMORY;
                                ADSIEditErrorMessage(hr);
                            }
                        }
                    }
                    
                    // Since the while() loop is last statement we do not
                    // need to worry about breaking out of false loop if
                    // we've hit an error condition (e.g. out of memory).
                }
            }
        }
        else
        {
            pObject->SetContainer(FALSE);
            CADSIEditLeafNode *pLeafNode = new CADSIEditLeafNode(pObject);
            if (pLeafNode)
            {
                // We don't want to free pObject since it was passed to a constructor.  That
                // object is responsible for deleting that memory.  Therefore, we set our
                // pointer to the memory to NULL so that we don't accidentally clean it
                // up.
                pObject = NULL;
            }
            else
            {
                hr = E_OUTOFMEMORY;
                ADSIEditErrorMessage(hr);
                break;
            }

            // Since we add pNewContNode to the list here we do not need to free
            // it before exiting function (it is freed when the list is freed).
            pLeafNode->SetDisplayName(m_sName);
            pLeafNode->GetADsObject()->SetConnectionNode(pConnectNode);
            VERIFY(pTreeNode->AddChildToListAndUI(pLeafNode, GetComponentData()));
            GetComponentData()->SetDescriptionBarText(pTreeNode);

            // Refresh any other subtrees of connections that contain this node
            //
            CList<CTreeNode*, CTreeNode*> foundNodeList;
            CADSIEditRootData* pRootNode = dynamic_cast<CADSIEditRootData*>(pTreeNode->GetRootContainer());
            if (pRootNode != NULL)
            {
                BOOL bFound = pRootNode->FindNode(sContPath, foundNodeList);
                if (bFound)
                {
                    POSITION posList = foundNodeList.GetHeadPosition();
                    while (posList != NULL && SUCCEEDED(hr))
                    {
                        CADSIEditContainerNode* pFoundContNode = dynamic_cast<CADSIEditContainerNode*>(foundNodeList.GetNext(posList));
                        if (pFoundContNode != NULL && pFoundContNode != pTreeNode && pFoundContNode != pConnectNode)
                        {
                            // Make a copy of the new leaf node and place it in the list.
                            CADSIEditLeafNode* pNewFoundNode = new CADSIEditLeafNode(pLeafNode);

                            if (pNewFoundNode)
                            {
                                pNewFoundNode->GetADsObject()->SetConnectionNode(pFoundContNode->GetADsObject()->GetConnectionNode());
                                VERIFY(pFoundContNode->AddChildToListAndUI(pNewFoundNode, GetComponentData()));
                                GetComponentData()->SetDescriptionBarText(pFoundContNode);
                            }
                            else
                            {
                                hr = E_OUTOFMEMORY;
                                ADSIEditErrorMessage(hr);
                            }
                        }
                    }

                    // Since the while() loop is last statement we do not
                    // need to worry about breaking out of false loop if
                    // we've hit an error condition (e.g. out of memory).
                }
            }
        } // end else

    }
    while (false); // end false loop

    //
    // Clean up memory.
    //

    if (pObject)
    {
        delete pObject;
    }

    FreeADsMem(pInfo);
    return SUCCEEDED(hr);
}

HRESULT CCreatePageHolder::EscapePath(CString& sEscapedName, const CString& sName)
{
    CComPtr<IADsPathname> pIADsPathname;
   HRESULT hr = ::CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                                  IID_IADsPathname, (PVOID *)&(pIADsPathname));
   ASSERT((S_OK == hr) && ((pIADsPathname) != NULL));

    CComBSTR bstrEscaped;
    hr = pIADsPathname->GetEscapedElement(0, //reserved
                                                        (BSTR)(LPCWSTR)sName,
                                                        &bstrEscaped);
    sEscapedName = bstrEscaped;
    return hr;
}


void CCreatePageHolder::GetDN(PWSTR pwszName, CString& sDN)
{
    CComPtr<IADsPathname> pIADsPathname;
   HRESULT hr = ::CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                                  IID_IADsPathname, (PVOID *)&(pIADsPathname));
   ASSERT((S_OK == hr) && ((pIADsPathname) != NULL));

    hr = pIADsPathname->Set(CComBSTR(pwszName), ADS_SETTYPE_FULL);
    if (FAILED(hr)) 
    {
    sDN = L"";
    return;
  }

    // Get the leaf DN
    CComBSTR bstrDN;
    hr = pIADsPathname->Retrieve(ADS_FORMAT_X500_DN, &bstrDN);
    if (FAILED(hr))
    {
        TRACE(_T("Failed to get element. %s"), hr);
        sDN = L"";
    }
    else
    {
        sDN = bstrDN;
    }
}

void CCreatePageHolder::OnMore()
{
  CThemeContextActivator activator;
  CString sServer;
  m_pCurrentNode->GetADsObject()->GetConnectionNode()->GetConnectionData()->GetDomainServer(sServer);
  CCreateWizPropertyPageHolder propPage(m_pCurrentNode, m_pComponentData, m_sClass, sServer, &m_AttrList);

  if (propPage.DoModalDialog(m_sName) == IDOK)
  {
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\createwiz.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       createwiz.h
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////
// createwiz.h

#ifndef _CREATEWIZ_H
#define _CREATEWIZ_H

#include "attredit.h"
#include "editor.h"

enum
{
	first,
	middle,
	last
};

//////////////////////////////////////////////////////////////////////////
// CCreateClassPage

class CCreateClassPage : public CPropertyPageBase
{
public:
	CCreateClassPage(CADSIEditContainerNode* pCurrentNode);
	~CCreateClassPage();

	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();

	virtual BOOL OnInitDialog();

protected:
	void FillList();

	CADSIEditContainerNode* m_pCurrentNode;

	CString m_sClass;

	DECLARE_MESSAGE_MAP()

}; 

////////////////////////////////////////////////////////////////////////
// CCreateAttributePage

class CCreateAttributePage : public CPropertyPageBase
{
public:
	CCreateAttributePage(UINT nID, CADSIAttr* pAttr);
	~CCreateAttributePage();

	virtual BOOL OnSetActive();
	virtual BOOL OnInitDialog();
	virtual LRESULT OnWizardNext();

	virtual void OnEditChangeValue();

	CADSIAttr* GetAttr() { return m_pAttr; }
	virtual void GetValue(CString& sVal);
	void SetSyntax(CString sAttr);
	void SetADsType(CString sProp);


protected:
	CADSIAttr* m_pAttr;

	CStringList m_sAttrValue;
	BOOL m_bInitialized;
	BOOL m_bNumber;
	long m_lMaxRange;
	long m_lMinRange;

	DECLARE_MESSAGE_MAP()
};

////////////////////////////////////////////////////////////////////////
// CCreateFinishPage

class CCreateFinishPage : public CPropertyPageBase
{
public:
	CCreateFinishPage(UINT nID);
	~CCreateFinishPage();

	virtual BOOL OnSetActive();
	virtual BOOL OnInitDialog();
	virtual BOOL OnWizardFinish();
  virtual void OnMore();

protected:
	BOOL m_bInitialized;

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////
// CPropertyPageList

typedef CList<CPropertyPageBase*,CPropertyPageBase*> CPropertyPageListBase;

class CPropertyPageList : public CPropertyPageListBase
{
public:
	void RemoveAll() 
	{	
		while (!IsEmpty()) 
			delete RemoveTail();	
	}

};


////////////////////////////////////////////////////////////////////////
// CCreatePageHolder

class CCreatePageHolder : public CPropertyPageHolderBase
{
public:
	CCreatePageHolder(CContainerNode* pContNode, CADSIEditContainerNode* pNode, 
		CComponentDataObject* pComponentData);
	~CCreatePageHolder();

	void AddAttrPage(CString sClass);  //Adds the dynamic attribute pages
	void RemoveAllPages();
	void GetMandatoryAttr(CString sClass, CStringList* sMandList);
	void RemovePresetAttr(CStringList* sMandList);
	void SetName(CString sName) { m_sName = m_sNamingAttr.GetHead() + _T("=") + sName; }
	void GetNamingAttribute(CString& sNamingAttr) { sNamingAttr = m_sNamingAttr.GetHead(); }
	void GetSchemaPath(CString sClass, CString& schema);
	HRESULT EscapePath(CString& sEscapedName, const CString& sName);
  void GetDN(PWSTR pwszName, CString& sDN);
  CAttrList* GetAttrList() { return &m_AttrList; }

	BOOL OnFinish();
  void OnMore();

protected:
	CPropertyPageList m_pageList;
	CCreateClassPage* m_pClassPage;
	CString m_sClass;
	CString m_sName;
	CStringList m_sNamingAttr;
  CAttrList m_AttrList;

	CADSIEditContainerNode* m_pCurrentNode;
  CComponentDataObject* m_pComponentData;
};

#endif _CREATEWIZ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\credobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2002
//
//  File:       credobj.cpp
//
//  History:    2002/03/29  artm        Separated from editor.cpp.
//                      Reimplemented password storage to use data 
//                      protection API.
// 
//--------------------------------------------------------------------------

#include "pch.h"
#include "credobj.h"
#include <strsafe.h>


CCredentialObject::CCredentialObject(void)
    : m_sUsername(_T("")), 
    m_password(),
    m_bUseCredentials(FALSE)
{

}


CCredentialObject::CCredentialObject(const CCredentialObject* pCredObject)
    : m_sUsername(_T("")),
    m_password(),
    m_bUseCredentials(FALSE)
{
    if(NULL != pCredObject)
    {
        m_sUsername = pCredObject->m_sUsername;
        m_password = pCredObject->m_password;
        m_bUseCredentials = pCredObject->m_bUseCredentials;

        // This should never happen, but doesn't hurt to be
        // paranoid.
        ASSERT(m_password.GetLength() <= MAX_PASSWORD_LENGTH);
    }
}


CCredentialObject::~CCredentialObject(void)
{

}


//
// CCredentialObject::SetPasswordFromHwnd:
//
// Reads the text from hWnd and sets the password for this
// credential object.  If the password is longer than
// MAX_PASSWORD_LENGTH characters the function returns
// ERROR_INVALID_PARAMETER.
//
// History:
//  2002/04/01  artm    Changed implementation to not use RtlRunDecodeUnicodeString().
//                  Instead, uses data protection API.
//
HRESULT CCredentialObject::SetPasswordFromHwnd(HWND parentDialog, int itemResID)
{
    HRESULT err = S_OK;
    EncryptedString newPwd;

    // Read the new password from the dialog window.
    err = GetEncryptedDlgItemText(
        parentDialog, 
        itemResID, 
        newPwd);

    if (SUCCEEDED(err))
    {
        if (newPwd.GetLength() <= MAX_PASSWORD_LENGTH)
        {
            m_password = newPwd;
        }
        else
        {
            err = ERROR_INVALID_PARAMETER;
        }
    }

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\credui.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       credui.cpp
//
//--------------------------------------------------------------------------

//////////////////////////////////////////////////////////
// credui.cpp
#include "pch.h"
#include <SnapBase.h>

#include "resource.h"
#include "editor.h"
#include "credui.h"

#ifdef DEBUG_ALLOCATOR
    #ifdef _DEBUG
    #define new DEBUG_NEW
    #undef THIS_FILE
    static char THIS_FILE[] = __FILE__;
    #endif
#endif

BEGIN_MESSAGE_MAP(CCredentialDialog, CDialog)
END_MESSAGE_MAP()

CCredentialDialog::CCredentialDialog(CCredentialObject* pCredObject, 
                                                                         LPCWSTR lpszConnectName,
                                                                         CWnd* pCWnd)
                                                                        : CDialog(IDD_CREDENTIAL_DIALOG, pCWnd)
{
    m_sConnectName = lpszConnectName;
    m_pCredObject = pCredObject;
}


CCredentialDialog::~CCredentialDialog()
{
}

BOOL CCredentialDialog::OnInitDialog()
{
    CDialog::OnInitDialog();

    CEdit* pUserBox = (CEdit*) GetDlgItem(IDC_USERNAME);
    CEdit* pPassBox = (CEdit*) GetDlgItem(IDC_PASSWORD);
    CStatic* pConnectStatic = (CStatic*) GetDlgItem(IDC_CONNECTION_STATIC);

    CString sUsername;
    m_pCredObject->GetUsername(sUsername);
    pUserBox->SetWindowText(sUsername);

    CString sStatic;
    pConnectStatic->GetWindowText(sStatic);
    sStatic += m_sConnectName + _T("\":");
    pConnectStatic->SetWindowText(sStatic);

    pPassBox->SetLimitText(MAX_PASSWORD_LENGTH);
    return TRUE;
}

void CCredentialDialog::OnOK()
{
    CEdit* pUserBox = (CEdit*) GetDlgItem(IDC_USERNAME);

    CString sUsername;
    pUserBox->GetWindowText(sUsername);

    m_pCredObject->SetUsername(sUsername);

    // There is nothing we can do if this fails without rewriting the 
    // signature, so assume that it succeeds.
    m_pCredObject->SetPasswordFromHwnd(
        GetSafeHwnd(),
        IDC_PASSWORD);

    CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\credobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2002
//
//  File:       credobj.h
//
//  History:    2002/03/29  artm        Separated from editor.h.
// 
//--------------------------------------------------------------------------


////////////////////////////////////////////////////////////////////////////////
// CCredentialObject
//
// Class manages the storing of a user name and password (latter stored using
// data protection API).  It also stores a flag marking whether or not to
// use credentials.

#ifndef _CREDENTIALOBJECT_
#define _CREDENTIALOBJECT_

#ifndef STRSAFE_NO_DEPRECATE
#define STRSAFE_NO_DEPRECATE
#endif

#ifndef _DDX_ENCRYPTED
#define _DDX_ENCRYPTED
#endif

#ifndef ENCRYPT_WITH_CRYPTPROTECTDATA
#define ENCRYPT_WITH_CRYPTPROTECTDATA
#endif

#include "common.h"
#include "EncryptedString.hpp"

class CCredentialObject
{
public :
    CCredentialObject(void); 
    CCredentialObject(const CCredentialObject* pCredObject);
    ~CCredentialObject(void); 

    void GetUsername(CString& sUsername) const { sUsername = m_sUsername; }
    void SetUsername(LPCWSTR lpszUsername) { m_sUsername = lpszUsername; }

    const EncryptedString& GetPassword(void) const
    {
        return m_password;
    }

    HRESULT SetPasswordFromHwnd(HWND parentDialog, int itemResID);

    BOOL UseCredentials() const { return m_bUseCredentials; }
    void SetUseCredentials(const BOOL bUseCred) { m_bUseCredentials = bUseCred; }

private :
    CString m_sUsername;
    EncryptedString m_password;
    BOOL m_bUseCredentials;

    // Disallow these to prevent accidental copying.
    const CCredentialObject& operator=(const CCredentialObject& rhs);
    CCredentialObject(const CCredentialObject& rhs);
};


#endif //_CREDENTIALOBJECT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\credui.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       credui.h
//
//--------------------------------------------------------------------------

///////////////////////////////////////////
// credui.h
#ifndef _CREDUI_H
#define _CREDUI_H

#include "editor.h"

class CCredentialDialog : public CDialog
{
public :
	CCredentialDialog::CCredentialDialog(CCredentialObject* pCredObject,
																			 LPCWSTR lpszConnectName,
																			 CWnd* pCWnd);
	~CCredentialDialog();

	virtual BOOL OnInitDialog();
	virtual void OnOK();

private :
	CCredentialObject* m_pCredObject;
	CString m_sConnectName;

	DECLARE_MESSAGE_MAP()
};

#endif //_CREDUI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\editimpl.h ===
#ifndef __ATTRIBUTEEDITORIMPL_H
#define __ATTRIBUTEEDITORIMPL_H

#include "editui.h"

class /*ATL_NO_VTABLE*/ CAttributeEditor : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IDsAttributeEditor,
  public CComCoClass<CAttributeEditor, &CLSID_DsAttributeEditor>
{
public:
   CAttributeEditor() : m_pHolder(0)
	{
    m_szClass = _T("");
    m_pEditor = NULL;
	}

 	~CAttributeEditor()
	{
    if (m_pEditor != NULL)
    {
      delete m_pEditor;
    }

    if (m_BindingInfo.lpszProviderServer != NULL)
    {
      delete[] m_BindingInfo.lpszProviderServer;
    }
	}
  DECLARE_REGISTRY_CLSID();

BEGIN_COM_MAP(CAttributeEditor)
	COM_INTERFACE_ENTRY(IDsAttributeEditor)
END_COM_MAP()


public:

  //
  // IDsAttributeEditor interface
  //
  STDMETHOD(Initialize)(
     IADs* pADsObj, 
     LPDS_ATTREDITOR_BINDINGINFO pBindingInfo,
     CADSIEditPropertyPageHolder* pHolder);
  STDMETHOD(CreateModal)();
  STDMETHOD(GetPage)(HPROPSHEETPAGE* phPropSheetPage);

private:
  CComPtr<IADs> m_spIADs;
  CString m_szClass;

  CAttributeEditorPropertyPage* m_pEditor;
  DS_ATTREDITOR_BINDINGINFO m_BindingInfo;
  CADSIEditPropertyPageHolder* m_pHolder;
};


#endif  //__ATTRIBUTEEDITORIMPL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\editimpl.cpp ===
#include "pch.h"
#include "common.h"
#include <snapbase.h>
#include "editimpl.h"

HRESULT CAttributeEditor::Initialize(
   IADs* pADsObj, 
   LPDS_ATTREDITOR_BINDINGINFO pBindingInfo,
   CADSIEditPropertyPageHolder* pHolder)
{
  TRACE(_T("CAttributeEditor::Initialize()\n"));
  m_spIADs = pADsObj;

  // NTRAID#NTBUG9-562277-2002/03/04-artm  There should be release code backing up ASSERT's.
  ASSERT(pBindingInfo != NULL);
  ASSERT(pBindingInfo->lpfnBind != NULL);
  ASSERT(pBindingInfo->lpszProviderServer != NULL);

  m_BindingInfo.lParam   = pBindingInfo->lParam;
  m_BindingInfo.lpfnBind = pBindingInfo->lpfnBind;
  m_BindingInfo.dwFlags  = pBindingInfo->dwFlags;

  // NTRAID#NTBUG9-562468-2002/03/04-artm  Can the info in binding struct be trusted?
  // In this case, are we guaranteed that lpszProviderServer is null terminated?
  int nCount = wcslen(pBindingInfo->lpszProviderServer);
  // NTRAID#NTBUG9-562222-2002/03/04-artm  Need to check that mem. allocation succeeded.
  m_BindingInfo.lpszProviderServer = new WCHAR[nCount + 1];
  // NOTICE-2002/03/04-artm  wcscpy() fine as long as mem. allocation succeeded
  wcscpy(m_BindingInfo.lpszProviderServer, pBindingInfo->lpszProviderServer);

  m_BindingInfo.dwSize = sizeof(DS_ATTREDITOR_BINDINGINFO);

  m_pHolder = pHolder;
  ASSERT(m_pHolder);

  //
  // Retrieve the class name
  //
  CComBSTR bstrClass;
  HRESULT hr = S_OK;
  hr = m_spIADs->get_Class(&bstrClass);
  if (SUCCEEDED(hr))
  {
    m_szClass = bstrClass;
  }
  return hr;
}

HRESULT CAttributeEditor::CreateModal()
{
  TRACE(_T("CAttributeEditor::CreateModal()\n"));

  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  CThemeContextActivator activator;

  //
  // Build the abstract schema path
  //
  CString szSchemaClass(m_BindingInfo.lpszProviderServer);
  szSchemaClass = szSchemaClass + _T("schema/") + m_szClass;

  //
  // Bind to the class object in the abstract schema
  //
  HRESULT hr = S_OK;
  CComPtr<IADsClass> spIADsClass;

  if (m_BindingInfo.dwFlags & DSATTR_EDITOR_ROOTDSE)
  {
    //
    // Trying to bind to the schema class of the RootDSE will fail.
    // Just pass NULL instead
    //
    spIADsClass = NULL;
  }
  else
  {
    hr = m_BindingInfo.lpfnBind((LPWSTR)(LPCWSTR)szSchemaClass,
                                  ADS_SECURE_AUTHENTICATION,
                                  IID_IADsClass, 
                                  (PVOID*)&spIADsClass,
                                  m_BindingInfo.lParam);
  }

  if (SUCCEEDED(hr))
  {
    //
    // Invoke the editor
    //
    m_pEditor = new CAttributeEditorPropertyPage(m_spIADs, spIADsClass, &m_BindingInfo, m_pHolder);
    if (m_pEditor)
    {
	    CPropertySheet*	m_pDummySheet = new CPropertySheet();
      if (m_pDummySheet)
      {
	      m_pDummySheet->m_psh.dwFlags |= PSH_NOAPPLYNOW;

        CString szCaption;
        VERIFY(szCaption.LoadString(IDS_ATTREDITOR_CAPTION));
	      m_pDummySheet->m_psh.pszCaption = szCaption;
	      
        m_pDummySheet->AddPage(m_pEditor);
        hr = (m_pDummySheet->DoModal() == IDOK) ? S_OK : S_FALSE;
      }
      delete m_pEditor;
      m_pEditor = NULL;
    }
  }

  return hr;
}

HRESULT CAttributeEditor::GetPage(HPROPSHEETPAGE* phPropSheetPage)
{
  TRACE(_T("CAttributeEditor::GetPage()\n"));

  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  //
  // Build the abstract schema path
  //
  CString szSchemaClass(m_BindingInfo.lpszProviderServer);
  szSchemaClass = szSchemaClass + _T("schema/") + m_szClass;

  //
  // Bind to the class object in the abstract schema
  //
  HRESULT hr = S_OK;
  CComPtr<IADsClass> spIADsClass;

  if (m_BindingInfo.dwFlags & DSATTR_EDITOR_ROOTDSE)
  {
    //
    // Trying to bind to the schema class of the RootDSE will fail.
    // Just pass NULL instead
    //
    spIADsClass = NULL;
  }
  else
  {

    hr = m_BindingInfo.lpfnBind((LPWSTR)(LPCWSTR)szSchemaClass,
                                  ADS_SECURE_AUTHENTICATION,
                                  IID_IADsClass, 
                                  (PVOID*)&spIADsClass,
                                  m_BindingInfo.lParam);
  }
  if (SUCCEEDED(hr))
  {
    //
    // Invoke the editor
    //
    m_pEditor = new CAttributeEditorPropertyPage(m_spIADs, spIADsClass, &m_BindingInfo, m_pHolder);
    *phPropSheetPage = MyCreatePropertySheetPage(&(m_pEditor->m_psp));
    if (*phPropSheetPage == NULL)
    {
      hr = E_FAIL;
    }
  }
  else
  {
     ADSIEditErrorMessage(hr);
  }
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\editor.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       editor.cpp
//
//--------------------------------------------------------------------------



#include "pch.h"

#include <shlobj.h> // needed for dsclient.h
#include <dsclient.h>

#include <SnapBase.h>

#include "resource.h"
#include "adsiedit.h"
#include "editor.h"
#include "editorui.h"
#include "snapdata.h"
#include "common.h"
#include "connection.h"
#include "createwiz.h"
#include "query.h"
#include "querynode.h"
#include "queryui.h"
#include "renameui.h"

#ifdef DEBUG_ALLOCATOR
    #ifdef _DEBUG
    #define new DEBUG_NEW
    #undef THIS_FILE
    static char THIS_FILE[] = __FILE__;
    #endif
#endif


//////////////////////////////////////////////////////////////////////////

LPCWSTR g_lpszGC = L"GC://";
LPCWSTR g_lpszLDAP = L"LDAP://";
LPCWSTR g_lpszRootDSE = L"RootDSE";



//////////////////////////////////////////////////////////////////////////

CADsObject::CADsObject()
{
    m_bContainer = FALSE;
    m_bIntermediate = FALSE;
    m_pConnectionNode = NULL;
    m_sName = _T("");
    m_sDN = _T("");
    m_sPath = _T("");
    m_sClass = _T("");
    m_bComplete = FALSE;

}

CADsObject::CADsObject(CADSIEditConnectionNode* pConnectNode)
{
    m_bContainer = FALSE;
    m_bIntermediate = FALSE;
    m_pConnectionNode = pConnectNode;
    m_bComplete = FALSE;
}

CADsObject::CADsObject(CADsObject* pADsObject)
{
    m_sName = pADsObject->m_sName;
    m_sDN = pADsObject->m_sDN;
    m_sPath = pADsObject->m_sPath;
    m_sClass = pADsObject->m_sClass;
    m_bContainer = pADsObject->m_bContainer;
    m_bIntermediate = pADsObject->m_bIntermediate;
    m_pConnectionNode = pADsObject->m_pConnectionNode;
    m_bComplete = pADsObject->m_bComplete;
}

void CADsObject::SetName(LPCWSTR lpszName)
{
    CString sPrefix, sRemaining, sTemp;
    sTemp = lpszName;
    int idx = sTemp.Find(L'=');

    if (idx != -1)
    {
        sPrefix = sTemp.Left(idx);
        sPrefix.MakeUpper();

        int iCount = sTemp.GetLength();
        sRemaining = sTemp.Right(iCount - idx);
        sTemp = sPrefix + sRemaining;
    }

    m_sName = sTemp;
}


/////////////////////////////////////////////////////////////////////////
//  CConnectionData
//
CConnectionData::CConnectionData()
{ 
    ConstructorHelper();
}

CConnectionData::CConnectionData(CADSIEditConnectionNode* pConnectNode) : CADsObject(pConnectNode)
{
    ConstructorHelper();
}

void CConnectionData::ConstructorHelper()
{
    m_pFilterObject = new CADSIFilterObject();
    m_pCredentialsObject = new CCredentialObject();

    m_sBasePath = _T("");
    m_sDomainServer = _T("");
    m_sPort = _T("");
    m_sDistinguishedName = _T("");
    m_sNamingContext = _T("Domain");
    m_sLDAP = g_lpszLDAP;

    m_sSchemaPath = _T("");
    m_sAbstractSchemaPath = _T("");
    m_bRootDSE = FALSE;
    m_bUserDefinedServer = FALSE;
    m_pDirObject = NULL;
    m_nMaxObjectCount = ADSIEDIT_QUERY_OBJ_COUNT_DEFAULT;
}

CConnectionData::CConnectionData(CConnectionData* pConnectData) : CADsObject(pConnectData)
{
    // Path data
    //
    m_sBasePath = pConnectData->m_sBasePath;
    m_sDomainServer = pConnectData->m_sDomainServer;
    m_sPort = pConnectData->m_sPort;
    m_sDistinguishedName = pConnectData->m_sDistinguishedName;
    m_sNamingContext = pConnectData->m_sNamingContext;
    m_sLDAP = pConnectData->m_sLDAP;
    m_sSchemaPath = pConnectData->m_sSchemaPath;
    m_sAbstractSchemaPath = pConnectData->m_sAbstractSchemaPath;

    // Filter
    //
    m_pFilterObject = new CADSIFilterObject(pConnectData->m_pFilterObject);

    // Credentials
    //
    m_pCredentialsObject = new CCredentialObject(pConnectData->m_pCredentialsObject);

    m_bRootDSE = pConnectData->m_bRootDSE;
    m_bUserDefinedServer = pConnectData->m_bUserDefinedServer;
    m_pDirObject = NULL;

    m_nMaxObjectCount = pConnectData->m_nMaxObjectCount;
}

CConnectionData::~CConnectionData()
{
    if (m_pDirObject != NULL)
    {
        m_pDirObject->Release();
    }
    delete m_pCredentialsObject;
    delete m_pFilterObject;
}

void CConnectionData::Save(IStream* pStm)
{
    SaveStringToStream(pStm, m_sBasePath);

    if (m_bUserDefinedServer)
    {
        SaveStringToStream(pStm, m_sDomainServer);
    }
    else
    {
        SaveStringToStream(pStm, _T(""));
    }
    SaveStringToStream(pStm, m_sPort);
    SaveStringToStream(pStm, m_sDistinguishedName);
    SaveStringToStream(pStm, m_sNamingContext);
    SaveStringToStream(pStm, m_sLDAP);

    CString sName;
    GetName(sName);
    SaveStringToStream(pStm, sName);

    if (m_bUserDefinedServer)
    {
        CString sPath;
        GetPath(sPath);
        SaveStringToStream(pStm, sPath);
    }
    else
    {
        SaveStringToStream(pStm, _T(""));
    }

    CString sClass;
    GetClass(sClass);
    SaveStringToStream(pStm, sClass);

    ULONG cbWrite;
    BOOL bUseCredentials = m_pCredentialsObject->UseCredentials();
    VERIFY(SUCCEEDED(pStm->Write((void*)&bUseCredentials, sizeof(UINT),&cbWrite)));
    ASSERT(cbWrite == sizeof(UINT));

    VERIFY(SUCCEEDED(pStm->Write((void*)&m_bRootDSE, sizeof(UINT),&cbWrite)));
    ASSERT(cbWrite == sizeof(UINT));

    GetFilter()->Save(pStm);

    BOOL bContainer = GetContainer();
    VERIFY(SUCCEEDED(pStm->Write((void*)&bContainer, sizeof(UINT),&cbWrite)));
    ASSERT(cbWrite == sizeof(UINT));

    ULONG nMaxNum = GetMaxObjectCount();
    VERIFY(SUCCEEDED(pStm->Write((void*)&nMaxNum, sizeof(ULONG),&cbWrite)));
    ASSERT(cbWrite == sizeof(ULONG));
}

CConnectionData* CConnectionData::Load(IStream* pStm)
{
    // FUTURE-2002/03/04-artm  Variable szBuffer does not appear to be used.
    WCHAR szBuffer[256]; // REVIEW_MARCOC: hardcoded
    ULONG nLen; // WCHAR counting NULL
    ULONG cbRead;

    CConnectionData* pConnectData = new CConnectionData();

    LoadStringFromStream(pStm, pConnectData->m_sBasePath);

    LoadStringFromStream(pStm, pConnectData->m_sDomainServer);

    LoadStringFromStream(pStm, pConnectData->m_sPort);

    LoadStringFromStream(pStm, pConnectData->m_sDistinguishedName);

    LoadStringFromStream(pStm, pConnectData->m_sNamingContext);

    LoadStringFromStream(pStm, pConnectData->m_sLDAP);

    CString sString;
  CString szConnectionName;
    LoadStringFromStream(pStm, szConnectionName);
    pConnectData->SetName(szConnectionName);

    LoadStringFromStream(pStm, sString);
    pConnectData->SetPath(sString);

    LoadStringFromStream(pStm, sString);
    pConnectData->SetClass(sString);

    VERIFY(SUCCEEDED(pStm->Read((void*)&nLen,sizeof(UINT), &cbRead)));
    ASSERT(cbRead == sizeof(UINT));
    pConnectData->GetCredentialObject()->SetUseCredentials(nLen);

    VERIFY(SUCCEEDED(pStm->Read((void*)&nLen,sizeof(UINT), &cbRead)));
    ASSERT(cbRead == sizeof(UINT));
    pConnectData->SetRootDSE(nLen);

    CADSIFilterObject* pFilterObject;
    HRESULT hr = CADSIFilterObject::CreateFilterFromStream(pStm, &pFilterObject);
    if (SUCCEEDED(hr))
    {
        pConnectData->SetFilter(pFilterObject);
    }

    VERIFY(SUCCEEDED(pStm->Read((void*)&nLen,sizeof(UINT), &cbRead)));
    ASSERT(cbRead == sizeof(UINT));
    pConnectData->SetContainer(nLen);

    ULONG nMaxCount;
    VERIFY(SUCCEEDED(pStm->Read((void*)&nMaxCount,sizeof(ULONG), &cbRead)));
    ASSERT(cbRead == sizeof(ULONG));
    pConnectData->SetMaxObjectCount(nMaxCount);

    if (pConnectData->m_sNamingContext != L"")
    {
        hr = LoadBasePathFromContext(pConnectData, pConnectData->m_sNamingContext);
    if (FAILED(hr))
    {
      CString szHrErr;
      GetErrorMessage(hr, szHrErr);

      CString szFormatErr;
      VERIFY(szFormatErr.LoadString(IDS_ERRMSG_FAILED_CONNECTION));

      CString szMessage;
      szMessage.Format(szFormatErr, szConnectionName, szHrErr);

      ADSIEditErrorMessage(szMessage);
      return pConnectData;
    }
    }

    if (pConnectData->m_sDomainServer == L"")
    {
        hr = GetServerNameFromDefault(pConnectData);
    if (FAILED(hr))
    {
      CString szHrErr;
      GetErrorMessage(hr, szHrErr);

      CString szFormatErr;
      VERIFY(szFormatErr.LoadString(IDS_ERRMSG_FAILED_CONNECTION));

      CString szMessage;
      szMessage.Format(szFormatErr, szConnectionName, szHrErr);

      ADSIEditErrorMessage(szMessage);
    }
        pConnectData->BuildPath();
    }

    return pConnectData;
}

void CConnectionData::BuildPath()
{
    // Get data from connection node
    //
    CString sServer, sLDAP, sPort, path;
    GetDomainServer(sServer);
    GetLDAP(sLDAP);
    GetPort(sPort);

    if (sServer == _T(""))
    {
        path = sLDAP + path;
    }
    else
    {
        if (sPort == _T(""))
        {
            path = sServer + _T("/") + path;
        }
        else
        {
            path = sServer + _T(":") + sPort + _T("/") + path;
        }
        path = sLDAP + path;
    }
    path += m_sBasePath;

    if (IsRootDSE())
    {
        path += g_lpszRootDSE;
    }
    SetPath(path);
}

HRESULT CConnectionData::GetServerNameFromDefault(CConnectionData* pConnectData)
{
    CString sSchemaPath, szServerName;
    HRESULT hr = pConnectData->GetSchemaPath(sSchemaPath);
  if (FAILED(hr))
  {
    return hr;
  }

  CComPtr<IADs> spConfig;
    hr = OpenObjectWithCredentials (pConnectData->GetCredentialObject(),
                                              sSchemaPath,
                                              IID_IADs,
                                              (LPVOID*)&spConfig
                                             );
    if (FAILED(hr))
    {
        TRACE(L"Failed ADsOpenObject(%s) on naming context\n", (LPCWSTR)sSchemaPath);
        return hr;
    }
    hr = pConnectData->GetADSIServerName(szServerName, spConfig);
    if (FAILED(hr))
    {
        TRACE(L"Failed GetADSIServerName(%s)\n", (LPCWSTR)szServerName);
        return hr;
    }

    pConnectData->SetDomainServer(szServerName);
    pConnectData->SetUserDefinedServer(FALSE);

  return hr;
}


HRESULT CConnectionData::GetADSIServerName(OUT CString& szServer, IN IUnknown* pUnk)
{
  szServer.Empty();

  CComPtr<IADsObjectOptions> spIADsObjectOptions;
  HRESULT hr = pUnk->QueryInterface(IID_IADsObjectOptions, (void**)&spIADsObjectOptions);
  if (FAILED(hr))
    return hr;

  CComVariant var;
  hr = spIADsObjectOptions->GetOption(ADS_OPTION_SERVERNAME, &var);
  if (FAILED(hr))
    return hr;

  ASSERT(var.vt == VT_BSTR);
  szServer = V_BSTR(&var);
  return hr;
}


HRESULT CConnectionData::LoadBasePathFromContext(CConnectionData* pConnectData, const CString sContext)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CString sContextPath, szSchema, szDomain, szConfig, szRootDSE;

    if ( !szSchema.LoadString(IDS_SCHEMA)   ||
          !szDomain.LoadString(IDS_DOMAIN_NC) ||
          !szConfig.LoadString(IDS_CONFIG_CONTAINER) ||
        !szRootDSE.LoadString(IDS_ROOTDSE))
    {
        ADSIEditMessageBox(IDS_MSG_FAIL_TO_LOAD, MB_OK);
        return S_FALSE;
    }

    if (sContext == szSchema)
    {
        sContextPath = L"schemaNamingContext";
    }
    else if (sContext == szDomain)
    {
        sContextPath = L"defaultNamingContext";
    }
    else if (sContext == szConfig)
    {
        sContextPath = L"configurationNamingContext";
    }
    else        // RootDSE
    {
        return S_FALSE;
    }

    // Get data from connection node
    //
    CString sRootDSE, sServer, sPort, sLDAP;
    pConnectData->GetDomainServer(sServer);
    pConnectData->GetLDAP(sLDAP);
    pConnectData->GetPort(sPort);

    if (sServer != _T(""))
    {
        sRootDSE = sLDAP + sServer;
        if (sPort != _T(""))
        {
            sRootDSE = sRootDSE + _T(":") + sPort + _T("/");
        }
        else
        {
            sRootDSE = sRootDSE + _T("/");
        }
        sRootDSE = sRootDSE + g_lpszRootDSE;
    }
    else
    {
        sRootDSE = sLDAP + g_lpszRootDSE;
    }

    CComPtr<IADs> pADs;
    HRESULT hr, hCredResult;

    hr = OpenObjectWithCredentials(
                                             pConnectData, 
                                             pConnectData->GetCredentialObject()->UseCredentials(),
                                             sRootDSE,
                                             IID_IADs, 
                                             (LPVOID*) &pADs,
                                             NULL,
                                             hCredResult
                                             );

    if ( FAILED(hr) )
    {
        if (SUCCEEDED(hCredResult))
        {
            return hr;
        }
        return hCredResult;
    }
    VARIANT var;
    VariantInit(&var);
    hr = pADs->Get( CComBSTR(sContextPath), &var );

    if ( FAILED(hr) )
    {
        VariantClear(&var);
        return hr;
    }

    BSTR bstrItem = V_BSTR(&var);
    pConnectData->m_sBasePath = bstrItem;
    VariantClear(&var);

  return hr;
}

HRESULT CConnectionData::GetSchemaPath(CString& sSchemaPath)
{
    CString sLDAP, sServer, sPort, sTemp;
    GetLDAP(sLDAP);
    GetDomainServer(sServer);
    GetPort(sPort);

  HRESULT hr = GetItemFromRootDSE(_T("schemaNamingContext"), sSchemaPath, this);
    if (FAILED(hr))
    {
        return hr;
    }
    if (sServer != _T(""))
    {
        sTemp = sLDAP + sServer;
        if (sPort != _T(""))
        {
            sTemp = sTemp + _T(":") + sPort + _T("/");
        }
        else
        {
            sTemp = sTemp + _T("/");
        }
        sSchemaPath = sTemp + sSchemaPath;
    }
    else
    {
        sSchemaPath = sLDAP + sSchemaPath;
    }
    m_sSchemaPath = sSchemaPath;
  return S_OK;
}

void CConnectionData::GetAbstractSchemaPath(CString& sSchemaPath)
{
    if (m_sAbstractSchemaPath == _T(""))
    {
        if (m_sDomainServer != _T(""))
        {
            sSchemaPath = m_sLDAP + m_sDomainServer;
            if (m_sPort != _T(""))
            {
                sSchemaPath = sSchemaPath + _T(":") + m_sPort + _T("/");
            }
            else
            {
                sSchemaPath = sSchemaPath + _T("/");
            }
            sSchemaPath = sSchemaPath + _T("schema") + _T("/");
        }
        else
        {
            sSchemaPath = m_sLDAP + _T("schema") + _T("/");
        }
        m_sAbstractSchemaPath = sSchemaPath;
    }
    else
    {
        sSchemaPath = m_sAbstractSchemaPath;
    }
}

void CConnectionData::GetBaseLDAPPath(CString& sBasePath)
{
    if (m_sDomainServer == _T(""))
    {
        sBasePath = m_sLDAP + sBasePath;
    }
    else
    {
        if (m_sPort == _T(""))
        {
            sBasePath = m_sDomainServer + _T("/") + sBasePath;
        }
        else
        {
            sBasePath = m_sDomainServer + _T(":") + m_sPort + _T("/") + sBasePath;
        }
        sBasePath = m_sLDAP + sBasePath;
    }
}

void CConnectionData::SetIDirectoryInterface(IDirectoryObject* pDirObject)
{
    if (m_pDirObject != NULL)
    {
        m_pDirObject->Release();
        m_pDirObject = NULL;
    }
    if (pDirObject != NULL)
    {
        m_pDirObject = pDirObject;
        m_pDirObject->AddRef();
    }
}

///////////////////////////////////////////////////////////////////////////////
// CADSIFilterObject

CADSIFilterObject::CADSIFilterObject()
{
    m_bInUse = FALSE;
}

CADSIFilterObject::CADSIFilterObject(CADSIFilterObject* pFilterObject)
{
    m_sFilterString = pFilterObject->m_sFilterString;
    m_sUserFilter = pFilterObject->m_sUserFilter;
    CopyStringList(&m_ContainerList, &(pFilterObject->m_ContainerList));
    m_bInUse = pFilterObject->m_bInUse;
}

void CADSIFilterObject::GetFilterString(CString& sFilterString)
{
    if (m_bInUse)
    {
        if (m_ContainerList.GetCount() != 0)
        {
            sFilterString = _T("(|") + m_sUserFilter;
        
            POSITION pos = m_ContainerList.GetHeadPosition();
            while (pos != NULL)
            {
                CString sContainer = m_ContainerList.GetNext(pos);
                sFilterString += _T("(objectCategory=") + sContainer + _T(")");
            }
            sFilterString += _T(")");
        }
        else
        {
            sFilterString = m_sUserFilter;
        }
        m_sFilterString = sFilterString;
    }
    else
    {
        sFilterString = L"(objectClass=*)";
    }
}

void CADSIFilterObject::Save(IStream* pStm)
{
    ULONG cbWrite;
    ULONG nLen;

    BOOL bInUse = InUse();
    VERIFY(SUCCEEDED(pStm->Write((void*)&bInUse, sizeof(UINT),&cbWrite)));
    ASSERT(cbWrite == sizeof(UINT));
    
    if (InUse())
    {
        SaveStringToStream(pStm, m_sUserFilter);
        SaveStringListToStream(pStm, m_ContainerList);
    }
}

HRESULT CADSIFilterObject::CreateFilterFromStream(IStream* pStm,
                                                                                                    CADSIFilterObject** ppFilterObject)
{
    ULONG nLen; // WCHAR counting NULL
    ULONG cbRead;

    *ppFilterObject = new CADSIFilterObject();
    
    VERIFY(SUCCEEDED(pStm->Read((void*)&nLen,sizeof(UINT), &cbRead)));
    ASSERT(cbRead == sizeof(UINT));
    (*ppFilterObject)->SetInUse(nLen);

    if ((*ppFilterObject)->InUse())
    {
        CString sUserFilter;
        LoadStringFromStream(pStm, sUserFilter);
        (*ppFilterObject)->SetUserDefinedFilter(sUserFilter);

        CStringList sContainerFilter;
        LoadStringListFromStream(pStm, sContainerFilter);
        (*ppFilterObject)->SetContainerList(&sContainerFilter);
    }
    return S_OK;
}

    
////////////////////////////////////////////////////////////////////////
// CADSIEditContainerNode
//

// {8690ABBB-CFF7-11d2-8801-00C04F72ED31}
const GUID CADSIEditContainerNode::NodeTypeGUID = 
{ 0x8690abbb, 0xcff7, 0x11d2, { 0x88, 0x1, 0x0, 0xc0, 0x4f, 0x72, 0xed, 0x31 } };


CADSIEditContainerNode::CADSIEditContainerNode(CADsObject* pADsObject)
  : m_pPartitionsColumnSet(NULL) 
{   
    m_pADsObject = pADsObject;
    m_nState = notLoaded; 
  m_szDescriptionText = L"";
}

CADSIEditContainerNode::CADSIEditContainerNode(CADSIEditContainerNode* pContNode)
  : m_pPartitionsColumnSet(NULL) 
{
    m_pADsObject = new CADsObject(pContNode->m_pADsObject);
    m_nState = notLoaded;
    CString sName;
    m_pADsObject->GetName(sName);

    SetDisplayName(sName);
  m_szDescriptionText = L"";
}


HRESULT CADSIEditContainerNode::OnCommand(long nCommandID, 
                                                                                    DATA_OBJECT_TYPES type, 
                                                                                    CComponentDataObject* pComponentData,
                                          CNodeList* pNodeList)
{
  ASSERT(pNodeList->GetCount() == 1); // for now I am not allowing multiple selection for any of these

    switch (nCommandID)
    {
    case IDM_MOVE :
          OnMove(pComponentData);
          break;
      case IDM_NEW_OBJECT :
          OnCreate(pComponentData);
          break;
    case IDM_NEW_CONNECT_FROM_HERE :
      OnConnectFromHere(pComponentData);
      break;
    case IDM_NEW_NC_CONNECT_FROM_HERE :
      OnConnectToNCFromHere(pComponentData);
      break;
    default:
            ASSERT(FALSE); // Unknown command!
            return E_FAIL;
    }
  return S_OK;
}

void CADSIEditContainerNode::OnConnectFromHere(CComponentDataObject* pComponentData)
{
  //
  // Retrieve the path to create the connection at
  //
  CADsObject* pADsObject = GetADsObject();
  CString szDN, szPath, szName;
  pADsObject->GetDN(szDN);
  pADsObject->GetPath(szPath);
  pADsObject->GetName(szName);

  //
  // Create the new connection node
  //
  CConnectionData* pConnectData = pADsObject->GetConnectionNode()->GetConnectionData();
  CADSIEditConnectionNode* pNewConnectNode = new CADSIEditConnectionNode(pConnectData);
  pNewConnectNode->SetDisplayName(GetDisplayName());
  pNewConnectNode->GetConnectionData()->SetBasePath(szDN);
  pNewConnectNode->GetConnectionData()->SetDistinguishedName(szDN);
  pNewConnectNode->GetConnectionData()->SetNamingContext(L"");
  pNewConnectNode->GetConnectionData()->SetDN(szDN);
  pNewConnectNode->GetConnectionData()->SetPath(szPath);
  pNewConnectNode->GetConnectionData()->SetName(szName);

  //
  // Add the new connection node to the root container
  //
  CADSIEditRootData* pRootData = (CADSIEditRootData*)pComponentData->GetRootData();
  BOOL bResult = pRootData->AddChildToListAndUI(pNewConnectNode, pComponentData);
  ASSERT(bResult);

  // 
  //  Select the new connection node
  //
  pComponentData->UpdateResultPaneView(pNewConnectNode);
}

void CADSIEditContainerNode::OnConnectToNCFromHere(CComponentDataObject* pComponentData)
{
  //
  // Retrieve the path to create the connection at
  //
  CADsObject* pADsObject = GetADsObject();
  CString szDN, szPath, szName, szNCName;
  pADsObject->GetDN(szDN);
  pADsObject->GetPath(szPath);
  pADsObject->GetName(szName);
  szNCName = pADsObject->GetNCName();

  ASSERT(!szNCName.IsEmpty());
  if (!szNCName.IsEmpty())
  {
    //
    // Create the new connection node
    //
    HRESULT hr = S_OK;
    CConnectionData* pConnectData = pADsObject->GetConnectionNode()->GetConnectionData();
    CADSIEditConnectionNode* pNewConnectNode = new CADSIEditConnectionNode(pConnectData);
    if (pNewConnectNode)
    {
      pNewConnectNode->SetDisplayName(GetDisplayName());
      pNewConnectNode->GetConnectionData()->SetBasePath(szNCName);
      pNewConnectNode->GetConnectionData()->SetDistinguishedName(szNCName);
      pNewConnectNode->GetConnectionData()->SetNamingContext(L"");
      pNewConnectNode->GetConnectionData()->SetDN(szNCName);
      pNewConnectNode->GetConnectionData()->SetName(szNCName);

      CString szServer, szProvider;
      pConnectData->GetDomainServer(szServer);
      pConnectData->GetLDAP(szProvider);

      do // false loop
      {
        //
        // Crack the path to get the path to the new NC
        //
        CComPtr<IADsPathname> spPathCracker;
        hr = ::CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                                        IID_IADsPathname, (PVOID *)&(spPathCracker));
        if (FAILED(hr))
        {
          ADSIEditErrorMessage(hr);
          break;
        }

        hr = spPathCracker->Set(CComBSTR(szNCName), ADS_SETTYPE_DN);
        if (FAILED(hr))
        {
          ADSIEditErrorMessage(hr);
          break;
        }

        hr = spPathCracker->SetDisplayType(ADS_DISPLAY_FULL);
        if (FAILED(hr))
        {
          ADSIEditErrorMessage(hr);
          break;
        }

        hr = spPathCracker->Set(CComBSTR((PCWSTR)szServer), ADS_SETTYPE_SERVER);
        if (FAILED(hr))
        {
          ADSIEditErrorMessage(hr);
          break;
        }

        hr = spPathCracker->Set(CComBSTR(L"LDAP"), ADS_SETTYPE_PROVIDER);
        if (FAILED(hr))
        {
          ADSIEditErrorMessage(hr);
          break;
        }

        CComBSTR sbstrNewPath;
        hr = spPathCracker->Retrieve(ADS_FORMAT_X500, &sbstrNewPath);
        if (FAILED(hr))
        {
          ADSIEditErrorMessage(hr);
          break;
        }

        pNewConnectNode->GetConnectionData()->SetPath(sbstrNewPath);

        //
        // Add the new connection node to the root container
        //
        CADSIEditRootData* pRootData = (CADSIEditRootData*)pComponentData->GetRootData();
        BOOL bResult = pRootData->AddChildToListAndUI(pNewConnectNode, pComponentData);
        ASSERT(bResult);

        // 
        //  Select the new connection node
        //
        pComponentData->UpdateResultPaneView(pNewConnectNode);
      } while (false);

      if (FAILED(hr))
      {
        delete pNewConnectNode;
        pNewConnectNode = 0;
      }
    } 
  }
}

HRESULT CADSIEditContainerNode::OnRename(CComponentDataObject* pComponentData,
                                         LPWSTR lpszNewName)
{
  HRESULT hr = S_OK;
    BOOL bLocked = IsThreadLocked();
    ASSERT(!bLocked); // cannot do refresh on locked node, the UI should prevent this
    if (bLocked)
        return hr; 
    if (IsSheetLocked())
    {
        if (!CanCloseSheets())
            return S_FALSE;
        pComponentData->GetPropertyPageHolderTable()->DeleteSheetsOfNode(this);
    }
    ASSERT(!IsSheetLocked());

  CString szPath, szOldPath;
  CADsObject* pADsObject = GetADsObject();
  pADsObject->GetPath(szPath);
  szOldPath = szPath;
    CADSIEditConnectionNode* pConnectionNode = pADsObject->GetConnectionNode();
    CConnectionData* pConnectData = pConnectionNode->GetConnectionData();

  CComPtr<IADsPathname> spPathCracker;
  hr = ::CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                          IID_IADsPathname, (PVOID *)&(spPathCracker));
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
    return S_FALSE;
  }

  hr = spPathCracker->Set(CComBSTR(szPath), ADS_SETTYPE_FULL);
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
    return S_FALSE;
  }

  hr = spPathCracker->SetDisplayType(ADS_DISPLAY_FULL);
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
    return S_FALSE;
  }

  CComBSTR bstrOldLeaf;
  hr = spPathCracker->Retrieve(ADS_FORMAT_LEAF, &bstrOldLeaf);
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
    return S_FALSE;
  }

  CString szOldLeaf = bstrOldLeaf;
  CString szPrefix;
  szPrefix = szOldLeaf.Left(szOldLeaf.Find(L'=') + 1);

  hr = spPathCracker->RemoveLeafElement();
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
    return S_FALSE;
  }

  CComBSTR bstrParentPath;
  hr = spPathCracker->Retrieve(ADS_FORMAT_X500, &bstrParentPath);
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
    return S_FALSE;
  }

  CComPtr<IADsContainer> spDestination;
  CString sContPath(bstrParentPath);
    hr = OpenObjectWithCredentials(
                                             pConnectData->GetCredentialObject(), 
                                             bstrParentPath,
                                             IID_IADsContainer, 
                                             (LPVOID*) &spDestination
                                             );
    if (FAILED(hr)) 
    {
        ADSIEditErrorMessage(hr);
        return S_FALSE;
    }

  //
  // Place the prefix in front of the name if it wasn't typed in by
  // the user
  //
  CString szNewLeaf, szNewName = lpszNewName;
  if (szNewName.Find(L'=') == -1)
  {
    szNewLeaf = szPrefix + lpszNewName;
  }
  else
  {
    szNewLeaf = lpszNewName;
  }
  hr = spPathCracker->AddLeafElement(CComBSTR(szNewLeaf));
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
    return S_FALSE;
  }

    CComPtr<IDispatch> spObject;
    hr = spDestination->MoveHere(CComBSTR(szOldPath),
                              CComBSTR(szNewLeaf),
                              &spObject);
  if (FAILED(hr)) 
    {
        ADSIEditErrorMessage(hr);
        return S_FALSE;
    }

    CComPtr<IADs> spIADs;
    hr = spObject->QueryInterface(IID_IADs, (LPVOID*)&spIADs);
    if (FAILED(hr))
    {
        ADSIEditErrorMessage(hr);
        return S_FALSE;
    }

    CComBSTR bstrPath;
    hr = spIADs->get_ADsPath(&bstrPath);
    if (FAILED(hr))
    {
        ADSIEditErrorMessage(hr);
        return S_FALSE;
    }

  CComBSTR bstrDN;
  hr = spPathCracker->Retrieve(ADS_FORMAT_X500_DN, &bstrDN);
    if (FAILED(hr))
    {
        ADSIEditErrorMessage(hr);
        return S_FALSE;
    }

  CComBSTR bstrLeaf;
  hr = spPathCracker->Retrieve(ADS_FORMAT_LEAF, &bstrLeaf);
    if (FAILED(hr))
    {
        ADSIEditErrorMessage(hr);
        return S_FALSE;
    }

    GetADsObject()->SetPath(bstrPath);
    GetADsObject()->SetName(bstrLeaf);
    GetADsObject()->SetDN(bstrDN);

    SetDisplayName(bstrLeaf);

  CNodeList nodeList;
  nodeList.AddTail(this);
  OnRefresh(pComponentData, &nodeList); 
  return hr;
}

void CADSIEditContainerNode::RefreshOverlappedTrees(CString& szPath, CComponentDataObject* pComponentData)
{
  //
  // REVIEW_JEFFJON : need to revisit this.  I am getting different behavior for
  //                  different verbs
  //

  //
    // Refresh any other subtrees of connections that contain this node
    //
    CList<CTreeNode*, CTreeNode*> foundNodeList;
    CADSIEditRootData* pRootNode = dynamic_cast<CADSIEditRootData*>(GetRootContainer());
    if (pRootNode != NULL)
    {
        BOOL bFound = pRootNode->FindNode(szPath, foundNodeList);
        if (bFound)
        {
            POSITION pos = foundNodeList.GetHeadPosition();
            while (pos != NULL)
            {
                CADSIEditContainerNode* pFoundContNode = dynamic_cast<CADSIEditContainerNode*>(foundNodeList.GetNext(pos));
                if (pFoundContNode != NULL)
                {
                    if (pFoundContNode->IsSheetLocked())
                    {
                        if (!pFoundContNode->CanCloseSheets())
                            continue;
                        pComponentData->GetPropertyPageHolderTable()->DeleteSheetsOfNode(pFoundContNode);
                    }
                    ASSERT(!pFoundContNode->IsSheetLocked());

          CNodeList nodeList;
          nodeList.AddTail(pFoundContNode);
                    pFoundContNode->GetContainer()->OnRefresh(pComponentData, &nodeList);
                }
            }
        }
    }
}

void CADSIEditContainerNode::OnCreate(CComponentDataObject* pComponentData)
{
   CThemeContextActivator activator;
    CCreatePageHolder* pHolder = new CCreatePageHolder(GetContainer(), this, pComponentData);
    ASSERT(pHolder != NULL);
  pHolder->SetSheetTitle(IDS_PROP_CONTAINER_TITLE, this);
    pHolder->DoModalWizard();
}

void CADSIEditContainerNode::OnMove(CComponentDataObject* pComponentData)
{
    BOOL bLocked = IsThreadLocked();
    ASSERT(!bLocked); // cannot do refresh on locked node, the UI should prevent this
    if (bLocked)
        return; 
    if (IsSheetLocked())
    {
        if (!CanCloseSheets())
            return;
        pComponentData->GetPropertyPageHolderTable()->DeleteSheetsOfNode(this);
    }
    ASSERT(!IsSheetLocked());

    HRESULT hr = S_OK, hCredResult;
    DWORD result;
    CComPtr<IADsContainer> pDSDestination = NULL;
    CComPtr<IDispatch> pDSObject = NULL;
    CString strDestPath;
    CString strTitle;
    strTitle.LoadString (IDS_MOVE_TITLE);

    DSBROWSEINFO dsbi;
    ::ZeroMemory( &dsbi, sizeof(dsbi) );

    TCHAR szPath[MAX_PATH+1];
    CString str;
    str.LoadString(IDS_MOVE_TARGET);

    
    CADSIEditConnectionNode* pConnectNode = GetADsObject()->GetConnectionNode();
    CCredentialObject* pCredObject = pConnectNode->GetConnectionData()->GetCredentialObject();

    CString strRootPath;
    GetADsObject()->GetConnectionNode()->GetADsObject()->GetPath(strRootPath);

    dsbi.hwndOwner = NULL;
    dsbi.cbStruct = sizeof (DSBROWSEINFO);
    dsbi.pszCaption = (LPWSTR)((LPCWSTR)strTitle); // this is actually the caption
    dsbi.pszTitle = (LPWSTR)((LPCWSTR)str);
    dsbi.pszRoot = strRootPath;
    dsbi.pszPath = szPath;
    dsbi.cchPath = (sizeof(szPath) / sizeof(TCHAR));
    dsbi.dwFlags = DSBI_INCLUDEHIDDEN | DSBI_RETURN_FORMAT;
    dsbi.pfnCallback = NULL;
    dsbi.lParam = 0;
//  dsbi.dwReturnFormat = ADS_FORMAT_X500;

    // Specify credentials
    CString sUserName;
    EncryptedString password;
    // NOTICE-NTRAID#NTBUG9-563071-2002/04/15-artm  Temp. password buffer should not be held on stack.
    // Rewrote to use encrypted string class.  This has advantage of forcing
    // us to zero out the clear text copy (by calling DestroyClearTextCopy()) as well
    // as managing the memory for the password.  See bug description for why it
    // was a _bad_ thing to hold clear text copy on the stack.
    WCHAR* cleartext = NULL;

    if (pCredObject->UseCredentials())
    {
        pCredObject->GetUsername(sUserName);
        password = pCredObject->GetPassword();

        // This should never happen, but we'll check anyways.
        ASSERT(password.GetLength() <= MAX_PASSWORD_LENGTH);

        dsbi.dwFlags |= DSBI_HASCREDENTIALS;
        dsbi.pUserName = sUserName;

        cleartext = password.GetClearTextCopy();

        // Clear text version of password can be NULL if we're out
        // of memory.  Let the user know that bad things are happening.
        if (NULL == cleartext)
        {
            password.DestroyClearTextCopy(cleartext);
            ADSIEditErrorMessage(E_OUTOFMEMORY);
            return;
        }

        dsbi.pPassword = cleartext;
    }
    
    result = DsBrowseForContainer( &dsbi );
 
    // Clean up any clear text copies.
    if (pCredObject->UseCredentials())
    {
        password.DestroyClearTextCopy(cleartext);
        cleartext = NULL;
    }

    if ( result == IDOK ) 
    { // returns -1, 0, IDOK or IDCANCEL
        // get path from BROWSEINFO struct, put in text edit field
        TRACE(_T("returned from DS Browse successfully with:\n %s\n"),
             dsbi.pszPath);
        strDestPath = dsbi.pszPath;

       // See if the destination is the same as the current parent.  If so, do nothing

       CADSIEditContainerNode* pContainer = dynamic_cast<CADSIEditContainerNode*>(GetContainer());
       if (pContainer)
       {
          CString szPath;
          pContainer->GetADsObject()->GetPath(szPath);

          if (szPath == strDestPath)
          {
             // No reason to do anything if the source and the destination are the same
             return;
          }
       }
        CConnectionData* pConnectData = GetADsObject()->GetConnectionNode()->GetConnectionData();

        hr = OpenObjectWithCredentials(
                                                 pConnectData, 
                                                 pConnectData->GetCredentialObject()->UseCredentials(),
                                                 strDestPath,
                                                 IID_IADsContainer, 
                                                 (LPVOID*) &pDSDestination,
                                                 NULL,
                                                 hCredResult
                                                 );
        if (FAILED(hr)) 
        {
            if (SUCCEEDED(hCredResult))
            {
                ADSIEditErrorMessage(hr);
            }
            return;
        }

        CString sCurrentPath;
        GetADsObject()->GetPath(sCurrentPath);
        hr = pDSDestination->MoveHere(CComBSTR(sCurrentPath),
                                 NULL,
                                 &pDSObject);
      if (FAILED(hr)) 
        {
            ADSIEditErrorMessage(hr);
            return;
        }

        DeleteHelper(pComponentData);

//      RefreshOverlappedTrees(sCurrentPath, pComponentData);
//      RefreshOverlappedTrees(strDestPath, pComponentData);

        delete this;
    }
}

BOOL CADSIEditContainerNode::OnSetRenameVerbState(DATA_OBJECT_TYPES type, 
                                                  BOOL* pbHideVerb, 
                                                  CNodeList* pNodeList)
{
  ASSERT(pNodeList->GetCount() == 1);

    if (GetADsObject()->GetConnectionNode()->GetConnectionData()->IsGC())
    {
        *pbHideVerb = TRUE; // always hide the verb
        return FALSE;
    }

    *pbHideVerb = FALSE; // always show the verb
    return TRUE;
}

BOOL CADSIEditContainerNode::OnSetDeleteVerbState(DATA_OBJECT_TYPES type, 
                                                  BOOL* pbHideVerb, 
                                                  CNodeList* pNodeList)
{
    CADsObject* pADsObject = GetADsObject();
    *pbHideVerb = FALSE; // always show the verb

  if (pNodeList->GetCount() > 1) // multiple selection
  {
    return !pADsObject->GetConnectionNode()->GetConnectionData()->IsGC();
  }

  if (pADsObject->IsIntermediateNode() || pADsObject->GetConnectionNode()->GetConnectionData()->IsGC())
    {
        return FALSE;
    }


    if (m_nState == loading)
    {
        return FALSE;
    }

    if (IsThreadLocked())
    {
        return FALSE;
    }
    return TRUE;
}

void CADSIEditContainerNode::OnDeleteMultiple(CComponentDataObject* pComponentData,
                                              CNodeList* pNodeList)
{
    if (ADSIEditMessageBox(IDS_MSG_DELETE_OBJECTS, MB_YESNO | MB_DEFBUTTON2) == IDYES)
    {
    POSITION pos = pNodeList->GetHeadPosition();
    while (pos != NULL)
    {
      //
      // Check all the nodes to be sure that none have property pages up 
      // or their thread is locked
      //
      CTreeNode* pNode = pNodeList->GetNext(pos);
      ASSERT(pNode != NULL);
      
      if (pNode->IsContainer())
      {
        CADSIEditContainerNode* pContNode = dynamic_cast<CADSIEditContainerNode*>(pNode);
        ASSERT(pContNode != NULL);

            BOOL bLocked = pContNode->IsThreadLocked();
            ASSERT(!bLocked); // cannot do refresh on locked node, the UI should prevent this
            if (bLocked)
        {
                return; 
        }
      }

          if (pNode->IsSheetLocked())
          {
              if (!pNode->CanCloseSheets())
        {
                  return;
        }
              pComponentData->GetPropertyPageHolderTable()->DeleteSheetsOfNode(pNode);
          }
          ASSERT(!pNode->IsSheetLocked());
    }

    //
    // REVIEW_JEFFJON : this should really only bring up an error message after all 
    //                  the objects have attempted a delete
    //
    POSITION pos2 = pNodeList->GetHeadPosition();
    while (pos2 != NULL)
    {
      CTreeNode* pNode = pNodeList->GetNext(pos2);
      ASSERT(pNode != NULL);

      CString sName, sClass, sPath;
      if (pNode->IsContainer())
      {
        CADSIEditContainerNode* pContainerNode = dynamic_cast<CADSIEditContainerNode*>(pNode);
        ASSERT(pContainerNode != NULL);

            pContainerNode->GetADsObject()->GetPath(sPath);
        pContainerNode->GetADsObject()->GetName(sName);
            pContainerNode->GetADsObject()->GetClass(sClass);
      }
      else
      {
        CADSIEditLeafNode* pLeafNode = dynamic_cast<CADSIEditLeafNode*>(pNode);
        ASSERT(pLeafNode != NULL);

            pLeafNode->GetADsObject()->GetPath(sPath);
        pLeafNode->GetADsObject()->GetName(sName);
            pLeafNode->GetADsObject()->GetClass(sClass);
      }

          HRESULT hr = DeleteChild(sClass, sPath);

          if (FAILED(hr))
          {
              if (HRESULT_CODE(hr) == ERROR_DS_CANT_ON_NON_LEAF)
              {
                    hr = DeleteSubtree(sPath);
                    if (FAILED(hr))
                    {
                        ADSIEditErrorMessage(hr);
                    }
            ASSERT(pComponentData != NULL);
            ASSERT(pNode->GetContainer() != pNode);
            CContainerNode* pCont = pNode->GetContainer();
            VERIFY(pCont->RemoveChildFromList(pNode));
            ASSERT(pNode->GetContainer() == NULL);
            pNode->SetContainer(pCont); // not in the container's list of children, but still needed
            
            // remove all the containers from UI only if the container is visible
          // all the leaves will be removed by the framework
          //
            if (pCont->IsVisible())
          {
            if (pNode->IsContainer())
            {
                  VERIFY(SUCCEEDED(pComponentData->DeleteNode(pNode))); // remove from the UI
            }
          }

          pComponentData->SetDescriptionBarText(this);
              delete pNode;
          pNode = NULL;
        }
              else
              {
          //
                  //Format Error message and pop up a dialog
          //
                  ADSIEditErrorMessage(hr);
              }
      }
      else // Delete Succeeded
      {
          ASSERT(pComponentData != NULL);
          ASSERT(pNode->GetContainer() != pNode);
          CContainerNode* pCont = pNode->GetContainer();
          VERIFY(pCont->RemoveChildFromList(pNode));
          ASSERT(pNode->GetContainer() == NULL);
          pNode->SetContainer(pCont); // not in the container's list of children, but still needed
          
          // remove all the containers from UI only if the container is visible
        // all the leaves will be removed by the framework
        //
          if (pCont->IsVisible())
        {
              VERIFY(SUCCEEDED(pComponentData->DeleteNode(pNode))); // remove from the UI
        }

        pComponentData->SetDescriptionBarText(this);
            delete pNode;
        pNode = NULL;
      }
    }
  }
}

void CADSIEditContainerNode::OnDelete(CComponentDataObject* pComponentData,
                                      CNodeList* pNodeList)
{
  if (pNodeList->GetCount() > 1) // multiple selection
  {
    OnDeleteMultiple(pComponentData, pNodeList);
  }
  else if (pNodeList->GetCount() == 1) // single selection
  {
      if (ADSIEditMessageBox(IDS_MSG_DELETE_OBJECT, MB_YESNO | MB_DEFBUTTON2) == IDYES)
      {
          CString sPath;
          GetADsObject()->GetPath(sPath);

          BOOL bLocked = IsThreadLocked();
          ASSERT(!bLocked); // cannot do refresh on locked node, the UI should prevent this
          if (bLocked)
              return; 
          if (IsSheetLocked())
          {
              if (!CanCloseSheets())
                  return;
              pComponentData->GetPropertyPageHolderTable()->DeleteSheetsOfNode(this);
          }
          ASSERT(!IsSheetLocked());

          CADSIEditContainerNode* pContNode = dynamic_cast<CADSIEditContainerNode*>(GetContainer());
          ASSERT(pContNode != NULL);

          CString sClass;
          GetADsObject()->GetClass(sClass);

          HRESULT hr = pContNode->DeleteChild(sClass, sPath);

          if (FAILED(hr))
          {
              if (HRESULT_CODE(hr) == ERROR_DS_CANT_ON_NON_LEAF)
              {
                  if (ADSIEditMessageBox(IDS_MSG_DELETE_CONTAINER, MB_YESNO | MB_DEFBUTTON2) == IDYES)
                  {
                      hr = DeleteSubtree(sPath);
                      if (FAILED(hr))
                      {
                          ADSIEditErrorMessage(hr);
                          return;
                      }
                  }
                  else
                  {
                      return;
                  }
              }
              else
              {
                  //Format Error message and pop up a dialog
                  ADSIEditErrorMessage(hr);
                  return;
              }
          }

          DeleteHelper(pComponentData);
//        RefreshOverlappedTrees(sPath, pComponentData);
      pComponentData->SetDescriptionBarText(pContNode);

          delete this;
      }
  }
}

BOOL CADSIEditContainerNode::FindNode(LPCWSTR lpszPath, CList<CTreeNode*, CTreeNode*>& foundNodeList)
{
    CString szPath;
    GetADsObject()->GetPath(szPath);

    // NTRAID#NTBUG9-563093-2002/03/04-artm  Need to validate lpszPath before using.
    // Need to check that lpszPath != NULL.  Should also protect against a 
    // string that is not null terminated.
    // Finally, if a maximum path length is known, use wcsncmp() instead.
    if (wcscmp(lpszPath, (LPCWSTR)szPath) == 0)
    {
        foundNodeList.AddHead(this);
        return TRUE;
    }

  BOOL bFound = FALSE;

  //
  // Look through the leaf child list first
  //
  POSITION leafPos;
  for (leafPos = m_leafChildList.GetHeadPosition(); leafPos != NULL; )
  {
    CTreeNode* pNode = m_leafChildList.GetNext(leafPos);
    CADSIEditLeafNode* pLeafNode = dynamic_cast<CADSIEditLeafNode*>(pNode);

    if (pLeafNode != NULL)
    {
      BOOL bTemp;
      bTemp = pLeafNode->FindNode(lpszPath, foundNodeList);
      if (!bFound)
      {
        bFound = bTemp;
      }
    }
  }

    POSITION pos;
    for (pos = m_containerChildList.GetHeadPosition(); pos != NULL; )
    {
        CTreeNode* pNode = m_containerChildList.GetNext(pos);
        CADSIEditContainerNode* pContNode = dynamic_cast<CADSIEditContainerNode*>(pNode);

        if (pContNode != NULL)
        {
            BOOL bTemp;
            bTemp = pContNode->FindNode(lpszPath, foundNodeList);
            if (!bFound)
            {
                bFound = bTemp;
            }
        }
    }
    return bFound;
}

HRESULT CADSIEditContainerNode::DeleteChild(LPCWSTR lpszClass, LPCWSTR lpszPath)
{
    HRESULT hr, hCredResult;
   //
   // Get the escaped name from the path 
   //
  CComPtr<IADsPathname> spPathCracker;
  hr = ::CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                          IID_IADsPathname, (PVOID *)&(spPathCracker));
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
    return S_FALSE;
  }

  hr = spPathCracker->Set(CComBSTR(lpszPath), ADS_SETTYPE_FULL);
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
    return S_FALSE;
  }

  hr = spPathCracker->SetDisplayType(ADS_DISPLAY_FULL);
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
    return S_FALSE;
  }

  hr = spPathCracker->put_EscapedMode(ADS_ESCAPEDMODE_ON);
  if (FAILED(hr))
  {
     ADSIEditErrorMessage(hr);
     return S_FALSE;
  }

  CComBSTR bstrChild;
  hr = spPathCracker->Retrieve(ADS_FORMAT_LEAF, &bstrChild);
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
    return S_FALSE;
  }

  hr = spPathCracker->RemoveLeafElement();
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
    return S_FALSE;
  }

  CComBSTR bstrParent;
  hr = spPathCracker->Retrieve(ADS_FORMAT_X500, &bstrParent);
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
    return S_FALSE;
  }

    CComPtr<IADsContainer> pContainer;

    CConnectionData* pConnectData = GetADsObject()->GetConnectionNode()->GetConnectionData();
    hr = OpenObjectWithCredentials(
                                             pConnectData, 
                                             pConnectData->GetCredentialObject()->UseCredentials(),
                                             bstrParent,
                                             IID_IADsContainer, 
                                             (LPVOID*) &pContainer,
                                             NULL,
                                             hCredResult
                                             );

    if (FAILED(hr))
    {
        if (SUCCEEDED(hCredResult))
        {
            ADSIEditErrorMessage(hr);
        }
        return E_FAIL;
    }

    hr = pContainer->Delete(CComBSTR(lpszClass), bstrChild);

    return hr;
}

HRESULT CADSIEditContainerNode::DeleteSubtree(LPCWSTR lpszPath)
{

  HRESULT hr = S_OK, hCredResult;
  CComPtr<IADsDeleteOps> pObj = NULL;

    CConnectionData* pConnectData = GetADsObject()->GetConnectionNode()->GetConnectionData();
    hr = OpenObjectWithCredentials(
                                                                 pConnectData, 
                                                                 pConnectData->GetCredentialObject()->UseCredentials(),
                                                                 lpszPath,
                                                                 IID_IADsDeleteOps, 
                                                                 (LPVOID*) &pObj,
                                                                 NULL,
                                                                 hCredResult
                                                                 );
  if (FAILED(hr))
    return hr;

  hr = pObj->DeleteObject(NULL); //flag is reserved by ADSI
  return hr;
}

LPCWSTR CADSIEditContainerNode::GetString(int nCol) 
{ 
    CString sClass, sDN;
    GetADsObject()->GetClass(sClass);
    GetADsObject()->GetDN(sDN);

    // NOTICE-2002/03/04-artm  _wcsicmp() compares a constant string w/ a 
    // member field; member field should be null terminated so there
    // should be no problem using _wcsicmp() here
  if (GetContainer()->GetColumnSet()->GetColumnID() &&
      _wcsicmp(GetContainer()->GetColumnSet()->GetColumnID(), COLUMNSET_ID_PARTITIONS) == 0)
  {
      switch(nCol)
      {
          case N_PARTITIONS_HEADER_NAME :
              return GetDisplayName();
      case N_PARTITIONS_HEADER_NCNAME :
        return GetADsObject()->GetNCName();
          case N_PARTITIONS_HEADER_TYPE :
              return sClass;
          case N_PARTITIONS_HEADER_DN :
              return sDN;
          default :
              return NULL;
      }
  }
  else
  {
      switch(nCol)
      {
          case N_HEADER_NAME :
              return GetDisplayName();
          case N_HEADER_TYPE :
              return sClass;
          case N_HEADER_DN :
              return sDN;
          default :
              return NULL;
      }
  }
}

BOOL CADSIEditContainerNode::HasPropertyPages(DATA_OBJECT_TYPES type, 
                                              BOOL* pbHideVerb, 
                                              CNodeList* pNodeList)
{
  if (pNodeList->GetCount() == 1) // single selection
  {
      *pbHideVerb = FALSE; // always show the verb
      return TRUE;
  }

  //
  // Multiple selection
  //
  *pbHideVerb = TRUE;
  return FALSE;
}

HRESULT CADSIEditContainerNode::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, 
                                                    LONG_PTR handle,
                                                    CNodeList* pNodeList)
{
  if (pNodeList->GetCount() > 1)
  {
    return S_OK;
  }

  CWaitCursor cursor;
    CComponentDataObject* pComponentDataObject = 
            ((CRootData*)(GetContainer()->GetRootContainer()))->GetComponentDataObject();
    ASSERT(pComponentDataObject != NULL);

    CADSIEditContainerNode* pCont = dynamic_cast<CADSIEditContainerNode*>(GetContainer());
  ASSERT(pCont != NULL);

    CString path;
    GetADsObject()->GetPath(path);

    CString sServer, sClass;
    GetADsObject()->GetClass(sClass);
    GetADsObject()->GetConnectionNode()->GetConnectionData()->GetDomainServer(sServer);

    CADSIEditPropertyPageHolder* pHolder = new CADSIEditPropertyPageHolder(pCont, 
            this, pComponentDataObject, sClass, sServer, path);
    ASSERT(pHolder != NULL);
  pHolder->SetSheetTitle(IDS_PROP_CONTAINER_TITLE, this);
    HRESULT hr = pHolder->CreateModelessSheet(lpProvider, handle);
    if (FAILED(hr) ||
        hr == S_FALSE)
    {
       delete pHolder;
       pHolder = 0;
    }
    return hr;
}

BOOL CADSIEditContainerNode::OnAddMenuItem(LPCONTEXTMENUITEM2 pContextMenuItem,
                                                                                     long *pInsertionAllowed)
{
    CString sNC, sClass;
    CConnectionData* pConnectData = GetADsObject()->GetConnectionNode()->GetConnectionData();
    pConnectData->GetNamingContext(sNC);
  GetADsObject()->GetClass(sClass);

    if (pConnectData->IsGC() && pContextMenuItem->lCommandID != IDM_NEW_QUERY)
    {
        return FALSE;
    }

    if ((pContextMenuItem->lCommandID == IDM_RENAME ||
            pContextMenuItem->lCommandID == IDM_MOVE ||
            pContextMenuItem->lCommandID == IDM_NEW_OBJECT ||
            pContextMenuItem->lCommandID == IDM_NEW_QUERY ||
      pContextMenuItem->lCommandID == IDM_NEW_CONNECT_FROM_HERE) && 
            (m_nState == loading))
    {
        pContextMenuItem->fFlags = MF_GRAYED;
        return TRUE;
    }

  CString szNCName = GetADsObject()->GetNCName();
  if (pContextMenuItem->lCommandID == IDM_NEW_NC_CONNECT_FROM_HERE)
  {
    if (szNCName.IsEmpty())
    {
      return FALSE;
    }
    return TRUE;
  }

    if (IsThreadLocked() && 
        (pContextMenuItem->lCommandID == IDM_RENAME ||
            pContextMenuItem->lCommandID == IDM_MOVE))
    {
        pContextMenuItem->fFlags = MF_GRAYED;
        return TRUE;
    }

  //
  // Load the NC strings from the resource to use in the comparisons
  //
  CString szDomain;
  CString szSchema;
  CString szConfig;
  CString szRootDSE;

  if (!szDomain.LoadString(IDS_DOMAIN_NC))
  {
    szDomain = L"Domain";
  }

  if (!szSchema.LoadString(IDS_SCHEMA))
  {
    szSchema = L"Schema";
  }

  if (!szConfig.LoadString(IDS_CONFIG_CONTAINER))
  {
    szConfig = L"Configuration";
  }

  if (!szRootDSE.LoadString(IDS_ROOTDSE))
  {
    szRootDSE = g_lpszRootDSE;
  }

    if (GetADsObject()->IsIntermediateNode())
    {
        if (pContextMenuItem->lCommandID == IDM_RENAME)
        {
            if (sNC.CompareNoCase(szSchema) == 0  || 
                    sNC.CompareNoCase(szRootDSE) == 0 || 
                    sNC.CompareNoCase(szConfig) == 0  ||
          sNC.CompareNoCase(szDomain) == 0  ||
          sClass.CompareNoCase(L"domainDNS") == 0)
            {
                return FALSE;
            }
            else
            {
                return TRUE;
            }
        }
        else if (pContextMenuItem->lCommandID == IDM_MOVE ||
              pContextMenuItem->lCommandID == IDM_NEW_CONNECT_FROM_HERE)
        {
            return FALSE;
        }
        else if (pContextMenuItem->lCommandID == IDM_NEW_OBJECT ||
                    pContextMenuItem->lCommandID == IDM_NEW_QUERY)
        {
            // NOTICE-2002/03/04-artm  wcscmp() safe here b/c 
            // arg1 is a CString (always null terminated) and arg2
            // is a global constant
            if (wcscmp(sNC, g_lpszRootDSE) == 0)
            {
                return FALSE;
            }
            else
            {
                return TRUE;
            }
        }
    }
    return TRUE;
}


int CADSIEditContainerNode::GetImageIndex(BOOL bOpenImage) 
{
    int nIndex = 0;
    switch (m_nState)
    {
    case notLoaded:
        nIndex = FOLDER_IMAGE_NOT_LOADED;
        break;
    case loading:
        nIndex = FOLDER_IMAGE_LOADING;
        break;
    case loaded:
        nIndex = FOLDER_IMAGE_LOADED;
        break;
    case unableToLoad:
        nIndex = FOLDER_IMAGE_UNABLE_TO_LOAD;
        break;
    case accessDenied:
        nIndex = FOLDER_IMAGE_ACCESS_DENIED;
        break;
    default:
        ASSERT(FALSE);
    }
    return nIndex;
}

void CADSIEditContainerNode::OnChangeState(CComponentDataObject* pComponentDataObject)
{
    switch (m_nState)
    {
    case notLoaded:
    case loaded:
    case unableToLoad:
    case accessDenied:
    {
        m_nState = loading;
        m_dwErr = 0;
    }
    break;
    case loading:
    {
        if (m_dwErr == 0)
            m_nState = loaded;
        else if (m_dwErr == ERROR_ACCESS_DENIED)
            m_nState = accessDenied;
        else 
            m_nState = unableToLoad;
    }
    break;
    default:
        ASSERT(FALSE);
    }
    VERIFY(SUCCEEDED(pComponentDataObject->ChangeNode(this, CHANGE_RESULT_ITEM_ICON)));
    VERIFY(SUCCEEDED(pComponentDataObject->UpdateVerbState(this)));
}

BOOL CADSIEditContainerNode::CanCloseSheets()
{
  //
  // We can't do this with the new property page since it is not derived
  // from the base class in MTFRMWK.
  //
    //return (IDCANCEL != ADSIEditMessageBox(IDS_MSG_RECORD_CLOSE_SHEET, MB_OKCANCEL));

  ADSIEditMessageBox(IDS_MSG_RECORD_SHEET_LOCKED, MB_OK);
  return FALSE;
}

void CADSIEditContainerNode::OnHaveData(CObjBase* pObj, CComponentDataObject* pComponentDataObject)
{
    CTreeNode* p = dynamic_cast<CTreeNode*>(pObj);
    ASSERT(p != NULL);
    if (p != NULL)
    {
        AddChildToListAndUI(p, pComponentDataObject);
    pComponentDataObject->SetDescriptionBarText(this);
    }
}


void CADSIEditContainerNode::OnError(DWORD dwerr) 
{
    if (dwerr == ERROR_TOO_MANY_NODES)
    {
      // need to pop message
     AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CThemeContextActivator activator;
     CString szFmt;
     szFmt.LoadString(IDS_MSG_QUERY_TOO_MANY_ITEMS);
     CString szMsg;
     szMsg.Format(szFmt, GetDisplayName()); 
     AfxMessageBox(szMsg);
    }
    else
    {
        ADSIEditErrorMessage(dwerr);
    }
}

CQueryObj* CADSIEditContainerNode::OnCreateQuery()
{
    CConnectionData* pConnectData = GetADsObject()->GetConnectionNode()->GetConnectionData();
    if (!pConnectData->IsRootDSE())
    {
        CADSIEditRootData* pRootData = static_cast<CADSIEditRootData*>(GetRootContainer());
        CComponentDataObject* pComponentData = pRootData->GetComponentDataObject();
        RemoveAllChildrenHelper(pComponentData);

        CString sFilter;
        pConnectData->GetFilter()->GetFilterString(sFilter);
        CString path;
        GetADsObject()->GetPath(path);

        CADSIEditQueryObject* pQuery = new CADSIEditQueryObject(path, sFilter, ADS_SCOPE_ONELEVEL,
                                                                                    pConnectData->GetMaxObjectCount(),
                                                                                    pConnectData->GetCredentialObject(),
                                          pConnectData->IsGC(),
                                                                                    pConnectData->GetConnectionNode());

    TRACE(_T("Sizeof query object: %i\n"),
          sizeof(CADSIEditQueryObject));

        return pQuery;
    }
  return CMTContainerNode::OnCreateQuery();
}

BOOL CADSIEditContainerNode::OnSetRefreshVerbState(DATA_OBJECT_TYPES type, 
                                                   BOOL* pbHide, 
                                                   CNodeList* pNodeList)
{
    if (GetADsObject()->GetConnectionNode()->GetConnectionData()->IsRootDSE())
    {
        *pbHide = TRUE;
        return FALSE;
    }
    *pbHide = FALSE;

    if (m_nState == loading)
    {
        return FALSE;
    }

    return !IsThreadLocked();
}

BOOL CADSIEditContainerNode::GetNamingAttribute(LPCWSTR lpszClass, CStringList* sNamingAttr)
{
    CString sSchemaPath;
    CConnectionData* pConnectData = (GetADsObject()->GetConnectionNode())->GetConnectionData();

    pConnectData->GetAbstractSchemaPath(sSchemaPath);
    sSchemaPath += lpszClass;

    CComPtr<IADsClass> pClass;
    HRESULT hr, hCredResult;

    hr = OpenObjectWithCredentials(
                                             pConnectData, 
                                             pConnectData->GetCredentialObject()->UseCredentials(),
                                             sSchemaPath,
                                             IID_IADsClass, 
                                             (LPVOID*) &pClass,
                                             NULL,
                                             hCredResult
                                            );
    if (FAILED(hr))
    {
        return FALSE;
    }

    VARIANT var;
    VariantInit(&var);
    hr = pClass->get_NamingProperties( &var );

    if ( FAILED(hr) )
    {
        VariantClear(&var);
        return FALSE;
    }

    hr = VariantToStringList(var, *sNamingAttr);
    if (FAILED(hr))
    {
        VariantClear(&var);
        return FALSE;
    }

    VariantClear(&var);
    return TRUE;
}


BOOL CADSIEditContainerNode::BuildSchemaPath(CString& path)
{
    CString sSchemaPath, sLDAP, sServer, sPort, sTemp;
    CConnectionData* m_pConnectData = GetADsObject()->GetConnectionNode()->GetConnectionData();
    m_pConnectData->GetLDAP(sLDAP);
    m_pConnectData->GetDomainServer(sServer);
    m_pConnectData->GetPort(sPort);
    HRESULT hr = m_pConnectData->GetSchemaPath(sSchemaPath);
  if (FAILED(hr))
  {
    return FALSE;
  }

    if (sSchemaPath.IsEmpty())
    {
        if (FAILED(GetItemFromRootDSE(_T("schemaNamingContext"), sSchemaPath, m_pConnectData)))
        {
            return FALSE;
        }
        if (sServer != _T(""))
        {
            sTemp = sLDAP + sServer;
            if (sPort != _T(""))
            {
                sTemp = sTemp + _T(":") + sPort + _T("/");
            }
            else
            {
                sTemp = sTemp + _T("/");
            }
            sSchemaPath = sTemp + sSchemaPath;
        }
        else
        {
            sSchemaPath = sLDAP + sSchemaPath;
        }
        m_pConnectData->SetSchemaPath(sSchemaPath);
    }

    path = sSchemaPath;
    return TRUE;
}

CColumnSet* CADSIEditContainerNode::GetColumnSet() 
{ 
  CColumnSet* pColumnSet = NULL;

  // NTRAID#NTBUG9-563235-2002/03/04-artm  Need to check that GetDisplayName() 
  // does not return NULL before passing to _wcsicmp().
  if (_wcsicmp(GetDisplayName(), L"CN=Partitions") == 0)
  {
    //
    // Since this is the partitions container we need to use a different column set
    //
    if (!m_pPartitionsColumnSet)
    {
      m_pPartitionsColumnSet = new CADSIEditColumnSet(COLUMNSET_ID_PARTITIONS);
    }
    pColumnSet = m_pPartitionsColumnSet;
  }

  if (!pColumnSet)
  {
    CRootData* pRootData = (CRootData*)GetRootContainer();
    pColumnSet = pRootData->GetColumnSet(); 
  }
  return pColumnSet;
}

//////////////////////////////////////////////////////////////////////////////////////
// CADSIEditLeafNode

// {70B9C151-CFF7-11d2-8801-00C04F72ED31}
const GUID CADSIEditLeafNode::NodeTypeGUID  = 
{ 0x70b9c151, 0xcff7, 0x11d2, { 0x88, 0x1, 0x0, 0xc0, 0x4f, 0x72, 0xed, 0x31 } };

BOOL CADSIEditLeafNode::OnAddMenuItem(LPCONTEXTMENUITEM2 pContextMenuItem,
                                                                            long *pInsertionAllowed)
{
    CString sNC;
    CConnectionData* pConnectData = GetADsObject()->GetConnectionNode()->GetConnectionData();
    pConnectData->GetNamingContext(sNC);

    if ((pContextMenuItem->lCommandID == IDM_RENAME ||
            pContextMenuItem->lCommandID == IDM_MOVE) &&
            pConnectData->IsGC())
    {
        return FALSE;
    }

  CString szNCName = GetADsObject()->GetNCName();
  if (pContextMenuItem->lCommandID == IDM_NEW_NC_CONNECT_FROM_HERE)
  {
    if (szNCName.IsEmpty())
    {
      return FALSE;
    }
    return TRUE;
  }

  // NOTICE-2002/03/04-artm  wcscmp() is OK here
  // arg1 is a CString (always null terminated), arg2 is global constant
    if (pContextMenuItem->lCommandID == IDM_RENAME &&
            (sNC == _T("Schema") || 
            wcscmp(sNC, g_lpszRootDSE) == 0 || 
            pConnectData->IsGC()))
    {
        return FALSE;
    }
    return TRUE;
}


HRESULT CADSIEditLeafNode::OnCommand(long nCommandID, 
                                     DATA_OBJECT_TYPES type, 
                                                     CComponentDataObject* pComponentData,
                                     CNodeList* pNodeList)
{
  ASSERT(pNodeList->GetCount() == 1);

    switch (nCommandID)
    {
        case IDM_MOVE :
            OnMove(pComponentData);
            break;
    case IDM_NEW_NC_CONNECT_FROM_HERE :
      OnConnectToNCFromHere(pComponentData);
      break;
      default:
            ASSERT(FALSE); // Unknown command!
            return E_FAIL;
    }

  return S_OK;
}

void CADSIEditLeafNode::OnConnectToNCFromHere(CComponentDataObject* pComponentData)
{
  //
  // Retrieve the path to create the connection at
  //
  CADsObject* pADsObject = GetADsObject();
  CString szDN, szPath, szName, szNCName;
  pADsObject->GetDN(szDN);
  pADsObject->GetPath(szPath);
  pADsObject->GetName(szName);
  szNCName = pADsObject->GetNCName();

  HRESULT hr = S_OK;

  ASSERT(!szNCName.IsEmpty());
  if (!szNCName.IsEmpty())
  {
    //
    // Create the new connection node
    //
    CConnectionData* pConnectData = pADsObject->GetConnectionNode()->GetConnectionData();
    CADSIEditConnectionNode* pNewConnectNode = new CADSIEditConnectionNode(pConnectData);
    if (pNewConnectNode)
    {
      pNewConnectNode->SetDisplayName(GetDisplayName());
      pNewConnectNode->GetConnectionData()->SetBasePath(szNCName);
      pNewConnectNode->GetConnectionData()->SetDistinguishedName(szNCName);
      pNewConnectNode->GetConnectionData()->SetNamingContext(L"");
      pNewConnectNode->GetConnectionData()->SetDN(szNCName);
      pNewConnectNode->GetConnectionData()->SetName(szNCName);

      CString szServer, szProvider;
      pConnectData->GetDomainServer(szServer);
      pConnectData->GetLDAP(szProvider);

      do // false loop
      {
        //
        // Crack the path to get the path to the new NC
        //
        CComPtr<IADsPathname> spPathCracker;
        hr = ::CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                                        IID_IADsPathname, (PVOID *)&(spPathCracker));
        if (FAILED(hr))
        {
          ADSIEditErrorMessage(hr);
          break;
        }

        hr = spPathCracker->Set(CComBSTR(szNCName), ADS_SETTYPE_DN);
        if (FAILED(hr))
        {
          ADSIEditErrorMessage(hr);
          break;
        }

        hr = spPathCracker->SetDisplayType(ADS_DISPLAY_FULL);
        if (FAILED(hr))
        {
          ADSIEditErrorMessage(hr);
          break;
        }

        hr = spPathCracker->Set(CComBSTR(szServer), ADS_SETTYPE_SERVER);
        if (FAILED(hr))
        {
          ADSIEditErrorMessage(hr);
          break;
        }

        hr = spPathCracker->Set(CComBSTR(L"LDAP"), ADS_SETTYPE_PROVIDER);
        if (FAILED(hr))
        {
          ADSIEditErrorMessage(hr);
          break;
        }

        CComBSTR sbstrNewPath;
        hr = spPathCracker->Retrieve(ADS_FORMAT_X500, &sbstrNewPath);
        if (FAILED(hr))
        {
          ADSIEditErrorMessage(hr);
          break;
        }

        pNewConnectNode->GetConnectionData()->SetPath(sbstrNewPath);

        //
        // Add the new connection node to the root container
        //
        CADSIEditRootData* pRootData = (CADSIEditRootData*)pComponentData->GetRootData();
        BOOL bResult = pRootData->AddChildToListAndUI(pNewConnectNode, pComponentData);
        ASSERT(bResult);

        // 
        //  Select the new connection node
        //
        pComponentData->UpdateResultPaneView(pNewConnectNode);
      } while (false);

      if (FAILED(hr))
      {
        delete pNewConnectNode;
        pNewConnectNode = 0;
      }
    }
  }
}

BOOL CADSIEditLeafNode::FindNode(LPCWSTR lpszPath, CList<CTreeNode*, CTreeNode*>& foundNodeList)
{
    CString szPath;
    GetADsObject()->GetPath(szPath);

    // NTRAID#NTBUG9-563093-2002/03/04-artm  Need to validate lpszPath before using.
    // Need to check that lpszPath != NULL.  Should also protect against a 
    // string that is not null terminated.
    // Finally, if a maximum path length is known, use wcsncmp() instead.
    if (wcscmp(lpszPath, (LPCWSTR)szPath) == 0)
    {
        foundNodeList.AddHead(this);
        return TRUE;
    }

    return FALSE;
}

void CADSIEditLeafNode::RefreshOverlappedTrees(CString& szPath, CComponentDataObject* pComponentData)
{
    // Refresh any other subtrees of connections that contain this node
    //
    CList<CTreeNode*, CTreeNode*> foundNodeList;
    CADSIEditRootData* pRootNode = dynamic_cast<CADSIEditRootData*>(GetRootContainer());
    if (pRootNode != NULL)
    {
        BOOL bFound = pRootNode->FindNode(szPath, foundNodeList);
        if (bFound)
        {
            POSITION pos = foundNodeList.GetHeadPosition();
            while (pos != NULL)
            {
                CADSIEditLeafNode* pFoundNode = dynamic_cast<CADSIEditLeafNode*>(foundNodeList.GetNext(pos));
//              if (pFoundNode != NULL && pFoundNode != this)
                if (pFoundNode != NULL)
                {
                    if (pFoundNode->IsSheetLocked())
                    {
                        if (!pFoundNode->CanCloseSheets())
                            continue;
                        pComponentData->GetPropertyPageHolderTable()->DeleteSheetsOfNode(pFoundNode);
                    }
                    ASSERT(!pFoundNode->IsSheetLocked());

          CNodeList nodeList;
          nodeList.AddTail(pFoundNode);

                    pFoundNode->GetContainer()->OnRefresh(pComponentData, &nodeList);
                }
            }
        }
    }
}


HRESULT CADSIEditLeafNode::OnRename(CComponentDataObject* pComponentData,
                                    LPWSTR lpszNewName)
{
  HRESULT hr = S_OK;
    if (IsSheetLocked())
    {
        if (!CanCloseSheets())
            return S_FALSE;
        pComponentData->GetPropertyPageHolderTable()->DeleteSheetsOfNode(this);
    }
    ASSERT(!IsSheetLocked());

  CString szPath, szOldPath;
  CADsObject* pADsObject = GetADsObject();
  pADsObject->GetPath(szPath);
  szOldPath = szPath;
    CADSIEditConnectionNode* pConnectionNode = pADsObject->GetConnectionNode();
    CConnectionData* pConnectData = pConnectionNode->GetConnectionData();

  CComPtr<IADsPathname> spPathCracker;
  hr = ::CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                          IID_IADsPathname, (PVOID *)&(spPathCracker));
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
    return S_FALSE;
  }

  hr = spPathCracker->Set(CComBSTR(szPath), ADS_SETTYPE_FULL);
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
    return S_FALSE;
  }

  hr = spPathCracker->SetDisplayType(ADS_DISPLAY_FULL);
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
    return S_FALSE;
  }

  CComBSTR bstrOldLeaf;
  hr = spPathCracker->Retrieve(ADS_FORMAT_LEAF, &bstrOldLeaf);
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
    return S_FALSE;
  }

  CString szOldLeaf = bstrOldLeaf;
  CString szPrefix;
  szPrefix = szOldLeaf.Left(szOldLeaf.Find(L'=') + 1);

  hr = spPathCracker->RemoveLeafElement();
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
    return S_FALSE;
  }

  CComBSTR bstrParentPath;
  hr = spPathCracker->Retrieve(ADS_FORMAT_X500, &bstrParentPath);
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
    return S_FALSE;
  }

  CComPtr<IADsContainer> spDestination;
  CString sContPath(bstrParentPath);
    hr = OpenObjectWithCredentials(
                                             pConnectData->GetCredentialObject(), 
                                             bstrParentPath,
                                             IID_IADsContainer, 
                                             (LPVOID*) &spDestination
                                             );
    if (FAILED(hr)) 
    {
        ADSIEditErrorMessage(hr);
        return S_FALSE;
    }

  //
  // Place the prefix in front of the name if it wasn't typed in by
  // the user
  //
  CString szNewLeaf, szNewName = lpszNewName;
  if (szNewName.Find(L'=') == -1)
  {
    szNewLeaf = szPrefix + lpszNewName;
  }
  else
  {
    szNewLeaf = lpszNewName;
  }
  hr = spPathCracker->AddLeafElement(CComBSTR(szNewLeaf));
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
    return S_FALSE;
  }

    CComPtr<IDispatch> spObject;
    hr = spDestination->MoveHere(CComBSTR(szOldPath),
                              CComBSTR(szNewLeaf),
                              &spObject);
  if (FAILED(hr)) 
    {
        ADSIEditErrorMessage(hr);
        return S_FALSE;
    }

    CComPtr<IADs> spIADs;
    hr = spObject->QueryInterface(IID_IADs, (LPVOID*)&spIADs);
    if (FAILED(hr))
    {
        ADSIEditErrorMessage(hr);
        return S_FALSE;
    }

    CComBSTR bstrPath;
    hr = spIADs->get_ADsPath(&bstrPath);
    if (FAILED(hr))
    {
        ADSIEditErrorMessage(hr);
        return S_FALSE;
    }

  CComBSTR bstrDN;
  hr = spPathCracker->Retrieve(ADS_FORMAT_X500_DN, &bstrDN);
    if (FAILED(hr))
    {
        ADSIEditErrorMessage(hr);
        return S_FALSE;
    }

  CComBSTR bstrLeaf;
  hr = spPathCracker->Retrieve(ADS_FORMAT_LEAF, &bstrLeaf);
    if (FAILED(hr))
    {
        ADSIEditErrorMessage(hr);
        return S_FALSE;
    }

    GetADsObject()->SetPath(bstrPath);
    GetADsObject()->SetName(bstrLeaf);
    GetADsObject()->SetDN(bstrDN);

    SetDisplayName(bstrLeaf);

  return hr;
}

void CADSIEditLeafNode::OnMove(CComponentDataObject* pComponentData)
{
    if (IsSheetLocked())
    {
        if (!CanCloseSheets())
            return;
        pComponentData->GetPropertyPageHolderTable()->DeleteSheetsOfNode(this);
    }
    ASSERT(!IsSheetLocked());

  HRESULT hr = S_OK, hCredResult;
  DWORD result;
  CComPtr<IADsContainer> pDSDestination = NULL;
  CComPtr<IDispatch> pDSObject = NULL;
  CString strDestPath;
  CString strTitle;
  strTitle.LoadString (IDS_MOVE_TITLE);

  DSBROWSEINFO dsbi;
  ::ZeroMemory( &dsbi, sizeof(dsbi) );

    TCHAR szPath[MAX_PATH+1];
  CString str;
  str.LoadString(IDS_MOVE_TARGET);

    CString strRootPath;
    GetADsObject()->GetConnectionNode()->GetADsObject()->GetPath(strRootPath);

  dsbi.hwndOwner = NULL;
  dsbi.cbStruct = sizeof (DSBROWSEINFO);
  dsbi.pszCaption = (LPWSTR)((LPCWSTR)strTitle); // this is actually the caption
  dsbi.pszTitle = (LPWSTR)((LPCWSTR)str);
  dsbi.pszRoot = strRootPath;
  dsbi.pszPath = szPath;
  dsbi.cchPath = (sizeof(szPath) / sizeof(TCHAR));
  dsbi.dwFlags = DSBI_INCLUDEHIDDEN | DSBI_RETURN_FORMAT;
  dsbi.pfnCallback = NULL;
  dsbi.lParam = 0;
    
  result = DsBrowseForContainer( &dsbi );
    
  if ( result == IDOK ) 
    { // returns -1, 0, IDOK or IDCANCEL
    // get path from BROWSEINFO struct, put in text edit field
    TRACE(_T("returned from DS Browse successfully with:\n %s\n"),
          dsbi.pszPath);
    strDestPath = dsbi.pszPath;

    // See if the destination is the same as the current parent.  If so, do nothing

    CADSIEditContainerNode* pContainer = dynamic_cast<CADSIEditContainerNode*>(GetContainer());
    if (pContainer)
    {
       CString szPath;
       pContainer->GetADsObject()->GetPath(szPath);

       if (szPath == strDestPath)
       {
          // No reason to do anything if the source and the destination are the same
          return;
       }
    }
        CConnectionData* pConnectData = GetADsObject()->GetConnectionNode()->GetConnectionData();
        hr = OpenObjectWithCredentials(
                                                                     pConnectData, 
                                                                     pConnectData->GetCredentialObject()->UseCredentials(),
                                                                     strDestPath,
                                                                     IID_IADsContainer, 
                                                                     (LPVOID*) &pDSDestination,
                                                                     NULL,
                                                                     hCredResult
                                                                     );

        if (FAILED(hr))
        {
            if (SUCCEEDED(hCredResult))
            {
                ADSIEditErrorMessage(hr);
            }
            return;
        }

        CString sCurrentPath;
        GetADsObject()->GetPath(sCurrentPath);
        hr = pDSDestination->MoveHere(CComBSTR(sCurrentPath),
                                 NULL,
                                 &pDSObject);
      if (FAILED(hr)) 
        {
            ADSIEditErrorMessage(hr);
            return;
        }

        DeleteHelper(pComponentData);
        
//      RefreshOverlappedTrees(sCurrentPath, pComponentData);
//      RefreshOverlappedTrees(strDestPath, pComponentData);

        delete this;
    }
}


CADSIEditLeafNode::CADSIEditLeafNode(CADSIEditLeafNode* pLeafNode)
{
    m_pADsObject = new CADsObject(pLeafNode->m_pADsObject);
    CString sName;
    m_pADsObject->GetName(sName);

    SetDisplayName(sName);
}

BOOL CADSIEditLeafNode::OnSetRenameVerbState(DATA_OBJECT_TYPES type, 
                                             BOOL* pbHideVerb, 
                                             CNodeList* pNodeList)
{
  ASSERT(pNodeList->GetCount() == 1);

    if (GetADsObject()->GetConnectionNode()->GetConnectionData()->IsGC())
    {
        *pbHideVerb = TRUE; // always hide the verb
        return FALSE;
    }

    *pbHideVerb = FALSE; // always show the verb
    return TRUE;
}

BOOL CADSIEditLeafNode::OnSetDeleteVerbState(DATA_OBJECT_TYPES type, 
                                             BOOL* pbHideVerb, 
                                             CNodeList* pNodeList)
{
  ASSERT(pNodeList->GetCount() == 1);

    if (GetADsObject()->GetConnectionNode()->GetConnectionData()->IsGC())
    {
        *pbHideVerb = TRUE; // always hide the verb
        return FALSE;
    }

    *pbHideVerb = FALSE; // always show the verb
    return TRUE;
}

void CADSIEditLeafNode::OnDelete(CComponentDataObject* pComponentData,
                                 CNodeList* pNodeList)
{
  ASSERT(pNodeList->GetCount() == 1);

    if (ADSIEditMessageBox(IDS_MSG_DELETE_OBJECT, MB_YESNO | MB_DEFBUTTON2) == IDYES)
    {
        if (IsSheetLocked())
        {
            if (!CanCloseSheets())
                return;
            pComponentData->GetPropertyPageHolderTable()->DeleteSheetsOfNode(this);
        }
        ASSERT(!IsSheetLocked());

        CADSIEditContainerNode* pContNode = dynamic_cast<CADSIEditContainerNode*>(GetContainer());
        ASSERT(pContNode != NULL);

        CString sName, sClass, sPath;
        GetADsObject()->GetName(sName);
        GetADsObject()->GetClass(sClass);
        GetADsObject()->GetPath(sPath);

        HRESULT hr;
    
        hr = pContNode->DeleteChild(sClass, sPath);

        if (FAILED(hr))
        {
            //Format Error message and pop up a dialog
            ADSIEditErrorMessage(hr);
            return;
        }

//      RefreshOverlappedTrees(sPath, pComponentData);

        DeleteHelper(pComponentData);
    pComponentData->SetDescriptionBarText(pContNode);
        delete this;
    }
}

LPCWSTR CADSIEditLeafNode::GetString(int nCol) 
{ 
    CString sClass, sDN;
    GetADsObject()->GetClass(sClass);
    GetADsObject()->GetDN(sDN);

    // NOTICE-2002/03/04-artm  _wcsicmp() OK here
    // arg1 is a member field (and should be null terminated),
    // arg2 is a constant
  if (GetContainer()->GetColumnSet()->GetColumnID() &&
      _wcsicmp(GetContainer()->GetColumnSet()->GetColumnID(), COLUMNSET_ID_PARTITIONS) == 0)
  {
      switch(nCol)
      {
          case N_PARTITIONS_HEADER_NAME :
              return GetDisplayName();
      case N_PARTITIONS_HEADER_NCNAME :
        return GetADsObject()->GetNCName();
          case N_PARTITIONS_HEADER_TYPE :
              return sClass;
          case N_PARTITIONS_HEADER_DN :
              return sDN;
          default :
              return NULL;
      }
  }
  else
  {
      switch(nCol)
      {
          case N_HEADER_NAME :
              return GetDisplayName();
          case N_HEADER_TYPE :
              return sClass;
          case N_HEADER_DN :
              return sDN;
          default :
              return NULL;
      }
  }
}

int CADSIEditLeafNode::GetImageIndex(BOOL bOpenImage) 
{
    return RECORD_IMAGE_BASE;
}

BOOL CADSIEditLeafNode::HasPropertyPages(DATA_OBJECT_TYPES type, 
                                         BOOL* pbHideVerb, 
                                         CNodeList* pNodeList)
{
  ASSERT(pNodeList->GetCount() == 1);
    *pbHideVerb = FALSE; // always show the verb
    return TRUE;
}


HRESULT CADSIEditLeafNode::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, 
                                               LONG_PTR handle,
                                               CNodeList* pNodeList)
{
  if (pNodeList->GetCount() > 1)
  {
    return S_OK;
  }

    CComponentDataObject* pComponentDataObject = 
            ((CRootData*)(GetContainer()->GetRootContainer()))->GetComponentDataObject();
    ASSERT(pComponentDataObject != NULL);
    
    CString path;
    GetADsObject()->GetPath(path);

    CString sServer, sClass;
    GetADsObject()->GetClass(sClass);
    GetADsObject()->GetConnectionNode()->GetConnectionData()->GetDomainServer(sServer);

    CADSIEditContainerNode *pContNode = dynamic_cast<CADSIEditContainerNode*>(GetContainer());
    ASSERT(pContNode != NULL);

    CADSIEditPropertyPageHolder* pHolder = new CADSIEditPropertyPageHolder(pContNode, this, 
            pComponentDataObject, sClass, sServer, path );
    ASSERT(pHolder != NULL);
  pHolder->SetSheetTitle(IDS_PROP_CONTAINER_TITLE, this);
    return pHolder->CreateModelessSheet(lpProvider, handle);
}

BOOL CADSIEditLeafNode::BuildSchemaPath(CString& path)
{
    return ((CADSIEditContainerNode*)m_pContainer)->BuildSchemaPath(path);
}


BOOL CADSIEditLeafNode::CanCloseSheets()
{
  //
  // We can't do this with the new property page since it is not derived
  // from the base class in MTFRMWK.
  //
    //return (IDCANCEL != ADSIEditMessageBox(IDS_MSG_RECORD_CLOSE_SHEET, MB_OKCANCEL));

  ADSIEditMessageBox(IDS_MSG_RECORD_SHEET_LOCKED, MB_OK);
  return FALSE;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////
// CADSIEditQuery


BOOL CADSIEditQueryObject::Enumerate()
{
    CADSIQueryObject enumSearch;

    // Initialize search object with path, username and password
    //
    HRESULT hCredResult = S_OK;
    HRESULT hr = enumSearch.Init(m_sPath, &m_credentialObject);
    if (FAILED(hr))
    {
        OnError(hr);
        return FALSE;
    }

  TRACE(_T("Sizeof CredentialObject: %i\n"), sizeof(CCredentialObject));

    int cCols = 2;
    LPWSTR pszAttributes[] = {L"aDSPath", L"nCName" };

    hr = enumSearch.SetSearchPrefs(m_Scope, m_ulMaxObjectCount);
    if (FAILED(hr))
    {
        OnError(hr);
        return FALSE;
    }

    enumSearch.SetFilterString((LPWSTR)(LPCWSTR)m_sFilter);
    enumSearch.SetAttributeList (pszAttributes, cCols);
    hr = enumSearch.DoQuery();
    if (SUCCEEDED(hr)) 
    {
        GetResults(enumSearch);
    }
    else
    {
        OnError(hr);
    }

    return FALSE;
}

void CADSIEditQueryObject::GetResults(CADSIQueryObject& enumSearch)
{
    HRESULT hr = S_OK;

    ADS_OBJECT_INFO* pInfo = NULL;
    ADS_SEARCH_COLUMN ColumnData;
  BOOL bNeedToFreeColumnData = FALSE;

    QUERY_STATE dwErr = QUERY_OK;
    ULONG nObjectCount = 0;
    ASSERT(nObjectCount <= m_ulMaxObjectCount);

    while (true)
    {
    hr = enumSearch.GetNextRow();
    if (hr == S_ADS_NOMORE_ROWS)
    {
      break;
    }

        if (FAILED(hr)) 
        {
            OnError(hr);
      break;
        }

    //
    // Get the NCName. Note this will be empty for all objects except
    // crossRef objects for app directory partitions (formerly known as NDNCs)
    //
    CString szNCName;
    hr = enumSearch.GetColumn(L"nCName", &ColumnData);
    if (SUCCEEDED(hr) && ColumnData.pADsValues)
    {
      szNCName = ColumnData.pADsValues->DNString;
      enumSearch.FreeColumn(&ColumnData);
    }

        // Get the path column
        bNeedToFreeColumnData = FALSE;
        hr = enumSearch.GetColumn(L"aDSPath", &ColumnData);
        if (FAILED(hr))
        {
            enumSearch.FreeColumn(&ColumnData);
            bNeedToFreeColumnData = FALSE;

            ADSIEditErrorMessage(hr);

      //
            // if we can't get the path there must be something extremely wrong since the
            // since the path is guaranteed, so we should break instead of continuing
      //
            break;
        }
        
        bNeedToFreeColumnData = TRUE;
        if (nObjectCount >= m_ulMaxObjectCount)
        {
            dwErr = ERROR_TOO_MANY_NODES;
            OnError(dwErr);
            break;
        }
        CString sPath(ColumnData.pADsValues->CaseIgnoreString);

        CComPtr<IDirectoryObject> spDirObject;
        hr = OpenObjectWithCredentials(
                                                 &m_credentialObject,
                                                 sPath,
                                                 IID_IDirectoryObject, 
                                                 (LPVOID*) &spDirObject
                                                 );
        if ( FAILED(hr) )
        {
      TRACE(_T("Unable to bind to new object. Creating incomplete object. hr=0x%x\n"), hr);
            // Create an incomplete object
            CreateNewObject(sPath, NULL, szNCName);

            if (bNeedToFreeColumnData)
            {
                enumSearch.FreeColumn(&ColumnData);
                bNeedToFreeColumnData = FALSE;
            }
            continue;
        }

        ASSERT(pInfo == NULL);
        hr = spDirObject->GetObjectInformation(&pInfo);
        if (FAILED(hr))
        {
      TRACE(_T("Unable to get object info. Creating incomplete object. hr=0x%x\n"), hr);

            // Create an incomplete object
            CreateNewObject(sPath, NULL, szNCName);

            if (bNeedToFreeColumnData)
            {
                enumSearch.FreeColumn(&ColumnData);
                bNeedToFreeColumnData = FALSE;
            }

            continue;
        }

        ASSERT(pInfo != NULL);
    TRACE(_T("Creating complete object\n"));

        // Create a complete object
        CreateNewObject(sPath, pInfo, szNCName);

        FreeADsMem(pInfo);
        pInfo = NULL;

        enumSearch.FreeColumn(&ColumnData);
        bNeedToFreeColumnData = FALSE;
        nObjectCount++;
    } // while

    if (pInfo != NULL)
    {
        FreeADsMem(pInfo);
    }

    if (bNeedToFreeColumnData)
    {
        enumSearch.FreeColumn(&ColumnData);
    }

}

void CADSIEditQueryObject::CreateNewObject(CString& sPath,
                                                                       ADS_OBJECT_INFO* pInfo,
                                           PCWSTR pszNCName)
{
    CADsObject* pObject = new CADsObject(m_pConnectNode);   
  if (pObject)
  {
    pObject->SetNCName(pszNCName);

      if (pInfo != NULL)
      {
          // This means we have a complete object
          pObject->SetPath(sPath);

          // Get the leaf name via PathCracker
          CString sDisplayName, sDN;
          CrackPath(sPath, sDisplayName, sDN);
          pObject->SetName(sDisplayName);
          pObject->SetDN(sDN);

          // make the prefix uppercase
          int idx = sDisplayName.Find(L'=');
          if (idx != -1)
          {
              CString sPrefix, sRemaining;
              sPrefix = sDisplayName.Left(idx);
              sPrefix.MakeUpper();

              int iCount = sDisplayName.GetLength();
              sRemaining = sDisplayName.Right(iCount - idx);
              sDisplayName = sPrefix + sRemaining;
          }

          pObject->SetClass(pInfo->pszClassName);
          pObject->SetComplete(TRUE);


          if (IsContainer(pInfo->pszClassName, pInfo->pszSchemaDN))
          {
        TRACE(_T("IsContainer returned TRUE\n"));
              CADSIEditContainerNode* pContNode = new CADSIEditContainerNode(pObject);
              pObject = NULL;
              pContNode->SetDisplayName(sDisplayName);

              pContNode->GetADsObject()->SetConnectionNode(m_pConnectNode);
              VERIFY(AddQueryResult(pContNode));
          }
          else
          {
        TRACE(_T("IsContainer returned FALSE\n"));
              CADSIEditLeafNode *pLeafNode = new CADSIEditLeafNode(pObject);
              pObject = NULL;
              pLeafNode->SetDisplayName(sDisplayName);
              pLeafNode->GetADsObject()->SetConnectionNode(m_pConnectNode);
              VERIFY(AddQueryResult(pLeafNode));
          }
      }
      else
      {
          // Get the leaf name and DN via PathCracker
          CString sCrackPath, sDN;
          CrackPath(sPath, sCrackPath, sDN);
          pObject->SetName(sCrackPath);
          pObject->SetDN(sDN);
          pObject->SetPath(sPath);

          CString sDisplayName;
          sDisplayName = sPath;

          // Make the prefix upper case
          int idx = sDisplayName.Find(L'=');
          if (idx != -1)
          {
              CString sPrefix, sRemaining;
              sPrefix = sDisplayName.Left(idx);
              sPrefix.MakeUpper();

              int iCount = sDisplayName.GetLength();
              sRemaining = sDisplayName.Right(iCount - idx);
              sDisplayName = sPrefix + sRemaining;
          }
          pObject->SetComplete(FALSE);

          // Make all nodes that were of undetermined type leaf nodes
          CADSIEditLeafNode *pLeafNode = new CADSIEditLeafNode(pObject);
          pObject = NULL;

          pLeafNode->SetDisplayName(sCrackPath);
          pLeafNode->GetADsObject()->SetConnectionNode(m_pConnectNode);
          VERIFY(AddQueryResult(pLeafNode));
      }
  }

    if (pObject != NULL)
    {
        delete pObject;
        pObject = NULL;
    }
}

void CADSIEditQueryObject::CrackPath(const CString sName, CString& sPath, CString& sDN)
{
    HRESULT hr = PathCracker()->Set(CComBSTR(sName), ADS_SETTYPE_FULL);
    if (FAILED(hr)) 
    {
        TRACE(_T("Set failed. %s"), hr);
    }

  //
  // Get the current escaped mode
  //
  LONG lEscapedMode = ADS_ESCAPEDMODE_DEFAULT;
  hr = PathCracker()->get_EscapedMode(&lEscapedMode);

  hr = PathCracker()->put_EscapedMode(ADS_ESCAPEDMODE_OFF_EX);

    // Get the leaf name
    CComBSTR bstrPath;
    hr = PathCracker()->Retrieve(ADS_FORMAT_LEAF, &bstrPath);
    if (FAILED(hr))
    {
        TRACE(_T("Failed to get element. %s"), hr);
        sPath = L"";
    }
    else
    {
        sPath = bstrPath;
    }

  //
  // Put the escaped mode back to what it was
  //
  hr = PathCracker()->put_EscapedMode(lEscapedMode);

    // Get the leaf DN
    CComBSTR bstrDN;
    hr = PathCracker()->Retrieve(ADS_FORMAT_X500_DN, &bstrDN);
    if (FAILED(hr))
    {
        TRACE(_T("Failed to get element. %s"), hr);
        sDN = L"";
    }
    else
    {
        sDN = bstrDN;
    }
}

IADsPathname* CADSIEditQueryObject::PathCracker()
{
  if (m_pPathCracker == NULL)
  {
     HRESULT hr = ::CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                                    IID_IADsPathname, (PVOID *)&(m_pPathCracker));
     ASSERT((S_OK == hr) && ((m_pPathCracker) != NULL));
  }
  return m_pPathCracker;
}

bool CADSIEditQueryObject::IsContainer(PCWSTR pszClass, PCWSTR pszPath)
{
  return m_pConnectNode->IsClassAContainer(&m_credentialObject, pszClass, pszPath);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\editorui.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       editorui.h
//
//--------------------------------------------------------------------------

#ifndef _EDITORUI_H
#define _EDITORUI_H

#include "attredit.h"
#include "snapdata.h"
#include "aclpage.h"

#include <initguid.h>

#include "IAttrEdt.h"

/////////////////////////////////////////////////////////////////////////////
// CADSIEditPropertyPage

class CADSIEditPropertyPage : public CPropertyPageBase
{

// Construction
public:
  CADSIEditPropertyPage();
  CADSIEditPropertyPage(CAttrList* pAttrList);
	virtual ~CADSIEditPropertyPage() 
  {
  }

	// Used to initialize data that is needed in the UI
	//
	void SetClass(LPCWSTR sClass) { m_sClass = sClass; }
	void SetServer(LPCWSTR sServer) { m_sServer = sServer; }
	void SetPath(LPCWSTR sPath) { m_sPath = sPath; }
  void SetConnectionData(CConnectionData* pConnectData) { m_pConnectData = pConnectData; }

  void SetAttrList(CAttrList* pAttrList);
  void CopyAttrList(CAttrList* pAttrList);
  CAttrList* GetAttrList() { return m_pOldAttrList; }

	// Implementation
protected:
	
	// Message map functions
	//
	virtual BOOL OnInitDialog();
	virtual BOOL OnApply();
  virtual void OnCancel();
	afx_msg void OnSelChangeAttrList();
	afx_msg void OnSelChangePropList();

	// Helper functions
	//
	void FillAttrList();
	void AddPropertiesToBox(BOOL bMand, BOOL bOpt);
	BOOL GetProperties();

// Member data

	CString m_sPath;
	CString m_sClass;
	CString m_sServer;
  CConnectionData* m_pConnectData;
	CStringList m_sMandatoryAttrList;
	CStringList m_sOptionalAttrList;
	CAttrEditor m_attrEditor;
  CAttrList* m_pOldAttrList;

  // REVIEW_JEFFJON : since this is an imbedded member and its destructor deletes everything in the list,
  //                  we have to remove everything in the list that is also in m_pOldAttrList so that it
  //                  doesn't get deleted.
  CAttrList m_AttrList;
  BOOL m_bExisting;

	DECLARE_MESSAGE_MAP()
};


///////////////////////////////////////////////////////////////////////////////
// CADSIEditPropertyPageHolder

class CADSIEditPropertyPageHolder : public CPropertyPageHolderBase
{
public:
	CADSIEditPropertyPageHolder(CADSIEditContainerNode* pRootDataNode, CTreeNode* pContainerNode,
			CComponentDataObject* pComponentData, LPCWSTR lpszClass, LPCWSTR lpszServer, LPCWSTR lpszPath); 
	~CADSIEditPropertyPageHolder()
	{
		if (m_pAclEditorPage != NULL)
    {
			delete m_pAclEditorPage;
      m_pAclEditorPage = NULL;
    }
	}

	HRESULT OnAddPage(int nPage, CPropertyPageBase* pPage);

	virtual CADSIEditContainerNode* GetContainerNode() { return m_pContainer; }

private:
	CAclEditorPage*					    m_pAclEditorPage;

  CComPtr<IDsAttributeEditor> m_spIDsAttributeEditor;

  CString                     m_sPath;

	CComPtr<IADs>               m_pADs;
	CADSIEditContainerNode*     m_pContainer;
};

/////////////////////////////////////////////////////////////////////////////////////
// CCreateWizPropertyPageHolder

class CCreateWizPropertyPageHolder : public CPropertyPageHolderBase
{
public:
	CCreateWizPropertyPageHolder(CADSIEditContainerNode* pRootDataNode,	
                               CComponentDataObject* pComponentData, 
                               LPCWSTR lpszClass, 
                               LPCWSTR lpszServer,
                               CAttrList* pAttrList); 
	~CCreateWizPropertyPageHolder()
	{
	}

	virtual CADSIEditContainerNode* GetContainerNode() { return m_pContainer; }

private:
	CADSIEditPropertyPage m_propPage;

	CADSIEditContainerNode* m_pContainer;
};


#endif _EDITORUI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\editorui.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       editorui.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#include <SnapBase.h>

#include "resource.h"
#include "attredit.h"
#include "adsiedit.h"
#include "editor.h"
#include "editorui.h"
#include "snapdata.h"
#include "common.h"
#include <aclpage.h>
#include <dssec.h>  // For AclEditor flags
#include "connection.h"


#ifdef DEBUG_ALLOCATOR
    #ifdef _DEBUG
    #define new DEBUG_NEW
    #undef THIS_FILE
    static char THIS_FILE[] = __FILE__;
    #endif
#endif

////////////////////////////////////////////////////////////////////////////
// this is used to fill in the attributes for RootDSE
//
typedef struct tagRootDSEAttr
{
    LPCWSTR lpszAttr;
    LPCWSTR lpszSyntax;
    BOOL        bMulti;     
} SYNTAXMAP;
    
SYNTAXMAP g_ldapRootDSESyntax[] = 
{
    _T("currentTime"),                      _T("2.5.5.11"), FALSE,
    _T("subschemaSubentry"),                _T("2.5.5.1"),      FALSE,
    _T("serverName"),                           _T("2.5.5.1"),      FALSE,
    _T("namingContexts"),                   _T("2.5.5.1"),      TRUE,
    _T("defaultNamingContext"),         _T("2.5.5.1"),      FALSE,
    _T("schemaNamingContext"),              _T("2.5.5.1"),      FALSE,
    _T("configurationNamingContext"),   _T("2.5.5.1"),      FALSE,
    _T("rootDomainNamingContext"),      _T("2.5.5.1"),      FALSE,
    _T("supportedControl"),                 _T("2.5.5.2"),      TRUE,
    _T("supportedLDAPVersion"),         _T("2.5.5.9"),      TRUE,
    _T("supportedLDAPPolicies"),            _T("2.5.5.4"),      TRUE,
    _T("supportedSASLMechanisms"),      _T("2.5.5.4"),      TRUE,
    _T("dsServiceName"),                        _T("2.5.5.1"),      FALSE,
    _T("dnsHostName"),                      _T("2.5.5.4"),      FALSE,
    _T("supportedCapabilities"),            _T("2.5.5.2"),      TRUE,
    _T("ldapServiceName"),                  _T("2.5.5.4"),      FALSE,
    _T("highestCommittedUsn"),              _T("2.5.5.4"),      FALSE, // this should be an integer but after investigation I found it was a string
   _T("domainControllerFunctionality"),_T("2.5.5.9"),    FALSE,
   _T("domainFunctionality"),          _T("2.5.5.9"),    FALSE,
   _T("forestFunctionality"),          _T("2.5.5.9"),    FALSE,
   _T("isGlobalCatalogReady"),         _T("2.5.5.8"),    FALSE,
   _T("isSynchronized"),               _T("2.5.5.8"),    FALSE,
    NULL,     0,
};

extern LPCWSTR g_lpszGC;

/////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CADSIEditPropertyPage, CPropertyPageBase)
    //{{AFX_MSG_MAP(CADsObjectDialog)
    ON_CBN_SELCHANGE(IDC_PROP_BOX, OnSelChangeAttrList) 
    ON_CBN_SELCHANGE(IDC_PROPTYPES_BOX, OnSelChangePropList)    
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


CADSIEditPropertyPage::CADSIEditPropertyPage() 
                : CPropertyPageBase(IDD_PROPERTY_PAGE)
{
  m_bExisting = TRUE;
}

CADSIEditPropertyPage::CADSIEditPropertyPage(CAttrList* pAttrs)
        : CPropertyPageBase(IDD_PROPERTY_PAGE)
{
  ASSERT(pAttrs != NULL);
  m_pOldAttrList = pAttrs;
  m_bExisting = FALSE;
  CopyAttrList(pAttrs);
}

void CADSIEditPropertyPage::CopyAttrList(CAttrList* pAttrList)
{
  m_AttrList.RemoveAll();
  POSITION pos = pAttrList->GetHeadPosition();
  while (pos != NULL)
  {
    m_AttrList.AddHead(pAttrList->GetNext(pos));
  }
}

BOOL CADSIEditPropertyPage::OnInitDialog()
{
    CPropertyPageBase::OnInitDialog();

    // Get the dialog items
    //
    CEdit* pPathBox = (CEdit*)GetDlgItem(IDC_PATH_BOX);
    CEdit* pClassBox = (CEdit*)GetDlgItem(IDC_CLASS_BOX);
    CComboBox* pPropSelectBox = (CComboBox*)GetDlgItem(IDC_PROPTYPES_BOX);
    CComboBox* pPropertyBox = (CComboBox*)GetDlgItem(IDC_PROP_BOX);
    CStatic* pPathLabel = (CStatic*)GetDlgItem(IDC_PATH_LABEL);
    CStatic* pClassLabel = (CStatic*)GetDlgItem(IDC_CLASS_LABEL);
    CStatic* pFilterLabel = (CStatic*)GetDlgItem(IDC_FILTER_LABEL);
    CStatic* pPropertyLabel = (CStatic*)GetDlgItem(IDC_PROPERTY_LABEL);
    CStatic* pSyntaxLabel = (CStatic*)GetDlgItem(IDC_SYNTAX_LABEL);
    CStatic* pEditLabel = (CStatic*)GetDlgItem(IDC_EDIT_LABEL);
    CStatic* pValueLabel = (CStatic*)GetDlgItem(IDC_VALUE_LABEL);
    CButton* pAttrGroup = (CButton*)GetDlgItem(IDC_ATTR_GROUP);
    CStatic* pNoInfoLabel = (CStatic*)GetDlgItem(IDC_NO_INFO);


  if (m_bExisting)
  {
    // This determines whether the node is complete with data or not.  If not we won't enable
      //   the UI
      //
      BOOL bComplete = TRUE;
      CADsObject* pADsObject = NULL;
      CTreeNode* pTreeNode = GetHolder()->GetTreeNode();
      CADSIEditContainerNode* pContNode = dynamic_cast<CADSIEditContainerNode*>(pTreeNode);
      if (pContNode == NULL)
      {
          CADSIEditLeafNode* pLeafNode = dynamic_cast<CADSIEditLeafNode*>(pTreeNode);
          ASSERT(pLeafNode != NULL);
          pADsObject = pLeafNode->GetADsObject();
      m_pConnectData = pADsObject->GetConnectionNode()->GetConnectionData();
          bComplete = pADsObject->IsComplete();
      }
      else
      {
          pADsObject = pContNode->GetADsObject();
      m_pConnectData = pADsObject->GetConnectionNode()->GetConnectionData();
          bComplete = pADsObject->IsComplete();
      }

      
      // Initialize the attribute editor 
      //
      m_attrEditor.Initialize(this, pTreeNode, m_sServer,
                                      IDC_EDITVALUE_BOX, IDC_SYNTAX_BOX,
                                      IDC_VALUE_EDITBOX,    IDC_VALUE_LISTBOX,
                                      IDC_ADD_BUTTON,   IDC_REMOVE_BUTTON,
                                      bComplete);


      // Get the UI to reflect the data
      //
      if ( bComplete)
      {
          pPathBox->SetWindowText(m_sPath);

          GetProperties();

          pClassBox->SetWindowText(m_sClass);

          CString sMand, sOpt, sBoth;
          if (!sMand.LoadString(IDS_MANDATORY) ||
                  !sOpt.LoadString(IDS_OPTIONAL) ||
                  !sBoth.LoadString(IDS_BOTH))
          {
              ADSIEditMessageBox(IDS_MSG_FAIL_TO_LOAD, MB_OK);
          }

          if (m_pConnectData->IsRootDSE())
          {
              pPropSelectBox->AddString(sMand);
              pPropSelectBox->SetCurSel(0);
          }
          else
          {
              pPropSelectBox->AddString(sMand);
              pPropSelectBox->AddString(sOpt);
              pPropSelectBox->AddString(sBoth);

              pPropSelectBox->SetCurSel(1);
          }

          OnSelChangePropList();
          pPropertyBox->SetCurSel(0);
      }
      else
      {
          pClassBox->ShowWindow(SW_HIDE);
          pPropSelectBox->ShowWindow(SW_HIDE);
          pPropertyBox->ShowWindow(SW_HIDE);
          pPathLabel->ShowWindow(SW_HIDE);
          pClassLabel->ShowWindow(SW_HIDE);
          pFilterLabel->ShowWindow(SW_HIDE);
          pPropertyLabel->ShowWindow(SW_HIDE);
          pSyntaxLabel->ShowWindow(SW_HIDE);
          pEditLabel->ShowWindow(SW_HIDE);
          pValueLabel->ShowWindow(SW_HIDE);
          pAttrGroup->ShowWindow(SW_HIDE);

          pNoInfoLabel->ShowWindow(SW_SHOW);
      }
  }
  else
  {
      // Initialize the attribute editor 
      //
      m_attrEditor.Initialize(this, m_pConnectData, m_sServer,
                                      IDC_EDITVALUE_BOX, IDC_SYNTAX_BOX,
                                      IDC_VALUE_EDITBOX,    IDC_VALUE_LISTBOX,
                                      IDC_ADD_BUTTON,   IDC_REMOVE_BUTTON,
                                      TRUE, &m_AttrList);

    pPathBox->SetWindowText(m_sPath);

        GetProperties();

        pClassBox->SetWindowText(m_sClass);

        CString sMand, sOpt, sBoth;
        if (!sMand.LoadString(IDS_MANDATORY) ||
                !sOpt.LoadString(IDS_OPTIONAL) ||
                !sBoth.LoadString(IDS_BOTH))
        {
            ADSIEditMessageBox(IDS_MSG_FAIL_TO_LOAD, MB_OK);
        }

        if (m_pConnectData->IsRootDSE())
        {
            pPropSelectBox->AddString(sMand);
            pPropSelectBox->SetCurSel(0);
        }
        else
        {
            pPropSelectBox->AddString(sMand);
            pPropSelectBox->AddString(sOpt);
            pPropSelectBox->AddString(sBoth);

            pPropSelectBox->SetCurSel(1);
        }

        OnSelChangePropList();
        pPropertyBox->SetCurSel(0);

  }
    return TRUE;
}

BOOL CADSIEditPropertyPage::OnApply()
{
    if( m_attrEditor.OnApply())
  {
    if (!m_bExisting)
    {
      m_pOldAttrList->RemoveAll();
      while (!m_AttrList.IsEmpty())
      {
        m_pOldAttrList->AddTail(m_AttrList.RemoveTail());
      }
    }
  }
  else
  {
    return FALSE;
  }
  return TRUE;
}

void CADSIEditPropertyPage::OnCancel()
{
  if (!m_bExisting)
  {
    while (!m_AttrList.IsEmpty())
    {
      CADSIAttr* pAttr = m_AttrList.RemoveTail();
      ASSERT(pAttr != NULL);

      CString szProp;
      pAttr->GetProperty(szProp);
      if (!m_pOldAttrList->HasProperty(szProp))
      {
        delete pAttr;
      }
    }
  }
}

void CADSIEditPropertyPage::SetAttrList(CAttrList* pAttrList)
{
  ASSERT(pAttrList != NULL);
  m_pOldAttrList = pAttrList;
}

void CADSIEditPropertyPage::OnSelChangePropList()
{
    // Filter the properties list
    //
    FillAttrList();
    OnSelChangeAttrList();
}

void CADSIEditPropertyPage::OnSelChangeAttrList()
{
    CComboBox* pPropertyBox = (CComboBox*)GetDlgItem(IDC_PROP_BOX);

    int idx, iCount;
    CString s;
    HRESULT hr;

  idx = pPropertyBox->GetCurSel();
    
    // Make sure a property was selected
    //
    if ( idx == LB_ERR )
    {
        return;
    }

    pPropertyBox->GetLBText( idx, s );

    // Have the attribute editor display the values for the new property
    //
    m_attrEditor.SetAttribute(s, m_sPath);
}

BOOL CADSIEditPropertyPage::GetProperties()
{
    CString schema;

    //Get the class object so that we can get the properties
    //
    if (!m_pConnectData->IsRootDSE()) // Not RootDSE
    {
        m_pConnectData->GetAbstractSchemaPath(schema);
        schema += m_sClass;

        // bind to object with authentication
        //
        CComPtr<IADsClass> pClass;
        HRESULT hr, hCredResult;
        hr = OpenObjectWithCredentials(
                                                 m_pConnectData, 
                                                 m_pConnectData->GetCredentialObject()->UseCredentials(),
                                                 schema,
                                                 IID_IADsClass, 
                                                 (LPVOID*) &pClass,
                                                 GetSafeHwnd(),
                                                 hCredResult
                                                );
        if ( FAILED(hr) )
        {
            if (SUCCEEDED(hCredResult))
            {
                ADSIEditErrorMessage(hr);
            }
            return FALSE;
        }

        // Get the Mandatory Properties
        //
        VARIANT var;
        VariantInit(&var);
        hr = pClass->get_MandatoryProperties(&var);
        if ( FAILED(hr) )
        {
            ADSIEditErrorMessage(hr);
            return FALSE;
        }
        VariantToStringList( var, m_sMandatoryAttrList );
        VariantClear(&var); 

        // Remove the nTSecurityDescriptor from the list because the aclEditor replaces it for ui purposes
        //
        m_sMandatoryAttrList.RemoveAt(m_sMandatoryAttrList.Find(_T("nTSecurityDescriptor")));

        // Get the Optional Properties
        //
        VariantInit(&var);
        hr = pClass->get_OptionalProperties(&var);
        if ( FAILED(hr) )
        {
            ADSIEditErrorMessage(hr);
            return FALSE;
        }
        VariantToStringList( var, m_sOptionalAttrList );
        VariantClear(&var);
    }
    else        // RootDSE
    {
        int idx=0;

        // Add in the predefined attributes for the RootDSE
        //
        while( g_ldapRootDSESyntax[idx].lpszAttr )
        {
            m_sMandatoryAttrList.AddTail(g_ldapRootDSESyntax[idx].lpszAttr);
            idx++;
        }
    }
    return TRUE;
}

void CADSIEditPropertyPage::FillAttrList()
{
    CComboBox* pPropSelectBox = (CComboBox*)GetDlgItem(IDC_PROPTYPES_BOX);
    CComboBox* pPropertyBox = (CComboBox*)GetDlgItem(IDC_PROP_BOX);
    POSITION pos;
    CString s;

    // Clean out the property box
    //
    int iCount = pPropertyBox->GetCount();
    while (iCount > 0)
    {
        pPropertyBox->DeleteString(0);
        iCount--;
    }

    // Get the filter to use
    //
  int idx = pPropSelectBox->GetCurSel();
    if ( idx == LB_ERR )
    {
        return;
    }

    // Fill in the property box using the filter
    //
    if (idx == IDS_BOTH - IDS_MANDATORY)
    {
        AddPropertiesToBox(TRUE, TRUE);
    }
    else if (idx == IDS_MANDATORY - IDS_MANDATORY)
    {
        AddPropertiesToBox(TRUE, FALSE);
    }
    else
    {
        AddPropertiesToBox(FALSE, TRUE);
    }
    pPropertyBox->SetCurSel(0);
}

void CADSIEditPropertyPage::AddPropertiesToBox(BOOL bMand, BOOL bOpt)
{
    CComboBox* pPropertyBox = (CComboBox*)GetDlgItem(IDC_PROP_BOX);

    POSITION pos;

    if (bMand)
    {
        // Add Mandatory Properties
        //
        pos = m_sMandatoryAttrList.GetHeadPosition();
        while( pos != NULL )
        {
            CString s = m_sMandatoryAttrList.GetNext(pos);
        
            if ( !s.IsEmpty())
            {
                pPropertyBox->AddString( s );
            }
        }
    }

    if (bOpt)
    {
        // Add Optional Properties
        //
        pos = m_sOptionalAttrList.GetHeadPosition();
        while( pos != NULL )
        {
            CString s = m_sOptionalAttrList.GetNext(pos);
        
            if ( !s.IsEmpty())
            {
                pPropertyBox->AddString( s );
            }
        }
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////

CADSIEditPropertyPageHolder::CADSIEditPropertyPageHolder(CADSIEditContainerNode* pContainerNode, 
            CTreeNode* pThisNode,   CComponentDataObject* pComponentData, 
            LPCWSTR lpszClass, LPCWSTR lpszServer, LPCWSTR lpszPath) 
            : CPropertyPageHolderBase(pContainerNode, pThisNode, pComponentData)
{
    ASSERT(pComponentData != NULL);
    ASSERT(pContainerNode != NULL);

    m_pContainer = pContainerNode;
    ASSERT(pContainerNode == GetContainerNode());
    ASSERT(pThisNode != NULL);
    m_pAclEditorPage = NULL;
    m_bAutoDeletePages = FALSE; // we have the page as embedded member

    m_sPath = lpszPath;
    m_pADs = NULL;

  //
    // This gets the CConnectionData from the ConnectionNode by finding a valid treenode and using its
    //   CADsObject to get the ConnectionNode and then the CConnectionData
    //
    CADSIEditContainerNode* pNode = GetContainerNode();
    CADSIEditConnectionNode* pConnectNode = pNode->GetADsObject()->GetConnectionNode();
    CConnectionData* pConnectData = pConnectNode->GetConnectionData();

    CCredentialObject* pCredObject = pConnectData->GetCredentialObject();

    HRESULT hr, hCredResult;
    hr = OpenObjectWithCredentials(
                                             pConnectData, 
                                             pConnectData->GetCredentialObject()->UseCredentials(),
                                             m_sPath,
                                             IID_IADs, 
                                             (LPVOID*) &m_pADs,
                                             NULL,
                                             hCredResult
                                             );

  if (SUCCEEDED(hr))
  {
    //
    // Create the advanced attribute editor
    //
    hr = ::CoCreateInstance(CLSID_DsAttributeEditor, NULL, CLSCTX_INPROC_SERVER,
                            IID_IDsAttributeEditor, (void**)&m_spIDsAttributeEditor);

    if (SUCCEEDED(hr))
    {
      CString szLDAP;
      pConnectData->GetLDAP(szLDAP);
      CString szServer;
      pConnectData->GetDomainServer(szServer);
      CString szPort;
      pConnectData->GetPort(szPort);

      // NTRAID#NTBUG9-762158-2003/01/12-artm
      // If targeting the GC the server name will be empty.

      CString szProviderServer;
      
      if (!szServer.IsEmpty())
      {
         if (!szPort.IsEmpty())
         {
            szProviderServer = szLDAP + szServer + _T(":") + szPort + _T("/");
         }
         else
         {
            szProviderServer = szLDAP + szServer + _T("/");
         }
      }
      else
      {
         szProviderServer = szLDAP;
      }

      DS_ATTREDITOR_BINDINGINFO attrInfo = {0};
      attrInfo.dwSize = sizeof(DS_ATTREDITOR_BINDINGINFO);
      attrInfo.lpfnBind = BindingCallbackFunction;
      attrInfo.lParam = (LPARAM)pCredObject;
      attrInfo.lpszProviderServer = const_cast<LPWSTR>((LPCWSTR)szProviderServer);

      if (pConnectData->IsRootDSE())
      {
        attrInfo.dwFlags = DSATTR_EDITOR_ROOTDSE;
      }

      if (pConnectData->IsGC())
      {
        attrInfo.dwFlags |= DSATTR_EDITOR_GC;
      }

      hr = m_spIDsAttributeEditor->Initialize(m_pADs, &attrInfo, this);
    }

      if (!pConnectData->IsRootDSE() && !pConnectData->IsGC())
      {

          if (pCredObject->UseCredentials())
          {
              CString szUsername;
              EncryptedString password;
              WCHAR* szPassword = NULL;

              pCredObject->GetUsername(szUsername);
              password = pCredObject->GetPassword();

              // Shouldn't happen, but let's check...
              ASSERT(password.GetLength() <= MAX_PASSWORD_LENGTH);

              szPassword = password.GetClearTextCopy();

              // If we ran out of memory just pass a NULL pwd instead
              // (not much else one can do w/in constructor).

              m_pAclEditorPage = CAclEditorPage::CreateInstanceEx(m_sPath, 
                                          lpszServer,
                                          szUsername,
                                          szPassword,
                                          DSSI_NO_FILTER,
                                          this);

              // Clean up clear text copies (call even if we ran
              // out of memory and cleartext == NULL).
              password.DestroyClearTextCopy(szPassword);
          }
          else
          {
              m_pAclEditorPage = CAclEditorPage::CreateInstanceEx(m_sPath, 
                                          NULL,
                                          NULL,
                                          NULL,
                                          DSSI_NO_FILTER,
                                          this);
          }
    }
  }
  else
  {
      if (!pConnectData->IsRootDSE() && !pConnectData->IsGC())
      {
          if (SUCCEEDED(hCredResult))
          {
        ADSIEditErrorMessage(hr);

        // Create the acl editor even if we were not successful binding, because 
        // the object may be deny read and we would still want the acl editor
              if (pCredObject->UseCredentials())
              {
                  CString szUsername;
                  EncryptedString password;
                  WCHAR* szPassword = NULL;

                  pCredObject->GetUsername(szUsername);
                  password = pCredObject->GetPassword();

                  // Shouldn't happen, but let's check...
                  ASSERT(password.GetLength() <= MAX_PASSWORD_LENGTH);

                  szPassword = password.GetClearTextCopy();

                  // If we ran out of memory just pass a NULL pwd instead
                  // (not much else one can do w/in constructor).

                  m_pAclEditorPage = CAclEditorPage::CreateInstanceEx(m_sPath, 
                                              lpszServer,
                                              szUsername,
                                              szPassword,
                                              DSSI_NO_FILTER,
                                              this);

                  // Clean up clear text copies (call even if we ran
                  // out of memory and cleartext == NULL).
                  password.DestroyClearTextCopy(szPassword);
              }
              else
              {
                  m_pAclEditorPage = CAclEditorPage::CreateInstanceEx(m_sPath, 
                                              NULL,
                                              NULL,
                                              NULL,
                                              DSSI_NO_FILTER,
                                              this);
              }

              return;
          }
    }
  }
}

HRESULT CADSIEditPropertyPageHolder::OnAddPage(int nPage, CPropertyPageBase* pPage)
{
  HRESULT hr = S_OK;

    if (nPage == 0)
  {
    //
    // Add the advanced editor page
    //
    HPROPSHEETPAGE hAttrPage = NULL;

    if (m_spIDsAttributeEditor != NULL)
    {
      hr = m_spIDsAttributeEditor->GetPage(&hAttrPage);
      if (SUCCEEDED(hr))
      {
        hr = AddPageToSheetRaw(hAttrPage);
      }
    }
  }
  else if ( nPage == -1)
  {
    if (m_pAclEditorPage != NULL)
    {
      //
        // add the ACL editor page after the last, if present
      //
        HPROPSHEETPAGE  hPage = m_pAclEditorPage->CreatePage();
        if (hPage == NULL)
      {
            return E_FAIL;
      }
      //
        // add the raw HPROPSHEETPAGE to sheet, not in the list
      //
        hr = AddPageToSheetRaw(hPage);
    }
  }
  return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

CCreateWizPropertyPageHolder::CCreateWizPropertyPageHolder(CADSIEditContainerNode* pContainerNode, 
            CComponentDataObject* pComponentData,   LPCWSTR lpszClass, LPCWSTR lpszServer, CAttrList* pAttrList) 
            : CPropertyPageHolderBase(pContainerNode, NULL, pComponentData), m_propPage(pAttrList)
{
    ASSERT(pComponentData != NULL);
    ASSERT(pContainerNode != NULL);

    m_pContainer = pContainerNode;
    ASSERT(pContainerNode == GetContainerNode());
    m_bAutoDeletePages = FALSE; // we have the page as embedded member

    m_propPage.SetClass(lpszClass);
    m_propPage.SetServer(lpszServer);
  m_propPage.SetConnectionData(pContainerNode->GetADsObject()->GetConnectionNode()->GetConnectionData());
    AddPageToList((CPropertyPageBase*)&m_propPage);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\editui.h ===
#ifndef __ATTRIBUTE_EDITOR_UI_H
#define __ATTRIBUTE_EDITOR_UI_H

#include "resource.h"
#include "attrres.h"

#include "attr.h"
#include "IAttrEdt.h"

////////////////////////////////////////////////////////////////////
// CValueEditDialog - base class for creating syntax specific editors

class CValueEditDialog : public CDialog
{
public:
  virtual ~CValueEditDialog() {}

protected:
  //
  // Force subclassing of this class
  //
  CValueEditDialog(UINT nDlgID) : CDialog(nDlgID) {}

private:
  CValueEditDialog() {}
  CValueEditDialog(const CValueEditDialog& copyref) {}
  CValueEditDialog& operator=(const CValueEditDialog& copyref) {}

public:
  virtual HRESULT Initialize(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo);
  virtual HRESULT GetNewValue(PADSVALUE* ppADsValue, DWORD* pdwNumValues);

  DECLARE_MESSAGE_MAP();

protected:
  void GetClass(CString& szClassRef) { szClassRef = m_szClass; }
  void GetAttribute(CString& szAttributeRef) { szAttributeRef = m_szAttribute; }
  BOOL IsMultivalued() { return m_bMultivalued; }
  LPBINDINGFUNC GetBindingFunction() { return m_pfnBindingFunction; }
  LPARAM GetLParam() { return m_lParam; }

  PADSVALUE     m_pOldADsValue;
  DWORD         m_dwOldNumValues;

  CString       m_szClass;
  CString       m_szAttribute;
  BOOL          m_bMultivalued;
  BOOL          m_bReadOnly;
  ADSTYPE       m_adsType;
  LPBINDINGFUNC m_pfnBindingFunction;
  LPARAM        m_lParam;
};

////////////////////////////////////////////////////////////////////
// LPEDITORDIALOGFUNC - editor creation function definition

typedef CValueEditDialog* (*LPEDITORDIALOGFUNC)(PCWSTR pszClass,
                                                PCWSTR pszAttribute,
                                                ADSTYPE adsType,
                                                BOOL   bMultivalued);

////////////////////////////////////////////////////////////////////
// ATTR_EDITOR_MAP - struct used to map a specific attribute and
//                   syntax to an editor

typedef struct _attr_editor_map
{
  PCWSTR  pszClass;
  PCWSTR  pszAttribute;
  ADSTYPE adsType;
  BOOL    bMultivalued;
  LPEDITORDIALOGFUNC pfnCreateFunc;
} ATTR_EDITOR_MAP, *PATTR_EDITOR_MAP;


////////////////////////////////////////////////////////////////////
// CSingleStringEditor - string editor implementation for single valued
//                       ADSTYPE_CASE_IGNORE_STRING, 
//                       ADSTYPE_CASE_EXACT_STRING,
//                       ADSTYPE_PRINTABLE_STRING
//

class CSingleStringEditor : public CValueEditDialog
{
public:
  CSingleStringEditor() : CValueEditDialog(IDD_STRING_EDITOR_DIALOG)
  {}

  virtual BOOL OnInitDialog();
  virtual void OnOK();

  afx_msg void OnClear();

  DECLARE_MESSAGE_MAP();

public:
  virtual HRESULT Initialize(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo);
  virtual HRESULT GetNewValue(PADSVALUE* ppADsValue, DWORD* pdwNumValues);

private:
  CString   m_szOldValue;
  CString   m_szNewValue;
};

CValueEditDialog* CreateSingleStringEditor(PCWSTR pszClass,
                                           PCWSTR pszAttribute,
                                           ADSTYPE adsType,
                                           BOOL bMultivalued);

////////////////////////////////////////////////////////////////////
// CMultiStringEditor - string editor implementation for multivalued
//                      ADSTYPE_CASE_IGNORE_STRING, 
//                      ADSTYPE_CASE_EXACT_STRING,
//                      ADSTYPE_PRINTABLE_STRING
//

class CMultiStringEditor : public CValueEditDialog
{
public:
  CMultiStringEditor() : CValueEditDialog(IDD_STRING_EDITOR_MULTI_DIALOG)
  {}

  virtual BOOL OnInitDialog();
  virtual void OnOK();

  afx_msg void OnAddButton();
  afx_msg void OnRemoveButton();
  afx_msg void OnListSelChange();
  afx_msg void OnEditChange();

  DECLARE_MESSAGE_MAP();

public:
  virtual HRESULT Initialize(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo);
  virtual HRESULT GetNewValue(PADSVALUE* ppADsValue, DWORD* pdwNumValues);

protected:
  void UpdateListboxHorizontalExtent();
  void ManageButtonStates();

private:
  CStringList   m_szOldValueList;
  CStringList   m_szNewValueList;
};

CValueEditDialog* CreateMultiStringEditor(PCWSTR pszClass,
                                           PCWSTR pszAttribute,
                                           ADSTYPE adsType,
                                           BOOL bMultivalued);

////////////////////////////////////////////////////////////////////
// CSingleIntEditor - string editor implementation for single valued
//                    ADSTYPE_INTEGER
//

class CSingleIntEditor : public CValueEditDialog
{
public:
  CSingleIntEditor() : CValueEditDialog(IDD_INT_EDITOR_DIALOG)
  {
    m_bValueSet = FALSE;
  }

  virtual BOOL OnInitDialog();
  virtual void OnOK();

  afx_msg void OnClear();

  DECLARE_MESSAGE_MAP();

public:
  virtual HRESULT Initialize(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo);
  virtual HRESULT GetNewValue(PADSVALUE* ppADsValue, DWORD* pdwNumValues);

private:
  DWORD   m_dwOldValue;
  DWORD   m_dwNewValue;
  BOOL    m_bValueSet;
};

CValueEditDialog* CreateSingleIntEditor(PCWSTR pszClass,
                                        PCWSTR pszAttribute,
                                        ADSTYPE adsType,
                                        BOOL bMultivalued);

////////////////////////////////////////////////////////////////////
// CMultiIntEditor - string editor implementation for multivalued
//                      ADSTYPE_INTEGER, 
//

class CMultiIntEditor : public CValueEditDialog
{
public:
  CMultiIntEditor() : CValueEditDialog(IDD_STRING_EDITOR_MULTI_DIALOG)
  {}

  virtual BOOL OnInitDialog();
  virtual void OnOK();

  afx_msg void OnAddButton();
  afx_msg void OnRemoveButton();
  afx_msg void OnListSelChange();
  afx_msg void OnEditChange();

  DECLARE_MESSAGE_MAP();

public:
  virtual HRESULT Initialize(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo);
  virtual HRESULT GetNewValue(PADSVALUE* ppADsValue, DWORD* pdwNumValues);

protected:
  void UpdateListboxHorizontalExtent();
  void ManageButtonStates();

private:
  CList<int, int>   m_oldValueList;
  CList<int, int>   m_newValueList;
};

CValueEditDialog* CreateMultiIntEditor(PCWSTR pszClass,
                                       PCWSTR pszAttribute,
                                       ADSTYPE adsType,
                                       BOOL bMultivalued);

////////////////////////////////////////////////////////////////////
// CSingleLargeIntEditor - string editor implementation for single valued
//                         ADSTYPE_LARGE_INTEGER
//

class CSingleLargeIntEditor : public CValueEditDialog
{
public:
  CSingleLargeIntEditor() : CValueEditDialog(IDD_LARGEINT_EDITOR_DIALOG)
  {
    m_bValueSet = FALSE;
  }

  virtual BOOL OnInitDialog();
  virtual void OnOK();

  afx_msg void OnClear();

  DECLARE_MESSAGE_MAP();

public:
  virtual HRESULT Initialize(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo);
  virtual HRESULT GetNewValue(PADSVALUE* ppADsValue, DWORD* pdwNumValues);

private:
  LARGE_INTEGER   m_liOldValue;
  LARGE_INTEGER   m_liNewValue;
  BOOL            m_bValueSet;
};

CValueEditDialog* CreateSingleLargeIntEditor(PCWSTR pszClass,
                                             PCWSTR pszAttribute,
                                             ADSTYPE adsType,
                                             BOOL bMultivalued);

////////////////////////////////////////////////////////////////////
// CSingleBooleanEditor - editor implementation for single valued
//                        ADSTYPE_BOOLEAN
//

class CSingleBooleanEditor : public CValueEditDialog
{
public:
  CSingleBooleanEditor() : CValueEditDialog(IDD_BOOLEAN_EDITOR_DIALOG)
  {}

  virtual BOOL OnInitDialog();
  virtual void OnOK();

  DECLARE_MESSAGE_MAP();

public:
  virtual HRESULT Initialize(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo);
  virtual HRESULT GetNewValue(PADSVALUE* ppADsValue, DWORD* pdwNumValues);

private:
  BOOL  m_bOldValue;
  BOOL  m_bNewValue;
  BOOL  m_bValueSet;
};

CValueEditDialog* CreateSingleBooleanEditor(PCWSTR pszClass,
                                            PCWSTR pszAttribute,
                                            ADSTYPE adsType,
                                            BOOL bMultivalued);

////////////////////////////////////////////////////////////////////
// CMultiBooleanEditor - boolean editor implementation for multivalued
//                       ADSTYPE_BOOLEAN
//

class CMultiBooleanEditor : public CValueEditDialog
{
public:
  CMultiBooleanEditor() : CValueEditDialog(IDD_BOOLEAN_EDITOR_MULTI_DIALOG)
  {}

  virtual BOOL OnInitDialog();
  virtual void OnOK();

  afx_msg void OnAddButton();
  afx_msg void OnRemoveButton();
  afx_msg void OnListSelChange();
  afx_msg void OnRadioChange();

  DECLARE_MESSAGE_MAP();

public:
  virtual HRESULT Initialize(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo);
  virtual HRESULT GetNewValue(PADSVALUE* ppADsValue, DWORD* pdwNumValues);

protected:
  void UpdateListboxHorizontalExtent();
  void ManageButtonStates();

private:
  CList<BOOL, BOOL>   m_bOldValueList;
  CList<BOOL, BOOL>   m_bNewValueList;
};

CValueEditDialog* CreateMultiBooleanEditor(PCWSTR pszClass,
                                           PCWSTR pszAttribute,
                                           ADSTYPE adsType,
                                           BOOL bMultivalued);


////////////////////////////////////////////////////////////////////
// CSingleTimeEditor - editor implementation for single valued
//                     ADSTYPE_UTC_TIME
//

class CSingleTimeEditor : public CValueEditDialog
{
public:
  CSingleTimeEditor() : CValueEditDialog(IDD_TIME_EDITOR_DIALOG)
  {
    memset(&m_stOldValue, 0, sizeof(SYSTEMTIME));
    memset(&m_stNewValue, 0, sizeof(SYSTEMTIME));
    m_bValueSet = FALSE;
  }

  virtual BOOL OnInitDialog();
  virtual void OnOK();

  DECLARE_MESSAGE_MAP();

public:
  virtual HRESULT Initialize(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo);
  virtual HRESULT GetNewValue(PADSVALUE* ppADsValue, DWORD* pdwNumValues);

private:
  SYSTEMTIME    m_stOldValue;
  SYSTEMTIME    m_stNewValue;
  BOOL          m_bValueSet;
};

CValueEditDialog* CreateSingleTimeEditor(PCWSTR pszClass,
                                         PCWSTR pszAttribute,
                                         ADSTYPE adsType,
                                         BOOL bMultivalued);


////////////////////////////////////////////////////////////////////
// CMultiTimeEditor - time editor implementation for multivalued
//                       ADSTYPE_UTC_TIME
//

class CMultiTimeEditor : public CValueEditDialog
{
public:
  CMultiTimeEditor() : CValueEditDialog(IDD_TIME_EDITOR_MULTI_DIALOG)
  {}

  virtual BOOL OnInitDialog();
  virtual void OnOK();

  afx_msg void OnAddButton();
  afx_msg void OnRemoveButton();
  afx_msg void OnListSelChange();

  DECLARE_MESSAGE_MAP();

public:
  virtual HRESULT Initialize(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo);
  virtual HRESULT GetNewValue(PADSVALUE* ppADsValue, DWORD* pdwNumValues);

protected:
  void UpdateListboxHorizontalExtent();
  void ManageButtonStates();

private:
  CList<SYSTEMTIME*, SYSTEMTIME*>   m_stOldValueList;
  CList<SYSTEMTIME*, SYSTEMTIME*>   m_stNewValueList;
};

CValueEditDialog* CreateMultiTimeEditor(PCWSTR pszClass,
                                        PCWSTR pszAttribute,
                                        ADSTYPE adsType,
                                        BOOL bMultivalued);


////////////////////////////////////////////////////////////////////
// COctetStringEditor - editor implementation for single valued
//                      ADSTYPE_OCTET_STRING
//

#define MAX_OCTET_STRING_VALUE_LENGTH 200

class COctetStringEditor : public CValueEditDialog
{
public:
  COctetStringEditor() : CValueEditDialog(IDD_OCTET_STRING_EDITOR_DIALOG)
  {
    m_dwOldLength = 0;
    m_pOldValue   = NULL;
    m_dwNewLength = 0;
    m_pNewValue   = NULL;

    m_bValueSet = FALSE;
  }

  ~COctetStringEditor()
  {
    if (m_pOldValue)
    {
      delete[] m_pOldValue;
      m_pOldValue = 0;
    }

    if (m_pNewValue)
    {
      delete[] m_pNewValue;
      m_pNewValue = 0;
    }
  }

  virtual BOOL OnInitDialog();
  virtual void OnOK();

  afx_msg void OnProcessEdit();
  afx_msg void OnEditButton();
  afx_msg void OnClearButton();

  DECLARE_MESSAGE_MAP();

public:
  virtual HRESULT Initialize(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo);
  virtual HRESULT GetNewValue(PADSVALUE* ppADsValue, DWORD* pdwNumValues);

private:
  DWORD         m_dwOldLength;
  BYTE*         m_pOldValue;
  DWORD         m_dwNewLength;
  BYTE*         m_pNewValue;
  BOOL          m_bValueSet;

  CByteArrayDisplay m_display;
};

CValueEditDialog* CreateSingleOctetStringEditor(PCWSTR pszClass,
                                                 PCWSTR pszAttribute,
                                                 ADSTYPE adsType,
                                                 BOOL bMultivalued);

////////////////////////////////////////////////////////////////////
// CMultiOctetStringEditor - octet string editor for multivalued
//                           ADSTYPE_OCTET_STRING, 
//

class CMultiOctetStringEditor : public CValueEditDialog
{
public:
  CMultiOctetStringEditor() : CValueEditDialog(IDD_OCTET_STRING_EDITOR_MULTI_DIALOG)
  {}

  virtual BOOL OnInitDialog();
  virtual void OnOK();

  afx_msg void OnAddButton();
  afx_msg void OnRemoveButton();
  afx_msg void OnEditButton();
  afx_msg void OnListSelChange();

  DECLARE_MESSAGE_MAP();

public:
  virtual HRESULT Initialize(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo);
  virtual HRESULT GetNewValue(PADSVALUE* ppADsValue, DWORD* pdwNumValues);

protected:
  void UpdateListboxHorizontalExtent();
  void ManageButtonStates();

private:
  CList<PADSVALUE, PADSVALUE>   m_OldValueList;
  CList<PADSVALUE, PADSVALUE>   m_NewValueList;
};

CValueEditDialog* CreateMultiOctetStringEditor(PCWSTR pszClass,
                                               PCWSTR pszAttribute,
                                               ADSTYPE adsType,
                                               BOOL bMultivalued);

////////////////////////////////////////////////////////////////////
// CDNWithStringEditor - DN with String editor for editing
//                       ADSTYPE_DN_WITH_STRING 
//

class CDNWithStringEditor : public CValueEditDialog
{
public:
  CDNWithStringEditor() : CValueEditDialog(IDD_DN_WITH_STRING_EDITOR_DIALOG)
  {}

  virtual BOOL OnInitDialog();
  virtual void OnOK();

  afx_msg void OnClear();

  DECLARE_MESSAGE_MAP();

public:
  virtual HRESULT Initialize(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo);
  virtual HRESULT GetNewValue(PADSVALUE* ppADsValue, DWORD* pdwNumValues);

private:
  CString   m_OldDNValue;
  CString   m_OldStringValue;

  CString   m_NewDNValue;
  CString   m_NewStringValue;
};

CValueEditDialog* CreateDNWithStringEditor(PCWSTR pszClass,
                                           PCWSTR pszAttribute,
                                           ADSTYPE adsType,
                                           BOOL bMultivalued);

////////////////////////////////////////////////////////////////////
// CAttributeEditorPropertyPage - attribute editor property pages

class CAttributeEditorPropertyPage : public CPropertyPage
{
public:
  CAttributeEditorPropertyPage(IADs* pIADs, 
                         IADsClass* pIADsClass, 
                         LPDS_ATTREDITOR_BINDINGINFO pBindingInfo,
                         CADSIEditPropertyPageHolder* pHolder);
  ~CAttributeEditorPropertyPage();

  virtual BOOL OnInitDialog();
  virtual BOOL OnApply();
  virtual void OnDestroy();
  virtual int  OnCreate(LPCREATESTRUCT lpCreateStruct);

  afx_msg void OnMandatoryCheck();
  afx_msg void OnOptionalCheck();
  afx_msg void OnValueSetCheck();
  afx_msg void OnEditAttribute();
  afx_msg void OnSortList(NMHDR* pNotifyStruct, LRESULT* result);
  afx_msg void OnNotifyEditAttribute(NMHDR* pNotifyStruct, LRESULT* result);
  afx_msg void OnListItemChanged(NMHDR* pNotifyStruct, LRESULT* result);

  CADSIAttribute* GetAttributeFromList(int iSelectedItem);
  HRESULT GetAttributeInfo(CADSIAttribute& pAttr, 
                           LPDS_ATTRIBUTE_EDITORINFO* ppAttributeEditorInfo,
                           BOOL* pbOwnValueMemory);
  void    EditAttribute(CADSIAttribute* pSelectedAttr);
  void    ShowListCtrl();
  HRESULT GetSchemaNamingContext();
  HRESULT RetrieveAttributes();
  bool    IsRangeOfValues(PCWSTR pszAttrName, 
                          CString& szAttrBase, 
                          DWORD& rangeStart, 
                          DWORD& rangeEnd);
  void    FillListControl();
  void    SetEditButton();
  HRESULT CreateAttributeList(CStringList& sList, BOOL bMandatory);
  ADSTYPE RetrieveADsTypeFromSyntax(LPCWSTR lpszAttribute, BOOL* pbMultivalued, CString& szSyntax);

  CValueEditDialog* RetrieveEditor(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo);

  UINT    GetSortColumn() { return m_nSortColumn; }

  DECLARE_MESSAGE_MAP()

private:
  CComPtr<IADs>      m_spIADs;
  CComPtr<IADsClass> m_spIADsClass;

  BOOL    m_bMandatory;
  BOOL    m_bOptional;
  BOOL    m_bSet;

  UINT    m_nSortColumn;

  CAttrList2 m_AttrList;
  CStringList m_RootDSEValueList;

  CString m_szClass;
  CString m_szPrefix;
  CString m_szSchemaNamingContext;

  LPARAM  m_BindLPARAM;
  LPBINDINGFUNC m_pfnBind;
  DWORD   m_dwBindFlags;

  CADSIEditPropertyPageHolder* m_pHolder;
};

#endif //__ATTRIBUTE_EDITOR_UI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\editui.cpp ===
#include "pch.h"
#include <SnapBase.h>

#include "resource.h"
#include "query.h"
#include "attrres.h"
#include "editui.h"
#include "common.h"
#include "attrqry.h"
#include "editorui.h"

////////////////////////////////////////////////////////////////////////////
// this is used to fill in the attributes for RootDSE
//
typedef struct tagRootDSEAttr
{
   LPCWSTR  lpszAttr;
   LPCWSTR  lpszSyntax;  
   BOOL     bMulti;
} SYNTAXMAP;

extern SYNTAXMAP g_ldapRootDSESyntax[];


// Helper function to delete a set of ADSVALUEs
void DeleteADsValues(PADSVALUE pADsValue, DWORD valueCount)
{
   if (!pADsValue)
   {
      return;
   }

   for (DWORD idx = 0; idx < valueCount; ++idx)
   {
      switch (pADsValue[idx].dwType)
      {
         case ADSTYPE_DN_STRING:
            if (pADsValue[idx].DNString)
            {
               delete[] pADsValue[idx].DNString;
            }
            break;

         case ADSTYPE_CASE_EXACT_STRING:
            if (pADsValue[idx].CaseExactString)
            {
               delete[] pADsValue[idx].CaseExactString;
            }
            break;

         case ADSTYPE_CASE_IGNORE_STRING:
            if (pADsValue[idx].CaseIgnoreString)
            {
               delete[] pADsValue[idx].CaseIgnoreString;
            }
            break;

         case ADSTYPE_PRINTABLE_STRING:
            if (pADsValue[idx].PrintableString)
            {
               delete[] pADsValue[idx].PrintableString;
            }
            break;

         case ADSTYPE_NUMERIC_STRING:
            if (pADsValue[idx].NumericString)
            {
               delete[] pADsValue[idx].NumericString;
            }
            break;

         case ADSTYPE_OCTET_STRING:
            if (pADsValue[idx].OctetString.lpValue)
            {
               delete[] pADsValue[idx].OctetString.lpValue;
            }
            break;

         case ADSTYPE_DN_WITH_STRING:
            if (pADsValue[idx].pDNWithString)
            {
               if (pADsValue[idx].pDNWithString->pszStringValue)
               {
                  delete[] pADsValue[idx].pDNWithString->pszStringValue;
               }

               if (pADsValue[idx].pDNWithString->pszDNString)
               {
                  delete[] pADsValue[idx].pDNWithString->pszDNString;
               }

               delete pADsValue[idx].pDNWithString;
            }
            break;

         case ADSTYPE_BOOLEAN:
         case ADSTYPE_INTEGER:
         case ADSTYPE_UTC_TIME:
         case ADSTYPE_LARGE_INTEGER:
         case ADSTYPE_CASEIGNORE_LIST:
         case ADSTYPE_OCTET_LIST:
         case ADSTYPE_PATH:
         case ADSTYPE_POSTALADDRESS:
         case ADSTYPE_TIMESTAMP:
         case ADSTYPE_BACKLINK:
         case ADSTYPE_TYPEDNAME:
         case ADSTYPE_HOLD:
         case ADSTYPE_NETADDRESS:
         case ADSTYPE_REPLICAPOINTER:
         case ADSTYPE_FAXNUMBER:
         case ADSTYPE_EMAIL:
         case ADSTYPE_DN_WITH_BINARY:
         default:
            // Do nothing, we didn't allocate any memory for these other types
            break;
      }
   }

   if (valueCount < 2)
   {
      delete pADsValue;
   }
   else
   {
      delete[] pADsValue;
   }
}

///////////////////////////////////////////////////////////////////////////////////////
// CValueEditDialog

BEGIN_MESSAGE_MAP(CValueEditDialog, CDialog)
END_MESSAGE_MAP()

HRESULT CValueEditDialog::Initialize(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo)
{
  HRESULT hr = S_OK;

  m_pOldADsValue    = pAttributeEditorInfo->pADsValue;
  m_dwOldNumValues  = pAttributeEditorInfo->dwNumValues;
  m_szClass         = pAttributeEditorInfo->lpszClass;
  m_szAttribute     = pAttributeEditorInfo->lpszAttribute;
  m_bMultivalued    = pAttributeEditorInfo->bMultivalued;
  m_bReadOnly       = pAttributeEditorInfo->bReadOnly;
  m_pfnBindingFunction = pAttributeEditorInfo->lpfnBind;
  m_lParam          = pAttributeEditorInfo->lParam;

  return hr;
}

HRESULT CValueEditDialog::GetNewValue(PADSVALUE* ppADsValue, DWORD* pdwNumValues)
{
  HRESULT hr = S_OK;

  if (ppADsValue == NULL ||
      pdwNumValues == NULL)
  {
    return E_OUTOFMEMORY;
  }

  *ppADsValue = NULL;
  *pdwNumValues = 0;
  return hr;
}


///////////////////////////////////////////////////////////////////////////////////////
// CSingleStringEditor

CValueEditDialog* CreateSingleStringEditor(PCWSTR pszClass,
                                           PCWSTR pszAttribute,
                                           ADSTYPE adsType,
                                           BOOL bMultivalued)
{
  return new CSingleStringEditor;
}

BEGIN_MESSAGE_MAP(CSingleStringEditor, CValueEditDialog)
  ON_BN_CLICKED(IDC_CLEAR_BUTTON, OnClear)
END_MESSAGE_MAP()

BOOL CSingleStringEditor::OnInitDialog()
{
  //
  // Initialize the static control with the attribute name
  //
  SetDlgItemText(IDC_ATTRIBUTE_STATIC, m_szAttribute);

  //
  // Initialize the edit box with the value
  //
  if (m_szOldValue.IsEmpty())
  {
    CString szNotSet;
    VERIFY(szNotSet.LoadString(IDS_NOTSET));
    SetDlgItemText(IDC_VALUE_EDIT, szNotSet);
  }
  else
  {
    SetDlgItemText(IDC_VALUE_EDIT, m_szOldValue);
  }

  //
  // Select the text in the edit box
  //
  SendDlgItemMessage(IDC_VALUE_EDIT, EM_SETSEL, 0, -1);

  if (m_bReadOnly)
  {
    SendDlgItemMessage(IDC_VALUE_EDIT, EM_SETREADONLY, TRUE, 0);
  }

  return CDialog::OnInitDialog();
}

void CSingleStringEditor::OnOK()
{
  GetDlgItemText(IDC_VALUE_EDIT, m_szNewValue);

  CDialog::OnOK();
}

HRESULT CSingleStringEditor::Initialize(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo)
{
  HRESULT hr = S_OK;

  if (SUCCEEDED(CValueEditDialog::Initialize(pAttributeEditorInfo)))
  {
    if (pAttributeEditorInfo->dwNumValues > 0 &&
        pAttributeEditorInfo->pADsValue != NULL)
    {
      switch (pAttributeEditorInfo->pADsValue->dwType)
      {
        case ADSTYPE_CASE_IGNORE_STRING:
          m_szOldValue = pAttributeEditorInfo->pADsValue->CaseIgnoreString;
          break;

        case ADSTYPE_CASE_EXACT_STRING:
          m_szOldValue = pAttributeEditorInfo->pADsValue->CaseExactString;
          break;

        case ADSTYPE_PRINTABLE_STRING:
          m_szOldValue = pAttributeEditorInfo->pADsValue->PrintableString;
          break;

        case ADSTYPE_DN_STRING:
          m_szOldValue = pAttributeEditorInfo->pADsValue->DNString;
          break;

        default:
          ASSERT(FALSE);
          break;
      }
    }
  }
  return hr;
}

void CSingleStringEditor::OnClear()
{
  //
  // Change the text in the edit box to "<not set>"
  //
  CString szNotSet;
  VERIFY(szNotSet.LoadString(IDS_NOTSET));
  SetDlgItemText(IDC_VALUE_EDIT, szNotSet);

  //
  // Change the focus to the edit box
  //
  GetDlgItem(IDC_VALUE_EDIT)->SetFocus();

  //
  // Select the text in the edit box
  //
  SendDlgItemMessage(IDC_VALUE_EDIT, EM_SETSEL, 0, -1);
}

HRESULT CSingleStringEditor::GetNewValue(PADSVALUE* ppADsValue, DWORD* pdwNumValues)
{
  HRESULT hr = S_OK;

  if (ppADsValue == NULL ||
      pdwNumValues == NULL)
  {
    return E_OUTOFMEMORY;
  }

  CString szNotSet;
  VERIFY(szNotSet.LoadString(IDS_NOTSET));

  if (m_szNewValue == szNotSet)
  {
    *ppADsValue = NULL;
    *pdwNumValues = 0;
  }
  else
  {
    *ppADsValue = new ADSVALUE;
    if (*ppADsValue != NULL)
    {
      *pdwNumValues = 1;
      (*ppADsValue)->dwType = m_pOldADsValue->dwType;
      switch (m_pOldADsValue->dwType)
      {
        case ADSTYPE_CASE_IGNORE_STRING:
          (*ppADsValue)->CaseIgnoreString = new WCHAR[wcslen(m_szNewValue) + 1];
          if ((*ppADsValue)->CaseIgnoreString != NULL)
          {
           // NOTICE-2002/03/05-artm  wcscpy() OK.
           // Both args are allocated the same amount of memory.
            wcscpy((*ppADsValue)->CaseIgnoreString, m_szNewValue);
          }
          else
          {
            DeleteADsValues(*ppADsValue, *pdwNumValues);
            *ppADsValue = NULL;
            *pdwNumValues = 0;
            hr = E_OUTOFMEMORY;
          }
          break;

        case ADSTYPE_CASE_EXACT_STRING:
          (*ppADsValue)->CaseExactString = new WCHAR[wcslen(m_szNewValue) + 1];
          if ((*ppADsValue)->CaseExactString != NULL)
          {
           // NOTICE-2002/03/05-artm  wcscpy() OK.
           // Both args are allocated the same amount of memory.
            wcscpy((*ppADsValue)->CaseExactString, m_szNewValue);
          }
          else
          {
            DeleteADsValues(*ppADsValue, *pdwNumValues);
            *ppADsValue = NULL;
            *pdwNumValues = 0;
            hr = E_OUTOFMEMORY;
          }
          break;

        case ADSTYPE_PRINTABLE_STRING:
          (*ppADsValue)->PrintableString = new WCHAR[wcslen(m_szNewValue) + 1];
          if ((*ppADsValue)->PrintableString != NULL)
          {
           // NOTICE-2002/03/05-artm  wcscpy() OK.
           // Both args are allocated the same amount of memory.
            wcscpy((*ppADsValue)->PrintableString, m_szNewValue);
          }
          else
          {
            DeleteADsValues(*ppADsValue, *pdwNumValues);
            *ppADsValue = NULL;
            *pdwNumValues = 0;
            hr = E_OUTOFMEMORY;
          }
          break;

        case ADSTYPE_DN_STRING:
          (*ppADsValue)->DNString = new WCHAR[wcslen(m_szNewValue) + 1];
          if ((*ppADsValue)->DNString != NULL)
          {
           // NOTICE-2002/03/05-artm  wcscpy() OK.
           // Both args are allocated the same amount of memory.
            wcscpy((*ppADsValue)->DNString, m_szNewValue);
          }
          else
          {
            DeleteADsValues(*ppADsValue, *pdwNumValues);
            *ppADsValue = NULL;
            *pdwNumValues = 0;
            hr = E_OUTOFMEMORY;
          }
          break;

        default:
          ASSERT(FALSE);
 
          DeleteADsValues(*ppADsValue, *pdwNumValues);
          *ppADsValue = NULL;
          *pdwNumValues = 0;
          hr = E_FAIL;
          break;
      }
    }
    else
    {
      *pdwNumValues = 0;
      hr = E_OUTOFMEMORY;
    }
  }
  return hr;
}

///////////////////////////////////////////////////////////////////////////////////////
// CMultiStringEditor

CValueEditDialog* CreateMultiStringEditor(PCWSTR pszClass,
                                           PCWSTR pszAttribute,
                                           ADSTYPE adsType,
                                           BOOL bMultivalued)
{
  return new CMultiStringEditor;
}

BEGIN_MESSAGE_MAP(CMultiStringEditor, CValueEditDialog)
  ON_BN_CLICKED(IDC_ATTR_ADD_BUTTON, OnAddButton)
  ON_BN_CLICKED(IDC_ATTR_REMOVE_BUTTON, OnRemoveButton)
  ON_LBN_SELCHANGE(IDC_VALUE_LIST, OnListSelChange)
  ON_EN_CHANGE(IDC_VALUE_EDIT, OnEditChange)
END_MESSAGE_MAP()

BOOL CMultiStringEditor::OnInitDialog()
{
  CDialog::OnInitDialog();

  //
  // Set the attribute name static
  //
  SetDlgItemText(IDC_ATTRIBUTE_STATIC, m_szAttribute);

  //
  // Fill the list box with the current values
  //
  POSITION pos = m_szOldValueList.GetHeadPosition();
  while (pos != NULL)
  {
    CString szValue = m_szOldValueList.GetNext(pos);
    if (!szValue.IsEmpty())
    {
      SendDlgItemMessage(IDC_VALUE_LIST, LB_ADDSTRING, 0, (LPARAM)(LPCWSTR)szValue);
    }
  }

  //
  // The remove button should be disabled until something is selected in the listbox
  //
  GetDlgItem(IDC_ATTR_REMOVE_BUTTON)->EnableWindow(FALSE);
  GetDlgItem(IDC_VALUE_EDIT)->SetFocus();

  ManageButtonStates();

  //
  // Update the width of the list box
  //
  UpdateListboxHorizontalExtent();

  if (m_bReadOnly)
  {
     GetDlgItem(IDC_ATTR_REMOVE_BUTTON)->EnableWindow(FALSE);
     GetDlgItem(IDC_ATTR_ADD_BUTTON)->EnableWindow(FALSE);
     SendDlgItemMessage(IDC_VALUE_EDIT, EM_SETREADONLY, TRUE, 0);
  }

  //
  // NOTE: I have explicitly set the focus so return 0
  //
  return FALSE;
}

void CMultiStringEditor::OnOK()
{
  if (!m_bReadOnly)
  {
     //
     // Get the values out of the list box
     //
     m_szNewValueList.RemoveAll();

     CListBox* pListBox = reinterpret_cast<CListBox*>(GetDlgItem(IDC_VALUE_LIST));
     if (pListBox != NULL)
     {
       int iCount = pListBox->GetCount();
       for (int idx = 0; idx < iCount; idx++)
       {
         CString szNewValue;
         pListBox->GetText(idx, szNewValue);

         m_szNewValueList.AddTail(szNewValue);
       }
     }
  }
  CDialog::OnOK();
}

void CMultiStringEditor::OnAddButton()
{
  if (!m_bReadOnly)
  {
     //
     // Add the value to the list box and clear the edit field
     //
     CString szNewValue;
     GetDlgItemText(IDC_VALUE_EDIT, szNewValue);

     if (!szNewValue.IsEmpty())
     {
       LRESULT lFind = SendDlgItemMessage(IDC_VALUE_LIST, 
                                          LB_FINDSTRING, 
                                          (WPARAM)-1, 
                                          (LPARAM)(PCWSTR)szNewValue);
       if (lFind != LB_ERR)
       {
         //
         // Ask them if they really want to add the duplicate value
         //
         UINT nResult = ADSIEditMessageBox(IDS_ATTREDIT_DUPLICATE_VALUE, MB_YESNO);
         lFind = (nResult == IDYES) ? LB_ERR : 1;
       }

       if (lFind == LB_ERR)
       {
         SendDlgItemMessage(IDC_VALUE_LIST, LB_ADDSTRING, 0, (LPARAM)(LPCWSTR)szNewValue);
       }
     }

     SetDlgItemText(IDC_VALUE_EDIT, L"");

     ManageButtonStates();

     //
     // Update the width of the list box
     //
     UpdateListboxHorizontalExtent();
  }
}

void CMultiStringEditor::OnRemoveButton()
{
  if (!m_bReadOnly)
  {
     CListBox* pListBox = reinterpret_cast<CListBox*>(GetDlgItem(IDC_VALUE_LIST));
     if (pListBox != NULL)
     {
       int iCurSel = pListBox->GetCurSel();
       if (iCurSel != LB_ERR)
       {
         //
         // Put the old value into the edit box
         //
         CString szOldValue;
         pListBox->GetText(iCurSel, szOldValue);
         SetDlgItemText(IDC_VALUE_EDIT, szOldValue);

         //
         // Delete the item from the list box
         //
         pListBox->DeleteString(iCurSel);
       }
     }

     //
     // Manage Button States
     //
     ManageButtonStates();

     //
     // Update the width of the list box
     //
     UpdateListboxHorizontalExtent();
  }
}

void CMultiStringEditor::ManageButtonStates()
{
  if (m_bReadOnly)
  {
    GetDlgItem(IDC_ATTR_REMOVE_BUTTON)->EnableWindow(FALSE);
    GetDlgItem(IDC_ATTR_ADD_BUTTON)->EnableWindow(FALSE);
  }
  else
  {
     //
     // Change the default button to the Add button
     //
     CString szValue;
     GetDlgItemText(IDC_VALUE_EDIT, szValue);

     if (szValue.IsEmpty())
     {
       //
       // Set the default button to OK
       //
       SendMessage(DM_SETDEFID, (WPARAM)IDOK, 0);
       SendDlgItemMessage(IDC_ATTR_ADD_BUTTON, 
                          BM_SETSTYLE, 
                          BS_PUSHBUTTON, 
                          MAKELPARAM(TRUE, 0));
       SendDlgItemMessage(IDOK,
                          BM_SETSTYLE,
                          BS_DEFPUSHBUTTON,
                          MAKELPARAM(TRUE, 0));
     }
     else
     {
       //
       // Set the default button to the Add button
       //
       SendMessage(DM_SETDEFID, (WPARAM)IDC_ATTR_ADD_BUTTON, 0);
       SendDlgItemMessage(IDOK, 
                          BM_SETSTYLE, 
                          BS_PUSHBUTTON, 
                          MAKELPARAM(TRUE, 0));
       SendDlgItemMessage(IDC_ATTR_ADD_BUTTON,
                          BM_SETSTYLE,
                          BS_DEFPUSHBUTTON,
                          MAKELPARAM(TRUE, 0));
     }

     LRESULT lSelection = SendDlgItemMessage(IDC_VALUE_LIST, LB_GETCURSEL, 0, 0);
     if (lSelection != LB_ERR)
     {
       GetDlgItem(IDC_ATTR_REMOVE_BUTTON)->EnableWindow(TRUE);
     }
     else
     {
       GetDlgItem(IDC_ATTR_REMOVE_BUTTON)->EnableWindow(FALSE);
     }
  }
}

void CMultiStringEditor::OnListSelChange()
{
  ManageButtonStates();
}

void CMultiStringEditor::OnEditChange()
{
  ManageButtonStates();
}

void CMultiStringEditor::UpdateListboxHorizontalExtent()
{
   int nHorzExtent = 0;
  CListBox* pListBox = reinterpret_cast<CListBox*>(GetDlgItem(IDC_VALUE_LIST));
  if (pListBox != NULL)
  {
     CClientDC dc(pListBox);
     int nItems = pListBox->GetCount();
     for (int i=0; i < nItems; i++)
     {
        TEXTMETRIC tm;
        VERIFY(dc.GetTextMetrics(&tm));
        CString szBuffer;
        pListBox->GetText(i, szBuffer);
        CSize ext = dc.GetTextExtent(szBuffer,szBuffer.GetLength());
        nHorzExtent = max(ext.cx ,nHorzExtent); 
     }
     pListBox->SetHorizontalExtent(nHorzExtent);
  }
}

HRESULT CMultiStringEditor::Initialize(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo)
{
  HRESULT hr = S_OK;

  if (SUCCEEDED(CValueEditDialog::Initialize(pAttributeEditorInfo)))
  {
    if (pAttributeEditorInfo->dwNumValues > 0 &&
        pAttributeEditorInfo->pADsValue != NULL)
    {
      for (int idx = 0; idx < pAttributeEditorInfo->dwNumValues; idx++)
      {
        switch (pAttributeEditorInfo->pADsValue[idx].dwType)
        {
          case ADSTYPE_CASE_IGNORE_STRING:
            m_szOldValueList.AddTail(pAttributeEditorInfo->pADsValue[idx].CaseIgnoreString);
            break;

          case ADSTYPE_CASE_EXACT_STRING:
            m_szOldValueList.AddTail(pAttributeEditorInfo->pADsValue[idx].CaseExactString);
            break;

          case ADSTYPE_PRINTABLE_STRING:
            m_szOldValueList.AddTail(pAttributeEditorInfo->pADsValue[idx].PrintableString);
            break;

          case ADSTYPE_DN_STRING:
            m_szOldValueList.AddTail(pAttributeEditorInfo->pADsValue[idx].DNString);
            break;
            
          default:
            ASSERT(FALSE);
            break;
        }
      }
    }
  }
  return hr;
}


// FUTURE-2002/03/05-artm  Very similar functionality in CSingleStringEditor
// and CMultiStringEditor classes.  Perhaps there is a way to combine the
// classes into a single class....or have one class inherit from the other.
HRESULT CMultiStringEditor::GetNewValue(PADSVALUE* ppADsValue, DWORD* pdwNumValues)
{
  HRESULT hr = S_OK;

  if (ppADsValue == NULL ||
      pdwNumValues == NULL)
  {
    return E_OUTOFMEMORY;
  }

  int iCount = m_szNewValueList.GetCount();
  if (iCount == 0)
  {
    *ppADsValue = NULL;
    *pdwNumValues = 0;
  }
  else
  {
    *ppADsValue = new ADSVALUE[iCount];
    if (*ppADsValue != NULL)
    {
      *pdwNumValues = iCount;

      int idx = 0;
      POSITION pos = m_szNewValueList.GetHeadPosition();
      while (pos != NULL)
      {
        CString szNewValue = m_szNewValueList.GetNext(pos);

        (*ppADsValue)[idx].dwType = m_pOldADsValue->dwType;
        switch (m_pOldADsValue->dwType)
        {
          case ADSTYPE_CASE_IGNORE_STRING:
            (*ppADsValue)[idx].CaseIgnoreString = new WCHAR[wcslen(szNewValue) + 1];
            if ((*ppADsValue)[idx].CaseIgnoreString != NULL)
            {
              // NOTICE-2002/03/05-artm  wcscpy() OK.
              // Both args are allocated the same amount of memory.
              wcscpy((*ppADsValue)[idx].CaseIgnoreString, szNewValue);
            }
            else
            {
              DeleteADsValues(*ppADsValue, *pdwNumValues);
              *ppADsValue = NULL;
              *pdwNumValues = 0;
              hr = E_OUTOFMEMORY;
            }
            break;

          case ADSTYPE_CASE_EXACT_STRING:
            (*ppADsValue)[idx].CaseExactString = new WCHAR[wcslen(szNewValue) + 1];
            if ((*ppADsValue)[idx].CaseExactString != NULL)
            {
              // NOTICE-2002/03/05-artm  wcscpy() OK.
              // Both args are allocated the same amount of memory.
              wcscpy((*ppADsValue)[idx].CaseExactString, szNewValue);
            }
            else
            {
              DeleteADsValues(*ppADsValue, *pdwNumValues);
              *ppADsValue = NULL;
              *pdwNumValues = 0;
              hr = E_OUTOFMEMORY;
            }
            break;

          case ADSTYPE_PRINTABLE_STRING:
            (*ppADsValue)[idx].PrintableString = new WCHAR[wcslen(szNewValue) + 1];
            if ((*ppADsValue)[idx].PrintableString != NULL)
            {
              // NOTICE-2002/03/05-artm  wcscpy() OK.
              // Both args are allocated the same amount of memory.
              wcscpy((*ppADsValue)[idx].PrintableString, szNewValue);
            }
            else
            {
              DeleteADsValues(*ppADsValue, *pdwNumValues);
              *ppADsValue = NULL;
              *pdwNumValues = 0;
              hr = E_OUTOFMEMORY;
            }
            break;

          case ADSTYPE_DN_STRING:
            (*ppADsValue)[idx].DNString = new WCHAR[wcslen(szNewValue) + 1];
            if ((*ppADsValue)[idx].DNString != NULL)
            {
              // NOTICE-2002/03/05-artm  wcscpy() OK.
              // Both args are allocated the same amount of memory.
              wcscpy((*ppADsValue)[idx].DNString, szNewValue);
            }
            else
            {
              DeleteADsValues(*ppADsValue, *pdwNumValues);
              *ppADsValue = NULL;
              *pdwNumValues = 0;
              hr = E_OUTOFMEMORY;
            }
            break;

          case ADSTYPE_NUMERIC_STRING:
            (*ppADsValue)[idx].NumericString = new WCHAR[wcslen(szNewValue) + 1];
            if ((*ppADsValue)[idx].NumericString != NULL)
            {
              // NOTICE-2002/03/05-artm  wcscpy() OK.
              // Both args are allocated the same amount of memory.
              wcscpy((*ppADsValue)[idx].NumericString, szNewValue);
            }
            else
            {
              DeleteADsValues(*ppADsValue, *pdwNumValues);
              *ppADsValue = NULL;
              *pdwNumValues = 0;
              hr = E_OUTOFMEMORY;
            }
            break;

          default:
            ASSERT(FALSE);
            DeleteADsValues(*ppADsValue, *pdwNumValues);
            *ppADsValue = NULL;
            *pdwNumValues = 0;
            hr = E_FAIL;
            break;
        }
        idx++;
      }
    }
    else
    {
      *ppADsValue = NULL;
      *pdwNumValues = 0;
      hr = E_OUTOFMEMORY;
    }
  }
  return hr;
}

///////////////////////////////////////////////////////////////////////////////////////
// CSingleIntEditor

CValueEditDialog* CreateSingleIntEditor(PCWSTR pszClass,
                                        PCWSTR pszAttribute,
                                        ADSTYPE adsType,
                                        BOOL bMultivalued)
{
  return new CSingleIntEditor;
}

BEGIN_MESSAGE_MAP(CSingleIntEditor, CValueEditDialog)
  ON_BN_CLICKED(IDC_CLEAR_BUTTON, OnClear)
END_MESSAGE_MAP()

BOOL CSingleIntEditor::OnInitDialog()
{
  //
  // Initialize the static control with the attribute name
  //
  SetDlgItemText(IDC_ATTRIBUTE_STATIC, m_szAttribute);

  //
  // Initialize the edit box with the value
  //
  if (!m_bValueSet)
  {
    CString szNotSet;
    VERIFY(szNotSet.LoadString(IDS_NOTSET));
    SetDlgItemText(IDC_VALUE_EDIT, szNotSet);
  }
  else
  {
    SetDlgItemInt(IDC_VALUE_EDIT, m_dwOldValue, TRUE);
  }

  //
  // Select the text in the edit box
  //
  SendDlgItemMessage(IDC_VALUE_EDIT, EM_SETSEL, 0, -1);

  //
  // Disable IME support on the edit box
  //
  ImmAssociateContext(::GetDlgItem(GetSafeHwnd(), IDC_VALUE_EDIT), NULL);

  if (m_bReadOnly)
  {
     SendDlgItemMessage(IDC_VALUE_EDIT, EM_SETREADONLY, TRUE, 0);
     GetDlgItem(IDC_CLEAR_BUTTON)->EnableWindow(FALSE);
  }

  return CDialog::OnInitDialog();
}

void CSingleIntEditor::OnOK()
{
  if (!m_bReadOnly)
  {
     BOOL bTranslated = FALSE;
     m_dwNewValue = GetDlgItemInt(IDC_VALUE_EDIT, &bTranslated, TRUE);

     if (!bTranslated)
     {
       // The translation will always fail if we are in the <not set> state

       CString szNotSet;
       VERIFY(szNotSet.LoadString(IDS_NOTSET));

       CString value;
       GetDlgItemText(IDC_VALUE_EDIT, value);

       if (value.CompareNoCase(szNotSet) != 0)
       {
         // The user probably entered some non-numeric characters

         ADSIEditMessageBox(IDS_ERR_MUST_BE_NUMERIC, MB_OK | MB_ICONEXCLAMATION);
       }
       else
       {
          CDialog::OnOK();
       }
     }
     else
     {
       m_bValueSet = TRUE;
       CDialog::OnOK();
     }
  }
  else
  {
     CDialog::OnOK();
  }
}

HRESULT CSingleIntEditor::Initialize(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo)
{
  HRESULT hr = S_OK;

  if (SUCCEEDED(CValueEditDialog::Initialize(pAttributeEditorInfo)))
  {
    if (pAttributeEditorInfo->dwNumValues > 0 &&
        pAttributeEditorInfo->pADsValue != NULL)
    {
      switch (pAttributeEditorInfo->pADsValue->dwType)
      {
        case ADSTYPE_INTEGER:
          m_dwOldValue = pAttributeEditorInfo->pADsValue->Integer;
          m_bValueSet = TRUE;
          break;

        default:
          ASSERT(FALSE);
          break;
      }
    }
  }
  return hr;
}

// FUTURE-2002/03/05-artm  Identical OnClear() functions...
// The OnClear() method for all of the classes that extend CValueEditDialog
// is implemented identically (or so it seems on first glance).  Perhaps
// the implementation should be placed in the base class to reduce
// code size, complexity, and maintenance.
void CSingleIntEditor::OnClear()
{
  if (!m_bReadOnly)
  {
     //
     // Change the text in the edit box to "<not set>"
     //
     CString szNotSet;
     VERIFY(szNotSet.LoadString(IDS_NOTSET));
     SetDlgItemText(IDC_VALUE_EDIT, szNotSet);

     //
     // Change the focus to the edit box
     //
     GetDlgItem(IDC_VALUE_EDIT)->SetFocus();

     //
     // Select the text in the edit box
     //
     SendDlgItemMessage(IDC_VALUE_EDIT, EM_SETSEL, 0, -1);

     m_bValueSet = FALSE;
  }
}

HRESULT CSingleIntEditor::GetNewValue(PADSVALUE* ppADsValue, DWORD* pdwNumValues)
{
  HRESULT hr = S_OK;

  if (ppADsValue == NULL ||
      pdwNumValues == NULL)
  {
    return E_OUTOFMEMORY;
  }

  CString szNotSet;
  VERIFY(szNotSet.LoadString(IDS_NOTSET));

  if (!m_bValueSet)
  {
    *ppADsValue = NULL;
    *pdwNumValues = 0;
  }
  else
  {
    *ppADsValue = new ADSVALUE;
    if (*ppADsValue != NULL)
    {
      *pdwNumValues = 1;
      (*ppADsValue)->dwType = m_pOldADsValue->dwType;
      switch (m_pOldADsValue->dwType)
      {
        case ADSTYPE_INTEGER:
          (*ppADsValue)->Integer = m_dwNewValue;
          break;

        default:
          ASSERT(FALSE);
          DeleteADsValues(*ppADsValue, *pdwNumValues);
          *ppADsValue = NULL;
          *pdwNumValues = 0;
          hr = E_FAIL;
          break;
      }
    }
    else
    {
      *pdwNumValues = 0;
      hr = E_OUTOFMEMORY;
    }
  }
  return hr;
}


///////////////////////////////////////////////////////////////////////////////////////
// CMultiIntEditor

CValueEditDialog* CreateMultiIntEditor(PCWSTR pszClass,
                                       PCWSTR pszAttribute,
                                       ADSTYPE adsType,
                                       BOOL bMultivalued)
{
  return new CMultiIntEditor;
}

BEGIN_MESSAGE_MAP(CMultiIntEditor, CValueEditDialog)
  ON_BN_CLICKED(IDC_ATTR_ADD_BUTTON, OnAddButton)
  ON_BN_CLICKED(IDC_ATTR_REMOVE_BUTTON, OnRemoveButton)
  ON_LBN_SELCHANGE(IDC_VALUE_LIST, OnListSelChange)
  ON_EN_CHANGE(IDC_VALUE_EDIT, OnEditChange)
END_MESSAGE_MAP()

BOOL CMultiIntEditor::OnInitDialog()
{
  CDialog::OnInitDialog();

  //
  // Set the attribute name static
  //
  SetDlgItemText(IDC_ATTRIBUTE_STATIC, m_szAttribute);

  //
  // Disable IME support on the edit box
  //
  ImmAssociateContext(::GetDlgItem(GetSafeHwnd(), IDC_VALUE_EDIT), NULL);

  //
  // Fill the list box with the current values
  //
  POSITION pos = m_oldValueList.GetHeadPosition();
  while (pos != NULL)
  {
    int value = m_oldValueList.GetNext(pos);

    // Convert value to string

    CString stringValue;
    stringValue.Format(L"%d", value);

    // Add string to list box

    LRESULT index = 
       SendDlgItemMessage(
          IDC_VALUE_LIST, 
          LB_ADDSTRING, 
          0, 
          (LPARAM)(LPCWSTR)stringValue);

    // Attach the int value to the list box item

    if (index != LB_ERR)
    {
       SendDlgItemMessage(
          IDC_VALUE_LIST,
          LB_SETITEMDATA,
          (WPARAM)index,
          (LPARAM)value);
    }
  }

  //
  // The remove button should be disabled until something is selected in the listbox
  //
  GetDlgItem(IDC_ATTR_REMOVE_BUTTON)->EnableWindow(FALSE);
  GetDlgItem(IDC_VALUE_EDIT)->SetFocus();

  ManageButtonStates();

  //
  // Update the width of the list box
  //
  UpdateListboxHorizontalExtent();

  if (m_bReadOnly)
  {
     GetDlgItem(IDC_ATTR_REMOVE_BUTTON)->EnableWindow(FALSE);
     GetDlgItem(IDC_ATTR_ADD_BUTTON)->EnableWindow(FALSE);
     SendDlgItemMessage(IDC_VALUE_EDIT, EM_SETREADONLY, TRUE, 0);
  }

  //
  // NOTE: I have explicitly set the focus so return 0
  //
  return FALSE;
}

void CMultiIntEditor::OnOK()
{
  if (!m_bReadOnly)
  {
     //
     // Get the values out of the list box
     //
     m_newValueList.RemoveAll();

     CListBox* pListBox = reinterpret_cast<CListBox*>(GetDlgItem(IDC_VALUE_LIST));
     if (pListBox != NULL)
     {
       int iCount = pListBox->GetCount();
       for (int idx = 0; idx < iCount; idx++)
       {
         int newValue;
         newValue = static_cast<int>(pListBox->GetItemData(idx));

         m_newValueList.AddTail(newValue);
       }
     }
  }
  CDialog::OnOK();
}

void CMultiIntEditor::OnAddButton()
{
  if (!m_bReadOnly)
  {
     //
     // Add the value to the list box and clear the edit field
     //
     int newValue = 0;
     BOOL trans = FALSE;

     newValue = GetDlgItemInt(IDC_VALUE_EDIT, &trans, TRUE);

     CString szNewValue;
     GetDlgItemText(IDC_VALUE_EDIT, szNewValue);

     if (trans && !szNewValue.IsEmpty())
     {
       LRESULT lFind = SendDlgItemMessage(IDC_VALUE_LIST, 
                                          LB_FINDSTRING, 
                                          (WPARAM)-1, 
                                          (LPARAM)(PCWSTR)szNewValue);
       if (lFind != LB_ERR)
       {
         //
         // Ask them if they really want to add the duplicate value
         //
         UINT nResult = ADSIEditMessageBox(IDS_ATTREDIT_DUPLICATE_VALUE, MB_YESNO);
         lFind = (nResult == IDYES) ? LB_ERR : 1;
       }

       if (lFind == LB_ERR)
       {
         // Add the string to the list box

         LRESULT index =
            SendDlgItemMessage(
               IDC_VALUE_LIST, 
               LB_ADDSTRING, 
               0, 
               (LPARAM)(LPCWSTR)szNewValue);

         if (index != LB_ERR)
         {
            // Set the item data to the integer value

            SendDlgItemMessage(
               IDC_VALUE_LIST,
               LB_SETITEMDATA,
               (WPARAM)index,
               (LPARAM)newValue);
         }
       }
       SetDlgItemText(IDC_VALUE_EDIT, L"");
     }
     else
     {
        //
        // I was unable to convert the value to an integer so tell
        // the user they can only enter digits from 0 to 9 and the
        // - (negative) sign
        //
        ADSIEditMessageBox(IDS_ERR_MUST_BE_NUMERIC, MB_OK);
     }

     ManageButtonStates();

     //
     // Update the width of the list box
     //
     UpdateListboxHorizontalExtent();
  }
}

void CMultiIntEditor::OnRemoveButton()
{
  if (!m_bReadOnly)
  {
     CListBox* pListBox = reinterpret_cast<CListBox*>(GetDlgItem(IDC_VALUE_LIST));
     if (pListBox != NULL)
     {
       int iCurSel = pListBox->GetCurSel();
       if (iCurSel != LB_ERR)
       {
         //
         // Put the old value into the edit box
         //
         CString szOldValue;
         pListBox->GetText(iCurSel, szOldValue);
         SetDlgItemText(IDC_VALUE_EDIT, szOldValue);

         //
         // Delete the item from the list box
         //
         pListBox->DeleteString(iCurSel);
       }
     }

     //
     // Manage Button States
     //
     ManageButtonStates();

     //
     // Update the width of the list box
     //
     UpdateListboxHorizontalExtent();
  }
}

void CMultiIntEditor::ManageButtonStates()
{
  if (m_bReadOnly)
  {
    GetDlgItem(IDC_ATTR_REMOVE_BUTTON)->EnableWindow(FALSE);
    GetDlgItem(IDC_ATTR_ADD_BUTTON)->EnableWindow(FALSE);
  }
  else
  {
     //
     // Change the default button to the Add button
     //
     int value = 0;
     BOOL trans = FALSE;

     value = GetDlgItemInt(IDC_VALUE_EDIT, &trans, TRUE);

     if (!trans)
     {
       //
       // Set the default button to OK
       //
       SendMessage(DM_SETDEFID, (WPARAM)IDOK, 0);
       SendDlgItemMessage(IDC_ATTR_ADD_BUTTON, 
                          BM_SETSTYLE, 
                          BS_PUSHBUTTON, 
                          MAKELPARAM(TRUE, 0));
       SendDlgItemMessage(IDOK,
                          BM_SETSTYLE,
                          BS_DEFPUSHBUTTON,
                          MAKELPARAM(TRUE, 0));
     }
     else
     {
       //
       // Set the default button to the Add button
       //
       SendMessage(DM_SETDEFID, (WPARAM)IDC_ATTR_ADD_BUTTON, 0);
       SendDlgItemMessage(IDOK, 
                          BM_SETSTYLE, 
                          BS_PUSHBUTTON, 
                          MAKELPARAM(TRUE, 0));
       SendDlgItemMessage(IDC_ATTR_ADD_BUTTON,
                          BM_SETSTYLE,
                          BS_DEFPUSHBUTTON,
                          MAKELPARAM(TRUE, 0));
     }

     LRESULT lSelection = SendDlgItemMessage(IDC_VALUE_LIST, LB_GETCURSEL, 0, 0);
     if (lSelection != LB_ERR)
     {
       GetDlgItem(IDC_ATTR_REMOVE_BUTTON)->EnableWindow(TRUE);
     }
     else
     {
       GetDlgItem(IDC_ATTR_REMOVE_BUTTON)->EnableWindow(FALSE);
     }
  }
}

void CMultiIntEditor::OnListSelChange()
{
  ManageButtonStates();
}

void CMultiIntEditor::OnEditChange()
{
  ManageButtonStates();
}

void CMultiIntEditor::UpdateListboxHorizontalExtent()
{
   int nHorzExtent = 0;
  CListBox* pListBox = reinterpret_cast<CListBox*>(GetDlgItem(IDC_VALUE_LIST));
  if (pListBox != NULL)
  {
     CClientDC dc(pListBox);
     int nItems = pListBox->GetCount();
     for (int i=0; i < nItems; i++)
     {
        TEXTMETRIC tm;
        VERIFY(dc.GetTextMetrics(&tm));
        CString szBuffer;
        pListBox->GetText(i, szBuffer);
        CSize ext = dc.GetTextExtent(szBuffer,szBuffer.GetLength());
        nHorzExtent = max(ext.cx ,nHorzExtent); 
     }
     pListBox->SetHorizontalExtent(nHorzExtent);
  }
}

HRESULT CMultiIntEditor::Initialize(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo)
{
  HRESULT hr = S_OK;

  if (SUCCEEDED(CValueEditDialog::Initialize(pAttributeEditorInfo)))
  {
    if (pAttributeEditorInfo->dwNumValues > 0 &&
        pAttributeEditorInfo->pADsValue != NULL)
    {
      for (int idx = 0; idx < pAttributeEditorInfo->dwNumValues; idx++)
      {
        switch (pAttributeEditorInfo->pADsValue[idx].dwType)
        {
          case ADSTYPE_INTEGER:
            m_oldValueList.AddTail(pAttributeEditorInfo->pADsValue[idx].Integer);
            break;

          default:
            ASSERT(FALSE);
            break;
        }
      }
    }
  }
  return hr;
}


// FUTURE-2002/03/05-artm  Very similar functionality in CSingleIntEditor
// and CMultiStringEditor classes.  Perhaps there is a way to combine the
// classes into a single class....or have one class inherit from the other.
HRESULT CMultiIntEditor::GetNewValue(PADSVALUE* ppADsValue, DWORD* pdwNumValues)
{
  HRESULT hr = S_OK;

  if (ppADsValue == NULL ||
      pdwNumValues == NULL)
  {
    return E_OUTOFMEMORY;
  }

  int iCount = m_newValueList.GetCount();
  if (iCount == 0)
  {
    *ppADsValue = NULL;
    *pdwNumValues = 0;
  }
  else
  {
    *ppADsValue = new ADSVALUE[iCount];
    if (*ppADsValue != NULL)
    {
      *pdwNumValues = iCount;

      int idx = 0;
      POSITION pos = m_newValueList.GetHeadPosition();
      while (pos != NULL)
      {
        int newValue = m_newValueList.GetNext(pos);

        (*ppADsValue)[idx].dwType = m_pOldADsValue->dwType;
        switch (m_pOldADsValue->dwType)
        {
          case ADSTYPE_INTEGER:
            (*ppADsValue)[idx].Integer = newValue;
            break;

           default:
            ASSERT(FALSE);
            DeleteADsValues(*ppADsValue, *pdwNumValues);
            *ppADsValue = NULL;
            *pdwNumValues = 0;
            hr = E_FAIL;
            break;
        }
        idx++;
      }
    }
    else
    {
      *ppADsValue = NULL;
      *pdwNumValues = 0;
      hr = E_OUTOFMEMORY;
    }
  }
  return hr;
}

///////////////////////////////////////////////////////////////////////////////////////
// CSingleLargeIntEditor

CValueEditDialog* CreateSingleLargeIntEditor(PCWSTR pszClass,
                                             PCWSTR pszAttribute,
                                             ADSTYPE adsType,
                                             BOOL bMultivalued)
{
  return new CSingleLargeIntEditor;
}

BEGIN_MESSAGE_MAP(CSingleLargeIntEditor, CValueEditDialog)
  ON_BN_CLICKED(IDC_CLEAR_BUTTON, OnClear)
END_MESSAGE_MAP()

BOOL CSingleLargeIntEditor::OnInitDialog()
{
  //
  // Initialize the static control with the attribute name
  //
  SetDlgItemText(IDC_ATTRIBUTE_STATIC, m_szAttribute);

  //
  // Initialize the edit box with the value
  //
  if (!m_bValueSet)
  {
    CString szNotSet;
    VERIFY(szNotSet.LoadString(IDS_NOTSET));
    SetDlgItemText(IDC_VALUE_EDIT, szNotSet);
  }
  else
  {
    CString szOldValue;
    litow(m_liOldValue, szOldValue);
    SetDlgItemText(IDC_VALUE_EDIT, szOldValue);
  }

  //
  // Select the text in the edit box
  //
  SendDlgItemMessage(IDC_VALUE_EDIT, EM_SETSEL, 0, -1);

  //
  // Disable IME support on the edit box
  //
  ImmAssociateContext(::GetDlgItem(GetSafeHwnd(), IDC_VALUE_EDIT), NULL);

  if (m_bReadOnly)
  {
     SendDlgItemMessage(IDC_VALUE_EDIT, EM_SETREADONLY, TRUE, 0);
     GetDlgItem(IDC_CLEAR_BUTTON)->EnableWindow(FALSE);
  }

  return CDialog::OnInitDialog();
}

void CSingleLargeIntEditor::OnOK()
{
  if (!m_bReadOnly)
  {
     CString szNotSet;
     VERIFY(szNotSet.LoadString(IDS_NOTSET));

     CString szNewValue;
     GetDlgItemText(IDC_VALUE_EDIT, szNewValue);

     if (szNewValue == szNotSet)
     {
       m_bValueSet = FALSE;
     }
     else
     {
       wtoli(szNewValue, m_liNewValue);
       m_bValueSet = TRUE;
     }
  }
  CDialog::OnOK();
}

HRESULT CSingleLargeIntEditor::Initialize(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo)
{
  HRESULT hr = S_OK;

  if (SUCCEEDED(CValueEditDialog::Initialize(pAttributeEditorInfo)))
  {
    if (pAttributeEditorInfo->dwNumValues > 0 &&
        pAttributeEditorInfo->pADsValue != NULL)
    {
      switch (pAttributeEditorInfo->pADsValue->dwType)
      {
        case ADSTYPE_LARGE_INTEGER:
          m_liOldValue = pAttributeEditorInfo->pADsValue->LargeInteger;
          m_bValueSet = TRUE;
          break;

        default:
          ASSERT(FALSE);
          break;
      }
    }
    else
    {
      m_bValueSet = FALSE;
    }
  }
  return hr;
}

void CSingleLargeIntEditor::OnClear()
{
  if (!m_bReadOnly)
  {
     //
     // Change the text in the edit box to "<not set>"
     //
     CString szNotSet;
     VERIFY(szNotSet.LoadString(IDS_NOTSET));
     SetDlgItemText(IDC_VALUE_EDIT, szNotSet);

     //
     // Change the focus to the edit box
     //
     GetDlgItem(IDC_VALUE_EDIT)->SetFocus();

     //
     // Select the text in the edit box
     //
     SendDlgItemMessage(IDC_VALUE_EDIT, EM_SETSEL, 0, -1);

     m_bValueSet = FALSE;
  }
}

HRESULT CSingleLargeIntEditor::GetNewValue(PADSVALUE* ppADsValue, DWORD* pdwNumValues)
{
  HRESULT hr = S_OK;

  if (ppADsValue == NULL ||
      pdwNumValues == NULL)
  {
    return E_OUTOFMEMORY;
  }

  if (!m_bValueSet)
  {
    *ppADsValue = NULL;
    *pdwNumValues = 0;
  }
  else
  {
    *ppADsValue = new ADSVALUE;
    if (*ppADsValue != NULL)
    {
      *pdwNumValues = 1;
      (*ppADsValue)->dwType = m_pOldADsValue->dwType;
      switch (m_pOldADsValue->dwType)
      {
        case ADSTYPE_LARGE_INTEGER:
          (*ppADsValue)->LargeInteger = m_liNewValue;
          break;

        default:
          ASSERT(FALSE);
          DeleteADsValues(*ppADsValue, *pdwNumValues);
          *ppADsValue = NULL;
          *pdwNumValues = 0;
          hr = E_FAIL;
          break;
      }
    }
    else
    {
      *pdwNumValues = 0;
      hr = E_OUTOFMEMORY;
    }
  }
  return hr;
}

///////////////////////////////////////////////////////////////////////////////////////
// CSingleBooleanEditor

CValueEditDialog* CreateSingleBooleanEditor(PCWSTR pszClass,
                                            PCWSTR pszAttribute,
                                            ADSTYPE adsType,
                                            BOOL bMultivalued)
{
  return new CSingleBooleanEditor;
}

BEGIN_MESSAGE_MAP(CSingleBooleanEditor, CValueEditDialog)
END_MESSAGE_MAP()

BOOL CSingleBooleanEditor::OnInitDialog()
{
  //
  // Initialize the static control with the attribute name
  //
  SetDlgItemText(IDC_ATTRIBUTE_STATIC, m_szAttribute);

  //
  // Initialize the edit box with the value
  //
  if (!m_bValueSet)
  {
    SendDlgItemMessage(IDC_NOTSET_RADIO, BM_SETCHECK, BST_CHECKED, 0);
  }
  else
  {
    if (m_bOldValue)
    {
      SendDlgItemMessage(IDC_TRUE_RADIO, BM_SETCHECK, BST_CHECKED, 0);
    }
    else
    {
      SendDlgItemMessage(IDC_FALSE_RADIO, BM_SETCHECK, BST_CHECKED, 0);
    }
  }

  if (m_bReadOnly)
  {
     GetDlgItem(IDC_TRUE_RADIO)->EnableWindow(FALSE);
     GetDlgItem(IDC_FALSE_RADIO)->EnableWindow(FALSE);
  }
  return CDialog::OnInitDialog();
}

void CSingleBooleanEditor::OnOK()
{
  if (!m_bReadOnly)
  {
     LRESULT lTrueCheck = SendDlgItemMessage(IDC_TRUE_RADIO, BM_GETCHECK, 0, 0);
     LRESULT lFalseCheck = SendDlgItemMessage(IDC_FALSE_RADIO, BM_GETCHECK, 0, 0);
     LRESULT lNotSetCheck = SendDlgItemMessage(IDC_NOTSET_RADIO, BM_GETCHECK, 0, 0);

     if (lTrueCheck == BST_CHECKED)
     {
       m_bNewValue = TRUE;
       m_bValueSet = TRUE;
     }

     if (lFalseCheck == BST_CHECKED)
     {
       m_bNewValue = FALSE;
       m_bValueSet = TRUE;
     }

     if (lNotSetCheck == BST_CHECKED)
     {
       m_bValueSet = FALSE;
     }
  }
  CDialog::OnOK();
}

HRESULT CSingleBooleanEditor::Initialize(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo)
{
  HRESULT hr = S_OK;

  if (SUCCEEDED(CValueEditDialog::Initialize(pAttributeEditorInfo)))
  {
    if (pAttributeEditorInfo->dwNumValues > 0 &&
        pAttributeEditorInfo->pADsValue != NULL)
    {
      switch (pAttributeEditorInfo->pADsValue->dwType)
      {
        case ADSTYPE_BOOLEAN:
          m_bOldValue = pAttributeEditorInfo->pADsValue->Boolean;
          m_bValueSet = TRUE;
          break;

        default:
          ASSERT(FALSE);
          break;
      }
    }
    else
    {
      m_bValueSet = FALSE;
    }
  }
  return hr;
}


HRESULT CSingleBooleanEditor::GetNewValue(PADSVALUE* ppADsValue, DWORD* pdwNumValues)
{
  HRESULT hr = S_OK;

  if (ppADsValue == NULL ||
      pdwNumValues == NULL)
  {
    return E_OUTOFMEMORY;
  }

  if (!m_bValueSet)
  {
    *ppADsValue = NULL;
    *pdwNumValues = 0;
  }
  else
  {
    *ppADsValue = new ADSVALUE;
    if (*ppADsValue != NULL)
    {
      *pdwNumValues = 1;
      (*ppADsValue)->dwType = m_pOldADsValue->dwType;
      switch (m_pOldADsValue->dwType)
      {
        case ADSTYPE_BOOLEAN:
          (*ppADsValue)->Boolean = m_bNewValue;
          break;

        default:
          ASSERT(FALSE);
          DeleteADsValues(*ppADsValue, *pdwNumValues);
          *ppADsValue = NULL;
          *pdwNumValues = 0;
          hr = E_FAIL;
          break;
      }
    }
    else
    {
      *pdwNumValues = 0;
      hr = E_OUTOFMEMORY;
    }
  }
  return hr;
}

///////////////////////////////////////////////////////////////////////////////////////
// CMultiBooleanEditor

CValueEditDialog* CreateMultiBooleanEditor(PCWSTR pszClass,
                                           PCWSTR pszAttribute,
                                           ADSTYPE adsType,
                                           BOOL bMultivalued)
{
  return new CMultiBooleanEditor;
}

BEGIN_MESSAGE_MAP(CMultiBooleanEditor, CValueEditDialog)
  ON_BN_CLICKED(IDC_ATTR_ADD_BUTTON, OnAddButton)
  ON_BN_CLICKED(IDC_ATTR_REMOVE_BUTTON, OnRemoveButton)
  ON_LBN_SELCHANGE(IDC_VALUE_LIST, OnListSelChange)
  ON_BN_CLICKED(IDC_TRUE_RADIO, OnRadioChange)
  ON_BN_CLICKED(IDC_FALSE_RADIO, OnRadioChange)
END_MESSAGE_MAP()

BOOL CMultiBooleanEditor::OnInitDialog()
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  CDialog::OnInitDialog();

  //
  // Set the attribute name static
  //
  SetDlgItemText(IDC_ATTRIBUTE_STATIC, m_szAttribute);

  //
  // Fill the list box with the current values
  //
  CString szTrue;
  szTrue.LoadString(IDS_TRUE);

  CString szFalse;
  szFalse.LoadString(IDS_FALSE);

  POSITION pos = m_bOldValueList.GetHeadPosition();
  while (pos != NULL)
  {
    BOOL bValue = m_bOldValueList.GetNext(pos);
    SendDlgItemMessage(IDC_VALUE_LIST, LB_ADDSTRING, 0, (LPARAM)(LPCWSTR)(bValue ? szTrue : szFalse));
  }

  //
  // The remove button should be disabled until something is selected in the listbox
  //
  GetDlgItem(IDC_ATTR_REMOVE_BUTTON)->EnableWindow(FALSE);

  ManageButtonStates();

  //
  // Update the width of the list box
  //
  UpdateListboxHorizontalExtent();

  if (m_bReadOnly)
  {
     GetDlgItem(IDC_TRUE_RADIO)->EnableWindow(FALSE);
     GetDlgItem(IDC_FALSE_RADIO)->EnableWindow(FALSE);
     GetDlgItem(IDC_ATTR_REMOVE_BUTTON)->EnableWindow(FALSE);
     GetDlgItem(IDC_ATTR_ADD_BUTTON)->EnableWindow(FALSE);
  }

  //
  // NOTE: I have explicitly set the focus so return 0
  //
  return FALSE;
}

void CMultiBooleanEditor::OnOK()
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  if (!m_bReadOnly)
  {
     //
     // Get the values out of the list box
     //
     m_bNewValueList.RemoveAll();

     CString szTrue;
     szTrue.LoadString(IDS_TRUE);

     CListBox* pListBox = reinterpret_cast<CListBox*>(GetDlgItem(IDC_VALUE_LIST));
     if (pListBox != NULL)
     {
       int iCount = pListBox->GetCount();
       for (int idx = 0; idx < iCount; idx++)
       {
         CString szNewValue;
         pListBox->GetText(idx, szNewValue);

         if (szNewValue.CompareNoCase(szTrue) == 0)
         {
            m_bNewValueList.AddTail(TRUE);
         }
         else
         {
            m_bNewValueList.AddTail(FALSE);
         }
       }
     }
  }
  CDialog::OnOK();
}

void CMultiBooleanEditor::OnAddButton()
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  if (!m_bReadOnly)
  {
     //
     // Add the value to the list box and clear the edit field
     //
     CString szNewValue;
     LRESULT result = SendDlgItemMessage(IDC_TRUE_RADIO, BM_GETCHECK, 0, 0);
     if (result == BST_CHECKED)
     {
       szNewValue.LoadString(IDS_TRUE);
     }
     else
     {
       szNewValue.LoadString(IDS_FALSE);
     }

     SendDlgItemMessage(IDC_VALUE_LIST, LB_ADDSTRING, 0, (LPARAM)(LPCWSTR)szNewValue);

     ManageButtonStates();

     //
     // Update the width of the list box
     //
     UpdateListboxHorizontalExtent();
  }
}

void CMultiBooleanEditor::OnRemoveButton()
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  if (!m_bReadOnly)
  {
     CListBox* pListBox = reinterpret_cast<CListBox*>(GetDlgItem(IDC_VALUE_LIST));
     if (pListBox != NULL)
     {
       int iCurSel = pListBox->GetCurSel();
       if (iCurSel != LB_ERR)
       {
         //
         // Put the old value into the radio buttons
         //
         CString szOldValue;
         pListBox->GetText(iCurSel, szOldValue);
         SetDlgItemText(IDC_VALUE_EDIT, szOldValue);

         CString szTrue;
         szTrue.LoadString(IDS_TRUE);

         if (szOldValue.CompareNoCase(szTrue) == 0)
         {
            SendDlgItemMessage(IDC_TRUE_RADIO, BM_SETCHECK, BST_CHECKED, 0);
            SendDlgItemMessage(IDC_FALSE_RADIO, BM_SETCHECK, BST_UNCHECKED, 0);
         }
         else
         {
            SendDlgItemMessage(IDC_TRUE_RADIO, BM_SETCHECK, BST_UNCHECKED, 0);
            SendDlgItemMessage(IDC_FALSE_RADIO, BM_SETCHECK, BST_CHECKED, 0);
         }

         //
         // Delete the item from the list box
         //
         pListBox->DeleteString(iCurSel);
       }
     }

     //
     // Manage Button States
     //
     ManageButtonStates();

     //
     // Update the width of the list box
     //
     UpdateListboxHorizontalExtent();
  }
}

void CMultiBooleanEditor::ManageButtonStates()
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  if (m_bReadOnly)
  {
     GetDlgItem(IDC_TRUE_RADIO)->EnableWindow(FALSE);
     GetDlgItem(IDC_FALSE_RADIO)->EnableWindow(FALSE);
     GetDlgItem(IDC_ATTR_REMOVE_BUTTON)->EnableWindow(FALSE);
     GetDlgItem(IDC_ATTR_ADD_BUTTON)->EnableWindow(FALSE);
  }
  else
  {
     //
     // Change the default button to the Add button
     //
     LRESULT trueResult = SendDlgItemMessage(IDC_TRUE_RADIO, BM_GETCHECK, 0, 0);
     LRESULT falseResult = SendDlgItemMessage(IDC_FALSE_RADIO, BM_GETCHECK, 0, 0);

     if (trueResult != BST_CHECKED &&
         falseResult != BST_CHECKED)
     {
       //
       // Set the default button to OK
       //
       SendMessage(DM_SETDEFID, (WPARAM)IDOK, 0);
       SendDlgItemMessage(IDC_ATTR_ADD_BUTTON, 
                          BM_SETSTYLE, 
                          BS_PUSHBUTTON, 
                          MAKELPARAM(TRUE, 0));
       SendDlgItemMessage(IDOK,
                          BM_SETSTYLE,
                          BS_DEFPUSHBUTTON,
                          MAKELPARAM(TRUE, 0));
     }
     else
     {
       //
       // Set the default button to the Add button
       //
       SendMessage(DM_SETDEFID, (WPARAM)IDC_ATTR_ADD_BUTTON, 0);
       SendDlgItemMessage(IDOK, 
                          BM_SETSTYLE, 
                          BS_PUSHBUTTON, 
                          MAKELPARAM(TRUE, 0));
       SendDlgItemMessage(IDC_ATTR_ADD_BUTTON,
                          BM_SETSTYLE,
                          BS_DEFPUSHBUTTON,
                          MAKELPARAM(TRUE, 0));
     }

     LRESULT lSelection = SendDlgItemMessage(IDC_VALUE_LIST, LB_GETCURSEL, 0, 0);
     if (lSelection != LB_ERR)
     {
       GetDlgItem(IDC_ATTR_REMOVE_BUTTON)->EnableWindow(TRUE);
     }
     else
     {
       GetDlgItem(IDC_ATTR_REMOVE_BUTTON)->EnableWindow(FALSE);
     }
  }
}

void CMultiBooleanEditor::OnListSelChange()
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  ManageButtonStates();
}

void CMultiBooleanEditor::OnRadioChange()
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  ManageButtonStates();
}

void CMultiBooleanEditor::UpdateListboxHorizontalExtent()
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  int nHorzExtent = 0;
  CListBox* pListBox = reinterpret_cast<CListBox*>(GetDlgItem(IDC_VALUE_LIST));
  if (pListBox != NULL)
  {
     CClientDC dc(pListBox);
     int nItems = pListBox->GetCount();
     for (int i=0; i < nItems; i++)
     {
        TEXTMETRIC tm = {0};
        VERIFY(dc.GetTextMetrics(&tm));
        CString szBuffer;
        pListBox->GetText(i, szBuffer);
        CSize ext = dc.GetTextExtent(szBuffer,szBuffer.GetLength());
        nHorzExtent = max(ext.cx ,nHorzExtent); 
     }
     pListBox->SetHorizontalExtent(nHorzExtent);
  }
}

HRESULT CMultiBooleanEditor::Initialize(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  HRESULT hr = S_OK;

  if (SUCCEEDED(CValueEditDialog::Initialize(pAttributeEditorInfo)))
  {
    if (pAttributeEditorInfo->dwNumValues > 0 &&
        pAttributeEditorInfo->pADsValue != NULL)
    {
      for (int idx = 0; idx < pAttributeEditorInfo->dwNumValues; idx++)
      {
        switch (pAttributeEditorInfo->pADsValue[idx].dwType)
        {
          case ADSTYPE_BOOLEAN:
            m_bOldValueList.AddTail(pAttributeEditorInfo->pADsValue[idx].Boolean);
            break;

          default:
            ASSERT(FALSE);
            break;
        }
      }
    }
  }
  return hr;
}

HRESULT CMultiBooleanEditor::GetNewValue(PADSVALUE* ppADsValue, DWORD* pdwNumValues)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  HRESULT hr = S_OK;

  if (ppADsValue == NULL ||
      pdwNumValues == NULL)
  {
    return E_OUTOFMEMORY;
  }

  int iCount = m_bNewValueList.GetCount();
  if (iCount == 0)
  {
    *ppADsValue = NULL;
    *pdwNumValues = 0;
  }
  else
  {
    *ppADsValue = new ADSVALUE[iCount];
    if (*ppADsValue != NULL)
    {
      *pdwNumValues = iCount;

      int idx = 0;
      POSITION pos = m_bNewValueList.GetHeadPosition();
      while (pos != NULL)
      {
        BOOL bNewValue = m_bNewValueList.GetNext(pos);

        (*ppADsValue)[idx].dwType = m_pOldADsValue->dwType;
        switch (m_pOldADsValue->dwType)
        {
          case ADSTYPE_BOOLEAN:
            (*ppADsValue)[idx].Boolean = bNewValue;
            break;

          default:
            ASSERT(FALSE);

            DeleteADsValues(*ppADsValue, *pdwNumValues);
            *ppADsValue = NULL;
            *pdwNumValues = 0;
            hr = E_FAIL;
            break;
        }
        idx++;
      }
    }
    else
    {
      *ppADsValue = NULL;
      *pdwNumValues = 0;
      hr = E_OUTOFMEMORY;
    }
  }
  return hr;
}


///////////////////////////////////////////////////////////////////////////////////////
// CSingleTimeEditor

CValueEditDialog* CreateSingleTimeEditor(PCWSTR pszClass,
                                            PCWSTR pszAttribute,
                                            ADSTYPE adsType,
                                            BOOL bMultivalued)
{
  return new CSingleTimeEditor;
}

BEGIN_MESSAGE_MAP(CSingleTimeEditor, CValueEditDialog)
END_MESSAGE_MAP()

BOOL CSingleTimeEditor::OnInitDialog()
{
  //
  // Initialize the static control with the attribute name
  //
  SetDlgItemText(IDC_ATTRIBUTE_STATIC, m_szAttribute);

  if (m_bValueSet)
  {
    SendDlgItemMessage(IDC_DATE_PICKER, DTM_SETSYSTEMTIME, GDT_VALID, (LPARAM)&m_stOldValue);
    SendDlgItemMessage(IDC_TIME_PICKER, DTM_SETSYSTEMTIME, GDT_VALID, (LPARAM)&m_stOldValue);
  }
  else
  {
    SendDlgItemMessage(IDC_DATE_PICKER, DTM_SETSYSTEMTIME, GDT_NONE, (LPARAM)&m_stOldValue);
    SendDlgItemMessage(IDC_TIME_PICKER, DTM_SETSYSTEMTIME, GDT_NONE, (LPARAM)&m_stOldValue);
  }

  if (m_bReadOnly)
  {
     GetDlgItem(IDC_DATE_PICKER)->EnableWindow(FALSE);
     GetDlgItem(IDC_TIME_PICKER)->EnableWindow(FALSE);
  }

  return CDialog::OnInitDialog();
}

void CSingleTimeEditor::OnOK()
{
  if (!m_bReadOnly)
  {
     SYSTEMTIME stDateResult = {0};
     SYSTEMTIME stTimeResult = {0};

     LRESULT lDateRes = SendDlgItemMessage(IDC_DATE_PICKER, DTM_GETSYSTEMTIME, 0, (LPARAM)&stDateResult);
     LRESULT lTimeRes = SendDlgItemMessage(IDC_TIME_PICKER, DTM_GETSYSTEMTIME, 0, (LPARAM)&stTimeResult);

     if (lDateRes == GDT_VALID ||
         lTimeRes == GDT_VALID)
     {
       memcpy(&m_stNewValue, &stDateResult, sizeof(SYSTEMTIME));
       m_stNewValue.wHour = stTimeResult.wHour;
       m_stNewValue.wMinute = stTimeResult.wMinute;
       m_stNewValue.wSecond = stTimeResult.wSecond;
       m_stNewValue.wMilliseconds = stTimeResult.wMilliseconds;
     }
  }
  CDialog::OnOK();
}

HRESULT CSingleTimeEditor::Initialize(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo)
{
  HRESULT hr = S_OK;

  if (SUCCEEDED(CValueEditDialog::Initialize(pAttributeEditorInfo)))
  {
    if (pAttributeEditorInfo->dwNumValues > 0 &&
        pAttributeEditorInfo->pADsValue != NULL)
    {
      switch (pAttributeEditorInfo->pADsValue->dwType)
      {
        case ADSTYPE_UTC_TIME:
            // NOTICE-2002/03/05-artm  memcpy() OK...
            // arg1 always valid pointer; arg2 valid ptr if 
            // pAttributeEditorInfo->pADsValue not NULL
            // (which is the case if we've gotten this far)
          memcpy(&m_stOldValue, &(pAttributeEditorInfo->pADsValue->UTCTime), sizeof(SYSTEMTIME));
          m_bValueSet = TRUE;
          break;

        default:
          ASSERT(FALSE);
          // NTRAID#NTBUG9-565760-2002/03/05-artm  Release code should return error code,
          // not S_OK.
          break;
      }
    }
    else
    {
      m_bValueSet = FALSE;
    }
  }
  return hr;
}


HRESULT CSingleTimeEditor::GetNewValue(PADSVALUE* ppADsValue, DWORD* pdwNumValues)
{
  HRESULT hr = S_OK;

  if (ppADsValue == NULL ||
      pdwNumValues == NULL)
  {
    return E_OUTOFMEMORY;
  }

  *ppADsValue = new ADSVALUE;
  if (*ppADsValue != NULL)
  {
    *pdwNumValues = 1;
    (*ppADsValue)->dwType = m_pOldADsValue->dwType;
    switch (m_pOldADsValue->dwType)
    {
      case ADSTYPE_UTC_TIME:
        memcpy(&((*ppADsValue)->UTCTime), &m_stNewValue, sizeof(SYSTEMTIME));
        break;

      default:
        ASSERT(FALSE);
        DeleteADsValues(*ppADsValue, *pdwNumValues);
        *ppADsValue = NULL;
        *pdwNumValues = 0;
        hr = E_FAIL;
        break;
    }
  }
  else
  {
    *pdwNumValues = 0;
    hr = E_OUTOFMEMORY;
  }
  return hr;
}


///////////////////////////////////////////////////////////////////////////////////////
// CMultiTimeEditor

CValueEditDialog* CreateMultiTimeEditor(PCWSTR pszClass,
                                           PCWSTR pszAttribute,
                                           ADSTYPE adsType,
                                           BOOL bMultivalued)
{
  return new CMultiTimeEditor;
}

BEGIN_MESSAGE_MAP(CMultiTimeEditor, CValueEditDialog)
  ON_BN_CLICKED(IDC_ATTR_ADD_BUTTON, OnAddButton)
  ON_BN_CLICKED(IDC_ATTR_REMOVE_BUTTON, OnRemoveButton)
  ON_LBN_SELCHANGE(IDC_VALUE_LIST, OnListSelChange)
END_MESSAGE_MAP()

BOOL CMultiTimeEditor::OnInitDialog()
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  CDialog::OnInitDialog();

  //
  // Set the attribute name static
  //
  SetDlgItemText(IDC_ATTRIBUTE_STATIC, m_szAttribute);

  //
  // Fill the list box with the current values
  //
  CListBox* pListBox = reinterpret_cast<CListBox*>(GetDlgItem(IDC_VALUE_LIST));

  POSITION pos = m_stOldValueList.GetHeadPosition();
  while (pos != NULL)
  {
    SYSTEMTIME* pstValue = m_stOldValueList.GetNext(pos);

    CString szValue = GetStringValueFromSystemTime(pstValue);
    int index = pListBox->AddString(szValue);
    if (LB_ERR != index)
    {
      pListBox->SetItemDataPtr(index, pstValue);
    }
  }

  //
  // The remove button should be disabled until something is selected in the listbox
  //
  GetDlgItem(IDC_ATTR_REMOVE_BUTTON)->EnableWindow(FALSE);

  ManageButtonStates();

  //
  // Update the width of the list box
  //
  UpdateListboxHorizontalExtent();

  if (m_bReadOnly)
  {
     GetDlgItem(IDC_ATTR_REMOVE_BUTTON)->EnableWindow(FALSE);
     GetDlgItem(IDC_ATTR_ADD_BUTTON)->EnableWindow(FALSE);
     GetDlgItem(IDC_DATE_PICKER)->EnableWindow(FALSE);
     GetDlgItem(IDC_TIME_PICKER)->EnableWindow(FALSE);
  }

  //
  // NOTE: I have explicitly set the focus so return 0
  //
  return FALSE;
}

void CMultiTimeEditor::OnOK()
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  if (!m_bReadOnly)
  {
     //
     // Get the values out of the list box
     //
     m_stNewValueList.RemoveAll();

     CListBox* pListBox = reinterpret_cast<CListBox*>(GetDlgItem(IDC_VALUE_LIST));
     if (pListBox != NULL)
     {
       int iCount = pListBox->GetCount();
       for (int idx = 0; idx < iCount; idx++)
       {
         SYSTEMTIME* pstValue = reinterpret_cast<SYSTEMTIME*>(pListBox->GetItemDataPtr(idx));
         m_stNewValueList.AddTail(pstValue);
       }
     }
  }
  CDialog::OnOK();
}

void CMultiTimeEditor::OnAddButton()
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  if (!m_bReadOnly)
  {
     //
     // Add the value to the list box and clear the edit field
     //

     SYSTEMTIME stDateResult = {0};
     SYSTEMTIME stTimeResult = {0};
     SYSTEMTIME* pstFullResult = new SYSTEMTIME;
     if (!pstFullResult)
     {
        return;
     }

     ZeroMemory(pstFullResult, sizeof(SYSTEMTIME));

     LRESULT lDateRes = SendDlgItemMessage(IDC_DATE_PICKER, DTM_GETSYSTEMTIME, 0, (LPARAM)&stDateResult);
     LRESULT lTimeRes = SendDlgItemMessage(IDC_TIME_PICKER, DTM_GETSYSTEMTIME, 0, (LPARAM)&stTimeResult);

     if (lDateRes == GDT_VALID ||
         lTimeRes == GDT_VALID)
     {
       memcpy(pstFullResult, &stDateResult, sizeof(SYSTEMTIME));
       pstFullResult->wHour = stTimeResult.wHour;
       pstFullResult->wMinute = stTimeResult.wMinute;
       pstFullResult->wSecond = stTimeResult.wSecond;
       pstFullResult->wMilliseconds = stTimeResult.wMilliseconds;

       // Convert into a string that can be added to the list

       CListBox* pListBox = reinterpret_cast<CListBox*>(GetDlgItem(IDC_VALUE_LIST));
       if (pListBox != NULL)
       {
         CString szValue = GetStringValueFromSystemTime(pstFullResult);
         int index = pListBox->AddString(szValue);
         if (LB_ERR != index)
         {
           pListBox->SetItemDataPtr(index, pstFullResult);
         }
       }
     }


     ManageButtonStates();

     //
     // Update the width of the list box
     //
     UpdateListboxHorizontalExtent();
  }
}

void CMultiTimeEditor::OnRemoveButton()
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  if (!m_bReadOnly)
  {
     CListBox* pListBox = reinterpret_cast<CListBox*>(GetDlgItem(IDC_VALUE_LIST));
     if (pListBox != NULL)
     {
       int iCurSel = pListBox->GetCurSel();
       if (iCurSel != LB_ERR)
       {
         //
         // Delete the item from the list box
         //
         pListBox->DeleteString(iCurSel);
       }
     }

     //
     // Manage Button States
     //
     ManageButtonStates();

     //
     // Update the width of the list box
     //
     UpdateListboxHorizontalExtent();
  }
}

void CMultiTimeEditor::ManageButtonStates()
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  if (m_bReadOnly)
  {
     GetDlgItem(IDC_ATTR_REMOVE_BUTTON)->EnableWindow(FALSE);
     GetDlgItem(IDC_ATTR_ADD_BUTTON)->EnableWindow(FALSE);
     GetDlgItem(IDC_DATE_PICKER)->EnableWindow(FALSE);
     GetDlgItem(IDC_TIME_PICKER)->EnableWindow(FALSE);
  }
  else
  {
     //
     // Change the default button to the Add button
     //
     SYSTEMTIME stDateResult = {0};
     SYSTEMTIME stTimeResult = {0};

     LRESULT lDateRes = SendDlgItemMessage(IDC_DATE_PICKER, DTM_GETSYSTEMTIME, 0, (LPARAM)&stDateResult);
     LRESULT lTimeRes = SendDlgItemMessage(IDC_TIME_PICKER, DTM_GETSYSTEMTIME, 0, (LPARAM)&stTimeResult);

     if (lDateRes == GDT_VALID &&
         lTimeRes == GDT_VALID)
     {
       //
       // Set the default button to OK
       //
       SendMessage(DM_SETDEFID, (WPARAM)IDOK, 0);
       SendDlgItemMessage(IDC_ATTR_ADD_BUTTON, 
                          BM_SETSTYLE, 
                          BS_PUSHBUTTON, 
                          MAKELPARAM(TRUE, 0));
       SendDlgItemMessage(IDOK,
                          BM_SETSTYLE,
                          BS_DEFPUSHBUTTON,
                          MAKELPARAM(TRUE, 0));
     }
     else
     {
       //
       // Set the default button to the Add button
       //
       SendMessage(DM_SETDEFID, (WPARAM)IDC_ATTR_ADD_BUTTON, 0);
       SendDlgItemMessage(IDOK, 
                          BM_SETSTYLE, 
                          BS_PUSHBUTTON, 
                          MAKELPARAM(TRUE, 0));
       SendDlgItemMessage(IDC_ATTR_ADD_BUTTON,
                          BM_SETSTYLE,
                          BS_DEFPUSHBUTTON,
                          MAKELPARAM(TRUE, 0));
     }

     LRESULT lSelection = SendDlgItemMessage(IDC_VALUE_LIST, LB_GETCURSEL, 0, 0);
     if (lSelection != LB_ERR)
     {
       GetDlgItem(IDC_ATTR_REMOVE_BUTTON)->EnableWindow(TRUE);
     }
     else
     {
       GetDlgItem(IDC_ATTR_REMOVE_BUTTON)->EnableWindow(FALSE);
     }
  }
}

void CMultiTimeEditor::OnListSelChange()
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  ManageButtonStates();
}

void CMultiTimeEditor::UpdateListboxHorizontalExtent()
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  int nHorzExtent = 0;
  CListBox* pListBox = reinterpret_cast<CListBox*>(GetDlgItem(IDC_VALUE_LIST));
  if (pListBox != NULL)
  {
     CClientDC dc(pListBox);
     int nItems = pListBox->GetCount();
     for (int i=0; i < nItems; i++)
     {
        TEXTMETRIC tm = {0};
        VERIFY(dc.GetTextMetrics(&tm));
        CString szBuffer;
        pListBox->GetText(i, szBuffer);
        CSize ext = dc.GetTextExtent(szBuffer,szBuffer.GetLength());
        nHorzExtent = max(ext.cx ,nHorzExtent); 
     }
     pListBox->SetHorizontalExtent(nHorzExtent);
  }
}

HRESULT CMultiTimeEditor::Initialize(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  HRESULT hr = S_OK;

  if (SUCCEEDED(CValueEditDialog::Initialize(pAttributeEditorInfo)))
  {
    if (pAttributeEditorInfo->dwNumValues > 0 &&
        pAttributeEditorInfo->pADsValue != NULL)
    {
      for (int idx = 0; idx < pAttributeEditorInfo->dwNumValues; idx++)
      {
        switch (pAttributeEditorInfo->pADsValue[idx].dwType)
        {
          case ADSTYPE_UTC_TIME:
            m_stOldValueList.AddTail(&(pAttributeEditorInfo->pADsValue[idx].UTCTime));
            break;

          default:
            ASSERT(FALSE);
            break;
        }
      }
    }
  }
  return hr;
}

HRESULT CMultiTimeEditor::GetNewValue(PADSVALUE* ppADsValue, DWORD* pdwNumValues)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  HRESULT hr = S_OK;

  if (ppADsValue == NULL ||
      pdwNumValues == NULL)
  {
    return E_OUTOFMEMORY;
  }

  int iCount = m_stNewValueList.GetCount();
  if (iCount == 0)
  {
    *ppADsValue = NULL;
    *pdwNumValues = 0;
  }
  else
  {
    *ppADsValue = new ADSVALUE[iCount];
    if (*ppADsValue != NULL)
    {
      *pdwNumValues = iCount;

      int idx = 0;
      POSITION pos = m_stNewValueList.GetHeadPosition();
      while (pos != NULL)
      {
        SYSTEMTIME* pstNewValue = m_stNewValueList.GetNext(pos);

        (*ppADsValue)[idx].dwType = m_pOldADsValue->dwType;
        switch (m_pOldADsValue->dwType)
        {
          case ADSTYPE_UTC_TIME:
            memcpy(&((*ppADsValue)[idx].UTCTime), pstNewValue, sizeof(SYSTEMTIME));
            break;

          default:
            ASSERT(FALSE);
            DeleteADsValues(*ppADsValue, *pdwNumValues);
            *ppADsValue = NULL;
            *pdwNumValues = 0;
            hr = E_FAIL;
            break;
        }
        idx++;
      }
    }
    else
    {
      *ppADsValue = NULL;
      *pdwNumValues = 0;
      hr = E_OUTOFMEMORY;
    }
  }
  return hr;
}


///////////////////////////////////////////////////////////////////////////////////////
// COctetStringEditor

CValueEditDialog* CreateSingleOctetStringEditor(PCWSTR pszClass,
                                                PCWSTR pszAttribute,
                                                ADSTYPE adsType,
                                                BOOL bMultivalued)
{
  return new COctetStringEditor;
}

BEGIN_MESSAGE_MAP(COctetStringEditor, CValueEditDialog)
  ON_EN_CHANGE(IDC_PROCESS_EDIT, OnProcessEdit)
  ON_BN_CLICKED(IDC_ATTR_EDIT_BUTTON, OnEditButton)
  ON_BN_CLICKED(IDC_CLEAR_BUTTON, OnClearButton)
END_MESSAGE_MAP()

BOOL COctetStringEditor::OnInitDialog()
{
  //
  // Initialize the static control with the attribute name
  //
  SetDlgItemText(IDC_ATTRIBUTE_STATIC, m_szAttribute);

  DWORD dwDisplayFlags = BYTE_ARRAY_DISPLAY_HEX   |
                         BYTE_ARRAY_DISPLAY_DEC   |
                         BYTE_ARRAY_DISPLAY_OCT   |
                         BYTE_ARRAY_DISPLAY_BIN;

  VERIFY(m_display.Initialize(IDC_VALUE_EDIT, 
                              IDC_VIEW_TYPE_COMBO,
                              dwDisplayFlags,
                              BYTE_ARRAY_DISPLAY_HEX,   // default display
                              this,
                              1024,
                              IDS_OCTET_DISPLAY_SIZE_EXCEEDED));                   // Only show 1K of data in the edit box

  m_display.SetData(m_pOldValue, m_dwOldLength);

  if (m_bReadOnly)
  {
     SendDlgItemMessage(IDC_VALUE_EDIT, EM_SETREADONLY, TRUE, 0);
     GetDlgItem(IDC_CLEAR_BUTTON)->EnableWindow(FALSE);

     CString szView;
     BOOL bResult = szView.LoadString(IDS_VIEW);
     ASSERT(bResult);
     SetDlgItemText(IDC_ATTR_EDIT_BUTTON, szView);
  }

  return CDialog::OnInitDialog();
}

void COctetStringEditor::OnOK()
{
  if (!m_bReadOnly)
  {
     //
     // Retrieve the new values from the control
     //
     if (m_pNewValue)
     {
       delete[] m_pNewValue;
       m_pNewValue = 0;
       m_dwNewLength = 0;
     }
     m_dwNewLength = m_display.GetData(&m_pNewValue);
  }

  CDialog::OnOK();
}

void COctetStringEditor::OnProcessEdit()
{
  CString szProcess;
  GetDlgItemText(IDC_PROCESS_EDIT, szProcess);
  if (szProcess.IsEmpty())
  {
    GetDlgItem(IDC_ATTR_EDIT_BUTTON)->EnableWindow(FALSE);

    //
    // Set the default button to OK
    //
    SendMessage(DM_SETDEFID, (WPARAM)IDOK, 0);
    SendDlgItemMessage(IDC_ATTR_EDIT_BUTTON, 
                       BM_SETSTYLE, 
                       BS_PUSHBUTTON, 
                       MAKELPARAM(TRUE, 0));
    SendDlgItemMessage(IDOK,
                       BM_SETSTYLE,
                       BS_DEFPUSHBUTTON,
                       MAKELPARAM(TRUE, 0));
  }
  else
  {
    GetDlgItem(IDC_ATTR_EDIT_BUTTON)->EnableWindow(TRUE);

    //
    // Set the default button to the Edit button
    //
    SendMessage(DM_SETDEFID, (WPARAM)IDC_ATTR_EDIT_BUTTON, 0);
    SendDlgItemMessage(IDOK, 
                       BM_SETSTYLE, 
                       BS_PUSHBUTTON, 
                       MAKELPARAM(TRUE, 0));
    SendDlgItemMessage(IDC_ATTR_EDIT_BUTTON,
                       BM_SETSTYLE,
                       BS_DEFPUSHBUTTON,
                       MAKELPARAM(TRUE, 0));
  }
}

void COctetStringEditor::OnEditButton()
{
  CString szProcess;
  GetDlgItemText(IDC_PROCESS_EDIT, szProcess);

  //
  // Create a temp file and write out the contents of the octet string
  //
  WCHAR szTempPath[MAX_PATH];
  if (!::GetTempPath(MAX_PATH, szTempPath))
  {
    ADSIEditMessageBox(IDS_MSG_FAIL_CREATE_TEMPFILE, MB_OK);
    return;
  }
  
  CString szDataPath;
  if (!::GetTempFileName(szTempPath, _T("attredit"), 0x0, szDataPath.GetBuffer(MAX_PATH)))
  {
    ADSIEditMessageBox(IDS_MSG_FAIL_CREATE_TEMPFILE, MB_OK);
    return;
  }
  szDataPath.ReleaseBuffer();

  //
  // Open the temp file so we can write out the data
  //
  CFile tempDataFile;
  if (!tempDataFile.Open(szDataPath, 
      CFile::modeCreate | CFile::modeReadWrite |CFile::shareExclusive | CFile::typeBinary))
  {
    //
    // Failed to open temp file, display error message
    //
    ADSIEditMessageBox(IDS_MSG_FAIL_CREATE_TEMPFILE, MB_OK);
    return;
  }

  //
  // Write the byte array to a temp file
  //
  BYTE* pData = 0;
  DWORD dwDataLength = m_display.GetData(&pData);
  if (dwDataLength != 0 && pData)
  {
    tempDataFile.Write(pData, dwDataLength);
  }
  tempDataFile.Close();

  if (pData)
  {
    delete[] pData;
    pData = 0;
  }
  dwDataLength = 0;

  //
  // Construct the command line from the executable and the temp file
  //
  CString szCommandLine = szProcess + L" " + szDataPath;

  //
  // Launch the process with the temp file as an argument
  //
    STARTUPINFO             si;
    PROCESS_INFORMATION     pi;

  ::ZeroMemory(&pi,sizeof(PROCESS_INFORMATION));
  ::ZeroMemory(&si,sizeof(STARTUPINFO));
   si.cb       = sizeof (STARTUPINFO);

   // NTRAID#NTBUG9-566011-2002/03/05-artm  CreateProcess() incorrectly used.
   // Vulnerability exists b/c application name is NULL, meaning that
   // the first whitespace delimited token in the command line is the
   // executable name.  This opens up a hole for trojan programs
   // (e.g. C:\Program.exe).
   //
   // Since we have the process name separate from data path, 
   // fix is to pass szProcess as first argument and szDataPath
   // as command line argument.
   //
   // I couldn't tell if the program name and data path were
   // complete paths or not---but they should be if they are not!
  if(CreateProcess(  NULL,             
                          (LPWSTR)(LPCWSTR)szCommandLine,         
                          NULL,              
                          NULL,              
                          FALSE,          
                          0,              
                          NULL,           
                          NULL,           
                          &si,                
                          &pi) )             
   {
      // wait to finish the runing setup process
      WaitForSingleObject(pi.hProcess,INFINITE);
   
      // close process handle
      if (pi.hProcess && pi.hProcess != INVALID_HANDLE_VALUE)
      {
         CloseHandle (pi.hProcess) ;
      }
      if (pi.hThread && pi.hThread != INVALID_HANDLE_VALUE)
      {
         CloseHandle (pi.hThread) ;
      }
  }
  else
  {
    ADSIEditMessageBox(IDS_MSG_FAIL_LAUNCH_PROCESS, MB_OK);
    return;
  }

  if (!m_bReadOnly)
  {
     //
     // Load the data from the saved temp file
     //
     if (!LoadFileAsByteArray(szDataPath, &pData, &dwDataLength))
     {
       ADSIEditMessageBox(IDS_MSG_FAIL_RETRIEVE_SAVED_DATA, MB_OK);
       return;
     }

     //
     // Delete temp file after picture is displayed
     //
     CFile::Remove(szDataPath);

     //
     // Update the UI with the new data
     //
     m_display.SetData(pData, dwDataLength);
  }
}


void COctetStringEditor::OnClearButton()
{
  if (!m_bReadOnly)
  {
     m_display.ClearData();
  }
}

HRESULT COctetStringEditor::Initialize(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo)
{
  HRESULT hr = S_OK;

  if (SUCCEEDED(CValueEditDialog::Initialize(pAttributeEditorInfo)))
  {
    if (pAttributeEditorInfo->dwNumValues > 0 &&
        pAttributeEditorInfo->pADsValue)
    {
      switch (pAttributeEditorInfo->pADsValue->dwType)
      {
        case ADSTYPE_OCTET_STRING:
          m_dwOldLength = pAttributeEditorInfo->pADsValue->OctetString.dwLength;
          m_pOldValue = new BYTE[m_dwOldLength];
          if (m_pOldValue)
          { 
              // NOTICE-2002/03/05-artm  memcpy() OK.
              // arg1 is same size as lpValue
            memcpy(m_pOldValue, pAttributeEditorInfo->pADsValue->OctetString.lpValue, m_dwOldLength);
          }
          else
          {
            hr = E_OUTOFMEMORY;
          }

          m_bValueSet = TRUE;
          break;

        default:
          ASSERT(FALSE);
          break;
      }
    }
    else
    {
      m_bValueSet = FALSE;
    }
  }
  return hr;
}


HRESULT COctetStringEditor::GetNewValue(PADSVALUE* ppADsValue, DWORD* pdwNumValues)
{
  HRESULT hr = S_OK;

  if (ppADsValue == NULL ||
      pdwNumValues == NULL)
  {
    return E_OUTOFMEMORY;
  }

  if (m_dwNewLength > 0 && m_pNewValue)
  {
    *ppADsValue = new ADSVALUE;
    if (*ppADsValue)
    {
      *pdwNumValues = 1;
      (*ppADsValue)->dwType = m_pOldADsValue->dwType;
      switch (m_pOldADsValue->dwType)
      {
        case ADSTYPE_OCTET_STRING:
          (*ppADsValue)->OctetString.dwLength = m_dwNewLength;
          (*ppADsValue)->OctetString.lpValue = new BYTE[m_dwNewLength];
          if ((*ppADsValue)->OctetString.lpValue)
          {
           // NOTICE-2002/03/05-artm  memcpy() OK.
           // arg1 and arg2 both m_dwNewLength in size.
            memcpy((*ppADsValue)->OctetString.lpValue, m_pNewValue, m_dwNewLength);
          }
          else
          {
            hr = E_OUTOFMEMORY;
          }
          break;

        default:
          ASSERT(FALSE);
          DeleteADsValues(*ppADsValue, *pdwNumValues);
          *ppADsValue = 0;
          *pdwNumValues = 0;
          hr = E_FAIL;
          break;
      }
    }
    else
    {
      *pdwNumValues = 0;
      hr = E_OUTOFMEMORY;
    }
  }
  else
  {
    *ppADsValue = 0;
    *pdwNumValues = 0;
  }
  return hr;
}

CValueEditDialog* CreateMultiOctetStringEditor(PCWSTR pszClass,
                                               PCWSTR pszAttribute,
                                               ADSTYPE adsType,
                                               BOOL bMultivalued)
{
  return new CMultiOctetStringEditor;
}


BEGIN_MESSAGE_MAP(CMultiOctetStringEditor, CValueEditDialog)
  ON_BN_CLICKED(IDC_ATTR_ADD_BUTTON, OnAddButton)
  ON_BN_CLICKED(IDC_ATTR_REMOVE_BUTTON, OnRemoveButton)
  ON_BN_CLICKED(IDC_EDIT_BUTTON, OnEditButton)
  ON_LBN_SELCHANGE(IDC_VALUE_LIST, OnListSelChange)
END_MESSAGE_MAP()

BOOL CMultiOctetStringEditor::OnInitDialog()
{
  CDialog::OnInitDialog();

  //
  // Set the attribute name static
  //
  SetDlgItemText(IDC_ATTRIBUTE_STATIC, m_szAttribute);

  //
  // Fill the list box with the current values
  //
  POSITION pos = m_OldValueList.GetHeadPosition();
  while (pos)
  {
    PADSVALUE pADsValue = m_OldValueList.GetNext(pos);
    if (pADsValue)
    {
      CString szValue;
      GetStringFromADsValue(pADsValue, szValue, MAX_OCTET_STRING_VALUE_LENGTH);
      LRESULT lIdx = SendDlgItemMessage(IDC_VALUE_LIST, 
                                        LB_ADDSTRING, 
                                        0, 
                                        (LPARAM)(LPCWSTR)szValue);
      if (lIdx != LB_ERR &&
          lIdx != LB_ERRSPACE)
      {
        LRESULT lSetData = SendDlgItemMessage(IDC_VALUE_LIST, 
                                              LB_SETITEMDATA, 
                                              (WPARAM)lIdx, 
                                              (LPARAM)pADsValue);
        if (lSetData == LB_ERR)
        {
          ASSERT(lSetData != LB_ERR);
          continue;
        }
      }
    }
  }

  //
  // The remove button should be disabled until something is selected in the listbox
  //
  GetDlgItem(IDC_ATTR_REMOVE_BUTTON)->EnableWindow(FALSE);
  SendDlgItemMessage(IDC_VALUE_LIST, LB_SETCURSEL, 0, 0);

  ManageButtonStates();

  //
  // Update the width of the list box
  //
  UpdateListboxHorizontalExtent();

  if (m_bReadOnly)
  {
     GetDlgItem(IDC_ATTR_REMOVE_BUTTON)->EnableWindow(FALSE);
     GetDlgItem(IDC_ATTR_ADD_BUTTON)->EnableWindow(FALSE);

     CString szView;
     BOOL bResult = szView.LoadString(IDS_VIEW);
     ASSERT(bResult);
     SetDlgItemText(IDC_EDIT_BUTTON, szView);
  }
  //
  // NOTE: I have explicitly set the focus so return 0
  //
  return FALSE;
}

void CMultiOctetStringEditor::OnOK()
{
  if (!m_bReadOnly)
  {
     //
     // Get the values out of the list box
     //
     m_NewValueList.RemoveAll();

     CListBox* pListBox = reinterpret_cast<CListBox*>(GetDlgItem(IDC_VALUE_LIST));
     if (pListBox != NULL)
     {
       int iCount = pListBox->GetCount();
       for (int idx = 0; idx < iCount; idx++)
       {
         CString szNewValue;
         LRESULT lData = SendDlgItemMessage(IDC_VALUE_LIST, 
                                            LB_GETITEMDATA, 
                                            (WPARAM)idx, 
                                            0);
         if (lData == LB_ERR)
         {
           ASSERT(lData != LB_ERR);
           continue;
         }

         m_NewValueList.AddTail(reinterpret_cast<PADSVALUE>(lData));
       }
     }
  }
  CDialog::OnOK();
}

void CMultiOctetStringEditor::OnEditButton()
{
  CThemeContextActivator activator;

  LRESULT lIdx = SendDlgItemMessage(IDC_VALUE_LIST, LB_GETCURSEL, 0, 0);
  if (lIdx == LB_ERR)
  {
    ASSERT(lIdx != LB_ERR);
    return;
  }

  LRESULT lData = SendDlgItemMessage(IDC_VALUE_LIST, LB_GETITEMDATA, (WPARAM)lIdx, 0);
  if (lData == LB_ERR)
  {
    ASSERT(lIdx != LB_ERR);
    return;
  }

  PADSVALUE pADsValue = reinterpret_cast<PADSVALUE>(lData);
  if (!pADsValue)
  {
    ASSERT(pADsValue);
    return;
  }

  DS_ATTRIBUTE_EDITORINFO attrEditInfo;
  ::ZeroMemory(&attrEditInfo, sizeof(DS_ATTRIBUTE_EDITORINFO));

  attrEditInfo.pADsValue = pADsValue;
  attrEditInfo.dwNumValues = 1;
  attrEditInfo.lpszClass = (PWSTR)(PCWSTR)m_szClass;
  attrEditInfo.lpszAttribute = (PWSTR)(PCWSTR)m_szAttribute;
  attrEditInfo.bMultivalued = FALSE;
  attrEditInfo.bReadOnly = m_bReadOnly;
  attrEditInfo.lpfnBind = m_pfnBindingFunction;
  attrEditInfo.lParam = m_lParam;

  COctetStringEditor dlg;
  HRESULT hr = dlg.Initialize(&attrEditInfo);
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr, IDS_FAILED_INITIALIZE_EDITOR, MB_OK | MB_ICONEXCLAMATION);
    return;
  }

  if (dlg.DoModal() == IDOK &&
      !m_bReadOnly)
  {
    PADSVALUE pNewADsValue = 0;
    DWORD dwNumNewValues = 0;
    hr = dlg.GetNewValue(&pNewADsValue, &dwNumNewValues);
    if (FAILED(hr))
    {
      ADSIEditErrorMessage(hr, IDS_FAILED_GET_NEW_VALUE_EDITOR, MB_OK | MB_ICONEXCLAMATION);
      return;
    }
    
    ASSERT(pNewADsValue);
    ASSERT(dwNumNewValues == 1);

    CString szNewValue;
    GetStringFromADsValue(pNewADsValue, szNewValue, MAX_OCTET_STRING_VALUE_LENGTH);
    ASSERT(!szNewValue.IsEmpty());

    LRESULT lNewIdx = SendDlgItemMessage(IDC_VALUE_LIST,
                                         LB_INSERTSTRING,
                                         lIdx + 1,
                                         (LPARAM)(PCWSTR)szNewValue);
    if (lNewIdx != LB_ERR)
    {
      //
      // Update the new item and delete the old
      //
      SendDlgItemMessage(IDC_VALUE_LIST, LB_SETITEMDATA, (WPARAM)lNewIdx, (LPARAM)pNewADsValue);
      SendDlgItemMessage(IDC_VALUE_LIST, LB_DELETESTRING, (WPARAM)lIdx, 0);
    }
    else
    {
      //
      // Since we had trouble adding the new item just update the old one.  The string
      // will be incorrect but the value will be fine.
      //
      SendDlgItemMessage(IDC_VALUE_LIST, LB_SETITEMDATA, (WPARAM)lIdx, (LPARAM)pNewADsValue);
    }
  }
}

void CMultiOctetStringEditor::OnRemoveButton()
{
  if (!m_bReadOnly)
  {
     CListBox* pListBox = reinterpret_cast<CListBox*>(GetDlgItem(IDC_VALUE_LIST));
     if (pListBox != NULL)
     {
       int iCurSel = pListBox->GetCurSel();
       if (iCurSel != LB_ERR)
       {
         //
         // Delete the item from the list box
         //
         pListBox->DeleteString(iCurSel);
       }
     }

     //
     // Manage Button States
     //
     ManageButtonStates();

     //
     // Update the width of the list box
     //
     UpdateListboxHorizontalExtent();
  }
}

void CMultiOctetStringEditor::OnAddButton()
{
  CThemeContextActivator activator;

  if (!m_bReadOnly)
  {
     DS_ATTRIBUTE_EDITORINFO attrEditInfo;
     ZeroMemory(&attrEditInfo, sizeof(DS_ATTRIBUTE_EDITORINFO));

     attrEditInfo.pADsValue = new ADSVALUE;
     if (attrEditInfo.pADsValue)
     {
       ::ZeroMemory(attrEditInfo.pADsValue, sizeof(ADSVALUE));
     }
     else
     {
       // NOTICE-NTRAID#NTBUG9-566088-2002/03/05-artm  If mem. allocation fails, short circuit function.
       // If we cannot allocate enough memory inform the user and return w/out
       // performing the rest of the operation.

       ADSIEditErrorMessage(E_OUTOFMEMORY);
       return;
     }

     attrEditInfo.pADsValue->dwType = ADSTYPE_OCTET_STRING;
     attrEditInfo.dwNumValues = 0;
     attrEditInfo.lpszClass = (PWSTR)(PCWSTR)m_szClass;
     attrEditInfo.lpszAttribute = (PWSTR)(PCWSTR)m_szAttribute;
     attrEditInfo.bMultivalued = FALSE;
     attrEditInfo.bReadOnly = m_bReadOnly;
     attrEditInfo.lpfnBind = m_pfnBindingFunction;
     attrEditInfo.lParam = m_lParam;

     COctetStringEditor dlg;
     HRESULT hr = dlg.Initialize(&attrEditInfo);
     if (FAILED(hr))
     {
       ADSIEditErrorMessage(hr, IDS_FAILED_INITIALIZE_EDITOR, MB_OK | MB_ICONEXCLAMATION);
       return;
     }

     if (dlg.DoModal() == IDOK)
     {
       PADSVALUE pNewADsValue = 0;
       DWORD dwNumNewValues = 0;
       hr = dlg.GetNewValue(&pNewADsValue, &dwNumNewValues);
       if (FAILED(hr))
       {
         ADSIEditErrorMessage(hr, IDS_FAILED_GET_NEW_VALUE_EDITOR, MB_OK | MB_ICONEXCLAMATION);
         return;
       }
    
       ASSERT(pNewADsValue);
       ASSERT(dwNumNewValues == 1);

       CString szNewValue;
       GetStringFromADsValue(pNewADsValue, 
                             szNewValue, 
                             MAX_OCTET_STRING_VALUE_LENGTH);

       if (!szNewValue.IsEmpty())
       {
         LRESULT lNewIdx = SendDlgItemMessage(IDC_VALUE_LIST, 
                                              LB_ADDSTRING, 
                                              0, 
                                              (WPARAM)(PCWSTR)szNewValue);
         if (lNewIdx != LB_ERR)
         {
           SendDlgItemMessage(IDC_VALUE_LIST, LB_SETITEMDATA, (WPARAM)lNewIdx, (LPARAM)pNewADsValue);
         }
       }
     }
  }
}

void CMultiOctetStringEditor::ManageButtonStates()
{
  if (m_bReadOnly)
  {
    GetDlgItem(IDC_ATTR_REMOVE_BUTTON)->EnableWindow(FALSE);
    GetDlgItem(IDC_EDIT_BUTTON)->EnableWindow(FALSE);
  }
  else
  {
     LRESULT lSelection = SendDlgItemMessage(IDC_VALUE_LIST, LB_GETCURSEL, 0, 0);
     if (lSelection != LB_ERR)
     {
       GetDlgItem(IDC_ATTR_REMOVE_BUTTON)->EnableWindow(TRUE);
       GetDlgItem(IDC_EDIT_BUTTON)->EnableWindow(TRUE);
     }
     else
     {
       GetDlgItem(IDC_ATTR_REMOVE_BUTTON)->EnableWindow(FALSE);
       GetDlgItem(IDC_EDIT_BUTTON)->EnableWindow(FALSE);
     }
  }
}

void CMultiOctetStringEditor::OnListSelChange()
{
  ManageButtonStates();
}

void CMultiOctetStringEditor::UpdateListboxHorizontalExtent()
{
  //
  // Note if the size passed to SetHorizontalExtent is less than the width of the control
  // then the scroll bar will be removed
  //
    int nHorzExtent = 0;
  CListBox* pListBox = reinterpret_cast<CListBox*>(GetDlgItem(IDC_VALUE_LIST));
  if (pListBox != NULL)
  {
      CClientDC dc(pListBox);
      int nItems = pListBox->GetCount();
      for   (int i=0; i < nItems; i++)
      {
          TEXTMETRIC tm;
          VERIFY(dc.GetTextMetrics(&tm));
          CString szBuffer;
          pListBox->GetText(i, szBuffer);
          CSize ext = dc.GetTextExtent(szBuffer,szBuffer.GetLength());
          nHorzExtent = max(ext.cx ,nHorzExtent); 
      }
      pListBox->SetHorizontalExtent(nHorzExtent);
  }
}

HRESULT CMultiOctetStringEditor::Initialize(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo)
{
  HRESULT hr = S_OK;

  if (SUCCEEDED(CValueEditDialog::Initialize(pAttributeEditorInfo)))
  {
    if (pAttributeEditorInfo->dwNumValues > 0 &&
        pAttributeEditorInfo->pADsValue != NULL)
    {
      for (int idx = 0; idx < pAttributeEditorInfo->dwNumValues; idx++)
      {
        switch (pAttributeEditorInfo->pADsValue[idx].dwType)
        {
          case ADSTYPE_OCTET_STRING:
            m_OldValueList.AddTail(&(pAttributeEditorInfo->pADsValue[idx]));
            break;

          default:
            ASSERT(FALSE);
            break;
        }
      }
    }
  }
  return hr;
}

HRESULT CMultiOctetStringEditor::GetNewValue(PADSVALUE* ppADsValue, DWORD* pdwNumValues)
{
  HRESULT hr = S_OK;

  if (!ppADsValue ||
      !pdwNumValues)
  {
    return E_OUTOFMEMORY;
  }

  int iCount = m_NewValueList.GetCount();
  if (iCount == 0)
  {
    *ppADsValue = 0;
    *pdwNumValues = 0;
  }
  else
  {
    *ppADsValue = new ADSVALUE[iCount];
    if (*ppADsValue)
    {
      *pdwNumValues = iCount;

      int idx = 0;
      POSITION pos = m_NewValueList.GetHeadPosition();
      while (pos)
      {
        PADSVALUE pADsValue = m_NewValueList.GetNext(pos);

        (*ppADsValue)[idx].dwType = m_pOldADsValue->dwType;
        switch (m_pOldADsValue->dwType)
        {
          case ADSTYPE_OCTET_STRING:
            (*ppADsValue)[idx].OctetString.dwLength = pADsValue->OctetString.dwLength;
            (*ppADsValue)[idx].OctetString.lpValue = new BYTE[pADsValue->OctetString.dwLength];
            if ((*ppADsValue)[idx].OctetString.lpValue)
            {
                // NOTICE-2002/03/05-artm  memcpy() OK.
                // arg1 and arg2 are both dwLength in size.
              memcpy((*ppADsValue)[idx].OctetString.lpValue, 
                     pADsValue->OctetString.lpValue,
                     pADsValue->OctetString.dwLength);
            }
            else
            {
              DeleteADsValues(*ppADsValue, *pdwNumValues);
              *ppADsValue = 0;
              *pdwNumValues = 0;
              hr = E_OUTOFMEMORY;
            }

            break;

          default:
            ASSERT(FALSE);
            DeleteADsValues(*ppADsValue, *pdwNumValues);
            *ppADsValue = 0;
            *pdwNumValues = 0;
            hr = E_FAIL;
            break;
        }
        if (FAILED(hr))
        {
          return hr;
        }
        idx++;
      }
    }
    else
    {
      *ppADsValue = NULL;
      *pdwNumValues = 0;
      hr = E_OUTOFMEMORY;
    }
  }
  return hr;
}

/////////////////////////////////////////////////////////////////
// CDNWithStringEditor

CValueEditDialog* CreateDNWithStringEditor(PCWSTR pszClass,
                                           PCWSTR pszAttribute,
                                           ADSTYPE adsType,
                                           BOOL bMultivalued)
{
  return new CDNWithStringEditor;
}


BEGIN_MESSAGE_MAP(CDNWithStringEditor, CValueEditDialog)
  ON_BN_CLICKED(IDC_CLEAR_BUTTON, OnClear)
END_MESSAGE_MAP()

BOOL CDNWithStringEditor::OnInitDialog()
{
  CDialog::OnInitDialog();

  return TRUE;
}

void CDNWithStringEditor::OnOK()
{
  if (!m_bReadOnly)
  {
    GetDlgItemText(IDC_VALUE_EDIT, m_NewDNValue);
    GetDlgItemText(IDC_STRING_VALUE_EDIT, m_NewStringValue);
  }
  CDialog::OnOK();
}


HRESULT CDNWithStringEditor::Initialize(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo)
{
  HRESULT hr = S_OK;

  if (SUCCEEDED(CValueEditDialog::Initialize(pAttributeEditorInfo)))
  {
    if (pAttributeEditorInfo->dwNumValues > 0 &&
        pAttributeEditorInfo->pADsValue != NULL)
    {
      ASSERT(pAttributeEditorInfo->dwNumValues == 1);
      ASSERT(pAttributeEditorInfo->pADsValue->dwType == ADSTYPE_DN_WITH_STRING);

      m_OldDNValue = pAttributeEditorInfo->pADsValue->pDNWithString->pszDNString;
      m_OldStringValue  = pAttributeEditorInfo->pADsValue->pDNWithString->pszStringValue;
    }
  }
  return hr;
}

void CDNWithStringEditor::OnClear()
{
  //
  // Change the text in the edit box to "<not set>"
  //
  CString szNotSet;
  VERIFY(szNotSet.LoadString(IDS_NOTSET));
  SetDlgItemText(IDC_VALUE_EDIT, szNotSet);
  SetDlgItemText(IDC_STRING_VALUE_EDIT, szNotSet);

  //
  // Change the focus to the edit box
  //
  GetDlgItem(IDC_VALUE_EDIT)->SetFocus();

  //
  // Select the text in the edit box
  //
  SendDlgItemMessage(IDC_VALUE_EDIT, EM_SETSEL, 0, -1);
}

HRESULT CDNWithStringEditor::GetNewValue(PADSVALUE* ppADsValue, DWORD* pdwNumValues)
{
  HRESULT hr = S_OK;

  if (ppADsValue == NULL ||
      pdwNumValues == NULL)
  {
    return E_OUTOFMEMORY;
  }

  CString szNotSet;
  VERIFY(szNotSet.LoadString(IDS_NOTSET));

  if (m_NewDNValue == szNotSet ||
      m_NewStringValue == szNotSet)
  {
    // User is clearing the attribute
    
    *ppADsValue = NULL;
    *pdwNumValues = 0;

    return hr;
  }

  if (!m_NewDNValue.IsEmpty() ||
      !m_NewStringValue.IsEmpty())
  {
    *ppADsValue = new ADSVALUE;
    if (*ppADsValue)
    {
      *pdwNumValues = 1;
      (*ppADsValue)->dwType = m_pOldADsValue->dwType;
      ASSERT((*ppADsValue)->dwType == ADSTYPE_DN_WITH_STRING);

      (*ppADsValue)->pDNWithString = new ADS_DN_WITH_STRING;
      if ((*ppADsValue)->pDNWithString)
      {
         ZeroMemory((*ppADsValue)->pDNWithString, sizeof (ADS_DN_WITH_STRING));

         int length = m_NewStringValue.GetLength();
         (*ppADsValue)->pDNWithString->pszStringValue = new WCHAR[length + 1];
         if ((*ppADsValue)->pDNWithString->pszStringValue)
         {
            ZeroMemory((*ppADsValue)->pDNWithString->pszStringValue, sizeof(WCHAR) * (length + 1));

            wcsncpy((*ppADsValue)->pDNWithString->pszStringValue, m_NewStringValue, length);

            length = m_NewDNValue.GetLength();
            (*ppADsValue)->pDNWithString->pszDNString = new WCHAR[length + 1];

            if ((*ppADsValue)->pDNWithString->pszDNString)
            {
               ZeroMemory((*ppADsValue)->pDNWithString->pszDNString, sizeof(WCHAR) * (length + 1));

               wcsncpy((*ppADsValue)->pDNWithString->pszDNString, m_NewDNValue, length);
            }
            else
            {
               hr = E_OUTOFMEMORY;
            }
         }
         else
         {
            hr = E_OUTOFMEMORY;
         }
      }
      else
      {
         hr = E_OUTOFMEMORY;
      }
    }
    else
    {
      hr = E_OUTOFMEMORY;
    }
  }
  else
  {
    // Set an empty value

    *ppADsValue = new ADSVALUE;

    if (*ppADsValue)
    {
       *pdwNumValues = 1;

      (*ppADsValue)->dwType = m_pOldADsValue->dwType;
      ASSERT((*ppADsValue)->dwType == ADSTYPE_DN_WITH_STRING);

      (*ppADsValue)->pDNWithString = new ADS_DN_WITH_STRING;
      if ((*ppADsValue)->pDNWithString)
      {
         ZeroMemory((*ppADsValue)->pDNWithString, sizeof (ADS_DN_WITH_STRING));
      }
      else
      {
         hr = E_OUTOFMEMORY;
      }
    }
    else
    {
       hr = E_OUTOFMEMORY;
    }
  }

  if (FAILED(hr))
  {
    DeleteADsValues(*ppADsValue, *pdwNumValues);
    *ppADsValue = 0;
    *pdwNumValues = 0;
  }

  return hr;
}

///////////////////////////////////////////////////////////////////////////////////////
// CAttributeEditorPropertyPage

BEGIN_MESSAGE_MAP(CAttributeEditorPropertyPage, CPropertyPage)
  ON_BN_CLICKED(IDC_MANDATORY_CHECK, OnMandatoryCheck)
  ON_BN_CLICKED(IDC_OPTIONAL_CHECK,  OnOptionalCheck)
  ON_BN_CLICKED(IDC_SET_CHECK,       OnValueSetCheck)
  ON_BN_CLICKED(IDC_ATTR_EDIT_BUTTON,OnEditAttribute)
  ON_WM_CREATE()
  ON_WM_DESTROY()
  ON_NOTIFY(LVN_ITEMACTIVATE, IDC_ATTRIBUTE_LIST, OnNotifyEditAttribute)
  ON_NOTIFY(LVN_ITEMCHANGED, IDC_ATTRIBUTE_LIST, OnListItemChanged)
  ON_NOTIFY(LVN_COLUMNCLICK, IDC_ATTRIBUTE_LIST, OnSortList)
END_MESSAGE_MAP()

CAttributeEditorPropertyPage::CAttributeEditorPropertyPage(IADs* pIADs, 
                                                           IADsClass* pIADsClass,
                                                           LPDS_ATTREDITOR_BINDINGINFO pBindingInfo,
                                                           CADSIEditPropertyPageHolder* pHolder)
  : CPropertyPage(IDD_ATTRIBUTE_EDITOR_DIALOG)
{
  m_spIADs      = pIADs;
  m_spIADsClass = pIADsClass;

  m_bMandatory  = TRUE;
  m_bOptional   = TRUE;
  m_bSet        = FALSE;

  m_nSortColumn = 0;

  ASSERT(pBindingInfo != NULL);
  ASSERT(pBindingInfo->dwSize == sizeof(DS_ATTREDITOR_BINDINGINFO));
  ASSERT(pBindingInfo->lpfnBind != NULL);
  ASSERT(pBindingInfo->lpszProviderServer != NULL);

  m_szPrefix = pBindingInfo->lpszProviderServer;
  m_pfnBind  = pBindingInfo->lpfnBind;
  m_BindLPARAM = pBindingInfo->lParam;
  m_dwBindFlags = pBindingInfo->dwFlags;

  m_pHolder = pHolder;
  ASSERT(m_pHolder);
}

CAttributeEditorPropertyPage::~CAttributeEditorPropertyPage()
{
}

BOOL CAttributeEditorPropertyPage::OnInitDialog()
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  CWaitCursor cursor;

  // Set the hwnd in the property page holder so that we can
  // be activated when necessary

  m_pHolder->SetSheetWindow(GetParent()->GetSafeHwnd());


  ((CButton*)GetDlgItem(IDC_MANDATORY_CHECK))->SetCheck(TRUE);
  ((CButton*)GetDlgItem(IDC_OPTIONAL_CHECK))->SetCheck(TRUE);
  ((CButton*)GetDlgItem(IDC_SET_CHECK))->SetCheck(FALSE);

  GetDlgItem(IDC_ATTR_EDIT_BUTTON)->EnableWindow(FALSE);

  HRESULT hr = GetSchemaNamingContext();
  ShowListCtrl();

  hr = RetrieveAttributes();
  if (FAILED(hr))
  {
    TRACE(_T("OnInitDialog() : error returned from RetrieveAttributes() = 0x%x\n"), hr);
  }

  CComBSTR bstr;
  hr = m_spIADs->get_Class(&bstr);
  if (FAILED(hr))
  {
    TRACE(_T("OnInitDialog() : error returned from m_pIADs->get_Class() = 0x%x\n"), hr);
  }
  else
  {
    m_szClass = bstr;
  }

  FillListControl();
  return FALSE;
}

int CAttributeEditorPropertyPage::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    m_pHolder->AddRef();
    int res = CPropertyPage::OnCreate(lpCreateStruct);
    ASSERT(res == 0);
    ASSERT(m_hWnd != NULL);
    ASSERT(::IsWindow(m_hWnd));
    HWND hParent = ::GetParent(m_hWnd);
    ASSERT(hParent);
    m_pHolder->SetSheetWindow(hParent);
    return res;
}

void CAttributeEditorPropertyPage::OnDestroy()
{
    ASSERT(m_hWnd != NULL);
    CPropertyPage::OnDestroy();
    m_pHolder->Release();
}

HRESULT CAttributeEditorPropertyPage::GetSchemaNamingContext()
{
  HRESULT hr = S_OK;
  CComPtr<IADs> spIADs;

  CString m_szPath = m_szPrefix + _T("RootDSE");
  hr = m_pfnBind(m_szPath, 
                 ADS_SECURE_AUTHENTICATION,
                 IID_IADs,
                 (PVOID*)&spIADs,
                 m_BindLPARAM);
  if (SUCCEEDED(hr))
  {
    CComVariant var;
    hr = spIADs->Get(CComBSTR(L"schemaNamingContext"), &var);
    if (SUCCEEDED(hr))
    {
      m_szSchemaNamingContext = var.bstrVal;
    }
  }
  m_szSchemaNamingContext = m_szPrefix + m_szSchemaNamingContext;
  return hr;
}

BOOL CAttributeEditorPropertyPage::OnApply()
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
   CThemeContextActivator activator;
    if (m_AttrList.HasDirty())
    {
        CComPtr<IDirectoryObject> spDirObject;

        // bind to object with authentication
        //
        HRESULT hr = S_OK;
        hr = m_spIADs->QueryInterface(IID_IDirectoryObject, (PVOID*) &spDirObject);

        if (FAILED(hr))
        {
            AfxMessageBox(L"Failed to QI the IDirectoryObject from the IADs.");
      return FALSE;
        }

        // Change or add values to ADSI cache that have changed
        //
        hr = CADSIAttribute::SetValuesInDS(&m_AttrList, spDirObject);
        if (FAILED(hr))
        {
        ADSIEditErrorMessage(hr);

      //
      // Instead of removing all the attributes we need to query for the ones that failed
      // or something to that effect.
      //
//          m_AttrList.RemoveAllAttr();
      return FALSE;
        }
    }
  return TRUE;
}

void CAttributeEditorPropertyPage::OnMandatoryCheck()
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  TRACE(_T("OnMandatoryCheck()\n"));
  m_bMandatory = ((CButton*)GetDlgItem(IDC_MANDATORY_CHECK))->GetCheck();

  FillListControl();
}

void CAttributeEditorPropertyPage::OnOptionalCheck()
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  TRACE(_T("OnOptionalCheck()\n"));
  m_bOptional = ((CButton*)GetDlgItem(IDC_OPTIONAL_CHECK))->GetCheck();

  FillListControl();
}

void CAttributeEditorPropertyPage::OnValueSetCheck()
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  TRACE(_T("OnValueSetCheck()\n"));
  m_bSet = ((CButton*)GetDlgItem(IDC_SET_CHECK))->GetCheck();

  FillListControl();
}

//
// Callback function used by CListCtrl::SortItems the items by the column that was clicked
//
static int CALLBACK CompareAttrColumns(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
  CAttributeEditorPropertyPage* pProppage = reinterpret_cast<CAttributeEditorPropertyPage*>(lParamSort);
  if (!pProppage)
  {
    ASSERT(pProppage);
    return 0;
  }

  UINT nColumn = pProppage->GetSortColumn();
  CListCtrl* pListCtrl = (CListCtrl*)pProppage->GetDlgItem(IDC_ATTRIBUTE_LIST);
  if (!pListCtrl)
  {
    ASSERT(pListCtrl);
    return 0;
  }

  //
  // Since lParam1 and lParam2 are pointers to the data we have to search for each item
  // in the list and remember their index
  //
  int iItem1 = -1;
  int iItem2 = -1;

  LVFINDINFO findInfo;
  ZeroMemory(&findInfo, sizeof(LVFINDINFO));
  findInfo.flags = LVFI_PARAM;
  findInfo.lParam = lParam1;
  iItem1 = pListCtrl->FindItem(&findInfo);

  findInfo.lParam = lParam2;
  iItem2 = pListCtrl->FindItem(&findInfo);

  //
  // Put any items with values above those that don't have values
  //
  int iRetVal = 0;
  if (iItem1 != -1 &&
      iItem2 == -1)
  {
    iRetVal = -1;
  }
  else if (iItem1 == -1 &&
           iItem2 != -1)
  {
    iRetVal = 1;
  }
  else if (iItem1 == -1 &&
           iItem2 == -1)
  {
    iRetVal = 0;
  }
  else
  {
    CString szItem1 = pListCtrl->GetItemText(iItem1, nColumn);
    CString szItem2 = pListCtrl->GetItemText(iItem2, nColumn);

    //
    // Have to put this in so that empty strings end up at the bottom
    //
    if (szItem1.IsEmpty() && !szItem2.IsEmpty())
    {
      iRetVal = 1;
    }
    else if (!szItem1.IsEmpty() && szItem2.IsEmpty())
    {
      iRetVal = -1;
    }
    else
    {
      // NOTICE-2002/03/05-artm  _wcsicmp() okay since comparing 2 CStrings.
      iRetVal = _wcsicmp(szItem1, szItem2);
    }
  }
  return iRetVal;
}

void CAttributeEditorPropertyPage::OnSortList(NMHDR* pNotifyStruct, LRESULT* result)
{
  if (!result ||
      !pNotifyStruct)
  {
    return;
  }

  *result = 0;

  //
  // Get the list view notify struct
  //
  LPNMLISTVIEW pnmv = (LPNMLISTVIEW)pNotifyStruct;
  if (!pnmv)
  {
    return;
  }

  //
  // Right now I only have 3 columns
  //
  if (pnmv->iSubItem < 0 ||
      pnmv->iSubItem >= 3)
  {
    return;
  }

  //
  // Store the sort column
  //
  m_nSortColumn = pnmv->iSubItem;

  CListCtrl* pAttrListCtrl = (CListCtrl*)GetDlgItem(IDC_ATTRIBUTE_LIST);
  ASSERT(pAttrListCtrl);
  pAttrListCtrl->SortItems(CompareAttrColumns, reinterpret_cast<LPARAM>(this));
}
  
void CAttributeEditorPropertyPage::OnListItemChanged(NMHDR* /*pNotifyStruct*/, LRESULT* result)
{
  if (!result)
  {
    return;
  }
  *result = 0;
  SetEditButton();
}

void CAttributeEditorPropertyPage::SetEditButton()
{
  //
  // Enable the edit button if something is selected in the ListCtrl
  //
  BOOL bEnableEdit = FALSE;

  CListCtrl* pAttrListCtrl = (CListCtrl*)GetDlgItem(IDC_ATTRIBUTE_LIST);
  ASSERT(pAttrListCtrl != NULL);
  int nSelectedItem = pAttrListCtrl->GetNextItem(-1, LVIS_SELECTED);

  if (nSelectedItem != -1 &&
      !(m_dwBindFlags & DSATTR_EDITOR_ROOTDSE))
  {
    bEnableEdit = TRUE;
  }
  GetDlgItem(IDC_ATTR_EDIT_BUTTON)->EnableWindow(bEnableEdit);
}

void CAttributeEditorPropertyPage::OnNotifyEditAttribute(NMHDR* pNotifyStruct, LRESULT* result)
{
  if (result == NULL ||
      pNotifyStruct == NULL)
  {
    return;
  }

  // No editing values on RootDSE (for now)
  if (m_dwBindFlags & DSATTR_EDITOR_ROOTDSE)
  {
     return;
  }

  LPNMITEMACTIVATE pnmia = (LPNMITEMACTIVATE)pNotifyStruct;
  ASSERT(pnmia != NULL);
  if (pnmia != NULL)
  {
    int iSelectedItem = pnmia->iItem;
    if (iSelectedItem != -1)
    {
      CADSIAttribute* pSelectedAttr = GetAttributeFromList(iSelectedItem);
      if (pSelectedAttr != NULL)
      {
        EditAttribute(pSelectedAttr);
      }
      else
      {
        //
        // REVIEW_JEFFJON : display an appropriate error message
        //
      }
    }
  }
  *result = 0;
}

void CAttributeEditorPropertyPage::OnEditAttribute()
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  TRACE(_T("OnEditAttribute()\n"));

  CListCtrl* pAttrListCtrl = (CListCtrl*)GetDlgItem(IDC_ATTRIBUTE_LIST);
  ASSERT(pAttrListCtrl != NULL);
    int nSelectedItem = pAttrListCtrl->GetNextItem(-1, LVIS_SELECTED);

  if (nSelectedItem == -1)
  {
    return;
  }

  CADSIAttribute* pSelectedAttr = GetAttributeFromList(nSelectedItem);
  ASSERT(pSelectedAttr != NULL);

  if (m_dwBindFlags & DSATTR_EDITOR_ROOTDSE)
  {
     // We have add the value to the attribute holder from
     // the RootDSE list

//     CString szValue;
//     szValue = m_RootDSEValueList.GetAt(m_RootDSEValueList.FindIndex(nSelectedItem));
  }
  EditAttribute(pSelectedAttr);
}

void CAttributeEditorPropertyPage::EditAttribute(CADSIAttribute* pSelectedAttr)
{
  HRESULT hr = S_OK;

  CThemeContextActivator activator;

  //
  // Retrieve all necessary info for initializing the appropriate editor
  //
  LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo = NULL;
  BOOL bOwnValueMemory = FALSE;
  hr = GetAttributeInfo(*pSelectedAttr, &pAttributeEditorInfo, &bOwnValueMemory);

  if (hr == E_OUTOFMEMORY)
  {
      ADSIEditErrorMessage(hr);
      return;
  }

  if (pAttributeEditorInfo == NULL || FAILED(hr))
  {
    ADSIEditMessageBox(IDS_NO_ATTRIBUTE_INFO, MB_OK);
    return;
  }
  
  //
  // Obtain the editor from the attribute and syntax map
  //
  CValueEditDialog* pEditorDialog = RetrieveEditor(pAttributeEditorInfo);
  if (pEditorDialog)
  {
    hr = pEditorDialog->Initialize(pAttributeEditorInfo);
    if (SUCCEEDED(hr))
    {
      if (pEditorDialog->DoModal() == IDOK)
      {
        PADSVALUE pNewValue = 0;
        DWORD dwNumValues   = 0;
        hr = pEditorDialog->GetNewValue(&pNewValue, &dwNumValues);
        if (SUCCEEDED(hr))
        {
          //
          // Do what ever needs done with the new value
          //
          hr = pSelectedAttr->SetValues(pNewValue, dwNumValues);
          //
          // REVIEW_JEFFJON : what should be done here if that failed?
          //
          pSelectedAttr->SetDirty(TRUE);

          CListCtrl* pAttrListCtrl = (CListCtrl*)GetDlgItem(IDC_ATTRIBUTE_LIST);
          ASSERT(pAttrListCtrl != NULL);
            int nSelectedItem = pAttrListCtrl->GetNextItem(-1, LVIS_SELECTED);

          if (nSelectedItem != -1)
          {
            if (dwNumValues > 0)
            {
              //
              // Get the new values (limit each individual value to MAX_OCTET_STRING_VALUE_LENGTH characters)
              //
              CStringList szValuesList;
              pSelectedAttr->GetValues(szValuesList, MAX_OCTET_STRING_VALUE_LENGTH);
            
              CString szCombinedString;
              POSITION pos = szValuesList.GetHeadPosition();
              while (pos != NULL)
              {
                CString szTemp = szValuesList.GetNext(pos);
                szCombinedString += szTemp;
                if (pos != NULL)
                {
                  szCombinedString += L";";
                }
              }

              VERIFY(-1 != pAttrListCtrl->SetItemText(nSelectedItem, 2, szCombinedString));
            }
            else
            {
              CString szNotSet;
              VERIFY(szNotSet.LoadString(IDS_ATTR_NOTSET));

              VERIFY(-1 != pAttrListCtrl->SetItemText(nSelectedItem, 2, szNotSet));
            }
          }
          SetModified();
        }
        else
        {
          //
          // REVIEW_JEFFJON : handle the GetNewValue() failure
          //
          ASSERT(FALSE);
          ADSIEditErrorMessage(hr);
        }
      }
    }
    else
    {
      //
      // REVIEW_JEFFJON : Handle the error Initialize
      //
      ASSERT(FALSE);
      ADSIEditErrorMessage(hr);
    }
    if (pEditorDialog)
    {
      delete pEditorDialog;
      pEditorDialog = 0;
    }
  }
  else
  {
    //
    // Unable to retrieve an appropriate editor for this attribute
    //
    ADSIEditMessageBox(IDS_NO_EDITOR, MB_OK);
  }

  if (pAttributeEditorInfo)
  {
    if (pAttributeEditorInfo->lpszAttribute)
    {
      delete[] pAttributeEditorInfo->lpszAttribute;
    }

    if (pAttributeEditorInfo->lpszClass)
    {
      delete[] pAttributeEditorInfo->lpszClass;
    }

    if (pAttributeEditorInfo->pADsValue && bOwnValueMemory)
    {
       delete pAttributeEditorInfo->pADsValue;
       pAttributeEditorInfo->pADsValue = 0;
    }

    delete pAttributeEditorInfo;
    pAttributeEditorInfo = 0;
  }
}

CADSIAttribute* CAttributeEditorPropertyPage::GetAttributeFromList(int iSelectedItem)
{
  if (iSelectedItem == -1)
  {
    return NULL;
  }

  CListCtrl* pAttrListCtrl = (CListCtrl*)GetDlgItem(IDC_ATTRIBUTE_LIST);
  ASSERT(pAttrListCtrl != NULL);
  return (CADSIAttribute*)pAttrListCtrl->GetItemData(iSelectedItem);
}

HRESULT CAttributeEditorPropertyPage::GetAttributeInfo(CADSIAttribute& attr, 
                                                    LPDS_ATTRIBUTE_EDITORINFO* ppAttributeEditorInfo,
                                                    BOOL* pbOwnValueMemory)
{
    HRESULT err = S_OK;

    ASSERT(ppAttributeEditorInfo != NULL);
    ASSERT(pbOwnValueMemory != NULL);

    if (!ppAttributeEditorInfo || !pbOwnValueMemory)
    {
        return E_POINTER;
    }

    // Temporary variable to hold values that will be passed out of
    // function.  We use this instead of *ppAttributeEditorInfo to remove
    // a level of indirection while we are collecting the information.
    LPDS_ATTRIBUTE_EDITORINFO attributeEditorInfo;

    // Set initial default (error) values.
    attributeEditorInfo = NULL;
    *pbOwnValueMemory = FALSE;

    // 
    // Set read-only if necessary
    //
    bool readOnly = false;
    if (  m_dwBindFlags & DSATTR_EDITOR_ROOTDSE 
       || m_dwBindFlags & DSATTR_EDITOR_GC)
    {
        readOnly = true;
    }
     
    //
    // Get the attribute to be edited
    //
    CString szAttribute = _T("");
    attr.GetProperty(szAttribute);

    //
    // Get the type and whether it is multi-valued or not by the syntax
    // of the attribute
    //
    CString szSyntax;
    BOOL bMultiValued = FALSE;
    ADSTYPE adsType = RetrieveADsTypeFromSyntax(szAttribute, &bMultiValued, szSyntax);

    DWORD dwNumValues = 0;
    PADSVALUE pADsValue = attr.GetADsValues();

    if (!pADsValue)
    {
        //
        // Value for attribute was not set so we have to 
        // create an empty ADSVALUE to pass the type
        //
        pADsValue = new ADSVALUE;
        if (pADsValue)
        {
            ::ZeroMemory(pADsValue, sizeof(ADSVALUE));
            pADsValue->dwType = adsType;
            dwNumValues = 0;
            *pbOwnValueMemory = TRUE;
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        //
        // Get the number of values in the attribute
        //
        dwNumValues = attr.GetNumValues();
    }

    //
    // Figure out how much space we need
    //
    DWORD dwStructSize = sizeof(DS_ATTRIBUTE_EDITORINFO);
    DWORD dwClassSize  = m_szClass.GetLength() + 1;
    DWORD dwAttrSize   = szAttribute.GetLength() + 1;

    do // false loop
    {
        attributeEditorInfo = new DS_ATTRIBUTE_EDITORINFO;
        if (!attributeEditorInfo)
        {
            err = E_OUTOFMEMORY;
            break;
        }

        ::ZeroMemory(attributeEditorInfo, sizeof(DS_ATTRIBUTE_EDITORINFO));

        // NOTICE-NTRAID#NTBUG9-566199-2002/03/05-artm  Check mem. alloc. succeeded.
        attributeEditorInfo->lpszClass = new WCHAR[dwClassSize];
        if (!attributeEditorInfo->lpszClass)
        {
            err = E_OUTOFMEMORY;
            break;
        }
        
        wcscpy(attributeEditorInfo->lpszClass, m_szClass);

        // NOTICE-NTRAID#NTBUG9-566199-2002/03/05-artm  Check mem. alloc. succeeded.
        attributeEditorInfo->lpszAttribute = new WCHAR[dwAttrSize];
        if (!attributeEditorInfo->lpszAttribute)
        {
            err = E_OUTOFMEMORY;
            break;
        }

        wcscpy(attributeEditorInfo->lpszAttribute, szAttribute);

        attributeEditorInfo->adsType      = adsType;
        attributeEditorInfo->bMultivalued = bMultiValued;
        attributeEditorInfo->bReadOnly    = readOnly;
        attributeEditorInfo->dwNumValues  = dwNumValues;
        attributeEditorInfo->pADsValue    = pADsValue;
        attributeEditorInfo->dwSize       = sizeof(DS_ATTRIBUTE_EDITORINFO);
    }
    while (false); // end false loop


    // If we were unable to get all the information, clean up memory.
    if (FAILED(err))
    {
        // Only delete the value structure if we allocated it.
        if (*pbOwnValueMemory)
        {
            delete pADsValue;
            pADsValue = NULL;
            *pbOwnValueMemory = FALSE;
        }

        if (attributeEditorInfo)
        {
            if (attributeEditorInfo->lpszClass)
            {
                delete [] attributeEditorInfo->lpszClass;
            }

            if (attributeEditorInfo->lpszAttribute)
            {
                delete [] attributeEditorInfo->lpszAttribute;
            }

            delete attributeEditorInfo;
            attributeEditorInfo = NULL;
        }
    }

    *ppAttributeEditorInfo = attributeEditorInfo;

    return err;
}

void CAttributeEditorPropertyPage::ShowListCtrl()
{
  CListCtrl* pAttrListCtrl = (CListCtrl*)GetDlgItem(IDC_ATTRIBUTE_LIST);
  ASSERT(pAttrListCtrl != NULL);

  // Set full row select

  ListView_SetExtendedListViewStyle(
     pAttrListCtrl->GetSafeHwnd(), 
     LVS_EX_FULLROWSELECT);

  //
  // Insert the Attribute column
  //
  CString szAttribute;
  VERIFY(szAttribute.LoadString(IDS_ATTR_COL_ATTRIBUTE));
  int iRet = pAttrListCtrl->InsertColumn(0, szAttribute, LVCFMT_LEFT, 120);
  if (iRet == -1)
  {
    TRACE(_T("Failed to insert the \"Attribute\" column.\n"));
  }

  //
  // Insert the Syntax column
  // This column will be hidden by default
  //
  CString szSyntax;
  VERIFY(szSyntax.LoadString(IDS_ATTR_COL_SYNTAX));
  iRet = pAttrListCtrl->InsertColumn(1, szSyntax, LVCFMT_LEFT, 90);
  if (iRet == -1)
  {
    TRACE(_T("Failed to insert the \"Syntax\" column.\n"));
  }

  //
  // Insert the Value column
  //
  CString szValue;
  VERIFY(szValue.LoadString(IDS_ATTR_COL_VALUE));
  iRet = pAttrListCtrl->InsertColumn(2, szValue, LVCFMT_LEFT, 400);
  if (iRet == -1)
  {
    TRACE(_T("Failed to insert the \"Value\" column.\n"));
  }

}

void CAttributeEditorPropertyPage::FillListControl()
{
  TRACE(_T("FillListControl()\n"));

  CListCtrl* pAttrListCtrl = (CListCtrl*)GetDlgItem(IDC_ATTRIBUTE_LIST);
  ASSERT(pAttrListCtrl != NULL);

  CString szNotSet;
  VERIFY(szNotSet.LoadString(IDS_ATTR_NOTSET));

  //
  // Clear the list control
  //
  pAttrListCtrl->DeleteAllItems();

  //
  // Add the attributes and their values into the list control
  //
  UINT nState = 0;
  int nIndex = 0;

  POSITION pos = m_AttrList.GetHeadPosition();
  while (pos != NULL)
  {
    CADSIAttribute* pAttr = m_AttrList.GetNext(pos);
    ASSERT(pAttr != NULL);

    CString szProperty;
    pAttr->GetProperty(szProperty);

    //
    // Don't add the nTSecurityDescriptor, we use the ACL UI instead
    //
    if (szProperty.CompareNoCase(L"nTSecurityDescriptor") == 0)
    {
      continue;
    }

    if (m_dwBindFlags & DSATTR_EDITOR_ROOTDSE)
    {
        int iNewIndex = pAttrListCtrl->InsertItem(LVIF_TEXT | LVIF_PARAM, nIndex, 
                szProperty, nState, 0, 0, (LPARAM)pAttr); 
      if (iNewIndex != -1)
      {
        // Insert the syntax
         
        VERIFY(-1 != pAttrListCtrl->SetItemText(iNewIndex, 1, pAttr->GetSyntax()));

        // Insert the value

        CString szValue;
        szValue = m_RootDSEValueList.GetAt(m_RootDSEValueList.FindIndex(nIndex));
        if (!szValue.IsEmpty())
        {
          VERIFY(-1 != pAttrListCtrl->SetItemText(iNewIndex, 2, szValue));
        }
        else
        {
          VERIFY(-1 != pAttrListCtrl->SetItemText(iNewIndex, 2, szNotSet));
        }
      }
      nIndex++;
    }
    else // not RootDSE
    {
      if ((m_bMandatory && pAttr->IsMandatory()) || (m_bOptional && !pAttr->IsMandatory()))
      {
        if (!m_bSet || (m_bSet && pAttr->IsValueSet()))
        {
            int iNewIndex = pAttrListCtrl->InsertItem(LVIF_TEXT | LVIF_PARAM, nIndex, 
                    szProperty, nState, 0, 0, (LPARAM)pAttr); 
          if (iNewIndex != -1)
          {
            // Insert the syntax
            
            VERIFY(-1 != pAttrListCtrl->SetItemText(iNewIndex, 1, pAttr->GetSyntax()));

            // Insert the value

            if (pAttr->IsValueSet())
            {
              //
              // Retrieve the values
              //
              CStringList szValuesList;
              pAttr->GetValues(szValuesList);
            
              CString szCombinedString;
              POSITION posList = szValuesList.GetHeadPosition();
              while (posList)
              {
                CString szTemp = szValuesList.GetNext(posList);
                szCombinedString += szTemp;
                if (posList)
                {
                  szCombinedString += L";";
                }
              }

              VERIFY(-1 != pAttrListCtrl->SetItemText(iNewIndex, 2, szCombinedString));
            }
            else
            {
              VERIFY(-1 != pAttrListCtrl->SetItemText(iNewIndex, 2, szNotSet));
            }
          }
          nIndex++;
        }
      }
    }
  }  
  TRACE(_T("Added %u properties\n"), nIndex);

  //
  // Select the first attribute in the list
  //
  pAttrListCtrl->SetItemState(0, 1, LVIS_SELECTED);
  SetEditButton();
}


HRESULT CAttributeEditorPropertyPage::RetrieveAttributes()
{
  TRACE(_T("RetrieveAttributes()\n"));
  HRESULT hr = S_OK;

  CWaitCursor cursor;

  if (m_dwBindFlags & DSATTR_EDITOR_ROOTDSE)
  {
    CStringList sMandList;

    m_spIADs->GetInfo();

    CComPtr<IADsPropertyList> spPropList;
    hr = m_spIADs->QueryInterface(IID_IADsPropertyList, (PVOID*)&spPropList);
    if (SUCCEEDED(hr))
    {
      LONG lCount = 0;
      hr = spPropList->get_PropertyCount(&lCount);
      if (SUCCEEDED(hr) && lCount > 0)
      {
        CComVariant var;
        while (hr == S_OK)
        {
          hr = spPropList->Next(&var);
          if (hr == S_OK)
          {
            ASSERT(var.vt == VT_DISPATCH);
            CComPtr<IADsPropertyEntry> spEntry;
            
            hr = V_DISPATCH(&var)->QueryInterface(IID_IADsPropertyEntry,
                                                 (PVOID*)&spEntry);
            if (SUCCEEDED(hr))
            {
              CComBSTR bstrName;
              hr = spEntry->get_Name(&bstrName);
              if (SUCCEEDED(hr))
              {
                sMandList.AddTail(bstrName);
              }
            }
          }
        }
      }
    }
        
    hr = CreateAttributeList(sMandList, TRUE);
  }
  else
  {
    //
    // Retrieve mandatory properties
    //
    CStringList sMandList;

      VARIANT varMand;
      VariantInit(&varMand);

    hr = m_spIADsClass->get_MandatoryProperties(&varMand);
    if (SUCCEEDED(hr))
    {
        VariantToStringList( varMand, sMandList );
    }
      VariantClear(&varMand);   

    //
    // Retrieve optional properties
    //
    CStringList sOptionalList;

    VARIANT varOpt;
    VariantInit(&varOpt);
    hr = m_spIADsClass->get_OptionalProperties(&varOpt);
    if (SUCCEEDED(hr))
    {
        VariantToStringList( varOpt, sOptionalList );
    }
      VariantClear(&varOpt);    

    hr = CreateAttributeList(sMandList, TRUE);
    if (FAILED(hr))
    {
      return hr;
    }

    hr = CreateAttributeList(sOptionalList, FALSE);
    if (FAILED(hr))
    {
      return hr;
    }
  }
  return hr;
}

// The function checks to see if the pszAttrName contains ";range="
// If it does that means the attribute contains a range of values.
// We will return the attribute name (without the range), and the start
// and end of the range.

bool CAttributeEditorPropertyPage::IsRangeOfValues(PCWSTR pszAttrName, 
                                                   CString& szAttrBase,
                                                   DWORD& rangeStart,
                                                   DWORD& rangeEnd)
{
   bool result = false;

   CString szAttrName = pszAttrName;
   int iFind = szAttrName.Find(L";range=");
   if (iFind != -1)
   {
      // This is a range, get the start and end

      result = true;
      szAttrBase = szAttrName.Left(iFind);

      int length = szAttrName.GetLength();

      // The range start is the value between the = and -

      iFind = szAttrName.ReverseFind(L'=');
      if (iFind != -1)
      {
         CString szStart = szAttrName.Right(length - iFind - 1);
         long start = _wtol(szStart);
         rangeStart = static_cast<DWORD>(start);
      }

      // The range end is the last value after the -.
      // This could be * so a return value of 0 for this
      // means we have the entire range

      iFind = szAttrName.ReverseFind(L'-');
      if (iFind != -1)
      {
         CString szEnd = szAttrName.Right(length - iFind - 1);
         long end = _wtol(szEnd);
         rangeEnd = static_cast<DWORD>(end);
      }

   }
   return result;
}

HRESULT CAttributeEditorPropertyPage::CreateAttributeList(CStringList& sAttrList, BOOL bMandatory)
{
  HRESULT hr = S_OK;
  LPWSTR* lpszAttrArray;
  UINT nCount = 0;
  GetStringArrayFromStringList(sAttrList, &lpszAttrArray, &nCount);
  TRACE(_T("There are %u properties to add\n"), nCount);

  for (UINT idx = 0; idx < nCount; idx++)
  {
    CADSIAttribute* pNewAttr = new CADSIAttribute(lpszAttrArray[idx]);
    ASSERT(pNewAttr != NULL);

    pNewAttr->SetMandatory(bMandatory);

    // Get the syntax

    BOOL bMultivalued = FALSE;
    CString szSyntax;
    ADSTYPE adstype = RetrieveADsTypeFromSyntax(lpszAttrArray[idx], &bMultivalued, szSyntax);
    pNewAttr->SetADsType(adstype);
    pNewAttr->SetMultivalued(bMultivalued);
    pNewAttr->SetSyntax(szSyntax);

    m_AttrList.AddTail(pNewAttr);
  }

  //
  // Retrieve the values that are set
  //
#define RETRIEVESET
#ifdef  RETRIEVESET

  if (m_dwBindFlags & DSATTR_EDITOR_ROOTDSE)
  {
    //
    // Special case RootDSE because it does not support IDirectoryObject
    //
    hr = m_spIADs->GetInfo();
    for (UINT idx = 0; idx < nCount; idx++)
    {

        VARIANT var;
        hr = m_spIADs->GetEx( CComBSTR(lpszAttrArray[idx]) , &var );
        if ( FAILED(hr) )
        {
        m_RootDSEValueList.AddTail(L" ");
        continue;
        }

        /////////////////////////////////////////
        //  Convert and populate
        ///////////////////////////////////////////
        CStringList sList;
        hr = VariantToStringList( var, sList );
      if (SUCCEEDED(hr))
      {
        CString szTempValue;
        POSITION pos = sList.GetHeadPosition();
        while (pos != NULL)
        {
          CString szValue = sList.GetNext(pos);

          if (szTempValue.IsEmpty())
          {
            szTempValue += szValue;
          }
          else
          {
            szTempValue += L";" + szValue;
          }
        }
        m_RootDSEValueList.AddTail(szTempValue);
      }
    }
  }
  else
  {
    CComPtr<IDirectoryObject> spDirObject;

    hr = m_spIADs->QueryInterface(IID_IDirectoryObject, (PVOID*)&spDirObject);
    if (FAILED(hr))
    {
      return hr;
    }

    PADS_ATTR_INFO pAttrInfo = NULL;
    DWORD dwReturned = 0;

    hr = spDirObject->GetObjectAttributes(lpszAttrArray, nCount, &pAttrInfo, &dwReturned);
    if (SUCCEEDED(hr))
    {
      //
      // Save the attribute info pointer for later deletion
      //
      if (bMandatory)
      {
        m_AttrList.SaveMandatoryValuesPointer(pAttrInfo);
      }
      else
      {
        m_AttrList.SaveOptionalValuesPointer(pAttrInfo);
      }

      for (DWORD idx = 0; idx < dwReturned; idx++)
      {
        POSITION pos = m_AttrList.FindProperty(pAttrInfo[idx].pszAttrName);

        if (pos)
        {
           CADSIAttribute* pNewAttr = m_AttrList.GetAt(pos);
           ASSERT(pNewAttr != NULL);

           pNewAttr->SetValueSet(TRUE);
           pNewAttr->SetAttrInfo(&(pAttrInfo[idx]));
        }
        else
        {
           // See if this is just a range of values for the attribute

           CString szAttributeBase;
           DWORD rangeStart = 0;
           DWORD rangeEnd = static_cast<DWORD>(-1);
           CADSIAttribute* pNewAttr = 0;

           PADS_ATTR_INFO pCurrentInfo = &(pAttrInfo[idx]);
           ASSERT(pCurrentInfo);

           bool currentInMasterList = true;

           // If we were sent only a portion of the values
           // we have to loop through and get the rest

           while (IsRangeOfValues(pCurrentInfo->pszAttrName, 
                                  szAttributeBase, 
                                  rangeStart,
                                  rangeEnd))
           {
              if (!pNewAttr)
              {
                 POSITION rangePos = m_AttrList.FindProperty(szAttributeBase);
                 if (rangePos)
                 {
                    pNewAttr = m_AttrList.GetAt(rangePos);
                 }
              }
              ASSERT(pNewAttr);

              if (!pNewAttr)
              {
                 break;
              }
               
              if (pNewAttr->IsValueSet())
              {
                 hr = pNewAttr->AppendValues(pCurrentInfo->pADsValues,
                                        pCurrentInfo->dwNumValues);
              }
              else
              {
                 pNewAttr->SetValueSet(TRUE);
                 pNewAttr->SetAttrInfo(pCurrentInfo);
              }

              // If the current attribute info was not in the array
              // of information from the initial request, release
              // it here now that we are done with it.

              if (!currentInMasterList)
              {
                 ::FreeADsMem(pCurrentInfo);
                 pCurrentInfo = NULL;
              }

              if (rangeEnd == 0)
              {
                 break;
              }

              // Request next batch of values for the attribute.

              CString szNextAttribute = szAttributeBase;
              CString szNextRange;
              szNextRange.Format(L";range=%ld-*", rangeEnd);
              szNextAttribute += szNextRange;

              DWORD dwNextReturned = 0;
              PWSTR pszAttrs = (PWSTR)(PCWSTR)szNextAttribute;

              hr = spDirObject->GetObjectAttributes(&pszAttrs, 
                                                    1, 
                                                    &pCurrentInfo, 
                                                    &dwNextReturned);
              if (FAILED(hr))
              {
                 break;
              }

              if (dwNextReturned != 1 ||
                  !pCurrentInfo)
              {
                 ASSERT(dwNextReturned == 1);
                 ASSERT(pCurrentInfo);
                 break;
              }

              // Since this pointer comes from an additional request to ADSI,
              // we'll need to free it when we are done with it.
              currentInMasterList = false;

              rangeEnd = static_cast<DWORD>(-1);
           }
        }
      }
      TRACE(_T("Added %u properties to the list\nThe list has %u total properties\n"), dwReturned, m_AttrList.GetCount());
    }
    else
    {
      ADSIEditErrorMessage(hr, IDS_MSG_FAIL_LOAD_VALUES, MB_OK);
    }

    for (UINT nIndex = 0; nIndex < nCount; nIndex++)
    {
      delete lpszAttrArray[nIndex];
      lpszAttrArray[nIndex] = NULL;
    }
    delete[] lpszAttrArray;
    lpszAttrArray = NULL;
  }
#endif //RETRIEVESET

  return hr;
}

ATTR_EDITOR_MAP g_attrEditorMap[] = {
//  Class,  Attribute,  ADSTYPE,                    Multivalued,  Creation function
  { NULL,   NULL,       ADSTYPE_DN_STRING,          FALSE,        CreateSingleStringEditor      },
  { NULL,   NULL,       ADSTYPE_DN_STRING,          TRUE,         CreateMultiStringEditor       },
  { NULL,   NULL,       ADSTYPE_CASE_IGNORE_STRING, FALSE,        CreateSingleStringEditor      },
  { NULL,   NULL,       ADSTYPE_CASE_IGNORE_STRING, TRUE,         CreateMultiStringEditor       },
  { NULL,   NULL,       ADSTYPE_CASE_EXACT_STRING,  FALSE,        CreateSingleStringEditor      },
  { NULL,   NULL,       ADSTYPE_CASE_EXACT_STRING,  TRUE,         CreateMultiStringEditor       },
  { NULL,   NULL,       ADSTYPE_PRINTABLE_STRING,   FALSE,        CreateSingleStringEditor      },
  { NULL,   NULL,       ADSTYPE_PRINTABLE_STRING,   TRUE,         CreateMultiStringEditor       },
  { NULL,   NULL,       ADSTYPE_NUMERIC_STRING,     FALSE,        CreateSingleStringEditor      },
  { NULL,   NULL,       ADSTYPE_NUMERIC_STRING,     TRUE,         CreateMultiStringEditor       },
  { NULL,   NULL,       ADSTYPE_OBJECT_CLASS,       FALSE,        CreateSingleStringEditor      },
  { NULL,   NULL,       ADSTYPE_OBJECT_CLASS,       TRUE,         CreateMultiStringEditor       },
  { NULL,   NULL,       ADSTYPE_INTEGER,            FALSE,        CreateSingleIntEditor         },
  { NULL,   NULL,       ADSTYPE_INTEGER,            TRUE,         CreateMultiIntEditor          },
  { NULL,   NULL,       ADSTYPE_LARGE_INTEGER,      FALSE,        CreateSingleLargeIntEditor    },
  { NULL,   NULL,       ADSTYPE_BOOLEAN,            FALSE,        CreateSingleBooleanEditor     },
  { NULL,   NULL,       ADSTYPE_BOOLEAN,            TRUE,         CreateMultiBooleanEditor      },
  { NULL,   NULL,       ADSTYPE_UTC_TIME,           FALSE,        CreateSingleTimeEditor        },
  { NULL,   NULL,       ADSTYPE_UTC_TIME,           TRUE,         CreateMultiTimeEditor         },
  { NULL,   NULL,       ADSTYPE_TIMESTAMP,          FALSE,        CreateSingleTimeEditor        },
  { NULL,   NULL,       ADSTYPE_TIMESTAMP,          TRUE,         CreateMultiTimeEditor         },
  { NULL,   NULL,       ADSTYPE_OCTET_STRING,       FALSE,        CreateSingleOctetStringEditor },
  { NULL,   NULL,       ADSTYPE_OCTET_STRING,       TRUE,         CreateMultiOctetStringEditor  },
  { NULL,   NULL,       ADSTYPE_DN_WITH_STRING,     FALSE,        CreateDNWithStringEditor      },
};

size_t g_attrEditMapCount = sizeof(g_attrEditorMap)/sizeof(ATTR_EDITOR_MAP);

CValueEditDialog* CAttributeEditorPropertyPage::RetrieveEditor(LPDS_ATTRIBUTE_EDITORINFO pAttributeEditorInfo)
{
  CValueEditDialog* pNewDialog = NULL;

  if (pAttributeEditorInfo != NULL)
  {
    int iMultivalued = 0;
    CString szSyntax;
    ADSTYPE adsType = RetrieveADsTypeFromSyntax(pAttributeEditorInfo->lpszAttribute, &iMultivalued, szSyntax);

    for (size_t idx = 0; idx < g_attrEditMapCount; idx++)
    {
      //
      // REVIEW_JEFFJON : for now I am just looking at ADSTYPE and single/multivalued
      //
      if (g_attrEditorMap[idx].adsType == adsType &&
          g_attrEditorMap[idx].bMultivalued == pAttributeEditorInfo->bMultivalued)
      {
        pNewDialog = g_attrEditorMap[idx].pfnCreateFunc(pAttributeEditorInfo->lpszClass,
                                                        pAttributeEditorInfo->lpszAttribute,
                                                        adsType,
                                                        pAttributeEditorInfo->bMultivalued);
        break;
      }
    }
  }

  return pNewDialog;
}


ADSTYPE CAttributeEditorPropertyPage::RetrieveADsTypeFromSyntax(LPCWSTR lpszAttribute, BOOL* pbMulti, CString& szSyntax)
{
  ADSTYPE adsType = ADSTYPE_INVALID;

  if (!pbMulti ||
      !lpszAttribute)
  {
     ASSERT(pbMulti);
     ASSERT(lpszAttribute);
     
     return adsType;
  }

  if (m_dwBindFlags & DSATTR_EDITOR_ROOTDSE)
  {
      int idx=0, iCount = 0;

      // NTRAID#NTBUG9-563093-2002/03/05-artm  If lpszAttribute not null terminated,
      // this will blow up.
      iCount = wcslen(lpszAttribute);

      while( g_ldapRootDSESyntax[idx].lpszAttr) 
      {
          // NOTICE-2002/03/05-artm  _wcsnicmp() OK.
          // arg1 is global var that should be null terminated;
          // arg2 is null terminated or we wouldn't have gotten this far.
          if ( _wcsnicmp(g_ldapRootDSESyntax[idx].lpszAttr, lpszAttribute, iCount) == 0)
          {
              *pbMulti = g_ldapRootDSESyntax[idx].bMulti;
            szSyntax = g_ldapRootDSESyntax[idx].lpszSyntax;
            break;
          }
          idx++;
      }
      adsType = GetADsTypeFromString(szSyntax, szSyntax);
  }
  else
  {
     CADSIQueryObject schemaSearch;

     HRESULT hr = S_OK;
     CComPtr<IDirectorySearch> spDirSearch;

     CString schemaBindPath(m_szSchemaNamingContext);

     if (m_dwBindFlags & DSATTR_EDITOR_GC)
     {
         // GC by default does not have 'attributeSyntax' or 'isSingleValued'
         // in the partial attribute set.  To ensure we can get these attributes,
         // we'll bind with LDAP instead of GC.  This is ok b/c we are searching
         // the schema, which is the same on the GC and all DC's.
         // NTRAID#NTBUG9-762158-2003/01/15-artm

         int numReplaced = schemaBindPath.Replace(L"GC://", L"LDAP://");
         if (numReplaced != 1)
         {
            ASSERT(numReplaced == 1);
            // fall back to connecting to the GC, since the path wasn't 
            // adapted the way we expected
            schemaBindPath = m_szSchemaNamingContext;
         }
     }

     // REVIEW_JEFFJON : this needs to be replaced with proper binding calls
     // REVIEW_JEFFJON : maybe this interface pointer should be retained for future use
     hr = m_pfnBind(schemaBindPath,
                    ADS_SECURE_AUTHENTICATION,
                    IID_IDirectorySearch,
                    (PVOID*)&spDirSearch,
                    m_BindLPARAM);
     if (FAILED(hr))
     {
       return ADSTYPE_INVALID;
     }
     //
     // Initialize search object with IDirectorySearch
     //
     hr = schemaSearch.Init(spDirSearch);
     if (FAILED(hr))
     {
       return ADSTYPE_INVALID;
     }

     int cCols = 2;
     LPWSTR pszAttributes[] = {L"isSingleValued", L"attributeSyntax"};
     ADS_SEARCH_COLUMN ColumnData;
     hr = schemaSearch.SetSearchPrefs(ADS_SCOPE_ONELEVEL);
     if (FAILED(hr))
     {
       return ADSTYPE_INVALID;
     }

     CString csFilter;
     csFilter.Format(L"(&(objectClass=attributeSchema)(lDAPDisplayName=%s)(!isDefunct=TRUE))", lpszAttribute);
     schemaSearch.SetFilterString((LPWSTR)(LPCWSTR)csFilter);
     schemaSearch.SetAttributeList (pszAttributes, cCols);
     hr = schemaSearch.DoQuery ();
     if (SUCCEEDED(hr)) 
      {
       hr = schemaSearch.GetNextRow();
       if (SUCCEEDED(hr)) 
         {
            hr = schemaSearch.GetColumn(pszAttributes[0], &ColumnData);
            if (SUCCEEDED(hr))
            {
               TRACE(_T("\t\tisSingleValued: %d\n"), 
                    ColumnData.pADsValues->Boolean);
           *pbMulti = !ColumnData.pADsValues->Boolean;
           schemaSearch.FreeColumn(&ColumnData);
            }

         hr = schemaSearch.GetColumn(pszAttributes[1], &ColumnData);
         if (SUCCEEDED(hr))
         {
           TRACE(_T("\t\tattributeSyntax: %s\n"), 
                 ColumnData.pADsValues->CaseIgnoreString);

           adsType = GetADsTypeFromString(ColumnData.pADsValues->CaseIgnoreString, szSyntax);
           schemaSearch.FreeColumn(&ColumnData);
         }
      }
    }
  }
  return adsType;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\editor.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       editor.h
//
//--------------------------------------------------------------------------

#ifndef _ADSIEDIT_EDIT_H
#define _ADSIEDIT_EDIT_H

class CADSIEditConnectionNode;
class CADSIFilterObject;

#include "common.h"
#include "snapdata.h"
#include "filterui.h"
#include "query.h"
#include "credobj.h"

typedef enum
{
	QUERY_OK = 0,
	ERROR_TOO_MANY_NODES
} QUERY_STATE;

extern LPCWSTR g_lpszGC;

class CADSIEditContainerNode; 

///////////////////////////////////////////////////////////////////////////////
// CADSIEditBackgroundThread

class CADSIEditBackgroundThread : public CBackgroundThread
{
public:
	CADSIEditBackgroundThread() : CBackgroundThread(){};

  virtual BOOL InitInstance() 
	{ 
		HRESULT hr = ::OleInitialize(NULL);
		if (FAILED(hr))
		{
			return FALSE;
		}
		return TRUE; 
	}	// MFC override

	virtual int ExitInstance()
	{
		::OleUninitialize();
		return CWinThread::ExitInstance();
	}
};

/////////////////////////////////////////////////////////////////////////////////
// CADsObject :

class CADsObject : public CObject
{
public:
	CADsObject(CADSIEditConnectionNode* cConnectNode);
	CADsObject(CADsObject* pADsObject);
	CADsObject();

	CADSIEditConnectionNode* GetConnectionNode() { return m_pConnectionNode; }
	void SetConnectionNode(CADSIEditConnectionNode* pConnectionNode) { m_pConnectionNode = pConnectionNode; }
	void GetName(CString& sName) { sName = m_sName; }
	void SetName(LPCWSTR lpszName);
	void GetDN(CString& sDN) { sDN = m_sDN; }
  PCWSTR GetDNString() { return m_sDN; }
	void SetDN(LPCWSTR lpszDN) { m_sDN = lpszDN; }
	void GetPath(CString& sPath) { sPath = m_sPath; }
	void SetPath(LPCWSTR sPath) { m_sPath = sPath; }	
	void GetClass(CString& sClass ) { sClass = m_sClass; }
	void SetClass(LPCWSTR lpszClass) { m_sClass = lpszClass; }
	BOOL GetContainer() { return m_bContainer; }
	void SetContainer(const BOOL bContainer) { m_bContainer = bContainer; }
	BOOL IsIntermediateNode() { return m_bIntermediate; }
	void SetIntermediateNode(BOOL bIntermediate) { m_bIntermediate = bIntermediate; }
	BOOL IsComplete() { return m_bComplete; }
	void SetComplete(const BOOL bComplete) { m_bComplete = bComplete; }
  PCWSTR GetNCName() { return m_szNCName; }
  void SetNCName(PCWSTR pszNCName) { m_szNCName = pszNCName; }

private:
	CADSIEditConnectionNode* m_pConnectionNode;
	CString m_sName;
	CString m_sDN;
	CString m_sClass;
	CString m_sPath;
  CString m_szNCName;

	BOOL m_bContainer;
	BOOL m_bIntermediate;
	BOOL m_bComplete;
};

///////////////////////////////////////////////////////////////////////////////
// CADSIFilterObject

class CADSIFilterObject
{
public :
	CADSIFilterObject();
	CADSIFilterObject(CADSIFilterObject* pFilterObject);
	~CADSIFilterObject() {}

	void GetFilterString(CString& sFilter);
	void GetUserDefinedFilter(CString& sUserFilter) { sUserFilter = m_sUserFilter; }
	void SetUserDefinedFilter(LPCWSTR lpszUserFilter) { m_sUserFilter = lpszUserFilter; }
	void GetContainerList(CStringList* pContainerList) { CopyStringList(pContainerList, &m_ContainerList); }
	void SetContainerList(CStringList* pContainerList) { CopyStringList(&m_ContainerList, pContainerList); }
	BOOL InUse() { return m_bInUse; }
	void SetInUse(BOOL bInUse) { m_bInUse = bInUse; }

	void Save(IStream* pStm);
	static HRESULT CreateFilterFromStream(IStream* pStm, CADSIFilterObject** ppFilterObject);

private :
	CString m_sFilterString;
	CString m_sUserFilter;
	CStringList m_ContainerList;
	BOOL m_bInUse;
};

/////////////////////////////////////////////////////////////////////////////////
// CConnectionData

class CConnectionData : public CADsObject
{
public:
	CConnectionData();

	CConnectionData(CADSIEditConnectionNode* pConnectNode);
	CConnectionData(CConnectionData* pConnectData);
	~CConnectionData();

	void ConstructorHelper();

	void GetDomainServer(CString& sServer) { sServer = m_sDomainServer; }
	void SetDomainServer(LPCWSTR lpszDomainServer) { m_sDomainServer = lpszDomainServer; }
	void GetPort(CString& sPort) { sPort = m_sPort; }
	void SetPort(LPCWSTR lpszPort) { m_sPort = lpszPort; }
	void GetDistinguishedName(CString& sDistinguished) { sDistinguished = m_sDistinguishedName; }
	void SetDistinguishedName(LPCWSTR lpszDistName) { m_sDistinguishedName = lpszDistName; }
	void GetNamingContext(CString& sNamingContext) { sNamingContext = m_sNamingContext; }
	void SetNamingContext(LPCWSTR lpszNamingContext) { m_sNamingContext = lpszNamingContext; }
	void GetBasePath(CString& sBasePath) { sBasePath = m_sBasePath; }
	void SetBasePath(LPCWSTR lpszPath) { m_sBasePath = lpszPath; }
	void GetBaseLDAPPath(CString& sBasePath);
	void GetLDAP(CString& sLDAP) { sLDAP = m_sLDAP; }
	void SetLDAP(LPCWSTR lpszLDAP) { m_sLDAP = lpszLDAP; }
	BOOL GetUserDefinedServer() { return m_bUserDefinedServer; }
	void SetUserDefinedServer(BOOL bUserDefinedServer) { m_bUserDefinedServer = bUserDefinedServer; }
	void SetPath(LPCWSTR lpszPath) { CADsObject::SetPath(lpszPath); }

	// Schema paths
	//
	void SetSchemaPath(LPCWSTR lpszPath) { m_sSchemaPath = lpszPath; }
	HRESULT GetSchemaPath(CString& sPath);
	void SetAbstractSchemaPath(LPCWSTR lpszPath) { m_sAbstractSchemaPath = lpszPath; }
	void GetAbstractSchemaPath(CString& sPath);

	// Filter Options
	//
	void SetFilter(CADSIFilterObject* pFilter) { m_pFilterObject = pFilter; }
	CADSIFilterObject* GetFilter() { return m_pFilterObject; }

	CCredentialObject* GetCredentialObject() { return m_pCredentialsObject; }

	ULONG GetMaxObjectCount() { return m_nMaxObjectCount; }
	void SetMaxObjectCount(ULONG nMaxCount) { m_nMaxObjectCount = nMaxCount; }

	// NOTICE-2002/03/06-artm  Member field m_sLDAP will never be NULL and
	// will always be null terminated.  Global var g_lpszGC should also
	// always be null terminated; therefore _wcsicmp() is safe to call.
	//
	// Also, the operator LPCWSTR() does not create a copy, so there
	// is no memory leak going on here.
  BOOL IsGC() { return (_wcsicmp(LPCWSTR(m_sLDAP), g_lpszGC) == 0); }
	BOOL IsRootDSE() { return m_bRootDSE; }
	void SetRootDSE(const BOOL bRootDSE) { m_bRootDSE = bRootDSE; }
	void SetIDirectoryInterface(IDirectoryObject* pDirObject);

	void Save(IStream* pStm);
	static CConnectionData* Load(IStream* pStm);
	static HRESULT LoadBasePathFromContext(CConnectionData* pConnectData, const CString sContext);
	static HRESULT GetServerNameFromDefault(CConnectionData* pConnectData);
	void BuildPath();

	HRESULT GetADSIServerName(OUT CString& szServer, IN IUnknown* pUnk);

private:
	CString m_sBasePath;
	CString m_sDomainServer;
	CString m_sPort;
	CString m_sDistinguishedName;
	CString m_sNamingContext;
	CString m_sLDAP;
	CString m_sSchemaPath;
	CString m_sAbstractSchemaPath;

	// Filter Options
	//
	CADSIFilterObject* m_pFilterObject;

	CCredentialObject* m_pCredentialsObject;

	IDirectoryObject* m_pDirObject;

	BOOL m_bCredentials;
	BOOL m_bRootDSE;
	BOOL m_bUserDefinedServer;
	ULONG m_nMaxObjectCount;	// Maximum Number of objects per container
};



//////////////////////////////////////////////////////////////////////////////////
// CADSIEditLeafNode : 

class CADSIEditLeafNode : public CLeafNode
{
	typedef enum
	{
		notLoaded = 0, // initial state, valid only if server never contacted
		loading,
		loaded,
		unableToLoad,
		accessDenied
	} nodeStateType;

protected:
	CADsObject* m_pADsObject;

public:
  CADSIEditLeafNode(CADsObject* pADsObject) 
	{ 
		m_pADsObject = pADsObject;
	}

	~CADSIEditLeafNode()
	{
		delete m_pADsObject;
	}

	// node info
	DECLARE_NODE_GUID()

	CADSIEditLeafNode(CADSIEditLeafNode* pLeafNode);

	virtual BOOL OnAddMenuItem(LPCONTEXTMENUITEM2 pContextMenuItem,
								 						 long *pInsertionAllowed);

	virtual HRESULT OnCommand(long nCommandID, 
                            DATA_OBJECT_TYPES type, 
                            CComponentDataObject* pComponentData,
                            CNodeList* pNodeList);
  virtual void OnConnectToNCFromHere(CComponentDataObject* pComponentData);
	virtual BOOL OnSetRenameVerbState(DATA_OBJECT_TYPES type, 
                                    BOOL* pbHide, 
                                    CNodeList* pNodeList);
	virtual BOOL OnSetDeleteVerbState(DATA_OBJECT_TYPES type, 
                                    BOOL* pbHide, 
                                    CNodeList* pNodeList);
	virtual void OnDelete(CComponentDataObject* pComponentData,
                        CNodeList* pNodeList);
	virtual HRESULT OnRename(CComponentDataObject* pComponentData, LPWSTR lpszNewName);
	virtual void OnMove(CComponentDataObject* pComponentData);
	virtual LPCWSTR GetString(int nCol);
  virtual int GetImageIndex(BOOL bOpenImage);

	virtual BOOL FindNode(LPCWSTR lpszPath, CList<CTreeNode*, CTreeNode*>& foundNodeList);
	virtual void RefreshOverlappedTrees(CString& szPath, CComponentDataObject* pComponentData);

  virtual BOOL HasPropertyPages(DATA_OBJECT_TYPES type, 
                                BOOL* pbHideVerb, 
                                CNodeList* pNodeList);
  virtual HRESULT CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, 
                                      LONG_PTR handle,
                                      CNodeList* pNodeList);

	virtual BOOL CanCloseSheets();

	virtual void SetContainer(BOOL container) { m_pADsObject->SetContainer(container); }

	BOOL BuildSchemaPath(CString& sPath);

	virtual LPCONTEXTMENUITEM2 OnGetContextMenuItemTable() 
		{ return CADSIEditLeafMenuHolder::GetContextMenuItem(); }


	virtual CADsObject* GetADsObject() { return m_pADsObject; }

	CContainerNode* GetRootContainer()
		{ return (m_pContainer != NULL) ? m_pContainer->GetRootContainer() : NULL; }
};

//////////////////////////////////////////////////////////////////////////////////
// CADSIEditContainerNode :

class CADSIEditContainerNode : public CMTContainerNode
{
public:
	// enumeration for node states, to handle icon changes
	typedef enum
	{
		notLoaded = 0, // initial state, valid only if server never contacted
		loading,
		loaded,
		unableToLoad,
		accessDenied
	} nodeStateType;



public:
  CADSIEditContainerNode() : m_pPartitionsColumnSet(NULL)
	{
		m_pADsObject = new CADsObject();
		m_nState = notLoaded;
    m_szDescriptionText = L"";
	}

	CADSIEditContainerNode(CADsObject* pADsObject);
	CADSIEditContainerNode(CADSIEditContainerNode* pContNode);

	~CADSIEditContainerNode()
	{
		delete m_pADsObject;

    if (m_pPartitionsColumnSet)
    {
      delete m_pPartitionsColumnSet;
      m_pPartitionsColumnSet = NULL;
    }
	}

	// node info
	DECLARE_NODE_GUID()

	virtual BOOL OnAddMenuItem(LPCONTEXTMENUITEM2 pContextMenuItem,
							               long *pInsertionAllowed);

	virtual HRESULT OnCommand(long nCommandID, 
                            DATA_OBJECT_TYPES type, 
                            CComponentDataObject* pComponentData,
                            CNodeList* pNodeList);
	virtual BOOL OnSetRenameVerbState(DATA_OBJECT_TYPES type, 
                                    BOOL* pbHide, 
                                    CNodeList* pNodeList);
	virtual BOOL OnSetDeleteVerbState(DATA_OBJECT_TYPES type, 
                                    BOOL* pbHide, 
                                    CNodeList* pNodeList);
	virtual void OnDelete(CComponentDataObject* pComponentData,
                        CNodeList* pNodeList);
	virtual HRESULT OnRename(CComponentDataObject* pComponentData, LPWSTR lpszNewName);
	virtual void OnMove(CComponentDataObject* pComponentData);
	virtual void OnCreate(CComponentDataObject* pComponentData);
  virtual void OnConnectFromHere(CComponentDataObject* pComponentData);
  virtual void OnConnectToNCFromHere(CComponentDataObject* pComponentData);
	virtual CQueryObj* OnCreateQuery();
	virtual LPCWSTR GetString(int nCol);

  virtual BOOL HasPropertyPages(DATA_OBJECT_TYPES type, 
                                BOOL* pbHideVerb, 
                                CNodeList* pNodeList);
  virtual HRESULT CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, 
                                      LONG_PTR handle,
                                      CNodeList* pNodeList);

	virtual BOOL OnSetRefreshVerbState(DATA_OBJECT_TYPES type, 
                                     BOOL* pbHide, 
                                     CNodeList* pNodeList);

	virtual void SetContainer(BOOL container) { m_pADsObject->SetContainer(container); }

	virtual LPCONTEXTMENUITEM2 OnGetContextMenuItemTable() 
		{ return CADSIEditContainerMenuHolder::GetContextMenuItem(); }

	virtual int GetImageIndex(BOOL bOpenImage);

	virtual CBackgroundThread* CreateThreadObject() 
	{ 
		return new CADSIEditBackgroundThread(); // override if need derived tipe of object
	} 

	BOOL GetNamingAttribute(LPCWSTR lpszClass, CStringList* sNamingAttr);
	BOOL BuildSchemaPath(CString& sPath);

  virtual void OnDeleteMultiple(CComponentDataObject* pComponentData,
                                CNodeList* pNodeList);

	virtual HRESULT DeleteChild(LPCWSTR lpszClass, LPCWSTR lpszPath);
	virtual HRESULT DeleteSubtree(LPCWSTR lpszPath);
	virtual BOOL FindNode(LPCWSTR lpszPath, CList<CTreeNode*, CTreeNode*>& foundNodeList);
	void RefreshOverlappedTrees(CString& sPath, CComponentDataObject* pComponentData);

	virtual CADsObject* GetADsObject() { return m_pADsObject; }

  virtual CColumnSet* GetColumnSet();

  virtual LPCWSTR GetColumnID()
  { 
    return GetColumnSet()->GetColumnID();
  }

  virtual LPWSTR GetDescriptionBarText()
  {
    LPWSTR lpszFormat = L"%d Object(s)";
    int iCount = m_containerChildList.GetCount() + m_leafChildList.GetCount();

    m_szDescriptionText.Format(lpszFormat, iCount);
    return (LPWSTR)(LPCWSTR)m_szDescriptionText;
  }

  //
  // Allow multiple selection
  //
  virtual HRESULT GetResultViewType(LPOLESTR* ppViewType, long* pViewOptions)
  {
	  *pViewOptions = MMC_VIEW_OPTIONS_MULTISELECT;
	  *ppViewType = NULL;
    return S_FALSE;
  }

protected:
	virtual BOOL CanCloseSheets();
	virtual void OnChangeState(CComponentDataObject* pComponentDataObject);
	virtual void OnHaveData(CObjBase* pObj, CComponentDataObject* pComponentDataObject);
  virtual void OnError(DWORD dwErr);

	CADsObject* m_pADsObject;

  CADSIEditColumnSet* m_pPartitionsColumnSet;
  CString m_szDescriptionText;
};

//////////////////////////////////////////////////////////////////////

class CADSIEditQueryObject : public CQueryObj
{
public:
	CADSIEditQueryObject(LPCWSTR lpszPath, 
											 LPCWSTR lpszFilter,
											 ADS_SCOPEENUM scope,
											 ULONG ulMaxObjectCount,
											 CCredentialObject* pCredObject,
                       BOOL bIsGC,
											 CADSIEditConnectionNode* pConnectNode) 
											: m_credentialObject(pCredObject)
	{ 
		m_sPath = lpszPath;
		m_sFilter = lpszFilter;
		m_ulMaxObjectCount = ulMaxObjectCount;
		m_Scope = scope;
    m_bIsGC = bIsGC;

    m_pPathCracker = NULL;

		// NOTE : this holds a pointer across threads but is not
		//					being used.  We should be sure not to use it or
		//					find another way to put the pointer in the data
		//					structures for any new nodes created
		//
		m_pConnectNode = pConnectNode;		
			
	}

  virtual ~CADSIEditQueryObject()
  {
/*    if (m_pPathCracker != NULL)
    {
      m_pPathCracker->Release();
    }
*/  }

	virtual BOOL Enumerate();
	virtual bool IsContainer(PCWSTR pszClass, PCWSTR pszPath);

  BOOL IsGC() { return m_bIsGC; }

	void GetResults(CADSIQueryObject& enumSearch);
	void CreateNewObject(CString& sPath,
		 					         ADS_OBJECT_INFO* pInfo,
                       PCWSTR pszNCName);
	void CrackPath(const CString sName, CString& sPath, CString& sDN);
  IADsPathname* PathCracker();
	void SetFilter(LPCWSTR lpszFilter) { m_sFilter = lpszFilter; }
	void GetFilter(CString& sFilter) { sFilter = m_sFilter; }

protected:
//	CADsObject *m_pADsObject;
	CString m_sPath;
	CString m_sFilter;

	ADS_SCOPEENUM m_Scope;

  BOOL m_bIsGC;
	ULONG m_ulMaxObjectCount;
	CCredentialObject m_credentialObject;
	CADSIEditConnectionNode* m_pConnectNode;

  CComPtr<IADsPathname> m_pPathCracker;
};


#endif _ADSIEDIT_EDIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\filterui.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       filterui.cpp
//
//--------------------------------------------------------------------------

///////////////////////////////////////////////////////////////////////////////
// filterui.cpp

#include "pch.h"
#include <SnapBase.h>

#include <shlobj.h> // needed for dsclient.h
#include <dsclient.h>

#include "common.h"
#include "resource.h"
#include "filterui.h"
#include "editor.h"
#include "query.h"

#ifdef DEBUG_ALLOCATOR
	#ifdef _DEBUG
	#define new DEBUG_NEW
	#undef THIS_FILE
	static char THIS_FILE[] = __FILE__;
	#endif
#endif

BEGIN_MESSAGE_MAP(CADSIFilterDialog, CDialog)
	//{{AFX_MSG_MAP(CADsObjectDialog)
	ON_BN_CLICKED(IDC_EDIT_BUTTON, OnEditFilter)
	ON_BN_CLICKED(IDC_FILTER_RADIO, OnSelFilterRadio)
	ON_BN_CLICKED(IDC_SHOWALL_RADIO, OnSelShowAllRadio)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CADSIFilterDialog

BOOL CADSIFilterDialog::OnInitDialog()
{
	CButton* pShowAllButton	= (CButton*)GetDlgItem(IDC_SHOWALL_RADIO);
	CButton* pFilterButton		= (CButton*)GetDlgItem(IDC_FILTER_RADIO);
	CButton* pEditButton			= (CButton*)GetDlgItem(IDC_EDIT_BUTTON);
	CEdit* pMaxNumBox			= (CEdit*)GetDlgItem(IDC_MAX_NUMBER_BOX);

	m_pFilterObject = m_pConnectData->GetFilter();

  // disable IME support on numeric edit fields
  ImmAssociateContext(pMaxNumBox->GetSafeHwnd(), NULL);

	if (m_pFilterObject->InUse())
	{
		pFilterButton->SetCheck(TRUE);
		pEditButton->EnableWindow(TRUE);
	}
	else
	{
		pShowAllButton->SetCheck(TRUE);
		pEditButton->EnableWindow(FALSE);
	}
	m_pFilterObject->GetUserDefinedFilter(m_sUserFilter);
	m_pFilterObject->GetContainerList(&m_sContainerList);

	ULONG nMaxNum = m_pConnectData->GetMaxObjectCount();
	CString sMaxNum;
	ultow(nMaxNum, sMaxNum);
	pMaxNumBox->SetLimitText(ADSIEDIT_QUERY_OBJ_TEXT_COUNT_MAX);
	pMaxNumBox->SetWindowText(sMaxNum);

	return CDialog::OnInitDialog();
}

void CADSIFilterDialog::OnSelFilterRadio()
{
	CButton* pFilterButton		= (CButton*)GetDlgItem(IDC_FILTER_RADIO);
	CButton* pEditButton			= (CButton*)GetDlgItem(IDC_EDIT_BUTTON);

	if (pFilterButton->GetCheck())
	{
		pEditButton->EnableWindow(TRUE);
	}
}

void CADSIFilterDialog::OnSelShowAllRadio()
{
	CButton* pShowAllButton	= (CButton*)GetDlgItem(IDC_SHOWALL_RADIO);
	CButton* pEditButton			= (CButton*)GetDlgItem(IDC_EDIT_BUTTON);

	if (pShowAllButton->GetCheck())
	{
		pEditButton->EnableWindow(FALSE);
	}
}

void CADSIFilterDialog::OnEditFilter()
{
   CThemeContextActivator activator;
	CADSIFilterEditDialog editDialog(m_pConnectData,
																	 &m_sUserFilter, 
																	 &m_sContainerList);
	editDialog.DoModal();
}

void CADSIFilterDialog::OnOK()
{
	CButton* pShowAllButton	= (CButton*)GetDlgItem(IDC_SHOWALL_RADIO);
	CEdit* pMaxNumBox			= (CEdit*)GetDlgItem(IDC_MAX_NUMBER_BOX);

	m_pFilterObject->SetInUse(!pShowAllButton->GetCheck());
	m_pFilterObject->SetUserDefinedFilter(m_sUserFilter);
	m_pFilterObject->SetContainerList(&m_sContainerList);

	CString sMaxNum;
	pMaxNumBox->GetWindowText(sMaxNum);
	ULONG nMaxNum = _wtol((LPWSTR)(LPCWSTR)sMaxNum);

	if (nMaxNum >= ADSIEDIT_QUERY_OBJ_COUNT_MIN && nMaxNum <= ADSIEDIT_QUERY_OBJ_COUNT_MAX)
	{
		m_pConnectData->SetMaxObjectCount(nMaxNum);
	}
	else if (nMaxNum < ADSIEDIT_QUERY_OBJ_COUNT_MIN)
	{
		m_pConnectData->SetMaxObjectCount(ADSIEDIT_QUERY_OBJ_COUNT_MIN);
	}
	else
	{
		m_pConnectData->SetMaxObjectCount(ADSIEDIT_QUERY_OBJ_COUNT_MAX);
	}

	CDialog::OnOK();
}

/////////////////////////////////////////////////////////////////////////////////
// CContainerCheckListBox

BOOL CContainerCheckListBox::Initialize(UINT nCtrlID, const CStringList& sContainerList, 
																				const CStringList& sFilterList, CWnd* pParentWnd)
{
	if (!SubclassDlgItem(nCtrlID, pParentWnd))
		return FALSE;
	SetCheckStyle(BS_AUTOCHECKBOX);

	POSITION pos = sContainerList.GetHeadPosition();
	while (pos != NULL)
	{
		CString sContainer = sContainerList.GetNext(pos);
		AddString((LPWSTR)(LPCWSTR)sContainer);
	}

	pos = sFilterList.GetHeadPosition();
	while (pos != NULL)
	{
		CString sFilter = sFilterList.GetNext(pos);
		int idx = FindStringExact(-1, sFilter);
		if (idx != LB_ERR)
		{
			SetCheck(idx, 1);
		}
	}
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
// CADSIFilterEditDialog

BEGIN_MESSAGE_MAP(CADSIFilterEditDialog, CDialog)
	//{{AFX_MSG_MAP(CADsObjectDialog)
//	ON_CBN_EDITCHANGE(IDC_FILTER_BOX, OnEditChangeDSList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CADSIFilterEditDialog::CADSIFilterEditDialog(CConnectionData* pConnectData, 
																						 CString* psFilter, 
																						 CStringList* psContList) 
																						: CDialog(IDD_EDIT_FILTER_DIALOG)
{ 
	m_pConnectData = pConnectData;
	m_pFilterObject = pConnectData->GetFilter();

	ASSERT(psFilter != NULL);
	m_psFilter = psFilter;

	ASSERT(psContList != NULL);
	m_psContList = psContList;
}

BOOL CADSIFilterEditDialog::OnInitDialog()
{
	CWaitCursor hourGlass;

	CStringList sContainerList;
	GetContainersFromSchema(sContainerList);

	VERIFY(m_ContainerBox.Initialize(IDC_CONTAINER_LIST, sContainerList, *m_psContList, this));
	CEdit* pFilterBox	= (CEdit*)GetDlgItem(IDC_FILTER_BOX);

	pFilterBox->SetWindowText(*m_psFilter);

	return CDialog::OnInitDialog();
}


void CADSIFilterEditDialog::GetContainersFromSchema(CStringList& sContainerList)
{
	CString sSchemaPath;
	HRESULT hr = m_pConnectData->GetSchemaPath(sSchemaPath);
  if (FAILED(hr))
  {
    ADSIEditErrorMessage(hr);
    return;
  }

	CADSIQueryObject schemaSearch;

	// Initialize search object with path, username and password
	//
	hr = schemaSearch.Init(sSchemaPath, m_pConnectData->GetCredentialObject());
	if (FAILED(hr))
	{
		ADSIEditErrorMessage(hr);
		return;
	}

	int cCols = 2;
  LPWSTR pszAttributes[] = {L"possibleInferiors", L"lDAPDisplayName"};
  hr = schemaSearch.SetSearchPrefs(ADS_SCOPE_ONELEVEL);
	if (FAILED(hr))
	{
		ADSIEditErrorMessage(hr);
		return;
	}

	BOOL bContainer = FALSE;

  CString csFilter = _T("(objectClass=classSchema)");
  schemaSearch.SetFilterString((LPWSTR)(LPCWSTR)csFilter);
  schemaSearch.SetAttributeList (pszAttributes, cCols);
  hr = schemaSearch.DoQuery ();
  while (SUCCEEDED(hr))
  {
    hr = schemaSearch.GetNextRow();
    if (hr == S_ADS_NOMORE_ROWS)
		{
      break;
    }

		if (SUCCEEDED(hr)) 
		{
			CString sContainer, sInferiors;

			ADS_SEARCH_COLUMN ColumnData0, ColumnData1;
			hr = schemaSearch.GetColumn(pszAttributes[1], &ColumnData1);
			if (SUCCEEDED(hr))
			{
				TRACE(_T("\t\tlDAPDisplayName: %s\n"),
							ColumnData1.pADsValues->CaseIgnoreString);

				hr = schemaSearch.GetColumn(pszAttributes[0], &ColumnData0);
				if (SUCCEEDED(hr) && ColumnData0.dwNumValues > 0)
				{
					TRACE(_T("\t\tpossibleInferiors: %s\n"), 
							 ColumnData0.pADsValues->CaseIgnoreString);
					sContainerList.AddTail(ColumnData1.pADsValues->CaseIgnoreString);
      			schemaSearch.FreeColumn(&ColumnData0);
				}
			   schemaSearch.FreeColumn(&ColumnData1);

            // reset hr so that the loop will continue
            hr = S_OK;
			}
		}
	}
}


void CADSIFilterEditDialog::OnOK()
{
	CEdit* pFilterBox	= (CEdit*)GetDlgItem(IDC_FILTER_BOX);

	CString sUserFilter;
	pFilterBox->GetWindowText(sUserFilter);
	*m_psFilter = sUserFilter;

	CString sContainer;

	m_psContList->RemoveAll();

	int iCount = m_ContainerBox.GetCount();
	for (int idx = 0; idx < iCount; idx++)
	{
		if (m_ContainerBox.GetCheck(idx) == 1)
		{
			m_ContainerBox.GetText(idx, sContainer);
			m_psContList->AddTail(sContainer);
		}
	}
	
	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\filterui.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       filterui.h
//
//--------------------------------------------------------------------------

///////////////////////////////////////////////////////////////////////////////
// filterui.h

#ifndef _FILTERUI_H
#define _FILTERUI_H

#include "common.h"
//#include "editor.h"
#include "resource.h"

class CConnectionData;
class CADSIFilterObject;

///////////////////////////////////////////////////////////////////////////////
// CADSIFilterDialog

class CADSIFilterDialog : public CDialog
{
public :
	CADSIFilterDialog(CConnectionData* pConnectData) : CDialog(IDD_FILTER_DIALOG)
	{	
		m_pConnectData = pConnectData;
		m_sUserFilter = _T("");
	}
	~CADSIFilterDialog() {};

	virtual BOOL OnInitDialog();
	virtual void OnOK();
	virtual void OnEditFilter();
	void OnSelFilterRadio();
	void OnSelShowAllRadio();


private :
	CADSIFilterObject* m_pFilterObject;

	CString m_sUserFilter;
	CStringList m_sContainerList;

	CConnectionData* m_pConnectData;
	DECLARE_MESSAGE_MAP()
};

///////////////////////////////////////////////////////////////////////////////
// CContainerCheckListBox

class CContainerCheckListBox : public CCheckListBox
{
public :
	CContainerCheckListBox() {}
	~CContainerCheckListBox(){}

	BOOL Initialize(UINT nID, const CStringList& sContainerList, 
									const CStringList& sFilterList, CWnd* pParentWnd);
};

///////////////////////////////////////////////////////////////////////////////
// CADSIFilterEditDialog

class CADSIFilterEditDialog : public CDialog
{
public :
	CADSIFilterEditDialog(CConnectionData* pConnectData,
												CString* psFilter,
												CStringList* psContList);
	~CADSIFilterEditDialog() {};

	virtual BOOL OnInitDialog();
	virtual void OnOK();
	void GetContainersFromSchema(CStringList& sContainerList);

private :
	CContainerCheckListBox m_ContainerBox;

	CConnectionData* m_pConnectData;
	CADSIFilterObject* m_pFilterObject;

	CString* m_psFilter;
	CStringList* m_psContList;

	DECLARE_MESSAGE_MAP()
};

#endif //_FILTERUI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\iattredt.h ===
#ifndef __ATTRINTERFACE_H
#define __ATTRINTERFACE_H


// {C7436F12-A27F-4cab-AACA-2BD27ED1B773}
DEFINE_GUID(CLSID_DsAttributeEditor, 
0xc7436f12, 0xa27f, 0x4cab, 0xaa, 0xca, 0x2b, 0xd2, 0x7e, 0xd1, 0xb7, 0x73);

//
// Interface GUIDs
//

// {A9948091-69FF-4c00-BE92-925D42E0AD39}
DEFINE_GUID(IID_IDsAttributeEditor, 
0xa9948091, 0x69ff, 0x4c00, 0xbe, 0x92, 0x92, 0x5d, 0x42, 0xe0, 0xad, 0x39);

// {A9948091-69FF-4c00-BE93-925D42E0AD39}
DEFINE_GUID(IID_IDsAttributeEditorExt, 
0xa9948091, 0x69ff, 0x4c00, 0xbe, 0x93, 0x92, 0x5d, 0x42, 0xe0, 0xad, 0x39);

// {5828DF66-95FB-4afa-8F8E-EA0B7D302FB5}
DEFINE_GUID(IID_IDsBindingInfo, 
0x5828df66, 0x95fb, 0x4afa, 0x8f, 0x8e, 0xea, 0xb, 0x7d, 0x30, 0x2f, 0xb5);

// ----------------------------------------------------------------------------
// 
// Interface: IDsBindingInfo
//  
// Implemented by any client needing to invoke the attribute editor UI
//
// Used by: the attribute editor UI
//

  
#undef  INTERFACE
#define INTERFACE   IDsBindingInfo

interface __declspec(uuid("{5828DF66-95FB-4afa-8F8E-EA0B7D302FB5}")) IDsBindingInfo : public IUnknown
{
  // *** IUnknown methods ***
  STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
  STDMETHOD_(ULONG,Release)(THIS) PURE;

  // *** IDsBindingInfo methods ***
  STDMETHOD(DoBind)(THIS_ /*IN*/ LPCWSTR lpszPathName,
                          /*IN*/ DWORD  dwReserved,
                          /*IN*/ REFIID riid,
                          /*IN*/ void FAR * FAR * ppObject) PURE;
};

// ----------------------------------------------------------------------------
// 
// Interface: IDsAttributeEditor
//  
// Implemented by the object (implemented by the system) CLSID_DsAttributeEditor
//
// Used by: any client needing to invoke the attribute editor UI
//

//
// Function definition for the binding callback function
//
typedef HRESULT (*LPBINDINGFUNC)(/*IN*/ LPCWSTR lpszPathName,
                                 /*IN*/ DWORD  dwReserved,
                                 /*IN*/ REFIID riid,
                                 /*IN*/ void FAR * FAR * ppObject,
                                 /*IN*/ LPARAM lParam);

//
// struct passed to IDsAttributeEditor::Initialize()
//
// it contains information regarding the binding function
//

typedef struct
{
    DWORD     dwSize;             // size of struct, for versioning
    DWORD     dwFlags;            // flags defined below
    LPBINDINGFUNC lpfnBind;       // the callback function used to bind to Active Directory
    LPARAM    lParam;             // an optional property that is passed back to lpfnBind
    LPWSTR    lpszProviderServer; // the provider and server that will be used to perform binds
                                  // in the form <Provider>://<server>:<port>/
} DS_ATTREDITOR_BINDINGINFO, * LPDS_ATTREDITOR_BINDINGINFO;
  
//
// Forward declaration
//
class CADSIEditPropertyPageHolder;

//
// Flags used in the DS_ATTREDITOR_BINDINGINFO struct above
//
#define DSATTR_EDITOR_ROOTDSE   0x00000001  // Connection is being made to the RootDSE (don't do schema checks)
#define DSATTR_EDITOR_GC        0x00000002  // Connection is being made to the global catalog (read only attrs)

#undef  INTERFACE
#define INTERFACE   IDsAttributeEditor

interface __declspec(uuid("{A9948091-69FF-4c00-BE92-925D42E0AD39}")) IDsAttributeEditor : public IUnknown
{
  // *** IUnknown methods ***
  STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
  STDMETHOD_(ULONG,Release)(THIS) PURE;

  // *** IDsAttributeEditor methods ***
  STDMETHOD(Initialize)(THIS_ /*IN*/ IADs* pADsObj, 
                              /*IN*/ LPDS_ATTREDITOR_BINDINGINFO pBindingInfo,
                              /*IN*/ CADSIEditPropertyPageHolder* pHolder) PURE;
  STDMETHOD(CreateModal)() PURE;
  STDMETHOD(GetPage)(THIS_ /*OUT*/ HPROPSHEETPAGE* phPropSheetPage) PURE;
};

// ----------------------------------------------------------------------------
// 
// Interface: IDsAttributeEditorExt
//  
// Implemented by any client needing to provide a custom editor for any DS attribute or syntax
//
// Used by: the system to provide editing capabilities for attributes
//

//
// struct passed to IDsAttributeEditorExt::Initialize()
//
// it contains information regarding the attribute type and values
//

typedef struct
{
    DWORD     dwSize;             // size of struct, for versioning
    LPWSTR    lpszClass;          // pointer to a wide character string containing the class name
    LPWSTR    lpszAttribute;      // pointer to a wide character string containing the attribute name
    ADSTYPE   adsType;            // the ADSTYPE of the attribute
    PADSVALUE pADsValue;          // pointer to the ADSVALUE struct that holds the current values
    DWORD     dwNumValues;        // the number of values pointed to by pADsValue
    BOOL      bMultivalued;       // TRUE if the attribute is multivalued, FALSE if it is not.
    BOOL      bReadOnly;          // TRUE if the editor should be shown as read-only
    LPBINDINGFUNC lpfnBind;       // the callback function used to bind to Active Directory
    LPARAM    lParam;             // an optional property that is passed back to lpfnBind
} DS_ATTRIBUTE_EDITORINFO, * LPDS_ATTRIBUTE_EDITORINFO;
  
#undef  INTERFACE
#define INTERFACE   IDsAttributeEditorExt

interface __declspec(uuid("{A9948091-69FF-4c00-BE93-925D42E0AD39}")) IDsAttributeEditorExt : public IUnknown
{
  // *** IUnknown methods ***
  STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
  STDMETHOD_(ULONG,Release)(THIS) PURE;

  // *** IDsAttributeEditor methods ***
  STDMETHOD(Initialize)(THIS_ /*IN*/ LPDS_ATTRIBUTE_EDITORINFO) PURE;
  STDMETHOD(GetNewValue)(THIS_ /*OUT*/ PADSVALUE* ppADsValue, 
                               /*OUT*/ DWORD*     dwNumValues) PURE;
  STDMETHOD(CreateModal)(THIS_ ) PURE;
};

#endif //__ATTRINTERFACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\pch.h ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

// pch.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

//#define _DEBUG_REFCOUNT
// #define _ATL_DEBUG_QI
//#define DEBUG_ALLOCATOR 

// C++ RTTI
#include <typeinfo.h>
#define IS_CLASS(x,y) (typeid(x) == typeid(y))

// MFC Headers

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

//#include <imagehlp.h>
//#include <stdio.h>
//#include <stdlib.h>
}

#ifdef ASSERT
#undef ASSERT
#endif

#include <afxwin.h>
#include <afxdisp.h>
#include <afxdlgs.h>
#include <afxcmn.h>
#include <afxtempl.h> 
#include <prsht.h>  

///////////////////////////////////////////////////////////////////
// miscellanea heades
#include <winsock.h>
#include <aclui.h>

///////////////////////////////////////////////////////////////////
// DNS headers
// DNSRPC.H: nonstandard extension used : zero-sized array in struct/union
//#pragma warning( disable : 4200) // disable zero-sized array


///////////////////////////////////////////
// ASSERT's and TRACE's without debug CRT's
#if defined (DBG)
  #if !defined (_DEBUG)
    #define _USE_MTFRMWK_TRACE
    #define _USE_MTFRMWK_ASSERT
    #define _MTFRMWK_INI_FILE (L"\\system32\\adsiedit.ini")
  #endif
#endif

#include <dbg.h> // from framework


///////////////////////////////////////////////////////////////////
// ATL Headers
#include <atlbase.h>


///////////////////////////////////////////////////////////////////
// CADSIEditModule
class CADSIEditModule : public CComModule
{
public:
	HRESULT WINAPI UpdateRegistryCLSID(const CLSID& clsid, BOOL bRegister);
};

#define DECLARE_REGISTRY_CLSID() \
static HRESULT WINAPI UpdateRegistry(BOOL bRegister) \
{ \
		return _Module.UpdateRegistryCLSID(GetObjectCLSID(), bRegister); \
}


extern CADSIEditModule _Module;


#include <atlcom.h>
#include <atlwin.h>


///////////////////////////////////////////////////////////////////
// Console Headers
#include <mmc.h>
#include <activeds.h>
#include <ADsOpenFlags.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\pch.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1998
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#include "pch.h"

#include <atlimpl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\query.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       query.h
//
//--------------------------------------------------------------------------

#ifndef _ADSIQUERY_H
#define _ADSIQUERY_H

#define QUERY_PAGESIZE 256

class CConnectionData;
class CCredentialObject;

////////////////////////////////////////////////////////////////////////
// CADSIQueryObject

class CADSIQueryObject
{
public:
  CADSIQueryObject();
  ~CADSIQueryObject();

// INTERFACES
public:
  HRESULT Init(IDirectorySearch * pObj);
  HRESULT Init(CString csObjectPath, CCredentialObject* pCredentialObject);
  HRESULT DoQuery();
  HRESULT GetNextRow ();
  HRESULT GetColumn(LPWSTR Attribute,
                    PADS_SEARCH_COLUMN pColumnData);
  HRESULT FreeColumn(PADS_SEARCH_COLUMN pColumnData) 
	{
    return m_pObj->FreeColumn(pColumnData);
  };

  HRESULT SetAttributeList (LPTSTR *pszAttribs, INT cAttrs);
  HRESULT SetSearchPrefs (ADS_SCOPEENUM scope, ULONG nMaxObjectCount = 0);
  HRESULT SetFilterString (LPWSTR pszFilter)
	{
    m_pwszFilter = pszFilter;
    return S_OK;
  }

  //Attributes
public:
  CComPtr<IDirectorySearch> m_pObj;
  ADS_SEARCH_HANDLE  m_SearchHandle;

protected:
  LPWSTR            m_pwszFilter;
  LPWSTR          * m_pszAttribs;
  ULONG             m_nAttrs;
  BOOL							m_bInitialized;

	ADS_SEARCHPREF_INFO* aSearchPref;
};
        
#endif //_ADSIQUERY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\query.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       query.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#include <SnapBase.h>

#include "query.h"
#include "editor.h"

#ifdef DEBUG_ALLOCATOR
	#ifdef _DEBUG
	#define new DEBUG_NEW
	#undef THIS_FILE
	static char THIS_FILE[] = __FILE__;
	#endif
#endif

	///////////////////////////////////////////////////////////////////////////////
CADSIQueryObject::CADSIQueryObject()
{
  m_bInitialized = FALSE;
  m_pwszFilter = NULL;
  m_pObj = NULL;
  m_SearchHandle = NULL;
  aSearchPref = NULL;
}

CADSIQueryObject::~CADSIQueryObject()
{
  if (m_SearchHandle) 
  {
    m_pObj->CloseSearchHandle (m_SearchHandle);
  }
  if (aSearchPref != NULL)
  {
    delete aSearchPref;
    aSearchPref = NULL;
  }
}


HRESULT CADSIQueryObject::Init(IDirectorySearch * pObj)
{
  HRESULT hr = S_OK;
  
  m_pObj = pObj;
  m_bInitialized = TRUE;
  
  return hr;
}

HRESULT CADSIQueryObject::Init(CString ObjPath, CCredentialObject* pCredObject)
{
  HRESULT hr, hCredResult;

	hr = OpenObjectWithCredentials(
																 pCredObject, 
																 ObjPath,
																 IID_IDirectorySearch, 
																 (LPVOID*) &m_pObj
																 );
  if (SUCCEEDED(hr)) 
	{
    m_bInitialized = TRUE;
  } 
	else 
	{
    m_bInitialized = FALSE;
    m_pObj = NULL;
  }
  return hr;
}

HRESULT CADSIQueryObject::SetAttributeList (LPTSTR *pszAttribs, INT cAttrs)
{

  m_pszAttribs = pszAttribs;
  m_nAttrs = cAttrs;
  return S_OK;
}

const int nSearchPrefs = 4;
HRESULT CADSIQueryObject::SetSearchPrefs (ADS_SCOPEENUM scope, ULONG nMaxObjectCount)
{
  HRESULT hr;
	int nNumPrefs = nSearchPrefs;
	if (nMaxObjectCount == 0)
	{
		nNumPrefs--;
	}
  aSearchPref = new ADS_SEARCHPREF_INFO[nNumPrefs];

  if (m_bInitialized) 
	{
    aSearchPref[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    aSearchPref[0].vValue.dwType = ADSTYPE_INTEGER;
    aSearchPref[0].vValue.Integer = scope;
    aSearchPref[1].dwSearchPref = ADS_SEARCHPREF_ASYNCHRONOUS;
    aSearchPref[1].vValue.dwType = ADSTYPE_BOOLEAN;
    aSearchPref[1].vValue.Boolean = TRUE;
    aSearchPref[2].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
    aSearchPref[2].vValue.dwType = ADSTYPE_INTEGER;
    aSearchPref[2].vValue.Integer = QUERY_PAGESIZE;
		
		if (nMaxObjectCount > 0)
		{
			aSearchPref[3].dwSearchPref = ADS_SEARCHPREF_SIZE_LIMIT;
			aSearchPref[3].vValue.dwType = ADSTYPE_INTEGER;
			aSearchPref[3].vValue.Integer = nMaxObjectCount;
		}
		hr = m_pObj->SetSearchPreference (aSearchPref, nNumPrefs);
    delete aSearchPref;
    aSearchPref = NULL;
  } 
	else 
	{
    hr = E_ADS_BAD_PATHNAME;
  }
  return hr;
}


const int NUM_PREFS=3;
HRESULT CADSIQueryObject::DoQuery()
{
  HRESULT hr;
  if (m_bInitialized) 
	{
     hr = m_pObj->ExecuteSearch (m_pwszFilter,
                                 m_pszAttribs,
                                 m_nAttrs,
                                 &m_SearchHandle);
  } 
	else 
	{
    hr = E_ADS_BAD_PATHNAME;
  }
  return hr;
}

HRESULT CADSIQueryObject::GetNextRow()
{
  if (m_bInitialized) 
	{
    return m_pObj->GetNextRow (m_SearchHandle);
  }
  return E_ADS_BAD_PATHNAME;
}

HRESULT CADSIQueryObject::GetColumn(LPWSTR Attribute, PADS_SEARCH_COLUMN pColumnData)
{
  if (m_bInitialized) 
	{
    return m_pObj->GetColumn (m_SearchHandle,
                              Attribute,
                              pColumnData);
  }
  return E_ADS_BAD_PATHNAME;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\querynode.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       querynode.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#include <SnapBase.h>

#include "resource.h"
#include "connection.h"
#include "querynode.h"
#include "queryui.h"
#include "editor.h"
#include <aclpage.h>


#ifdef DEBUG_ALLOCATOR
	#ifdef _DEBUG
	#define new DEBUG_NEW
	#undef THIS_FILE
	static char THIS_FILE[] = __FILE__;
	#endif
#endif

////////////////////////////////////////////////////////////////////////
// CADSIEditQueryData

void CADSIEditQueryData::SetRootPath(LPCWSTR lpszRootPath)
{
	m_sRootPath = lpszRootPath;

	GetDisplayPath(m_sDN);
}

void CADSIEditQueryData::GetDisplayPath(CString& sDisplayPath)
{
	CComPtr<IADsPathname> pIADsPathname;
   HRESULT hr = ::CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                                  IID_IADsPathname, (PVOID *)&(pIADsPathname));
   ASSERT((S_OK == hr) && ((pIADsPathname) != NULL));

	hr = pIADsPathname->Set(CComBSTR(m_sRootPath), ADS_SETTYPE_FULL);
	if (FAILED(hr)) 
	{
		TRACE(_T("Set failed. %s"), hr);
	}

	// Get the leaf name
	CString sDN;
	BSTR bstrPath = NULL;
	hr = pIADsPathname->Retrieve(ADS_FORMAT_X500_DN, &bstrPath);
	if (FAILED(hr))
	{
		TRACE(_T("Failed to get element. %s"), hr);
		sDisplayPath = L"";
	}
	else
	{
		sDisplayPath = bstrPath;
	}
}

void CADSIEditQueryData::GetDisplayName(CString& sDisplayName)
{
	CString sDisplayPath;
	GetDisplayPath(sDisplayPath);
	
	sDisplayName = m_sName + _T(" [") + sDisplayPath + _T("]");
}

////////////////////////////////////////////////////////////////////////
// CADSIEditQueryNode
//

// {072B64B7-CFF7-11d2-8801-00C04F72ED31}
const GUID CADSIEditQueryNode::NodeTypeGUID = 
{ 0x72b64b7, 0xcff7, 0x11d2, { 0x88, 0x1, 0x0, 0xc0, 0x4f, 0x72, 0xed, 0x31 } };


CADSIEditQueryNode::CADSIEditQueryNode(CADsObject* pADsObject,
													CADSIEditQueryData* pQueryData)
{	
	m_pADsObject = pADsObject;
	m_pQueryData = pQueryData;
	m_nState = notLoaded; 
	m_sType.LoadString(IDS_QUERY_STRING);
}

HRESULT CADSIEditQueryNode::OnCommand(long nCommandID, 
												  DATA_OBJECT_TYPES type, 
												  CComponentDataObject* pComponentData,
                          CNodeList* pNodeList)
{
  ASSERT (pNodeList->GetCount() == 1); // not allowing multiple selection on any of these yet

	switch (nCommandID)
	{
	case IDM_SETTINGS_QUERY :
		{
			OnSettings(pComponentData);
			break;
		}
	case IDM_REMOVE_QUERY :
		{
			OnRemove(pComponentData);
			break;
		}
  default:
			ASSERT(FALSE); // Unknown command!
			return E_FAIL;
	}
  return S_OK;
}

BOOL CADSIEditQueryNode::OnSetDeleteVerbState(DATA_OBJECT_TYPES type, 
                                              BOOL* pbHideVerb, 
                                              CNodeList* pNodeList)
{
  if (pNodeList->GetCount() == 1) // single selection
  {
	  *pbHideVerb = TRUE; // always hide the verb
	  return FALSE;
  }

  //
  // Multiple selection
  //
  *pbHideVerb = FALSE;
  return TRUE;
}

void CADSIEditQueryNode::OnRemove(CComponentDataObject* pComponentData)
{
	if (ADSIEditMessageBox(IDS_MSG_REMOVE_QUERY, MB_YESNO | MB_DEFBUTTON2) == IDYES)
	{
		BOOL bLocked = IsThreadLocked();
		ASSERT(!bLocked); // cannot do refresh on locked node, the UI should prevent this
		if (bLocked)
			return; 
		if (IsSheetLocked())
		{
			if (!CanCloseSheets())
				return;
		// Do deletion stuff
			pComponentData->GetPropertyPageHolderTable()->DeleteSheetsOfNode(this);
		}
		ASSERT(!IsSheetLocked());

		// Remove query data from connection node's list
		GetADsObject()->GetConnectionNode()->RemoveQueryFromList(GetQueryData());

		// now remove from the UI
		DeleteHelper(pComponentData);
    pComponentData->SetDescriptionBarText(GetContainer());
		delete this; // gone
	}
}

void CADSIEditQueryNode::OnDelete(CComponentDataObject* pComponentData,
                                      CNodeList* pNodeList)
{
  if (pNodeList->GetCount() > 1) // multiple selection
  {
    // Delete some results

    OnDeleteMultiple(pComponentData, pNodeList);
  }
  else if (pNodeList->GetCount() == 1) // single selection
  {
     // Can't delete a query node
     ASSERT(FALSE);
  }
}

void CADSIEditQueryNode::OnSettings(CComponentDataObject* pComponentData)
{
   CThemeContextActivator activator;

   // Get the data from the existing query node data
	BOOL bOneLevel;
	bOneLevel = (GetQueryData()->GetScope() == ADS_SCOPE_ONELEVEL);
	CString sFilter, sName, sPath, sConnectPath;
	GetQueryData()->GetName(sName);
	GetQueryData()->GetFilter(sFilter);
	GetQueryData()->GetRootPath(sPath);

   CConnectionData* pConnectData = GetADsObject()->GetConnectionNode()->GetConnectionData();
   ASSERT(pConnectData);

	GetADsObject()->GetConnectionNode()->GetADsObject()->GetPath(sConnectPath);

	CCredentialObject* pCredObject = 
		pConnectData->GetCredentialObject();

   CString szServer;
   pConnectData->GetDomainServer(szServer);

	// Initialize dialog with data
	CADSIEditQueryDialog queryDialog(szServer, sName, sFilter, sPath, sConnectPath, bOneLevel, pCredObject);

	if (queryDialog.DoModal() == IDOK)
	{
		// If OK
		CString sNewPath;
		queryDialog.GetResults(sName, sFilter, sNewPath, &bOneLevel);
		GetQueryData()->SetName(sName);
		GetQueryData()->SetFilter(sFilter);
		GetQueryData()->SetRootPath(sNewPath);
		GetADsObject()->SetPath(sNewPath);
		ADS_SCOPEENUM scope = (bOneLevel) ? ADS_SCOPE_ONELEVEL : ADS_SCOPE_SUBTREE;
		GetQueryData()->SetScope(scope);

		// Make changes take effect
		CString sDisplayName;
		GetQueryData()->GetDisplayName(sDisplayName);
		SetDisplayName(sDisplayName);

    CNodeList nodeList;
    nodeList.AddTail(this);
		OnRefresh(pComponentData, &nodeList);
	}
}

LPCWSTR CADSIEditQueryNode::GetString(int nCol) 
{ 
	switch(nCol)
	{
		case N_HEADER_NAME :
			return GetDisplayName();
		case N_HEADER_TYPE :
			return m_sType;
		case N_HEADER_DN :
			return m_pQueryData->GetDNString();
		default :
			return NULL;
	}
}

BOOL CADSIEditQueryNode::HasPropertyPages(DATA_OBJECT_TYPES type, 
                                          BOOL* pbHideVerb, 
                                          CNodeList* pNodeList)
{
  *pbHideVerb = TRUE; // always hide the verb
  return FALSE;
}


BOOL CADSIEditQueryNode::OnAddMenuItem(LPCONTEXTMENUITEM2 pContextMenuItem,
													             long *pInsertionAllowed)
{

	if (pContextMenuItem->lCommandID == IDM_SETTINGS_QUERY)
	{
		return TRUE;
	}
	else if (pContextMenuItem->lCommandID == IDM_REMOVE_QUERY)
	{
		return TRUE;
	}
	return FALSE;
}

CQueryObj* CADSIEditQueryNode::OnCreateQuery()
{
	CConnectionData* pConnectData = GetADsObject()->GetConnectionNode()->GetConnectionData();
	CADSIEditRootData* pRootData = static_cast<CADSIEditRootData*>(GetRootContainer());
	CComponentDataObject* pComponentData = pRootData->GetComponentDataObject();
	RemoveAllChildrenHelper(pComponentData);

	CString sPath;
	GetADsObject()->GetPath(sPath);

	CString sFilter;
	GetQueryData()->GetFilter(sFilter);
	ADS_SCOPEENUM scope;
	scope = GetQueryData()->GetScope();

	CADSIEditQueryObject* pQuery = new CADSIEditQueryObject(sPath, sFilter, scope,
																				  pConnectData->GetMaxObjectCount(),
																				  pConnectData->GetCredentialObject(),
                                          pConnectData->IsGC(),
																				  pConnectData->GetConnectionNode());
	return pQuery;
}

BOOL CADSIEditQueryNode::OnSetRefreshVerbState(DATA_OBJECT_TYPES type, 
                                               BOOL* pbHide, 
                                               CNodeList* pNodeList)
{
	*pbHide = FALSE;

	if (m_nState == loading)
	{
		return FALSE;
	}

	return !IsThreadLocked();
}

void CADSIEditQueryNode::OnChangeState(CComponentDataObject* pComponentDataObject)
{
	switch (m_nState)
	{
	case notLoaded:
	case loaded:
	case unableToLoad:
	case accessDenied:
	{
		m_nState = loading;
		m_dwErr = 0;
	}
	break;
	case loading:
	{
		if (m_dwErr == 0)
			m_nState = loaded;
		else if (m_dwErr == ERROR_ACCESS_DENIED)
			m_nState = accessDenied;
		else 
			m_nState = unableToLoad;
	}
	break;
	default:
		ASSERT(FALSE);
	}
	VERIFY(SUCCEEDED(pComponentDataObject->ChangeNode(this, CHANGE_RESULT_ITEM_ICON)));
	VERIFY(SUCCEEDED(pComponentDataObject->UpdateVerbState(this)));
}

int CADSIEditQueryNode::GetImageIndex(BOOL bOpenImage) 
{
	int nIndex = 0;
	switch (m_nState)
	{
	case notLoaded:
		nIndex = ZONE_IMAGE_1;
		break;
	case loading:
		nIndex = ZONE_IMAGE_LOADING_1;
		break;
	case loaded:
		nIndex = ZONE_IMAGE_1;
		break;
	case unableToLoad:
		nIndex = ZONE_IMAGE_UNABLE_TO_LOAD_1;
		break;
	case accessDenied:
		nIndex = ZONE_IMAGE_ACCESS_DENIED_1;
		break;
	default:
		ASSERT(FALSE);
	}
	return nIndex;
}


BOOL CADSIEditQueryNode::CanCloseSheets()
{
  //
  // We can't do this with the new property page since it is not derived
  // from the base class in MTFRMWK.
  //
	//return (IDCANCEL != ADSIEditMessageBox(IDS_MSG_RECORD_CLOSE_SHEET, MB_OKCANCEL));

  ADSIEditMessageBox(IDS_MSG_RECORD_SHEET_LOCKED, MB_OK);
  return FALSE;
}

void CADSIEditQueryNode::OnHaveData(CObjBase* pObj, CComponentDataObject* pComponentDataObject)
{
	CTreeNode* p = dynamic_cast<CTreeNode*>(pObj);
	ASSERT(p != NULL);
	if (p != NULL)
	{
		AddChildToListAndUI(p, pComponentDataObject);
    pComponentDataObject->SetDescriptionBarText(this);
	}
}


void CADSIEditQueryNode::OnError(DWORD dwerr) 
{
	if (dwerr == ERROR_TOO_MANY_NODES)
	{
	  // need to pop message
	 AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CThemeContextActivator activator;

    CString szFmt;
	 szFmt.LoadString(IDS_MSG_QUERY_TOO_MANY_ITEMS);
	 CString szMsg;
	 szMsg.Format(szFmt, GetDisplayName()); 
	 AfxMessageBox(szMsg);
	}
	else
	{
		ADSIEditErrorMessage(dwerr);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\queryui.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       queryui.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#include <SnapBase.h>
#include <shlobj.h>
#include <dsclient.h> // Browse for container dialog

#include <cmnquery.h> // IPersistQuery
#include <dsquery.h> // DSFind dialog

#include "resource.h"
#include "editor.h"
#include "queryui.h"

#ifdef DEBUG_ALLOCATOR
    #ifdef _DEBUG
    #define new DEBUG_NEW
    #undef THIS_FILE
    static char THIS_FILE[] = __FILE__;
    #endif
#endif

BEGIN_MESSAGE_MAP(CADSIEditQueryDialog, CDialog)
    //{{AFX_MSG_MAP(CADsObjectDialog)
    ON_EN_CHANGE(IDC_EDIT_QUERY_STRING, OnEditQueryString)
    ON_EN_CHANGE(IDC_EDIT_QUERY_NAME, OnEditNameString)
    ON_BN_CLICKED(IDC_RADIO_ONELEVEL, OnOneLevel)
    ON_BN_CLICKED(IDC_RADIO_SUBTREE, OnSubtree)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE_CONTAINER, OnBrowse)
    ON_BN_CLICKED(IDC_BUTTON_EDIT_QUERY, OnEditQuery)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

CADSIEditQueryDialog::CADSIEditQueryDialog(CString& szServer,
                                           CString& sName, 
                                                         CString& sFilter, 
                                                         CString& sPath,
                                                         CString& sConnectPath,
                                                         BOOL bOneLevel,
                                                         CCredentialObject* pCredObject)
                : CDialog(IDD_QUERY_DIALOG)

{
    m_bOneLevel = bOneLevel;
    m_sFilter = sFilter;
    m_sName = sName;
    m_sRootPath = sPath;
    m_sConnectPath = sConnectPath;
   m_szServer = szServer;

    m_pCredObject = pCredObject;
}

CADSIEditQueryDialog::CADSIEditQueryDialog(CString& szServer,
                                           CString& sConnectPath, 
                                           CCredentialObject* pCredObject)
                : CDialog(IDD_QUERY_DIALOG)
{
    m_bOneLevel = FALSE;
    m_sConnectPath = sConnectPath;
   m_szServer = szServer;
    m_pCredObject = pCredObject;
}

CADSIEditQueryDialog::~CADSIEditQueryDialog()
{
}


BOOL CADSIEditQueryDialog::OnInitDialog()
{
    CDialog::OnInitDialog();

    CEdit* pEditName = (CEdit*)GetDlgItem(IDC_EDIT_QUERY_NAME);
    CEdit* pEditQueryString = (CEdit*)GetDlgItem(IDC_EDIT_QUERY_STRING);
    CEdit* pEditPath = (CEdit*)GetDlgItem(IDC_EDIT_ROOT_PATH);
    CButton* pOneLevelButton = (CButton*)GetDlgItem(IDC_RADIO_ONELEVEL);
    CButton* pSubtreeButton = (CButton*)GetDlgItem(IDC_RADIO_SUBTREE);
    CButton* pOkButton = (CButton*)GetDlgItem(IDOK);

    if (m_sRootPath != L"")
    {
        CString sDisplayPath;
        GetDisplayPath(sDisplayPath);
        pEditPath->SetWindowText(sDisplayPath);
    }

    pEditName->SetWindowText(m_sName);
    pEditName->SetLimitText(256);   // REVEIW_JEFFJON : Hardcoded length
    pEditQueryString->SetWindowText(m_sFilter);
    pEditQueryString->FmtLines(FALSE);
    pEditQueryString->SetLimitText(256); // REVIEW_JEFFJON : Hardcoded length
    if (pEditQueryString->GetWindowTextLength() > 0 && pEditName->GetWindowTextLength() > 0)
    {
        pOkButton->EnableWindow(TRUE);
    }
    else
    {
        pOkButton->EnableWindow(FALSE);
    }
    pOneLevelButton->SetCheck(m_bOneLevel);
    pSubtreeButton->SetCheck(!m_bOneLevel);
    
    return TRUE;
}

void CADSIEditQueryDialog::OnEditQueryString()
{
    CEdit* pEditName = (CEdit*)GetDlgItem(IDC_EDIT_QUERY_NAME);
    CEdit* pEditQueryString = (CEdit*)GetDlgItem(IDC_EDIT_QUERY_STRING);
    CEdit* pEditPath = (CEdit*)GetDlgItem(IDC_EDIT_ROOT_PATH);
    CButton* pOkButton = (CButton*)GetDlgItem(IDOK);

    if (pEditQueryString->GetWindowTextLength() > 0 && 
            pEditName->GetWindowTextLength() > 0 &&
            pEditPath->GetWindowTextLength() > 0)
    {
        pEditQueryString->GetWindowText(m_sFilter);
        pOkButton->EnableWindow(TRUE);
    }
    else
    {
        pEditQueryString->GetWindowText(m_sFilter);
        pOkButton->EnableWindow(FALSE);
    }
}

void CADSIEditQueryDialog::OnEditNameString()
{
    CEdit* pEditName = (CEdit*)GetDlgItem(IDC_EDIT_QUERY_NAME);
    CEdit* pEditQueryString = (CEdit*)GetDlgItem(IDC_EDIT_QUERY_STRING);
    CEdit* pEditPath = (CEdit*)GetDlgItem(IDC_EDIT_ROOT_PATH);
    CButton* pOkButton = (CButton*)GetDlgItem(IDOK);

    if (pEditQueryString->GetWindowTextLength() > 0 && 
            pEditName->GetWindowTextLength() > 0 &&
            pEditPath->GetWindowTextLength() > 0)
    {
        pEditName->GetWindowText(m_sName);
        pOkButton->EnableWindow(TRUE);
    }
    else
    {
        pEditName->GetWindowText(m_sName);
        pOkButton->EnableWindow(FALSE);
    }
}
        
void CADSIEditQueryDialog::OnOneLevel()
{
    CButton* pOneLevelButton = (CButton*)GetDlgItem(IDC_RADIO_ONELEVEL);

    m_bOneLevel = pOneLevelButton->GetCheck();
}

void CADSIEditQueryDialog::OnSubtree()
{
    CButton* pOneLevelButton = (CButton*)GetDlgItem(IDC_RADIO_ONELEVEL);

    m_bOneLevel = pOneLevelButton->GetCheck();
}

void CADSIEditQueryDialog::OnBrowse()
{
    HRESULT hr = S_OK, hCredResult;
    DWORD result;
    CString strTitle;
    strTitle.LoadString (IDS_QUERY_BROWSE_TITLE);

    DSBROWSEINFO dsbi;
    ::ZeroMemory( &dsbi, sizeof(dsbi) );

    TCHAR szPath[2 * MAX_PATH+1];
    CString str;
    str.LoadString(IDS_MOVE_TARGET);

    dsbi.hwndOwner = GetSafeHwnd();
    dsbi.cbStruct = sizeof (DSBROWSEINFO);
    dsbi.pszCaption = (LPWSTR)((LPCWSTR)strTitle); // this is actually the caption
    dsbi.pszTitle = (LPWSTR)((LPCWSTR)str);
    dsbi.pszRoot = m_sConnectPath;
    dsbi.pszPath = szPath;
    dsbi.cchPath = ((2 * MAX_PATH + 1) / sizeof(TCHAR));
    dsbi.dwFlags = DSBI_INCLUDEHIDDEN | DSBI_RETURN_FORMAT;
    dsbi.pfnCallback = NULL;
    dsbi.lParam = 0;
  dsbi.dwReturnFormat = ADS_FORMAT_X500;

    // Specify credentials
    CString sUserName;
    EncryptedString password;
    WCHAR* cleartext = NULL;

    // NOTICE-NTRAID#NTBUG9-563071-2002/04/17-artm  Password buffer should not be allocated on stack.  
    // I've rewritten the password code to use encrypted string.  See bug
    // for details.

    if (m_pCredObject->UseCredentials())
    {
        m_pCredObject->GetUsername(sUserName);
        password = m_pCredObject->GetPassword();

        // This should never happen, but let's be paranoid.
        ASSERT(password.GetLength() <= MAX_PASSWORD_LENGTH);

        cleartext = password.GetClearTextCopy();

        // If we're out of memory our clear text is null.
        // Let the user know that bad things are happening
        // and abort.
        if (NULL == cleartext)
        {
            password.DestroyClearTextCopy(cleartext);
            ADSIEditErrorMessage(E_OUTOFMEMORY);
            return;
        }

        dsbi.dwFlags |= DSBI_HASCREDENTIALS;
        dsbi.pUserName = sUserName;
        dsbi.pPassword = cleartext;
    }

    result = DsBrowseForContainer( &dsbi );

    // Clean up any clear text copies we have.
    if (m_pCredObject->UseCredentials())
    {
        password.DestroyClearTextCopy(cleartext);
    }

    if ( result == IDOK ) 
    { // returns -1, 0, IDOK or IDCANCEL
        // get path from BROWSEINFO struct, put in text edit field
        TRACE(_T("returned from DS Browse successfully with:\n %s\n"),
        dsbi.pszPath);
        m_sRootPath = dsbi.pszPath;

        CEdit* pEditPath = (CEdit*)GetDlgItem(IDC_EDIT_ROOT_PATH);

        CString sDisplay;
        GetDisplayPath(sDisplay);
        pEditPath->SetWindowText(sDisplay);
    }

    OnEditNameString(); // to check to see if the ok button should be enabled

}

void CADSIEditQueryDialog::GetDisplayPath(CString& sDisplay)
{
    CComPtr<IADsPathname> pIADsPathname;
   HRESULT hr = ::CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                                  IID_IADsPathname, (PVOID *)&(pIADsPathname));
   ASSERT((S_OK == hr) && ((pIADsPathname) != NULL));

    hr = pIADsPathname->Set(CComBSTR(m_sRootPath), ADS_SETTYPE_FULL);
    if (FAILED(hr)) 
    {
        TRACE(_T("Set failed. %s"), hr);
    }

    // Get the leaf name
    CString sDN;
    BSTR bstrPath = NULL;
    hr = pIADsPathname->Retrieve(ADS_FORMAT_X500_DN, &bstrPath);
    if (FAILED(hr))
    {
        TRACE(_T("Failed to get element. %s"), hr);
        sDN = L"";
    }
    else
    {
        sDN = bstrPath;
    }

    sDisplay = sDN;

}

// respone to the Edit Query... button
void CADSIEditQueryDialog::OnEditQuery()
{
    CLIPFORMAT cfDsQueryParams = (CLIPFORMAT)::RegisterClipboardFormat(CFSTR_DSQUERYPARAMS);

    // create a query object
    HRESULT hr;
    CComPtr<ICommonQuery> spCommonQuery;
    hr = ::CoCreateInstance(CLSID_CommonQuery, NULL, CLSCTX_INPROC_SERVER,
                          IID_ICommonQuery, (PVOID *)&spCommonQuery);
    if (FAILED(hr))
        return;
    
    // setup structs to make the query
    DSQUERYINITPARAMS dqip;
    OPENQUERYWINDOW oqw;
    ZeroMemory(&dqip, sizeof(DSQUERYINITPARAMS));
    ZeroMemory(&oqw, sizeof(OPENQUERYWINDOW));

  dqip.cbStruct = sizeof(dqip);
  dqip.dwFlags = DSQPF_NOSAVE | DSQPF_SHOWHIDDENOBJECTS |
                 DSQPF_ENABLEADMINFEATURES;

   CString szUsername;
   EncryptedString password;
   WCHAR* cleartext = NULL;

   // Get the username and password if we are impersonating credentials
   if (m_pCredObject->UseCredentials())
   {
      // NOTICE-NTRAID#NTBUG9-563071-2002/04/17-artm  Password buffer should not
      // be allocated on stack.  
      //
      // I rewrote this to use encrypted string class so that the buffer is not
      // on the stack and to help manage the lifetime of the password.  See bug
      // for more information.
      
      m_pCredObject->GetUsername(szUsername);
      password = m_pCredObject->GetPassword();

      // This shouldn't happen, but let's be paranoid.
      ASSERT(password.GetLength() <= MAX_PASSWORD_LENGTH);

      cleartext = password.GetClearTextCopy();

      // If we run out of memory our clear text is null.
      // Let the user know that bad things are happening
      // and abort operation.
      if (NULL == cleartext)
      {
          password.DestroyClearTextCopy(cleartext);
          ADSIEditErrorMessage(E_OUTOFMEMORY);
          return;
      }

      dqip.pUserName = (LPWSTR)(LPCWSTR)szUsername;
      dqip.pPassword = cleartext;
      dqip.dwFlags |= DSQPF_HASCREDENTIALS;
   }

  if (!m_szServer.IsEmpty())
  {
    dqip.pServer = (LPWSTR)(LPCWSTR)m_szServer;
    dqip.dwFlags |= DSQPF_HASCREDENTIALS;
  }
  dqip.pDefaultScope = NULL;


  oqw.cbStruct = sizeof(oqw);
  oqw.dwFlags = OQWF_OKCANCEL | OQWF_DEFAULTFORM | OQWF_REMOVEFORMS |
        OQWF_REMOVESCOPES | OQWF_SAVEQUERYONOK | OQWF_HIDEMENUS | OQWF_HIDESEARCHUI;

  oqw.clsidHandler = CLSID_DsQuery;
  oqw.pHandlerParameters = &dqip;
  oqw.clsidDefaultForm = CLSID_DsFindAdvanced;

    // Get the HWND of the current dialog
  HWND hWnd = GetSafeHwnd();

    // make the call to get the query displayed
    CComPtr<IDataObject> spQueryResultDataObject;
    hr = spCommonQuery->OpenQueryWindow(hWnd, &oqw, &spQueryResultDataObject);

    // Clean up any clear text copies.
    if (m_pCredObject->UseCredentials())
    {
        password.DestroyClearTextCopy(cleartext);
        cleartext = NULL;
    }

    if (spQueryResultDataObject == NULL)
    {
        if (FAILED(hr))
        {
            // no query available, reset to no data
            m_sFilter = L"";
        }

        // user hit cancel
        return;
    }

    // retrieve the query string from the data object
    FORMATETC fmte = {cfDsQueryParams, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM medium = {TYMED_NULL, NULL, NULL};
    hr = spQueryResultDataObject->GetData(&fmte, &medium);

    if (SUCCEEDED(hr)) // we have data
    {
        // get the query string
        LPDSQUERYPARAMS pDsQueryParams = (LPDSQUERYPARAMS)medium.hGlobal;
        LPWSTR pwszFilter = (LPWSTR)ByteOffset(pDsQueryParams, pDsQueryParams->offsetQuery);
        m_sFilter = pwszFilter;
        ::ReleaseStgMedium(&medium);

        // REVIEW_MARCOC: this is a hack waiting for Diz to fix it...
        // the query string should be a well formed expression. Period
        // the query string is in the form (<foo>)(<bar>)...
        // if more of one token, need to wrap as (& (<foo>)(<bar>)...)
        WCHAR* pChar = (WCHAR*)(LPCWSTR)m_sFilter;
        int nLeftPar = 0;
        while (*pChar != NULL)
        {
            if (*pChar == TEXT('('))
            {
                nLeftPar++;
                if (nLeftPar > 1)
                    break;
            }
            pChar++;
        }
        if (nLeftPar > 1)
        {
            CString s;
            s.Format(_T("(&%s)"), (LPCTSTR)m_sFilter);
            m_sFilter = s;
        }
        TRACE(_T("m_sFilter = %s\n"), (LPCTSTR)m_sFilter);
        CEdit* pEditQueryString = (CEdit*)GetDlgItem(IDC_EDIT_QUERY_STRING);
        pEditQueryString->SetWindowText(m_sFilter);
        OnEditQueryString();
    }

    return;
}

void CADSIEditQueryDialog::GetResults(CString& sName, 
                                                  CString& sFilter, 
                                                  CString& sPath,
                                                  BOOL* pOneLevel)
{
    sName = m_sName;
    sFilter = m_sFilter;
    sPath = m_sRootPath;
    *pOneLevel = m_bOneLevel;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\querynode.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       querynode.h
//
//--------------------------------------------------------------------------

#ifndef _QUERYNODE_H
#define _QUERYNODE_H

#include "editor.h"
//#include "connection.h"
//#include "resource.h"
//#include "snapdata.h"

//////////////////////////////////////////////////////////////////////////////////
// CADSIEditQueryData :

class CADSIEditQueryData
{
public :
	CADSIEditQueryData() {} 
	~CADSIEditQueryData() {}


	void SetName(LPCWSTR lpszName) { m_sName = lpszName; }
	void GetName(CString& sName) { sName = m_sName; }
	void SetDN(LPCWSTR lpszDN) { m_sDN = lpszDN; }
	void GetDN(CString& szDN) { szDN = m_sDN; }
  PCWSTR GetDNString() { return m_sDN; }
	void SetFilter(LPCWSTR lpszFilter) { m_sFilter = lpszFilter; }
	void GetFilter(CString& sFilter) { sFilter = m_sFilter; }
	void SetRootPath(LPCWSTR lpszRootPath);
	void GetRootPath(CString& sRootPath) { sRootPath = m_sRootPath; }
	void SetScope(ADS_SCOPEENUM scope) { m_scope = scope; }
	ADS_SCOPEENUM GetScope() { return m_scope; }

	void GetDisplayPath(CString& sDisplayPath);
	void GetDisplayName(CString& sDisplayName);

private :
	CString m_sName;
	CString m_sDN;
	CString m_sFilter;
	CString m_sRootPath;
	ADS_SCOPEENUM m_scope;
};

//////////////////////////////////////////////////////////////////////////////////
// CADSIEditQueryNode :

class CADSIEditQueryNode : public CADSIEditContainerNode
{
public:
	// enumeration for node states, to handle icon changes
	typedef enum
	{
		notLoaded = 0, // initial state, valid only if server never contacted
		loading,
		loaded,
		unableToLoad,
		accessDenied
	} nodeStateType;


public:
	CADSIEditQueryNode() : m_pQueryData(NULL)
	{
		// NOTICE-2002/02/27-artm  Under low memory environment CString can
		// throw out of memory exceptions.  ADSI edit prefers to shutdown over
		// trying to handle the exception (since no other components depend on
		// the tool).
		m_sType.LoadString(IDS_QUERY_STRING);
	}

	CADSIEditQueryNode(CADsObject* pADsObject, CADSIEditQueryData* pQueryData);

	~CADSIEditQueryNode()
	{
	}

	// node info
	DECLARE_NODE_GUID()

	virtual BOOL OnAddMenuItem(LPCONTEXTMENUITEM2 pContextMenuItem,
							               long *pInsertionAllowed);

	virtual HRESULT OnCommand(long nCommandID, 
                            DATA_OBJECT_TYPES type, 
                            CComponentDataObject* pComponentData,
                            CNodeList* pNodeList);
	virtual BOOL OnSetDeleteVerbState(DATA_OBJECT_TYPES type, 
                                    BOOL* pbHide, 
                                    CNodeList* pNodeList);
	virtual void OnDelete(CComponentDataObject* pComponentData,
                        CNodeList* pNodeList);
	virtual CQueryObj* OnCreateQuery();
	virtual LPCWSTR GetString(int nCol);

	void OnSettings(CComponentDataObject* pComponentData);
	void OnRemove(CComponentDataObject* pComponentData);

	virtual BOOL HasPropertyPages(DATA_OBJECT_TYPES type, 
                                BOOL* pbHideVerb, 
                                CNodeList* pNodeList);
	virtual int GetImageIndex(BOOL bOpenImage);

	virtual BOOL OnSetRefreshVerbState(DATA_OBJECT_TYPES type, 
                                     BOOL* pbHide, 
                                     CNodeList* pNodeList);


	virtual LPCONTEXTMENUITEM2 OnGetContextMenuItemTable() 
		{ return CADSIEditQueryMenuHolder::GetContextMenuItem(); }

	virtual CBackgroundThread* CreateThreadObject() 
	{ 
		return new CADSIEditBackgroundThread(); // override if need derived type of object
	} 

	virtual BOOL CanCloseSheets();
	virtual void OnChangeState(CComponentDataObject* pComponentDataObject);
	virtual void OnHaveData(CObjBase* pObj, CComponentDataObject* pComponentDataObject);
  virtual void OnError(DWORD dwErr);

  void SetQueryData(CADSIEditQueryData* pQueryData) { m_pQueryData = pQueryData; }
  CADSIEditQueryData* GetQueryData() { return m_pQueryData; }

  //
  // Allow multiple selection
  //
  virtual HRESULT GetResultViewType(LPOLESTR* ppViewType, long* pViewOptions)
  {
	  *pViewOptions = MMC_VIEW_OPTIONS_MULTISELECT;
	  *ppViewType = NULL;
    return S_FALSE;
  }

private:
	CADSIEditQueryData* m_pQueryData;
	CString m_sType;
};


#endif _QUERYNODE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\queryui.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       queryui.h
//
//--------------------------------------------------------------------------

//////////////////////////////////////////////////////////////////////////////
// queryui.h

#ifndef _QUERYUI_H
#define _QUERYUI_H

#include "editor.h"

/////////////////////////////////////////////////////////////////////////////
// CADSIEditConnectPropertyPage

class CADSIEditQueryDialog : public CDialog
{

// Construction
public:
  CADSIEditQueryDialog(CString& szServer,
                       CString& sName, 
								CString& sFilter, 
								CString& sPath, 
								CString& sConnectPath,
								BOOL bOneLevel,
								CCredentialObject* pCredObject);
  CADSIEditQueryDialog(CString& szServer, CString& sConnectPath, CCredentialObject* pCredObject);
	~CADSIEditQueryDialog();

	void GetResults(CString& sName, CString& sFilter, CString& sPath, BOOL* pbOneLevel);

protected:

	virtual BOOL OnInitDialog();
	void OnEditQueryString();
	void OnEditNameString();
	void OnOneLevel();
	void OnSubtree();
	void OnBrowse();
	void OnEditQuery();

	void GetDisplayPath(CString& sDisplay);

	DECLARE_MESSAGE_MAP()

private:
	CString m_sName;
	CString m_sFilter;
	CString m_sRootPath;
	CString m_sConnectPath;
   CString m_szServer;
	BOOL m_bOneLevel;

	CCredentialObject* m_pCredObject;
};


#endif _QUERYUI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\renameui.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       renameui.h
//
//--------------------------------------------------------------------------

//////////////////////////////////////////////////////////////////////////////
// renameui.h

#ifndef _RENAMEUI_H
#define _RENAMEUI_H

#include "editor.h"

/////////////////////////////////////////////////////////////////////////////
// CADSIEditConnectPropertyPage

class CADSIEditRenameDialog : public CDialog
{

// Construction
public:
  CADSIEditRenameDialog(CTreeNode* pCurrentNode, 
                        CADsObject* pADsObject, 
                        CString sCurrentPath,
                        LPWSTR lpszNewName);
	~CADSIEditRenameDialog();

protected:

	virtual BOOL OnInitDialog();
	virtual void OnOK();
	HRESULT EscapePath(CString& sEscapedName, const CString& sName);
	void CrackPath(const CString& szPath, CString& sDN);

	CString m_sPrefix;
	CString m_sPostfix;

	CADsObject* m_pADsObject;
	CString m_sCurrentPath;
  CString m_sNewName;
	CTreeNode* m_pCurrentNode;
	
	DECLARE_MESSAGE_MAP()
};


#endif _RENAMEUI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\schemacache.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       schemacache.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"

#include "schemacache.h"


//+--------------------------------------------------------------------------
//
//  Member:     CADSIEditSchemaCache::Lookup
//
//  Synopsis:   Gets the cache item identified by the given class name
//
//  Arguments:  [pszClass - IN]  : the name of the class to retrieve the
//                                 cache information for
//              [refpItem - OUT] : reference to a pointer that will receive
//                                 the cached item
//
//  Returns:    bool : true if the cache contained the item
//
//  History:    27-Nov-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
CADSIEditClassCacheItemBase* CADSIEditSchemaCache::FindClassCacheItem(CCredentialObject* pCredObject,
                                                                      PCWSTR pszClass,
                                                                      PCWSTR pszSchemaPath)
{
  _Lock();
  CADSIEditClassCacheItemBase* pCacheSchemaItem = 0;

  do // false while
  {
    BOOL bFound = m_Map.Lookup(pszClass, pCacheSchemaItem);
    if (!bFound)
    {
      TRACE(_T("Cache miss: %s\n"), pszClass);

	    HRESULT hr = S_OK;
      CComPtr<IADsClass> spClass;

	    hr = OpenObjectWithCredentials(pCredObject,
											               pszSchemaPath,
											               IID_IADsClass, 
											               (void**)&spClass);
	    if ( FAILED(hr) )
	    {
        TRACE(_T("Bind failed in IsContainer() because hr=0x%x\n"), hr);
		    break;
	    }

      short bContainer = 0;
	    hr = spClass->get_Container( &bContainer );
      if (FAILED(hr))
      {
        TRACE(_T("IADsClass::get_Container() failed. hr=0x%x\n"), hr);
      }

      pCacheSchemaItem = new CADSIEditClassCacheItemBase(pszClass, bContainer ? true : false);
      if (pCacheSchemaItem)
      {
        //
        // set in the cache
        //
        m_Map.SetAt(pszClass, pCacheSchemaItem);
      }
      else
      {
        ASSERT(pCacheSchemaItem);
        break;
      }
    }
  } while (false);

  _Unlock();
  return pCacheSchemaItem;
}

//+--------------------------------------------------------------------------
//
//  Member:     CADSIEditSchemaCache::Lookup
//
//  Synopsis:   Gets the cache item identified by the given class name
//
//  Arguments:  [pszClass - IN]  : the name of the class to retrieve the
//                                 cache information for
//              [refpItem - OUT] : reference to a pointer that will receive
//                                 the cached item
//
//  Returns:    bool : true if the cache contained the item
//
//  History:    27-Nov-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
BOOL CADSIEditSchemaCache::Lookup(PCWSTR pszClass, CADSIEditClassCacheItemBase*& refpItem)
{
  _Lock();
  BOOL b = m_Map.Lookup(pszClass, refpItem);
  _Unlock();
  return b;
}

//+--------------------------------------------------------------------------
//
//  Member:     CADSIEditSchemaCache::Initialize
//
//  Synopsis:   Initializes the critical section and cleans out the cache
//
//  Arguments:  
//
//  Returns:    HRESULT : S_OK if initialization succeeded
//
//  History:    27-Nov-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT CADSIEditSchemaCache::Initialize() 
{ 
  HRESULT hr = S_OK;

  ExceptionPropagatingInitializeCriticalSection(&m_cs);

  _Lock();
  _Cleanup();
  _Unlock();

  return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CADSIEditSchemaCache::Destroy
//
//  Synopsis:   Cleans out the cache and deletes the critical section
//
//  Arguments:  
//
//  Returns:    HRESULT : S_OK if everything was deleted successfully
//
//  History:    27-Nov-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
HRESULT CADSIEditSchemaCache::Destroy()
{
  HRESULT hr = S_OK;

  _Lock();
  _Cleanup();
  _Unlock();

  //
  // REVIEW_JEFFJON : need to add exception handling here
  //
  ::DeleteCriticalSection(&m_cs);

  return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CADSIEditSchemaCache::Clear
//
//  Synopsis:   Cleans out the cache
//
//  Arguments:  
//
//  Returns:    
//
//  History:    27-Nov-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
void CADSIEditSchemaCache::Clear()
{
  _Lock();
  _Cleanup();
  _Unlock();
}

//+--------------------------------------------------------------------------
//
//  Member:     CADSIEditSchemaCache::_Cleanup
//
//  Synopsis:   Removes all entries from the map and deletes them
//
//  Arguments:  
//
//  Returns:    
//
//  History:    27-Nov-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
void CADSIEditSchemaCache::_Cleanup()
{
  CString Key;
  CADSIEditClassCacheItemBase* pCacheItem = NULL;
  POSITION pos = m_Map.GetStartPosition();
  while (!m_Map.IsEmpty()) 
  {
    m_Map.GetNextAssoc (pos, Key, pCacheItem);
    m_Map.RemoveKey (Key);
    delete pCacheItem;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by adsiedit.rc
//
#define IDS_SNAPIN_NAME                 11
#define IDS_SNAPINABOUT_DESCRIPTION     12
#define IDS_MOVE_TITLE                  34
#define IDS_HEADER_NCNAME               99
#define IDS_HEADER_NAME                 100
#define IDS_HEADER_TYPE                 101
#define IDB_16x16                       102
#define IDS_HEADER_DN                   102
#define IDS_PROP_CONTAINER_TITLE        103
#define IDB_32x32                       104
#define IDS_CONNECT_TO                  104
#define IDI_ADSIEDIT_SNAPIN             105
#define IDS_REMOVE_CONNECTION           105
#define IDS_VIEW                        106
#define IDD_CREATE_CLASS_PAGE           107
#define IDD_CONNECTION_DIALOG           108
#define IDS_MOVE                        108
#define IDD_CONNECTION_ADVANCED         110
#define IDS_SETTINGS_CONNECTION         110
#define IDD_PROPERTY_PAGE               111
#define IDS_FILTER                      111
#define IDD_CREATE_EMPTY_PAGE           112
#define IDS_NEW_OBJECT                  112
#define IDD_CREATE_LAST_PAGE            113
#define IDD_RENAME_PAGE                 114
#define IDS_NOT_SET                     114
#define IDS_MY_CONNECTION               115
#define IDS_DOMAIN_NC                   116
#define IDS_SCHEMA                      117
#define IDS_CONFIG_CONTAINER            118
#define IDD_FILTER_DIALOG               119
#define IDS_ROOTDSE                     119
#define IDS_REMOVE_QUERY                120
#define IDD_EDIT_FILTER_DIALOG          121
#define IDS_SETTINGS_QUERY              121
#define IDD_CREDENTIAL_DIALOG           122
#define IDS_NEW_QUERY                   122
#define IDS_QUERY_STRING                123
#define IDS_UPDATE_SCHEMA               124
#define IDS_NEW_CONNECT_FROM_HERE       125
#define IDS_NEW_CONNECT_TO_NC_FROM_HERE 126
#define IDD_QUERY_DIALOG                127
#define IDB_ABOUT_16x16                 129
#define IDB_ABOUT_32x32                 130
#define IDS_MOVE_TARGET                 249
#define IDS_MANDATORY                   250
#define IDS_OPTIONAL                    251
#define IDS_BOTH                        252
#define IDS_BUTTON_TEXT_ADD             253
#define IDS_BUTTON_TEXT_SET             254
#define IDS_BUTTON_TEXT_REMOVE          255
#define IDS_BUTTON_TEXT_CLEAR           256
#define IDS_MESSAGE_VIEW_NO_CONNECTIONS_TITLE 500
#define IDS_MESSAGE_VIEW_NO_CONNECTIONS_MESSAGE 501
#define IDS_SYNTAX_DN                   600
#define IDS_SYNTAX_OID                  601
#define IDS_SYNTAX_NOCASE_STR           602
#define IDS_SYNTAX_PRCS_STR             603
#define IDS_SYNTAX_I5_STR               604
#define IDS_SYNTAX_NUMSTR               605
#define IDS_SYNTAX_DN_BINARY            606
#define IDS_SYNTAX_BOOLEAN              607
#define IDS_SYNTAX_INTEGER              608
#define IDS_SYNTAX_OCTET                609
#define IDS_SYNTAX_UTC                  610
#define IDS_SYNTAX_UNICODE              611
#define IDS_SYNTAX_ADDRESS              612
#define IDS_SYNTAX_DNSTRING             613
#define IDS_SYNTAX_SEC_DESC             614
#define IDS_SYNTAX_LINT                 615
#define IDS_SYNTAX_SID                  616
#define IDS_SYNTAX_UNKNOWN              617
#define IDS_MSG_DELETE_OBJECTS          618
#define IDC_FULLPATH_BOX                1017
#define IDC_DN_RADIO                    1018
#define IDC_NC_RADIO                    1019
#define IDC_DN_BOX                      1020
#define IDC_NC_BOX                      1021
#define IDC_DOMAIN_SERVER_RADIO         1022
#define IDC_DEFAULT_RADIO               1024
#define IDC_DOMAIN_SERVER_BOX           1025
#define IDC_CONNECTION_NAME             1027
#define IDC_ADVANCED_BUTTON             1028
#define IDC_USERNAME                    1029
#define IDC_PASSWORD                    1030
#define IDC_CREDENTIALS                 1031
#define IDC_CREDENTIALS_CHECK           1031
#define IDC_PORT                        1032
#define IDC_LDAP_RADIO                  1033
#define IDC_GC_RADIO                    1034
#define IDC_PROPTYPES_BOX               1037
#define IDC_PROP_BOX                    1038
#define IDC_EDITVALUE_BOX               1039
#define IDC_VALUE_LISTBOX               1040
#define IDC_VALUE_EDITBOX               1041
#define IDC_ADD_BUTTON                  1042
#define IDC_REMOVE_BUTTON               1043
#define IDC_PATH_BOX                    1046
#define IDC_SYNTAX_BOX                  1047
#define IDC_CLASS_LIST                  1048
#define IDC_ATTR_BOX                    1049
#define IDC_ATTR_VALUE_BOX              1050
#define IDC_NUMBER_VALUE_BOX            1052
#define IDC_NEW_NAME_BOX                1056
#define IDC_CREDENTIALS_GROUP           1057
#define IDC_CREDENTIALS_USER            1058
#define IDC_CREDENTIALS_PASSWORD        1059
#define IDC_CLASS_BOX                   1062
#define IDC_SHOWALL_RADIO               1063
#define IDC_FILTER_RADIO                1064
#define IDC_FILTER_BOX                  1065
#define IDC_MAX_NUMBER_BOX              1066
#define IDC_EDIT_BUTTON                 1072
#define IDC_CONTAINER_LIST              1085
#define IDC_CONNECTION_STATIC           1088
#define IDC_NO_INFO                     1090
#define IDC_PATH_LABEL                  1091
#define IDC_CLASS_LABEL                 1092
#define IDC_FILTER_LABEL                1093
#define IDC_PROPERTY_LABEL              1094
#define IDC_ATTR_GROUP                  1095
#define IDC_SYNTAX_LABEL                1096
#define IDC_EDIT_LABEL                  1097
#define IDC_VALUE_LABEL                 1098
#define IDC_EDIT_QUERY_STRING           1099
#define IDC_RADIO_ONELEVEL              1101
#define IDC_RADIO_SUBTREE               1102
#define IDC_EDIT_QUERY_NAME             1103
#define IDC_EDIT_ROOT_PATH              1105
#define IDC_BUTTON_BROWSE_CONTAINER     1106
#define IDC_BUTTON_EDIT_QUERY           1107
#define IDC_BUTTON_MORE                 1108
#define IDS_PROJNAME                    5000
#define IDD_ATTRIBUTE_EDITOR_DIALOG     5001
#define IDS_NOTSET                      5001
#define IDC_MANDATORY_CHECK             5002
#define IDD_STRING_EDITOR_DIALOG        5002
#define IDS_NO_EDITOR                   5002
#define IDC_OPTIONAL_CHECK              5003
#define IDD_STRING_EDITOR_MULTI_DIALOG  5003
#define IDS_NO_ATTRIBUTE_INFO           5003
#define IDC_SET_CHECK                   5004
#define IDC_ATTRIBUTE_LIST              5006
#define IDC_VALUE_EDIT                  5008
#define IDC_VALUE_LIST                  5010
#define IDC_CLEAR_BUTTON                5014
#define IDD_INT_EDITOR_DIALOG           5020
#define IDD_LARGEINT_EDITOR_DIALOG      5021
#define IDD_BOOLEAN_EDITOR_DIALOG       5022
#define IDD_TIME_EDITOR_DIALOG          5023
#define IDD_OCTET_STRING_EDITOR_DIALOG  5024
#define IDC_ATTRIBUTE_STATIC            6000
#define IDS_ATTR_COL_ATTRIBUTE          6000
#define IDS_ATTR_COL_SETNOTSET          6001
#define IDC_TRUE_RADIO                  6002
#define IDS_ATTR_COL_VALUE              6002
#define IDC_FALSE_RADIO                 6003
#define IDS_ATTR_SET                    6003
#define IDC_NOTSET_RADIO                6004
#define IDS_ATTR_NOTSET                 6004
#define IDC_DATE_PICKER                 6005
#define IDC_TIME_PICKER                 6006
#define IDC_EDIT2                       6008
#define IDC_VIEW_TYPE_COMBO             6010
#define IDS_HEXADECIMAL                 6050
#define IDS_DECIMAL                     6051
#define IDS_BINARY                      6052
#define IDS_WCHAR                       6053
#define IDS_CHAR                        6054
#define IDS_OCTAL                       6055
#define IDS_MSG_RECORD_CLOSE_SHEET      42981
#define IDS_MSG_QUERY_TOO_MANY_ITEMS    42982
#define IDS_MSG_INCORRECT_FORMAT        42983
#define IDS_MSG_CONNECTION_NAME         42984
#define IDS_MSG_ROOTDSE_ERROR           42985
#define IDS_MSG_DELETE_OBJECT           42986
#define IDS_MSG_DELETE_CONTAINER        42987
#define IDS_MSG_FAIL_TO_LOAD            42988
#define IDS_MSG_NOT_X500_PATH           42989
#define IDS_MSG_REMOVE_CONNECTION       42990
#define IDS_MSG_INCORRECT_FORMAT_OCTET  42991
#define IDS_MSG_INCORRECT_FORMAT_BOOLEAN 42994
#define IDS_MSG_INCORRECT_FORMAT_TIME   42995
#define IDS_MSG_REMOVE_QUERY            42996
#define IDS_MSG_EXISTING_QUERIES        42997
#define IDS_SCHEMA_UPDATE_SUCCESSFUL    42998
#define IDS_QUERY_BROWSE_TITLE          42999
#define IDS_MSG_RECORD_SHEET_LOCKED     43001
#define IDS_ERRMSG_FAILED_CONNECTION    43002

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        131
#define _APS_NEXT_COMMAND_VALUE         40002
#define _APS_NEXT_CONTROL_VALUE         1109
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\snapbase.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       snapbase.cpp
//
//--------------------------------------------------------------------------


// SNAPBASE.CPP
#include "pch.h"
#include <snapbase.h>

#ifdef DEBUG_ALLOCATOR
	#ifdef _DEBUG
	#define new DEBUG_NEW
	#undef THIS_FILE
	static char THIS_FILE[] = __FILE__;
	#endif
#endif

#include <dbg_.cpp>

#include <stdabou_.cpp>

#include <compbas_.cpp>
#include <proppag_.cpp>
#include <dataobj_.cpp>
#include <treedat_.cpp>

#include <aclpag_.cpp>

//////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\renameui.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       renameui.cpp
//
//--------------------------------------------------------------------------

#include "pch.h"
#include <SnapBase.h>

#include "resource.h"
#include "renameui.h"
#include "editor.h"
#include "connection.h"

#ifdef DEBUG_ALLOCATOR
	#ifdef _DEBUG
	#define new DEBUG_NEW
	#undef THIS_FILE
	static char THIS_FILE[] = __FILE__;
	#endif
#endif

BEGIN_MESSAGE_MAP(CADSIEditRenameDialog, CDialog)
	//{{AFX_MSG_MAP(CADsObjectDialog)
//	ON_CBN_EDITCHANGE(IDC_NEW_NAME_BOX, OnEditChangeName)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CADSIEditRenameDialog::CADSIEditRenameDialog(CTreeNode* pCurrentNode, 
                                             CADsObject* pADsObject,
																						 CString sPath,
                                             LPWSTR lpszNewName) 
				: CDialog(IDD_RENAME_PAGE)
{
	m_pCurrentNode = pCurrentNode;
	m_pADsObject = pADsObject;
	m_sCurrentPath = sPath;
  m_sNewName = lpszNewName;
}

CADSIEditRenameDialog::~CADSIEditRenameDialog()
{
}


BOOL CADSIEditRenameDialog::OnInitDialog()
{
	CDialog::OnInitDialog();

	CEdit* pNameBox = (CEdit*)GetDlgItem(IDC_NEW_NAME_BOX);
  pNameBox->SetWindowText(m_sNewName);
	
	return TRUE;
}


void CADSIEditRenameDialog::OnOK()
{
	CEdit* pNameBox = (CEdit*)GetDlgItem(IDC_NEW_NAME_BOX);

	CString sOldPath, sNewPath;
	sOldPath = m_sCurrentPath;

	CString sNewName, sFullName;
	pNameBox->GetWindowText(sNewName);
	sFullName = m_sPrefix + sNewName;

	CComPtr<IADsContainer> pDestination;
	CADSIEditContainerNode* pContNode = dynamic_cast<CADSIEditContainerNode*>(m_pCurrentNode->GetContainer());
	ASSERT(pContNode != NULL);

	// Get the username and password from the connection node
	//
	CADSIEditConnectionNode* pConnectionNode = pContNode->GetADsObject()->GetConnectionNode();
	CConnectionData* pConnectData = pConnectionNode->GetConnectionData();

	HRESULT hr, hCredResult;
	CComPtr<IADs> pParentIADs;
	hr = OpenObjectWithCredentials(
											 pConnectData,
											 pConnectData->GetCredentialObject()->UseCredentials(),
											 m_sCurrentPath,
											 IID_IADs, 
											 (LPVOID*) &pParentIADs,
											 GetSafeHwnd(),
											 hCredResult
											 );
	if (FAILED(hr))
	{
		if (SUCCEEDED(hCredResult))
		{
			ADSIEditErrorMessage(hr);
		}
		return;
	}

	CComBSTR bstrParentPath;
	hr = pParentIADs->get_Parent(&bstrParentPath);
	if (FAILED(hr))
	{
		ADSIEditErrorMessage(hr);
		return;
	}

	CString sContPath(bstrParentPath);
	hr = OpenObjectWithCredentials(
											 pConnectData, 
											 pConnectData->GetCredentialObject()->UseCredentials(),
											 sContPath,
											 IID_IADsContainer, 
											 (LPVOID*) &pDestination,
											 GetSafeHwnd(),
											 hCredResult
											 );
	if (FAILED(hr)) 
	{
		if (SUCCEEDED(hCredResult))
		{
			ADSIEditErrorMessage(hr);
		}
		return;
	}

	CString sEscapedName;
	hr = EscapePath(sEscapedName, sFullName);

	if (FAILED(hr))
	{
		ADSIEditErrorMessage(hr);
		return;
	}


	IDispatch* pObject;
	hr = pDestination->MoveHere(CComBSTR(sOldPath),
                                CComBSTR(sEscapedName),
                                &pObject);
  if (FAILED(hr)) 
	{
		ADSIEditErrorMessage(hr);
		return;
	}

	CComPtr<IADs> pIADs;
	hr = pObject->QueryInterface(IID_IADs, (LPVOID*)&pIADs);
	if (FAILED(hr))
	{
		ADSIEditErrorMessage(hr);
		return;
	}

	CComBSTR bstrPath;
	hr = pIADs->get_ADsPath(&bstrPath);
	if (FAILED(hr))
	{
		ADSIEditErrorMessage(hr);
		return;
	}

	CString szDN, szPath;
	szPath = bstrPath;
	CrackPath(szPath, szDN);
	m_pADsObject->SetPath(bstrPath);
	m_pADsObject->SetName(sFullName + m_sPostfix);
	m_pADsObject->SetDN(szDN);

	m_pCurrentNode->SetDisplayName(sFullName);

	CDialog::OnOK();
	return;
}

HRESULT CADSIEditRenameDialog::EscapePath(CString& sEscapedName, const CString& sName)
{
	CComPtr<IADsPathname> pIADsPathname;
   HRESULT hr = ::CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                                  IID_IADsPathname, (PVOID *)&(pIADsPathname));
   ASSERT((S_OK == hr) && ((pIADsPathname) != NULL));

	CComBSTR bstrEscaped;
	hr = pIADsPathname->GetEscapedElement(0, //reserved
														(BSTR)(LPCWSTR)sName,
														&bstrEscaped);
	sEscapedName = bstrEscaped;
	return hr;
}

void CADSIEditRenameDialog::CrackPath(const CString& szPath, CString& sDN)
{
	CComPtr<IADsPathname> pIADsPathname;
   HRESULT hr = ::CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                                  IID_IADsPathname, (PVOID *)&(pIADsPathname));
   ASSERT((S_OK == hr) && ((pIADsPathname) != NULL));

	hr = pIADsPathname->Set(CComBSTR(szPath), ADS_SETTYPE_FULL);
	if (FAILED(hr)) 
	{
		TRACE(_T("Set failed. %s"), hr);
	}

	// Get the leaf DN
	CComBSTR bstrDN;
	hr = pIADsPathname->Retrieve(ADS_FORMAT_X500_DN, &bstrDN);
	if (FAILED(hr))
	{
		TRACE(_T("Failed to get element. %s"), hr);
		sDN = L"";
	}
	else
	{
		sDN = bstrDN;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\snapdata.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       snapdata.cpp
//
//--------------------------------------------------------------------------


#include "pch.h"
#include <SnapBase.h>

#include "resource.h"
#include "adsiedit.h"
#include "editor.h"
#include "connection.h"
#include "connectionui.h"
#include "snapdata.h"


#ifdef DEBUG_ALLOCATOR
	#ifdef _DEBUG
	#define new DEBUG_NEW
	#undef THIS_FILE
	static char THIS_FILE[] = __FILE__;
	#endif
#endif

BEGIN_MENU(CADSIEditRootMenuHolder)
	BEGIN_CTX
		CTX_ENTRY_TOP(IDM_CONNECT_TO, L"_ADSIEDIT_CONNECTTO")
	END_CTX
	BEGIN_RES
		RES_ENTRY(IDS_CONNECT_TO)
	END_RES
END_MENU


BEGIN_MENU(CADSIEditConnectMenuHolder)
	BEGIN_CTX
	   CTX_ENTRY_VIEW(IDM_FILTER, L"_ADSIEDIT_FILTER")
		CTX_ENTRY_TOP(IDM_SETTINGS_CONNECTION, L"_ADSIEDIT_SETTINGS")
		CTX_ENTRY_TOP(IDM_REMOVE_CONNECTION, L"_ADSIEDIT_REMOVE")
    CTX_ENTRY_TOP(IDM_UPDATE_SCHEMA, L"_ADSIEDIT_UPDATE")
		CTX_ENTRY_NEW(IDM_NEW_QUERY, L"_ADSIEDIT_NEWQUERY")
	END_CTX
	BEGIN_RES
		RES_ENTRY(IDS_FILTER)
		RES_ENTRY(IDS_SETTINGS_CONNECTION)
		RES_ENTRY(IDS_REMOVE_CONNECTION)
    RES_ENTRY(IDS_UPDATE_SCHEMA)
		RES_ENTRY(IDS_NEW_QUERY)
	END_RES
END_MENU

BEGIN_MENU(CADSIEditContainerMenuHolder)
	BEGIN_CTX
		CTX_ENTRY_NEW(IDM_NEW_OBJECT, L"_ADSIEDIT_NEWOBJECT")
		CTX_ENTRY_TOP(IDM_MOVE, L"_ADSIEDIT_MOVE")
    CTX_ENTRY_TOP(IDM_NEW_CONNECT_FROM_HERE, L"_ADSIEDIT_CONNECTFROMHERE")
	END_CTX
	BEGIN_RES
		RES_ENTRY(IDS_NEW_OBJECT)
		RES_ENTRY(IDS_MOVE)
    RES_ENTRY(IDS_NEW_CONNECT_FROM_HERE)
	END_RES
END_MENU

BEGIN_MENU(CADSIEditLeafMenuHolder)
	BEGIN_CTX
		CTX_ENTRY_TOP(IDM_MOVE, L"_ADSIEDIT_MOVE")
    CTX_ENTRY_TOP(IDM_NEW_NC_CONNECT_FROM_HERE, L"_ADSIEDIT_CONNECTTONCFROMHERE")
	END_CTX
	BEGIN_RES
		RES_ENTRY(IDS_MOVE)
    RES_ENTRY(IDS_NEW_CONNECT_TO_NC_FROM_HERE)
	END_RES
END_MENU

BEGIN_MENU(CADSIEditQueryMenuHolder)
	BEGIN_CTX
		CTX_ENTRY_TOP(IDM_SETTINGS_QUERY, L"_ADSIEDIT_QUERYSETTINGS")
		CTX_ENTRY_TOP(IDM_REMOVE_QUERY, L"_ADSIEDIT_REMOVE")
	END_CTX
	BEGIN_RES
		RES_ENTRY(IDS_SETTINGS_QUERY)
		RES_ENTRY(IDS_REMOVE_QUERY)
	END_RES
END_MENU
	
//////////////////////////////////////////////////////////////////////
// CADSIEditRootData

// {D4F3374F-052F-11d2-97B0-00A0C9A06D2D}
const GUID CADSIEditRootData::NodeTypeGUID = 
{ 0xd4f3374f, 0x52f, 0x11d2, { 0x97, 0xb0, 0x0, 0xa0, 0xc9, 0xa0, 0x6d, 0x2d } };


CADSIEditRootData::CADSIEditRootData(CComponentDataObject* pComponentData) 
      : CRootData(pComponentData) 
{
  m_szDescriptionText = L"";
}

CADSIEditRootData::~CADSIEditRootData()
{
	TRACE(_T("~CADSIEditRootData(), name <%s>\n"),GetDisplayName());
}

HRESULT CADSIEditRootData::LoadMRUs(IStream* pStm)
{
	HRESULT hr = LoadStringListFromStream(pStm, m_sDNMRU);
	if (FAILED(hr))
	{
		return hr;
	}
	hr = LoadStringListFromStream(pStm, m_sServerMRU);
	return hr;
}

HRESULT CADSIEditRootData::SaveMRUs(IStream* pStm)
{
	HRESULT hr = SaveStringListToStream(pStm, m_sDNMRU);
	if (FAILED(hr))
	{
		return hr;
	}
	hr = SaveStringListToStream(pStm, m_sServerMRU);
	return hr;
}

BOOL CADSIEditRootData::FindNode(LPCWSTR lpszPath, CList<CTreeNode*, CTreeNode*>& nodeList)
{
	BOOL bFound = FALSE;
	POSITION pos;
	for (pos = m_containerChildList.GetHeadPosition(); pos != NULL; )
	{
		CTreeNode* pNode = m_containerChildList.GetNext(pos);
		CADSIEditConnectionNode* pConnectNode = dynamic_cast<CADSIEditConnectionNode*>(pNode);
		ASSERT(pConnectNode != NULL);

		CTreeNode* pFoundNode;
		BOOL bTemp;
		bTemp = pConnectNode->FindNode(lpszPath, nodeList);
		if (!bFound)
		{
			bFound = bTemp;
		}
	}
	return bFound;
}

BOOL CADSIEditRootData::OnAddMenuItem(LPCONTEXTMENUITEM2 pContextMenuItem, 
                                      long *pInsertionAllowed)
{
  //
  // Single selection
  //
  if (pContextMenuItem->lCommandID == IDM_CONNECT_TO)
  {
    return TRUE;
  }
	return FALSE;
}

BOOL CADSIEditRootData::OnSetRefreshVerbState(DATA_OBJECT_TYPES type, 
                                              BOOL* pbHide,
                                              CNodeList* pNodeList)
{
	*pbHide = FALSE;
	return !IsThreadLocked();
}


HRESULT CADSIEditRootData::OnCommand(long nCommandID, 
                                     DATA_OBJECT_TYPES type, 
								                     CComponentDataObject* pComponentData,
                                     CNodeList* pNodeList)
{
  if (pNodeList->GetCount() == 1) // single selection
  {
	  switch (nCommandID)
	  {
		  case IDM_CONNECT_TO :
			  OnConnectTo(pComponentData);
			  break;
		  default:
			  ASSERT(FALSE); // Unknown command!
			  return E_FAIL;
	  }
  }
  else if (pNodeList->GetCount() > 1) // multiple selection
  {
    switch (nCommandID)
    {
      case IDM_REMOVE_CONNECTION :
        {
          POSITION pos = pNodeList->GetHeadPosition();
          while (pos != NULL)
          {
            CTreeNode* pNode = pNodeList->GetNext(pos);
            ASSERT(pNode != NULL);

            CADSIEditConnectionNode* pConnectionNode = dynamic_cast<CADSIEditConnectionNode*>(pNode);
            ASSERT(pConnectionNode != NULL);

            pConnectionNode->OnRemove(pComponentData);
          }
          break;
        }
      default :
        ASSERT(FALSE);
        return E_FAIL;
    }
  }

  return S_OK;
}

void CADSIEditRootData::OnConnectTo(CComponentDataObject* pComponentData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
   CThemeContextActivator activator;

   CString s, sPath;
	BSTR bstrPath;
	CConnectionData* pConnectData = NULL;

	CADSIEditConnectDialog pConnectDialog(NULL,
																				this,
																				pComponentData, 
																				pConnectData);
	pConnectDialog.DoModal();

  //Change the result pane if this is the first child being added
  pComponentData->UpdateResultPaneView(this);
}


HRESULT CADSIEditRootData::GetResultViewType(LPOLESTR* ppViewType, long* pViewOptions)
{
  HRESULT hr = S_FALSE;

  if (m_containerChildList.IsEmpty() && m_leafChildList.IsEmpty())
  {
    *pViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS;

    LPOLESTR psz = NULL;
    StringFromCLSID(CLSID_MessageView, &psz);

    USES_CONVERSION;

    if (psz != NULL)
    {
        *ppViewType = psz;
        hr = S_OK;
    }
  }
  else
  {
	  *pViewOptions = MMC_VIEW_OPTIONS_MULTISELECT;
	  *ppViewType = NULL;
    hr = S_FALSE;
  }
  return hr;
}

HRESULT CADSIEditRootData::OnShow(LPCONSOLE lpConsole)
{
  CComPtr<IUnknown> spUnknown;
  CComPtr<IMessageView> spMessageView;

  HRESULT hr = lpConsole->QueryResultView(&spUnknown);
  if (FAILED(hr))
    return S_OK;

  hr = spUnknown->QueryInterface(IID_IMessageView, (PVOID*)&spMessageView);
  if (SUCCEEDED(hr))
  {
    CString szTitle, szMessage;
    IconIdentifier iconID;

    VERIFY(szTitle.LoadString(IDS_MESSAGE_VIEW_NO_CONNECTIONS_TITLE));
    VERIFY(szMessage.LoadString(IDS_MESSAGE_VIEW_NO_CONNECTIONS_MESSAGE));
    iconID = Icon_Information;

    spMessageView->SetTitleText(szTitle);
    spMessageView->SetBodyText(szMessage);
    spMessageView->SetIcon(iconID);
  }
  return S_OK;
}


#define ADSIEDIT_STREAM_VERSION (12)

// IStream manipulation helpers overrides
HRESULT CADSIEditRootData::Load(IStream* pStm)
{
  //
	// assume never get multiple loads
  //
	if(!m_containerChildList.IsEmpty() || !m_leafChildList.IsEmpty())
		return E_FAIL;

	WCHAR szBuffer[256]; // REVIEW_MARCOC: hardcoded
	ULONG nLen; // WCHAR counting NULL

	UINT nCount;
	ULONG cbRead;
	// read the version ##
	DWORD dwVersion;
	VERIFY(SUCCEEDED(pStm->Read((void*)&dwVersion,sizeof(DWORD), &cbRead)));
	ASSERT(cbRead == sizeof(DWORD));
	if (dwVersion != ADSIEDIT_STREAM_VERSION)
		return E_FAIL;

	HRESULT hr = LoadMRUs(pStm);
	if (FAILED(hr))
	{
		return hr;
	}

	// load the list of connections
	VERIFY(SUCCEEDED(pStm->Read((void*)&nCount,sizeof(UINT), &cbRead)));
	ASSERT(cbRead == sizeof(UINT));

	CComponentDataObject* pComponentData = GetComponentDataObject();
	for (int k=0; k< (int)nCount; k++)
	{
		CADSIEditConnectionNode* p = NULL;
		VERIFY(SUCCEEDED(CADSIEditConnectionNode::CreateFromStream(pStm, &p)));
		ASSERT(p != NULL);
		VERIFY(AddChildToList(p));
	}
	if (nCount > 0)
		MarkEnumerated();
	ASSERT(m_containerChildList.GetCount() == (int)nCount);

  return S_OK;
}

HRESULT CADSIEditRootData::Save(IStream* pStm, BOOL fClearDirty)
{
	UINT nCount;
	ULONG cbWrite;
	// write the version ##
	DWORD dwVersion = ADSIEDIT_STREAM_VERSION;
	VERIFY(SUCCEEDED(pStm->Write((void*)&dwVersion, sizeof(DWORD),&cbWrite)));
	ASSERT(cbWrite == sizeof(DWORD));

	HRESULT hr = SaveMRUs(pStm);
	if (FAILED(hr))
	{
		return hr;
	}

	// write # of servers 
	nCount = (UINT)m_containerChildList.GetCount();
	VERIFY(SUCCEEDED(pStm->Write((void*)&nCount, sizeof(UINT),&cbWrite)));
	ASSERT(cbWrite == sizeof(UINT));

	// loop through the list of connections and serialize them
	POSITION pos;
	for (pos = m_containerChildList.GetHeadPosition(); pos != NULL; )
	{
		CADSIEditConnectionNode* pConnectNode = dynamic_cast<CADSIEditConnectionNode*>(m_containerChildList.GetNext(pos));
		ASSERT(pConnectNode != NULL);
		VERIFY(SUCCEEDED(pConnectNode->SaveToStream(pStm)));
	}

	if (fClearDirty)
		SetDirtyFlag(FALSE);
	return S_OK;
}


HRESULT CADSIEditRootData::IsDirty()
{
  return CRootData::IsDirty();
}



BOOL CADSIEditRootData::CanCloseSheets()
{
  //
  // We can't do this with the new property page since it is not derived
  // from the base class in MTFRMWK.
  //
	//return (IDCANCEL != ADSIEditMessageBox(IDS_MSG_RECORD_CLOSE_SHEET, MB_OKCANCEL));

  ADSIEditMessageBox(IDS_MSG_RECORD_SHEET_LOCKED, MB_OK);
  return FALSE;
}

BOOL CADSIEditRootData::OnRefresh(CComponentDataObject* pComponentData,
                                  CNodeList* pNodeList)
{
  BOOL bRet = TRUE;
  if (pNodeList->GetCount() > 1) //multiple selection
  {
    POSITION pos = pNodeList->GetHeadPosition();
    while (pos != NULL)
    {
      CTreeNode* pNode = pNodeList->GetNext(pos);
      ASSERT(pNode != NULL);

      CNodeList nodeList;
      nodeList.AddTail(pNode);
      if (!pNode->OnRefresh(pComponentData, &nodeList))
      {
        bRet = FALSE;
      }
    }
  }
  else if (pNodeList->GetCount() == 1) // single selection
  {
	  if (IsSheetLocked())
	  {
		  if (!CanCloseSheets())
			  return FALSE;
		  pComponentData->GetPropertyPageHolderTable()->DeleteSheetsOfNode(this);
	  }
	  ASSERT(!IsSheetLocked());

	  POSITION pos;
	  for (pos = m_containerChildList.GetHeadPosition(); pos != NULL; )
	  {
		  CTreeNode* pNode = m_containerChildList.GetNext(pos);
		  CADSIEditConnectionNode* pConnectNode = dynamic_cast<CADSIEditConnectionNode*>(pNode);
		  ASSERT(pConnectNode != NULL);

      CNodeList nodeList;
      nodeList.AddTail(pNode);
		  pConnectNode->OnRefresh(pComponentData, &nodeList);
	  }
    bRet = TRUE;
  }
	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\schemacache.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       schemacache.h
//
//--------------------------------------------------------------------------

#ifndef _SCHEMA_CACHE_H_
#define _SCHEMA_CACHE_H_

#include <SnapBase.h>
#include "adsiedit.h"
#include "editor.h"

//+--------------------------------------------------------------------------
//
//  Class:      CADSIEditClassCacheItemBase
//
//  Purpose:    Object for storing and retrieving schema class information
//
//  History:    27-Nov-2000 JeffJon  Created
//
//---------------------------------------------------------------------------

class CADSIEditClassCacheItemBase
{
public:
  CADSIEditClassCacheItemBase(PCWSTR pszClass,
                              bool bIsContainer)
    : m_bIsContainer(bIsContainer),
      m_szClass(pszClass)
  {}

  ~CADSIEditClassCacheItemBase() {}

  bool    IsContainer() { return m_bIsContainer; }
  PCWSTR  GetClass() { return m_szClass; } 

private:
  bool    m_bIsContainer;
  CString m_szClass;
};

//+--------------------------------------------------------------------------
//
//  Class:      CADSIEditSchemaCache
//
//  Purpose:    Object for caching the schema information keyed by the
//              objectClass
//
//  History:    27-Nov-2000 JeffJon  Created
//
//---------------------------------------------------------------------------

typedef CMap <CString, PCWSTR, CADSIEditClassCacheItemBase*, CADSIEditClassCacheItemBase*> CADSIEditSchemaCacheMap;

class CADSIEditSchemaCache
{
public:
  CADSIEditSchemaCache()  {}
  ~CADSIEditSchemaCache() {}

  CADSIEditClassCacheItemBase* FindClassCacheItem(CCredentialObject* pCredObject,
                                                  PCWSTR pszClass,
                                                  PCWSTR pszSchemaPath);
  BOOL    Lookup(PCWSTR pszClass, CADSIEditClassCacheItemBase*& refpItem);
  HRESULT Initialize();
  HRESULT Destroy();
  void    Clear();

private:
  void _Cleanup();
  void _Lock()   { ::EnterCriticalSection(&m_cs);}
  void _Unlock() { ::LeaveCriticalSection(&m_cs);}

  CRITICAL_SECTION        m_cs;
  CADSIEditSchemaCacheMap m_Map;
};

#endif // _SCHEMA_CACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\about.h ===
//	About.h

#ifndef __ABOUT_H_INCLUDED__
#define __ABOUT_H_INCLUDED__


//	About for "Certificate Templates" snapin
class CCertTemplatesAbout :
	public CSnapinAbout,
	public CComCoClass<CCertTemplatesAbout, &CLSID_CertTemplatesAbout>

{
public:
DECLARE_REGISTRY(CCertTemplatesAbout, _T("CERTTMPL.CertTemplatesAboutObject.1"), _T("CERTTMPL.CertTemplatesAboutObject.1"), IDS_CERTTMPL_DESC, THREADFLAGS_BOTH)
	CCertTemplatesAbout();
};

// version information

#include <ntverp.h>
#define IDS_SNAPINABOUT_VERSION VER_PRODUCTVERSION_STR
#define IDS_SNAPINABOUT_PROVIDER VER_COMPANYNAME_STR

#endif // ~__ABOUT_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\about.cpp ===
/////////////////////////////////////////////////////////////////////
//	About.cpp
//
//	Provide constructor for the CSnapinAbout implementation.
//
/////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "about.h"

#include "stdabout.cpp" 

/////////////////////////////////////////////////////////////////////
CCertTemplatesAbout::CCertTemplatesAbout()
{
	m_szProvider = IDS_SNAPINABOUT_PROVIDER;
	m_szVersion = IDS_SNAPINABOUT_VERSION;
	m_uIdStrDestription = IDS_SNAPINABOUT_DESCRIPTION;
	m_uIdIconImage = IDI_CERT_TEMPLATEV2;
	m_uIdBitmapSmallImage = IDB_CERTTMPL_SMALL;
	m_uIdBitmapSmallImageOpen = IDB_CERTTMPL_SMALL;
	m_uIdBitmapLargeImage = IDB_CERTTMPL_LARGE;
	m_crImageMask = RGB(255, 0, 255);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\adsiedit\snapdata.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       snapdata.h
//
//--------------------------------------------------------------------------


#ifndef _SNAPDATA_H
#define _SNAPDATA_H

#include "adsiedit.h"
#include "common.h"

enum
{
	//Root node verbs
	IDM_CONNECT_TO,
	IDM_SETTINGS_CONNECTION,
	IDM_REMOVE_CONNECTION,
  IDM_UPDATE_SCHEMA,
	IDM_FILTER,

	//Container node verbs
	IDM_RENAME,
	IDM_MOVE,
	IDM_NEW_OBJECT,
	IDM_NEW_QUERY,
  IDM_NEW_CONNECT_FROM_HERE,
  IDM_NEW_NC_CONNECT_FROM_HERE,

	//Query node verbs
	IDM_REMOVE_QUERY,
	IDM_SETTINGS_QUERY
};

DECLARE_MENU(CADSIEditRootMenuHolder)
DECLARE_MENU(CADSIEditConnectMenuHolder)
DECLARE_MENU(CADSIEditContainerMenuHolder)
DECLARE_MENU(CADSIEditLeafMenuHolder)
DECLARE_MENU(CADSIEditQueryMenuHolder)

//  # of items per folder: must be >=0  and <= 0xFFFFFFFF (DWORD) to serialize
#define ADSIEDIT_QUERY_OBJ_COUNT_DEFAULT 10000   // default value
#define ADSIEDIT_QUERY_OBJ_COUNT_MIN 10          // min value
#define ADSIEDIT_QUERY_OBJ_COUNT_MAX 0xFFFFFFFF  // max value
#define ADSIEDIT_QUERY_OBJ_TEXT_COUNT_MAX 9      // max # of bytes in text

///////////////////////////////////////////////////////////////////
// CADSIEditRootData



class CADSIEditRootData : public CRootData
{
public:

	CADSIEditRootData(CComponentDataObject* pComponentData);
	virtual ~CADSIEditRootData();

	// node info
	DECLARE_NODE_GUID()

	virtual HRESULT OnCommand(long nCommandID, 
                            DATA_OBJECT_TYPES type, 
                            CComponentDataObject* pComponentData,
                            CNodeList* pNodeList);
	virtual void OnDelete(CComponentDataObject* pComponentData,
                        CNodeList* pNodeList) { ASSERT(FALSE);}
	virtual BOOL OnRefresh(CComponentDataObject* pComponentData,
                         CNodeList* pNodeList);
	virtual BOOL OnSetRefreshVerbState(DATA_OBJECT_TYPES type, 
                                     BOOL* pbHide, 
                                     CNodeList* pNodeList);

  virtual HRESULT GetResultViewType(LPOLESTR* ppViewType, long* pViewOptions);
  virtual HRESULT OnShow(LPCONSOLE lpConsole);
  
  virtual int GetImageIndex(BOOL bOpenImage) { return ROOT_IMAGE;}

	void OnConnectTo(CComponentDataObject* pComponentData);

	// IStream manipulation helpers overrides
  virtual HRESULT IsDirty();
	virtual HRESULT Load(IStream* pStm);
	virtual HRESULT Save(IStream* pStm, BOOL fClearDirty);

	// Accessors for the Connect to... MRUs
	void GetDNMRU(CStringList* psDNList) { CopyStringList(psDNList, &m_sDNMRU); }
	void SetDNMRU(CStringList* psDNList) { CopyStringList(&m_sDNMRU, psDNList); }
	void GetServerMRU(CStringList* psServerList) { CopyStringList(psServerList, &m_sServerMRU); }
	void SetServerMRU(CStringList* psServerList) { CopyStringList(&m_sServerMRU, psServerList); }
	HRESULT LoadMRUs(IStream* pStm);
	HRESULT SaveMRUs(IStream* pStm);

	BOOL FindNode(LPCWSTR lpszPath, CList<CTreeNode*, CTreeNode*>& foundNodeList);

  CColumnSet* GetColumnSet() { return ((CADSIEditComponentDataObject*)GetComponentDataObject())->GetColumnSet(); }
  LPCWSTR GetColumnID() { return ((CADSIEditComponentDataObject*)GetComponentDataObject())->GetColumnSet()->GetColumnID(); }

  virtual LPWSTR GetDescriptionBarText()
  {
    LPWSTR lpszFormat = L"%d Connection(s)";
    int iCount = m_containerChildList.GetCount() + m_leafChildList.GetCount();

    m_szDescriptionText.Format(lpszFormat, iCount);
    return (LPWSTR)(LPCWSTR)m_szDescriptionText;
  }

protected:
	virtual BOOL CanCloseSheets();
	virtual BOOL OnAddMenuItem(LPCONTEXTMENUITEM2 pContextMenuItem,
								             long *pInsertionAllowed);
	virtual LPCONTEXTMENUITEM2 OnGetContextMenuItemTable() 
				{ return CADSIEditRootMenuHolder::GetContextMenuItem(); }

private:
	CStringList m_sDNMRU;
	CStringList m_sServerMRU;
  CString m_szDescriptionText;
};

#endif // _SNAPDATA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\addapprovaldlg.cpp ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2002.
//
//  File:       AddApprovalDlg.cpp
//
//  Contents:   Implementation of CAddApprovalDlg
//
//----------------------------------------------------------------------------
// AddApprovalDlg.cpp : implementation file
//

#include "stdafx.h"
#include "certtmpl.h"
#include "AddApprovalDlg.h"
#include "PolicyOID.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern POLICY_OID_LIST	    g_policyOIDList;

/////////////////////////////////////////////////////////////////////////////
// CAddApprovalDlg dialog

CAddApprovalDlg::CAddApprovalDlg(CWnd* pParent, const PSTR* paszUsedApprovals)
	: CHelpDialog(CAddApprovalDlg::IDD, pParent),
    m_paszReturnedApprovals (0),
    m_paszUsedApprovals (paszUsedApprovals)
{
	//{{AFX_DATA_INIT(CAddApprovalDlg)
	//}}AFX_DATA_INIT
}

CAddApprovalDlg::~CAddApprovalDlg()
{
    if ( m_paszReturnedApprovals )
    {
        for (int nIndex = 0; m_paszReturnedApprovals[nIndex]; nIndex++)
            delete [] m_paszReturnedApprovals[nIndex];
        delete [] m_paszReturnedApprovals;
    }
}

void CAddApprovalDlg::DoDataExchange(CDataExchange* pDX)
{
	CHelpDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddApprovalDlg)
	DDX_Control(pDX, IDC_APPROVAL_LIST, m_issuanceList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddApprovalDlg, CHelpDialog)
	//{{AFX_MSG_MAP(CAddApprovalDlg)
	ON_LBN_SELCHANGE(IDC_APPROVAL_LIST, OnSelchangeApprovalList)
	ON_LBN_DBLCLK(IDC_APPROVAL_LIST, OnDblclkApprovalList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddApprovalDlg message handlers


BOOL CAddApprovalDlg::OnInitDialog() 
{
	CHelpDialog::OnInitDialog();
	
    for (POSITION nextPos = g_policyOIDList.GetHeadPosition (); nextPos; )
    {
        CPolicyOID* pPolicyOID = g_policyOIDList.GetNext (nextPos);
        if ( pPolicyOID )
        {
            // If this is the Application OID dialog, show only application 
            // OIDS, otherwise if this is the Issuance OID dialog, show only
            // issuance OIDs
            if ( pPolicyOID->IsIssuanceOID () )
            {
                bool bFound = false;

                // Don't display an approval that's already been used
                if ( m_paszUsedApprovals )
                {
                    for (int nIndex = 0; m_paszUsedApprovals[nIndex]; nIndex++)
                    {
                        if ( !strcmp (pPolicyOID->GetOIDA (), m_paszUsedApprovals[nIndex]) )
                        {
                            bFound = true;
                            break;
                        }
                    }
                }

                if ( !bFound )
                {
                    int nIndex = m_issuanceList.AddString (pPolicyOID->GetDisplayName ());
                    if ( nIndex >= 0 )
                    {
                        // security review 2/21/2002 BryanWal ok
                        LPSTR   pszOID = new char[strlen (pPolicyOID->GetOIDA ())+1];
                        if ( pszOID )
                        {
                            strcpy (pszOID, pPolicyOID->GetOIDA ());
                            m_issuanceList.SetItemDataPtr (nIndex, pszOID);
                        }
                        else
                            break;
                    }
                }
            }
        }
    }

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CAddApprovalDlg::EnableControls()
{
    GetDlgItem (IDOK)->EnableWindow (m_issuanceList.GetSelCount () > 0);
}

void CAddApprovalDlg::OnOK() 
{
    int     nSelectedCnt = m_issuanceList.GetSelCount ();

	
    // allocate an array of PSTR pointers and set each item to an approval.
    // Set the last to NULL
    if ( nSelectedCnt )
    {
        int* pnSelItems = new int[nSelectedCnt];
        if ( pnSelItems )
        {
            if ( LB_ERR != m_issuanceList.GetSelItems (nSelectedCnt, pnSelItems) )
            {
                m_paszReturnedApprovals = new PSTR[nSelectedCnt+1];
                if ( m_paszReturnedApprovals )
                {
                    // security review 2/21/2002 BryanWal ok
                    ::ZeroMemory (m_paszReturnedApprovals, sizeof (PSTR) * (nSelectedCnt+1));
	                for (int nIndex = 0; nIndex < nSelectedCnt; nIndex++)
	                {
                        PSTR pszPolicyOID = (PSTR) m_issuanceList.GetItemData (pnSelItems[nIndex]);
                        if ( pszPolicyOID )
                        {
                            // security review 2/21/2002 BryanWal ok
                            PSTR pNewStr = new char[strlen (pszPolicyOID) + 1];
                            if ( pNewStr )
                            {
                                // security review 2/21/2002 BryanWal ok
                                strcpy (pNewStr, pszPolicyOID);
                                m_paszReturnedApprovals[nIndex] = pNewStr;
                            }
                            else
                                break;
                        }
                    }
                }
            }
            delete [] pnSelItems;
        }
    }

    CHelpDialog::OnOK();
}

bool CAddApprovalDlg::ApprovalAlreadyUsed(PCSTR pszOID) const
{
    bool    bResult = false;

    if ( m_paszUsedApprovals )
    {
        for (int nIndex = 0; m_paszUsedApprovals[nIndex]; nIndex++)
        {
            if ( !strcmp (m_paszUsedApprovals[nIndex], pszOID) )
            {
                bResult = true;
                break;
            }
        }
    }

    return bResult;
}

void CAddApprovalDlg::DoContextHelp (HWND hWndControl)
{
	_TRACE(1, L"Entering CAddApprovalDlg::DoContextHelp\n");
    
	switch (::GetDlgCtrlID (hWndControl))
	{
	case IDC_STATIC:
		break;

	default:
		// Display context help for a control
		if ( !::WinHelp (
				hWndControl,
				GetContextHelpFile (),
				HELP_WM_HELP,
				(DWORD_PTR) g_aHelpIDs_IDD_ADD_APPROVAL) )
		{
			_TRACE(0, L"WinHelp () failed: 0x%x\n", GetLastError ());        
		}
		break;
	}
    _TRACE(-1, L"Leaving CAddApprovalDlg::DoContextHelp\n");
}

void CAddApprovalDlg::OnSelchangeApprovalList() 
{
	EnableControls ();
}

void CAddApprovalDlg::OnDblclkApprovalList() 
{
    OnOK ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\basicconstraintsdlg.cpp ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2002.
//
//  File:       BasicConstraintsDlg.cpp
//
//  Contents:   Implementation of CBasicConstraintsDlg
//
//----------------------------------------------------------------------------
// BasicConstraintsDlg.cpp : implementation file
//

#include "stdafx.h"
#include "BasicConstraintsDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBasicConstraintsDlg property page


CBasicConstraintsDlg::CBasicConstraintsDlg(CWnd* pParent, 
        CCertTemplate& rCertTemplate, 
        PCERT_EXTENSION pCertExtension) 
    : CHelpDialog(CBasicConstraintsDlg::IDD, pParent),
    m_rCertTemplate (rCertTemplate),
    m_pCertExtension (pCertExtension),
    m_bModified (false),
    m_pBCInfo (0),
    m_cbInfo (0)
{
	//{{AFX_DATA_INIT(CBasicConstraintsDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
    m_rCertTemplate.AddRef ();
}

CBasicConstraintsDlg::~CBasicConstraintsDlg()
{
    if ( m_pBCInfo )
        LocalFree (m_pBCInfo);
    m_rCertTemplate.Release ();
}

void CBasicConstraintsDlg::DoDataExchange(CDataExchange* pDX)
{
	CHelpDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CBasicConstraintsDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CBasicConstraintsDlg, CHelpDialog)
	//{{AFX_MSG_MAP(CBasicConstraintsDlg)
	ON_WM_CANCELMODE()
	ON_BN_CLICKED(IDC_BASIC_CONSTRAINTS_CRITICAL, OnBasicConstraintsCritical)
	ON_BN_CLICKED(IDC_ONLY_ISSUE_END_ENTITIES, OnOnlyIssueEndEntities)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CBasicConstraintsDlg message handlers

BOOL CBasicConstraintsDlg::OnInitDialog() 
{
    _TRACE (1, L"Entering CBasicConstraintsDlg::OnInitDialog\n");
	CHelpDialog::OnInitDialog();
	
    if ( m_pCertExtension->fCritical )
        SendDlgItemMessage (IDC_BASIC_CONSTRAINTS_CRITICAL, BM_SETCHECK, BST_CHECKED);
	
    if ( 1 == m_rCertTemplate.GetType () )
    {
        GetDlgItem (IDC_BASIC_CONSTRAINTS_CRITICAL)->EnableWindow (FALSE);
        GetDlgItem (IDC_ONLY_ISSUE_END_ENTITIES)->EnableWindow (FALSE);
    }

     

    if ( CryptDecodeObject (
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            szOID_BASIC_CONSTRAINTS2, 
            m_pCertExtension->Value.pbData,
            m_pCertExtension->Value.cbData,
            0,
            0,
            &m_cbInfo) )
    {
        m_pBCInfo = (PCERT_BASIC_CONSTRAINTS2_INFO) ::LocalAlloc (
                LPTR, m_cbInfo);
        if ( m_pBCInfo )
        {
            if ( CryptDecodeObject (
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                szOID_BASIC_CONSTRAINTS2, 
                m_pCertExtension->Value.pbData,
                m_pCertExtension->Value.cbData,
                0,
                m_pBCInfo,
                &m_cbInfo) )
            {
                if ( m_pBCInfo->fPathLenConstraint )
                    SendDlgItemMessage (IDC_ONLY_ISSUE_END_ENTITIES, BM_SETCHECK, BST_CHECKED);
            }
            else
            {
                _TRACE (0, L"CryptDecodeObjectEx (szOID_BASIC_CONSTRAINTS2) failed: 0x%x\n", GetLastError ());
            }
        }
    }
    else
    {
        DWORD   dwErr = GetLastError ();
        CString text;
        CString caption;
        CThemeContextActivator activator;

        VERIFY (caption.LoadString (IDS_CERTTMPL));
        // security review 2/21/2002 BryanWal ok
        text.FormatMessage (IDS_CANNOT_READ_BASIC_CONSTRAINTS, GetSystemMessage (dwErr));
        MessageBox (text, caption, MB_ICONWARNING);

        _TRACE (0, L"CryptDecodeObjectEx (szOID_BASIC_CONSTRAINTS2) failed: 0x%x\n", dwErr);
    }
    EnableControls ();

    _TRACE (-1, L"Leaving CBasicConstraintsDlg::OnInitDialog\n");
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CBasicConstraintsDlg::OnBasicConstraintsCritical() 
{
    m_pCertExtension->fCritical = BST_CHECKED == SendDlgItemMessage (IDC_BASIC_CONSTRAINTS_CRITICAL, BM_GETCHECK);
    m_bModified = true;
    EnableControls ();
}

void CBasicConstraintsDlg::EnableControls()
{
    if ( 1 == m_rCertTemplate.GetType () )
    {
        GetDlgItem (IDOK)->EnableWindow (FALSE);
        GetDlgItem (IDC_BASIC_CONSTRAINTS_CRITICAL)->EnableWindow (FALSE);
        GetDlgItem (IDC_ONLY_ISSUE_END_ENTITIES)->EnableWindow (FALSE);
    }
    else
    {
        GetDlgItem (IDOK)->EnableWindow (m_bModified && !m_rCertTemplate.ReadOnly ());
        GetDlgItem (IDC_BASIC_CONSTRAINTS_CRITICAL)->EnableWindow (!m_rCertTemplate.ReadOnly ());
        GetDlgItem (IDC_ONLY_ISSUE_END_ENTITIES)->EnableWindow (!m_rCertTemplate.ReadOnly ());
    }
}

void CBasicConstraintsDlg::OnOnlyIssueEndEntities() 
{
    m_bModified = true;
    EnableControls ();
}

void CBasicConstraintsDlg::DoContextHelp (HWND hWndControl)
{
	_TRACE(1, L"Entering CBasicConstraintsDlg::DoContextHelp\n");
    
	switch (::GetDlgCtrlID (hWndControl))
	{
	case IDC_STATIC:
		break;

	default:
		// Display context help for a control
		if ( !::WinHelp (
				hWndControl,
				GetContextHelpFile (),
				HELP_WM_HELP,
				(DWORD_PTR) g_aHelpIDs_IDD_BASIC_CONSTRAINTS) )
		{
			_TRACE(0, L"WinHelp () failed: 0x%x\n", GetLastError ());        
		}
		break;
	}
    _TRACE(-1, L"Leaving CBasicConstraintsDlg::DoContextHelp\n");
}

void CBasicConstraintsDlg::OnOK() 
{
    if ( m_pBCInfo )
    {
        if ( BST_CHECKED == SendDlgItemMessage (IDC_ONLY_ISSUE_END_ENTITIES, BM_GETCHECK) )
        {
            m_pBCInfo->dwPathLenConstraint = 0;
            m_pBCInfo->fPathLenConstraint = TRUE;
        }
        else
        {
            m_pBCInfo->dwPathLenConstraint = (DWORD) -1;
            m_pBCInfo->fPathLenConstraint = FALSE;
        }

        bool    bCritical = BST_CHECKED == SendDlgItemMessage (
                    IDC_BASIC_CONSTRAINTS_CRITICAL, BM_GETCHECK);
        HRESULT hr = m_rCertTemplate.SetBasicConstraints (m_pBCInfo, bCritical);
        if ( FAILED (hr) )
            return;
    }
    else
        return;

	CHelpDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\basicconstraintsdlg.h ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       BasicConstraintsDlg.h
//
//  Contents:   Implementation of CBasicConstraintsDlg
//
//----------------------------------------------------------------------------
#if !defined(AFX_BASICCONSTRAINTSDLG_H__DE830A13_21AB_489A_B899_57560400C11B__INCLUDED_)
#define AFX_BASICCONSTRAINTSDLG_H__DE830A13_21AB_489A_B899_57560400C11B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// BasicConstraintsDlg.h : header file
//
#include "CertTemplate.h"

/////////////////////////////////////////////////////////////////////////////
// CBasicConstraintsDlg dialog

class CBasicConstraintsDlg : public CHelpDialog
{
// Construction
public:
	void EnableControls();
	CBasicConstraintsDlg(CWnd* pParent, 
            CCertTemplate& rCertTemplate, 
            PCERT_EXTENSION pCertExtension);
	~CBasicConstraintsDlg();

// Dialog Data
	//{{AFX_DATA(CBasicConstraintsDlg)
	enum { IDD = IDD_BASIC_CONSTRAINTS };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CBasicConstraintsDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual void DoContextHelp (HWND hWndControl);
	// Generated message map functions
	//{{AFX_MSG(CBasicConstraintsDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnBasicConstraintsCritical();
	afx_msg void OnOnlyIssueEndEntities();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	bool                            m_bModified;
    CCertTemplate&                  m_rCertTemplate;
    PCERT_EXTENSION                 m_pCertExtension;
    PCERT_BASIC_CONSTRAINTS2_INFO   m_pBCInfo;   
    DWORD                           m_cbInfo;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_BASICCONSTRAINTSDLG_H__DE830A13_21AB_489A_B899_57560400C11B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\addapprovaldlg.h ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       AddApprovalDlg.h
//
//  Contents:   Definition of CAddApprovalDlg
//
//----------------------------------------------------------------------------
#if !defined(AFX_ADDAPPROVALDLG_H__1BB4F754_0009_4237_A82A_B533CB46C543__INCLUDED_)
#define AFX_ADDAPPROVALDLG_H__1BB4F754_0009_4237_A82A_B533CB46C543__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// AddApprovalDlg.h : header file
//


/////////////////////////////////////////////////////////////////////////////
// CAddApprovalDlg dialog

class CAddApprovalDlg : public CHelpDialog
{
// Construction
public:
	virtual  ~CAddApprovalDlg();
	PSTR* m_paszReturnedApprovals;
    void EnableControls ();
	CAddApprovalDlg(CWnd* pParent, const PSTR* paszUsedApprovals);


// Dialog Data
	//{{AFX_DATA(CAddApprovalDlg)
	enum { IDD = IDD_ADD_APPROVAL };
	CListBox	m_issuanceList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddApprovalDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual void DoContextHelp (HWND hWndControl);
	bool ApprovalAlreadyUsed (PCSTR pszOID) const;

	// Generated message map functions
	//{{AFX_MSG(CAddApprovalDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnSelchangeApprovalList();
	afx_msg void OnDblclkApprovalList();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
    const PSTR*     m_paszUsedApprovals;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADDAPPROVALDLG_H__1BB4F754_0009_4237_A82A_B533CB46C543__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\certtemplate.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2002.
//
//  File:       CertTemplate.cpp
//
//  Contents:   CCertTemplate
//
//----------------------------------------------------------------------------
/// CertTemplate.cpp: implementation of the CCertTemplate class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CertTemplate.h"

#define _SECOND ((ULONGLONG) 10000000)
#define _MINUTE (60 * _SECOND)
#define _HOUR   (60 * _MINUTE)
#define _DAY    (24 * _HOUR)

CERT_EXTENSION  g_EKUCertExtension = {szOID_ENHANCED_KEY_USAGE, 0, {0, 0}};
CERT_EXTENSION  g_certPolCertExtension = {szOID_CERT_POLICIES, 0, {0, 0}};

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
CCertTemplate::CCertTemplate(
        PCWSTR pszObjectName, 
        PCWSTR pszTemplateName, 
        const CString& szLDAPPath, 
        bool fIsReadOnly,
        const bool fUseCache) :
    CCertTmplCookie (CERTTMPL_CERT_TEMPLATE, pszObjectName),
    m_strTemplateName (pszTemplateName),
    m_hCertType (0),
    m_dwVersion (0),
    m_dwEnrollmentFlags (0),
    m_dwSubjectNameFlags (0),
    m_dwPrivateKeyFlags (0),
    m_dwGeneralFlags (0),
    m_dwKeySpec (0),
    m_bIsClone (false),
    m_bCanBeDeletedOnCancel (false),
    m_bGoodForAutoenrollmentFlagPendingSave (false),
    m_szLDAPPath (szLDAPPath),
    m_fIsReadOnly (fIsReadOnly),
    m_nOriginalValidityDays (-1),
    m_nNewValidityDays (-1),
    m_nOriginalRenewalDays (-1),
    m_nNewRenewalDays (-1),
    m_pCertExtensions (0),
    m_fUseCache (fUseCache),
    m_bIssuancePoliciesRequired (false),
    m_fFailedToSetSecurity (false)
{
//    _TRACE (1, L"Entering CCertTemplate::CCertTemplate\n");

    m_strOriginalTemplateName = pszTemplateName;

    Initialize ();
//    _TRACE (-1, L"Leaving CCertTemplate::CCertTemplate\n");
}

CCertTemplate::CCertTemplate(
        const CCertTemplate &rTemplate, 
        bool bIsClone, 
        bool fIsReadOnly, 
        const bool fUseCache)
 : CCertTmplCookie (CERTTMPL_CERT_TEMPLATE),
    m_hCertType (0),
    m_dwVersion (0),
    m_dwEnrollmentFlags (0),
    m_dwSubjectNameFlags (0),
    m_dwPrivateKeyFlags (0),
    m_dwGeneralFlags (0),
    m_dwKeySpec (0),
    m_bIsClone (bIsClone),
    m_bCanBeDeletedOnCancel (true),
    m_bGoodForAutoenrollmentFlagPendingSave (false),
    m_fIsReadOnly (fIsReadOnly),
    m_szLDAPPath (rTemplate.GetLDAPPath ()),
    m_nOriginalValidityDays (-1),
    m_nNewValidityDays (-1),
    m_nOriginalRenewalDays (-1),
    m_nNewRenewalDays (-1),
    m_pCertExtensions (0),
    m_fUseCache (fUseCache),
    m_bIssuancePoliciesRequired (false),
    m_fFailedToSetSecurity (false)
{
//    _TRACE (1, L"Entering CCertTemplate::CCertTemplate (copy constructor)\n");
//    _TRACE (-1, L"Leaving CCertTemplate::CCertTemplate (copy constructor)\n");
}

CCertTemplate::~CCertTemplate()
{
//    _TRACE (1, L"Entering CCertTemplate::~CCertTemplate - m_hCertType = 0x%x\n", m_hCertType);
    if ( m_hCertType )
    {
        FreeCertExtensions ();

        HRESULT hr = CACloseCertType (m_hCertType);
        _ASSERT (SUCCEEDED (hr));
        if ( !SUCCEEDED (hr) )
        {
            _TRACE (0, L"CACloseCertType (%s) failed: 0x%x\n", hr);
        }
    }
//    _TRACE (-1, L"Leaving CCertTemplate::~CCertTemplate\n");
}

HRESULT CCertTemplate::Initialize()
{
//    _TRACE (1, L"Entering CCertTemplate::Initialize - m_hCertType = 0x%x\n", m_hCertType);
    HRESULT hr = S_OK;
    
    
    if ( !m_hCertType )
    {
        DWORD dwFlags = CT_ENUM_MACHINE_TYPES | CT_ENUM_USER_TYPES;

        if ( !m_fUseCache )
        {
            dwFlags |= CT_FLAG_NO_CACHE_LOOKUP;
        }

        hr = CAFindCertTypeByName (m_strTemplateName,
                NULL,
                dwFlags,
                &m_hCertType);
        _ASSERT (SUCCEEDED (hr));
    }
    if ( SUCCEEDED (hr) )
    {
        hr = CAGetCertTypePropertyEx (m_hCertType,
                CERTTYPE_PROP_SCHEMA_VERSION,
                &m_dwVersion);
        if ( FAILED (hr) )
        {
            _TRACE (0, L"CAGetCertTypePropertyEx (CERTTYPE_PROP_SCHEMA_VERSION) failed: 0x%x\n", hr);
        }

        // Get enrollment flags
        if ( SUCCEEDED (hr) )
        {
            hr = CAGetCertTypeFlagsEx (m_hCertType, CERTTYPE_ENROLLMENT_FLAG, 
                    &m_dwEnrollmentFlags);
            if ( FAILED (hr) )
            {
                _TRACE (0, L"CAGetCertTypeFlagsEx (CERTTYPE_ENROLLMENT_FLAG) failed: 0x%x\n", hr);
            }
        }

        // Get subject name flags
        if ( SUCCEEDED (hr) )
        {
            hr = CAGetCertTypeFlagsEx (m_hCertType, CERTTYPE_SUBJECT_NAME_FLAG, 
                    &m_dwSubjectNameFlags);
            if ( FAILED (hr) )
            {
                _TRACE (0, L"CAGetCertTypeFlagsEx (CERTTYPE_SUBJECT_NAME_FLAG) failed: 0x%x\n", hr);
            }
        }

        // Get private key flags
        if ( SUCCEEDED (hr) )
        {
            hr = CAGetCertTypeFlagsEx (m_hCertType, CERTTYPE_PRIVATE_KEY_FLAG, 
                    &m_dwPrivateKeyFlags);
            if ( FAILED (hr) )
            {
                _TRACE (0, L"CAGetCertTypeFlagsEx (CERTTYPE_PRIVATE_KEY_FLAG) failed: 0x%x\n", hr);
            }
        }

        // Get general flags
        if ( SUCCEEDED (hr) )
        {
            hr = CAGetCertTypeFlagsEx (m_hCertType, CERTTYPE_GENERAL_FLAG, 
                    &m_dwGeneralFlags);
            if ( FAILED (hr) )
            {
                _TRACE (0, L"CAGetCertTypeFlagsEx (CERTTYPE_GENERAL_FLAG) failed: 0x%x\n", hr);
            }
        }

        if ( SUCCEEDED (hr) )
        {
            hr = CAGetCertTypeKeySpec (m_hCertType, &m_dwKeySpec);
            if ( FAILED (hr) )
            {
                _TRACE (0, L"CAGetCertTypeKeySpec () failed: 0x%x\n", hr);
            }
        }
    }
    else
    {
        _TRACE (0, L"CAFindCertTypeByName (%s) failed: 0x%x\n", (PCWSTR) m_strTemplateName, hr);
    }

//    _TRACE (-1, L"Leaving CCertTemplate::Initialize: 0x%x\n", hr);
    return hr;
}

DWORD CCertTemplate::GetType() const
{
    return m_dwVersion;
}

CString CCertTemplate::GetDisplayName ()
{
//    _TRACE (1, L"Entering CCertTemplate::GetDisplayName - m_hCertType = 0x%x\n", m_hCertType);
    HRESULT hr = S_OK;
    if ( m_szDisplayName.IsEmpty () )
    {
        if ( m_hCertType )
        {
            PWSTR* rgwszProp = 0;

            hr = CAGetCertTypePropertyEx (m_hCertType, 
                CERTTYPE_PROP_FRIENDLY_NAME, &rgwszProp);
            if ( SUCCEEDED (hr) && rgwszProp )
            {
                m_szDisplayName = *rgwszProp;
                CAFreeCertTypeProperty (m_hCertType, rgwszProp);
            }
            else
            {
                _TRACE (0, L"CAGetCertTypePropertyEx (CERTTYPE_PROP_FRIENDLY_NAME) failed: 0x%x\n", hr);
                m_szDisplayName = GetObjectName ();
            }
        }
        else
            m_szDisplayName = GetObjectName ();
    }

//    _TRACE (-1, L"Leaving CCertTemplate::GetDisplayName: %s, 0x%x\n", (PCWSTR) m_szDisplayName, hr);
   return m_szDisplayName;
}

CString CCertTemplate::GetTemplateName() const
{
    return m_strTemplateName;
}

bool CCertTemplate::SubjectIsCA() const
{
    return (m_dwGeneralFlags & CT_FLAG_IS_CA) ? true : false;
}

bool CCertTemplate::SubjectIsCrossCA() const
{
    return (m_dwGeneralFlags & CT_FLAG_IS_CROSS_CA) ? true : false;
}

bool CCertTemplate::IsMachineType() const
{
    return (m_dwGeneralFlags & CT_FLAG_MACHINE_TYPE) ? true : false;
}

bool CCertTemplate::PublishToDS() const
{
    return (m_dwEnrollmentFlags & CT_FLAG_PUBLISH_TO_DS) ? true : false;
}

DWORD CCertTemplate::GetCertExtensionCount()
{
    DWORD               dwCnt = 0;
    PCERT_EXTENSIONS    pCertExtensions = 0;
    
    HRESULT hr = CAGetCertTypeExtensions (m_hCertType, &pCertExtensions);
    if ( SUCCEEDED (hr) )
    {
        if ( pCertExtensions )
        {
            dwCnt = pCertExtensions->cExtension;
            CAFreeCertTypeExtensions (m_hCertType, pCertExtensions);
        }
    }
    else
    {
        _TRACE (0, L"CAGetCertTypeExtensions () failed: 0x%x\n", hr);
    }

    return dwCnt;
}

///////////////////////////////////////////////////////////////////////////////
//
//  Method: GetCertExtension
//
//  Note: The pointer returned through ppCertExtension must not be freed.  The
//          caller must call FreeCertExtensions () when done with it.
///////////////////////////////////////////////////////////////////////////////
HRESULT CCertTemplate::GetCertExtension (PSTR pszOID, PCERT_EXTENSION* ppCertExtension)
{
    HRESULT hr = S_OK;
    if ( ppCertExtension )
    {
        hr = CAGetCertTypeExtensions (m_hCertType, &m_pCertExtensions);
        if ( SUCCEEDED (hr) )
        {
            if ( m_pCertExtensions )
            {
                *ppCertExtension = CertFindExtension(pszOID,
                        m_pCertExtensions->cExtension,
                        m_pCertExtensions->rgExtension);
                if ( ! (*ppCertExtension) )
                {
                    if ( SubjectIsCA () )
                    {
                        if ( !_stricmp (szOID_ENHANCED_KEY_USAGE, pszOID) )
                            *ppCertExtension = &g_EKUCertExtension;
                        else if ( !_stricmp (szOID_CERT_POLICIES, pszOID) )
                            *ppCertExtension = &g_certPolCertExtension;
                    }
                }
            }
            else
                hr = E_FAIL;
        }
        else
        {
            _TRACE (0, L"CAGetCertTypeExtensions () failed: 0x%x\n", hr);
        }
    }
    else
        return E_POINTER;

    return hr;
}

HRESULT CCertTemplate::GetCertExtension(DWORD dwIndex, PSTR* ppszObjId, BOOL& fCritical)
{
    if ( !ppszObjId )
        return E_POINTER;

    PCERT_EXTENSIONS pCertExtensions = 0;
    HRESULT hr = CAGetCertTypeExtensions (m_hCertType, &pCertExtensions);
    if ( SUCCEEDED (hr) )
    {
        if ( pCertExtensions )
        {
            if ( dwIndex >= pCertExtensions->cExtension )
                hr = E_INVALIDARG;
            else
            {
                PCERT_EXTENSION pExtension = &pCertExtensions->rgExtension[dwIndex];
                ASSERT (pExtension->pszObjId);
                if ( pExtension->pszObjId )
                {
                    // security review 2/21/2002 BryanWal ok
                    PSTR    pszOID = new char[strlen (pExtension->pszObjId)+1];
                    if ( pszOID )
                    {
                        // security review 2/21/2002 BryanWal ok
                        strcpy (pszOID, pExtension->pszObjId);
                        *ppszObjId = pszOID;
                        fCritical = pExtension->fCritical;
                    }
                    else
                        hr = E_OUTOFMEMORY;
                }
                else
                    hr = E_FAIL;
            }
            CAFreeCertTypeExtensions (m_hCertType, pCertExtensions);
        }
    }
    else
    {
        _TRACE (0, L"CAGetCertTypeExtensions () failed: 0x%x\n", hr);
    }


    return hr;
}

bool CCertTemplate::HasKeySpecSignature() const
{
    return m_dwKeySpec & AT_SIGNATURE ? true : false;
}

bool CCertTemplate::HasEncryptionSignature() const
{
    return m_dwKeySpec & AT_KEYEXCHANGE ? true : false;
}

bool CCertTemplate::RequireSubjectInRequest() const
{
    return m_dwSubjectNameFlags & CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT ? true : false;
}

#define CVT_BASE	(1000 * 1000 * 10)

HRESULT CCertTemplate::ConvertCertTypeFileTimeToDays (FILETIME const *pftCertType, int& nDays)
{
    HRESULT     hr = S_OK;
    if ( !pftCertType )
        return E_POINTER;

    LONGLONG ll = *(LONGLONG *) pftCertType;	// Signed 64 bit scalar!
    if (0 > ll)
    {
        ll = -ll;
        ll /= CVT_BASE; // now in seconds

        nDays = (int) (ll / (60 * 60 * 24));
    }
    else
        nDays = 0;

    return hr;
}

HRESULT CCertTemplate::GetValidityPeriod(int& nValidityDays)
{
    HRESULT hr = S_OK;

    FILETIME    ftValidity;
    hr = CAGetCertTypeExpiration (m_hCertType, &ftValidity, 0);
    if ( SUCCEEDED (hr) )
    {
        hr = ConvertCertTypeFileTimeToDays (&ftValidity, nValidityDays);
        if ( SUCCEEDED (hr) )
            m_nOriginalValidityDays = nValidityDays;
    }

    return hr;
}

HRESULT CCertTemplate::GetRenewalPeriod(int& nRenewalDays)
{
    HRESULT hr = S_OK;

    FILETIME    ftRenewal;
    hr = CAGetCertTypeExpiration (m_hCertType, 0, &ftRenewal);
    if ( SUCCEEDED (hr) )
    {
        hr = ConvertCertTypeFileTimeToDays (&ftRenewal, nRenewalDays);
        if ( SUCCEEDED (hr) )
            m_nOriginalRenewalDays = nRenewalDays;
    }

    return hr;
}

// NEW CLONE
HRESULT CCertTemplate::Clone (
        const CCertTemplate& rTemplate, 
        const CString& strTemplateName, 
        const CString& strDisplayName)
{
    _TRACE (1, L"Entering CCertTemplate::Clone (%s, %s)\n", (PCWSTR) strTemplateName, (PCWSTR) strDisplayName);
    HRESULT hr = S_OK;

    _ASSERT (m_bIsClone);
    if ( m_bIsClone )
    {
        m_strTemplateName = strTemplateName;

        // Set the originalTemplateName so that we can tell later if the
        // user has renamed the template.  This is important because renaming
        // a template creates a brand new template and the old one must then
        // be deleted.
        m_strOriginalTemplateName = strTemplateName;

        SetObjectName (strDisplayName);

        if ( SUCCEEDED (hr) )
        {
            hr = CAFindCertTypeByName (rTemplate.GetTemplateName (), 
                    NULL,
                    CT_ENUM_MACHINE_TYPES | CT_ENUM_USER_TYPES | CT_FLAG_NO_CACHE_LOOKUP,
                    &m_hCertType);
            if ( SUCCEEDED (hr) )
            {
                HCERTTYPE   hNewCertType = 0;
                hr = CACloneCertType (
                        m_hCertType,
                        strTemplateName,
                        strDisplayName,
                        0,
                        (GetType () > 1 ) ? 
                            (CT_CLONE_KEEP_SUBJECT_NAME_SETTING | CT_CLONE_KEEP_AUTOENROLLMENT_SETTING): 0, 
                        &hNewCertType);
                if ( SUCCEEDED (hr) )
                {
                    CACloseCertType (m_hCertType);
                    
                    m_hCertType = hNewCertType;

                    m_szLDAPPath = GetDN ();
                    hr = Initialize ();
                }
                else
                {
                    _TRACE (0, L"CACloneCertType (%s, %s) failed: 0x%d\n",
                            (PCWSTR) strTemplateName, (PCWSTR) strDisplayName,
                            hr);
                }
            }
            else
            {
                _TRACE (0, L"CAFindCertTypeByName (%s) failed: 0x%x", 
                        (PCWSTR) rTemplate.GetTemplateName (), hr);
            }
        }
    }
    else
        hr = E_FAIL;

    _TRACE (-1, L"Leaving CCertTemplate::Clone: 0x%x\n", hr);
    return hr;
}


HRESULT CCertTemplate::Delete()
{
    _TRACE (1, L"Entering CCertTemplate::Delete - m_hCertType = 0x%x\n", m_hCertType);
    HRESULT hr = S_OK;

    if ( !(m_dwGeneralFlags & CT_FLAG_IS_DEFAULT) )
    {
        if ( m_hCertType )
        {
            hr = CADeleteCertType (m_hCertType);
            if ( FAILED (hr) )
            {
                _TRACE (0, L"CADeleteCertType failed: 0x%x\n", hr);
            }
        }
        else
        {
            _TRACE (0, L"m_hCertType was unexpectedly NULL\n");
            hr = E_UNEXPECTED;
        }
    }
    else
        hr = E_FAIL;

    _TRACE (-1, L"Leaving CCertTemplate::Delete: 0x%x\n", hr);
    return hr;
}

bool CCertTemplate::IsDefault() const
{
    return m_dwGeneralFlags & CT_FLAG_IS_DEFAULT ? true : false;
}

bool CCertTemplate::IsClone() const
{
    return m_bIsClone;
}

HRESULT CCertTemplate::SetTemplateName(const CString &strTemplateName)
{
    _TRACE (1, L"Entering CCertTemplate::SetTemplateName (%s) - m_hCertType = 0x%x\n", 
            strTemplateName, m_hCertType);
    HRESULT hr = S_OK;

    if ( LocaleStrCmp (m_strTemplateName, strTemplateName) )
    {
        PWSTR   rgwszProp[2];
        rgwszProp[0] = (PWSTR)(PCWSTR) strTemplateName;
        rgwszProp[1] = 0;;

        hr = CASetCertTypePropertyEx (m_hCertType, 
                CERTTYPE_PROP_CN, rgwszProp);
        if ( SUCCEEDED (hr) )
        {
            m_strTemplateName = strTemplateName;
        }
        else
        {
            _TRACE (0, L"CASetCertTypePropertyEx (CERTTYPE_PROP_CN, %s) failed: 0x%x",
                    rgwszProp[0], hr);
        }
    }
    _TRACE (-1, L"Leaving CCertTemplate::SetTemplateName: 0x%x\n", hr);
    return hr;
}

HRESULT CCertTemplate::SetDisplayName(const CString &strDisplayName, bool bForce)
{
    _TRACE (1, L"Entering CCertTemplate::SetDisplayName (%s) - m_hCertType = 0x%x\n", 
            strDisplayName, m_hCertType);
    HRESULT hr = S_OK;

    if ( bForce || LocaleStrCmp (GetDisplayName (), strDisplayName) )
    {
        PWSTR   rgwszProp[2];
        rgwszProp[0] = (PWSTR)(PCWSTR) strDisplayName;
        rgwszProp[1] = 0;

        hr = CASetCertTypePropertyEx (m_hCertType, 
                CERTTYPE_PROP_FRIENDLY_NAME, rgwszProp);
        if ( SUCCEEDED (hr) )
        {
            m_szDisplayName = L"";
            m_szDisplayName = GetDisplayName ();
            SetObjectName (m_szDisplayName);
        }
        else
        {
            _TRACE (0, L"CASetCertTypePropertyEx (CERTTYPE_PROP_FRIENDLY_NAME, %s) failed: 0x%x",
                    rgwszProp[0], hr);
        }
    }

    _TRACE (-1, L"Leaving CCertTemplate::SetDisplayName: 0x%x\n", hr);
    return hr;
}

HRESULT CCertTemplate::SaveChanges(bool bIncrementMinorVersion /*=true*/)
{
    _TRACE (1, L"Entering CCertTemplate::SaveChanges - m_hCertType = 0x%x\n", m_hCertType);
    HRESULT hr = S_OK;

    m_bCanBeDeletedOnCancel = false;

    if ( m_hCertType )
    {
        // Save validity period 
        if ( -1 != m_nNewValidityDays && m_nOriginalValidityDays != m_nNewValidityDays )
        {
            LONGLONG ll = (LONGLONG) m_nNewValidityDays * (60 * 60 * 24); // seconds
            ll *= CVT_BASE;
            ll = -ll;

            FILETIME    ftValidity;
            ftValidity.dwLowDateTime = (DWORD) (ll & 0xFFFFFFFF);
            ftValidity.dwHighDateTime = (DWORD) (ll >> 32);

            // save the new value back to the cert template
            hr = CASetCertTypeExpiration (m_hCertType, &ftValidity, 0);
            if ( FAILED (hr) )
            {
                _TRACE (0, L"CASetCertTypeExpiration (validity) failed: 0x%x\n", hr);
            }
        }

        // Save renewal period 
        if ( -1 != m_nNewRenewalDays && m_nOriginalRenewalDays != m_nNewRenewalDays )
        {
            LONGLONG ll = (LONGLONG) m_nNewRenewalDays * (60 * 60 * 24); // seconds
            ll *= CVT_BASE;
            ll = -ll;

            // get the original value
            FILETIME    ftRenewal;
            ftRenewal.dwLowDateTime = (DWORD) (ll & 0xFFFFFFFF);
            ftRenewal.dwHighDateTime = (DWORD) (ll >> 32);

            // save the new value back to the cert template
            hr = CASetCertTypeExpiration (m_hCertType, 0, &ftRenewal);
            if ( FAILED (hr) )
            {
                _TRACE (0, L"CASetCertTypeExpiration (renewal) failed: 0x%x\n", hr);
            }
        }

        if ( SUCCEEDED (hr) )
        {
            if ( bIncrementMinorVersion )
                hr = IncrementMinorVersion ();
            if ( SUCCEEDED (hr) )
            {
                hr = CAUpdateCertType (m_hCertType);
                if ( SUCCEEDED (hr) )
                {
                    // If the name was changed a new template was created and the old one needs to be deleted
                    if ( LocaleStrCmp (m_strOriginalTemplateName, m_strTemplateName) )
                    {
                        HCERTTYPE   hCertType = 0;
                        HRESULT     hr1 = CAFindCertTypeByName (m_strOriginalTemplateName, 
                                NULL,
                                CT_ENUM_MACHINE_TYPES | CT_ENUM_USER_TYPES | CT_FLAG_NO_CACHE_LOOKUP,
                                &hCertType);
                        if ( SUCCEEDED (hr1) )
                        {
                            hr1 = CADeleteCertType (hCertType);
                            if (FAILED (hr1) )
                            {
                                _TRACE (0, L"Cert Template was renamed. Original cert template %s was found but could not be deleted: 0x%x\n", 
                                        m_strOriginalTemplateName, hr);
                            }

                            m_strOriginalTemplateName = m_strTemplateName;

                            hr1 = CACloseCertType (hCertType);
                            if ( FAILED (hr1) )
                            {
                                _TRACE (0, L"CACloseCertType () failed: 0x%x", hr);
                            }
                        }
                        else
                        {
                            _TRACE (0, L"Cert Template was renamed. Unable to find original cert template %s. 0x%x\n",
                                        m_strOriginalTemplateName, hr);
                        }
                    }
                    else
                    {
                        m_bIsClone = false;
                        Cancel (); // cause all settings to be refreshed
                    }
                }
                else
                {
                    _TRACE (0, L"CAUpdateCertType () failed: 0x%x", hr);
                }
            }
        }
    }
    else
        hr = E_FAIL;

    if ( SUCCEEDED (hr) )
        m_bIsClone = false;

    _TRACE (-1, L"Leaving CCertTemplate::SaveChanges: 0x%x\n", hr);
    return hr;
}

HRESULT CCertTemplate::SetSubjectIsCA(bool bSubjectIsCA)
{
    _TRACE (1, L"Entering CCertTemplate::SetSubjectIsCA - m_hCertType = 0x%x\n", m_hCertType);
    HRESULT hr = SetFlag (CERTTYPE_GENERAL_FLAG, CT_FLAG_IS_CA, bSubjectIsCA);


    _TRACE (-1, L"Leaving CCertTemplate::SetSubjectIsCA: 0x%x\n", hr);
    return hr;
}

HRESULT CCertTemplate::SetKeySpecSignature(bool bHasKeySpecSignature)
{
    _TRACE (1, L"Entering CCertTemplate::SetKeySpecSignature - m_hCertType = 0x%x\n", m_hCertType);
    HRESULT hr = S_OK; 

    if ( m_hCertType )
    {
        if ( bHasKeySpecSignature )
            m_dwKeySpec |= AT_SIGNATURE;
        else
            m_dwKeySpec &= ~AT_SIGNATURE;

        hr = CASetCertTypeKeySpec (m_hCertType, m_dwKeySpec);
        if ( SUCCEEDED (hr) )
        {
            PCERT_EXTENSION pCertExtension = 0;
            hr = GetCertExtension (szOID_KEY_USAGE, &pCertExtension);
            if ( SUCCEEDED (hr) && pCertExtension )
            {
                DWORD   cbKeyUsage = 0;
		        if ( ::CryptDecodeObject(CRYPT_ASN_ENCODING, 
				        szOID_KEY_USAGE, 
				        pCertExtension->Value.pbData,
				        pCertExtension->Value.cbData,
				        0, NULL, &cbKeyUsage) )
		        {
			        CRYPT_BIT_BLOB* pKeyUsage = (CRYPT_BIT_BLOB*)
					        ::LocalAlloc (LPTR, cbKeyUsage);
			        if ( pKeyUsage )
			        {
				        if ( ::CryptDecodeObject (CRYPT_ASN_ENCODING, 
						        szOID_KEY_USAGE, 
						        pCertExtension->Value.pbData,
						        pCertExtension->Value.cbData,
						        0, pKeyUsage, &cbKeyUsage) )
				        {
                            if (pKeyUsage->cbData >= 1)
                            {
                                if ( bHasKeySpecSignature )
                                {
                                    pKeyUsage->pbData[0] |= CERT_DIGITAL_SIGNATURE_KEY_USAGE;

                                    // NTRAID# 312946 Cert Template Snap-in: 
                                    // Should clear up the Key Encipherment 
                                    // bit for signature certificate
                                    pKeyUsage->pbData[0] &= ~CERT_KEY_AGREEMENT_KEY_USAGE;
                                    pKeyUsage->pbData[0] &= ~CERT_KEY_ENCIPHERMENT_KEY_USAGE;
                                    pKeyUsage->pbData[0] &= ~CERT_DATA_ENCIPHERMENT_KEY_USAGE;
                                }
                                else
                                {
                                    // is encryption only - clear the digital 
                                    // signature and non-repudiation key usages
                                    pKeyUsage->pbData[0] &= ~CERT_DIGITAL_SIGNATURE_KEY_USAGE;
                                    pKeyUsage->pbData[0] &= ~CERT_NON_REPUDIATION_KEY_USAGE;                                    
                                    if ( !(CERT_KEY_AGREEMENT_KEY_USAGE & pKeyUsage->pbData[0]) )
                                        pKeyUsage->pbData[0] |= CERT_KEY_ENCIPHERMENT_KEY_USAGE;
                                }

                                pKeyUsage->cUnusedBits = 0;                
                                SetKeyUsage (pKeyUsage, 
                                        pCertExtension->fCritical ? true : false);
                                FreeCertExtensions ();
                            }
				        }
				        else
                        {
                            DWORD   dwErr = GetLastError ();
                            _TRACE (0, L"CryptDecodeObject (szOID_KEY_USAGE) failed: 0x%x\n", dwErr);
			                DisplaySystemError (NULL, dwErr);
                        }

                        ::LocalFree (pKeyUsage);
			        }
		        }
		        else
                {
                    DWORD   dwErr = GetLastError ();
                    _TRACE (0, L"CryptDecodeObject (szOID_KEY_USAGE) failed: 0x%x\n", dwErr);
			        DisplaySystemError (NULL, dwErr);
                }
            }
        }
        else
        {
            _TRACE (0, L"CASetCertTypeKeySpec() failed: 0x%x\n", hr);
        }
    }
    else
        hr = E_UNEXPECTED;

    _TRACE (-1, L"Leaving CCertTemplate::SetKeySpecSignature: 0x%x\n", hr);
    return hr;
}


HRESULT CCertTemplate::SetFlag (DWORD dwFlagType, DWORD dwFlag, bool bValue)
{
    _TRACE (1, L"Entering CCertTemplate::SetFlag - m_hCertType = 0x%x\n", m_hCertType);;
    HRESULT hr = S_OK;
    
    DWORD*  pdwFlags = 0;

    switch (dwFlagType)
    {
    case CERTTYPE_ENROLLMENT_FLAG:
        pdwFlags = &m_dwEnrollmentFlags;
        break;

    case CERTTYPE_SUBJECT_NAME_FLAG:
        pdwFlags = &m_dwSubjectNameFlags;
        break;

    case CERTTYPE_PRIVATE_KEY_FLAG:
        pdwFlags = &m_dwPrivateKeyFlags;
        break;

    case CERTTYPE_GENERAL_FLAG:
        pdwFlags = &m_dwGeneralFlags;
        break;

    default:
        _ASSERT (0);
        hr = E_FAIL;
        break;
    }

    if ( pdwFlags )
    {
        if ( bValue )
            *pdwFlags |= dwFlag;
        else
            *pdwFlags &= ~dwFlag;

        hr = CASetCertTypeFlagsEx (m_hCertType, dwFlagType, *pdwFlags);
        _ASSERT (SUCCEEDED (hr));
        if ( FAILED (hr) )
        {
            _TRACE (0, L"CASetCertTypeFlagsEx () failed: 0x%x\n", hr);
        }
    }

    _TRACE (-1, L"Leaving CCertTemplate::SetFlag: 0x%x\n", hr);
    return hr;
}

HRESULT CCertTemplate::SetEncryptionSignature(bool bHasEncryptionSignature)
{
    _TRACE (1, L"Entering CCertTemplate::SetEncryptionSignature - m_hCertType = 0x%x\n", m_hCertType);
    HRESULT hr = S_OK;

    if ( m_hCertType )
    {
        if ( bHasEncryptionSignature )
            m_dwKeySpec |= AT_KEYEXCHANGE;
        else
            m_dwKeySpec &= ~AT_KEYEXCHANGE;

        hr = CASetCertTypeKeySpec (m_hCertType, m_dwKeySpec);
        if ( FAILED (hr) )
        {
            _TRACE (0, L"CASetCertTypeKeySpec() failed: 0x%x\n", hr);
        }
    }
    else
        hr = E_UNEXPECTED;


    _TRACE (-1, L"Leaving CCertTemplate::SetEncryptionSignature: 0x%x\n", hr);
    return hr;
}

bool CCertTemplate::CanBeDeletedOnCancel() const
{
    return m_bCanBeDeletedOnCancel;
}

HRESULT CCertTemplate::SetAutoEnrollment(bool bSuitableForAutoEnrollment)
{
    HRESULT hr = S_OK;

    if ( IsClone () )
    {
        // If this is a clone, the autoenrollment flag has already been turned 
        // off.  Here we wish only to keep track of what the user's 
        // preferences are so that we can turn it on, if desired, at the
        // final save.
        m_bGoodForAutoenrollmentFlagPendingSave = bSuitableForAutoEnrollment;
    }
    else
        hr = SetFlag (CERTTYPE_ENROLLMENT_FLAG, CT_FLAG_AUTO_ENROLLMENT, 
                bSuitableForAutoEnrollment);

    return hr;
}

HRESULT CCertTemplate::GetMinimumKeySize(DWORD &dwMinKeySize) const
{
    _TRACE (1, L"Entering CCertTemplate::GetMinimumKeySize - m_hCertType = 0x%x\n", m_hCertType);
    HRESULT hr = S_OK;
    if ( m_hCertType )
    {
        hr = CAGetCertTypePropertyEx (m_hCertType,
                CERTTYPE_PROP_MIN_KEY_SIZE,
                &dwMinKeySize);
        if ( FAILED (hr) )
        {
            _TRACE (0, L"CAGetCertTypePropertyEx (CERTTYPE_PROP_MIN_KEY_SIZE) failed: 0x%x\n", hr);
        }
    }

    _TRACE (-1, L"Leaving CCertTemplate::GetMinimumKeySize (%d): 0x%x\n", dwMinKeySize, hr);
   return hr;
}

bool CCertTemplate::PrivateKeyIsExportable() const
{
    return (m_dwPrivateKeyFlags & CT_FLAG_EXPORTABLE_KEY) ? true : false;
}

HRESULT CCertTemplate::MakePrivateKeyExportable(bool bMakeExportable)
{
    return SetFlag (CERTTYPE_PRIVATE_KEY_FLAG, CT_FLAG_EXPORTABLE_KEY, 
            bMakeExportable);
}

bool CCertTemplate::AllowPrivateKeyArchival() const
{
    return (m_dwPrivateKeyFlags & CT_FLAG_ALLOW_PRIVATE_KEY_ARCHIVAL) ? true : false;
}

HRESULT CCertTemplate::AllowPrivateKeyArchival(bool bAllowArchival)
{
    return SetFlag (CERTTYPE_PRIVATE_KEY_FLAG, 
            CT_FLAG_ALLOW_PRIVATE_KEY_ARCHIVAL, bAllowArchival);
}


bool CCertTemplate::IncludeSymmetricAlgorithms() const
{
    return (m_dwEnrollmentFlags & CT_FLAG_INCLUDE_SYMMETRIC_ALGORITHMS) ? true : false;
}

HRESULT CCertTemplate::IncludeSymmetricAlgorithms(bool bInclude)
{
    return SetFlag (CERTTYPE_ENROLLMENT_FLAG, 
            CT_FLAG_INCLUDE_SYMMETRIC_ALGORITHMS, bInclude);
}

HRESULT CCertTemplate::DoAutoEnrollmentPendingSave()
{
    HRESULT hr = S_OK;

    if ( m_hCertType )
    {
        if ( IsClone () && m_bGoodForAutoenrollmentFlagPendingSave )
        {
            // Set the flag for real
            hr = SetFlag (CERTTYPE_ENROLLMENT_FLAG, CT_FLAG_AUTO_ENROLLMENT, 
                    true);
        
            // Save changes
            if ( SUCCEEDED (hr) )
                hr = SaveChanges ();
        }
    }
    else
        hr = E_FAIL;

    return hr;
}

bool CCertTemplate::AltNameIncludesDNS() const
{
    return (m_dwSubjectNameFlags & CT_FLAG_SUBJECT_ALT_REQUIRE_DNS) ? true : false;
}

HRESULT CCertTemplate::AltNameIncludesDNS(bool fIncludeDNS)
{
    return SetFlag (CERTTYPE_SUBJECT_NAME_FLAG, 
            CT_FLAG_SUBJECT_ALT_REQUIRE_DNS, fIncludeDNS);
}

bool CCertTemplate::AltNameIncludesEMail() const
{
    return (m_dwSubjectNameFlags & CT_FLAG_SUBJECT_ALT_REQUIRE_EMAIL) ? true : false;
}

HRESULT CCertTemplate::AltNameIncludesEMail(bool bIncludesEMail)
{
    return SetFlag (CERTTYPE_SUBJECT_NAME_FLAG, 
            CT_FLAG_SUBJECT_ALT_REQUIRE_EMAIL, bIncludesEMail);
}

bool CCertTemplate::AltNameIncludesUPN() const
{
    return (m_dwSubjectNameFlags & CT_FLAG_SUBJECT_ALT_REQUIRE_UPN) ? true : false;
}

HRESULT CCertTemplate::AltNameIncludesUPN(bool bIncludesUPN)
{
    return SetFlag (CERTTYPE_SUBJECT_NAME_FLAG, 
            CT_FLAG_SUBJECT_ALT_REQUIRE_UPN, bIncludesUPN);
}

bool CCertTemplate::SubjectNameIncludesEMail() const
{
    return (m_dwSubjectNameFlags & CT_FLAG_SUBJECT_REQUIRE_EMAIL) ? true : false;
}

HRESULT CCertTemplate::SubjectNameIncludesEMail(bool bIncludesEMail)
{
    return SetFlag (CERTTYPE_SUBJECT_NAME_FLAG, 
            CT_FLAG_SUBJECT_REQUIRE_EMAIL, bIncludesEMail);
}

bool CCertTemplate::SubjectNameMustBeFullDN() const
{
    return (m_dwSubjectNameFlags & CT_FLAG_SUBJECT_REQUIRE_DIRECTORY_PATH) ? true : false;
}

HRESULT CCertTemplate::SubjectNameMustBeFullDN(bool bMustBeDN)
{
    return SetFlag (CERTTYPE_SUBJECT_NAME_FLAG, 
            CT_FLAG_SUBJECT_REQUIRE_DIRECTORY_PATH, bMustBeDN);
}

bool CCertTemplate::SubjectNameMustBeCN() const
{
    return (m_dwSubjectNameFlags & CT_FLAG_SUBJECT_REQUIRE_COMMON_NAME) ? true : false;
}

HRESULT CCertTemplate::SubjectNameMustBeCN(bool bMustBeCN)
{
    return SetFlag (CERTTYPE_SUBJECT_NAME_FLAG, 
            CT_FLAG_SUBJECT_REQUIRE_COMMON_NAME, bMustBeCN);
}

HRESULT CCertTemplate::RequireSubjectInRequest(bool bRequire)
{
    return SetFlag (CERTTYPE_SUBJECT_NAME_FLAG, 
            CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT, bRequire);
}

bool CCertTemplate::AltNameIncludesSPN() const
{
    return (m_dwSubjectNameFlags & CT_FLAG_SUBJECT_ALT_REQUIRE_SPN) ? true : false;
}

HRESULT CCertTemplate::AltNameIncludesSPN(bool bIncludesSPN)
{
    return SetFlag (CERTTYPE_SUBJECT_NAME_FLAG, 
            CT_FLAG_SUBJECT_ALT_REQUIRE_SPN, bIncludesSPN);
}

HRESULT CCertTemplate::SetMinimumKeySizeValue(DWORD dwMinKeySize)
{
    _TRACE (1, L"Entering CCertTemplate::SetMinimumKeySizeValue (%d)- m_hCertType = 0x%x\n", 
            dwMinKeySize, m_hCertType);
    HRESULT hr = S_OK;
    if ( m_hCertType )
    {
        hr = CASetCertTypePropertyEx (m_hCertType,
                CERTTYPE_PROP_MIN_KEY_SIZE,
                &dwMinKeySize);
        if ( FAILED (hr) )
        {
            _TRACE (0, L"CASetCertTypePropertyEx (CERTTYPE_PROP_MIN_KEY_SIZE) failed: 0x%x\n", hr);
        }
    }

    _TRACE (-1, L"Leaving CCertTemplate::SetMinimumKeySizeValue (%d): 0x%x\n", dwMinKeySize, hr);
   return hr;

}


HRESULT CCertTemplate::ModifyCriticalExtensions (const CString &szExtension, bool bAdd)
{
    _TRACE (1, L"Entering CCertTemplate::ModifyCriticalExtensions (%s, bAdd=%s)\n", 
            (PCWSTR) szExtension, bAdd ? L"true" : L"false");
    PWSTR*   pawszCriticalExtensions = 0;
    
    HRESULT hr = CAGetCertTypeProperty (m_hCertType, 
                CERTTYPE_PROP_CRITICAL_EXTENSIONS,
                &pawszCriticalExtensions);
    if ( SUCCEEDED (hr) )
    {
        if ( !pawszCriticalExtensions )
            pawszCriticalExtensions = (PWSTR*) LocalAlloc (LPTR, sizeof (PWSTR));
        if ( pawszCriticalExtensions )
        {
            hr = ModifyStringList (CERTTYPE_PROP_CRITICAL_EXTENSIONS,
                    &pawszCriticalExtensions, szExtension, bAdd);
            LocalFree (pawszCriticalExtensions);
        }
        else
            hr = E_OUTOFMEMORY;
    }
    else
    {
        _TRACE (0, L"CAGetCertTypeProperty (CERTTYPE_PROP_CRITICAL_EXTENSIONS) failed: 0x%x\n", hr);
    }

    _TRACE (-1, L"Leaving CCertTemplate::ModifyCriticalExtensions: 0x%x\n", hr);
    return hr;
}

HRESULT CCertTemplate::ModifyCSPList(const CString &szCSPName, bool bAdd)
{
    _TRACE (1, L"Entering CCertTemplate::ModifyCSPList (%s, bAdd=%s)\n", 
            (PCWSTR) szCSPName, bAdd ? L"true" : L"false");
    PWSTR*   pawszCSPList = 0;
    
    HRESULT hr = CAGetCertTypeProperty (m_hCertType, 
                CERTTYPE_PROP_CSP_LIST,
                &pawszCSPList);
    if ( SUCCEEDED (hr) )
    {
        if ( !pawszCSPList )
            pawszCSPList = (PWSTR*) LocalAlloc (LPTR, sizeof (PWSTR*));
        if ( pawszCSPList )
        {
            hr = ModifyStringList (CERTTYPE_PROP_CSP_LIST,
                    &pawszCSPList, szCSPName, bAdd);
            LocalFree (pawszCSPList);
        }
        else
            hr = E_FAIL;
    }
    else
    {
        _TRACE (0, L"CAGetCertTypeProperty (CERTTYPE_PROP_CSP_LIST) failed: 0x%x\n", hr);
    }

    _TRACE (-1, L"Leaving CCertTemplate::ModifyCSPList: 0x%x\n", hr);
    return hr;
}

HRESULT CCertTemplate::ModifyRAIssuancePolicyList(const CString &szRAPolicyOID, bool bAdd)
{
    _TRACE (1, L"Entering CCertTemplate::ModifyRAIssuancePolicyList (%s, bAdd=%s)\n", 
            (PCWSTR) szRAPolicyOID, bAdd ? L"true" : L"false");
    PWSTR*   pawszRAPolicyList = 0;
    HRESULT hr = CAGetCertTypeProperty (m_hCertType, 
            CERTTYPE_PROP_RA_POLICY,
            &pawszRAPolicyList);
    if ( SUCCEEDED (hr) )
    {
        if ( !pawszRAPolicyList )
            pawszRAPolicyList = (PWSTR*) LocalAlloc (LPTR, sizeof (PWSTR*));
        if ( pawszRAPolicyList )
        {
            hr = ModifyStringList (CERTTYPE_PROP_RA_POLICY,
                    &pawszRAPolicyList, szRAPolicyOID, bAdd);
            LocalFree (pawszRAPolicyList);
        }
        else
            hr = E_FAIL;
    }
    else
    {
        _TRACE (0, L"CAGetCertTypeProperty (CERTTYPE_PROP_RA_POLICY) failed: 0x%x\n", hr);
    }

    _TRACE (-1, L"Leaving CCertTemplate::ModifyRAIssuancePolicyList: 0x%x\n", hr);
    return hr;
}

HRESULT CCertTemplate::ModifyRAApplicationPolicyList(const CString &szRAPolicyOID, bool bAdd)
{
    _TRACE (1, L"Entering CCertTemplate::ModifyRAApplicationPolicyList (%s, bAdd=%s)\n", 
            (PCWSTR) szRAPolicyOID, bAdd ? L"true" : L"false");
    PWSTR*   pawszRAPolicyList = 0;
    HRESULT hr = CAGetCertTypeProperty (m_hCertType, 
            CERTTYPE_PROP_RA_APPLICATION_POLICY,
            &pawszRAPolicyList);
    if ( SUCCEEDED (hr) )
    {
        if ( !pawszRAPolicyList )
            pawszRAPolicyList = (PWSTR*) LocalAlloc (LPTR, sizeof (PWSTR*));
        if ( pawszRAPolicyList )
        {
            hr = ModifyStringList (CERTTYPE_PROP_RA_APPLICATION_POLICY,
                    &pawszRAPolicyList, szRAPolicyOID, bAdd);
            LocalFree (pawszRAPolicyList);
        }
        else
            hr = E_FAIL;
    }
    else
    {
        _TRACE (0, L"CAGetCertTypeProperty (CERTTYPE_PROP_RA_APPLICATION_POLICY) failed: 0x%x\n", hr);
    }

    _TRACE (-1, L"Leaving CCertTemplate::ModifyRAApplicationPolicyList: 0x%x\n", hr);
    return hr;
}

HRESULT CCertTemplate::ModifySupercededTemplateList(
        const CString &szSupercededTemplateName, 
        bool bAdd)
{
    _TRACE (1, L"Entering CCertTemplate::ModifySupercededTemplateList (%s, bAdd=%s)\n", 
            (PCWSTR) szSupercededTemplateName, bAdd ? L"true" : L"false");

    PWSTR*  pawszSupercededTemplateList = 0;
    HRESULT hr = CAGetCertTypeProperty (m_hCertType, 
            CERTTYPE_PROP_SUPERSEDE,
            &pawszSupercededTemplateList);
    if ( SUCCEEDED (hr) )
    {
        if ( !pawszSupercededTemplateList )
            pawszSupercededTemplateList = (PWSTR*) LocalAlloc (LPTR, sizeof (PWSTR*));
        if ( pawszSupercededTemplateList )
        {
            hr = ModifyStringList (CERTTYPE_PROP_SUPERSEDE,
                    &pawszSupercededTemplateList, szSupercededTemplateName, bAdd);
            LocalFree (pawszSupercededTemplateList);
        }
        else
            hr = E_FAIL;
    }
    else
    {
        _TRACE (0, L"CAGetCertTypeProperty (CERTTYPE_PROP_SUPERSEDE) failed: 0x%x\n", hr);
    }

    _TRACE (-1, L"Leaving CCertTemplate::ModifySupercededTemplateList: 0x%x\n", hr);
    return hr;
}


HRESULT CCertTemplate::ModifyStringList(const CString& szPropertyName, 
                                        PWSTR** ppStringList, 
                                        const CString &szValue, 
                                        bool bAdd)
{
    _TRACE (1, L"Entering CCertTemplate::ModifyStringList (%s, bAdd=%s)\n", 
            (PCWSTR) szValue, bAdd ? L"true" : L"false");
    HRESULT hr = S_OK;
    if ( !szValue.IsEmpty () )
    {
        bool    bFound = false;
        int     nCnt = 0;
        size_t  cbNameBytes = 0;
        int     nDeleteIndex = -1;

        // count the number of items we already have and get the string lengths
        for (int nIndex = 0; (*ppStringList)[nIndex]; nIndex++)
        {
            nCnt++;
            // security review 2/21/2002 BryanWal ok
            cbNameBytes += (wcslen ((*ppStringList)[nIndex]) + 1) * sizeof (WCHAR);
            if ( !LocaleStrCmp (szValue, (*ppStringList)[nIndex]) )
            {
                bFound = true;
                if ( !bAdd )
                    nDeleteIndex = nIndex;
            }
        }

        // Adding a name: If the name was found, nothing needs to be done,
        // otherwise, increment the count and rebuild the list.
        // Removing a name: If the name was not found, nothing needs to be 
        // done, otherwise, decrement the count and rebuild the list.
        if ( (bAdd && !bFound) || (!bAdd && bFound) )
        {
            // awszResult is an array of pointers to different offsets of 
            // null-terminated strings stored in a contiguous array
            PWSTR *awszResult = 0;
            if ( bAdd )
                nCnt++;
            else
                nCnt--;

            if ( bAdd )
            {
                // security review 2/21/2002 BryanWal ok
                cbNameBytes += (wcslen (szValue) + 1 ) * sizeof (WCHAR);
            }
            size_t cbBuf = sizeof (WCHAR*) * (nCnt + 1) + // the WCHAR pointers
                    cbNameBytes;                          // the strings themselves
            awszResult = (WCHAR**) LocalAlloc (LPTR, cbBuf); 
            if ( awszResult )
            {
                // set the ptr to the space after the last valid index (
                // including the NULL terminator
                PWSTR   ptr = (WCHAR*) &awszResult[nCnt+1];
                int     nTgtIndex = 0;
                for (int nSrcIndex = 0; (*ppStringList)[nSrcIndex]; nSrcIndex++)
                {
                    // If we are removing the name, and this is the item to be
                    // removed, then skip this name and go to the next
                    if ( !bAdd && nSrcIndex == nDeleteIndex )
                        continue;

                    awszResult[nTgtIndex] = ptr;
                    // security review 2/21/2002 BryanWal ok
                    ptr += wcslen ((*ppStringList)[nSrcIndex]) + 1; // ptr arithmetic - increments by sizeof (WCHAR)
                    // security review 2/21/2002 BryanWal ok
                    wcscpy (awszResult[nTgtIndex], (*ppStringList)[nSrcIndex]);
                    nTgtIndex++;
                }

                // If we are adding, append the name here
                if ( bAdd )
                {
                    awszResult[nTgtIndex] = ptr;
                    // security review 2/21/2002 BryanWal ok
                    ptr += wcslen (szValue) + 1; // ptr arithmetic - increments by sizeof (WCHAR)
                    // security review 2/21/2002 BryanWal ok
                    wcscpy (awszResult[nTgtIndex], szValue);
                    nTgtIndex++;
                }

                _ASSERT (nTgtIndex == nCnt);
                awszResult[nTgtIndex] = 0;

                LocalFree (*ppStringList);
                (*ppStringList) = awszResult;
                hr = CASetCertTypePropertyEx (m_hCertType,
                        szPropertyName,
                        (*ppStringList));
                if ( FAILED (hr) )
                {
                    _TRACE (0, L"CASetCertTypePropertyEx (%s) failed: 0x%x\n", 
                            szPropertyName, hr);
                }
            }
            else
                hr = E_OUTOFMEMORY;
        }
    }
    else
        hr = E_INVALIDARG;

    _TRACE (-1, L"Leaving CCertTemplate::ModifyStringList: 0x%x\n", hr);
    return hr;
}

HRESULT CCertTemplate::IsExtensionCritical (PCWSTR szExtension, bool& bCritical)
{
    _TRACE (1, L"Entering CCertTemplate::IsExtensionCritical (szExtension=%s\n", szExtension);

    // Get Cryptographic Service Providers
    PWSTR*   pawszCriticalExtensionList = 0;
    bCritical = false;
    
    HRESULT hr = CAGetCertTypeProperty (m_hCertType, 
                CERTTYPE_PROP_CRITICAL_EXTENSIONS,
                &pawszCriticalExtensionList);
    if ( SUCCEEDED (hr) )
    {
        if ( pawszCriticalExtensionList )
        {
            for (int nIndex = 0; pawszCriticalExtensionList[nIndex]; nIndex++)
            {
                if ( !wcscmp (szExtension, pawszCriticalExtensionList[nIndex]) )
                {
                    bCritical = true;
                    break;
                }
            }

            LocalFree (pawszCriticalExtensionList);
        }
        else
            hr = E_FAIL;
    }
    else
    {
        _TRACE (0, L"CAGetCertTypeProperty (CERTTYPE_PROP_CRITICAL_EXTENSIONS) failed: 0x%x\n", hr);
    }

    _TRACE (-1, L"Leaving CCertTemplate::GeIsExtensionCriticaltCSP (szCSP=%s, bCritical=%s): 0x%x\n", 
            szExtension, bCritical ? L"true" : L"false", hr);
    return hr;
}


HRESULT CCertTemplate::GetCSP(int nIndex, CString &szCSP)
{
    _TRACE (1, L"Entering CCertTemplate::GetCSP (nIndex=%d\n", nIndex);

    // Get Cryptographic Service Providers
    PWSTR*   pawszCSPList = 0;
    
    HRESULT hr = CAGetCertTypeProperty (m_hCertType, 
                CERTTYPE_PROP_CSP_LIST,
                &pawszCSPList);
    if ( SUCCEEDED (hr) )
    {
        if ( pawszCSPList )
        {
            int     nCnt = 0;
            while ( pawszCSPList[nCnt] )
                nCnt++;

            if ( nIndex < nCnt )
                szCSP = pawszCSPList[nIndex];
            else
                hr = E_INVALIDARG;

            LocalFree (pawszCSPList);
        }
        else
            hr = E_FAIL;
    }
    else
    {
        _TRACE (0, L"CAGetCertTypeProperty (CERTTYPE_PROP_CSP_LIST) failed: 0x%x\n", hr);
    }

    _TRACE (-1, L"Leaving CCertTemplate::GetCSP (szCSP=%s): 0x%x\n", 
            (PCWSTR) szCSP, hr);
    return hr;
}

HRESULT CCertTemplate::GetCertPolicy (int nIndex, CString &szCertPolicy)
{
    _TRACE (1, L"Entering CCertTemplate::GetCertPolicy (nIndex=%d\n", nIndex);
    HRESULT hr = S_OK;
    PWSTR*  pawszCertPolicyList = 0;

    hr = CAGetCertTypeProperty (m_hCertType, 
            CERTTYPE_PROP_POLICY,
            &pawszCertPolicyList);
    if ( SUCCEEDED (hr) )
    {
        if ( pawszCertPolicyList )
        {
            int nCnt = 0;
            while ( pawszCertPolicyList[nCnt] )
                nCnt++;

            if ( nIndex < nCnt )
                szCertPolicy = pawszCertPolicyList[nIndex];
            else
                hr = E_FAIL;

            LocalFree (pawszCertPolicyList);
        }
        else
            hr = E_FAIL;
    }
    else
    {
        _TRACE (0, L"CAGetCertTypeProperty (CERTTYPE_PROP_POLICY) failed: 0x%x\n", hr);
    }


    _TRACE (-1, L"Leaving CCertTemplate::GetCertPolicy (szCSP=%s): 0x%x\n", 
            (PCWSTR) szCertPolicy, hr);
    return hr;
}

HRESULT CCertTemplate::GetRAIssuancePolicy (int nIndex, CString &szRAPolicyOID)
{
    _TRACE (1, L"Entering CCertTemplate::GetRAIssuancePolicy (nIndex=%d\n", nIndex);
    
    PWSTR*  pawszRAPolicyList = 0;
    HRESULT hr = CAGetCertTypeProperty (m_hCertType, 
            CERTTYPE_PROP_RA_POLICY,
            &pawszRAPolicyList);
    if ( SUCCEEDED (hr) )
    {
        if ( pawszRAPolicyList )
        {
            int     nCnt = 0;

            while ( pawszRAPolicyList[nCnt] )
                nCnt++;

             if ( nIndex < nCnt )
                szRAPolicyOID = pawszRAPolicyList[nIndex];
            else
                hr = E_FAIL;
            LocalFree (pawszRAPolicyList);
       }
        else
            hr = E_FAIL;
    }
    else
    {
        _TRACE (0, L"CAGetCertTypeProperty (CERTTYPE_PROP_RA_POLICY) failed: 0x%x\n", hr);
    }


    _TRACE (-1, L"Leaving CCertTemplate::GetRAIssuancePolicy (szRAPolicyOID=%s): 0x%x\n", 
            (PCWSTR) szRAPolicyOID, hr);
    return hr;
}

HRESULT CCertTemplate::GetRAApplicationPolicy (int nIndex, CString &szRAPolicyOID)
{
    _TRACE (1, L"Entering CCertTemplate::GetRAApplicationPolicy (nIndex=%d\n", nIndex);
    
    PWSTR*  pawszRAPolicyList = 0;
    HRESULT hr = CAGetCertTypeProperty (m_hCertType, 
            CERTTYPE_PROP_RA_APPLICATION_POLICY,
            &pawszRAPolicyList);
    if ( SUCCEEDED (hr) )
    {
        if ( pawszRAPolicyList )
        {
            int     nCnt = 0;

            while ( pawszRAPolicyList[nCnt] )
                nCnt++;

             if ( nIndex < nCnt )
                szRAPolicyOID = pawszRAPolicyList[nIndex];
            else
                hr = E_FAIL;
            LocalFree (pawszRAPolicyList);
       }
        else
            hr = E_FAIL;
    }
    else
    {
        _TRACE (0, L"CAGetCertTypeProperty (CERTTYPE_PROP_RA_APPLICATION_POLICY) failed: 0x%x\n", hr);
    }


    _TRACE (-1, L"Leaving CCertTemplate::GetRAApplicationPolicy (szRAPolicyOID=%s): 0x%x\n", 
            (PCWSTR) szRAPolicyOID, hr);
    return hr;
}
HRESULT CCertTemplate::GetSupercededTemplate(int nIndex, CString &szSupercededTemplate)
{
    _TRACE (1, L"Entering CCertTemplate::GetSupercededTemplate (nIndex=%d\n", nIndex);
    PWSTR*  pawszSupercededTemplateList = 0;
    HRESULT hr = CAGetCertTypeProperty (m_hCertType, 
            CERTTYPE_PROP_SUPERSEDE,
            &pawszSupercededTemplateList);
    if ( SUCCEEDED (hr) )
    {
        if ( pawszSupercededTemplateList )
        {
            int     nCnt = 0;
            while ( pawszSupercededTemplateList[nCnt] )
                nCnt++;

            if ( nIndex < nCnt )
                szSupercededTemplate = pawszSupercededTemplateList[nIndex];
            else
                hr = E_FAIL;
            LocalFree (pawszSupercededTemplateList);
        }
        else
            hr = E_FAIL;
    }
    else
    {
        _TRACE (0, L"CAGetCertTypeProperty (CERTTYPE_PROP_SUPERSEDE) failed: 0x%x\n", hr);
    }


    _TRACE (-1, L"Leaving CCertTemplate::GetSupercededTemplate (szSupercededTemplate=%s): 0x%x\n", 
            (PCWSTR) szSupercededTemplate, hr);
    return hr;
}

bool CCertTemplate::ReadOnly() const
{
    return m_fIsReadOnly;
}

HRESULT CCertTemplate::SetSecurity(PSECURITY_DESCRIPTOR pSD)
{
    HRESULT hr = CACertTypeSetSecurity (m_hCertType, pSD);
    if (S_OK != hr)
	    return hr;

    for (int nTry = 0; nTry < 20; nTry++)
    {
        hr = CAUpdateCertType(m_hCertType);
        if ( FAILED (hr) && HRESULT_FROM_WIN32 (ERROR_DS_OBJ_NOT_FOUND) == hr )
        {
            // pause and retry up to 20 times - object was renamed and needs a 
            // little time to propagate
            // NTRAID# 643744 Certtmpl: Cannot save security settings on newly 
            // cloned template from member in non Root Domain -- object not found
            Sleep (1000);
            continue;
        }
        else
            break;
    }

    if ( FAILED (hr) )
        Cancel ();

    return hr;
}

HRESULT CCertTemplate::GetSecurity(PSECURITY_DESCRIPTOR *ppSD) const
{
    return CACertTypeGetSecurity (m_hCertType, ppSD);
}

CString CCertTemplate::GetLDAPPath() const
{
    return m_szLDAPPath;
}

HRESULT CCertTemplate::SetValidityPeriod(int nDays)
{
    HRESULT hr = S_OK;

    if ( nDays >= 0 )
        this->m_nNewValidityDays = nDays;
    else
        hr = E_INVALIDARG;

    return hr;
}

HRESULT CCertTemplate::SetRenewalPeriod(int nDays)
{
    HRESULT hr = S_OK;

    if ( nDays >= 0 )
        this->m_nNewRenewalDays = nDays;
    else
        hr = E_INVALIDARG;

    return hr;
}

HRESULT CCertTemplate::SetPublishToDS(bool bPublish)
{
    _TRACE (1, L"Entering CCertTemplate::SetPublishToDS - m_hCertType = 0x%x\n", m_hCertType);
    HRESULT hr = SetFlag (CERTTYPE_ENROLLMENT_FLAG, CT_FLAG_PUBLISH_TO_DS, bPublish);


    _TRACE (-1, L"Leaving CCertTemplate::SetPublishToDS: 0x%x\n", hr);
    return hr;
}

HRESULT CCertTemplate::GetRANumSignaturesRequired(DWORD &dwNumSignatures)
{
    _TRACE (1, L"Entering CCertTemplate::GetRANumSignaturesRequired - m_hCertType = 0x%x\n", m_hCertType);
    HRESULT hr = S_OK;
    
    if ( m_hCertType )
    {
        hr = CAGetCertTypePropertyEx (m_hCertType,
            CERTTYPE_PROP_RA_SIGNATURE,
            &dwNumSignatures);
        if ( FAILED (hr) )
        {
            _TRACE (0, L"CAGetCertTypePropertyEx (CERTTYPE_PROP_RA_SIGNATURE) failed: 0x%x\n", hr);
        }
    }
    else
        hr = E_FAIL;

    _TRACE (-1, L"Leaving CCertTemplate::GetRANumSignaturesRequired: 0x%x\n", hr);

    return hr;
}

HRESULT CCertTemplate::SetRANumSignaturesRequired(DWORD dwNumSignaturesRequired)
{
    _TRACE (1, L"Entering CCertTemplate::SetRANumSignaturesRequired (%d)- m_hCertType = 0x%x\n", 
            dwNumSignaturesRequired, m_hCertType);
    HRESULT hr = S_OK;
    if ( m_hCertType )
    {
        hr = CASetCertTypePropertyEx (m_hCertType,
                CERTTYPE_PROP_RA_SIGNATURE,
                &dwNumSignaturesRequired);
        if ( FAILED (hr) )
        {
            _TRACE (0, L"CASetCertTypePropertyEx (CERTTYPE_PROP_RA_SIGNATURE) failed: 0x%x\n", hr);
        }
    }
    else
        hr = E_FAIL;


    _TRACE (-1, L"Leaving CCertTemplate::SetRANumSignaturesRequired (): 0x%x\n", hr);

   return hr;
}

bool CCertTemplate::ReenrollmentValidWithPreviousApproval() const
{
    return m_dwEnrollmentFlags & CT_FLAG_PREVIOUS_APPROVAL_VALIDATE_REENROLLMENT ? true : false;
}

HRESULT CCertTemplate::SetReenrollmentValidWithPreviousApproval(bool bValid)
{
    _TRACE (1, L"Entering CCertTemplate::SetReenrollmentValidWithPreviousApproval - m_hCertType = 0x%x\n", m_hCertType);
    HRESULT hr = SetFlag (CERTTYPE_ENROLLMENT_FLAG, CT_FLAG_PREVIOUS_APPROVAL_VALIDATE_REENROLLMENT, bValid);


    _TRACE (-1, L"Leaving CCertTemplate::SetReenrollmentValidWithPreviousApproval: 0x%x\n", hr);
    return hr;
}

bool CCertTemplate::PendAllRequests() const
{
    return m_dwEnrollmentFlags & CT_FLAG_PEND_ALL_REQUESTS ? true : false;
}

HRESULT CCertTemplate::SetPendAllRequests(bool bPend)
{
    _TRACE (1, L"Entering CCertTemplate::SetPendAllRequests - m_hCertType = 0x%x\n", m_hCertType);
    HRESULT hr = SetFlag (CERTTYPE_ENROLLMENT_FLAG, CT_FLAG_PEND_ALL_REQUESTS, bPend);


    _TRACE (-1, L"Leaving CCertTemplate::SetPendAllRequests: 0x%x\n", hr);
    return hr;
}

HRESULT CCertTemplate::GetMajorVersion(DWORD &dwMajorVersion) const
{
//    _TRACE (1, L"Entering CCertTemplate::GetMajorVersion\n");
    HRESULT hr = S_OK;

    if ( m_hCertType )
    {
        hr = CAGetCertTypePropertyEx (m_hCertType,
                CERTTYPE_PROP_REVISION,
                &dwMajorVersion);
        if ( FAILED (hr) )
        {
            _TRACE (0, L"CAGetCertTypePropertyEx (CERTTYPE_PROP_REVISION) failed: 0x%x\n", hr);
        }
    }
    else
        hr = E_FAIL;

//    _TRACE (-1, L"Leaving CCertTemplate::GetMajorVersion (dwMajorVersion = %d) : 0x%x\n", 
//            dwMajorVersion, hr);
    return hr;
}

HRESULT CCertTemplate::GetMinorVersion(DWORD &dwMinorVersion) const
{
//    _TRACE (1, L"Entering CCertTemplate::GetMinorVersion\n");
    HRESULT hr = S_OK;

    if ( m_hCertType )
    {
        hr = CAGetCertTypePropertyEx (m_hCertType,
                CERTTYPE_PROP_MINOR_REVISION,
                &dwMinorVersion);
        if ( FAILED (hr) )
        {
            _TRACE (0, L"CAGetCertTypePropertyEx (CERTTYPE_PROP_MINOR_REVISION) failed: 0x%x\n", hr);
        }
    }
    else
        hr = E_FAIL;

//    _TRACE (-1, L"Leaving CCertTemplate::GetMinorVersion (dwMinorVersion = %d) : 0x%x\n", 
//            dwMinorVersion, hr);
    return hr;
}

HRESULT CCertTemplate::IncrementMajorVersion()
{
   _TRACE (1, L"Entering CCertTemplate::IncrementMajorVersion\n");
    HRESULT hr = S_OK;
    DWORD   dwMajorVersion = 0;

    if ( m_hCertType )
    {
        hr = CAGetCertTypePropertyEx (m_hCertType,
                CERTTYPE_PROP_REVISION,
                &dwMajorVersion);
        if ( SUCCEEDED (hr) )
        {
            dwMajorVersion++;
            hr = CASetCertTypePropertyEx (m_hCertType,
                    CERTTYPE_PROP_REVISION,
                    &dwMajorVersion);
            if ( SUCCEEDED (hr) )
            {
                DWORD dwMinorVersion = 0;
                hr = CASetCertTypePropertyEx (m_hCertType,
                        CERTTYPE_PROP_MINOR_REVISION,
                        &dwMinorVersion);
                if ( FAILED (hr) )
                {
                    _TRACE (0, L"CASetCertTypePropertyEx (CERTTYPE_PROP_MINOR_REVISION, %d) failed: 0x%x\n", 
                            dwMinorVersion, hr);
                }
            }
            else
            {
                _TRACE (0, L"CASetCertTypePropertyEx (CERTTYPE_PROP_REVISION, %d) failed: 0x%x\n", 
                        dwMajorVersion, hr);
            }
        }
        else
        {
            _TRACE (0, L"CAGetCertTypePropertyEx (CERTTYPE_PROP_REVISION) failed: 0x%x\n", hr);
        }
    }
    else
        hr = E_FAIL;

    _TRACE (-1, L"Leaving CCertTemplate::IncrementMajorVersion (dwMajorVersion = %d) : 0x%x\n", 
            dwMajorVersion, hr);
    return hr;
}

HRESULT CCertTemplate::IncrementMinorVersion()
{
   _TRACE (1, L"Entering CCertTemplate::IncrementMinorVersion\n");
    HRESULT hr = S_OK;
    DWORD   dwMinorVersion = 0;

    if ( m_hCertType )
    {
        
        hr = CAGetCertTypePropertyEx (m_hCertType,
                CERTTYPE_PROP_MINOR_REVISION,
                &dwMinorVersion);
        if ( SUCCEEDED (hr) )
        {
            dwMinorVersion++;
            hr = CASetCertTypePropertyEx (m_hCertType,
                    CERTTYPE_PROP_MINOR_REVISION,
                    &dwMinorVersion);
            if ( FAILED (hr) )
            {
                _TRACE (0, L"CASetCertTypePropertyEx (CERTTYPE_PROP_MINOR_REVISION, %d) failed: 0x%x\n", 
                        dwMinorVersion, hr);
            }
        }
        else
        {
            _TRACE (0, L"CAGetCertTypePropertyEx (CERTTYPE_PROP_MINOR_REVISION) failed: 0x%x\n", hr);
        }
    }
    else
        hr = E_FAIL;

    _TRACE (-1, L"Leaving CCertTemplate::IncrementMinorVersion (dwMinorVersion = %d) : 0x%x\n", 
            dwMinorVersion, hr);
    return hr;
}

bool CCertTemplate::GoodForAutoEnrollment() const
{
    bool    bGoodForAutoEnrollment = false;

    // Bug 175912 Version 1 type templates not good for autoenrollment    
    if ( (GetType () > 1) && (m_dwEnrollmentFlags & CT_FLAG_AUTO_ENROLLMENT) )
        bGoodForAutoEnrollment = true;

    return bGoodForAutoEnrollment;
}

HRESULT CCertTemplate::SetKeyUsage(CRYPT_BIT_BLOB* pKeyUsage, bool bCritical)
{
    _TRACE (1, L"Entering CCertTemplate::SetKeyUsage\n");
    HRESULT hr = S_OK;
    if ( pKeyUsage )
    {
        hr = CASetCertTypeExtension(
                m_hCertType,
                TEXT (szOID_KEY_USAGE),
                bCritical ? CA_EXT_FLAG_CRITICAL : 0,
                pKeyUsage);
        if ( FAILED (hr) )
        {
            _TRACE (0, L"CASetCertTypeExtension (szOID_KEY_USAGE) failed: 0x%x\n", hr);
        }
    }
    else
        hr = E_POINTER;

    _TRACE (-1, L"Leaving CCertTemplate::SetKeyUsage: 0x%x\n", hr);
    return hr;
}

HRESULT CCertTemplate::SetBasicConstraints(PCERT_BASIC_CONSTRAINTS2_INFO pBCInfo, bool bCritical)
{
    _TRACE (1, L"Entering CCertTemplate::SetBasicConstraints\n");
    HRESULT hr = S_OK;
    if ( pBCInfo )
    {
        hr = CASetCertTypeExtension(
                m_hCertType,
                TEXT (szOID_BASIC_CONSTRAINTS2), 
                bCritical ? CA_EXT_FLAG_CRITICAL : 0,
                pBCInfo);
        if ( FAILED (hr) )
        {
            _TRACE (0, L"CASetCertTypeExtension (X509_BASIC_CONSTRAINTS2) failed: 0x%x\n", hr);
        }
    }
    else
        hr = E_POINTER;

    _TRACE (-1, L"Leaving CCertTemplate::SetBasicConstraints: 0x%x\n", hr);
    return hr;
}

bool CCertTemplate::CheckDSCert() const
{
    return (m_dwEnrollmentFlags & CT_FLAG_AUTO_ENROLLMENT_CHECK_USER_DS_CERTIFICATE) ? true : false;
}

HRESULT CCertTemplate::SetCheckDSCert(bool bCheck)
{
    return SetFlag (CERTTYPE_ENROLLMENT_FLAG, 
            CT_FLAG_AUTO_ENROLLMENT_CHECK_USER_DS_CERTIFICATE, bCheck);
}

bool CCertTemplate::RemoveInvalidCertFromPersonalStore () const
{
    return (m_dwEnrollmentFlags & CT_FLAG_REMOVE_INVALID_CERTIFICATE_FROM_PERSONAL_STORE) ? true : false;
}


HRESULT CCertTemplate::SetRemoveInvalidCertFromPersonalStore(bool bRemove)
{
    return SetFlag (CERTTYPE_ENROLLMENT_FLAG, 
            CT_FLAG_REMOVE_INVALID_CERTIFICATE_FROM_PERSONAL_STORE, bRemove);
}

bool CCertTemplate::UserInteractionRequired () const
{
    return (m_dwEnrollmentFlags & CT_FLAG_USER_INTERACTION_REQUIRED) ? true : false;
}


HRESULT CCertTemplate::SetUserInteractionRequired(bool bSet)
{
    return SetFlag (CERTTYPE_ENROLLMENT_FLAG, 
            CT_FLAG_USER_INTERACTION_REQUIRED, bSet);
}

bool CCertTemplate::StrongKeyProtectionRequired () const
{
    return (m_dwPrivateKeyFlags & CT_FLAG_STRONG_KEY_PROTECTION_REQUIRED) ? true : false;
}

HRESULT CCertTemplate::SetStrongKeyProtectionRequired(bool bSet)
{
    return SetFlag (CERTTYPE_PRIVATE_KEY_FLAG, 
            CT_FLAG_STRONG_KEY_PROTECTION_REQUIRED, bSet);
}



HRESULT CCertTemplate::GetEnhancedKeyUsage (int nIndex, CString &szEKU)
{
    _TRACE (1, L"Entering CCertTemplate::GetEnhancedKeyUsage (nIndex=%d\n", nIndex);
    HRESULT hr = S_OK;
    PWSTR*  pawszEKU = 0;

    hr = CAGetCertTypeProperty (m_hCertType, 
            CERTTYPE_PROP_EXTENDED_KEY_USAGE,
            &pawszEKU);
    if ( SUCCEEDED (hr) )
    {
        if ( pawszEKU )
        {
            int nCnt = 0;

            while ( pawszEKU[nCnt] )
                nCnt++;

            if ( nIndex < nCnt )
                szEKU = pawszEKU[nIndex];
            else
                hr = E_FAIL;
        }
        else
            hr = E_FAIL;

        LocalFree (pawszEKU);
    }
    else
    {
        _TRACE (0, L"CAGetCertTypeProperty (CERTTYPE_PROP_EXTENDED_KEY_USAGE) failed: 0x%x\n", hr);
    }


    _TRACE (-1, L"Leaving CCertTemplate::GetEnhancedKeyUsage (szEKU=%s): 0x%x\n", 
            (PCWSTR) szEKU, hr);
    return hr;
}

HRESULT CCertTemplate::GetApplicationPolicy (int nIndex, CString &szAppPolicy)
{
    _TRACE (1, L"Entering CCertTemplate::GetApplicationPolicy (nIndex=%d\n", nIndex);
    HRESULT hr = S_OK;
    PWSTR*  pawszAppPolicy = 0;

    hr = CAGetCertTypeProperty (m_hCertType, 
            CERTTYPE_PROP_APPLICATION_POLICY,
            &pawszAppPolicy);
    if ( SUCCEEDED (hr) )
    {
        if ( pawszAppPolicy )
        {
            int nCnt = 0;

            while ( pawszAppPolicy[nCnt] )
                nCnt++;

            if ( nIndex < nCnt )
                szAppPolicy = pawszAppPolicy[nIndex];
            else
                hr = E_FAIL;
        }
        else
            hr = E_FAIL;

        LocalFree (pawszAppPolicy);
    }
    else
    {
        _TRACE (0, L"CAGetCertTypeProperty (CERTTYPE_PROP_APPLICATION_POLICY) failed: 0x%x\n", hr);
    }


    _TRACE (-1, L"Leaving CCertTemplate::GetApplicationPolicy (szAppPolicy=%s): 0x%x\n", 
            (PCWSTR) szAppPolicy, hr);
    return hr;
}

HRESULT CCertTemplate::SetEnhancedKeyUsage (const PWSTR* pawszEKU, bool bCritical)
{
    _TRACE (1, L"Entering CCertTemplate::SetEnhancedKeyUsage ()\n");
    HRESULT hr = S_OK;

    hr = CASetCertTypePropertyEx (m_hCertType,
            CERTTYPE_PROP_EXTENDED_KEY_USAGE,
            (PVOID) pawszEKU);
    if ( SUCCEEDED (hr) )
    {
         hr = ModifyCriticalExtensions (szOID_ENHANCED_KEY_USAGE, bCritical);
    }
    else
    {
        _TRACE (0, L"CASetCertTypePropertyEx (CERTTYPE_PROP_EXTENDED_KEY_USAGE) failed: 0x%x\n", 
                hr);
    }

    _TRACE (-1, L"Leaving CCertTemplate::SetEnhancedKeyUsage: 0x%x\n", hr);
    return hr;
}

HRESULT CCertTemplate::SetApplicationPolicy (const PWSTR* pawszAppPolicy, bool bCritical)
{
    _TRACE (1, L"Entering CCertTemplate::SetApplicationPolicy ()\n");
    HRESULT hr = S_OK;

    hr = CASetCertTypePropertyEx (m_hCertType,
            CERTTYPE_PROP_APPLICATION_POLICY,
            (PVOID) pawszAppPolicy);
    if ( SUCCEEDED (hr) )
    {
         hr = ModifyCriticalExtensions (szOID_APPLICATION_CERT_POLICIES, bCritical);
    }
    else
    {
        _TRACE (0, L"CASetCertTypePropertyEx (CERTTYPE_PROP_APPLICATION_POLICY) failed: 0x%x\n", 
                hr);
    }

    _TRACE (-1, L"Leaving CCertTemplate::SetApplicationPolicy: 0x%x\n", hr);
    return hr;
}

HRESULT CCertTemplate::SetCertPolicy (const PWSTR* pawszCertPolicy, bool bCritical)
{
    _TRACE (1, L"Entering CCertTemplate::SetCertPolicy ()\n");
    HRESULT hr = S_OK;

    hr = CASetCertTypePropertyEx (m_hCertType,
            CERTTYPE_PROP_POLICY,
            (PVOID) pawszCertPolicy);
    if ( SUCCEEDED (hr) )
    {
         hr = ModifyCriticalExtensions (szOID_CERT_POLICIES, bCritical);
    }
    else
    {
        _TRACE (0, L"CASetCertTypePropertyEx (CERTTYPE_PROP_POLICY) failed: 0x%x\n", 
                hr);
    }

    _TRACE (-1, L"Leaving CCertTemplate::SetCertPolicy: 0x%x\n", hr);
    return hr;
}
void CCertTemplate::FreeCertExtensions()
{
    if ( m_pCertExtensions )
    {
        CAFreeCertTypeExtensions (m_hCertType, m_pCertExtensions);
        m_pCertExtensions = 0;
    }
}

HRESULT CCertTemplate::Cancel()
{
    _TRACE (1, L"Entering CCertTemplate::Cancel\n");
    HRESULT hr = S_OK;

    // Close and re-open cert template without saving.
    if ( m_hCertType )
    {
        FreeCertExtensions ();

        hr = CACloseCertType (m_hCertType);
        _ASSERT (SUCCEEDED (hr));
        if ( SUCCEEDED (hr) )
        {
            m_hCertType = 0;

            // Reinitialize the cert template
            if ( !m_bIsClone )
                hr = Initialize ();
        }
        else
        {
            _TRACE (0, L"CACloseCertType (%s) failed: 0x%x\n", hr);
        }
    }
    else
        hr = E_FAIL;

    _TRACE (-1, L":Leaving CCertTemplate::Cancel: 0x%x\n", hr);
    return hr;
}

/*  NO LONGER NEEDED  NTRAID# 321742
bool CCertTemplate::AllowAutoenrollment()
{
    // Bug 251388 "There are templates that should never be allowed to set 
    // autoenrollment flag (CT_FLAG_AUTO_ENROLLMENT).   The "Allow 
    // Autoenrollment" task for those templates should be disabled if one of 
    // the following three conditions is true:
    //
    // templates whose subject name flag has CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT  
    // set; 	
	// templates whose subject name flag has 
    // CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT_ALT_NAME set; 
	// templates whose CERTTYPE_PROP_RA_SIGNATURE is greater than 1 and 
    // CT_FLAG_PREVIOUS_APPROVAL_VALIDATE_REENROLLMENT is not set in the 
    // enrollment flag."
    bool    bResult = true;
    DWORD   dwNumSignatures = 0;
    
    GetRANumSignaturesRequired (dwNumSignatures);

    // NTRAID# 175912 Version 1 type templates not good for autoenrollment
    if ( 1 == GetType () ||
        (m_dwSubjectNameFlags & CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT) ||
            (m_dwSubjectNameFlags & CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT_ALT_NAME) ||
            ( dwNumSignatures > 1 &&
                !(m_dwEnrollmentFlags & CT_FLAG_PREVIOUS_APPROVAL_VALIDATE_REENROLLMENT)) )
    {
        bResult = false;
    }

    // NTRAID# 276180 Certificate Template Snap-in: Grey out "Allow 
    // Autoenrollment" context menu based on properties of the template
    if ( RequireSubjectInRequest () ||
            dwNumSignatures >= 2 && !ReenrollmentValidWithPreviousApproval () )
    {
        bResult = false;
    }

    return bResult;
}
*/

HRESULT CCertTemplate::GetSubjectTypeDescription (int nIndex, CString &szSubjectTypeDescription)
{
    _TRACE (1, L"Entering CCertTemplate::GetSubjectTypeDescription (nIndex=%d\n", nIndex);
    
    PWSTR*  pawszSubjectTypeDescriptionList = 0;
    HRESULT hr = CAGetCertTypeProperty (m_hCertType, 
            CERTTYPE_PROP_DESCRIPTION,
            &pawszSubjectTypeDescriptionList);
    if ( SUCCEEDED (hr) )
    {
        if ( pawszSubjectTypeDescriptionList )
        {
            int     nCnt = 0;

            while ( pawszSubjectTypeDescriptionList[nCnt] )
                nCnt++;

            if ( nIndex < nCnt )
                szSubjectTypeDescription = pawszSubjectTypeDescriptionList[nIndex];
            else
                hr = E_FAIL;
            LocalFree (pawszSubjectTypeDescriptionList);
       }
        else
            hr = E_FAIL;
    }
    else
    {
        _TRACE (0, L"CAGetCertTypeProperty (CERTTYPE_PROP_DESCRIPTION) failed: 0x%x\n", hr);
    }


    _TRACE (-1, L"Leaving CCertTemplate::GetSubjectTypeDescription (szRAPolicyOID=%s): 0x%x\n", 
            (PCWSTR) szSubjectTypeDescription, hr);
    return hr;
}

// NTRAID# 278356  CertSRV: No CSPs in mmc certificate snapin advanced 
// option list with v2 templates that have ENC and SIG as purpose.
HRESULT CCertTemplate::SetDigitalSignature(
            bool bSet, 
            bool bSetOnlyDigitalSignature /* = false */)
{
    _TRACE (1, L"Entering CCertTemplate::SetDigitalSignature (bSet = %s)\n", bSet ? L"true" : L"false");
    PCERT_EXTENSION pCertExtension = 0;
    HRESULT hr = GetCertExtension (szOID_KEY_USAGE, &pCertExtension);
    if ( SUCCEEDED (hr) )
    {
	    ASSERT (pCertExtension);
	    if ( pCertExtension )
	    {
            DWORD   cbKeyUsage = 0;
		    if ( ::CryptDecodeObject(CRYPT_ASN_ENCODING, 
				    szOID_KEY_USAGE, 
				    pCertExtension->Value.pbData,
				    pCertExtension->Value.cbData,
				    0, NULL, &cbKeyUsage) )
		    {
                CRYPT_BIT_BLOB* pKeyUsage = (CRYPT_BIT_BLOB*)
					    ::LocalAlloc (LPTR, cbKeyUsage);
			    if ( pKeyUsage )
			    {
				    if ( ::CryptDecodeObject (CRYPT_ASN_ENCODING, 
						    szOID_KEY_USAGE, 
						    pCertExtension->Value.pbData,
						    pCertExtension->Value.cbData,
						    0, pKeyUsage, &cbKeyUsage) )
				    {
                        if (pKeyUsage->cbData >= 1)
                        {
                            pKeyUsage->cUnusedBits = 0;

                            if ( bSetOnlyDigitalSignature )
                            {
                                pKeyUsage->pbData[0] = CERT_DIGITAL_SIGNATURE_KEY_USAGE;
                            }
                            else if ( bSet )
                                pKeyUsage->pbData[0] |= CERT_DIGITAL_SIGNATURE_KEY_USAGE;
                            else
                                pKeyUsage->pbData[0] &= ~CERT_DIGITAL_SIGNATURE_KEY_USAGE;

                            hr = SetKeyUsage (pKeyUsage, pCertExtension->fCritical ? true : false);
                        }
                        else
                            hr = E_FAIL;
                    }
                    else
                    {
                        DWORD   dwErr = GetLastError ();
                        hr = HRESULT_FROM_WIN32 (dwErr);
                        _TRACE (0, L"CryptDecodeObject(CRYPT_ASN_ENCODING, szOID_KEY_USAGE) failed: 0x%x\n", dwErr);
                    }
                    LocalFree (pKeyUsage);
                }
                else
                    hr = E_OUTOFMEMORY;
            }
            else
            {
                DWORD   dwErr = GetLastError ();
                hr = HRESULT_FROM_WIN32 (dwErr);
                _TRACE (0, L"CryptDecodeObject(CRYPT_ASN_ENCODING, szOID_KEY_USAGE) failed: 0x%x\n", dwErr);
            }
        }

        FreeCertExtensions ();
    }

    _TRACE (-1, L"Leaving CCertTemplate::SetDigitalSignature (bSet = %s): 0x%x\n", 
            bSet ? L"true" : L"false", hr);
    return hr;
}

HRESULT CCertTemplate::GetDigitalSignature(
        bool &bHasDigitalSignature, 
        bool* pbHasOnlyDigitalSignature /* = 0 */)
{
    _TRACE (1, L"Entering CCertTemplate::GetDigitalSignature ()\n");
    PCERT_EXTENSION pCertExtension = 0;
    HRESULT hr = GetCertExtension (szOID_KEY_USAGE, &pCertExtension);
    if ( SUCCEEDED (hr) )
    {
	    ASSERT (pCertExtension);
	    if ( pCertExtension )
	    {
            DWORD   cbKeyUsage = 0;
		    if ( ::CryptDecodeObject(CRYPT_ASN_ENCODING, 
				    szOID_KEY_USAGE, 
				    pCertExtension->Value.pbData,
				    pCertExtension->Value.cbData,
				    0, NULL, &cbKeyUsage) )
		    {
                CRYPT_BIT_BLOB* pKeyUsage = (CRYPT_BIT_BLOB*)
					    ::LocalAlloc (LPTR, cbKeyUsage);
			    if ( pKeyUsage )
			    {
				    if ( ::CryptDecodeObject (CRYPT_ASN_ENCODING, 
						    szOID_KEY_USAGE, 
						    pCertExtension->Value.pbData,
						    pCertExtension->Value.cbData,
						    0, pKeyUsage, &cbKeyUsage) )
				    {
                        if (pKeyUsage->cbData >= 1)
                        {
                            pKeyUsage->cUnusedBits = 0;

                            if ( pKeyUsage->pbData[0] & CERT_DIGITAL_SIGNATURE_KEY_USAGE )
                                bHasDigitalSignature = true;
                            else
                                bHasDigitalSignature = false;

                            if ( pbHasOnlyDigitalSignature )
                            {
                                if ( pKeyUsage->pbData[0] == CERT_DIGITAL_SIGNATURE_KEY_USAGE )
                                    *pbHasOnlyDigitalSignature = true;
                                else
                                    *pbHasOnlyDigitalSignature = false;
                            }
                        }
                        else
                            hr = E_FAIL;
                    }
                    else
                    {
                        DWORD   dwErr = GetLastError ();
                        hr = HRESULT_FROM_WIN32 (dwErr);
                        _TRACE (0, L"CryptDecodeObject(CRYPT_ASN_ENCODING, szOID_KEY_USAGE) failed: 0x%x\n", dwErr);
                    }
                    LocalFree (pKeyUsage);
                }
                else
                    hr = E_OUTOFMEMORY;
            }
            else
            {
                DWORD   dwErr = GetLastError ();
                hr = HRESULT_FROM_WIN32 (dwErr);
                _TRACE (0, L"CryptDecodeObject(CRYPT_ASN_ENCODING, szOID_KEY_USAGE) failed: 0x%x\n", dwErr);
            }
        }

        FreeCertExtensions ();
    }

    _TRACE (-1, L"Leaving CCertTemplate::GetDigitalSignature (bHasDigitalSignature = %s): 0x%x\n", 
            bHasDigitalSignature ? L"true" : L"false", hr);
    return hr;
}

void CCertTemplate::IssuancePoliciesRequired(bool bRequired)
{
    m_bIssuancePoliciesRequired = bRequired;
}

bool CCertTemplate::IssuancePoliciesRequired() const
{
    return m_bIssuancePoliciesRequired;
}

CString CCertTemplate::GetDN () const
{
    _TRACE (1, L"Entering CCertTemplate::GetDN - m_hCertType = 0x%x\n", m_hCertType);
    HRESULT hr = S_OK;
    CString szDN;

    if ( m_hCertType )
    {
        PWSTR* rgwszProp = 0;

        hr = CAGetCertTypePropertyEx (m_hCertType, 
            CERTTYPE_PROP_DN, &rgwszProp);
        if ( SUCCEEDED (hr) && rgwszProp )
        {
            szDN = *rgwszProp;
            CAFreeCertTypeProperty (m_hCertType, rgwszProp);
        }
        else
        {
            _TRACE (0, L"CAGetCertTypePropertyEx (CERTTYPE_PROP_DN) failed: 0x%x\n", hr);
            szDN = GetObjectName ();
        }
    }
    else
        szDN = GetObjectName ();

    _TRACE (-1, L"Leaving CCertTemplate::GetDN: %s, 0x%x\n", (PCWSTR) szDN, hr);
   return szDN;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\certtmpl.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       CertTmpl.cpp
//
//  Contents:   Implementation of DLL Exports
//
//----------------------------------------------------------------------------


#include "stdafx.h"
#define INITGUID
#pragma warning(push,3)
#include <initguid.h>
#pragma warning(pop)
#include "CertTmpl_i.c"
#include "about.h"      // CCertTemplatesAbout
#include "compdata.h" // CCertTmplSnapin
#include "uuids.h"

#pragma warning(push,3)
#include <ntverp.h>     // VER_PRODUCTVERSION_STR
#include <typeinfo.h>

#define INCL_WINSOCK_API_TYPEDEFS 1
#include <winsock2.h>
#include <svcguid.h>
#include <winldap.h>



#pragma warning(pop)
#include "chooser.cpp"

#include "ShellExt.h"
#include "PolicyOID.h"

extern POLICY_OID_LIST      g_policyOIDList;
USE_HANDLE_MACROS ("CERTTMPL (CertTmpl.cpp)")


//
// This is used by the nodetype utility routines in stdutils.cpp
//

const struct NODETYPE_GUID_ARRAYSTRUCT g_NodetypeGuids[CERTTMPL_NUMTYPES] =
{
    { // CERTTMPL_SNAPIN
        structuuidNodetypeSnapin,
        lstruuidNodetypeSnapin    },
    {  // CERT_TEMPLATE
        structuuidNodetypeCertTemplate,
        lstruuidNodetypeCertTemplate  }
};

const struct NODETYPE_GUID_ARRAYSTRUCT* g_aNodetypeGuids = g_NodetypeGuids;

const int g_cNumNodetypeGuids = CERTTMPL_NUMTYPES;

const CLSID CLSID_CertTemplateShellExt = /* {11BDCE06-D55C-44e9-BC0B-8655F89E8CC5} */
{ 0x11bdce06, 0xd55c, 0x44e9, { 0xbc, 0xb, 0x86, 0x55, 0xf8, 0x9e, 0x8c, 0xc5 } };


HINSTANCE   g_hInstance = 0;
CComModule  _Module;

BEGIN_OBJECT_MAP (ObjectMap)
    OBJECT_ENTRY (CLSID_CertTemplatesSnapin, CCertTmplSnapin)
    OBJECT_ENTRY (CLSID_CertTemplatesAbout, CCertTemplatesAbout)
    OBJECT_ENTRY(CLSID_CertTemplateShellExt, CCertTemplateShellExt)
END_OBJECT_MAP ()

class CCertTmplApp : public CWinApp
{
public:
    CCertTmplApp ();
    virtual ~CCertTmplApp ();
    virtual BOOL InitInstance ();
    virtual int ExitInstance ();
private:
};

CCertTmplApp theApp;

CCertTmplApp::CCertTmplApp ()
{
}

CCertTmplApp::~CCertTmplApp ()
{
}

BOOL CCertTmplApp::InitInstance ()
{
#ifdef _MERGE_PROXYSTUB
    hProxyDll = m_hInstance;

#endif
    g_hInstance = m_hInstance;
    AfxSetResourceHandle (m_hInstance);
    _Module.Init (ObjectMap, m_hInstance);

    AfxInitRichEdit();

#if DBG
    CheckDebugOutputLevel ();
#endif

    SHFusionInitializeFromModuleID (m_hInstance, 2);

    return CWinApp::InitInstance ();
}

int CCertTmplApp::ExitInstance ()
{
    SHFusionUninitialize();

    while ( !g_policyOIDList.IsEmpty () )
    {
        CPolicyOID* pPolicyOID = g_policyOIDList.RemoveHead ();
        if ( pPolicyOID )
            delete pPolicyOID;
    }

    _Module.Term ();
    return CWinApp::ExitInstance ();
}



/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow (void)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    return (AfxDllCanUnloadNow ()==S_OK && _Module.GetLockCount ()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject (REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject (rclsid, riid, ppv);
}





/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer (void)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());

    // registers object, typelib and all interfaces in typelib
    HRESULT hr = _Module.RegisterServer (TRUE);
    ASSERT (SUCCEEDED (hr));
    if ( E_ACCESSDENIED == hr )
    {
        CString caption;
        CString text;
        CThemeContextActivator activator;

        VERIFY (caption.LoadString (IDS_REGISTER_CERTTMPL));
        VERIFY (text.LoadString (IDS_INSUFFICIENT_RIGHTS_TO_REGISTER_CERTTMPL));

        MessageBox (NULL, text, caption, MB_OK);
        return hr;
    }
    try
    {
        CString         strGUID;
        CString         snapinName;
        AMC::CRegKey    rkSnapins;
        BOOL            fFound = rkSnapins.OpenKeyEx (HKEY_LOCAL_MACHINE, SNAPINS_KEY);
        ASSERT (fFound);
        if ( fFound )
        {
            {
                AMC::CRegKey    rkCertTmplSnapin;
                hr = GuidToCString (&strGUID, CLSID_CertTemplatesSnapin);
                if ( FAILED (hr) )
                {
                    ASSERT (FALSE);
                    return SELFREG_E_CLASS;
                }
                rkCertTmplSnapin.CreateKeyEx (rkSnapins, strGUID);
                ASSERT (rkCertTmplSnapin.GetLastError () == ERROR_SUCCESS);
                rkCertTmplSnapin.SetString (g_szNodeType, g_aNodetypeGuids[CERTTMPL_SNAPIN].bstr);
                VERIFY (snapinName.LoadString (IDS_CERTTMPL_REGISTRY));
                rkCertTmplSnapin.SetString (g_szNameString, (PCWSTR) snapinName);
                hr = GuidToCString (&strGUID, CLSID_CertTemplatesAbout);
                if ( FAILED (hr) )
                {
                    ASSERT (FALSE);
                    return SELFREG_E_CLASS;
                }
                rkCertTmplSnapin.SetString (L"About", strGUID);
                rkCertTmplSnapin.SetString (L"Provider", L"Microsoft");
                // security review 2/20/2002 BryanWal ok
                size_t  len = strlen (VER_PRODUCTVERSION_STR);
                PWSTR   pszVer = new WCHAR[len+1];
                if ( pszVer )
                {
                    // security review BryanWal 02/20/2002 ok
                    ::ZeroMemory (pszVer, (len+1) * sizeof (WCHAR));
                    // security review BryanWal 02/20/2002 cnt should be len+1 
                    // to include conversion of NULL char
                    len = ::mbstowcs (pszVer, VER_PRODUCTVERSION_STR, len+1);

                    rkCertTmplSnapin.SetString (L"Version", pszVer);
                    delete [] pszVer;
                }


                AMC::CRegKey rkCertTmplMgrStandalone;
                rkCertTmplMgrStandalone.CreateKeyEx (rkCertTmplSnapin, g_szStandAlone);
                ASSERT (rkCertTmplMgrStandalone.GetLastError () == ERROR_SUCCESS);


                AMC::CRegKey rkMyNodeTypes;
                rkMyNodeTypes.CreateKeyEx (rkCertTmplSnapin, g_szNodeTypes);
                ASSERT (rkMyNodeTypes.GetLastError () == ERROR_SUCCESS);
                AMC::CRegKey rkMyNodeType;

                for (int i = CERTTMPL_SNAPIN; i < CERTTMPL_NUMTYPES; i++)
                {
                    rkMyNodeType.CreateKeyEx (rkMyNodeTypes, g_aNodetypeGuids[i].bstr);
                    ASSERT (rkMyNodeType.GetLastError () == ERROR_SUCCESS);
                    rkMyNodeType.CloseKey ();
                }

                //
                // BryanWal 5/18/00
                // 94793: MUI: MMC: Certificates snap-in stores its display 
                //              information in the registry
                //
                // MMC now supports NameStringIndirect
                //
                // NTRAID# Bug9 611500 prefast: certtmpl: certtmpl.cpp(247) : 
                // warning 53: Call to 'GetModuleFileNameW' may not 
                // zero-terminate string 'achModuleFileName'.
                // Fix by zero'ing out the buffer and passing in 1 less than
                // the buffer size to GetModuleFileName
                WCHAR achModuleFileName[MAX_PATH+20];
                ::ZeroMemory (achModuleFileName, sizeof(achModuleFileName)/sizeof(WCHAR));
                if (0 != ::GetModuleFileName(
                             AfxGetInstanceHandle(),
                             achModuleFileName,
                             sizeof(achModuleFileName)/sizeof(WCHAR) - 1))
                {
                    CString strNameIndirect;
                    strNameIndirect.Format (L"@%s,-%d",
                                            achModuleFileName,
                                            IDS_CERTTMPL_REGISTRY);
                    rkCertTmplSnapin.SetString (L"NameStringIndirect",
                                            strNameIndirect );
                }

                rkCertTmplSnapin.CloseKey ();
            }

            AMC::CRegKey rkNodeTypes;
            fFound = rkNodeTypes.OpenKeyEx (HKEY_LOCAL_MACHINE, NODE_TYPES_KEY);
            ASSERT (fFound);
            if ( fFound )
            {
                AMC::CRegKey rkNodeType;

                for (int i = CERTTMPL_SNAPIN; i < CERTTMPL_NUMTYPES; i++)
                {
                    rkNodeType.CreateKeyEx (rkNodeTypes, g_aNodetypeGuids[i].bstr);
                    ASSERT (rkNodeType.GetLastError () == ERROR_SUCCESS);
                    rkNodeType.CloseKey ();
                }


                rkNodeTypes.CloseKey ();
            }
            else
                return SELFREG_E_CLASS;
        }
        else
            return SELFREG_E_CLASS;
    }
    catch (COleException* e)
    {
        ASSERT (FALSE);
        e->Delete ();
        return SELFREG_E_CLASS;
    }

    ASSERT (SUCCEEDED (hr));
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer (void)
{
    LRESULT         lResult = 0;

    try
    {
        AMC::CRegKey    rkSnapins;
        BOOL            fFound = FALSE;

        do
        {
            CString         strGUID;
            CString         snapinName;
            
            fFound = rkSnapins.OpenKeyEx (HKEY_LOCAL_MACHINE, SNAPINS_KEY);
            ASSERT (fFound);
            if ( fFound )
            {
                {
                    AMC::CRegKey    rkCertTmplSnapin;
                    HRESULT         hr = GuidToCString (&strGUID, CLSID_CertTemplatesSnapin);
                    if ( FAILED (hr) )
                    {
                        ASSERT (FALSE);
                        lResult = SELFREG_E_CLASS;
                        break;
                    }

                    lResult = RegDelnode (rkSnapins, (PCWSTR) strGUID);
                }

                AMC::CRegKey rkNodeTypes;
                fFound = rkNodeTypes.OpenKeyEx (HKEY_LOCAL_MACHINE, NODE_TYPES_KEY);
                ASSERT (fFound);
                if ( fFound )
                {
                    for (int i = CERTTMPL_SNAPIN; i < CERTTMPL_NUMTYPES; i++)
                    {
                        lResult = RegDelnode (rkNodeTypes, g_aNodetypeGuids[i].bstr);
                    }


                    rkNodeTypes.CloseKey ();
                }
                else
                {
                    lResult = SELFREG_E_CLASS;
                    break;
                }
            }
            else
            {
                lResult = SELFREG_E_CLASS;
                break;
            }
        } while (0);

        if ( fFound )
            rkSnapins.CloseKey ();
    }
    catch (COleException* e)
    {
        ASSERT (FALSE);
        e->Delete ();
        lResult = SELFREG_E_CLASS;
    }

    if ( SELFREG_E_CLASS != lResult )
        _Module.UnregisterServer ();

    return HRESULT_FROM_WIN32 (lResult);
}

STDAPI DllInstall(BOOL /*bInstall*/, PCWSTR /*pszCmdLine*/)
{
    return S_OK;
}





///////////////////////////////////////////////////////////////////////////////
//  FormatDate ()
//
//  utcDateTime (IN)    -   A FILETIME in UTC format.
//  pszDateTime (OUT)   -   A string containing the local date and time
//                          formatted by locale and user preference
//
///////////////////////////////////////////////////////////////////////////////
HRESULT FormatDate (FILETIME utcDateTime, CString & pszDateTime)
{
    //  Time is returned as UTC, will be displayed as local.
    //  Use FileTimeToLocalFileTime () to make it local,
    //  then call FileTimeToSystemTime () to convert to system time, then
    //  format with GetDateFormat () and GetTimeFormat () to display
    //  according to user and locale preferences
    HRESULT     hr = S_OK;
    FILETIME    localDateTime;

    BOOL bResult = FileTimeToLocalFileTime (&utcDateTime, // pointer to UTC file time to convert
            &localDateTime); // pointer to converted file time
    ASSERT (bResult);
    if ( bResult )
    {
        SYSTEMTIME  sysTime;

        bResult = FileTimeToSystemTime (
                &localDateTime, // pointer to file time to convert
                &sysTime); // pointer to structure to receive system time
        if ( bResult )
        {
            CString date;
            CString time;

            // Get date
            // Get length to allocate buffer of sufficient size
            int iLen = GetDateFormat (
                    LOCALE_USER_DEFAULT, // locale for which date is to be formatted
                    0, // flags specifying function options
                    &sysTime, // date to be formatted
                    0, // date format string
                    0, // buffer for storing formatted string
                    0); // size of buffer
            ASSERT (iLen > 0);
            if ( iLen > 0 )
            {
                int iResult = GetDateFormat (
                        LOCALE_USER_DEFAULT, // locale for which date is to be formatted
                        0, // flags specifying function options
                        &sysTime, // date to be formatted
                        0, // date format string
                        date.GetBufferSetLength (iLen), // buffer for storing formatted string
                        iLen); // size of buffer
                ASSERT (iResult);
                date.ReleaseBuffer ();
                if ( iResult )
                    pszDateTime = date;
                else
                    hr = HRESULT_FROM_WIN32 (GetLastError ());

                if ( iResult )
                {
                    // Get time
                    // Get length to allocate buffer of sufficient size
                    iLen = GetTimeFormat (
                            LOCALE_USER_DEFAULT, // locale for which date is to be formatted
                            0, // flags specifying function options
                            &sysTime, // date to be formatted
                            0, // date format string
                            0, // buffer for storing formatted string
                            0); // size of buffer
                    ASSERT (iLen > 0);
                    if ( iLen > 0 )
                    {
                        iResult = GetTimeFormat (
                                LOCALE_USER_DEFAULT, // locale for which date is to be formatted
                                0, // flags specifying function options
                                &sysTime, // date to be formatted
                                0, // date format string
                                time.GetBufferSetLength (iLen), // buffer for storing formatted string
                                iLen); // size of buffer
                        ASSERT (iResult);
                        time.ReleaseBuffer ();
                        if ( iResult )
                        {
                            pszDateTime = date + L"  " + time;
                        }
                        else
                            hr = E_UNEXPECTED;
                    }
                    else
                        hr = E_UNEXPECTED;
                }
                else
                    hr = E_UNEXPECTED;
            }
            else
            {
                hr = HRESULT_FROM_WIN32 (GetLastError ());
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32 (GetLastError ());
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
    }

    return hr;
}


void DisplaySystemError (HWND hParent, DWORD dwErr)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    LPVOID  lpMsgBuf;

    // security review BryanWal 2/20/2002 ok because message is from system
    FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            dwErr,
            MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
             (PWSTR) &lpMsgBuf,    0,    NULL);

    // Display the string.
    CThemeContextActivator activator;
    CString caption;
    VERIFY (caption.LoadString (IDS_CERTTMPL));
    ::MessageBox (hParent, (PWSTR) lpMsgBuf, (PCWSTR) caption, MB_OK);
    // Free the buffer.
    LocalFree (lpMsgBuf);
}


bool IsWindowsNT()
{
    OSVERSIONINFO   versionInfo;

    // security review BryanWal 2/20/2002 ok 
    ::ZeroMemory (&versionInfo, sizeof (versionInfo));
    versionInfo.dwOSVersionInfoSize = sizeof (versionInfo);
    BOOL    bResult = ::GetVersionEx (&versionInfo);
    ASSERT (bResult);
    if ( bResult )
    {
        if ( VER_PLATFORM_WIN32_NT == versionInfo.dwPlatformId )
            bResult = TRUE;
    }

    return bResult ? true : false;
}





////// This stuff was stolen from windows\gina\snapins\gpedit (eric flo's stuff) //////

//*************************************************************
//
//  RegDelnodeRecurse()
//
//  Purpose:    Deletes a registry key and all it's subkeys / values.
//              Called by RegDelnode
//
//  Parameters: hKeyRoot    -   Root key
//              pwszSubKey    -   SubKey to delete
//
//  Return:     ERROR_SUCCESS if successful
//              something else if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/3/95     ericflo    Created
//              5/13/98     BryanWal   Modified to return LRESULT
//
//*************************************************************

LRESULT RegDelnodeRecurse (HKEY hKeyRoot, CString szSubKey)
{
    ASSERT (hKeyRoot && !szSubKey.IsEmpty ());
    if ( !hKeyRoot || szSubKey.IsEmpty () )
        return ERROR_INVALID_PARAMETER;

    //
    // First, see if we can delete the key without having
    // to recurse.
    //


    LONG    lResult = ::RegDeleteKey(hKeyRoot, szSubKey);
    if (lResult == ERROR_SUCCESS) 
    {
        return lResult;
    }


    HKEY    hKey = 0;
    lResult = ::RegOpenKeyEx (hKeyRoot, szSubKey, 0, KEY_READ, &hKey);
    if (lResult == ERROR_SUCCESS) 
    {
        // ensure szSubKey ends with a slash
        if ( L'\\' != szSubKey.GetAt (szSubKey.GetLength () - 1) )
        {
            szSubKey += L"\\";
        }

        //
        // Enumerate the keys
        //

        DWORD       dwSize = MAX_PATH;
        FILETIME    ftWrite;
        WCHAR       szName[MAX_PATH];
        lResult = ::RegEnumKeyEx(hKey, 0, 
                    szName, 
                    &dwSize,    // size in TCHARS of szName, including terminating NULL (on input)
                    NULL,
                    NULL, NULL, &ftWrite);
        if (lResult == ERROR_SUCCESS) 
        {
            do {
                if ( ERROR_SUCCESS != RegDelnodeRecurse (hKeyRoot, szSubKey + szName) ) 
                {
                    break;
                }

                //
                // Enumerate again
                //

                dwSize = MAX_PATH;

                lResult = ::RegEnumKeyEx(hKey, 0, 
                            szName, 
                            &dwSize,     // size in TCHARS of szName, including terminating NULL (on input)
                            NULL,
                            NULL, NULL, &ftWrite);


            } while (lResult == ERROR_SUCCESS);
        }


        ::RegCloseKey (hKey);
    }

    // remove slash from szSubKey
    szSubKey.Delete (szSubKey.GetLength () - 1, 1);

    //
    // Try again to delete the key
    //

    lResult = ::RegDeleteKey(hKeyRoot, szSubKey);
    if (lResult == ERROR_SUCCESS) 
    {
        return lResult;
    }

    return lResult;
}

//*************************************************************
//
//  RegDelnode()
//
//  Purpose:    Deletes a registry key and all it's subkeys / values
//
//  Parameters: hKeyRoot    -   Root key
//              pwszSubKey    -   SubKey to delete
//
//  Return:     ERROR_SUCCESS if successful
//              something else if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/3/95     ericflo    Created
//              5/13/98     BryanWal   Modified to return LRESULT
//
//*************************************************************

LRESULT RegDelnode (HKEY hKeyRoot, CString szSubKey)
{
    ASSERT (hKeyRoot && !szSubKey.IsEmpty ());
    if ( !hKeyRoot || szSubKey.IsEmpty () )
        return ERROR_INVALID_PARAMETER;

    return RegDelnodeRecurse (hKeyRoot, szSubKey);
}


//+--------------------------------------------------------------------------
//
//  Function:   InitObjectPickerForDomainComputers
//
//  Synopsis:   Call IDsObjectPicker::Initialize with arguments that will
//              set it to allow the user to pick a single computer object.
//
//  Arguments:  [pDsObjectPicker] - object picker interface instance
//
//  Returns:    Result of calling IDsObjectPicker::Initialize.
//
//  History:    10-14-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT InitObjectPickerForDomainComputers(IDsObjectPicker *pDsObjectPicker)
{
    //
    // Prepare to initialize the object picker.
    // Set up the array of scope initializer structures.
    //

    static const int     SCOPE_INIT_COUNT = 1;
    DSOP_SCOPE_INIT_INFO aScopeInit[SCOPE_INIT_COUNT];


    // security review BryanWal 02/02/2002 ok
    ::ZeroMemory(aScopeInit, sizeof(aScopeInit));

    //
    // Since we just want computer objects from every scope, combine them
    // all in a single scope initializer.
    //

    aScopeInit[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[0].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
                           | DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;
    aScopeInit[0].FilterFlags.Uplevel.flBothModes =
            DSOP_FILTER_COMPUTERS;
    aScopeInit[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

    //
    // Put the scope init array into the object picker init array
    //

    DSOP_INIT_INFO  InitInfo;
    // security review BryanWal 02/02/2002 ok
    ::ZeroMemory(&InitInfo, sizeof(InitInfo));

    InitInfo.cbSize = sizeof(InitInfo);
    InitInfo.pwzTargetComputer = NULL;  // NULL == local machine
    InitInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
    InitInfo.aDsScopeInfos = aScopeInit;

    //
    // Note object picker makes its own copy of InitInfo.  Also note
    // that Initialize may be called multiple times, last call wins.
    //

    return pDsObjectPicker->Initialize(&InitInfo);
}


CString GetSystemMessage (DWORD dwErr)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    CString message;

    if ( HRESULT_FROM_WIN32 (ERROR_NO_SUCH_DOMAIN) == dwErr )
    {
        VERIFY (message.LoadString (IDS_ERROR_NO_SUCH_DOMAIN));
    }
    else
    {
        LPVOID lpMsgBuf = 0;

        // security review BryanWal 02/02/2002 ok because message is from system
        FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                dwErr,
                MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                 (PWSTR) &lpMsgBuf,    0,    NULL );
        message = (PWSTR) lpMsgBuf;

        // Remove white space (including new line characters)
        message.TrimRight ();

        // Free the buffer.
        LocalFree (lpMsgBuf);
    }

    return message;
}

//+---------------------------------------------------------------------------
//
//  Function:   LocaleStrCmp
//
//  Synopsis:   Do a case insensitive string compare that is safe for any
//              locale.
//
//  Arguments:  [ptsz1] - strings to compare
//              [ptsz2]
//
//  Returns:    -1, 0, or 1 just like lstrcmpi
//
//  History:    10-28-96   DavidMun   Created
//
//  Notes:      This is slower than lstrcmpi, but will work when sorting
//              strings even in Japanese.
//
//----------------------------------------------------------------------------

int LocaleStrCmp(LPCWSTR ptsz1, LPCWSTR ptsz2)
{
    ASSERT (ptsz1 && ptsz2);
    if ( !ptsz1 || !ptsz2 )
        return 0;

    int iRet = 0;

    iRet = CompareString(LOCALE_USER_DEFAULT,
                         NORM_IGNORECASE        |
                           NORM_IGNOREKANATYPE  |
                           NORM_IGNOREWIDTH,
                         ptsz1,
                         -1,
                         ptsz2,
                         -1);

    if (iRet)
    {
        iRet -= 2;  // convert to lstrcmpi-style return -1, 0, or 1

        if ( 0 == iRet )
        {
            UNICODE_STRING unistr1;
            UNICODE_STRING unistr2;

            // security review 2/20/2002 BryanWal ok - Length is length in BYTES
            ::RtlInitUnicodeString (&unistr1, ptsz1);

            // security review 2/20/2002 BryanWal ok - Length is length in BYTES
            ::RtlInitUnicodeString (&unistr2, ptsz2);
            
            iRet = ::RtlCompareUnicodeString(
                &unistr1,
                &unistr2,
                FALSE );
        }
    }
    else
    {
        DWORD   dwErr = GetLastError ();
        _TRACE (0, L"CompareString (%s, %s) failed: 0x%x\n", ptsz1, ptsz2, dwErr);
    }
    return iRet;
}


void FreeStringArray (PWSTR* rgpszStrings, DWORD dwAddCount)
{
    if ( rgpszStrings )
    {
        for (DWORD dwIndex = 0; dwIndex < dwAddCount; dwIndex++)
        {
            if ( rgpszStrings[dwIndex] )
                CoTaskMemFree (rgpszStrings[dwIndex]);
        }

        CoTaskMemFree (rgpszStrings);
    }
}

HRESULT DisplayRootNodeStatusBarText (LPCONSOLE pConsole)
{
    if ( !pConsole )
        return E_POINTER;

    _TRACE (1, L"Entering DisplayRootNodeStatusBarText\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ( ));
    CComPtr<IConsole2>  spConsole2;
    HRESULT     hr = pConsole->QueryInterface (IID_PPV_ARG (IConsole2, &spConsole2));
    if (SUCCEEDED (hr))
    {
        CString statusText;
        VERIFY (statusText.LoadString (IDS_ROOTNODE_STATUSBAR_TEXT));
        hr = spConsole2->SetStatusText ((PWSTR)(PCWSTR) statusText);
    }

    _TRACE (-1, L"Leaving DisplayRootNodeStatusBarText: 0x%x\n", hr);
    return hr;
}

HRESULT DisplayObjectCountInStatusBar (LPCONSOLE pConsole, DWORD dwCnt)
{
    if ( !pConsole )
        return E_POINTER;

    _TRACE (1, L"Entering DisplayObjectCountInStatusBar- %d, %s\n",
            dwCnt, L"Certificate Templates");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ( ));
    CComPtr<IConsole2>  spConsole2;
    HRESULT     hr = pConsole->QueryInterface (IID_PPV_ARG (IConsole2, &spConsole2));
    if (SUCCEEDED (hr))
    {
        CString statusText;
        UINT    formatID = 0;

        switch (dwCnt)
        {
        case -1:
            statusText = L"";
            break;

        case 1:
            VERIFY (statusText.LoadString (IDS_CERT_TEMPLATE_COUNT_SINGLE));
            break;

        default:
            formatID = IDS_CERT_TEMPLATE_COUNT;
            break;
        }

        if ( formatID )
        {
            // security review BryanWal 02/02/2002 ok
            statusText.FormatMessage (formatID, dwCnt);
        }

        hr = spConsole2->SetStatusText ((PWSTR)(PCWSTR) statusText);
    }

    _TRACE (-1, L"Leaving DisplayObjectCountInStatusBar: 0x%x\n", hr);
    return hr;
}


PCWSTR GetContextHelpFile ()
{
    static CString strHelpTopic;

    if ( strHelpTopic.IsEmpty () )
    {
        UINT nLen = ::GetSystemWindowsDirectory (strHelpTopic.GetBufferSetLength(2 * MAX_PATH), 2 * MAX_PATH);
        strHelpTopic.ReleaseBuffer();
        if (0 == nLen)
        {
            ASSERT(FALSE);
            return 0;
        }

        strHelpTopic += CERTTMPL_HELP_PATH; 
        strHelpTopic += CERTTMPL_CONTEXT_HELP_FILE;
    }

    return (PCWSTR) strHelpTopic;
}

bool MyGetOIDInfoA (CString & string, LPCSTR pszObjId)
{   
    ASSERT (pszObjId);
    if ( !pszObjId )
        return false;

    PCCRYPT_OID_INFO    pOIDInfo;  // This points to a constant data structure and must not be freed.
    bool                bResult = false;

    // NTRAID# 479067 Certtmpl UI: Title bar and descriptive text incorrect
    if ( !strcmp (szOID_CERT_POLICIES, pszObjId) )
    {
        VERIFY (string.LoadString (IDS_ISSUANCE_POLICIES));
        bResult = true;
    }
    else
    {
        string = L"";
        pOIDInfo = ::CryptFindOIDInfo (CRYPT_OID_INFO_OID_KEY, (void *) pszObjId, 0);

        if ( pOIDInfo )
        {
            string = pOIDInfo->pwszName;
            bResult = true;
        }
        else
        {
            for (POSITION nextPos = g_policyOIDList.GetHeadPosition (); nextPos; )
            {
                CPolicyOID* pPolicyOID = g_policyOIDList.GetNext (nextPos);
                if ( pPolicyOID )
                {
                    if ( !strcmp (pPolicyOID->GetOIDA (), pszObjId) )
                    {
                        string = pPolicyOID->GetDisplayName ();
                        bResult = true;
                        break;
                    }
                }
            }

            if ( !bResult )
            {
                // security review BryanWal 02/02/2002 ok
                int nLen = ::MultiByteToWideChar (CP_ACP, 0, pszObjId, -1, NULL, 0);
                ASSERT (nLen > 0);
                if ( nLen > 0)
                {
                    // security review BryanWal 02/02/2002 ok
                    // NOTICE: GetBufferSetLength () takes len not including trailing NULL,
                    // returns NULL on failure. MultiByteToWideChar () handles NULL arg.
                    nLen = ::MultiByteToWideChar (CP_ACP, 0, pszObjId, -1, 
                            string.GetBufferSetLength (nLen), nLen);
                    ASSERT (nLen > 0);
                    string.ReleaseBuffer ();
                }
                bResult = (nLen > 0) ? true : false;
            }
        }
    }

    return bResult;
}

#define REGSZ_ENABLE_CERTTYPE_EDITING L"EnableCertTypeEditing"

bool IsCerttypeEditingAllowed()
{
    DWORD   lResult;
    HKEY    hKey = NULL;
    DWORD   dwType;
    DWORD   dwEnabled = 0;
    DWORD   cbEnabled = sizeof(dwEnabled);
    lResult = RegOpenKeyEx (HKEY_CURRENT_USER, 
                            L"Software\\Microsoft\\Cryptography\\CertificateTemplateCache", 
                            0, 
                            KEY_READ,
                            &hKey);

    if (lResult == ERROR_SUCCESS) 
    {
        // security review BryanWal 02/02/2002 ok
        lResult = RegQueryValueEx(hKey, 
                  REGSZ_ENABLE_CERTTYPE_EDITING,  
                  NULL,
                  &dwType,
                  (PBYTE)&dwEnabled,
                  &cbEnabled);
        if(lResult == ERROR_SUCCESS)
        {
            if(dwType != REG_DWORD)
            {
                dwEnabled = 0;
            }
        }
        RegCloseKey (hKey);
    }


    return (dwEnabled != 0);
}

BOOL EnumOIDInfo (PCCRYPT_OID_INFO pInfo, void* /*pvArg*/)
{
    BOOL    bRVal = TRUE;

    if ( pInfo && pInfo->pszOID )
    {
        // NTRAID# 463344 Certtmpl.msc: Remove "All Application Policies" from 
        // Extensions selection list in Certtmpl.msc -- break Enrollment
        if ( !strcmp (szOID_ANY_APPLICATION_POLICY, pInfo->pszOID) )
            return TRUE;


        for (POSITION nextPos = g_policyOIDList.GetHeadPosition (); nextPos; )
        {
            CPolicyOID* pPolicyOID = g_policyOIDList.GetNext (nextPos);
            if ( pPolicyOID )
            {
                if ( !strcmp (pPolicyOID->GetOIDA (), pInfo->pszOID) )
                    return TRUE; // duplicate found, get next
            }
        }

        int flags = 0;
        if ( CRYPT_ENHKEY_USAGE_OID_GROUP_ID == pInfo->dwGroupId )
            flags = CERT_OID_TYPE_APPLICATION_POLICY;
        else if ( CRYPT_POLICY_OID_GROUP_ID == pInfo->dwGroupId )
            flags = CERT_OID_TYPE_ISSUER_POLICY;
        else
        {
            ASSERT (0);
            return TRUE;
        }

        CPolicyOID* pPolicyOID = new CPolicyOID (pInfo->pszOID, pInfo->pwszName,
                flags, false);
        if ( pPolicyOID )
        {
            g_policyOIDList.AddTail (pPolicyOID);
        }
        else
            bRVal = FALSE;
    }
    else
        bRVal = FALSE;

    return bRVal;
}
 

HRESULT GetBuiltInOIDs ()
{
    HRESULT hr = S_OK;

    CryptEnumOIDInfo (
            CRYPT_ENHKEY_USAGE_OID_GROUP_ID,
            0,
            0,
            EnumOIDInfo);

    CryptEnumOIDInfo (
            CRYPT_POLICY_OID_GROUP_ID,
            0,
            0,
            EnumOIDInfo);

    return hr;
}

HRESULT EnumerateOIDs (
        IDirectoryObject* pOIDContObj)
{
    _TRACE (1, L"Entering EnumerateOIDs\n");

    CComPtr<IDirectorySearch>   spDsSearch;
    HRESULT hr = pOIDContObj->QueryInterface (IID_PPV_ARG(IDirectorySearch, &spDsSearch));
    if ( SUCCEEDED (hr) )
    {
        ASSERT (!!spDsSearch);
        ADS_SEARCHPREF_INFO pSearchPref[1];
        DWORD dwNumPref = 1;

        pSearchPref[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
        pSearchPref[0].vValue.dwType = ADSTYPE_INTEGER;
        pSearchPref[0].vValue.Integer = ADS_SCOPE_ONELEVEL;

        hr = spDsSearch->SetSearchPreference(
                 pSearchPref,
                 dwNumPref
                 );
        if ( SUCCEEDED (hr) )
        {
            static const DWORD  cAttrs = 3;
            static PWSTR        rgszAttrList[cAttrs] = {OID_PROP_DISPLAY_NAME, OID_PROP_OID, OID_PROP_TYPE};
            ADS_SEARCH_HANDLE   hSearchHandle = 0;
            wstring             strQuery;
            ADS_SEARCH_COLUMN   Column;

            Column.pszAttrName = 0;
            strQuery = L"objectClass=msPKI-Enterprise-Oid";

            hr = spDsSearch->ExecuteSearch(
                                 const_cast <PWSTR>(strQuery.c_str ()),
                                 rgszAttrList,
                                 cAttrs,
                                 &hSearchHandle
                                 );
            if ( SUCCEEDED (hr) )
            {
                while ((hr = spDsSearch->GetNextRow (hSearchHandle)) != S_ADS_NOMORE_ROWS )
                {
                    if (FAILED(hr))
                        continue;

                    //
                    // Getting current row's information
                    //
                    hr = spDsSearch->GetColumn(
                             hSearchHandle,
                             rgszAttrList[0],
                             &Column
                             );
                    if ( SUCCEEDED (hr) )
                    {
                        CString strDisplayName = Column.pADsValues->CaseIgnoreString;

                        spDsSearch->FreeColumn (&Column);
                        Column.pszAttrName = NULL;

                        hr = spDsSearch->GetColumn(
                                 hSearchHandle,
                                 rgszAttrList[1],
                                 &Column
                                 );
                        if ( SUCCEEDED (hr) )
                        {
                            bool    bOIDFound = false;
                            CString strOID = Column.pADsValues->CaseIgnoreString;
                            spDsSearch->FreeColumn (&Column);

                            for (POSITION nextPos = g_policyOIDList.GetHeadPosition (); nextPos; )
                            {
                                CPolicyOID* pPolicyOID = g_policyOIDList.GetNext (nextPos);
                                if ( pPolicyOID )
                                {
                                    if ( pPolicyOID->GetOIDW () == strOID )
                                    {
                                        bOIDFound = true;
                                        break;
                                    }
                                }
                            }

                            if ( !bOIDFound )
                            {
                                Column.pszAttrName = NULL;

                                hr = spDsSearch->GetColumn(
                                         hSearchHandle,
                                         rgszAttrList[2],
                                         &Column
                                         );
                                if ( SUCCEEDED (hr) )
                                {
                                    ADS_INTEGER flags = Column.pADsValues->Integer;
                                    spDsSearch->FreeColumn (&Column);
                                    Column.pszAttrName = NULL;

                                    // Only add issuance and application OIDs to the list
                                    if ( CERT_OID_TYPE_ISSUER_POLICY == flags || 
                                        CERT_OID_TYPE_APPLICATION_POLICY == flags )
                                    {
                                        CPolicyOID* pPolicyOID = new CPolicyOID (strOID, strDisplayName, flags);
                                        if ( pPolicyOID )
                                        {
                                            g_policyOIDList.AddTail (pPolicyOID);
                                        }
                                        else
                                            break;
                                    }
                                }
                            }
                        }
                    }
                    else if ( hr != E_ADS_COLUMN_NOT_SET )
                    {
                        break;
                    }
                    else
                    {
                        _TRACE (0, L"IDirectorySearch::GetColumn () failed: 0x%x\n", hr);
                    }
                }
            }
            else
            {
                _TRACE (0, L"IDirectorySearch::ExecuteSearch () failed: 0x%x\n", hr);
            }

            spDsSearch->CloseSearchHandle(hSearchHandle);
        }
        else
        {
            _TRACE (0, L"IDirectorySearch::SetSearchPreference () failed: 0x%x\n", hr);
        }
    }
    else
    {
        _TRACE (0, L"IDirectoryObject::QueryInterface (IDirectorySearch) failed: 0x%x\n", hr);
    }

    _TRACE (-1, L"Leaving EnumerateOIDs: 0x%x\n", hr);
    return hr;
}


HRESULT GetEnterpriseOIDs ()
{
    _TRACE (1, L"Entering GetEnterpriseOIDs\n");
    AFX_MANAGE_STATE(AfxGetStaticModuleState());    
    HRESULT hr = S_OK;

    // Empty the list first
    while ( !g_policyOIDList.IsEmpty () )
    {
        CPolicyOID* pPolicyOID = g_policyOIDList.RemoveHead ();
        if ( pPolicyOID )
            delete pPolicyOID;
    }

    hr = GetBuiltInOIDs ();
    
    if ( SUCCEEDED (hr) )
    {
        CComPtr<IADsPathname> spPathname;
        //
        // Constructing the directory paths
        //
        // security review BryanWal 02/02/2002 ok
        hr = CoCreateInstance(
                    CLSID_Pathname,
                    NULL,
                    CLSCTX_ALL,
                    IID_PPV_ARG (IADsPathname, &spPathname));
        if ( SUCCEEDED (hr) )
        {
            CComBSTR    bstrPathElement;
            ASSERT (!!spPathname);

            bstrPathElement = CERTTMPL_LDAP;
            hr = spPathname->Set(bstrPathElement, ADS_SETTYPE_PROVIDER);
            if ( SUCCEEDED (hr) )
            {
                //
                // Open the root DSE object
                //
                bstrPathElement = CERTTMPL_ROOTDSE;
                hr = spPathname->AddLeafElement(bstrPathElement);
                if ( SUCCEEDED (hr) )
                {
                    BSTR bstrFullPath = 0;
                    hr = spPathname->Retrieve(ADS_FORMAT_X500, &bstrFullPath);
                    if ( SUCCEEDED (hr) )
                    {
                        CComPtr<IADs> spRootDSEObject;
                        VARIANT varNamingContext;


                        hr = ADsGetObject (
                              bstrFullPath,
                              IID_PPV_ARG (IADs, &spRootDSEObject));
                        if ( SUCCEEDED (hr) )
                        {
                            ASSERT (!!spRootDSEObject);
                            //
                            // Get the configuration naming context from the root DSE
                            //
                            bstrPathElement = CERTTMPL_CONFIG_NAMING_CONTEXT;
                            hr = spRootDSEObject->Get(bstrPathElement,
                                                 &varNamingContext);
                            if ( SUCCEEDED (hr) )
                            {
                                hr = spPathname->Set(V_BSTR(&varNamingContext),
                                                    ADS_SETTYPE_DN);
                                if ( SUCCEEDED (hr) )
                                {
                                    bstrPathElement = L"CN=Services";
                                    hr = spPathname->AddLeafElement (bstrPathElement);
                                    if ( SUCCEEDED (hr) )
                                    {
                                        bstrPathElement = L"CN=Public Key Services";
                                        hr = spPathname->AddLeafElement (bstrPathElement);
                                        if ( SUCCEEDED (hr) )
                                        {
                                            bstrPathElement = L"CN=OID";
                                            hr = spPathname->AddLeafElement (bstrPathElement);
                                            if ( SUCCEEDED (hr) )
                                            {
                                                BSTR bstrOIDPath = 0;
                                                hr = spPathname->Retrieve(ADS_FORMAT_X500, &bstrOIDPath);
                                                if ( SUCCEEDED (hr) )
                                                {
                                                    CComPtr<IDirectoryObject> spOIDContObj;

                                                    hr = ADsGetObject (
                                                          bstrOIDPath,
                                                          IID_PPV_ARG (IDirectoryObject, &spOIDContObj));
                                                    if ( SUCCEEDED (hr) )
                                                    {
                                                        hr = EnumerateOIDs (spOIDContObj);
                                                    }
                                                    else
                                                    {
                                                        _TRACE (0, L"ADsGetObject (%s) failed: 0x%x\n", bstrOIDPath, hr);
                                                    }

                                                    SysFreeString (bstrOIDPath);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            else
                            {
                                _TRACE (0, L"IADs::Get (%s) failed: 0x%x\n", CERTTMPL_CONFIG_NAMING_CONTEXT, hr);
                            }
                        }
                        else
                        {
                            _TRACE (0, L"ADsGetObject (%s) failed: 0x%x\n", bstrFullPath, hr);
                        }
                    }
                }
            }
        }
        else
            hr = E_POINTER;
    }

    _TRACE (-1, L"Leaving GetEnterpriseOIDs: 0x%x\n", hr);
    return hr;
}


bool OIDHasValidFormat (PCWSTR pszOidValue, int& rErrorTypeStrID)
{
    ASSERT (pszOidValue);
    if ( !pszOidValue )
        return false;

    _TRACE (1, L"Entering OIDHasValidFormat (%s)\n", pszOidValue);
    rErrorTypeStrID = 0;

    bool    bFormatIsValid = false;
    int nLen = WideCharToMultiByte(
          CP_ACP,                   // code page
          0,                        // performance and mapping flags
          pszOidValue,              // wide-character string
          -1,                       // -1 - calculate length of null-terminated string automatically
          0,                        // buffer for new string
          0,                        // size of buffer - 0 causes API to return length including null terminator
          0,                        // default for unmappable chars
          0);                       // set when default char used
    if ( nLen > 0 )
    {
        PSTR    pszAnsiBuf = new char[nLen];
        if ( pszAnsiBuf )
        {
            // security review BryanWal 02/02/2002 ok
            ZeroMemory (pszAnsiBuf, nLen*sizeof(char));
            // security review BryanWal 02/02/2002 ok
            nLen = WideCharToMultiByte(
                    CP_ACP,                 // code page
                    0,                      // performance and mapping flags
                    pszOidValue,            // wide-character string
                    -1,                     // -1 - calculate length of null-terminated string automatically
                    pszAnsiBuf,             // buffer for new string
                    nLen,                   // size of buffer
                    0,                      // default for unmappable chars
                    0);                     // set when default char used
            if ( nLen )
            {
                // According to PhilH:
                // The first number is limited to 
                // 0,1 or 2. The second number is 
                // limited to 0 - 39 when the first 
                // number is 0 or 1. Otherwise, any 
                // number.
                // Also, according to X.208, there 
                // must be at least 2 numbers.
                bFormatIsValid = true;
                // security review 2/20/2002 BryanWal ok
                size_t cbAnsiBufLen = strlen (pszAnsiBuf);

                // check for only digits and "."
                size_t nIdx = strspn (pszAnsiBuf, "0123456789.\0");
                if ( nIdx > 0 && nIdx < cbAnsiBufLen )
                {
                    bFormatIsValid = false;
                    rErrorTypeStrID = IDS_OID_CONTAINS_NON_DIGITS;
                }

                // check for consecutive "."s - string not valid if present
                if ( bFormatIsValid && strstr (pszAnsiBuf, "..") )
                {
                    bFormatIsValid = false;
                    rErrorTypeStrID = IDS_OID_CONTAINS_CONSECUTIVE_DOTS;
                }
                

                // must begin with "0." or "1." or "2."
                bool bFirstNumberIs0 = false;
                bool bFirstNumberIs1 = false;
                bool bFirstNumberIs2 = false;
                if ( bFormatIsValid )
                {
                    if ( !strncmp (pszAnsiBuf, "0.", 2) )
                        bFirstNumberIs0 = true;
                    else if ( !strncmp (pszAnsiBuf, "1.", 2) )
                        bFirstNumberIs1 = true;
                    else if ( !strncmp (pszAnsiBuf, "2.", 2) )
                        bFirstNumberIs2 = true;
                    
                    if ( !bFirstNumberIs0 && !bFirstNumberIs1 && !bFirstNumberIs2 )
                    {
                        bFormatIsValid = false;
                        rErrorTypeStrID = IDS_OID_MUST_START_WITH_0_1_2;
                    }
                }

                if ( bFormatIsValid && ( bFirstNumberIs0 || bFirstNumberIs1 ) )
                {
                    PSTR pszBuf = pszAnsiBuf;
                    pszBuf += 2;

                    // there must be a number after the dot
                    // security review 2/20/2002 BryanWal ok
                    if ( strlen (pszBuf) )
                    {
                        // truncate the string at the next dot, if any
                        PSTR pszDot = strstr (pszBuf, ".");
                        if ( pszDot )
                            pszDot[0] = 0;

                        // convert the string to a number and check for range 0-39
                        int nValue = atoi (pszBuf);
                        if ( nValue < 0 || nValue > 39 )
                        {
                            bFormatIsValid = false;
                            rErrorTypeStrID = IDS_OID_0_1_MUST_BE_0_TO_39;
                        }
                    }
                    else
                    {
                        bFormatIsValid = false;
                        rErrorTypeStrID = IDS_OID_MUST_HAVE_TWO_NUMBERS;
                    }
                }

                // ensure no trailing "."
                if ( bFormatIsValid )
                {
                    if ( '.' == pszAnsiBuf[cbAnsiBufLen - 1] )
                    {
                        bFormatIsValid = false;
                        rErrorTypeStrID = IDS_OID_CANNOT_END_WITH_DOT;
                    }
                }

                if ( bFormatIsValid )
                {
                    bFormatIsValid = false;
                    CRYPT_ATTRIBUTE cryptAttr;
                    // security review BryanWal 02/02/2002 ok
                    ::ZeroMemory (&cryptAttr, sizeof (cryptAttr));

                    cryptAttr.cValue = 0;
                    cryptAttr.pszObjId = pszAnsiBuf;
                    cryptAttr.rgValue = 0;

                    DWORD   cbEncoded = 0;
                    BOOL bResult = CryptEncodeObject (X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                            PKCS_ATTRIBUTE,
                            &cryptAttr,
                            NULL,
                            &cbEncoded);
                    if ( cbEncoded > 0 )
                    {
                        BYTE* pBuffer = new BYTE[cbEncoded];
                        if ( pBuffer )
                        {
                            bResult = CryptEncodeObject (X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                    PKCS_ATTRIBUTE,
                                    &cryptAttr,
                                    pBuffer,
                                    &cbEncoded);
                            if ( bResult )
                            {   
                                DWORD   cbStructInfo = 0;
                                bResult = CryptDecodeObject (X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                        PKCS_ATTRIBUTE,
                                        pBuffer,
                                        cbEncoded,
                                        0,
                                        0,
                                        &cbStructInfo);
                                if ( cbStructInfo > 0 )
                                {
                                    BYTE* pStructBuf = new BYTE[cbStructInfo];
                                    if ( pStructBuf )
                                    {
                                        bResult = CryptDecodeObject (X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                                PKCS_ATTRIBUTE,
                                                pBuffer,
                                                cbEncoded,
                                                0,
                                                pStructBuf,
                                                &cbStructInfo);
                                        if ( bResult )
                                        {
                                            CRYPT_ATTRIBUTE* pCryptAttr = (CRYPT_ATTRIBUTE*) pStructBuf;
                                            if ( !strcmp (pszAnsiBuf, pCryptAttr->pszObjId) )
                                            {
                                                bFormatIsValid = true;
                                            }
                                        }
                                        delete [] pStructBuf;
                                    }
                                }
                            }
                            delete [] pBuffer;
                        }
                    }
                }
            }
            else
            {
                _TRACE (0, L"WideCharToMultiByte (%s) failed: 0x%x\n", pszOidValue, 
                        GetLastError ());
            }

            delete [] pszAnsiBuf;
        }
    }
    else
    {
        _TRACE (0, L"WideCharToMultiByte (%s) failed: 0x%x\n", pszOidValue, 
                GetLastError ());
    }

    _TRACE (-1, L"Leaving EnumerateOIDs: %s\n", bFormatIsValid ? L"true" : L"false");
    return bFormatIsValid;
}

HPROPSHEETPAGE MyCreatePropertySheetPage(AFX_OLDPROPSHEETPAGE* psp)
{
    ASSERT (psp);
    if ( !psp )
        return 0;

    PROPSHEETPAGE_V3 sp_v3 = {0};
    // security review 2/20/2002 BryanWal ok
    ASSERT (sizeof (sp_v3) >= psp->dwSize);
    if ( sizeof (sp_v3) >= psp->dwSize )
    {
        CopyMemory (&sp_v3, psp, psp->dwSize);
        sp_v3.dwSize = sizeof(sp_v3);
    }
    else
        return 0;

    return (::CreatePropertySheetPage (&sp_v3));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\cmponent.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       cmponent.cpp
//
//  Contents:   Implementation of CCertTmplComponent
//
//----------------------------------------------------------------------------

#include "stdafx.h"

#include "dbg.h"
#include "compdata.h" // CCertTmplComponentData
#include "dataobj.h"
#include "cmponent.h" // CCertTmplComponent
#include "utils.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

DECLARE_INFOLEVEL(CertTmplSnapin)

USE_HANDLE_MACROS ("CERTTMPL (cmponent.cpp)")

#pragma warning(push,3)
#include "stdcmpnt.cpp" // CComponent
#pragma warning(pop)

UINT m_aColumnsSnapinSelected[CERT_TEMPLATES_NUM_COLS+1] =
    {IDS_COLUMN_CERT_TEMPLATE_OBJECT,
        IDS_COLUMN_CERT_TEMPLATE_TYPE,
        IDS_COLUMN_CERT_TEMPLATE_VERSION,
        IDS_COLUMN_CERT_TEMPLATE_AUTOENROLLMENT,
        0};

UINT* m_Columns[CERTTMPL_NUMTYPES] =
    {   
        m_aColumnsSnapinSelected,   // CERTTMPL_SNAPIN (displays certificate templates in the result pane)
        0
    };



UINT** g_aColumns = 0;  // for framework
int** g_aColumnWidths = 0;  // for framework
const int SINGLE_COL_WIDTH = 300;
extern bool g_bDomainIsPresent;

CCertTmplComponent::CCertTmplComponent ()
    : m_pViewedCookie (NULL),
    m_currResultNodeType (CERTTMPL_INVALID),
    m_nSortColumn (COLNUM_CERT_TEMPLATE_OBJECT)
{
    _TRACE (1, L"Entering CCertTmplComponent::CCertTmplComponent\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ( ));

    // security review BryanWal 02/20/2002 ok
    ::ZeroMemory (m_ColumnWidths, sizeof (m_ColumnWidths));

    m_ColumnWidths[CERTTMPL_SNAPIN] = new UINT[CERT_TEMPLATES_NUM_COLS];
    if ( m_ColumnWidths[CERTTMPL_SNAPIN] )
    {
        m_ColumnWidths[CERTTMPL_SNAPIN][COLNUM_CERT_TEMPLATE_OBJECT] = 250;
        m_ColumnWidths[CERTTMPL_SNAPIN][COLNUM_CERT_TEMPLATE_TYPE] = 150;
        m_ColumnWidths[CERTTMPL_SNAPIN][COLNUM_CERT_TEMPLATE_VERSION] = 50;
        m_ColumnWidths[CERTTMPL_SNAPIN][COLNUM_CERT_TEMPLATE_AUTOENROLL_STATUS] = 100;
    }

    _TRACE (-1, L"Leaving CCertTmplComponent::CCertTmplComponent\n");
}

CCertTmplComponent::~CCertTmplComponent ()
{
    _TRACE (1, L"Entering CCertTmplComponent::~CCertTmplComponent\n");
    VERIFY ( SUCCEEDED (ReleaseAll ()) );

    for (int i = 0; i < CERTTMPL_NUMTYPES; i++)
    {
        if ( m_ColumnWidths[i] )
            delete [] m_ColumnWidths[i];
    }
    _TRACE (-1, L"Leaving CCertTmplComponent::~CCertTmplComponent\n");
}

HRESULT CCertTmplComponent::ReleaseAll ()
{
    return CComponent::ReleaseAll ();
}


/////////////////////////////////////////////////////////////////////////////
// IComponent Implementation

HRESULT CCertTmplComponent::LoadStrings ()
{
    return S_OK;
}

HRESULT CCertTmplComponent::LoadColumns ( CCertTmplCookie* pcookie )
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    _TRACE (1, L"Entering CCertTmplComponent::LoadColumns\n");
    HRESULT hr = S_OK;


    hr = LoadColumnsFromArrays (pcookie->m_objecttype);

    _TRACE (-1, L"Leaving CCertTmplComponent::LoadColumns\n");
    return hr;
}


/* This is generated by UpdateAllViews () */
HRESULT CCertTmplComponent::OnViewChange (LPDATAOBJECT pDataObject, LPARAM /*data*/, LPARAM hint)
{
    _TRACE (1, L"Entering CCertTmplComponent::OnViewChange\n");
    ASSERT (pDataObject);
    if ( !pDataObject )
        return E_POINTER;

    CCertTmplComponentData& dataRef = QueryComponentDataRef ();
    HRESULT                 hr = S_OK;

    if ( hint & UPDATE_HINT_ENUM_CERT_TEMPLATES )
    {
        hr = RefreshResultPane (false);
        return hr;
    }
    
    hr = RefreshResultPane (false);


    CCertTmplCookie* pCookie = dataRef.ConvertCookie (pDataObject);
    if ( pCookie )
    {
        switch (pCookie->m_objecttype)
        {
        case CERTTMPL_CERT_TEMPLATE:
            break;

        case CERTTMPL_SNAPIN:
            break;

        default:
            {
                IConsole2*  pConsole2 = 0;
                hr = m_pConsole->QueryInterface (
                        IID_PPV_ARG(IConsole2, &pConsole2));
                if (SUCCEEDED (hr))
                {
                    hr = pConsole2->SetStatusText (L"");
                    if ( !SUCCEEDED (hr) )
                    {
                        _TRACE (0, L"IConsole2::SetStatusText () failed: %x", hr);
                    }
                    pConsole2->Release ();
                }
            }
            break;
        }
    }

    _TRACE (-1, L"Leaving CCertTmplComponent::OnViewChange\n");
    return hr;
}

HRESULT CCertTmplComponent::Show (
        CCookie* pcookie, 
        LPARAM arg, 
        HSCOPEITEM /*hScopeItem*/, 
        LPDATAOBJECT /*pDataObject*/)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    HRESULT hr = S_OK;

    if ( !arg )
    {
        if ( !m_pResultData )
        {
            ASSERT ( FALSE );
            return E_UNEXPECTED;
        }

        m_pViewedCookie = dynamic_cast <CCertTmplCookie*> (pcookie);
        ASSERT (m_pViewedCookie);
        if ( m_pViewedCookie )
            hr = SaveWidths (m_pViewedCookie);
        m_pViewedCookie = 0;
        return S_OK;
    }

    if ( m_pResultData )
    {
        m_pResultData->ModifyViewStyle (
                (MMC_RESULT_VIEW_STYLE) (MMC_ENSUREFOCUSVISIBLE | MMC_SHOWSELALWAYS),
                MMC_NOSORTHEADER);
    }

    m_pViewedCookie = dynamic_cast <CCertTmplCookie*> (pcookie);
    ASSERT (m_pViewedCookie);
    if ( m_pViewedCookie )
    {
        // Load default columns and widths
        LoadColumns (m_pViewedCookie);

        // Restore persisted column widths
        switch (m_pViewedCookie->m_objecttype)
        {
        case CERTTMPL_SNAPIN:
            break;

        case CERTTMPL_CERT_TEMPLATE:  // not a scope pane item
            ASSERT (0);
            break;

        default:
            ASSERT (0);
            break;
        }

        if ( g_bDomainIsPresent )  //
        {
            hr = PopulateListbox (m_pViewedCookie);
            if ( FAILED (hr) )
            {
                CString caption;
                CString text;

                VERIFY (caption.LoadString (IDS_CERTTMPL));

                if ( HRESULT_FROM_WIN32 (ERROR_DS_NO_SUCH_OBJECT) == hr )
                {
                    // security review BryanWal 2/20/2002 ok
                    text.FormatMessage (IDS_CANNOT_ENUM_CERT_TEMPLATES_CONTAINER_NOT_FOUND, 
                            m_szCertTemplatePath);
                }
                else
                {
                    // security review BryanWal 2/20/2002 ok
                    text.FormatMessage (IDS_CANNOT_ENUM_CERT_TEMPLATES, GetSystemMessage (hr));
                }

                int     iRetVal = 0;
                VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption,
                    MB_ICONWARNING | MB_OK, &iRetVal)));
            }
        }
    }

    return hr;
}

HRESULT CCertTmplComponent::Show ( CCookie* pcookie, LPARAM arg, HSCOPEITEM hScopeItem)
{
    ASSERT (0);
    return Show (pcookie, arg, hScopeItem, 0);
}


HRESULT CCertTmplComponent::OnNotifyAddImages (LPDATAOBJECT /*pDataObject*/,
                                                 LPIMAGELIST lpImageList,
                                                 HSCOPEITEM /*hSelectedItem*/)
{
    long    lViewMode = 0;

    ASSERT (m_pResultData);
    QueryComponentDataRef ().SetResultData (m_pResultData);

    HRESULT hr = m_pResultData->GetViewMode (&lViewMode);   
    ASSERT (SUCCEEDED (hr));
    BOOL    bLoadLargeIcons = (LVS_ICON == lViewMode);

    return QueryComponentDataRef ().LoadIcons (lpImageList, bLoadLargeIcons);
}


HRESULT CCertTmplComponent::PopulateListbox (CCertTmplCookie* pCookie)
{
    _TRACE (1, L"Entering CCertTmplComponent::PopulateListbox\n");
    HRESULT     hr = S_OK;

    
    switch ( pCookie->m_objecttype )
    {
    case CERTTMPL_SNAPIN:
        hr = AddEnterpriseTemplates ();
        if ( SUCCEEDED (hr) )
        {
            m_currResultNodeType = CERTTMPL_CERT_TEMPLATE;
        }
        break;

    case CERTTMPL_CERT_TEMPLATE:
        ASSERT (0);
        break;

    default:
        ASSERT (0);
        break;
    }

    _TRACE (-1, L"Leaving CCertTmplComponent::PopulateListbox\n");
    return hr;
}

HRESULT CCertTmplComponent::RefreshResultPane (const bool bSilent)
{
    _TRACE (1, L"Entering CCertTmplComponent::RefreshResultPane\n");
    HRESULT hr = S_OK;

    ASSERT (NULL != m_pResultData);
    if ( m_pResultData )
    {
        m_pResultData->DeleteAllRsltItems ();
    }
    else
        hr = E_UNEXPECTED;

    if ( m_pViewedCookie )
    {
        hr = PopulateListbox (m_pViewedCookie);
        if ( FAILED (hr) && !bSilent )
        {
            CString caption;
            CString text;

            VERIFY (caption.LoadString (IDS_CERTTMPL));

            // security review BryanWal 2/20/2002 ok
            text.FormatMessage (IDS_CANNOT_ENUM_CERT_TEMPLATES, GetSystemMessage (hr));

            int     iRetVal = 0;
            VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption,
                MB_ICONWARNING | MB_OK, &iRetVal)));
        }
    }

    _TRACE (-1, L"Leaving CCertTmplComponent::RefreshResultPane\n");
    return hr;
}

STDMETHODIMP CCertTmplComponent::GetDisplayInfo (RESULTDATAITEM * pResult)
{   
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    ASSERT (pResult);
    HRESULT hr = S_OK;


    if ( pResult && !pResult->bScopeItem ) //&& (pResult->mask & RDI_PARAM) )
    {
        CCookie* pResultCookie = reinterpret_cast<CCookie*> (pResult->lParam);
        ASSERT (pResultCookie);
        if ( !pResultCookie || IsBadWritePtr ((LPVOID) pResultCookie, sizeof (CCookie)) )
            return E_UNEXPECTED;

        CCookie* pActiveCookie = ActiveBaseCookie (pResultCookie);
        ASSERT (pActiveCookie);
        if ( !pActiveCookie || IsBadWritePtr ((LPVOID) pActiveCookie, sizeof (CCookie)) )
            return E_UNEXPECTED;

        CCertTmplCookie* pCookie = dynamic_cast <CCertTmplCookie*>(pActiveCookie);
        ASSERT (pCookie);
        switch (pCookie->m_objecttype)
        {
        case CERTTMPL_CERT_TEMPLATE:
            {
                CCertTemplate* pCertTemplate = reinterpret_cast <CCertTemplate*> (pCookie);
                ASSERT (pCertTemplate);
                if ( pCertTemplate )
                {
                    if (pResult->mask & RDI_STR)
                    {
                        // Note:  text is first stored in class variable so that the buffer is
                        // somewhat persistent.  Copying the buffer pointer directly to the
                        // pResult->str would result in the buffer being freed before the pointer
                        // is used.
                        switch (pResult->nCol)
                        {
                        case COLNUM_CERT_TEMPLATE_OBJECT:
                            m_szDisplayInfoResult = pCertTemplate->GetDisplayName ();
                            break;

                        case COLNUM_CERT_TEMPLATE_TYPE:
                            {
                                DWORD   dwVersion = pCertTemplate->GetType ();
                                switch (dwVersion)
                                {
                                case 1:
                                    VERIFY (m_szDisplayInfoResult.LoadString (IDS_WINDOWS_2000_AND_LATER));
                                    break;

                                case 2:
                                    VERIFY (m_szDisplayInfoResult.LoadString (IDS_WINDOWS_2002_AND_LATER));
                                    break;

                                default:
                                    break;
                                }
                            }
                            break;

                        case COLNUM_CERT_TEMPLATE_VERSION:
                            {
                                DWORD   dwMajorVersion = 0;
                                DWORD   dwMinorVersion = 0;

                                hr = pCertTemplate->GetMajorVersion (dwMajorVersion);
                                if ( SUCCEEDED (hr) )
                                {
                                    hr = pCertTemplate->GetMinorVersion (dwMinorVersion);
                                    if ( SUCCEEDED (hr) )
                                    {
                                        WCHAR   str[32];
                                        // security review BryanWal 2/20/2002
                                        // str buffer need only be 18 characters to contain a DWORD
                                        m_szDisplayInfoResult = _ultow (dwMajorVersion, str, 10);
                                        m_szDisplayInfoResult += L".";
                                        m_szDisplayInfoResult += _ultow (dwMinorVersion, str, 10);
                                    }
                                }
                            }
                            break;

                        case COLNUM_CERT_TEMPLATE_AUTOENROLL_STATUS:
                            if ( pCertTemplate->GoodForAutoEnrollment () )
                                VERIFY (m_szDisplayInfoResult.LoadString (IDS_VALID_FOR_AUTOENROLLMENT));
                            else
                                VERIFY (m_szDisplayInfoResult.LoadString (IDS_INVALID_FOR_AUTOENROLLMENT));
                            break;

                        default:
                            ASSERT (0);
                            break;
                        }

                        pResult->str = const_cast<LPWSTR> ( (LPCWSTR) m_szDisplayInfoResult);
                    }
                    if (pResult->mask & RDI_IMAGE)
                    {
                        if ( 1 == pCertTemplate->GetType () )
                            pResult->nImage = iIconCertTemplateV1;
                        else
                            pResult->nImage = iIconCertTemplateV2;
                    }
                }
            }
            break;

        default:
            ASSERT (0);
            break;
        }
    }
    else
        hr = CComponent::GetDisplayInfo (pResult);

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
// IExtendContextMenu implementation
//
STDMETHODIMP CCertTmplComponent::AddMenuItems (LPDATAOBJECT pDataObject,
                                            LPCONTEXTMENUCALLBACK pContextMenuCallback,
                                            long *pInsertionAllowed)
{
    return QueryComponentDataRef ().AddMenuItems (pDataObject,
            pContextMenuCallback, pInsertionAllowed);
}


STDMETHODIMP CCertTmplComponent::Command (long nCommandID, LPDATAOBJECT pDataObject)
{
    HRESULT hr = S_OK;

    hr = QueryComponentDataRef ().Command (nCommandID, pDataObject);

    return hr;
}


HRESULT CCertTmplComponent::OnNotifyDblClick (LPDATAOBJECT pDataObject)
{
    _TRACE (1, L"Entering CCertTmplComponent::OnNotifyDblClick\n");
    HRESULT hr = S_OK;
    ASSERT (pDataObject);

    CCertTmplCookie* pParentCookie =
            QueryComponentDataRef ().ConvertCookie (pDataObject);
    if ( pParentCookie )
    {
        switch ( pParentCookie->m_objecttype )
        {
            case CERTTMPL_SNAPIN:
                hr = S_FALSE;
                break;

            case CERTTMPL_CERT_TEMPLATE:
                hr = S_FALSE;
                break;

            default:
                _TRACE (0, L"CCertTmplComponentData::OnNotifyDblClick bad parent type\n");
                ASSERT (FALSE);
                hr = S_OK;
                break;
        }
    }
    else
        hr =  E_UNEXPECTED;


    _TRACE (-1, L"Leaving CCertTmplComponent::OnNotifyDblClick\n");
    return hr;
}


HRESULT CCertTmplComponent::OnNotifySelect (LPDATAOBJECT pDataObject, BOOL fSelected)
{
    ASSERT (m_pConsoleVerb && 0xdddddddd != (UINT_PTR) m_pConsoleVerb);
    if ( !m_pConsoleVerb || 0xdddddddd == (UINT_PTR) m_pConsoleVerb )
        return E_FAIL;


    HRESULT hr = S_OK;
    CCertTmplComponentData& dataRef = QueryComponentDataRef ();

    // we have to reset the IResultData pointer in the IComponentData object
    // so that it points to the correct result pane
    if ( fSelected )
    {
        ASSERT (m_pResultData);
        dataRef.SetResultData (m_pResultData);
    }


    switch (dataRef.GetObjectType (pDataObject))
    {
    case CERTTMPL_SNAPIN:
        m_pConsoleVerb->SetVerbState (MMC_VERB_REFRESH, ENABLED, TRUE);
        m_pConsoleVerb->SetDefaultVerb (MMC_VERB_OPEN);
        DisplayRootNodeStatusBarText (m_pConsole);
        break;

    case CERTTMPL_CERT_TEMPLATE:
        {
            CCertTmplCookie* pCookie = ConvertCookie (pDataObject);
            if ( pCookie )
            {
                CCertTemplate* pCertTemplate = dynamic_cast <CCertTemplate*> (pCookie);
                if ( pCertTemplate )
                {
                    if ( !pCertTemplate->IsDefault () )
                        m_pConsoleVerb->SetVerbState (MMC_VERB_DELETE, ENABLED, TRUE);

                    // #NTRAID 360650: Cert Server: Cannot rename cert templates
                    //if ( 1 != pCertTemplate->GetType () && !pCertTemplate->IsDefault () )
                    //  m_pConsoleVerb->SetVerbState (MMC_VERB_RENAME, ENABLED, TRUE);
                }
            }
        }
        m_pConsoleVerb->SetVerbState (MMC_VERB_PROPERTIES, ENABLED, TRUE);
        m_pConsoleVerb->SetDefaultVerb (MMC_VERB_PROPERTIES);
        m_currResultNodeType = CERTTMPL_CERT_TEMPLATE;
        DisplayObjectCountInStatusBar (m_pConsole, 
                QueryComponentDataRef ().m_dwNumCertTemplates);
        break;

    case CERTTMPL_MULTISEL:
        m_pConsoleVerb->SetVerbState (MMC_VERB_DELETE, ENABLED, TRUE);
        m_currResultNodeType = CERTTMPL_MULTISEL;
        DisplayObjectCountInStatusBar (m_pConsole, 
                QueryComponentDataRef ().m_dwNumCertTemplates);
        break;

    default:
        m_currResultNodeType = CERTTMPL_INVALID;
        hr = E_UNEXPECTED;
        break;
    }

    return hr;
}

STDMETHODIMP CCertTmplComponent::CreatePropertyPages (
    LPPROPERTYSHEETCALLBACK pCallBack,
    LONG_PTR handle,        // This handle must be saved in the property page object to notify the parent when modified
    LPDATAOBJECT pDataObject)
{
    return QueryComponentDataRef ().CreatePropertyPages (pCallBack, handle, pDataObject);
}

STDMETHODIMP CCertTmplComponent::QueryPagesFor (LPDATAOBJECT pDataObject)
{
    return QueryComponentDataRef ().QueryPagesFor (pDataObject);
}


HRESULT CCertTmplComponent::OnNotifyRefresh (LPDATAOBJECT pDataObject)
{
    _TRACE (1, L"Entering CCertTmplComponent::OnNotifyRefresh\n");
    ASSERT (pDataObject);
    if ( !pDataObject )
        return E_POINTER;

    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    HRESULT     hr = S_OK;
    CWaitCursor waitCursor;

    CCertTmplCookie* pCookie = ConvertCookie (pDataObject);
    if ( !pCookie )
        return E_UNEXPECTED;

    CCertTmplComponentData& dataRef = QueryComponentDataRef ();

    switch (pCookie->m_objecttype)
    {
    case CERTTMPL_SNAPIN:
        {
            // Delete all the result items and force a reexpansion
            hr = m_pResultData->DeleteAllRsltItems ();
            if ( SUCCEEDED (hr) || E_UNEXPECTED == hr ) // returns E_UNEXPECTED if console shutting down
            {
                dataRef.RemoveResultCookies (m_pResultData);
            }

            hr = PopulateListbox (m_pViewedCookie);
            if ( FAILED (hr) )
            {
                CString caption;
                CString text;

                VERIFY (caption.LoadString (IDS_CERTTMPL));

                // security review BryanWal 2/20/2002 ok
                text.FormatMessage (IDS_CANNOT_ENUM_CERT_TEMPLATES, GetSystemMessage (hr));

                int     iRetVal = 0;
                VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption,
                    MB_ICONWARNING | MB_OK, &iRetVal)));
            }
        }
        break;

    case CERTTMPL_CERT_TEMPLATE:
        ASSERT (0);
        break;

    default:
        ASSERT (0);
        hr = E_UNEXPECTED;
        break;
    }

    _TRACE (-1, L"Leaving CCertTmplComponent::OnNotifyRefresh\n");
    return hr;
}

void CCertTmplComponent::SetTextNotAvailable ()
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    m_szDisplayInfoResult.LoadString (IDS_NOT_AVAILABLE);
}


HRESULT CCertTmplComponent::DeleteCookie (CCertTmplCookie* pCookie, LPDATAOBJECT pDataObject, bool bRequestConfirmation, bool bIsMultipleSelect)
{
    _TRACE (1, L"Entering CCertTmplComponent::DeleteCookie\n");
    HRESULT         hr = S_OK;
    CString         text;
    CString         caption;
    int             iRetVal = IDYES;
    CWaitCursor     waitCursor;

    switch (pCookie->m_objecttype)
    {
    case CERTTMPL_CERT_TEMPLATE:
        {
            CCertTemplate* pCertTemplate = dynamic_cast <CCertTemplate*> (pCookie);
            ASSERT (pCertTemplate);
            if ( pCertTemplate )
            {
                if ( bRequestConfirmation )
                {
                    if ( bIsMultipleSelect )
                    {
                        VERIFY (text.LoadString (IDS_CONFIRM_DELETE_CERT_TEMPLATE_MULTI));
                    }
                    else
                        VERIFY (text.LoadString (IDS_CONFIRM_DELETE_CERT_TEMPLATE));
                    VERIFY (caption.LoadString (IDS_CERTTMPL));
                    hr = m_pConsole->MessageBox (text, caption, MB_ICONWARNING | MB_YESNO, &iRetVal);
                    ASSERT (SUCCEEDED (hr));
                }

                if ( IDYES == iRetVal )
                {
                    hr = DeleteCertTemplateFromResultPane (pCertTemplate, pDataObject);
                }
                else
                    hr = E_FAIL;
            }
        }
        break;

    default:
        ASSERT (0);
        hr = E_UNEXPECTED;
        break;
    }

    _TRACE (-1, L"Leaving CCertTmplComponent::DeleteCookie\n");
    return hr;
}



HRESULT CCertTmplComponent::DeleteCertTemplateFromResultPane (CCertTemplate* pCertTemplate, LPDATAOBJECT /*pDataObject*/)
{
    _TRACE (1, L"Entering CCertTmplComponent::DeleteCertTemplateFromResultPane\n");
    HRESULT         hr = S_OK;
    hr = pCertTemplate->Delete ();

    if ( SUCCEEDED (hr) )
    {
        CCertTmplComponentData& dataref = QueryComponentDataRef ();

        POSITION    prevPos = 0;
        POSITION pos = 0;
        for (pos = dataref.m_globalFriendlyNameList.GetHeadPosition (); pos;)
        {
            prevPos = pos;
            if ( pCertTemplate->GetDisplayName () == 
                    dataref.m_globalFriendlyNameList.GetNext (pos) )
            {
                dataref.m_globalFriendlyNameList.RemoveAt (prevPos);
                break;
            }
        }

        for (pos = dataref.m_globalTemplateNameList.GetHeadPosition (); pos;)
        {
            prevPos = pos;
            if ( pCertTemplate->GetTemplateName () == 
                    dataref.m_globalTemplateNameList.GetNext (pos) )
            {
                dataref.m_globalTemplateNameList.RemoveAt (prevPos);
                break;
            }
        }

    }
    else
    {
        CString caption;
        CString text;

        VERIFY (caption.LoadString (IDS_CERTTMPL));
        // security review BryanWal 2/20/2002 ok
        text.FormatMessage (IDS_CANNOT_DELETE_CERT_TEMPLATE, GetSystemMessage (hr));

        int     iRetVal = 0;
        VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption,
            MB_ICONWARNING | MB_OK, &iRetVal)));
    }
    _TRACE (-1, L"Leaving CCertTmplComponent::DeleteCertTemplateFromResultPane\n");
    return hr;
}


HRESULT CCertTmplComponent::OnNotifyDelete (LPDATAOBJECT pDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    ASSERT (pDataObject);
    if ( !pDataObject )
        return E_POINTER;

    HRESULT         hr = S_OK;
    long            hint = 0;
    CWaitCursor     waitCursor;

    CCertTmplCookie* pCookie =
            QueryComponentDataRef ().ConvertCookie (pDataObject);
    if ( pCookie )
    {
        if ( ((CCertTmplCookie*) MMC_MULTI_SELECT_COOKIE) == pCookie )
        {

            // Is multiple select, get all selected items and paste each one
            CCertTemplatesDataObject* pDO = dynamic_cast <CCertTemplatesDataObject*>(pDataObject);
            ASSERT (pDO);
            if ( pDO )
            {
                // Is multiple select, get all selected items and delete - confirm
                // first deletion only.
                bool    bRequestConfirmation = true;
                pDO->Reset();
                while (pDO->Next(1, reinterpret_cast<MMC_COOKIE*>(&pCookie), NULL) != S_FALSE &&
                        SUCCEEDED (hr) )
                {
                    hr = DeleteCookie (pCookie, pDataObject, bRequestConfirmation, true);
                    bRequestConfirmation = false;
                }

                hr = m_pConsole->UpdateAllViews (pDataObject, 0, hint);
            }

        }
        else
        {
            // In that event, we don't want a confirmation message.
            hr = DeleteCookie (pCookie, pDataObject, true, false);
            if ( SUCCEEDED (hr) )
                hr = m_pConsole->UpdateAllViews (pDataObject, 0, hint);
        }
    }

    return hr;
}



// This compare is used to sort the items in the listview
//
// Parameters:
//
// lUserParam - user param passed in when IResultData::Sort () was called
// cookieA - first item to compare
// cookieB - second item to compare
// pnResult [in, out]- contains the col on entry,
//          -1, 0, 1 based on comparison for return value.
//
// Note: Assume sort is ascending when comparing.

STDMETHODIMP CCertTmplComponent::Compare (RDCOMPARE* prdc, int* pnResult)
{
//  _TRACE (1, L"Entering CCertTmplComponent::Compare\n");
    if ( !prdc || !pnResult )
        return E_POINTER;

    HRESULT                     hr = S_OK;

    if ( RDCI_ScopeItem & prdc->prdch1->dwFlags )
    {
    }
    else
    {
        CCertTmplCookie* pCookie = reinterpret_cast <CCertTmplCookie*> (prdc->prdch1->cookie);
        ASSERT (pCookie);
        if ( !pCookie )
            return E_UNEXPECTED;

        switch (pCookie->m_objecttype)
        {
        case CERTTMPL_CERT_TEMPLATE:
            {
                CCertTemplate* pCertTemplateA = reinterpret_cast <CCertTemplate*> (prdc->prdch1->cookie);
                CCertTemplate* pCertTemplateB = reinterpret_cast <CCertTemplate*> (prdc->prdch2->cookie);
                switch ( prdc->nColumn )
                {
                case COLNUM_CERT_TEMPLATE_OBJECT:
                    *pnResult = LocaleStrCmp (pCertTemplateA->GetDisplayName (), pCertTemplateB->GetDisplayName ());
                    break;

                case COLNUM_CERT_TEMPLATE_TYPE:
                    if ( pCertTemplateA->GetType () == pCertTemplateB->GetType () )
                        *pnResult = 0;
                    else if ( pCertTemplateA->GetType () > pCertTemplateB->GetType () )
                        *pnResult = 1;
                    else
                        *pnResult = -1;
                    break;

                case COLNUM_CERT_TEMPLATE_VERSION:
                    {
                        // Sort first on major version, then on minor version
                        *pnResult = 0;
                        DWORD dwMajorVersionA = 0;
                        hr = pCertTemplateA->GetMajorVersion (dwMajorVersionA);
                        if ( SUCCEEDED (hr) )
                        {
                            DWORD dwMajorVersionB = 0;
                            hr = pCertTemplateB->GetMajorVersion (dwMajorVersionB);
                            if ( SUCCEEDED (hr) )
                            {
                                if ( dwMajorVersionA == dwMajorVersionB )
                                {
                                    DWORD dwMinorVersionA = 0;
                                    hr = pCertTemplateA->GetMinorVersion (dwMinorVersionA);
                                    if ( SUCCEEDED (hr) )
                                    {
                                        DWORD dwMinorVersionB = 0;
                                        hr = pCertTemplateB->GetMinorVersion (dwMinorVersionB);
                                        if ( SUCCEEDED (hr) )
                                        {
                                            if ( dwMinorVersionA == dwMinorVersionB )
                                                *pnResult = 0;
                                            else if ( dwMinorVersionA > dwMinorVersionB )
                                                *pnResult = 1;
                                            else
                                                *pnResult = -1;
                                        }
                                    }
                                }
                                else if ( dwMajorVersionA > dwMajorVersionB )
                                    *pnResult = 1;
                                else
                                    *pnResult = -1;
                            }
                        }
                    }
                    break;

                case COLNUM_CERT_TEMPLATE_AUTOENROLL_STATUS:
                    if ( pCertTemplateA->GoodForAutoEnrollment () && 
                            pCertTemplateB->GoodForAutoEnrollment () )
                    {
                        *pnResult = 0;
                    }
                    else if ( pCertTemplateA->GoodForAutoEnrollment () && 
                            !pCertTemplateB->GoodForAutoEnrollment () )
                    {
                        *pnResult = 1;
                    }
                    else
                        *pnResult = 0;
                    break;

                default:
                    ASSERT (0);
                    break;
                }
            }
            break;

        default:
            ASSERT (0);
            break;
        }
    }

//  _TRACE (-1, L"Leaving CCertTmplComponent::Compare\n");
    return hr;
}


/////////////////////////////////////////////////////////////////////
// Virtual function called by CComponent::IComponent::Notify (MMCN_COLUMN_CLICK)
HRESULT CCertTmplComponent::OnNotifyColumnClick (LPDATAOBJECT /*pDataObject*/, LPARAM iColumn, LPARAM uFlags)
{
    _TRACE (1, L"Entering CCertTmplComponent::OnNotifyColumnClick\n");

    IResultData*    pResultData = 0;
    HRESULT         hr = m_pConsole->QueryInterface (
            IID_PPV_ARG (IResultData, &pResultData));
    if ( SUCCEEDED (hr) )
    {
        m_nSortColumn = (int) iColumn;
        hr = pResultData->Sort (m_nSortColumn, (DWORD)uFlags, 0);
        _TRACE (0, L"IResultData::Sort () returned: 0x%x\n", hr);

        pResultData->Release ();
    }

    _TRACE (-1, L"Leaving CCertTmplComponent::OnNotifyColumnClick\n");
    return hr;
}


STDMETHODIMP CCertTmplComponent::Notify (LPDATAOBJECT pDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;

    switch (event)
    {
        case MMCN_CUTORMOVE:
            hr = OnNotifyCutOrMove (arg);
            break;

        case MMCN_QUERY_PASTE:
            hr = OnNotifyQueryPaste (pDataObject, arg, param);
            break;

        case MMCN_PASTE:
            hr = OnNotifyPaste (pDataObject, arg, param);
            break;

        case MMCN_SHOW:
            {
                CCookie* pCookie = NULL;
                hr = ::ExtractData (pDataObject,
                                  CDataObject::m_CFRawCookie,
                                  &pCookie,
                                  sizeof(pCookie));
                if ( SUCCEEDED (hr) )
                {
                    hr = Show (ActiveBaseCookie (pCookie), arg,
                            (HSCOPEITEM) param, pDataObject);
                }
            }
            break;

        case MMCN_RENAME:
            hr = OnNotifyRename (pDataObject, arg, param);
            break;

        default:
            hr = CComponent::Notify (pDataObject, event, arg, param);
            break;
    }

    return hr;
}


HRESULT CCertTmplComponent::OnNotifySnapinHelp (LPDATAOBJECT pDataObject)
{
    _TRACE (1, L"Entering CCertTmplComponent::OnNotifySnapinHelp\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ( ));

    CComQIPtr<IDisplayHelp,&IID_IDisplayHelp>   spDisplayHelp = m_pConsole;
    if ( !spDisplayHelp )
    {
        ASSERT(FALSE);
        return E_UNEXPECTED;
    }

    CString strHelpTopic;

    UINT nLen = ::GetSystemWindowsDirectory (strHelpTopic.GetBufferSetLength(2 * MAX_PATH), 2 * MAX_PATH);
    strHelpTopic.ReleaseBuffer();
    if (0 == nLen)
    {
        ASSERT(FALSE);
        return E_FAIL;
    }

    strHelpTopic += CERTTMPL_HELP_PATH;
    strHelpTopic += CERTTMPL_CONCEPTS_HELP_FILE; 
    strHelpTopic += L"::/";

    CCertTmplComponentData& dataRef = QueryComponentDataRef ();
    CCertTmplCookie* pCookie = dataRef.ConvertCookie (pDataObject);
    if ( pCookie )
    {
        switch (pCookie->m_objecttype)
        {
        case CERTTMPL_SNAPIN:
        case CERTTMPL_CERT_TEMPLATE:
        default:
            strHelpTopic += CERTTMPL_HTML_TOP_NODE;
            break;
        }
    }

    HRESULT hr = spDisplayHelp->ShowTopic (T2OLE ((PWSTR)(PCWSTR) strHelpTopic));
    if ( FAILED (hr) )
    {
        CString caption;
        CString text;

        VERIFY (caption.LoadString (IDS_CERTTMPL));

        // security review BryanWal 2/20/2002 ok
        text.FormatMessage (IDS_CANT_DISPLAY_SNAPIN_HELP_TOPIC, strHelpTopic, 
                GetSystemMessage (hr));

        int     iRetVal = 0;
        VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption,
            MB_ICONWARNING | MB_OK, &iRetVal)));
    }


    _TRACE (-1, L"Leaving CCertTmplComponent::OnNotifySnapinHelp\n");
    return hr;
}

HRESULT CCertTmplComponent::OnNotifyPaste (LPDATAOBJECT /*pDataObject*/, LPARAM /*arg*/, LPARAM /*param*/)
{
    return E_NOTIMPL;
}


HRESULT CCertTmplComponent::OnNotifyQueryPaste(LPDATAOBJECT /*pDataObject*/, LPARAM /*arg*/, LPARAM /*param*/)
{
    return E_NOTIMPL;
}


STDMETHODIMP CCertTmplComponent::GetResultViewType(MMC_COOKIE cookie,
        BSTR* ppViewType,
        long* pViewOptions) 
{
    CCertTmplCookie* pScopeCookie = reinterpret_cast <CCertTmplCookie*> (cookie);
    if ( pScopeCookie )
    {
        switch (pScopeCookie->m_objecttype)
        {
        case CERTTMPL_SNAPIN:
            *pViewOptions |= MMC_VIEW_OPTIONS_MULTISELECT;
            break;

        case CERTTMPL_CERT_TEMPLATE:
        default:
            break;
        }
    }
    else
        *pViewOptions |= MMC_VIEW_OPTIONS_MULTISELECT;

    *ppViewType = NULL;
    return S_FALSE;
}


STDMETHODIMP CCertTmplComponent::Initialize(LPCONSOLE lpConsole)
{
    _TRACE (1, L"Entering CCertTmplComponent::Initialize\n");
    HRESULT  hr = CComponent::Initialize (lpConsole);
    if ( SUCCEEDED (hr) )
    {
        ASSERT (m_pHeader);
        QueryComponentDataRef ().m_pHeader = m_pHeader;

        if ( lpConsole )
        {
            if ( QueryComponentDataRef ().m_pComponentConsole )
                SAFE_RELEASE (QueryComponentDataRef ().m_pComponentConsole);
            QueryComponentDataRef ().m_pComponentConsole = m_pConsole;
            QueryComponentDataRef ().m_pComponentConsole->AddRef ();
        }
    }

    _TRACE (-1, L"Leaving CCertTmplComponent::Initialize\n");
    return hr;
}


HRESULT CCertTmplComponent::LoadColumnsFromArrays (CertTmplObjectType objecttype )
{
    _TRACE (1, L"Entering CCertTmplComponent::LoadColumnsFromArrays\n");
    ASSERT (m_pHeader);

    CString str;
    for ( INT i = 0; 0 != m_Columns[objecttype][i]; i++)
    {
        VERIFY(str.LoadString (m_Columns[objecttype][i]));
        m_pHeader->InsertColumn(i, const_cast<PWSTR>((PCWSTR)str), LVCFMT_LEFT,
            m_ColumnWidths[objecttype][i]);
    }

    _TRACE (-1, L"Leaving CCertTmplComponent::LoadColumnsFromArrays\n");
    return S_OK;
}

HRESULT CCertTmplComponent::SaveWidths(CCertTmplCookie * pCookie)
{
    _TRACE (1, L"Entering CCertTmplComponent::SaveWidths\n");
    HRESULT hr = S_OK;

    m_fDirty = TRUE;

    ASSERT (pCookie);
    if ( pCookie )
    {
        switch (m_pViewedCookie->m_objecttype)
        {
        case CERTTMPL_SNAPIN:
            {
                const UINT* pColumns = m_Columns[m_pViewedCookie->m_objecttype];
                ASSERT(pColumns);
                int    nWidth = 0;

                for (UINT iIndex = 0; iIndex < pColumns[iIndex]; iIndex++)
                {
                    hr = m_pHeader->GetColumnWidth ((int) iIndex, &nWidth);
                    if ( SUCCEEDED (hr) )
                    {
                        m_ColumnWidths[m_pViewedCookie->m_objecttype][iIndex] =
                                (UINT) nWidth;
                    }
                    else
                        break;
                }
            }
            break;

        default:
            ASSERT (0);
            break;
        }
    }
    else
        hr = E_POINTER;

    _TRACE (-1, L"Leaving CCertTmplComponent::SaveWidths\n");
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
#define _dwMagicword    10000  // Internal version number
STDMETHODIMP CCertTmplComponent::Load(IStream __RPC_FAR *pIStream)
{
    _TRACE (1, L"Entering CCertTmplComponent::Load\n");
    HRESULT hr = S_OK;

#ifndef DONT_PERSIST
    ASSERT (pIStream);
    XSafeInterfacePtr<IStream> pIStreamSafePtr( pIStream );

    // Read the magic word from the stream
    DWORD dwMagicword = 0;
    hr = pIStream->Read (&dwMagicword, sizeof(dwMagicword), NULL);
    if ( FAILED(hr) )
    {
        ASSERT( FALSE );
        return hr;
    }
    if (dwMagicword != _dwMagicword)
    {
        // We have a version mismatch
        _TRACE(0, L"INFO: CCertTmplComponentData::Load() - Wrong Magicword.  You need to re-save your .msc file.\n");
        return E_FAIL;
    }

    int numCols = 0;

    for (int iIndex = 0; iIndex < CERTTMPL_NUMTYPES && SUCCEEDED (hr); iIndex++)
    {
        switch (iIndex)
        {
        case CERTTMPL_SNAPIN:
            numCols = CERT_TEMPLATES_NUM_COLS;
            break;;

        case CERTTMPL_CERT_TEMPLATE:
            continue;

        default:
            ASSERT (0);
            break;
        }

        for (int colNum = 0; colNum < numCols; colNum++)
        {
            hr = pIStream->Read (&(m_ColumnWidths[iIndex][colNum]),
                    sizeof (UINT), NULL);
            ASSERT (SUCCEEDED (hr));
            if ( FAILED(hr) )
            {
                break;
            }
        }
    }
#endif
    _TRACE (-1, L"Leaving CCertTmplComponent::Load\n");
    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CCertTmplComponent::Save(IStream __RPC_FAR *pIStream, BOOL /*fSameAsLoad*/)
{
    _TRACE (1, L"Entering CCertTmplComponent::Save\n");
    HRESULT hr = S_OK;


#ifndef DONT_PERSIST
    ASSERT (pIStream);
    XSafeInterfacePtr<IStream> pIStreamSafePtr (pIStream);

    // Store the magic word to the stream
    DWORD dwMagicword = _dwMagicword;
    hr = pIStream->Write (&dwMagicword, sizeof(dwMagicword), NULL);
    ASSERT (SUCCEEDED (hr));
    if ( FAILED (hr) )
        return hr;


    int numCols = 0;

    for (int iIndex = 0; iIndex < CERTTMPL_NUMTYPES && SUCCEEDED (hr); iIndex++)
    {
        switch (iIndex)
        {
        case CERTTMPL_SNAPIN:
            numCols = CERT_TEMPLATES_NUM_COLS;
            break;;

        case CERTTMPL_CERT_TEMPLATE:
            continue;

        default:
            ASSERT (0);
            break;
        }

        for (int colNum = 0; colNum < numCols; colNum++)
        {
            hr = pIStream->Write (&(m_ColumnWidths[iIndex][colNum]),
                    sizeof (UINT), NULL);
            ASSERT (SUCCEEDED (hr));
            if ( FAILED(hr) )
            {
                ASSERT (FALSE);
                break;
            }
        }
    }
#endif

    _TRACE (-1, L"Leaving CCertTmplComponent::Save\n");
    return S_OK;
}

HRESULT CCertTmplComponent::OnNotifyCutOrMove(LPARAM arg)
{
    _TRACE (1, L"Entering CCertTmplComponent::OnNotifyCutOrMove\n");
    if ( !arg )
        return E_POINTER;

    LPDATAOBJECT pDataObject = reinterpret_cast <IDataObject*> (arg);
    ASSERT (pDataObject);
    if ( !pDataObject )
        return E_UNEXPECTED;


    HRESULT         hr = S_OK;

    CCertTmplCookie* pCookie =
            QueryComponentDataRef ().ConvertCookie (pDataObject);
    if ( pCookie )
    {
        if ( ((CCertTmplCookie*) MMC_MULTI_SELECT_COOKIE) == pCookie )
        {
            CCertTemplatesDataObject* pDO = dynamic_cast <CCertTemplatesDataObject*>(pDataObject);
            ASSERT (pDO);
            if ( pDO )
            {
                pDO->Reset();
                while (pDO->Next(1, reinterpret_cast<MMC_COOKIE*>(&pCookie), NULL) != S_FALSE)
                {
                    hr = DeleteCookie (pCookie, pDataObject, false, true);
                }
            }
            else
                hr = E_FAIL;
        }
        else
        {
            hr = DeleteCookie (pCookie, pDataObject, false, false);
        }
        if ( SUCCEEDED (hr) )
            RefreshResultPane (false);
    }

    _TRACE (-1, L"Leaving CCertTmplComponent::OnNotifyCutOrMove\n");
    return hr;
}



CCertTmplCookie* CCertTmplComponent::ConvertCookie(LPDATAOBJECT pDataObject)
{
    return QueryComponentDataRef ().ConvertCookie (pDataObject);
}



HRESULT CCertTmplComponent::RefreshResultItem (CCertTmplCookie* pCookie)
{
    _TRACE (1, L"Entering CCertTmplComponent::RefreshResultItem\n");
    ASSERT (pCookie);
    if ( !pCookie )
        return E_POINTER;

    HRESULT hr = S_OK;
    HRESULTITEM itemID = 0;

    ASSERT (m_pResultData);
    if ( m_pResultData )
    {
        pCookie->Refresh ();
        hr = m_pResultData->FindItemByLParam ( (LPARAM) pCookie, &itemID);
        ASSERT (SUCCEEDED (hr));
        if ( SUCCEEDED (hr) )
        {
            hr = m_pResultData->UpdateItem (itemID);
            ASSERT (SUCCEEDED (hr));
        }
    }
    else
        hr = E_FAIL;

    _TRACE (-1, L"Leaving CCertTmplComponent::RefreshResultItem\n");
    return hr;
}


/////////////////////////////////////////////////////////////////////
// Virtual function called by CComponent::IComponent::Notify(MMCN_PROPERTY_CHANGE)
// OnPropertyChange() is generated by MMCPropertyChangeNotify( param )
HRESULT CCertTmplComponent::OnPropertyChange (LPARAM param)
{
    return  QueryComponentDataRef ().OnPropertyChange (param);
}

HRESULT CCertTmplComponent::AddEnterpriseTemplates ()
{
    _TRACE (1, L"Entering CCertTmplComponent::AddEnterpriseTemplates\n");
    AFX_MANAGE_STATE(AfxGetStaticModuleState());    
    HRESULT                 hr = S_OK;
    CWaitCursor             cursor;
    CComPtr<IADsPathname>   spPathname;

    //
    // Constructing the directory paths
    //
    // security review BryanWal 2/20/2002 ok
    hr = CoCreateInstance(
                CLSID_Pathname,
                NULL,
                CLSCTX_ALL,
                IID_PPV_ARG (IADsPathname, &spPathname));
    if ( SUCCEEDED (hr) )
    {
        ASSERT (!!spPathname);

        CComBSTR bstrPathElement = CERTTMPL_LDAP;
        hr = spPathname->Set(bstrPathElement,
                            ADS_SETTYPE_PROVIDER);
        if ( SUCCEEDED (hr) )
        {
            hr = spPathname->Set (const_cast <BSTR> ((PCWSTR)QueryComponentDataRef ().m_szThisDomainDns),
                    ADS_SETTYPE_SERVER);
            if ( SUCCEEDED (hr) )
            {
                //
                // Open the root DSE object
                //
                bstrPathElement = CERTTMPL_ROOTDSE;
                hr = spPathname->AddLeafElement(bstrPathElement);
                if ( SUCCEEDED (hr) )
                {
                    BSTR bstrFullPath = 0;
                    hr = spPathname->Retrieve(ADS_FORMAT_X500, &bstrFullPath);
                    if ( SUCCEEDED (hr) )
                    {
                        CComPtr<IADs> spRootDSEObject;
                        VARIANT varNamingContext;


                        hr = ADsGetObject (
                              bstrFullPath,
                              IID_PPV_ARG (IADs, &spRootDSEObject));
                        if ( SUCCEEDED (hr) )
                        {
                            ASSERT (!!spRootDSEObject);
                            //
                            // Get the configuration naming context from the root DSE
                            //
                            bstrPathElement = CERTTMPL_CONFIG_NAMING_CONTEXT;
                            hr = spRootDSEObject->Get(bstrPathElement,
                                                 &varNamingContext);
                            if ( SUCCEEDED (hr) )
                            {
                                hr = spPathname->Set(V_BSTR(&varNamingContext),
                                                    ADS_SETTYPE_DN);
                                if ( SUCCEEDED (hr) )
                                {
                                    bstrPathElement = L"CN=Services";
                                    hr = spPathname->AddLeafElement (bstrPathElement);
                                    if ( SUCCEEDED (hr) )
                                    {
                                        bstrPathElement = L"CN=Public Key Services";
                                        hr = spPathname->AddLeafElement (bstrPathElement);
                                        if ( SUCCEEDED (hr) )
                                        {
                                            bstrPathElement = L"CN=Certificate Templates";
                                            hr = spPathname->AddLeafElement (bstrPathElement);
                                            if ( SUCCEEDED (hr) )
                                            {
                                                BSTR bstrCertTemplatePath = 0;
                                                hr = spPathname->Retrieve(ADS_FORMAT_X500, &bstrCertTemplatePath);
                                                if ( SUCCEEDED (hr) )
                                                {
                                                    m_szCertTemplatePath = bstrCertTemplatePath;
                                                    CComPtr<IDirectoryObject> spTemplateContObj;

                                                    hr = ADsGetObject (
                                                          bstrCertTemplatePath,
                                                          IID_PPV_ARG (IDirectoryObject, &spTemplateContObj));
                                                    if ( SUCCEEDED (hr) )
                                                    {
                                                        hr = EnumerateTemplates (spTemplateContObj, bstrCertTemplatePath);
                                                        if ( SUCCEEDED (hr) )
                                                        {
                                                            m_currResultNodeType = CERTTMPL_CERT_TEMPLATE;
                                                            hr = m_pResultData->Sort (m_nSortColumn, 0, 0);
                                                        }
                                                    }
                                                    else
                                                    {
                                                        _TRACE (0, L"ADsGetObject (%s) failed: 0x%x\n", bstrCertTemplatePath, hr);
                                                    }

                                                    SysFreeString (bstrCertTemplatePath);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            else
                            {
                                _TRACE (0, L"IADs::Get (%s) failed: 0x%x\n", CERTTMPL_CONFIG_NAMING_CONTEXT, hr);
                            }
                        }
                        else
                        {
                            _TRACE (0, L"ADsGetObject (%s) failed: 0x%x\n", bstrFullPath, hr);
                        }
                    }
                }
            }
        }
    }
    else
        hr = E_POINTER;

    _TRACE (-1, L"Leaving CCertTmplComponent::AddEnterpriseTemplates\n");
    return hr;
}


HRESULT CCertTmplComponent::EnumerateTemplates (
        IDirectoryObject* pTemplateContObj, 
        const BSTR bszTemplateContainerPath)
{
    _TRACE (1, L"Entering CCertTmplComponent::EnumerateTemplates\n");
    CCertTmplComponentData& dataRef = QueryComponentDataRef ();
    CWaitCursor             cursor;

    dataRef.m_fUseCache = false;

    // Bug 243609   CertServer: Wrong count of templates displayed in the MMC
    dataRef.m_dwNumCertTemplates = 0;
    dataRef.m_globalTemplateNameList.RemoveAll ();
    dataRef.m_globalFriendlyNameList.RemoveAll ();
    CComPtr<IDirectorySearch>   spDsSearch;
    HRESULT hr = pTemplateContObj->QueryInterface (IID_PPV_ARG(IDirectorySearch, &spDsSearch));
    if ( SUCCEEDED (hr) )
    {
        ASSERT (!!spDsSearch);
        ADS_SEARCHPREF_INFO pSearchPref[1];
        DWORD dwNumPref = 1;

        pSearchPref[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
        pSearchPref[0].vValue.dwType = ADSTYPE_INTEGER;
        pSearchPref[0].vValue.Integer = ADS_SCOPE_ONELEVEL;

        hr = spDsSearch->SetSearchPreference(
                 pSearchPref,
                 dwNumPref
                 );
        if ( SUCCEEDED (hr) )
        {
            static const DWORD  cAttrs = 2;
            static PWSTR        rgszAttrList[cAttrs] = {L"displayName", L"cn"};
            ADS_SEARCH_HANDLE   hSearchHandle = 0;
            wstring             strQuery;
            ADS_SEARCH_COLUMN   Column;

            Column.pszAttrName = 0;
            strQuery = L"objectClass=pKICertificateTemplate";

            hr = spDsSearch->ExecuteSearch(
                                 const_cast <PWSTR>(strQuery.c_str ()),
                                 rgszAttrList,
                                 cAttrs,
                                 &hSearchHandle
                                 );
            if ( SUCCEEDED (hr) )
            {
                CCookie&    rootCookie = dataRef.QueryBaseRootCookie ();

                while ((hr = spDsSearch->GetNextRow (hSearchHandle)) != S_ADS_NOMORE_ROWS )
                {
                    if (FAILED(hr))
                        continue;

                    //
                    // Getting current row's information
                    //
                    hr = spDsSearch->GetColumn(
                             hSearchHandle,
                             rgszAttrList[0],
                             &Column
                             );
                    if ( SUCCEEDED (hr) )
                    {
                        CString strDisplayName = Column.pADsValues->CaseIgnoreString;

                        spDsSearch->FreeColumn (&Column);
                        Column.pszAttrName = NULL;

                        hr = spDsSearch->GetColumn(
                                 hSearchHandle,
                                 rgszAttrList[1],
                                 &Column
                                 );
                        if ( SUCCEEDED (hr) )
                        {
                            CString strTemplateName = Column.pADsValues->CaseIgnoreString;

                            spDsSearch->FreeColumn (&Column);
                            Column.pszAttrName = NULL;


                            CComPtr<IADsPathname> spPathname;
                            //
                            // Constructing the directory paths
                            //
                            // security review BryanWal 2/20/2002 ok
                            hr = CoCreateInstance(
                                        CLSID_Pathname,
                                        NULL,
                                        CLSCTX_ALL,
                                        IID_PPV_ARG (IADsPathname, &spPathname));
                            if ( SUCCEEDED (hr) )
                            {
                                ASSERT (!!spPathname);
                                hr = spPathname->Set(bszTemplateContainerPath,
                                                    ADS_SETTYPE_FULL);
                                if ( SUCCEEDED (hr) )
                                {
                                    //
                                    // Open the root DSE object
                                    //
                                    CComBSTR bstrPathElement = strTemplateName;
                                    hr = spPathname->AddLeafElement(bstrPathElement);
                                    if ( SUCCEEDED (hr) )
                                    {
                                        BSTR bstrFullPath = 0;
                                        hr = spPathname->Retrieve(ADS_FORMAT_X500, &bstrFullPath);
                                        if ( SUCCEEDED (hr) )
                                        {
                                            CCertTemplate* pCertTemplate = 
                                                    new CCertTemplate (strDisplayName, strTemplateName,
                                                            bstrFullPath, false,
                                                            dataRef.m_fUseCache);
                                            if ( pCertTemplate )
                                            {
                                                dataRef.m_fUseCache = true;                                    

                                                rootCookie.m_listResultCookieBlocks.AddHead (pCertTemplate);

                                                RESULTDATAITEM          rdItem;
                                                // security review BryanWal 02/20/2002 ok
                                                ::ZeroMemory (&rdItem, sizeof (rdItem));
                                                rdItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
                                                rdItem.nCol = 0;
                                                rdItem.str = MMC_CALLBACK;
                                                if ( 1 == pCertTemplate->GetType () )
                                                    rdItem.nImage = iIconCertTemplateV1;
                                                else
                                                    rdItem.nImage = iIconCertTemplateV2;
                                                rdItem.lParam = (LPARAM) pCertTemplate;
                                                pCertTemplate->m_resultDataID = m_pResultData;
                                                hr = m_pResultData->InsertItem (&rdItem);
                                                if ( FAILED (hr) )
                                                {
                                                    _TRACE (0, L"IResultData::InsertItem failed: 0x%x\n", hr);
                                                    hr = S_OK;
                                                    break;
                                                }
                                                else
                                                {
                                                    dataRef.m_dwNumCertTemplates++;
                                                    dataRef.m_globalTemplateNameList.AddTail (strTemplateName);
                                                    dataRef.m_globalFriendlyNameList.AddHead (
                                                        pCertTemplate->GetDisplayName ());    
                                                }
                                            }
                                            else
                                            {
                                                hr = E_OUTOFMEMORY;
                                                break;
                                            }

                                            SysFreeString (bstrFullPath);
                                        }
                                    }
                                }
                            }

                        }
                    }
                    else if ( hr != E_ADS_COLUMN_NOT_SET )
                    {
                        break;
                    }
                    else
                    {
                        _TRACE (0, L"IDirectorySearch::GetColumn () failed: 0x%x\n", hr);
                    }
                }
            }
            else
            {
                _TRACE (0, L"IDirectorySearch::ExecuteSearch () failed: 0x%x\n", hr);
            }

            spDsSearch->CloseSearchHandle(hSearchHandle);
        }
        else
        {
            _TRACE (0, L"IDirectorySearch::SetSearchPreference () failed: 0x%x\n", hr);
        }
    }
    else
    {
        _TRACE (0, L"IDirectoryObject::QueryInterface (IDirectorySearch) failed: 0x%x\n", hr);
    }

    _TRACE (-1, L"Leaving CCertTmplComponent::EnumerateTemplates: 0x%x\n", hr);
    dataRef.m_fUseCache = false;

    return hr;
}


HRESULT CCertTmplComponent::OnNotifyRename(LPDATAOBJECT pDataObject, LPARAM /*arg*/, LPARAM param)
{
    _TRACE (1, L"Entering CCertTmplComponent::OnNotifyRename\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    HRESULT hr = S_FALSE;

    CCertTmplCookie* pCookie = ConvertCookie (pDataObject);
    if ( pCookie )
    {
        switch (pCookie->m_objecttype)
        {
        case CERTTMPL_CERT_TEMPLATE:
            {
                CString newName = (LPOLESTR) param;

                newName.TrimLeft ();
                newName.TrimRight ();

                if ( !newName.IsEmpty () )
                {
                    CCertTmplComponentData& dataref = QueryComponentDataRef ();
                    POSITION                pos = 0;
                    bool                    bFound = false;
                    for (pos = dataref.m_globalFriendlyNameList.GetHeadPosition (); pos;)
                    {
                        if ( !_wcsicmp (newName, dataref.m_globalFriendlyNameList.GetNext (pos)) )
                        {
                            CString caption;
                            CString text;

                            VERIFY (caption.LoadString (IDS_CERTTMPL));
                            // security review BryanWal 2/20/2002 ok
                            text.FormatMessage (IDS_FRIENDLY_NAME_ALREADY_USED, newName);

                            int     iRetVal = 0;
                            VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption,
                                    MB_OK, &iRetVal)));
                            bFound = true;
                            break;
                        }
                    }

                    if ( !bFound )
                    {
                        CCertTemplate* pCertTemplate = dynamic_cast<CCertTemplate*> (pCookie);
                        if ( pCertTemplate )
                        {
                            hr = pCertTemplate->SetDisplayName (newName);
                            if ( SUCCEEDED (hr) )
                            {
                                hr = pCertTemplate->SaveChanges ();
                                if ( FAILED (hr) )
                                {
                                    CString caption;
                                    CString text;

                                    VERIFY (caption.LoadString (IDS_CERTTMPL));
                                    // security review BryanWal 2/20/2002 ok
                                    text.FormatMessage (IDS_UNABLE_TO_SAVE_CERT_TEMPLATE_CHANGES, GetSystemMessage (hr));

                                    int     iRetVal = 0;
                                    VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption,
                                            MB_ICONWARNING | MB_OK, &iRetVal)));
                                }
                            }
                            else
                            {
                                CString caption;
                                CString text;

                                VERIFY (caption.LoadString (IDS_CERTTMPL));
                                // security review BryanWal 2/20/2002 ok
                                text.FormatMessage (IDS_CANNOT_CHANGE_DISPLAY_NAME, hr);

                                int     iRetVal = 0;
                                VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption,
                                        MB_ICONWARNING | MB_OK, &iRetVal)));
                            }
                        }
                    }
                }
                else
                {
                    CString caption;
                    CString text;

                    VERIFY (caption.LoadString (IDS_CERTTMPL));
                    VERIFY (text.LoadString (IDS_MUST_TYPE_TEMPLATE_DISPLAY_NAME));
                    int     iRetVal = 0;
                    VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption,
                            MB_ICONWARNING | MB_OK, &iRetVal)));
                    hr = S_FALSE;
                }
            }
            break;

        default:
            break;
        }
    }

    if ( !SUCCEEDED (hr) )
        hr = S_FALSE;

    _TRACE(-1, L"Leaving CCertTmplComponent::OnNotifyRename: 0x%x\n", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\certtemplate.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       CertTemplate.h
//
//  Contents:   CCertTemplate
//
//----------------------------------------------------------------------------
/// CertTemplate.h: interface for the CCertTemplate class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CERTTEMPLATE_H__2562C528_F60F_4F4B_9E2A_FBD96732369C__INCLUDED_)
#define AFX_CERTTEMPLATE_H__2562C528_F60F_4F4B_9E2A_FBD96732369C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "cookie.h"

typedef enum {
    PERIOD_TYPE_NONE = -1,
    PERIOD_TYPE_DAY = 0,
    PERIOD_TYPE_WEEK,
    PERIOD_TYPE_MONTH,
    PERIOD_TYPE_YEAR
} PERIOD_TYPE;

class CCertTemplate : public CCertTmplCookie  
{
public:
	CCertTemplate(
            PCWSTR pszObjectName, 
            PCWSTR pszTemplateName, 
            const CString& szLDAPPath,
            bool fIsReadOnly,
            const bool fUseCache);
	CCertTemplate (
            const CCertTemplate& rTemplate, 
            bool bIsClone, 
            bool fIsReadOnly, 
            const bool fUseCache);
	virtual ~CCertTemplate();

public:
    bool FailedToSetSecurity () const
    {
        return m_fFailedToSetSecurity;
    }

    void FailedToSetSecurity (bool bFailed)
    {
        m_fFailedToSetSecurity = bFailed;
    }
    void SetCanBeDeletedOnCancel ()
    {
        m_bCanBeDeletedOnCancel = true;
    }
	bool IssuancePoliciesRequired () const;
	void IssuancePoliciesRequired (bool bRequired);
    HRESULT GetDigitalSignature(
                bool &bHasDigitalSignature, 
                bool* pbHasOnlyDigitalSignature = 0);
	HRESULT SetDigitalSignature (
                bool bSet, 
                bool bSetOnlyDigitalSignature = false);
	HRESULT GetSubjectTypeDescription (int nIndex, CString &szSubjectTypeDescription);
//	bool AllowAutoenrollment (); /*  NO LONGER NEEDED  NTRAID# 321742 */
    bool UserInteractionRequired () const;
    HRESULT SetUserInteractionRequired(bool bSet);
    bool StrongKeyProtectionRequired () const;
    HRESULT SetStrongKeyProtectionRequired(bool bSet);
    bool RemoveInvalidCertFromPersonalStore () const;
    HRESULT SetRemoveInvalidCertFromPersonalStore(bool bRemove);
    HRESULT IsExtensionCritical (PCWSTR szExtension, bool& bCritical);
    HRESULT ModifyCriticalExtensions (const CString &szExtension, bool bAdd);
	HRESULT Cancel();
	void FreeCertExtensions ();
    HRESULT GetEnhancedKeyUsage (int nIndex, CString &szEKU);
    HRESULT SetEnhancedKeyUsage (const PWSTR* pawszEKU, bool bCritical);
    HRESULT GetApplicationPolicy (int nIndex, CString &szAppPolicy);
    HRESULT SetApplicationPolicy (const PWSTR* pawszAppPolicy, bool bCritical);
    HRESULT SetCertPolicy (const PWSTR* pawszCertPolicy, bool bCritical);
	HRESULT SetCheckDSCert (bool bIgnore);
	bool CheckDSCert () const;
    HRESULT SetBasicConstraints(PCERT_BASIC_CONSTRAINTS2_INFO pBCInfo, 
                bool bCritical);
	HRESULT SetKeyUsage (CRYPT_BIT_BLOB* pKeyUsage, bool bCritical);
	bool GoodForAutoEnrollment () const;
	HRESULT IncrementMinorVersion ();
	HRESULT IncrementMajorVersion ();
	HRESULT GetMinorVersion (DWORD& dwMinorVersion) const;
	HRESULT GetMajorVersion (DWORD& dwMajorVersion) const;
	HRESULT SetPendAllRequests (bool bPend);
	bool PendAllRequests () const;
	HRESULT SetReenrollmentValidWithPreviousApproval (bool bValid);
	bool ReenrollmentValidWithPreviousApproval () const;
	HRESULT SetRANumSignaturesRequired (DWORD dwNumSignaturesRequired);
	HRESULT GetRANumSignaturesRequired (DWORD& dwNumSignatures);
	HRESULT SetPublishToDS (bool bPublish);
	HRESULT SetRenewalPeriod (int nDays);
	HRESULT SetValidityPeriod (int nDays);
	CString GetLDAPPath () const;
	HRESULT GetSecurity (PSECURITY_DESCRIPTOR* ppSD) const;
	HRESULT SetSecurity (PSECURITY_DESCRIPTOR pSD);
	bool ReadOnly () const;
	HRESULT GetSupercededTemplate (int nIndex, CString& szSupercededTemplate);
	HRESULT ModifySupercededTemplateList(const CString &szSupercededTemplateName, 
                bool bAdd);
	HRESULT GetCSP (int nIndex, CString& szCSP);
    HRESULT GetCertPolicy (int nIndex, CString& szCertPolicy);
	HRESULT ModifyCSPList(const CString &szCSPName, bool bAdd);
	HRESULT GetRAIssuancePolicy(int nIndex, CString& szRAPolicyOID);
	HRESULT GetRAApplicationPolicy(int nIndex, CString& szRAPolicyOID);
	HRESULT ModifyRAIssuancePolicyList(const CString &szRAPolicyOID, bool bAdd);
	HRESULT ModifyRAApplicationPolicyList(const CString &szRAPolicyOID, bool bAdd);
    HRESULT SetMinimumKeySizeValue (DWORD dwMinKeySize);
	HRESULT AltNameIncludesSPN (bool bIncludesSPN);
	bool AltNameIncludesSPN () const;
	HRESULT RequireSubjectInRequest (bool bRequire);
	HRESULT SubjectNameMustBeCN (bool bMustBeCN);
	bool SubjectNameMustBeCN () const;
	HRESULT SubjectNameMustBeFullDN (bool bMustBeDN);
	bool SubjectNameMustBeFullDN () const;
	HRESULT SubjectNameIncludesEMail (bool bIncludesEMail);
	bool SubjectNameIncludesEMail () const;
	HRESULT AltNameIncludesUPN (bool bIncludesUPN);
	bool AltNameIncludesUPN () const;
	HRESULT AltNameIncludesEMail (bool bIncludesEMail);
	bool AltNameIncludesEMail () const;
	HRESULT AltNameIncludesDNS (bool fIncludeDNS);
	bool AltNameIncludesDNS () const;
	HRESULT DoAutoEnrollmentPendingSave ();
	HRESULT IncludeSymmetricAlgorithms (bool bInclude);
	bool IncludeSymmetricAlgorithms () const;
	HRESULT AllowPrivateKeyArchival (bool bAllowArchival);
	bool AllowPrivateKeyArchival () const;
	HRESULT MakePrivateKeyExportable (bool bMakeExportable);
	bool PrivateKeyIsExportable () const;
	HRESULT GetMinimumKeySize (DWORD& dwMinKeySize) const;
	HRESULT SetAutoEnrollment (bool bSuitableForAutoEnrollment);
	bool CanBeDeletedOnCancel () const;
	HRESULT SetEncryptionSignature (bool bHasEncryptionSignature);
	HRESULT SetKeySpecSignature (bool bHasKeySpecSignature);
	HRESULT SetSubjectIsCA (bool bSubjectIsCA);
	HRESULT SaveChanges (bool bIncrementMinorVersion = true);
	HRESULT SetDisplayName (const CString& strDisplayName, bool bForce = false);
	HRESULT SetTemplateName (const CString& strTemplateName);
	bool IsClone () const;
	bool IsDefault () const;
	HRESULT Delete ();
	HRESULT Clone (
            const CCertTemplate& rTemplate, 
            const CString& strTemplateName, 
            const CString& strDisplayName);
	HRESULT GetValidityPeriod (int& nValidityDays);
	HRESULT GetRenewalPeriod (int& nRenewalDays);
	bool RequireSubjectInRequest () const;
	bool HasEncryptionSignature () const;
	bool HasKeySpecSignature () const;
	HRESULT GetCertExtension (DWORD dwIndex, PSTR* ppszObjId, BOOL& fCritical);
	HRESULT GetCertExtension (PSTR pszOID, PCERT_EXTENSION* ppCertExtension);
	DWORD GetCertExtensionCount ();
	bool PublishToDS () const;
	bool IsMachineType () const;
	bool SubjectIsCA() const;
	bool SubjectIsCrossCA() const;
	CString GetTemplateName() const;
    CString GetDisplayName ();
	DWORD GetType() const;
	HRESULT Initialize ();

protected:
    HRESULT ConvertCertTypeFileTimeToDays (FILETIME const *pftCertType, int& nDays);
    CString GetDN () const;

private:
	bool m_fFailedToSetSecurity;
	bool m_bIssuancePoliciesRequired;
    PCERT_EXTENSIONS m_pCertExtensions; 
	int     m_nNewRenewalDays;
	int     m_nOriginalRenewalDays;
	int     m_nNewValidityDays;
	int     m_nOriginalValidityDays;
	const bool m_fIsReadOnly;
	bool m_bGoodForAutoenrollmentFlagPendingSave;
	bool m_bCanBeDeletedOnCancel;
    HRESULT SetFlag (DWORD dwFlagType, DWORD dwFlag, bool bValue);

	CString     m_strOriginalTemplateName;
	bool        m_bIsClone;
	DWORD       m_dwKeySpec;
	DWORD       m_dwEnrollmentFlags;
    DWORD       m_dwSubjectNameFlags;
    DWORD       m_dwPrivateKeyFlags;
    DWORD       m_dwGeneralFlags;

    DWORD       m_dwVersion;
	HCERTTYPE   m_hCertType;
	CString     m_strTemplateName;
    CString     m_szLDAPPath;
    CString     m_szDisplayName;
    const bool  m_fUseCache;

protected:
    HRESULT ModifyStringList(const CString& szPropertyName, 
                            PWSTR** ppStringList, 
                            const CString &szCSPName, 
                            bool bAdd);
};

#endif // !defined(AFX_CERTTEMPLATE_H__2562C528_F60F_4F4B_9E2A_FBD96732369C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\cmponent.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       cmponent.h
//
//  Contents:   CCertTmplComponent
//
//----------------------------------------------------------------------------
// cmponent.h : Declaration of CCertTmplComponent

#ifndef __CMPONENT_H_INCLUDED__
#define __CMPONENT_H_INCLUDED__

#include "cookie.h"     // CCertTmplCookie
#include "CertTemplate.h"   // CCertTemplate

#define UPDATE_HINT_ENUM_CERT_TEMPLATES	    0x01

enum {
    IDM_CLONE_TEMPLATE = 101,
    IDM_REENROLL_ALL_CERTS,
    IDM_VIEW_OIDS
};

// forward declarations
class CCertTmplComponentData;

class CCertTmplComponent :
	public CComponent,
	public IExtendContextMenu,
	public ICertTemplatesSnapin,
	public IExtendPropertySheet,
	public IResultDataCompareEx,
	public PersistStream
{
public:
	CCertTmplComponent();
	virtual ~CCertTmplComponent();
BEGIN_COM_MAP(CCertTmplComponent)
	COM_INTERFACE_ENTRY(ICertTemplatesSnapin)
	COM_INTERFACE_ENTRY(IExtendContextMenu)
	COM_INTERFACE_ENTRY(IExtendPropertySheet)
	COM_INTERFACE_ENTRY(IResultDataCompareEx)
	COM_INTERFACE_ENTRY(IPersistStream) // security review BryanWal 2/20/2002 ok
    COM_INTERFACE_ENTRY_CHAIN(CComponent)
END_COM_MAP()

#if DBG==1
	ULONG InternalAddRef()
	{
        return CComObjectRoot::InternalAddRef();
	}
	ULONG InternalRelease()
	{
        return CComObjectRoot::InternalRelease();
	}
    int dbg_InstID;
#endif // DBG==1



// IExtendContextMenu
public:
  STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject,
                          LPCONTEXTMENUCALLBACK pCallbackUnknown,
                          long *pInsertionAllowed);
  STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);


// IResultDataCompareEx
    STDMETHOD(Compare)(RDCOMPARE* prdc, int* pnResult);

// IComponent implemented in CComponent
	// support methods for IComponent
	virtual HRESULT ReleaseAll();
	virtual HRESULT OnPropertyChange( LPARAM param );
	virtual HRESULT OnViewChange (LPDATAOBJECT pDataObject, LPARAM data, LPARAM hint);
	virtual HRESULT Show(CCookie* pcookie, LPARAM arg, HSCOPEITEM hScopeItem, LPDATAOBJECT pDataObject);
	virtual HRESULT Show(CCookie* pcookie, LPARAM arg, HSCOPEITEM hScopeItem);
	virtual HRESULT OnNotifyAddImages( LPDATAOBJECT pDataObject,
	                                   LPIMAGELIST lpImageList,
	                                   HSCOPEITEM hSelectedItem );
	virtual HRESULT OnNotifyColumnClick (LPDATAOBJECT pDataObject,
										LPARAM iColumn,
										LPARAM uFlags);

	HRESULT PopulateListbox(CCertTmplCookie* pcookie);
	HRESULT RefreshResultPane(const bool bSilent);

	static HRESULT LoadStrings();
    HRESULT LoadColumns( CCertTmplCookie* pcookie );

	CCertTmplComponentData& QueryComponentDataRef()
	{
		return (CCertTmplComponentData&)QueryBaseComponentDataRef();
	}

public:
	STDMETHOD(GetDisplayInfo)(RESULTDATAITEM* pResultDataItem);
	CCertTmplCookie* m_pViewedCookie; // CODEWORK I hate to have to do this...

	inline CCertTmplCookie* ActiveCookie( CCookie* pBaseCookie )
	{
		return (CCertTmplCookie*)ActiveBaseCookie( pBaseCookie );
	}

// IExtendPropertySheet
	STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK pCall, LONG_PTR handle, LPDATAOBJECT pDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT pDataObject);

	// PersistStream
    HRESULT STDMETHODCALLTYPE Load(IStream __RPC_FAR *pStg);
    HRESULT STDMETHODCALLTYPE Save(IStream __RPC_FAR *pStgSave, BOOL fSameAsLoad);


private:
    CertTmplObjectType      m_currResultNodeType;
    CString                 m_szDisplayInfoResult;
    UINT*                   m_ColumnWidths[CERTTMPL_NUMTYPES];
    CString                 m_szCertTemplatePath;
    int                     m_nSortColumn;

	void SetTextNotAvailable ();

protected:
    virtual HRESULT     OnNotifyRename(
						    LPDATAOBJECT lpDataObject, 
							LPARAM arg, 
							LPARAM param);
    HRESULT EnumerateTemplates (IDirectoryObject* pTemplateContObj,
                const BSTR bszTemplateContainerPath);
	HRESULT AddEnterpriseTemplates ();
	HRESULT DeleteCertTemplateFromResultPane (
                CCertTemplate* pCertTemplate, 
                LPDATAOBJECT pDataObject);
	HRESULT	DeleteCookie (
				CCertTmplCookie* pCookie,
				LPDATAOBJECT pDataObject,
				bool bRequestConfirmation,
				bool bIsMultipleSelect);
	HRESULT RefreshResultItem (CCertTmplCookie* pCookie);
	CCertTmplCookie* ConvertCookie (LPDATAOBJECT pDataObject);
	HRESULT OnNotifyCutOrMove (LPARAM arg);
	HRESULT SaveWidths (CCertTmplCookie* pCookie);
	HRESULT LoadColumnsFromArrays (CertTmplObjectType objecttype);
	STDMETHOD(Initialize)(LPCONSOLE lpConsole);
    STDMETHOD(GetResultViewType)(MMC_COOKIE cookie, BSTR* ppViewType, long* pViewOptions);
	HRESULT OnNotifyQueryPaste (LPDATAOBJECT pDataObject, LPARAM arg, LPARAM param);
	HRESULT OnNotifyPaste (LPDATAOBJECT pDataObject, LPARAM arg, LPARAM param);
    STDMETHOD(Notify)(LPDATAOBJECT pDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
	virtual HRESULT OnNotifyDelete (LPDATAOBJECT pDataObject);
	virtual HRESULT OnNotifyRefresh (LPDATAOBJECT pDataObject);
	virtual HRESULT OnNotifySelect( LPDATAOBJECT pDataObject, BOOL fSelected);
	virtual HRESULT OnNotifySnapinHelp (LPDATAOBJECT pDataObject);
	virtual HRESULT OnNotifyDblClick( LPDATAOBJECT pDataObject );

}; // class CCertTmplComponent


// Enumeration for the icons used
enum
{
	iIconDefault = 0,
    iIconCertTemplateV1,
    iIconCertTemplateV2,
	iIconLast		// Must be last
};


typedef enum _COLNUM_CERT_TEMPLATES {
    COLNUM_CERT_TEMPLATE_OBJECT = 0,
    COLNUM_CERT_TEMPLATE_TYPE,
    COLNUM_CERT_TEMPLATE_VERSION,
    COLNUM_CERT_TEMPLATE_AUTOENROLL_STATUS,
    CERT_TEMPLATES_NUM_COLS      // always last
} COLNUM_CERT_TEMPLATES;


#endif // ~__CMPONENT_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\compdata.cpp ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       compdata.cpp
//
//  Contents:   Implementation of CCertTmplComponentData
//
//----------------------------------------------------------------------------

#include "stdafx.h"

USE_HANDLE_MACROS ("CERTTMPL (compdata.cpp)")
#include "compdata.h"
#include "dataobj.h"
#include "cookie.h"
#include "uuids.h"
#include "TemplateGeneralPropertyPage.h"
#include "TemplateV1RequestPropertyPage.h"
#include "TemplateV2RequestPropertyPage.h"
#include "TemplateV1SubjectNamePropertyPage.h"
#include "TemplateV2SubjectNamePropertyPage.h"
#include "TemplateV2AuthenticationPropertyPage.h"
#include "TemplateV2SupercedesPropertyPage.h"
#include "TemplateExtensionsPropertyPage.h"
#include "SecurityPropertyPage.h"
#include "TemplatePropertySheet.h"
#include "ViewOIDDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "dbg.h"
#include "stdcdata.cpp" // CComponentData implementation

extern  HINSTANCE   g_hInstance;
POLICY_OID_LIST     g_policyOIDList;

BOOL CALLBACK AddPageProc(HPROPSHEETPAGE hPage, LPARAM pCall);

extern bool g_bSchemaIsW2K;
bool g_bDomainIsPresent = true;

//
// CCertTmplComponentData
//

CCertTmplComponentData::CCertTmplComponentData ()
    : m_RootCookie (CERTTMPL_SNAPIN),
    m_hRootScopeItem (0),
    m_pResultData (0),
    m_bIsUserAdministrator (FALSE),
    m_pHeader (0),
    m_bMultipleObjectsSelected (false),
    m_dwNumCertTemplates (0),
    m_pComponentConsole (0),
    m_fUseCache (false),
    m_bSchemaChecked (false)
{
    _TRACE (1, L"Entering CCertTmplComponentData::CCertTmplComponentData\n");

    // Get name of logged-in user
    DWORD   dwSize = 0;
    BOOL bRet = ::GetUserName (0, &dwSize);
    if ( dwSize > 0 )
    {
        bRet = ::GetUserName (m_szLoggedInUser.GetBufferSetLength (dwSize), &dwSize);
        _ASSERT (bRet);
        m_szLoggedInUser.ReleaseBuffer ();
    }

    // Get name of this computer
    dwSize = MAX_COMPUTERNAME_LENGTH + 1 ;
    bRet = ::GetComputerName (m_szThisComputer.GetBufferSetLength (MAX_COMPUTERNAME_LENGTH + 1 ), &dwSize);
    _ASSERT (bRet);
    m_szThisComputer.ReleaseBuffer ();

    // Find out if logged-in users is an Administrator
    HRESULT hr = IsUserAdministrator (m_bIsUserAdministrator);
    _ASSERT (SUCCEEDED (hr));

    // default help file name.
    SetHtmlHelpFileName (CERTTMPL_HTML_HELP_FILE);

    // Find out if we're joined to a domain.
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC    pInfo = 0;
    DWORD dwErr = ::DsRoleGetPrimaryDomainInformation (
            0,
            DsRolePrimaryDomainInfoBasic, 
            (PBYTE*) &pInfo);
    if ( ERROR_SUCCESS == dwErr )
    {
        if ( pInfo->Flags & DSROLE_PRIMARY_DS_RUNNING ||
                pInfo->Flags & DSROLE_PRIMARY_DOMAIN_GUID_PRESENT )
        {
            m_szThisDomainDns = pInfo->DomainNameDns;
            m_RootCookie.SetManagedDomainDNSName (m_szThisDomainDns);
            m_szThisDomainFlat = pInfo->DomainNameFlat;
        }
    }
    else
    {
        _TRACE (0, L"DsRoleGetPrimaryDomainInformation () failed: 0x%x\n", dwErr);
    }

    ::DsRoleFreeMemory (pInfo);

    _TRACE (-1, L"Leaving CCertTmplComponentData::CCertTmplComponentData\n");
}

CCertTmplComponentData::~CCertTmplComponentData ()
{
    _TRACE (1, L"Entering CCertTmplComponentData::~CCertTmplComponentData\n");
    CCookie& rootCookie = QueryBaseRootCookie ();
    while ( !rootCookie.m_listResultCookieBlocks.IsEmpty() )
    {
        (rootCookie.m_listResultCookieBlocks.RemoveHead())->Release();
    }

    if ( m_pResultData )
    {
        m_pResultData->Release ();
        m_pResultData = 0;
    }

    if ( m_pComponentConsole )
    {
        SAFE_RELEASE (m_pComponentConsole);
        m_pComponentConsole = 0;
    }

    _TRACE (-1, L"Leaving CCertTmplComponentData::~CCertTmplComponentData\n");
}

DEFINE_FORWARDS_MACHINE_NAME ( CCertTmplComponentData, (&m_RootCookie) )

CCookie& CCertTmplComponentData::QueryBaseRootCookie ()
{
    return (CCookie&) m_RootCookie;
}


STDMETHODIMP CCertTmplComponentData::CreateComponent (LPCOMPONENT* ppComponent)
{
    _TRACE (1, L"Entering CCertTmplComponentData::CreateComponent\n");
    _ASSERT (ppComponent);

    CComObject<CCertTmplComponent>* pObject = 0;
    CComObject<CCertTmplComponent>::CreateInstance (&pObject);
    _ASSERT (pObject);
    pObject->SetComponentDataPtr ( (CCertTmplComponentData*) this);

    _TRACE (-1, L"Leaving CCertTmplComponentData::CreateComponent\n");
    return pObject->QueryInterface (IID_PPV_ARG (IComponent, ppComponent));
}

HRESULT CCertTmplComponentData::LoadIcons (LPIMAGELIST pImageList, BOOL /*fLoadLargeIcons*/)
{
    _TRACE (1, L"Entering CCertTmplComponentData::LoadIcons\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());

    // Structure to map a Resource ID to an index of icon
    struct RESID2IICON
    {
        UINT uIconId;   // Icon resource ID
        int iIcon;      // Index of the icon in the image list
    };
    const static RESID2IICON rgzLoadIconList[] =
    {
        // Misc icons
        { IDI_CERT_TEMPLATEV1, iIconCertTemplateV1 },
        { IDI_CERT_TEMPLATEV2, iIconCertTemplateV2 },
        { 0, 0} // Must be last
    };


    HINSTANCE   hInst = AfxGetInstanceHandle ();
    for (int i = 0; rgzLoadIconList[i].uIconId != 0; i++)
    {
        HICON hIcon = ::LoadIcon (hInst,
                MAKEINTRESOURCE (rgzLoadIconList[i].uIconId));
        _ASSERT (hIcon && "Icon ID not found in resources");
        if ( hIcon )
        {
            HRESULT hr = pImageList->ImageListSetIcon ( (PLONG_PTR) hIcon,
                    rgzLoadIconList[i].iIcon);
            _ASSERT (SUCCEEDED (hr) && "Unable to add icon to ImageList");
        }
    }
    _TRACE (-1, L"Leaving CCertTmplComponentData::LoadIcons\n");

    return S_OK;
}


HRESULT CCertTmplComponentData::OnNotifyExpand (LPDATAOBJECT pDataObject, BOOL bExpanding, HSCOPEITEM hParent)
{
    _TRACE (1, L"Entering CCertTmplComponentData::OnNotifyExpand\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    HRESULT     hr = S_OK;
    CWaitCursor waitCursor;

    _ASSERT (pDataObject && hParent && m_pConsoleNameSpace);
    if ( bExpanding )
    {
        // Need to check schema first before getting OIDs (sets g_bSchemaIsW2K)
        if ( !m_bSchemaChecked )
        {
            InstallWindows2002CertTemplates ();
            m_bSchemaChecked = true;
        }

        if ( 0 == g_policyOIDList.GetCount () )
        {
            hr = GetEnterpriseOIDs ();
            if ( FAILED (hr) )
            {
                if ( HRESULT_FROM_WIN32 (ERROR_DS_NO_SUCH_OBJECT) == hr )
                    g_bSchemaIsW2K = true;
                else if ( HRESULT_FROM_WIN32 (ERROR_NO_SUCH_DOMAIN) == hr )
                    g_bDomainIsPresent = false;

                if ( !g_bSchemaIsW2K )
                {
                    CString caption;
                    CString text;

                    VERIFY (caption.LoadString (IDS_CERTTMPL));
                    // security review BryanWal 2/20/2002 ok
                    text.FormatMessage (IDS_CANNOT_LOAD_OID_LIST, GetSystemMessage (hr));

                    int     iRetVal = 0;
                    VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption,
                            MB_ICONWARNING | MB_OK, &iRetVal)));
                }
                else
                    hr = S_OK;
            }
        }


        GUID guidObjectType;
        hr = ExtractObjectTypeGUID (pDataObject, &guidObjectType);
        _ASSERT (SUCCEEDED (hr));

        // Beyond this point we are not dealing with extension node types.
        {
            CCertTmplCookie* pParentCookie = ConvertCookie (pDataObject);
            if ( pParentCookie )
            {
                hr = ExpandScopeNodes (pParentCookie, hParent, guidObjectType, pDataObject);
            }
            else
                hr = E_UNEXPECTED;
        }
    }
    else
        hr = S_OK;


    _TRACE (-1, L"Leaving CCertTmplComponentData::OnNotifyExpand: 0x%x\n", hr);
    return hr;
}

HRESULT CCertTmplComponentData::OnNotifyRelease (LPDATAOBJECT /*pDataObject*/, HSCOPEITEM hItem)
{
    _TRACE (1, L"Entering CCertTmplComponentData::OnNotifyRelease\n");
    // _ASSERT ( IsExtensionSnapin () );
    // This might also happen if I expand a node and then remove
    // the snapin via Snapin Manager
    HRESULT hr = DeleteChildren (hItem);

    _TRACE (-1, L"Leaving CCertTmplComponentData::OnNotifyRelease: 0x%x\n", hr);
    return hr;
}

// global space to store the string handed back to GetDisplayInfo ()
// CODEWORK should use "bstr" for ANSI-ization
CString g_strResultColumnText;

BSTR CCertTmplComponentData::QueryResultColumnText (CCookie& basecookie, int /*nCol*/)
{
    BSTR    strResult = L"";

    CCertTmplCookie& cookie = (CCertTmplCookie&) basecookie;
#ifndef UNICODE
#error not ANSI-enabled
#endif
    switch ( cookie.m_objecttype )
    {
        case CERTTMPL_SNAPIN:
            break;

        case CERTTMPL_CERT_TEMPLATE:
            _ASSERT (0);
            break;

        default:
            break;
    }

    return strResult;
}

int CCertTmplComponentData::QueryImage (CCookie& basecookie, BOOL /*fOpenImage*/)
{
    int             nIcon = 0;

    CCertTmplCookie& cookie = (CCertTmplCookie&)basecookie;
    switch ( cookie.m_objecttype )
    {
        case CERTTMPL_SNAPIN:
            nIcon = iIconCertTemplateV2;
            break;

        case CERTTMPL_CERT_TEMPLATE:
            {
                CCertTemplate& rCertTemplate = (CCertTemplate&) cookie;

                if ( 1 == rCertTemplate.GetType () )
                    nIcon = iIconCertTemplateV1;
                else
                    nIcon = iIconCertTemplateV2;
            }
            break;

        default:
            _TRACE (0, L"CCertTmplComponentData::QueryImage bad parent type\n");
            break;
    }
    return nIcon;
}


///////////////////////////////////////////////////////////////////////////////
/// IExtendPropertySheet

STDMETHODIMP CCertTmplComponentData::QueryPagesFor (LPDATAOBJECT pDataObject)
{
    _TRACE (1, L"Entering CCertTmplComponentData::QueryPagesFor\n");
    HRESULT hr = S_OK;
    _ASSERT (pDataObject);

    if ( pDataObject )
    {
        DATA_OBJECT_TYPES dataobjecttype = CCT_SCOPE;
        hr = ::ExtractData (pDataObject,
                CCertTemplatesDataObject::m_CFDataObjectType,
                 &dataobjecttype, sizeof (dataobjecttype));
        if ( SUCCEEDED (hr) )
        {
            switch (dataobjecttype)
            {
            case CCT_SNAPIN_MANAGER:
                hr = S_FALSE;
                break;

            case CCT_RESULT:
                {
                    hr = S_FALSE;
                    CCertTmplCookie* pParentCookie = ConvertCookie (pDataObject);
                    if ( pParentCookie )
                    {
                        switch (pParentCookie->m_objecttype)
                        {
                        case CERTTMPL_CERT_TEMPLATE:
                            hr = S_OK;
                            break;

                        default:
                            break;
                        }
                    }
                }
                break;

            case CCT_SCOPE:
                hr = S_FALSE;
                break;

            default:
                hr = S_FALSE;
                break;
            }
        }
    }
    else
        hr = E_POINTER;


    _TRACE (-1, L"Leaving CCertTmplComponentData::QueryPagesFor: 0x%x\n", hr);
    return hr;
}

STDMETHODIMP CCertTmplComponentData::CreatePropertyPages (
    LPPROPERTYSHEETCALLBACK pCallback,
    LONG_PTR lNotifyHandle,        // This handle must be saved in the property page object to notify the parent when modified
    LPDATAOBJECT pDataObject)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    _TRACE (1, L"Entering CCertTmplComponentData::CreatePropertyPages\n");
    HRESULT hr = S_OK;


    _ASSERT (pCallback && pDataObject);
    if ( pCallback && pDataObject )
    {
        DATA_OBJECT_TYPES dataobjecttype = CCT_SCOPE;
        hr = ::ExtractData (pDataObject,
                CCertTemplatesDataObject::m_CFDataObjectType,
                 &dataobjecttype, sizeof (dataobjecttype));
        switch (dataobjecttype)
        {
        case CCT_SNAPIN_MANAGER:
            break;

        case CCT_RESULT:
            {
                CCertTmplCookie* pParentCookie = ConvertCookie (pDataObject);
                if ( pParentCookie )
                {
                    switch (pParentCookie->m_objecttype)
                    {
                    case CERTTMPL_CERT_TEMPLATE:
                        {
                            CCertTemplate* pCertTemplate = 
                                    dynamic_cast <CCertTemplate*> (pParentCookie);
                            _ASSERT (pCertTemplate);
                            if ( pCertTemplate )
                            {
                                hr = AddCertTemplatePropPages (pCertTemplate, 
                                        pCallback, lNotifyHandle);
                            }
                            else
                                hr = E_FAIL;
                        }
                        break;

                    default:
                        _ASSERT (0);
                        break;
                    }
                }
                else
                    hr = E_UNEXPECTED;
            }
            break;

        case CCT_SCOPE:
            {
                CCertTmplCookie* pParentCookie = ConvertCookie (pDataObject);
                if ( pParentCookie )
                {
                }
                else
                    hr = E_UNEXPECTED;
            }
            break;


        default:
            break;
        }
    }
    else
        hr = E_POINTER;

    _TRACE (-1, L"Leaving CCertTmplComponentData::CreatePropertyPages: 0x%x\n", hr);
    return hr;
}




BOOL IsMMCMultiSelectDataObject(IDataObject* pDataObject)
{
    if (pDataObject == NULL)
        return FALSE;

    static UINT s_cf = 0;
    if (s_cf == 0)
    {
        USES_CONVERSION;
        s_cf = RegisterClipboardFormat(CCF_MMC_MULTISELECT_DATAOBJECT);
    }

    FORMATETC fmt = {(CLIPFORMAT)s_cf, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    return (pDataObject->QueryGetData(&fmt) == S_OK);
}


///////////////////////////////////////////////////////////////////////////////
// IExtendContextMenu implementation
//
STDMETHODIMP CCertTmplComponentData::AddMenuItems (LPDATAOBJECT pDataObject,
                                            LPCONTEXTMENUCALLBACK pContextMenuCallback,
                                            long *pInsertionAllowed)
{
    _TRACE (1, L"Entering CCertTmplComponentData::AddMenuItems\n");
    HRESULT                         hr = S_OK;

    CCertTmplCookie*                 pCookie = 0;

    LPDATAOBJECT    pMSDO = ExtractMultiSelect (pDataObject);
    m_bMultipleObjectsSelected = false;

    if ( pMSDO )
    {
        m_bMultipleObjectsSelected = true;

        CCertTemplatesDataObject* pDO = dynamic_cast <CCertTemplatesDataObject*>(pMSDO);
        _ASSERT (pDO);
        if ( pDO )
        {
            // Get first cookie - all items should be the same?
            // Is this a valid assumption?
            // TODO: Verify
            pDO->Reset();
            if ( pDO->Next(1, reinterpret_cast<MMC_COOKIE*>(&pCookie), NULL) == S_FALSE )
                return S_FALSE;
        }
        else
            return E_UNEXPECTED;

    }
    else
        pCookie = ConvertCookie (pDataObject);
    _ASSERT (pCookie);
    if ( !pCookie )
        return E_UNEXPECTED;

    CertTmplObjectType    objType = pCookie->m_objecttype;


    if ( *pInsertionAllowed & CCM_INSERTIONALLOWED_TOP )
    {
        switch (objType)
        {
        case CERTTMPL_CERT_TEMPLATE:
            if ( !m_bMultipleObjectsSelected )
            {
                CCertTemplate* pCertTemplate = dynamic_cast <CCertTemplate*> (pCookie);
                _ASSERT (pCertTemplate);
                if ( pCertTemplate )
                {
                    if ( !g_bSchemaIsW2K )
                    {
                        // NTRAID# 457682 Certtmpl.msc: Should not allow 
                        // admins to duplicate certificate template if windows 
                        // did not upgrade templates successfully
                        if ( !pCertTemplate->IsDefault () || 
                                CAIsCertTypeCurrent (0, 
                                    const_cast<PWSTR>((PCWSTR) pCertTemplate->GetTemplateName ())) )
                        {
                            hr = AddCloneTemplateMenuItem (pContextMenuCallback,
                                    CCM_INSERTIONPOINTID_PRIMARY_TOP);
                        }
                        if ( SUCCEEDED (hr) )
                        {
                            // NTRAID# 471160 Certtmpl: Remove option to 
                            // "ReEnroll all Certificate Holders" on any V1 
                            // Certificate Template.  V2 ONLY.
                            if ( pCertTemplate->GetType () > 1 )
                            {
                                hr = AddReEnrollAllCertsMenuItem (pContextMenuCallback,
                                        CCM_INSERTIONPOINTID_PRIMARY_TOP);
                            }
                        }
                    }
                }
                else
                    hr = E_FAIL;
            }
            break;

        case CERTTMPL_SNAPIN:
            _ASSERT (!m_bMultipleObjectsSelected);
            hr = AddViewOIDsMenuItem (pContextMenuCallback,
                                CCM_INSERTIONPOINTID_PRIMARY_TOP);
            break;


        default:
            break;
        }
    }
    if ( *pInsertionAllowed & CCM_INSERTIONALLOWED_NEW  )
    {
    }
    if ( *pInsertionAllowed & CCM_INSERTIONALLOWED_TASK )
    {
        switch (objType)
        {
        case CERTTMPL_CERT_TEMPLATE:
            if ( !m_bMultipleObjectsSelected )
            {
                CCertTemplate* pCertTemplate = dynamic_cast <CCertTemplate*> (pCookie);
                _ASSERT (pCertTemplate);
                if ( pCertTemplate )
                {
                    if ( !g_bSchemaIsW2K )
                    {
                        hr = AddCloneTemplateMenuItem (pContextMenuCallback,
                                CCM_INSERTIONPOINTID_PRIMARY_TASK);
                        if ( SUCCEEDED (hr) )
                        {
                            // NTRAID# 471160 Certtmpl: Remove option to 
                            // "ReEnroll all Certificate Holders" on any V1 
                            // Certificate Template.  V2 ONLY.
                            if ( pCertTemplate->GetType () > 1 )
                            {
                                hr = AddReEnrollAllCertsMenuItem (pContextMenuCallback,
                                        CCM_INSERTIONPOINTID_PRIMARY_TASK);
                            }
                        }
                    }
                }
                else
                    hr = E_FAIL;
            }
            break;

        case CERTTMPL_SNAPIN:
            _ASSERT (!m_bMultipleObjectsSelected);
            hr = AddViewOIDsMenuItem (pContextMenuCallback,
                                CCM_INSERTIONPOINTID_PRIMARY_TASK);
            break;
        }
    }
    if ( *pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW )
    {
        switch (objType)
        {
        case CERTTMPL_SNAPIN:
            _ASSERT (!m_bMultipleObjectsSelected);
            break;

        case CERTTMPL_CERT_TEMPLATE:
            _ASSERT (0);
            break;

        default:
            break;
        }
    }

    _TRACE (-1, L"Leaving CCertTmplComponentData::AddMenuItems: 0x%x\n", hr);
    return hr;
}


STDMETHODIMP CCertTmplComponentData::Command (long nCommandID, LPDATAOBJECT pDataObject)
{
    HRESULT hr = S_OK;

    switch (nCommandID)
    {
    case IDM_CLONE_TEMPLATE:
        hr = OnCloneTemplate (pDataObject);
        break;

    case IDM_REENROLL_ALL_CERTS:
        hr = OnReEnrollAllCerts (pDataObject);
        break;

    case IDM_VIEW_OIDS:
        OnViewOIDs ();
        break;

    case -1:    // Received on forward/back buttons from toolbar
        break;

    default:
        _ASSERT (0);
        break;
    }

    return hr;
}




HRESULT CCertTmplComponentData::RefreshScopePane (LPDATAOBJECT pDataObject)
{
    _TRACE (1, L"Entering CCertTmplComponentData::RefreshScopePane\n");
    HRESULT hr = S_OK;
    CCertTmplCookie* pCookie = 0;

    if ( pDataObject )
        pCookie = ConvertCookie (pDataObject);
    if ( !pDataObject || pCookie )
    {
        hr = DeleteScopeItems ();
        _ASSERT (SUCCEEDED (hr));
        GUID    guid;
        hr = ExpandScopeNodes (&m_RootCookie, m_hRootScopeItem, guid, pDataObject);
    }
    _TRACE (-1, L"Leaving CCertTmplComponentData::RefreshScopePane: 0x%x\n", hr);
    return hr;
}


HRESULT CCertTmplComponentData::ExpandScopeNodes (
        CCertTmplCookie* pParentCookie,
        HSCOPEITEM      hParent,
        const GUID&     /*guidObjectType*/,
        LPDATAOBJECT    /*pDataObject*/)
{
    _TRACE (1, L"Entering CCertTmplComponentData::ExpandScopeNodes\n");
    _ASSERT (hParent);
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    CWaitCursor waitCursor;
    HRESULT     hr = S_OK;

    if ( pParentCookie )
    {
        CString     objectName;

        switch ( pParentCookie->m_objecttype )
        {
            // These node types have no children yet
            case CERTTMPL_SNAPIN:
                // We don't expect the handle of the root scope item to change, ever!
                _ASSERT ( m_hRootScopeItem ? (m_hRootScopeItem == hParent) : 1);
                if ( !m_hRootScopeItem )
                    m_hRootScopeItem = hParent;
                break;

            case CERTTMPL_CERT_TEMPLATE:
                _ASSERT (0);
                break;

            // This node type has no children
            default:
                _TRACE (0, L"CCertTmplComponentData::EnumerateScopeChildren bad parent type\n");
                hr = S_OK;
                break;
        }
    }
    else
    {
        // If parentCookie not passed in, then this is an extension snap-in
    }

    _TRACE (-1, L"Leaving CCertTmplComponentData::ExpandScopeNodes: 0x%x\n", hr);
    return hr;
}

HRESULT CCertTmplComponentData::DeleteScopeItems ()
{
    _TRACE (1, L"Entering CCertTmplComponentData::DeleteScopeItems\n");
    HRESULT hr = S_OK;

    hr = DeleteChildren (m_hRootScopeItem);

    _TRACE (-1, L"Leaving CCertTmplComponentData::DeleteScopeItems: 0x%x\n", hr);
    return hr;
}


HRESULT CCertTmplComponentData::DeleteChildren (HSCOPEITEM hParent)
{
    _TRACE (1, L"Entering CCertTmplComponentData::DeleteChildren\n");
    HRESULT         hr = S_OK;
    if ( hParent )
    {
        HSCOPEITEM      hChild = 0;
        HSCOPEITEM      hNextChild = 0;
        MMC_COOKIE      lCookie = 0;

        // Optimization:  If we're deleting everything below the root, free all
        // the result items here so we don't have to go looking for them later by
        // store
        if ( hParent == m_hRootScopeItem )
        {
            LPRESULTDATA    pResultData = 0;
            hr = GetResultData (&pResultData);
            if ( SUCCEEDED (hr) )
            {
                hr = pResultData->DeleteAllRsltItems ();
                if ( SUCCEEDED (hr) || E_UNEXPECTED == hr ) // returns E_UNEXPECTED if console shutting down
                {
                    RemoveResultCookies (pResultData);
                }
                pResultData->Release ();
            }
        }


        hr = m_pConsoleNameSpace->GetChildItem (hParent, &hChild, &lCookie);
        _ASSERT (SUCCEEDED (hr) || E_FAIL == hr);    // appears to return E_FAIL when there are no children
        while ( SUCCEEDED (hr) && hChild )
        {
            hr = m_pConsoleNameSpace->GetNextItem (hChild, &hNextChild, &lCookie);
            _ASSERT (SUCCEEDED (hr));

            hr = DeleteChildren (hChild);
            _ASSERT (SUCCEEDED (hr));
            if ( SUCCEEDED (hr) )
            {
                m_pConsoleNameSpace->DeleteItem (hChild, TRUE);
            }
            hChild = hNextChild;
        }
   }


    _TRACE (-1, L"Leaving CCertTmplComponentData::DeleteChildren: 0x%x\n", hr);
    return hr;
}


CertTmplObjectType CCertTmplComponentData::GetObjectType (LPDATAOBJECT pDataObject)
{
    _ASSERT (pDataObject);
    CCertTmplCookie* pCookie = ConvertCookie (pDataObject);
    if ( ((CCertTmplCookie*) MMC_MULTI_SELECT_COOKIE) == pCookie )
        return CERTTMPL_MULTISEL;
    else if ( pCookie )
        return pCookie->m_objecttype;

    return CERTTMPL_INVALID;
}


HRESULT CCertTmplComponentData::IsUserAdministrator (BOOL & bIsAdministrator)
{
    HRESULT hr = S_OK;
    DWORD   dwErr = 0;

    bIsAdministrator = FALSE;
    if ( IsWindowsNT () )
    {
        PSID                        psidAdministrators = 0;
        SID_IDENTIFIER_AUTHORITY    siaNtAuthority = SECURITY_NT_AUTHORITY;

        // security review BryanWal 2/20/2002 ok
        BOOL bResult = AllocateAndInitializeSid (&siaNtAuthority, 2,
                SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
                0, 0, 0, 0, 0, 0, &psidAdministrators);
        _ASSERT (bResult);
        if ( bResult && psidAdministrators)
        {
            bResult = CheckTokenMembership (0, psidAdministrators,
                    &bIsAdministrator);
            _ASSERT (bResult);
            if ( !bResult )
            {
                dwErr = GetLastError ();
                DisplaySystemError (dwErr);
                hr = HRESULT_FROM_WIN32 (dwErr);
            }
            FreeSid (psidAdministrators);
        }
        else
        {
            dwErr = GetLastError ();
            DisplaySystemError (dwErr);
            hr = HRESULT_FROM_WIN32 (dwErr);
        }
    }
    return hr;
}


void CCertTmplComponentData::DisplaySystemError (DWORD dwErr)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    LPVOID lpMsgBuf;

    // security review BryanWal 2/20/2002 ok because using 
    // FORMAT_MESSAGE_ALLOCATE_BUFFER flag and getting message from system
    FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            dwErr,
            MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
             (PWSTR) &lpMsgBuf,    0,    NULL );

    // Display the string.
    CString caption;
    VERIFY (caption.LoadString (IDS_CERTTMPL));
    int     iRetVal = 0;
    if ( m_pConsole )
    {
        HRESULT hr = m_pConsole->MessageBox ( (PWSTR) lpMsgBuf, caption,
            MB_ICONWARNING | MB_OK, &iRetVal);
        _ASSERT (SUCCEEDED (hr));
    }
    else
    {
        CThemeContextActivator activator;
        ::MessageBox (NULL, (PWSTR) lpMsgBuf, caption, MB_ICONWARNING | MB_OK);
    }
    // Free the buffer.
    LocalFree (lpMsgBuf);
}

HRESULT CCertTmplComponentData::AddSeparator (LPCONTEXTMENUCALLBACK pContextMenuCallback)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    _ASSERT (pContextMenuCallback);
    CONTEXTMENUITEM menuItem;

    // security review BryanWal 02/20/2002 ok
    ::ZeroMemory (&menuItem, sizeof (menuItem));
    menuItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
    menuItem.fSpecialFlags = 0;
    menuItem.strName = _T ("Separator");            // Dummy name
    menuItem.strStatusBarText = _T ("Separator");// Dummy status text
    menuItem.lCommandID = ID_SEPARATOR;         // Command ID
    menuItem.fFlags = MF_SEPARATOR;             // most important the flag
    HRESULT hr = pContextMenuCallback->AddItem (&menuItem);
//  _ASSERT (SUCCEEDED (hr));

    return hr;
}

LPCONSOLENAMESPACE CCertTmplComponentData::GetConsoleNameSpace () const
{
    return m_pConsoleNameSpace;
}

CCertTmplCookie* CCertTmplComponentData::ConvertCookie (LPDATAOBJECT pDataObject)
{
    CCertTmplCookie* pParentCookie = 0;
    CCookie*        pBaseParentCookie = 0;
    HRESULT         hr = ::ExtractData (pDataObject,
            CCertTemplatesDataObject::m_CFRawCookie,
             &pBaseParentCookie,
             sizeof (pBaseParentCookie) );
    if ( SUCCEEDED (hr) )
    {
        pParentCookie = ActiveCookie (pBaseParentCookie);
        _ASSERT (pParentCookie);
    }
    return pParentCookie;
}




HRESULT CCertTmplComponentData::AddScopeNode(CCertTmplCookie * pNewCookie, HSCOPEITEM hParent)
{
    _TRACE (1, L"Entering CCertTmplComponentData::AddScopeNode\n");
    _ASSERT (pNewCookie);
    HRESULT hr = S_OK;
    if ( pNewCookie )
    {
        SCOPEDATAITEM tSDItem;

        // security review BryanWal 02/20/2002 ok
        ::ZeroMemory (&tSDItem,sizeof (tSDItem));
        tSDItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE |
            SDI_STATE | SDI_PARAM | SDI_PARENT | SDI_CHILDREN;
        tSDItem.displayname = MMC_CALLBACK;
        tSDItem.relativeID = hParent;
        tSDItem.nState = 0;
        tSDItem.cChildren = 0;

        if ( pNewCookie != &m_RootCookie )
            m_RootCookie.m_listScopeCookieBlocks.AddHead ( (CBaseCookieBlock*) pNewCookie);
        tSDItem.lParam = reinterpret_cast<LPARAM> ( (CCookie*) pNewCookie);
        tSDItem.nImage = QueryImage (*pNewCookie, FALSE);
        tSDItem.nOpenImage = QueryImage (*pNewCookie, FALSE);
        hr = m_pConsoleNameSpace->InsertItem (&tSDItem);
        if ( SUCCEEDED (hr) )
            pNewCookie->m_hScopeItem = tSDItem.ID;
    }
    else
        hr = E_POINTER;

    _TRACE (-1, L"Leaving CCertTmplComponentData::AddScopeNode: 0x%x\n", hr);
    return hr;
}

HRESULT CCertTmplComponentData::ReleaseResultCookie (
        CBaseCookieBlock *  pResultCookie,
        CCookie&            /*rootCookie*/,
        POSITION            /*pos2*/)
{
    _TRACE (1, L"Entering CCertTmplComponentData::ReleaseResultCookie\n");
    CCertTmplCookie* pCookie = dynamic_cast <CCertTmplCookie*> (pResultCookie);
    _ASSERT (pCookie);
    if ( pCookie )
    {
        switch (pCookie->m_objecttype)
        {
        case CERTTMPL_CERT_TEMPLATE:
            _ASSERT (0);
            break;

        default:
            _ASSERT (0);
            break;
        }
    }

    _TRACE (-1, L"Leaving CCertTmplComponentData::ReleaseResultCookie\n");
    return S_OK;
}

void CCertTmplComponentData::SetResultData(LPRESULTDATA pResultData)
{
    _ASSERT (pResultData);
    if ( pResultData && pResultData != m_pResultData )
    {
        if ( m_pResultData )
            m_pResultData->Release ();
        m_pResultData = pResultData;
        m_pResultData->AddRef ();
    }
}

HRESULT CCertTmplComponentData::GetResultData(LPRESULTDATA* ppResultData)
{
    HRESULT hr = S_OK;

    if ( !ppResultData )
        hr = E_POINTER;
    else if ( !m_pResultData )
    {
        if ( m_pConsole )
        {
            hr = m_pConsole->QueryInterface(IID_PPV_ARG (IResultData, &m_pResultData));
            _ASSERT (SUCCEEDED (hr));
        }
        else
            hr = E_FAIL;
    }
    
    if ( SUCCEEDED (hr) && m_pResultData )
    {
        *ppResultData = m_pResultData;
        m_pResultData->AddRef ();
    }

    return hr;
}


CString CCertTmplComponentData::GetThisComputer() const
{
    return m_szThisComputer;
}

HRESULT CCertTmplComponentData::OnPropertyChange (LPARAM param)
{
    _TRACE (1, L"Entering CCertTmplComponentData::OnPropertyChange\n");
    _ASSERT (param);
    HRESULT         hr = S_OK;
    if ( param )
    {
        CCertTmplCookie* pCookie = reinterpret_cast<CCertTmplCookie*> (param);
        if ( pCookie )
        {
            switch (pCookie->m_objecttype)
            {
            case CERTTMPL_CERT_TEMPLATE:
                {
                    HRESULTITEM itemID = 0;
                    hr = pCookie->m_resultDataID->FindItemByLParam ((LPARAM) pCookie, &itemID);
                    _ASSERT (SUCCEEDED (hr));
                    if ( SUCCEEDED (hr) )
                    {
                        hr = m_pResultData->UpdateItem (itemID);
                        _ASSERT (SUCCEEDED (hr));
                    }
                }
                break;

            default:
                break;
            }
        }
    }
    else
        hr = E_FAIL;


    _TRACE (-1, L"Leaving CCertTmplComponentData::OnPropertyChange: 0x%x\n", hr);
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
// CCertTmplComponentData::RemoveResultCookies
//
// Remove and delete all the result cookies corresponding to the LPRESULTDATA
// object passed in.  Thus all cookies added to pResultData are released and
// removed from the master list.
//
///////////////////////////////////////////////////////////////////////////////
void CCertTmplComponentData::RemoveResultCookies(LPRESULTDATA pResultData)
{
    _TRACE (1, L"Entering CCertTmplComponentData::RemoveResultCookies\n");
    CCertTmplCookie* pCookie = 0;

    CCookie& rootCookie = QueryBaseRootCookie ();

    POSITION        curPos = 0;

    for (POSITION nextPos = rootCookie.m_listResultCookieBlocks.GetHeadPosition (); nextPos; )
    {
        curPos = nextPos;
        pCookie = dynamic_cast <CCertTmplCookie*> (rootCookie.m_listResultCookieBlocks.GetNext (nextPos));
        _ASSERT (pCookie);
        if ( pCookie )
        {
            if ( pCookie->m_resultDataID == pResultData )
            {
                pCookie->Release ();
                rootCookie.m_listResultCookieBlocks.RemoveAt (curPos);
            }
        }
    }
    _TRACE (-1, L"Leaving CCertTmplComponentData::RemoveResultCookies\n");
}

HRESULT CCertTmplComponentData::AddVersion1CertTemplatePropPages (CCertTemplate* pCertTemplate, LPPROPERTYSHEETCALLBACK pCallback)
{
    _TRACE (1, L"Entering CCertTmplComponentData::AddVersion1CertTemplatePropPages\n");
    HRESULT         hr = S_OK;
    _ASSERT (pCertTemplate && pCallback);
    if ( pCertTemplate && pCallback )
    {
        _ASSERT (1 == pCertTemplate->GetType ());

        // Add General page
        CTemplateGeneralPropertyPage * pGeneralPage = new CTemplateGeneralPropertyPage (
                *pCertTemplate, this);
        if ( pGeneralPage )
        {
            HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pGeneralPage->m_psp);
            _ASSERT (hPage);
            hr = pCallback->AddPage (hPage);
            _ASSERT (SUCCEEDED (hr));
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        // Add Request page only if subject is not a CA
        if ( SUCCEEDED (hr) && !pCertTemplate->SubjectIsCA () )
        {
            CTemplateV1RequestPropertyPage * pRequestPage = 
                    new CTemplateV1RequestPropertyPage (*pCertTemplate);
            if ( pRequestPage )
            {
                HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pRequestPage->m_psp);
                _ASSERT (hPage);
                hr = pCallback->AddPage (hPage);
                _ASSERT (SUCCEEDED (hr));
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

    
        // Add Subject Name page only if subject is not a CA
        if ( SUCCEEDED (hr) && !pCertTemplate->SubjectIsCA () )
        {
            CTemplateV1SubjectNamePropertyPage * pSubjectNamePage = 
                    new CTemplateV1SubjectNamePropertyPage (*pCertTemplate);
            if ( pSubjectNamePage )
            {
                HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pSubjectNamePage->m_psp);
                _ASSERT (hPage);
                hr = pCallback->AddPage (hPage);
                _ASSERT (SUCCEEDED (hr));
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        // Add extensions page - always add this page last (except for security)
        if ( SUCCEEDED (hr) )
        {
            CTemplateExtensionsPropertyPage * pExtensionsPage = 
                    new CTemplateExtensionsPropertyPage (*pCertTemplate, 
                    pGeneralPage->m_bIsDirty);
            if ( pExtensionsPage )
            {
                HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pExtensionsPage->m_psp);
                _ASSERT (hPage);
                hr = pCallback->AddPage (hPage);
                _ASSERT (SUCCEEDED (hr));
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        // Add security page
        if ( SUCCEEDED (hr) )
        {
            // if error, don't display this page
            LPSECURITYINFO pCertTemplateSecurity = NULL;

            hr = CreateCertTemplateSecurityInfo (pCertTemplate, 
                    &pCertTemplateSecurity);
            if ( SUCCEEDED (hr) )
            {
                // save the pCASecurity pointer for later releasing
                pGeneralPage->SetAllocedSecurityInfo (pCertTemplateSecurity);

                HPROPSHEETPAGE hPage = CreateSecurityPage (pCertTemplateSecurity);
                if (hPage == NULL)
                {
                    hr = HRESULT_FROM_WIN32 (GetLastError());
                    _TRACE (0, L"CreateSecurityPage () failed: 0x%x\n", hr);
                }
                hr = pCallback->AddPage (hPage);
                _ASSERT (SUCCEEDED (hr));
            }
        }
    }
    _TRACE (-1, L"Leaving CCertTmplComponentData::AddVersion1CertTemplatePropPages: 0x%x\n", hr);
    return hr;
}

HRESULT CCertTmplComponentData::AddVersion2CertTemplatePropPages (CCertTemplate* pCertTemplate, LPPROPERTYSHEETCALLBACK pCallback, LONG_PTR lNotifyHandle)
{
    _TRACE (1, L"Entering CCertTmplComponentData::AddVersion2CertTemplatePropPages\n");
    HRESULT         hr = S_OK;
    _ASSERT (pCertTemplate && pCallback);
    if ( pCertTemplate && pCallback )
    {
        _ASSERT (2 == pCertTemplate->GetType ());
        int nPage = 0;

        // Add General page
        CTemplateGeneralPropertyPage * pGeneralPage = new CTemplateGeneralPropertyPage (
                *pCertTemplate, this);
        if ( pGeneralPage )
        {
            pGeneralPage->m_lNotifyHandle = lNotifyHandle;
            HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pGeneralPage->m_psp);
            _ASSERT (hPage);
            hr = pCallback->AddPage (hPage);
            _ASSERT (SUCCEEDED (hr));
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        // Add Request page only if subject is not a CA
        if ( SUCCEEDED (hr) && !pCertTemplate->SubjectIsCA () )
        {
            CTemplateV2RequestPropertyPage * pRequestPage = 
                    new CTemplateV2RequestPropertyPage (*pCertTemplate, 
                    pGeneralPage->m_bIsDirty);
            if ( pRequestPage )
            {
                HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pRequestPage->m_psp);
                _ASSERT (hPage);
                hr = pCallback->AddPage (hPage);
                _ASSERT (SUCCEEDED (hr));
                if ( SUCCEEDED (hr) )
                {
                    nPage++;
                    pGeneralPage->SetV2RequestPageNumber (nPage);
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

    
        // Add Subject Name page only if subject is not a CA
        if ( SUCCEEDED (hr) && !pCertTemplate->SubjectIsCA () )
        {
            if( !pCertTemplate->SubjectIsCrossCA() ) //Bug 435628, Yanggao, 7/13/2001
            {
                CTemplateV2SubjectNamePropertyPage * pSubjectNamePage = 
                    new CTemplateV2SubjectNamePropertyPage (*pCertTemplate, 
                    pGeneralPage->m_bIsDirty);
                if ( pSubjectNamePage )
                {
                    HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pSubjectNamePage->m_psp);
                    _ASSERT (hPage);
                    hr = pCallback->AddPage (hPage);
                    _ASSERT (SUCCEEDED (hr));
                    if ( SUCCEEDED (hr) )
                        nPage++;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }


        // Add Authentication Name page
        if ( SUCCEEDED (hr) )
        {
            CTemplateV2AuthenticationPropertyPage * pAuthenticationPage = 
                    new CTemplateV2AuthenticationPropertyPage (*pCertTemplate, 
                    pGeneralPage->m_bIsDirty);
            if ( pAuthenticationPage )
            {
                HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pAuthenticationPage->m_psp);
                _ASSERT (hPage);
                hr = pCallback->AddPage (hPage);
                _ASSERT (SUCCEEDED (hr));
                if ( SUCCEEDED (hr) )
                {
                    nPage++;
                    pGeneralPage->SetV2AuthPageNumber (nPage);
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        // Add Superceded page
        if ( SUCCEEDED (hr) )
        {
            CTemplateV2SupercedesPropertyPage * pSupercededPage = 
                    new CTemplateV2SupercedesPropertyPage (*pCertTemplate, 
                            pGeneralPage->m_bIsDirty,
                            this);
            if ( pSupercededPage )
            {
                HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pSupercededPage->m_psp);
                _ASSERT (hPage);
                hr = pCallback->AddPage (hPage);
                _ASSERT (SUCCEEDED (hr));
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        // Add extensions page - always add this page last (except for security)
        if ( SUCCEEDED (hr) )
        {
            CTemplateExtensionsPropertyPage * pExtensionsPage = 
                    new CTemplateExtensionsPropertyPage (*pCertTemplate, 
                    pGeneralPage->m_bIsDirty);
            if ( pExtensionsPage )
            {
                HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pExtensionsPage->m_psp);
                _ASSERT (hPage);
                hr = pCallback->AddPage (hPage);
                _ASSERT (SUCCEEDED (hr));
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }


        // Add security page
        if ( SUCCEEDED (hr) )
        {
            // if error, don't display this page
            LPSECURITYINFO pCertTemplateSecurity = NULL;

            hr = CreateCertTemplateSecurityInfo (pCertTemplate, 
                    &pCertTemplateSecurity);
            if ( SUCCEEDED (hr) )
            {
                // save the pCertTemplateSecurity pointer for later releasing
                pGeneralPage->SetAllocedSecurityInfo (pCertTemplateSecurity);

                HPROPSHEETPAGE hPage = CreateSecurityPage (pCertTemplateSecurity);
                if (hPage == NULL)
                {
                    hr = HRESULT_FROM_WIN32 (GetLastError());
                    _TRACE (0, L"CreateSecurityPage () failed: 0x%x\n", hr);
                }
                hr = pCallback->AddPage (hPage);
                _ASSERT (SUCCEEDED (hr));
            }
        }
    }
    _TRACE (-1, L"Leaving CCertTmplComponentData::AddVersion2CertTemplatePropPages: 0x%x\n", hr);
    return hr;
}

HRESULT CCertTmplComponentData::AddCertTemplatePropPages (
            CCertTemplate* pCertTemplate, 
            LPPROPERTYSHEETCALLBACK pCallback,
            LONG_PTR lNotifyHandle)
{
    _TRACE (1, L"Entering CCertTmplComponentData::AddCertTemplatePropPages\n");
    HRESULT         hr = S_OK;
    _ASSERT (pCertTemplate && pCallback);
    if ( pCertTemplate && pCallback )
    {
        switch (pCertTemplate->GetType ())
        {
        case 1:
            hr = AddVersion1CertTemplatePropPages (pCertTemplate, pCallback);
            break;

        case 2:
            hr = AddVersion2CertTemplatePropPages (pCertTemplate, pCallback, lNotifyHandle);
            break;

        default:
            _ASSERT (0);
            break;
        }
    }
    else
        hr = E_POINTER;

    _TRACE(-1, L"Leaving CCertTmplComponentData::AddCertTemplatePropPages: 0x%x\n", hr);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// IExtendPropertySheet Implementation

//+----------------------------------------------------------------------------
//
//  Function:   AddPageProc
//
//  Synopsis:   The IShellPropSheetExt->AddPages callback.
//
//-----------------------------------------------------------------------------
BOOL CALLBACK
AddPageProc(HPROPSHEETPAGE hPage, LPARAM pCall)
{
    TRACE(_T("xx.%03x> AddPageProc()\n"), GetCurrentThreadId());

    HRESULT hr = ((LPPROPERTYSHEETCALLBACK)pCall)->AddPage(hPage);

    return hr == S_OK;
}


HRESULT CCertTmplComponentData::AddCloneTemplateMenuItem(LPCONTEXTMENUCALLBACK pContextMenuCallback, LONG lInsertionPointID)
{
    _TRACE (1, L"Entering CCertTmplComponentData::AddCloneTemplateMenuItem\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    _ASSERT (pContextMenuCallback);
    HRESULT         hr = S_OK;
    CONTEXTMENUITEM menuItem;
    CString         szMenu;
    CString         szHint;

    // security review BryanWal 02/20/2002 ok
    ::ZeroMemory (&menuItem, sizeof (menuItem));
    menuItem.lInsertionPointID = lInsertionPointID;
    menuItem.fFlags = 0;
    menuItem.fSpecialFlags = 0;
    VERIFY (szMenu.LoadString (IDS_CLONE_TEMPLATE));
    menuItem.strName = (PWSTR) (PCWSTR) szMenu;
    VERIFY (szHint.LoadString (IDS_CLONE_TEMPLATE_HINT));
    menuItem.strStatusBarText = (PWSTR) (PCWSTR) szHint;
    menuItem.lCommandID = IDM_CLONE_TEMPLATE;

    hr = pContextMenuCallback->AddItem (&menuItem);
    _ASSERT (SUCCEEDED (hr));

    _TRACE (-1, L"Leaving CCertTmplComponentData::AddCloneTemplateMenuItem\n");
    return hr;
}

HRESULT CCertTmplComponentData::AddReEnrollAllCertsMenuItem(LPCONTEXTMENUCALLBACK pContextMenuCallback, LONG lInsertionPointID)
{
    _TRACE (1, L"Entering CCertTmplComponentData::AddReEnrollAllCertsMenuItem\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    _ASSERT (pContextMenuCallback);
    HRESULT         hr = S_OK;
    CONTEXTMENUITEM menuItem;
    CString         szMenu;
    CString         szHint;

    // security review BryanWal 02/20/2002 ok
    ::ZeroMemory (&menuItem, sizeof (menuItem));
    menuItem.lInsertionPointID = lInsertionPointID;
    menuItem.fFlags = 0;
    menuItem.fSpecialFlags = 0;
    VERIFY (szMenu.LoadString (IDS_REENROLL_ALL_CERTS));
    menuItem.strName = (PWSTR) (PCWSTR) szMenu;
    VERIFY (szHint.LoadString (IDS_REENROLL_ALL_CERTS_HINT));
    menuItem.strStatusBarText = (PWSTR) (PCWSTR) szHint;
    menuItem.lCommandID = IDM_REENROLL_ALL_CERTS;

    hr = pContextMenuCallback->AddItem (&menuItem);
    _ASSERT (SUCCEEDED (hr));

    _TRACE (-1, L"Leaving CCertTmplComponentData::AddReEnrollAllCertsMenuItem\n");
    return hr;
}

HRESULT CCertTmplComponentData::RefreshServer()
{
    //  Delete all the scope items and result items, attempt recreate the
    // server and force a reexpansion
    HRESULT hr = DeleteScopeItems ();
    if ( m_pResultData )
    {
        m_pResultData->DeleteAllRsltItems ();
    }

    HWND    hWndConsole = 0;

    m_pConsole->GetMainWindow (&hWndConsole);
    GUID    guid;
    hr = ExpandScopeNodes (
            &(m_RootCookie), m_hRootScopeItem,
            guid);

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
//  ChangeRootNodeName ()
//
//  Purpose:    Change the text of the root node
//
//  Input:      newName - the new machine name that the snapin manages
//  Output:     Returns S_OK on success
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CCertTmplComponentData::ChangeRootNodeName()
{
    _TRACE (1, L"Entering CCertTmplComponentData::ChangeRootNodeName\n");

    if ( !QueryBaseRootCookie ().m_hScopeItem )
    {
        if ( m_hRootScopeItem )
            QueryBaseRootCookie ().m_hScopeItem = m_hRootScopeItem;
        else
            return E_UNEXPECTED;
    }

    CString     formattedName;

    if ( m_szManagedDomain.IsEmpty () )
    {
        // security review BryanWal 2/20/2002 ok
        formattedName.FormatMessage (IDS_CERTTMPL_ROOT_NODE_NAME, m_szThisDomainDns);
    }
    else
    {
        // security review BryanWal 2/20/2002 ok
        formattedName.FormatMessage (IDS_CERTTMPL_ROOT_NODE_NAME, m_szManagedDomain);
    }

    SCOPEDATAITEM   item;
    // security review BryanWal 02/20/2002 ok
    ::ZeroMemory (&item, sizeof (item));
    item.mask = SDI_STR;
    item.displayname = (PWSTR) (PCWSTR) formattedName;
    item.ID = QueryBaseRootCookie ().m_hScopeItem;

    HRESULT hr = m_pConsoleNameSpace->SetItem (&item);
    if ( FAILED (hr) )
    {
        _TRACE (0, L"IConsoleNameSpace2::SetItem () failed: 0x%x\n", hr);        
    }
    _TRACE (-1, L"Leaving CCertTmplComponentData::ChangeRootNodeName: 0x%x\n", hr);
    return hr;
}

HRESULT CCertTmplComponentData::OnNotifyPreload(LPDATAOBJECT /*pDataObject*/, HSCOPEITEM hRootScopeItem)
{
    _TRACE (1, L"Entering CCertTmplComponentData::OnNotifyPreload\n");
    HRESULT hr = S_OK;

    QueryBaseRootCookie ().m_hScopeItem = hRootScopeItem;
    hr = ChangeRootNodeName ();

    _TRACE (-1, L"Leaving CCertTmplComponentData::OnNotifyPreload: 0x%x\n", hr);
    return hr;
}

// Help on IComponentData just returns the file and no particular topic
STDMETHODIMP CCertTmplComponentData::GetHelpTopic(LPOLESTR* lpCompiledHelpFile)
{
    if (lpCompiledHelpFile == NULL)
        return E_INVALIDARG;

    CString szHelpFilePath;
    HRESULT hr = GetHtmlHelpFilePath( szHelpFilePath );
    if ( FAILED(hr) )
        return hr;

    *lpCompiledHelpFile = reinterpret_cast <LPOLESTR> (
            CoTaskMemAlloc ((szHelpFilePath.GetLength () + 1) * sizeof (wchar_t)));
    if ( NULL == *lpCompiledHelpFile )
        return E_OUTOFMEMORY;

    USES_CONVERSION;
    // security review BryanWal 2/20/2002 ok
    wcscpy (*lpCompiledHelpFile, T2OLE ((LPTSTR)(LPCTSTR) szHelpFilePath));
  
    return S_OK;
}

HRESULT CCertTmplComponentData::GetHtmlHelpFilePath( CString& strref ) const
{
  UINT nLen = ::GetSystemWindowsDirectory (strref.GetBufferSetLength(2 * MAX_PATH), 2 * MAX_PATH);
  strref.ReleaseBuffer();
  if (0 == nLen)
  {
    _ASSERT(FALSE);
    return E_FAIL;
  }

  strref += CERTTMPL_HELP_PATH;
  strref += CERTTMPL_LINKED_HELP_FILE;
  
  return S_OK;
}


HRESULT CCertTmplComponentData::OnReEnrollAllCerts (LPDATAOBJECT pDataObject)
{
    _TRACE (1, L"Entering CCertTmplComponentData::OnReEnrollAllCerts");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    HRESULT hr = S_OK;

    if ( pDataObject )
    {
        CCertTmplCookie* pCookie = ConvertCookie (pDataObject);
        if ( pCookie )
        {
            _ASSERT (CERTTMPL_CERT_TEMPLATE == pCookie->m_objecttype);
            CCertTemplate* pCertTemplate = dynamic_cast <CCertTemplate*> (pCookie);
            if ( pCertTemplate )
            {
                hr = pCertTemplate->IncrementMajorVersion ();
                if ( SUCCEEDED (hr) )
                {
                    // Don't increment minor version - was set to 0 in 
                    // IncrementMajorVersion
                    hr = pCertTemplate->SaveChanges (false);
                    if ( SUCCEEDED (hr) )
                    {
                        HRESULTITEM itemID = 0;
                        hr = pCookie->m_resultDataID->FindItemByLParam ((LPARAM) pCookie, &itemID);
                        _ASSERT (SUCCEEDED (hr));
                        if ( SUCCEEDED (hr) )
                        {
                            hr = m_pResultData->UpdateItem (itemID);
                            _ASSERT (SUCCEEDED (hr));
                        }
                    }
                }
            }    
            else
                hr = E_FAIL;
        }
        else
            hr = E_FAIL;
    }
    else
        hr = E_POINTER;

    _TRACE (-1, L"Leaving CCertTmplComponentData::OnReEnrollAllCerts");
    return hr;
}

HRESULT CCertTmplComponentData::OnCloneTemplate (LPDATAOBJECT pDataObject)
{
    _TRACE (1, L"Entering CCertTmplComponentData::OnCloneTemplate");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    HRESULT     hr = S_OK;
    CWaitCursor waitCursor;

    if ( pDataObject )
    {
        CCertTmplCookie* pCookie = ConvertCookie (pDataObject);
        if ( pCookie )
        {
            _ASSERT (CERTTMPL_CERT_TEMPLATE == pCookie->m_objecttype);
            CCertTemplate* pOldTemplate = dynamic_cast <CCertTemplate*> (pCookie);
            if ( pOldTemplate )
            {
                static  PCWSTR  pszDomainController = L"DomainController";
                static  PCWSTR  pszComputer = L"Machine";
                bool    bIsComputerOrDC = pOldTemplate->GetTemplateName () == pszDomainController ||
                                    pOldTemplate->GetTemplateName () == pszComputer;

                HWND    hWndConsole = 0;

                m_pConsole->GetMainWindow (&hWndConsole);
                CWnd    mainWindow;
                mainWindow.Attach (hWndConsole);

                CCertTemplate* pNewTemplate = new CCertTemplate (*pOldTemplate, 
                        true, false, m_fUseCache);
                if ( pNewTemplate )
                {
                    // Generate a unique name for the new template
                    int     nCopy = 1;
                    CString newName;

                    while ( 1 )
                    {
                        if ( 1 == nCopy )
                        {
                            // security review BryanWal 2/20/2002 ok
                            newName.FormatMessage (IDS_COPY_OF_TEMPLATE, 
                                    (PCWSTR) pOldTemplate->GetDisplayName ());
                        }
                        else
                        {
                            // security review BryanWal 2/20/2002 ok
                            newName.FormatMessage (IDS_COPY_X_OF_TEMPLATE, nCopy, 
                                    (PCWSTR) pOldTemplate->GetDisplayName ());
                        }

                        HCERTTYPE   hCertType = 0;
                        HRESULT     hr1 = CAFindCertTypeByName (newName, 
                                NULL,
                                CT_ENUM_MACHINE_TYPES | CT_ENUM_USER_TYPES | CT_FLAG_NO_CACHE_LOOKUP,
                                &hCertType);
                        _TRACE (0, L"checking to see if %s exists: %s\n", 
                                (PCWSTR) newName,
                                SUCCEEDED (hr) ? L"was found" : L"was not found");
                        if ( SUCCEEDED (hr1) )
                        {
                            hr1 = CACloseCertType (hCertType);
                            if ( FAILED (hr1) )
                            {
                                _TRACE (0, L"CACloseCertType () failed: 0x%x", hr);
                            }

                            // This one exists, try another.
                            nCopy++;
                            continue;
                        }
                        else
                        {
                            // This one does not exist.  Use it as the new name.
                            break;
                        }
                    }
                    
                    if ( SUCCEEDED (hr) )
                    {
                        hr = pNewTemplate->Clone (*pOldTemplate, 
                                newName, newName);
                        if ( SUCCEEDED (hr) )
                        {

                            CString title;

                            VERIFY (title.LoadString (IDS_PROPERTIES_OF_NEW_TEMPLATE));
                            CTemplatePropertySheet  propSheet (title, *pNewTemplate, &mainWindow);

                            CTemplateGeneralPropertyPage* pGeneralPage = 
                                    new CTemplateGeneralPropertyPage (
                                            *pNewTemplate,
                                            this);

                            if ( pGeneralPage )
                            {
                                propSheet.AddPage (pGeneralPage);
                                int nPage = 0;


                                // Add Request and Subject pages if subject is not a CA
                                if ( !pNewTemplate->SubjectIsCA () )
                                {
                                    propSheet.AddPage (new CTemplateV2RequestPropertyPage (
                                            *pNewTemplate, pGeneralPage->m_bIsDirty));
                                    nPage++;
                                    pGeneralPage->SetV2RequestPageNumber (nPage);
                                    if( !pNewTemplate->SubjectIsCrossCA() ) //Bug 435628, Yanggao, 7/13/2001
                                    {
                                        propSheet.AddPage (new CTemplateV2SubjectNamePropertyPage (
                                            *pNewTemplate, pGeneralPage->m_bIsDirty,
                                            bIsComputerOrDC));
                                        nPage++;
                                    }
                                }

                                propSheet.AddPage (new CTemplateV2AuthenticationPropertyPage ( 
                                        *pNewTemplate, pGeneralPage->m_bIsDirty));
                                nPage++;
                                pGeneralPage->SetV2AuthPageNumber (nPage);

                                propSheet.AddPage (new CTemplateV2SupercedesPropertyPage (
                                        *pNewTemplate, pGeneralPage->m_bIsDirty,
                                        this));

                                // Add template extension page - always add this page last (except for security)
                                propSheet.AddPage (new CTemplateExtensionsPropertyPage (
                                        *pNewTemplate, pGeneralPage->m_bIsDirty));

                                CThemeContextActivator activator;
                                INT_PTR iResult = propSheet.DoModal ();
                                switch (iResult)
                                {
                                case IDOK:
                                    if ( pNewTemplate->FailedToSetSecurity () )
                                        hr = pNewTemplate->Delete ();
                                    else
                                    {
                                        hr = pNewTemplate->DoAutoEnrollmentPendingSave ();

                                        m_globalTemplateNameList.AddTail (
                                                pNewTemplate->GetTemplateName ());

                                        // unselect old template
                                        HRESULTITEM itemID = 0;

                                        ASSERT (m_pResultData);
                                        if ( m_pResultData )
                                        {
                                            hr = m_pResultData->FindItemByLParam (
                                                    (LPARAM) pCookie, &itemID);
                                            ASSERT (SUCCEEDED (hr));
                                            if ( SUCCEEDED (hr) )
                                            {
                                                RESULTDATAITEM  rdItem;
                                                // security review BryanWal 02/20/2002 ok
                                                ::ZeroMemory (&rdItem, sizeof (rdItem));
                                                rdItem.itemID = itemID;

                                                rdItem.mask = RDI_STATE;
                                                rdItem.nState &= ~(LVIS_FOCUSED | LVIS_SELECTED);
                                                hr = m_pResultData->SetItem (&rdItem);
                                                if ( SUCCEEDED (hr) )
                                                {
                                                    hr = m_pResultData->UpdateItem (itemID);
                                                    ASSERT (SUCCEEDED (hr));
                                                }
                                            }
                                        }
                                        else
                                            hr = E_FAIL;

                                        // Reinitialize before displaying
                                        hr = pNewTemplate->Initialize ();

                                        // Add certificate template to result pane
                                        RESULTDATAITEM          rdItem;
                                        CCookie&                rootCookie = QueryBaseRootCookie ();

                                        // security review BryanWal 02/20/2002 ok
                                        ::ZeroMemory (&rdItem, sizeof (rdItem));
                                        rdItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM | RDI_STATE;
                                        rdItem.nImage = iIconCertTemplateV2;
                                        rdItem.nCol = 0;
                                        rdItem.nState = LVIS_SELECTED | LVIS_FOCUSED;
                                        rdItem.str = MMC_TEXTCALLBACK;

                                        rootCookie.m_listResultCookieBlocks.AddHead (pNewTemplate);
                                        rdItem.lParam = (LPARAM) pNewTemplate;
                                        pNewTemplate->m_resultDataID = m_pResultData;
                                        hr = m_pResultData->InsertItem (&rdItem);
                                        if ( FAILED (hr) )
                                        {
                                             _TRACE (0, L"IResultData::InsertItem () failed: 0x%x\n", hr);
                                        }
                                        else
                                        {
                                            m_dwNumCertTemplates++;
                                            DisplayObjectCountInStatusBar (
                                                    m_pConsole, 
                                                    m_dwNumCertTemplates);
                                        }
                                        pNewTemplate = 0;
                                    }
                                    break;

                                case IDCANCEL:
                                    // Delete cloned template
                                    if ( pNewTemplate->CanBeDeletedOnCancel () || 
                                            pNewTemplate->FailedToSetSecurity () )
                                        hr = pNewTemplate->Delete ();
                                    else   // was created - let's update
                                    {
                                        hr = pNewTemplate->DoAutoEnrollmentPendingSave ();
                                        m_globalTemplateNameList.AddTail (
                                                pNewTemplate->GetTemplateName ());

                                        // Reinitialize before displaying
                                        hr = pNewTemplate->Initialize ();

                                        // Add certificate template to result pane
                                        RESULTDATAITEM          rdItem;
                                        CCookie&                rootCookie = QueryBaseRootCookie ();

                                        // security review BryanWal 02/20/2002 ok
                                        ::ZeroMemory (&rdItem, sizeof (rdItem));
                                        rdItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM | RDI_STATE;
                                        rdItem.nImage = iIconCertTemplateV2;
                                        rdItem.nCol = 0;
                                        rdItem.nState = LVIS_SELECTED | LVIS_FOCUSED;
                                        rdItem.str = MMC_TEXTCALLBACK;

                                        rootCookie.m_listResultCookieBlocks.AddHead (pNewTemplate);
                                        rdItem.lParam = (LPARAM) pNewTemplate;
                                        pNewTemplate->m_resultDataID = m_pResultData;
                                        hr = m_pResultData->InsertItem (&rdItem);
                                        if ( FAILED (hr) )
                                        {
                                             _TRACE (0, L"IResultData::InsertItem () failed: 0x%x\n", hr);
                                        }
                                        else
                                        {
                                            m_dwNumCertTemplates++;
                                            DisplayObjectCountInStatusBar (
                                                    m_pConsole, 
                                                    m_dwNumCertTemplates);
                                        }
                                        pNewTemplate = 0;
                                    }
                                    break;
                                }
                            }
                            else
                                hr = E_OUTOFMEMORY;

                        }
                        else
                        {
                            CString caption;
                            CString text;

                            VERIFY (caption.LoadString (IDS_CERTTMPL));
                            // security review BryanWal 2/20/2002 ok
                            text.FormatMessage (IDS_UNABLE_TO_CLONE_TEMPLATE, 
                                    pOldTemplate->GetDisplayName (), 
                                    GetSystemMessage (hr));

                            int     iRetVal = 0;
                            VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption,
                                    MB_ICONWARNING | MB_OK, &iRetVal)));
                        }
                    }

                    if ( pNewTemplate )
                        delete pNewTemplate;
                }
                else
                    hr = E_OUTOFMEMORY;

                mainWindow.Detach ();
            }
            else
                hr = E_UNEXPECTED;
        }
        else
            hr = E_FAIL;
    }
    else
        hr = E_POINTER;

    _TRACE (-1, L"Leaving CCertTmplComponentData::OnCloneTemplate");
    return hr;
}
    
HRESULT CCertTmplComponentData::AddViewOIDsMenuItem (
                LPCONTEXTMENUCALLBACK pContextMenuCallback, 
                LONG lInsertionPointID)
{
    _TRACE (1, L"Entering CCertTmplComponentData::AddViewOIDsMenuItem\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    _ASSERT (pContextMenuCallback);
    HRESULT         hr = S_OK;
    CONTEXTMENUITEM menuItem;
    CString         szMenu;
    CString         szHint;

    // security review BryanWal 02/20/2002 ok
    ::ZeroMemory (&menuItem, sizeof (menuItem));
    menuItem.lInsertionPointID = lInsertionPointID;
    menuItem.fFlags = 0;
    menuItem.fSpecialFlags = 0;
    VERIFY (szMenu.LoadString (IDS_VIEW_OIDS));
    menuItem.strName = (PWSTR) (PCWSTR) szMenu;
    VERIFY (szHint.LoadString (IDS_VIEW_OIDS_HINT));
    menuItem.strStatusBarText = (PWSTR) (PCWSTR) szHint;
    menuItem.lCommandID = IDM_VIEW_OIDS;

    hr = pContextMenuCallback->AddItem (&menuItem);
    _ASSERT (SUCCEEDED (hr));

    _TRACE (-1, L"Leaving CCertTmplComponentData::AddViewOIDsMenuItem\n");
    return hr;

}

void CCertTmplComponentData::OnViewOIDs ()
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    HWND    hWndConsole = 0;

    m_pConsole->GetMainWindow (&hWndConsole);
    CWnd    mainWindow;
    mainWindow.Attach (hWndConsole);

    CViewOIDDlg dlg (&mainWindow);

    CThemeContextActivator activator;
    dlg.DoModal ();

    mainWindow.Detach ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\cookie.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       Cookie.cpp
//
//  Contents:   Implementation of CCertTmplCookie and related classes
//
//----------------------------------------------------------------------------


#include "stdafx.h"
#include "cookie.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#pragma warning(push,3)
#pragma warning (disable : 4702)
#include "atlimpl.cpp"
#pragma warning (default : 4702)
#pragma warning(pop)
#include "stdcooki.cpp"
#include "stdutils.cpp"


//
// CCertTmplCookie
//

// returns <0, 0 or >0


CCertTmplCookie::CCertTmplCookie (CertTmplObjectType objecttype,
		PCWSTR objectName)
	: m_objecttype (objecttype),
	m_objectName (objectName),
	m_resultDataID (0)
{
	_ASSERT (IsValidObjectType (m_objecttype));
	if ( m_objectName.IsEmpty () )
	{
		AFX_MANAGE_STATE (AfxGetStaticModuleState ());
		VERIFY (m_objectName.LoadString (IDS_CERTTMPL));
	}
}

CCertTmplCookie::~CCertTmplCookie ()
{
}


HRESULT CCertTmplCookie::CompareSimilarCookies( CCookie* pOtherCookie, int* pnResult )
{
	_ASSERT (pOtherCookie);

	CCertTmplCookie* pcookie = dynamic_cast <CCertTmplCookie*>(pOtherCookie);
	_ASSERT (pcookie);
	if ( pcookie && m_objecttype != pcookie->m_objecttype )
	{
		*pnResult = ((int)m_objecttype) - ((int)pcookie->m_objecttype); // arbitrary ordering
		return S_OK;
	}

	return E_UNEXPECTED;
}

CCookie* CCertTmplCookie::QueryBaseCookie(int i)
{
	_ASSERT(!i);
	return (CCookie*)this;
}

int CCertTmplCookie::QueryNumCookies()
{
	return 1;
}

PCWSTR CCertTmplCookie::GetObjectName() const
{
	return m_objectName;
}

HRESULT CCertTmplCookie::Commit()
{
	return S_OK;
}


CString CCertTmplCookie::GetManagedDomainDNSName() const
{
	return m_szManagedDomainDNSName;
}

void CCertTmplCookie::SetManagedDomainDNSName(const CString &szManagedDomainDNSName)
{
	m_szManagedDomainDNSName = szManagedDomainDNSName;
}

void CCertTmplCookie::SetObjectName(const CString& strObjectName)
{
    m_objectName = strObjectName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\compdata.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       compdata.h
//
//  Contents:   CCertTmplComponentData
//
//----------------------------------------------------------------------------

#ifndef __COMPDATA_H_INCLUDED__
#define __COMPDATA_H_INCLUDED__

#include "cmponent.h" // LoadIconsIntoImageList
#include "cookie.h"	// Added by ClassView
#include "PolicyOID.h"

class CCertTmplComponentData:
	public CComponentData,
	public IExtendContextMenu,
	public IExtendPropertySheet,
	public PersistStream,
	public CHasMachineName
{
friend CCertTmplComponent;

public:
	CertTmplObjectType GetObjectType (LPDATAOBJECT pDataObject);

// Use DECLARE_NOT_AGGREGATABLE(CCertTmplComponentData)
// if you don't want your object to support aggregation
//DECLARE_AGGREGATABLE(CCertTmplComponentData)
//DECLARE_REGISTRY(CCertTmplComponentData, _T("CERTTMPL.CertTemplatesSnapinObject.1"), _T("CERTTMPL.CertTemplatesSnapinObject.1"), IDS_CERTTMPL_DESC , THREADFLAGS_BOTH)

	CCertTmplComponentData();
	virtual ~CCertTmplComponentData();
BEGIN_COM_MAP(CCertTmplComponentData)
	COM_INTERFACE_ENTRY(IExtendPropertySheet)
	COM_INTERFACE_ENTRY(IPersistStream)         // security review BryanWal 2/20/2002 ok
	COM_INTERFACE_ENTRY_CHAIN(CComponentData)
	COM_INTERFACE_ENTRY(IExtendContextMenu)
END_COM_MAP()

#if DBG==1
	ULONG InternalAddRef()
	{
        return CComObjectRoot::InternalAddRef();
	}
	ULONG InternalRelease()
	{
        return CComObjectRoot::InternalRelease();
	}
    int dbg_InstID;
#endif // DBG==1

// IComponentData
	STDMETHOD(CreateComponent)(LPCOMPONENT* ppComponent);
	STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);

// IExtendPropertySheet
	STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK pCall, LONG_PTR handle, LPDATAOBJECT pDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT pDataObject);

// IExtendContextMenu
public:
	CString				m_szManagedDomain;
    CString             m_szPreviousManagedDomain;
	CString				m_szThisDomainDns;
	CString				m_szThisDomainFlat;
	CString				m_szManagedServerName;
	DWORD				m_dwNumCertTemplates;
    bool        m_fUseCache;
	

	HRESULT RefreshServer ();
	void RemoveResultCookies (LPRESULTDATA pResultData);
	CString GetThisComputer() const;
	void SetResultData (LPRESULTDATA pResultData);
	LPCONSOLENAMESPACE GetConsoleNameSpace () const;
	HRESULT RefreshScopePane (LPDATAOBJECT pDataObject);
	STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject,
                          LPCONTEXTMENUCALLBACK pCallbackUnknown,
                          long *pInsertionAllowed);
	STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);

    HRESULT STDMETHODCALLTYPE Load(IStream __RPC_FAR *pStg);
    HRESULT STDMETHODCALLTYPE Save(IStream __RPC_FAR *pStgSave, BOOL fSameAsLoad);

	// needed for Initialize()
	virtual HRESULT LoadIcons(LPIMAGELIST pImageList, BOOL fLoadLargeIcons);

	// needed for Notify()
	virtual HRESULT OnNotifyExpand(LPDATAOBJECT pDataObject, BOOL bExpanding, HSCOPEITEM hParent);

	// needed for GetDisplayInfo(), must be defined by subclass
	virtual BSTR QueryResultColumnText(CCookie& basecookieref, int nCol );
	virtual int QueryImage(CCookie& basecookieref, BOOL fOpenImage);

	virtual CCookie& QueryBaseRootCookie();

	inline CCertTmplCookie* ActiveCookie( CCookie* pBaseCookie )
	{
		return (CCertTmplCookie*)ActiveBaseCookie( pBaseCookie );
	}

	inline CCertTmplCookie& QueryRootCookie()
	{
		return m_RootCookie;
	}

	virtual HRESULT OnNotifyRelease(LPDATAOBJECT pDataObject, HSCOPEITEM hItem);

	// CHasMachineName
	DECLARE_FORWARDS_MACHINE_NAME( (&m_RootCookie) )

    CStringList m_globalFriendlyNameList;
	CStringList m_globalTemplateNameList;

protected:
    LPCONSOLE m_pComponentConsole;

    void OnViewOIDs ();
    HRESULT AddViewOIDsMenuItem (
                LPCONTEXTMENUCALLBACK pContextMenuCallback, 
                LONG lInsertionPointID);
	HRESULT ChangeRootNodeName();
	HRESULT AddCloneTemplateMenuItem(
                LPCONTEXTMENUCALLBACK pContextMenuCallback, 
                LONG lInsertionPointID);
    HRESULT AddReEnrollAllCertsMenuItem(
                LPCONTEXTMENUCALLBACK pContextMenuCallback, 
                LONG lInsertionPointID);
	HRESULT OnCloneTemplate (LPDATAOBJECT pDataObject);
    HRESULT OnReEnrollAllCerts (LPDATAOBJECT pDataObject);
    HRESULT AddCertTemplatePropPages (
                CCertTemplate* pCertTemplate, 
                LPPROPERTYSHEETCALLBACK pCallback,
                LONG_PTR lNotifyHandle);
	HRESULT AddVersion1CertTemplatePropPages (CCertTemplate* pCertTemplate, LPPROPERTYSHEETCALLBACK pCallback);
	HRESULT AddVersion2CertTemplatePropPages (
                CCertTemplate* pCertTemplate, 
                LPPROPERTYSHEETCALLBACK pCallback,
                LONG_PTR lNotifyHandle);
	HRESULT				AddScopeNode (
								CCertTmplCookie*		pCookie,
								HSCOPEITEM			hParent);
	HRESULT				AddSeparator (
								LPCONTEXTMENUCALLBACK pContextMenuCallback);
	CCertTmplCookie*    ConvertCookie (
								LPDATAOBJECT		pDataObject);
	HRESULT				DeleteChildren (
								HSCOPEITEM			hParent);
	HRESULT				DeleteScopeItems ();
	void				DisplaySystemError (
								DWORD				dwErr);
	HRESULT				ExpandScopeNodes (
								CCertTmplCookie*		pParentCookie,
								HSCOPEITEM			hParent,
								const GUID&			guidObjectType,
                                LPDATAOBJECT        pDataObject = 0);
	HRESULT				GetResultData (LPRESULTDATA* ppResultData);
	HRESULT				IsUserAdministrator (
								BOOL&				bIsAdministrator);
	virtual HRESULT		OnPropertyChange (LPARAM param);
	HRESULT				QueryMultiSelectDataObject(
								MMC_COOKIE			cookie,
								DATA_OBJECT_TYPES	type,
                                   LPDATAOBJECT*		ppDataObject);
	HRESULT				ReleaseResultCookie (
								CBaseCookieBlock *	pResultCookie,
								CCookie&			rootCookie,
								POSITION			pos2);
	HRESULT				OnNotifyPreload(
								LPDATAOBJECT		pDataObject,
								HSCOPEITEM			hRootScopeItem);
	STDMETHOD(GetHelpTopic)(LPOLESTR* lpCompiledHelpFile);
	HRESULT GetHtmlHelpFilePath( CString& strref ) const;

    LPHEADERCTRL					m_pHeader;

private:
	CString							m_serverName;
	bool							m_bMultipleObjectsSelected;
	BOOL							m_bIsUserAdministrator;
	CString							m_szThisComputer;
	CString							m_szLoggedInUser;
	HSCOPEITEM						m_hRootScopeItem;
	CCertTmplCookie					m_RootCookie;
	LPRESULTDATA					m_pResultData;
    bool                            m_bSchemaChecked;
}; // CCertTmplComponentData


/////////////////////////////////////////////////////////////////////
class CCertTmplSnapin: public CCertTmplComponentData,
	public CComCoClass<CCertTmplSnapin, &CLSID_CertTemplatesSnapin>
{
public:
	CCertTmplSnapin() : CCertTmplComponentData () {};
	virtual ~CCertTmplSnapin() {};

// Use DECLARE_NOT_AGGREGATABLE(CCertTmplSnapin) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(CCertTmplSnapin)
DECLARE_REGISTRY(CCertTmplSnapin, _T("CERTTMPL.CertTemplatesSnapinObject.1"), _T("CERTTMPL.CertTemplatesSnapinObject.1"), IDS_CERTTMPL_DESC, THREADFLAGS_BOTH)
	virtual BOOL IsServiceSnapin() { return FALSE; }

// IPersistStream or IPersistStorage
	STDMETHOD(GetClassID)(CLSID __RPC_FAR *pClassID)
	{
		*pClassID = CLSID_CertTemplatesSnapin;
		return S_OK;
	}
};


#endif // ~__COMPDATA_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\cookie.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       cookie.h
//
//  Contents:   CCertTmplCookie
//
//----------------------------------------------------------------------------

#ifndef __COOKIE_H_INCLUDED__
#define __COOKIE_H_INCLUDED__

extern HINSTANCE g_hInstanceSave;   // Instance handle of the DLL (initialized 
                                    //during CCertTmplComponent::Initialize)


#include "nodetype.h"

/////////////////////////////////////////////////////////////////////////////
// cookie

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class CCertTmplCookie : public CCookie,
                        public CBaseCookieBlock
{
public:
	CCertTmplCookie (CertTmplObjectType objecttype,
			PCWSTR objectName = 0);

	virtual ~CCertTmplCookie ();

	// returns <0, 0 or >0
	virtual HRESULT CompareSimilarCookies( CCookie* pOtherCookie, int* pnResult );
	
// CBaseCookieBlock
	virtual CCookie* QueryBaseCookie(int i);
	virtual int QueryNumCookies();

public:
	void SetManagedDomainDNSName (const CString& szManagedDomainDNSName);
	CString GetManagedDomainDNSName() const;
	virtual CString GetClass () { return L"";}
	LPRESULTDATA m_resultDataID;
	virtual void Refresh () {};
	virtual HRESULT Commit ();
	CString GetServiceName () const;
	void SetServiceName (CString &szManagedService);
	PCWSTR GetObjectName () const;
	const CertTmplObjectType m_objecttype;

private:
	CString m_szManagedDomainDNSName;
	CString m_objectName;
protected:
	void SetObjectName (const CString& strObjectName);
};


#endif // ~__COOKIE_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\dataobj.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1999.
//
//  File:       dataobj.h
//
//  Contents:   CCertTemplatesDataObject
//
//----------------------------------------------------------------------------

#ifndef __DATAOBJ_H_INCLUDED__
#define __DATAOBJ_H_INCLUDED__


// For use in multiple selection.
LPDATAOBJECT ExtractMultiSelect (LPDATAOBJECT lpDataObject);


class CCertTemplatesDataObject : public CDataObject
{
	DECLARE_NOT_AGGREGATABLE(CCertTemplatesDataObject)

public:

// debug refcount
#if DBG==1
	ULONG InternalAddRef()
	{
        return CComObjectRoot::InternalAddRef();
	}
	ULONG InternalRelease()
	{
        return CComObjectRoot::InternalRelease();
	}
    int dbg_InstID;
#endif // DBG==1

	CCertTemplatesDataObject();

	virtual ~CCertTemplatesDataObject();

	STDMETHODIMP Next(ULONG celt, MMC_COOKIE* rgelt, ULONG *pceltFetched);
	STDMETHODIMP Skip(ULONG celt);
	STDMETHODIMP Reset(void);
	void AddCookie(CCertTmplCookie* pCookie);
	virtual HRESULT Initialize (
			CCertTmplCookie* pcookie,
			DATA_OBJECT_TYPES type,
			CCertTmplComponentData& refComponentData);

	// IDataObject interface implementation
    HRESULT STDMETHODCALLTYPE GetDataHere(
		FORMATETC __RPC_FAR *pFormatEtcIn,
        STGMEDIUM __RPC_FAR *pMedium);

	void SetMultiSelData(BYTE* pbMultiSelData, UINT cbMultiSelData);
	STDMETHODIMP GetData(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);
    STDMETHOD(IsMultiSelect)(void)
    {
        return (m_rgCookies.GetSize() > 1) ? S_OK : S_FALSE;
    }

protected:
	HRESULT PutDisplayName(STGMEDIUM* pMedium);
	HRESULT CreateMultiSelectObject(LPSTGMEDIUM lpMedium);
	HRESULT Create (const void* pBuffer, int len, LPSTGMEDIUM lpMedium);
	CCertTmplCookie* m_pCookie; // the CCookieBlock is AddRef'ed for the life of the DataObject
	CertTmplObjectType m_objecttype;
	DATA_OBJECT_TYPES m_dataobjecttype;
	GUID m_SnapInCLSID;

public:

	// Clipboard formats
	static CLIPFORMAT m_CFDisplayName;
    static CLIPFORMAT m_CFMultiSel;        // Required for multiple selection
    static CLIPFORMAT m_CFMultiSelDobj;    // Required for multiple selection
	static CLIPFORMAT m_CFMultiSelDataObjs;// for Multiple selection
	static CLIPFORMAT m_CFDsObjectNames;	 // For DS object property pages

private:
    // data member used by IEnumCookies
    ULONG							m_iCurr;
	CCookiePtrArray					m_rgCookies;
	bool							m_bMultiSelDobj;
    BYTE*							m_pbMultiSelData;
    UINT							m_cbMultiSelData;

public:
    void SetMultiSelDobj()
    {
        m_bMultiSelDobj = true;
    }
}; // CCertTemplatesDataObject

#endif // ~__DATAOBJ_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\dbg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       dbg.h
//
//  Contents:   
//
//----------------------------------------------------------------------------

#include <StdDbg.h>

#if DBG==1
    DECLARE_DEBUG(CertTmplSnapin)
    #define DBG_COMP    CertTmplSnapinInfoLevel
#endif // DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\dataobj.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       DataObj.cpp
//
//  Contents:   Implementation of data object classes: CCertTemplatesDataObject
//
//----------------------------------------------------------------------------

#include "stdafx.h"

USE_HANDLE_MACROS("CERTTMPL(dataobj.cpp)")

#include "compdata.h"
#include "dataobj.h"

#include "uuids.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#include "stddtobj.cpp"

// IDataObject interface implementation

CCertTemplatesDataObject::CCertTemplatesDataObject()
		: m_pCookie (0),
		m_objecttype (CERTTMPL_SNAPIN),
		m_dataobjecttype (CCT_UNINITIALIZED),
        m_pbMultiSelData(NULL),
        m_cbMultiSelData(0),
		m_bMultiSelDobj(false),
		m_iCurr(0)
{
}

HRESULT CCertTemplatesDataObject::GetDataHere(
	FORMATETC __RPC_FAR *pFormatEtcIn,
	STGMEDIUM __RPC_FAR *pMedium)
{
	const CLIPFORMAT cf=pFormatEtcIn->cfFormat;
	if (cf == m_CFNodeType)
	{
		if ( IsValidObjectType (m_pCookie->m_objecttype) )
		{
			const GUID* pguid = GetObjectTypeGUID( m_pCookie->m_objecttype );
			stream_ptr s(pMedium);
			return s.Write(pguid, sizeof(GUID));
		}
		else
			return E_UNEXPECTED;
	}
	else if (cf == m_CFSnapInCLSID)
	{
		stream_ptr s(pMedium);
		return s.Write(&m_SnapInCLSID, sizeof(GUID));
	}
	else if (cf == m_CFNodeTypeString)
	{
		if ( IsValidObjectType (m_pCookie->m_objecttype) )
		{
			const BSTR strGUID = GetObjectTypeString( m_pCookie->m_objecttype );
			stream_ptr s(pMedium);
			return s.Write(strGUID);
		}
		else
			return E_UNEXPECTED;
	}
	else if (cf == m_CFDisplayName)
	{
		return PutDisplayName(pMedium);
	}
	else if (cf == m_CFDataObjectType)
	{
		stream_ptr s(pMedium);
		return s.Write(&m_dataobjecttype, sizeof(m_dataobjecttype));
	}
	else if (cf == m_CFRawCookie)
	{
		stream_ptr s(pMedium);


		if ( m_pCookie )
		{
			// CODEWORK This cast ensures that the data format is
			// always a CCookie*, even for derived subclasses
			if ( ((CCertTmplCookie*) MMC_MULTI_SELECT_COOKIE) == m_pCookie ||
					IsValidObjectType (m_pCookie->m_objecttype) )
			{
				CCookie* pcookie = (CCookie*) m_pCookie;
				return s.Write(reinterpret_cast<PBYTE>(&pcookie), sizeof(m_pCookie));
			}
			else
				return E_UNEXPECTED;
		}
	}
	else if ( cf == m_CFMultiSel )
	{
		return CreateMultiSelectObject (pMedium);
	}
	else if (cf == m_CFSnapinPreloads)
	{
		stream_ptr s(pMedium);
		// If this is TRUE, then the next time this snapin is loaded, it will
		// be preloaded to give us the opportunity to change the root node
		// name before the user sees it.
		BOOL	x = 1;

		return s.Write (reinterpret_cast<PBYTE>(&x), sizeof (BOOL));
	}

	return DV_E_FORMATETC;
}

HRESULT CCertTemplatesDataObject::Initialize(
	CCertTmplCookie*			pcookie,
	DATA_OBJECT_TYPES		type,
	CCertTmplComponentData&	refComponentData)
{
	if ( !pcookie || m_pCookie )
	{
		ASSERT(FALSE);
		return S_OK;	// Initialize must not fail
	}

	m_dataobjecttype = type;
	m_pCookie = pcookie;

	if ( ((CCertTmplCookie*) MMC_MULTI_SELECT_COOKIE) != m_pCookie )
		((CRefcountedObject*)m_pCookie)->AddRef();
	VERIFY( SUCCEEDED(refComponentData.GetClassID(&m_SnapInCLSID)) );
	return S_OK;
}


CCertTemplatesDataObject::~CCertTemplatesDataObject()
{
	if ( ((CCertTmplCookie*) MMC_MULTI_SELECT_COOKIE) != m_pCookie &&
			m_pCookie && IsValidObjectType (m_pCookie->m_objecttype) )
	{
		((CRefcountedObject*)m_pCookie)->Release();
	}
    if (m_pbMultiSelData)
        delete m_pbMultiSelData;

    for (int i=0; i < m_rgCookies.GetSize(); ++i)
    {
        m_rgCookies[i]->Release();
        m_rgCookies[i] = 0;
    }
}

void CCertTemplatesDataObject::AddCookie(CCertTmplCookie* pCookie)
{
    m_rgCookies.Add(pCookie);
    pCookie->AddRef();
}

HRESULT CCertTemplatesDataObject::PutDisplayName(STGMEDIUM* pMedium)
	// Writes the "friendly name" to the provided storage medium
	// Returns the result of the write operation
{
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	CString strDomainName = m_pCookie->GetManagedDomainDNSName();

	stream_ptr s (pMedium);
	CString		snapinName;
    // security review 2/21/2002 BryanWal ok
	snapinName.FormatMessage (IDS_CERTTMPL_ROOT_NODE_NAME, strDomainName);
	return s.Write ((PCWSTR) snapinName);
}

// Register the clipboard formats
CLIPFORMAT CCertTemplatesDataObject::m_CFDisplayName =
								(CLIPFORMAT)RegisterClipboardFormat(CCF_DISPLAY_NAME);
CLIPFORMAT CDataObject::m_CFRawCookie =
								(CLIPFORMAT)RegisterClipboardFormat(L"CERTTMPL_SNAPIN_RAW_COOKIE");
CLIPFORMAT CCertTemplatesDataObject::m_CFMultiSel =
								(CLIPFORMAT)RegisterClipboardFormat(CCF_OBJECT_TYPES_IN_MULTI_SELECT);
CLIPFORMAT CCertTemplatesDataObject::m_CFMultiSelDobj =
								(CLIPFORMAT)RegisterClipboardFormat(CCF_MMC_MULTISELECT_DATAOBJECT);
CLIPFORMAT CCertTemplatesDataObject::m_CFMultiSelDataObjs =
							    (CLIPFORMAT)RegisterClipboardFormat(CCF_MULTI_SELECT_SNAPINS);
CLIPFORMAT CCertTemplatesDataObject::m_CFDsObjectNames =
                                (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DSOBJECTNAMES);


void CCertTemplatesDataObject::SetMultiSelData(BYTE* pbMultiSelData, UINT cbMultiSelData)
{
    m_pbMultiSelData = pbMultiSelData;
    m_cbMultiSelData = cbMultiSelData;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCertTmplComponentData::QueryDataObject (
		MMC_COOKIE cookie,
		DATA_OBJECT_TYPES type,
		LPDATAOBJECT* ppDataObject)
{
	if ( MMC_MULTI_SELECT_COOKIE == cookie )
	{
		return QueryMultiSelectDataObject (cookie, type, ppDataObject);
	}
	CCertTmplCookie* pUseThisCookie =
			(CCertTmplCookie*) ActiveBaseCookie (
			reinterpret_cast<CCookie*> (cookie));

	CComObject<CCertTemplatesDataObject>* pDataObject = 0;
	HRESULT hRes = CComObject<CCertTemplatesDataObject>::CreateInstance(&pDataObject);
	if ( FAILED(hRes) )
		return hRes;

	HRESULT hr = pDataObject->Initialize (
			pUseThisCookie,
			type,
			*this);
	if ( FAILED(hr) )
	{
		delete pDataObject;
		return hr;
	}

    pDataObject->AddRef();
	*ppDataObject = pDataObject;
	return hr;
}

typedef CArray<GUID, const GUID&> CGUIDArray;

void GuidArray_Add(CGUIDArray& rgGuids, const GUID& guid)
{
    for (INT_PTR i=rgGuids.GetUpperBound(); i >= 0; --i)
    {
        if (rgGuids[i] == guid)
            break;
    }

    if (i < 0)
        rgGuids.Add(guid);
}

HRESULT CCertTmplComponentData::QueryMultiSelectDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                                            LPDATAOBJECT* ppDataObject)
{
    ASSERT(ppDataObject != NULL);
    if (ppDataObject == NULL)
        return E_POINTER;

	HRESULT		hr = S_OK;
    CGUIDArray	rgGuids;

    // Determine the items selected
    ASSERT(m_pResultData != NULL);
    RESULTDATAITEM rdi;
    // security review 2/21/2002 BryanWal ok
    ZeroMemory(&rdi, sizeof(rdi));
    rdi.mask = RDI_STATE;
    rdi.nIndex = -1;
    rdi.nState = TVIS_SELECTED;

	CCookiePtrArray	rgCookiesSelected;
    while (m_pResultData->GetNextItem (&rdi) == S_OK)
    {
        const GUID* pguid;
        CCertTmplCookie* pCookie = reinterpret_cast <CCertTmplCookie*> (rdi.lParam);
        if ( pCookie )
        {
			rgCookiesSelected.Add (pCookie);
			switch (pCookie->m_objecttype)
			{
            case CERTTMPL_CERT_TEMPLATE:
                pguid = &NODEID_CertTmpl_CERT_TEMPLATE;
                break;

			default:
				ASSERT (0);
				continue;
			}
        }
        else
        {
			hr = E_INVALIDARG;
			break;
        }

        GuidArray_Add(rgGuids, *pguid);
    }

    if ( SUCCEEDED (hr) )
    {
        CComObject<CCertTemplatesDataObject>* pObject;
        hr = CComObject<CCertTemplatesDataObject>::CreateInstance(&pObject);
        ASSERT(SUCCEEDED (hr) && pObject != NULL);
        if ( SUCCEEDED (hr) )
        {
            if ( pObject )
            {
                // Save cookie and type for delayed rendering
	            pObject->Initialize ((CCertTmplCookie*) cookie,
				            type,
				            *this);
                pObject->SetMultiSelDobj();



                // Store the coclass with the data object
                UINT cb = (UINT)(rgGuids.GetSize() * sizeof(GUID));
                GUID* pGuid = new GUID[(UINT)rgGuids.GetSize()];
                if ( pGuid )
                {
                    // security review 2/21/2002 BryanWal ok
                    CopyMemory(pGuid, rgGuids.GetData(), cb);
                    pObject->SetMultiSelData((BYTE*)pGuid, cb);
	                for (int i=0; i < rgCookiesSelected.GetSize(); ++i)
	                {
		                pObject->AddCookie(rgCookiesSelected[i]);
	                }

                    hr = pObject->QueryInterface(
			                IID_PPV_ARG (IDataObject, ppDataObject));
                }
                else
                    hr = E_OUTOFMEMORY;
            }
            else
                hr = E_FAIL;
        }
    }

    return hr;
}



//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::Create
//
//  Synopsis:   Fill the hGlobal in [lpmedium] with the data in pBuffer
//
//  Arguments:  [pBuffer]  - [in] the data to be written
//              [len]      - [in] the length of that data
//              [pMedium] - [in,out] where to store the data
//  History:
//
//---------------------------------------------------------------------------
HRESULT CCertTemplatesDataObject::Create (const void* pBuffer, int len, LPSTGMEDIUM pMedium)
{
   HRESULT hr = DV_E_TYMED;

   //
   // Do some simple validation
   //
   if (pBuffer == NULL || pMedium == NULL)
      return E_POINTER;

   //
   // Make sure the type medium is HGLOBAL
   //
   if (pMedium->tymed == TYMED_HGLOBAL) {
      //
      // Create the stream on the hGlobal passed in
      //
      LPSTREAM lpStream = 0;
      hr = CreateStreamOnHGlobal(pMedium->hGlobal, FALSE, &lpStream);

	  ASSERT (SUCCEEDED (hr));
      if (SUCCEEDED(hr))
	  {
         //
         // Write to the stream the number of bytes
         //
         ULONG written = 0;
         hr = lpStream->Write(pBuffer, len, &written);
		 ASSERT (SUCCEEDED (hr));

         //
         // Because we told CreateStreamOnHGlobal with 'FALSE',
         // only the stream is released here.
         // Note - the caller (i.e. snap-in, object) will free the HGLOBAL
         // at the correct time.  This is according to the IDataObject specification.
         //
         lpStream->Release();
      }
   }

   return hr;
}


//+----------------------------------------------------------------------------
//
//  Method:     CCertTemplatesDataObject::CreateMultiSelectObject
//
//  Synopsis:   this is to create the list of types selected
//
//-----------------------------------------------------------------------------

HRESULT CCertTemplatesDataObject::CreateMultiSelectObject(LPSTGMEDIUM pMedium)
{
    ASSERT(m_pbMultiSelData != 0);
    ASSERT(m_cbMultiSelData != 0);

    pMedium->tymed = TYMED_HGLOBAL;
    pMedium->hGlobal = ::GlobalAlloc(GMEM_SHARE|GMEM_MOVEABLE,
                                      (m_cbMultiSelData + sizeof(DWORD)));
    if (pMedium->hGlobal == NULL)
        return STG_E_MEDIUMFULL;

    BYTE* pb = reinterpret_cast<BYTE*>(::GlobalLock(pMedium->hGlobal));
    *((DWORD*)pb) = m_cbMultiSelData / sizeof(GUID);
    pb += sizeof(DWORD);
    // security review 2/21/2002 BryanWal ok
    CopyMemory(pb, m_pbMultiSelData, m_cbMultiSelData);

    ::GlobalUnlock(pMedium->hGlobal);

	return S_OK;
}




LPDATAOBJECT ExtractMultiSelect (LPDATAOBJECT lpDataObject)
{
	if (lpDataObject == NULL)
		return NULL;

	SMMCDataObjects * pDO = NULL;

	STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
	FORMATETC formatetc = { CCertTemplatesDataObject::m_CFMultiSelDataObjs, NULL,
                           DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

	if ( FAILED (lpDataObject->GetData (&formatetc, &stgmedium)) )
	{
		return NULL;
	}
	else
	{
		pDO = reinterpret_cast<SMMCDataObjects*>(stgmedium.hGlobal);
		return pDO->lpDataObject[0]; //assume that ours is the 1st
	}
}

STDMETHODIMP CCertTemplatesDataObject::GetData(LPFORMATETC lpFormatetc, LPSTGMEDIUM pMedium)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = DV_E_CLIPFORMAT;

    if (lpFormatetc->cfFormat == m_CFMultiSel)
    {
        ASSERT(((CCertTmplCookie*) MMC_MULTI_SELECT_COOKIE) == m_pCookie);
        if ( ((CCertTmplCookie*) MMC_MULTI_SELECT_COOKIE) != m_pCookie )
            return E_FAIL;

        hr = CreateMultiSelectObject (pMedium);
    }
	else if ( lpFormatetc->cfFormat == m_CFDsObjectNames )
	{
		switch (m_pCookie->m_objecttype)
		{
        case CERTTMPL_CERT_TEMPLATE:
			{
				CCertTemplate* pCertTemplate = dynamic_cast <CCertTemplate*> (m_pCookie);
				ASSERT (pCertTemplate);
				if ( pCertTemplate )
				{
					// figure out how much storage we need
                    CString adsiPath;
                    adsiPath = pCertTemplate->GetLDAPPath ();
					int cbPath = sizeof (WCHAR) * (adsiPath.GetLength() + 1);
					int cbClass = sizeof (WCHAR) * (pCertTemplate->GetClass ().GetLength() + 1);;
					int cbStruct = sizeof(DSOBJECTNAMES); //contains already a DSOBJECT embedded struct

					LPDSOBJECTNAMES pDSObj = 0;

					pDSObj = (LPDSOBJECTNAMES)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
							cbStruct + cbPath + cbClass);

					if ( pDSObj )
					{
						// write the info
						pDSObj->clsidNamespace = CLSID_CertTemplatesSnapin;
						pDSObj->cItems = 1;

						pDSObj->aObjects[0].dwFlags = 0;
						pDSObj->aObjects[0].dwProviderFlags = 0;

						pDSObj->aObjects[0].offsetName = cbStruct;
						pDSObj->aObjects[0].offsetClass = cbStruct + cbPath;

                        // security review 2/21/2002 BryanWal ok
						wcsncpy((LPWSTR)((BYTE *)pDSObj + (pDSObj->aObjects[0].offsetName)),
								(LPCWSTR) adsiPath, cbPath);

                        // security review 2/21/2002 BryanWal ok
						wcsncpy((LPWSTR)((BYTE *)pDSObj + (pDSObj->aObjects[0].offsetClass)),
								(LPCWSTR) pCertTemplate->GetClass (), cbClass);

						pMedium->hGlobal = (HGLOBAL)pDSObj;
						pMedium->tymed = TYMED_HGLOBAL;
						pMedium->pUnkForRelease = NULL;
						hr = S_OK;
					}
					else
						hr = STG_E_MEDIUMFULL;
				}
			}
			break;

		default:
			break;
		}
	}

    return hr;
}

STDMETHODIMP CCertTemplatesDataObject::Next(ULONG celt, MMC_COOKIE* rgelt, ULONG *pceltFetched)
{
    HRESULT hr = S_OK;

    if ((rgelt == NULL) ||
        ((celt > 1) && (pceltFetched == NULL)))
    {
        hr = E_INVALIDARG;
        return hr;
    }

    ULONG celtTemp = (ULONG)(m_rgCookies.GetSize() - m_iCurr);
    celtTemp = (celt < celtTemp) ? celt : celtTemp;

    if (pceltFetched)
        *pceltFetched = celtTemp;

    if (celtTemp == 0)
        return S_FALSE;

    for (ULONG i=0; i < celtTemp; ++i)
    {
        rgelt[i] = reinterpret_cast<MMC_COOKIE>(m_rgCookies[m_iCurr++]);
    }

    return (celtTemp < celt) ? S_FALSE : S_OK;
}

STDMETHODIMP CCertTemplatesDataObject::Skip(ULONG celt)
{
    ULONG celtTemp = (ULONG)(m_rgCookies.GetSize() - m_iCurr);
    celtTemp = (celt < celtTemp) ? celt : celtTemp;

    m_iCurr += celtTemp;

    return (celtTemp < celt) ? S_FALSE : S_OK;
}


STDMETHODIMP CCertTemplatesDataObject::Reset(void)
{
    m_iCurr = 0;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\debug.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       debug.h
//
//  Contents:   Debugging macros and prototypes
//
//----------------------------------------------------------------------------


#ifndef _DEBUG_H_
#define _DEBUG_H_


#if DBG == 1


void __cdecl _TRACE (int level, const wchar_t *format, ... );


//
// External functions
//

PCSTR StripDirPrefixA(PCSTR);



//
// These macros are used for asserting certain conditions. They are
// independent of the debugging level.
// These also require additional paranthesis to enclose the msg as
// shown below.
//

#ifdef _ASSERT
#undef _ASSERT
#undef _ASSERTMSG
#endif

#define _ASSERT(expr)                                                    \
        {                                                               \
            if (!(expr))                                                \
            {                                                           \
               _TRACE (0, L"Cert Template Snapin(Thread ID: %d): Assert: %s(%u)\n",               \
                         GetCurrentThreadId(),                          \
                         StripDirPrefixA(__FILE__), __LINE__);          \
                DebugBreak();                                           \
            }                                                           \
        }


#define _ASSERTMSG(expr, msg)                                            \
        {                                                               \
            if (!(expr))                                                \
            {                                                           \
                _TRACE (0, L"Cert Template Snapin(%d): Assert: %s(%u)\n",               \
                         GetCurrentThreadId(),                          \
                         StripDirPrefixA(__FILE__), __LINE__);          \
                _TRACE (0, msg);                                           \
                _TRACE (0, "\n");                                         \
                DebugBreak();                                           \
            }                                                           \
        }

    void CheckDebugOutputLevel ();

#else // !DBG


#define _TRACE 
#define _ASSERTMSG(expr, msg)

#endif



#endif  // ifndef _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\disabledwarnings.h ===
// Copyright (c) 2000-2001 Microsoft Corporation
//
// pragma warnings
//
// 8 Feb 2000 sburns



// disable "symbols too long for debugger" warning: it happens a lot w/ STL

#pragma warning (disable: 4786)

// disable "exception specification ignored" warning: we use exception
// specifications

#pragma warning (disable: 4290)

// who cares about unreferenced inline removal?

#pragma warning (disable: 4514)
#pragma warning (disable : 4505)

// we frequently use constant conditional expressions: do/while(0), etc.

#pragma warning (disable: 4127)

// some stl templates are lousy signed/unsigned mismatches

#pragma warning (disable: 4018 4146)

// we like this extension

#pragma warning (disable: 4239)

// we don't always want copy constructors

#pragma warning (disable: 4511)

// we don't always want assignment operators

#pragma warning (disable: 4512)

// often, we have local variables for the express purpose of ASSERTion.
// when compiling retail, those assertions disappear, leaving our locals
// as unreferenced.

#ifndef DBG

#pragma warning (disable: 4189 4100)

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\extendedkeyusagepropertypage.h ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       ExtendedKeyUsagePropertyPage.h
//
//  Contents:   Definition of CExtendedKeyUsagePropertyPage
//
//----------------------------------------------------------------------------
#if !defined(AFX_EXTENDEDKEYUSAGEPROPERTYPAGE_H__71F4BE79_981E_4D84_BE10_3BA145D665E3__INCLUDED_)
#define AFX_EXTENDEDKEYUSAGEPROPERTYPAGE_H__71F4BE79_981E_4D84_BE10_3BA145D665E3__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ExtendedKeyUsagePropertyPage.h : header file
//
#include "CertTemplate.h"

class EKUCheckListBox : public CCheckListBox
{
public:
	EKUCheckListBox () : CCheckListBox () {};
	virtual ~EKUCheckListBox () {};
	virtual BOOL Create (DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID)
	{
        CThemeContextActivator activator;
		return CCheckListBox::Create (dwStyle, rect, pParentWnd, nID);
	}
};


/////////////////////////////////////////////////////////////////////////////
// CExtendedKeyUsagePropertyPage dialog

class CExtendedKeyUsagePropertyPage : public CPropertyPage
{
// Construction
public:
	CExtendedKeyUsagePropertyPage(
            CCertTemplate& rCertTemplate, 
            PCERT_EXTENSION pCertExtension);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CExtendedKeyUsagePropertyPage)
	enum { IDD = IDD_EXTENDED_KEY_USAGE };
	EKUCheckListBox	m_EKUList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CExtendedKeyUsagePropertyPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CExtendedKeyUsagePropertyPage)
	afx_msg void OnNewEku();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
    CCertTemplate&  m_rCertTemplate;
    PCERT_EXTENSION m_pCertExtension;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EXTENDEDKEYUSAGEPROPERTYPAGE_H__71F4BE79_981E_4D84_BE10_3BA145D665E3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\debug.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2002.
//
//  File:       debug.cpp
//
//  Contents:   Debugging support
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include <strsafe.h>

#if DBG == 1
static int indentLevel = 0;

#define DEBUG_OUTPUT_NONE       0
#define DEBUG_OUTPUT_ERROR      1
#define DEBUG_OUTPUT_WARNING    2
#define DEBUG_OUTPUT_TRACE      3
#define DEBUGKEY    L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AdminDebug\\CertTmpl"
#define DEBUGLEVEL  L"debugOutput"

static bool             g_fDebugOutputLevelInit = false;
static unsigned long    g_ulDebugOutput = DEBUG_OUTPUT_NONE;

void __cdecl _TRACE (int level, const wchar_t *format, ... )
{
    if ( g_ulDebugOutput > DEBUG_OUTPUT_NONE )
    {
        va_list arglist;
        const size_t DEBUG_BUF_LEN = 512;
        WCHAR Buffer[DEBUG_BUF_LEN];
        Buffer[0] = 0;

        if ( level < 0 )
            indentLevel += level;
        //
        // Format the output into a buffer and then print it.
        //
        wstring strTabs;

        for (int nLevel = 0; nLevel < indentLevel; nLevel++)
            strTabs += L"  ";

        OutputDebugStringW (strTabs.c_str ());

        va_start(arglist, format);

        // Don't check return value - we don't care if this gets truncated as
        // it's just debugging output
        if ( SUCCEEDED (::StringCchVPrintf (Buffer,  // check value only to shut up prefast
                        DEBUG_BUF_LEN,
                        format,
                        arglist)) )
        {
        }

        if ( Buffer[0] )
            OutputDebugStringW (Buffer);

        va_end(arglist);

        if ( level > 0 )
            indentLevel += level;
    }
}


PCSTR 
StripDirPrefixA (
    PCSTR pszPathName
    )

/*++

Routine Description:

    Strip the directory prefix off a filename (ANSI version)

Arguments:

    pstrFilename - Pointer to filename string

Return Value:

    Pointer to the last component of a filename (without directory prefix)

--*/

{
    if ( pszPathName )
    {
        DWORD dwLen = lstrlenA(pszPathName);

        pszPathName += dwLen - 1;       // go to the end

        while (*pszPathName != '\\' && dwLen--)
        {
            pszPathName--;
        }

        return pszPathName + 1;
    }
    else
        return "";
}

//+----------------------------------------------------------------------------
// Function:    CheckDebugOutputLevel
//
// Synopsis:    Performs debugging library initialization
//              including reading the registry for the desired infolevel
//
//-----------------------------------------------------------------------------
void CheckDebugOutputLevel ()
{
    if ( g_fDebugOutputLevelInit ) 
        return;
    g_fDebugOutputLevelInit = true;
    HKEY    hKey = 0;
    DWORD   dwDisposition = 0;
    LONG lResult = ::RegCreateKeyEx (HKEY_LOCAL_MACHINE, // handle of an open key
            DEBUGKEY,     // address of subkey name
            0,       // reserved
            L"",       // address of class string
            REG_OPTION_VOLATILE,      // special options flag
            // security review 2/21/2002 BryanWal ok
            KEY_SET_VALUE | KEY_QUERY_VALUE,    // desired security access
            NULL,     // address of key security structure
			&hKey,      // address of buffer for opened handle
		    &dwDisposition);  // address of disposition value buffer
    if (lResult == ERROR_SUCCESS)
    {
        DWORD   dwSize = sizeof(unsigned long);
        DWORD   dwType = REG_DWORD;
        // security review 2/21/2002 BryanWal ok
        lResult = RegQueryValueExW (hKey, DEBUGLEVEL, NULL, &dwType,
                                (LPBYTE)&g_ulDebugOutput, &dwSize);
        if (lResult != ERROR_SUCCESS)
        {
            g_ulDebugOutput = DEBUG_OUTPUT_NONE;
            if ( ERROR_FILE_NOT_FOUND == lResult )
            {
                lResult = ::RegSetValueExW (hKey, DEBUGLEVEL, 0, REG_DWORD,
                        (LPBYTE)&g_ulDebugOutput, sizeof (g_ulDebugOutput));
                ASSERT (lResult == ERROR_SUCCESS);
            }
        }
        else
        {
            ASSERT (dwType == REG_DWORD);
        }
        RegCloseKey(hKey);
    }
}

#endif  // if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\extendedkeyusagepropertypage.cpp ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       ExtendedKeyUsagePropertyPage.cpp
//
//  Contents:   Implementation of CExtendedKeyUsagePropertyPage
//
//----------------------------------------------------------------------------
// ExtendedKeyUsagePropertyPage.cpp : implementation file
//

#include "stdafx.h"
#include "ExtendedKeyUsagePropertyPage.h"
#include "NewOIDDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CExtendedKeyUsagePropertyPage dialog


CExtendedKeyUsagePropertyPage::CExtendedKeyUsagePropertyPage(
        CCertTemplate& rCertTemplate, 
        PCERT_EXTENSION pCertExtension)
	: CPropertyPage(CExtendedKeyUsagePropertyPage::IDD),
    m_rCertTemplate (rCertTemplate),
    m_pCertExtension (pCertExtension)
{
	//{{AFX_DATA_INIT(CExtendedKeyUsagePropertyPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CExtendedKeyUsagePropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CExtendedKeyUsagePropertyPage)
	DDX_Control(pDX, IDC_EKU_LIST, m_EKUList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CExtendedKeyUsagePropertyPage, CPropertyPage)
	//{{AFX_MSG_MAP(CExtendedKeyUsagePropertyPage)
	ON_BN_CLICKED(IDC_NEW_EKU, OnNewEku)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CExtendedKeyUsagePropertyPage message handlers

void CExtendedKeyUsagePropertyPage::OnNewEku() 
{
	CNewOIDDlg  oidDlg;


    CThemeContextActivator activator;
    oidDlg.DoModal ();
}

BOOL CExtendedKeyUsagePropertyPage::OnInitDialog() 
{
    _TRACE (1, L"Entering CExtendedKeyUsagePropertyPage::OnInitDialog ()\n");
	CPropertyPage::OnInitDialog();
	
	ASSERT (m_pCertExtension);
	if ( m_pCertExtension )
	{
		DWORD	cbEnhKeyUsage = 0;


		if ( ::CryptDecodeObject(CRYPT_ASN_ENCODING, 
				szOID_ENHANCED_KEY_USAGE, 
				m_pCertExtension->Value.pbData,
				m_pCertExtension->Value.cbData,
				0, NULL, &cbEnhKeyUsage) )
		{
			PCERT_ENHKEY_USAGE	pEnhKeyUsage = (PCERT_ENHKEY_USAGE)
					::LocalAlloc (LPTR, cbEnhKeyUsage);
			if ( pEnhKeyUsage )
			{
				if ( ::CryptDecodeObject (CRYPT_ASN_ENCODING, 
						szOID_ENHANCED_KEY_USAGE, 
						m_pCertExtension->Value.pbData,
						m_pCertExtension->Value.cbData,
						0, pEnhKeyUsage, &cbEnhKeyUsage) )
				{
					CString	usageName;

					for (DWORD dwIndex = 0; 
							dwIndex < pEnhKeyUsage->cUsageIdentifier; 
							dwIndex++)
					{
						if ( MyGetOIDInfoA (usageName, 
								pEnhKeyUsage->rgpszUsageIdentifier[dwIndex]) )
						{
                            int nIndex = m_EKUList.AddString (usageName);
                            if ( nIndex >= 0 )
                            {
                                m_EKUList.SetCheck (nIndex, BST_CHECKED);
                                m_EKUList.SetItemDataPtr (nIndex, 
                                        pEnhKeyUsage->rgpszUsageIdentifier[dwIndex]);
                            }
						}
					}
				}
				else
                {
                    DWORD   dwErr = GetLastError ();
                    _TRACE (0, L"CryptDecodeObject (szOID_ENHANCED_KEY_USAGE) failed: 0x%x\n", dwErr);
			        DisplaySystemError (NULL, dwErr);
                }
				::LocalFree (pEnhKeyUsage);
			}
		}
		else
        {
            DWORD   dwErr = GetLastError ();
            _TRACE (0, L"CryptDecodeObject (szOID_ENHANCED_KEY_USAGE) failed: 0x%x\n", dwErr);
			DisplaySystemError (NULL, dwErr);
        }
	}
	
    if ( 1 == m_rCertTemplate.GetType () )
    {
        int nCnt = m_EKUList.GetCount ();
        for (int nIndex = 0; nIndex < nCnt; nIndex++)
            m_EKUList.Enable (nIndex, FALSE);

        GetDlgItem (IDC_NEW_EKU)->EnableWindow (FALSE);
    }
    _TRACE (-1, L"Leaving CExtendedKeyUsagePropertyPage::OnInitDialog ()\n");
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\helpids.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       helpids.h
//
//  Contents:   Help Identifiers for the entire UI project
//
//----------------------------------------------------------------------------
#ifndef __CERTTMPL_HELPIDS_H
#define __CERTTMPL_HELPIDS_H

// IDD_NEW_APPLICATION_OID
#define IDH_NEW_APPLICATION_OID_NAME    1500
#define IDH_NEW_APPLICATION_OID_VALUE   1501

// IDD_NEW_ISSUANCE_OID
#define IDH_NEW_ISSUANCE_OID_NAME    1505
#define IDH_NEW_ISSUANCE_OID_VALUE   1506
#define IDH_CPS_EDIT                 1507

// IDD_ADD_APPROVAL
#define IDH_APPROVAL_LIST   1510

// IDD_BASIC_CONSTRAINTS
#define IDH_BASIC_CONSTRAINTS_CRITICAL  1520
#define IDH_ONLY_ISSUE_END_ENTITIES     1521

// IDD_KEY_USAGE
#define IDH_KEY_USAGE_CRITICAL          1530
#define IDH_CHECK_DIGITAL_SIGNATURE     1531
#define IDH_CHECK_NON_REPUDIATION       1532
#define IDH_CHECK_CERT_SIGNING          1533
#define IDH_CRL_SIGNING                 1534
#define IDH_CHECK_KEY_AGREEMENT         1535
#define IDH_CHECK_KEY_ENCIPHERMENT      1536
#define IDH_CHECK_DATA_ENCIPHERMENT     1537

// IDD_POLICY
#define IDH_POLICY_CRITICAL             1550
#define IDH_POLICIES_LIST               1551
#define IDH_ADD_POLICY                  1552
#define IDH_REMOVE_POLICY               1553
#define IDH_EDIT_POLICY                 1554

// IDD_SELECT_OIDS
#define IDH_OID_LIST                    1560
#define IDH_NEW_OID                     1561

// IDD_SELECT_TEMPLATE
#define IDH_TEMPLATE_LIST               1570
#define IDH_TEMPLATE_PROPERTIES         1571

// IDD_TEMPLATE_EXTENSIONS
#define IDH_EXTENSION_LIST              1580
#define IDH_SHOW_DETAILS                1581
#define IDH_EXTENSION_DESCRIPTION       1582

// IDD_TEMPLATE_GENERAL
#define IDH_DISPLAY_NAME                1600
#define IDH_TEMPLATE_NAME               1601
#define IDH_VALIDITY_EDIT               1602
#define IDH_VALIDITY_UNITS              1603
#define IDH_RENEWAL_EDIT                1604
#define IDH_RENEWAL_UNITS               1605
#define IDH_PUBLISH_TO_AD               1606
#define IDH_TEMPLATE_VERSION            1607
#define IDH_USE_AD_CERT_FOR_REENROLLMENT 1608

// IDD_TEMPLATE_V1_REQUEST
#define IDH_V1_PURPOSE_COMBO            1610
#define IDH_V1_EXPORT_PRIVATE_KEY       1611
#define IDH_V1_CSP_LIST                 1612

// IDD_TEMPLATE_V2_REQUEST
#define IDH_V2_PURPOSE_COMBO            1620
#define IDH_V2_ARCHIVE_KEY_CHECK        1621
#define IDH_V2_INCLUDE_SYMMETRIC_ALGORITHMS_CHECK  1622
#define IDH_V2_MINIMUM_KEYSIZE_VALUE    1623
#define IDH_V2_EXPORT_PRIVATE_KEY       1624
#define IDH_V2_DELETE_PERMANENTLY       1710
#define IDH_V2_ENROLL_WITHOUT_INPUT     1626
#define IDH_V2_ENROLL_PROMPT_USER       1627
#define IDH_V2_ENROLL_PROMPT_USER_REQUIRE_IF_PRIVATE_KEY    1628
#define IDH_V2_CSPS                     1629

// IDD_CSP_SELECTION
#define IDH_USE_ANY_CSP                 1700          
#define IDH_USE_SELECTED_CSPS           1701
#define IDH_V2_CSP_LIST                 1625

// IDD_TEMPLATE_V1_SUBJECT_NAME
#define IDH_REQUIRE_SUBJECT             1630
#define IDH_SUBJECT_AND_BUILD_SUBJECT_BY_CA 1631
#define IDH_EMAIL_NAME                  1633
#define IDH_SUBJECT_MUST_BE_MACHINE     1634
#define IDH_SUBJECT_MUST_BE_USER        1635

// IDD_TEMPLATE_V2_AUTHENTICATION
#define IDH_ISSUANCE_POLICIES           1640
#define IDH_ADD_APPROVAL                1641
#define IDH_REMOVE_APPROVAL             1642
#define IDH_NUM_SIG_REQUIRED_EDIT       1643
#define IDH_REENROLLMENT_REQUIRES_VALID_CERT    1644
#define IDH_REENROLLMENT_SAME_AS_ENROLLMENT     1645
#define IDH_NUM_SIG_REQUIRED_CHECK      1646
#define IDH_PEND_ALL_REQUESTS           1647
#define IDH_POLICY_TYPES                1648
#define IDH_APPLICATION_POLICIES        1649

// IDD_TEMPLATE_V2_SUBJECT_NAME
#define IDH_SUBJECT_NAME_SUPPLIED_IN_REQUEST    1650
#define IDH_SUBJECT_NAME_BUILT_BY_CA    1651
#define IDH_SUBJECT_NAME_NAME_LABEL     1652
#define IDH_SUBJECT_NAME_NAME_COMBO     1653
#define IDH_EMAIL_IN_SUB                1654
#define IDH_EMAIL_IN_ALT                1655
#define IDH_DNS_NAME                    1656
#define IDH_UPN                         1657
#define IDH_SPN                         1658

// IDD_TEMPLATE_V2_SUPERCEDES
#define IDH_SUPERCEDED_TEMPLATES_LIST   1680
#define IDH_ADD_SUPERCEDED_TEMPLATE     1681
#define IDH_REMOVE_SUPERCEDED_TEMPLATE  1682

// IDD_VIEW_OIDS
#define IDH_VIEW_OIDS_OID_LIST          1690
#define IDH_COPY_OID                    1691

#endif // __CERTTMPL_HELPIDS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\helppropertypage.cpp ===
// HelpPropertyPage.cpp : implementation file
//

#include "stdafx.h"
#include "HelpPropertyPage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CHelpPropertyPage property page


CHelpPropertyPage::CHelpPropertyPage(UINT uIDD) : 
    CAutoDeletePropPage(uIDD),
    m_hWndWhatsThis (0)
{
	//{{AFX_DATA_INIT(CHelpPropertyPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CHelpPropertyPage::~CHelpPropertyPage()
{
}

void CHelpPropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CAutoDeletePropPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CHelpPropertyPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CHelpPropertyPage, CAutoDeletePropPage)
	//{{AFX_MSG_MAP(CHelpPropertyPage)
	ON_WM_CONTEXTMENU()
	//}}AFX_MSG_MAP
    ON_MESSAGE(WM_HELP, OnHelp)
    ON_COMMAND(IDM_WHATS_THIS, OnWhatsThis)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHelpPropertyPage message handlers
void CHelpPropertyPage::OnWhatsThis()
{
    _TRACE (1, L"Entering CHelpPropertyPage::OnWhatsThis\n");
    // Display context help for a control
    if ( m_hWndWhatsThis )
    {
        DoContextHelp (m_hWndWhatsThis);
    }
    _TRACE (-1, L"Leaving CHelpPropertyPage::OnWhatsThis\n");
}

BOOL CHelpPropertyPage::OnHelp(WPARAM /*wParam*/, LPARAM lParam)
{
    _TRACE (1, L"Entering CHelpPropertyPage::OnHelp\n");
   
    const LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
    if (pHelpInfo && pHelpInfo->iContextType == HELPINFO_WINDOW)
    {
        // Display context help for a control
        DoContextHelp ((HWND) pHelpInfo->hItemHandle);
    }

    _TRACE (-1, L"Leaving CHelpPropertyPage::OnHelp\n");
    return TRUE;
}

void CHelpPropertyPage::DoContextHelp (HWND /*hWndControl*/)
{
}

void CHelpPropertyPage::OnContextMenu(CWnd* /*pWnd*/, CPoint point) 
{
    // point is in screen coordinates
    _TRACE (1, L"Entering CHelpPropertyPage::OnContextMenu\n");
	CMenu bar;
	if ( bar.LoadMenu(IDR_WHATS_THIS_CONTEXT_MENU1) )
	{
		CMenu& popup = *bar.GetSubMenu (0);
		ASSERT(popup.m_hMenu);

		if ( popup.TrackPopupMenu (TPM_RIGHTBUTTON | TPM_LEFTBUTTON,
			    point.x,    // in screen coordinates
				point.y,    // in screen coordinates
			    this) ) // route commands through main window
		{
			m_hWndWhatsThis = 0;
			ScreenToClient (&point);
			CWnd* pChild = ChildWindowFromPoint (
					point,  // in client coordinates
					CWP_SKIPINVISIBLE | CWP_SKIPTRANSPARENT);
			if ( pChild )
				m_hWndWhatsThis = pChild->m_hWnd;
	    }
	}

    _TRACE (-1, L"Leaving CHelpPropertyPage::OnContextMenu\n");
}


/////////////////////////////////////////////////////////////////////////////
// CHelpDialog property page


CHelpDialog::CHelpDialog(UINT uIDD, CWnd* pParentWnd) : 
    CDialog(uIDD, pParentWnd),
    m_hWndWhatsThis (0)
{
	//{{AFX_DATA_INIT(CHelpDialog)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CHelpDialog::~CHelpDialog()
{
}

void CHelpDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CHelpDialog)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CHelpDialog, CDialog)
	//{{AFX_MSG_MAP(CHelpDialog)
	ON_WM_CONTEXTMENU()
	//}}AFX_MSG_MAP
    ON_MESSAGE(WM_HELP, OnHelp)
    ON_COMMAND(IDM_WHATS_THIS, OnWhatsThis)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHelpDialog message handlers
void CHelpDialog::OnWhatsThis()
{
    _TRACE (1, L"Entering CHelpDialog::OnWhatsThis\n");
    // Display context help for a control
    if ( m_hWndWhatsThis )
    {
        DoContextHelp (m_hWndWhatsThis);
    }
    _TRACE (-1, L"Leaving CHelpDialog::OnWhatsThis\n");
}

BOOL CHelpDialog::OnHelp(WPARAM /*wParam*/, LPARAM lParam)
{
    _TRACE (1, L"Entering CHelpDialog::OnHelp\n");
   
    const LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
    if (pHelpInfo && pHelpInfo->iContextType == HELPINFO_WINDOW)
    {
        // Display context help for a control
        DoContextHelp ((HWND) pHelpInfo->hItemHandle);
    }

    _TRACE (-1, L"Leaving CHelpDialog::OnHelp\n");
    return TRUE;
}

void CHelpDialog::DoContextHelp (HWND /*hWndControl*/)
{
}

void CHelpDialog::OnContextMenu(CWnd* /*pWnd*/, CPoint point) 
{
    // point is in screen coordinates
    _TRACE (1, L"Entering CHelpDialog::OnContextMenu\n");
	CMenu bar;
	if ( bar.LoadMenu(IDR_WHATS_THIS_CONTEXT_MENU1) )
	{
		CMenu& popup = *bar.GetSubMenu (0);
		ASSERT(popup.m_hMenu);

		if ( popup.TrackPopupMenu (TPM_RIGHTBUTTON | TPM_LEFTBUTTON,
			    point.x,    // in screen coordinates
				point.y,    // in screen coordinates
			    this) ) // route commands through main window
		{
			m_hWndWhatsThis = 0;
			ScreenToClient (&point);
			CWnd* pChild = ChildWindowFromPoint (
					point,  // in client coordinates
					CWP_SKIPINVISIBLE | CWP_SKIPTRANSPARENT);
			if ( pChild )
				m_hWndWhatsThis = pChild->m_hWnd;
	    }
	}

    _TRACE (-1, L"Leaving CHelpDialog::OnContextMenu\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\helpmap.h ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       helpmap.h
//
//  Contents:   Help Identifiers mapped with control IDs for CertTmpl.DLL
//
//----------------------------------------------------------------------------
#ifndef __CERTTMPL_HELPMAP_H
#define __CERTTMPL_HELPMAP_H
#include "resource.h"

const DWORD g_aHelpIDs_IDD_NEW_APPLICATION_OID[]=
{
	IDC_NEW_APPLICATION_OID_NAME,IDH_NEW_APPLICATION_OID_NAME,
	IDC_NEW_APPLICATION_OID_VALUE,IDH_NEW_APPLICATION_OID_VALUE,
	0,0
};


const DWORD g_aHelpIDs_IDD_NEW_ISSUANCE_OID[]=
{
	IDC_NEW_ISSUANCE_OID_NAME,IDH_NEW_ISSUANCE_OID_NAME,
	IDC_NEW_ISSUANCE_OID_VALUE,IDH_NEW_ISSUANCE_OID_VALUE,
    IDC_CPS_EDIT, IDH_CPS_EDIT, 
	0,0
};

const DWORD g_aHelpIDs_IDD_ADD_APPROVAL[]=
{
    IDC_APPROVAL_LIST, IDH_APPROVAL_LIST,
    0, 0
};

const DWORD g_aHelpIDs_IDD_BASIC_CONSTRAINTS[]=
{
    IDC_BASIC_CONSTRAINTS_CRITICAL, IDH_BASIC_CONSTRAINTS_CRITICAL,
    IDC_ONLY_ISSUE_END_ENTITIES, IDH_ONLY_ISSUE_END_ENTITIES,
    0, 0
};

const DWORD g_aHelpIDs_IDD_KEY_USAGE[]=
{
    IDC_KEY_USAGE_CRITICAL, IDH_KEY_USAGE_CRITICAL,
    IDC_CHECK_DIGITAL_SIGNATURE, IDH_CHECK_DIGITAL_SIGNATURE,
    IDC_CHECK_NON_REPUDIATION, IDH_CHECK_NON_REPUDIATION,
    IDC_CHECK_CERT_SIGNING, IDH_CHECK_CERT_SIGNING,
    IDC_CRL_SIGNING, IDH_CRL_SIGNING,
    IDC_CHECK_KEY_AGREEMENT, IDH_CHECK_KEY_AGREEMENT,
    IDC_CHECK_KEY_ENCIPHERMENT, IDH_CHECK_KEY_ENCIPHERMENT,
    IDC_CHECK_DATA_ENCIPHERMENT, IDH_CHECK_DATA_ENCIPHERMENT,
    0, 0
};


const DWORD g_aHelpIDs_IDD_POLICY[]=
{
    IDC_POLICY_CRITICAL, IDH_POLICY_CRITICAL,
    IDC_POLICIES_LIST, IDH_POLICIES_LIST,
    IDC_ADD_POLICY, IDH_ADD_POLICY,
    IDC_REMOVE_POLICY, IDH_REMOVE_POLICY,
    IDC_EDIT_POLICY, IDH_EDIT_POLICY,
    0, 0
};


const DWORD g_aHelpIDs_IDD_SELECT_OIDS[]=
{
    IDC_OID_LIST, IDH_OID_LIST,
    IDC_NEW_OID, IDH_NEW_OID,
    0, 0
};


const DWORD g_aHelpIDs_IDD_SELECT_TEMPLATE[]=
{
    IDC_TEMPLATE_LIST, IDH_TEMPLATE_LIST,
    IDC_TEMPLATE_PROPERTIES, IDH_TEMPLATE_PROPERTIES,
    0, 0
};


const DWORD g_aHelpIDs_IDD_TEMPLATE_EXTENSIONS[]=
{
    IDC_EXTENSION_LIST, IDH_EXTENSION_LIST,
    IDC_SHOW_DETAILS, IDH_SHOW_DETAILS,
    IDC_EXTENSION_DESCRIPTION, IDH_EXTENSION_DESCRIPTION,
    0, 0
};


const DWORD g_aHelpIDs_IDD_TEMPLATE_GENERAL[]=
{
    IDC_DISPLAY_NAME, IDH_DISPLAY_NAME,
    IDC_TEMPLATE_NAME, IDH_TEMPLATE_NAME,
    IDC_VALIDITY_EDIT, IDH_VALIDITY_EDIT,
    IDC_VALIDITY_UNITS, IDH_VALIDITY_UNITS, 
    IDC_RENEWAL_EDIT, IDH_RENEWAL_EDIT,
    IDC_RENEWAL_UNITS, IDH_RENEWAL_UNITS, 
    IDC_PUBLISH_TO_AD, IDH_PUBLISH_TO_AD,
    IDC_TEMPLATE_VERSION, IDH_TEMPLATE_VERSION,
    IDC_USE_AD_CERT_FOR_REENROLLMENT, IDH_USE_AD_CERT_FOR_REENROLLMENT,
    0, 0
};


const DWORD g_aHelpIDs_IDD_TEMPLATE_V1_REQUEST[]=
{
    IDC_PURPOSE_COMBO, IDH_V1_PURPOSE_COMBO,
    IDC_EXPORT_PRIVATE_KEY, IDH_V1_EXPORT_PRIVATE_KEY,
    IDC_CSP_LIST, IDH_V1_CSP_LIST, 
    0, 0
};

const DWORD g_aHelpIDs_IDD_TEMPLATE_V2_REQUEST[]=
{
    IDC_PURPOSE_COMBO, IDH_V2_PURPOSE_COMBO,
    IDC_ARCHIVE_KEY_CHECK, IDH_V2_ARCHIVE_KEY_CHECK,
    IDC_INCLUDE_SYMMETRIC_ALGORITHMS_CHECK, IDH_V2_INCLUDE_SYMMETRIC_ALGORITHMS_CHECK,
    IDC_MINIMUM_KEYSIZE_VALUE, IDH_V2_MINIMUM_KEYSIZE_VALUE, 
    IDC_EXPORT_PRIVATE_KEY, IDH_V2_EXPORT_PRIVATE_KEY,
	IDC_DELETE_PERMANENTLY, IDH_V2_DELETE_PERMANENTLY,
    IDC_ENROLL_WITHOUT_INPUT, IDH_V2_ENROLL_WITHOUT_INPUT,
    IDC_ENROLL_PROMPT_USER, IDH_V2_ENROLL_PROMPT_USER,
    IDC_ENROLL_PROMPT_USER_REQUIRE_IF_PRIVATE_KEY, IDH_V2_ENROLL_PROMPT_USER_REQUIRE_IF_PRIVATE_KEY ,
    IDC_CSPS, IDH_V2_CSPS,
    0, 0
};

const DWORD g_aHelpIDs_IDD_CSP_SELECTION[]=
{
    IDC_USE_ANY_CSP, IDH_USE_ANY_CSP,
    IDC_USE_SELECTED_CSPS, IDH_USE_SELECTED_CSPS,
    IDC_CSP_LIST, IDH_V2_CSP_LIST, 
    0, 0
};

const DWORD g_aHelpIDs_IDD_TEMPLATE_V1_SUBJECT_NAME[]=
{
    IDC_REQUIRE_SUBJECT, IDH_REQUIRE_SUBJECT,
    IDC_SUBJECT_AND_BUILD_SUBJECT_BY_CA, IDH_SUBJECT_AND_BUILD_SUBJECT_BY_CA,
    IDC_EMAIL_NAME, IDH_EMAIL_NAME, 
    IDC_SUBJECT_MUST_BE_MACHINE, IDH_SUBJECT_MUST_BE_MACHINE,
    IDC_SUBJECT_MUST_BE_USER, IDH_SUBJECT_MUST_BE_USER, 
    0, 0
};


const DWORD g_aHelpIDs_IDD_TEMPLATE_V2_AUTHENTICATION[]=
{
    IDC_ISSUANCE_POLICIES, IDH_ISSUANCE_POLICIES,
    IDC_ADD_APPROVAL, IDH_ADD_APPROVAL,
    IDC_REMOVE_APPROVAL, IDH_REMOVE_APPROVAL,
    IDC_NUM_SIG_REQUIRED_EDIT, IDH_NUM_SIG_REQUIRED_EDIT, 
    IDC_REENROLLMENT_REQUIRES_VALID_CERT, IDH_REENROLLMENT_REQUIRES_VALID_CERT,
    IDC_REENROLLMENT_SAME_AS_ENROLLMENT, IDH_REENROLLMENT_SAME_AS_ENROLLMENT,
    IDC_NUM_SIG_REQUIRED_CHECK, IDH_NUM_SIG_REQUIRED_CHECK,
    IDC_PEND_ALL_REQUESTS, IDH_PEND_ALL_REQUESTS,
    IDC_POLICY_TYPES, IDH_POLICY_TYPES,
    IDC_APPLICATION_POLICIES, IDH_APPLICATION_POLICIES,
    0, 0
};


const DWORD g_aHelpIDs_IDD_TEMPLATE_V2_SUBJECT_NAME[]=
{
    IDC_SUBJECT_NAME_SUPPLIED_IN_REQUEST, IDH_SUBJECT_NAME_SUPPLIED_IN_REQUEST,
    IDC_SUBJECT_NAME_BUILT_BY_CA, IDH_SUBJECT_NAME_BUILT_BY_CA,
    IDC_SUBJECT_NAME_NAME_LABEL, IDH_SUBJECT_NAME_NAME_LABEL,
    IDC_SUBJECT_NAME_NAME_COMBO, IDH_SUBJECT_NAME_NAME_COMBO, 
    IDC_EMAIL_IN_SUB, IDH_EMAIL_IN_SUB,
    IDC_EMAIL_IN_ALT, IDH_EMAIL_IN_ALT,
    IDC_DNS_NAME, IDH_DNS_NAME,
    IDC_UPN, IDH_UPN,
    IDC_SPN, IDH_SPN,
    0, 0
};


const DWORD g_aHelpIDs_IDD_TEMPLATE_V2_SUPERCEDES[]=
{
    IDC_SUPERCEDED_TEMPLATES_LIST, IDH_SUPERCEDED_TEMPLATES_LIST,
    IDC_ADD_SUPERCEDED_TEMPLATE, IDH_ADD_SUPERCEDED_TEMPLATE,
    IDC_REMOVE_SUPERCEDED_TEMPLATE, IDH_REMOVE_SUPERCEDED_TEMPLATE,
    0, 0
};

const DWORD g_aHelpIDs_IDD_VIEW_OIDS[]=
{
    IDC_OID_LIST, IDH_VIEW_OIDS_OID_LIST,
    IDC_COPY_OID, IDH_COPY_OID,
    0, 0
};

#endif // __CERTTMPL_HELPMAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\helppropertypage.h ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       HelpPropertyPage.h
//
//  Contents:   Declaration of CHelpPropertyPage
//
//----------------------------------------------------------------------------
#if !defined(AFX_HELPPROPERTYPAGE_H__C75F826D_B054_45CC_B440_34F44645FF90__INCLUDED_)
#define AFX_HELPPROPERTYPAGE_H__C75F826D_B054_45CC_B440_34F44645FF90__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// HelpPropertyPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CHelpPropertyPage dialog

class CHelpPropertyPage : public CAutoDeletePropPage
{
// Construction
public:
	CHelpPropertyPage(UINT uIDD);
	~CHelpPropertyPage();

// Dialog Data
	//{{AFX_DATA(CHelpPropertyPage)
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CHelpPropertyPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CHelpPropertyPage)
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    virtual void DoContextHelp (HWND hWndControl);
	afx_msg void OnWhatsThis();
    afx_msg BOOL OnHelp(WPARAM wParam, LPARAM lParam);

private:
    HWND            m_hWndWhatsThis;
};


/////////////////////////////////////////////////////////////////////////////
// CHelpPropertyPage dialog

class CHelpDialog : public CDialog
{
// Construction
public:
	CHelpDialog(UINT uIDD, CWnd* pParentWnd);
	~CHelpDialog();

// Dialog Data
	//{{AFX_DATA(CHelpDialog)
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CHelpDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CHelpDialog)
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    virtual void DoContextHelp (HWND hWndControl);
	afx_msg void OnWhatsThis();
    afx_msg BOOL OnHelp(WPARAM wParam, LPARAM lParam);

private:
    HWND            m_hWndWhatsThis;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SAFERENTRYCERTIFICATEPROPERTYPAGE_H__C75F826D_B054_45CC_B440_34F44645FF90__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\keyusagedlg.cpp ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       KeyUsageDlg.cpp
//
//  Contents:   Implementation of CKeyUsageDlg
//
//----------------------------------------------------------------------------
// KeyUsageDlg.cpp : implementation file
//

#include "stdafx.h"
#include "KeyUsageDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define WM_INITIALIZATION_COMPLETE  WM_APP + 2002

/////////////////////////////////////////////////////////////////////////////
// CKeyUsageDlg property page

CKeyUsageDlg::CKeyUsageDlg(CWnd* pParent, CCertTemplate& rCertTemplate, PCERT_EXTENSION pCertExtension) : 
    CHelpDialog(CKeyUsageDlg::IDD, pParent),
    m_rCertTemplate (rCertTemplate),
    m_pCertExtension (pCertExtension),
    m_bModified (false),
    m_pKeyUsage (0),
    m_cbKeyUsage (0),
    m_bInitializationComplete (false)
{
	//{{AFX_DATA_INIT(CKeyUsageDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
    m_rCertTemplate.AddRef ();
}

CKeyUsageDlg::~CKeyUsageDlg()
{
    if ( m_pKeyUsage )
        LocalFree (m_pKeyUsage);
    m_rCertTemplate.Release ();
}

void CKeyUsageDlg::DoDataExchange(CDataExchange* pDX)
{
	CHelpDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CKeyUsageDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CKeyUsageDlg, CHelpDialog)
	//{{AFX_MSG_MAP(CKeyUsageDlg)
	ON_BN_CLICKED(IDC_CHECK_CERT_SIGNING, OnCheckCertSigning)
	ON_BN_CLICKED(IDC_CHECK_DATA_ENCIPHERMENT, OnCheckDataEncipherment)
	ON_BN_CLICKED(IDC_CHECK_DIGITAL_SIGNATURE, OnCheckDigitalSignature)
	ON_BN_CLICKED(IDC_CHECK_KEY_AGREEMENT, OnCheckKeyAgreement)
	ON_BN_CLICKED(IDC_CHECK_KEY_ENCIPHERMENT, OnCheckKeyEncipherment)
	ON_BN_CLICKED(IDC_CHECK_NON_REPUDIATION, OnCheckNonRepudiation)
	ON_BN_CLICKED(IDC_CRL_SIGNING, OnCrlSigning)
	ON_BN_CLICKED(IDC_KEY_USAGE_CRITICAL, OnKeyUsageCritical)
	//}}AFX_MSG_MAP
    ON_MESSAGE (WM_INITIALIZATION_COMPLETE, OnInitializationComplete)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CKeyUsageDlg message handlers

BOOL CKeyUsageDlg::OnInitDialog() 
{
    _TRACE (1, L"Entering CKeyUsageDlg::OnInitDialog\n");
	CHelpDialog::OnInitDialog();
	

	ASSERT (m_pCertExtension);
	if ( m_pCertExtension )
	{

        if ( m_pCertExtension->fCritical )
            SendDlgItemMessage (IDC_KEY_USAGE_CRITICAL, BM_SETCHECK, BST_CHECKED);

		if ( ::CryptDecodeObject(CRYPT_ASN_ENCODING, 
				szOID_KEY_USAGE, 
				m_pCertExtension->Value.pbData,
				m_pCertExtension->Value.cbData,
				0, NULL, &m_cbKeyUsage) )
		{
			m_pKeyUsage = (CRYPT_BIT_BLOB*)
					::LocalAlloc (LPTR, m_cbKeyUsage);
			if ( m_pKeyUsage )
			{
				if ( ::CryptDecodeObject (CRYPT_ASN_ENCODING, 
						szOID_KEY_USAGE, 
						m_pCertExtension->Value.pbData,
						m_pCertExtension->Value.cbData,
						0, m_pKeyUsage, &m_cbKeyUsage) )
				{
                    if (m_pKeyUsage->cbData >= 1)
                    {
                        if ( m_pKeyUsage->pbData[0] & CERT_DIGITAL_SIGNATURE_KEY_USAGE )
                            SendDlgItemMessage (IDC_CHECK_DIGITAL_SIGNATURE, BM_SETCHECK, BST_CHECKED);

                        if ( m_pKeyUsage->pbData[0] & CERT_NON_REPUDIATION_KEY_USAGE )
                            SendDlgItemMessage (IDC_CHECK_NON_REPUDIATION, BM_SETCHECK, BST_CHECKED);

                        if ( m_pKeyUsage->pbData[0] & CERT_KEY_ENCIPHERMENT_KEY_USAGE )
                            SendDlgItemMessage (IDC_CHECK_KEY_ENCIPHERMENT, BM_SETCHECK, BST_CHECKED);

                        if ( m_pKeyUsage->pbData[0] & CERT_DATA_ENCIPHERMENT_KEY_USAGE )
                            SendDlgItemMessage (IDC_CHECK_DATA_ENCIPHERMENT, BM_SETCHECK, BST_CHECKED);

                        if ( m_pKeyUsage->pbData[0] & CERT_KEY_AGREEMENT_KEY_USAGE )
                            SendDlgItemMessage (IDC_CHECK_KEY_AGREEMENT, BM_SETCHECK, BST_CHECKED);

                        if ( m_pKeyUsage->pbData[0] & CERT_KEY_CERT_SIGN_KEY_USAGE )
                            SendDlgItemMessage (IDC_CHECK_CERT_SIGNING, BM_SETCHECK, BST_CHECKED);

                        if ( m_pKeyUsage->pbData[0] & CERT_OFFLINE_CRL_SIGN_KEY_USAGE )
                            SendDlgItemMessage (IDC_CRL_SIGNING, BM_SETCHECK, BST_CHECKED);
                    }

                    if (m_pKeyUsage->cbData >= 2)
                    {
//                        if ( m_pKeyUsage->pbData[1] & CERT_DECIPHER_ONLY_KEY_USAGE )
//                            SendDlgItemMessage (IDC_CHECK_DECIPHERMENT_ONLY, BM_SETCHECK, BST_CHECKED);
                    }
				}
				else
                {
                    DWORD   dwErr = GetLastError ();
                    _TRACE (0, L"CryptDecodeObject (szOID_KEY_USAGE) failed: 0x%x\n", dwErr);
			        DisplaySystemError (NULL, dwErr);
                }
			}
		}
		else
        {
            DWORD   dwErr = GetLastError ();
            _TRACE (0, L"CryptDecodeObject (szOID_KEY_USAGE) failed: 0x%x\n", dwErr);
			DisplaySystemError (NULL, dwErr);
        }
	}

	if ( 1 == m_rCertTemplate.GetType () )  // type 1 is Win2K templates
    {
        GetDlgItem (IDC_CHECK_DIGITAL_SIGNATURE)->EnableWindow (FALSE);
        GetDlgItem (IDC_KEY_USAGE_CRITICAL)->EnableWindow (FALSE);
        GetDlgItem (IDC_CHECK_NON_REPUDIATION)->EnableWindow (FALSE);
        GetDlgItem (IDC_CHECK_KEY_ENCIPHERMENT)->EnableWindow (FALSE);
        GetDlgItem (IDC_CHECK_DATA_ENCIPHERMENT)->EnableWindow (FALSE);
        GetDlgItem (IDC_CHECK_KEY_AGREEMENT)->EnableWindow (FALSE);
        GetDlgItem (IDC_CHECK_CERT_SIGNING)->EnableWindow (FALSE);
    }
	
    EnableControls ();

    PostMessage (WM_INITIALIZATION_COMPLETE);

    _TRACE (-1, L"Leaving CKeyUsageDlg::OnInitDialog\n");
    return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CKeyUsageDlg::OnCheckCertSigning() 
{
    m_bModified = true;
    EnableControls ();
}

void CKeyUsageDlg::OnCheckDataEncipherment() 
{
    m_bModified = true;
    EnableControls ();
}

void CKeyUsageDlg::OnCheckDigitalSignature() 
{
    m_bModified = true;
    EnableControls ();
}

void CKeyUsageDlg::OnCheckKeyAgreement() 
{
    if ( m_bInitializationComplete )
    {
        SendDlgItemMessage (IDC_CHECK_DATA_ENCIPHERMENT, BM_SETCHECK, BST_UNCHECKED);
    
        m_bModified = true;
        EnableControls ();
    }
}

void CKeyUsageDlg::OnCheckKeyEncipherment() 
{
    m_bModified = true;
    EnableControls ();
}

void CKeyUsageDlg::OnCheckNonRepudiation() 
{
    m_bModified = true;
    EnableControls ();
}

void CKeyUsageDlg::OnCrlSigning() 
{
    m_bModified = true;
    EnableControls ();
}

void CKeyUsageDlg::EnableControls()
{
    // NTRAID# 471748 Certtmpl: V2 Template Purpose is set to: "Signature and 
    // Smart Card Logon" -- Entire KeyUsage page should be inactive
    bool bHasDigitalSignature = false;
    bool bHasOnlyDigitalSignature = false;

    m_rCertTemplate.GetDigitalSignature (bHasDigitalSignature,
            &bHasOnlyDigitalSignature);

    if ( 1 == m_rCertTemplate.GetType () ||     // type 1 is Win2K templates
            (bHasOnlyDigitalSignature && 
            bHasDigitalSignature && m_rCertTemplate.HasEncryptionSignature ()) )
    {
        GetDlgItem (IDC_SIGNATURE_OPTIONS)->EnableWindow (FALSE);
        GetDlgItem (IDC_CHECK_DIGITAL_SIGNATURE)->EnableWindow (1 != m_rCertTemplate.GetType ());
        GetDlgItem (IDC_CHECK_NON_REPUDIATION)->EnableWindow (FALSE);
        GetDlgItem (IDC_CHECK_CERT_SIGNING)->EnableWindow (FALSE);
        GetDlgItem (IDC_CRL_SIGNING)->EnableWindow (FALSE);
        GetDlgItem (IDC_ENCRYPTION_OPTIONS)->EnableWindow (FALSE);
        GetDlgItem (IDC_CHECK_KEY_AGREEMENT)->EnableWindow (FALSE);
        GetDlgItem (IDC_CHECK_KEY_ENCIPHERMENT)->EnableWindow (FALSE);
        GetDlgItem (IDC_CHECK_DATA_ENCIPHERMENT)->EnableWindow (FALSE);
        GetDlgItem (IDOK)->EnableWindow (FALSE);
        GetDlgItem (IDC_KEY_USAGE_CRITICAL)->EnableWindow (FALSE);
    }
    else
    {
        bool bSubjectIsCA = m_rCertTemplate.SubjectIsCA ();
        bool bSubjectIsCrossCA = m_rCertTemplate.SubjectIsCrossCA ();
        BOOL bKeyEnc = (BST_CHECKED == SendDlgItemMessage (IDC_CHECK_KEY_ENCIPHERMENT, BM_GETCHECK));
        bool bEncryption = m_rCertTemplate.HasEncryptionSignature () && !m_rCertTemplate.ReadOnly ();
        bool bHasKeySpecSignature = m_rCertTemplate.HasKeySpecSignature () && !m_rCertTemplate.ReadOnly ();

        // Enable Signature group
        GetDlgItem (IDC_SIGNATURE_OPTIONS)->EnableWindow (bHasKeySpecSignature);
        GetDlgItem (IDC_CHECK_DIGITAL_SIGNATURE)->EnableWindow (bHasKeySpecSignature || bHasDigitalSignature);
        GetDlgItem (IDC_CHECK_NON_REPUDIATION)->EnableWindow (!bSubjectIsCA && !bSubjectIsCrossCA && bHasKeySpecSignature);
        GetDlgItem (IDC_CHECK_CERT_SIGNING)->EnableWindow (bHasKeySpecSignature && (bSubjectIsCA || bSubjectIsCrossCA));
        GetDlgItem (IDC_CRL_SIGNING)->EnableWindow (bHasKeySpecSignature && (bSubjectIsCA || bSubjectIsCrossCA));

        // Enable Encryption group
        GetDlgItem (IDC_ENCRYPTION_OPTIONS)->EnableWindow (bEncryption);
        GetDlgItem (IDC_CHECK_KEY_AGREEMENT)->EnableWindow (bEncryption);
        GetDlgItem (IDC_CHECK_KEY_ENCIPHERMENT)->EnableWindow (bEncryption);
        GetDlgItem (IDC_CHECK_DATA_ENCIPHERMENT)->EnableWindow (bKeyEnc && bEncryption);

        GetDlgItem (IDOK)->EnableWindow (m_bModified);

        GetDlgItem (IDC_KEY_USAGE_CRITICAL)->EnableWindow (!m_rCertTemplate.ReadOnly ());
    }
}

void CKeyUsageDlg::OnKeyUsageCritical() 
{
    m_bModified = true;
    EnableControls ();
}

void CKeyUsageDlg::DoContextHelp (HWND hWndControl)
{
	_TRACE(1, L"Entering CKeyUsageDlg::DoContextHelp\n");
    
	switch (::GetDlgCtrlID (hWndControl))
	{
	case IDC_SIGNATURE_OPTIONS:
    case IDC_ENCRYPTION_OPTIONS:
		break;

	default:
		// Display context help for a control
		if ( !::WinHelp (
				hWndControl,
				GetContextHelpFile (),
				HELP_WM_HELP,
				(DWORD_PTR) g_aHelpIDs_IDD_KEY_USAGE) )
		{
			_TRACE(0, L"WinHelp () failed: 0x%x\n", GetLastError ());        
		}
		break;
	}
    _TRACE(-1, L"Leaving CKeyUsageDlg::DoContextHelp\n");
}

void CKeyUsageDlg::OnOK() 
{
    if (m_pKeyUsage->cbData >= 1)
    {
        m_pKeyUsage->pbData[0] = 0;
        m_pKeyUsage->cUnusedBits = 0;

        if ( BST_CHECKED == SendDlgItemMessage (IDC_CHECK_DIGITAL_SIGNATURE, BM_GETCHECK) )
            m_pKeyUsage->pbData[0] |= CERT_DIGITAL_SIGNATURE_KEY_USAGE;

        if ( BST_CHECKED == SendDlgItemMessage (IDC_CHECK_NON_REPUDIATION, BM_GETCHECK) )
            m_pKeyUsage->pbData[0] |= CERT_NON_REPUDIATION_KEY_USAGE;

        if ( BST_CHECKED == SendDlgItemMessage (IDC_CHECK_KEY_ENCIPHERMENT, BM_GETCHECK) )
            m_pKeyUsage->pbData[0] |= CERT_KEY_ENCIPHERMENT_KEY_USAGE;

        if ( BST_CHECKED == SendDlgItemMessage (IDC_CHECK_DATA_ENCIPHERMENT, BM_GETCHECK) )
            m_pKeyUsage->pbData[0] |= CERT_DATA_ENCIPHERMENT_KEY_USAGE;

        if ( BST_CHECKED == SendDlgItemMessage (IDC_CHECK_KEY_AGREEMENT, BM_GETCHECK) )
            m_pKeyUsage->pbData[0] |= CERT_KEY_AGREEMENT_KEY_USAGE;

        if ( BST_CHECKED == SendDlgItemMessage (IDC_CHECK_CERT_SIGNING, BM_GETCHECK) )
            m_pKeyUsage->pbData[0] |= CERT_KEY_CERT_SIGN_KEY_USAGE;

        if ( BST_CHECKED == SendDlgItemMessage (IDC_CRL_SIGNING, BM_GETCHECK) )
            m_pKeyUsage->pbData[0] |= CERT_OFFLINE_CRL_SIGN_KEY_USAGE;
    }

    bool    bCritical = BST_CHECKED == SendDlgItemMessage (
                IDC_KEY_USAGE_CRITICAL, BM_GETCHECK);
    HRESULT hr = m_rCertTemplate.SetKeyUsage (m_pKeyUsage, bCritical);
    if ( FAILED (hr) )
        return;
	CHelpDialog::OnOK();
}

LRESULT CKeyUsageDlg::OnInitializationComplete (WPARAM, LPARAM)
{
    m_bInitializationComplete = true;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\newapplicationoiddlg.cpp ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2002
//
//  File:       NewApplicationOIDDlg.cpp
//
//  Contents:   Implementation of CNewApplicationOIDDlg
//
//----------------------------------------------------------------------------
// NewApplicationOIDDlg.cpp : implementation file
//

#include "stdafx.h"
#include "NewApplicationOIDDlg.h"
#include "PolicyOID.h"

extern POLICY_OID_LIST      g_policyOIDList;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNewApplicationOIDDlg dialog


CNewApplicationOIDDlg::CNewApplicationOIDDlg(CWnd* pParent)
    : CHelpDialog(CNewApplicationOIDDlg::IDD, pParent),
    m_bEdit (false),
    m_bDirty (false)
{
    //{{AFX_DATA_INIT(CNewApplicationOIDDlg)
    m_oidFriendlyName = _T("");
    m_oidValue = _T("");
    //}}AFX_DATA_INIT
}


CNewApplicationOIDDlg::CNewApplicationOIDDlg(CWnd* pParent, 
        const CString& szDisplayName,
        const CString& szOID)
    : CHelpDialog(CNewApplicationOIDDlg::IDD, pParent),
    m_bEdit (true),
    m_bDirty (false),
    m_originalOidFriendlyName (szDisplayName),
    m_oidFriendlyName (szDisplayName),
    m_oidValue (szOID)
{
}


void CNewApplicationOIDDlg::DoDataExchange(CDataExchange* pDX)
{
    CHelpDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CNewApplicationOIDDlg)
    DDX_Control(pDX, IDC_NEW_APPLICATION_OID_VALUE, m_oidValueEdit);
    DDX_Text(pDX, IDC_NEW_APPLICATION_OID_NAME, m_oidFriendlyName);
	DDV_MaxChars(pDX, m_oidFriendlyName, MAX_TEMPLATE_NAME_LEN);
    DDX_Text(pDX, IDC_NEW_APPLICATION_OID_VALUE, m_oidValue);
    DDV_MaxChars(pDX, m_oidValue, MAX_OID_LEN);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNewApplicationOIDDlg, CHelpDialog)
    //{{AFX_MSG_MAP(CNewApplicationOIDDlg)
    ON_EN_CHANGE(IDC_NEW_APPLICATION_OID_NAME, OnChangeNewOidName)
    ON_EN_CHANGE(IDC_NEW_APPLICATION_OID_VALUE, OnChangeNewOidValue)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewApplicationOIDDlg message handlers

BOOL CNewApplicationOIDDlg::OnInitDialog() 
{
    _TRACE (1, L"Entering CNewApplicationOIDDlg::OnInitDialog\n");
    CHelpDialog::OnInitDialog();
    
        
    PWSTR   pwszOID = 0;
    if ( m_bEdit )
    {
        CString text;

        VERIFY (text.LoadString (IDS_EDIT_APPLICATION_POLICY));
        SetWindowText (text);
        m_oidValueEdit.SetReadOnly ();

        VERIFY (text.LoadString (IDS_EDIT_APPLICATION_POLICY_HINT));
        SetDlgItemText (IDC_NEW_APPLICATION_OID_HINT, text);
    }
    else
    {
        HRESULT hr = CAOIDCreateNew
                (CERT_OID_TYPE_APPLICATION_POLICY,
                0,
                &pwszOID);
        _ASSERT (SUCCEEDED(hr));
        if ( SUCCEEDED (hr) )
        {
            m_szOriginalOID = pwszOID;
            m_oidValue = pwszOID;
            LocalFree (pwszOID);
        }
        else
        {
            _TRACE (0, L"CAOIDCreateNew (CERT_OID_TYPE_APPLICATION_POLICY) failed: 0x%x\n",
                    hr);
        }
    }

    UpdateData (FALSE);

    // Don't allow rename for OIDS returned by CryptoAPI
    if ( m_bEdit )
    {
        for (POSITION nextPos = g_policyOIDList.GetHeadPosition (); nextPos; )
        {
            CPolicyOID* pPolicyOID = g_policyOIDList.GetNext (nextPos);
            if ( pPolicyOID )
            {
                if ( pPolicyOID->GetOIDW () == m_oidValue )
                {
                    if ( !pPolicyOID->CanRename () )
                    {
                        GetDlgItem (IDC_NEW_APPLICATION_OID_NAME)->EnableWindow (FALSE);
                    }
                    break;
                }
            }
        }
    }

    EnableControls ();

    _TRACE (-1, L"Leaving CNewApplicationOIDDlg::OnInitDialog\n");
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CNewApplicationOIDDlg::EnableControls()
{
    UpdateData (TRUE);
    if ( m_oidFriendlyName.IsEmpty () || m_oidValue.IsEmpty () || !m_bDirty )
        GetDlgItem (IDOK)->EnableWindow (FALSE);
    else
        GetDlgItem (IDOK)->EnableWindow (TRUE);
}

void CNewApplicationOIDDlg::OnChangeNewOidName() 
{
    m_bDirty = true;
    EnableControls ();
}

void CNewApplicationOIDDlg::OnChangeNewOidValue() 
{
    m_bDirty = true;
    EnableControls ();
}

void CNewApplicationOIDDlg::OnCancel() 
{
    if ( !m_bEdit )
    {
        HRESULT hr = CAOIDDelete (m_szOriginalOID);
        _ASSERT (SUCCEEDED(hr));
        if ( FAILED (hr) )
        {
            _TRACE (0, L"CAOIDDelete (%s) failed: 0x%x\n",
                    (PCWSTR) m_szOriginalOID, hr);
        }
    }
    
    CHelpDialog::OnCancel();
}

void CNewApplicationOIDDlg::OnOK() 
{
    UpdateData (TRUE);

    int errorTypeStrID = 0;
    if ( !OIDHasValidFormat (m_oidValue, errorTypeStrID) )
    {
        CString text;
        CString caption;
        CString errorType;
        CThemeContextActivator activator;


        VERIFY (caption.LoadString (IDS_CERTTMPL));
        VERIFY (errorType.LoadString (errorTypeStrID));
        // security review 2/21/2002 BryanWal ok
        text.FormatMessage (IDS_OID_FORMAT_INVALID, m_oidValue, errorType);

        MessageBox (text, caption, MB_OK);
        GetDlgItem (IDOK)->EnableWindow (FALSE);
        m_oidValueEdit.SetFocus ();
        return;
    }

    if ( !m_bEdit && m_szOriginalOID != m_oidValue )
    {
        HRESULT hr = CAOIDDelete (m_szOriginalOID);
        _ASSERT (SUCCEEDED(hr));
        if ( SUCCEEDED (hr) )
        {
            hr = CAOIDAdd (CERT_OID_TYPE_APPLICATION_POLICY,
                    0,
                    m_oidValue);
            if ( FAILED (hr) )
            {
                CString text;
                CString caption;
                CThemeContextActivator activator;

                VERIFY (caption.LoadString (IDS_CERTTMPL));
                // security review 2/21/2002 BryanWal ok
                text.FormatMessage (IDS_OID_ALREADY_EXISTS, m_oidValue);

                MessageBox (text, caption, MB_OK);
                GetDlgItem (IDOK)->EnableWindow (FALSE);
                m_oidValueEdit.SetFocus ();
 
                _TRACE (0, L"CAOIDAdd (%s) failed: 0x%x\n",
                        (PCWSTR) m_oidValue, hr);
                return;
            }
        }
        else
        {
            _TRACE (0, L"CAOIDDelete (%s) failed: 0x%x\n",
                    (PCWSTR) m_szOriginalOID, hr);
            return;
        }
    }

    HRESULT hr = S_OK;
    // If we're editing, don't save the value if it hasn't changed
    if ( (m_bEdit && m_originalOidFriendlyName != m_oidFriendlyName) || !m_bEdit )
    {
        hr = CAOIDSetProperty (m_oidValue, CERT_OID_PROPERTY_DISPLAY_NAME,
                m_oidFriendlyName.IsEmpty () ? 0 : ((LPVOID) (LPCWSTR) m_oidFriendlyName));
        if ( SUCCEEDED (hr) )
        {
            // Update the OID list
            for (POSITION nextPos = g_policyOIDList.GetHeadPosition (); nextPos; )
            {
                CPolicyOID* pPolicyOID = g_policyOIDList.GetNext (nextPos);
                if ( pPolicyOID && 
                        pPolicyOID->IsApplicationOID () && 
                        m_oidValue == pPolicyOID->GetOIDW ())
                {
                    pPolicyOID->SetDisplayName (m_oidFriendlyName);
                }
            }
        }
        else 
        {
            CString text;
            CString caption;
            CThemeContextActivator activator;

            VERIFY (caption.LoadString (IDS_CERTTMPL));
            text.FormatMessage (IDS_CANNOT_SAVE_FRIENDLY_NAME, GetSystemMessage (hr));

            MessageBox (text, caption, MB_OK);
            GetDlgItem (IDOK)->EnableWindow (FALSE);
            GetDlgItem (IDC_NEW_APPLICATION_OID_NAME)->SetFocus ();
            _TRACE (0, L"CAOIDSetProperty (%s, CERT_OID_PROPERTY_DISPLAY_NAME, %s) failed: 0x%x\n",
                (PCWSTR) m_oidValue, (PCWSTR) m_oidFriendlyName, hr);
            return;
        }
    }

    
    CHelpDialog::OnOK();
}

void CNewApplicationOIDDlg::DoContextHelp (HWND hWndControl)
{
    _TRACE(1, L"Entering CNewApplicationOIDDlg::DoContextHelp\n");
    
    // Display context help for a control
    if ( !::WinHelp (
            hWndControl,
            GetContextHelpFile (),
            HELP_WM_HELP,
            (DWORD_PTR) g_aHelpIDs_IDD_NEW_APPLICATION_OID) )
    {
        _TRACE(0, L"WinHelp () failed: 0x%x\n", GetLastError ());        
    }
    _TRACE(-1, L"Leaving CNewApplicationOIDDlg::DoContextHelp\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\newapplicationoiddlg.h ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       NewApplicationOIDDlg.h
//
//  Contents:   Definition of CNewApplicationOIDDlg
//
//----------------------------------------------------------------------------
#if !defined(AFX_NEWAPPLICATIONOIDDLG_H__6DC0B725_094F_4960_9C8F_417BF7D4474D__INCLUDED_)
#define AFX_NEWAPPICATIONOIDDLG_H__6DC0B725_094F_4960_9C8F_417BF7D4474D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// NewApplicationOIDDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CNewApplicationOIDDlg dialog

class CNewApplicationOIDDlg : public CHelpDialog
{
// Construction
public:
	CNewApplicationOIDDlg(CWnd* pParent);   // standard constructor
    CNewApplicationOIDDlg(CWnd* pParent, 
            const CString& szDisplayName,
            const CString& szOID);
    virtual ~CNewApplicationOIDDlg () {}

// Dialog Data
	//{{AFX_DATA(CNewApplicationOIDDlg)
	enum { IDD = IDD_NEW_APPLICATION_OID };
	CEdit	m_oidValueEdit;
	CString	m_oidFriendlyName;
	CString	m_oidValue;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNewApplicationOIDDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual void DoContextHelp (HWND hWndControl);
	void EnableControls ();

	// Generated message map functions
	//{{AFX_MSG(CNewApplicationOIDDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeNewOidName();
	afx_msg void OnChangeNewOidValue();
	virtual void OnCancel();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
   	const CString m_originalOidFriendlyName;
    CString     m_szOriginalOID;
    const bool  m_bEdit;
    bool        m_bDirty;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NEWAPPLICATIONOIDDLG_H__6DC0B725_094F_4960_9C8F_417BF7D4474D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\keyusagedlg.h ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       KeyUsageDlg.h
//
//  Contents:   Definition of CKeyUsageDlg
//
//----------------------------------------------------------------------------
#if !defined(AFX_KEYUSAGEDLG_H__18ABC4AB_A46B_46A9_B1BA_888CE7C5C782__INCLUDED_)
#define AFX_KEYUSAGEDKG_H__18ABC4AB_A46B_46A9_B1BA_888CE7C5C782__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// KeyUsageDlg.h : header file
//
#include "CertTemplate.h"

/////////////////////////////////////////////////////////////////////////////
// CKeyUsageDlg dialog

class CKeyUsageDlg : public CHelpDialog
{
// Construction
public:
	CKeyUsageDlg(CWnd* pParent, CCertTemplate& rCertTemplate, PCERT_EXTENSION pCertExtension);
	~CKeyUsageDlg();

// Dialog Data
	//{{AFX_DATA(CKeyUsageDlg)
	enum { IDD = IDD_KEY_USAGE };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CKeyUsageDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual void DoContextHelp (HWND hWndControl);
	void EnableControls ();
	// Generated message map functions
	//{{AFX_MSG(CKeyUsageDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnCheckCertSigning();
	afx_msg void OnCheckDataEncipherment();
	afx_msg void OnCheckDigitalSignature();
	afx_msg void OnCheckKeyAgreement();
	afx_msg void OnCheckKeyEncipherment();
	afx_msg void OnCheckNonRepudiation();
	afx_msg void OnCrlSigning();
	afx_msg void OnKeyUsageCritical();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
    afx_msg LRESULT OnInitializationComplete (WPARAM, LPARAM);

    bool            m_bInitializationComplete;
	DWORD           m_cbKeyUsage;
	CRYPT_BIT_BLOB* m_pKeyUsage;
	bool            m_bModified;
    CCertTemplate&  m_rCertTemplate;
    PCERT_EXTENSION m_pCertExtension;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TEMPLATEKEYUSAGEDLG_H__18ABC4AB_A46B_46A9_B1BA_888CE7C5C782__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\nodetype.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001
//
//  File:       nodetype.h
//
//  Contents:   Declaration of CertTmplObjectType
//
//----------------------------------------------------------------------------

#ifndef __NODETYPE_H_INCLUDED__
#define __NODETYPE_H_INCLUDED__

// Also note that the IDS_DISPLAYNAME_* and IDS_DISPLAYNAME_*_LOCAL string resources
// must be kept in sync with these values, and in the appropriate order.
// Also global variable cookie.cpp aColumns[][] must be kept in sync.
//
typedef enum _CertTmplObjectType {
	CERTTMPL_MULTISEL = MMC_MULTI_SELECT_COOKIE,
	CERTTMPL_INVALID = -1,
	CERTTMPL_SNAPIN = 0,
    CERTTMPL_CERT_TEMPLATE,
	CERTTMPL_NUMTYPES		//must be last
} CertTmplObjectType, *PCertTmplObjectType;

inline bool IsValidObjectType (CertTmplObjectType objecttype)
{ 
	return ((objecttype >= CERTTMPL_SNAPIN && objecttype < CERTTMPL_NUMTYPES)); 
}



#endif // ~__NODETYPE_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\persist.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       Persist.cpp
//
//  Contents:   Implementation of persistence
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "compdata.h"

USE_HANDLE_MACROS("CERTTMPL(persist.cpp)")


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////
//	The _dwMagicword is the internal version number.
//	Increment this number if you make a file format change.
#define _dwMagicword	10002


/////////////////////////////////////////////////////////////////////
STDMETHODIMP CCertTmplComponentData::Load(IStream __RPC_FAR *pIStream)
{
	HRESULT hr = S_OK;;

#ifndef DONT_PERSIST
	ASSERT (pIStream);
	XSafeInterfacePtr<IStream> pIStreamSafePtr( pIStream );

	// Read the magic word from the stream
	DWORD dwMagicword;
	hr = pIStream->Read( OUT &dwMagicword, sizeof(dwMagicword), NULL );
	if ( SUCCEEDED (hr) )
	{
	    if (dwMagicword != _dwMagicword)
	    {
		    // We have a version mismatch
		    _TRACE(0, L"INFO: CCertTmplComponentData::Load() - Wrong Magicword.  You need to re-save your .msc file.\n");
		    return E_FAIL;
	    }

	    // read domain name from stream
	    DWORD dwLen = 0;
	    hr = pIStream->Read (&dwLen, 4, NULL);
	    if ( SUCCEEDED (hr) )
	    {
	        ASSERT (dwLen <= MAX_PATH * sizeof (WCHAR));

            if ( dwLen <= MAX_PATH * sizeof (WCHAR) )
            {
                try 
                {
                    // security push 2/22/2002 BryanWal ok
	                PWSTR wcszDomainName = (PWSTR) alloca (dwLen);

	                hr = pIStream->Read ((PVOID) wcszDomainName, dwLen, NULL);
	                if ( SUCCEEDED (hr) )
	                {
                        // NOTICE: ensure null-termination
                        wcszDomainName[dwLen-1] = 0;
	                    m_szManagedDomain = wcszDomainName;
	                }
                }
                catch (CException* e)
                {
                    e->Delete ();
                }
            }
            else
                hr = E_FAIL;
	    }
	}
#endif
	return hr;
}


/////////////////////////////////////////////////////////////////////
STDMETHODIMP CCertTmplComponentData::Save(IStream __RPC_FAR *pIStream, BOOL /*fSameAsLoad*/)
{
	HRESULT hr = S_OK;

#ifndef DONT_PERSIST
	ASSERT (pIStream);
	XSafeInterfacePtr<IStream> pIStreamSafePtr( pIStream );

	// Store the magic word to the stream
	DWORD dwMagicword = _dwMagicword;
	hr = pIStream->Write( IN &dwMagicword, sizeof(dwMagicword), NULL );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}

	// Persist m_szManagedDomain length and m_szManagedDomain
    // security 
    // security review 2/21/2002 BryanWal ok
    size_t dwLen = (::wcslen (m_szManagedDomain) + 1) * sizeof (WCHAR);
	ASSERT( 4 == sizeof(DWORD) );
	hr = pIStream->Write (&dwLen, 4, NULL);
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}
	hr = pIStream->Write ((PCWSTR) m_szManagedDomain, (ULONG) dwLen, NULL);
	if ( FAILED (hr) )
	{
		ASSERT (FALSE);
		return hr;
	}

#endif
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\newissuanceoiddlg.h ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       NewIssuanceOIDDlg.h
//
//  Contents:   Definition of CNewIssuanceOIDDlg
//
//----------------------------------------------------------------------------
#if !defined(AFX_NEWISSUANCEOIDDLG_H__6DC0B725_094F_4960_9C8F_417BF7D4474D__INCLUDED_)
#define AFX_NEWISSUANCEOIDDLG_H__6DC0B725_094F_4960_9C8F_417BF7D4474D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// NewIssuanceOIDDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CNewIssuanceOIDDlg dialog

class CNewIssuanceOIDDlg : public CHelpDialog
{
// Construction
public:
	CNewIssuanceOIDDlg(CWnd* pParent);   // standard constructor
    CNewIssuanceOIDDlg(CWnd* pParent, 
            const CString& szDisplayName,
            const CString& szOID,
            const CString& szCPS);
    virtual ~CNewIssuanceOIDDlg () {};

// Dialog Data
	//{{AFX_DATA(CNewIssuanceOIDDlg)
	enum { IDD = IDD_NEW_ISSUANCE_OID };
	CEdit	m_oidValueEdit;
	CRichEditCtrl	m_CPSEdit;
	CString	m_oidFriendlyName;
	CString	m_oidValue;
	CString	m_CPSValue;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNewIssuanceOIDDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    bool StartsWithHTTP (const CString& szURL) const;
	virtual void DoContextHelp (HWND hWndControl);
	void EnableControls ();

	// Generated message map functions
	//{{AFX_MSG(CNewIssuanceOIDDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeNewOidName();
	afx_msg void OnChangeNewOidValue();
	virtual void OnCancel();
	virtual void OnOK();
    afx_msg void OnClickedURL (NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnChangeCpsEdit();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	const CString m_originalCPSValue;
	const CString m_originalOidFriendlyName;
    CString     m_szOriginalOID;
    const bool  m_bEdit;
    bool        m_bDirty;
    bool        m_bInInitDialog;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NEWISSUANCEOIDDLG_H__6DC0B725_094F_4960_9C8F_417BF7D4474D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\newissuanceoiddlg.cpp ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2002.
//
//  File:       NewIssuanceOIDDlg.cpp
//
//  Contents:   Implementation of CNewIssuanceOIDDlg
//
//----------------------------------------------------------------------------
// NewIssuanceOIDDlg.cpp : implementation file
//

#include "stdafx.h"
#include <wchar.h>
#include "NewIssuanceOIDDlg.h"
#include "PolicyOID.h"

extern POLICY_OID_LIST      g_policyOIDList;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNewIssuanceOIDDlg dialog


CNewIssuanceOIDDlg::CNewIssuanceOIDDlg(CWnd* pParent)
    : CHelpDialog(CNewIssuanceOIDDlg::IDD, pParent),
    m_bEdit (false),
    m_bDirty (false),
    m_bInInitDialog (false)
{
    //{{AFX_DATA_INIT(CNewIssuanceOIDDlg)
    m_oidFriendlyName = _T("");
    m_oidValue = _T("");
    m_CPSValue = _T("");
    //}}AFX_DATA_INIT
}

CNewIssuanceOIDDlg::CNewIssuanceOIDDlg(CWnd* pParent, 
        const CString& szDisplayName,
        const CString& szOID,
        const CString& szCPS)
    : CHelpDialog(CNewIssuanceOIDDlg::IDD, pParent),
    m_bEdit (true),
    m_bDirty (false),
    m_originalOidFriendlyName (szDisplayName),
    m_oidFriendlyName (szDisplayName),
    m_oidValue (szOID),
    m_CPSValue (szCPS),
    m_originalCPSValue (szCPS)
{
}

void CNewIssuanceOIDDlg::DoDataExchange(CDataExchange* pDX)
{
    CHelpDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CNewIssuanceOIDDlg)
    DDX_Control(pDX, IDC_NEW_ISSUANCE_OID_VALUE, m_oidValueEdit);
    DDX_Control(pDX, IDC_CPS_EDIT, m_CPSEdit);
    DDX_Text(pDX, IDC_NEW_ISSUANCE_OID_NAME, m_oidFriendlyName);
    DDV_MaxChars(pDX, m_oidFriendlyName, MAX_TEMPLATE_NAME_LEN);
    DDX_Text(pDX, IDC_NEW_ISSUANCE_OID_VALUE, m_oidValue);
    DDV_MaxChars(pDX, m_oidValue, MAX_OID_LEN);
    DDX_Text(pDX, IDC_CPS_EDIT, m_CPSValue);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNewIssuanceOIDDlg, CHelpDialog)
    //{{AFX_MSG_MAP(CNewIssuanceOIDDlg)
    ON_EN_CHANGE(IDC_NEW_ISSUANCE_OID_NAME, OnChangeNewOidName)
    ON_EN_CHANGE(IDC_NEW_ISSUANCE_OID_VALUE, OnChangeNewOidValue)
    ON_NOTIFY(EN_LINK, IDC_CPS_EDIT, OnClickedURL )
    ON_EN_CHANGE(IDC_CPS_EDIT, OnChangeCpsEdit)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewIssuanceOIDDlg message handlers

BOOL CNewIssuanceOIDDlg::OnInitDialog() 
{
    _TRACE (1, L"Entering CNewIssuanceOIDDlg::OnInitDialog\n");
    m_bInInitDialog = true;
    CHelpDialog::OnInitDialog();
    
    m_CPSEdit.SendMessage (EM_AUTOURLDETECT, TRUE);
    m_CPSEdit.SetEventMask (ENM_CHANGE | ENM_LINK | ENM_UPDATE);

    // If the URL starts with "http://" or "https://", then make the URL hot.
    if ( StartsWithHTTP (m_CPSValue) )
    {
        CHARFORMAT2  charFormat2;
        ::ZeroMemory (&charFormat2, sizeof (charFormat2));
        charFormat2.cbSize = sizeof (charFormat2);
        charFormat2.dwMask = CFM_LINK;
        charFormat2.dwEffects = CFE_LINK;

        size_t cchVal = m_CPSValue.GetLength ();
        // skip the header when looking for common invalid URL characters
        size_t cchColonWhackWhack = m_CPSValue.Find (L':') + 3;
        CString szBufAfterColonWhackWhack = ((PCWSTR) m_CPSValue) + cchColonWhackWhack;
        // cchInvalidChars is relative to the substring, not the entire URL
        size_t cchInvalidChars = szBufAfterColonWhackWhack.FindOneOf (L" %<>\"#{}|\\^~[]'");
        if ( -1 != cchInvalidChars )
        {
            // add back the length of the header so that cchInvalidChars is 
            // relative to the entire URL
            cchInvalidChars += cchColonWhackWhack;
            cchVal = min (cchVal, cchInvalidChars);
        }
        m_CPSEdit.SendMessage (EM_SETSEL, 0, cchVal);
        VERIFY (0 != m_CPSEdit.SendMessage (EM_SETCHARFORMAT, SCF_SELECTION, 
                (LPARAM) &charFormat2));
    }
        


    PWSTR   pwszOID = 0;
    if ( m_bEdit )
    {
        CString text;

        VERIFY (text.LoadString (IDS_EDIT_ISSUANCE_POLICY));
        SetWindowText (text);
        m_oidValueEdit.SetReadOnly ();

        VERIFY (text.LoadString (IDS_NEW_ISSUANCE_POLICY_HINT));
        SetDlgItemText (IDC_NEW_ISSUANCE_POLICY_HINT, text);
    }
    else
    {
        HRESULT hr = CAOIDCreateNew
                (CERT_OID_TYPE_ISSUER_POLICY,
                0,
                &pwszOID);
        _ASSERT (SUCCEEDED(hr));
        if ( SUCCEEDED (hr) )
        {
            m_szOriginalOID = pwszOID;
            m_oidValue = pwszOID;
            LocalFree (pwszOID);
        }
        else
        {
            _TRACE (0, L"CAOIDCreateNew (CERT_OID_TYPE_ISSUER_POLICY) failed: 0x%x\n",
                    hr);
        }
    }


    UpdateData (FALSE);

    // Don't allow rename for OIDS returned by CryptoAPI
    if ( m_bEdit )
    {
        for (POSITION nextPos = g_policyOIDList.GetHeadPosition (); nextPos; )
        {
            CPolicyOID* pPolicyOID = g_policyOIDList.GetNext (nextPos);
            if ( pPolicyOID )
            {
                if ( pPolicyOID->GetOIDW () == m_oidValue )
                {
                    if ( !pPolicyOID->CanRename () )
                    {
                        GetDlgItem (IDC_NEW_ISSUANCE_OID_NAME)->EnableWindow (FALSE);
                    }
                    break;
                }
            }
        }
    }
    EnableControls ();

    m_bInInitDialog = false;
    _TRACE (-1, L"Leaving CNewIssuanceOIDDlg::OnInitDialog\n");
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CNewIssuanceOIDDlg::EnableControls()
{
    UpdateData (TRUE);
    if ( m_oidFriendlyName.IsEmpty () || m_oidValue.IsEmpty () || !m_bDirty )
        GetDlgItem (IDOK)->EnableWindow (FALSE);
    else
        GetDlgItem (IDOK)->EnableWindow (TRUE);
}

void CNewIssuanceOIDDlg::OnChangeNewOidName() 
{
    if ( !m_bInInitDialog )
    {
        m_bDirty = true;
        EnableControls ();
    }
}

void CNewIssuanceOIDDlg::OnChangeNewOidValue() 
{
    if ( !m_bInInitDialog )
    {
        m_bDirty = true;
        EnableControls ();
    }
}

void CNewIssuanceOIDDlg::OnCancel() 
{
    if ( !m_bEdit )
    {
        HRESULT hr = CAOIDDelete (m_szOriginalOID);
        _ASSERT (SUCCEEDED(hr));
        if ( FAILED (hr) )
        {
            _TRACE (0, L"CAOIDDelete (%s) failed: 0x%x\n",
                    (PCWSTR) m_szOriginalOID, hr);
        }
    }
    
    CHelpDialog::OnCancel();
}

bool CNewIssuanceOIDDlg::StartsWithHTTP (const CString& szURL) const
{
    bool bStartsWithHTTP = false;

    const PWSTR szHTTPfs = L"http://";
    const PWSTR szHTTPSfs = L"https://";
    const PWSTR szHTTPbs = L"http:\\\\";
    const PWSTR szHTTPSbs = L"https:\\\\";
    static size_t cchHTTPfs = wcslen (szHTTPfs);
    static size_t cchHTTPSfs = wcslen (szHTTPSfs);
    static size_t cchHTTPbs = wcslen (szHTTPbs);
    static size_t cchHTTPSbs = wcslen (szHTTPSbs);

    if ( 0 == _wcsnicmp (szURL, szHTTPfs, cchHTTPfs) || 
            0 == _wcsnicmp (szURL, szHTTPSfs, cchHTTPSfs) ||
            0 ==_wcsnicmp (szURL, szHTTPbs, cchHTTPbs) ||
            0 == _wcsnicmp (szURL, szHTTPSbs, cchHTTPSbs) )
    {
        bStartsWithHTTP = true;
    }

    return bStartsWithHTTP;
}

void CNewIssuanceOIDDlg::OnOK() 
{
    CThemeContextActivator activator;
    UpdateData (TRUE);

    // validate the CPS - it must begin with "http://" or "https:// or be empty"
    
    if ( !m_CPSValue.IsEmpty () && !StartsWithHTTP (m_CPSValue) )
    {
        CString text;
        CString caption;


        VERIFY (caption.LoadString (IDS_CERTTMPL));
        VERIFY (text.LoadString (IDS_CPS_MUST_START_WITH_HTTP_OR_HTTPS));

        MessageBox (text, caption, MB_OK);
        GetDlgItem (IDOK)->EnableWindow (FALSE);
        m_CPSEdit.SetFocus ();
        return;
    }

    // validate oid
    int errorTypeStrID = 0;
    if ( !OIDHasValidFormat (m_oidValue, errorTypeStrID) )
    {
        CString text;
        CString caption;
        CString errorType;


        VERIFY (caption.LoadString (IDS_CERTTMPL));
        if ( errorTypeStrID )
            VERIFY (errorType.LoadString (errorTypeStrID));
        // security review 2/21/2002 BryanWal ok
        text.FormatMessage (IDS_OID_FORMAT_INVALID, m_oidValue, errorType);

        MessageBox (text, caption, MB_OK);
        GetDlgItem (IDOK)->EnableWindow (FALSE);
        m_oidValueEdit.SetFocus ();
        return;
    }

    if ( !m_bEdit && m_szOriginalOID != m_oidValue )
    {
        HRESULT hr = CAOIDDelete (m_szOriginalOID);
        _ASSERT (SUCCEEDED(hr));
        if ( SUCCEEDED (hr) )
        {
            hr = CAOIDAdd (CERT_OID_TYPE_ISSUER_POLICY,
                    0,
                    m_oidValue);
            if ( FAILED (hr) )
            {
                CString text;
                CString caption;

                VERIFY (caption.LoadString (IDS_CERTTMPL));
                // security review 2/21/2002 BryanWal ok
                text.FormatMessage (IDS_CANNOT_ADD_ISSUANCE_OID, GetSystemMessage (hr));

                MessageBox (text, caption, MB_OK | MB_ICONWARNING);
                _TRACE (0, L"CAOIDAdd (%s) failed: 0x%x\n",
                        (PCWSTR) m_oidValue, hr);
                return;
            }
        }
        else
        {
            _TRACE (0, L"CAOIDDelete (%s) failed: 0x%x\n",
                    (PCWSTR) m_szOriginalOID, hr);
            return;
        }
    }

    HRESULT hr = S_OK;
    // If we're editing, don't save the value if it hasn't changed
    if ( (m_bEdit && m_originalOidFriendlyName != m_oidFriendlyName) || !m_bEdit )
        hr = CAOIDSetProperty (m_oidValue, CERT_OID_PROPERTY_DISPLAY_NAME,
                m_oidFriendlyName.IsEmpty () ? 0 : ((LPVOID) (LPCWSTR) m_oidFriendlyName));
    if ( SUCCEEDED (hr) )
    {
        if ( SUCCEEDED (hr) )
        {
            // Update the OID list
            for (POSITION nextPos = g_policyOIDList.GetHeadPosition (); nextPos; )
            {
                CPolicyOID* pPolicyOID = g_policyOIDList.GetNext (nextPos);
                if ( pPolicyOID && 
                        pPolicyOID->IsIssuanceOID () && 
                        m_oidValue == pPolicyOID->GetOIDW ())
                {
                    pPolicyOID->SetDisplayName (m_oidFriendlyName);
                }
            }
        }

        if ( (m_bEdit && m_originalCPSValue != m_CPSValue) || !m_bEdit )
            hr = CAOIDSetProperty (m_oidValue, CERT_OID_PROPERTY_CPS,
                    m_CPSValue.IsEmpty () ? 0 : ((LPVOID) (LPCWSTR) m_CPSValue));
        if ( FAILED (hr) )
        {
            CString text;
            CString caption;

            VERIFY (caption.LoadString (IDS_CERTTMPL));
            // security review 2/21/2002 BryanWal ok
            text.FormatMessage (IDS_CANNOT_WRITE_CPS, GetSystemMessage (hr));

            MessageBox (text, caption, MB_OK | MB_ICONWARNING);
            _TRACE (0, L"CAOIDSetProperty (%s, CERT_OID_PROPERTY_CPS, %s) failed: 0x%x\n",
                    (PCWSTR) m_oidValue, (PCWSTR) m_CPSValue, hr);
            return;
        }
    }
    else
    {
        CString text;
        CString caption;

        VERIFY (caption.LoadString (IDS_CERTTMPL));
        // security review 2/21/2002 BryanWal ok
        text.FormatMessage (IDS_CANNOT_WRITE_DISPLAY_NAME, GetSystemMessage (hr));

        MessageBox (text, caption, MB_OK | MB_ICONWARNING);
        _TRACE (0, L"CAOIDSetProperty (%s, CERT_OID_PROPERTY_DISPLAY_NAME, %s) failed: 0x%x\n",
                (PCWSTR) m_oidValue, (PCWSTR) m_oidFriendlyName, hr);
        return;
    }

    
    CHelpDialog::OnOK();
}

void CNewIssuanceOIDDlg::DoContextHelp (HWND hWndControl)
{
    _TRACE(-1, L"Entering CNewIssuanceOIDDlg::DoContextHelp\n");
    
    // Display context help for a control
    if ( !::WinHelp (
            hWndControl,
            GetContextHelpFile (),
            HELP_WM_HELP,
            (DWORD_PTR) g_aHelpIDs_IDD_NEW_ISSUANCE_OID) )
    {
        _TRACE(-1, L"WinHelp () failed: 0x%x\n", GetLastError ());        
    }
    _TRACE(-1, L"Leaving CNewIssuanceOIDDlg::DoContextHelp\n");
}

void CNewIssuanceOIDDlg::OnClickedURL( NMHDR * pNMHDR, LRESULT * pResult )
{
    ENLINK *pEnlink = reinterpret_cast< ENLINK * >( pNMHDR );

    if ( pEnlink->msg == WM_LBUTTONUP )
    {
        UpdateData (TRUE);
        CString strCPSText;
        CString strURL;


        // pEnlink->chrg.cpMin and pEnlink->chrg.cpMax delimit the URL string.
        strURL = m_CPSValue.Mid (pEnlink->chrg.cpMin, pEnlink->chrg.cpMax - pEnlink->chrg.cpMin);

        // Displaying the URL may take time, so show the hourglass cursor.
        CWaitCursor waitCursor;

        // // security review 2/21/2002 BryanWal 
        // ISSUE
        // NTRAID 551040 Security: Cert Templates: issuance OID CPS should be restricted to http or https types
        if ( ShellExecute( this->m_hWnd, _T("open"), strURL, NULL, NULL, SW_SHOWDEFAULT ) <= (HINSTANCE) 32 )
        {
            CThemeContextActivator activator;
            AfxMessageBox( IDS_BROWSER_ERROR );
        }
    }

    *pResult = 0;
}


void CNewIssuanceOIDDlg::OnChangeCpsEdit() 
{
    if ( !m_bInInitDialog )
    {
        m_bDirty = true;
        EnableControls ();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\policyoid.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2002.
//
//  File:       PolicyOID.cpp
//
//  Contents:   CPolicyOID
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "PolicyOID.h"

CPolicyOID::CPolicyOID (const CString& szOID, const CString& szDisplayName, ADS_INTEGER flags, bool bCanRename)
    : m_szOIDW (szOID),
    m_szDisplayName (szDisplayName),
    m_pszOIDA (0),
    m_flags (flags),
    m_bCanRename (bCanRename)
{
    // security review 2/21/2002 BryanWal ok
    int nLen = WideCharToMultiByte(
          CP_ACP,                   // code page
          0,                        // performance and mapping flags
          (PCWSTR) m_szOIDW,        // wide-character string
          -1,                       // -1 - calculate length of null-terminated string automatically
          0,                        // buffer for new string
          0,                        // size of buffer - 0 causes API to return len inc. null term.
          0,                        // default for unmappable chars
          0);                       // set when default char used
    if ( nLen > 0 )
    {
        m_pszOIDA = new char[nLen];
        if ( m_pszOIDA )
        {
            // security review 2/21/2002 BryanWal ok
            ZeroMemory (m_pszOIDA, nLen);
            // security review 2/21/2002 BryanWal ok
            nLen = WideCharToMultiByte(
                    CP_ACP,                 // code page
                    0,                      // performance and mapping flags
                    (PCWSTR) m_szOIDW,      // wide-character string
                    -1,                     // -1 - calculate length of null-terminated string automatically
                    m_pszOIDA,              // buffer for new string
                    nLen,                   // size of buffer
                    0,                      // default for unmappable chars
                    0);                     // set when default char used
            if ( !nLen )
            {
                _TRACE (0, L"WideCharToMultiByte (%s) failed: 0x%x\n", 
                        (PCWSTR) m_szOIDW, GetLastError ());
            }
        }
    }
    else
    {
        _TRACE (0, L"WideCharToMultiByte (%s) failed: 0x%x\n", 
                (PCWSTR) m_szOIDW, GetLastError ());
    }
}

CPolicyOID::~CPolicyOID ()
{
    if ( m_pszOIDA )
        delete [] m_pszOIDA;
}

bool CPolicyOID::IsIssuanceOID() const
{
    return (m_flags == CERT_OID_TYPE_ISSUER_POLICY) ? true : false;
}

bool CPolicyOID::IsApplicationOID() const
{
    return (m_flags == CERT_OID_TYPE_APPLICATION_POLICY) ? true : false;
}

void CPolicyOID::SetDisplayName(const CString &szDisplayName)
{
    m_szDisplayName = szDisplayName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\policydlg.h ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       PolicyDlg.h
//
//  Contents:   Definition of CPolicyDlg
//
//----------------------------------------------------------------------------
#if !defined(AFX_POLICYDLG_H__824C478F_445C_44A8_8FC1_67A91BED283F__INCLUDED_)
#define AFX_POLICYDLG_H__824C478F_445C_44A8_8FC1_67A91BED283F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// PolicyDlg.h : header file
//
#include "CertTemplate.h"
#include "PolicyOID.h"

/////////////////////////////////////////////////////////////////////////////
// CPolicyDlg dialog

class CPolicyDlg : public CHelpDialog
{
// Construction
public:
	CPolicyDlg(CWnd* pParent, 
        CCertTemplate& rCertTemplate, 
        PCERT_EXTENSION pCertExtension);
	~CPolicyDlg();

// Dialog Data
	//{{AFX_DATA(CPolicyDlg)
	enum { IDD = IDD_POLICY };
	CListBox	m_policyList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPolicyDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual void DoContextHelp (HWND hWndControl);
	void EnableControls();
	// Generated message map functions
	//{{AFX_MSG(CPolicyDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnCancelMode();
	afx_msg void OnAddPolicy();
	afx_msg void OnRemovePolicy();
	afx_msg void OnPolicyCritical();
	afx_msg void OnDestroy();
	afx_msg void OnSelchangePoliciesList();
	afx_msg void OnEditPolicy();
	virtual void OnOK();
	afx_msg void OnDblclkPoliciesList();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
    bool m_bModified;
	const bool m_bIsEKU;
    const bool m_bIsApplicationPolicy;
    CCertTemplate&      m_rCertTemplate;
    PCERT_EXTENSION     m_pCertExtension;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_POLICYDLG_H__824C478F_445C_44A8_8FC1_67A91BED283F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\policydlg.cpp ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2002.
//
//  File:       PolicyDlg.cpp
//
//  Contents:   Implementation of CPolicyDlg
//
//----------------------------------------------------------------------------
// PolicyDlg.cpp : implementation file
//

#include "stdafx.h"
#include "PolicyDlg.h"
#include "SelectOIDDlg.h"
#include "NewApplicationOIDDlg.h"
#include "NewIssuanceOIDDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CPolicyDlg property page

CPolicyDlg::CPolicyDlg(CWnd* pParent, 
        CCertTemplate& rCertTemplate, 
        PCERT_EXTENSION pCertExtension) 
 : CHelpDialog(CPolicyDlg::IDD, pParent),
    m_rCertTemplate (rCertTemplate),
    m_pCertExtension (pCertExtension),
    m_bIsEKU ( !_stricmp (szOID_ENHANCED_KEY_USAGE, pCertExtension->pszObjId) ? true : false),
    m_bIsApplicationPolicy ( !_stricmp (szOID_APPLICATION_CERT_POLICIES, pCertExtension->pszObjId) ? true : false),
    m_bModified (false)
{
	//{{AFX_DATA_INIT(CPolicyDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CPolicyDlg::~CPolicyDlg()
{
}

void CPolicyDlg::DoDataExchange(CDataExchange* pDX)
{
	CHelpDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPolicyDlg)
	DDX_Control(pDX, IDC_POLICIES_LIST, m_policyList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPolicyDlg, CHelpDialog)
	//{{AFX_MSG_MAP(CPolicyDlg)
	ON_WM_CANCELMODE()
	ON_BN_CLICKED(IDC_ADD_POLICY, OnAddPolicy)
	ON_BN_CLICKED(IDC_REMOVE_POLICY, OnRemovePolicy)
	ON_BN_CLICKED(IDC_POLICY_CRITICAL, OnPolicyCritical)
	ON_WM_DESTROY()
	ON_LBN_SELCHANGE(IDC_POLICIES_LIST, OnSelchangePoliciesList)
	ON_BN_CLICKED(IDC_EDIT_POLICY, OnEditPolicy)
	ON_LBN_DBLCLK(IDC_POLICIES_LIST, OnDblclkPoliciesList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPolicyDlg message handlers

BOOL CPolicyDlg::OnInitDialog() 
{
    _TRACE (1, L"Entering CPolicyDlg::OnInitDialog\n");
	CHelpDialog::OnInitDialog();
	
    CString text;
	if ( m_bIsEKU )
    {
        VERIFY (text.LoadString (IDS_EDIT_APPLICATION_POLICIES_EXTENSION));
        SetWindowText (text);

        VERIFY (text.LoadString (IDS_EFFECTIVE_APPLICATION_POLICIES));

        int     nEKUIndex = 0;
        CString szEKU;
        while ( SUCCEEDED (m_rCertTemplate.GetEnhancedKeyUsage (nEKUIndex, szEKU)) )
        {
            // security review 2/21/2002 BryanWal ok
            int nLen = WideCharToMultiByte(
                  CP_ACP,                   // code page
                  0,                        // performance and mapping flags
                  (PCWSTR) szEKU,           // wide-character string
                  -1,                       // -1 - calculate length of null-terminated string automatically
                  0,                        // buffer for new string
                  0,                        // size of buffer - API returns null terminator when 0
                  0,                        // default for unmappable chars
                  0);                       // set when default char used
            if ( nLen > 0 )
            {
                PSTR    pszAnsiBuf = new char[nLen];
                if ( pszAnsiBuf )
                {
                    // security review 2/21/2002 BryanWal ok
                    ZeroMemory (pszAnsiBuf, nLen);
                    // security review 2/21/2002 BryanWal ok
                    nLen = WideCharToMultiByte(
                            CP_ACP,                 // code page
                            0,                      // performance and mapping flags
                            (PCWSTR) szEKU,         // wide-character string
                            -1,                     // -1 - calculate length of null-terminated string automatically
                            pszAnsiBuf,             // buffer for new string
                            nLen,                   // size of buffer
                            0,                      // default for unmappable chars
                            0);                     // set when default char used
                    if ( nLen )
                    {
                        CString szEKUName;
                        if ( MyGetOIDInfoA (szEKUName, pszAnsiBuf) )
                        {
                            int nIndex = m_policyList.AddString (szEKUName);
                            if ( nIndex >= 0 )
                            {
                                m_policyList.SetItemDataPtr (nIndex, pszAnsiBuf);
                            }
                            else
                                delete [] pszAnsiBuf;
                        }
                        else
                            delete [] pszAnsiBuf;
                    }
                }
            }
            nEKUIndex++;
        }
    }
    else if ( m_bIsApplicationPolicy )
    {
        VERIFY (text.LoadString (IDS_EDIT_APPLICATION_POLICIES_EXTENSION));
        SetWindowText (text);

        VERIFY (text.LoadString (IDS_EFFECTIVE_APPLICATION_POLICIES));

        int     nAppPolicyIndex = 0;
        CString szAppPolicy;
        while ( SUCCEEDED (m_rCertTemplate.GetApplicationPolicy (nAppPolicyIndex, szAppPolicy)) )
        {
            // security review 2/21/2002 BryanWal ok
            int nLen = WideCharToMultiByte(
                  CP_ACP,                   // code page
                  0,                        // performance and mapping flags
                  (PCWSTR) szAppPolicy,  // wide-character string
                  -1,                       // -1 - calculate length of null-terminated string automatically
                  0,                        // buffer for new string
                  0,                        // size of buffer - 0 causes API to return len inc. null term.
                  0,                    // default for unmappable chars
                  0);                   // set when default char used
            if ( nLen > 0 )
            {
                PSTR    pszAnsiBuf = new char[nLen];
                if ( pszAnsiBuf )
                {
                    // security review 2/21/2002 BryanWal ok
                    ZeroMemory (pszAnsiBuf, nLen);
                    // security review 2/21/2002 BryanWal ok
                    nLen = WideCharToMultiByte(
                            CP_ACP,                 // code page
                            0,                      // performance and mapping flags
                            (PCWSTR) szAppPolicy, // wide-character string
                            -1,                     // -1 - calculate length of null-terminated string automatically
                            pszAnsiBuf,             // buffer for new string
                            nLen,                   // size of buffer
                            0,                      // default for unmappable chars
                            0);                     // set when default char used
                    if ( nLen )
                    {
                        CString szAppPolicyName;
                        if ( MyGetOIDInfoA (szAppPolicyName, pszAnsiBuf) )
                        {
                            int nIndex = m_policyList.AddString (szAppPolicyName);
                            if ( nIndex >= 0 )
                            {
                                m_policyList.SetItemDataPtr (nIndex, pszAnsiBuf);
                            }
                            else
                                delete [] pszAnsiBuf;
                        }
                        else
                            delete [] pszAnsiBuf;
                    }
                }
            }
            nAppPolicyIndex++;
        }
    }
    else
    {
        VERIFY (text.LoadString (IDS_EDIT_ISSUANCE_POLICIES_EXTENSION));
        SetWindowText (text);

        VERIFY (text.LoadString (IDS_ISSUANCE_POLICIES_HINT));
        SetDlgItemText (IDC_POLICIES_HINT, text);
        VERIFY (text.LoadString (IDS_EFFECTIVE_ISSUANCE_POLICIES));

        int     nCertPolicyIndex = 0;
        CString szCertPolicy;
        while ( SUCCEEDED (m_rCertTemplate.GetCertPolicy (nCertPolicyIndex, szCertPolicy)) )
        {
            // security review 2/21/2002 BryanWal ok
            int nLen = WideCharToMultiByte(
                  CP_ACP,                   // code page
                  0,                        // performance and mapping flags
                  (PCWSTR) szCertPolicy,  // wide-character string
                  // security review 2/21/2002 BryanWal ok
                  -1,                       // -1 - calculate length of null-terminated string automatically
                  0,                        // buffer for new string
                  0,                        // size of buffer - 0 causes API to return len inc. null term.
                  0,                    // default for unmappable chars
                  0);                   // set when default char used
            if ( nLen > 0 )
            {
                PSTR    pszAnsiBuf = new char[nLen];
                if ( pszAnsiBuf )
                {
                    // security review 2/21/2002 BryanWal ok
                    ZeroMemory (pszAnsiBuf, nLen);
                    // security review 2/21/2002 BryanWal ok
                    nLen = WideCharToMultiByte(
                            CP_ACP,                 // code page
                            0,                      // performance and mapping flags
                            (PCWSTR) szCertPolicy, // wide-character string
                            -1,                     // -1 - calculate length of null-terminated string automatically
                            pszAnsiBuf,             // buffer for new string
                            nLen,                   // size of buffer
                            0,                      // default for unmappable chars
                            0);                     // set when default char used
                    if ( nLen )
                    {
                        CString szPolicyName;
                        if ( MyGetOIDInfoA (szPolicyName, pszAnsiBuf) )
                        {
                            int nIndex = m_policyList.AddString (szPolicyName);
                            if ( nIndex >= 0 )
                            {
                                m_policyList.SetItemDataPtr (nIndex, pszAnsiBuf);
                            }
                            else
                                delete [] pszAnsiBuf;
                        }
                        else
                            delete [] pszAnsiBuf;
                    }
                }
            }
            nCertPolicyIndex++;
        }
    }
	SetDlgItemText (IDC_POLICIES_LABEL, text);

    if ( 1 == m_rCertTemplate.GetType () )
    {
        GetDlgItem (IDC_POLICY_CRITICAL)->EnableWindow (FALSE);
        GetDlgItem (IDC_POLICIES_LABEL)->EnableWindow (FALSE);
        GetDlgItem (IDC_POLICIES_LIST)->EnableWindow (FALSE);
        GetDlgItem (IDC_ADD_POLICY)->EnableWindow (FALSE);
        GetDlgItem (IDC_REMOVE_POLICY)->EnableWindow (FALSE);
    }

    bool    bCritical = false;
    PWSTR   pszOID = 0;
    if ( m_bIsEKU )
        pszOID = TEXT (szOID_ENHANCED_KEY_USAGE);
    else if ( m_bIsApplicationPolicy )
        pszOID = TEXT (szOID_APPLICATION_CERT_POLICIES);
    else
        pszOID = TEXT (szOID_CERT_POLICIES);

    if ( SUCCEEDED (m_rCertTemplate.IsExtensionCritical (
            pszOID, 
            bCritical)) && bCritical )
    {
        SendDlgItemMessage (IDC_POLICY_CRITICAL, BM_SETCHECK, BST_CHECKED);
    }

    EnableControls ();

    _TRACE (-1, L"Leaving CPolicyDlg::OnInitDialog\n");
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CPolicyDlg::OnCancelMode() 
{
	CHelpDialog::OnCancelMode();
	
    if ( m_pCertExtension->fCritical )
        SendDlgItemMessage (IDC_POLICY_CRITICAL, BM_SETCHECK, BST_CHECKED);
	
}

void CPolicyDlg::OnAddPolicy() 
{
    // Create the list of already added OIDs.  These will not be displayed
    // in the Select OID dialog.
	int		nCnt = m_policyList.GetCount ();
    PSTR*   paszUsedOIDs = 0;

	
    // allocate an array of PSTR pointers and add each item.
    // Set the last to NULL
    if ( nCnt )
    {
        paszUsedOIDs = new PSTR[nCnt+1];
        if ( paszUsedOIDs )
        {
            // security review 2/21/2002 BryanWal ok
            ::ZeroMemory (paszUsedOIDs, sizeof (PSTR) * (nCnt+1));
	        while (--nCnt >= 0)
	        {
                PSTR pszOID = (PSTR) m_policyList.GetItemData (nCnt);
                if ( pszOID )
                {
                    // security review 2/21/2002 BryanWal ok
                    PSTR pNewStr = new char[strlen (pszOID) + 1];
                    if ( pNewStr )
                    {
                        // security review 2/21/2002 BryanWal ok
                        strcpy (pNewStr, pszOID);
                        paszUsedOIDs[nCnt] = pNewStr;
                    }
                    else
                        break;
                }
            }
        }
    }

	CSelectOIDDlg  dlg (this, m_pCertExtension, m_bIsEKU || m_bIsApplicationPolicy, 
            paszUsedOIDs);

    CThemeContextActivator activator;
    if ( IDOK == dlg.DoModal () )
    {
        if ( dlg.m_paszReturnedOIDs && dlg.m_paszReturnedFriendlyNames )
        {
            for (int nIndex = 0; !dlg.m_paszReturnedOIDs[nIndex].IsEmpty (); nIndex++)
            {
                // security review 2/21/2002 BryanWal ok
                int nLen = WideCharToMultiByte(
                      CP_ACP,                   // code page
                      0,                        // performance and mapping flags
                      (PCWSTR) dlg.m_paszReturnedOIDs[nIndex],  // wide-character string
                      -1,                       // -1 - calculate length of null-terminated string automatically
                      0,                        // buffer for new string
                      0,                        // size of buffer - 0 causes API to return len inc. null term.
                      0,                    // default for unmappable chars
                      0);                   // set when default char used
                if ( nLen > 0 )
                {
                    PSTR    pszAnsiBuf = new char[nLen];
                    if ( pszAnsiBuf )
                    {
                        // security review 2/21/2002 BryanWal ok
                        ZeroMemory (pszAnsiBuf, nLen);
                        // security review 2/21/2002 BryanWal ok
                        nLen = WideCharToMultiByte(
                                CP_ACP,                 // code page
                                0,                      // performance and mapping flags
                                (PCWSTR) dlg.m_paszReturnedOIDs[nIndex], // wide-character string
                                -1,                     // -1 - calculate length of null-terminated string automatically
                                pszAnsiBuf,             // buffer for new string
                                nLen,                   // size of buffer
                                0,                      // default for unmappable chars
                                0);                     // set when default char used
                        if ( nLen )
                        {
                            int nAddedIndex = m_policyList.AddString (dlg.m_paszReturnedFriendlyNames[nIndex]);
                            if ( nAddedIndex >= 0 )
                            {
                                m_policyList.SetItemDataPtr (nAddedIndex, pszAnsiBuf);
                                m_policyList.SetSel (nAddedIndex, TRUE);
                                m_bModified = true;
                                EnableControls ();
                            }
                        }
                        else
                        {
                            _TRACE (0, L"WideCharToMultiByte (%s) failed: 0x%x\n", 
                                    (PCWSTR) dlg.m_paszReturnedOIDs[nIndex], GetLastError ());
                        }
                    }
                }
                else
                {
                    _TRACE (0, L"WideCharToMultiByte (%s) failed: 0x%x\n", 
                            (PCWSTR) dlg.m_paszReturnedOIDs[nIndex], GetLastError ());
                }
            }
        }
    }

    // clean up
    if ( paszUsedOIDs )
    {
        for (int nIndex = 0; paszUsedOIDs[nIndex]; nIndex++)
            delete [] paszUsedOIDs[nIndex];
        delete [] paszUsedOIDs;
    }
}

void CPolicyDlg::OnRemovePolicy() 
{
    int nSelCnt = m_policyList.GetSelCount ();
    if ( nSelCnt > 0 )
    {
        int* pnSelIndexes = new int[nSelCnt];
        if ( pnSelIndexes )
        {
            if ( LB_ERR != m_policyList.GetSelItems (nSelCnt, pnSelIndexes) )
            {
                for (int nIndex = nSelCnt - 1; nIndex >= 0; nIndex--)
                {
                    PSTR pszOID = (PSTR) m_policyList.GetItemDataPtr (pnSelIndexes[nIndex]);
                    if ( pszOID )
                        delete [] pszOID;
                    m_policyList.DeleteString (pnSelIndexes[nIndex]);
                }
                m_bModified = true;
            }
            delete [] pnSelIndexes;
        }
    }

    m_policyList.SetFocus ();

    EnableControls ();
}

void CPolicyDlg::EnableControls()
{
    if ( 1 == m_rCertTemplate.GetType () )
    {
        GetDlgItem (IDOK)->EnableWindow (FALSE);
        GetDlgItem (IDC_REMOVE_POLICY)->EnableWindow (FALSE);
        GetDlgItem (IDC_ADD_POLICY)->EnableWindow (FALSE);
        GetDlgItem (IDC_POLICY_CRITICAL)->EnableWindow (FALSE);
        GetDlgItem (IDC_EDIT_POLICY)->EnableWindow (FALSE);
    }
    else
    {
        GetDlgItem (IDOK)->EnableWindow (m_bModified && !m_rCertTemplate.ReadOnly ());
        GetDlgItem (IDC_REMOVE_POLICY)->EnableWindow (
                m_policyList.GetSelCount () > 0 && !m_rCertTemplate.ReadOnly ());
        GetDlgItem (IDC_ADD_POLICY)->EnableWindow (!m_rCertTemplate.ReadOnly ());
        GetDlgItem (IDC_POLICY_CRITICAL)->EnableWindow (!m_rCertTemplate.ReadOnly ());
        GetDlgItem (IDC_EDIT_POLICY)->EnableWindow (
                m_policyList.GetSelCount () == 1 && !m_rCertTemplate.ReadOnly ());
    }
}

void CPolicyDlg::OnPolicyCritical() 
{
    m_bModified = true;
    EnableControls ();	
}

void CPolicyDlg::OnDestroy() 
{
	CHelpDialog::OnDestroy();
	
    int nCnt = m_policyList.GetCount ();
    for (int nIndex = 0; nIndex < nCnt; nIndex++)
    {
        PSTR pszOID = (PSTR) m_policyList.GetItemDataPtr (nIndex);
        if ( pszOID )
            delete [] pszOID;
    }
}

void CPolicyDlg::OnSelchangePoliciesList() 
{
    EnableControls ();	
}

void CPolicyDlg::DoContextHelp (HWND hWndControl)
{
	_TRACE(1, L"Entering CPolicyDlg::DoContextHelp\n");
    
	switch (::GetDlgCtrlID (hWndControl))
	{
	case IDC_POLICIES_LABEL:
		break;

	default:
		// Display context help for a control
		if ( !::WinHelp (
				hWndControl,
				GetContextHelpFile (),
				HELP_WM_HELP,
				(DWORD_PTR) g_aHelpIDs_IDD_POLICY) )
		{
			_TRACE(0, L"WinHelp () failed: 0x%x\n", GetLastError ());        
		}
		break;
	}
    _TRACE(-1, L"Leaving CPolicyDlg::DoContextHelp\n");
}

void CPolicyDlg::OnEditPolicy() 
{
    int nSel = this->m_policyList.GetCurSel ();
    if ( nSel >= 0 )
    {
        CString szDisplayName;
        m_policyList.GetText (nSel, szDisplayName);
        PSTR pszOID = (PSTR) m_policyList.GetItemDataPtr (nSel);
        if ( pszOID )
        {
            CString newDisplayName;
            INT_PTR iRet = 0;
	        if ( m_bIsEKU || m_bIsApplicationPolicy)
            {
                CNewApplicationOIDDlg   dlg (this, szDisplayName, pszOID);

                CThemeContextActivator activator;
                iRet = dlg.DoModal ();
                if ( IDOK == iRet )
                    newDisplayName = dlg.m_oidFriendlyName;
            }
            else
            {
                PWSTR   pszCPS = 0;
                CString strOID = pszOID;
                HRESULT hr = CAOIDGetProperty(
                            strOID,
                            CERT_OID_PROPERTY_CPS,
                            &pszCPS);
                if ( SUCCEEDED (hr) || 
                        HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND) == hr ||
                        HRESULT_FROM_WIN32 (ERROR_DS_OBJ_NOT_FOUND) == hr ||
                        HRESULT_FROM_WIN32 (ERROR_INVALID_PARAMETER) == hr )
                {
                    CNewIssuanceOIDDlg   dlg (this, szDisplayName, pszOID, 
                            pszCPS);

                    CThemeContextActivator activator;
                    iRet = dlg.DoModal ();
                    if ( IDOK == iRet )
                        newDisplayName = dlg.m_oidFriendlyName;
                }
                else 
                {
                    DWORD   dwErr = HRESULT_CODE (hr);
                    if ( ERROR_INVALID_PARAMETER != dwErr )
                    {
                        CString text;
                        CString caption;
                        CThemeContextActivator activator;

                        VERIFY (caption.LoadString (IDS_CERTTMPL));
                        // security review 2/21/2002 BryanWal ok
                        text.FormatMessage (IDS_CANNOT_READ_CPS, GetSystemMessage (hr));

                        MessageBox (text, caption, MB_OK);

                        _TRACE (0, L"CAOIDGetProperty (CERT_OID_PROPERTY_CPS) failed: 0x%x\n", hr);
                    }
                }
            }
            if ( IDOK == iRet )
            {
                if ( szDisplayName != newDisplayName )
                {
                    m_policyList.DeleteString (nSel);
                    int nIndex = m_policyList.AddString (newDisplayName);
                    if ( nIndex >= 0 )
                        m_policyList.SetItemDataPtr (nIndex, pszOID);
                }
            }
        }
    }
}

void CPolicyDlg::OnOK() 
{
    // Create the list of OIDs.
	int		nCnt = m_policyList.GetCount ();
    PWSTR*   paszEKUs = 0;

	
    // allocate an array of PSTR pointers and add each item.
    // Set the last to NULL
    if ( nCnt )
    {
        paszEKUs = new PWSTR[nCnt+1];
        if ( paszEKUs )
        {
            // security review 2/21/2002 BryanWal ok
            ::ZeroMemory (paszEKUs, sizeof (PWSTR) * (nCnt+1));
	        while (--nCnt >= 0)
	        {
                PSTR pszOID = (PSTR) m_policyList.GetItemData (nCnt);
                if ( pszOID )
                {
                    PWSTR   pNewStr = 0;
                    // security review 2/21/2002 BryanWal ok
                    int     nLen = ::MultiByteToWideChar (CP_ACP, 0, pszOID, -1, NULL, 0);
		            ASSERT (nLen);  // NOTICE: API returns required char count 
                                    // including null terminator if last arg is 0
		            if ( nLen > 0 )
		            {
                        pNewStr = new WCHAR[nLen];
                        if ( pNewStr )
                        {
                            // security review 2/21/2002 BryanWal ok
			                nLen = ::MultiByteToWideChar (CP_ACP, 0, pszOID, -1, 
					                pNewStr, nLen);
			                ASSERT (nLen);
                            if ( nLen > 0)
                            {
                                paszEKUs[nCnt] = pNewStr;
                            }
                        }
		            }
                }
            }
        }
    }

    CThemeContextActivator activator;
    bool    bCritical = BST_CHECKED == SendDlgItemMessage (
                IDC_POLICY_CRITICAL, BM_GETCHECK);
    
    HRESULT hr = S_OK;
    if ( m_bIsEKU )
    {
        hr = m_rCertTemplate.SetEnhancedKeyUsage (paszEKUs, bCritical);
        if ( FAILED (hr) )
        {
            CString text;
            CString caption;

            VERIFY (caption.LoadString (IDS_CERTTMPL));
            // security review 2/21/2002 BryanWal ok
            text.FormatMessage (IDS_CANNOT_SAVE_EKU_EXTENSION, GetSystemMessage (hr));

            MessageBox (text, caption, MB_OK);
        }
    }
    else if ( m_bIsApplicationPolicy )
    {
        hr = m_rCertTemplate.SetApplicationPolicy (paszEKUs, bCritical);
        if ( FAILED (hr) )
        {
            CString text;
            CString caption;

            VERIFY (caption.LoadString (IDS_CERTTMPL));
            // security review 2/21/2002 BryanWal ok
            text.FormatMessage (IDS_CANNOT_SAVE_APPLICATION_POLICY_EXTENSION, GetSystemMessage (hr));

            MessageBox (text, caption, MB_OK);
        }
    }
    else
    {
        hr = m_rCertTemplate.SetCertPolicy (paszEKUs, bCritical);
        if ( FAILED (hr) )
        {
            CString text;
            CString caption;

            VERIFY (caption.LoadString (IDS_CERTTMPL));
            // security review 2/21/2002 BryanWal ok
            text.FormatMessage (IDS_CANNOT_SAVE_CERT_POLICY_EXTENSION, GetSystemMessage (hr));

            MessageBox (text, caption, MB_OK);
        }
    }

    // clean up
    if ( paszEKUs )
    {
        for (int nIndex = 0; paszEKUs[nIndex]; nIndex++)
            delete [] paszEKUs[nIndex];
        delete [] paszEKUs;
    }

    if ( SUCCEEDED (hr) )
	    CHelpDialog::OnOK();
}

void CPolicyDlg::OnDblclkPoliciesList() 
{
	OnEditPolicy ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\securitypropertypage.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998-2001
//
//  File:       SecurityPropertyPage.h
//
//--------------------------------------------------------------------------
#ifndef _CERTTMPL_SECURITYPROPERTYPAGE_H
#define _CERTTMPL_SECURITYPROPERTYPAGE_H

#include <aclui.h>
#include "CertTemplate.h"

HRESULT CreateCertTemplateSecurityInfo (
            CCertTemplate *pCertTemplate, 
            LPSECURITYINFO *ppObjSI);



















#endif // _CERTTMPL_SECURITYPROPERTYPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by certtmpl.rc
//
#define IDS_CERTTMPL_DESC               101
#define IDD_BASIC_CONSTRAINTS           102
#define IDS_NOT_AVAILABLE               103
#define IDS_SNAPINABOUT_DESCRIPTION     106
#define IDS_CERTTMPL_REGISTRY           107
#define IDD_TEMPLATE_GENERAL            107
#define IDD_TEMPLATE_V1_REQUEST         108
#define IDD_KEY_USAGE                   109
#define IDD_TEMPLATE_V1_SUBJECT_NAME    110
#define IDS_REGISTER_CERTTMPL           111
#define IDS_INSUFFICIENT_RIGHTS_TO_REGISTER_CERTTMPL 112
#define IDB_CERTTMPL_LARGE              114
#define IDB_CERTTMPL_SMALL              115
#define IDS_CANNOT_SAVE_CERT_POLICY_EXTENSION 119
#define IDS_CERTTMPL                    120
#define IDS_CANNOT_DELETE_CERT_TEMPLATE 121
#define IDS_WINDOWS_2000_AND_LATER      122
#define IDS_CONFIRM_DELETE_CERT_TEMPLATE_MULTI 123
#define IDS_CONFIRM_DELETE_CERT_TEMPLATE 124
#define IDS_INH_NONE                    125
#define IDS_ACTRL_ENROLL                126
#define IDS_ACTRL_AUTOENROLL            127
#define IDS_ACTRL_CERTSRV_MANAGE        128
#define IDS_CERTTEMPLATESHELLEXT_DESC   130
#define IDS_EDIT                        131
#define IDS_EDIT_HINT                   132
#define IDS_ACTRL_CERTSRV_READ          133
#define IDS_CANNOT_READ_BASIC_CONSTRAINTS 134
#define IDS_WINDOWS_2002_AND_LATER      135
#define IDS_ADD_ISSUANCE_POLICY         136
#define IDS_ACTRL_CERTSRV_WRITE         137
#define IDS_BROWSER_ERROR               138
#define IDS_ISSUANCE_POLICIES_HINT      139
#define IDS_CANNOT_SAVE_EKU_EXTENSION   140
#define IDS_ISSUANCE_POLICY             141
#define IDS_APPLICATION_POLICY          142
#define IDS_APPLICATION_AND_ISSUANCE_POLICY 143
#define IDI_CERT_TEMPLATEV1             144
#define IDS_MUST_ADD_RA_ISSUANCE_POLICY 144
#define IDI_CERT_TEMPLATEV2             145
#define IDS_RENEWAL_MUST_BE_LESS_THAN_VALIDITY 145
#define IDS_OID_FORMAT_INVALID          146
#define IDS_OID_CONTAINS_NON_DIGITS     147
#define IDS_OID_CONTAINS_CONSECUTIVE_DOTS 148
#define IDD_EXTENDED_KEY_USAGE          149
#define IDS_OID_MUST_START_WITH_0_1_2   149
#define IDD_NEW_APPLICATION_OID         150
#define IDS_OID_0_1_MUST_BE_0_TO_39     150
#define IDD_SELECT_TEMPLATE             151
#define IDS_OID_MUST_HAVE_TWO_NUMBERS   151
#define IDD_POLICY                      152
#define IDS_OID_CANNOT_END_WITH_DOT     152
#define IDD_TEMPLATE_V2_SUBJECT_NAME    153
#define IDS_EDIT_ISSUANCE_POLICY        153
#define IDS_EDIT_APPLICATION_POLICY     154
#define IDD_TEMPLATE_V2_AUTHENTICATION  155
#define IDS_EXTENSION_NAME              155
#define IDD_TEMPLATE_V2_SUPERCEDES      156
#define IDS_SUBJECT_IS_CA               156
#define IDD_TEMPLATE_EXTENSIONS         157
#define IDS_CRITICAL_EXTENSION          157
#define IDD_SELECT_OIDS                 158
#define IDS_ONLY_ISSUE_END_ENTITIES     158
#define IDD_ADD_APPROVAL                159
#define IDS_SIGNATURE_REQUIREMENTS      159
#define IDB_TEMPLATES                   160
#define IDS_CERTIFICATE_TEMPLATES       160
#define IDS_PROPERTIES_OF_TEMPLATE_X    161
#define IDD_NEW_ISSUANCE_OID            162
#define IDS_DIGITAL_SIGNATURE           162
#define IDD_TEMPLATE_V2_REQUEST         163
#define IDS_NON_REPUDIATION             163
#define IDS_CERTIFICATE_SIGNING         164
#define IDD_VIEW_OIDS                   164
#define IDS_CRL_SIGNING                 165
#define IDS_ALLOW_KEY_EXCHANGE_ONLY_WITH_KEY_ENCRYPTION 166
#define IDS_ALLOW_KEY_EXCHANGE_WITHOUT_KEY_ENCRYPTION 167
#define IDD_CSP_SELECTION               167
#define IDS_ALLOW_ENCRYPTION_OF_USER_DATA 168
#define IDS_MAJOR_VERSION_NUMBER        169
#define IDS_MINOR_VERSION_NUMBER        170
#define IDS_TEMPLATE_NAME               171
#define IDS_VIEW_OIDS                   172
#define IDS_VIEW_OIDS_HINT              173
#define IDS_POLICY_NAME                 174
#define IDS_OID                         175
#define IDS_POLICY_TYPE                 176
#define IDS_CPS_LOCATION                177
#define IDS_UNABLE_TO_CLONE_TEMPLATE    178
#define IDS_CANNOT_ENUM_CERT_TEMPLATES  179
#define IDS_APPLICATION                 180
#define IDS_ISSUANCE                    181
#define IDS_INSTALL_WINDOWS2002_CERT_TEMPLATES 182
#define IDS_INSTALL_FAILURE_WINDOWS2002_CERT_TEMPLATES 183
#define IDS_INSTALL_SUCCESS_WINDOWS2002_CERT_TEMPLATES 184
#define IDS_NONE                        185
#define IDS_CANNOT_LOAD_OID_LIST        186
#define IDS_FRIENDLY_NAME_ALREADY_USED  187
#define IDS_CSP_SELECTION               188
#define IDS_NO_SELECTED_CSPS            189
#define IDS_COLUMN_CERT_TEMPLATE_OBJECT 190
#define IDS_CPS_MUST_START_WITH_HTTP_OR_HTTPS 191
#define IDS_COLUMN_CERT_TEMPLATE_TYPE   193
#define IDC_VALIDITY_UNITS              252
#define IDC_VALIDITY_EDIT               254
#define IDC_RENEWAL_UNITS               255
#define IDC_RENEWAL_EDIT                256
#define IDC_TEMPLATE_VERSION            258
#define IDC_SIGNATURE                   260
#define IDC_CSP_LIST                    262
#define IDC_EXPORT_PRIVATE_KEY          264
#define IDC_UPN                         264
#define IDC_EXTENSION_LIST              265
#define IDC_SHOW_DETAILS                267
#define IDC_ADD_APPROVAL                268
#define IDC_REMOVE_POLICY               269
#define IDC_CHECK_DIGITAL_SIGNATURE     270
#define IDC_CHECK_NON_REPUDIATION       271
#define IDC_CHECK_KEY_ENCIPHERMENT      272
#define IDC_CHECK_DATA_ENCIPHERMENT     273
#define IDC_CHECK_KEY_AGREEMENT         274
#define IDC_CHECK_CERT_SIGNING          275
#define IDC_CHECK_DECIPHERMENT_ONLY     277
#define IDS_CANT_DISPLAY_SNAPIN_HELP_TOPIC 278
#define IDC_NEW_EKU                     278
#define IDC_EKU_LIST                    279
#define IDC_OID_LIST                    280
#define IDC_NEW_APPLICATION_OID_NAME    281
#define IDC_NEW_APPLICATION_OID_VALUE   282
#define IDC_TEMPLATE_NAME               283
#define IDC_DISPLAY_NAME                284
#define IDC_SUPERCEDES_LABEL            285
#define IDC_SUPERCEDED_TEMPLATES_LIST   286
#define IDC_ADD_SUPERCEDED_TEMPLATE     287
#define IDC_REMOVE_SUPERCEDED_TEMPLATE  288
#define IDC_MINIMUM_KEYSIZE_VALUE       289
#define IDC_MINIMUM_KEYSIZE_LABEL       291
#define IDC_ARCHIVE_KEY_CHECK           292
#define IDC_INCLUDE_SYMMETRIC_ALGORITHMS_CHECK 293
#define IDC_TEMPLATE_LIST               294
#define IDC_TEMPLATE_PROPERTIES         295
#define IDC_ONLY_ISSUE_END_ENTITIES     297
#define IDC_POLICIES_LIST               298
#define IDC_REQUIRE_SUBJECT             300
#define IDC_SUBJECT_AND_SUBJECT_ALT_NAME 302
#define IDS_CERTTMPL_ROOT_NODE_NAME     304
#define IDC_EMAIL_NAME                  305
#define IDC_PUBLISH_TO_AD               306
#define IDB_EXTENSIONS                  308
#define IDC_SUBJECT_AND_BUILD_SUBJECT_BY_CA 311
#define IDC_SUBJECT_MUST_BE_MACHINE     312
#define IDC_SUBJECT_MUST_BE_USER        313
#define IDS_CERT_TEMPLATE_COUNT         316
#define IDC_ISSUANCE_POLICIES           316
#define IDC_NUM_SIG_REQUIRED_EDIT       317
#define IDS_CERT_TEMPLATE_COUNT_SINGLE  318
#define IDS_PROPERTIES                  323
#define IDS_DAYS                        324
#define IDC_BASIC_CONSTRAINTS_CRITICAL  324
#define IDS_WEEKS                       325
#define IDC_KEY_USAGE_CRITICAL          325
#define IDS_MONTHS                      326
#define IDC_POLICY_CRITICAL             326
#define IDS_YEARS                       327
#define IDS_CLONE_TEMPLATE              328
#define IDC_ADD_POLICY                  328
#define IDS_CLONE_TEMPLATE_HINT         329
#define IDS_VALID_FOR_AUTOENROLLMENT    330
#define IDS_ENTER_UNIQUE_TEMPLATE_NAME  331
#define IDC_NEW_OID                     331
#define IDS_UNABLE_TO_SAVE_CERT_TEMPLATE_CHANGES 332
#define IDC_OID_TYPE                    332
#define IDS_CANNOT_CHANGE_DISPLAY_NAME  333
#define IDS_CANNOT_CHANGE_TEMPLATE_NAME 334
#define IDC_SUBJECT_NAME_SUPPLIED_IN_REQUEST 334
#define IDS_MUST_TYPE_TEMPLATE_DISPLAY_NAME 335
#define IDC_SUBJECT_NAME_BUILT_BY_CA    335
#define IDS_COPY_OF_TEMPLATE            336
#define IDC_SUBJECT_NAME_NAME_COMBO     336
#define IDS_COPY_X_OF_TEMPLATE          337
#define IDC_EMAIL_IN_SUB                337
#define IDS_CERTIFICATE_EXTENSION       338
#define IDC_EMAIL_IN_ALT                338
#define IDC_DNS_NAME                    339
#define IDS_INVALID_FOR_AUTOENROLLMENT  339
#define IDC_SPN                         340
#define IDS_COLUMN_CERT_TEMPLATE_AUTOENROLLMENT 340
#define IDC_SUBJECT_NAME_NAME_LABEL     341
#define IDS_REENROLL_ALL_CERTS          341
#define IDS_REENROLL_ALL_CERTS_HINT     342
#define IDS_ALL_APPLICATION_OIDS        343
#define IDS_ALL_ISSUANCE_OIDS           344
#define IDC_POLICIES_LABEL              344
#define IDS_CANNOT_WRITE_MINKEYSIZE     345
#define IDC_PURPOSE_COMBO               346
#define IDS_SUBJECT_NAME_NONE           347
#define IDS_FULL_DN                     348
#define IDC_REMOVE_APPROVAL             348
#define IDC_APPROVAL_LIST               349
#define IDS_CN_ONLY                     350
#define IDC_SIGNATURE_OPTIONS           350
#define IDS_PROPERTIES_OF_NEW_TEMPLATE  351
#define IDC_CRL_SIGNING                 351
#define IDS_SIGNATURE                   352
#define IDC_ENCRYPTION_OPTIONS          352
#define IDS_ENCRYPTION                  353
#define IDC_EDIT_POLICY                 353
#define IDC_COPY_OID                    353
#define IDS_SIGNATURE_AND_ENCRYPTION    354
#define IDS_COLUMN_CERT_TEMPLATE_VERSION 355
#define IDS_AT_LEAST_1_NAME_OPTION_MUST_BE_CHECKED 356
#define IDS_CANNOT_WRITE_DISPLAY_NAME   357
#define IDS_CANNOT_WRITE_CPS            358
#define IDS_EFFECTIVE_APPLICATION_POLICIES 359
#define IDC_USE_AD_CERT_FOR_REENROLLMENT 359
#define IDS_EFFECTIVE_ISSUANCE_POLICIES 360
#define IDC_NEW_ISSUANCE_OID_NAME       360
#define IDC_NEW_ISSUANCE_OID_VALUE      361
#define IDS_CANNOT_DELETE_ISSUANCE_RA   361
#define IDC_CPS_EDIT                    362
#define IDC_TEMPLATE_NAME_LABEL         365
#define IDS_CANNOT_READ_CPS             365
#define IDS_OID_ALREADY_EXISTS          366
#define IDC_POLICIES_HINT               367
#define IDS_CANNOT_ADD_ISSUANCE_OID     367
#define IDC_PEND_ALL_REQUESTS           368
#define IDS_NO_EXTENSION_SELECTED       368
#define IDS_CANNOT_SAVE_APPLICATION_POLICY_EXTENSION 369
#define IDC_POLICY_TYPES                370
#define IDS_V2_EXTENSIONS_HELP_HINT     370
#define IDC_APPLICATION_POLICIES        371
#define IDS_EDIT_APPLICATION_POLICIES_EXTENSION 371
#define IDS_EDIT_ISSUANCE_POLICIES_EXTENSION 372
#define IDS_EDIT_APPLICATION_POLICY_HINT 373
#define IDC_APP_POLICY_LABEL            374
#define IDS_ADD_ISSUANCE_POLICY_HINT    374
#define IDC_ISSUANCE_POLICY_LABEL       375
#define IDS_NEW_ISSUANCE_POLICY_HINT    375
#define IDC_EXTENSION_DESCRIPTION       376
#define IDS_SUBJECT_TYPE_DESCRIPTION    376
#define IDC_EXTENSION_NAME              377
#define IDS_TEMPLATE_OID                377
#define IDS_TEMPLATE_INTERNAL_NAME      378
#define IDS_CERT_POLICY_KNOWN_AS_ISSUANCE_POLICY 379
#define IDS_COLUMN_SUPPORTED_CAS        380
#define IDC_DELETE_PERMANENTLY          381
#define IDS_DAY                         381
#define IDS_WEEK                        382
#define IDR_WHATS_THIS_CONTEXT_MENU1    383
#define IDS_MONTH                       383
#define IDC_CANT_CHANGE_TEMPLATE_NAME   384
#define IDS_YEAR                        384
#define IDC_NUM_SIG_REQUIRED_CHECK      385
#define IDS_MUST_HAVE_DOMAIN_AND_ENTERPRISE_ADMIN_RIGHTS_TO_INSTALL_CERT_TEMPLATES 385
#define IDC_REENROLLMENT_SAME_AS_ENROLLMENT 386
#define IDS_2_DAY_SMALLEST_VALIDITY     386
#define IDC_REENROLLMENT_REQUIRES_VALID_CERT 387
#define IDS_TEMPLATE_NAME_CONTAINS_INVALID_CHARS 387
#define IDC_POLICY_TYPES_LABEL          388
#define IDS_ROOTNODE_STATUSBAR_TEXT     388
#define IDS_ERROR_NO_SUCH_DOMAIN        389
#define IDC_EXTENSIONS_HELP_HINT        390
#define IDS_CSPS_NOT_INSTALLED_LOCALLY  390
#define IDC_NEW_APPLICATION_OID_HINT    391
#define IDS_SIGNATURE_AND_SMARTCARD_LOGON 391
#define IDC_ADD_POLICY_HINT             392
#define IDS_CANNOT_ENUM_CERT_TEMPLATES_CONTAINER_NOT_FOUND 392
#define IDC_NEW_ISSUANCE_POLICY_HINT    393
#define IDS_ISSUANCE_POLICIES           393
#define IDC_DISPLAY_NAME_LABEL          394
#define IDS_NO_ENTERPRISE_ADMIN_RIGHTS  394
#define IDS_NO_DOMAIN_ADMIN_RIGHTS      395
#define IDC_USE_ANY_CSP                 395
#define IDS_NO_ENTERPRISE_OR_DOMAIN_ADMIN_RIGHTS 396
#define IDC_USE_SELECTED_CSPS           396
#define IDC_CSPS                        397
#define IDS_CANNOT_SAVE_FRIENDLY_NAME   397
#define IDC_ENROLL_WITHOUT_INPUT        398
#define IDC_ENROLL_PROMPT_USER          399
#define IDC_ENROLL_PROMPT_USER_REQUIRE_IF_PRIVATE_KEY 400
#define IDC_LABEL                       401
#define IDC_PURPOSE_LABEL               402
#define IDC_INPUT_LABEL                 403
#define IDC_CSP_LABEL                   404
#define IDC_CSP_LIST_LABEL              405
#define IDM_WHATS_THIS                  430

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        168
#define _APS_NEXT_COMMAND_VALUE         121
#define _APS_NEXT_CONTROL_VALUE         406
#define _APS_NEXT_SYMED_VALUE           121
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\policyoid.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2002.
//
//  File:       PolicyOID.h
//
//  Contents:   CPolicyOID
//
//----------------------------------------------------------------------------

#ifndef __POLICYOID_H_INCLUDED__
#define __POLICYOID_H_INCLUDED__

class CPolicyOID {
public:
	void SetDisplayName (const CString& szDisplayName);
	bool IsApplicationOID () const;
	bool IsIssuanceOID () const;
    CPolicyOID (const CString& szOID, const CString& szDisplayName, 
            ADS_INTEGER flags, bool bCanRename = true);
    virtual ~CPolicyOID ();

    CString GetOIDW () const
    {
        return m_szOIDW;
    }

    PCSTR GetOIDA () const
    {
        if ( m_pszOIDA )
            return m_pszOIDA;
        else
            return "";
    }

    CString GetDisplayName () const
    {
        return m_szDisplayName;
    }

    bool CanRename () const
    {
        return m_bCanRename;
    }

private:
	const ADS_INTEGER   m_flags;
    CString             m_szOIDW;
    CString             m_szDisplayName;
    PSTR                m_pszOIDA;
    const bool          m_bCanRename;
};

typedef CTypedPtrList<CPtrList, CPolicyOID*> POLICY_OID_LIST;

// NTRAID #572262 Certtmpl: Limit OID input UI to allow ( 20 elements * 2^28 ) 
//          == 200 characters + 19 dots for a total of 219 characters
#define MAX_OID_LEN  219

#endif // __POLICYOID_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\securitypropertypage.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998-2002
//
//  File:       SecurityPropertyPage.cpp
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////
//	casec.cpp
//
//	ISecurityInformation implementation for CA objects
//  and the new acl editor
//
//	PURPOSE

//
//
//  DYNALOADED LIBRARIES
//
//	HISTORY
//	5-Nov-1998		petesk		Copied template from privobsi.cpp sample.
//  6-Mar-2000      bryanwal    Modified to support cert templates
//
/////////////////////////////////////////////////////////////////////


#include <stdafx.h>
#include <accctrl.h>
//#include <certca.h>
#include <sddl.h>
#include "CertTemplate.h"

// Important, keep enroll GUID in sync with string define in certacl.h
const GUID GUID_ENROLL = { /* 0e10c968-78fb-11d2-90d4-00c04f79dc55 */
    0x0e10c968,
    0x78fb,
    0x11d2,
    {0x90, 0xd4, 0x00, 0xc0, 0x4f, 0x79, 0xdc, 0x55} };

const GUID GUID_AUTOENROLL = { /* a05b8cc2-17bc-4802-a710-e7c15ab866a2 */
    0xa05b8cc2,
    0x17bc,
    0x4802,
    {0xa7, 0x10, 0xe7, 0xc1, 0x5a, 0xb8, 0x66, 0xa2} };

//
// defined in Security.cpp 
//
// // define our generic mapping structure for our private objects // 


#define INHERIT_FULL            (CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE)

#define ACTRL_CERTSRV_ENROLL       (ACTRL_DS_CONTROL_ACCESS)

#define ACTRL_CERTSRV_MANAGE       (ACTRL_DS_READ_PROP | \
                                    ACTRL_DS_WRITE_PROP | \
                                    READ_CONTROL | \
                                    DELETE | \
                                    WRITE_DAC | \
                                    WRITE_OWNER | \
                                    ACTRL_DS_CONTROL_ACCESS | \
                                    ACTRL_DS_CREATE_CHILD | \
                                    ACTRL_DS_DELETE_CHILD | \
                                    ACTRL_DS_LIST | \
                                    ACTRL_DS_SELF | \
                                    ACTRL_DS_DELETE_TREE | \
                                    ACTRL_DS_LIST_OBJECT)

#define ACTRL_CERTSRV_READ           ( READ_CONTROL | \
                                       ACTRL_DS_READ_PROP | \
                                       ACTRL_DS_LIST )
#define ACTRL_CERTSRV_WRITE         ( WRITE_DAC | \
                                        WRITE_OWNER | \
                                        ACTRL_DS_WRITE_PROP )

GENERIC_MAPPING ObjMap = 
{     
    ACTRL_CERTSRV_READ,
    DELETE | WRITE_DAC | WRITE_OWNER | ACTRL_DS_WRITE_PROP,     
    0, 
    ACTRL_CERTSRV_MANAGE 
}; 


//
// DESCRIPTION OF ACCESS FLAG AFFECTS
//
// SI_ACCESS_GENERAL shows up on general properties page
// SI_ACCESS_SPECIFIC shows up on advanced page 
// SI_ACCESS_CONTAINER shows on general page IF object is a container
//
SI_ACCESS g_siV1ObjAccesses[] =
{
  { &GUID_NULL, 
    ACTRL_CERTSRV_MANAGE, 
    MAKEINTRESOURCE(IDS_ACTRL_CERTSRV_MANAGE), 
    SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
  { &GUID_NULL, 
    ACTRL_CERTSRV_READ, 
    MAKEINTRESOURCE(IDS_ACTRL_CERTSRV_READ), 
    SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
  { &GUID_NULL, 
    ACTRL_CERTSRV_WRITE, 
    MAKEINTRESOURCE(IDS_ACTRL_CERTSRV_WRITE), 
    SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
  { &GUID_ENROLL, 
    ACTRL_CERTSRV_ENROLL, 
    MAKEINTRESOURCE(IDS_ACTRL_ENROLL), 
    SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC }
};

SI_ACCESS g_siV2ObjAccesses[] =
{
  { &GUID_NULL, 
    ACTRL_CERTSRV_MANAGE, 
    MAKEINTRESOURCE(IDS_ACTRL_CERTSRV_MANAGE), 
    SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
  { &GUID_NULL, 
    ACTRL_CERTSRV_READ, 
    MAKEINTRESOURCE(IDS_ACTRL_CERTSRV_READ), 
    SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
  { &GUID_NULL, 
    ACTRL_CERTSRV_WRITE, 
    MAKEINTRESOURCE(IDS_ACTRL_CERTSRV_WRITE), 
    SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
  { &GUID_ENROLL, 
    ACTRL_CERTSRV_ENROLL, 
    MAKEINTRESOURCE(IDS_ACTRL_ENROLL), 
    SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
  { &GUID_AUTOENROLL,
    ACTRL_CERTSRV_ENROLL, 
    MAKEINTRESOURCE(IDS_ACTRL_AUTOENROLL), 
    SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC }
};


#define g_iObjDefAccess    1   // DS_GENERIC_READ

// The following array defines the inheritance types for my containers.
SI_INHERIT_TYPE g_siObjInheritTypes[] =
{
    &GUID_NULL, 0,                                            MAKEINTRESOURCE(IDS_INH_NONE),
};


class CCertTemplateSecurityObject : public ISecurityInformation
{
protected:
    ULONG                   m_cRef;
    CCertTemplate *         m_pCertTemplate;
    PSECURITY_DESCRIPTOR    m_pSD;

public:
    CCertTemplateSecurityObject() : m_cRef(1),
        m_pCertTemplate (0),
        m_pSD (0)
    { 
    }
    virtual ~CCertTemplateSecurityObject();

    STDMETHOD(Initialize)(CCertTemplate *pCertTemplate);

    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID, LPVOID *);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    
    // ISecurityInformation methods
    STDMETHOD(GetObjectInformation)(PSI_OBJECT_INFO pObjectInfo);
    STDMETHOD(GetSecurity)(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR *ppSD,
                           BOOL fDefault);
    STDMETHOD(SetSecurity)(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR pSD);
    STDMETHOD(GetAccessRights)(const GUID* pguidObjectType,
                               DWORD dwFlags,
                               PSI_ACCESS *ppAccess,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess);
    STDMETHOD(MapGeneric)(const GUID *pguidObjectType,
                          UCHAR *pAceFlags,
                          ACCESS_MASK *pmask);
    STDMETHOD(GetInheritTypes)(PSI_INHERIT_TYPE *ppInheritTypes,
                               ULONG *pcInheritTypes);
    STDMETHOD(PropertySheetPageCallback)(HWND hwnd,
                                         UINT uMsg,
                                         SI_PAGE_TYPE uPage);
};

///////////////////////////////////////////////////////////////////////////////
//
//  This is the entry point function called from our code that establishes
//  what the ACLUI interface is going to need to know.
//
//
///////////////////////////////////////////////////////////////////////////////


HRESULT CreateCertTemplateSecurityInfo (
                        CCertTemplate *pCertTemplate,
                        LPSECURITYINFO *ppObjSI)
{
    _TRACE (1, L"Entering CreateCertTemplateSecurityInfo\n");
    ASSERT (pCertTemplate && ppObjSI);
    if ( !pCertTemplate || !ppObjSI )
        return E_POINTER;

    HRESULT                     hr = S_OK;
    CCertTemplateSecurityObject *psi = new CCertTemplateSecurityObject;
    if ( psi)
    {
        *ppObjSI = NULL;

        hr = psi->Initialize (pCertTemplate);
        if ( SUCCEEDED (hr) )
            *ppObjSI = psi;
        else
            delete psi;
    }
    else 
        hr = E_OUTOFMEMORY;;


    _TRACE (-1, L"Leaving CreateCertTemplateSecurityInfo: 0x%x\n", hr);
    return hr;
}


CCertTemplateSecurityObject::~CCertTemplateSecurityObject()
{
    if ( m_pSD )
    {
        LocalFree (m_pSD);
    }
    if ( m_pCertTemplate )
        m_pCertTemplate->Release ();
}

STDMETHODIMP
CCertTemplateSecurityObject::Initialize(CCertTemplate *pCertTemplate)
{
    _TRACE (1, L"Entering CCertTemplateSecurityObject::Initialize\n");
    HRESULT hr = S_OK;

    if ( pCertTemplate )
    {
        m_pCertTemplate = pCertTemplate;
        m_pCertTemplate->AddRef ();

        hr = pCertTemplate->GetSecurity (&m_pSD);
    }
    else
        hr = E_POINTER;

    _TRACE (-1, L"Leaving CCertTemplateSecurityObject::Initialize: 0x%x\n", hr);
    return hr;
}


///////////////////////////////////////////////////////////
//
// IUnknown methods
//
///////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CCertTemplateSecurityObject::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CCertTemplateSecurityObject::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CCertTemplateSecurityObject::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ISecurityInformation))
    {
        *ppv = (LPSECURITYINFO)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


///////////////////////////////////////////////////////////
//
// ISecurityInformation methods
//
///////////////////////////////////////////////////////////

STDMETHODIMP
CCertTemplateSecurityObject::GetObjectInformation(PSI_OBJECT_INFO pObjectInfo)
{
    if ( pObjectInfo == NULL )
    {
        return E_POINTER;
    }
    if ( m_pCertTemplate == NULL )
    {
        return E_POINTER;
    }

    // security review 2/21/2002 BryanWal ok
    ZeroMemory(pObjectInfo, sizeof (SI_OBJECT_INFO));
    pObjectInfo->dwFlags = SI_EDIT_ALL | SI_NO_ACL_PROTECT | SI_ADVANCED | SI_NO_ADDITIONAL_PERMISSION; 
    if ( m_pCertTemplate->ReadOnly () )
        pObjectInfo->dwFlags |= SI_READONLY;

    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    pObjectInfo->hInstance = AfxGetResourceHandle (); //AfxGetInstanceHandle ();

    pObjectInfo->pszObjectName = const_cast<WCHAR *>((LPCTSTR)m_pCertTemplate->GetLDAPPath ());
    return S_OK;
}

STDMETHODIMP
CCertTemplateSecurityObject::GetSecurity(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR *ppSD,
                           BOOL fDefault)
{
    _TRACE (1, L"Entering CCertTemplateSecurityObject::GetSecurity\n");
    HRESULT                     hr = S_OK;
    DWORD                       dwLength = 0;
    SECURITY_DESCRIPTOR_CONTROL Control = SE_DACL_PROTECTED;
    DWORD                       dwRevision = 0;

    *ppSD = NULL;

    if (fDefault)
        return E_NOTIMPL;

    //
    // Assume that required privileges have already been enabled
    //


    hr = S_OK;

    // find out out much to allocate
    if ( !GetPrivateObjectSecurity(m_pSD, si, NULL, 0, &dwLength) )
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        if ( hr == HRESULT_FROM_WIN32 (ERROR_INSUFFICIENT_BUFFER) && dwLength )
        {
            hr = S_OK;
            // allocate and
            *ppSD = LocalAlloc(LPTR, dwLength);
            if (*ppSD )
            {
                // retrieve
                if ( GetPrivateObjectSecurity (m_pSD, si, *ppSD, dwLength, &dwLength) )
                {
                    if ( GetSecurityDescriptorControl(m_pSD, &Control, &dwRevision))
                    {
                        Control &= SE_DACL_PROTECTED | SE_DACL_AUTO_INHERIT_REQ | SE_DACL_AUTO_INHERITED;
                        // security review 2/21/2002 BryanWal ok - if it ain't broke, don't fix it
                        SetSecurityDescriptorControl (*ppSD, 
                                SE_DACL_PROTECTED | SE_DACL_AUTO_INHERIT_REQ | SE_DACL_AUTO_INHERITED, 
                                Control);
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32 (GetLastError ());
                        _TRACE (0, L"GetSecurityDescriptorControl failed: 0x%x\n", hr);
                    }
                }
                else
                {
                    _TRACE (0, L"GetPrivateObjectSecurity failed: 0x%x\n", hr);
                    hr = GetLastError();
                    LocalFree(*ppSD);
                    *ppSD = NULL;
                }
            }
            else
                hr = E_OUTOFMEMORY;
        }
        else if ( FAILED (hr) )
        {
            _TRACE (0, L"GetPrivateObjectSecurity failed: 0x%x\n", hr);
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
    }

    _TRACE (-1, L"Leaving CCertTemplateSecurityObject::GetSecurity: 0x%x\n", hr);
    return hr;
}

STDMETHODIMP
CCertTemplateSecurityObject::SetSecurity(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR pSD)
{
    HRESULT                     hr = S_OK;
    HANDLE                      hClientToken = NULL;
    HANDLE                      hHandle = NULL;
    SECURITY_DESCRIPTOR_CONTROL Control = SE_DACL_PROTECTED;
    DWORD                       dwRevision = 0;


    hHandle = GetCurrentThread();
    if (NULL == hHandle)
    {
        hr = HRESULT_FROM_WIN32 (GetLastError());
    }
    else
    {
        if (!OpenThreadToken(hHandle,
                             TOKEN_QUERY,
                             TRUE,  // open as self
                             &hClientToken))
        {
            hr = HRESULT_FROM_WIN32 (GetLastError());
            CloseHandle(hHandle);
            hHandle = NULL;
        }
    }
    
    if(hr != S_OK)
    {
        hHandle = GetCurrentProcess();
        if (NULL == hHandle)
        {
            hr = HRESULT_FROM_WIN32 (GetLastError());
        }
        else
        {
            HANDLE hProcessToken = NULL;
            hr = S_OK;


            if (!OpenProcessToken(hHandle,
                                 TOKEN_DUPLICATE,
                                 &hProcessToken))
            {
                hr = HRESULT_FROM_WIN32 (GetLastError());
                CloseHandle(hHandle);
                hHandle = NULL;
            }
            else
            {
                // security review 2/21/2002 BryanWal ok
                if(!DuplicateToken(hProcessToken,
                               SecurityImpersonation,
                               &hClientToken))
                {
                    hr = HRESULT_FROM_WIN32 (GetLastError());
                    CloseHandle(hHandle);
                    hHandle = NULL;
                }
                CloseHandle(hProcessToken);
            }
        }
    }

    if ( SUCCEEDED (hr) )
    {
        //
        // Assume that required privileges have already been enabled
        //
        if ( SetPrivateObjectSecurityEx (si, pSD, &m_pSD, SEF_DACL_AUTO_INHERIT, &ObjMap, hClientToken) )
        {
            if ( si & DACL_SECURITY_INFORMATION )
            {
                if ( GetSecurityDescriptorControl (pSD, &Control, &dwRevision) )
                {
                    Control &= SE_DACL_PROTECTED | SE_DACL_AUTO_INHERIT_REQ | SE_DACL_AUTO_INHERITED;
                    // security review 2/21/2002 BryanWal ok
                    SetSecurityDescriptorControl(m_pSD, 
                            SE_DACL_PROTECTED | SE_DACL_AUTO_INHERIT_REQ | SE_DACL_AUTO_INHERITED, 
                            Control);
                }
            }

            hr = m_pCertTemplate->SetSecurity (m_pSD);
        }
        else
        {
            hr = HRESULT_FROM_WIN32 (GetLastError());
            _TRACE (0, L"SetPrivateObjectSecurityEx () failed: 0x%x\n", hr);
        }
    }


    if ( hClientToken )
    {
        CloseHandle (hClientToken);
    }
    if ( hHandle )
    {
        CloseHandle (hHandle);
    }

    m_pCertTemplate->FailedToSetSecurity (FAILED (hr) ? true : false);

    return hr;
}

STDMETHODIMP
CCertTemplateSecurityObject::GetAccessRights(const GUID* /*pguidObjectType*/,
                               DWORD /*dwFlags*/,
                               PSI_ACCESS *ppAccesses,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess)
{
    if ( !ppAccesses || !pcAccesses || !piDefaultAccess )
        return E_POINTER;

    if ( 1 == m_pCertTemplate->GetType () )
    {
        *ppAccesses = g_siV1ObjAccesses;
        *pcAccesses = sizeof(g_siV1ObjAccesses)/sizeof(g_siV1ObjAccesses[0]);
    }
    else
    {
        *ppAccesses = g_siV2ObjAccesses;
        *pcAccesses = sizeof(g_siV2ObjAccesses)/sizeof(g_siV2ObjAccesses[0]);
    }
    *piDefaultAccess = g_iObjDefAccess;

    return S_OK;
}

STDMETHODIMP
CCertTemplateSecurityObject::MapGeneric(const GUID* /*pguidObjectType*/,
                          UCHAR * /*pAceFlags*/,
                          ACCESS_MASK *pmask)
{
    MapGenericMask(pmask, &ObjMap);

    return S_OK;
}

STDMETHODIMP
CCertTemplateSecurityObject::GetInheritTypes(PSI_INHERIT_TYPE *ppInheritTypes,
                               ULONG *pcInheritTypes)
{
    *ppInheritTypes = g_siObjInheritTypes;
    *pcInheritTypes = sizeof(g_siObjInheritTypes)/sizeof(g_siObjInheritTypes[0]);

    return S_OK;
}

STDMETHODIMP
CCertTemplateSecurityObject::PropertySheetPageCallback(HWND /*hwnd*/,
                                         UINT uMsg,
                                         SI_PAGE_TYPE /*uPage*/)
{
    if ( PSPCB_CREATE == uMsg )
        return E_NOTIMPL;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\selectcspdlg.cpp ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2002.
//
//  File:       SelectCSPDlg.cpp
//
//  Contents:   Implementation of CSelectCSPDlg
//
//----------------------------------------------------------------------------
//
// SelectCSPDlg.cpp : implementation file
//

#include "stdafx.h"
#include "certtmpl.h"
#include "SelectCSPDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSelectCSPDlg dialog


CSelectCSPDlg::CSelectCSPDlg(
        CWnd* pParent, 
        CCertTemplate& rCertTemplate, 
        CSP_LIST& rCSPList,
        int&    rnProvDSSCnt)
    : CHelpDialog(CSelectCSPDlg::IDD, pParent),
    m_rCertTemplate (rCertTemplate),
    m_rCSPList (rCSPList),
    m_rnProvDSSCnt (rnProvDSSCnt),
    m_nSelected (0),
    m_bDirty (false)
{
    //{{AFX_DATA_INIT(CSelectCSPDlg)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}


void CSelectCSPDlg::DoDataExchange(CDataExchange* pDX)
{
    CHelpDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CSelectCSPDlg)
    DDX_Control(pDX, IDC_CSP_LIST, m_CSPListbox);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSelectCSPDlg, CHelpDialog)
    //{{AFX_MSG_MAP(CSelectCSPDlg)
    ON_BN_CLICKED(IDC_USE_ANY_CSP, OnUseAnyCsp)
    ON_BN_CLICKED(IDC_USE_SELECTED_CSPS, OnUseSelectedCsps)
    //}}AFX_MSG_MAP
    ON_CONTROL(CLBN_CHKCHANGE, IDC_CSP_LIST, OnCheckChange)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSelectCSPDlg message handlers

BOOL CSelectCSPDlg::OnInitDialog() 
{
    CHelpDialog::OnInitDialog();
    
    CString szCSP;
    CString szInvalidCSPs;

    for (POSITION nextPos = m_rCSPList.GetHeadPosition (); nextPos; )
    {
        CT_CSP_DATA* pCSPData = m_rCSPList.GetNext (nextPos);
        if ( pCSPData )
        {
            if ( pCSPData->m_bConforming )
            {
                int nIndex = m_CSPListbox.AddString (pCSPData->m_szName);
                ASSERT (nIndex >= 0);
                if ( nIndex >= 0 )
                {
                    if ( pCSPData->m_bSelected )
                    {
                        m_CSPListbox.SetCheck (nIndex, BST_CHECKED);
                        m_nSelected++;
                    }
                    VERIFY (LB_ERR != m_CSPListbox.SetItemData (nIndex, (DWORD_PTR) pCSPData));
                }
                else
                {
                    break;
                }
            }
        }
    }

    if ( m_nSelected > 0 )
        SendDlgItemMessage (IDC_USE_SELECTED_CSPS, BM_SETCHECK, BST_CHECKED);
    else
        SendDlgItemMessage (IDC_USE_ANY_CSP, BM_SETCHECK, BST_CHECKED);

    EnableControls ();
    
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


void CSelectCSPDlg::EnableControls ()
{
    if (  m_rCertTemplate.ReadOnly () )
    {
        GetDlgItem (IDC_LABEL)->EnableWindow (FALSE);
        GetDlgItem (IDC_USE_ANY_CSP)->EnableWindow (FALSE);
        GetDlgItem (IDC_USE_SELECTED_CSPS)->EnableWindow (FALSE);

        GetDlgItem (IDC_CSP_LIST_LABEL)->EnableWindow (FALSE);
        int nCnt = m_CSPListbox.GetCount ();
        for (int nIndex = 0; nIndex < nCnt; nIndex++)
            m_CSPListbox.Enable (nIndex, FALSE);

        GetDlgItem (IDOK)->EnableWindow (FALSE);
    }
    else
    {
        BOOL bEnable = FALSE;
        if ( BST_CHECKED == SendDlgItemMessage (IDC_USE_SELECTED_CSPS, BM_GETCHECK) )
            bEnable = TRUE;

        GetDlgItem (IDC_CSP_LIST_LABEL)->EnableWindow (bEnable);
        int nCnt = m_CSPListbox.GetCount ();
        for (int nIndex = 0; nIndex < nCnt; nIndex++)
            m_CSPListbox.Enable (nIndex, bEnable);

        GetDlgItem (IDOK)->EnableWindow (m_bDirty ? TRUE : FALSE);
    }
}

void CSelectCSPDlg::DoContextHelp (HWND hWndControl)
{
    _TRACE(1, L"Entering CSelectCSPDlg::DoContextHelp\n");
    
    switch (::GetDlgCtrlID (hWndControl))
    {
    case IDC_STATIC:
    case IDC_CSP_LIST_LABEL:
        break;

    default:
        // Display context help for a control
        if ( !::WinHelp (
                hWndControl,
                GetContextHelpFile (),
                HELP_WM_HELP,
                (DWORD_PTR) g_aHelpIDs_IDD_CSP_SELECTION) )
        {
            _TRACE(0, L"WinHelp () failed: 0x%x\n", GetLastError ());        
        }
        break;
    }
    _TRACE(-1, L"Leaving CSelectCSPDlg::DoContextHelp\n");
}


void CSelectCSPDlg::OnCheckChange() 
{
    int nSel = m_CSPListbox.GetCurSel ();
    if ( nSel >= 0 )
    {
        if ( BST_CHECKED == m_CSPListbox.GetCheck (nSel) )
        {
            CT_CSP_DATA* pData = (CT_CSP_DATA*) m_CSPListbox.GetItemData (nSel);
            ASSERT (pData);
            if ( pData )
            {
                pData->m_bSelected = true;
                if ( PROV_DSS == pData->m_dwProvType || PROV_DSS_DH == pData->m_dwProvType )
                    m_rnProvDSSCnt++;
            }
            m_nSelected++;
        }
        else
        {
            CT_CSP_DATA* pData = (CT_CSP_DATA*) m_CSPListbox.GetItemData (nSel);
            ASSERT (pData);
            if ( pData )
            {
                pData->m_bSelected = false;
                if ( PROV_DSS == pData->m_dwProvType || PROV_DSS_DH == pData->m_dwProvType )
                    m_rnProvDSSCnt--;
            }
            m_nSelected--;
        }

        m_bDirty = true;
    }
    ASSERT (m_nSelected >= 0);

    EnableControls ();
} 


void CSelectCSPDlg::OnUseAnyCsp() 
{
    // clear all checks and selection
    int nCnt = m_CSPListbox.GetCount ();
    for (int nIndex = 0; nIndex < nCnt; nIndex++)
    {
        m_CSPListbox.SetCheck (nIndex, BST_UNCHECKED);
    }

    for (POSITION nextPos = m_rCSPList.GetHeadPosition (); nextPos; )
    {
        CT_CSP_DATA* pCSPData = m_rCSPList.GetNext (nextPos);
        if ( pCSPData )
        {
            if ( pCSPData->m_bSelected )
            {
                pCSPData->m_bSelected = false;
                m_bDirty = true;
            }
        }
    }

    EnableControls ();
}

void CSelectCSPDlg::OnUseSelectedCsps() 
{
    EnableControls ();  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\selectcspdlg.h ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2002.
//
//  File:       SelectCSPDlg.h
//
//  Contents:   Definition of CSelectCSPDlg
//
//----------------------------------------------------------------------------
#if !defined(AFX_SELECTCSPDLG_H__D54310EF_E70D_4911_B40C_7F20C87B9893__INCLUDED_)
#define AFX_SELECTCSPDLG_H__D54310EF_E70D_4911_B40C_7F20C87B9893__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SelectCSPDlg.h : header file
//
#include "CertTemplate.h"
#include "TemplateV1RequestPropertyPage.h"


class CT_CSP_DATA
{
public:
    CT_CSP_DATA (PCWSTR pszName, DWORD dwProvType, DWORD dwSigMaxKeySize, DWORD dwKeyExMaxKeySize)
        : m_szName (pszName),
        m_dwProvType (dwProvType),
        m_dwSigMaxKeySize (dwSigMaxKeySize),
        m_dwKeyExMaxKeySize (dwKeyExMaxKeySize),
        m_bConforming (false),
        m_bSelected (false)
    {
    }

    CString m_szName;
    DWORD   m_dwProvType;
    DWORD   m_dwSigMaxKeySize;
    DWORD   m_dwKeyExMaxKeySize;
    bool    m_bConforming;
    bool    m_bSelected;
};

typedef CTypedPtrList<CPtrList, CT_CSP_DATA*> CSP_LIST;

/////////////////////////////////////////////////////////////////////////////
// CSelectCSPDlg dialog

class CSelectCSPDlg : public CHelpDialog
{
// Construction
public:
    CSelectCSPDlg(CWnd* pParent, 
            CCertTemplate& rCertTemplate, 
            CSP_LIST& rCSPList,
            int& rnProvDSSCnt);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CSelectCSPDlg)
	enum { IDD = IDD_CSP_SELECTION };
	CSPCheckListBox	m_CSPListbox;
	//}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CSelectCSPDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    virtual void DoContextHelp (HWND hWndControl);
    void EnableControls ();

    // Generated message map functions
    //{{AFX_MSG(CSelectCSPDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnUseAnyCsp();
	afx_msg void OnUseSelectedCsps();
	//}}AFX_MSG
    afx_msg void OnCheckChange();
    DECLARE_MESSAGE_MAP()

private:
    CCertTemplate&  m_rCertTemplate;
    CSP_LIST&       m_rCSPList;
    int&            m_rnProvDSSCnt;
    int             m_nSelected;
    bool            m_bDirty;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SELECTCSPDLG_H__D54310EF_E70D_4911_B40C_7F20C87B9893__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\selectoiddlg.cpp ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2002.
//
//  File:       SelectOIDDlg.cpp
//
//  Contents:   Implementation of CSelectOIDDlg
//
//----------------------------------------------------------------------------
//

#include "stdafx.h"
#include "certtmpl.h"
#include "SelectOIDDlg.h"
#include "NewApplicationOIDDlg.h"
#include "NewIssuanceOIDDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSelectOIDDlg dialog

extern POLICY_OID_LIST      g_policyOIDList;

CSelectOIDDlg::CSelectOIDDlg(CWnd* pParent, PCERT_EXTENSION pCertExtension, 
        const bool bIsEKU,
        const PSTR* paszUsedOIDs)
    : CHelpDialog(CSelectOIDDlg::IDD, pParent),
    m_pCertExtension (pCertExtension),
    m_bIsEKU (bIsEKU),
    m_paszUsedOIDs (paszUsedOIDs),
    m_paszReturnedOIDs (0),
    m_paszReturnedFriendlyNames (0)
{
    //{{AFX_DATA_INIT(CSelectOIDDlg)
    //}}AFX_DATA_INIT
}

CSelectOIDDlg::~CSelectOIDDlg()
{
    if ( m_paszReturnedOIDs )
        delete [] m_paszReturnedOIDs;

    if ( m_paszReturnedFriendlyNames )
        delete [] m_paszReturnedFriendlyNames;
}


void CSelectOIDDlg::DoDataExchange(CDataExchange* pDX)
{
    CHelpDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CSelectOIDDlg)
    DDX_Control(pDX, IDC_OID_LIST, m_oidList);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSelectOIDDlg, CHelpDialog)
    //{{AFX_MSG_MAP(CSelectOIDDlg)
    ON_BN_CLICKED(IDC_NEW_OID, OnNewOid)
    ON_LBN_SELCHANGE(IDC_OID_LIST, OnSelchangeOidList)
    ON_WM_DESTROY()
    ON_LBN_DBLCLK(IDC_OID_LIST, OnDblclkOidList)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSelectOIDDlg message handlers

void CSelectOIDDlg::OnNewOid() 
{
    INT_PTR iRet = 0;
    CString szFriendlyName;
    CString szOID;

    if ( m_bIsEKU )
    {
        CNewApplicationOIDDlg  dlg (this);

        CThemeContextActivator activator;
        iRet = dlg.DoModal ();
        if (IDOK == iRet )
        {
            szFriendlyName = dlg.m_oidFriendlyName;
            szOID = dlg.m_oidValue;
        }
    }
    else
    {
        CNewIssuanceOIDDlg  dlg (this);

        CThemeContextActivator activator;
        iRet = dlg.DoModal ();
        if (IDOK == iRet )
        {
            szFriendlyName = dlg.m_oidFriendlyName;
            szOID = dlg.m_oidValue;
        }
    }
    if ( IDOK == iRet )
    {
        CPolicyOID* pPolicyOID = new CPolicyOID (szOID, szFriendlyName,
            m_bIsEKU ? CERT_OID_TYPE_APPLICATION_POLICY : CERT_OID_TYPE_ISSUER_POLICY);
        if ( pPolicyOID )
        {
            g_policyOIDList.AddTail (pPolicyOID);
            int nIndex = m_oidList.AddString (szFriendlyName);
            if ( nIndex >= 0 )
            {
                m_oidList.SetItemData (nIndex, (DWORD_PTR) new CString (szOID));
                VERIFY (LB_ERR != m_oidList.SetSel (nIndex, TRUE));
                VERIFY (LB_ERR !=m_oidList.SetTopIndex (nIndex));
                EnableControls ();
            }
        }
    }
}

BOOL CSelectOIDDlg::OnInitDialog() 
{
    CHelpDialog::OnInitDialog();
    
    CString text;

    if ( m_bIsEKU )
        VERIFY (text.LoadString (IDS_ALL_APPLICATION_OIDS));
    else
    {
        VERIFY (text.LoadString (IDS_ADD_ISSUANCE_POLICY));
        SetWindowText (text);

        VERIFY (text.LoadString (IDS_ADD_ISSUANCE_POLICY_HINT));
        SetDlgItemText (IDC_ADD_POLICY_HINT, text);

        VERIFY (text.LoadString (IDS_ALL_ISSUANCE_OIDS));
    }

    SetDlgItemText (IDC_OID_TYPE, text);

    

    for (POSITION nextPos = g_policyOIDList.GetHeadPosition (); nextPos; )
    {
        CPolicyOID* pPolicyOID = g_policyOIDList.GetNext (nextPos);
        if ( pPolicyOID )
        {
            // If this is the Application OID dialog, show only application 
            // OIDS, otherwise if this is the Issuance OID dialog, show only
            // issuance OIDs
            if ( (m_bIsEKU && pPolicyOID->IsApplicationOID ()) ||
                 (!m_bIsEKU && pPolicyOID->IsIssuanceOID ()) )
            {
                bool bFound = false;

                // Don't display an OID that's already been used
                if ( m_paszUsedOIDs )
                {
                    for (int nIndex = 0; m_paszUsedOIDs[nIndex]; nIndex++)
                    {
                        if ( !strcmp (pPolicyOID->GetOIDA (), m_paszUsedOIDs[nIndex]) )
                        {
                            bFound = true;
                            break;
                        }
                    }
                }

                if ( !bFound )
                {
                    int nIndex = m_oidList.AddString (pPolicyOID->GetDisplayName ());
                    if ( nIndex >= 0 )
                    {
                        m_oidList.SetItemData (nIndex, 
                                (DWORD_PTR) new CString (pPolicyOID->GetOIDW ()));
                    }
                }
            }
        }
    }

    EnableControls ();

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CSelectOIDDlg::DoContextHelp (HWND hWndControl)
{
    _TRACE(1, L"Entering CSelectOIDDlg::DoContextHelp\n");
    
    switch (::GetDlgCtrlID (hWndControl))
    {
    case IDC_OID_TYPE:
    case IDC_STATIC:
        break;

    default:
        // Display context help for a control
        if ( !::WinHelp (
                hWndControl,
                GetContextHelpFile (),
                HELP_WM_HELP,
                (DWORD_PTR) g_aHelpIDs_IDD_SELECT_OIDS) )
        {
            _TRACE(0, L"WinHelp () failed: 0x%x\n", GetLastError ());        
        }
        break;
    }
    _TRACE(-1, L"Leaving CSelectOIDDlg::DoContextHelp\n");
}


void CSelectOIDDlg::OnOK() 
{
    UpdateData (TRUE);
    
    int nSelCnt = m_oidList.GetSelCount ();
    if ( nSelCnt > 0 )
    {
        int* pnSelItems = new int[nSelCnt];
        if ( pnSelItems )
        {
            if ( LB_ERR != m_oidList.GetSelItems (nSelCnt, pnSelItems) )
            {
                m_paszReturnedOIDs = new CString[nSelCnt+1];
                if ( m_paszReturnedOIDs )
                {
                    m_paszReturnedFriendlyNames = new CString[nSelCnt+1];
                    if ( m_paszReturnedFriendlyNames )
                    {
                        for (int nIndex = 0; nIndex < nSelCnt; nIndex++)
                        {
                            m_paszReturnedOIDs[nIndex] = *(CString*) m_oidList.GetItemData (pnSelItems[nIndex]);
                            m_oidList.GetText (pnSelItems[nIndex], m_paszReturnedFriendlyNames[nIndex]);
                        }
                    }
                }
            }
            delete [] pnSelItems;
        }
    }

    CHelpDialog::OnOK();
}

void CSelectOIDDlg::EnableControls ()
{
    int nSel = m_oidList.GetSelCount ();
    GetDlgItem (IDOK)->EnableWindow (nSel >= 0);
}

void CSelectOIDDlg::OnSelchangeOidList() 
{
    EnableControls ();  
}

void CSelectOIDDlg::OnDestroy() 
{
    CHelpDialog::OnDestroy();
    
    int nCnt = m_oidList.GetCount ();
    for (int nIndex = 0; nIndex < nCnt; nIndex++)
    {
        CString* pszOID = (CString*) m_oidList.GetItemData (nIndex);
        if ( pszOID )
            delete pszOID;
    }
}

void CSelectOIDDlg::OnDblclkOidList() 
{
    OnOK ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\selectoiddlg.h ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2002.
//
//  File:       SelectOIDDlg.h
//
//  Contents:   Definition of CSelectOIDDlg
//
//----------------------------------------------------------------------------
#if !defined(AFX_SELECTOIDDLG_H__519FA306_5A24_4A7D_B37C_7D1715742911__INCLUDED_)
#define AFX_SELECTOIDDLG_H__519FA306_5A24_4A7D_B37C_7D1715742911__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SelectOIDDlg.h : header file
//
#include "PolicyOID.h"

/////////////////////////////////////////////////////////////////////////////
// CSelectOIDDlg dialog

class CSelectOIDDlg : public CHelpDialog
{
// Construction
public:
	~CSelectOIDDlg();
	CSelectOIDDlg(CWnd* pParent, PCERT_EXTENSION pCertExtension, 
            const bool bIsEKU,
            const PSTR* paszUsedOIDs);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CSelectOIDDlg)
	enum { IDD = IDD_SELECT_OIDS };
	CListBox	m_oidList;
	//}}AFX_DATA
    CString*            m_paszReturnedOIDs;
    CString*            m_paszReturnedFriendlyNames;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSelectOIDDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    void EnableControls ();
	virtual void DoContextHelp (HWND hWndControl);

	// Generated message map functions
	//{{AFX_MSG(CSelectOIDDlg)
	afx_msg void OnNewOid();
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnSelchangeOidList();
	afx_msg void OnDestroy();
	afx_msg void OnDblclkOidList();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	const bool          m_bIsEKU;
    PCERT_EXTENSION     m_pCertExtension;
    const PSTR*         m_paszUsedOIDs;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SELECTOIDDLG_H__519FA306_5A24_4A7D_B37C_7D1715742911__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\shellext.h ===
/*++

Copyright (C) Microsoft Corporation, 1998-2001

Module Name:

    ShellExt.h

Abstract:
    This is the header for the Cert Type shell extension object.

Author:

    petesk 27-aug-98

Environment:
	
	 NT only.
--*/


#ifndef __CTSHLEXT_H_
#define __CTSHLEXT_H_


#include <shlobj.h>
#include "CertTemplate.h"

/////////////////////////////////////////////////////////////////////////////
// CDfsShell
class ATL_NO_VTABLE CCertTemplateShellExt : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CCertTemplateShellExt, &CLSID_CertTemplateShellExt>,
	public IShellExtInit,
	public IShellPropSheetExt,
    public IContextMenu
{
public:
	CCertTemplateShellExt();
	virtual ~CCertTemplateShellExt();

    //Simple ALL 1.0 based registry entry
    DECLARE_REGISTRY(   CCertTemplateShellExt,
                        _T("CERTTMPL.CCertTemplateShellExt.1"),
                        _T("CERTTMPL.CCertTemplateShellExt"),
                        IDS_CERTTEMPLATESHELLEXT_DESC,
                        THREADFLAGS_APARTMENT)

BEGIN_COM_MAP(CCertTemplateShellExt)
	COM_INTERFACE_ENTRY(IShellExtInit)
	COM_INTERFACE_ENTRY(IShellPropSheetExt)
	COM_INTERFACE_ENTRY(IContextMenu)
END_COM_MAP()

// IDfsShell
public:


// IShellExtInit Methods

	STDMETHOD (Initialize)
	(
		IN LPCITEMIDLIST	pidlFolder,		// Points to an ITEMIDLIST structure
		IN LPDATAOBJECT	lpdobj,			// Points to an IDataObject interface
		IN HKEY			hkeyProgID		// Registry key for the file object or folder type
	);	

    //IShellPropSheetExt methods
    STDMETHODIMP AddPages
	(
		IN LPFNADDPROPSHEETPAGE lpfnAddPage, 
		IN LPARAM lParam
	);
    
    STDMETHODIMP ReplacePage
	(
		IN UINT uPageID, 
		IN LPFNADDPROPSHEETPAGE lpfnReplaceWith, 
		IN LPARAM lParam
	);

    // IContextMenu methods
    STDMETHODIMP GetCommandString
    (    
        UINT_PTR idCmd,    
        UINT uFlags,    
        UINT *pwReserved,
        LPSTR pszName,    
        UINT cchMax   
    );

    STDMETHODIMP InvokeCommand
    (    
        LPCMINVOKECOMMANDINFO lpici   
    );	



    STDMETHODIMP QueryContextMenu
    (
        HMENU hmenu,
        UINT indexMenu,
        UINT idCmdFirst,
        UINT idCmdLast,
        UINT uFlags
    );

protected:
    HRESULT AddVersion1CertTemplatePropPages (
            CCertTemplate* pCertTemplate, 
            LPFNADDPROPSHEETPAGE lpfnAddPage, 
            LPARAM lParam);
    HRESULT AddVersion2CertTemplatePropPages (
            CCertTemplate* pCertTemplate, 
            LPFNADDPROPSHEETPAGE lpfnAddPage, 
            LPARAM lParam);

private:

    DWORD           m_Count;
    CCertTemplate** m_apCertTemplates;
    UINT            m_uiEditId;


};

#endif //__CTSHLEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\selecttemplatedlg.h ===
#if !defined(AFX_SELECTTEMPLATEDLG_H__3974984C_4767_407B_ADE4_0017F635E553__INCLUDED_)
#define AFX_SELECTTEMPLATEDLG_H__3974984C_4767_407B_ADE4_0017F635E553__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SelectTemplateDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSelectTemplateDlg dialog

class CSelectTemplateDlg : public CHelpDialog
{
// Construction
public:
	CStringList m_returnedTemplates;
	CSelectTemplateDlg(CWnd* pParent, 
            const CCertTmplComponentData* pCompData,
            const CStringList& supercededNameList);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CSelectTemplateDlg)
	enum { IDD = IDD_SELECT_TEMPLATE };
	CListCtrl	m_templateList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSelectTemplateDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual void DoContextHelp (HWND hWndControl);
    int GetSelectedListItem();
	void EnableControls();

	// Generated message map functions
	//{{AFX_MSG(CSelectTemplateDlg)
	afx_msg void OnTemplateProperties();
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnItemchangedTemplateList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDblclkTemplateList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeleteitemTemplateList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
    const CStringList& m_supercededTemplateNameList;
    WTL::CImageList m_imageListSmall;
	WTL::CImageList m_imageListNormal;
    const CCertTmplComponentData* m_pCompData;

	enum {
		COL_CERT_TEMPLATE = 0,
        COL_CERT_VERSION, 
		NUM_COLS	// must be last
	};
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SELECTTEMPLATEDLG_H__3974984C_4767_407B_ADE4_0017F635E553__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__3BFC9651_7A55_11D0_B928_00C04FD8D5B0__INCLUDED_)
#define AFX_STDAFX_H__3BFC9651_7A55_11D0_B928_00C04FD8D5B0__INCLUDED_

#if _MSC_VER >= 1000
#pragma once 
#endif // _MSC_VER >= 1000

#define STRICT

#pragma warning(push,3)

#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>
#define NT_INCLUDED
#undef ASSERT
#undef ASSERTMSG

#include <afxwin.h>
#include <afxdisp.h>
#include <afxtempl.h> // CTypedPtrList
#include <afxdlgs.h>  // CPropertyPage
#include <afxcmn.h>     // CSpinButtonCtrl

//#define _WIN32_WINNT 0x0500
#define _ATL_APARTMENT_THREADED

#include <mmc.h>
#include "certtmpl.h"

EXTERN_C const CLSID CLSID_CertTemplatesSnapin;
EXTERN_C const CLSID CLSID_CertTemplateShellExt;

#include <xstring>
#include <list>
#include <vector>
#include <algorithm>

using namespace std;

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
/*
 * Define/include the stuff we need for WTL::CImageList.  We need prototypes
 * for IsolationAwareImageList_Read and IsolationAwareImageList_Write here
 * because commctrl.h only declares them if __IStream_INTERFACE_DEFINED__
 * is defined.  __IStream_INTERFACE_DEFINED__ is defined by objidl.h, which
 * we can't include before including afx.h because it ends up including
 * windows.h, which afx.h expects to include itself.  Ugh.
 */
HIMAGELIST WINAPI IsolationAwareImageList_Read(LPSTREAM pstm);
BOOL WINAPI IsolationAwareImageList_Write(HIMAGELIST himl,LPSTREAM pstm);
#define _WTL_NO_AUTOMATIC_NAMESPACE
#include <atlapp.h>
#include <atlwin.h>

#include <atlctrls.h>

#include <iads.h>
#include <adserr.h>
#include <adshlp.h>
#include <lmcons.h>

#include "stdcooki.h" // from ..\framewrk
#include "stdcmpnt.h" // from ..\framewrk
#include "stdcdata.h" // from ..\framewrk
#include "persist.h" // PersistStream   from ..\framewrk
#include "stdutils.h" // GetObjectType() utility routines from ..\corecopy
#include "stddtobj.h" // class DataObject   from ..\framewrk
#include "stdabout.h" // from ..\framewrk


#include "chooser.h" //                 from ..\chooser
#include "regkey.h" // AMC::CRegKey     from ..\corecopy
#include "safetemp.h"   // from ..\corecopy
#include "macros.h"
#include "guidhelp.h" // GuidToCString

#include <comstrm.h>

#include <strings.h>
#include <dssec.h>
#include <dsrole.h>
#include <lmapibuf.h>

#include <prsht.h>
#include <shlobj.h>
#include <dsclient.h>
#include <objsel.h>

#include <CertCA.h>
#include <wincrypt.h>

#include <shfusion.h>

#pragma warning(pop)


#include "DisabledWarnings.h"
#include "helpids.h"
#include "utils.h"
#include "resource.h"
#include "strconst.h"
#include "debug.h"
#include "helpmap.h"
#include "HelpPropertyPage.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__3BFC9651_7A55_11D0_B928_00C04FD8D5B0__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\shellext.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1997-2002

Module Name:

ShellExt.cpp

Abstract:
	This is the implementation file for Dfs Shell Extension object which implements
	IShellIExtInit and IShellPropSheetExt.

Author:

    Constancio Fernandes (ferns@qspl.stpp.soft.net) 12-Jan-1998

Environment:
	
	 NT only.
*/
    
#include "stdafx.h"
#include <dsclient.h>
#include "ShellExt.h"	
#include "TemplateGeneralPropertyPage.h"
#include "TemplateV1RequestPropertyPage.h"
#include "TemplateV2RequestPropertyPage.h"
#include "TemplateV1SubjectNamePropertyPage.h"
#include "TemplateV2SubjectNamePropertyPage.h"
#include "TemplateV2AuthenticationPropertyPage.h"
#include "TemplateV2SupercedesPropertyPage.h"
#include "TemplateExtensionsPropertyPage.h"
#include "SecurityPropertyPage.h"
#include "PolicyOID.h"

#define ByteOffset(base, offset) (((LPBYTE)base)+offset)

/*----------------------------------------------------------------------
					IShellExtInit Implementation.
------------------------------------------------------------------------*/
CCertTemplateShellExt::CCertTemplateShellExt()
    : m_Count (0),
    m_apCertTemplates (0),
    m_uiEditId (0)
{
}

CCertTemplateShellExt::~CCertTemplateShellExt()
{	
    if ( m_apCertTemplates )
    {
        for (int nIndex = 0; nIndex < m_Count; nIndex++)
        {
            if ( m_apCertTemplates[nIndex] )
                m_apCertTemplates[nIndex]->Release ();
        }
    }
}

STDMETHODIMP CCertTemplateShellExt::Initialize
(
	IN LPCITEMIDLIST	/*pidlFolder*/,		// Points to an ITEMIDLIST structure
	IN LPDATAOBJECT	    pDataObj,		// Points to an IDataObject interface
	IN HKEY			    /*hkeyProgID*/		// Registry key for the file object or folder type
)
{

  HRESULT hr = 0;
  FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
  STGMEDIUM medium = { TYMED_NULL };
  LPDSOBJECTNAMES pDsObjects;
  CString csClass, csPath;
  USES_CONVERSION;

  PWSTR wszTypeDN = 0;
  PWSTR wszTemplateName = 0;
  PWSTR wszType = 0;

  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  // if we have a pDataObj then try and get the first name from it

  if ( pDataObj ) 
  {
    // get path and class

    fmte.cfFormat = (CLIPFORMAT) RegisterClipboardFormat(CFSTR_DSOBJECTNAMES);
    if ( SUCCEEDED(pDataObj->GetData(&fmte, &medium)) ) 
    {
        pDsObjects = (LPDSOBJECTNAMES)medium.hGlobal;
        m_Count = pDsObjects->cItems;

        if(m_Count > 0)
        {

            m_apCertTemplates = (CCertTemplate **) ::LocalAlloc (
                    LPTR, sizeof(CCertTemplate*)*m_Count);
            if(m_apCertTemplates == NULL)
            {
              hr = E_OUTOFMEMORY;
              goto error;
            }

            for (UINT index = 0; index < m_Count ; index++) 
            {
                LPWSTR wszEnd = NULL;
                wszTypeDN = (LPWSTR)ByteOffset(pDsObjects, pDsObjects->aObjects[index].offsetName);
                if(wszTypeDN == NULL)
                {
                    continue;
                }
                wszTemplateName = wcsstr(wszTypeDN, L"CN=");
                if(wszTemplateName == NULL)
                {
                    continue;
                }
                wszTemplateName += 3;


                // security review 2/21/2002 BryanWal ok - worst case: wszTemplateName is "";
                wszType = (LPWSTR) ::LocalAlloc (LPTR, sizeof(WCHAR)*(wcslen(wszTemplateName)+1));
                if ( wszType == NULL )
                {
                    hr = E_OUTOFMEMORY;
                    goto error;
                }
                
                // security review 2/21/2002 BryanWal ok
                wcscpy (wszType, wszTemplateName);
                wszEnd = wcschr (wszType, L',');
                if ( wszEnd )
                {
                    *wszEnd = 0;
                }

                m_apCertTemplates[index] = new CCertTemplate (0, wszType, wszTypeDN, false, true);
                LocalFree(wszType);
                wszType = NULL;
            }

        }
        ReleaseStgMedium(&medium);
    }
  }
  hr = S_OK;                  // success
  
error:
  
  return hr;

}


STDMETHODIMP CCertTemplateShellExt::AddPages
(
	IN LPFNADDPROPSHEETPAGE lpfnAddPage, 
	IN LPARAM lParam
)

{
    HRESULT hr = S_OK;
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if(m_apCertTemplates[0] == NULL)
    {
        return E_UNEXPECTED;
    }

    DWORD dwType = m_apCertTemplates[0]->GetType ();
    switch (dwType)
    {
    case 1:
        hr = AddVersion1CertTemplatePropPages (m_apCertTemplates[0], lpfnAddPage, lParam);
        break;

    case 2:
        hr = AddVersion2CertTemplatePropPages (m_apCertTemplates[0], lpfnAddPage, lParam);
        break;

    default:
        _ASSERT (0);
        break;
    }

/*
    CCertTemplateGeneralPage* pControlPage = new CCertTemplateGeneralPage(m_apCertTemplates[0]);
    if(pControlPage)
    {
        pBasePage = pControlPage;
        HPROPSHEETPAGE hPage = MyCreatePropertySheetPage(&pBasePage->m_psp);
        if (hPage == NULL)
        {
            delete (pControlPage);
            return E_UNEXPECTED;
        }
        lpfnAddPage(hPage, lParam);                          
    }
*/                                                                         
    return hr;                                                            
}

HRESULT CCertTemplateShellExt::AddVersion1CertTemplatePropPages (CCertTemplate* pCertTemplate, LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
{
    _TRACE (1, L"Entering CCertTemplateShellExt::AddVersion1CertTemplatePropPages\n");
    HRESULT         hr = S_OK;
    _ASSERT (pCertTemplate && lpfnAddPage);
    if ( pCertTemplate && lpfnAddPage )
    {
        BOOL    bResult = FALSE;

        _ASSERT (1 == pCertTemplate->GetType ());

        // Add General page
        CTemplateGeneralPropertyPage * pGeneralPage = new CTemplateGeneralPropertyPage (
                *pCertTemplate, 0);
        if ( pGeneralPage )
        {
            HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pGeneralPage->m_psp);
            _ASSERT (hPage);
            if ( hPage )
            {
                bResult = lpfnAddPage (hPage, lParam);
                _ASSERT (bResult);
                if ( !bResult )
                    hr = E_FAIL;
            }
            else
                hr = E_FAIL;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        // Add Request page only if subject is not a CA
        if ( SUCCEEDED (hr) && !pCertTemplate->SubjectIsCA () )
        {
            CTemplateV1RequestPropertyPage * pRequestPage = new CTemplateV1RequestPropertyPage (*pCertTemplate);
            if ( pRequestPage )
            {
                HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pRequestPage->m_psp);
                _ASSERT (hPage);
                if ( hPage )
                {
                    bResult = lpfnAddPage (hPage, lParam);
                    _ASSERT (bResult);
                    if ( !bResult )
                        hr = E_FAIL;
                }
                else
                    hr = E_FAIL;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

    
        // Add Subject Name page only if subject is not a CA
        if ( SUCCEEDED (hr) && !pCertTemplate->SubjectIsCA () )
        {
            CTemplateV1SubjectNamePropertyPage * pSubjectNamePage = 
                    new CTemplateV1SubjectNamePropertyPage (*pCertTemplate);
            if ( pSubjectNamePage )
            {
                HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pSubjectNamePage->m_psp);
                _ASSERT (hPage);
                if ( hPage )
                {
                    bResult = lpfnAddPage (hPage, lParam);
                    _ASSERT (bResult);
                    if ( !bResult )
                        hr = E_FAIL;
                }
                else
                    hr = E_FAIL;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        // Add extensions page
        if ( SUCCEEDED (hr) )
        {
            CTemplateExtensionsPropertyPage * pExtensionsPage = 
                    new CTemplateExtensionsPropertyPage (*pCertTemplate, 
                    pGeneralPage->m_bIsDirty);
            if ( pExtensionsPage )
            {
                HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pExtensionsPage->m_psp);
                _ASSERT (hPage);
                if ( hPage )
                {
                    bResult = lpfnAddPage (hPage, lParam);
                    _ASSERT (bResult);
                    if ( !bResult )
                        hr = E_FAIL;
                }
                else
                    hr = E_FAIL;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        // Add security page
        if ( SUCCEEDED (hr) )
        {
            // if error, don't display this page
            LPSECURITYINFO pCertTemplateSecurity = NULL;

            hr = CreateCertTemplateSecurityInfo (pCertTemplate, 
                    &pCertTemplateSecurity);
            if ( SUCCEEDED (hr) )
            {
                // save the pCASecurity pointer for later releasing
                pGeneralPage->SetAllocedSecurityInfo (pCertTemplateSecurity);

                HPROPSHEETPAGE hPage = CreateSecurityPage (pCertTemplateSecurity);
                if (hPage == NULL)
                {
                    hr = HRESULT_FROM_WIN32 (GetLastError());
                    _TRACE (0, L"CreateSecurityPage () failed: 0x%x\n", hr);
                }
                bResult = lpfnAddPage (hPage, lParam);
                _ASSERT (bResult);
            }
        }
    }
    _TRACE (-1, L"Leaving CCertTemplateShellExt::AddVersion1CertTemplatePropPages: 0x%x\n", hr);
    return hr;
}

HRESULT CCertTemplateShellExt::AddVersion2CertTemplatePropPages (CCertTemplate* pCertTemplate, LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
{
    _TRACE (1, L"Entering CCertTemplateShellExt::AddVersion1CertTemplatePropPages\n");
    HRESULT         hr = S_OK;
    BOOL            bResult = FALSE;
    _ASSERT (pCertTemplate && lpfnAddPage);
    if ( pCertTemplate && lpfnAddPage )
    {
        _ASSERT (2 == pCertTemplate->GetType ());
        
        // Add General page
        CTemplateGeneralPropertyPage * pGeneralPage = new CTemplateGeneralPropertyPage (
                *pCertTemplate, 0);
        if ( pGeneralPage )
        {
			pGeneralPage->m_lNotifyHandle = 0; //lNotifyHandle;
            //m_lNotifyHandle = lNotifyHandle;
            HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pGeneralPage->m_psp);
            _ASSERT (hPage);
            if ( hPage )
            {
                bResult = lpfnAddPage (hPage, lParam);
                _ASSERT (bResult);
                if ( !bResult )
                    hr = E_FAIL;
            }
            else
                hr = E_FAIL;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        // Add Request page only if subject is not a CA
        if ( SUCCEEDED (hr) && !pCertTemplate->SubjectIsCA () )
        {
            CTemplateV2RequestPropertyPage * pRequestPage = 
                    new CTemplateV2RequestPropertyPage (*pCertTemplate,
                    pGeneralPage->m_bIsDirty);
            if ( pRequestPage )
            {
                HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pRequestPage->m_psp);
                _ASSERT (hPage);
                if ( hPage )
                {
                    bResult = lpfnAddPage (hPage, lParam);
                    _ASSERT (bResult);
                    if ( !bResult )
                        hr = E_FAIL;
                }
                else
                    hr = E_FAIL;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

    
        // Add Subject Name page only if subject is not a CA
        if ( SUCCEEDED (hr) && !pCertTemplate->SubjectIsCA () )
        {
            CTemplateV2SubjectNamePropertyPage * pSubjectNamePage = 
                    new CTemplateV2SubjectNamePropertyPage (*pCertTemplate,
                    pGeneralPage->m_bIsDirty);
            if ( pSubjectNamePage )
            {
                HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pSubjectNamePage->m_psp);
                _ASSERT (hPage);
                bResult = lpfnAddPage (hPage, lParam);
                _ASSERT (bResult);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }


        // Add Authentication Name page
        if ( SUCCEEDED (hr) )
        {
            CTemplateV2AuthenticationPropertyPage * pAuthenticationPage = 
                    new CTemplateV2AuthenticationPropertyPage (*pCertTemplate,
                    pGeneralPage->m_bIsDirty);
            if ( pAuthenticationPage )
            {
                HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pAuthenticationPage->m_psp);
                _ASSERT (hPage);
                if ( hPage )
                {
                    bResult = lpfnAddPage (hPage, lParam);
                    _ASSERT (bResult);
                    if ( !bResult )
                        hr = E_FAIL;
                }
                else
                    hr = E_FAIL;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        // Add Superceded page
        if ( SUCCEEDED (hr) )
        {
            CTemplateV2SupercedesPropertyPage * pSupercededPage = 
                    new CTemplateV2SupercedesPropertyPage (*pCertTemplate,
                    pGeneralPage->m_bIsDirty, 0);
            if ( pSupercededPage )
            {
                HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pSupercededPage->m_psp);
                _ASSERT (hPage);
                if ( hPage )
                {
                    bResult = lpfnAddPage (hPage, lParam);
                    _ASSERT (bResult);
                    if ( !bResult )
                        hr = E_FAIL;
                }
                else
                    hr = E_FAIL;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        // Add extensions page
        if ( SUCCEEDED (hr) )
        {
            CTemplateExtensionsPropertyPage * pExtensionsPage = 
                    new CTemplateExtensionsPropertyPage (*pCertTemplate, 
                    pGeneralPage->m_bIsDirty);
            if ( pExtensionsPage )
            {
                HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pExtensionsPage->m_psp);
                _ASSERT (hPage);
                if ( hPage )
                {
                    bResult = lpfnAddPage (hPage, lParam);
                    _ASSERT (bResult);
                    if ( !bResult )
                        hr = E_FAIL;
                }
                else
                    hr = E_FAIL;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }


        // Add security page
        if ( SUCCEEDED (hr) )
        {
            // if error, don't display this page
            LPSECURITYINFO pCertTemplateSecurity = NULL;

            hr = CreateCertTemplateSecurityInfo (pCertTemplate, 
                    &pCertTemplateSecurity);
            if ( SUCCEEDED (hr) )
            {
                // save the pCertTemplateSecurity pointer for later releasing
                pGeneralPage->SetAllocedSecurityInfo (pCertTemplateSecurity);

                HPROPSHEETPAGE hPage = CreateSecurityPage (pCertTemplateSecurity);
                if (hPage == NULL)
                {
                    hr = HRESULT_FROM_WIN32 (GetLastError());
                    _TRACE (0, L"CreateSecurityPage () failed: 0x%x\n", hr);
                }
                bResult = lpfnAddPage (hPage, lParam);
                _ASSERT (bResult);
            }
        }
    }
    _TRACE (-1, L"Leaving CCertTemplateShellExt::AddVersion1CertTemplatePropPages: 0x%x\n", hr);
    return hr;
}

STDMETHODIMP CCertTemplateShellExt::ReplacePage
(
	IN UINT /*uPageID*/, 
    IN LPFNADDPROPSHEETPAGE /*lpfnReplaceWith*/, 
    IN LPARAM /*lParam*/
)
{
    return E_FAIL;
}


// IContextMenu methods
STDMETHODIMP CCertTemplateShellExt::GetCommandString
(    
    UINT_PTR idCmd,    
    UINT uFlags,    
    UINT*   /*pwReserved*/,
    LPSTR pszName,    
    UINT cchMax   
)
{
    if((idCmd == m_uiEditId) && (m_uiEditId != 0))
    {
        if (uFlags == GCS_HELPTEXT)    
        {
            LoadString(AfxGetResourceHandle( ), IDS_EDIT_HINT, (LPTSTR)pszName, cchMax);
            return S_OK;    
        }    
    }
    return E_NOTIMPL;
}


STDMETHODIMP CCertTemplateShellExt::InvokeCommand
(    
    LPCMINVOKECOMMANDINFO lpici   
)
{
    if (!HIWORD(lpici->lpVerb))    
    {        
        UINT idCmd = LOWORD(lpici->lpVerb);
        switch(idCmd)
        {
        case 0: // Edit 
//            InvokeCertTypeWizard(m_ahCertTemplates[0],
//                             lpici->hwnd);
            return S_OK;

        }
    }

    return E_NOTIMPL;
}



STDMETHODIMP CCertTemplateShellExt::QueryContextMenu
(
    HMENU hmenu,
    UINT indexMenu,
    UINT idCmdFirst,
    UINT /*idCmdLast*/,
    UINT /*uFlags*/
)
{

    CString szEdit;
    MENUITEMINFO mii;
    UINT idLastUsedCmd = idCmdFirst;
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // security review 2/21/2002 BryanWal ok
    ZeroMemory (&mii, sizeof (mii));
    
    if ( IsCerttypeEditingAllowed () )
    {
        mii.cbSize = sizeof(mii);   
        mii.fMask = MIIM_TYPE | MIIM_ID;
        mii.fType = MFT_STRING;    
        mii.wID = idCmdFirst; 

        szEdit.LoadString(IDS_EDIT);

        mii.dwTypeData = (LPTSTR)(LPCTSTR)szEdit;
        mii.cch = szEdit.GetLength();


        // Add new menu items to the context menu.    //
        ::InsertMenuItem(hmenu, 
                     indexMenu++, 
                     TRUE,
                     &mii);

    }

    return ResultFromScode (MAKE_SCODE (SEVERITY_SUCCESS, 0,
                            USHORT (idLastUsedCmd  + 1)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\selecttemplatedlg.cpp ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2002.
//
//  File:       SelectTemplateDlg.cpp
//
//  Contents:   Implementation of CSelectTemplateDlg
//
//----------------------------------------------------------------------------
//

#include "stdafx.h"
#include "CompData.h"
#include "SelectTemplateDlg.h"
#include "CertTemplate.h"
#include "TemplateGeneralPropertyPage.h"
#include "TemplateV1RequestPropertyPage.h"
#include "TemplateV2RequestPropertyPage.h"
#include "TemplateV1SubjectNamePropertyPage.h"
#include "TemplateV2SubjectNamePropertyPage.h"
#include "TemplateV2AuthenticationPropertyPage.h"
#include "TemplateV2SupercedesPropertyPage.h"
#include "TemplateExtensionsPropertyPage.h"
#include "PolicyOID.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSelectTemplateDlg dialog


CSelectTemplateDlg::CSelectTemplateDlg(CWnd* pParent, 
        const CCertTmplComponentData* pCompData,
        const CStringList& supercededNameList)
	: CHelpDialog(CSelectTemplateDlg::IDD, pParent),
    m_supercededTemplateNameList (supercededNameList),
    m_pCompData (pCompData)
{
	//{{AFX_DATA_INIT(CSelectTemplateDlg)
	//}}AFX_DATA_INIT
}


void CSelectTemplateDlg::DoDataExchange(CDataExchange* pDX)
{
	CHelpDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSelectTemplateDlg)
	DDX_Control(pDX, IDC_TEMPLATE_LIST, m_templateList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSelectTemplateDlg, CHelpDialog)
	//{{AFX_MSG_MAP(CSelectTemplateDlg)
	ON_BN_CLICKED(IDC_TEMPLATE_PROPERTIES, OnTemplateProperties)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_TEMPLATE_LIST, OnItemchangedTemplateList)
	ON_NOTIFY(NM_DBLCLK, IDC_TEMPLATE_LIST, OnDblclkTemplateList)
	ON_NOTIFY(LVN_DELETEITEM, IDC_TEMPLATE_LIST, OnDeleteitemTemplateList)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSelectTemplateDlg message handlers
BOOL CSelectTemplateDlg::OnInitDialog() 
{
    _TRACE (1, L"Entering CSelectTemplateDlg::OnInitDialog\n");
	CHelpDialog::OnInitDialog();
    CWaitCursor cursor;
	
    // Set up list controls
	COLORREF	cr = RGB (255, 0, 255);
    CThemeContextActivator activator;
	VERIFY (m_imageListNormal.Create (IDB_TEMPLATES, 32, 0, cr));
	VERIFY (m_imageListSmall.Create (IDB_TEMPLATES, 16, 0, cr));
    m_templateList.SetImageList (CImageList::FromHandle (m_imageListSmall), LVSIL_SMALL);
	m_templateList.SetImageList (CImageList::FromHandle (m_imageListNormal), LVSIL_NORMAL);

	int	colWidths[NUM_COLS] = {200, 200};

	// Add "Certificate Extension" column
	CString	szText;
	VERIFY (szText.LoadString (IDS_CERTIFICATE_TEMPLATES));
	VERIFY (m_templateList.InsertColumn (COL_CERT_TEMPLATE, (LPCWSTR) szText,
			LVCFMT_LEFT, colWidths[COL_CERT_TEMPLATE], COL_CERT_TEMPLATE) != -1);

	VERIFY (szText.LoadString (IDS_COLUMN_SUPPORTED_CAS));
	VERIFY (m_templateList.InsertColumn (COL_CERT_VERSION, (LPCWSTR) szText,
			LVCFMT_LEFT, colWidths[COL_CERT_VERSION], COL_CERT_VERSION) != -1);

    ASSERT (m_pCompData);
    if ( m_pCompData )
    {
        POSITION    pos = m_pCompData->m_globalTemplateNameList.GetHeadPosition ();
        CString     szTemplateName;

	    for (; pos; )
	    {
	        szTemplateName = m_pCompData->m_globalTemplateNameList.GetNext (pos);

            // #NTRAID 363879 Certtmpl: Certificate Template Snapin must not 
            // allow the Subordinate CA template to be Superceded
            if ( wszCERTTYPE_SUBORDINATE_CA == szTemplateName )
                continue;

            // Only add those templates which are not already superceded
            if ( !m_supercededTemplateNameList.Find (szTemplateName) )
            {
                HCERTTYPE   hCertType = 0;
                HRESULT     hr = CAFindCertTypeByName (szTemplateName,
                        NULL,
                        CT_ENUM_MACHINE_TYPES | CT_ENUM_USER_TYPES | CT_FLAG_NO_CACHE_LOOKUP,
                        &hCertType);
                _ASSERT (SUCCEEDED (hr));
                if ( SUCCEEDED (hr) )
                {
                    // NTRAID# 660535 Certtmpl: Supercedes list should filter 
                    // out any certificate templates which have the TYPE == CA

                    DWORD dwGeneralFlags = 0;

                    hr = CAGetCertTypeFlagsEx (hCertType, CERTTYPE_GENERAL_FLAG, 
                            &dwGeneralFlags);
                    if ( FAILED (hr) )
                        continue;

                    if ( dwGeneralFlags & (CT_FLAG_IS_CA | CT_FLAG_IS_CROSS_CA) )
                        continue;


                    PWSTR* rgwszProp = 0;

                    hr = CAGetCertTypePropertyEx (hCertType, 
                        CERTTYPE_PROP_FRIENDLY_NAME, &rgwszProp);
                    if ( SUCCEEDED (hr) )
                    {
                        DWORD   dwVersion = 0;
                        hr = CAGetCertTypePropertyEx (hCertType,
                                CERTTYPE_PROP_SCHEMA_VERSION,
                                &dwVersion);
                        if ( SUCCEEDED (hr) )
                        {
	                        LV_ITEM	lvItem;
	                        int		iItem = m_templateList.GetItemCount ();
	                        int iResult = 0;

                            // security review 2/21/2002 BryanWal ok
	                        ::ZeroMemory (&lvItem, sizeof (lvItem));
	                        lvItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
	                        lvItem.iItem = iItem;
                            lvItem.iSubItem = COL_CERT_TEMPLATE;
	                        lvItem.pszText = rgwszProp[0];
                            if ( 1 == dwVersion )
                                lvItem.iImage = 0;  // version is 1
                            else
                                lvItem.iImage = 1;  // version is 2
                            lvItem.lParam = (LPARAM) new CString (szTemplateName);
	                        iItem = m_templateList.InsertItem (&lvItem);
	                        ASSERT (-1 != iItem);
	                        if ( -1 == iItem )
		                        break;
                            else
                            {
                                // security review 2/21/2002 BryanWal ok
	                            ::ZeroMemory (&lvItem, sizeof (lvItem));
	                            lvItem.mask = LVIF_TEXT;
	                            lvItem.iItem = iItem;
                                lvItem.iSubItem = COL_CERT_VERSION;
                                CString text;
                                if ( 1 == dwVersion )
                                    VERIFY (text.LoadString (IDS_WINDOWS_2000_AND_LATER));
                                else
                                    VERIFY (text.LoadString (IDS_WINDOWS_2002_AND_LATER));
                                lvItem.pszText = (PWSTR)(PCWSTR) text;
	                            iResult = m_templateList.SetItem (&lvItem);
	                            ASSERT (-1 != iResult);
                            }
                        }
                        else
                        {
                            _TRACE (0, L"CAGetCertTypePropertyEx (CERTTYPE_PROP_SCHEMA_VERSION) failed: 0x%x\n", hr);
                        }

                        CAFreeCertTypeProperty (hCertType, rgwszProp);
                    }
                    else
                    {
                        _TRACE (0, L"CAGetCertTypePropertyEx (CERTTYPE_PROP_FRIENDLY_NAME) failed: 0x%x\n", hr);
                    }

                    hr = CACloseCertType (hCertType);
                    _ASSERT (SUCCEEDED (hr));
                    if ( !SUCCEEDED (hr) )
                    {
                        _TRACE (0, L"CACloseCertType (%s) failed: 0x%x\n", hr);
                    }
                }
                else
                {
                    _TRACE (0, L"CAFindCertTypeByName (%s) failed: 0x%x\n", 
                            (PCWSTR) szTemplateName, hr);
                }
            }
        }	
    }

    EnableControls ();

    _TRACE (-1, L"Leaving CSelectTemplateDlg::OnInitDialog\n");
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CSelectTemplateDlg::OnTemplateProperties() 
{
    int     nSelCnt = m_templateList.GetSelectedCount ();
    int     nSelItem = GetSelectedListItem ();

    if ( 1 == nSelCnt )
    {
        CString szFriendlyName = m_templateList.GetItemText (nSelItem, 
                COL_CERT_TEMPLATE);
        CString* pszTemplateName = (CString*) m_templateList.GetItemData (nSelItem); 
        HCERTTYPE   hCertType = 0;
        HRESULT     hr = CAFindCertTypeByName (*pszTemplateName,
                NULL,
                CT_ENUM_MACHINE_TYPES | CT_ENUM_USER_TYPES | CT_FLAG_NO_CACHE_LOOKUP,
                &hCertType);
        _ASSERT (SUCCEEDED (hr));
        if ( SUCCEEDED (hr) )
        {
            CCertTemplate   certTemplate (szFriendlyName, *pszTemplateName, 
                    L"", true, m_pCompData->m_fUseCache);
            CString         title;

            // security review 2/21/2002 BryanWal ok
            title.FormatMessage (IDS_PROPERTIES_OF_TEMPLATE_X, szFriendlyName);
            CTemplatePropertySheet  propSheet (title, certTemplate, this);


            if ( 1 == certTemplate.GetType () )
            {
                CTemplateGeneralPropertyPage* pGeneralPage = 
                        new CTemplateGeneralPropertyPage (certTemplate, 
                                m_pCompData);
                if ( pGeneralPage )
                {
                    // Add General page
                    propSheet.AddPage (pGeneralPage);

                    // Add Request and Subject Name page only if subject is not a CA
                    if ( !certTemplate.SubjectIsCA () )
                    {
                        propSheet.AddPage (new CTemplateV1RequestPropertyPage (
                                certTemplate));
                        propSheet.AddPage (new CTemplateV1SubjectNamePropertyPage (
                                certTemplate));
                    }

                    // Add extensions page
                    propSheet.AddPage (new CTemplateExtensionsPropertyPage (
                            certTemplate, pGeneralPage->m_bIsDirty));
                }
            }
            else    // version is 2
            {
                CTemplateGeneralPropertyPage* pGeneralPage = 
                        new CTemplateGeneralPropertyPage (certTemplate,
                                m_pCompData);
                if ( pGeneralPage )
                {
                    propSheet.AddPage (pGeneralPage);

                    // Add Request and Subject pages if subject is not a CA
                    if ( !certTemplate.SubjectIsCA () )
                    {
                        propSheet.AddPage (new CTemplateV2RequestPropertyPage (
                                certTemplate, pGeneralPage->m_bIsDirty));
                        propSheet.AddPage (new CTemplateV2SubjectNamePropertyPage (
                                certTemplate, pGeneralPage->m_bIsDirty));
                    }
                    propSheet.AddPage (new CTemplateV2AuthenticationPropertyPage ( 
                            certTemplate, pGeneralPage->m_bIsDirty));
                    propSheet.AddPage (new CTemplateV2SupercedesPropertyPage (
                            certTemplate, 
                            pGeneralPage->m_bIsDirty, 
                            m_pCompData));
                    propSheet.AddPage (new CTemplateExtensionsPropertyPage (
                            certTemplate, pGeneralPage->m_bIsDirty));
                }
            }

            CThemeContextActivator activator;
            propSheet.DoModal ();

            hr = CACloseCertType (hCertType);
            _ASSERT (SUCCEEDED (hr));
            if ( !SUCCEEDED (hr) )
            {
                _TRACE (0, L"CACloseCertType (%s) failed: 0x%x\n", hr);
            }
        }
        else
        {
            _TRACE (0, L"CAFindCertTypeByName (%s) failed: 0x%x\n", 
                    (PCWSTR) pszTemplateName, hr);
        }
    }
}


void CSelectTemplateDlg::OnOK() 
{
	int		nCnt = m_templateList.GetItemCount ();
	ASSERT (nCnt >= 1);
	UINT	flag = 0;
	while (--nCnt >= 0)
	{
		flag = ListView_GetItemState (m_templateList.m_hWnd, nCnt, LVIS_SELECTED);
		if ( flag & LVNI_SELECTED )
		{
            CString* pszTemplateName = (CString*) m_templateList.GetItemData (nCnt);
            if ( pszTemplateName )
                m_returnedTemplates.AddTail (*pszTemplateName);
        }
    }
	
	CHelpDialog::OnOK();
}

void CSelectTemplateDlg::EnableControls()
{
    int nSelCnt = m_templateList.GetSelectedCount ();

    GetDlgItem (IDC_TEMPLATE_PROPERTIES)->EnableWindow (1 == nSelCnt);
    GetDlgItem (IDOK)->EnableWindow (nSelCnt > 0);
}

void CSelectTemplateDlg::OnItemchangedTemplateList(NMHDR* /*pNMHDR*/, LRESULT* pResult) 
{
    EnableControls ();
	
	*pResult = 0;
}

int CSelectTemplateDlg::GetSelectedListItem()
{
    int nSelItem = -1;

	if ( m_templateList.m_hWnd && m_templateList.GetSelectedCount () > 0 )
	{
		int		nCnt = m_templateList.GetItemCount ();
		ASSERT (nCnt >= 1);
		UINT	flag = 0;
		while (--nCnt >= 0)
		{
			flag = ListView_GetItemState (m_templateList.m_hWnd, nCnt, LVIS_SELECTED);
			if ( flag & LVNI_SELECTED )
			{
                nSelItem = nCnt;
                break;
            }
        }
    }

    return nSelItem;
}


void CSelectTemplateDlg::OnDblclkTemplateList(NMHDR* /*pNMHDR*/, LRESULT* pResult) 
{
	OnTemplateProperties ();
	
	*pResult = 0;
}

void CSelectTemplateDlg::OnDeleteitemTemplateList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	
    CString* pszTemplateName = (CString*) m_templateList.GetItemData (pNMListView->iItem);
    if ( pszTemplateName )
        delete pszTemplateName;
	
	*pResult = 0;
}

void CSelectTemplateDlg::DoContextHelp (HWND hWndControl)
{
	_TRACE(1, L"Entering CSelectTemplateDlg::DoContextHelp\n");
    
	switch (::GetDlgCtrlID (hWndControl))
	{
	case IDC_STATIC:
		break;

	default:
		// Display context help for a control
		if ( !::WinHelp (
				hWndControl,
				GetContextHelpFile (),
				HELP_WM_HELP,
				(DWORD_PTR) g_aHelpIDs_IDD_SELECT_TEMPLATE) )
		{
			_TRACE(0, L"WinHelp () failed: 0x%x\n", GetLastError ());        
		}
		break;
	}
    _TRACE(-1, L"Leaving CSelectTemplateDlg::DoContextHelp\n");
}

void CSelectTemplateDlg::OnDestroy() 
{
	CHelpDialog::OnDestroy();
	
    m_imageListNormal.Destroy ();
    m_imageListSmall.Destroy ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\strconst.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998-2002
//
//  File:       strconst.h
//
//  Contents:   Definition of string constants for Certificate Templates
//
//----------------------------------------------------------------------------
#ifndef __STRCONST_H
#define __STRCONST_H

#define CERTTMPL_LDAP                   L"LDAP"
#define CERTTMPL_ROOTDSE                L"RootDSE"

#define CERTTMPL_DEFAULT_NAMING_CONTEXT  L"defaultNamingContext"
#define CERTTMPL_SYSTEM_RDN             L"CN=System"
#define CERTTMPL_CONFIG_NAMING_CONTEXT  L"configurationNamingContext"

#define CERTTMPL_CONTEXT_HELP_FILE	L"CapeSnpn.hlp"
#define CERTTMPL_LINKED_HELP_FILE   L"CertTmpl.chm" 
#define CERTTMPL_HTML_HELP_FILE		L"CertTmpl.chm"
#define CERTTMPL_HTML_TOP_NODE		L"sag_CT_topnode.htm"
#define CERTTMPL_HELP_PATH			L"\\help\\"
#define CERTTMPL_CONCEPTS_HELP_FILE L"CTconcepts.chm"

#endif // __STRCONST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\templateextensionspropertypage.cpp ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2002.
//
//  File:       TemplateExtensionsPropertyPage.cpp
//
//  Contents:   Implementation of CTemplateExtensionsPropertyPage
//
//----------------------------------------------------------------------------
// TemplateExtensionsPropertyPage.cpp : implementation file
//

#include "stdafx.h"
#include "certtmpl.h"
#include "TemplateExtensionsPropertyPage.h"
#include "KeyUsageDlg.h"
#include "BasicConstraintsDlg.h"
#include "PolicyDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


PCWSTR pcszNEWLINE = L"\r\n";

#define IDI_CRITICAL_EXTENSION  0
#define IDI_EXTENSION           1

/////////////////////////////////////////////////////////////////////////////
// CTemplateExtensionsPropertyPage property page

CTemplateExtensionsPropertyPage::CTemplateExtensionsPropertyPage(
        CCertTemplate& rCertTemplate, 
        bool& rbIsDirty) 
    : CHelpPropertyPage(CTemplateExtensionsPropertyPage::IDD),
    m_rCertTemplate (rCertTemplate),
    m_rbIsDirty (rbIsDirty)
{
	//{{AFX_DATA_INIT(CTemplateExtensionsPropertyPage)
	//}}AFX_DATA_INIT
    m_rCertTemplate.AddRef ();
}

CTemplateExtensionsPropertyPage::~CTemplateExtensionsPropertyPage()
{
    m_rCertTemplate.Release ();
}

void CTemplateExtensionsPropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CHelpPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTemplateExtensionsPropertyPage)
	DDX_Control(pDX, IDC_EXTENSION_LIST, m_extensionList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTemplateExtensionsPropertyPage, CHelpPropertyPage)
	//{{AFX_MSG_MAP(CTemplateExtensionsPropertyPage)
	ON_BN_CLICKED(IDC_SHOW_DETAILS, OnShowDetails)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_EXTENSION_LIST, OnItemchangedExtensionList)
	ON_NOTIFY(NM_DBLCLK, IDC_EXTENSION_LIST, OnDblclkExtensionList)
	ON_NOTIFY(LVN_DELETEITEM, IDC_EXTENSION_LIST, OnDeleteitemExtensionList)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTemplateExtensionsPropertyPage message handlers

BOOL CTemplateExtensionsPropertyPage::OnInitDialog() 
{
	CHelpPropertyPage::OnInitDialog();

    if ( m_rCertTemplate.GetType () > 1 )
    {
        CString szText;
        VERIFY (szText.LoadString (IDS_V2_EXTENSIONS_HELP_HINT));
        SetDlgItemText (IDC_EXTENSIONS_HELP_HINT, szText);
    }

    // Set up list controls
	COLORREF	cr = RGB (255, 0, 255);
    CThemeContextActivator activator;
	VERIFY (m_imageListNormal.Create (IDB_EXTENSIONS, 32, 0, cr));
	VERIFY (m_imageListSmall.Create (IDB_EXTENSIONS, 16, 0, cr));
	m_extensionList.SetImageList (CImageList::FromHandle (m_imageListSmall), LVSIL_SMALL);
	m_extensionList.SetImageList (CImageList::FromHandle (m_imageListNormal), LVSIL_NORMAL);

	int	colWidths[NUM_COLS] = {400};

	// Add "Certificate Extension" column
	CString	szText;
	VERIFY (szText.LoadString (IDS_CERTIFICATE_EXTENSION));
	VERIFY (m_extensionList.InsertColumn (COL_CERT_EXTENSION, (LPCWSTR) szText,
			LVCFMT_LEFT, colWidths[COL_CERT_EXTENSION], COL_CERT_EXTENSION) != -1);

    // Add extensions
    bool    bEKUExtensionFound = false;
    bool    bCertPoliciesExtensionFound = false;
    bool    bApplicationPoliciesExtensionFound = false;
    HRESULT hr = S_OK;
    DWORD   dwExtensionCnt = m_rCertTemplate.GetCertExtensionCount ();
    for (DWORD dwIndex = 0; dwIndex < dwExtensionCnt; dwIndex++)
    {
        PSTR            pszObjId = 0;
        BOOL            fCritical = FALSE;

        hr = m_rCertTemplate.GetCertExtension (dwIndex, &pszObjId, fCritical);
        if ( SUCCEEDED (hr) )
        {
            if ( !_stricmp (szOID_ENHANCED_KEY_USAGE, pszObjId) )
                bEKUExtensionFound = true;
            else if ( !_stricmp (szOID_CERT_POLICIES, pszObjId) )
                bCertPoliciesExtensionFound = true;
            else if ( !_stricmp (szOID_APPLICATION_CERT_POLICIES, pszObjId) )
                bApplicationPoliciesExtensionFound = true;

            // Don't add EKU except for version 1
            if ( m_rCertTemplate.GetType () > 1 && !_stricmp (szOID_ENHANCED_KEY_USAGE, pszObjId) )
                continue; 

            // Don't add Application Policies for version 1
            if ( m_rCertTemplate.GetType () == 1 && !_stricmp (szOID_APPLICATION_CERT_POLICIES, pszObjId) )
                continue;

            InsertListItem (pszObjId, fCritical);
            delete [] pszObjId;
        }
    }

    if ( !bEKUExtensionFound && 1 == m_rCertTemplate.GetType () )   // only version 1
    {
        InsertListItem (szOID_ENHANCED_KEY_USAGE, FALSE);
    }
    if ( !bCertPoliciesExtensionFound && m_rCertTemplate.GetType ()  > 1 )   // not version 1
    {
        InsertListItem (szOID_CERT_POLICIES, FALSE);
    }

    // Fixes 228146: CERTTMPL:The default "Cross Certification Authority" template does not have the application Policy extension item
    if ( !bApplicationPoliciesExtensionFound && m_rCertTemplate.GetType () > 1 )    // version 2 or greater
    {
        InsertListItem (szOID_APPLICATION_CERT_POLICIES, FALSE);
    }

    // Select first item
    VERIFY (m_extensionList.SetItemState (0, LVIS_SELECTED, LVIS_SELECTED));

    EnableControls ();	

    if ( 1 == m_rCertTemplate.GetType () )
        GetDlgItem (IDC_SHOW_DETAILS)->ShowWindow (SW_HIDE);

   	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

HRESULT CTemplateExtensionsPropertyPage::InsertListItem (LPSTR pszExtensionOid, BOOL fCritical)
{
    if ( !pszExtensionOid )
        return E_POINTER;

    HRESULT hr = S_OK;

    CString friendlyName;
    if ( MyGetOIDInfoA (friendlyName, pszExtensionOid) )
    {
	    LV_ITEM	lvItem;
	    int		iItem = m_extensionList.GetItemCount ();

        // security review 2/20/2002 BryanWal ok
	    ::ZeroMemory (&lvItem, sizeof (lvItem));
	    lvItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
	    lvItem.iItem = iItem;
        lvItem.iSubItem = COL_CERT_EXTENSION;
	    lvItem.pszText = (LPWSTR)(LPCWSTR) friendlyName;
        if ( fCritical )
            lvItem.iImage = IDI_CRITICAL_EXTENSION;
        else
            lvItem.iImage = IDI_EXTENSION;
        // security review 2/20/2002 BryanWal ok
        PSTR    pszOID = new char[strlen (pszExtensionOid)+1];
        if ( pszOID )
        {
            // security review 2/20/2002 BryanWal ok
            strcpy (pszOID, pszExtensionOid);
            lvItem.lParam = (LPARAM) pszOID;

	        iItem = m_extensionList.InsertItem (&lvItem);
	        ASSERT (-1 != iItem);
            if ( -1 != iItem )
                hr = E_FAIL;
        }
        else
            hr = E_OUTOFMEMORY;
    }
    else
        hr = E_FAIL;

    return hr;
}

void CTemplateExtensionsPropertyPage::EnableControls()
{
    int     nSelCnt = m_extensionList.GetSelectedCount ();
    BOOL    bEnableDetails = TRUE;
    int     nSelIndex = GetSelectedListItem ();


    if ( 1 == nSelCnt )
    {
        PSTR pszOID = (PSTR) m_extensionList.GetItemData (nSelIndex);
        _ASSERT (pszOID);
        if ( pszOID )
        {
            if ( !_stricmp (szOID_ENROLL_CERTTYPE_EXTENSION, pszOID) )
                bEnableDetails = FALSE;
            else if ( !_stricmp (szOID_BASIC_CONSTRAINTS, pszOID) )
                bEnableDetails = FALSE;
            else if ( !_stricmp (szOID_CERTIFICATE_TEMPLATE, pszOID) )
                bEnableDetails = FALSE;
        }
    }
    else
        bEnableDetails = FALSE;
    GetDlgItem (IDC_SHOW_DETAILS)->EnableWindow (bEnableDetails);
}

void CTemplateExtensionsPropertyPage::OnOK() 
{
	CDialog::OnOK();
}

void CTemplateExtensionsPropertyPage::OnShowDetails() 
{
	int nSelCnt = m_extensionList.GetSelectedCount ();
    _ASSERT (1 == nSelCnt);
    int nSelIndex = GetSelectedListItem ();
    if ( 1 == nSelCnt )
    {
        PSTR    pszOID = (PSTR) m_extensionList.GetItemData (nSelIndex);
        if ( pszOID )
        {
            PCERT_EXTENSION pCertExtension = 0;
            HRESULT hr = m_rCertTemplate.GetCertExtension (pszOID, &pCertExtension);
            if ( SUCCEEDED (hr) )
            {
                bool bExtensionAllocedLocally = false;
                if ( !pCertExtension )
                {
                    pCertExtension = new CERT_EXTENSION;
                    if ( pCertExtension )
                    {
                        // security review 2/20/2002 BryanWal ok
                        ::ZeroMemory (pCertExtension, sizeof (CERT_EXTENSION));
                        pCertExtension->pszObjId = pszOID;
                        bExtensionAllocedLocally = true;
                    }
                    else
                        return;
                }
                CDialog* pDlg = 0;

                if ( !_stricmp (szOID_ENROLL_CERTTYPE_EXTENSION, pszOID) )
                {
                    return;
                }
                else if ( !_stricmp (szOID_ENHANCED_KEY_USAGE, pszOID) )
                {
                    if ( m_rCertTemplate.GetType () == 1 )
                    {
                        pDlg = new CPolicyDlg (this, m_rCertTemplate, pCertExtension);
                    }
                }
                else if ( !_stricmp (szOID_KEY_USAGE, pszOID) )
                {
                    pDlg = new CKeyUsageDlg (this, m_rCertTemplate, pCertExtension);
                }
                else if ( !_stricmp (szOID_BASIC_CONSTRAINTS, pszOID) )
                {
                    return;
                }
                else if ( !_stricmp (szOID_BASIC_CONSTRAINTS2, pszOID) )
                {
                    pDlg = new CBasicConstraintsDlg (this, m_rCertTemplate, pCertExtension);
                }
                else if ( !_stricmp (szOID_CERT_POLICIES, pszOID) )
                {
                    pDlg = new CPolicyDlg (this, m_rCertTemplate, pCertExtension);
                }
                else if ( !_stricmp (szOID_APPLICATION_CERT_POLICIES, pszOID) )
                {
                    if ( m_rCertTemplate.GetType () > 1 )
                    {
                        pDlg = new CPolicyDlg (this, m_rCertTemplate, pCertExtension);
                    }
                }
                else
                {
                    ASSERT (0);
                }

                bool bRefresh = false;

                if ( pDlg )
                {
                    CThemeContextActivator activator;
                    if ( IDOK == pDlg->DoModal () )
                        bRefresh = true;

                    delete pDlg;
                }

                if ( bExtensionAllocedLocally )
                    delete pCertExtension;
                m_rCertTemplate.FreeCertExtensions ();

                if ( bRefresh )
                {
                    hr = m_rCertTemplate.GetCertExtension (pszOID, &pCertExtension);
                    if ( SUCCEEDED (hr)  )
                    {
                        SetModified ();
                        m_rbIsDirty = true;
                        int nImage = 0;
                        if ( pCertExtension && pCertExtension->fCritical )
                            nImage = IDI_CRITICAL_EXTENSION;
                        else
                            nImage = IDI_EXTENSION;

                        VERIFY (m_extensionList.SetItem (nSelIndex, 0, LVIF_IMAGE, 0, 
                                nImage, 0, 0, 0));

                        ShowDescription ();

                        VERIFY (m_extensionList.SetItem (nSelIndex, 0, LVIF_IMAGE, 0, 
                                nImage, 0, 0, 0));

                        m_rCertTemplate.FreeCertExtensions ();
                    }
                }
            }
        }
    }
}


int CTemplateExtensionsPropertyPage::GetSelectedListItem()
{
    int nSelItem = -1;

	if ( m_extensionList.m_hWnd && m_extensionList.GetSelectedCount () > 0 )
	{
		int		nCnt = m_extensionList.GetItemCount ();
		ASSERT (nCnt >= 1);
		UINT	flag = 0;
		while (--nCnt >= 0)
		{
			flag = ListView_GetItemState (m_extensionList.m_hWnd, nCnt, LVIS_SELECTED);
			if ( flag & LVNI_SELECTED )
			{
                nSelItem = nCnt;
                break;
            }
        }
    }

    return nSelItem;
}

void CTemplateExtensionsPropertyPage::OnItemchangedExtensionList(NMHDR* pNMHDR, LRESULT* pResult) 
{
    LPNMLISTVIEW pNMListView = (LPNMLISTVIEW) pNMHDR;
    ASSERT (pNMListView);
    if ( !pNMListView )
    {
        *pResult = 0;
        return;
    }

    if ( !(LVIS_SELECTED & pNMListView->uNewState) )
    {
        CString szText;

        VERIFY (szText.LoadString (IDS_NO_EXTENSION_SELECTED));
        SetDlgItemText (IDC_EXTENSION_NAME, szText);
        VERIFY (szText.LoadString (IDS_NONE));
        SetDlgItemText (IDC_EXTENSION_DESCRIPTION, szText);
        *pResult = 0;
        return;
    }

    EnableControls ();
	
    ShowDescription ();

	*pResult = 0;
}

void CTemplateExtensionsPropertyPage::SetCertTemplateExtension (PCERT_EXTENSION pCertExtension)
{
    ASSERT (pCertExtension);
    if ( !pCertExtension )
        return;

    DWORD   cbData = 0;
       
    if ( CryptDecodeObject(X509_ASN_ENCODING,
                          szOID_CERTIFICATE_TEMPLATE,
                          pCertExtension->Value.pbData,
                          pCertExtension->Value.cbData,
                          0,
                          NULL,
                          &cbData) )
    {
        CERT_TEMPLATE_EXT* pbTemplate = (CERT_TEMPLATE_EXT*) LocalAlloc(LPTR, cbData);
        if ( pbTemplate )
        {
            if ( CryptDecodeObject(X509_ASN_ENCODING,
                                  szOID_CERTIFICATE_TEMPLATE,
                                  pCertExtension->Value.pbData,
                                  pCertExtension->Value.cbData,
                                  0,
                                  pbTemplate,
                                  &cbData) )
            {
                CString text;
                CString description;

                //copy the extension oid
                if ( pbTemplate->pszObjId )
                {
                    CString templateName;
                    if ( MyGetOIDInfoA (templateName, pbTemplate->pszObjId) )
                    {
                        CString szOID;

                        // security review 2/20/2002 BryanWal ok
                        int nLen = ::MultiByteToWideChar (CP_ACP, 0, 
                                pbTemplate->pszObjId, -1, NULL, 0); // NOTICE: API returns required character count 
                                                                    // including null terminator if last arg is 0
		                ASSERT (nLen > 0);
		                if ( nLen > 0 )
		                {
                            // security review 2/20/2002 BryanWal ok
			                nLen = ::MultiByteToWideChar (CP_ACP, 0, 
                                    pbTemplate->pszObjId, -1, 
					                szOID.GetBufferSetLength (nLen), nLen);
			                ASSERT (nLen > 0);
			                szOID.ReleaseBuffer ();
		                }

                        if ( !wcscmp (templateName, szOID) )
                        {
                            // Bug 213073 CryptFormatObject: Need to include 
                            // the cert temp OID in the Certificate Template 
                            // Information extension
                            // When the template is cloned, the oid-name pair
                            // is not in the global list.  Just use the
                            // template display name the user provided
                            templateName = m_rCertTemplate.GetDisplayName ();
                        }

                        // security review 2/20/2002 BryanWal ok
                        text.FormatMessage (IDS_TEMPLATE_NAME, templateName);
                        description += text;
                        description += pcszNEWLINE;

                        // Copy the template OID
                        // security review 2/20/2002 BryanWal ok
                        text.FormatMessage (IDS_TEMPLATE_OID, szOID);
                        description += text;
                        description += pcszNEWLINE;
                    }
                }

                // copy the subject type description
                CString szSubjectTypeDescription;
                if ( SUCCEEDED (m_rCertTemplate.GetSubjectTypeDescription (
                        0, szSubjectTypeDescription)) )
                {
                    // security review 2/20/2002 BryanWal ok
                    text.FormatMessage (IDS_SUBJECT_TYPE_DESCRIPTION, szSubjectTypeDescription);
                    description += text;
                    description += pcszNEWLINE;
                }

                //copy the version
                WCHAR   str[32];
                // security review 3/5/2002 BryanWal ok
                // str buffer is big enough for a DWORD value (where 18 characters are required)
                _ultow (pbTemplate->dwMajorVersion, str, 10);
                // security review 2/20/2002 BryanWal ok
                text.FormatMessage (IDS_MAJOR_VERSION_NUMBER, str);
                description += text;
                description += pcszNEWLINE;

                // security review 3/5/2002 BryanWal ok
                // str buffer is big enough for a DWORD value (where 18 characters are required)
                _ultow (pbTemplate->dwMinorVersion, str, 10);
                // security review 2/20/2002 BryanWal ok
                text.FormatMessage (IDS_MINOR_VERSION_NUMBER, str);
                description += text;
                description += pcszNEWLINE;

                if ( description.IsEmpty () )
                    VERIFY (description.LoadString (IDS_NONE));
                SetDlgItemText (IDC_EXTENSION_DESCRIPTION, description);

            }
            LocalFree (pbTemplate);
        }
    }
}

void CTemplateExtensionsPropertyPage::SetCertTypeDescription (PCERT_EXTENSION pCertExtension)
{
    ASSERT (pCertExtension);
    if ( !pCertExtension )
        return;

    DWORD	cbValue = 0;

	if ( ::CryptDecodeObject(
			CRYPT_ASN_ENCODING,
			X509_UNICODE_ANY_STRING,
			pCertExtension->Value.pbData,
			pCertExtension->Value.cbData,
			0,
			0,
			&cbValue) )
	{
		CERT_NAME_VALUE* pCNValue = (CERT_NAME_VALUE*) 
			::LocalAlloc(LPTR, cbValue);
		if ( pCNValue )
		{
			if ( ::CryptDecodeObject(
					CRYPT_ASN_ENCODING,
					X509_UNICODE_ANY_STRING,
					pCertExtension->Value.pbData,
					pCertExtension->Value.cbData,
					0,
					pCNValue,
					&cbValue) )
			{
				CString text = (LPWSTR) pCNValue->Value.pbData;
                CString description;
                
                if ( text.IsEmpty () )
                    VERIFY (text.LoadString (IDS_NONE));
                // security review 2/20/2002 BryanWal ok
                description.FormatMessage (IDS_TEMPLATE_INTERNAL_NAME, text);
                description += pcszNEWLINE;

                // copy the subject type description
                CString szSubjectTypeDescription;
                if ( SUCCEEDED (m_rCertTemplate.GetSubjectTypeDescription (
                        0, szSubjectTypeDescription)) )
                {
                    // security review 2/20/2002 BryanWal ok
                    text.FormatMessage (IDS_SUBJECT_TYPE_DESCRIPTION, szSubjectTypeDescription);
                    description += text;
                    description += pcszNEWLINE;
                }

                SetDlgItemText (IDC_EXTENSION_DESCRIPTION, description);
			}
			::LocalFree (pCNValue);
		}
	    else
	    {
            _TRACE (0, L"CryptDecodeObject (CRYPT_ASN_ENCODING, X509_UNICODE_ANY_STRING, ...) failed: 0x%x\n",
                    GetLastError ());
	    }
	}
	else
	{
        _TRACE (0, L"CryptDecodeObject (CRYPT_ASN_ENCODING, X509_UNICODE_ANY_STRING, ...) failed: 0x%x\n",
                GetLastError ());
	}
}


void CTemplateExtensionsPropertyPage::SetKeyUsageDescription (PCERT_EXTENSION pCertExtension)
{ 
    ASSERT (pCertExtension);
    if ( !pCertExtension )
        return;

    CString description;
    CString text;

	DWORD           cbKeyUsage = 0;
	CRYPT_BIT_BLOB* pKeyUsage = 0;

	if ( ::CryptDecodeObject(CRYPT_ASN_ENCODING, 
			szOID_KEY_USAGE, 
			pCertExtension->Value.pbData,
			pCertExtension->Value.cbData,
			0, NULL, &cbKeyUsage) )
	{
		pKeyUsage = (CRYPT_BIT_BLOB*)
				::LocalAlloc (LPTR, cbKeyUsage);
		if ( pKeyUsage )
		{
			if ( ::CryptDecodeObject (CRYPT_ASN_ENCODING, 
					szOID_KEY_USAGE, 
					pCertExtension->Value.pbData,
					pCertExtension->Value.cbData,
					0, pKeyUsage, &cbKeyUsage) )
			{
                if (pKeyUsage->cbData >= 1)
                {
                    if ( pKeyUsage->pbData[0] & 
                            (CERT_DIGITAL_SIGNATURE_KEY_USAGE | 
                            CERT_NON_REPUDIATION_KEY_USAGE | 
                            CERT_KEY_CERT_SIGN_KEY_USAGE | 
                            CERT_OFFLINE_CRL_SIGN_KEY_USAGE) )
                    {
                        VERIFY (text.LoadString (IDS_SIGNATURE_REQUIREMENTS));
                        description += text;
                        description += pcszNEWLINE;

                        if ( pKeyUsage->pbData[0] & CERT_DIGITAL_SIGNATURE_KEY_USAGE )
                        {
                            VERIFY (text.LoadString (IDS_DIGITAL_SIGNATURE));
                            description += text;
                            description += pcszNEWLINE;
                        }

                        if ( pKeyUsage->pbData[0] & CERT_NON_REPUDIATION_KEY_USAGE )
                        {
                            VERIFY (text.LoadString (IDS_NON_REPUDIATION));
                            description += text;
                            description += pcszNEWLINE;
                        }

                        if ( pKeyUsage->pbData[0] & CERT_KEY_CERT_SIGN_KEY_USAGE )
                        {
                            VERIFY (text.LoadString (IDS_CERTIFICATE_SIGNING));
                            description += text;
                            description += pcszNEWLINE;
                        }

                        if ( pKeyUsage->pbData[0] & CERT_OFFLINE_CRL_SIGN_KEY_USAGE )
                        {
                            VERIFY (text.LoadString (IDS_CRL_SIGNING));
                            description += text;
                            description += pcszNEWLINE;
                        }
                    }

                    if ( pKeyUsage->pbData[0] & (CERT_KEY_ENCIPHERMENT_KEY_USAGE |
                            CERT_DATA_ENCIPHERMENT_KEY_USAGE |
                            CERT_KEY_AGREEMENT_KEY_USAGE) )
                    {
                        if ( !description.IsEmpty () )
                            description += pcszNEWLINE;

                        if ( pKeyUsage->pbData[0] & CERT_KEY_ENCIPHERMENT_KEY_USAGE )
                        {
                            VERIFY (text.LoadString (IDS_ALLOW_KEY_EXCHANGE_ONLY_WITH_KEY_ENCRYPTION));
                            description += text;
                            description += pcszNEWLINE;
                        }

                        if ( pKeyUsage->pbData[0] & CERT_KEY_AGREEMENT_KEY_USAGE )
                        {
                            VERIFY (text.LoadString (IDS_ALLOW_KEY_EXCHANGE_WITHOUT_KEY_ENCRYPTION));
                            description += text;
                            description += pcszNEWLINE;
                        }

                        if ( pKeyUsage->pbData[0] & CERT_DATA_ENCIPHERMENT_KEY_USAGE )
                        {
                            VERIFY (text.LoadString (IDS_ALLOW_ENCRYPTION_OF_USER_DATA));
                            description += text;
                            description += pcszNEWLINE;
                        }

                    }
                }

//                if (pKeyUsage->cbData >= 2)
//                {
//                    if ( pKeyUsage->pbData[1] & CERT_DECIPHER_ONLY_KEY_USAGE )
//                        SendDlgItemMessage (IDC_CHECK_DECIPHERMENT_ONLY, BM_SETCHECK, BST_CHECKED);
//                }
			}
			else
            {
                DWORD   dwErr = GetLastError ();
                _TRACE (0, L"CryptDecodeObject (szOID_KEY_USAGE) failed: 0x%x\n", dwErr);
			    DisplaySystemError (NULL, dwErr);
            }

            LocalFree (pKeyUsage);
		}
	}
	else
    {
        DWORD   dwErr = GetLastError ();
        _TRACE (0, L"CryptDecodeObject (szOID_KEY_USAGE) failed: 0x%x\n", dwErr);
		DisplaySystemError (NULL, dwErr);
    }

    if ( pCertExtension->fCritical )
    {
        VERIFY (text.LoadString (IDS_CRITICAL_EXTENSION));
        description += text;
        description += pcszNEWLINE;
    }

    if ( description.IsEmpty () )
        VERIFY (description.LoadString (IDS_NONE));
    SetDlgItemText (IDC_EXTENSION_DESCRIPTION, description);
}


void CTemplateExtensionsPropertyPage::SetEnhancedKeyUsageDescription (bool bCritical)
{ 
    CString description;
    CString text;

    int     nEKUIndex = 0;
    CString szEKU;
    while ( SUCCEEDED (m_rCertTemplate.GetEnhancedKeyUsage (nEKUIndex, szEKU)) )
    {
        // security review 2/20/2002 BryanWal ok
        int nLen = WideCharToMultiByte(
              CP_ACP,                   // code page
              0,                        // performance and mapping flags
              (PCWSTR) szEKU,  // wide-character string
              -1,                       // -1 - calculate length of null-terminated string automatically
              0,                        // buffer for new string
              0,                        // size of buffer - if 0 causes to return required len including NULL terminator
              0,                    // default for unmappable chars
              0);                   // set when default char used - returns length including null-terminator
        if ( nLen > 0 )
        {
            PSTR    pszAnsiBuf = new char[nLen];
            if ( pszAnsiBuf )
            {
                // security review 2/20/2002 BryanWal ok
                ZeroMemory (pszAnsiBuf, nLen);
                nLen = WideCharToMultiByte(
                        CP_ACP,                 // code page
                        0,                      // performance and mapping flags
                        (PCWSTR) szEKU,         // wide-character string
                        -1,                     // -1 - calculate length of null-terminated string automatically
                        pszAnsiBuf,             // buffer for new string
                        nLen,                   // size of buffer
                        0,                      // default for unmappable chars
                        0);                     // set when default char used
                if ( nLen > 0 )
                {
                    CString szEKUName;
                    if ( MyGetOIDInfoA (szEKUName, pszAnsiBuf) )
                    {
                        description += szEKUName;
                        description += pcszNEWLINE;
                    }
                }
                delete [] pszAnsiBuf;
            }
        }
        nEKUIndex++;
    }

    if ( bCritical )
    {
        VERIFY (text.LoadString (IDS_CRITICAL_EXTENSION));
        description += text;
        description += pcszNEWLINE;
    }

    if ( description.IsEmpty () )
        VERIFY (description.LoadString (IDS_NONE));
    SetDlgItemText (IDC_EXTENSION_DESCRIPTION, description);
}

void CTemplateExtensionsPropertyPage::SetApplicationPoliciesDescription (bool bCritical)
{ 
    CString description;
    CString text;

    int     nAppPolicyIndex = 0;
    CString szAppPolicy;
    while ( SUCCEEDED (m_rCertTemplate.GetApplicationPolicy (nAppPolicyIndex, szAppPolicy)) )
    {
        // security review 2/20/2002 BryanWal ok
        int nLen = WideCharToMultiByte(
              CP_ACP,                   // code page
              0,                        // performance and mapping flags
              (PCWSTR) szAppPolicy,  // wide-character string
              -1,                       // -1 - calculate length of null-terminated string automatically
              0,                        // buffer for new string
              0,                        // size of buffer - 0 causes API to return length including null terminator
              0,                    // default for unmappable chars
              0);                   // set when default char used
        if ( nLen > 0 )
        {
            PSTR pszAnsiBuf = new char[nLen];
            if ( pszAnsiBuf )
            {
                // security review 2/20/2002 BryanWal ok
                ZeroMemory (pszAnsiBuf, nLen);
                // security review 2/20/2002 BryanWal ok
                nLen = WideCharToMultiByte(
                        CP_ACP,                 // code page
                        0,                      // performance and mapping flags
                        (PCWSTR) szAppPolicy,   // wide-character string
                        -1,                     // -1 - calculate length of null-terminated string automatically
                        pszAnsiBuf,             // buffer for new string
                        nLen,                   // size of buffer
                        0,                      // default for unmappable chars
                        0);                     // set when default char used
                if ( nLen )
                {
                    CString szAppPolicyName;
                    if ( MyGetOIDInfoA (szAppPolicyName, pszAnsiBuf) )
                    {
                        description += szAppPolicyName;
                        description += pcszNEWLINE;
                    }
                }
                delete [] pszAnsiBuf;
            }
        }
        nAppPolicyIndex++;
    }

    if ( bCritical )
    {
        VERIFY (text.LoadString (IDS_CRITICAL_EXTENSION));
        description += text;
        description += pcszNEWLINE;
    }

    if ( description.IsEmpty () )
        VERIFY (description.LoadString (IDS_NONE));
    SetDlgItemText (IDC_EXTENSION_DESCRIPTION, description);
}


void CTemplateExtensionsPropertyPage::SetCertPoliciesDescription (bool bCritical)
{ 
    CString description;
    CString text;

    VERIFY (text.LoadString (IDS_CERT_POLICY_KNOWN_AS_ISSUANCE_POLICY));
    description += text;
    description += pcszNEWLINE;
    description += pcszNEWLINE;

    int     nCertPolicyIndex = 0;
    CString szCertPolicy;
    while ( SUCCEEDED (m_rCertTemplate.GetCertPolicy (nCertPolicyIndex, szCertPolicy)) )
    {
        // security review 2/20/2002 BryanWal ok
        int nLen = WideCharToMultiByte(
              CP_ACP,                   // code page
              0,                        // performance and mapping flags
              (PCWSTR) szCertPolicy,    // wide-character string
              -1,                       // -1 - calculate length of null-terminated string automatically
              0,                        // buffer for new string
              0,                        // size of buffer - 0 causes API to return len with null terminator
              0,                        // default for unmappable chars
              0);                       // set when default char used
        if ( nLen > 0 )
        {
            PSTR    pszAnsiBuf = new char[nLen];
            if ( pszAnsiBuf )
            {
                // security review 2/20/2002 BryanWal ok
                ZeroMemory (pszAnsiBuf, nLen);
                // security review 2/20/2002 BryanWal ok
                nLen = WideCharToMultiByte(
                        CP_ACP,                 // code page
                        0,                      // performance and mapping flags
                        (PCWSTR) szCertPolicy,  // wide-character string
                        -1,                     // -1 - calculate length of null-terminated string automatically
                        pszAnsiBuf,             // buffer for new string
                        nLen,                   // size of buffer
                        0,                      // default for unmappable chars
                        0);                     // set when default char used
                if ( nLen )
                {
                    CString szPolicyName;
                    if ( MyGetOIDInfoA (szPolicyName, pszAnsiBuf) )
                    {
                        description += szPolicyName;
                        description += pcszNEWLINE;
                    }
                }

                delete [] pszAnsiBuf;
            }
        }
        nCertPolicyIndex++;
    }

    if ( bCritical )
    {
        VERIFY (text.LoadString (IDS_CRITICAL_EXTENSION));
        description += text;
        description += pcszNEWLINE;
    }

    if ( description.IsEmpty () )
        VERIFY (description.LoadString (IDS_NONE));
    SetDlgItemText (IDC_EXTENSION_DESCRIPTION, description);
}

void CTemplateExtensionsPropertyPage::SetBasicConstraintsDescription (PCERT_EXTENSION pCertExtension)
{
    ASSERT (pCertExtension);
    if ( !pCertExtension )
        return;

    CString description;
    CString text;

    VERIFY (text.LoadString (IDS_SUBJECT_IS_CA));
    description += text;
    description += pcszNEWLINE;

    PCERT_BASIC_CONSTRAINTS2_INFO   pBCInfo = 0;   
    DWORD                           cbInfo = 0;

    if ( CryptDecodeObject (
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            //X509_BASIC_CONSTRAINTS2, 
            szOID_BASIC_CONSTRAINTS2, 
            pCertExtension->Value.pbData,
            pCertExtension->Value.cbData,
            0,
            0,
            &cbInfo) )
    {
        pBCInfo = (PCERT_BASIC_CONSTRAINTS2_INFO) ::LocalAlloc (
                LPTR, cbInfo);
        if ( pBCInfo )
        {
            if ( CryptDecodeObject (
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                //X509_BASIC_CONSTRAINTS2, 
                szOID_BASIC_CONSTRAINTS2, 
                pCertExtension->Value.pbData,
                pCertExtension->Value.cbData,
                0,
                pBCInfo,
                &cbInfo) )
            {
                if ( pBCInfo->fPathLenConstraint )
                {
                    VERIFY (text.LoadString (IDS_ONLY_ISSUE_END_ENTITIES));
                    description += text;
                    description += pcszNEWLINE;
                }
            }
            else
            {
                _TRACE (0, L"CryptDecodeObjectEx (szOID_BASIC_CONSTRAINTS2) failed: 0x%x\n", GetLastError ());
            }
            LocalFree (pBCInfo);
        }
    }
    else
    {
        _TRACE (0, L"CryptDecodeObjectEx (szOID_BASIC_CONSTRAINTS2) failed: 0x%x\n", GetLastError ());
    }

    if ( pCertExtension->fCritical )
    {
        VERIFY (text.LoadString (IDS_CRITICAL_EXTENSION));
        description += text;
        description += pcszNEWLINE;
    }

    if ( description.IsEmpty () )
        VERIFY (description.LoadString (IDS_NONE));
    SetDlgItemText (IDC_EXTENSION_DESCRIPTION, description);
}

void CTemplateExtensionsPropertyPage::OnDblclkExtensionList(NMHDR* /*pNMHDR*/, LRESULT* pResult) 
{
	OnShowDetails ();
	
	*pResult = 0;
}

void CTemplateExtensionsPropertyPage::DoContextHelp (HWND hWndControl)
{
	_TRACE(1, L"Entering CTemplateExtensionsPropertyPage::DoContextHelp\n");
    
	switch (::GetDlgCtrlID (hWndControl))
	{
	case IDC_STATIC:
		break;

	default:
		// Display context help for a control
		if ( !::WinHelp (
				hWndControl,
				GetContextHelpFile (),
				HELP_WM_HELP,
				(DWORD_PTR) g_aHelpIDs_IDD_TEMPLATE_EXTENSIONS) )
		{
			_TRACE(0, L"WinHelp () failed: 0x%x\n", GetLastError ());        
		}
		break;
	}
    _TRACE(-1, L"Leaving CTemplateExtensionsPropertyPage::DoContextHelp\n");
}

void CTemplateExtensionsPropertyPage::OnDeleteitemExtensionList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    PSTR pszOID = (PSTR) m_extensionList.GetItemData (pNMListView->iItem);
    if ( pszOID )
    {
        delete [] pszOID;
    }
	
	*pResult = 0;
}

BOOL CTemplateExtensionsPropertyPage::OnSetActive() 
{
    BOOL  bRVal = CHelpPropertyPage::OnSetActive();
    	
    ShowDescription ();

    return bRVal;
}

void CTemplateExtensionsPropertyPage::ShowDescription ()
{
	int nSelCnt = m_extensionList.GetSelectedCount ();
    int nSelIndex = GetSelectedListItem ();
    if ( 1 == nSelCnt )
    {
        PSTR    pszOID = (PSTR) m_extensionList.GetItemData (nSelIndex);
        if ( pszOID )
        {
            CString friendlyName;
            if ( MyGetOIDInfoA (friendlyName, pszOID) )
            {
                CString text;

                // security review 2/20/2002 BryanWal ok
                text.FormatMessage (IDS_EXTENSION_NAME, friendlyName);
                SetDlgItemText (IDC_EXTENSION_NAME, text);
            }
            else
                SetDlgItemText (IDC_EXTENSION_NAME, L"");

            PCERT_EXTENSION pCertExtension = 0;
            HRESULT hr = m_rCertTemplate.GetCertExtension (pszOID, &pCertExtension);
            if ( SUCCEEDED (hr) )
            {
                if ( pCertExtension )
                {
                    if ( !_stricmp (szOID_BASIC_CONSTRAINTS2, pszOID) )
                    {
                        SetBasicConstraintsDescription (pCertExtension);
                    }
                    else if ( !_stricmp (szOID_ENHANCED_KEY_USAGE, pszOID) )
                    {
                        bool bCritical = false;
                        m_rCertTemplate.IsExtensionCritical (TEXT (szOID_ENHANCED_KEY_USAGE), 
                                bCritical);

                        SetEnhancedKeyUsageDescription (bCritical);
                    }
                    else if ( !_stricmp (szOID_APPLICATION_CERT_POLICIES, pszOID) )
                    {
                        bool bCritical = false;
                        m_rCertTemplate.IsExtensionCritical (TEXT (szOID_APPLICATION_CERT_POLICIES), 
                                bCritical);

                        SetApplicationPoliciesDescription (bCritical);
                    }
                    else if ( !_stricmp (szOID_KEY_USAGE, pszOID) )
                    {
                        SetKeyUsageDescription (pCertExtension);
                    }
                    else if ( !_stricmp (szOID_CERT_POLICIES, pszOID) )
                    {
                        bool bCritical = false;
                        m_rCertTemplate.IsExtensionCritical (TEXT (szOID_CERT_POLICIES), 
                                bCritical);
                        SetCertPoliciesDescription (bCritical);
                    }
                    else if ( !_stricmp (szOID_ENROLL_CERTTYPE_EXTENSION, pszOID) )
                    {
                        SetCertTypeDescription (pCertExtension);
                    }
                    else if ( !_stricmp (szOID_CERTIFICATE_TEMPLATE, pszOID) )
                    {
                        SetCertTemplateExtension (pCertExtension);
                    }
                    else
                    {
                        CString szText;

                        VERIFY (szText.LoadString (IDS_NONE));
                        SetDlgItemText (IDC_EXTENSION_DESCRIPTION, szText);
                    }
                }
                else if ( !_stricmp (szOID_CERT_POLICIES, pszOID) )
                {
                    SetCertPoliciesDescription (false);
                }
                else if ( !_stricmp (szOID_APPLICATION_CERT_POLICIES, pszOID) )
                {
                    SetApplicationPoliciesDescription (false);
                }
            }
        }
    }
    else
    {
        CString szText;

        VERIFY (szText.LoadString (IDS_NO_EXTENSION_SELECTED));
        SetDlgItemText (IDC_EXTENSION_NAME, szText);
        VERIFY (szText.LoadString (IDS_NONE));
        SetDlgItemText (IDC_EXTENSION_DESCRIPTION, szText);
    }
}

void CTemplateExtensionsPropertyPage::OnDestroy() 
{
	CHelpPropertyPage::OnDestroy();
	
    m_imageListNormal.Destroy ();
    m_imageListSmall.Destroy ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\templateextensionspropertypage.h ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       TemplateExtensionsPropertyPage.h
//
//  Contents:   Definition of CTemplateExtensionsPropertyPage
//
//----------------------------------------------------------------------------
#if !defined(AFX_TEMPLATEEXTENSIONSPROPERTYPAGE_H__6C588253_32DA_4E99_A714_EAECE8C81B20__INCLUDED_)
#define AFX_TEMPLATEEXTENSIONSPROPERTYPAGE_H__6C588253_32DA_4E99_A714_EAECE8C81B20__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// TemplateExtensionsPropertyPage.h : header file
//
#include "CertTemplate.h"
#include "PolicyOID.h"


/////////////////////////////////////////////////////////////////////////////
// CTemplateExtensionsPropertyPage dialog

class CTemplateExtensionsPropertyPage : public CHelpPropertyPage
{
// Construction
public:
	CTemplateExtensionsPropertyPage(CCertTemplate& rCertTemplate, 
            bool& rbIsDirty);
	~CTemplateExtensionsPropertyPage();

// Dialog Data
	//{{AFX_DATA(CTemplateExtensionsPropertyPage)
	enum { IDD = IDD_TEMPLATE_EXTENSIONS };
	CListCtrl	m_extensionList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTemplateExtensionsPropertyPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    void ShowDescription ();
    void SetCertTemplateExtension (PCERT_EXTENSION pCertExtension);
    void SetCertTypeDescription (PCERT_EXTENSION pCertExtension);
    void SetKeyUsageDescription (PCERT_EXTENSION pCertExtension);
    void SetEnhancedKeyUsageDescription (bool bCritical);
    void SetCertPoliciesDescription (bool bCritical);
    void SetBasicConstraintsDescription (PCERT_EXTENSION pCertExtension);
    void SetApplicationPoliciesDescription (bool bCritical);
    HRESULT InsertListItem (LPSTR pszExtensionOid, BOOL fCritical);
	virtual void DoContextHelp (HWND hWndControl);
	int GetSelectedListItem ();
	// Generated message map functions
	//{{AFX_MSG(CTemplateExtensionsPropertyPage)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnShowDetails();
	afx_msg void OnItemchangedExtensionList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDblclkExtensionList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeleteitemExtensionList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    void EnableControls ();

private:
	bool& m_rbIsDirty;
    CCertTemplate& m_rCertTemplate;
	WTL::CImageList		m_imageListSmall;
	WTL::CImageList		m_imageListNormal;

	enum {
		COL_CERT_EXTENSION = 0,
		NUM_COLS	// must be last
	};
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TEMPLATEEXTENSIONSPROPERTYPAGE_H__6C588253_32DA_4E99_A714_EAECE8C81B20__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\templatepropertysheet.cpp ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       TemplatePropertySheet.cpp
//
//  Contents:   Implementation of CTemplatePropertySheet
//
//----------------------------------------------------------------------------

#include "stdafx.h"

#include "TemplatePropertySheet.h"
#include "SecurityPropertyPage.h"


#define WM_ADDSECURITYPAGE  WM_APP + 2000
#define WM_SETOKDEFAULT     WM_APP + 2001


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CTemplatePropertySheet::CTemplatePropertySheet(
        LPCTSTR pszCaption, 
        CCertTemplate& rCertTemplate, 
        CWnd *pParentWnd, 
        UINT iSelectPage)
: CPropertySheet (pszCaption, pParentWnd, iSelectPage),
    m_rCertTemplate (rCertTemplate),
    m_pReleaseMe (0)
{
    m_rCertTemplate.AddRef ();
}

CTemplatePropertySheet::~CTemplatePropertySheet()
{
    m_rCertTemplate.Release ();
    if ( m_pReleaseMe )
        m_pReleaseMe->Release ();
}

BEGIN_MESSAGE_MAP(CTemplatePropertySheet, CPropertySheet)
    ON_MESSAGE (WM_ADDSECURITYPAGE, OnAddSecurityPage)
    ON_MESSAGE(WM_HELP, OnHelp)
    ON_MESSAGE (WM_SETOKDEFAULT, OnSetOKDefault)
END_MESSAGE_MAP()

LRESULT CTemplatePropertySheet::OnAddSecurityPage (WPARAM, LPARAM)
{
    _TRACE (1, L"Entering CTemplatePropertySheet::OnAddSecurityPage\n");
    LPSECURITYINFO pCertTemplateSecurity = NULL;

    HRESULT hr = CreateCertTemplateSecurityInfo (&m_rCertTemplate, 
            &pCertTemplateSecurity);
    if ( SUCCEEDED (hr) )
    {
        HPROPSHEETPAGE hPage = CreateSecurityPage (pCertTemplateSecurity);
        if ( hPage )
        {
            if ( SendMessage (PSM_ADDPAGE, 0, (LPARAM) hPage) )
            {
                SendMessage (PSM_RECALCPAGESIZES, 0, 0); 
            }
            else
            {
                DestroyPropertySheetPage (hPage);
                pCertTemplateSecurity->Release ();
                pCertTemplateSecurity = 0;
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32 (GetLastError());
            _TRACE (0, L"CreateSecurityPage () failed: 0x%x\n", hr);
            pCertTemplateSecurity->Release ();
            pCertTemplateSecurity = 0;
        }
        _ASSERT (SUCCEEDED (hr));
    }

    m_pReleaseMe = pCertTemplateSecurity;

    _TRACE (-1, L"Leaving CTemplatePropertySheet::OnAddSecurityPage\n");
    return 0;
}

BOOL CTemplatePropertySheet::OnInitDialog() 
{
    _TRACE (1, L"Entering CTemplatePropertySheet::OnInitDialog ()\n");
    CPropertySheet::OnInitDialog();
    
    LONG    dwStyle = GetWindowLong (m_hWnd, GWL_STYLE);

    dwStyle |= DS_CONTEXTHELP;
    SetWindowLong (m_hWnd, GWL_STYLE, dwStyle);
    
    dwStyle = GetWindowLong (m_hWnd, GWL_EXSTYLE);
    dwStyle |= /*WS_EX_DLGMODALFRAME |*/ WS_EX_CONTEXTHELP;
    SetWindowLong (m_hWnd, GWL_EXSTYLE, dwStyle);

    // Add security page
    PostMessage (WM_ADDSECURITYPAGE, 0, 0);


    // Make the OK button the default
    PostMessage (WM_SETOKDEFAULT, 0, 0);

    _TRACE (-1, L"Leaving CTemplatePropertySheet::OnInitDialog ()\n");
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


LRESULT CTemplatePropertySheet::OnSetOKDefault (WPARAM, LPARAM)
{
    // Make the OK button the default
    SendMessage (DM_SETDEFID, MAKEWPARAM (IDOK, 0), 0);
    SendDlgItemMessage (IDOK, BM_SETSTYLE, BS_DEFPUSHBUTTON, MAKELPARAM(TRUE, 0));

    SendDlgItemMessage (IDCANCEL, BM_SETSTYLE, BS_PUSHBUTTON, MAKELPARAM(TRUE, 0));

    return 0;
}



BOOL CTemplatePropertySheet::OnHelp(WPARAM /*wParam*/, LPARAM lParam)
{
    _TRACE(1, L"Entering CTemplatePropertySheet::OnHelp\n");
   
    const LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
    if (pHelpInfo && pHelpInfo->iContextType == HELPINFO_WINDOW)
    {
        DoContextHelp ((HWND) pHelpInfo->hItemHandle);
    }

    _TRACE(-1, L"Leaving CTemplatePropertySheet::OnHelp\n");

    return TRUE;
}

void CTemplatePropertySheet::DoContextHelp (HWND hWndControl)
{
    _TRACE(1, L"Entering CTemplatePropertySheet::DoContextHelp\n");
    const int   IDC_COMM_APPLYNOW = 12321;
    const int   IDH_COMM_APPLYNOW = 28447;
    const DWORD aHelpIDs_PropSheet[]=
    {
        IDC_COMM_APPLYNOW, IDH_COMM_APPLYNOW,
        0, 0
    };

    PWSTR  pszHelpFile = 0;
    switch (::GetDlgCtrlID (hWndControl))
    {
    case IDC_COMM_APPLYNOW:
        pszHelpFile = L"windows.hlp";
        break;

    default:
        // Display context help for a control
        pszHelpFile = const_cast<PWSTR> (GetContextHelpFile ());
        break;
    }

    if ( !::WinHelp (
            hWndControl,
            pszHelpFile,
            HELP_WM_HELP,
            (DWORD_PTR) aHelpIDs_PropSheet) )
    {
        _TRACE(0, L"WinHelp () failed: 0x%x\n", GetLastError ());        
    }

    _TRACE(-1, L"Leaving CTemplatePropertySheet::DoContextHelp\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\templatepropertysheet.h ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       TemplatePropertySheet.h
//
//  Contents:   interface for the CTemplatePropertySheet class.
//
//----------------------------------------------------------------------------
// NTRAID# 496094 CertTMPL: German - Duplicating a template has one of the 
// tabs and part of some buttons chopped-off from view.
// This happens because the security page is added on the fly: the property 
// sheet size is already calculated.  So add a dummy placeholder to ensure
// the correct size of the property sheet and then remove it on the fly.

#if !defined(AFX_TEMPLATEPROPERTYSHEET_H__E4EE749E_308A_4F88_8DA0_97E1EF292D67__INCLUDED_)
#define AFX_TEMPLATEPROPERTYSHEET_H__E4EE749E_308A_4F88_8DA0_97E1EF292D67__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "CertTemplate.h"

class CTemplatePropertySheet : public CPropertySheet  
{
public:
	CTemplatePropertySheet(
            LPCTSTR pszCaption, 
            CCertTemplate& m_rCertTemplate, 
            CWnd *pParentWnd = NULL, 
            UINT iSelectPage = 0 );
	virtual ~CTemplatePropertySheet();

protected:
    virtual BOOL OnInitDialog();

	// Generated message map functions
	//{{AFX_MSG(CTemplatePropertySheet)
	//}}AFX_MSG
    afx_msg LRESULT OnAddSecurityPage (WPARAM, LPARAM);
    afx_msg LRESULT OnSetOKDefault (WPARAM, LPARAM);
	DECLARE_MESSAGE_MAP()

    BOOL OnHelp(WPARAM wParam, LPARAM lParam);
	virtual void DoContextHelp (HWND hWndControl);

private:
    CCertTemplate&  m_rCertTemplate;
    LPSECURITYINFO  m_pReleaseMe;
};

#endif // !defined(AFX_TEMPLATEPROPERTYSHEET_H__E4EE749E_308A_4F88_8DA0_97E1EF292D67__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\templatev1requestpropertypage.cpp ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       TemplateV1RequestPropertyPage.cpp
//
//  Contents:   Implementation of CTemplateV1RequestPropertyPage
//
//----------------------------------------------------------------------------
// TemplateV1RequestPropertyPage.cpp : implementation file
//

#include "stdafx.h"
#include "TemplateV1RequestPropertyPage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTemplateV1RequestPropertyPage property page
enum {
    REQUEST_PURPOSE_SIGNATURE = 0,
    REQUEST_PURPOSE_ENCRYPTION,
    REQUEST_PURPOSE_SIGNATURE_AND_ENCRYPTION
};

CTemplateV1RequestPropertyPage::CTemplateV1RequestPropertyPage(CCertTemplate& rCertTemplate) : 
    CHelpPropertyPage(CTemplateV1RequestPropertyPage::IDD),
    m_rCertTemplate (rCertTemplate)
{
    _TRACE (1, L"Entering CTemplateV1RequestPropertyPage::CTemplateV1RequestPropertyPage ()\n");
	//{{AFX_DATA_INIT(CTemplateV1RequestPropertyPage)
	//}}AFX_DATA_INIT
    m_rCertTemplate.AddRef ();

    _TRACE (-1, L"Leaving CTemplateV1RequestPropertyPage::CTemplateV1RequestPropertyPage ()\n");
}

CTemplateV1RequestPropertyPage::~CTemplateV1RequestPropertyPage()
{
    _TRACE (1, L"Entering CTemplateV1RequestPropertyPage::~CTemplateV1RequestPropertyPage ()\n");
   m_rCertTemplate.Release ();
    _TRACE (-1, L"Leaving CTemplateV1RequestPropertyPage::~CTemplateV1RequestPropertyPage ()\n");
}

void CTemplateV1RequestPropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CHelpPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTemplateV1RequestPropertyPage)
	DDX_Control(pDX, IDC_PURPOSE_COMBO, m_purposeCombo);
	DDX_Control(pDX, IDC_CSP_LIST, m_CSPList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTemplateV1RequestPropertyPage, CHelpPropertyPage)
	//{{AFX_MSG_MAP(CTemplateV1RequestPropertyPage)
	ON_CBN_SELCHANGE(IDC_PURPOSE_COMBO, OnSelchangePurposeCombo)
	ON_BN_CLICKED(IDC_EXPORT_PRIVATE_KEY, OnExportPrivateKey)
	//}}AFX_MSG_MAP
    ON_CONTROL(CLBN_CHKCHANGE, IDC_CSP_LIST, OnCheckChange)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTemplateV1RequestPropertyPage message handlers


BOOL CTemplateV1RequestPropertyPage::OnInitDialog() 
{
    _TRACE (1, L"Entering CTemplateV1RequestPropertyPage::OnInitDialog ()\n");
	CHelpPropertyPage::OnInitDialog();

    CString text;

    VERIFY (text.LoadString (IDS_SIGNATURE));
    int nIndex = m_purposeCombo.AddString (text);
    if ( nIndex >= 0 )
    {
        m_purposeCombo.SetItemData (nIndex, (DWORD_PTR) REQUEST_PURPOSE_SIGNATURE);
        if ( m_rCertTemplate.HasKeySpecSignature () )
            m_purposeCombo.SetCurSel (nIndex);
    }

    VERIFY (text.LoadString (IDS_ENCRYPTION));
    nIndex = m_purposeCombo.AddString (text);
    if ( nIndex >= 0 )
    {
        m_purposeCombo.SetItemData (nIndex, (DWORD_PTR) REQUEST_PURPOSE_ENCRYPTION);
        if ( m_rCertTemplate.HasEncryptionSignature () )
            m_purposeCombo.SetCurSel (nIndex);
    }
    
    VERIFY (text.LoadString (IDS_SIGNATURE_AND_ENCRYPTION));
    nIndex = m_purposeCombo.AddString (text);
    if ( nIndex >= 0 )
    {
        // NTRAID# 269907  Certificate Template Snap-in: Should set the 
        // purpose of the template to both signature and encryption if 
        // CERT_DIGITAL_SIGNATURE_KEY_USAGE is set
        bool bHasDigitalSignature = false;
        m_rCertTemplate.GetDigitalSignature (bHasDigitalSignature);

        m_purposeCombo.SetItemData (nIndex, (DWORD_PTR) REQUEST_PURPOSE_SIGNATURE_AND_ENCRYPTION);
        if ( m_rCertTemplate.HasEncryptionSignature () && 
                (bHasDigitalSignature || m_rCertTemplate.HasKeySpecSignature ()) )
            m_purposeCombo.SetCurSel (nIndex);
    }


    if ( SUCCEEDED (EnumerateCSPs ()) )
    {

    }

   
    if ( m_rCertTemplate.PrivateKeyIsExportable () )
        SendDlgItemMessage (IDC_EXPORT_PRIVATE_KEY, BM_SETCHECK, BST_CHECKED);

    EnableControls ();

    _TRACE (-1, L"Leaving CTemplateV1RequestPropertyPage::OnInitDialog ()\n");
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CTemplateV1RequestPropertyPage::EnableControls ()
{
    GetDlgItem (IDC_PURPOSE_COMBO)->EnableWindow (FALSE);

    int nCnt = m_CSPList.GetCount ();
    for (int nIndex = 0; nIndex < nCnt; nIndex++)
        m_CSPList.Enable (nIndex, FALSE);

    GetDlgItem (IDC_EXPORT_PRIVATE_KEY)->EnableWindow (FALSE);
}



HRESULT CTemplateV1RequestPropertyPage::EnumerateCSPs()
{
    _TRACE (1, L"Entering CTemplateV1RequestPropertyPage::EnumerateCSPs\n");
    HRESULT hr = S_OK;
    for (DWORD dwIndex = 0; ;dwIndex++)
    {
        DWORD   cbName = 0;
        DWORD   dwProvType = 0;

        if ( CryptEnumProviders (dwIndex, NULL, 0, &dwProvType, NULL, &cbName) )
        {
            PWSTR  pszTypeName = new WCHAR[cbName];
            if ( pszTypeName )
            {
                if ( CryptEnumProviders (dwIndex, NULL, 0, &dwProvType,
                        pszTypeName, &cbName) )
                {
                    int nIndex = m_CSPList.AddString (pszTypeName);
                    if ( nIndex < 0 )
                    {
                        _TRACE (0, L"AddString (%s) failed: %d\n", nIndex);
                        break;
                    }
                }
                else
                {
                    hr = HRESULT_FROM_WIN32 (GetLastError ());
                    _TRACE (0, L"CryptEnumProviderTypes () failed: 0x%x\n", hr);
                    break;
                }

                delete [] pszTypeName;
            }
            else
                hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = HRESULT_FROM_WIN32 (GetLastError ());
            _TRACE (0, L"CryptEnumProviderTypes () failed: 0x%x\n", hr);
            break;
        }
    }

    int     nCSPIndex = 0;
    CString szCSP;
    while ( SUCCEEDED (m_rCertTemplate.GetCSP (nCSPIndex, szCSP)) )
    {
        int nIndex = m_CSPList.FindString (-1, szCSP);
        if ( CB_ERR != nIndex )
            m_CSPList.SetCheck (nIndex, BST_CHECKED);
        else
        {
            // was not found - add it
            nIndex = m_CSPList.AddString (szCSP);
            if ( nIndex >= 0 )
                m_CSPList.SetCheck (nIndex, BST_CHECKED);
        }
        nCSPIndex++;
    }

    _TRACE (-1, L"Entering CTemplateV1RequestPropertyPage::EnumerateCSPs: 0x%x\n", hr);
    return hr;
}



void CTemplateV1RequestPropertyPage::OnSelchangePurposeCombo() 
{
	int nIndex = m_purposeCombo.GetCurSel ();
    if ( nIndex >= 0 )
    {
        switch (m_purposeCombo.GetItemData (nIndex))
        {
        case REQUEST_PURPOSE_SIGNATURE:
            m_rCertTemplate.SetEncryptionSignature (false);
            m_rCertTemplate.SetKeySpecSignature (true);
            break;

        case REQUEST_PURPOSE_ENCRYPTION:
            m_rCertTemplate.SetEncryptionSignature (true);
            m_rCertTemplate.SetKeySpecSignature (false);
            break;

        case REQUEST_PURPOSE_SIGNATURE_AND_ENCRYPTION:
            m_rCertTemplate.SetEncryptionSignature (true);
            m_rCertTemplate.SetKeySpecSignature (true);
            break;

        default:
            _ASSERT (0);
            break;
        }
    }
    SetModified ();
	EnableControls ();
}

void CTemplateV1RequestPropertyPage::OnExportPrivateKey() 
{
    bool bMakeExportable = (BST_CHECKED == SendDlgItemMessage (IDC_EXPORT_PRIVATE_KEY, BM_GETCHECK));
	
    m_rCertTemplate.MakePrivateKeyExportable (bMakeExportable);
    SetModified ();
}


void CTemplateV1RequestPropertyPage::OnCheckChange() 
{
    int nSel = m_CSPList.GetCurSel ();
    if ( nSel >= 0 )
    {
        CString szCSPName;

        m_CSPList.GetText (nSel, szCSPName);

        if ( !szCSPName.IsEmpty () )
        {
            HRESULT hr = S_OK;
            if ( BST_CHECKED == m_CSPList.GetCheck (nSel) )
            {
                hr = m_rCertTemplate.ModifyCSPList (szCSPName, true); // add
            }
            else
            {
                hr = m_rCertTemplate.ModifyCSPList (szCSPName, false); // remove
            }
            if ( SUCCEEDED (hr) )
                SetModified ();
        }
    }
} 

void CTemplateV1RequestPropertyPage::DoContextHelp (HWND hWndControl)
{
	_TRACE(1, L"Entering CTemplateV1RequestPropertyPage::DoContextHelp\n");
    
	switch (::GetDlgCtrlID (hWndControl))
	{
	case IDC_STATIC:
		break;

	default:
		// Display context help for a control
		if ( !::WinHelp (
				hWndControl,
				GetContextHelpFile (),
				HELP_WM_HELP,
				(DWORD_PTR) g_aHelpIDs_IDD_TEMPLATE_V1_REQUEST) )
		{
			_TRACE(0, L"WinHelp () failed: 0x%x\n", GetLastError ());        
		}
		break;
	}
    _TRACE(-1, L"Leaving CTemplateV1RequestPropertyPage::DoContextHelp\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\templategeneralpropertypage.h ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       TemplateGeneralPropertyPage.h
//
//  Contents:   Definition of CTemplateGeneralPropertyPage
//
//----------------------------------------------------------------------------
#if !defined(AFX_TEMPLATEGeneralPROPERTYPAGE_H__C483A673_05AA_4185_8F37_5CB31AA23967__INCLUDED_)
#define AFX_TEMPLATEGeneralPROPERTYPAGE_H__C483A673_05AA_4185_8F37_5CB31AA23967__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// TemplateGeneralPropertyPage.h : header file
//
#include "CertTemplate.h"
#include "TemplatePropertySheet.h"

/////////////////////////////////////////////////////////////////////////////
// CTemplateGeneralPropertyPage dialog

class CTemplateGeneralPropertyPage : public CHelpPropertyPage
{
	// Construction
public:
	bool m_bIsDirty;
	LONG_PTR m_lNotifyHandle;
	CTemplateGeneralPropertyPage(CCertTemplate& rCertTemplate, 
            const CCertTmplComponentData* pCompData);
	virtual ~CTemplateGeneralPropertyPage();

    void SetAllocedSecurityInfo(LPSECURITYINFO pToBeReleased) 
    {
        m_pReleaseMe = pToBeReleased; 
    }

    void SetV2AuthPageNumber (int nPage)
    {
        m_nTemplateV2AuthPageNumber = nPage;
    }

    void SetV2RequestPageNumber (int nPage)
    {
        m_nTemplateV2RequestPageNumber = nPage;
    }
// Dialog Data
	//{{AFX_DATA(CTemplateGeneralPropertyPage)
	enum { IDD = IDD_TEMPLATE_GENERAL };
	CComboBox	m_validityUnits;
	CComboBox	m_renewalUnits;
	CString	m_strDisplayName;
	CString	m_strTemplateName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTemplateGeneralPropertyPage)
	public:
	virtual BOOL OnApply();
    virtual void OnCancel();
    protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    bool ValidateTemplateName(const CString& m_szTemplateName);
    int SetRenewalPeriod (int nMaxRenewalDays, bool bSilent);
    HRESULT EnumerateTemplates (
                IDirectoryObject* pTemplateContObj, 
                const CString& szFriendlyName, 
                bool& bFound);
    HRESULT FindFriendlyNameInEnterpriseTemplates (
                const CString& szFriendlyName, 
                bool& bFound);

	virtual void DoContextHelp (HWND hWndControl);
	// Generated message map functions
	//{{AFX_MSG(CTemplateGeneralPropertyPage)
	afx_msg void OnChangeDisplayName();
	afx_msg void OnSelchangeRenewalUnits();
	afx_msg void OnSelchangeValidityUnits();
	afx_msg void OnChangeRenewalEdit();
	afx_msg void OnChangeValidityEdit();
	afx_msg void OnPublishToAd();
	afx_msg void OnUseADCert();
	afx_msg void OnChangeTemplateName();
	afx_msg void OnKillfocusValidityEdit();
	afx_msg void OnKillfocusValidityUnits();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	virtual BOOL OnInitDialog();
    virtual void EnableControls ();

    CCertTemplate& m_rCertTemplate;

private:
	PERIOD_TYPE     m_dwCurrentRenewalUnits;
	PERIOD_TYPE     m_dwCurrentValidityUnits;
	CString         m_strOriginalName;
    CString         m_strOriginalDisplayName;
    LPSECURITYINFO  m_pReleaseMe;
    int             m_nRenewalDays;
    int             m_nValidityDays;
    const CCertTmplComponentData* m_pCompData;
    int             m_nTemplateV2AuthPageNumber;
    int             m_nTemplateV2RequestPageNumber;
};



//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TEMPLATEGeneralPROPERTYPAGE_H__C483A673_05AA_4185_8F37_5CB31AA23967__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\templategeneralpropertypage.cpp ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2002.
//
//  File:       TemplateGeneralPropertyPage.cpp
//
//  Contents:   Implementation of CTemplateGeneralPropertyPage
//
//----------------------------------------------------------------------------
// TemplateGeneralPropertyPage.cpp : implementation file
//

#include "stdafx.h"
#include "CompData.h"
#include "TemplateGeneralPropertyPage.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTemplateGeneralPropertyPage property page

CTemplateGeneralPropertyPage::CTemplateGeneralPropertyPage(
        CCertTemplate& rCertTemplate,
        const CCertTmplComponentData* pCompData) : 
    CHelpPropertyPage(CTemplateGeneralPropertyPage::IDD),
    m_rCertTemplate (rCertTemplate),
    m_strOriginalName (rCertTemplate.GetTemplateName ()),
    m_pReleaseMe (0),
    m_dwCurrentValidityUnits (PERIOD_TYPE_NONE),
    m_dwCurrentRenewalUnits (PERIOD_TYPE_NONE),
    m_lNotifyHandle (0),
    m_bIsDirty (false),
    m_nRenewalDays (0),
    m_nValidityDays (0),
    m_pCompData (pCompData),
    m_nTemplateV2AuthPageNumber (-1),
    m_nTemplateV2RequestPageNumber (-1)
{
    _TRACE (1, L"Entering CTemplateGeneralPropertyPage::CTemplateGeneralPropertyPage ()\n");
	//{{AFX_DATA_INIT(CTemplateGeneralPropertyPage)
	m_strDisplayName = _T("");
	m_strTemplateName = _T("");
	//}}AFX_DATA_INIT
    m_rCertTemplate.AddRef ();

   _TRACE (-1, L"Leaving CTemplateGeneralPropertyPage::CTemplateGeneralPropertyPage ()\n");
}

CTemplateGeneralPropertyPage::~CTemplateGeneralPropertyPage()
{
    _TRACE (1, L"Entering CTemplateGeneralPropertyPage::~CTemplateGeneralPropertyPage ()\n");
    m_rCertTemplate.Release ();

    if ( m_pReleaseMe )
    {
        m_pReleaseMe->Release ();
        m_pReleaseMe = 0;
    }

    if ( m_lNotifyHandle )
    {
        MMCFreeNotifyHandle (m_lNotifyHandle);
        m_lNotifyHandle = 0;
    }


    _TRACE (-1, L"Leaving CTemplateGeneralPropertyPage::~CTemplateGeneralPropertyPage ()\n");
}

void CTemplateGeneralPropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CHelpPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTemplateGeneralPropertyPage)
	DDX_Control(pDX, IDC_VALIDITY_UNITS, m_validityUnits);
	DDX_Control(pDX, IDC_RENEWAL_UNITS, m_renewalUnits);
	DDX_Text(pDX, IDC_DISPLAY_NAME, m_strDisplayName);
	DDV_MaxChars(pDX, m_strDisplayName, MAX_TEMPLATE_NAME_LEN);
	DDX_Text(pDX, IDC_TEMPLATE_NAME, m_strTemplateName);
	DDV_MaxChars(pDX, m_strTemplateName, MAX_TEMPLATE_NAME_LEN);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTemplateGeneralPropertyPage, CHelpPropertyPage)
	//{{AFX_MSG_MAP(CTemplateGeneralPropertyPage)
	ON_EN_CHANGE(IDC_DISPLAY_NAME, OnChangeDisplayName)
	ON_CBN_SELCHANGE(IDC_RENEWAL_UNITS, OnSelchangeRenewalUnits)
	ON_CBN_SELCHANGE(IDC_VALIDITY_UNITS, OnSelchangeValidityUnits)
	ON_EN_CHANGE(IDC_RENEWAL_EDIT, OnChangeRenewalEdit)
	ON_EN_CHANGE(IDC_VALIDITY_EDIT, OnChangeValidityEdit)
	ON_BN_CLICKED(IDC_PUBLISH_TO_AD, OnPublishToAd)
	ON_BN_CLICKED(IDC_USE_AD_CERT_FOR_REENROLLMENT, OnUseADCert)
	ON_EN_CHANGE(IDC_TEMPLATE_NAME, OnChangeTemplateName)
	ON_EN_KILLFOCUS(IDC_VALIDITY_EDIT, OnKillfocusValidityEdit)
	ON_CBN_KILLFOCUS(IDC_VALIDITY_UNITS, OnKillfocusValidityUnits)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTemplateGeneralPropertyPage message handlers


BOOL CTemplateGeneralPropertyPage::OnInitDialog() 
{
    _TRACE (1, L"Entering CTemplateGeneralPropertyPage::OnInitDialog ()\n");
	CHelpPropertyPage::OnInitDialog();

    SendDlgItemMessage (IDC_VALIDITY_EDIT, EM_LIMITTEXT, 4, 0);
    SendDlgItemMessage (IDC_RENEWAL_EDIT, EM_LIMITTEXT, 4, 0);
    
    CString version;
    if ( 1 == m_rCertTemplate.GetType () )
    {
        VERIFY (version.LoadString (IDS_WINDOWS_2000_AND_LATER));
    }
    else
    {
        VERIFY (version.LoadString (IDS_WINDOWS_2002_AND_LATER));
    }
    
    SetDlgItemText (IDC_TEMPLATE_VERSION, version);
    

    if ( m_rCertTemplate.IsClone () )
    {
        GetDlgItem (IDC_CANT_CHANGE_TEMPLATE_NAME)->ShowWindow (SW_SHOW);
    }
    else
    {
        // The template name is only editable if the template is a clone. Since
        // this is not a clone, disable the template name fields.
        GetDlgItem (IDC_TEMPLATE_NAME)->EnableWindow (FALSE);
        GetDlgItem (IDC_TEMPLATE_NAME_LABEL)->EnableWindow (FALSE);

        // #NTRAID 360650: Cert Server: Cannot rename cert templates
        GetDlgItem (IDC_DISPLAY_NAME)->EnableWindow (FALSE);
        GetDlgItem (IDC_DISPLAY_NAME_LABEL)->EnableWindow (FALSE);
    }

    m_strTemplateName = m_rCertTemplate.GetTemplateName ();
    m_strOriginalDisplayName = m_strDisplayName = m_rCertTemplate.GetDisplayName ();

    // Get validity period, determine current units and then initialize drop down
    HRESULT hr = m_rCertTemplate.GetValidityPeriod (m_nValidityDays);
    if ( SUCCEEDED (hr) )
    {
        int nValue = m_nValidityDays;
        if ( nValue % 365 == 0 )
        {
            nValue /= 365;
            m_dwCurrentValidityUnits = PERIOD_TYPE_YEAR;

        }
        else if ( nValue % 30 == 0 )
        {
            nValue /= 30;
            m_dwCurrentValidityUnits = PERIOD_TYPE_MONTH;
        }
        else if ( nValue % 7 == 0 )
        {
            nValue /= 7;
            m_dwCurrentValidityUnits = PERIOD_TYPE_WEEK;
        }
        else
            m_dwCurrentValidityUnits = PERIOD_TYPE_DAY;
        SetDlgItemInt (IDC_VALIDITY_EDIT, (UINT) nValue, FALSE);
    }

    hr = m_rCertTemplate.GetRenewalPeriod (m_nRenewalDays);
    if ( SUCCEEDED (hr) )
    {
        int nValue = m_nRenewalDays;

        // NTRAID# 353945 - if the renewal period is 0, the units should match
        // those selected for the validity period.
        if ( 0 == nValue )
        {
            m_dwCurrentRenewalUnits = m_dwCurrentValidityUnits;
        }
        else if ( nValue % 365 == 0 )
        {
            nValue /= 365;
            m_dwCurrentRenewalUnits = PERIOD_TYPE_YEAR;

        }
        else if ( nValue % 30 == 0 )
        {
            nValue /= 30;
            m_dwCurrentRenewalUnits = PERIOD_TYPE_MONTH;
        }
        else if ( nValue % 7 == 0 )
        {
            nValue /= 7;
            m_dwCurrentRenewalUnits = PERIOD_TYPE_WEEK;
        }
        else
            m_dwCurrentRenewalUnits = PERIOD_TYPE_DAY;
        SetDlgItemInt (IDC_RENEWAL_EDIT, (UINT) nValue, FALSE);
    }

    // Now that we know what units the validity and renewal periods are
    // to be displayed in, initialize the dropdowns and select the
    // appropriate unit
    // Initialize validity and renewal period dropdowns
    CString text;
    VERIFY (text.LoadString (IDS_DAYS));
    int nIndex = m_validityUnits.AddString (text);
    if ( nIndex >= 0 )
    {
        m_validityUnits.SetItemData (nIndex, PERIOD_TYPE_DAY);
        if ( PERIOD_TYPE_DAY == m_dwCurrentValidityUnits )
            m_validityUnits.SetCurSel (nIndex);
    }

    nIndex = m_renewalUnits.AddString (text);
    if ( nIndex >= 0 )
    {
        m_renewalUnits.SetItemData (nIndex, PERIOD_TYPE_DAY);
        if ( PERIOD_TYPE_DAY == m_dwCurrentRenewalUnits )
            m_renewalUnits.SetCurSel (nIndex);
    }

    VERIFY (text.LoadString (IDS_WEEKS));
    nIndex = m_validityUnits.AddString (text);
    if ( nIndex >= 0 )
    {
        m_validityUnits.SetItemData (nIndex, PERIOD_TYPE_WEEK);
        if ( PERIOD_TYPE_WEEK == m_dwCurrentValidityUnits )
            m_validityUnits.SetCurSel (nIndex);
    }
    nIndex = m_renewalUnits.AddString (text);
    if ( nIndex >= 0 )
    {
        m_renewalUnits.SetItemData (nIndex, PERIOD_TYPE_WEEK);
        if ( PERIOD_TYPE_WEEK == m_dwCurrentRenewalUnits )
            m_renewalUnits.SetCurSel (nIndex);
    }

    VERIFY (text.LoadString (IDS_MONTHS));
    nIndex = m_validityUnits.AddString (text);
    if ( nIndex >= 0 )
    {
        m_validityUnits.SetItemData (nIndex, PERIOD_TYPE_MONTH);
        if ( PERIOD_TYPE_MONTH == m_dwCurrentValidityUnits )
            m_validityUnits.SetCurSel (nIndex);
    }
    nIndex = m_renewalUnits.AddString (text);
    if ( nIndex >= 0 )
    {
        m_renewalUnits.SetItemData (nIndex, PERIOD_TYPE_MONTH);
        if ( PERIOD_TYPE_MONTH == m_dwCurrentRenewalUnits )
            m_renewalUnits.SetCurSel (nIndex);
    }

    VERIFY (text.LoadString (IDS_YEARS));
    nIndex = m_validityUnits.AddString (text);
    if ( nIndex >= 0 )
    {
        m_validityUnits.SetItemData (nIndex, PERIOD_TYPE_YEAR);
        if ( PERIOD_TYPE_YEAR == m_dwCurrentValidityUnits )
            m_validityUnits.SetCurSel (nIndex);
    }
    nIndex = m_renewalUnits.AddString (text);
    if ( nIndex >= 0 )
    {
        m_renewalUnits.SetItemData (nIndex, PERIOD_TYPE_YEAR);
        if ( PERIOD_TYPE_YEAR == m_dwCurrentRenewalUnits )
            m_renewalUnits.SetCurSel (nIndex);
    }


    if ( m_rCertTemplate.PublishToDS () )
        SendDlgItemMessage (IDC_PUBLISH_TO_AD, BM_SETCHECK, BST_CHECKED);

    if ( m_rCertTemplate.CheckDSCert () )
        SendDlgItemMessage (IDC_USE_AD_CERT_FOR_REENROLLMENT, BM_SETCHECK, BST_CHECKED);


    EnableControls ();

    UpdateData (FALSE);


    m_bIsDirty = false;  // because SetDlgItemInt () sets it to true

    if ( m_rCertTemplate.IsClone () )
    {
        SetModified ();
        m_bIsDirty = true;
    }

    _TRACE (-1, L"Leaving CTemplateGeneralPropertyPage::OnInitDialog ()\n");
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CTemplateGeneralPropertyPage::EnableControls ()
{
    if ( 1 == m_rCertTemplate.GetType () || m_rCertTemplate.ReadOnly () )
    {
        GetDlgItem (IDC_TEMPLATE_NAME)->EnableWindow (FALSE);
        GetDlgItem (IDC_TEMPLATE_NAME_LABEL)->EnableWindow (FALSE);
        GetDlgItem (IDC_DISPLAY_NAME)->EnableWindow (FALSE);
        GetDlgItem (IDC_DISPLAY_NAME_LABEL)->EnableWindow (FALSE);
        GetDlgItem (IDC_VALIDITY_UNITS)->EnableWindow (FALSE);
        GetDlgItem (IDC_VALIDITY_EDIT)->EnableWindow (FALSE);
        GetDlgItem (IDC_RENEWAL_UNITS)->EnableWindow (FALSE);
        GetDlgItem (IDC_RENEWAL_EDIT)->EnableWindow (FALSE);
        GetDlgItem (IDC_PUBLISH_TO_AD)->EnableWindow (FALSE);
        GetDlgItem (IDC_USE_AD_CERT_FOR_REENROLLMENT)->EnableWindow (FALSE);
    }
    else if ( m_rCertTemplate.IsDefault () )
    {
        GetDlgItem (IDC_DISPLAY_NAME)->EnableWindow (FALSE);
    }
    else
    {
        if ( BST_CHECKED == SendDlgItemMessage (IDC_PUBLISH_TO_AD, BM_GETCHECK) )
            GetDlgItem (IDC_USE_AD_CERT_FOR_REENROLLMENT)->EnableWindow (TRUE);
        else
            GetDlgItem (IDC_USE_AD_CERT_FOR_REENROLLMENT)->EnableWindow (FALSE);
    }
}


void CTemplateGeneralPropertyPage::OnCancel()
{
    if ( !m_rCertTemplate.IsClone () )
        m_rCertTemplate.Cancel ();


    CHelpPropertyPage::OnCancel ();
}

int CTemplateGeneralPropertyPage::SetRenewalPeriod (int nMaxRenewalDays, bool bSilent)
{
    CThemeContextActivator activator;
    CString caption;
    CString text;
    CString timeUnit;
    int     nAmount = 0;

    VERIFY (caption.LoadString (IDS_CERTTMPL));

    if ( nMaxRenewalDays % 365 == 0 )
    {
        nAmount = nMaxRenewalDays/365;
        if ( 1 == nAmount )
            VERIFY (timeUnit.LoadString (IDS_YEAR));
        else
            VERIFY (timeUnit.LoadString (IDS_YEARS));
    }
    else if ( nMaxRenewalDays % 30 == 0 )
    {
        nAmount = nMaxRenewalDays/30;
        if ( 1 == nAmount )
            VERIFY (timeUnit.LoadString (IDS_MONTH));
        else
            VERIFY (timeUnit.LoadString (IDS_MONTHS));
    }
    else if ( nMaxRenewalDays % 7 == 0 )
    {
        nAmount = nMaxRenewalDays/7;
        if ( 1 == nAmount )
            VERIFY (timeUnit.LoadString (IDS_WEEK));
        else
            VERIFY (timeUnit.LoadString (IDS_WEEKS));
    }
    else 
    {
        nAmount = nMaxRenewalDays;
        if ( 1 == nMaxRenewalDays )
            VERIFY (timeUnit.LoadString (IDS_DAY));
        else
            VERIFY (timeUnit.LoadString (IDS_DAYS));
    }
    // security review 2/20/2002 BryanWal ok
    text.FormatMessage (IDS_RENEWAL_MUST_BE_LESS_THAN_VALIDITY,
            nAmount, timeUnit);

    int nRetVal = IDOK;
    
    if ( !bSilent )
        nRetVal = MessageBox (text, caption, MB_OKCANCEL);
    if ( IDOK == nRetVal )
    {
        HRESULT hr = m_rCertTemplate.SetRenewalPeriod (nMaxRenewalDays);
        if ( SUCCEEDED (hr) )
        {
            m_nRenewalDays = nMaxRenewalDays;
            int nValue = m_nRenewalDays;
            if ( 0 == nValue )
            {
                m_dwCurrentRenewalUnits = m_dwCurrentValidityUnits;
            }
            else if ( nValue % 365 == 0 )
            {
                nValue /= 365;
                m_dwCurrentRenewalUnits = PERIOD_TYPE_YEAR;

            }
            else if ( nValue % 30 == 0 )
            {
                nValue /= 30;
                m_dwCurrentRenewalUnits = PERIOD_TYPE_MONTH;
            }
            else if ( nValue % 7 == 0 )
            {
                nValue /= 7;
                m_dwCurrentRenewalUnits = PERIOD_TYPE_WEEK;
            }
            else
                m_dwCurrentRenewalUnits = PERIOD_TYPE_DAY;

            int nCnt = m_renewalUnits.GetCount ();
            while (--nCnt >= 0)
            {
                if ( m_dwCurrentRenewalUnits == (PERIOD_TYPE) m_renewalUnits.GetItemData (nCnt) )
                {
                    m_renewalUnits.SetCurSel (nCnt);
                    break;
                }
            }

            // Must set this after the units
            SetDlgItemInt (IDC_RENEWAL_EDIT, (UINT) nValue, FALSE);


            SetModified ();
            m_bIsDirty = true;
        }
    }

    return nRetVal;
}

#define ILLEGAL_FAT_CHARS   L"\"+,;<=>"

bool CTemplateGeneralPropertyPage::ValidateTemplateName(const CString& m_szTemplateName)
{
    bool    bRVal = true;

    PCWSTR szInvalidCharSet = ILLEGAL_FAT_CHARS; 


    if ( -1 != m_szTemplateName.FindOneOf (szInvalidCharSet) )
    {
        bRVal = false;
        CString text;
        CString caption;

        VERIFY (caption.LoadString (IDS_CERTTMPL));
        CString charsWithSpaces;

        UINT nIndex = 0;
        while (szInvalidCharSet[nIndex])
        {
            charsWithSpaces += szInvalidCharSet[nIndex];
            charsWithSpaces += L"  ";
            nIndex++;
        }
        // security review 2/20/2002 BryanWal ok
        text.FormatMessage (IDS_TEMPLATE_NAME_CONTAINS_INVALID_CHARS, charsWithSpaces);

        MessageBox (text, caption, MB_OK);
        GetDlgItem (IDC_TEMPLATE_NAME)->SetFocus ();
    }

    return bRVal;
}

BOOL CTemplateGeneralPropertyPage::OnApply() 
{
    UpdateData (TRUE);

    if ( m_rCertTemplate.GetType () > 1 && m_bIsDirty )
    {
        HRESULT hr = S_OK;

        if ( m_rCertTemplate.IssuancePoliciesRequired () )
        {
            CString text;
            CString caption;

            VERIFY (caption.LoadString (IDS_CERTTMPL));
            VERIFY (text.LoadString (IDS_MUST_ADD_RA_ISSUANCE_POLICY));

            MessageBox (text, caption, MB_OK);

            if ( -1 != m_nTemplateV2AuthPageNumber )
            {
                CWnd* pParent = GetParent ();
                if ( pParent )
                {
                    pParent->SendMessage (PSM_SETCURSEL, 
                            m_nTemplateV2AuthPageNumber);
                }
            }

            return FALSE;
        }


        // NTRAID# 331178 Certtmpl: All Certificate Templates must enforce 
        // that the certificate Renewal Period < = 75% of the Validity Period
        int nMaxRenewalDays = (m_nValidityDays * 3) / 4;
        if ( nMaxRenewalDays < m_nRenewalDays )
        {
            if ( IDOK != SetRenewalPeriod (nMaxRenewalDays, false) )
            {
                CWnd* pParent = GetParent ();
                if ( pParent )
                    pParent->SendMessage (PSM_SETCURSEL, 0);
                GetDlgItem (IDC_VALIDITY_EDIT)->SetFocus ();
                return FALSE;
            }
        }

        // NTRAID# 353945: Certtmpl: Changing V2 certificate template validity 
        // period to 1 Day, automatically sets the renewal period to 0 years
        if ( m_nValidityDays < 2 )
        {
            CString text;
            CString caption;

            VERIFY (caption.LoadString (IDS_CERTTMPL));
            VERIFY (text.LoadString (IDS_2_DAY_SMALLEST_VALIDITY));

            MessageBox (text, caption, MB_OK);

            CWnd* pParent = GetParent ();
            if ( pParent )
                pParent->SendMessage (PSM_SETCURSEL, 0);
            GetDlgItem (IDC_VALIDITY_EDIT)->SetFocus ();
            return FALSE;
        }

        // Note: The CERTYPE_PROP_CN resets the CERTTYPE_PROP_FRIENDLY_NAME 
        // and so must be set before it.
        bool   bResetDisplayName = false;
        if ( LocaleStrCmp (m_strTemplateName, m_rCertTemplate.GetTemplateName ()) )
        {
            bResetDisplayName = true;

            // Check new name for invalid characters
            m_strTemplateName.TrimLeft ();
            m_strTemplateName.TrimRight ();

            if ( !ValidateTemplateName (m_strTemplateName) )
                return FALSE;

            if ( _wcsicmp (m_strOriginalName, m_strTemplateName) ) // was renamed
            {
                // Ensure that the selected name is unique
                HCERTTYPE   hCertType = 0;
                bool        bFound = false;
                hr = CAFindCertTypeByName (m_rCertTemplate.GetTemplateName (), 
                        NULL,
                        CT_ENUM_MACHINE_TYPES | CT_ENUM_USER_TYPES | CT_FLAG_NO_CACHE_LOOKUP,
                        &hCertType);
                if ( SUCCEEDED (hr) )
                {
                    bFound = TRUE;
                    hr = CACloseCertType (hCertType);
                    if ( FAILED (hr) )
                    {
                        _TRACE (0, L"CACloseCertType () failed: 0x%x", hr);
                    }
                }
                else
                {
                    if ( m_pCompData )
                    {
                        POSITION                pos = 0;
                        for (pos = m_pCompData->m_globalTemplateNameList.GetHeadPosition (); pos;)
                        {
                            if ( !_wcsicmp (m_strTemplateName, 
                                    m_pCompData->m_globalTemplateNameList.GetNext (pos)) )
                            {
                                bFound = true;
                                break;
                            }
                        }
                    }
                }

                if ( bFound )
                {
                    CString caption;
                    CString text;

                    VERIFY (caption.LoadString (IDS_CERTTMPL));
                    // security review 2/20/2002 BryanWal ok
                    text.FormatMessage (IDS_ENTER_UNIQUE_TEMPLATE_NAME, 
                            m_strTemplateName);

                    MessageBox (text, caption, MB_OK);
                    GetDlgItem (IDC_TEMPLATE_NAME)->SetFocus ();

                    return FALSE;
                }
            }

            hr = m_rCertTemplate.SetTemplateName (m_strTemplateName);
            if ( FAILED (hr) )
            {
                CString caption;
                CString text;

                VERIFY (caption.LoadString (IDS_CERTTMPL));
                // security review 2/20/2002 BryanWal ok
                text.FormatMessage (IDS_CANNOT_CHANGE_TEMPLATE_NAME, hr);

                MessageBox (text, caption, MB_OK | MB_ICONWARNING);
                CWnd* pParent = GetParent ();
                if ( pParent )
                    pParent->SendMessage (PSM_SETCURSEL, 0);
                GetDlgItem (IDC_TEMPLATE_NAME)->SetFocus ();

                return FALSE;
            }
        }

        // Check if the display name has changed.  Don't allow reuse of existing names.
        if ( bResetDisplayName || _wcsicmp (m_strDisplayName, m_strOriginalDisplayName) )
        {
            bool                    bFound = false;

            if ( m_pCompData )
            {
                POSITION                pos = 0;
                for (pos = m_pCompData->m_globalFriendlyNameList.GetHeadPosition (); pos;)
                {
                    if ( !_wcsicmp (m_strDisplayName, 
                            m_pCompData->m_globalFriendlyNameList.GetNext (pos)) )
                    {
                        bFound = true;
                        break;
                    }
                }
            }
            else
            {
                // Generate list of templates and search for name.  This should only be called
                // from the shell extension because it doesn't build the list of templates
                // beforehand
                hr = FindFriendlyNameInEnterpriseTemplates (
                            m_strDisplayName, 
                            bFound);
            }

            if ( bFound )
            {
                CString caption;
                CString text;

                VERIFY (caption.LoadString (IDS_CERTTMPL));
                // security review 2/20/2002 BryanWal ok
                text.FormatMessage (IDS_FRIENDLY_NAME_ALREADY_USED, m_strDisplayName);

                MessageBox (text, caption, MB_OK);
                return FALSE;
            }
            else
            {
                hr = m_rCertTemplate.SetDisplayName (m_strDisplayName, true);
                if ( FAILED (hr) )
                {
                    CString caption;
                    CString text;

                    VERIFY (caption.LoadString (IDS_CERTTMPL));
                    // security review 2/20/2002 BryanWal ok
                    text.FormatMessage (IDS_CANNOT_CHANGE_DISPLAY_NAME, hr);

                    MessageBox (text, caption, MB_OK | MB_ICONWARNING);
                    GetDlgItem (IDC_DISPLAY_NAME)->SetFocus ();

                    return FALSE;
                }
            }
        }


//        // NTRAID# 276180 Certificate Template Snap-in: Grey out "Allow 
//        // Autoenrollment" context menu based on properties of the template
//        DWORD   dwNumSignatures = 0;
//        m_rCertTemplate.GetRANumSignaturesRequired (dwNumSignatures);
//        if ( m_rCertTemplate.RequireSubjectInRequest () ||
//                dwNumSignatures >= 2 && !m_rCertTemplate.ReenrollmentValidWithPreviousApproval () )
//        {
//            m_rCertTemplate.SetAutoEnrollment (false);
//        }

        hr = m_rCertTemplate.SaveChanges ();
        if ( SUCCEEDED (hr) )
        {
            m_strOriginalName = m_strTemplateName;
            hr = MMCPropertyChangeNotify (m_lNotifyHandle,  // handle to a notification
                    (LPARAM) &m_rCertTemplate);           // unique identifier

            if ( bResetDisplayName )
            {
                // name has changed. We need to close m_hCertType and reopen it
                m_rCertTemplate.Cancel (); // closes and reopens without 
                                            // saving. Since changes are already
                                            // saved, this is not a problem
            }

            // Now that the template has been saved, never allow the internal 
            // name to be edited.
            GetDlgItem (IDC_TEMPLATE_NAME)->EnableWindow (FALSE);
            GetDlgItem (IDC_TEMPLATE_NAME_LABEL)->EnableWindow (FALSE);

            // #NTRAID 360650: Cert Server: Cannot rename cert templates
            GetDlgItem (IDC_DISPLAY_NAME)->EnableWindow (FALSE);
            GetDlgItem (IDC_DISPLAY_NAME_LABEL)->EnableWindow (FALSE);
        }
        else
        {
            CString caption;
            CString text;

            VERIFY (caption.LoadString (IDS_CERTTMPL));
            // security review 2/20/2002 BryanWal ok
            text.FormatMessage (IDS_UNABLE_TO_SAVE_CERT_TEMPLATE_CHANGES, GetSystemMessage (hr));

            MessageBox (text, caption, MB_OK | MB_ICONWARNING);
            return FALSE;
        }

        m_bIsDirty = false;
    }


    return CHelpPropertyPage::OnApply();
}

void CTemplateGeneralPropertyPage::OnChangeDisplayName() 
{
	SetModified ();	
    m_bIsDirty = true;
    if ( m_rCertTemplate.IsClone () )
    {
        CString text;

        GetDlgItemText (IDC_DISPLAY_NAME, text);

        // strip out spaces
        PCWSTR  pszSrc = (PCWSTR) text;

        const int  LEN = text.GetLength () + 1; 
        PWSTR   pszTgt = new WCHAR[LEN];
        PWSTR   pszTgtPtr = pszTgt;
        // security review 2/20/2002 BryanWal ok
        ::ZeroMemory (pszTgt, LEN * sizeof (WCHAR));

        for (; *pszSrc; pszSrc++)
        {
            if ( !iswspace (*pszSrc) )
            {
                *pszTgtPtr = *pszSrc;
                pszTgtPtr++;
            }
        }

        SetDlgItemText (IDC_TEMPLATE_NAME, pszTgt);
        delete [] pszTgt;
    }
}

void CTemplateGeneralPropertyPage::OnChangeTemplateName() 
{
    UpdateData (TRUE);
    SetModified ();
    m_bIsDirty = true;
}


void CTemplateGeneralPropertyPage::OnSelchangeRenewalUnits() 
{
    OnChangeRenewalEdit ();
}

void CTemplateGeneralPropertyPage::OnSelchangeValidityUnits() 
{
    OnChangeValidityEdit ();
}

void CTemplateGeneralPropertyPage::OnChangeRenewalEdit() 
{
    HRESULT     hr = S_OK;
    int         nCurSel = m_renewalUnits.GetCurSel ();
    if ( nCurSel < 0 )
        return;

    int         nCurVal = GetDlgItemInt (IDC_RENEWAL_EDIT);
    DWORD dwRenewalUnits = (PERIOD_TYPE) m_renewalUnits.GetItemData (nCurSel);

    // convert to days
	switch ( dwRenewalUnits )
    {
    case PERIOD_TYPE_DAY:
        m_dwCurrentRenewalUnits = PERIOD_TYPE_DAY;
        break; // do nothing - is already days

    case PERIOD_TYPE_WEEK:
        m_dwCurrentRenewalUnits = PERIOD_TYPE_WEEK;
        nCurVal *= 7;
        break;

    case PERIOD_TYPE_MONTH:
        m_dwCurrentRenewalUnits = PERIOD_TYPE_MONTH;
        nCurVal *= 30;
        break;

    case PERIOD_TYPE_YEAR:
        m_dwCurrentRenewalUnits = PERIOD_TYPE_YEAR;
        nCurVal *= 365;
        break;

    case PERIOD_TYPE_NONE:
    default:
        m_dwCurrentRenewalUnits = PERIOD_TYPE_NONE;
        _ASSERT (0);
        hr = E_FAIL; //don't know what the units are
        break;
    }

    if ( SUCCEEDED (hr) )
    {
        hr = m_rCertTemplate.SetRenewalPeriod (nCurVal);
        if ( SUCCEEDED (hr) )
        {
            m_nRenewalDays = nCurVal;
    	    SetModified ();
            m_bIsDirty = true;
        }
    }
}

void CTemplateGeneralPropertyPage::OnChangeValidityEdit() 
{
    HRESULT     hr = S_OK;
    int         nCurSel = m_validityUnits.GetCurSel ();
    if ( nCurSel < 0 )
        return;
    
    int         nCurVal = GetDlgItemInt (IDC_VALIDITY_EDIT);
    PERIOD_TYPE dwValidityUnits = (PERIOD_TYPE) m_validityUnits.GetItemData (nCurSel);

    // convert to days
	switch ( dwValidityUnits )
    {
    case PERIOD_TYPE_DAY:
        m_dwCurrentValidityUnits = PERIOD_TYPE_DAY;
        break; // do nothing - is already days

    case PERIOD_TYPE_WEEK:
        m_dwCurrentValidityUnits = PERIOD_TYPE_WEEK;
        nCurVal *= 7;
        break;

    case PERIOD_TYPE_MONTH:
        m_dwCurrentValidityUnits = PERIOD_TYPE_MONTH;
        nCurVal *= 30;
        break;

    case PERIOD_TYPE_YEAR:
        m_dwCurrentValidityUnits = PERIOD_TYPE_YEAR;
        nCurVal *= 365;
        break;

    case PERIOD_TYPE_NONE:
    default:
        m_dwCurrentValidityUnits = PERIOD_TYPE_NONE;
        _ASSERT (0);
        hr = E_FAIL; //don't know what the units are
        break;
    }

    if ( SUCCEEDED (hr) )
    {
        hr = m_rCertTemplate.SetValidityPeriod (nCurVal);
        if ( SUCCEEDED (hr) )
        {
            m_nValidityDays = nCurVal;
    	    SetModified ();
            m_bIsDirty = true;
        }
    }
}

void CTemplateGeneralPropertyPage::OnPublishToAd() 
{
    bool bPublishToAD = BST_CHECKED == SendDlgItemMessage (IDC_PUBLISH_TO_AD, BM_GETCHECK);
    m_rCertTemplate.SetPublishToDS (bPublishToAD);
    if ( !bPublishToAD )
    {
        SendDlgItemMessage (IDC_USE_AD_CERT_FOR_REENROLLMENT, BM_SETCHECK, BST_UNCHECKED);
        m_rCertTemplate.SetCheckDSCert (false);
    }
	SetModified ();
    m_bIsDirty = true;
    EnableControls ();
}

void CTemplateGeneralPropertyPage::DoContextHelp (HWND hWndControl)
{
	_TRACE(1, L"Entering CTemplateGeneralPropertyPage::DoContextHelp\n");
    
	switch (::GetDlgCtrlID (hWndControl))
	{
    case IDC_STATIC:
		break;

	default:
		// Display context help for a control
		if ( !::WinHelp (
				hWndControl,
				GetContextHelpFile (),
				HELP_WM_HELP,
				(DWORD_PTR) g_aHelpIDs_IDD_TEMPLATE_GENERAL) )
		{
			_TRACE(0, L"WinHelp () failed: 0x%x\n", GetLastError ());        
		}
		break;
	}
    _TRACE(-1, L"Leaving CTemplateGeneralPropertyPage::DoContextHelp\n");
}

void CTemplateGeneralPropertyPage::OnUseADCert() 
{
	bool bCheck = (BST_CHECKED == SendDlgItemMessage (IDC_USE_AD_CERT_FOR_REENROLLMENT, BM_GETCHECK) );
    m_rCertTemplate.SetCheckDSCert (bCheck);
    m_bIsDirty = true;
    SetModified ();
}

HRESULT CTemplateGeneralPropertyPage::EnumerateTemplates (
        IDirectoryObject* pTemplateContObj, 
        const CString& szFriendlyName, 
        bool& bFound)
{
    _TRACE (1, L"Entering CTemplateGeneralPropertyPage::EnumerateTemplates\n");
	CComPtr<IDirectorySearch>   spDsSearch;
	HRESULT hr = pTemplateContObj->QueryInterface (IID_PPV_ARG(IDirectorySearch, &spDsSearch));
	if ( SUCCEEDED (hr) )
	{
        ASSERT (!!spDsSearch);
		ADS_SEARCHPREF_INFO pSearchPref[1];
		DWORD dwNumPref = 1;

		pSearchPref[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
		pSearchPref[0].vValue.dwType = ADSTYPE_INTEGER;
		pSearchPref[0].vValue.Integer = ADS_SCOPE_ONELEVEL;

		hr = spDsSearch->SetSearchPreference(
				 pSearchPref,
				 dwNumPref
				 );
		if ( SUCCEEDED (hr) )
		{
			static const DWORD	cAttrs = 1; //2;
            static PWSTR	    rgszAttrList[cAttrs] = {L"displayName"}; //, L"cn"};
			ADS_SEARCH_HANDLE	hSearchHandle = 0;
            wstring             strQuery;
            ADS_SEARCH_COLUMN   Column;

            Column.pszAttrName = 0;
            strQuery = L"objectClass=pKICertificateTemplate";

			hr = spDsSearch->ExecuteSearch(
								 const_cast <PWSTR>(strQuery.c_str ()),
								 rgszAttrList,
								 cAttrs,
								 &hSearchHandle
								 );
			if ( SUCCEEDED (hr) )
			{
				while ((hr = spDsSearch->GetNextRow (hSearchHandle)) != S_ADS_NOMORE_ROWS )
				{
                    if (FAILED(hr))
                        continue;

					//
					// Getting current row's information
					//
					hr = spDsSearch->GetColumn(
							 hSearchHandle,
							 rgszAttrList[0],
							 &Column
							 );
					if ( SUCCEEDED (hr) )
					{
                        CString strDisplayName = Column.pADsValues->CaseIgnoreString;
                        if ( !_wcsicmp (strDisplayName, szFriendlyName) )
                        {
                            bFound = true;
                        }
						spDsSearch->FreeColumn (&Column);

                        if ( bFound )
                            break;
					}
					else if ( hr != E_ADS_COLUMN_NOT_SET )
					{
						break;
					}
                    else
                    {
                        _TRACE (0, L"IDirectorySearch::GetColumn () failed: 0x%x\n", hr);
                    }
                }
			}
            else
            {
                _TRACE (0, L"IDirectorySearch::ExecuteSearch () failed: 0x%x\n", hr);
            }

            spDsSearch->CloseSearchHandle(hSearchHandle);
		}
        else
        {
            _TRACE (0, L"IDirectorySearch::SetSearchPreference () failed: 0x%x\n", hr);
        }
    }
    else
    {
        _TRACE (0, L"IDirectoryObject::QueryInterface (IDirectorySearch) failed: 0x%x\n", hr);
    }

    _TRACE (-1, L"Leaving CTemplateGeneralPropertyPage::EnumerateTemplates: 0x%x\n", hr);
    return hr;
}

HRESULT CTemplateGeneralPropertyPage::FindFriendlyNameInEnterpriseTemplates (
            const CString& szFriendlyName, 
            bool& bFound)
{
	_TRACE (1, L"Entering CTemplateGeneralPropertyPage::FindFriendlyNameInEnterpriseTemplates\n");
    AFX_MANAGE_STATE(AfxGetStaticModuleState());	
    HRESULT	hr = S_OK;
	CComPtr<IADsPathname> spPathname;
	//
	// Constructing the directory paths
	//
    // security review 2/20/2002 BryanWal ok
    hr = CoCreateInstance(
				CLSID_Pathname,
				NULL,
				CLSCTX_ALL,
				IID_PPV_ARG (IADsPathname, &spPathname));
	if ( SUCCEEDED (hr) )
	{
        ASSERT (!!spPathname);
        CComBSTR bstrPathElement = CERTTMPL_LDAP;
		hr = spPathname->Set(bstrPathElement, ADS_SETTYPE_PROVIDER);
		if ( SUCCEEDED (hr) )
		{
			//
			// Open the root DSE object
			//
            bstrPathElement = CERTTMPL_ROOTDSE;
			hr = spPathname->AddLeafElement(bstrPathElement);
			if ( SUCCEEDED (hr) )
			{
				BSTR bstrFullPath = 0;
				hr = spPathname->Retrieve(ADS_FORMAT_X500, &bstrFullPath);
				if ( SUCCEEDED (hr) )
				{
					CComPtr<IADs> spRootDSEObject;
					VARIANT varNamingContext;


					hr = ADsGetObject (
			              bstrFullPath,
						  IID_PPV_ARG (IADs, &spRootDSEObject));
					if ( SUCCEEDED (hr) )
					{
                        ASSERT (!!spRootDSEObject);
						//
						// Get the configuration naming context from the root DSE
						//
                        bstrPathElement = CERTTMPL_CONFIG_NAMING_CONTEXT;
						hr = spRootDSEObject->Get(bstrPathElement,
											 &varNamingContext);
						if ( SUCCEEDED (hr) )
						{
							hr = spPathname->Set(V_BSTR(&varNamingContext),
												ADS_SETTYPE_DN);
							if ( SUCCEEDED (hr) )
							{
                                bstrPathElement = L"CN=Services";
                                hr = spPathname->AddLeafElement (bstrPathElement);
                                if ( SUCCEEDED (hr) )
                                {
                                    bstrPathElement = L"CN=Public Key Services";
                                    hr = spPathname->AddLeafElement (bstrPathElement);
                                    if ( SUCCEEDED (hr) )
                                    {
                                        bstrPathElement = L"CN=Certificate Templates";
                                        hr = spPathname->AddLeafElement (bstrPathElement);
                                        if ( SUCCEEDED (hr) )
                                        {
				                            BSTR bstrCertTemplatePath = 0;
				                            hr = spPathname->Retrieve(ADS_FORMAT_X500, &bstrCertTemplatePath);
				                            if ( SUCCEEDED (hr) )
				                            {
					                            CComPtr<IDirectoryObject> spTemplateContObj;

					                            hr = ADsGetObject (
			                                          bstrCertTemplatePath,
						                              IID_PPV_ARG (IDirectoryObject, &spTemplateContObj));
					                            if ( SUCCEEDED (hr) )
					                            {
                                                    hr = EnumerateTemplates (spTemplateContObj, 
                                                                szFriendlyName, bFound);
                                                }
                                                else
                                                {
                                                    _TRACE (0, L"ADsGetObject (%s) failed: 0x%x\n", bstrCertTemplatePath, hr);
                                                }

                                                SysFreeString (bstrCertTemplatePath);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        else
                        {
                            _TRACE (0, L"IADs::Get (%s) failed: 0x%x\n", CERTTMPL_CONFIG_NAMING_CONTEXT, hr);
                        }
                    }
                    else
                    {
                        _TRACE (0, L"ADsGetObject (%s) failed: 0x%x\n", bstrFullPath, hr);
                    }
                }
            }
        }
    }
    else
        hr = E_POINTER;


	_TRACE (-1, L"Leaving CTemplateGeneralPropertyPage::FindFriendlyNameInEnterpriseTemplates\n");
	return hr;
}

void CTemplateGeneralPropertyPage::OnKillfocusValidityEdit() 
{
    // NTRAID# 331178 Certtmpl: All Certificate Templates must enforce 
    // that the certificate Renewal Period < = 75% of the Validity Period
    int nMaxRenewalDays = (m_nValidityDays * 3) / 4;
    if ( nMaxRenewalDays < m_nRenewalDays )
    {
        // change without confirmation
        SetRenewalPeriod (nMaxRenewalDays, true);
        GetDlgItem (IDC_VALIDITY_EDIT)->SetFocus ();
    }
}

void CTemplateGeneralPropertyPage::OnKillfocusValidityUnits() 
{
    // NTRAID# 331178 Certtmpl: All Certificate Templates must enforce 
    // that the certificate Renewal Period < = 75% of the Validity Period
    int nMaxRenewalDays = (m_nValidityDays * 3) / 4;
    if ( nMaxRenewalDays < m_nRenewalDays )
    {
        // change without confirmation
        SetRenewalPeriod (nMaxRenewalDays, true);
        GetDlgItem (IDC_VALIDITY_EDIT)->SetFocus ();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\templatev1subjectnamepropertypage.cpp ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       TemplateV1SubjectNamePropertyPage.cpp
//
//  Contents:   Implementation of CTemplateV1SubjectNamePropertyPage
//
//----------------------------------------------------------------------------
// TemplateSubjectNamePropertyPage.cpp : implementation file
//

#include "stdafx.h"
#include "TemplateV1SubjectNamePropertyPage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTemplateV1SubjectNamePropertyPage property page

CTemplateV1SubjectNamePropertyPage::CTemplateV1SubjectNamePropertyPage(CCertTemplate& rCertTemplate) : 
    CHelpPropertyPage(CTemplateV1SubjectNamePropertyPage::IDD),
    m_rCertTemplate (rCertTemplate)
{
	//{{AFX_DATA_INIT(CTemplateV1SubjectNamePropertyPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    m_rCertTemplate.AddRef ();
}

CTemplateV1SubjectNamePropertyPage::~CTemplateV1SubjectNamePropertyPage()
{
    m_rCertTemplate.Release ();
}

void CTemplateV1SubjectNamePropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CHelpPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTemplateV1SubjectNamePropertyPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTemplateV1SubjectNamePropertyPage, CHelpPropertyPage)
	//{{AFX_MSG_MAP(CTemplateV1SubjectNamePropertyPage)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTemplateV1SubjectNamePropertyPage message handlers


BOOL CTemplateV1SubjectNamePropertyPage::OnInitDialog ()
{
    CHelpPropertyPage::OnInitDialog ();

    if ( m_rCertTemplate.RequireSubjectInRequest () )
        SendDlgItemMessage (IDC_REQUIRE_SUBJECT, BM_SETCHECK, BST_CHECKED);
    else
        SendDlgItemMessage (IDC_SUBJECT_AND_BUILD_SUBJECT_BY_CA, BM_SETCHECK, BST_CHECKED);

    if ( m_rCertTemplate.SubjectNameIncludesEMail () )
        SendDlgItemMessage (IDC_EMAIL_NAME, BM_SETCHECK, BST_CHECKED);

    if ( m_rCertTemplate.IsMachineType () )
        SendDlgItemMessage (IDC_SUBJECT_MUST_BE_MACHINE, BM_SETCHECK, BST_CHECKED);
    else
        SendDlgItemMessage (IDC_SUBJECT_MUST_BE_USER, BM_SETCHECK, BST_CHECKED);
    
    EnableControls ();
    return TRUE;
}

void CTemplateV1SubjectNamePropertyPage::EnableControls()
{
    if ( 1 == m_rCertTemplate.GetType () )
    {
        GetDlgItem (IDC_REQUIRE_SUBJECT)->EnableWindow (FALSE);
        GetDlgItem (IDC_SUBJECT_AND_BUILD_SUBJECT_BY_CA)->EnableWindow (FALSE);
        GetDlgItem (IDC_EMAIL_NAME)->EnableWindow (FALSE);
        GetDlgItem (IDC_SUBJECT_MUST_BE_MACHINE)->EnableWindow (FALSE);
        GetDlgItem (IDC_SUBJECT_MUST_BE_USER)->EnableWindow (FALSE);
    }
}

void CTemplateV1SubjectNamePropertyPage::DoContextHelp (HWND hWndControl)
{
	_TRACE(1, L"Entering CTemplateV1SubjectNamePropertyPage::DoContextHelp\n");
    
	switch (::GetDlgCtrlID (hWndControl))
	{
	case IDC_STATIC:
		break;

	default:
		// Display context help for a control
		if ( !::WinHelp (
				hWndControl,
				GetContextHelpFile (),
				HELP_WM_HELP,
				(DWORD_PTR) g_aHelpIDs_IDD_TEMPLATE_V1_SUBJECT_NAME) )
		{
			_TRACE(0, L"WinHelp () failed: 0x%x\n", GetLastError ());        
		}
		break;
	}
    _TRACE(-1, L"Leaving CTemplateV1SubjectNamePropertyPage::DoContextHelp\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\templatev1requestpropertypage.h ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       TemplateV1RequestPropertyPage.h
//
//  Contents:   Definition of CTemplateV1RequestPropertyPage
//
//----------------------------------------------------------------------------
#if !defined(AFX_TEMPLATEV1REQUESTPROPERTYPAGE_H__A3E4D067_D3C3_4C85_A331_97D940A82063__INCLUDED_)
#define AFX_TEMPLATEV1REQUESTPROPERTYPAGE_H__A3E4D067_D3C3_4C85_A331_97D940A82063__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// TemplateV1RequestPropertyPage.h : header file
//
#include "CertTemplate.h"

class CSPCheckListBox : public CCheckListBox
{
public:
	CSPCheckListBox () : CCheckListBox () {};
	virtual ~CSPCheckListBox () {};
	virtual BOOL Create (DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID)
	{
		return CCheckListBox::Create (dwStyle, rect, pParentWnd, nID);
	}
};

/////////////////////////////////////////////////////////////////////////////
// CTemplateV1RequestPropertyPage dialog

class CTemplateV1RequestPropertyPage : public CHelpPropertyPage
{
// Construction
public:
	CTemplateV1RequestPropertyPage(CCertTemplate& rCertTemplate);
	virtual ~CTemplateV1RequestPropertyPage();

// Dialog Data
	//{{AFX_DATA(CTemplateV1RequestPropertyPage)
	enum { IDD = IDD_TEMPLATE_V1_REQUEST };
	CComboBox	m_purposeCombo;
	CSPCheckListBox	m_CSPList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTemplateV1RequestPropertyPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual void DoContextHelp (HWND hWndControl);
	HRESULT EnumerateCSPs();
	// Generated message map functions
	//{{AFX_MSG(CTemplateV1RequestPropertyPage)
	afx_msg void OnSelchangePurposeCombo();
	afx_msg void OnExportPrivateKey();
	//}}AFX_MSG
    afx_msg void OnCheckChange();
	DECLARE_MESSAGE_MAP()

	virtual BOOL OnInitDialog();
    virtual void EnableControls ();

private:
    CCertTemplate& m_rCertTemplate;
};



//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TEMPLATEV1REQUESTPROPERTYPAGE_H__A3E4D067_D3C3_4C85_A331_97D940A82063__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\templatev1subjectnamepropertypage.h ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       TemplateV1SubjectNamePropertyPage.h
//
//  Contents:   Definition of CTemplateV1SubjectNamePropertyPage
//
//----------------------------------------------------------------------------
#if !defined(AFX_TEMPLATESUBJECTNAMEPROPERTYPAGE_H__72F0D57F_221D_4A06_9C62_1BBB5800FBD2__INCLUDED_)
#define AFX_TEMPLATESUBJECTNAMEPROPERTYPAGE_H__72F0D57F_221D_4A06_9C62_1BBB5800FBD2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// TemplateSubjectNamePropertyPage.h : header file
//
#include "CertTemplate.h"

/////////////////////////////////////////////////////////////////////////////
// CTemplateV1SubjectNamePropertyPage dialog

class CTemplateV1SubjectNamePropertyPage : public CHelpPropertyPage
{
// Construction
public:
	CTemplateV1SubjectNamePropertyPage(CCertTemplate& rCertTemplate);
	~CTemplateV1SubjectNamePropertyPage();

// Dialog Data
	//{{AFX_DATA(CTemplateV1SubjectNamePropertyPage)
	enum { IDD = IDD_TEMPLATE_V1_SUBJECT_NAME };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTemplateV1SubjectNamePropertyPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual void DoContextHelp (HWND hWndControl);
    virtual BOOL OnInitDialog();
	void EnableControls ();
	// Generated message map functions
	//{{AFX_MSG(CTemplateV1SubjectNamePropertyPage)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
    CCertTemplate& m_rCertTemplate;
};



//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TEMPLATESUBJECTNAMEPROPERTYPAGE_H__72F0D57F_221D_4A06_9C62_1BBB5800FBD2__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\templatev2requestpropertypage.h ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       TemplateV2RequestPropertyPage.h
//
//  Contents:   Definition of CTemplateV2RequestPropertyPage
//
//----------------------------------------------------------------------------
#if !defined(AFX_TEMPLATEV2REQUESTPROPERTYPAGE_H__A3E4D067_D3C3_4C85_A331_97D940A82063__INCLUDED_)
#define AFX_TEMPLATEV2REQUESTPROPERTYPAGE_H__A3E4D067_D3C3_4C85_A331_97D940A82063__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// TemplateV2RequestPropertyPage.h : header file
//
#include "CertTemplate.h"
#include "TemplateV1RequestPropertyPage.h"
#include "SelectCSPDlg.h"

/////////////////////////////////////////////////////////////////////////////
// CTemplateV2RequestPropertyPage dialog

class CTemplateV2RequestPropertyPage : public CHelpPropertyPage
{
// Construction
public:
    CTemplateV2RequestPropertyPage(CCertTemplate& rCertTemplate, bool& rbIsDirty);
    virtual ~CTemplateV2RequestPropertyPage();

// Dialog Data
    //{{AFX_DATA(CTemplateV2RequestPropertyPage)
    enum { IDD = IDD_TEMPLATE_V2_REQUEST };
    CComboBox   m_minKeySizeCombo;
    CComboBox   m_purposeCombo;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CTemplateV2RequestPropertyPage)
    public:
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    int GetSelectedCSPCount ();
    virtual void DoContextHelp (HWND hWndControl);
    void AddKeySizeToCombo (DWORD dwValue, PCWSTR strValue, DWORD dwSizeToSelect);
    HRESULT EnumerateCSPs(DWORD dwMinKeySize);
    // Generated message map functions
    //{{AFX_MSG(CTemplateV2RequestPropertyPage)
    afx_msg void OnSelchangePurposeCombo();
    afx_msg void OnExportPrivateKey();
    afx_msg void OnArchiveKeyCheck();
    afx_msg void OnIncludeSymmetricAlgorithmsCheck();
    afx_msg void OnSelchangeMinimumKeysizeValue();
    afx_msg void OnDeletePermanently();
    afx_msg void OnDestroy();
	afx_msg void OnCsps();
	afx_msg void OnEnrollWithoutInput();
	afx_msg void OnEnrollPromptUser();
	afx_msg void OnEnrollPromptUserRequireIfPrivateKey();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    virtual BOOL OnInitDialog();
    virtual void EnableControls ();
    HRESULT CSPGetMaxKeySupported (
                PCWSTR pszProvider, 
                DWORD dwProvType, 
                DWORD& dwSigMaxKey, 
                DWORD& dwKeyExMaxKey);
    void NormalizeCSPList (DWORD dwMinKeySize);

private:
    bool&           m_rbIsDirty;
    CCertTemplate&  m_rCertTemplate;
    int             m_nProvDSSCnt;

    CSP_LIST        m_CSPList;
};




//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TEMPLATEV2REQUESTPROPERTYPAGE_H__A3E4D067_D3C3_4C85_A331_97D940A82063__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\templatev2authenticationpropertypage.cpp ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2002.
//
//  File:       TemplateV2AuthenticationPropertyPage.cpp
//
//  Contents:   Implementation of CTemplateV2AuthenticationPropertyPage
//
//----------------------------------------------------------------------------
// TemplateV2AuthenticationPropertyPage.cpp : implementation file
//

#include "stdafx.h"
#include "certtmpl.h"
#include "TemplateV2AuthenticationPropertyPage.h"
#include "AddApprovalDlg.h"
#include "PolicyOID.h"

extern POLICY_OID_LIST	    g_policyOIDList;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



/////////////////////////////////////////////////////////////////////////////
// CTemplateV2AuthenticationPropertyPage property page

CTemplateV2AuthenticationPropertyPage::CTemplateV2AuthenticationPropertyPage(
        CCertTemplate& rCertTemplate,
        bool& rbIsDirty) 
    : CHelpPropertyPage(CTemplateV2AuthenticationPropertyPage::IDD),
    m_rCertTemplate (rCertTemplate),
    m_curApplicationSel (LB_ERR),
    m_rbIsDirty (rbIsDirty)
{
	//{{AFX_DATA_INIT(CTemplateV2AuthenticationPropertyPage)
	//}}AFX_DATA_INIT
    m_rCertTemplate.AddRef ();
}

CTemplateV2AuthenticationPropertyPage::~CTemplateV2AuthenticationPropertyPage()
{
    m_rCertTemplate.Release ();
}

void CTemplateV2AuthenticationPropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CHelpPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTemplateV2AuthenticationPropertyPage)
	DDX_Control(pDX, IDC_APPLICATION_POLICIES, m_applicationPolicyCombo);
	DDX_Control(pDX, IDC_POLICY_TYPES, m_policyTypeCombo);
	DDX_Control(pDX, IDC_ISSUANCE_POLICIES, m_issuanceList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTemplateV2AuthenticationPropertyPage, CHelpPropertyPage)
	//{{AFX_MSG_MAP(CTemplateV2AuthenticationPropertyPage)
	ON_BN_CLICKED(IDC_ADD_APPROVAL, OnAddApproval)
	ON_BN_CLICKED(IDC_REMOVE_APPROVAL, OnRemoveApproval)
	ON_EN_CHANGE(IDC_NUM_SIG_REQUIRED_EDIT, OnChangeNumSigRequiredEdit)
	ON_BN_CLICKED(IDC_REENROLLMENT_REQUIRES_VALID_CERT, OnAllowReenrollment)
	ON_BN_CLICKED(IDC_PEND_ALL_REQUESTS, OnPendAllRequests)
	ON_LBN_SELCHANGE(IDC_ISSUANCE_POLICIES, OnSelchangeIssuancePolicies)
	ON_CBN_SELCHANGE(IDC_POLICY_TYPES, OnSelchangePolicyTypes)
	ON_CBN_SELCHANGE(IDC_APPLICATION_POLICIES, OnSelchangeApplicationPolicies)
	ON_WM_DESTROY()
	ON_BN_CLICKED(IDC_NUM_SIG_REQUIRED_CHECK, OnNumSigRequiredCheck)
	ON_BN_CLICKED(IDC_REENROLLMENT_SAME_AS_ENROLLMENT, OnReenrollmentSameAsEnrollment)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTemplateV2AuthenticationPropertyPage message handlers
enum {
    POLICY_TYPE_ISSUANCE = 0,
    POLICY_TYPE_APPLICATION,
    POLICY_TYPE_APPLICATION_AND_ISSUANCE
};

BOOL CTemplateV2AuthenticationPropertyPage::OnInitDialog()
{
    _TRACE (1, L"Entering CTemplateV2AuthenticationPropertyPage::OnInitDialog\n");
    CHelpPropertyPage::OnInitDialog ();

    // Initialize Application Policy combo
    for (POSITION nextPos = g_policyOIDList.GetHeadPosition (); nextPos; )
    {
        CPolicyOID* pPolicyOID = g_policyOIDList.GetNext (nextPos);
        if ( pPolicyOID )
        {
            // If this is the Application OID dialog, show only application 
            // OIDS, otherwise if this is the Issuance OID dialog, show only
            // issuance OIDs
            if ( pPolicyOID->IsApplicationOID () )
            {
                // Bug 262925 CERTSRV: "All Application Policies should be 
                // removed from  Issuance Requirements tab for a cert template
                if ( 0 != strcmp (szOID_ANY_APPLICATION_POLICY, pPolicyOID->GetOIDA ()) )
                {
                    int nIndex = m_applicationPolicyCombo.AddString (pPolicyOID->GetDisplayName ());
                    if ( nIndex >= 0 )
                    {
                        // security review 2/20/2002 BryanWal ok GetOIDA () returns L"" if empty
                        LPSTR   pszOID = new char[strlen (pPolicyOID->GetOIDA ())+1];
                        if ( pszOID )
                        {
                            // security review 2/20/2002 BryanWal ok
                            strcpy (pszOID, pPolicyOID->GetOIDA ());
                            m_applicationPolicyCombo.SetItemDataPtr (nIndex, pszOID);
                        }
                    }
                }
            }
        }
    }

    // Check for and add pending requests
    if ( m_rCertTemplate.PendAllRequests () )
        SendDlgItemMessage (IDC_PEND_ALL_REQUESTS, BM_SETCHECK, BST_CHECKED);

    // Get the RA Issuance Policies and add them to the issuance list
    int     nRAPolicyIndex = 0;
    CString szRAPolicyOID;
    while ( SUCCEEDED (m_rCertTemplate.GetRAIssuancePolicy (nRAPolicyIndex, szRAPolicyOID)) )
    {
        CString policyName;

        // ISSUE
        // RAID 547613 Security: cert templates - CPolicyDlg::OnInitDialog() - methodize all unicode to mbcs conversion
        // security review 2/20/2002 BryanWal ok
        int nLen = WideCharToMultiByte(
              CP_ACP,                   // code page
              0,                        // performance and mapping flags
              (PCWSTR) szRAPolicyOID,  // wide-character string
              -1,                       // number of chars in string
              0,                        // buffer for new string
              0,                        // size of buffer - if 0 causes to return required len including NULL terminator
              0,                    // default for unmappable chars
              0);                   // set when default char used
        if ( nLen > 0 )
        {
            PSTR    pszAnsiBuf = new char[nLen];
            if ( pszAnsiBuf )
            {
                // security review 2/20/2002 BryanWal ok
                ZeroMemory (pszAnsiBuf, nLen);
                // security review 2/20/2002 BryanWal ok
                nLen = WideCharToMultiByte(
                        CP_ACP,                 // code page
                        0,                      // performance and mapping flags
                        (PCWSTR) szRAPolicyOID, // wide-character string
                        -1,                     // -1 - calculate length of null-terminated string automatically
                        pszAnsiBuf,             // buffer for new string
                        nLen,                   // size of buffer
                        0,                      // default for unmappable chars
                        0);                     // set when default char used
                if ( nLen )
                {
		            if ( MyGetOIDInfoA (policyName, pszAnsiBuf) )
		            {
                        int nIndex = m_issuanceList.AddString (policyName);
                        if ( nIndex >= 0 )
                            m_issuanceList.SetItemData (nIndex, (DWORD_PTR) pszAnsiBuf);
		            }
                }
                else
                {
                    _TRACE (0, L"WideCharToMultiByte (%s) failed: 0x%x\n", 
                            (PCWSTR) szRAPolicyOID, GetLastError ());
                }
            }
            else
                break;
        }
        else
        {
            _TRACE (0, L"WideCharToMultiByte (%s) failed: 0x%x\n", 
                    (PCWSTR) szRAPolicyOID, GetLastError ());
        }

        nRAPolicyIndex++;
    }

    // Get the RA Application policy and select it
    // in the application combo
    nRAPolicyIndex = 0;
    while ( SUCCEEDED (m_rCertTemplate.GetRAApplicationPolicy (nRAPolicyIndex, szRAPolicyOID)) )
    {
        CString policyName;
        int nLen = WideCharToMultiByte(
              CP_ACP,                   // code page
              0,                        // performance and mapping flags
              (PCWSTR) szRAPolicyOID,  // wide-character string
              -1,                       // -1 - calculate length of null-terminated string automatically
              0,                        // buffer for new string
              0,                        // size of buffer - if 0 then API returns length including null terminator
              0,                    // default for unmappable chars
              0);                   // set when default char used
        if ( nLen > 0 )
        {
            PSTR    pszAnsiBuf = new char[nLen];
            if ( pszAnsiBuf )
            {
                // security review 2/20/2002 BryanWal ok
                ZeroMemory (pszAnsiBuf, nLen);
                nLen = WideCharToMultiByte(
                        CP_ACP,                 // code page
                        0,                      // performance and mapping flags
                        (PCWSTR) szRAPolicyOID, // wide-character string
                        -1,                     // -1 - calculate length of null-terminated string automatically
                        pszAnsiBuf,             // buffer for new string
                        nLen,                   // size of buffer
                        0,                      // default for unmappable chars
                        0);                     // set when default char used
                if ( nLen )
                {
		            if ( MyGetOIDInfoA (policyName, pszAnsiBuf) )
		            {
                        int nIndex = m_applicationPolicyCombo.FindStringExact (-1, policyName);
                        if ( nIndex >= 0 )
                            m_applicationPolicyCombo.SetCurSel (nIndex);
                        m_curApplicationSel = nIndex;
                        break;
		            }
                }
                else
                {
                    _TRACE (0, L"WideCharToMultiByte (%s) failed: 0x%x\n", 
                            (PCWSTR) szRAPolicyOID, GetLastError ());
                }
                delete [] pszAnsiBuf;
            }
            else
                break;
        }
        else
        {
            _TRACE (0, L"WideCharToMultiByte (%s) failed: 0x%x\n", 
                    (PCWSTR) szRAPolicyOID, GetLastError ());
        }

        nRAPolicyIndex++;
    }

    // Initialize "Policy Type" combo box
    CString text;
    int nApplicationSel = m_applicationPolicyCombo.GetCurSel ();
    int nIssuanceCnt = m_issuanceList.GetCount ();

    VERIFY (text.LoadString (IDS_ISSUANCE_POLICY));
    int nIndex = m_policyTypeCombo.AddString (text);
    if ( nIndex >= 0 )
    {
        m_policyTypeCombo.SetItemData (nIndex, POLICY_TYPE_ISSUANCE);
        if ( LB_ERR == nApplicationSel && nIssuanceCnt > 0 )
            m_policyTypeCombo.SetCurSel (nIndex);
    }

    VERIFY (text.LoadString (IDS_APPLICATION_POLICY));
    nIndex = m_policyTypeCombo.AddString (text);
    if ( nIndex >= 0 )
    {
        m_policyTypeCombo.SetItemData (nIndex, POLICY_TYPE_APPLICATION);
        if ( nApplicationSel >= 0 && 0 == nIssuanceCnt )
            m_policyTypeCombo.SetCurSel (nIndex);
    }

    VERIFY (text.LoadString (IDS_APPLICATION_AND_ISSUANCE_POLICY));
    nIndex = m_policyTypeCombo.AddString (text);
    if ( nIndex >= 0 )
    {
        m_policyTypeCombo.SetItemData (nIndex, POLICY_TYPE_APPLICATION_AND_ISSUANCE);
        if ( nApplicationSel >= 0 && nIssuanceCnt > 0 )
            m_policyTypeCombo.SetCurSel (nIndex);
    }

    
    DWORD   dwNumSignatures = 0;
    if ( SUCCEEDED (m_rCertTemplate.GetRANumSignaturesRequired (dwNumSignatures)) )
        SetDlgItemInt (IDC_NUM_SIG_REQUIRED_EDIT, dwNumSignatures);

    if ( dwNumSignatures > 0 )
        SendDlgItemMessage (IDC_NUM_SIG_REQUIRED_CHECK, BM_SETCHECK, BST_CHECKED);

    if ( m_rCertTemplate.ReenrollmentValidWithPreviousApproval () )
        SendDlgItemMessage (IDC_REENROLLMENT_REQUIRES_VALID_CERT, BM_SETCHECK, BST_CHECKED);
    else 
        SendDlgItemMessage (IDC_REENROLLMENT_SAME_AS_ENROLLMENT, BM_SETCHECK, BST_CHECKED);

    EnableControls ();

    _TRACE (-1, L"Leaving CTemplateV2AuthenticationPropertyPage::OnInitDialog\n");
    return TRUE;
}

void CTemplateV2AuthenticationPropertyPage::OnAddApproval() 
{
    // Create the list of already added approvals.  These will not be displayed
    // in the Add Approval dialog.
	int		nCnt = m_issuanceList.GetCount ();
    PSTR*   paszUsedApprovals = 0;

	
    // allocate an array of PSTR pointers and add each item.
    // Set the last to NULL
    if ( nCnt )
    {
        paszUsedApprovals = new PSTR[nCnt+1];
        if ( paszUsedApprovals )
        {
            // security review 2/20/2002 BryanWal ok
            ::ZeroMemory (paszUsedApprovals, sizeof (PSTR) * (nCnt+1));
	        while (--nCnt >= 0)
	        {
                PSTR pszPolicyOID = (PSTR) m_issuanceList.GetItemData (nCnt);
                if ( pszPolicyOID )
                {
                    // security review 2/20/2002 BryanWal ok
                    PSTR pNewStr = new char[strlen (pszPolicyOID) + 1];
                    if ( pNewStr )
                    {
                        // security review 2/20/2002 BryanWal ok
                        strcpy (pNewStr, pszPolicyOID);
                        paszUsedApprovals[nCnt] = pNewStr;
                    }
                    else
                        break;
                }
            }
        }
    }

	CAddApprovalDlg dlg (this, paszUsedApprovals);

    CThemeContextActivator activator;
    if ( IDOK == dlg.DoModal () && dlg.m_paszReturnedApprovals )
    {
        for (int nIndex = 0; dlg.m_paszReturnedApprovals[nIndex]; nIndex++)
        {
            SetModified ();
            m_rbIsDirty = true;

            // Add to template RA list
            CString szRAPolicyOID (dlg.m_paszReturnedApprovals[nIndex]);
            HRESULT hr = m_rCertTemplate.ModifyRAIssuancePolicyList (szRAPolicyOID, true);
            ASSERT (SUCCEEDED (hr));
            if ( SUCCEEDED (hr) )
            {
                // Add to list
                CString  policyName;
		        if ( MyGetOIDInfoA (policyName, dlg.m_paszReturnedApprovals[nIndex]) )
		        {
                    int nAddedIndex = m_issuanceList.AddString (policyName);
                    if ( nAddedIndex >= 0 )
                    {
                        // security review 2/20/2002 BryanWal ok
                        PSTR    pszAnsiBuf = new char[strlen (dlg.m_paszReturnedApprovals[nIndex]) + 1];
                        if ( pszAnsiBuf )
                        {
                            // security review 2/20/2002 BryanWal ok
                            strcpy (pszAnsiBuf, dlg.m_paszReturnedApprovals[nIndex]);
                            m_issuanceList.SetItemData (nAddedIndex, (DWORD_PTR) pszAnsiBuf);
                        }
                    }
		        }
            }
        }
    }

    if ( paszUsedApprovals )
    {
        for (int nIndex = 0; paszUsedApprovals[nIndex]; nIndex++)
            delete [] paszUsedApprovals[nIndex];
        delete [] paszUsedApprovals;
    }

    EnableControls ();
}


void CTemplateV2AuthenticationPropertyPage::OnRemoveApproval() 
{
    int     nSelCnt = m_issuanceList.GetSelCount ();
    int*    pnSelIndexes = new int[nSelCnt];
    if ( pnSelIndexes )
    {
        m_issuanceList.GetSelItems (nSelCnt, pnSelIndexes);
        for (int nIndex = nSelCnt-1; nIndex >= 0; nIndex--)
        {
            PSTR pszPolicyOID = (PSTR) m_issuanceList.GetItemData (pnSelIndexes[nIndex]);
            if ( pszPolicyOID )
            {
                HRESULT hr = m_rCertTemplate.ModifyRAIssuancePolicyList (pszPolicyOID, false);
                if ( SUCCEEDED (hr) )
                    VERIFY (m_issuanceList.DeleteString (pnSelIndexes[nIndex]));
                else
                {
                    CString text;
                    CString caption;
                    CThemeContextActivator activator;

                    VERIFY (caption.LoadString (IDS_CERTTMPL));
                    // security review 2/20/2002 BryanWal ok
                    text.FormatMessage (IDS_CANNOT_DELETE_ISSUANCE_RA, GetSystemMessage (hr));
                    MessageBox (text, caption, MB_OK | MB_ICONWARNING);
                    delete [] pszPolicyOID;
                }
            }
        }

        delete [] pnSelIndexes;
    }
    SetModified ();
    m_rbIsDirty = true;

    GetDlgItem (IDC_ADD_APPROVAL)->SetFocus ();
	EnableControls ();
}

void CTemplateV2AuthenticationPropertyPage::EnableControls()
{
    if ( m_rCertTemplate.ReadOnly () )
    {
        GetDlgItem (IDC_PEND_ALL_REQUESTS)->EnableWindow (FALSE);
        m_policyTypeCombo.EnableWindow (FALSE);
        m_issuanceList.EnableWindow (FALSE);
        m_applicationPolicyCombo.EnableWindow (FALSE);
        GetDlgItem (IDC_ADD_APPROVAL)->EnableWindow (FALSE);
        GetDlgItem (IDC_REMOVE_APPROVAL)->EnableWindow (FALSE);
        GetDlgItem (IDC_NUM_SIG_REQUIRED_EDIT)->EnableWindow (FALSE);
        GetDlgItem (IDC_REENROLLMENT_REQUIRES_VALID_CERT)->EnableWindow (FALSE);
        GetDlgItem (IDC_REENROLLMENT_SAME_AS_ENROLLMENT)->EnableWindow (FALSE);
        GetDlgItem (IDC_NUM_SIG_REQUIRED_CHECK)->EnableWindow (FALSE);
    }
    else
    {
	    BOOL bEnable = (BST_CHECKED == SendDlgItemMessage (IDC_NUM_SIG_REQUIRED_CHECK, BM_GETCHECK));

        EnablePolicyControls (bEnable);

        if ( bEnable )
        {
            int nCnt = m_issuanceList.GetCount ();
            int nSel = m_issuanceList.GetSelCount ();
    

            switch (m_policyTypeCombo.GetItemData (m_policyTypeCombo.GetCurSel ()))
            {
            case POLICY_TYPE_ISSUANCE:
                m_issuanceList.EnableWindow (TRUE);
                GetDlgItem (IDC_ADD_APPROVAL)->EnableWindow (TRUE);
                GetDlgItem (IDC_REMOVE_APPROVAL)->EnableWindow (TRUE);
                GetDlgItem (IDC_ISSUANCE_POLICY_LABEL)->EnableWindow (TRUE);
                m_applicationPolicyCombo.EnableWindow (FALSE);
                GetDlgItem (IDC_APP_POLICY_LABEL)->EnableWindow (FALSE);
                break;

            case POLICY_TYPE_APPLICATION:
                m_issuanceList.EnableWindow (FALSE);
                GetDlgItem (IDC_ADD_APPROVAL)->EnableWindow (FALSE);
                GetDlgItem (IDC_REMOVE_APPROVAL)->EnableWindow (FALSE);
                GetDlgItem (IDC_ISSUANCE_POLICY_LABEL)->EnableWindow (FALSE);
                m_applicationPolicyCombo.EnableWindow (TRUE);
                GetDlgItem (IDC_APP_POLICY_LABEL)->EnableWindow (TRUE);
                break;

            case POLICY_TYPE_APPLICATION_AND_ISSUANCE:
                m_issuanceList.EnableWindow (TRUE);
                GetDlgItem (IDC_ADD_APPROVAL)->EnableWindow (TRUE);
                GetDlgItem (IDC_REMOVE_APPROVAL)->EnableWindow (nSel > 0 && nCnt > nSel);
                GetDlgItem (IDC_ISSUANCE_POLICY_LABEL)->EnableWindow (TRUE);
                m_applicationPolicyCombo.EnableWindow (TRUE);
                GetDlgItem (IDC_APP_POLICY_LABEL)->EnableWindow (TRUE);
                break;

            default: // nothing selected
                m_issuanceList.EnableWindow (FALSE);
                GetDlgItem (IDC_ADD_APPROVAL)->EnableWindow (FALSE);
                GetDlgItem (IDC_REMOVE_APPROVAL)->EnableWindow (FALSE);
                GetDlgItem (IDC_ISSUANCE_POLICY_LABEL)->EnableWindow (FALSE);
                m_applicationPolicyCombo.EnableWindow (FALSE);
                GetDlgItem (IDC_APP_POLICY_LABEL)->EnableWindow (FALSE);
                break;
            }
        }

        if ( BST_CHECKED == SendDlgItemMessage (IDC_PEND_ALL_REQUESTS, 
                    BM_GETCHECK) ||
                BST_CHECKED == SendDlgItemMessage (IDC_NUM_SIG_REQUIRED_CHECK, 
                        BM_GETCHECK) )
        {
            GetDlgItem (IDC_REENROLLMENT_SAME_AS_ENROLLMENT)->EnableWindow (TRUE);
            GetDlgItem (IDC_REENROLLMENT_REQUIRES_VALID_CERT)->EnableWindow (TRUE);
        }
        else
        {
            GetDlgItem (IDC_REENROLLMENT_SAME_AS_ENROLLMENT)->EnableWindow (FALSE);
            SendDlgItemMessage (IDC_REENROLLMENT_SAME_AS_ENROLLMENT, 
                    BM_SETCHECK, BST_CHECKED);
            SendDlgItemMessage (IDC_REENROLLMENT_REQUIRES_VALID_CERT, 
                    BM_SETCHECK, BST_UNCHECKED);
            m_rCertTemplate.SetReenrollmentValidWithPreviousApproval (false);
            GetDlgItem (IDC_REENROLLMENT_REQUIRES_VALID_CERT)->EnableWindow (FALSE);
        }
    }
}

void CTemplateV2AuthenticationPropertyPage::OnChangeNumSigRequiredEdit() 
{
    static bool bProcessingOnChangeNumSigRequiredEdit = false;

    if ( !bProcessingOnChangeNumSigRequiredEdit )
    {
        bProcessingOnChangeNumSigRequiredEdit = true;
        CString szText;
        
        if ( GetDlgItemText (IDC_NUM_SIG_REQUIRED_EDIT, szText) > 0 )
        {
            DWORD   dwNumSignatures = GetDlgItemInt (IDC_NUM_SIG_REQUIRED_EDIT);
            DWORD   dwFormerNumSignatures = 0;
            m_rCertTemplate.GetRANumSignaturesRequired (dwFormerNumSignatures);

            if ( dwFormerNumSignatures != dwNumSignatures )
            {
                HRESULT hr = m_rCertTemplate.SetRANumSignaturesRequired (dwNumSignatures);
                if ( SUCCEEDED (hr) )
                {
                    if ( 0 == dwFormerNumSignatures || 
                            0 == dwNumSignatures )
                    {
                        OnNumSigRequiredCheck();
                    }

                    SetModified ();
                    m_rbIsDirty = true;
                }
            }
        }

        bProcessingOnChangeNumSigRequiredEdit = false;
    }
}

void CTemplateV2AuthenticationPropertyPage::OnAllowReenrollment() 
{
    HRESULT hr = m_rCertTemplate.SetReenrollmentValidWithPreviousApproval (
            BST_CHECKED == SendDlgItemMessage (IDC_REENROLLMENT_REQUIRES_VALID_CERT, BM_GETCHECK));
    if ( SUCCEEDED (hr) )
    {
        SetModified ();
        m_rbIsDirty = true;
    }
}


void CTemplateV2AuthenticationPropertyPage::DoContextHelp (HWND hWndControl)
{
	_TRACE(1, L"Entering CTemplateV2AuthenticationPropertyPage::DoContextHelp\n");
    
	switch (::GetDlgCtrlID (hWndControl))
	{
	case IDC_STATIC:
		break;

	default:
		// Display context help for a control
		if ( !::WinHelp (
				hWndControl,
				GetContextHelpFile (),
				HELP_WM_HELP,
				(DWORD_PTR) g_aHelpIDs_IDD_TEMPLATE_V2_AUTHENTICATION) )
		{
			_TRACE(0, L"WinHelp () failed: 0x%x\n", GetLastError ());        
		}
		break;
	}
    _TRACE(-1, L"Leaving CTemplateV2AuthenticationPropertyPage::DoContextHelp\n");
}

void CTemplateV2AuthenticationPropertyPage::OnPendAllRequests() 
{
	m_rCertTemplate.SetPendAllRequests (
            BST_CHECKED == SendDlgItemMessage (IDC_PEND_ALL_REQUESTS, BM_GETCHECK));
	SetModified ();
    m_rbIsDirty = true;
    EnableControls ();
}

void CTemplateV2AuthenticationPropertyPage::OnSelchangeIssuancePolicies() 
{
    EnableControls ();	
}

void CTemplateV2AuthenticationPropertyPage::OnSelchangePolicyTypes() 
{
    SetModified ();
    m_rbIsDirty = true;

    switch (m_policyTypeCombo.GetItemData (m_policyTypeCombo.GetCurSel ()))
    {
    case POLICY_TYPE_ISSUANCE:
        {
            // Unselect the application policy and inform the user that
            // an issuance policy must be added if there aren't any
            int nSel = m_applicationPolicyCombo.GetCurSel ();
            if ( nSel >= 0 )
            {
                PSTR    pszOID = (PSTR) m_applicationPolicyCombo.GetItemDataPtr (nSel);
                if ( pszOID )
                {
                    HRESULT hr = m_rCertTemplate.ModifyRAApplicationPolicyList (pszOID, false);
                    _ASSERT (SUCCEEDED (hr));
                    if ( SUCCEEDED (hr) )
                    {
                        SetModified ();
                        m_rbIsDirty = true;
                    }
                }
                m_applicationPolicyCombo.SetCurSel (LB_ERR);
                m_curApplicationSel = LB_ERR;
            }
        }
        break;

    case POLICY_TYPE_APPLICATION:
        {
            // Select an application policy, if necessary and remove
            // the issuance policies
            int nSel = m_applicationPolicyCombo.GetCurSel ();
            if ( LB_ERR == nSel )
            {
                m_applicationPolicyCombo.SetCurSel (0);
                nSel = m_applicationPolicyCombo.GetCurSel ();
                m_curApplicationSel = nSel;
                if ( nSel >= 0 )
                {
                    PSTR    pszOID = (PSTR) m_applicationPolicyCombo.GetItemDataPtr (nSel);
                    if ( pszOID )
                    {
                        HRESULT hr = m_rCertTemplate.ModifyRAApplicationPolicyList (pszOID, true);
                        _ASSERT (SUCCEEDED (hr));
                        if ( SUCCEEDED (hr) )
                        {
                            SetModified ();
                            m_rbIsDirty = true;
                        }
                    }
                }
            }

            ClearIssuanceList ();
        }
        break;

    case POLICY_TYPE_APPLICATION_AND_ISSUANCE:
        {
            // Select an application policy, if necessary and inform the user
            // that an issuance policy must be added, if there aren't any.
            int nSel = m_applicationPolicyCombo.GetCurSel ();
            if ( LB_ERR == nSel )
            {
                m_applicationPolicyCombo.SetCurSel (0);
                nSel = m_applicationPolicyCombo.GetCurSel ();
                m_curApplicationSel = nSel;
                if ( nSel >= 0 )
                {
                    PSTR    pszOID = (PSTR) m_applicationPolicyCombo.GetItemDataPtr (nSel);
                    if ( pszOID )
                    {
                        HRESULT hr = m_rCertTemplate.ModifyRAApplicationPolicyList (pszOID, true);
                        _ASSERT (SUCCEEDED (hr));
                        if ( SUCCEEDED (hr) )
                        {
                            SetModified ();
                            m_rbIsDirty = true;
                        }
                    }
                }
            }
        }
        break;

    default: // nothing selected
        break;
    }
    EnableControls ();	
}

void CTemplateV2AuthenticationPropertyPage::OnSelchangeApplicationPolicies() 
{
    int nNewSel = m_applicationPolicyCombo.GetCurSel ();
    
    // Remove the old application OID and add the new one
	if ( m_curApplicationSel != nNewSel )
    {
        if ( LB_ERR != m_curApplicationSel )
        {
            LPSTR   pszOID = (LPSTR) m_applicationPolicyCombo.GetItemDataPtr (m_curApplicationSel);
            if ( pszOID )
            {
                HRESULT hr = m_rCertTemplate.ModifyRAApplicationPolicyList (pszOID, false);
                _ASSERT (SUCCEEDED (hr));
            }
        }

        if ( LB_ERR != nNewSel )
        {
            LPSTR   pszOID = (LPSTR) m_applicationPolicyCombo.GetItemDataPtr (nNewSel);
            if ( pszOID )
            {
                HRESULT hr = m_rCertTemplate.ModifyRAApplicationPolicyList (pszOID, true);
                _ASSERT (SUCCEEDED (hr));
            }
        }

        SetModified ();
        m_rbIsDirty = true;

        m_curApplicationSel = nNewSel;
    }
}

void CTemplateV2AuthenticationPropertyPage::OnDestroy() 
{
    int nCnt = m_issuanceList.GetCount ();
    for (int nIndex = 0; nIndex < nCnt; nIndex++)
    {
        PSTR pszBuf = (PSTR) m_issuanceList.GetItemData (nIndex);
        if ( pszBuf )
            delete [] pszBuf;
    }

    
    nCnt = m_applicationPolicyCombo.GetCount ();
    for (int nIndex = 0; nIndex < nCnt; nIndex++)
    {
        PSTR    pszOID = (PSTR) m_applicationPolicyCombo.GetItemDataPtr (nIndex);
        if ( pszOID )
            delete [] pszOID;
    }

	CHelpPropertyPage::OnDestroy();
}

void CTemplateV2AuthenticationPropertyPage::OnNumSigRequiredCheck() 
{
    static bProcessingOnNumSigRequiredCheck = false;

    if ( !bProcessingOnNumSigRequiredCheck ) // to prevent reentrancy
    {
        bProcessingOnNumSigRequiredCheck = true;
        if ( BST_UNCHECKED == SendDlgItemMessage (IDC_NUM_SIG_REQUIRED_CHECK, BM_GETCHECK) )
        {
            if ( 0 != GetDlgItemInt (IDC_NUM_SIG_REQUIRED_EDIT) )
                SetDlgItemInt (IDC_NUM_SIG_REQUIRED_EDIT, 0);

            // NTRAID# 369551 CertTmpl:UI does not clean up changed settings
            // clear out policy type combo, application policy combo and issuance
            // policy list
            m_policyTypeCombo.SetCurSel (-1);
            m_policyTypeCombo.Clear ();

            // Clear application policy
            int nCurSel = m_applicationPolicyCombo.GetCurSel ();
            if ( LB_ERR != nCurSel )
            {
                // Remove the old application OID
                LPSTR   pszOID = (LPSTR) m_applicationPolicyCombo.GetItemDataPtr (nCurSel);
                if ( pszOID )
                {
                    HRESULT hr = m_rCertTemplate.ModifyRAApplicationPolicyList (pszOID, false);
                    _ASSERT (SUCCEEDED (hr));
                }
            }
            m_applicationPolicyCombo.SetCurSel (-1);
            m_curApplicationSel = -1;
            m_applicationPolicyCombo.Clear ();
    
            // Clear issuance policy
            ClearIssuanceList ();
        }
        else if ( 0 == GetDlgItemInt (IDC_NUM_SIG_REQUIRED_EDIT) )
            SetDlgItemInt (IDC_NUM_SIG_REQUIRED_EDIT, 1);

        if ( GetDlgItemInt (IDC_NUM_SIG_REQUIRED_EDIT) > 0 )
        {
            // NTRAID# 397330 Certificate Template MMC: Add wrong RA 
            // application policy OID for a cloned template
            m_curApplicationSel = 0;
            m_policyTypeCombo.SetCurSel (0);
            m_applicationPolicyCombo.SetCurSel (0);
            LPSTR   pszOID = (LPSTR) m_applicationPolicyCombo.GetItemDataPtr (0);
            if ( pszOID )
            {
                HRESULT hr = m_rCertTemplate.ModifyRAApplicationPolicyList (pszOID, true);
                _ASSERT (SUCCEEDED (hr));
            }
        }

        EnableControls ();

        bProcessingOnNumSigRequiredCheck = false;
    }
}

void CTemplateV2AuthenticationPropertyPage::EnablePolicyControls (BOOL& bEnable)
{
    GetDlgItem (IDC_NUM_SIG_REQUIRED_EDIT)->EnableWindow (bEnable);

    if ( bEnable )
    {
        if ( GetDlgItemInt (IDC_NUM_SIG_REQUIRED_EDIT) < 1 )
            bEnable = false;
    }

    GetDlgItem (IDC_POLICY_TYPES_LABEL)->EnableWindow (bEnable);
    GetDlgItem (IDC_POLICY_TYPES)->EnableWindow (bEnable);
    GetDlgItem (IDC_APP_POLICY_LABEL)->EnableWindow (bEnable);
    GetDlgItem (IDC_APPLICATION_POLICIES)->EnableWindow (bEnable);
    GetDlgItem (IDC_ISSUANCE_POLICY_LABEL)->EnableWindow (bEnable);
    GetDlgItem (IDC_ISSUANCE_POLICIES)->EnableWindow (bEnable);
    GetDlgItem (IDC_ADD_APPROVAL)->EnableWindow (bEnable);
    GetDlgItem (IDC_REMOVE_APPROVAL)->EnableWindow (bEnable);
}


BOOL CTemplateV2AuthenticationPropertyPage::OnKillActive() 
{
    switch (m_policyTypeCombo.GetItemData (m_policyTypeCombo.GetCurSel ()))
    {
    case POLICY_TYPE_ISSUANCE:
        {
            // Inform the user that
            // an issuance policy must be added if there aren't any
            m_rCertTemplate.IssuancePoliciesRequired (
                    (0 == m_issuanceList.GetCount ()) ? true : false); 
        }
        break;

    case POLICY_TYPE_APPLICATION_AND_ISSUANCE:
        {
            // Inform the user
            // that an issuance policy must be added, if there aren't any.
            m_rCertTemplate.IssuancePoliciesRequired (
                    (0 == m_issuanceList.GetCount ()) ? true : false); 
        }
        break;

    case POLICY_TYPE_APPLICATION:
    default: // nothing selected
        m_rCertTemplate.IssuancePoliciesRequired (false);
        break;
    }
	
	return CHelpPropertyPage::OnKillActive();
}

void CTemplateV2AuthenticationPropertyPage::OnReenrollmentSameAsEnrollment() 
{
    HRESULT hr = m_rCertTemplate.SetReenrollmentValidWithPreviousApproval (
            BST_CHECKED == SendDlgItemMessage (IDC_REENROLLMENT_REQUIRES_VALID_CERT, BM_GETCHECK));
    if ( SUCCEEDED (hr) )
    {
        SetModified ();
        m_rbIsDirty = true;
    }
}

void CTemplateV2AuthenticationPropertyPage::ClearIssuanceList ()
{
    int nCnt = m_issuanceList.GetCount ();
    for (int nIndex = nCnt-1; nIndex >= 0; nIndex--)
    {
        LPSTR pszOID = (LPSTR) m_issuanceList.GetItemDataPtr (nIndex);
        if ( pszOID )
        {
            HRESULT hr = m_rCertTemplate.ModifyRAIssuancePolicyList (pszOID, false);
            if ( SUCCEEDED (hr) )
            {
                m_issuanceList.DeleteString (nIndex);
                delete [] pszOID;
                SetModified ();
                m_rbIsDirty = true;
            }
            else
            {
                _ASSERT (0);
                break;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\templatev2authenticationpropertypage.h ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       TemplateV2AuthenticationPropertyPage.h
//
//  Contents:   Definition of CTemplateV2AuthenticationPropertyPage
//
//----------------------------------------------------------------------------
#if !defined(AFX_TEMPLATEV2AUTHENTICATIONPROPERTYPAGE_H__FA3C2A95_B56D_4948_8BB8_F825323B8C31__INCLUDED_)
#define AFX_TEMPLATEV2AUTHENTICATIONPROPERTYPAGE_H__FA3C2A95_B56D_4948_8BB8_F825323B8C31__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// TemplateV2AuthenticationPropertyPage.h : header file
//
#include "CertTemplate.h"

/////////////////////////////////////////////////////////////////////////////
// CTemplateV2AuthenticationPropertyPage dialog

class CTemplateV2AuthenticationPropertyPage : public CHelpPropertyPage
{
// Construction
public:
	CTemplateV2AuthenticationPropertyPage(CCertTemplate& rCertTemplate,
            bool& rbIsDirty);
	~CTemplateV2AuthenticationPropertyPage();

// Dialog Data
	//{{AFX_DATA(CTemplateV2AuthenticationPropertyPage)
	enum { IDD = IDD_TEMPLATE_V2_AUTHENTICATION };
	CComboBox	m_applicationPolicyCombo;
	CComboBox	m_policyTypeCombo;
	CListBox	m_issuanceList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTemplateV2AuthenticationPropertyPage)
	public:
	virtual BOOL OnKillActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    void ClearIssuanceList ();
    void EnablePolicyControls (BOOL& bEnable);
	virtual void DoContextHelp (HWND hWndControl);
    virtual BOOL OnInitDialog();
	void EnableControls ();
	// Generated message map functions
	//{{AFX_MSG(CTemplateV2AuthenticationPropertyPage)
	afx_msg void OnAddApproval();
	afx_msg void OnRemoveApproval();
	afx_msg void OnChangeNumSigRequiredEdit();
	afx_msg void OnAllowReenrollment();
	afx_msg void OnPendAllRequests();
	afx_msg void OnSelchangeIssuancePolicies();
	afx_msg void OnSelchangePolicyTypes();
	afx_msg void OnSelchangeApplicationPolicies();
	afx_msg void OnDestroy();
	afx_msg void OnNumSigRequiredCheck();
	afx_msg void OnReenrollmentSameAsEnrollment();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	bool& m_rbIsDirty;
	int m_curApplicationSel;
    CCertTemplate& m_rCertTemplate;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TEMPLATEV2AUTHENTICATIONPROPERTYPAGE_H__FA3C2A95_B56D_4948_8BB8_F825323B8C31__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\templatev2subjectnamepropertypage.cpp ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       TemplateV2SubjectNamePropertyPage.cpp
//
//  Contents:   Implementation of CTemplateV2SubjectNamePropertyPage
//
//----------------------------------------------------------------------------
// TemplateV2SubjectNamePropertyPage.cpp : implementation file
//

#include "stdafx.h"
#include "TemplateV2SubjectNamePropertyPage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTemplateV2SubjectNamePropertyPage property page

CTemplateV2SubjectNamePropertyPage::CTemplateV2SubjectNamePropertyPage(
        CCertTemplate& rCertTemplate, bool& rbIsDirty, bool bIsComputerOrDC) 
    : CHelpPropertyPage(CTemplateV2SubjectNamePropertyPage::IDD),
    m_rCertTemplate (rCertTemplate),
    m_rbIsDirty (rbIsDirty),
    m_bIsComputerOrDC (bIsComputerOrDC)
{
	//{{AFX_DATA_INIT(CTemplateV2SubjectNamePropertyPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
    m_rCertTemplate.AddRef ();
}

CTemplateV2SubjectNamePropertyPage::~CTemplateV2SubjectNamePropertyPage()
{
    m_rCertTemplate.Release ();
}

void CTemplateV2SubjectNamePropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CHelpPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTemplateV2SubjectNamePropertyPage)
	DDX_Control(pDX, IDC_SUBJECT_NAME_NAME_COMBO, m_nameCombo);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTemplateV2SubjectNamePropertyPage, CHelpPropertyPage)
	//{{AFX_MSG_MAP(CTemplateV2SubjectNamePropertyPage)
	ON_BN_CLICKED(IDC_SUBJECT_AND_SUBJECT_ALT_NAME, OnSubjectAndSubjectAltName)
	ON_CBN_SELCHANGE(IDC_SUBJECT_NAME_NAME_COMBO, OnSelchangeSubjectNameNameCombo)
	ON_BN_CLICKED(IDC_SUBJECT_NAME_BUILT_BY_CA, OnSubjectNameBuiltByCa)
	ON_BN_CLICKED(IDC_SUBJECT_NAME_SUPPLIED_IN_REQUEST, OnSubjectNameSuppliedInRequest)
	ON_BN_CLICKED(IDC_DNS_NAME, OnDnsName)
	ON_BN_CLICKED(IDC_EMAIL_IN_ALT, OnEmailInAlt)
	ON_BN_CLICKED(IDC_EMAIL_IN_SUB, OnEmailInSub)
	ON_BN_CLICKED(IDC_SPN, OnSpn)
	ON_BN_CLICKED(IDC_UPN, OnUpn)
	ON_WM_KILLFOCUS()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTemplateV2SubjectNamePropertyPage message handlers

void CTemplateV2SubjectNamePropertyPage::OnSubjectAndSubjectAltName() 
{
    EnableControls ();	
}

void CTemplateV2SubjectNamePropertyPage::EnableControls()
{
    BOOL    bEnable = FALSE;

   
    if ( m_rCertTemplate.ReadOnly () )
    {
        bEnable = FALSE;
        GetDlgItem (IDC_SUBJECT_NAME_SUPPLIED_IN_REQUEST)->EnableWindow (FALSE);
        GetDlgItem (IDC_SUBJECT_NAME_BUILT_BY_CA)->EnableWindow (FALSE);
    }
    else if ( BST_CHECKED == SendDlgItemMessage (IDC_SUBJECT_NAME_BUILT_BY_CA, BM_GETCHECK) )
        bEnable = TRUE;

    GetDlgItem (IDC_SUBJECT_NAME_NAME_COMBO)->EnableWindow (bEnable);
    GetDlgItem (IDC_SUBJECT_NAME_NAME_LABEL)->EnableWindow (bEnable);
    GetDlgItem (IDC_EMAIL_IN_ALT)->EnableWindow (bEnable);
    GetDlgItem (IDC_DNS_NAME)->EnableWindow (bEnable); // removed for bug 253823 "&& !m_bIsComputerOrDC);"
    GetDlgItem (IDC_UPN)->EnableWindow (bEnable);
    GetDlgItem (IDC_SPN)->EnableWindow (bEnable);

    BOOL    bEnableEmailInSub = FALSE;
    if ( bEnable )
    {
        int nSel = m_nameCombo.GetCurSel ();
        if ( nSel >= 0 )
        {
            if ( NAME_TYPE_NONE != m_nameCombo.GetItemData (nSel) )
                bEnableEmailInSub = TRUE;
        }
    }
   
    GetDlgItem (IDC_EMAIL_IN_SUB)->EnableWindow (bEnableEmailInSub);
    if ( !bEnableEmailInSub )
        SendDlgItemMessage (IDC_EMAIL_IN_SUB, BM_SETCHECK, BST_UNCHECKED);
}


BOOL CTemplateV2SubjectNamePropertyPage::OnInitDialog()
{
    CHelpPropertyPage::OnInitDialog ();

    // Initialize Combo Box
    CString text;

    VERIFY (text.LoadString (IDS_SUBJECT_NAME_NONE));
    int nIndex = m_nameCombo.AddString (text);
    if ( nIndex >= 0 )
    {
        m_nameCombo.SetCurSel (nIndex); // set by default
        m_nameCombo.SetItemData (nIndex, (DWORD_PTR) NAME_TYPE_NONE);
    }

    VERIFY (text.LoadString (IDS_FULL_DN));
    nIndex = m_nameCombo.AddString (text);
    if ( nIndex >= 0 )
    {
        m_nameCombo.SetItemData (nIndex, (DWORD_PTR) NAME_TYPE_FULL_DN);
        if ( m_rCertTemplate.SubjectNameMustBeFullDN () )
            m_nameCombo.SetCurSel (nIndex);
    }

    VERIFY (text.LoadString (IDS_CN_ONLY));
    nIndex = m_nameCombo.AddString (text);
    if ( nIndex >= 0 )
    {
        m_nameCombo.SetItemData (nIndex, (DWORD_PTR) NAME_TYPE_CN_ONLY);
        if ( m_rCertTemplate.SubjectNameMustBeCN () )
            m_nameCombo.SetCurSel (nIndex);
    }

    // Initialize Radio buttons
    if ( m_rCertTemplate.RequireSubjectInRequest () )
        SendDlgItemMessage (IDC_SUBJECT_NAME_SUPPLIED_IN_REQUEST, BM_SETCHECK, BST_CHECKED);
    else
        SendDlgItemMessage (IDC_SUBJECT_NAME_BUILT_BY_CA, BM_SETCHECK, BST_CHECKED);

    // Initialize Check boxes
    if ( m_rCertTemplate.SubjectNameIncludesEMail () )
        SendDlgItemMessage (IDC_EMAIL_IN_SUB, BM_SETCHECK, BST_CHECKED);

    if ( m_rCertTemplate.AltNameIncludesDNS () )
        SendDlgItemMessage (IDC_DNS_NAME, BM_SETCHECK, BST_CHECKED);

    if ( m_rCertTemplate.AltNameIncludesEMail () )
        SendDlgItemMessage (IDC_EMAIL_IN_ALT, BM_SETCHECK, BST_CHECKED);

    if ( m_rCertTemplate.AltNameIncludesUPN () )
        SendDlgItemMessage (IDC_UPN, BM_SETCHECK, BST_CHECKED);

    if ( m_rCertTemplate.AltNameIncludesSPN () )
        SendDlgItemMessage (IDC_SPN, BM_SETCHECK, BST_CHECKED);

    EnableControls ();

    return TRUE;
}

void CTemplateV2SubjectNamePropertyPage::SetSettingsForNameTypeNone ()
{
    m_rCertTemplate.SubjectNameMustBeCN (false);
    m_rCertTemplate.SubjectNameMustBeFullDN (false);
    int nCntChecked = 0;

    if ( BST_CHECKED == SendDlgItemMessage (IDC_EMAIL_IN_ALT, BM_GETCHECK) )
        nCntChecked++;
    if ( BST_CHECKED == SendDlgItemMessage (IDC_DNS_NAME, BM_GETCHECK) )
        nCntChecked++;
    if ( BST_CHECKED == SendDlgItemMessage (IDC_UPN, BM_GETCHECK) )
        nCntChecked++;
    if ( BST_CHECKED == SendDlgItemMessage (IDC_SPN, BM_GETCHECK) )
        nCntChecked++;

    if ( 0 == nCntChecked )
    {
        m_rCertTemplate.AltNameIncludesUPN (true);
        SendDlgItemMessage (IDC_UPN, BM_SETCHECK, BST_CHECKED);
    }

    // NTRAID# 313588 CertTMPL: If subject name format  = none, 
    // sub alt name should be marked as critical for D.C.A. cert 
    // template.
    m_rCertTemplate.ModifyCriticalExtensions (szOID_SUBJECT_ALT_NAME, true);
}

void CTemplateV2SubjectNamePropertyPage::OnSelchangeSubjectNameNameCombo() 
{
    SetModified ();
    m_rbIsDirty = true;

    int nSel = m_nameCombo.GetCurSel ();
    if ( nSel >= 0 )
    {
        switch (m_nameCombo.GetItemData (nSel) )
        {
        case NAME_TYPE_NONE:
            SetSettingsForNameTypeNone ();
            m_rCertTemplate.SubjectNameIncludesEMail(false); //NTRAID# 435818, YangGao, 7/25/2001
            break;

        case NAME_TYPE_FULL_DN:
            m_rCertTemplate.SubjectNameMustBeCN (false);
            m_rCertTemplate.SubjectNameMustBeFullDN (true);
            // NTRAID# 313588 CertTMPL: If subject name format  = none, 
            // sub alt name should be marked as critical for D.C.A. cert 
            // template.
            m_rCertTemplate.ModifyCriticalExtensions (szOID_SUBJECT_ALT_NAME, 
                    false);
            break;

        case NAME_TYPE_CN_ONLY:
            m_rCertTemplate.SubjectNameMustBeCN (true);
            m_rCertTemplate.SubjectNameMustBeFullDN (false);
            // NTRAID# 313588 CertTMPL: If subject name format  = none, 
            // sub alt name should be marked as critical for D.C.A. cert 
            // template.
            m_rCertTemplate.ModifyCriticalExtensions (szOID_SUBJECT_ALT_NAME, 
                    false);
            break;

        default:
            ASSERT (0);
            break;
        }
    }

    EnableControls ();
}

void CTemplateV2SubjectNamePropertyPage::OnSubjectNameBuiltByCa() 
{
    SetModified ();
    SendDlgItemMessage (IDC_SUBJECT_NAME_SUPPLIED_IN_REQUEST, BM_SETCHECK, BST_UNCHECKED);
    m_rbIsDirty = true;

    m_rCertTemplate.RequireSubjectInRequest (false);

	EnableControls ();
}

void CTemplateV2SubjectNamePropertyPage::OnSubjectNameSuppliedInRequest() 
{
    SetModified ();
    SendDlgItemMessage (IDC_SUBJECT_NAME_BUILT_BY_CA, BM_SETCHECK, BST_UNCHECKED);
    m_rbIsDirty = true;
    m_rCertTemplate.RequireSubjectInRequest (true);

    // Clear all "built by CA" settings
    int nCnt = m_nameCombo.GetCount ();
    for (int nIndex = 0; nIndex < nCnt; nIndex++)
    {
        if ( NAME_TYPE_NONE == m_nameCombo.GetItemData (nIndex) )
        {
            m_nameCombo.SetCurSel (nIndex);
            break;
        }
    }
    SetSettingsForNameTypeNone ();

    if ( BST_CHECKED == SendDlgItemMessage (IDC_EMAIL_IN_SUB, BM_GETCHECK) )
    {
        SendDlgItemMessage (IDC_EMAIL_IN_SUB, BM_SETCHECK, BST_UNCHECKED);
        m_rCertTemplate.SubjectNameIncludesEMail (false);
    }

    if ( BST_CHECKED == SendDlgItemMessage (IDC_EMAIL_IN_ALT, BM_GETCHECK) &&
            CanUncheckLastSetting (IDC_EMAIL_IN_ALT) )
    {
        SendDlgItemMessage (IDC_EMAIL_IN_ALT, BM_SETCHECK, BST_UNCHECKED);
        m_rCertTemplate.AltNameIncludesEMail (false);
    }

    if ( BST_CHECKED == SendDlgItemMessage (IDC_DNS_NAME, BM_GETCHECK) &&
            CanUncheckLastSetting (IDC_DNS_NAME) )
    {
        m_rCertTemplate.AltNameIncludesDNS (false);
        SendDlgItemMessage (IDC_DNS_NAME, BM_SETCHECK, BST_UNCHECKED);
    }

    if ( BST_CHECKED == SendDlgItemMessage (IDC_UPN, BM_GETCHECK) && 
            CanUncheckLastSetting (IDC_UPN) )
    {
        m_rCertTemplate.AltNameIncludesUPN (false);
        SendDlgItemMessage (IDC_UPN, BM_SETCHECK, BST_UNCHECKED);  
    }

    if ( BST_CHECKED == SendDlgItemMessage (IDC_SPN, BM_GETCHECK) &&
            CanUncheckLastSetting (IDC_SPN) )
    {
        m_rCertTemplate.AltNameIncludesSPN (false);
        SendDlgItemMessage (IDC_SPN, BM_SETCHECK, BST_UNCHECKED);
    }

	EnableControls ();
}

void CTemplateV2SubjectNamePropertyPage::OnDnsName() 
{
    if ( CanUncheckLastSetting (IDC_DNS_NAME) )
    {
        m_rCertTemplate.AltNameIncludesDNS (
                BST_CHECKED == SendDlgItemMessage (IDC_DNS_NAME, BM_GETCHECK));
    }
    SetModified ();
    m_rbIsDirty = true;
}

void CTemplateV2SubjectNamePropertyPage::OnEmailInAlt() 
{
    if ( CanUncheckLastSetting (IDC_EMAIL_IN_ALT) )
    {
        m_rCertTemplate.AltNameIncludesEMail (
                BST_CHECKED == SendDlgItemMessage (IDC_EMAIL_IN_ALT, BM_GETCHECK));
    }
    SetModified ();
    m_rbIsDirty = true;
}

void CTemplateV2SubjectNamePropertyPage::OnEmailInSub() 
{
    m_rCertTemplate.SubjectNameIncludesEMail (
            BST_CHECKED == SendDlgItemMessage (IDC_EMAIL_IN_SUB, BM_GETCHECK));
    SetModified ();
    m_rbIsDirty = true;
}

void CTemplateV2SubjectNamePropertyPage::OnSpn() 
{
    if ( CanUncheckLastSetting (IDC_SPN) )
    {
        m_rCertTemplate.AltNameIncludesSPN (
                BST_CHECKED == SendDlgItemMessage (IDC_SPN, BM_GETCHECK));
    }
    SetModified ();
    m_rbIsDirty = true;
}

void CTemplateV2SubjectNamePropertyPage::OnUpn() 
{
    if ( CanUncheckLastSetting (IDC_UPN) )
    {
        m_rCertTemplate.AltNameIncludesUPN (
                BST_CHECKED == SendDlgItemMessage (IDC_UPN, BM_GETCHECK));  
    }
    SetModified ();
    m_rbIsDirty = true;
}


bool CTemplateV2SubjectNamePropertyPage::CanUncheckLastSetting(int ctrlID)
{
    bool    bResult = true;

    // If request is to be built by CA and "none" is selected for subject name,
    // ensure that at least one of the alt-name options is checked
    // If the control in question is now unchecked, verify that at least
    // one other is checked
    if ( BST_UNCHECKED == SendDlgItemMessage (ctrlID, BM_GETCHECK) )
    {
        if ( BST_CHECKED == SendDlgItemMessage (IDC_SUBJECT_NAME_BUILT_BY_CA, BM_GETCHECK) )
        {
            int nSel = m_nameCombo.GetCurSel ();
            if ( nSel >= 0 )
            {
                if ( NAME_TYPE_NONE == m_nameCombo.GetItemData (nSel) )
                {
                    int nCntChecked = 0;

                    if ( BST_CHECKED == SendDlgItemMessage (IDC_EMAIL_IN_ALT, BM_GETCHECK) )
                        nCntChecked++;
                    if ( BST_CHECKED == SendDlgItemMessage (IDC_DNS_NAME, BM_GETCHECK) )
                        nCntChecked++;
                    if ( BST_CHECKED == SendDlgItemMessage (IDC_UPN, BM_GETCHECK) )
                        nCntChecked++;
                    if ( BST_CHECKED == SendDlgItemMessage (IDC_SPN, BM_GETCHECK) )
                        nCntChecked++;

                    if ( 0 == nCntChecked )
                    {
                        CString text;
                        CString caption;
                        CThemeContextActivator activator;

                        VERIFY (caption.LoadString (IDS_CERTTMPL));
                        VERIFY (text.LoadString (IDS_AT_LEAST_1_NAME_OPTION_MUST_BE_CHECKED));

                        MessageBox (text, caption, MB_OK);

                        bResult = false;
                        SendDlgItemMessage (ctrlID, BM_SETCHECK, BST_CHECKED);
                    }
                }
            }
        }
    }

    return bResult;
}

void CTemplateV2SubjectNamePropertyPage::DoContextHelp (HWND hWndControl)
{
	_TRACE(1, L"Entering CTemplateV2SubjectNamePropertyPage::DoContextHelp\n");
    
	switch (::GetDlgCtrlID (hWndControl))
	{
    case IDC_STATIC:
		break;

	default:
		// Display context help for a control
		if ( !::WinHelp (
				hWndControl,
				GetContextHelpFile (),
				HELP_WM_HELP,
				(DWORD_PTR) g_aHelpIDs_IDD_TEMPLATE_V2_SUBJECT_NAME) )
		{
			_TRACE(0, L"WinHelp () failed: 0x%x\n", GetLastError ());        
		}
		break;
	}
    _TRACE(-1, L"Leaving CTemplateV2SubjectNamePropertyPage::DoContextHelp\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\templatev2supercedespropertypage.cpp ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2002.
//
//  File:       TemplateV2SupercedesPropertyPage.cpp
//
//  Contents:   Implementation of CTemplateV2SupercedesPropertyPage
//
//----------------------------------------------------------------------------
// TemplateV2SupercedesPropertyPage.cpp : implementation file
//

#include "stdafx.h"
#include "certtmpl.h"
#include "TemplateV2SupercedesPropertyPage.h"
#include "CompData.h"
#include "SelectTemplateDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTemplateV2SupercedesPropertyPage property page

CTemplateV2SupercedesPropertyPage::CTemplateV2SupercedesPropertyPage(
        CCertTemplate& rCertTemplate, 
        bool& rbIsDirty,
        const CCertTmplComponentData* pCompData) 
    : CHelpPropertyPage(CTemplateV2SupercedesPropertyPage::IDD),
    m_rCertTemplate (rCertTemplate),
    m_pGlobalTemplateNameList (0),
    m_bGlobalListCreatedByDialog (false),
    m_rbIsDirty (rbIsDirty),
    m_pCompData (pCompData)
{  
	//{{AFX_DATA_INIT(CTemplateV2SupercedesPropertyPage)
	//}}AFX_DATA_INIT
    m_rCertTemplate.AddRef ();

    if ( m_pCompData )
        m_pGlobalTemplateNameList = &(m_pCompData->m_globalTemplateNameList);
    if ( !m_pGlobalTemplateNameList )
    {
        m_bGlobalListCreatedByDialog = true;
        m_pGlobalTemplateNameList = new CStringList;
        if ( m_pGlobalTemplateNameList )
        {
        }
    }
}

CTemplateV2SupercedesPropertyPage::~CTemplateV2SupercedesPropertyPage()
{
    m_rCertTemplate.Release ();

    if ( m_bGlobalListCreatedByDialog )
        delete m_pGlobalTemplateNameList;
}

void CTemplateV2SupercedesPropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CHelpPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTemplateV2SupercedesPropertyPage)
	DDX_Control(pDX, IDC_SUPERCEDED_TEMPLATES_LIST, m_templateList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTemplateV2SupercedesPropertyPage, CHelpPropertyPage)
	//{{AFX_MSG_MAP(CTemplateV2SupercedesPropertyPage)
	ON_BN_CLICKED(IDC_ADD_SUPERCEDED_TEMPLATE, OnAddSupercededTemplate)
	ON_BN_CLICKED(IDC_REMOVE_SUPERCEDED_TEMPLATE, OnRemoveSupercededTemplate)
	ON_NOTIFY(LVN_DELETEITEM, IDC_SUPERCEDED_TEMPLATES_LIST, OnDeleteitemSupercededTemplatesList)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_SUPERCEDED_TEMPLATES_LIST, OnItemchangedSupercededTemplatesList)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTemplateV2SupercedesPropertyPage message handlers

void CTemplateV2SupercedesPropertyPage::OnAddSupercededTemplate() 
{
    CStringList supercededTemplateNames;

    // Add all the currently superceded templates.  These will not be displayed
    // in the popup dialog
    int nCnt = m_templateList.GetItemCount (); 
    for (int nIndex = 0; nIndex < nCnt; nIndex++)
    {
        CString* pszTemplateName = (CString*) m_templateList.GetItemData (nIndex);
        if ( pszTemplateName )
            supercededTemplateNames.AddTail (*pszTemplateName);
    }

    // Also add this template name.  Templates can't supercede themselves.
    supercededTemplateNames.AddTail (m_rCertTemplate.GetTemplateName ());
    if ( m_pGlobalTemplateNameList )
    {
	    CSelectTemplateDlg  dlg (this, m_pCompData, 
                supercededTemplateNames);


        CThemeContextActivator activator;
        if ( IDOK == dlg.DoModal () )
        {
            POSITION    pos = dlg.m_returnedTemplates.GetHeadPosition ();
            CString     szTemplateName;

            for (; pos; )
            {
	            szTemplateName = dlg.m_returnedTemplates.GetNext (pos);
                HRESULT hr = m_rCertTemplate.ModifySupercededTemplateList (
                        szTemplateName, true);
                if ( SUCCEEDED (hr) )
                {
                    hr = AddItem (szTemplateName, true);
                    SetModified ();
                    m_rbIsDirty = true;
                }
            }
        }
    }
}

void CTemplateV2SupercedesPropertyPage::OnRemoveSupercededTemplate() 
{
	int		nCnt = m_templateList.GetItemCount ();
	ASSERT (nCnt >= 1);
	UINT	flag = 0;
	while (--nCnt >= 0)
	{
		flag = ListView_GetItemState (m_templateList.m_hWnd, nCnt, LVIS_SELECTED);
		if ( flag & LVNI_SELECTED )
		{
            CString* pszTemplateName = (CString*) m_templateList.GetItemData (nCnt);
            if ( pszTemplateName )
            {
                HRESULT hr = m_rCertTemplate.ModifySupercededTemplateList (
                        *pszTemplateName, false);
                if ( SUCCEEDED (hr) )
                {
                    m_templateList.DeleteItem (nCnt);
                    SetModified ();
                    m_rbIsDirty = true;
                }
            }
        }
    }

    GetDlgItem (IDC_ADD_SUPERCEDED_TEMPLATE)->SetFocus ();
}

void CTemplateV2SupercedesPropertyPage::EnableControls()
{
    if ( m_rCertTemplate.ReadOnly () )
    {
        GetDlgItem (IDC_SUPERCEDED_TEMPLATES_LIST)->EnableWindow (FALSE);
        GetDlgItem (IDC_REMOVE_SUPERCEDED_TEMPLATE)->EnableWindow (FALSE);
        GetDlgItem (IDC_ADD_SUPERCEDED_TEMPLATE)->EnableWindow (FALSE);
    }
    else
    {
        BOOL bEnable = (m_templateList.GetSelectedCount () > 0);
    
        GetDlgItem(IDC_REMOVE_SUPERCEDED_TEMPLATE)->EnableWindow (bEnable);
    }
}


BOOL CTemplateV2SupercedesPropertyPage::OnInitDialog()
{
    CHelpPropertyPage::OnInitDialog ();

    // Set up list controls
	COLORREF	cr = RGB (255, 0, 255);
    CThemeContextActivator activator;
	VERIFY (m_imageListNormal.Create (IDB_TEMPLATES, 32, 0, cr));
	VERIFY (m_imageListSmall.Create (IDB_TEMPLATES, 16, 0, cr));
	m_templateList.SetImageList (CImageList::FromHandle (m_imageListSmall), LVSIL_SMALL);
	m_templateList.SetImageList (CImageList::FromHandle (m_imageListNormal), LVSIL_NORMAL);

    // Set to full-row select
    DWORD   dwExstyle = m_templateList.GetExtendedStyle ();
	m_templateList.SetExtendedStyle (dwExstyle | LVS_EX_FULLROWSELECT);


    int	colWidths[NUM_COLS] = {200, 200};

	// Add "Certificate Extension" column
	CString	szText;
	VERIFY (szText.LoadString (IDS_CERTIFICATE_TEMPLATES));
	VERIFY (m_templateList.InsertColumn (COL_CERT_TEMPLATE, (LPCWSTR) szText,
			LVCFMT_LEFT, colWidths[COL_CERT_TEMPLATE], COL_CERT_TEMPLATE) != -1);

	VERIFY (szText.LoadString (IDS_COLUMN_SUPPORTED_CAS));
	VERIFY (m_templateList.InsertColumn (COL_CERT_VERSION, (LPCWSTR) szText,
			LVCFMT_LEFT, colWidths[COL_CERT_VERSION], COL_CERT_VERSION) != -1);
    m_templateList.SetColumnWidth (COL_CERT_VERSION, LVSCW_AUTOSIZE_USEHEADER);

    // Initialize superceded list
    int     nTemplateIndex = 0;
    CString szTemplateName;
    while ( SUCCEEDED ( m_rCertTemplate.GetSupercededTemplate (nTemplateIndex, 
            szTemplateName)) )
    {
        VERIFY (SUCCEEDED (AddItem (szTemplateName)));
        nTemplateIndex++;
    }

    // Select first item
    if ( m_templateList.GetItemCount () > 0 )
        VERIFY (m_templateList.SetItemState (0, LVIS_SELECTED, LVIS_SELECTED));

    EnableControls ();

    return TRUE;
}

void CTemplateV2SupercedesPropertyPage::OnDeleteitemSupercededTemplatesList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    CString* pszTemplateName = (CString*) m_templateList.GetItemData (pNMListView->iItem);
    if ( pszTemplateName )
        delete pszTemplateName;
	
	*pResult = 0;
}

HRESULT CTemplateV2SupercedesPropertyPage::AddItem(const CString &szTemplateName, bool bSelect /* = false */)
{
    HCERTTYPE   hCertType = 0;
    HRESULT     hr = CAFindCertTypeByName (szTemplateName,
            NULL,
            CT_ENUM_MACHINE_TYPES | CT_ENUM_USER_TYPES | CT_FLAG_NO_CACHE_LOOKUP,
            &hCertType);
    _ASSERT (SUCCEEDED (hr));
    if ( SUCCEEDED (hr) )
    {
        PWSTR* rgwszProp = 0;

        hr = CAGetCertTypePropertyEx (hCertType, 
            CERTTYPE_PROP_FRIENDLY_NAME, &rgwszProp);
        if ( SUCCEEDED (hr) )
        {
            DWORD   dwVersion = 0;
            hr = CAGetCertTypePropertyEx (hCertType,
                    CERTTYPE_PROP_SCHEMA_VERSION,
                    &dwVersion);
            if ( SUCCEEDED (hr) )
            {
	            LV_ITEM	lvItem;
	            int		iItem = m_templateList.GetItemCount ();
	            int iResult = 0;

                // security review 2/20/2002 BryanWal ok
	            ::ZeroMemory (&lvItem, sizeof (lvItem));
	            lvItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
	            lvItem.iItem = iItem;
                lvItem.iSubItem = COL_CERT_TEMPLATE;
	            lvItem.pszText = rgwszProp[0];
                if ( 1 == dwVersion )
                    lvItem.iImage = 0;  // version is 1
                else
                    lvItem.iImage = 1;  // version is 2
                lvItem.lParam = (LPARAM) new CString (szTemplateName);
	            iItem = m_templateList.InsertItem (&lvItem);
	            ASSERT (-1 != iItem);
	            if ( -1 != iItem )
                {
                    // security review 2/20/2002 BryanWal ok
	                ::ZeroMemory (&lvItem, sizeof (lvItem));
	                lvItem.mask = LVIF_TEXT;
	                lvItem.iItem = iItem;
                    lvItem.iSubItem = COL_CERT_VERSION;
                    CString text;
                    if ( 1 == dwVersion )
                        VERIFY (text.LoadString (IDS_WINDOWS_2000_AND_LATER));
                    else
                        VERIFY (text.LoadString (IDS_WINDOWS_2002_AND_LATER));
                    lvItem.pszText = (PWSTR)(PCWSTR) text;
	                iResult = m_templateList.SetItem (&lvItem);
	                ASSERT (-1 != iResult);
                    if ( -1 == iResult )
                        hr = E_FAIL;

                    if ( bSelect )
                        VERIFY (m_templateList.SetItemState (iItem, 
                                LVIS_SELECTED, LVIS_SELECTED));
                }
                else
                    hr = E_FAIL;
            }
            else
            {
                _TRACE (0, L"CAGetCertTypePropertyEx (CERTTYPE_PROP_SCHEMA_VERSION) failed: 0x%x\n", hr);
            }

            CAFreeCertTypeProperty (hCertType, rgwszProp);
        }
        else
        {
            _TRACE (0, L"CAGetCertTypePropertyEx (CERTTYPE_PROP_FRIENDLY_NAME) failed: 0x%x\n", hr);
        }

        hr = CACloseCertType (hCertType);
        _ASSERT (SUCCEEDED (hr));
        if ( !SUCCEEDED (hr) )
        {
            _TRACE (0, L"CACloseCertType (%s) failed: 0x%x\n", hr);
        }
    }
    else
    {
        _TRACE (0, L"CAFindCertTypeByName (%s) failed: 0x%x\n", 
                (PCWSTR) szTemplateName, hr);
    }
    return hr;
}

void CTemplateV2SupercedesPropertyPage::OnItemchangedSupercededTemplatesList(NMHDR* /*pNMHDR*/, LRESULT* pResult) 
{
    EnableControls ();	

	
	*pResult = 0;
}

void CTemplateV2SupercedesPropertyPage::DoContextHelp (HWND hWndControl)
{
	_TRACE(1, L"Entering CTemplateV2SupercedesPropertyPage::DoContextHelp\n");
    
	switch (::GetDlgCtrlID (hWndControl))
	{
	case IDC_SUPERCEDES_LABEL:
    case IDC_STATIC:
		break;

	default:
		// Display context help for a control
		if ( !::WinHelp (
				hWndControl,
				GetContextHelpFile (),
				HELP_WM_HELP,
				(DWORD_PTR) g_aHelpIDs_IDD_TEMPLATE_V2_SUPERCEDES) )
		{
			_TRACE(0, L"WinHelp () failed: 0x%x\n", GetLastError ());        
		}
		break;
	}
    _TRACE(-1, L"Leaving CTemplateV2SupercedesPropertyPage::DoContextHelp\n");
}

void CTemplateV2SupercedesPropertyPage::OnDestroy() 
{
	CHelpPropertyPage::OnDestroy();
	
    m_imageListNormal.Destroy ();
    m_imageListSmall.Destroy ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\templatev2requestpropertypage.cpp ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2002.
//
//  File:       TemplateV2RequestPropertyPage.cpp
//
//  Contents:   Implementation of CTemplateV2RequestPropertyPage
//
//----------------------------------------------------------------------------
// TemplateV2RequestPropertyPage.cpp : implementation file
//

#include "stdafx.h"
#include "TemplateV2RequestPropertyPage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTemplateV2RequestPropertyPage property page
enum {
    REQUEST_PURPOSE_SIGNATURE = 0,
    REQUEST_PURPOSE_ENCRYPTION,
    REQUEST_PURPOSE_SIGNATURE_AND_ENCRYPTION,
    REQUEST_PURPOSE_SIGNATURE_AND_SMARTCARD_LOGON
};

const DWORD CERTTMPL_NON_LOCAL_CSP = (DWORD) -1;

CTemplateV2RequestPropertyPage::CTemplateV2RequestPropertyPage(
        CCertTemplate& rCertTemplate, bool& rbIsDirty) : 
    CHelpPropertyPage(CTemplateV2RequestPropertyPage::IDD),
    m_rCertTemplate (rCertTemplate),
    m_rbIsDirty (rbIsDirty),
    m_nProvDSSCnt (0)
{
    _TRACE (1, L"Entering CTemplateV2RequestPropertyPage::CTemplateV2RequestPropertyPage ()\n");
    //{{AFX_DATA_INIT(CTemplateV2RequestPropertyPage)
    //}}AFX_DATA_INIT
    m_rCertTemplate.AddRef ();

    _TRACE (-1, L"Leaving CTemplateV2RequestPropertyPage::CTemplateV2RequestPropertyPage ()\n");
}

CTemplateV2RequestPropertyPage::~CTemplateV2RequestPropertyPage()
{
    _TRACE (1, L"Entering CTemplateV2RequestPropertyPage::~CTemplateV2RequestPropertyPage ()\n");

    while ( !m_CSPList.IsEmpty () )
    {
        CT_CSP_DATA* pCSPData = m_CSPList.RemoveHead ();
        if ( pCSPData )
            delete pCSPData;
    }

   m_rCertTemplate.Release ();
    _TRACE (-1, L"Leaving CTemplateV2RequestPropertyPage::~CTemplateV2RequestPropertyPage ()\n");
}

void CTemplateV2RequestPropertyPage::DoDataExchange(CDataExchange* pDX)
{
    CHelpPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CTemplateV2RequestPropertyPage)
    DDX_Control(pDX, IDC_MINIMUM_KEYSIZE_VALUE, m_minKeySizeCombo);
    DDX_Control(pDX, IDC_PURPOSE_COMBO, m_purposeCombo);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTemplateV2RequestPropertyPage, CHelpPropertyPage)
    //{{AFX_MSG_MAP(CTemplateV2RequestPropertyPage)
    ON_CBN_SELCHANGE(IDC_PURPOSE_COMBO, OnSelchangePurposeCombo)
    ON_BN_CLICKED(IDC_EXPORT_PRIVATE_KEY, OnExportPrivateKey)
    ON_BN_CLICKED(IDC_ARCHIVE_KEY_CHECK, OnArchiveKeyCheck)
    ON_BN_CLICKED(IDC_INCLUDE_SYMMETRIC_ALGORITHMS_CHECK, OnIncludeSymmetricAlgorithmsCheck)
    ON_CBN_SELCHANGE(IDC_MINIMUM_KEYSIZE_VALUE, OnSelchangeMinimumKeysizeValue)
    ON_BN_CLICKED(IDC_DELETE_PERMANENTLY, OnDeletePermanently)
    ON_BN_CLICKED(IDC_CSPS, OnCsps)
    ON_BN_CLICKED(IDC_ENROLL_WITHOUT_INPUT, OnEnrollWithoutInput)
    ON_BN_CLICKED(IDC_ENROLL_PROMPT_USER, OnEnrollPromptUser)
    ON_BN_CLICKED(IDC_ENROLL_PROMPT_USER_REQUIRE_IF_PRIVATE_KEY, OnEnrollPromptUserRequireIfPrivateKey)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTemplateV2RequestPropertyPage message handlers


BOOL CTemplateV2RequestPropertyPage::OnInitDialog() 
{
    _TRACE (1, L"Entering CTemplateV2RequestPropertyPage::OnInitDialog ()\n");
    CHelpPropertyPage::OnInitDialog();

    CString text;

    VERIFY (text.LoadString (IDS_SIGNATURE));
    int nIndex = m_purposeCombo.AddString (text);
    if ( nIndex >= 0 )
    {
        m_purposeCombo.SetItemData (nIndex, (DWORD_PTR) REQUEST_PURPOSE_SIGNATURE);
        if ( m_rCertTemplate.HasKeySpecSignature () )
            m_purposeCombo.SetCurSel (nIndex);
    }

    VERIFY (text.LoadString (IDS_ENCRYPTION));
    nIndex = m_purposeCombo.AddString (text);
    if ( nIndex >= 0 )
    {
        m_purposeCombo.SetItemData (nIndex, (DWORD_PTR) REQUEST_PURPOSE_ENCRYPTION);
        if ( m_rCertTemplate.HasEncryptionSignature () )
            m_purposeCombo.SetCurSel (nIndex);
    }
    
    VERIFY (text.LoadString (IDS_SIGNATURE_AND_ENCRYPTION));
    nIndex = m_purposeCombo.AddString (text);
    if ( nIndex >= 0 )
    {
        // NTRAID# 278356  CertSRV: No CSPs in mmc certificate snapin advanced 
        // option list with v2 templates that have ENC and SIG as purpose.
        bool bHasDigitalSignature = false;

        m_rCertTemplate.GetDigitalSignature (bHasDigitalSignature);

        m_purposeCombo.SetItemData (nIndex, (DWORD_PTR) REQUEST_PURPOSE_SIGNATURE_AND_ENCRYPTION);
        if ( m_rCertTemplate.HasEncryptionSignature () && 
                (bHasDigitalSignature || m_rCertTemplate.HasKeySpecSignature ()) )
            m_purposeCombo.SetCurSel (nIndex);
    }

    // NTRAID# 476615 Certtmpl: Signature and Smart Card Logon Certificate 
    // Purpose should only be available for User Templates.
    if ( !m_rCertTemplate.IsMachineType () )
    {
        VERIFY (text.LoadString (IDS_SIGNATURE_AND_SMARTCARD_LOGON));
        nIndex = m_purposeCombo.AddString (text);
        if ( nIndex >= 0 )
        {
            // NTRAID# 278356  CertSRV: No CSPs in mmc certificate snapin advanced 
            // option list with v2 templates that have ENC and SIG as purpose.
            bool bHasDigitalSignature = false;
            bool bHasOnlyDigitalSignature = false;

            m_rCertTemplate.GetDigitalSignature (bHasDigitalSignature,
                    &bHasOnlyDigitalSignature);

            m_purposeCombo.SetItemData (nIndex, (DWORD_PTR) REQUEST_PURPOSE_SIGNATURE_AND_SMARTCARD_LOGON);
            if ( bHasOnlyDigitalSignature && 
                    bHasDigitalSignature && m_rCertTemplate.HasEncryptionSignature () )
            {
                m_purposeCombo.SetCurSel (nIndex);
            }
        }
    }


    // Initialize minimum key size combo box- values in powers of 2 from 512 to 16384
    DWORD   dwMinKeySize = 0;
    m_rCertTemplate.GetMinimumKeySize (dwMinKeySize);
    AddKeySizeToCombo(512, L"512", dwMinKeySize);
    AddKeySizeToCombo(768, L"768", dwMinKeySize);
    AddKeySizeToCombo(1024, L"1024", dwMinKeySize);
    AddKeySizeToCombo(2048, L"2048", dwMinKeySize);
    AddKeySizeToCombo(4096, L"4096", dwMinKeySize);
    AddKeySizeToCombo(8192, L"8192", dwMinKeySize);
    AddKeySizeToCombo(16384, L"16384", dwMinKeySize);

    if ( SUCCEEDED (EnumerateCSPs (dwMinKeySize)) )
    {

    }

    if ( m_rCertTemplate.PrivateKeyIsExportable () )
        SendDlgItemMessage (IDC_EXPORT_PRIVATE_KEY, BM_SETCHECK, BST_CHECKED);

    if ( m_rCertTemplate.AllowPrivateKeyArchival () )
        SendDlgItemMessage (IDC_ARCHIVE_KEY_CHECK, BM_SETCHECK, BST_CHECKED);

    if ( m_rCertTemplate.IncludeSymmetricAlgorithms () )
        SendDlgItemMessage (IDC_INCLUDE_SYMMETRIC_ALGORITHMS_CHECK, BM_SETCHECK, BST_CHECKED);

    GetDlgItem (IDC_ARCHIVE_KEY_CHECK)->ShowWindow (SW_SHOW);
    GetDlgItem (IDC_MINIMUM_KEYSIZE_VALUE)->ShowWindow (SW_SHOW);
    GetDlgItem (IDC_MINIMUM_KEYSIZE_LABEL)->ShowWindow (SW_SHOW);
    GetDlgItem (IDC_INCLUDE_SYMMETRIC_ALGORITHMS_CHECK)->ShowWindow (SW_SHOW);


    if ( m_rCertTemplate.UserInteractionRequired () )
    {
        if ( m_rCertTemplate.StrongKeyProtectionRequired () )
            SendDlgItemMessage (IDC_ENROLL_PROMPT_USER_REQUIRE_IF_PRIVATE_KEY, BM_SETCHECK, BST_CHECKED);
        else
            SendDlgItemMessage (IDC_ENROLL_PROMPT_USER, BM_SETCHECK, BST_CHECKED);
    }
    else
    {
        SendDlgItemMessage (IDC_ENROLL_WITHOUT_INPUT, BM_SETCHECK, BST_CHECKED);
    }
      

    if ( m_rCertTemplate.RemoveInvalidCertFromPersonalStore () )
        SendDlgItemMessage (IDC_DELETE_PERMANENTLY, BM_SETCHECK, BST_CHECKED);

    EnableControls ();

    _TRACE (-1, L"Leaving CTemplateV2RequestPropertyPage::OnInitDialog ()\n");
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CTemplateV2RequestPropertyPage::EnableControls ()
{
    if (  m_rCertTemplate.ReadOnly () )
    {
        GetDlgItem (IDC_PURPOSE_COMBO)->EnableWindow (FALSE);

        GetDlgItem (IDC_EXPORT_PRIVATE_KEY)->EnableWindow (FALSE);

        //version 2 fields
        GetDlgItem (IDC_ARCHIVE_KEY_CHECK)->EnableWindow (FALSE);
        GetDlgItem (IDC_INCLUDE_SYMMETRIC_ALGORITHMS_CHECK)->EnableWindow (FALSE);
        SendDlgItemMessage (IDC_INCLUDE_SYMMETRIC_ALGORITHMS_CHECK, BM_SETCHECK, BST_UNCHECKED);
        GetDlgItem (IDC_MINIMUM_KEYSIZE_LABEL)->EnableWindow (FALSE);
        GetDlgItem (IDC_MINIMUM_KEYSIZE_VALUE)->EnableWindow (FALSE);
        GetDlgItem (IDC_DELETE_PERMANENTLY)->EnableWindow (FALSE);
        GetDlgItem (IDC_ENROLL_WITHOUT_INPUT)->EnableWindow (FALSE);
        GetDlgItem (IDC_ENROLL_PROMPT_USER)->EnableWindow (FALSE);
        GetDlgItem (IDC_ENROLL_PROMPT_USER_REQUIRE_IF_PRIVATE_KEY)->EnableWindow (FALSE);

        GetDlgItem (IDC_PURPOSE_LABEL)->EnableWindow (FALSE);
        GetDlgItem (IDC_INPUT_LABEL)->EnableWindow (FALSE);
        GetDlgItem (IDC_CSP_LABEL)->EnableWindow (FALSE);
    }
    else
    {
        BOOL bEncryptionSelected = FALSE; 
        int nIndex = m_purposeCombo.GetCurSel ();

        
        if ( nIndex >= 0 )
        {
            switch (m_purposeCombo.GetItemData (nIndex))
            {
            case REQUEST_PURPOSE_SIGNATURE:
                GetDlgItem (IDC_ENROLL_WITHOUT_INPUT)->EnableWindow (TRUE);
                GetDlgItem (IDC_EXPORT_PRIVATE_KEY)->EnableWindow (TRUE);
                bEncryptionSelected = FALSE;
                break;

            case REQUEST_PURPOSE_SIGNATURE_AND_SMARTCARD_LOGON:
                GetDlgItem (IDC_ENROLL_WITHOUT_INPUT)->EnableWindow (FALSE);
                GetDlgItem (IDC_EXPORT_PRIVATE_KEY)->EnableWindow (FALSE);
                bEncryptionSelected = FALSE;
                break;

            case REQUEST_PURPOSE_SIGNATURE_AND_ENCRYPTION:
            case REQUEST_PURPOSE_ENCRYPTION:
                GetDlgItem (IDC_ENROLL_WITHOUT_INPUT)->EnableWindow (TRUE);
                GetDlgItem (IDC_EXPORT_PRIVATE_KEY)->EnableWindow (TRUE);
                bEncryptionSelected = TRUE;
                break;

            default:
                _ASSERT (0);
                break;
            }
        }

        GetDlgItem (IDC_DELETE_PERMANENTLY)->EnableWindow (!bEncryptionSelected);
        if ( bEncryptionSelected && 
                BST_CHECKED == SendDlgItemMessage (IDC_DELETE_PERMANENTLY, BM_GETCHECK) )
        {
            SendDlgItemMessage (IDC_DELETE_PERMANENTLY, BM_SETCHECK, BST_UNCHECKED);
            m_rCertTemplate.SetRemoveInvalidCertFromPersonalStore (false);
        }

        GetDlgItem (IDC_INCLUDE_SYMMETRIC_ALGORITHMS_CHECK)->EnableWindow (bEncryptionSelected);
        if ( !bEncryptionSelected )
        {
            SendDlgItemMessage (IDC_INCLUDE_SYMMETRIC_ALGORITHMS_CHECK, BM_SETCHECK, BST_UNCHECKED);
        }

        BOOL bEnableArchiveKeyCheck = bEncryptionSelected;

        if ( m_nProvDSSCnt > 0 )
            bEnableArchiveKeyCheck = FALSE;

        if ( bEnableArchiveKeyCheck )
        {
            GetDlgItem (IDC_ARCHIVE_KEY_CHECK)->EnableWindow (TRUE);
        }
        else
        {
            SendDlgItemMessage (IDC_ARCHIVE_KEY_CHECK, BM_SETCHECK, BST_UNCHECKED);
            OnArchiveKeyCheck ();   // clear flag
            GetDlgItem (IDC_ARCHIVE_KEY_CHECK)->EnableWindow (FALSE);
        }

        if ( m_rCertTemplate.IsMachineType () || m_rCertTemplate.SubjectIsCA () ||
                m_rCertTemplate.SubjectIsCrossCA () )
        {
            GetDlgItem (IDC_ENROLL_WITHOUT_INPUT)->EnableWindow (FALSE);
            GetDlgItem (IDC_ENROLL_PROMPT_USER)->EnableWindow (FALSE);
            GetDlgItem (IDC_ENROLL_PROMPT_USER_REQUIRE_IF_PRIVATE_KEY)->EnableWindow (FALSE);
        }
    }
}


HRESULT CTemplateV2RequestPropertyPage::EnumerateCSPs(DWORD dwMinKeySize)
{
    _TRACE (1, L"Entering CTemplateV2RequestPropertyPage::EnumerateCSPs\n");
    HRESULT hr = S_OK;
    for (DWORD dwIndex = 0; ;dwIndex++)
    {
        DWORD   cbName = 0;
        DWORD   dwProvType = 0;

        if ( CryptEnumProviders (dwIndex, NULL, 0, &dwProvType, NULL, &cbName) )
        {
            PWSTR  pszTypeName = new WCHAR[cbName];
            if ( pszTypeName )
            {
                if ( CryptEnumProviders (dwIndex, NULL, 0, &dwProvType,
                        pszTypeName, &cbName) )
                {
                    DWORD   dwSigMaxKey = (DWORD) -1;
                    DWORD   dwKeyExMaxKey = (DWORD) -1;

                    CSPGetMaxKeySupported (pszTypeName, dwProvType, dwSigMaxKey, dwKeyExMaxKey);
                    // If either of these values is still -1, then it was not 
                    // set.  Set to 0.
                    if ( -1 == dwSigMaxKey )
                        dwSigMaxKey = 0;
                    if ( -1 == dwKeyExMaxKey )
                        dwKeyExMaxKey = 0;
                    CT_CSP_DATA* pNewData = new CT_CSP_DATA (pszTypeName, 
                            dwProvType, dwSigMaxKey, dwKeyExMaxKey);
                    if ( pNewData )
                    {
                        m_CSPList.AddTail (pNewData);
                    }
                }
                else
                {
                    hr = HRESULT_FROM_WIN32 (GetLastError ());
                    _TRACE (0, L"CryptEnumProviderTypes () failed: 0x%x\n", hr);
                    break;
                }

                delete [] pszTypeName;
            }
            else
                hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = HRESULT_FROM_WIN32 (GetLastError ());
            _TRACE (0, L"CryptEnumProviderTypes () failed: 0x%x\n", hr);
            break;
        }
    }


    int     nCSPIndex = 0;
    CString szCSP;
    CString szInvalidCSPs;

    // Set the selection
    // Get the list of selected CSPs from the cert template.
    // If a selected CSP is not found in the generated CSP list, add it to the list
    m_nProvDSSCnt = 0;
    nCSPIndex = 0;
    while ( SUCCEEDED (m_rCertTemplate.GetCSP (nCSPIndex, szCSP)) )
    {
        bool    bFound = false;
        for (POSITION nextPos = m_CSPList.GetHeadPosition (); nextPos; )
        {
            CT_CSP_DATA* pCSPData = m_CSPList.GetNext (nextPos);
            if ( pCSPData )
            {
                if ( !LocaleStrCmp (szCSP, pCSPData->m_szName) )
                {
                    pCSPData->m_bSelected = true;
                    if ( PROV_DSS == pCSPData->m_dwProvType || 
                            PROV_DSS_DH == pCSPData->m_dwProvType )
                    {
                        m_nProvDSSCnt++;
                    }
                    bFound = true;
                    break;
                }
            }
        }

        if ( !bFound )
        {
            if ( !szInvalidCSPs.IsEmpty () )
                szInvalidCSPs += L", ";
            szInvalidCSPs += szCSP;

            // Should show CSPs that are not available on the client
            CT_CSP_DATA* pNewData = new CT_CSP_DATA (szCSP, 
                    CERTTMPL_NON_LOCAL_CSP, 0, 0);
            if ( pNewData )
            {
                pNewData->m_bSelected = true;
                m_CSPList.AddTail (pNewData);
            }
        }
        nCSPIndex++;
    }

    if ( !szInvalidCSPs.IsEmpty () )
    {
        CString text;
        CString caption;
        CThemeContextActivator activator;

        VERIFY (caption.LoadString (IDS_CERTTMPL));
        text.FormatMessage (IDS_CSPS_NOT_INSTALLED_LOCALLY, (PCWSTR) szInvalidCSPs);

        MessageBox (text, caption, MB_OK | MB_ICONWARNING);
    }

    NormalizeCSPList (dwMinKeySize);

    EnableControls ();

    _TRACE (-1, L"Entering CTemplateV2RequestPropertyPage::EnumerateCSPs: 0x%x\n", hr);
    return hr;
}



void CTemplateV2RequestPropertyPage::OnSelchangePurposeCombo() 
{
    int nIndex = m_purposeCombo.GetCurSel ();
    if ( nIndex >= 0 )
    {
        // NTRAID# 278356  CertSRV: No CSPs in mmc certificate snapin advanced 
        // option list with v2 templates that have ENC and SIG as purpose.
        switch (m_purposeCombo.GetItemData (nIndex))
        {
        case REQUEST_PURPOSE_SIGNATURE:
            m_rCertTemplate.SetEncryptionSignature (false);
            m_rCertTemplate.SetKeySpecSignature (true);
            m_rCertTemplate.IncludeSymmetricAlgorithms (false);
            m_rCertTemplate.AllowPrivateKeyArchival (false);
            break;

        case REQUEST_PURPOSE_ENCRYPTION:
            m_rCertTemplate.SetEncryptionSignature (true);
            m_rCertTemplate.SetKeySpecSignature (false);
            m_rCertTemplate.SetDigitalSignature (false);
            break;

        case REQUEST_PURPOSE_SIGNATURE_AND_ENCRYPTION:
            m_rCertTemplate.SetEncryptionSignature (true);
            m_rCertTemplate.SetKeySpecSignature (false);
            m_rCertTemplate.SetDigitalSignature (true);
            break;

        case REQUEST_PURPOSE_SIGNATURE_AND_SMARTCARD_LOGON:
            m_rCertTemplate.SetKeySpecSignature (false);
            m_rCertTemplate.SetEncryptionSignature (true);
            m_rCertTemplate.SetDigitalSignature (true, true);
            // 499389 CertTMPL: Signature and Smartcard Logon purpose does not 
            // clear CT_FLAG_INCLUDE_SYMMETRIC_ALGORITHMS flag
            m_rCertTemplate.IncludeSymmetricAlgorithms (false);
            if ( BST_CHECKED == SendDlgItemMessage (IDC_ENROLL_WITHOUT_INPUT, BM_GETCHECK) )
            {
                m_rCertTemplate.SetUserInteractionRequired (true);
                m_rCertTemplate.SetStrongKeyProtectionRequired (false);
                SendDlgItemMessage (IDC_ENROLL_WITHOUT_INPUT, BM_SETCHECK, BST_UNCHECKED);
                SendDlgItemMessage (IDC_ENROLL_PROMPT_USER, BM_SETCHECK, BST_CHECKED);
            }

            // smart card keys not exportable
            SendDlgItemMessage (IDC_EXPORT_PRIVATE_KEY, BM_SETCHECK, BST_UNCHECKED);
            m_rCertTemplate.MakePrivateKeyExportable (false);
            break;

        default:
            _ASSERT (0);
            break;
        }
    }


    int nSel = m_minKeySizeCombo.GetCurSel ();
    ASSERT (nSel >= 0);
    if ( nSel >= 0 )
    {
        DWORD   dwMinKeySize = (DWORD) m_minKeySizeCombo.GetItemData (nSel);
        ASSERT (dwMinKeySize > 0);

        // Clear CSP list and add only values that correspond, saving 
        // selection for conforming CSPs
        int nInitialSelCnt = GetSelectedCSPCount ();
        NormalizeCSPList (dwMinKeySize);
        int nFinalSelCnt = GetSelectedCSPCount ();

        if ( nInitialSelCnt > 0 && 0 == nFinalSelCnt )
        {
            CString caption;
            CString text;

            VERIFY (caption.LoadString (IDS_CSP_SELECTION));
            VERIFY (text.LoadString (IDS_NO_SELECTED_CSPS));

            if ( IDYES == MessageBox (text, caption, MB_YESNO) )
            {
                OnCsps();
            }
        }
    }


    SetModified ();
    m_rbIsDirty = true;
    EnableControls ();
}

void CTemplateV2RequestPropertyPage::AddKeySizeToCombo(DWORD dwValue, PCWSTR strValue, DWORD dwSizeToSelect)
{
    int nIndex = m_minKeySizeCombo.AddString (strValue);
    if ( nIndex >= 0 )
    {
        m_minKeySizeCombo.SetItemData (nIndex, dwValue);
        if ( dwSizeToSelect == dwValue )
            m_minKeySizeCombo.SetCurSel (nIndex);
    }
}

void CTemplateV2RequestPropertyPage::OnExportPrivateKey() 
{
    bool bMakeExportable = (BST_CHECKED == SendDlgItemMessage (IDC_EXPORT_PRIVATE_KEY, BM_GETCHECK));
    
    m_rCertTemplate.MakePrivateKeyExportable (bMakeExportable);
    SetModified ();
    m_rbIsDirty = true;
}

void CTemplateV2RequestPropertyPage::OnArchiveKeyCheck() 
{
    bool bAllowKeyArchival = (BST_CHECKED == SendDlgItemMessage (IDC_ARCHIVE_KEY_CHECK, BM_GETCHECK));
    
    m_rCertTemplate.AllowPrivateKeyArchival (bAllowKeyArchival);
    SetModified ();
    m_rbIsDirty = true;
}

void CTemplateV2RequestPropertyPage::OnIncludeSymmetricAlgorithmsCheck() 
{
    bool bInclude = 
            (BST_CHECKED == SendDlgItemMessage (IDC_INCLUDE_SYMMETRIC_ALGORITHMS_CHECK, BM_GETCHECK));
    
    m_rCertTemplate.IncludeSymmetricAlgorithms (bInclude);
    SetModified ();
    m_rbIsDirty = true;
}

void CTemplateV2RequestPropertyPage::OnSelchangeMinimumKeysizeValue() 
{
    SetModified ();
    m_rbIsDirty = true;

    int nSel = m_minKeySizeCombo.GetCurSel ();
    ASSERT (nSel >= 0);
    if ( nSel >= 0 )
    {
        DWORD   dwMinKeySize = (DWORD) m_minKeySizeCombo.GetItemData (nSel);
        ASSERT (dwMinKeySize > 0);
        HRESULT hr = m_rCertTemplate.SetMinimumKeySizeValue (dwMinKeySize);
        if ( FAILED (hr) )
        {
            CString text;
            CString caption;
            CThemeContextActivator activator;

            VERIFY (caption.LoadString (IDS_CERTTMPL));
            // security review 2/20/2002 BryanWal ok
            text.FormatMessage (IDS_CANNOT_WRITE_MINKEYSIZE, hr);

            MessageBox (text, caption, MB_OK | MB_ICONWARNING);
        }


        // Clear CSP list and add only values that correspond, saving checks
        int nInitialSelCnt = GetSelectedCSPCount ();
        NormalizeCSPList (dwMinKeySize);
        int nFinalSelCnt = GetSelectedCSPCount ();

        if ( nInitialSelCnt > 0 && 0 == nFinalSelCnt )
        {
            CString caption;
            CString text;

            VERIFY (caption.LoadString (IDS_CSP_SELECTION));
            VERIFY (text.LoadString (IDS_NO_SELECTED_CSPS));

            if ( IDYES == MessageBox (text, caption, MB_YESNO) )
            {
                OnCsps();
            }
        }
    }
}


void CTemplateV2RequestPropertyPage::DoContextHelp (HWND hWndControl)
{
    _TRACE(1, L"Entering CTemplateV2RequestPropertyPage::DoContextHelp\n");
    
    switch (::GetDlgCtrlID (hWndControl))
    {
    case IDC_STATIC:
    case IDC_MINIMUM_KEYSIZE_LABEL:
    case IDC_INPUT_LABEL:
        break;

    default:
        // Display context help for a control
        if ( !::WinHelp (
                hWndControl,
                GetContextHelpFile (),
                HELP_WM_HELP,
                (DWORD_PTR) g_aHelpIDs_IDD_TEMPLATE_V2_REQUEST) )
        {
            _TRACE(0, L"WinHelp () failed: 0x%x\n", GetLastError ());        
        }
        break;
    }
    _TRACE(-1, L"Leaving CTemplateV2RequestPropertyPage::DoContextHelp\n");
}


void CTemplateV2RequestPropertyPage::OnDeletePermanently() 
{
    m_rCertTemplate.SetRemoveInvalidCertFromPersonalStore (
            BST_CHECKED == SendDlgItemMessage (IDC_DELETE_PERMANENTLY, BM_GETCHECK));
    SetModified ();
    m_rbIsDirty = true;
}


HRESULT CTemplateV2RequestPropertyPage::CSPGetMaxKeySupported (
        PCWSTR pszProvider, 
        DWORD dwProvType, 
        DWORD& rdwSigMaxKey, 
        DWORD& rdwKeyExMaxKey)
{
    _TRACE (1, L"Entering CTemplateV2RequestPropertyPage::CSPGetMaxKeySupported (%s)\n",
            pszProvider);
    HRESULT     hr = S_OK;
    HCRYPTPROV  hProv = 0;

    BOOL bResult = ::CryptAcquireContext (&hProv,
            NULL,
            pszProvider,
            dwProvType,
            CRYPT_VERIFYCONTEXT | CRYPT_SILENT);
    if ( bResult )
    {
        PROV_ENUMALGS_EX EnumAlgs;     //   Structure to hold information on 
                                   //   a supported algorithm
        DWORD dFlag = CRYPT_FIRST;     //   Flag indicating that the first
                                       //   supported algorithm is to be
                                       //   enumerated. Changed to 0 after the
                                       //   first call to the function.
        DWORD   cbData = sizeof(PROV_ENUMALGS_EX);

        while (CryptGetProvParam(
                hProv,              // handle to an open cryptographic provider
                PP_ENUMALGS_EX, 
                (BYTE *)&EnumAlgs,  // information on the next algorithm
                &cbData,            // number of bytes in the PROV_ENUMALGS_EX
                dFlag))             // flag to indicate whether this is a first or
                                    // subsequent algorithm supported by the
                                    // CSP.
        {
            if ( ALG_CLASS_SIGNATURE == GET_ALG_CLASS (EnumAlgs.aiAlgid) )
                rdwSigMaxKey = EnumAlgs.dwMaxLen;

            if ( ALG_CLASS_KEY_EXCHANGE == GET_ALG_CLASS (EnumAlgs.aiAlgid) )
                rdwKeyExMaxKey = EnumAlgs.dwMaxLen;

            if ( -1 != rdwSigMaxKey && -1 != rdwKeyExMaxKey )
                break;  // both have been set

            dFlag = 0;          // Set to 0 after the first call,
        } //  end of while loop. When all of the supported algorithms have
          //  been enumerated, the function returns FALSE.

        ::CryptReleaseContext (hProv, 0);
    }
    else
    {
        DWORD   dwErr = GetLastError ();
        _TRACE (0, L"CryptAcquireContext () failed: 0x%x\n", dwErr);
        hr = HRESULT_FROM_WIN32 (dwErr);
    }

    _TRACE (-1, L"Leaving CTemplateV2RequestPropertyPage::CSPGetMaxKeySupported (%s)\n",
            pszProvider);
    return hr;
}

// NTRAID# 313348 Cert Template UI: Need to warn the user if the template 
// minimum key length is not supported by the CSPs
void CTemplateV2RequestPropertyPage::NormalizeCSPList (DWORD dwMinKeySize)
{
    bool bSignatureOnly = false;
    int nIndex = m_purposeCombo.GetCurSel ();
    if ( nIndex >= 0 )
        bSignatureOnly = (REQUEST_PURPOSE_SIGNATURE == m_purposeCombo.GetItemData (nIndex));

    // Check for conforming CSPs
    for (POSITION nextPos = m_CSPList.GetHeadPosition (); nextPos; )
    {
        CT_CSP_DATA* pCSPData = m_CSPList.GetNext (nextPos);
        if ( pCSPData )
        {
            bool bAddString = false;

            // NTRAID# 460671: Certtmpl.msc: Should show  CSPs that is not 
            // available on the client
            if ( CERTTMPL_NON_LOCAL_CSP == pCSPData->m_dwProvType )
                bAddString = true;
            else if ( bSignatureOnly && pCSPData->m_dwSigMaxKeySize >= dwMinKeySize )
                bAddString = true;
            else if ( pCSPData->m_dwKeyExMaxKeySize >= dwMinKeySize )
                bAddString = true;

            if ( bAddString )
            {
                pCSPData->m_bConforming = true;
            }
            else
            {
                pCSPData->m_bConforming = false;

                if ( pCSPData->m_bSelected )
                {
                    HRESULT hr = m_rCertTemplate.ModifyCSPList (pCSPData->m_szName, false); // remove
                    if ( SUCCEEDED (hr) )
                    {
                        pCSPData->m_bSelected = false;
                        if ( PROV_DSS == pCSPData->m_dwProvType || 
                                PROV_DSS_DH == pCSPData->m_dwProvType )
                        {
                            m_nProvDSSCnt--;
                        }

                        SetModified ();
                        m_rbIsDirty = true;
                    }
                }
            }
        }
    }
}

int CTemplateV2RequestPropertyPage::GetSelectedCSPCount ()
{
    int nSelected = 0;

    for (POSITION nextPos = m_CSPList.GetHeadPosition (); nextPos; )
    {
        CT_CSP_DATA* pCSPData = m_CSPList.GetNext (nextPos);
        if ( pCSPData )
        {
            if ( pCSPData->m_bSelected )
                nSelected++;
        }
    }

    return nSelected;
}

void CTemplateV2RequestPropertyPage::OnCsps() 
{
    bool bSignatureOnly = false;
    int nIndex = m_purposeCombo.GetCurSel ();
    if ( nIndex >= 0 )
        bSignatureOnly = (REQUEST_PURPOSE_SIGNATURE == m_purposeCombo.GetItemData (nIndex));


    CSelectCSPDlg dlg (this, m_rCertTemplate, m_CSPList, m_nProvDSSCnt);

    if ( IDOK == dlg.DoModal () )
    {
        HRESULT hr = S_OK;
        for (POSITION nextPos = m_CSPList.GetHeadPosition (); nextPos; )
        {
            CT_CSP_DATA* pCSPData = m_CSPList.GetNext (nextPos);
            if ( pCSPData )
            {
                if ( pCSPData->m_bSelected )
                    hr = m_rCertTemplate.ModifyCSPList (pCSPData->m_szName, true); // add
                else
                    hr = m_rCertTemplate.ModifyCSPList (pCSPData->m_szName, false); // remove
                if ( FAILED (hr) )
                    break;
            }
        }

        if ( SUCCEEDED (hr) )
        {
            SetModified ();
            m_rbIsDirty = true;
        }
        EnableControls ();
    }
}

void CTemplateV2RequestPropertyPage::OnEnrollWithoutInput() 
{
    m_rCertTemplate.SetUserInteractionRequired (false);
    m_rCertTemplate.SetStrongKeyProtectionRequired (false);
    SetModified ();
    m_rbIsDirty = true;
}

void CTemplateV2RequestPropertyPage::OnEnrollPromptUser() 
{
    m_rCertTemplate.SetUserInteractionRequired (true);
    m_rCertTemplate.SetStrongKeyProtectionRequired (false);
    SetModified ();
    m_rbIsDirty = true;
}

void CTemplateV2RequestPropertyPage::OnEnrollPromptUserRequireIfPrivateKey() 
{
    m_rCertTemplate.SetUserInteractionRequired (true);
    m_rCertTemplate.SetStrongKeyProtectionRequired (true);
    SetModified ();
    m_rbIsDirty = true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\templatev2subjectnamepropertypage.h ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       TemplateV2SubjectNamePropertyPage.h
//
//  Contents:   Definition of CTemplateV2SubjectNamePropertyPage
//
//----------------------------------------------------------------------------
#if !defined(AFX_TEMPLATEV2SUBJECTNAMEPROPERTYPAGE_H__4EC37055_348A_462A_A177_286A2B0AF3F4__INCLUDED_)
#define AFX_TEMPLATEV2SUBJECTNAMEPROPERTYPAGE_H__4EC37055_348A_462A_A177_286A2B0AF3F4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// TemplateV2SubjectNamePropertyPage.h : header file
//
#include "CertTemplate.h"

/////////////////////////////////////////////////////////////////////////////
// CTemplateV2SubjectNamePropertyPage dialog

class CTemplateV2SubjectNamePropertyPage : public CHelpPropertyPage
{
// Construction
public:
	CTemplateV2SubjectNamePropertyPage(
            CCertTemplate& rCertTemplate, 
            bool& rbIsDirty, 
            bool bIsComputerOrDC = false);
	~CTemplateV2SubjectNamePropertyPage();

// Dialog Data
	//{{AFX_DATA(CTemplateV2SubjectNamePropertyPage)
	enum { IDD = IDD_TEMPLATE_V2_SUBJECT_NAME };
	CComboBox	m_nameCombo;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTemplateV2SubjectNamePropertyPage)
	public:
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    void SetSettingsForNameTypeNone ();
	virtual void DoContextHelp (HWND hWndControl);
	bool CanUncheckLastSetting (int ctrlID);
    virtual BOOL OnInitDialog();
	void EnableControls ();
	// Generated message map functions
	//{{AFX_MSG(CTemplateV2SubjectNamePropertyPage)
	afx_msg void OnSubjectAndSubjectAltName();
	afx_msg void OnSelchangeSubjectNameNameCombo();
	afx_msg void OnSubjectNameBuiltByCa();
	afx_msg void OnSubjectNameSuppliedInRequest();
	afx_msg void OnDnsName();
	afx_msg void OnEmailInAlt();
	afx_msg void OnEmailInSub();
	afx_msg void OnSpn();
	afx_msg void OnUpn();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    enum {
        NAME_TYPE_NONE = 0,
        NAME_TYPE_FULL_DN,
        NAME_TYPE_CN_ONLY
    };

private:
	bool&           m_rbIsDirty;
    CCertTemplate&  m_rCertTemplate;
    bool            m_bIsComputerOrDC;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TEMPLATEV2SUBJECTNAMEPROPERTYPAGE_H__4EC37055_348A_462A_A177_286A2B0AF3F4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\templatev2supercedespropertypage.h ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       TemplateV2SupercedesPropertyPage.h
//
//  Contents:   Definition of CTemplateV2SupercedesPropertyPage
//
//----------------------------------------------------------------------------
#if !defined(AFX_TEMPLATEV2SUPERCEDESPROPERTYPAGE_H__13B90B4A_2B60_492A_910F_8DA4383BDD8C__INCLUDED_)
#define AFX_TEMPLATEV2SUPERCEDESPROPERTYPAGE_H__13B90B4A_2B60_492A_910F_8DA4383BDD8C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// TemplateV2SupercedesPropertyPage.h : header file
//
#include "CertTemplate.h"

/////////////////////////////////////////////////////////////////////////////
// CTemplateV2SupercedesPropertyPage dialog

class CTemplateV2SupercedesPropertyPage : public CHelpPropertyPage
{
// Construction
public:
	CTemplateV2SupercedesPropertyPage(CCertTemplate& rCertTemplate, 
            bool& rbIsDirty,
            const CCertTmplComponentData* pCompData);
	~CTemplateV2SupercedesPropertyPage();

// Dialog Data
	//{{AFX_DATA(CTemplateV2SupercedesPropertyPage)
	enum { IDD = IDD_TEMPLATE_V2_SUPERCEDES };
	CListCtrl	m_templateList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTemplateV2SupercedesPropertyPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual void DoContextHelp (HWND hWndControl);
	HRESULT AddItem (const CString& szTemplateName, bool bSelect = false);
    virtual BOOL OnInitDialog();
	void EnableControls();
	// Generated message map functions
	//{{AFX_MSG(CTemplateV2SupercedesPropertyPage)
	afx_msg void OnAddSupercededTemplate();
	afx_msg void OnRemoveSupercededTemplate();
	afx_msg void OnDeleteitemSupercededTemplatesList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnItemchangedSupercededTemplatesList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	bool& m_rbIsDirty;
	WTL::CImageList m_imageListSmall;
	WTL::CImageList m_imageListNormal;
    CCertTemplate& m_rCertTemplate;
    const CStringList* m_pGlobalTemplateNameList;
    bool    m_bGlobalListCreatedByDialog;
    const CCertTmplComponentData* m_pCompData;

	enum {
		COL_CERT_TEMPLATE = 0,
        COL_CERT_VERSION, 
		NUM_COLS	// must be last
	};
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TEMPLATEV2SUPERCEDESPROPERTYPAGE_H__13B90B4A_2B60_492A_910F_8DA4383BDD8C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\uuids.h ===
// Nodetypes for the Certificate Templates snapin
// created by GUIDGEN 7/13/98 BryanWal

#ifndef _UUIDS_CERTTMPL_MANAGEMENT_
#define _UUIDS_CERTTMPL_MANAGEMENT_

#define struuidNodetypeSnapin			    "{C4EC3F82-0F43-4d72-B8A2-3D7A27F6D13A}"
#define struuidNodetypeCertTemplate         "{EE240DBE-9E44-4e85-AFB7-FB330048D4C7}"


#define lstruuidNodetypeSnapin				L"{C4EC3F82-0F43-4d72-B8A2-3D7A27F6D13A}"
#define lstruuidNodetypeCertTemplate        L"{EE240DBE-9E44-4e85-AFB7-FB330048D4C7}"



// {C4EC3F82-0F43-4d72-B8A2-3D7A27F6D13A}
#define structuuidNodetypeSnapin    \
    { 0xc4ec3f82, 0xf43, 0x4d72, { 0xb8, 0xa2, 0x3d, 0x7a, 0x27, 0xf6, 0xd1, 0x3a } }


// {EE240DBE-9E44-4e85-AFB7-FB330048D4C7}
#define structuuidNodetypeCertTemplate \
    { 0xee240dbe, 0x9e44, 0x4e85, { 0xaf, 0xb7, 0xfb, 0x33, 0x0, 0x48, 0xd4, 0xc7 } }



DEFINE_GUID (NODEID_CertTmpl_CERT_TEMPLATE, 0xee240dbe, 0x9e44, 0x4e85, 0xaf, 0xb7, 0xfb, 0x33, 0x0, 0x48, 0xd4, 0xc7);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\viewoiddlg.h ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       ViewOIDDlg.h
//
//  Contents:   Definition of CViewOIDDlg
//
//----------------------------------------------------------------------------
#if !defined(AFX_VIEWOIDDLG_H__CACA6370_0DB7_423B_80AD_C8F0F30D75D9__INCLUDED_)
#define AFX_VIEWOIDDLG_H__CACA6370_0DB7_423B_80AD_C8F0F30D75D9__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ViewOIDDlg.h : header file
//

#include "PolicyOID.h"

/////////////////////////////////////////////////////////////////////////////
// CViewOIDDlg dialog

class CViewOIDDlg : public CHelpDialog
{
// Construction
public:
	CViewOIDDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CViewOIDDlg)
	enum { IDD = IDD_VIEW_OIDS };
	CListCtrl	m_oidList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CViewOIDDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
	enum {
		COL_POLICY_NAME = 0,
        COL_OID,
        COL_POLICY_TYPE,
        COL_CPS_LOCATION,
		NUM_COLS	// must be last
	};

protected:
    virtual void DoContextHelp (HWND hWndControl);
    static int CALLBACK fnCompareOIDItems (LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
    HRESULT InsertItemInList (CPolicyOID* pPolicyOID);

	// Generated message map functions
	//{{AFX_MSG(CViewOIDDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnItemchangedOidList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnCopyOid();
	afx_msg void OnColumnclickOidList(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_VIEWOIDDLG_H__CACA6370_0DB7_423B_80AD_C8F0F30D75D9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\about.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       About.cpp
//
//  Contents:   
//
//----------------------------------------------------------------------------\
/////////////////////////////////////////////////////////////////////
//	About.cpp
//
//	Provide constructor for the CSnapinAbout implementation.
//
//	HISTORY
//	01-Aug-97	t-danm		Creation.
//  11-Sep-97	bryanwal	Modify for certificate manager
/////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "about.h"

#include "stdabout.cpp" 

// version and provider strings

#include <ntverp.h>
#define IDS_SNAPINABOUT_VERSION VER_PRODUCTVERSION_STR
#define IDS_SNAPINABOUT_PROVIDER VER_COMPANYNAME_STR


/////////////////////////////////////////////////////////////////////
CCertMgrAbout::CCertMgrAbout()
{
	m_szProvider = IDS_SNAPINABOUT_PROVIDER;
	m_szVersion = IDS_SNAPINABOUT_VERSION;
	m_uIdStrDestription = IDS_SNAPINABOUT_DESCRIPTION;
	m_uIdIconImage = IDI_CERTMGR;
	m_uIdBitmapSmallImage = IDB_CERTMGR_SMALL;
	m_uIdBitmapSmallImageOpen = IDB_CERTMGR_SMALL;
	m_uIdBitmapLargeImage = IDB_CERTMGR_LARGE;
	m_crImageMask = RGB(255, 0, 255);
}


/////////////////////////////////////////////////////////////////////
CPublicKeyPoliciesAbout::CPublicKeyPoliciesAbout()
{
	m_szProvider = IDS_SNAPINABOUT_PROVIDER;
	m_szVersion = IDS_SNAPINABOUT_VERSION;
	m_uIdStrDestription = IDS_SNAPINPKPABOUT_DESCRIPTION;
	m_uIdIconImage = IDI_CERTMGR;
	m_uIdBitmapSmallImage = IDB_CERTMGR_SMALL;
	m_uIdBitmapSmallImageOpen = IDB_CERTMGR_SMALL;
	m_uIdBitmapLargeImage = IDB_CERTMGR_LARGE;
	m_crImageMask = RGB(255, 0, 255);
}

/////////////////////////////////////////////////////////////////////
CSaferWindowsAbout::CSaferWindowsAbout()
{
	m_szProvider = IDS_SNAPINABOUT_PROVIDER;
	m_szVersion = IDS_SNAPINABOUT_VERSION;
	m_uIdStrDestription = IDS_SNAPINSAFERWINDOWSABOUT_DESCRIPTION;
	m_uIdIconImage = IDI_SAFER_WINDOWS_SNAPIN;
	m_uIdBitmapSmallImage = IDB_CERTMGR_SMALL;
	m_uIdBitmapSmallImageOpen = IDB_CERTMGR_SMALL;
	m_uIdBitmapLargeImage = IDB_SAFERWINDOWS_LARGE;
	m_crImageMask = RGB(255, 0, 255);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\utils.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       utils.h
//
//  Contents:   
//
//----------------------------------------------------------------------------
#ifndef __UTILS_H
#define __UTILS_H
#include "cookie.h"

typedef CArray<CCertTmplCookie*, CCertTmplCookie*> CCookiePtrArray;


// Convert win32 error code to a text message and display
void DisplaySystemError (HWND hParent, DWORD dwErr);
void TraceSystemError (DWORD dwErr);

extern PCWSTR MMC_APP;

HRESULT FormatDate (FILETIME utcDateTime, CString & pszDateTime);


bool IsWindowsNT ();

LRESULT RegDelnode (HKEY hKeyRoot, CString pszSubKey);

#define IID_PPV_ARG(Type, Expr) IID_##Type, \
    reinterpret_cast<void**>(static_cast<Type **>(Expr))


#define g_cszHideWelcomePage    L"Hide Session Wizard Welcome"

enum {
    PUBLISHER_DIRECTORY = 1,
    SUBSCRIBER_DIRECTORY
};


HRESULT InitObjectPickerForDomainComputers(IDsObjectPicker *pDsObjectPicker);
class CCertTmplComponentData; //forward declaration


// {4E40F770-369C-11d0-8922-00A024AB2DBB}
DEFINE_GUID(CLSID_DsSecurityPage,  0x4E40F770,  0x369C, 0x11d0, 0x89, 0x22, 0x0, 0xa0, 0x24, 0xab, 0x2d, 0xbb);

#define MAX_ADS_ENUM 16

void FreeStringArray (PWSTR* rgpszStrings, DWORD dwAddCount);


typedef enum {
    CERTTMPL_OBJECT_CERT_TEMPLATE
} CERTTMPL_OBJECT_TYPE;

HRESULT DisplayObjectCountInStatusBar (LPCONSOLE pConsole, DWORD dwCnt);
HRESULT DisplayRootNodeStatusBarText (LPCONSOLE pConsole);

////////////////////////////////////////////////////////////////////////////////
// CCredentialObject

class CCredentialObject
{
public :
    CCredentialObject() :
        m_pszPassword (0),
        m_bUseCredentials (false)
    {
    }

    CCredentialObject(CCredentialObject* pCredObject);

    ~CCredentialObject() 
    {
        free(m_pszPassword);
    }

    CString GetUsername() const { return m_sUsername; }
    void SetUsername (PCWSTR pszUsername) { m_sUsername = pszUsername; }
    HRESULT GetPassword (PWSTR pszPassword, int bufLen) const; 
    HRESULT SetPasswordFromHwnd (HWND hWnd);
    BOOL UseCredentials () const { return m_bUseCredentials; }
    void SetUseCredentials (const bool bUseCred) { m_bUseCredentials = bUseCred; }

private :
    CString m_sUsername;
    PWSTR m_pszPassword;
    bool m_bUseCredentials;
};

//  Do a case insensitive string compare that is safe for any locale.
//
//  Arguments:  [ptsz1] - strings to compare
//              [ptsz2]
//
//  Returns:    -1, 0, or 1 just like lstrcmpi
int LocaleStrCmp (LPCWSTR ptsz1, LPCWSTR ptsz2);

CString GetSystemMessage (DWORD dwErr);


PCWSTR  GetContextHelpFile ();

///////////////////////////////////////////////////////////////////////////////
//  OID functions
///////////////////////////////////////////////////////////////////////////////
bool MyGetOIDInfoA (CString & string, LPCSTR pszObjId);
HRESULT GetEnterpriseOIDs ();
HRESULT GetBuiltInOIDS ();
bool OIDHasValidFormat (PCWSTR pszOidValue, int& rErrorTypeStrID);

///////////////////////////////////////////////////////////////////////////////
bool IsCerttypeEditingAllowed();


void InstallWindows2002CertTemplates ();


#ifdef UNICODE
#define PROPSHEETPAGE_V3 PROPSHEETPAGEW_V3
#else
#define PROPSHEETPAGE_V3 PROPSHEETPAGEA_V3
#endif

HPROPSHEETPAGE MyCreatePropertySheetPage(AFX_OLDPROPSHEETPAGE* psp);

class CThemeContextActivator
{
public:
    CThemeContextActivator() : m_ulActivationCookie(0)
        { SHActivateContext (&m_ulActivationCookie); }

    ~CThemeContextActivator()
        { SHDeactivateContext (m_ulActivationCookie); }

private:
    ULONG_PTR m_ulActivationCookie;
};


#define MAX_TEMPLATE_NAME_LEN   256

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\viewoiddlg.cpp ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2002.
//
//  File:       ViewOIDDlg.cpp
//
//  Contents:   Implementation of CViewOIDDlg
//
//----------------------------------------------------------------------------
// ViewOIDDlg.cpp : implementation file
//

#include "stdafx.h"
#include "certtmpl.h"
#include "ViewOIDDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern POLICY_OID_LIST	    g_policyOIDList;
extern PCWSTR               pcszNEWLINE;

/////////////////////////////////////////////////////////////////////////////
// CViewOIDDlg dialog


CViewOIDDlg::CViewOIDDlg(CWnd* pParent /*=NULL*/)
	: CHelpDialog(CViewOIDDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CViewOIDDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CViewOIDDlg::DoDataExchange(CDataExchange* pDX)
{
	CHelpDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CViewOIDDlg)
	DDX_Control(pDX, IDC_OID_LIST, m_oidList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CViewOIDDlg, CHelpDialog)
	//{{AFX_MSG_MAP(CViewOIDDlg)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_OID_LIST, OnItemchangedOidList)
	ON_BN_CLICKED(IDC_COPY_OID, OnCopyOid)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_OID_LIST, OnColumnclickOidList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CViewOIDDlg message handlers

BOOL CViewOIDDlg::OnInitDialog() 
{
	CHelpDialog::OnInitDialog();
	

    GetDlgItem (IDC_COPY_OID)->EnableWindow (FALSE);

    // Set up list control
	int	colWidths[NUM_COLS] = {200, 150, 100, 100};

    // Set to full-row select
    DWORD   dwExstyle = m_oidList.GetExtendedStyle ();
	m_oidList.SetExtendedStyle (dwExstyle | LVS_EX_FULLROWSELECT);


	// Add "Policy Name" column
	CString	szText;
	VERIFY (szText.LoadString (IDS_POLICY_NAME));
	VERIFY (m_oidList.InsertColumn (COL_POLICY_NAME, (LPCWSTR) szText,
			LVCFMT_LEFT, colWidths[COL_POLICY_NAME], COL_POLICY_NAME) != -1);

	VERIFY (szText.LoadString (IDS_OID));
	VERIFY (m_oidList.InsertColumn (COL_OID, (LPCWSTR) szText,
			LVCFMT_LEFT, colWidths[COL_OID], COL_OID) != -1);
	
	VERIFY (szText.LoadString (IDS_POLICY_TYPE));
	VERIFY (m_oidList.InsertColumn (COL_POLICY_TYPE, (LPCWSTR) szText,
			LVCFMT_LEFT, colWidths[COL_POLICY_TYPE], COL_POLICY_TYPE) != -1);

	VERIFY (szText.LoadString (IDS_CPS_LOCATION));
	VERIFY (m_oidList.InsertColumn (COL_CPS_LOCATION, (LPCWSTR) szText,
			LVCFMT_LEFT, colWidths[COL_CPS_LOCATION], COL_CPS_LOCATION) != -1);
    m_oidList.SetColumnWidth (COL_CPS_LOCATION, LVSCW_AUTOSIZE_USEHEADER);

    // Fill list
    for (POSITION nextPos = g_policyOIDList.GetHeadPosition (); nextPos; )
    {
        CPolicyOID* pPolicyOID = g_policyOIDList.GetNext (nextPos);
        if ( pPolicyOID )
        {
            if ( FAILED (InsertItemInList (pPolicyOID)) )
                break;
        }
    }

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

HRESULT CViewOIDDlg::InsertItemInList (CPolicyOID* pPolicyOID)
{
    ASSERT (pPolicyOID);
    if ( !pPolicyOID )
        return E_POINTER;

    if ( !pPolicyOID->IsApplicationOID () && !pPolicyOID->IsIssuanceOID () )
        return S_OK;  // not a failure, but don't add

    HRESULT hr = S_OK;
	LV_ITEM	lvItem;
	int		iItem = m_oidList.GetItemCount ();
	int iResult = 0;

    // security review 2/20/2002 BryanWal ok
	::ZeroMemory (&lvItem, sizeof (lvItem));
	lvItem.mask = LVIF_TEXT | LVIF_PARAM;
	lvItem.iItem = iItem;
    lvItem.iSubItem = COL_POLICY_NAME;
	lvItem.pszText = (PWSTR)(PCWSTR) pPolicyOID->GetDisplayName ();
    lvItem.lParam = (LPARAM) pPolicyOID;
	iItem = m_oidList.InsertItem (&lvItem);
	ASSERT (-1 != iItem);
	if ( -1 == iItem )
		hr = E_FAIL;

    if ( SUCCEEDED (hr) )
    {
        // security review 2/20/2002 BryanWal ok
	    ::ZeroMemory (&lvItem, sizeof (lvItem));
        lvItem.mask = LVIF_TEXT;
        lvItem.iItem = iItem;
        lvItem.iSubItem = COL_OID;
        lvItem.pszText = (PWSTR)(PCWSTR) pPolicyOID->GetOIDW ();
	    iResult = m_oidList.SetItem (&lvItem);
        ASSERT (-1 != iResult);
	    if ( -1 == iResult )
		    hr = E_FAIL;
    }

    if ( SUCCEEDED (hr) )
    {
        lvItem.iSubItem = COL_POLICY_TYPE;
        CString text;
        if ( pPolicyOID->IsApplicationOID () )
            VERIFY (text.LoadString (IDS_APPLICATION));
        else // Is issuance OID
            VERIFY (text.LoadString (IDS_ISSUANCE));
        lvItem.pszText = (PWSTR)(PCWSTR) text;
	    iResult = m_oidList.SetItem (&lvItem);
        ASSERT (-1 != iResult);
	    if ( -1 == iResult )
		    hr = E_FAIL;
    }


    if ( SUCCEEDED (hr) && pPolicyOID->IsIssuanceOID () )
    {
        lvItem.iSubItem = COL_CPS_LOCATION;
    
        PWSTR   pszCPS = 0;
        hr = CAOIDGetProperty(
                    pPolicyOID->GetOIDW (),
                    CERT_OID_PROPERTY_CPS,
                    &pszCPS);
        if ( SUCCEEDED (hr) )
        {
            lvItem.pszText = pszCPS;
	        iResult = m_oidList.SetItem (&lvItem);
            ASSERT (-1 != iResult);
	        if ( -1 == iResult )
		        hr = E_FAIL;

            CAOIDFreeProperty (pszCPS);
        }
        else if ( HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND) == hr ||
                HRESULT_FROM_WIN32 (ERROR_DS_OBJ_NOT_FOUND) == hr )
        {
            hr = S_OK;
        }
        else
        {
            _TRACE (0, L"CAOIDGetProperty (%s, CERT_OID_PROPERTY_CPS) failed: 0x%x\n", 
                    (PCWSTR) pPolicyOID->GetOIDW (), hr);
            hr = S_OK;
        }
    }

    return hr;
}

void CViewOIDDlg::OnItemchangedOidList(NMHDR* /*pNMHDR*/, LRESULT* pResult) 
{
//	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    GetDlgItem (IDC_COPY_OID)->EnableWindow (m_oidList.GetSelectedCount () > 0);
	
	*pResult = 0;
}

void CViewOIDDlg::OnCopyOid() 
{
    CString szText;
    int nCnt = m_oidList.GetItemCount ();
    if ( nCnt > 0 && m_oidList.GetSelectedCount () > 0 )
    {
        for (int nItem = 0; nItem < nCnt; nItem++)
        {
            if ( LVIS_SELECTED == m_oidList.GetItemState (nItem, LVIS_SELECTED) )
            {
                if ( !szText.IsEmpty () )
                    szText += pcszNEWLINE;
                szText += m_oidList.GetItemText (nItem, COL_OID);
            }
        }
    }

    if ( !szText.IsEmpty () )
    {
        if ( OpenClipboard () ) 
        {
            if ( EmptyClipboard () )
            {
                // security review 2/20/2002 BryanWal ok
                size_t  nLen = wcslen (szText);
                HGLOBAL hglbCopy = GlobalAlloc (GMEM_MOVEABLE, 
                        (nLen + 1) * sizeof (WCHAR)); 
                if ( hglbCopy )
                {

                    PWSTR pszCopy = (PWSTR) GlobalLock (hglbCopy); 
                    if ( pszCopy )
                    {
                        // security review 2/20/2002 BryanWal ok
                        wcscpy (pszCopy, szText); 
                        GlobalUnlock(hglbCopy); 
 
                        // Place the handle on the clipboard. 
 
                        if ( !SetClipboardData (CF_UNICODETEXT, hglbCopy) )
                        {
                            ASSERT (0);
                            _TRACE (0, L"SetClipboardData () failed: %d\n", GetLastError ());
                            GlobalFree (hglbCopy);
                        }
                    }
                    else
                        GlobalFree (hglbCopy);
                }

                if ( !CloseClipboard () ) 
                {
                    ASSERT (0);
                    _TRACE (0, L"CloseClipboard () failed: %d\n", GetLastError ());
                }
            }
            else
            {
                ASSERT (0);
                _TRACE (0, L"EmptyClipboard () failed: %d\n", GetLastError ());
            }
        }
        else
        {
            ASSERT (0);
            _TRACE (0, L"OpenClipboard () failed: %d\n", GetLastError ());
        }
    }
}

int CALLBACK CViewOIDDlg::fnCompareOIDItems (LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    int iVal = 0;

    if ( lParam1 && lParam2 )
    {
        CPolicyOID* pPolicyOID1 = (CPolicyOID*) lParam1;
        CPolicyOID* pPolicyOID2 = (CPolicyOID*) lParam2;
        switch (lParamSort)
        {
        case COL_POLICY_NAME:
            iVal = LocaleStrCmp (pPolicyOID1->GetDisplayName (), 
                    pPolicyOID2->GetDisplayName ());
            break;

        case COL_OID:
            iVal = LocaleStrCmp (pPolicyOID1->GetOIDW (), 
                    pPolicyOID2->GetOIDW ());
            break;

        case COL_POLICY_TYPE:
            {
                CString szApplication;
                CString szIssuance;

                VERIFY (szApplication.LoadString (IDS_APPLICATION));
                VERIFY (szIssuance.LoadString (IDS_ISSUANCE));
                iVal = LocaleStrCmp (pPolicyOID1->IsApplicationOID () ? szApplication : szIssuance, 
                        pPolicyOID2->IsApplicationOID () ? szApplication : szIssuance);
            }
            break;

        case COL_CPS_LOCATION:
            {
                CString strItem1;
                CString strItem2;

                if ( pPolicyOID1->IsIssuanceOID () )
                {
                    PWSTR   pszCPS = 0;
                    if ( SUCCEEDED (CAOIDGetProperty(
                                pPolicyOID1->GetOIDW (),
                                CERT_OID_PROPERTY_CPS,
                                &pszCPS)) )
                    {
                        strItem1 = pszCPS;
                    }
                }

                if ( pPolicyOID2->IsIssuanceOID () )
                {
                    PWSTR   pszCPS = 0;
                    if ( SUCCEEDED (CAOIDGetProperty(
                                pPolicyOID2->GetOIDW (),
                                CERT_OID_PROPERTY_CPS,
                                &pszCPS)) )
                    {
                        strItem2 = pszCPS;
                    }
                }

                iVal = LocaleStrCmp (strItem1, strItem2);
            }
            break;

        default:
            ASSERT (0);
            break;
        }
    }

    return iVal;
}


void CViewOIDDlg::OnColumnclickOidList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
    if ( pNMListView )
    {
        m_oidList.SortItems ((PFNLVCOMPARE) fnCompareOIDItems, 
                (LPARAM) pNMListView->iSubItem);
        
    }
	
	*pResult = 0;
}

void CViewOIDDlg::DoContextHelp (HWND hWndControl)
{
	_TRACE(1, L"Entering CViewOIDDlg::DoContextHelp\n");
    
	switch (::GetDlgCtrlID (hWndControl))
	{
	case IDC_STATIC:
		break;

	default:
		// Display context help for a control
		if ( !::WinHelp (
				hWndControl,
				GetContextHelpFile (),
				HELP_WM_HELP,
				(DWORD_PTR) g_aHelpIDs_IDD_VIEW_OIDS) )
		{
			_TRACE (0, L"WinHelp () failed: 0x%x\n", GetLastError ());        
		}
		break;
	}
    _TRACE(-1, L"Leaving CViewOIDDlg::DoContextHelp\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certentp\tinstall.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2002
//
//  File:       tinstall.cpp
//
//--------------------------------------------------------------------------
#include "stdafx.h"
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <stdio.h>
#include <certca.h>
#include <winldap.h>
#include <ntldap.h>
#include <dsrole.h>
#include <dsgetdc.h>
#include <accctrl.h>

#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmerr.h>

//--------------------------------------------------------------------------
//
//       Defines
//
//--------------------------------------------------------------------------
#define DS_RETEST_SECONDS                   3
#define CVT_BASE                            (1000 * 1000 * 10)
#define CVT_SECONDS                         (1)
#define CERTTYPE_SECURITY_DESCRIPTOR_NAME   L"NTSecurityDescriptor"
#define TEMPLATE_CONTAINER_NAME             L"CN=Certificate Templates,CN=Public Key Services,CN=Services,"
#define SCHEMA_CONTAINER_NAME               L"CN=Schema,"


typedef WCHAR *CERTSTR; 
bool g_bSchemaIsW2K = false;

//--------------------------------------------------------------------------
//
//
//     Helper Functions
//
//--------------------------------------------------------------------------
HANDLE GetClientIdentity()
{
    HANDLE  hHandle       = NULL;
    HANDLE  hClientToken  = NULL; 
    HANDLE  hProcessToken = NULL; 

    // Step 1: attempt to acquire the thread token.  
    hHandle = GetCurrentThread();
    if ( hHandle )
    {
        if ( OpenThreadToken(hHandle,
                 TOKEN_QUERY,
                 TRUE,           // open as self
                 &hClientToken))
        goto Exit;
    }
  
    if (hHandle != NULL)
    {
        CloseHandle(hHandle); 
        hHandle=NULL;
    }
    
    // We failed to get the thread token, now try to acquire the process token:
    hHandle = GetCurrentProcess();
    if (NULL == hHandle)
        goto Exit; 
    
    if (!OpenProcessToken(hHandle,
              TOKEN_DUPLICATE,
              &hProcessToken))
        goto Exit; 
    
    // security review 2/20/2002 BryanWal ok
    if(!DuplicateToken(hProcessToken,
               SecurityImpersonation,
               &hClientToken))
        goto Exit;
    
Exit:
    if (NULL != hHandle)       
        CloseHandle(hHandle); 

    if (NULL != hProcessToken) 
        CloseHandle(hProcessToken); 
    
    return hClientToken; 
}    



HRESULT myHError(HRESULT hr)
{

    if (S_OK != hr && S_FALSE != hr && !FAILED(hr))
    {
        hr = HRESULT_FROM_WIN32(hr);
        if ( SUCCEEDED (hr) )
        {
            // A call failed without properly setting an error condition!
            hr = E_UNEXPECTED;
        }
    }
    return(hr);
}


HRESULT 
myDupString (
    IN WCHAR const *pwszIn, 
    IN WCHAR **ppwszOut)
{
    ASSERT (pwszIn && ppwszOut);
    if ( !pwszIn || !ppwszOut )
        return E_POINTER;

    HRESULT hr = S_OK;

    // security review 2/20/2002 BryanWal ok
    size_t cb = (wcslen(pwszIn) + 1) * sizeof(WCHAR);
    *ppwszOut = (WCHAR *) LocalAlloc (LPTR, cb);
    if (NULL == *ppwszOut)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    // security review 2/20/2002 BryanWal ok
    CopyMemory (*ppwszOut, pwszIn, cb);
    hr = S_OK;

error:
    return(hr);
}


DWORD
CAGetAuthoritativeDomainDn(
    IN  LDAP*   LdapHandle,
    OUT CString* pszDomainDn,
    OUT CString* pszConfigDn
    )
/*++

Routine Description:

    This routine simply queries the operational attributes for the
    domaindn and configdn.

    The strings returned by this routine must be freed by the caller
    using RtlFreeHeap() using the process heap.

Parameters:

    LdapHandle    : a valid handle to an ldap session

    pszDomainDn      : a pointer to a string to be allocated in this routine

    pszConfigDn      : a pointer to a string to be allocated in this routine

Return Values:

    An error from the win32 error space.

    ERROR_SUCCESS and

    Other operation errors.

--*/
{

    DWORD  WinError = ERROR_SUCCESS;
    ULONG  LdapError;

    LDAPMessage  *SearchResult = NULL;
    LDAPMessage  *Entry = NULL;
    WCHAR        *Attr = NULL;
    BerElement   *BerElement;
    WCHAR        **Values = NULL;

    WCHAR  *AttrArray[3];

    WCHAR  *DefaultNamingContext       = L"defaultNamingContext";
    WCHAR  *ConfigNamingContext       = L"configurationNamingContext";
    WCHAR  *ObjectClassFilter          = L"objectClass=*";

    //
    // These must be present
    //

    //
    // Set the out parameters to null
    //

    if ( pszDomainDn )
        *pszDomainDn = L"";
    if ( pszConfigDn )
        *pszConfigDn = L"";

    //
    // Query for the ldap server operational attributes to obtain the default
    // naming context.
    //
    AttrArray[0] = DefaultNamingContext;
    AttrArray[1] = ConfigNamingContext;  // this is the sentinel
    AttrArray[2] = NULL;  // this is the sentinel

    __try
    {
        LdapError = ldap_search_sW(LdapHandle,
                       NULL,
                       LDAP_SCOPE_BASE,
                       ObjectClassFilter,
                       AttrArray,
                       FALSE,
                       &SearchResult);

        WinError = LdapMapErrorToWin32(LdapError);

        if (ERROR_SUCCESS == WinError) {

            Entry = ldap_first_entry(LdapHandle, SearchResult);

            if (Entry)
            {

                Attr = ldap_first_attributeW(LdapHandle, Entry, &BerElement);

                while (Attr)
                {

                    if (!_wcsicmp(Attr, DefaultNamingContext))
                    {
                        if ( pszDomainDn )
                        {
                            Values = ldap_get_values(LdapHandle, Entry, Attr);

                            if (Values && Values[0])
                            {
                                *pszDomainDn = Values[0];
                            }
                            ldap_value_free(Values);
                        }

                    }
                    else if (!_wcsicmp(Attr, ConfigNamingContext))
                    {
                        if ( pszConfigDn )
                        {
                            Values = ldap_get_values(LdapHandle, Entry, Attr);

                            if (Values && Values[0])
                            {
                                *pszConfigDn = Values[0];
                            }
                            ldap_value_free(Values);
                        }
                    }

                    Attr = ldap_next_attribute(LdapHandle, Entry, BerElement);
                }
            }

            if ( pszDomainDn && pszDomainDn->IsEmpty () )
            {
                //
                // We could get the default domain - bail out
                //
                WinError =  ERROR_CANT_ACCESS_DOMAIN_INFO;

            }
            else if ( pszConfigDn && pszConfigDn->IsEmpty () )
            {
                //
                // We could get the default domain - bail out
                //
                WinError =  ERROR_CANT_ACCESS_DOMAIN_INFO;

            }

        }
    }
    __except(WinError = GetExceptionCode(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

    // make sure we free this
    if (SearchResult)
        ldap_msgfree( SearchResult );

    return WinError;
}



HRESULT myDoesDSExist (IN BOOL fRetry)
{
    HRESULT hr = S_OK;

    static BOOL s_fKnowDSExists = FALSE;
    static HRESULT s_hrDSExists = HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN);
    static FILETIME s_ftNextTest = {0,0};
    
    if (s_fKnowDSExists && (s_hrDSExists != S_OK) && fRetry)
    //    s_fKnowDSExists = FALSE;  // force a retry
    {
        FILETIME ftCurrent;
        GetSystemTimeAsFileTime(&ftCurrent);

        // if Compare is < 0 (next < current), force retest
        if (0 > CompareFileTime(&s_ftNextTest, &ftCurrent))
            s_fKnowDSExists = FALSE;    
    }

    if (!s_fKnowDSExists)
    {
        GetSystemTimeAsFileTime(&s_ftNextTest);

        // set NEXT in 100ns increments

        ((LARGE_INTEGER *) &s_ftNextTest)->QuadPart +=
        (__int64) (CVT_BASE * CVT_SECONDS * 60) * DS_RETEST_SECONDS;

        // NetApi32 is delay loaded, so wrap to catch problems when it's not available
        __try
        {
            DOMAIN_CONTROLLER_INFO *pDCI;
            DSROLE_PRIMARY_DOMAIN_INFO_BASIC *pDsRole;
        
            // ensure we're not standalone
            pDsRole = NULL;
            hr = DsRoleGetPrimaryDomainInformation( // Delayload wrapped
                    NULL,
                    DsRolePrimaryDomainInfoBasic,
                    (BYTE **) &pDsRole);

            if (S_OK == hr &&
                (pDsRole->MachineRole == DsRole_RoleStandaloneServer ||
                 pDsRole->MachineRole == DsRole_RoleStandaloneWorkstation))
            {
                hr = HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN);
            }

            if (NULL != pDsRole) 
            {
                DsRoleFreeMemory(pDsRole);     // Delayload wrapped
            }
            if (S_OK == hr)
            {
                // not standalone; return info on our DS

                pDCI = NULL;
                hr = DsGetDcName(    // Delayload wrapped
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        DS_DIRECTORY_SERVICE_PREFERRED,
                        &pDCI);
           
                if (S_OK == hr && 0 == (pDCI->Flags & DS_DS_FLAG))
                {
                    hr = HRESULT_FROM_WIN32(ERROR_CANT_ACCESS_DOMAIN_INFO);
                }
                if (NULL != pDCI)
                {
                   NetApiBufferFree(pDCI);    // Delayload wrapped
                }
            }
            s_fKnowDSExists = TRUE;
        }
        __except(hr = GetExceptionCode(), EXCEPTION_EXECUTE_HANDLER)
        {
        }

        // else just allow users without netapi flounder with timeouts
        // if ds not available...

        s_hrDSExists = myHError(hr);
    }
    return(s_hrDSExists);
}


//--------------------------------------------------------------------------
//
//  AERobustLdapBind
//
//--------------------------------------------------------------------------
HRESULT 
AERobustLdapBind(
    OUT LDAP ** ppldap)
{
    HRESULT             hr = S_OK;
    BOOL                fForceRediscovery = FALSE;
    DWORD               dwDSNameFlags= DS_RETURN_DNS_NAME | DS_BACKGROUND_ONLY;
    LDAP                *pld = NULL;
    ULONG               ldaperr=LDAP_SERVER_DOWN;

    do {

        if(fForceRediscovery)
        {
           dwDSNameFlags |= DS_FORCE_REDISCOVERY;
        }

        ldaperr = LDAP_SERVER_DOWN;

        if(NULL != pld)
        {
            ldap_unbind(pld);
            pld=NULL;
        }

        // bind to ds
        if((pld = ldap_initW(NULL, LDAP_PORT)) == NULL)
        {
            ldaperr = LdapGetLastError();
        }
        else
        {                         
            ldaperr = ldap_set_option(pld, LDAP_OPT_GETDSNAME_FLAGS, (VOID *)&dwDSNameFlags);

            if(LDAP_SUCCESS == ldaperr)
            {
                ldaperr = ldap_set_option(pld, LDAP_OPT_SIGN, LDAP_OPT_ON);

                if (LDAP_SUCCESS == ldaperr)
                {
                    ldaperr = ldap_bind_sW(pld, NULL, NULL, LDAP_AUTH_NEGOTIATE);
                }
            }
        }

        hr = HRESULT_FROM_WIN32(LdapMapErrorToWin32(ldaperr));

        if(fForceRediscovery)
        {
            break;
        }

        fForceRediscovery = TRUE;

    } while(ldaperr == LDAP_SERVER_DOWN);


    if(S_OK != hr)
        goto error;

    *ppldap = pld;
    pld = NULL;

    hr=S_OK;

error:

    if(pld)
    {
        ldap_unbind(pld);
    }

    return hr;
}



//--------------------------------------------------------------------
static HRESULT GetRootDomEntitySid(SID ** ppSid, DWORD dwEntityRid)
{
    HRESULT hr = S_OK;
    NET_API_STATUS nasError = 0;
    unsigned int nSubAuthorities = 0;
    unsigned int nSubAuthIndex = 0;

    // must be cleaned up
    SID * psidRootDomEntity=NULL;
    USER_MODALS_INFO_2 * pumi2=NULL;
    DOMAIN_CONTROLLER_INFOW * pdci=NULL;
    DOMAIN_CONTROLLER_INFOW * pdciForest=NULL;

    // initialize out params
    *ppSid=NULL;


    // get the forest name
    nasError=DsGetDcNameW(NULL, NULL, NULL, NULL, 0, &pdciForest);
    if (NERR_Success!=nasError) {
        hr=HRESULT_FROM_WIN32(nasError);
        goto error;
    }

    // get the top level DC name
    nasError=DsGetDcNameW(NULL, pdciForest->DnsForestName, NULL, NULL, 0, &pdci);
    if (NERR_Success!=nasError) {
        hr=HRESULT_FROM_WIN32(nasError);
        goto error;
    }

    // get the domain Sid on the top level DC.
    nasError = NetUserModalsGet (pdci->DomainControllerName, 2, (LPBYTE *)&pumi2);
    if ( NERR_Success!=nasError || !pumi2 ) 
    {
        hr=HRESULT_FROM_WIN32(nasError);
        goto error;
    }

    nSubAuthorities = *GetSidSubAuthorityCount (pumi2->usrmod2_domain_id);

    // allocate storage for new Sid. account domain Sid + account Rid
    psidRootDomEntity=(SID *)LocalAlloc(LPTR, GetSidLengthRequired((UCHAR)(nSubAuthorities+1)));

    if(NULL == psidRootDomEntity)
    {
        hr=E_OUTOFMEMORY;
        goto error;
    }

    // copy the first few pieces into the SID
    // security review 2/20/2002 BryanWal ok
    if (!InitializeSid(psidRootDomEntity, 
            GetSidIdentifierAuthority(pumi2->usrmod2_domain_id), 
            (BYTE)(nSubAuthorities+1)))
    {
        hr=HRESULT_FROM_WIN32(GetLastError());
        goto error;
    }

    // copy existing subauthorities from account domain Sid into new Sid
    for (nSubAuthIndex=0; nSubAuthIndex < nSubAuthorities ; nSubAuthIndex++) {
        *GetSidSubAuthority(psidRootDomEntity, nSubAuthIndex)=
            *GetSidSubAuthority(pumi2->usrmod2_domain_id, nSubAuthIndex);
    }

    // append Rid to new Sid
    *GetSidSubAuthority(psidRootDomEntity, nSubAuthorities)=dwEntityRid;

    *ppSid=psidRootDomEntity;
    psidRootDomEntity=NULL;
    hr=S_OK;

error:
    if (NULL!=psidRootDomEntity) {
        FreeSid(psidRootDomEntity);
    }
    if (NULL!=pdci) {
        NetApiBufferFree(pdci);
    }
    if (NULL!=pdci) {
        NetApiBufferFree(pdciForest);
    }
    if (NULL!=pumi2) {
        NetApiBufferFree(pumi2);
    }

    return hr;
}


//--------------------------------------------------------------------
HRESULT GetRootDomAdminSid(SID ** ppSid)
{
    return GetRootDomEntitySid(ppSid, DOMAIN_GROUP_RID_ADMINS);
}

HRESULT GetEnterpriseAdminSid(SID ** ppSid)
{
    return GetRootDomEntitySid(ppSid, DOMAIN_GROUP_RID_ENTERPRISE_ADMINS);
}


//***********************************************************************************
//
//
//    Main
//
//          This function will install new Windows 2002 certificate template if and onlyif
//    the following conditions are TRUE:
//
//          1. Whistler Schema
//          2. New certificate templates have not yet installed
//          3. The caller has privilege to install templates in the directory
//
//
//***********************************************************************************
void InstallWindows2002CertTemplates ()
{
    _TRACE (1, L"Entering InstallWindows2002CertTemplates()\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());

    OSVERSIONINFOEX osVersionInfo;
    ::ZeroMemory (&osVersionInfo, sizeof (osVersionInfo));
    osVersionInfo.dwOSVersionInfoSize = sizeof (osVersionInfo);
    if ( !::GetVersionEx (reinterpret_cast<OSVERSIONINFO*>(&osVersionInfo)) )
    {
        DWORD   dwErr = GetLastError ();
        _TRACE (0, L"GetVersionEx () failed: 0x%x. Template install attempt will not be made.", dwErr);
        _TRACE (-1, L"Leaving InstallWindows2002CertTemplates()\n");
        return;
    }

    if ( VER_NT_WORKSTATION == osVersionInfo.wProductType &&    // Windows XP Home Edition or Windows XP Professional
            5 == osVersionInfo.dwMajorVersion &&                // Windows XP
            1 == osVersionInfo.dwMinorVersion )                 // Windows XP
    {
        // is Windows XP client
        // NTRAIDE# 530524 CERTTMPL: ADMINPAK: adminpak installed on XP 2600 
        // Pro, will prompt to upgrade templates every time it is opened
        _TRACE (0, L"Computer is running Windows XP workstation version. Template install attempt will not be made.\n");
        _TRACE (-1, L"Leaving InstallWindows2002CertTemplates()\n");
        return;
    }


    HRESULT             hr=S_OK;
    DWORD               dwErr=0;
    ULONG               ldaperr=0;
    struct l_timeval    timeout;
    DWORD               dwCount=0;
    LPWSTR              awszAttr[2] = {0, 0};
    BOOL                fAccessAllowed = FALSE;
    DWORD               grantAccess=0;
    GENERIC_MAPPING     AccessMapping;
    PRIVILEGE_SET       ps;
    DWORD               dwPSSize = sizeof(ps);
    LDAPMessage         *Entry = NULL;
    char                sdBerValue[] = {0x30, 0x03, 0x02, 0x01, DACL_SECURITY_INFORMATION |
                                                 OWNER_SECURITY_INFORMATION |
                                                 GROUP_SECURITY_INFORMATION };
       
    LDAPControl         se_info_control =
                        {
                            LDAP_SERVER_SD_FLAGS_OID_W,
                            {
                                5, sdBerValue
                            },
                            TRUE
                        };

    LDAPControl         permissive_modify_control =
                        {
                            LDAP_SERVER_PERMISSIVE_MODIFY_OID_W,
                            {
                                0, NULL
                            },
                            FALSE
                        };


    PLDAPControl        server_controls[3] =
                        {
                            &se_info_control,
                            &permissive_modify_control,
                            NULL
                        };



    HCERTTYPE           hCertType=NULL;      
    LDAP                *pld = NULL;
    CString             szConfig;
    CString             szDN;
    LDAPMessage         *SearchResult = NULL;
    LDAPMessage         *SDResult = NULL;
    struct berval       **apSD =NULL;
    PSECURITY_DESCRIPTOR    pSD=NULL;
    HANDLE              hClientToken=NULL;
    CString             text;
    CString             caption;
    SID                 * psidRootDomAdmins=NULL;
    BOOL                bIsRootDomAdmin=FALSE;
    SID                 * psidEnterpriseAdmins=NULL;
    BOOL                bIsEnterpriseAdmin=FALSE;
    CThemeContextActivator activator;



    //*************************************************************
    // 
    // check the schema version
    //
    _TRACE (0, L"Checking the schema version...\n");
    //retrieve the ldap handle and the config string
    if(S_OK != myDoesDSExist(TRUE))
    {
        _TRACE (0, L"No DS exists.\n");
        goto error;
    }

    if ( S_OK != (hr = AERobustLdapBind (&pld)))
    {
        _TRACE (0, L"Error: Failed to bind to the DS.\n");
        goto error;
    }

    dwErr = CAGetAuthoritativeDomainDn(pld, NULL, &szConfig);
    if(ERROR_SUCCESS != dwErr)
    {
        _TRACE (0, L"Error: Failed to get the domain name.\n");
        hr = HRESULT_FROM_WIN32(dwErr);
        goto error;
    }

    szDN = SCHEMA_CONTAINER_NAME;
    szDN += szConfig;

    timeout.tv_sec = 300;
    timeout.tv_usec = 0;

    awszAttr[0]=L"cn";
    awszAttr[1]=NULL;
    
    ldaperr = ldap_search_stW(
              pld, 
              const_cast <PWCHAR>((PCWSTR) szDN),
              LDAP_SCOPE_ONELEVEL,
              L"(cn=ms-PKI-Enrollment-Flag)",
              awszAttr,
              0,
              &timeout,
              &SearchResult);

    if ( LDAP_SUCCESS != ldaperr )
    {
        _TRACE (0, L"We have W2K Schema.  Exit\n");
        g_bSchemaIsW2K = true;
        hr = S_OK;
        goto error;
    }

    dwCount = ldap_count_entries(pld, SearchResult);

    if(0 == dwCount)
    {
        _TRACE (0, L"We have W2K Schema.  Exit\n");
        hr=S_OK;
        goto error;
    }


    //*************************************************************
    // 
    //  check if keyRecoveryAgent certificate is present and
    //  and update to date
    //

    //check if all the templates are update to date
    // NTRAID# 501806 Certtmpl.msc: Need to detect enterprise admin rights 
    // and verify each template for upgrade
    if ( CAIsCertTypeCurrent (0,NULL) )
    {
        _TRACE (0, L"All certificate templates are current.  Exit\n");  
        goto error;
    }
    

    //*************************************************************
    // 
    //  check the write access
    //
    //
    _TRACE (0, L"Checking the write access...\n");
    if(NULL==(hClientToken=GetClientIdentity()))
    {
        TRACE (0, L"Can not retrieve client identity.\n");
        hr = myHError(GetLastError());
        goto error;
    }

    //get the SD of the certificate template container
    _TRACE (0, L"Getting the SD of the certificate template container...\n");
    szDN = TEMPLATE_CONTAINER_NAME;
    szDN += szConfig;



    awszAttr[0]=CERTTYPE_SECURITY_DESCRIPTOR_NAME;
    awszAttr[1]=NULL;

    ldaperr = ldap_search_ext_sW(
                  pld, 
                  const_cast <PWCHAR>((PCWSTR) szDN),
                  LDAP_SCOPE_BASE,
                  L"(objectclass=*)",
                  awszAttr,
                  0,
                  (PLDAPControl *)server_controls,
                  NULL,
                  &timeout,
                  10,
                  &SDResult);

    if(LDAP_SUCCESS != ldaperr)
    {
        _TRACE (0, L"Fail to locate the template container.\n");
        hr = myHError(LdapMapErrorToWin32(ldaperr));
        goto error;
    }

    if(NULL == (Entry = ldap_first_entry(pld, SDResult)))
    {
        _TRACE (0, L"Can not find first entry for template container.\n");
        hr = E_UNEXPECTED;
        goto error;
    }

    apSD = ldap_get_values_len(pld, Entry, CERTTYPE_SECURITY_DESCRIPTOR_NAME);
    if(apSD == NULL)
    {
        _TRACE (0, L"Can not retrieve security descriptor.\n");
        hr = E_FAIL;
        goto error;
   }

    pSD = LocalAlloc(LPTR, (*apSD)->bv_len);
    if(pSD == NULL)
    {
        _TRACE (0, L"Error: No more memory.\n");
        hr = E_OUTOFMEMORY;
        goto error;
    }

    // security review 2/20/2002 BryanWal ok
    CopyMemory(pSD, (*apSD)->bv_val, (*apSD)->bv_len);

    //check the write access
    _TRACE (0, L"Checking the write access...\n");
    if(!AccessCheckByType(
          pSD,                      // security descriptor
          NULL,                     // SID of object being checked
          hClientToken,             // handle to client access token
          ACTRL_DS_CREATE_CHILD |
          ACTRL_DS_LIST,            // requested access rights 
          NULL,                     // array of object types
          0,                        // number of object type elements
          &AccessMapping,           // map generic to specific rights
          &ps,                      // receives privileges used
          &dwPSSize,                // size of privilege-set buffer
          &grantAccess,             // retrieves mask of granted rights
          &fAccessAllowed))         // retrieves results of access check);
    {
        _TRACE (0, L"Error: Fail to check the write access.\n");
        hr = myHError(GetLastError());
        goto error;
    }

    if(!fAccessAllowed)
    {
        _TRACE (0, L"No previlege to create certificate template.  Exit\n");
        hr = S_OK;
        goto error;
    }

    //*************************************************************
    // 
    //  check the root domain admin rights
    //
    //
    hr=GetRootDomAdminSid(&psidRootDomAdmins);

    if( FAILED (hr) )
    {
        _TRACE (0, L"Error: GetRootDomAdminSid.\n");
        goto error;
    }


    // check for membership
    if (!CheckTokenMembership(NULL, psidRootDomAdmins, &bIsRootDomAdmin)) 
    {
        hr=HRESULT_FROM_WIN32(GetLastError());
        _TRACE (0, L"Error: CheckTokenMembership.\n");
        goto error;
    }


    //*************************************************************
    // 
    //  check the enterprise admin rights
    //
    //
    hr=GetEnterpriseAdminSid(&psidEnterpriseAdmins);

    if( FAILED (hr) )
    {
        _TRACE (0, L"Error: GetEnterpriseAdminSid.\n");
        goto error;
    }


    // check for membership
    if (!CheckTokenMembership(NULL, psidEnterpriseAdmins, &bIsEnterpriseAdmin)) 
    {
        hr=HRESULT_FROM_WIN32(GetLastError());
        _TRACE (0, L"Error: CheckTokenMembership.\n");
        goto error;
    }

    if ( !bIsEnterpriseAdmin || !bIsRootDomAdmin )
    {
        CString missingRights;

        VERIFY (caption.LoadString (IDS_CERTTMPL));

        if ( !bIsEnterpriseAdmin && !bIsRootDomAdmin )
            VERIFY (missingRights.LoadString (IDS_NO_ENTERPRISE_OR_DOMAIN_ADMIN_RIGHTS));
        else if ( !bIsEnterpriseAdmin )
            VERIFY (missingRights.LoadString (IDS_NO_ENTERPRISE_ADMIN_RIGHTS));
        else /* !bIsRootDomAdmin */
            VERIFY (missingRights.LoadString (IDS_NO_DOMAIN_ADMIN_RIGHTS));

        // security review 2/20/2002 BryanWal ok
        text.FormatMessage (IDS_MUST_HAVE_DOMAIN_AND_ENTERPRISE_ADMIN_RIGHTS_TO_INSTALL_CERT_TEMPLATES,
                (PCWSTR) missingRights);
        MessageBoxW (NULL, 
                    text,
                    caption,
                    MB_ICONWARNING | MB_OK);

        _TRACE (0, L"No domain admin and/or enterprise admin rights to create certificate template.  Exit\n");
        hr = S_OK;
        goto error;
    }

    //*************************************************************
    // 
    //  everything looks good.  Install the certificate templates
    //
    //
    _TRACE (0, L"Everything looks good.  Installing the certificate templates...\n");

    VERIFY (caption.LoadString (IDS_CERTTMPL));
    VERIFY (text.LoadString (IDS_INSTALL_WINDOWS2002_CERT_TEMPLATES));

    if ( IDYES == MessageBoxW (
                NULL, 
                text,
                caption,
                MB_YESNO) )
    {
        hr = CAInstallDefaultCertType(0);
        _TRACE (0, L"CAInstallDefaultCertType () returned: 0x%x\n", hr);

        if(hr != S_OK)
        {
            VERIFY (caption.LoadString (IDS_CERTTMPL));
            // security review 2/20/2002 BryanWal ok
            text.FormatMessage (IDS_INSTALL_FAILURE_WINDOWS2002_CERT_TEMPLATES, GetSystemMessage (hr));

            MessageBoxW(
                    NULL, 
                    text,
                    caption,
                    MB_ICONWARNING | MB_OK);
        }
        else
        {
            VERIFY (caption.LoadString (IDS_CERTTMPL));
            VERIFY (text.LoadString (IDS_INSTALL_SUCCESS_WINDOWS2002_CERT_TEMPLATES));

            MessageBoxW(
                    NULL, 
                    text,
                    caption,
                    MB_OK);
        }
    }
    else
    {
        _TRACE (0, L"User chose not to install templates\n");
        hr=S_OK;
    }

error:

    if (psidEnterpriseAdmins) 
        FreeSid(psidEnterpriseAdmins);

    if (psidRootDomAdmins) 
        FreeSid(psidRootDomAdmins);

    if(hClientToken)
        CloseHandle(hClientToken);

    if(pSD)
        LocalFree(pSD);

    if(apSD != NULL)
        ldap_value_free_len(apSD);

    if(SDResult)
        ldap_msgfree(SDResult);

    if(SearchResult)
        ldap_msgfree(SearchResult);


    if(hCertType)
        CACloseCertType(hCertType);


    if (pld)
        ldap_unbind(pld);
    _TRACE (-1, L"Leaving InstallWindows2002CertTemplates()\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\about.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       about.h
//
//  Contents:
//
//----------------------------------------------------------------------------
//	About.h

#ifndef __ABOUT_H_INCLUDED__
#define __ABOUT_H_INCLUDED__


//	About for "Certificate Manager" snapin
class CCertMgrAbout :
	public CSnapinAbout,
	public CComCoClass<CCertMgrAbout, &CLSID_CertificateManagerAbout>

{
public:
DECLARE_REGISTRY(CCertMgrAbout, _T("CERTMGR.CertMgrAboutObject.1"), 
        _T("CERTMGR.CertMgrAboutObject.1"), IDS_CERTMGR_DESC, THREADFLAGS_BOTH)
	CCertMgrAbout();
};


//	About for "Public Key Policies" snapin
class CPublicKeyPoliciesAbout :
	public CSnapinAbout,
	public CComCoClass<CPublicKeyPoliciesAbout, &CLSID_PublicKeyPoliciesAbout>

{
public:
DECLARE_REGISTRY(CPublicKeyPoliciesAbout, _T("CERTMGR.PubKeyPolAboutObject.1"), 
        _T("CERTMGR.PubKeyPolAboutObject.1"), IDS_CERTMGR_DESC, THREADFLAGS_BOTH)
	CPublicKeyPoliciesAbout();
};

//	About for "Software Restriction Policies" snapin
class CSaferWindowsAbout :
	public CSnapinAbout,
	public CComCoClass<CSaferWindowsAbout, &CLSID_SaferWindowsAbout>

{
public:
DECLARE_REGISTRY(CSaferWindowsAbout, _T("CERTMGR.SaferWindowsAboutObject.1"), 
        _T("CERTMGR.SaferWindowsAboutObject.1"), IDS_CERTMGR_SAFER_WINDOWS_DESC, THREADFLAGS_BOTH)
	CSaferWindowsAbout();
};

#endif // ~__ABOUT_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\acrgenpg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       ACRGenPg.cpp
//
//  Contents:
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "ACRGenPg.h"

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CACRGeneralPage property page

CACRGeneralPage::CACRGeneralPage(CAutoCertRequest& rACR) : 
	CHelpPropertyPage(CACRGeneralPage::IDD),
	m_rACR (rACR)
{
	m_rACR.AddRef ();
	//{{AFX_DATA_INIT(CACRGeneralPage)
	//}}AFX_DATA_INIT
}

CACRGeneralPage::~CACRGeneralPage()
{
	m_rACR.Release ();
}

void CACRGeneralPage::DoDataExchange(CDataExchange* pDX)
{
	CHelpPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CACRGeneralPage)
	DDX_Control(pDX, IDC_CERT_TYPE, m_certTypeEdit);
	DDX_Control(pDX, IDC_CERT_PURPOSES, m_purposesEditControl);
	DDX_Control(pDX, IDC_CA_LIST, m_caListbox);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CACRGeneralPage, CHelpPropertyPage)
	//{{AFX_MSG_MAP(CACRGeneralPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CACRGeneralPage message handlers

BOOL CACRGeneralPage::OnInitDialog() 
{
	CHelpPropertyPage::OnInitDialog();
	
	CString	purposes;
	HRESULT	hResult = m_rACR.GetUsages (purposes);
	if ( SUCCEEDED (hResult) )
	{
		if ( purposes.IsEmpty () )
			VERIFY (purposes.LoadString (IDS_ANY));
		m_purposesEditControl.SetWindowText (purposes);
	}
	else
	{
		CString	error;

		VERIFY (error.LoadString (IDS_ERROR_READING_ACR_PURPOSES));
		m_purposesEditControl.SetWindowText (error);
	}

	CString	certTypeName;
	hResult = m_rACR.GetCertTypeName (certTypeName);
	if ( !SUCCEEDED (hResult) )
	{
		VERIFY (certTypeName.LoadString (IDS_ERROR_READING_ACR_CERTTYPE));
	}
	m_certTypeEdit.SetWindowText (certTypeName);	


    // We want the display names

	CStringList&	CANameList = m_rACR.GetCANameList (TRUE);
	CString			CAName;
	POSITION		pos = CANameList.GetHeadPosition ();

	for (; pos; )
	{
		CAName = CANameList.GetNext (pos);
		m_caListbox.AddString (CAName);
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CACRGeneralPage::DoContextHelp (HWND hWndControl)
{
    _TRACE (1, L"Entering CACRGeneralPage::DoContextHelp\n");
    static const DWORD help_map[] =
    {
        IDC_CERT_TYPE,      IDH_ACRPAGE_CERT_TYPE,
        IDC_CERT_PURPOSES,  IDH_ACRPAGE_CERT_PURPOSES,
        IDC_CA_LIST,        IDH_ACRPAGE_CA_LIST,
        0, 0
    };

    // Display context help for a control
    switch (::GetDlgCtrlID (hWndControl))
    {
    case IDC_CERT_TYPE:
    case IDC_CERT_PURPOSES:
    case IDC_CA_LIST:
        if ( !::WinHelp (
                hWndControl,
                GetF1HelpFilename(),
                HELP_WM_HELP,
                (DWORD_PTR) help_map) )
        {
            _TRACE (0, L"WinHelp () failed: 0x%x\n", GetLastError ());        
        }
        break;

    default:
        break;
    }
    _TRACE (-1, L"Leaving CACRGeneralPage::DoContextHelp\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\acrgenpg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       ACRGenPg.h
//
//  Contents:   Declaration of CACRGeneralPage
//
//----------------------------------------------------------------------------
#if !defined(AFX_ACRGENPG_H__B67821ED_7261_11D1_85D4_00C04FB94F17__INCLUDED_)
#define AFX_ACRGENPG_H__B67821ED_7261_11D1_85D4_00C04FB94F17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ACRGenPg.h : header file
//
#include "AutoCert.h"

/////////////////////////////////////////////////////////////////////////////
// CACRGeneralPage dialog

class CACRGeneralPage : public CHelpPropertyPage
{
// Construction
public:
	CACRGeneralPage(CAutoCertRequest& rACR);
	virtual ~CACRGeneralPage();

// Dialog Data
	//{{AFX_DATA(CACRGeneralPage)
	enum { IDD = IDD_AUTO_CERT_REQUEST_GENERAL };
	CEdit	m_certTypeEdit;
	CEdit	m_purposesEditControl;
	CListBox	m_caListbox;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CACRGeneralPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    virtual void DoContextHelp (HWND hWndControl);

	// Generated message map functions
	//{{AFX_MSG(CACRGeneralPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	CAutoCertRequest&   m_rACR;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ACRGENPG_H__B67821ED_7261_11D1_85D4_00C04FB94F17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\acrslast.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       ACRSLast.h
//
//  Contents:
//
//----------------------------------------------------------------------------
#if !defined(AFX_ACRSLAST_H__1BCEA8C7_756A_11D1_85D5_00C04FB94F17__INCLUDED_)
#define AFX_ACRSLAST_H__1BCEA8C7_756A_11D1_85D5_00C04FB94F17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ACRSLast.h : header file
//
#include "Wiz97PPg.h"

/////////////////////////////////////////////////////////////////////////////
// ACRSCompletionPage dialog

class ACRSCompletionPage : public CWizard97PropertyPage
{
	DECLARE_DYNCREATE(ACRSCompletionPage)

// Construction
public:
	ACRSCompletionPage();
	virtual ~ACRSCompletionPage();

// Dialog Data
	//{{AFX_DATA(ACRSCompletionPage)
	enum { IDD = IDD_ACR_SETUP_FINAL };
	CListCtrl	m_choicesList;
	CStatic	m_staticBold;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(ACRSCompletionPage)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL OnWizardFinish();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HRESULT MakeCTL (OUT BYTE **ppbEncodedCTL,
             OUT DWORD *pcbEncodedCTL);

	// Generated message map functions
	//{{AFX_MSG(ACRSCompletionPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	enum {
		COL_OPTION = 0,
		COL_VALUE,
		NUM_COLS
	};
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ACRSLAST_H__1BCEA8C7_756A_11D1_85D5_00C04FB94F17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\acrspsht.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       ACRSPSht.h
//
//  Contents:
//
//----------------------------------------------------------------------------
#if !defined(AFX_ACRSPSHT_H__98CAC389_7325_11D1_85D4_00C04FB94F17__INCLUDED_)
#define AFX_ACRSPSHT_H__98CAC389_7325_11D1_85D4_00C04FB94F17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ACRSPSht.h : header file
//
#include "cookie.h"
#include "AutoCert.h"
#include "Wiz97Sht.h"

/////////////////////////////////////////////////////////////////////////////
// ACRSWizardPropertySheet
class CCertStoreGPE;	// forward definition

class ACRSWizardPropertySheet : public CWizard97PropertySheet
{
// Construction
public:
	ACRSWizardPropertySheet(CCertStoreGPE* pCertStore, CAutoCertRequest* pACR);

// Attributes
public:

// Operations
public:

// Implementation
public:
	bool m_bEditModeDirty;	// relevant only when editing, tells us if any changes were made.
							// If not, nothing happens when Finish is pressed.
	CAutoCertRequest* GetACR();
	CCertStoreGPE* m_pCertStore;
	HCERTTYPE m_selectedCertType;
	void SetDirty ();
	void MarkAsClean ();
	bool IsDirty ();
	virtual ~ACRSWizardPropertySheet();

	// Generated message map functions
private:
	CAutoCertRequest* m_pACR;	// only set in 'edit' mode
	bool m_bDirty;				// used to know if it is necessary to re-enumerate the CAs
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ACRSPSHT_H__98CAC389_7325_11D1_85D4_00C04FB94F17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\acrslast.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       ACRSLast.cpp
//
//  Contents:   Implementation of Auto Cert Request Wizard Completion Page
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include <gpedit.h>
#include "ACRSLast.h"
#include "ACRSPSht.h"
#include "storegpe.h"


USE_HANDLE_MACROS("CERTMGR(ACRSLast.cpp)")

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


// Gross
#define MAX_GPE_NAME_SIZE  40


/////////////////////////////////////////////////////////////////////////////
// ACRSCompletionPage property page

IMPLEMENT_DYNCREATE (ACRSCompletionPage, CWizard97PropertyPage)

ACRSCompletionPage::ACRSCompletionPage () : CWizard97PropertyPage (ACRSCompletionPage::IDD)
{
	//{{AFX_DATA_INIT(ACRSCompletionPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	InitWizard97 (TRUE);
}

ACRSCompletionPage::~ACRSCompletionPage ()
{
}

void ACRSCompletionPage::DoDataExchange (CDataExchange* pDX)
{
	CWizard97PropertyPage::DoDataExchange (pDX);
	//{{AFX_DATA_MAP(ACRSCompletionPage)
	DDX_Control (pDX, IDC_CHOICES_LIST, m_choicesList);
	DDX_Control (pDX, IDC_BOLD_STATIC, m_staticBold);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(ACRSCompletionPage, CWizard97PropertyPage)
	//{{AFX_MSG_MAP(ACRSCompletionPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// ACRSCompletionPage message handlers

BOOL ACRSCompletionPage::OnInitDialog ()
{
	CWizard97PropertyPage::OnInitDialog ();
	
	m_staticBold.SetFont (&GetBigBoldFont ());

		// Set up columns in list view
	int	colWidths[NUM_COLS] = {150, 200};

	VERIFY (m_choicesList.InsertColumn (COL_OPTION, L"",
			LVCFMT_LEFT, colWidths[COL_OPTION], COL_OPTION) != -1);
	VERIFY (m_choicesList.InsertColumn (COL_VALUE, L"",
			LVCFMT_LEFT, colWidths[COL_VALUE], COL_VALUE) != -1);


	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL ACRSCompletionPage::OnSetActive ()
{
	BOOL	bResult = CWizard97PropertyPage::OnSetActive ();
	if ( bResult )
	{
		// Remove all items then repopulate.
		ACRSWizardPropertySheet* pSheet = reinterpret_cast <ACRSWizardPropertySheet*> (m_pWiz);
		ASSERT (pSheet);
		if ( pSheet )
		{
			// If edit mode and nothing changed, show disabled finish
			if ( pSheet->GetACR () && !pSheet->m_bEditModeDirty )
				GetParent ()->PostMessage (PSM_SETWIZBUTTONS, 0, PSWIZB_DISABLEDFINISH | PSWIZB_BACK);
			else
				GetParent ()->PostMessage (PSM_SETWIZBUTTONS, 0, PSWIZB_FINISH | PSWIZB_BACK);

			if ( pSheet->IsDirty () )
				pSheet->MarkAsClean ();
			VERIFY (m_choicesList.DeleteAllItems ());
			CString	text;
			LV_ITEM	lvItem;
			int		iItem = 0;

			// Display cert type selection
			VERIFY (text.LoadString (IDS_CERTIFICATE_TYPE_COLUMN_NAME));

            // security review 2/25/2002 BryanWal ok
			::ZeroMemory (&lvItem, sizeof (lvItem));
			lvItem.mask = LVIF_TEXT;
			lvItem.iItem = iItem;
			lvItem.iSubItem = COL_OPTION;
			lvItem.pszText = (LPWSTR) (LPCWSTR) text;
			VERIFY (-1 != m_choicesList.InsertItem (&lvItem));

			WCHAR**		pawszPropertyValue = 0;
			HRESULT	hResult = ::CAGetCertTypeProperty (pSheet->m_selectedCertType,
					CERTTYPE_PROP_FRIENDLY_NAME,
					&pawszPropertyValue);
			ASSERT (SUCCEEDED (hResult));
			if ( SUCCEEDED (hResult) )
			{
				if ( pawszPropertyValue[0] )
				{
					VERIFY (m_choicesList.SetItemText (iItem, COL_VALUE,
							*pawszPropertyValue));
				}
				VERIFY (SUCCEEDED (::CAFreeCertTypeProperty (
						pSheet->m_selectedCertType, pawszPropertyValue)));
			}
			iItem++;
		}
	}

	return bResult;
}


BOOL ACRSCompletionPage::OnWizardFinish ()
{
    BOOL                        bResult = TRUE;
	HRESULT						hResult = S_OK;
	CWaitCursor					waitCursor;
	ACRSWizardPropertySheet*	pSheet = reinterpret_cast <ACRSWizardPropertySheet*> (m_pWiz);
	ASSERT (pSheet);
	if ( pSheet )
	{
		// If edit mode and nothing changed, just return
		if ( pSheet->GetACR () && !pSheet->m_bEditModeDirty )
		{
			ASSERT (0);
			return FALSE;
		}

		BYTE    *pbEncodedCTL = NULL;
		DWORD   cbEncodedCTL = 0;

		hResult = MakeCTL (&pbEncodedCTL, &cbEncodedCTL);
		if ( SUCCEEDED (hResult) )
		{
			bResult = pSheet->m_pCertStore->AddEncodedCTL (
					X509_ASN_ENCODING,
					pbEncodedCTL, cbEncodedCTL,
					CERT_STORE_ADD_REPLACE_EXISTING,
					NULL);
			if ( !bResult )
			{
				DWORD	dwErr = GetLastError ();
				hResult = HRESULT_FROM_WIN32 (dwErr);
				DisplaySystemError (m_hWnd, dwErr);
			}
		}

		if (pbEncodedCTL)
			::LocalFree (pbEncodedCTL);
	}
	
	if ( SUCCEEDED (hResult) )
		bResult = CWizard97PropertyPage::OnWizardFinish ();
	else
		bResult = FALSE;

    return bResult;
}


HRESULT ACRSCompletionPage::MakeCTL (
             OUT BYTE **ppbEncodedCTL,
             OUT DWORD *pcbEncodedCTL)
{
	HRESULT					hResult = S_OK;
	ACRSWizardPropertySheet* pSheet = reinterpret_cast <ACRSWizardPropertySheet*> (m_pWiz);
	ASSERT (pSheet);
	if ( pSheet )
	{
		PCERT_EXTENSIONS        pCertExtensions = NULL;


		hResult = ::CAGetCertTypeExtensions (pSheet->m_selectedCertType, &pCertExtensions);
		ASSERT (SUCCEEDED (hResult));
		if ( SUCCEEDED (hResult) )
		{
			CMSG_SIGNED_ENCODE_INFO SignerInfo;
            // security review 2/25/2002 BryanWal ok
            ::ZeroMemory (&SignerInfo, sizeof (SignerInfo));
			CTL_INFO                CTLInfo;
            // security review 2/25/2002 BryanWal ok
            ::ZeroMemory (&CTLInfo, sizeof (CTLInfo));
			WCHAR**					pawszPropName = 0;


			// set up the CTL info
			CTLInfo.dwVersion = sizeof (CTLInfo);
			CTLInfo.SubjectUsage.cUsageIdentifier = 1;

			hResult = ::CAGetCertTypeProperty (pSheet->m_selectedCertType,
					CERTTYPE_PROP_DN,	&pawszPropName);
			ASSERT (SUCCEEDED (hResult));
			if ( SUCCEEDED (hResult) && pawszPropName[0] )
			{
				LPSTR	psz = szOID_AUTO_ENROLL_CTL_USAGE;
                WCHAR   szGPEName[MAX_GPE_NAME_SIZE];

                IGPEInformation *pGPEInfo = pSheet->m_pCertStore->GetGPEInformation();

                // security review 2/25/2002 BryanWal ok
                ::ZeroMemory (szGPEName, sizeof (szGPEName));

                // Allocate the size of the property name plus the GPEName, if any
                // security review 2/25/2002 BryanWal ok
				CTLInfo.ListIdentifier.cbData = (DWORD) (sizeof (WCHAR) * (wcslen (pawszPropName[0]) + 1));

                if ( pGPEInfo )
                {
                    pGPEInfo->GetName(szGPEName, sizeof(szGPEName)/sizeof(szGPEName[0]));
                    // security review 2/25/2002 BryanWal ok
                    CTLInfo.ListIdentifier.cbData += (DWORD) (sizeof(WCHAR)*(wcslen(szGPEName)+1));
                }

				CTLInfo.ListIdentifier.pbData = (PBYTE)LocalAlloc(LPTR, CTLInfo.ListIdentifier.cbData);
                if(CTLInfo.ListIdentifier.pbData == NULL)
                {
                    hResult = E_OUTOFMEMORY;
                }
                else //Bug 427957, 427958, Yanggao, 7/16/2001
                {
                    // ISSUE - convert to strsafe.  Ensure sufficient buffer 
                    // size for the following operations
                    // NTRAID Bug9 538774 Security: certmgr.dll : convert to strsafe string functions
                    if(szGPEName[0])
                    {
                        wcscpy((LPWSTR)CTLInfo.ListIdentifier.pbData, szGPEName);
                        wcscat((LPWSTR)CTLInfo.ListIdentifier.pbData, L"|");
                    }
                    wcscat((LPWSTR)CTLInfo.ListIdentifier.pbData, pawszPropName[0]);
                }

				CTLInfo.SubjectUsage.rgpszUsageIdentifier = &psz;
				::GetSystemTimeAsFileTime (&CTLInfo.ThisUpdate);
				CTLInfo.SubjectAlgorithm.pszObjId = szOID_OIWSEC_sha1;
				CTLInfo.cCTLEntry = 0;
				CTLInfo.rgCTLEntry = 0;

				// UNDONE - add the cert type extension

				// add all the reg info as an extension
				CTLInfo.cExtension = pCertExtensions->cExtension;
				CTLInfo.rgExtension = pCertExtensions->rgExtension;

				// encode the CTL
				*pcbEncodedCTL = 0;
				SignerInfo.cbSize = sizeof (SignerInfo);
				if ( ::CryptMsgEncodeAndSignCTL (PKCS_7_ASN_ENCODING,
											  &CTLInfo, &SignerInfo, 0,
											  NULL, pcbEncodedCTL) )
				{
					*ppbEncodedCTL = (BYTE*) ::LocalAlloc (LPTR, *pcbEncodedCTL);
					if ( *ppbEncodedCTL )
					{
						if (!::CryptMsgEncodeAndSignCTL (PKCS_7_ASN_ENCODING,
													  &CTLInfo, &SignerInfo, 0,
													  *ppbEncodedCTL, pcbEncodedCTL))
						{
							DWORD	dwErr = GetLastError ();
							hResult = HRESULT_FROM_WIN32 (dwErr);
							DisplaySystemError (m_hWnd, dwErr);
						}
					}
					else
					{
						hResult = E_OUTOFMEMORY;
					}

				}
				else
				{
					DWORD	dwErr = GetLastError ();
					hResult = HRESULT_FROM_WIN32 (dwErr);
					DisplaySystemError (m_hWnd, dwErr);
				}

				VERIFY (SUCCEEDED (::CAFreeCertTypeProperty (
						pSheet->m_selectedCertType, pawszPropName)));
			}
            if(CTLInfo.ListIdentifier.pbData)
            {
                ::LocalFree(CTLInfo.ListIdentifier.pbData);
            }

		}
		if (pCertExtensions)
			::LocalFree (pCertExtensions);
	}

    return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\acrstype.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       ACRSType.cpp
//
//  Contents:   Implementation of Auto Cert Request Wizard Certificate Type Page
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include <gpedit.h>
#include "storegpe.h"
#include "ACRSType.h"
#include "ACRSPSht.h"


USE_HANDLE_MACROS("CERTMGR(ACRSType.cpp)")

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// ACRSWizardTypePage property page

//IMPLEMENT_DYNCREATE(ACRSWizardTypePage, CWizard97PropertyPage)


ACRSWizardTypePage::ACRSWizardTypePage() 
	: CWizard97PropertyPage(ACRSWizardTypePage::IDD),
	m_bInitDialogComplete (false)
{
	//{{AFX_DATA_INIT(ACRSWizardTypePage)
	//}}AFX_DATA_INIT
	VERIFY (m_szHeaderTitle.LoadString (IDS_ACRS_TYPE_TITLE));
	VERIFY (m_szHeaderSubTitle.LoadString (IDS_ACRS_TYPE_SUBTITLE));
	InitWizard97 (FALSE);
}


ACRSWizardTypePage::~ACRSWizardTypePage ()
{
}


void ACRSWizardTypePage::DoDataExchange(CDataExchange* pDX)
{
	CWizard97PropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(ACRSWizardTypePage)
	DDX_Control(pDX, IDC_CERT_TYPES, m_certTypeList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(ACRSWizardTypePage, CWizard97PropertyPage)
	//{{AFX_MSG_MAP(ACRSWizardTypePage)
	ON_WM_DESTROY()
	ON_BN_CLICKED(IDC_USE_SMARTCARD, OnUseSmartcard)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_CERT_TYPES, OnItemchangedCertTypes)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// ACRSWizardTypePage message handlers

BOOL ACRSWizardTypePage::OnInitDialog() 
{
	CWizard97PropertyPage::OnInitDialog();

	// Set up columns in list view
	int	colWidths[NUM_COLS] = {200, 400};

	CString	columnLabel;
	VERIFY (columnLabel.LoadString (IDS_CERTIFICATE_TYPE_COLUMN_NAME));
	VERIFY (m_certTypeList.InsertColumn (COL_TYPE, (LPCWSTR) columnLabel, 
			LVCFMT_LEFT, colWidths[COL_TYPE], COL_TYPE) != -1);
	VERIFY (columnLabel.LoadString (IDS_PURPOSES_ALLOWED_COLUMN_NAME));
	VERIFY (m_certTypeList.InsertColumn (COL_PURPOSES, (LPCWSTR) columnLabel, 
			LVCFMT_LEFT, colWidths[COL_PURPOSES], COL_PURPOSES) != -1);


	EnumerateCertTypes ();  // Called here because only done once.

	m_bInitDialogComplete = true;

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


///////////////////////////////////////////////////////////////////////////////
//
//	EnumerateCertTypes
//
//	Enumerate all known Certificate types
//
///////////////////////////////////////////////////////////////////////////////
void ACRSWizardTypePage::EnumerateCertTypes()
{
	CWaitCursor	waitCursor;

	ACRSWizardPropertySheet* pSheet = reinterpret_cast <ACRSWizardPropertySheet*> (m_pWiz);
	ASSERT (pSheet);
	if ( pSheet )
	{
		CAutoCertRequest*	pACR = pSheet->GetACR ();
		HRESULT				hr = S_OK;
		WCHAR**				pawszPropertyValue = 0;
		HCERTTYPE			hCertType = 0;
		HCERTTYPE			hNextCertType = 0;
		int					iItem = 0;
		LV_ITEM				lvItem;
		HCERTTYPE			hACRCertType = 0;
		bool				bOneWasSelected = false;
		WCHAR**				pawszPropNameACR = 0;
		WCHAR**				pawszPropName = 0;
        bool                fMachine = FALSE;

		if ( pACR )		// an ACR was passed in - we're in 'edit' mode
		{

            hACRCertType = pACR->GetCertType ();
			hr = ::CAGetCertTypeProperty (hACRCertType,
					CERTTYPE_PROP_CN,
					&pawszPropNameACR);
			ASSERT (SUCCEEDED (hr));
		}

        fMachine = pSheet->m_pCertStore->IsMachineStore();
		m_certTypeList.DeleteAllItems ();
        hr = ::CAEnumCertTypes ((fMachine?CT_ENUM_MACHINE_TYPES:CT_ENUM_USER_TYPES), 
                                        &hCertType);
		ASSERT (SUCCEEDED (hr));
        if ( SUCCEEDED (hr) && !hCertType )
        {
			CString	caption;
			CString	text;
            CThemeContextActivator activator;

			VERIFY (caption.LoadString (IDS_CREATE_AUTO_CERT_REQUEST));
			VERIFY (text.LoadString (IDS_NO_CERT_TEMPLATES_INSTALLED));
			MessageBox (text, caption, MB_OK | MB_ICONWARNING);
        }

		while (SUCCEEDED (hr) && hCertType)
		{
            DWORD   dwFlags = 0;
            hr = ::CAGetCertTypeFlags (hCertType, &dwFlags);
            if ( SUCCEEDED (hr) )
            {
                DWORD   dwSchemaVersion = 0;

                // Only add version 1 cert templates (types)
                hr = CAGetCertTypePropertyEx (hCertType,
                        CERTTYPE_PROP_SCHEMA_VERSION,
                        &dwSchemaVersion);
                if ( SUCCEEDED (hr) )
                {
                    if ( 1 == dwSchemaVersion )
                    {
                        // Only add cert types appropriate for autoenrollment
                        if ( dwFlags & CT_FLAG_AUTO_ENROLLMENT )
                        {
			                hr = ::CAGetCertTypeProperty (hCertType,
					                CERTTYPE_PROP_FRIENDLY_NAME,
					                &pawszPropertyValue);
			                ASSERT (SUCCEEDED (hr));
			                if ( SUCCEEDED (hr) )
			                {
				                if ( pawszPropertyValue[0] )
				                {
					                hr = ::CAGetCertTypeProperty (hCertType,
							                CERTTYPE_PROP_CN,
							                &pawszPropName);
					                ASSERT (SUCCEEDED (hr));
					                if ( SUCCEEDED (hr) && pawszPropName[0] )
					                {
                                        // security review 2/26/2002 BryanWal ok
						                ::ZeroMemory (&lvItem, sizeof (lvItem));
						                UINT	selMask = 0;
						                if ( pawszPropNameACR && !bOneWasSelected )
						                {
							                // If an ACR was passed in, compare the
							                // names, if they are the same, mark
							                // it as selected.  Only one was selected
							                // so we needn't pass through here again if
							                // one is marked.
                                            // security review 2/26/2002 BryanWal ok
							                if ( !wcscmp (pawszPropNameACR[0], pawszPropName[0]) )
							                {
								                bOneWasSelected = true;
								                selMask = LVIF_STATE;
								                lvItem.state = LVIS_SELECTED;
							                }
						                }
						                iItem = m_certTypeList.GetItemCount ();

						                lvItem.mask = LVIF_TEXT | LVIF_PARAM | selMask;
						                lvItem.iItem = iItem;        
						                lvItem.iSubItem = COL_TYPE;      
						                lvItem.pszText = pawszPropertyValue[0]; 
						                lvItem.lParam = (LPARAM) hCertType;     
						                int iNewItem = m_certTypeList.InsertItem (&lvItem);
						                ASSERT (-1 != iNewItem);

						                hr = GetPurposes (hCertType, iNewItem);

						                VERIFY (SUCCEEDED (::CAFreeCertTypeProperty (hCertType,
								                pawszPropName)));
					                }
				                }
				                VERIFY (SUCCEEDED (::CAFreeCertTypeProperty (hCertType,
						                pawszPropertyValue)));
			                }
                        }
                    }
                }
                else if ( FAILED (hr) )
                {
                    _TRACE (0, L"CAGetCertTypePropertyEx (CERTTYPE_PROP_SCHEMA_VERSION) failed: 0x%x\n", hr);
                }

			    // Find the Next Cert Type in an enumeration.
			    hr = ::CAEnumNextCertType (hCertType, &hNextCertType);
			    hCertType = hNextCertType;
            }
            else
            {
                _TRACE (0, L"CAGetCertTypeFlags () failed: 0x%x\n", hr);
            }
		}

		// If we are not in edit mode, select the first item in the list
		if ( !pACR && m_certTypeList.GetItemCount () > 0 )
		{
			VERIFY (m_certTypeList.SetItemState (0, LVIS_SELECTED, LVIS_SELECTED));
		}

		if ( hACRCertType && pawszPropNameACR )
		{
			VERIFY (SUCCEEDED (::CAFreeCertTypeProperty (hACRCertType,
				pawszPropNameACR)));
		}
	}
}


void ACRSWizardTypePage::OnDestroy() 
{
	CWizard97PropertyPage::OnDestroy();

	int			nItem = m_certTypeList.GetItemCount ();
	HCERTTYPE	hCertType = 0;
	HRESULT		hr = S_OK;

	for (int nIndex = 0; nIndex < nItem; nIndex++)
	{
		hCertType = (HCERTTYPE) m_certTypeList.GetItemData (nIndex);
		ASSERT (hCertType);
		if ( hCertType )
		{
			hr = ::CACloseCertType (hCertType);
			ASSERT (SUCCEEDED (hr));
		}
	}
}

HRESULT ACRSWizardTypePage::GetPurposes(HCERTTYPE hCertType, int iItem)
{
    ASSERT (hCertType);
    if ( !hCertType )
        return E_INVALIDARG;
    
    if ( iItem < 0 || iItem >= m_certTypeList.GetItemCount () )
    {
        ASSERT (0);
        return E_INVALIDARG;
    }

	CWaitCursor	waitCursor;
	PCERT_EXTENSIONS	pCertExtensions = 0;
	HRESULT				hr = ::CAGetCertTypeExtensions (
			hCertType, &pCertExtensions);
	ASSERT (SUCCEEDED (hr));
	if ( SUCCEEDED (hr) )
	{
        if ( !pCertExtensions || !pCertExtensions->cExtension || !pCertExtensions->rgExtension )
        {
            ::LocalFree ((HLOCAL) pCertExtensions);
            return E_FAIL;
        }

		CString	purpose;
		CString purposes;

		for (DWORD dwIndex = 0; 
				dwIndex < pCertExtensions->cExtension; 
				dwIndex++)
		{
            // security review 2/26/2002 BryanWal - ensure valid pointer
			if ( !_stricmp (pCertExtensions->rgExtension[dwIndex].pszObjId,
					szOID_ENHANCED_KEY_USAGE) )
			{
				DWORD	cbStructInfo = 0;
				BOOL bResult = ::CryptDecodeObject (  
						X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
						szOID_ENHANCED_KEY_USAGE,
						pCertExtensions->rgExtension[dwIndex].Value.pbData,
						pCertExtensions->rgExtension[dwIndex].Value.cbData,
						0,
						NULL,
						&cbStructInfo);
				ASSERT (bResult);
				if ( bResult )
				{
					PCERT_ENHKEY_USAGE pUsage = (PCERT_ENHKEY_USAGE) new BYTE[cbStructInfo];
					if ( pUsage )
					{
						bResult = ::CryptDecodeObject (  
								X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
								szOID_ENHANCED_KEY_USAGE,
								pCertExtensions->rgExtension[dwIndex].Value.pbData,
								pCertExtensions->rgExtension[dwIndex].Value.cbData,
								0,
								pUsage,
								&cbStructInfo);
						ASSERT (bResult);
						if ( bResult )
						{
							for (DWORD dwUsageIDIndex = 0; 
                                    dwUsageIDIndex < pUsage->cUsageIdentifier; 
                                    dwUsageIDIndex++)
							{
								if ( MyGetOIDInfo (purpose, pUsage->rgpszUsageIdentifier[dwUsageIDIndex]) )
								{
									// add delimeter if not first iteration
									if ( dwUsageIDIndex )
										purposes += _T(", ");
									purposes += purpose;
								}
							}

						}
						delete [] pUsage;
					}
					else
					{
						hr = E_OUTOFMEMORY;
					}
				}
				break;
			}
		}
		::LocalFree ((HLOCAL) pCertExtensions);

		if ( purposes.IsEmpty () )
			VERIFY (purposes.LoadString (IDS_ANY));
		VERIFY (m_certTypeList.SetItemText (iItem, COL_PURPOSES, purposes));
	}

	return hr;
}

LRESULT ACRSWizardTypePage::OnWizardNext() 
{
	CWaitCursor	waitCursor;
	UINT	nSelCnt = m_certTypeList.GetSelectedCount ();
	LRESULT lResult = 0;

	if ( 1 == nSelCnt )
	{
		ACRSWizardPropertySheet* pSheet = reinterpret_cast <ACRSWizardPropertySheet*> (m_pWiz);
		ASSERT (pSheet);
		if ( pSheet )
		{
			VERIFY (UpdateData (TRUE));
			pSheet->m_selectedCertType = 0;

			// Save type to property sheet
			UINT	flag = 0;
			int		nCnt = m_certTypeList.GetItemCount ();
			for (int nItem = 0; nItem < nCnt; nItem++)
			{
				flag = ListView_GetItemState (m_certTypeList.m_hWnd, nItem, LVIS_SELECTED);
				if ( flag & LVNI_SELECTED )
				{
					pSheet->m_selectedCertType = (HCERTTYPE) m_certTypeList.GetItemData (nItem);
					ASSERT (pSheet->m_selectedCertType);
					if ( !pSheet->m_selectedCertType )
					{
						CString	caption;
						CString	text;
                        CThemeContextActivator activator;

						VERIFY (caption.LoadString (IDS_CREATE_AUTO_CERT_REQUEST));
						VERIFY (text.LoadString (IDS_ERROR_RETRIEVING_SELECTED_CERT_TYPE));
						MessageBox (text, caption, MB_OK | MB_ICONWARNING);
						return -1;
					}
					break;	// since only 1 item can be selected
				}
			}
			ASSERT (pSheet->m_selectedCertType);	// we must have selected something by now
		}

		lResult = CWizard97PropertyPage::OnWizardNext();
	}
	else
	{
		CString	caption;
		CString	text;
        CThemeContextActivator activator;

		VERIFY (caption.LoadString (IDS_ACRS_WIZARD_SHEET_CAPTION));
		VERIFY (text.LoadString (IDS_MUST_SELECT_CERT_TYPE));
		MessageBox (text, caption, MB_OK);
		lResult = -1;
	}

    return lResult;
}

BOOL ACRSWizardTypePage::OnSetActive() 
{
	BOOL	bResult = CWizard97PropertyPage::OnSetActive();

	if ( bResult )
		GetParent ()->PostMessage (PSM_SETWIZBUTTONS, 0, PSWIZB_NEXT | PSWIZB_BACK);

    int nCnt = m_certTypeList.GetItemCount ();
    if ( !nCnt )
        GetParent ()->PostMessage (PSM_SETWIZBUTTONS, 0, PSWIZB_BACK | PSWIZB_DISABLEDFINISH);

	return bResult;
}

void ACRSWizardTypePage::OnUseSmartcard() 
{
	ACRSWizardPropertySheet* pSheet = reinterpret_cast <ACRSWizardPropertySheet*> (m_pWiz);
	ASSERT (pSheet);
	if ( pSheet )
		pSheet->SetDirty ();
}

void ACRSWizardTypePage::OnItemchangedCertTypes(NMHDR* /*pNMHDR*/, LRESULT* pResult) 
{
	ACRSWizardPropertySheet* pSheet = reinterpret_cast <ACRSWizardPropertySheet*> (m_pWiz);
	ASSERT (pSheet);
	if ( pSheet )
	{
		pSheet->SetDirty ();
		if ( m_bInitDialogComplete )
			pSheet->m_bEditModeDirty = true;
	}
	
	*pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\acrswlcm.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       ACRSWlcm.cpp
//
//  Contents:
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "ACRSWLCM.H"
#include "ACRSPSht.h"

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// ACRSWizardWelcomePage property page

//IMPLEMENT_DYNCREATE(ACRSWizardWelcomePage, CWizard97PropertyPage)

ACRSWizardWelcomePage::ACRSWizardWelcomePage() : CWizard97PropertyPage(ACRSWizardWelcomePage::IDD)
{
	//{{AFX_DATA_INIT(ACRSWizardWelcomePage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	InitWizard97 (TRUE);
}

ACRSWizardWelcomePage::~ACRSWizardWelcomePage()
{
}

void ACRSWizardWelcomePage::DoDataExchange(CDataExchange* pDX)
{
	CWizard97PropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(ACRSWizardWelcomePage)
	DDX_Control(pDX, IDC_WIZARD_STATIC_BIG_BOLD1, m_staticBigBold);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(ACRSWizardWelcomePage, CWizard97PropertyPage)
	//{{AFX_MSG_MAP(ACRSWizardWelcomePage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// ACRSWizardWelcomePage message handlers

BOOL ACRSWizardWelcomePage::OnInitDialog() 
{
	CWizard97PropertyPage::OnInitDialog();

	m_staticBigBold.SetFont (&GetBigBoldFont ());

	CString	title;
	VERIFY (title.LoadString (IDS_ACRS_WIZARD_SHEET_CAPTION));
	CWnd* pParent = GetParent ();
    if ( pParent )
        pParent->SendMessage (PSM_SETTITLE, 0, (LPARAM) (LPCWSTR) title);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL ACRSWizardWelcomePage::OnSetActive() 
{
	BOOL	bResult = CWizard97PropertyPage::OnSetActive();

	if ( bResult )
		GetParent ()->PostMessage (PSM_SETWIZBUTTONS, 0, PSWIZB_NEXT);
	
	return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\acrstype.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       acrstype.h
//
//  Contents:
//
//----------------------------------------------------------------------------
#if !defined(AFX_ACRSTYPE_H__1BCEA8C5_756A_11D1_85D5_00C04FB94F17__INCLUDED_)
#define AFX_ACRSTYPE_H__1BCEA8C5_756A_11D1_85D5_00C04FB94F17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ACRSType.h : header file
//
#include "Wiz97PPg.h"

/////////////////////////////////////////////////////////////////////////////
// ACRSWizardTypePage dialog

class ACRSWizardTypePage : public CWizard97PropertyPage
{
//	DECLARE_DYNCREATE(ACRSWizardTypePage)

// Construction
public:
	ACRSWizardTypePage();   // standard constructor
	virtual ~ACRSWizardTypePage();

// Dialog Data
	//{{AFX_DATA(ACRSWizardTypePage)
	enum { IDD = IDD_ACR_SETUP_TYPE };
	CListCtrl	m_certTypeList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(ACRSWizardTypePage)
	public:
	virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
//	bool AlreadyInList (CStringList& typeList, CString propName);
	HRESULT GetPurposes (HCERTTYPE hCertType, int iItem);
	void EnumerateCertTypes ();

	// Generated message map functions
	//{{AFX_MSG(ACRSWizardTypePage)
	virtual BOOL OnInitDialog();
	afx_msg void OnDestroy();
	afx_msg void OnUseSmartcard();
	afx_msg void OnItemchangedCertTypes(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	bool m_bInitDialogComplete;
	enum {
		COL_TYPE = 0,
		COL_PURPOSES,
		NUM_COLS
	};
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ACRSTYPE_H__1BCEA8C5_756A_11D1_85D5_00C04FB94F17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\acrspsht.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       ACRSPSht.cpp
//
//  Contents:
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include <gpedit.h>
#include "ACRSPSht.h"
#include "storegpe.h"

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// ACRSWizardPropertySheet

ACRSWizardPropertySheet::ACRSWizardPropertySheet(
		CCertStoreGPE* pCertStore, 
		CAutoCertRequest* pACR)
	:CWizard97PropertySheet (IDS_ACRS_WIZARD_SHEET_CAPTION, IDB_ACRS_WATERMARK, IDB_ACRS_BANNER), 
	m_bDirty (false),
	m_selectedCertType (0),
	m_pCertStore (pCertStore),
	m_pACR (pACR),
	m_bEditModeDirty (false)
{
	ASSERT (m_pCertStore);
	m_pCertStore->AddRef ();
	if ( m_pACR )
		m_pACR->AddRef ();
}

ACRSWizardPropertySheet::~ACRSWizardPropertySheet()
{
	m_pCertStore->Release ();
	if ( m_pACR )
		m_pACR->Release ();
}


bool ACRSWizardPropertySheet::IsDirty()
{
	return m_bDirty;
}

void ACRSWizardPropertySheet::MarkAsClean()
{
	m_bDirty = false;
}

void ACRSWizardPropertySheet::SetDirty()
{
	m_bDirty = true;
}

CAutoCertRequest* ACRSWizardPropertySheet::GetACR()
{
	return m_pACR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\acrswlcm.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       acrswlcm.h
//
//  Contents:
//
//----------------------------------------------------------------------------
#if !defined(AFX_ACRSWLCM_H__98CAC388_7325_11D1_85D4_00C04FB94F17__INCLUDED_)
#define AFX_ACRSWLCM_H__98CAC388_7325_11D1_85D4_00C04FB94F17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ACRSWLCM.H : header file
//
#include "Wiz97PPg.h"

/////////////////////////////////////////////////////////////////////////////
// ACRSWizardWelcomePage dialog

class ACRSWizardWelcomePage : public CWizard97PropertyPage
{
//	DECLARE_DYNCREATE(ACRSWizardWelcomePage)

// Construction
public:
	ACRSWizardWelcomePage();
	virtual ~ACRSWizardWelcomePage();

// Dialog Data
	//{{AFX_DATA(ACRSWizardWelcomePage)
	enum { IDD = IDD_ACR_SETUP_WELCOME };
	CStatic	m_staticBigBold;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(ACRSWizardWelcomePage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(ACRSWizardWelcomePage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ACRSWLCM_H__98CAC388_7325_11D1_85D4_00C04FB94F17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\addsheet.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       addsheet.h
//
//  Contents:
//
//----------------------------------------------------------------------------
#if !defined(AFX_ADDSHEET_H__AD17A140_5492_11D1_BB63_00A0C906345D__INCLUDED_)
#define AFX_ADDSHEET_H__AD17A140_5492_11D1_BB63_00A0C906345D__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// AddSheet.h : header file
//

#include "welcome.h"
#include "locate.h"
#include "complete.h"
#pragma warning(push, 3)
#include <dsclient.h>
#pragma warning(pop)
#include "Users.h"	// Added by ClassView

/////////////////////////////////////////////////////////////////////////////
// CAddEFSWizSheet

class CAddEFSWizSheet : public CWizard97PropertySheet
{
// Construction
public:
	CAddEFSWizSheet(UINT nIDCaption, CUsers& externalUsers, bool bMachineIsStandAlone);

    DWORD   Add(
                LPWSTR UserName,
                LPWSTR DnName, 
                PVOID UserCert, 
                PSID UserSid = NULL, 
                DWORD Flag = USERINFILE,
                PCCERT_CONTEXT pCertContext = NULL
              );

    DWORD   Remove(
                LPCWSTR UserName,
                LPCWSTR CertName
              );

    PUSERSONFILE    StartEnum(void);

    PUSERSONFILE GetNextUser(
                        PUSERSONFILE Token, 
                        CString &UserName,
                        CString &CertName
                        );

    void ClearUserList(void);

    DWORD AddNewUsers(void);

protected:
	void AddControlPages(void);

// Attributes
private:
    CUsers              m_Users;
    CUsers&             m_externalUsers;
    CAddEFSWizWelcome	m_WelcomePage;	// Welcome PropPage
    CAddEFSWizLocate    m_LocatePage;	// Locate User PropPage
    CAddEFSWizComplete  m_CompletePage; // Complete PropPage
    CString             m_SheetTitle;
    CLIPFORMAT          m_cfDsObjectNames; // ClipBoardFormat

// Attributes
public:
    const bool m_bMachineIsStandAlone;

// Operations
public:

// Implementation
public:
	CLIPFORMAT GetDataFormat(void);
	virtual ~CAddEFSWizSheet();
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADDSHEET_H__AD17A140_5492_11D1_BB63_00A0C906345D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\addsheet.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       AddSheet.cpp
//
//  Contents:
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "AddSheet.h"

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAddEFSWizSheet

CAddEFSWizSheet::CAddEFSWizSheet (UINT nIDCaption, CUsers& externalUsers, bool bMachineIsStandAlone)
	:CWizard97PropertySheet (nIDCaption, IDB_RECOVERY_WATERMARK, IDB_RECOVERY_BANNER),
	m_externalUsers (externalUsers),
    m_bMachineIsStandAlone (bMachineIsStandAlone)
{
    AddControlPages ();
    m_cfDsObjectNames = (CLIPFORMAT)RegisterClipboardFormat (CFSTR_DSOBJECTNAMES);
}


CAddEFSWizSheet::~CAddEFSWizSheet ()
{
}


//
// This routine adds the tab to the sheet
//

void CAddEFSWizSheet::AddControlPages ()
{
    AddPage (&m_WelcomePage);
	AddPage (&m_LocatePage);
    AddPage (&m_CompletePage);
}


CLIPFORMAT CAddEFSWizSheet::GetDataFormat ()
{
    return m_cfDsObjectNames;
}

DWORD CAddEFSWizSheet::Add (
        LPWSTR UserName,
        LPWSTR DnName, 
        PVOID UserCert, 
        PSID UserSid /*= NULL */, 
        DWORD Flag /*= USERINFILE*/,
        PCCERT_CONTEXT pCertContext /*= NULL*/
      )
{
    return m_Users.Add (
                    UserName,
                    DnName,
                    UserCert,
                    UserSid,
                    Flag,
                    pCertContext
                    );    
}

DWORD CAddEFSWizSheet::Remove (
    LPCWSTR UserName,
    LPCWSTR UserCertName
    )
{
    return m_Users.Remove (
                    UserName,
                    UserCertName
                    );
}

PUSERSONFILE CAddEFSWizSheet::StartEnum ()
{
    return m_Users.StartEnum ();
}

PUSERSONFILE CAddEFSWizSheet::GetNextUser (
    PUSERSONFILE Token, 
    CString &UserName,
    CString &CertName
    )
{
    return m_Users.GetNextUser (
                    Token,
                    UserName,
                    CertName
                    );
}

void CAddEFSWizSheet::ClearUserList (void)
{
   m_Users.Clear ();
}

DWORD CAddEFSWizSheet::AddNewUsers (void)
{
	m_externalUsers.Add (m_Users);
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\autocert.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       AutoCert.h
//
//  Contents:   
//
//----------------------------------------------------------------------------

#if !defined(AFX_AUTOCERT_H__6C3D4D37_3527_11D1_B4AD_00C04FB94F17__INCLUDED_)
#define AFX_AUTOCERT_H__6C3D4D37_3527_11D1_B4AD_00C04FB94F17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "ctl.h"
#pragma warning(push, 3)
#include <autoenr.h>
#pragma warning(pop)

class CAutoCertRequest : public CCTL  
{
public:
	HCERTTYPE GetCertType();
	CStringList& GetCANameList (bool fDisplayName);
	HRESULT GetUsages (CString& usages);
	HRESULT GetCertTypeName (CString& certTypeName);
	CAutoCertRequest (const PCCTL_CONTEXT pCTLContext, CCertStore& rCertStore);
	virtual ~CAutoCertRequest();

private:
	HCERTTYPE m_hCertType;
	bool m_bCANamesEnumerated;
	CString m_szUsages;
	PCERT_EXTENSION m_pEnhKeyUsageExtension;
	PCERT_EXTENSION m_pCertTypeExtension;
	CString m_szCertTypeName;
	CStringList m_CANameList;
	CStringList m_CADisplayNameList;
protected:

	HRESULT BuildCANameList ();
	PCERT_EXTENSION GetEnhancedKeyUsageExtension();
	PCERT_EXTENSION GetCertTypeExtension ();
};

#endif // !defined(AFX_AUTOCERT_H__6C3D4D37_3527_11D1_B4AD_00C04FB94F17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\autoenrollmentpropertypage.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       AutoenrollmentPropertyPage.h
//
//  Contents:   Declaration of CAutoenrollmentPropertyPage
//
//----------------------------------------------------------------------------
#if !defined(AFX_AUTOENROLLMENTPROPERTYPAGE_H__DA50335B_4919_4B92_BE66_73B07410EFBD__INCLUDED_)
#define AFX_AUTOENROLLMENTPROPERTYPAGE_H__DA50335B_4919_4B92_BE66_73B07410EFBD__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// AutoenrollmentPropertyPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CAutoenrollmentPropertyPage dialog
class CCertMgrComponentData; // forward declaration

class CAutoenrollmentPropertyPage : public CHelpPropertyPage
{
// Construction
public:
	CAutoenrollmentPropertyPage(CCertMgrComponentData* pCompData,
            bool fIsComputerTYpe);
	~CAutoenrollmentPropertyPage();

// Dialog Data
	//{{AFX_DATA(CAutoenrollmentPropertyPage)
	enum { IDD = IDD_PROPPAGE_AUTOENROLL };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CAutoenrollmentPropertyPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    void EnableControls ();
    virtual void OnOK();
    virtual void DoContextHelp (HWND hWndControl);
    void SetGPEFlags ();
	void GPEGetAutoenrollmentFlags ();
    void RSOPGetAutoenrollmentFlags (const CCertMgrComponentData* pCompData);

	void SaveCheck();
	// Generated message map functions
	//{{AFX_MSG(CAutoenrollmentPropertyPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnAutoenrollDisableAll();
	afx_msg void OnAutoenrollEnable();
	afx_msg void OnAutoenrollEnablePending();
	afx_msg void OnAutoenrollEnableTemplate();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	HKEY				    m_hAutoenrollmentFlagsKey;
	DWORD				    m_dwAutoenrollmentFlags;
	IGPEInformation*	    m_pGPEInformation;
	HKEY				    m_hGroupPolicyKey;
    bool                    m_fIsComputerType;

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_AUTOENROLLMENTPROPERTYPAGE_H__DA50335B_4919_4B92_BE66_73B07410EFBD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\autocert.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998-2002.
//
//  File:       AutoCert.cpp
//
//  Contents:   implementation of the CAutoCertRequest class.
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include <gpedit.h>
#include "AutoCert.h"
#include "storegpe.h"


USE_HANDLE_MACROS("CERTMGR(AutoCert.cpp)")


////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CAutoCertRequest::CAutoCertRequest (const PCCTL_CONTEXT pCTLContext, CCertStore& rCertStore) :
	CCTL (pCTLContext, rCertStore, CERTMGR_AUTO_CERT_REQUEST),
	m_pCertTypeExtension (0),
	m_pEnhKeyUsageExtension (0),
	m_bCANamesEnumerated (false),
	m_hCertType (0)
{
	ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype);
}

CAutoCertRequest::~CAutoCertRequest()
{
	ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype);
	if ( m_hCertType )
	{
		VERIFY (SUCCEEDED (::CACloseCertType (m_hCertType)));
	}
}



HRESULT CAutoCertRequest::GetCertTypeName(CString & certTypeName)
{
	ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype);
	HRESULT	hResult = S_OK;

    

	if ( CERTMGR_LOG_STORE_GPE != GetCertStore().m_objecttype && 
            CERTMGR_LOG_STORE_RSOP != GetCertStore().m_objecttype )
    {
        hResult = E_FAIL;
        return hResult;
    }

    CCertStore* pStore = reinterpret_cast <CCertStore*>(&GetCertStore());
    if(pStore == NULL)
    {
        hResult = E_FAIL;
        return hResult;
    }




	if ( m_szCertTypeName.IsEmpty () )
	{
		bool	bFound = false;


		hResult = E_FAIL;
		PCERT_EXTENSION	pCertTypeExtension = GetCertTypeExtension ();
		if ( pCertTypeExtension )
		{
			DWORD	cbValue = 0;

			if ( ::CryptDecodeObject(
					CRYPT_ASN_ENCODING,
					X509_UNICODE_ANY_STRING,
					pCertTypeExtension->Value.pbData,
					pCertTypeExtension->Value.cbData,
					0,
					0,
					&cbValue) )
			{
				CERT_NAME_VALUE* pCNValue = (CERT_NAME_VALUE*) 
					::LocalAlloc(LPTR, cbValue);
				if ( pCNValue )
				{
					if ( ::CryptDecodeObject(
							CRYPT_ASN_ENCODING,
							X509_UNICODE_ANY_STRING,
							pCertTypeExtension->Value.pbData,
							pCertTypeExtension->Value.cbData,
							0,
							pCNValue,
							&cbValue) )
					{
						LPWSTR			pszCertTypeName = (LPWSTR) pCNValue->Value.pbData;
						CString			CAName;
						HCERTTYPE		hCertType = 0;

						hResult = ::CAFindCertTypeByName ( pszCertTypeName,
                                                           NULL,
                                                            (pStore->IsMachineStore()?CT_ENUM_MACHINE_TYPES:CT_ENUM_USER_TYPES), 
                                                              &hCertType);
						if ( SUCCEEDED (hResult) )
						{
							WCHAR**		pawszPropertyValue = 0;

							hResult = ::CAGetCertTypeProperty (hCertType,
									CERTTYPE_PROP_FRIENDLY_NAME,
									&pawszPropertyValue);
							ASSERT (SUCCEEDED (hResult));
							if ( SUCCEEDED (hResult) )
							{
								if ( pawszPropertyValue[0] )
								{
									m_szCertTypeName = pawszPropertyValue[0];
									bFound = true;
									m_hCertType = hCertType;
								}
                                else
                                {
									VERIFY (SUCCEEDED (::CAFreeCertTypeProperty (hCertType,
										pawszPropertyValue)));
                                }
							}
							if ( !bFound )
							{
								hResult = ::CACloseCertType (hCertType);
								ASSERT (SUCCEEDED (hResult));
							}
						}

					}
					else
					{
						DWORD	dwErr = GetLastError ();
						DisplaySystemError (NULL, dwErr);
						hResult = HRESULT_FROM_WIN32 (dwErr);
					}
					::LocalFree (pCNValue);
				}
				else
				{
					hResult = E_OUTOFMEMORY;
				}
			}
			else
			{
				DWORD	dwErr = GetLastError ();
				DisplaySystemError (NULL, dwErr);
				hResult = HRESULT_FROM_WIN32 (dwErr);
			}
		}
		// If all calls succeded but it still wasn't found, then fail anyway.
		if ( SUCCEEDED (hResult) && !bFound )
			hResult = E_FAIL;
	}

	if ( SUCCEEDED (hResult) )
		certTypeName = m_szCertTypeName;

	return hResult;
}

PCERT_EXTENSION CAutoCertRequest::GetCertTypeExtension()
{
	ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype);
	if ( !m_pCertTypeExtension )
	{
		m_pCertTypeExtension = ::CertFindExtension (
				szOID_ENROLL_CERTTYPE_EXTENSION, 
				GetCTLContext ()->pCtlInfo->cExtension,
				GetCTLContext ()->pCtlInfo->rgExtension);
		ASSERT (m_pCertTypeExtension);
		if ( !m_pCertTypeExtension )
		{
			DisplaySystemError (NULL, GetLastError ());
		}
	}

	return m_pCertTypeExtension;
}

PCERT_EXTENSION CAutoCertRequest::GetEnhancedKeyUsageExtension()
{
	ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype);
	if ( !m_pEnhKeyUsageExtension )
	{
		m_pEnhKeyUsageExtension = ::CertFindExtension (
				szOID_ENHANCED_KEY_USAGE, 
				GetCTLContext ()->pCtlInfo->cExtension,
				GetCTLContext ()->pCtlInfo->rgExtension);
		ASSERT (m_pEnhKeyUsageExtension);
		if ( !m_pEnhKeyUsageExtension )
		{
			DWORD	dwErr = GetLastError ();
			if ( dwErr )
				DisplaySystemError (NULL, dwErr);
		}
	}

	return m_pEnhKeyUsageExtension;
}

HRESULT CAutoCertRequest::GetUsages(CString & usages)
{
	ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype);
	HRESULT	hResult = S_OK;

	if ( m_szUsages.IsEmpty () )
	{
		hResult = E_FAIL;
		PCERT_EXTENSION	pEnhKeyUsageExtension = GetEnhancedKeyUsageExtension ();
		ASSERT (pEnhKeyUsageExtension);
		if ( pEnhKeyUsageExtension )
		{
			DWORD	cbEnhKeyUsage = 0;


			if ( ::CryptDecodeObject(CRYPT_ASN_ENCODING, 
					szOID_ENHANCED_KEY_USAGE, 
					pEnhKeyUsageExtension->Value.pbData,
					pEnhKeyUsageExtension->Value.cbData,
					0, NULL, &cbEnhKeyUsage) )
			{
				PCERT_ENHKEY_USAGE	pEnhKeyUsage = (PCERT_ENHKEY_USAGE)
						::LocalAlloc (LPTR, cbEnhKeyUsage);
				if ( pEnhKeyUsage )
				{
					if ( ::CryptDecodeObject (CRYPT_ASN_ENCODING, 
							szOID_ENHANCED_KEY_USAGE, 
							pEnhKeyUsageExtension->Value.pbData,
							pEnhKeyUsageExtension->Value.cbData,
							0, pEnhKeyUsage, &cbEnhKeyUsage) )
					{
						CString	usageName;

						for (DWORD dwIndex = 0; 
								dwIndex < pEnhKeyUsage->cUsageIdentifier; 
								dwIndex++)
						{
							if ( MyGetOIDInfo (usageName, 
									pEnhKeyUsage->rgpszUsageIdentifier[dwIndex]) )
							{
								// add delimeter if not first iteration
								if ( dwIndex )
									m_szUsages += _T(", ");
								m_szUsages += usageName;
							}
						}
						hResult = S_OK;
					}
					else
						DisplaySystemError (NULL, GetLastError());
					::LocalFree (pEnhKeyUsage);
				}
				else
				{
					hResult = E_OUTOFMEMORY;
				}
			}
			else
				DisplaySystemError (NULL, GetLastError());
		}
	}

	if ( SUCCEEDED (hResult) )
		usages = m_szUsages;

	return hResult;
}


// To get CAs, enumerate CAs on DS, get certs, get hash, compare with stored hash
// in CTL, if match found, call GetCAInfoFromDS


HRESULT CAutoCertRequest::BuildCANameList()
{
	ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype);
	HRESULT	hResult = S_OK;

	if ( !m_bCANamesEnumerated )
	{
		m_bCANamesEnumerated = true;

		// To get CAs, enumerate CAs on DS, get certs, get hash, compare with stored hash
		// in CTL, if match found, call GetCAInfoFromDS
		CWaitCursor		waitCursor;
		HCAINFO			hCAInfo = 0;
		DWORD			dwCACnt = 0;
		HCAINFO*		pCAList = 0;
		UINT			nIndex = 0;
		PCCERT_CONTEXT* ppCertContext = NULL;
		DWORD           cbHash = 20;
		hResult = ::CAEnumFirstCA (NULL, 0, &hCAInfo);
		if ( SUCCEEDED (hResult) )
			dwCACnt = ::CACountCAs (hCAInfo);

		if ( dwCACnt > 0 )
		{
        
			pCAList = new HCAINFO[dwCACnt];
			ppCertContext = new PCCERT_CONTEXT[dwCACnt];
			if ( pCAList && ppCertContext )
			{
				nIndex = 0;
				while (SUCCEEDED (hResult) && hCAInfo && nIndex < dwCACnt)
				{
					pCAList[nIndex] = hCAInfo;
					hResult = ::CAGetCACertificate (hCAInfo, &ppCertContext[nIndex]);
					ASSERT (SUCCEEDED (hResult));
					nIndex++;
					hResult = ::CAEnumNextCA (hCAInfo, &hCAInfo);
				}
            
				PCCTL_CONTEXT	pCTLContext = GetCTLContext ();
				if ( pCTLContext )
				{
					PCTL_INFO		pCTLInfo = pCTLContext->pCtlInfo;
					DWORD			cCTLEntry = pCTLInfo->cCTLEntry;
					PCTL_ENTRY		rgCTLEntry = pCTLInfo->rgCTLEntry;
					const size_t	HASH_SIZE = 20;
					BYTE			pbHash[HASH_SIZE];
                
					for (UINT nCAHash = 0; nCAHash < cCTLEntry; nCAHash++)
					{
						for (UINT nCertContextIndex = 0; nCertContextIndex < dwCACnt; nCertContextIndex++)
						{
							cbHash = HASH_SIZE;
							if (::CertGetCertificateContextProperty (ppCertContext[nCertContextIndex],
															  CERT_SHA1_HASH_PROP_ID,
															  pbHash,
															  &cbHash) )
							{
                            
								// Compare pbHash with pCAHash;
                                // security review 2/26/2002 BryanWal ok
                                ASSERT (pbHash);
                                if ( !pbHash )
                                    break;

								if ( !memcmp (pbHash, 
										rgCTLEntry[nCAHash].SubjectIdentifier.pbData, 
										rgCTLEntry[nCAHash].SubjectIdentifier.cbData) )
								{
                                    LPWSTR *awszCAName = NULL;
                                    LPWSTR *awszCADisplayName = NULL;
                                    //
                                    // Add this CA to the list of 
                                    // CA's.
                                    //
                                
	                                // get the name of the CA 
	                                hResult = ::CAGetCAProperty (pCAList[nCertContextIndex], 
                                                                 CA_PROP_NAME, 
                                                                 &awszCAName);


	                                if (SUCCEEDED (hResult) && awszCAName && awszCAName[0] )
	                                {
                                    
		                                // get the display name of the CA
		                                hResult = ::CAGetCAProperty (pCAList[nCertContextIndex], 
                                                                     CA_PROP_DISPLAY_NAME, 
                                                                     &awszCADisplayName);
                                    
		                                if ( SUCCEEDED(hResult) && awszCADisplayName && awszCADisplayName[0] )
                                        {
										    m_CANameList.AddHead (awszCAName[0]);

										    m_CADisplayNameList.AddHead (awszCADisplayName[0]);	
                                        }
                                    }

									if ( awszCAName )
                                    {
                                        CAFreeCAProperty(pCAList[nCertContextIndex], awszCAName);
                                    }
									if ( awszCADisplayName )
                                    {
                                        CAFreeCAProperty(pCAList[nCertContextIndex], awszCADisplayName);
                                    }
									break;

								}
							}
							else
							{
								DWORD	dwErr = GetLastError ();
								hResult = HRESULT_FROM_WIN32 (dwErr);
								DisplaySystemError (NULL, dwErr);
								break;
							}
						}
					}
				}

				for (UINT nCAListIndex = 0; nCAListIndex < dwCACnt; nCAListIndex++)
				{
					hResult = ::CACloseCA (pCAList[nCAListIndex]);
					ASSERT (SUCCEEDED (hResult));

					::CertFreeCertificateContext (ppCertContext[nCAListIndex]);
				}
			}
			else
			{
				hResult = E_OUTOFMEMORY;
			}
            if ( pCAList )
			    delete [] pCAList;
            if ( ppCertContext )
			    delete [] ppCertContext;
		}
	}

	return hResult;
}

CStringList& CAutoCertRequest::GetCANameList(bool fDisplayName)
{
	ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype);
	BuildCANameList ();
    return fDisplayName?m_CADisplayNameList:m_CANameList;
}

HCERTTYPE CAutoCertRequest::GetCertType()
{
	ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype);
	if ( !m_hCertType )
	{
		CString	name;
		GetCertTypeName (name); // generates m_hCertType
	}
	return m_hCertType;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\certifct.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       Certifct.cpp
//
//  Contents:   Implementation of CCertmgrApp and DLL registration.
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "Certifct.h"

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

USE_HANDLE_MACROS("CERTMGR(Certifct.cpp)")

/////////////////////////////////////////////////////////////////////////////
//
const int FIELD_ISSUER_ALT_NAME =   0x00000001;
const int FIELD_SUBJECT_ALT_NAME =  0x00000002;
const int FIELD_CAN_DELETE =        0x00000004;
const int FIELD_IS_ARCHIVED =       0x00000008;
const int FIELD_TEMPLATE_NAME =     0x00000010;

CCertificate::CCertificate(const PCCERT_CONTEXT pCertContext, CCertStore* pCertStore) 
: CCertMgrCookie (CERTMGR_CERTIFICATE),
m_pCertContext (::CertDuplicateCertificateContext (pCertContext)),
    m_pCertInfo (0),
    m_fieldChecked (0),
    m_pCertStore (pCertStore),
    m_bCanDelete (false),
    m_bIsArchived (false)
{
//  _TRACE (1, L"Entering CCertificate::CCertificate\n");
    ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
    ASSERT (m_pCertStore);
    if ( m_pCertStore )
        m_pCertStore->AddRef ();
    ASSERT (m_pCertContext);
    if ( m_pCertContext )
        m_pCertInfo = m_pCertContext->pCertInfo;
//  _TRACE (-1, L"Leaving CCertificate::CCertificate\n");
}



CCertificate::~CCertificate()
{
//  _TRACE (1, L"Entering CCertificate::~CCertificate\n");
    ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
    if ( m_pCertContext )
        ::CertFreeCertificateContext (m_pCertContext);
    if ( m_pCertStore )
        m_pCertStore->Release ();
//  _TRACE (-1, L"Leaving CCertificate::~CCertificate\n");
}


CString CCertificate::GetFriendlyName ()
{
//  _TRACE (1, L"Entering CCertificate::GetFriendlyName\n");
    ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
    ASSERT (m_pCertContext);
    if ( m_pCertContext && m_szFriendlyName.IsEmpty () )
    {   
        AFX_MANAGE_STATE (AfxGetStaticModuleState ());
        DWORD   cbData = 0;
        BOOL bResult = ::CertGetCertificateContextProperty (
                m_pCertContext,
                CERT_FRIENDLY_NAME_PROP_ID,
                NULL,
                &cbData);
        if ( bResult )
        {
            LPWSTR  pszName = new WCHAR[cbData];
            if ( pszName )
            {
                // security review 2/22/2002 BryanWal ok
                ::ZeroMemory (pszName, cbData*sizeof (WCHAR));
                bResult = ::CertGetCertificateContextProperty (
                        m_pCertContext,
                        CERT_FRIENDLY_NAME_PROP_ID,
                        pszName,
                        &cbData);
                ASSERT (bResult);
                if ( bResult )
                {
                    m_szFriendlyName = pszName;
                }
                else
                {
                    VERIFY (m_szFriendlyName.LoadString (IDS_NOT_AVAILABLE));
                }
                delete [] pszName;
            }
        }
        else
        {
            if ( GetLastError () == CRYPT_E_NOT_FOUND )
            {
                VERIFY (m_szFriendlyName.LoadString (IDS_NONE));
            }
            else
            {
                ASSERT (0);
                VERIFY (m_szFriendlyName.LoadString (IDS_NOT_AVAILABLE));
            }
        }
    }
//  _TRACE (-1, L"Leaving CCertificate::GetFriendlyName\n");
    return m_szFriendlyName;
}


CString CCertificate::GetIssuerName ()
{
//  _TRACE (1, L"Entering CCertificate::GetIssuerName\n");
    ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
    ASSERT (m_pCertInfo);
    if ( m_pCertInfo )
    {
        // Decode issuer name if not already present
        if ( m_szIssuerName.IsEmpty () )
        {
            m_szIssuerName = ::GetNameString (m_pCertContext, CERT_NAME_ISSUER_FLAG);
        }
    }
    else
        return _T("");


//  _TRACE (-1, L"Leaving CCertificate::GetIssuerName\n");
    return m_szIssuerName;
}

///////////////////////////////////////////////////////////////////////////
//  GetSubjectName ()
//
//  pszName (IN / OPTIONAL)  - returns the alternate issuer name.  An empty 
//                              string is a valid return value
//  cbName  (IN / OUT)       - If pszName is NULL, then the required length
//                              of pszName is returned.  
//                              Otherwise, contains the length of pszName.
///////////////////////////////////////////////////////////////////////////
CString CCertificate::GetSubjectName()
{
//  _TRACE (1, L"Entering CCertificate::GetSubjectName\n");
    ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
    ASSERT (m_pCertInfo);
    if ( m_pCertInfo )
    {
        // Decode subject name if not already present
        if ( m_szSubjectName.IsEmpty () )
        {
            m_szSubjectName = ::GetNameString (m_pCertContext, 0);
        }
    }
    else
        return _T("");

//  _TRACE (-1, L"Leaving CCertificate::GetSubjectName\n");
    return m_szSubjectName;
}

///////////////////////////////////////////////////////////////////////////
//  GetValidNotBefore ()
//
//  pszDateTime (IN / OPTIONAL)  - returns the formatted date and time.
//  cbDateTime  (IN / OUT)       - If pszDateTime is NULL, then the required length
//                              of pszDateTime is returned.  
//                              Otherwise, contains the length of pszDateTime.
///////////////////////////////////////////////////////////////////////////
CString CCertificate::GetValidNotBefore()
{
//  _TRACE (1, L"Entering CCertificate::GetValidNotBefore\n");
    ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
    ASSERT (m_pCertInfo);
    if ( m_pCertInfo )
    {
        // Format date/time string if not already present
        if ( m_szValidNotBefore.IsEmpty () )
        {
            HRESULT hr = FormatDate (m_pCertInfo->NotBefore, m_szValidNotBefore);
            if ( !SUCCEEDED (hr) )
                return _T("");
        }
    }
    else
        return _T("");

//  _TRACE (-1, L"Leaving CCertificate::GetValidNotBefore\n");
    return m_szValidNotBefore;
}

///////////////////////////////////////////////////////////////////////////
//  GetValidNotAfter ()
//
//  pszDateTime (IN / OPTIONAL)  - returns the formatted date and time.
//  cbDateTime  (IN / OUT)       - If pszDateTime is NULL, then the required length
//                              of pszDateTime is returned.  
//                              Otherwise, contains the length of pszDateTime.
///////////////////////////////////////////////////////////////////////////
CString CCertificate::GetValidNotAfter ()
{
//  _TRACE (1, L"Entering CCertificate::GetValidNotAfter\n");
    ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
    ASSERT (m_pCertInfo);
    if ( m_pCertInfo )
    {
        // Format date/time string if not already present
        if ( m_szValidNotAfter.IsEmpty () )
        {
            HRESULT hr = FormatDate (m_pCertInfo->NotAfter, m_szValidNotAfter);
            if ( !SUCCEEDED (hr) )
                m_szValidNotAfter = _T("");
        }
    }
    else
        m_szValidNotAfter = _T("");

//  _TRACE (-1, L"Leaving CCertificate::GetValidNotAfter\n");
    return m_szValidNotAfter;
}


CString CCertificate::GetEnhancedKeyUsage ()
{
//  _TRACE (1, L"Entering CCertificate::GetEnhancedKeyUsage\n");
    ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
    ASSERT (m_pCertInfo);
    if ( m_pCertInfo )
    {
        // Format date/time string if not already present
        if ( m_szEnhancedKeyUsage.IsEmpty () )
        {
            FormatEnhancedKeyUsagePropertyString (
                    m_szEnhancedKeyUsage);
        }
    }
    else
        m_szEnhancedKeyUsage = _T("");

//  _TRACE (-1, L"Leaving CCertificate::GetEnhancedKeyUsage\n");
    return m_szEnhancedKeyUsage;
}


bool CCertificate::FormatEnhancedKeyUsagePropertyString (CString& string)
{
//  _TRACE (1, L"Entering CCertificate::FormatEnhancedKeyUsagePropertyString\n");
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
    BOOL    bReturn = TRUE;
    DWORD   cbUsage = 0;


    bReturn = ::CertGetEnhancedKeyUsage (m_pCertContext,  0, // get extension and property
            NULL, &cbUsage);
    if ( bReturn )
    {
        CString usageName;

        PCERT_ENHKEY_USAGE pUsage = (PCERT_ENHKEY_USAGE) ::LocalAlloc (LPTR, cbUsage);
        if ( pUsage )
        {
            bReturn = ::CertGetEnhancedKeyUsage (m_pCertContext,  0, // get extension and property
                    pUsage, &cbUsage);
            if ( bReturn )
            {
                if ( !pUsage->cUsageIdentifier )
                {
                    switch (GetLastError ())
                    {
                    case CRYPT_E_NOT_FOUND:
                        VERIFY (string.LoadString (IDS_ANY));
                        break;

                    case 0:
                        VERIFY (string.LoadString (IDS_NONE));
                        break;

                    default:
                        break;
                    }
                }
                else
                {
                    for (DWORD dwIndex = 0; dwIndex < pUsage->cUsageIdentifier; dwIndex++)
                    {
                        if ( MyGetOIDInfo (usageName, pUsage->rgpszUsageIdentifier[dwIndex]) )
                        {
                            // add delimeter if not first iteration
                            if ( dwIndex )
                                string += _T(", ");
                            string += usageName;
                        }
                    }
                }
            }
            else
            {
                switch (GetLastError ())
                {
                case CRYPT_E_NOT_FOUND:
                    VERIFY (string.LoadString (IDS_ANY));
                    break;

                case 0:
                    VERIFY (string.LoadString (IDS_NONE));
                    break;

                default:
                    break;
                }
            }

            ::LocalFree (pUsage);
        }
        else
        {
            bReturn = FALSE;
        }
    }
    else
    {
        switch (GetLastError ())
        {
        case CRYPT_E_NOT_FOUND:
            VERIFY (string.LoadString (IDS_ANY));
            break;

        case 0:
            VERIFY (string.LoadString (IDS_NONE));
            break;

        default:
            break;
        }
    }

//  _TRACE (-1, L"Leaving CCertificate::FormatEnhancedKeyUsagePropertyString\n");
    return bReturn ? true : false;
}

///////////////////////////////////////////////////////////////////////////
//  GetAlternateIssuerName ()
//
//  pszName (IN / OPTIONAL)  - returns the alternate issuer name.  An empty 
//                              string is a valid return value
//  cbName  (IN / OUT)       - If pszName is NULL, then the required length
//                              of pszName is returned.  
//                              Otherwise, contains the length of pszName.
///////////////////////////////////////////////////////////////////////////
CString CCertificate::GetAlternateIssuerName ()
{
//  _TRACE (1, L"Entering CCertificate::GetAlternateIssuerName\n");
    ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
    ASSERT (m_pCertInfo);
    if ( m_pCertInfo )
    {
        if ( !(m_fieldChecked & FIELD_ISSUER_ALT_NAME) )
        {
            HRESULT hr = ConvertAltNameToString (_T(szOID_ISSUER_ALT_NAME),
                    CERT_ALT_NAME_URL, m_szAltIssuerName);
            ASSERT (SUCCEEDED (hr));
            if ( !SUCCEEDED (hr) )
                m_szAltIssuerName = _T("");
            m_fieldChecked |= FIELD_ISSUER_ALT_NAME;
        }
    }
    else
        m_szAltIssuerName = _T("");

//  _TRACE (-1, L"Leaving CCertificate::GetAlternateIssuerName\n");
    return m_szAltIssuerName;
}

///////////////////////////////////////////////////////////////////////////
//  GetAlternateSubjectName ()
//
//  pszName (IN / OPTIONAL)  - returns the alternate issuer name.  An empty 
//                              string is a valid return value
//  cbName  (IN / OUT)       - If pszName is NULL, then the required length
//                              of pszName is returned.  
//                              Otherwise, contains the length of pszName.
///////////////////////////////////////////////////////////////////////////
CString CCertificate::GetAlternateSubjectName ()
{
//  _TRACE (1, L"Entering CCertificate::GetAlternateSubjectName\n");
    ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
    ASSERT (m_pCertInfo);
    if ( m_pCertInfo )
    {
        if ( !(m_fieldChecked & FIELD_SUBJECT_ALT_NAME) )
        {
            HRESULT hr = ConvertAltNameToString (_T(szOID_SUBJECT_ALT_NAME),
                    CERT_ALT_NAME_URL, m_szAltSubjectName);
            if ( !SUCCEEDED (hr) )
                m_szAltSubjectName = _T("");
            m_fieldChecked |= FIELD_SUBJECT_ALT_NAME;
        }
    }
    else
        m_szAltSubjectName = _T("");

//  _TRACE (-1, L"Leaving CCertificate::GetAlternateSubjectName\n");
    return m_szAltSubjectName;
}

///////////////////////////////////////////////////////////////////////////
//  GetSerialNumber ()
//
//  pszSerNum (IN / OPTIONAL)   - returns the alternate issuer name.  An empty 
//                                  string is a valid return value
//  cbSerNum (IN / OUT)         - If pszSerNum is NULL, then the required length
//                                  of pszSerNum is returned.  
//                                  Otherwise, contains the length of pszSerNum.
///////////////////////////////////////////////////////////////////////////
CString CCertificate::GetSerialNumber ()
{
//  _TRACE (1, L"Entering CCertificate::GetSerialNumber\n");
    ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
    ASSERT (m_pCertInfo);
    if ( m_pCertInfo )
    {
        // Decode issuer name if not already present
        if ( m_szSerNum.IsEmpty () )
        {
            LPWSTR pwszText = 0;

            if ( SUCCEEDED (FormatSerialNoString (&pwszText, & (m_pCertInfo->SerialNumber))) )
            {
                m_szSerNum = pwszText;
                CoTaskMemFree (pwszText);
            }
        }
    }
    else
        m_szSerNum = _T("");
    
//  _TRACE (-1, L"Leaving CCertificate::GetSerialNumber\n");
    return m_szSerNum;
}

//////////////////////////////////////////////////////////////////////////////
//  ConvertAltNameToString ()
//
//  pszOID (IN)         - The OID of the alternate name to retrieve
//  dwNameChoice (IN)   - The type of alternate name to return
//  altName (OUT)       - The version of the desired alternate name indicated
//                          by dwNameChoice
//////////////////////////////////////////////////////////////////////////////
HRESULT CCertificate::ConvertAltNameToString(LPCWSTR pszOID, const DWORD dwNameChoice, CString & altName)
{
//  _TRACE (1, L"Entering CCertificate::ConvertAltNameToString\n");
    ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
    HRESULT hr = S_OK;

    ASSERT (pszOID);
    if ( !pszOID )
        return E_POINTER;

    // Iterate through the extensions until the one indicated by the
    // passed-in pszOID is found.
    for (DWORD  index = 0; index < m_pCertInfo->cExtension; index++)
    {
        ASSERT (m_pCertInfo->rgExtension);
        if ( !m_pCertInfo->rgExtension )
        {
            hr = E_FAIL;
            break;
        }

        // security review 2/22/2002 BryanWal ok
        size_t  len = strlen (m_pCertInfo->rgExtension[index].pszObjId);
        LPWSTR  wcsObjId = new WCHAR[len+1];
        if ( wcsObjId )
        {
            // security review BryanWal 02/02/2002 ok
            ::ZeroMemory (wcsObjId, (len + 1) * sizeof (WCHAR));
            // security review 2/22/2002 BryanWal ok
            mbstowcs (wcsObjId,  m_pCertInfo->rgExtension[index].pszObjId, len+1);  // last arg includes NULL terminator

            if ( !wcscmp (wcsObjId, pszOID) )
            {
                CERT_ALT_NAME_INFO  nameInfo;
                DWORD               cbNameInfo = sizeof (CERT_ALT_NAME_INFO);

                BOOL    bResult = CryptDecodeObject(
                        MY_ENCODING_TYPE,
                        X509_ALTERNATE_NAME,    // in
                        m_pCertInfo->rgExtension[index].Value.pbData,   // in
                        m_pCertInfo->rgExtension[index].Value.cbData,   // in
                        0,  // in
                        (void *) &nameInfo, // out
                        &cbNameInfo);   // in/out
                ASSERT (bResult);
                if ( bResult )
                {
                    //  We've found the right extension, now iterate through
                    //  the alternate names until we find the desired type.
                    for (DWORD  dwAltEntryIndex = 0; dwAltEntryIndex < nameInfo.cAltEntry; dwAltEntryIndex++)
                    {
                        if ( nameInfo.rgAltEntry[dwAltEntryIndex].dwAltNameChoice ==
                                dwNameChoice )
                        {
                            altName = nameInfo.rgAltEntry[dwAltEntryIndex].pwszURL;
                            break;
                        }
                    }
                }
                else
                    hr = E_UNEXPECTED;
                break;
            }
            delete [] wcsObjId;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

//  _TRACE (-1, L"Leaving CCertificate::ConvertAltNameToString\n");
    return hr;
}


CCertStore* CCertificate::GetCertStore() const  
{
//  _TRACE (0, L"Entering and leaving CCertificate::GetCertStore\n");
    ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
    return m_pCertStore;
}

PCCERT_CONTEXT CCertificate::GetCertContext() const
{
//  _TRACE (0, L"Entering and leaving CCertificate::GetCertContext\n");
    ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
    return m_pCertContext;
}

bool CCertificate::IsValid()
{
//  _TRACE (1, L"Entering CCertificate::IsValid\n");
    ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
    bool        bIsValid = false;
    ASSERT (m_pCertInfo);
    if ( m_pCertInfo )
    {
        FILETIME    systemTime;


        ::GetSystemTimeAsFileTime (&systemTime);
        LONG    lBefore = ::CompareFileTime (&m_pCertInfo->NotBefore, &systemTime);
        LONG    lAfter = ::CompareFileTime (&systemTime, &m_pCertInfo->NotAfter);
        if ( lBefore < 1 && lAfter < 1 )
            bIsValid = true;
    }

//  _TRACE (-1, L"Leaving CCertificate::IsValid\n");
    return bIsValid;
}




const SPECIAL_STORE_TYPE CCertificate::GetStoreType () const
{
//  _TRACE (0, L"Entering and leaving CCertificate::GetStoreType\n");
    ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
    if ( m_pCertStore )
        return m_pCertStore->GetStoreType ();
    else
        return NO_SPECIAL_TYPE;
}

void CCertificate::Refresh()
{
//  _TRACE (1, L"Entering CCertificate::Refresh\n");
    ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
    // Clearing all fields forces rereading of the data.
    m_szAltIssuerName = L"";
    m_szAltSubjectName = L"";
    m_szAuthorityKeyID = L"";
    m_szEnhancedKeyUsage = L"";
    m_szFriendlyName = L"";
    m_szIssuerName = L"";
    m_szMD5Hash = L"";
    m_szPolicyURL = L"";
    m_szSerNum = L"";
    m_szSHAHash = L"";
    m_szSubjectKeyID = L"";
    m_szSubjectName = L"";
    m_szValidNotAfter = L"";
    m_szValidNotBefore = L"";
    m_fieldChecked = 0;
//  _TRACE (-1, L"Leaving CCertificate::Refresh\n");
}

CString CCertificate::GetMD5Hash()
{
//  _TRACE (1, L"Entering CCertificate::GetMD5Hash\n");
    ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
    ASSERT (m_pCertContext);
    if ( m_pCertContext && m_szMD5Hash.IsEmpty ())
    {
        m_szMD5Hash = GetGenericHash (CERT_MD5_HASH_PROP_ID);
    }
//  _TRACE (-1, L"Leaving CCertificate::GetMD5Hash\n");
    return m_szMD5Hash;
}

CString CCertificate::GetSHAHash()
{
//  _TRACE (1, L"Entering CCertificate::GetSHAHash\n");
    ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
    ASSERT (m_pCertContext);
    if ( m_pCertContext && m_szSHAHash.IsEmpty ())
    {
        m_szSHAHash = GetGenericHash (CERT_SHA1_HASH_PROP_ID);
    }
//  _TRACE (-1, L"Leaving CCertificate::GetSHAHash\n");
    return m_szSHAHash;
}



CString CCertificate::GetGenericHash(DWORD dwPropId)
{
//  _TRACE (1, L"Entering CCertificate::GetGenericHash\n");
    ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
    CString szHash;


    DWORD   cbData = 0;
    BOOL    bReturn = ::CertGetCertificateContextProperty (
            m_pCertContext,
            dwPropId,
            NULL,
            &cbData);
    if ( bReturn )
    {
        cbData += 2;  // for null terminator
        BYTE* pCertHash = new BYTE[cbData];
        if ( pCertHash )
        {
            // security review 2/22/2002 BryanWal ok
            ::ZeroMemory (pCertHash, cbData);
            bReturn = CertGetCertificateContextProperty (
                    m_pCertContext,
                    dwPropId,
                    pCertHash,
                    &cbData);
            ASSERT (bReturn);
            if ( bReturn )
            {
                DataToHex (pCertHash, szHash, cbData, false);
            }
            delete [] pCertHash;
        }
    }
//  _TRACE (-1, L"Leaving CCertificate::GetGenericHash\n");
    return szHash;  
}


int CCertificate::CompareExpireDate(const CCertificate & cert) const
{
//  _TRACE (1, L"Entering CCertificate::CompareExpireDate\n");
    ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
    int compVal = 0;

    ASSERT (m_pCertInfo && cert.m_pCertInfo);
    if ( m_pCertInfo && cert.m_pCertInfo )
    {
        compVal = ::CompareFileTime (&m_pCertInfo->NotAfter, 
                &cert.m_pCertInfo->NotAfter);
    }

//  _TRACE (-1, L"Leaving CCertificate::CompareExpireDate\n");
    return compVal;
}

bool CCertificate::CanDelete()
{
//  _TRACE (1, L"Entering CCertificate::CanDelete\n");
    if ( m_pCertContext && !(m_fieldChecked & FIELD_CAN_DELETE) )
    {   
        DWORD   dwAccessFlags = 0;
        DWORD   cbData = sizeof (DWORD);
        BOOL bResult = ::CertGetCertificateContextProperty (
                m_pCertContext,
                CERT_ACCESS_STATE_PROP_ID,
                &dwAccessFlags,
                &cbData);
        if ( bResult )
        {
            if ( dwAccessFlags & CERT_ACCESS_STATE_WRITE_PERSIST_FLAG )
                m_bCanDelete = true;
        }
        m_fieldChecked |= FIELD_CAN_DELETE;
    }

//  _TRACE (-1, L"Leaving CCertificate::CanDelete\n");
    return m_bCanDelete;
}

bool CCertificate::IsReadOnly()
{
    bool    bResult = false;
    
    if ( m_pCertStore )
        bResult = (m_pCertStore->IsReadOnly () || !CanDelete ());

    return bResult;
}

bool CCertificate::IsArchived()
{
//  _TRACE (1, L"Entering CCertificate::IsArchived\n");
    if ( m_pCertContext && !(m_fieldChecked & FIELD_IS_ARCHIVED) )
    {   
        DWORD   cbData = sizeof (DWORD);
        BOOL bResult = ::CertGetCertificateContextProperty (
                m_pCertContext,
                CERT_ARCHIVED_PROP_ID,
                NULL,
                &cbData);
        if ( bResult )
        {
            m_bIsArchived = true;
        }
        else
            m_bIsArchived = false;
        m_fieldChecked |= FIELD_IS_ARCHIVED;
    }

//  _TRACE (-1, L"Leaving CCertificate::IsArchived\n");
    return m_bIsArchived;
}

BOOL CCertificate::DeleteFromStore(bool bDoCommit)
{
    _TRACE (1, L"Entering CCertificate::DeleteFromStore\n");
    BOOL    bResult = FALSE;

    if ( m_pCertStore )
    {
        PCCERT_CONTEXT pCertContext = GetNewCertContext ();
        if ( pCertContext )
        {
            bResult = ::CertDeleteCertificateFromStore (pCertContext);
            if ( bResult )
            {
                m_pCertStore->InvalidateCertCount ();
                m_pCertStore->SetDirty ();

                if ( bDoCommit )
                {
                    m_pCertStore->SetDeleting ();
                    HRESULT hr = m_pCertStore->Commit ();
                    m_pCertStore->SetAdding ();
                    if ( SUCCEEDED (hr) )
                        m_pCertStore->Resync ();
                    else
                        bResult = FALSE;
                }
                m_pCertStore->Release ();
                m_pCertStore = 0;
            }
        }
    }

    _TRACE (-1, L"Leaving CCertificate::DeleteFromStore\n");
    return bResult;
}

PCCERT_CONTEXT CCertificate::GetNewCertContext()
{
    PCCERT_CONTEXT  pCertContext = 0;

    if ( m_pCertStore )
    {
        HCERTSTORE      hCertStore = m_pCertStore->GetStoreHandle ();
        if ( hCertStore )
        {
            DWORD   cbData = 20;
            BYTE    certHash[20];
            BOOL bReturn = ::CertGetCertificateContextProperty (
                    m_pCertContext,
                    CERT_SHA1_HASH_PROP_ID,
                    certHash,
                    &cbData);
            ASSERT (bReturn);
            if ( bReturn )
            {
                CRYPT_DATA_BLOB blob = {sizeof (certHash), certHash};
                pCertContext = CertFindCertificateInStore(
                    hCertStore,
                    0,
                    0,
                    CERT_FIND_SHA1_HASH,
                    &blob,
                    0);
                if ( pCertContext )
                {
                    ::CertFreeCertificateContext (m_pCertContext);
                    m_pCertContext = ::CertDuplicateCertificateContext (pCertContext);
                }
            }
        }
    }

    return pCertContext;
}

CString CCertificate::FormatStatus()
{
    CString status;

    // security review 2/22/2002 BryanWal ok
    status.FormatMessage (L"%1  %2",
            (IsReadOnly () ? L"R" : L" "),
            (IsArchived () ? L"A" : L" "));

    return status;
}



//////////////////////////////////////////////////////////////////////////////////////
// Stolen from private\ispu\ui\cryptui\frmtutil.cpp
//////////////////////////////////////////////////////////////////////////////////////
const WCHAR     RgwchHex[] = {'0', '1', '2', '3', '4', '5', '6', '7',
                              '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

HRESULT CCertificate::FormatSerialNoString(LPWSTR *ppString, CRYPT_INTEGER_BLOB const *pblob)
{
    if ( !ppString || !pblob )
        return E_POINTER;

    DWORD                 i = 0;
    LPBYTE                pb;
    DWORD                 numCharsInserted = 0;

    //
    // calculate size needed
    //
    pb = &pblob->pbData[pblob->cbData-1];
    while (pb >= &pblob->pbData[0]) 
    {
        if (numCharsInserted == 4)
        {
            i += sizeof(WCHAR);
            numCharsInserted = 0;
        }
        else
        {
            i += 2 * sizeof(WCHAR);
            pb--;
            numCharsInserted += 2;
        }
    }

    if (NULL == (*ppString = (LPWSTR) CoTaskMemAlloc (i+sizeof(WCHAR))))
    {
        return E_OUTOFMEMORY;
    }

    // fill the buffer
    i=0;
    numCharsInserted = 0;
    pb = &pblob->pbData[pblob->cbData-1];
    while (pb >= &pblob->pbData[0]) 
    {
        if (numCharsInserted == 4)
        {
            (*ppString)[i++] = L' ';
            numCharsInserted = 0;
        }
        else
        {
            (*ppString)[i++] = RgwchHex[(*pb & 0xf0) >> 4];
            (*ppString)[i++] = RgwchHex[*pb & 0x0f];
            pb--;
            numCharsInserted += 2;
        }
    }
    (*ppString)[i] = 0;

    return S_OK;
}


CString CCertificate::GetDescription()
{
    ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
    if ( m_pCertContext && m_szDescription.IsEmpty () )
    {   
        AFX_MANAGE_STATE (AfxGetStaticModuleState ());
        DWORD   cbData = 0;
        BOOL bResult = ::CertGetCertificateContextProperty (
                m_pCertContext,
                CERT_DESCRIPTION_PROP_ID,
                NULL,
                &cbData);
        if ( bResult )
        {
            LPWSTR  pszName = new WCHAR[cbData];
            if ( pszName )
            {
                // security review 2/22/2002 BryanWal ok
                ::ZeroMemory (pszName, cbData*sizeof (WCHAR));
                bResult = ::CertGetCertificateContextProperty (
                        m_pCertContext,
                        CERT_DESCRIPTION_PROP_ID,
                        pszName,
                        &cbData);
                ASSERT (bResult);
                if ( bResult )
                {
                    m_szDescription = pszName;
                }
                delete [] pszName;
            }
        }
        else
        {
            DWORD   dwErr = GetLastError ();
            if ( CRYPT_E_NOT_FOUND == dwErr )
            {
                _TRACE (0, L"CertGetCertificateContextProperty (CERT_DESCRIPTION_PROP_ID) found no description.\n");
            }
            else
            {
                _TRACE (0, L"CertGetCertificateContextProperty (CERT_DESCRIPTION_PROP_ID) failed: 0x%x\n", dwErr);
            }
        }
    }
    return m_szDescription;
}

HRESULT CCertificate::SetDescription(const CString &szDescription)
{
    _TRACE (1, L"Entering CCertificate::SetDescription (%s)\n", 
            (PCWSTR) szDescription);
    HRESULT         hr = S_OK;
    CRYPT_DATA_BLOB cryptDataBlob;
    // security review 2/22/2002 BryanWal ok
    ::ZeroMemory (&cryptDataBlob, sizeof (cryptDataBlob));
    cryptDataBlob.pbData = (LPBYTE) (PCWSTR) szDescription;
    // security review 2/22/2002 BryanWal ok
    cryptDataBlob.cbData = (DWORD) (wcslen (szDescription) + 1) * sizeof (WCHAR);
 
    BOOL bResult = ::CertSetCertificateContextProperty (m_pCertContext,
            CERT_DESCRIPTION_PROP_ID, 0, &cryptDataBlob);
    ASSERT (bResult);
    if ( bResult )
    {
        m_szDescription = szDescription;
    }
    else
    {
        DWORD dwErr = GetLastError ();
        _TRACE (0, L"CertSetCertificateContextProperty (CERT_DESCRIPTION_PROP_ID, %s) failed: %d\n",
                (PCWSTR) szDescription, dwErr);
        hr = HRESULT_FROM_WIN32 (dwErr);
    }

    _TRACE (1, L"Entering CCertificate::SetDescription (%s): 0x%x\n", 
            (PCWSTR) szDescription, hr);
    return hr;
}

HRESULT CCertificate::SetLastModified ()
{
    HRESULT hr = S_OK;

    if ( m_pCertContext )
    {
        SYSTEMTIME  st;
        FILETIME    ft;

        GetSystemTime (&st);

        VERIFY (SystemTimeToFileTime(&st, &ft));
        CRYPT_DATA_BLOB cryptDataBlob;
        // security review 2/22/2002 BryanWal ok
        ::ZeroMemory (&cryptDataBlob, sizeof (cryptDataBlob));
        cryptDataBlob.pbData = (LPBYTE) &ft;
        cryptDataBlob.cbData = sizeof (FILETIME);

        BOOL bResult = ::CertSetCertificateContextProperty (
                m_pCertContext,
                CERT_DATE_STAMP_PROP_ID, 0, &cryptDataBlob);
        ASSERT (bResult);
        if ( !bResult )
        {
            DWORD   dwErr = GetLastError ();
            _TRACE (0, L"CertSetCertificateContextProperty (CERT_DATE_STAMP_PROP_ID) failed: %d\n",
                    dwErr);
            hr = HRESULT_FROM_WIN32 (dwErr);
        }
    }

    return hr;
}

CString CCertificate::GetShortLastModified ()
{
    return GetLastModified (DATE_SHORTDATE);
}

CString CCertificate::GetLongLastModified ()
{
    return GetLastModified (DATE_LONGDATE);
}

///////////////////////////////////////////////////////////////////////////////
//
// Method:  GetLastModified
// Purpose: Get the date stamp property of the cert and format for display
// Inputs:  dwDateFlags - as defined in SDK, specify DATE_SHORTDATE or 
//              DATE_LONGDATE
//          bRetryIfNotPresent - to prevent stack overflow. Used if the property
//              is not set, to set the property to the current time and
//              retrieve again.
//
// Output:  locale-formatted date and time string
//
///////////////////////////////////////////////////////////////////////////////
CString CCertificate::GetLastModified(DWORD dwDateFlags, bool bRetryIfNotPresent /* true */)
{
    _TRACE (1, L"Entering CCertificate::GetLastModified ()\n");
    CString szDate;

    ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
    if ( m_pCertContext )
    {   
        AFX_MANAGE_STATE (AfxGetStaticModuleState ());
        FILETIME    ft;
        // security review 2/22/2002 BryanWal ok
        ::ZeroMemory (&ft, sizeof (ft));
        DWORD       cbData = sizeof (ft);
        BOOL bResult = ::CertGetCertificateContextProperty (
                m_pCertContext,
                CERT_DATE_STAMP_PROP_ID,
                &ft,
                &cbData);
        if ( bResult )
        {
            VERIFY (SUCCEEDED (FormatDate (ft, szDate, dwDateFlags, true)) );
        }
        else
        {
            DWORD   dwErr = GetLastError ();
            _TRACE (0, L"CertGetCertificateContextProperty (CERT_DATE_STAMP_PROP_ID) returned 0x%x\n",
                    dwErr);
            if ( bRetryIfNotPresent && CRYPT_E_NOT_FOUND == dwErr )
            {
                // NTRAID# 461474 SAFER:  last modified date is being updated 
                // everytime the rules are refreshed.

                GetNewCertContext ();
                if ( SUCCEEDED (SetLastModified ()) )  // not present - set the value
                {
                    szDate = GetLastModified (dwDateFlags, false);
                    CCertStore* pCertStore = GetCertStore ();
                    if ( pCertStore )
                    {
                        pCertStore->SetDirty ();
                        pCertStore->Commit ();
                    }
                }
            }

            dwErr = GetLastError ();
            if ( CRYPT_E_NOT_FOUND == dwErr )
            {
                _TRACE (0, L"CertGetCertificateContextProperty (CERT_DATE_STAMP_PROP_ID) found no property.\n");
            }
            else
            {
                _TRACE (0, L"CertGetCertificateContextProperty (CERT_DATE_STAMP_PROP_ID) failed: 0x%x\n", dwErr);
            }
        }
    }

    _TRACE (-1, L"Leaving CCertificate::GetLastModified (): %s\n", (PCWSTR) szDate);
    return szDate;
}

HRESULT CCertificate::GetLastModifiedFileTime (FILETIME& ft)
{
    HRESULT hr = S_OK;

    ASSERT (CERTMGR_CERTIFICATE == m_objecttype);
    ASSERT (m_pCertContext);
    if ( m_pCertContext )
    {   
        DWORD       cbData = sizeof (ft);
        BOOL bResult = ::CertGetCertificateContextProperty (
                m_pCertContext,
                CERT_DATE_STAMP_PROP_ID,
                &ft,
                &cbData);
        if ( !bResult )
        {
            DWORD   dwErr = GetLastError ();
            if ( CRYPT_E_NOT_FOUND == dwErr )
            {
                _TRACE (0, L"CertGetCertificateContextProperty (CERT_DATE_STAMP_PROP_ID) found no property.\n");
            }
            else
            {
                _TRACE (0, L"CertGetCertificateContextProperty (CERT_DATE_STAMP_PROP_ID) failed: 0x%x\n", dwErr);
            }
            hr = HRESULT_FROM_WIN32 (dwErr);
        }
    }
    else
        hr = E_FAIL;

    return hr;
}

BOOL CCertificate::operator==(CCertificate& rCert)
{
    if ( GetMD5Hash () == rCert.GetMD5Hash () )
        return TRUE;
    else
        return FALSE;
}

// NTRAID# 247237   Cert UI: Cert Snapin: Certificates snapin should show  template name
CString CCertificate::GetTemplateName()
{
    if ( m_pCertInfo && !(m_fieldChecked & FIELD_TEMPLATE_NAME) )
    {
        // Iterate through the extensions until szOID_CERTIFICATE_TEMPLATE is found.
        for (DWORD  index = 0; index < m_pCertInfo->cExtension; index++)
        {
            ASSERT (m_pCertInfo->rgExtension);
            if ( !m_pCertInfo->rgExtension )
                break;

            // security review 2/22/2002 BryanWal ok
            if ( !strcmp (szOID_CERTIFICATE_TEMPLATE, m_pCertInfo->rgExtension[index].pszObjId) )
            {
                m_szTemplateName = DecodeV2TemplateName (m_pCertInfo);
                if ( m_szTemplateName.IsEmpty () )
                {
                   m_szTemplateName = OriginalDecodeV2TemplateName (&(m_pCertInfo->rgExtension[index]));
                }
                break;
            } 
            // security review 2/22/2002 BryanWal ok
            else if ( !strcmp (szOID_ENROLL_CERTTYPE_EXTENSION, m_pCertInfo->rgExtension[index].pszObjId) )
            {
                m_szTemplateName = DecodeV1TemplateName (&(m_pCertInfo->rgExtension[index]));
                break;
            }
        }
        m_fieldChecked |= FIELD_TEMPLATE_NAME;
    }

    return m_szTemplateName;
}

// NTRAID# 247237   Cert UI: Cert Snapin: Certificates snapin should show  template name
CString CCertificate::DecodeV1TemplateName (PCERT_EXTENSION pCertExtension)
{
    CString szTemplateName;
    ASSERT (pCertExtension);
    if ( pCertExtension )
    {
        DWORD   cbValue = 0;

        if ( ::CryptDecodeObject(
                CRYPT_ASN_ENCODING,
                X509_UNICODE_ANY_STRING,
                pCertExtension->Value.pbData,
                pCertExtension->Value.cbData,
                0,
                0,
                &cbValue) )
        {
            CERT_NAME_VALUE* pCNValue = (CERT_NAME_VALUE*) 
                ::LocalAlloc(LPTR, cbValue);
            if ( pCNValue )
            {
                if ( ::CryptDecodeObject(
                        CRYPT_ASN_ENCODING,
                        X509_UNICODE_ANY_STRING,
                        pCertExtension->Value.pbData,
                        pCertExtension->Value.cbData,
                        0,
                        pCNValue,
                        &cbValue) )
                {
                    szTemplateName = (LPWSTR) pCNValue->Value.pbData;

                    // NTRAID# 395173 Certificates Snapin:The column "
                    // Certificate Template" should contain value of "Template 
                    // Name" for V1 templates
                    HCERTTYPE   hCertType = 0;
                    HRESULT hr = ::CAFindCertTypeByName (szTemplateName,
                            NULL,
                            CT_ENUM_MACHINE_TYPES | CT_ENUM_USER_TYPES,
                            &hCertType);
                    if ( SUCCEEDED (hr) )
                    {
                        PWSTR* rgwszProp = 0;

                        hr = ::CAGetCertTypePropertyEx (hCertType, 
                            CERTTYPE_PROP_FRIENDLY_NAME, &rgwszProp);
                        if ( SUCCEEDED (hr) && rgwszProp )
                        {
                            szTemplateName = *rgwszProp;
                            ::CAFreeCertTypeProperty (hCertType, rgwszProp);
                        }
                        else
                        {
                            _TRACE (0, L"CAGetCertTypePropertyEx (CERTTYPE_PROP_FRIENDLY_NAME) failed: 0x%x\n", hr);
                        }

                        ::CACloseCertType (hCertType);
                    }
                }
                else
                {
                    _TRACE (0, L"CryptDecodeObject (CRYPT_ASN_ENCODING, X509_UNICODE_ANY_STRING, ...) failed: 0x%x\n",
                            GetLastError ());
                }
                ::LocalFree (pCNValue);
            }
        }
        else
        {
            _TRACE (0, L"CryptDecodeObject (CRYPT_ASN_ENCODING, X509_UNICODE_ANY_STRING, ...) failed: 0x%x\n",
                    GetLastError ());
        }
    }

    return szTemplateName;
}



BOOL ConvertSzToWsz (
    OUT WCHAR **ppwsz,
    IN CHAR const *pch,
    IN LONG cch)
{
    HRESULT hr = S_OK;
    LONG cwc = 0;
    UINT codePage = ::GetACP ();

    *ppwsz = NULL;
    for (;;)
    {
        cwc = ::MultiByteToWideChar (codePage, 0, pch, cch, *ppwsz, cwc);
        if (0 >= cwc)
        {
            hr = HRESULT_FROM_WIN32 (GetLastError());
            _TRACE (0, L"MultiByteToWideChar () failed: 0x%x\n", hr);

            if (NULL != *ppwsz)
            {
                ::LocalFree(*ppwsz);
                *ppwsz = NULL;
            }
            break;
        }
        if (NULL != *ppwsz)
        {
            (*ppwsz)[cwc] = L'\0';
            hr = S_OK;
            break;
        }
        *ppwsz = (WCHAR *) ::LocalAlloc (LMEM_FIXED, (cwc + 1) * sizeof (WCHAR));
        if ( !*ppwsz )
        {
            hr = E_OUTOFMEMORY;
            break;
        }
    }
    if (S_OK != hr)
    {
        ::SetLastError (hr);
    }

    return (S_OK == hr);
}


HRESULT GetTemplateDisplayName(
    IN const CString& szTemplateObjId,
    CString& szDisplayName)
{
    HRESULT     hr = S_OK;
    PWSTR       pwszDisplayName = NULL;
    HCERTTYPE   hCertType = NULL;
    DWORD       dwFlags = 0;
    PWSTR*      apwszCertTypeName = NULL;

    dwFlags = CT_ENUM_USER_TYPES | CT_ENUM_MACHINE_TYPES;

    hr = ::CAFindCertTypeByName (szTemplateObjId, NULL, dwFlags, &hCertType);
    if ( HRESULT_FROM_WIN32 (ERROR_NOT_FOUND) == hr )
    {
        hr = ::CAFindCertTypeByName (
                szTemplateObjId,
                NULL,
                CT_FIND_BY_OID | dwFlags,
                &hCertType);
    }
    if ( SUCCEEDED (hr) )
    {
        hr = ::CAGetCertTypeProperty (
                hCertType,
                CERTTYPE_PROP_FRIENDLY_NAME,
                &apwszCertTypeName);
        if ( SUCCEEDED (hr) )
        {
            if ( apwszCertTypeName && apwszCertTypeName[0])
                szDisplayName = apwszCertTypeName[0];
        }
        else
        {
            _TRACE (0, L"CAGetCertTypeProperty (CERTTYPE_PROP_FRIENDLY_NAME) failed: 0x%x\n", hr);
        }
    }
    else
    {
        _TRACE (0, L"CAFindCertTypeByName (%s) failed: 0x%x\n", (PCWSTR) szTemplateObjId, hr);
    }

    if ( apwszCertTypeName )
        ::CAFreeCertTypeProperty (hCertType, apwszCertTypeName);

    if ( hCertType )
        ::CACloseCertType (hCertType);
    
    if ( pwszDisplayName )
        ::LocalFree (pwszDisplayName);

    return hr;
}

CString CCertificate::DecodeV2TemplateName (PCERT_INFO pCertInfo)
{
    CWaitCursor waitCursor;
    CString     szTemplateName;
    ASSERT (pCertInfo);
    if ( pCertInfo )
    {
        CERT_EXTENSION* pExt = ::CertFindExtension(
                szOID_CERTIFICATE_TEMPLATE,
                pCertInfo->cExtension,
                pCertInfo->rgExtension);
        if ( pExt )
        {
            DWORD               cbTemplate = 0;
            CERT_TEMPLATE_EXT*  pTemplate = NULL;

            BOOL bResult = ::CryptDecodeObjectEx(
                    X509_ASN_ENCODING,
                    X509_CERTIFICATE_TEMPLATE,
                    pExt->Value.pbData,
                    pExt->Value.cbData,
                    CRYPT_DECODE_ALLOC_FLAG,    // dwFlags
                    NULL,                       // use LocalAlloc and LocalFree
                    &pTemplate,
                    &cbTemplate);
            if (bResult && !pTemplate)
            {
                ::SetLastError((DWORD) HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
                bResult = FALSE;
            }

            if ( bResult )
            {
                WCHAR *pwszCertTypeObjId = NULL;
                CString szDisplayName;
                if ( ConvertSzToWsz(&pwszCertTypeObjId, pTemplate->pszObjId, -1) )
                {
                    HRESULT hr = GetTemplateDisplayName(pwszCertTypeObjId, szDisplayName);
                    if ( SUCCEEDED (hr) )
                    {
                        szTemplateName = szDisplayName;
                    }

                    if (NULL != pwszCertTypeObjId)
                    {
                        ::LocalFree(pwszCertTypeObjId);
                    }
                    if (NULL != pTemplate)
                    {
                        ::LocalFree(pTemplate);
                    }
                }
            }
        }
    }

    return szTemplateName;
}

// NTRAID# 247237   Cert UI: Cert Snapin: Certificates snapin should show  template name
CString CCertificate::OriginalDecodeV2TemplateName (PCERT_EXTENSION pCertExtension)
{
    CString szTemplateName;
    ASSERT (pCertExtension);
    if ( pCertExtension )
    {
        DWORD   cbData = 0;
   
        if ( CryptDecodeObject(X509_ASN_ENCODING,
                              szOID_CERTIFICATE_TEMPLATE,
                              pCertExtension->Value.pbData,
                              pCertExtension->Value.cbData,
                              0,
                NULL,
                              &cbData) )
        {
            CERT_TEMPLATE_EXT* pbTemplate = (CERT_TEMPLATE_EXT*) LocalAlloc(LPTR, cbData);
            if ( pbTemplate )
            {
                if ( CryptDecodeObject(X509_ASN_ENCODING,
                                      szOID_CERTIFICATE_TEMPLATE,
                                      pCertExtension->Value.pbData,
                                      pCertExtension->Value.cbData,
                                      0,
                                      pbTemplate,
                                      &cbData) )
                {
                    CString text;
                    CString description;

                    //copy the extension oid
                    if ( pbTemplate->pszObjId )
                    {
                        MyGetOIDInfo (szTemplateName, pbTemplate->pszObjId);
                    }
                }
                else
                {
                    _TRACE (0, L"CryptDecodeObject (X509_ASN_ENCODING, szOID_CERTIFICATE_TEMPLATE, ...) failed: 0x%x\n",
                            GetLastError ());
                }
                LocalFree (pbTemplate);
            }
        }
        else
        {
            _TRACE (0, L"CryptDecodeObject (X509_ASN_ENCODING, szOID_CERTIFICATE_TEMPLATE, ...) failed: 0x%x\n",
                    GetLastError ());
        }
    }

    return szTemplateName;
}

void CCertificate::SetStore (CCertStore* pStore)
{
    if ( !m_pCertStore && !pStore )
        return;

    if ( m_pCertStore && pStore )
    {
        if ( *m_pCertStore == *pStore )
            return;  // don't change if the same
    }

    if ( m_pCertStore )
    {
        m_pCertStore->Release ();
        m_pCertStore = 0;
    }

    

    if ( pStore )
    {
        m_pCertStore = pStore;
        m_pCertStore->AddRef ();
    }

    if ( m_pCertContext )
    {
        PCCERT_CONTEXT pCertContext = GetNewCertContext ();
        ::CertFreeCertificateContext (m_pCertContext);
        m_pCertInfo = 0;
        m_pCertContext = 0;
        
        m_pCertContext = pCertContext;
        if ( m_pCertContext )
            m_pCertInfo = m_pCertContext->pCertInfo;
    }
}

bool CCertificate::IsCertStillInStore() const
{
    bool    bCertFound = false;

    if ( m_pCertStore )
    {
        PCCERT_CONTEXT pFoundCertContext = 
                m_pCertStore->FindCertificate (0, CERT_FIND_EXISTING,
                (void*) m_pCertContext, NULL);

        if ( pFoundCertContext )
        {
            ::CertFreeCertificateContext (pFoundCertContext);
            bCertFound = true;
        }
    }

    return bCertFound;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\autoenrollmentpropertypage.cpp ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2002.
//
//  File:       AutoenrollmentPropertyPage.cpp
//
//  Contents:   Implementation of CAutoenrollmentPropertyPage
//
//----------------------------------------------------------------------------
// AutoenrollmentPropertyPage.cpp : implementation file
//

#include "stdafx.h"
#include <gpedit.h>
#include "AutoenrollmentPropertyPage.h"
#include "compdata.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern GUID g_guidExtension;
extern GUID g_guidRegExt;
extern GUID g_guidSnapin;

/////////////////////////////////////////////////////////////////////////////
// CAutoenrollmentPropertyPage property page

CAutoenrollmentPropertyPage::CAutoenrollmentPropertyPage(CCertMgrComponentData* pCompData,
        bool fIsComputerType) : 
    CHelpPropertyPage(CAutoenrollmentPropertyPage::IDD),
    m_dwAutoenrollmentFlags (0),
    m_hAutoenrollmentFlagsKey (0),
    m_hGroupPolicyKey (0),
    m_pGPEInformation (pCompData ? pCompData->GetGPEInformation () : 0),
    m_fIsComputerType (fIsComputerType)
{
    if ( m_pGPEInformation )
    {
        HRESULT hResult = m_pGPEInformation->GetRegistryKey (m_fIsComputerType ?
                GPO_SECTION_MACHINE : GPO_SECTION_USER,
		        &m_hGroupPolicyKey);
        ASSERT (SUCCEEDED (hResult));
        if ( SUCCEEDED (hResult) )
		    GPEGetAutoenrollmentFlags ();
    } 
    else 
        RSOPGetAutoenrollmentFlags (pCompData);
}

CAutoenrollmentPropertyPage::~CAutoenrollmentPropertyPage()
{
    if ( m_hAutoenrollmentFlagsKey )
        ::RegCloseKey (m_hAutoenrollmentFlagsKey);
}

void CAutoenrollmentPropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CHelpPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAutoenrollmentPropertyPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAutoenrollmentPropertyPage, CHelpPropertyPage)
	//{{AFX_MSG_MAP(CAutoenrollmentPropertyPage)
	ON_BN_CLICKED(IDC_AUTOENROLL_DISABLE_ALL, OnAutoenrollDisableAll)
	ON_BN_CLICKED(IDC_AUTOENROLL_ENABLE, OnAutoenrollEnable)
	ON_BN_CLICKED(IDC_AUTOENROLL_ENABLE_PENDING, OnAutoenrollEnablePending)
	ON_BN_CLICKED(IDC_AUTOENROLL_ENABLE_TEMPLATE, OnAutoenrollEnableTemplate)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAutoenrollmentPropertyPage message handlers

BOOL CAutoenrollmentPropertyPage::OnInitDialog()
{
    CHelpPropertyPage::OnInitDialog();

    // If this is the RSOP, make it read-only
    if ( !m_pGPEInformation )
    {
        // Make the page read-only
        GetDlgItem (IDC_AUTOENROLL_DISABLE_ALL)->EnableWindow (FALSE);
        GetDlgItem (IDC_AUTOENROLL_ENABLE)->EnableWindow (FALSE);
        GetDlgItem (IDC_AUTOENROLL_ENABLE_PENDING)->EnableWindow (FALSE);
        GetDlgItem (IDC_AUTOENROLL_ENABLE_TEMPLATE)->EnableWindow (FALSE);
    }

    if ( m_dwAutoenrollmentFlags & AUTO_ENROLLMENT_DISABLE_ALL )
        SendDlgItemMessage (IDC_AUTOENROLL_DISABLE_ALL, BM_SETCHECK, BST_CHECKED);
    else
        SendDlgItemMessage (IDC_AUTOENROLL_ENABLE, BM_SETCHECK, BST_CHECKED);

    if ( m_dwAutoenrollmentFlags & (AUTO_ENROLLMENT_ENABLE_MY_STORE_MANAGEMENT | AUTO_ENROLLMENT_ENABLE_PENDING_FETCH) )
        SendDlgItemMessage (IDC_AUTOENROLL_ENABLE_PENDING, BM_SETCHECK, BST_CHECKED);

    if ( m_dwAutoenrollmentFlags & AUTO_ENROLLMENT_ENABLE_TEMPLATE_CHECK )
        SendDlgItemMessage (IDC_AUTOENROLL_ENABLE_TEMPLATE, BM_SETCHECK, BST_CHECKED);

    EnableControls ();

	return TRUE;  // return TRUE unless you set the focus to a control
      // EXCEPTION: OCX Property Pages should return FALSE
}

void CAutoenrollmentPropertyPage::OnOK()
{
    if ( m_pGPEInformation )
    {
	    SaveCheck ();
	    CHelpPropertyPage::OnOK ();
    }
}

void CAutoenrollmentPropertyPage::SaveCheck()
{
    ASSERT (m_pGPEInformation);
    if ( m_pGPEInformation )
    {
        m_dwAutoenrollmentFlags = 0;
        if ( BST_CHECKED == SendDlgItemMessage (IDC_AUTOENROLL_DISABLE_ALL, BM_GETCHECK) )
            m_dwAutoenrollmentFlags |= AUTO_ENROLLMENT_DISABLE_ALL;
        else
        {
            if ( BST_CHECKED == SendDlgItemMessage (IDC_AUTOENROLL_ENABLE_PENDING, BM_GETCHECK) )
                m_dwAutoenrollmentFlags |= AUTO_ENROLLMENT_ENABLE_MY_STORE_MANAGEMENT | AUTO_ENROLLMENT_ENABLE_PENDING_FETCH;

            if ( BST_CHECKED == SendDlgItemMessage (IDC_AUTOENROLL_ENABLE_TEMPLATE, BM_GETCHECK) )
                m_dwAutoenrollmentFlags |= AUTO_ENROLLMENT_ENABLE_TEMPLATE_CHECK;
        }

        SetGPEFlags (); // save flag to registry
    }
}


void CAutoenrollmentPropertyPage::SetGPEFlags ()
{
    ASSERT (m_pGPEInformation);
    if ( m_pGPEInformation )
    {
        DWORD   cbData = sizeof (m_dwAutoenrollmentFlags);
        LONG    lResult = ::RegSetValueEx (m_hAutoenrollmentFlagsKey,
				    AUTO_ENROLLMENT_POLICY, // address of value to set
				    0,              // reserved
				    REG_DWORD,          // flag for value type
				    (CONST BYTE *) &m_dwAutoenrollmentFlags, // address of value data
				    cbData);        // size of value data);
        ASSERT (ERROR_SUCCESS == lResult);
        if ( ERROR_SUCCESS == lResult )
		{
			// TRUE means we're changing the machine policy only
            m_pGPEInformation->PolicyChanged (m_fIsComputerType ? TRUE : FALSE, 
                    TRUE, &g_guidExtension, &g_guidSnapin);
            m_pGPEInformation->PolicyChanged (m_fIsComputerType ? TRUE : FALSE, 
                    TRUE, &g_guidRegExt, &g_guidSnapin);
		}
		else
            DisplaySystemError (m_hWnd, lResult);
    }
}

void CAutoenrollmentPropertyPage::RSOPGetAutoenrollmentFlags(const CCertMgrComponentData* pCompData)
{
    if ( pCompData )
    {
        const CRSOPObjectArray* pObjectArray = 
                m_fIsComputerType ? pCompData->GetRSOPObjectArrayComputer () : 
                        pCompData->GetRSOPObjectArrayUser ();
        int     nIndex = 0;
        // NOTE: rsop object array is sorted first by registry key, then by precedence
        INT_PTR nUpperBound = pObjectArray->GetUpperBound ();

        while ( nUpperBound >= nIndex )
        {
            CRSOPObject* pObject = pObjectArray->GetAt (nIndex);
            if ( pObject )
            {
                // Consider only entries from this store
                // security review 2/22/2002 BryanWal ok
                if ( !_wcsicmp (AUTO_ENROLLMENT_KEY, pObject->GetRegistryKey ()) &&
						!_wcsicmp (AUTO_ENROLLMENT_POLICY, pObject->GetValueName ()) )
                {
					ASSERT (1 == pObject->GetPrecedence ());
                    m_dwAutoenrollmentFlags = pObject->GetDWORDValue ();
                    break;
                }
            }
            else
                break;

            nIndex++;
        }
    }
}

void CAutoenrollmentPropertyPage::GPEGetAutoenrollmentFlags()
{
    DWORD   dwDisposition = 0;

    LONG lResult = ::RegCreateKeyEx (m_hGroupPolicyKey, // handle of an open key
            AUTO_ENROLLMENT_KEY,     // address of subkey name
            0,       // reserved
            L"",       // address of class string
            REG_OPTION_NON_VOLATILE,      // special options flag
            // security review 2/22/2002 BryanWal ok
            KEY_ALL_ACCESS,    // desired security access
            NULL,     // address of key security structure
			&m_hAutoenrollmentFlagsKey,      // address of buffer for opened handle
		    &dwDisposition);  // address of disposition value buffer
	ASSERT (lResult == ERROR_SUCCESS);
    if ( lResult == ERROR_SUCCESS )
    {
        // Read value
        DWORD   dwType = REG_DWORD;
        DWORD   dwData = 0;
        DWORD   cbData = sizeof (dwData);

        // security review 2/22/2002 BryanWal ok
        lResult = ::RegQueryValueEx (m_hAutoenrollmentFlagsKey,       // handle of key to query
		        AUTO_ENROLLMENT_POLICY,  // address of name of value to query
			    0,              // reserved
	            &dwType,        // address of buffer for value type
		        (LPBYTE) &dwData,       // address of data buffer
			    &cbData);           // address of data buffer size);
		ASSERT (ERROR_SUCCESS == lResult || ERROR_FILE_NOT_FOUND == lResult);
        if ( ERROR_SUCCESS == lResult || ERROR_FILE_NOT_FOUND == lResult )
		{
            if ( REG_DWORD == dwType )
                m_dwAutoenrollmentFlags = dwData;
		}
        else
            DisplaySystemError (NULL, lResult);
    }
    else
        DisplaySystemError (NULL, lResult);
}

void CAutoenrollmentPropertyPage::DoContextHelp (HWND hWndControl)
{
    _TRACE (1, L"Entering CAutoenrollmentPropertyPage::DoContextHelp\n");
    static const DWORD help_map[] =
    {
        IDC_AUTOENROLL_DISABLE_ALL,         IDH_AUTOENROLL_DISABLE_ALL,
        IDC_AUTOENROLL_ENABLE,              IDH_AUTOENROLL_ENABLE,
        IDC_AUTOENROLL_ENABLE_PENDING,      IDH_AUTOENROLL_ENABLE_PENDING,
        IDC_AUTOENROLL_ENABLE_TEMPLATE,     IDH_AUTOENROLL_ENABLE_TEMPLATE,
        0, 0
    };
    if ( !::WinHelp (
        hWndControl,
        GetF1HelpFilename(),
        HELP_WM_HELP,
    (DWORD_PTR) help_map) )
    {
        _TRACE (0, L"WinHelp () failed: 0x%x\n", GetLastError ());    
    }
    _TRACE (-1, L"Leaving CAutoenrollmentPropertyPage::DoContextHelp\n");
}

void CAutoenrollmentPropertyPage::OnAutoenrollDisableAll() 
{
    if ( !(m_dwAutoenrollmentFlags & AUTO_ENROLLMENT_DISABLE_ALL) )
    {
        m_dwAutoenrollmentFlags |= AUTO_ENROLLMENT_DISABLE_ALL;
        SetModified (TRUE);
   	    SendDlgItemMessage (IDC_AUTOENROLL_ENABLE_PENDING, BM_SETCHECK, BST_UNCHECKED);
        SendDlgItemMessage (IDC_AUTOENROLL_ENABLE_TEMPLATE, BM_SETCHECK, BST_UNCHECKED);
    }
    EnableControls ();
}

void CAutoenrollmentPropertyPage::OnAutoenrollEnable() 
{
    if ( m_dwAutoenrollmentFlags & AUTO_ENROLLMENT_DISABLE_ALL )
    {
        m_dwAutoenrollmentFlags &= ~AUTO_ENROLLMENT_DISABLE_ALL;
        SetModified (TRUE);
    }
    EnableControls ();
}

void CAutoenrollmentPropertyPage::OnAutoenrollEnablePending() 
{
	SetModified (TRUE);
}

void CAutoenrollmentPropertyPage::OnAutoenrollEnableTemplate() 
{
    SetModified (TRUE);
    EnableControls ();
}

void CAutoenrollmentPropertyPage::EnableControls ()
{
    // Only change the enabling if this is not RSOP
    if ( m_pGPEInformation )
    {
        if ( BST_CHECKED == SendDlgItemMessage (IDC_AUTOENROLL_ENABLE, BM_GETCHECK) )
        {
            GetDlgItem (IDC_AUTOENROLL_ENABLE_PENDING)->EnableWindow (TRUE);
            GetDlgItem (IDC_AUTOENROLL_ENABLE_TEMPLATE)->EnableWindow (TRUE);
        }
        else
        {
            GetDlgItem (IDC_AUTOENROLL_ENABLE_PENDING)->EnableWindow (FALSE);
            GetDlgItem (IDC_AUTOENROLL_ENABLE_TEMPLATE)->EnableWindow (FALSE);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\certmgr.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       CertMgr.cpp
//
//  Contents:   Implementation of DLL Exports
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include <initguid.h>
#include <gpedit.h>
#include "CertMgr_i.c"
#include "about.h"      // CCertMgrAbout
#include "compdata.h" // CCertMgrSnapin, CCertMgrExtension
#pragma warning(push, 3)
#include <compuuid.h> // UUIDs for Computer Management
#include "uuids.h"
#include <efsstruc.h>
#include <sceattch.h>   // For Security Configuratino Editor snapin
#include <ntverp.h>     // VER_PRODUCTVERSION_STR, VERS_COMPANYNAME_STR
#include <typeinfo.h>
#pragma warning(pop)

#include <dsadminp.h>
#include <ntdsapi.h>

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


bool g_bSchemaIsW2K = false;

USE_HANDLE_MACROS ("CERTMGR (CertMgr.cpp)")                                        

LPCWSTR CM_HELP_TOPIC = L"sag_CMtopNode.htm";  
LPCWSTR CM_HELP_FILE = L"certmgr.chm"; 
LPCWSTR CM_LINKED_HELP_FILE = L"CMconcepts.chm";
LPCWSTR PKP_LINKED_HELP_FILE = L"SecSetConcepts.chm";
LPCWSTR PKP_HELP_FILE = L"secsettings.chm";
LPCWSTR PKP_HELP_TOPIC = L"sag_secsettopnode.htm";
LPCWSTR SAFER_WINDOWS_HELP_FILE = L"SAFER.chm";
LPCWSTR SAFER_WINDOWS_LINKED_HELP_FILE = L"SAFERconcepts.chm";
LPCWSTR SAFER_HELP_TOPIC = L"SAFER_topnode.htm";
LPCWSTR CM_CONTEXT_HELP = L"\\help\\certmgr.hlp";
LPCWSTR WINDOWS_HELP = L"windows.hlp";
LPCWSTR EFS_LINKED_HELP_FILE = L"encrypt.chm";
LPCWSTR EFS_HELP_TOPIC = L"sag_SEProcsOndisk.htm";

//
// This is used by the nodetype utility routines in stdutils.cpp
//

const struct NODETYPE_GUID_ARRAYSTRUCT g_NodetypeGuids[CERTMGR_NUMTYPES] =
{
    { // CERTMGR_SNAPIN
        structuuidNodetypeSnapin,
        lstruuidNodetypeSnapin    },
    {  // CERTMGR_CERTIFICATE
        structuuidNodetypeCertificate,
        lstruuidNodetypeCertificate  },
    {  // CERTMGR_LOG_STORE
        structuuidNodetypeLogStore,
        lstruuidNodetypeLogStore  },
    {  // CERTMGR_PHYS_STORE
        structuuidNodetypePhysStore,
        lstruuidNodetypePhysStore  },
    {  // CERTMGR_USAGE
        structuuidNodetypeUsage,
        lstruuidNodetypeUsage  },
    {  // CERTMGR_CRL_CONTAINER
        structuuidNodetypeCRLContainer,
        lstruuidNodetypeCRLContainer  },
    {  // CERTMGR_CTL_CONTAINER
        structuuidNodetypeCTLContainer,
        lstruuidNodetypeCTLContainer  },
    {  // CERTMGR_CERT_CONTAINER
        structuuidNodetypeCertContainer,
        lstruuidNodetypeCertContainer  },
    {  // CERTMGR_CRL
        structuuidNodetypeCRL,
        lstruuidNodetypeCRL  },
    {  // CERTMGR_CTL
        structuuidNodetypeCTL,
        lstruuidNodetypeCTL  },
    {  // CERTMGR_AUTO_CERT_REQUEST
        structuuidNodetypeAutoCertRequest,
        lstruuidNodetypeAutoCertRequest  },
    { // CERTMGR_CERT_POLICIES_USER,
        structuuidNodetypeCertPoliciesUser,
        lstruiidNodetypeCertPoliciesUser },
    { // CERTMGR_CERT_POLICIES_COMPUTER,
        structuuidNodetypeCertPoliciesComputer,
        lstruiidNodetypeCertPoliciesComputer },
    {  // CERTMGR_LOG_STORE_GPE
        structuuidNodetypeLogStore,
        lstruuidNodetypeLogStore  },
    {  // CERTMGR_LOG_STORE_RSOP
        structuuidNodetypeLogStore,
        lstruuidNodetypeLogStore  },
    { // CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS
        structuuidNodetypePKPAutoenrollmentSettings,
            lstruiidNodetypePKPAutoenrollmentSettings },
    { // CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS
        0,
            0 },
    { // CERTMGR_SAFER_COMPUTER_ROOT
        structuuidNodetypeSaferComputerRoot,
            lstruiidNodetypeSaferComputerRoot },
    { // CERTMGR_SAFER_COMPUTER_LEVELS
        structuuidNodetypeSaferComputerLevels,
            lstruiidNodetypeSaferComputerLevels },
    { // CERTMGR_SAFER_COMPUTER_ENTRIES
        structuuidNodetypeSaferComputerEntries,
            lstruiidNodetypeSaferComputerEntries },
    { // CERTMGR_SAFER_USER_ROOT
        structuuidNodetypeSaferUserRoot,
            lstruiidNodetypeSaferUserRoot },
    { // CERTMGR_SAFER_USER_ENTRIES
        structuuidNodetypeSaferUserEntries,
            lstruiidNodetypeSaferUserEntries },
    { // CERTMGR_SAFER_USER_LEVELS
        structuuidNodetypeSaferUserLevels,
            lstruiidNodetypeSaferUserLevels },
    { // CERTMGR_SAFER_COMPUTER_LEVEL
        structuuidNodetypeSaferComputerLevel,
            lstruiidNodetypeSaferComputerLevel },
    { // CERTMGR_SAFER_USER_LEVEL
        structuuidNodetypeSaferUserLevel,
            lstruiidNodetypeSaferUserLevel },
    { // CERTMGR_SAFER_COMPUTER_ENTRY
        structuuidNodetypeSaferComputerEntry,
            lstruiidNodetypeSaferComputerEntry },
    { // CERTMGR_SAFER_USER_ENTRY
        structuuidNodetypeSaferUserEntry,
            lstruiidNodetypeSaferUserEntry },
    { // CERTMGR_SAFER_COMPUTER_TRUSTED_PUBLISHERS
        structuuidNodetypeSaferTrustedPublishers,
            lstruiidNodetypeSaferTrustedPublisher },
    { // CERTMGR_SAFER_USER_TRUSTED_PUBLISHERS
        0,
            0 },
    { // CERTMGR_SAFER_COMPUTER_DEFINED_FILE_TYPES
        structuuidNodetypeSaferDefinedFileTypes,
            lstruiidNodetypeSaferDefinedFileTypes },
    { // CERTMGR_SAFER_USER_DEFINED_FILE_TYPES
        0,
            0 },
    { // CERTMGR_SAFER_USER_ENFORCEMENT
        structuuidNodetypeSaferEnforcement,
            lstruiidNodetypeSaferEnforcement },
    { // CERTMGR_SAFER_COMPUTER_ENFORCEMENT
        0,
            0 }
};

const struct NODETYPE_GUID_ARRAYSTRUCT* g_aNodetypeGuids = g_NodetypeGuids;

const int g_cNumNodetypeGuids = CERTMGR_NUMTYPES;


HINSTANCE   g_hInstance = 0;
CString     g_szFileName;
CComModule  _Module;

BEGIN_OBJECT_MAP (ObjectMap)
    OBJECT_ENTRY (CLSID_CertificateManager, CCertMgrSnapin)
    OBJECT_ENTRY (CLSID_CertificateManagerPKPOLExt, CCertMgrPKPolExtension)
    OBJECT_ENTRY (CLSID_CertificateManagerAbout, CCertMgrAbout)
    OBJECT_ENTRY (CLSID_PublicKeyPoliciesAbout, CPublicKeyPoliciesAbout)
    OBJECT_ENTRY (CLSID_SaferWindowsExtension, CSaferWindowsExtension)
    OBJECT_ENTRY (CLSID_SaferWindowsAbout, CSaferWindowsAbout)
END_OBJECT_MAP ()

class CCertMgrApp : public CWinApp
{
public:
    CCertMgrApp ();
    virtual BOOL InitInstance ();
    virtual int ExitInstance ();
private:
};

CCertMgrApp theApp;

CCertMgrApp::CCertMgrApp ()
{
    // security review 2/26/2002 BryanWal ok
    LPWSTR  pszCommandLine = _wcsupr (::GetCommandLine ());
    LPWSTR  pszParam = L"/CERTMGR:FILENAME=";
    // security review 2/26/2002 BryanWal ok
    size_t  len = wcslen (pszParam);

    // security review 2/26/2002 BryanWal ok 
    // NOTICE: handles very long strings - the Windows commandline parser will 
    // return an error if the commandline is too long
    LPWSTR  pszArg = wcsstr (pszCommandLine, pszParam);
    if ( !pszArg )
    {
        pszParam = L"-CERTMGR:FILENAME=";
        // security review 2/26/2002 BryanWal ok
        pszArg = wcsstr (pszCommandLine, pszParam);
    }
    if ( pszArg )
    {
        LPWSTR  pszDelimiters = 0;

        // jump past the name of the arg to get the value
        pszArg += len;
        //  Is the file name delimited by double quotes?  This could indicate 
        //  the presence of spaces in the name.  If so, skip the quote
        //  and look for the closing quote.  Otherwise, look for the next
        //  space, tab or NULL terminator.
        if (  L'\"' == pszArg[0] )
        {
            pszDelimiters = L"\"";
            pszArg++;
        }
        else
            pszDelimiters = L" \t\0";

        // security review 2/26/2002 BryanWal ok
        len = wcscspn (pszArg, pszDelimiters);
        * (pszArg + len) = 0;
        g_szFileName = pszArg;
    }
}


BOOL CCertMgrApp::InitInstance ()
{
#ifdef _MERGE_PROXYSTUB
    hProxyDll = m_hInstance;

#endif
    g_hInstance = m_hInstance;
    AfxSetResourceHandle (m_hInstance);
    _Module.Init (ObjectMap, m_hInstance);

#if DBG == 1
    CheckDebugOutputLevel ();
#endif 

    SHFusionInitializeFromModuleID (m_hInstance, 2);

    return CWinApp::InitInstance ();
}

int CCertMgrApp::ExitInstance ()
{
    SHFusionUninitialize();

    SetRegistryScope (0, false);
    _Module.Term ();

    return CWinApp::ExitInstance ();
}



/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow (void)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    return (AfxDllCanUnloadNow ()==S_OK && _Module.GetLockCount ()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject (REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject (rclsid, riid, ppv);
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry
//const WCHAR g_szNameString[] = TEXT ("NameString");
//const WCHAR g_szNodeType[] = TEXT ("NodeType");


STDAPI DllRegisterServer (void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // NTRAID# 88502    intlext: mui: me common: crypto: certificate 's 
    // intended purpose string unlocalized
    // Unregister szOID_EFS_RECOVERY
    CRYPT_OID_INFO  oid;
    // security review 2/26/2002 BryanWal ok
    ::ZeroMemory (&oid, sizeof (oid));
    oid.cbSize = sizeof (CRYPT_OID_INFO);
    oid.pszOID = szOID_EFS_RECOVERY;
    oid.dwGroupId = CRYPT_ENHKEY_USAGE_OID_GROUP_ID;

    CryptUnregisterOIDInfo (&oid);

    // registers object, typelib and all interfaces in typelib
    HRESULT hr = _Module.RegisterServer (TRUE);
    ASSERT (SUCCEEDED (hr));
    if ( E_ACCESSDENIED == hr )
    {
        CString caption;
        CString text;
        CThemeContextActivator activator;

        VERIFY (caption.LoadString (IDS_REGISTER_CERTMGR));
        VERIFY (text.LoadString (IDS_INSUFFICIENT_RIGHTS_TO_REGISTER_CERTMGR));

        MessageBox (NULL, text, caption, MB_OK);
        return hr;
    }

    try 
    {
        CString         strGUID;
        CString         snapinName;
        CString         verProviderStr, verVersionStr;
        AMC::CRegKey    rkSnapins;
        BOOL            fFound = rkSnapins.OpenKeyEx (HKEY_LOCAL_MACHINE, SNAPINS_KEY);
        ASSERT (fFound);
        if ( fFound )
        {
            {
                AMC::CRegKey    rkCertMgrSnapin;
                hr = GuidToCString (&strGUID, CLSID_CertificateManager);
                if ( FAILED (hr) )
                {
                    ASSERT (FALSE);
                    return SELFREG_E_CLASS;
                }
                rkCertMgrSnapin.CreateKeyEx (rkSnapins, strGUID);
                ASSERT (rkCertMgrSnapin.GetLastError () == ERROR_SUCCESS);
                rkCertMgrSnapin.SetString (g_szNodeType, g_aNodetypeGuids[CERTMGR_SNAPIN].bstr);
                VERIFY (snapinName.LoadString (IDS_CERTIFICATE_MANAGER_REGISTRY));
                rkCertMgrSnapin.SetString (g_szNameString, (LPCWSTR) snapinName);
                hr = GuidToCString (&strGUID, CLSID_CertificateManagerAbout);
                if ( FAILED (hr) )
                {
                    ASSERT (FALSE);
                    return SELFREG_E_CLASS;
                }
                rkCertMgrSnapin.SetString (L"About", strGUID);

                // security review 2/26/2002 BryanWal ok
                size_t  len = strlen (VER_COMPANYNAME_STR);
                // last arg includes null-terminator.  If the last arg doesn't 
                // include the null terminator, the '/0' will not get converted.
                len = mbstowcs (verProviderStr.GetBufferSetLength ((int) len),
                                VER_COMPANYNAME_STR, len+1);    
                rkCertMgrSnapin.SetString (L"Provider", verProviderStr);

                // security review 2/26/2002 BryanWal ok
                len = strlen (VER_PRODUCTVERSION_STR);
                // security review 2/26/2002 BryanWal ok
                len = mbstowcs (verVersionStr.GetBufferSetLength ((int)len),
                                VER_PRODUCTVERSION_STR, len+1);    // last arg includes null-terminator
                rkCertMgrSnapin.SetString (L"Version", verVersionStr);

                AMC::CRegKey rkCertMgrStandalone;
                rkCertMgrStandalone.CreateKeyEx (rkCertMgrSnapin, g_szStandAlone);
                ASSERT (rkCertMgrStandalone.GetLastError () == ERROR_SUCCESS);


                AMC::CRegKey rkMyNodeTypes;
                rkMyNodeTypes.CreateKeyEx (rkCertMgrSnapin, g_szNodeTypes);
                ASSERT (rkMyNodeTypes.GetLastError () == ERROR_SUCCESS);
                AMC::CRegKey rkMyNodeType;

                for (int i = CERTMGR_SNAPIN; i < CERTMGR_NUMTYPES; i++)
                {
                    switch (i)
                    {
                    case CERTMGR_LOG_STORE_GPE:
                    case CERTMGR_LOG_STORE_RSOP:
                    case CERTMGR_AUTO_CERT_REQUEST:
                    case CERTMGR_CERT_POLICIES_USER:
                    case CERTMGR_CERT_POLICIES_COMPUTER:
                    case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS: // not necessary - just another kind of the same node
                        break;

                    // TODO: What to do with these?
                    case CERTMGR_SAFER_COMPUTER_ROOT:
                    case CERTMGR_SAFER_USER_ROOT:
                    case CERTMGR_SAFER_COMPUTER_LEVELS:
                    case CERTMGR_SAFER_USER_LEVELS:
                    case CERTMGR_SAFER_COMPUTER_ENTRIES:
                    case CERTMGR_SAFER_USER_ENTRIES:
                    case CERTMGR_SAFER_COMPUTER_LEVEL:
                    case CERTMGR_SAFER_USER_LEVEL:
                    case CERTMGR_SAFER_COMPUTER_ENTRY:
                    case CERTMGR_SAFER_USER_ENTRY:
                    case CERTMGR_SAFER_COMPUTER_TRUSTED_PUBLISHERS:
                    case CERTMGR_SAFER_USER_TRUSTED_PUBLISHERS:
                    case CERTMGR_SAFER_COMPUTER_DEFINED_FILE_TYPES:
                    case CERTMGR_SAFER_USER_DEFINED_FILE_TYPES:
                    case CERTMGR_SAFER_USER_ENFORCEMENT:
                    case CERTMGR_SAFER_COMPUTER_ENFORCEMENT:
                        break;

                    case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
                    default:
                        // security review 2/26/2002 BryanWal ok
                        if ( wcslen (g_aNodetypeGuids[i].bstr) )
                        {
                            rkMyNodeType.CreateKeyEx (rkMyNodeTypes, g_aNodetypeGuids[i].bstr);
                            ASSERT (rkMyNodeType.GetLastError () == ERROR_SUCCESS);
                            rkMyNodeType.CloseKey ();
                        }
                        break;
                    }
                }

                //
                // BryanWal 5/18/00
                // 94793: MUI: MMC: Certificates snap-in stores its display 
                //              information in the registry
                //
                // MMC now supports NameStringIndirect
                //
                WCHAR achModuleFileName[MAX_PATH+20];
                if (0 < ::GetModuleFileName(
                             AfxGetInstanceHandle(),
                             achModuleFileName,
                             sizeof(achModuleFileName)/sizeof(WCHAR) ))  // size of buffer in TCHARS
                {
                    CString strNameIndirect;
                    strNameIndirect.Format(L"@%s,-%d",
                                            achModuleFileName,
                                            IDS_CERTIFICATE_MANAGER_REGISTRY );
                    rkCertMgrSnapin.SetString(L"NameStringIndirect",
                                            strNameIndirect );
                }

                rkCertMgrSnapin.CloseKey ();
            }

            AMC::CRegKey rkNodeTypes;
            fFound = rkNodeTypes.OpenKeyEx (HKEY_LOCAL_MACHINE, NODE_TYPES_KEY);
            ASSERT (fFound);
            if ( fFound )
            {
                AMC::CRegKey rkNodeType;

                for (int i = CERTMGR_SNAPIN; i < CERTMGR_NUMTYPES; i++)
                {
                    switch (i)
                    {
                    // these types are not used in the primary snapin
                    case CERTMGR_LOG_STORE_GPE:
                    case CERTMGR_LOG_STORE_RSOP:
                    case CERTMGR_AUTO_CERT_REQUEST:
                    case CERTMGR_CERT_POLICIES_USER:
                    case CERTMGR_CERT_POLICIES_COMPUTER:
                    case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
                    case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
                    case CERTMGR_SAFER_COMPUTER_ROOT:
                    case CERTMGR_SAFER_USER_ROOT:
                    case CERTMGR_SAFER_COMPUTER_LEVELS:
                    case CERTMGR_SAFER_USER_LEVELS:
                    case CERTMGR_SAFER_COMPUTER_ENTRIES:
                    case CERTMGR_SAFER_USER_ENTRIES:
                    case CERTMGR_SAFER_COMPUTER_LEVEL:
                    case CERTMGR_SAFER_USER_LEVEL:
                    case CERTMGR_SAFER_COMPUTER_ENTRY:
                    case CERTMGR_SAFER_USER_ENTRY:
                    case CERTMGR_SAFER_COMPUTER_TRUSTED_PUBLISHERS:
                    case CERTMGR_SAFER_USER_TRUSTED_PUBLISHERS:
                    case CERTMGR_SAFER_COMPUTER_DEFINED_FILE_TYPES:
                    case CERTMGR_SAFER_USER_DEFINED_FILE_TYPES:
                    case CERTMGR_SAFER_USER_ENFORCEMENT:
                    case CERTMGR_SAFER_COMPUTER_ENFORCEMENT:
                        break;

                    default:
                        // security review 2/26/2002 BryanWal ok
                        if ( wcslen (g_aNodetypeGuids[i].bstr) )
                        {
                            rkNodeType.CreateKeyEx (rkNodeTypes, g_aNodetypeGuids[i].bstr);
                            ASSERT (rkNodeType.GetLastError () == ERROR_SUCCESS);
                            rkNodeType.CloseKey ();
                        }
                        break;
                    }
                }


                if ( IsWindowsNT () )
                {
                    {
                        // Public Key PoliciesSnap-in under Security Configuration Editor (SCE)
                        // Certificate Manager extends "Computer Settings" and 
                        // "User Settings" node
                        CString strCertMgrExtPKPolGUID;
                        hr = GuidToCString (&strCertMgrExtPKPolGUID, 
                                CLSID_CertificateManagerPKPOLExt);
                        if ( FAILED (hr) )
                        {
                            ASSERT (FALSE);
                            return SELFREG_E_CLASS;
                        }

                        VERIFY (snapinName.LoadString (IDS_CERT_MGR_SCE_EXTENSION_REGISTRY));
                        {
                            AMC::CRegKey rkCertMgrExtension;
                            rkCertMgrExtension.CreateKeyEx (rkSnapins, strCertMgrExtPKPolGUID);
                            ASSERT (rkCertMgrExtension.GetLastError () == ERROR_SUCCESS);
                            rkCertMgrExtension.SetString (g_szNameString, (LPCWSTR) snapinName);
                            hr = GuidToCString (&strGUID, CLSID_PublicKeyPoliciesAbout);
                            if ( FAILED (hr) )
                            {
                                ASSERT (FALSE);
                                return SELFREG_E_CLASS;
                            }
                            rkCertMgrExtension.SetString (L"About", strGUID);
                            rkCertMgrExtension.SetString (L"Provider", verProviderStr);
                            rkCertMgrExtension.SetString (L"Version", verVersionStr);


                            // Register the node types of the extension
                            AMC::CRegKey rkMyNodeTypes;
                            rkMyNodeTypes.CreateKeyEx (rkCertMgrExtension, g_szNodeTypes);
                            ASSERT (rkMyNodeTypes.GetLastError () == ERROR_SUCCESS);
                            AMC::CRegKey rkMyNodeType;
                            for (int i = CERTMGR_SNAPIN; i < CERTMGR_NUMTYPES; i++)
                            {
                                switch (i)
                                {
                                // None of these are used in the Public Key Policy extension
                                case CERTMGR_USAGE:
                                case CERTMGR_PHYS_STORE:
                                case CERTMGR_LOG_STORE:
                                case CERTMGR_CRL_CONTAINER:
                                case CERTMGR_CTL_CONTAINER:
                                case CERTMGR_CERT_CONTAINER:
                                case CERTMGR_CRL:
                                case CERTMGR_SAFER_COMPUTER_ROOT:
                                case CERTMGR_SAFER_USER_ROOT:
                                case CERTMGR_SAFER_COMPUTER_LEVELS:
                                case CERTMGR_SAFER_USER_LEVELS:
                                case CERTMGR_SAFER_COMPUTER_ENTRIES:
                                case CERTMGR_SAFER_USER_ENTRIES:
                                case CERTMGR_SAFER_COMPUTER_LEVEL:
                                case CERTMGR_SAFER_USER_LEVEL:
                                case CERTMGR_SAFER_COMPUTER_ENTRY:
                                case CERTMGR_SAFER_USER_ENTRY:
                                case CERTMGR_SAFER_COMPUTER_TRUSTED_PUBLISHERS:
                                case CERTMGR_SAFER_USER_TRUSTED_PUBLISHERS:
                                case CERTMGR_SAFER_COMPUTER_DEFINED_FILE_TYPES:
                                case CERTMGR_SAFER_USER_DEFINED_FILE_TYPES:
                                case CERTMGR_SAFER_USER_ENFORCEMENT:
                                case CERTMGR_SAFER_COMPUTER_ENFORCEMENT:

                                // not necessary - just another kind of the same node
                                case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
                                    break;

                                default:
                                    // security review 2/26/2002 BryanWal ok
                                    if ( wcslen (g_aNodetypeGuids[i].bstr) )
                                    {
                                        rkMyNodeType.CreateKeyEx (rkMyNodeTypes, g_aNodetypeGuids[i].bstr);
                                        ASSERT (rkMyNodeType.GetLastError () == ERROR_SUCCESS);
                                        rkMyNodeType.CloseKey ();
                                    }
                                    break;
                                }
                            }

                            //
                            // BryanWal 5/18/00
                            // 94793: MUI: MMC: Certificates snap-in stores its display 
                            //              information in the registry
                            //
                            // MMC now supports NameStringIndirect
                            //
                            WCHAR achModuleFileName[MAX_PATH+20];
                            if (0 < ::GetModuleFileName(
                                         AfxGetInstanceHandle(),
                                         achModuleFileName,
                                         sizeof(achModuleFileName)/sizeof(WCHAR) )) // size of buffer in TCHARS
                            {
                                CString strNameIndirect;
                                strNameIndirect.Format(L"@%s,-%d",
                                                        achModuleFileName,
                                                        IDS_CERT_MGR_SCE_EXTENSION_REGISTRY );
                                rkCertMgrExtension.SetString( L"NameStringIndirect",
                                                        strNameIndirect );
                            }
                            rkCertMgrExtension.CloseKey ();
                        }

                        hr = GuidToCString (&strGUID, cNodetypeSceTemplate);
                        if ( FAILED (hr) )
                        {
                            ASSERT (FALSE);
                            return SELFREG_E_CLASS;
                        }
                        rkNodeType.CreateKeyEx (rkNodeTypes, strGUID); 
                        ASSERT (rkNodeType.GetLastError () == ERROR_SUCCESS);
                        if ( rkNodeType.GetLastError () == ERROR_SUCCESS )
                        {
                            AMC::CRegKey rkExtensions;
                            ASSERT (rkExtensions.GetLastError () == ERROR_SUCCESS);
                            rkExtensions.CreateKeyEx (rkNodeType, g_szExtensions);
                            AMC::CRegKey rkNameSpace;
                            rkNameSpace.CreateKeyEx (rkExtensions, g_szNameSpace);
                            ASSERT (rkNameSpace.GetLastError () == ERROR_SUCCESS);
                            rkNameSpace.SetString (strCertMgrExtPKPolGUID, (LPCWSTR) snapinName);
                            rkNodeType.CloseKey ();
                        }
                        else
                            return SELFREG_E_CLASS;
                    }


                    {
                        // SAFER Windows Snap-in under Security Configuration Editor (SCE)
                        // Certificate Manager extends "Computer Settings" and 
                        // "User Settings" node
                        CString strSaferWindowsExtensionGUID;
                        hr = GuidToCString (&strSaferWindowsExtensionGUID, 
                                CLSID_SaferWindowsExtension);
                        if ( FAILED (hr) )
                        {
                            ASSERT (FALSE);
                            return SELFREG_E_CLASS;
                        }

                        VERIFY (snapinName.LoadString (IDS_SAFER_WINDOWS_EXTENSION_REGISTRY));
                        {
                            AMC::CRegKey rkCertMgrExtension;
                            rkCertMgrExtension.CreateKeyEx (rkSnapins, strSaferWindowsExtensionGUID);
                            ASSERT (rkCertMgrExtension.GetLastError () == ERROR_SUCCESS);
                            rkCertMgrExtension.SetString (g_szNameString, (LPCWSTR) snapinName);
                            hr = GuidToCString (&strGUID, CLSID_SaferWindowsAbout);
                            if ( FAILED (hr) )
                            {
                                ASSERT (FALSE);
                                return SELFREG_E_CLASS;
                            }
                            rkCertMgrExtension.SetString (L"About", strGUID);
                            rkCertMgrExtension.SetString (L"Provider", verProviderStr);
                            rkCertMgrExtension.SetString (L"Version", verVersionStr);


                            // Register the node types of the extension
                            AMC::CRegKey rkMyNodeTypes;
                            rkMyNodeTypes.CreateKeyEx (rkCertMgrExtension, g_szNodeTypes);
                            ASSERT (rkMyNodeTypes.GetLastError () == ERROR_SUCCESS);
                            AMC::CRegKey rkMyNodeType;
                            for (int i = CERTMGR_SNAPIN; i < CERTMGR_NUMTYPES; i++)
                            {
                                switch (i)
                                {
                                case CERTMGR_CERTIFICATE:
                                case CERTMGR_LOG_STORE:
                                case CERTMGR_PHYS_STORE:
                                case CERTMGR_USAGE:
                                case CERTMGR_CRL_CONTAINER:
                                case CERTMGR_CTL_CONTAINER:
                                case CERTMGR_CERT_CONTAINER:
                                case CERTMGR_CRL:
                                case CERTMGR_CTL:
                                case CERTMGR_AUTO_CERT_REQUEST:
                                case CERTMGR_CERT_POLICIES_USER:
                                case CERTMGR_CERT_POLICIES_COMPUTER:
                                case CERTMGR_LOG_STORE_GPE:
                                case CERTMGR_LOG_STORE_RSOP:
                                case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
                                case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
                                    // None of these are used in the Software Restriction Policies extension
                                    break;

                                case CERTMGR_SAFER_COMPUTER_ROOT:
                                case CERTMGR_SAFER_USER_ROOT:
                                case CERTMGR_SAFER_COMPUTER_LEVELS:
                                case CERTMGR_SAFER_USER_LEVELS:
                                case CERTMGR_SAFER_COMPUTER_ENTRIES:
                                case CERTMGR_SAFER_USER_ENTRIES:
                                case CERTMGR_SAFER_COMPUTER_LEVEL:
                                case CERTMGR_SAFER_USER_LEVEL:
                                case CERTMGR_SAFER_COMPUTER_ENTRY:
                                case CERTMGR_SAFER_USER_ENTRY:                              
                                case CERTMGR_SAFER_COMPUTER_TRUSTED_PUBLISHERS:
                                case CERTMGR_SAFER_USER_TRUSTED_PUBLISHERS:
                                case CERTMGR_SAFER_COMPUTER_DEFINED_FILE_TYPES:
                                case CERTMGR_SAFER_USER_DEFINED_FILE_TYPES:
                                case CERTMGR_SAFER_USER_ENFORCEMENT:
                                case CERTMGR_SAFER_COMPUTER_ENFORCEMENT:
                                default:
                                    // security review 2/26/2002 BryanWal ok
                                    if ( g_aNodetypeGuids[i].bstr && wcslen (g_aNodetypeGuids[i].bstr) )
                                    {
                                        rkMyNodeType.CreateKeyEx (rkMyNodeTypes, g_aNodetypeGuids[i].bstr);
                                        ASSERT (rkMyNodeType.GetLastError () == ERROR_SUCCESS);
                                        rkMyNodeType.CloseKey ();
                                    }
                                    break;
                                }
                            }

                            WCHAR achModuleFileName[MAX_PATH+20];
                            if (0 < ::GetModuleFileName(
                                         AfxGetInstanceHandle(),
                                         achModuleFileName,
                                         sizeof(achModuleFileName)/sizeof(WCHAR) )) // size of buffer in TCHARS
                            {
                                CString strNameIndirect;
                                strNameIndirect.Format( L"@%s,-%d",
                                                        achModuleFileName,
                                                        IDS_SAFER_WINDOWS_EXTENSION_REGISTRY );
                                rkCertMgrExtension.SetString( L"NameStringIndirect",
                                                        strNameIndirect );
                            }
                            rkCertMgrExtension.CloseKey ();
                        }

                        hr = GuidToCString (&strGUID, cNodetypeSceTemplate);
                        if ( FAILED (hr) )
                        {
                            ASSERT (FALSE);
                            return SELFREG_E_CLASS;
                        }
                        rkNodeType.CreateKeyEx (rkNodeTypes, strGUID); 
                        ASSERT (rkNodeType.GetLastError () == ERROR_SUCCESS);
                        if ( rkNodeType.GetLastError () == ERROR_SUCCESS )
                        {
                            AMC::CRegKey rkExtensions;
                            ASSERT (rkExtensions.GetLastError () == ERROR_SUCCESS);
                            rkExtensions.CreateKeyEx (rkNodeType, g_szExtensions);
                            AMC::CRegKey rkNameSpace;
                            rkNameSpace.CreateKeyEx (rkExtensions, g_szNameSpace);
                            ASSERT (rkNameSpace.GetLastError () == ERROR_SUCCESS);
                            rkNameSpace.SetString (strSaferWindowsExtensionGUID, 
                                    (LPCWSTR) snapinName);
                            rkNodeType.CloseKey ();
                        }
                        else
                            return SELFREG_E_CLASS;
                    }

                    // Deregister as extension to My Computer System Tools node
                    // CODEWORK It would be good if we deregistered the server too
                    // JonN 12/14/98
                    try
                    {
                        fFound = rkNodeType.OpenKeyEx (rkNodeTypes, TEXT(struuidNodetypeSystemTools));
                        // if this fails just carry on
                        if ( fFound )
                        {
                            AMC::CRegKey rkExtensions;
                            ASSERT (rkExtensions.GetLastError () == ERROR_SUCCESS);
                            fFound = rkExtensions.OpenKeyEx (rkNodeType, g_szExtensions);
                            // if this fails just carry on
                            if ( fFound )
                            {
                                AMC::CRegKey rkNameSpace;
                                ASSERT (rkNameSpace.GetLastError () == ERROR_SUCCESS);
                                fFound = rkNameSpace.OpenKeyEx (rkExtensions, g_szNameSpace);
                                // if this fails just carry on
                                if ( fFound )
                                {
                                    rkNameSpace.DeleteValue( L"{9C7910D2-4C01-11D1-856B-00C04FB94F17}" );
                                }
                            }
                        }
                    } catch (COleException* /*e*/)
                    {
                        // don't do anything
                    }

                } // endif IsWindowsNT ()
                rkNodeTypes.CloseKey ();
            }
            else
                return SELFREG_E_CLASS;
        }
        else
            return SELFREG_E_CLASS;
    }
    catch (COleException* e)
    {
        ASSERT (FALSE);
        e->Delete ();
        return SELFREG_E_CLASS;
    }

    ASSERT (SUCCEEDED (hr));
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer (void)
{

    _Module.UnregisterServer ();
    return S_OK;
}


STDAPI DllInstall(BOOL /*bInstall*/, LPCWSTR pszCmdLine)
{
    LPCWSTR wszCurrentCmd = pszCmdLine;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());


    // parse the cmd line
    while(wszCurrentCmd && *wszCurrentCmd)
    {
        while(*wszCurrentCmd == L' ')
            wszCurrentCmd++;
        if(*wszCurrentCmd == 0)
            break;

        switch(*wszCurrentCmd++)
        {
            case L'?':
                return S_OK;
        }
    }


    return S_OK;
}



///////////////////////////////////////////////////////////////////////////
//  ConvertNameBlobToString ()
//
//  nameBlob (IN)       - Contains a CERT_NAME_BLOB to be decoded
//  pszName  (OUT)      - The decoded contents of the name blob
//   
///////////////////////////////////////////////////////////////////////////
HRESULT ConvertNameBlobToString (CERT_NAME_BLOB nameBlob, CString & pszName)
{
    HRESULT hr = S_OK;
    DWORD   dwSize = 0;

    // Call CertNameToStr to get returned the string length.
    dwSize = CertNameToStr (
              MY_ENCODING_TYPE,     // Encoding type
              &nameBlob,            // CERT_NAME_BLOB
              CERT_SIMPLE_NAME_STR | CERT_NAME_STR_REVERSE_FLAG, // Type
              NULL,                 // Place to return string
              dwSize);              // Size of string (chars), 
                                    //   including zero terminator.

    ASSERT (dwSize > 1);
    if ( dwSize > 1 )   // This function always returns a null char 
                        //   (0), so the minimum count returned will 
                        //   be 1, even if nothing got converted.
    {
        // Call CertNameToStr to get the string.
        dwSize = CertNameToStr (
                   MY_ENCODING_TYPE,     // Encoding type
                   &nameBlob,            // CERT_NAME_BLOB
                   CERT_SIMPLE_NAME_STR | CERT_NAME_STR_REVERSE_FLAG, // Type
                   pszName.GetBufferSetLength (dwSize), // Place to return string
                   dwSize);              // Size of string (chars)
        ASSERT (dwSize > 1);
        pszName.ReleaseBuffer ();
        if ( dwSize <= 1 )
        {
            hr = E_UNEXPECTED;
        }
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//  FormatDate ()
//
//  utcDateTime (IN)    -   A FILETIME in UTC format.
//  pszDateTime (OUT)   -   A string containing the local date and time 
//                          formatted by locale and user preference
//
///////////////////////////////////////////////////////////////////////////////
HRESULT FormatDate (FILETIME utcDateTime, CString & pszDateTime, DWORD dwDateFlags, bool bGetTime)
{
    //  Time is returned as UTC, will be displayed as local.  
    //  Use FileTimeToLocalFileTime () to make it local, 
    //  then call FileTimeToSystemTime () to convert to system time, then 
    //  format with GetDateFormat () and GetTimeFormat () to display 
    //  according to user and locale preferences    
    HRESULT     hr = S_OK;
    FILETIME    localDateTime;

    BOOL bResult = FileTimeToLocalFileTime (&utcDateTime, // pointer to UTC file time to convert 
            &localDateTime); // pointer to converted file time 
    ASSERT (bResult);
    if ( bResult )
    {
        SYSTEMTIME  sysTime;

        bResult = FileTimeToSystemTime (
                &localDateTime, // pointer to file time to convert 
                &sysTime); // pointer to structure to receive system time 
        if ( bResult )
        {
            CString date;
            CString time;

            // Get date
            // Get length to allocate buffer of sufficient size
            int iLen = GetDateFormat (
                    LOCALE_USER_DEFAULT, // locale for which date is to be formatted 
                    dwDateFlags, // flags specifying function options 
                    &sysTime, // date to be formatted 
                    0, // date format string 
                    0, // buffer for storing formatted string 
                    0); // size of buffer 
            ASSERT (iLen > 0);
            if ( iLen > 0 )
            {
                int iResult = GetDateFormat (
                        LOCALE_USER_DEFAULT, // locale for which date is to be formatted 
                        dwDateFlags, // flags specifying function options 
                        &sysTime, // date to be formatted 
                        0, // date format string 
                        date.GetBufferSetLength (iLen), // buffer for storing formatted string 
                        iLen); // size of buffer 
                ASSERT (iResult);
                date.ReleaseBuffer ();
                if ( iResult )
                    pszDateTime = date;
                else
                    hr = HRESULT_FROM_WIN32 (GetLastError ());

                if ( iResult && bGetTime )
                {
                    // Get time
                    // Get length to allocate buffer of sufficient size
                    iLen = GetTimeFormat (
                            LOCALE_USER_DEFAULT, // locale for which date is to be formatted 
                            0, // flags specifying function options 
                            &sysTime, // date to be formatted 
                            0, // date format string 
                            0, // buffer for storing formatted string 
                            0); // size of buffer 
                    ASSERT (iLen > 0);
                    if ( iLen > 0 )
                    {
                        iResult = GetTimeFormat (
                                LOCALE_USER_DEFAULT, // locale for which date is to be formatted 
                                0, // flags specifying function options 
                                &sysTime, // date to be formatted 
                                0, // date format string 
                                time.GetBufferSetLength (iLen), // buffer for storing formatted string 
                                iLen); // size of buffer 
                        ASSERT (iResult);
                        time.ReleaseBuffer ();
                        if ( iResult )
                        {
                            pszDateTime = date + L"  " + time;
                        }
                        else
                            hr = E_UNEXPECTED;
                    }
                    else
                        hr = E_UNEXPECTED;
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32 (GetLastError ());
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32 (GetLastError ());
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
    }

    return hr;
}


void DisplaySystemError (HWND hParent, DWORD dwErr)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    LPVOID  lpMsgBuf;
    
    // security review 2/26/2002 BryanWal ok - message is from system
    ::FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,    
            NULL,
            dwErr,
            MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
             (LPWSTR) &lpMsgBuf,    0,    NULL);
        
    // Display the string.
    CString caption;
    VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
    CThemeContextActivator activator;
    ::MessageBox (hParent, (LPWSTR) lpMsgBuf, (LPCWSTR) caption, MB_OK);
    // Free the buffer.
    LocalFree (lpMsgBuf);
}


CString GetSystemMessage (DWORD dwErr)
{
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    CString message;

    LPVOID lpMsgBuf;
        
    // security review 2/26/2002 BryanWal ok - message is from system
    ::FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,    
            NULL,
            dwErr,
            MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
             (LPWSTR) &lpMsgBuf,    0,    NULL );
    message = (LPWSTR) lpMsgBuf;

    // Free the buffer.
    LocalFree (lpMsgBuf);

    return message;
}


bool MyGetOIDInfo (CString & string, LPCSTR pszObjId)
{   
    ASSERT (pszObjId);
    PCCRYPT_OID_INFO    pOIDInfo;  // This points to a constant data structure and must not be freed.
    bool                bResult = true;

    pOIDInfo = ::CryptFindOIDInfo (CRYPT_OID_INFO_OID_KEY, (void *) pszObjId, 0);

    if ( pOIDInfo )
    {
        string = pOIDInfo->pwszName;
        string.TrimLeft ();
        string.TrimRight ();
    }
    else
    {
        // security review 2/26/2002 BryanWal ok
        // NOTICE: API returns required char count including null terminator if 
        // last arg is 0
        int nLen = ::MultiByteToWideChar (CP_ACP, 0, pszObjId, -1, NULL, 0);
        ASSERT (nLen);
        if ( nLen )
        {
            // security review 2/26/2002 BryanWal ok
            nLen = ::MultiByteToWideChar (CP_ACP, 0, pszObjId, -1, 
            string.GetBufferSetLength (nLen), nLen);
            ASSERT (nLen);
            string.ReleaseBuffer ();
        }
        bResult = (nLen > 0) ? true : false;
    }
    return bResult;
}


bool IsWindowsNT()
{
    OSVERSIONINFO   versionInfo;

    // security review 2/26/2002 BryanWal ok
    ::ZeroMemory (&versionInfo, sizeof (versionInfo));
    versionInfo.dwOSVersionInfoSize = sizeof (versionInfo);
    BOOL    bResult = ::GetVersionEx (&versionInfo);
    ASSERT (bResult);
    if ( bResult )
    {
        if ( VER_PLATFORM_WIN32_NT == versionInfo.dwPlatformId )
            bResult = TRUE;
    }
        
    return bResult ? true : false;
}

bool GetNameStringByType (
        PCCERT_CONTEXT pCertContext, 
        DWORD dwFlag, 
        DWORD dwType, 
        CString& szNameString)
{
    bool    bResult = false;
    DWORD   dwTypePara = CERT_SIMPLE_NAME_STR | CERT_NAME_STR_REVERSE_FLAG;
    DWORD   cchNameString = 0;
    DWORD   dwResult = ::CertGetNameString (pCertContext,
                    dwType,
                    dwFlag,
                    &dwTypePara,
                    NULL,
                    cchNameString);
    if ( dwResult > 1 )
    {
        cchNameString = dwResult;
        LPWSTR  pszNameString = new WCHAR[cchNameString];
        if ( pszNameString )
        {
            // security review 2/26/2002 BryanWal ok
            ::ZeroMemory (pszNameString, cchNameString*sizeof (WCHAR));
            dwResult = ::CertGetNameString (pCertContext,
                            dwType,
                            dwFlag,
                            &dwTypePara,
                            pszNameString,
                            cchNameString);
                ASSERT (dwResult > 1);
            if ( dwResult > 1 )
            {
                szNameString = pszNameString;
                bResult = true;
            }
            delete [] pszNameString;
        }
    }

    return bResult;
}

CString GetNameString (PCCERT_CONTEXT pCertContext, DWORD dwFlag)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CString szNameString;
    DWORD   dwTypes[] = {CERT_NAME_SIMPLE_DISPLAY_TYPE,
                        CERT_NAME_EMAIL_TYPE,
                        CERT_NAME_UPN_TYPE,
                        CERT_NAME_DNS_TYPE,
                        CERT_NAME_URL_TYPE,
                        (DWORD) -1};
    int     nIndex = 0;
    while ( -1 != dwTypes[nIndex])
    {
        if ( GetNameStringByType (
                pCertContext, 
                dwFlag, 
                dwTypes[nIndex], 
                szNameString) )
        {
            break;
        }
        nIndex++;
    }

    if ( szNameString.IsEmpty () )
        szNameString.FormatMessage (IDS_NOT_AVAILABLE);

    return szNameString;
}


bool CertHasEFSKeyUsage(PCCERT_CONTEXT pCertContext)
{
    bool    bFound = false;
    BOOL    bResult = FALSE;
    DWORD   cbUsage = 0;
    


    bResult = ::CertGetEnhancedKeyUsage (pCertContext,  
            0,  // get extension and property
            NULL, &cbUsage);
    if ( bResult )
    {
        PCERT_ENHKEY_USAGE pUsage = (PCERT_ENHKEY_USAGE) new BYTE[cbUsage];
        if ( pUsage )
        {
            bResult = ::CertGetEnhancedKeyUsage (pCertContext,  
                    0, // get extension and property
                    pUsage, &cbUsage);
            if ( bResult )
            {
                for (DWORD dwIndex = 0; dwIndex < pUsage->cUsageIdentifier; dwIndex++)
                {
                    // security review 2/26/2002 BryanWal ok
                    if ( !_stricmp (szOID_EFS_RECOVERY, 
                            pUsage->rgpszUsageIdentifier[dwIndex]) )
                    {
                        bFound = true;
                        break;
                    }
                }
            }
            else
            {
                ASSERT (GetLastError () == CRYPT_E_NOT_FOUND);
            }

            delete [] pUsage;
        }
    }
    else
    {
        ASSERT (GetLastError () == CRYPT_E_NOT_FOUND);
    }
    return bFound;
}


////// This stuff was stolen from windows\gina\snapins\gpedit (eric flo's stuff) //////


//*************************************************************
//
//  RegDelnodeRecurse()
//
//  Purpose:    Deletes a registry key and all it's subkeys / values.
//              Called by RegDelnode
//
//  Parameters: hKeyRoot    -   Root key
//              pwszSubKey    -   SubKey to delete
//
//  Return:     ERROR_SUCCESS if successful
//              something else if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/3/95     ericflo    Created
//              5/13/98     BryanWal   Modified to return LRESULT
//
//*************************************************************

LRESULT RegDelnodeRecurse (HKEY hKeyRoot, CString szSubKey)
{
    ASSERT (hKeyRoot && !szSubKey.IsEmpty ());
    if ( !hKeyRoot || szSubKey.IsEmpty () )
        return ERROR_INVALID_PARAMETER;

    //
    // First, see if we can delete the key without having
    // to recurse.
    //


    LONG    lResult = ::RegDeleteKey(hKeyRoot, szSubKey);
    if (lResult == ERROR_SUCCESS) 
    {
        return lResult;
    }


    HKEY    hKey = 0;
    lResult = ::RegOpenKeyEx (hKeyRoot, szSubKey, 0, KEY_READ, &hKey);
    if (lResult == ERROR_SUCCESS) 
    {
        // ensure szSubKey ends with a slash
        if ( L'\\' != szSubKey.GetAt (szSubKey.GetLength () - 1) )
        {
            szSubKey += L"\\";
        }

        //
        // Enumerate the keys
        //

        DWORD       dwSize = MAX_PATH;
        FILETIME    ftWrite;
        WCHAR       szName[MAX_PATH];
        lResult = ::RegEnumKeyEx(hKey, 0, 
                    szName, 
                    &dwSize,    // size in TCHARS of szName, including terminating NULL (on input)
                    NULL,
                    NULL, NULL, &ftWrite);
        if (lResult == ERROR_SUCCESS) 
        {
            do {
                if ( ERROR_SUCCESS != RegDelnodeRecurse (hKeyRoot, szSubKey + szName) ) 
                {
                    break;
                }

                //
                // Enumerate again
                //

                dwSize = MAX_PATH;

                lResult = ::RegEnumKeyEx(hKey, 0, 
                            szName, 
                            &dwSize,     // size in TCHARS of szName, including terminating NULL (on input)
                            NULL,
                            NULL, NULL, &ftWrite);


            } while (lResult == ERROR_SUCCESS);
        }


        ::RegCloseKey (hKey);
    }

    // remove slash from szSubKey
    szSubKey.Delete (szSubKey.GetLength () - 1, 1);

    //
    // Try again to delete the key
    //

    lResult = ::RegDeleteKey(hKeyRoot, szSubKey);
    if (lResult == ERROR_SUCCESS) 
    {
        return lResult;
    }

    return lResult;
}

//*************************************************************
//
//  RegDelnode()
//
//  Purpose:    Deletes a registry key and all it's subkeys / values
//
//  Parameters: hKeyRoot    -   Root key
//              pwszSubKey    -   SubKey to delete
//
//  Return:     ERROR_SUCCESS if successful
//              something else if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/3/95     ericflo    Created
//              5/13/98     BryanWal   Modified to return LRESULT
//
//*************************************************************

LRESULT RegDelnode (HKEY hKeyRoot, CString szSubKey)
{
    ASSERT (hKeyRoot && !szSubKey.IsEmpty ());
    if ( !hKeyRoot || szSubKey.IsEmpty () )
        return ERROR_INVALID_PARAMETER;

    return RegDelnodeRecurse (hKeyRoot, szSubKey);
}


HRESULT DisplayCertificateCountByStore(LPCONSOLE pConsole, CCertStore* pCertStore, bool bIsGPE)
{
    if ( !pConsole || !pCertStore )
        return E_POINTER;

    _TRACE (1, L"Entering DisplayCertificateCountByStore- %s \n", 
            (LPCWSTR) pCertStore->GetStoreName ());
    AFX_MANAGE_STATE (AfxGetStaticModuleState ( ));
    IConsole2*  pConsole2 = 0;
    HRESULT     hr = pConsole->QueryInterface (IID_PPV_ARG (IConsole2, &pConsole2));
    if (SUCCEEDED (hr))
    {
        CString statusText;
        int     nCertCount = 0;

        switch (pCertStore->GetStoreType ())
        {
        case ACRS_STORE:
            nCertCount = pCertStore->GetCTLCount ();
            break;

        case TRUST_STORE:
            if ( bIsGPE ) 
            {
                nCertCount = pCertStore->GetCTLCount ();
            }
            else
                nCertCount = pCertStore->GetCertCount ();
            break;

        default:
            nCertCount = pCertStore->GetCertCount ();
            break;
        }


        switch (nCertCount)
        {
            case 0:
                {
                    UINT formatID = 0;
                    switch (pCertStore->GetStoreType ())
                    {
                    case ACRS_STORE:
                        formatID = IDS_STATUS_NO_AUTOENROLLMENT_OBJECTS;
                        break;

                    case TRUST_STORE:
                        if ( bIsGPE ) 
                        {
                            formatID = IDS_STATUS_NO_CTLS;
                        }
                        else
                            formatID = IDS_STATUS_NO_CERTS;
                        break;

                    default:
                        formatID = IDS_STATUS_NO_CERTS;
                        break;
                    }
                    statusText.FormatMessage (formatID, pCertStore->GetLocalizedName ());
                }
                break;

            case 1:
                {
                    UINT formatID = 0;
                    switch (pCertStore->GetStoreType ())
                    {
                    case ACRS_STORE:
                        formatID = IDS_STATUS_ONE_AUTOENROLLMENT_OBJECT;
                        break;

                    case TRUST_STORE:
                        if ( bIsGPE ) 
                        {
                            formatID = IDS_STATUS_ONE_CTL;
                        }
                        else
                            formatID = IDS_STATUS_ONE_CERT;
                        break;

                    default:
                        formatID = IDS_STATUS_ONE_CERT;
                        break;
                    }
                    statusText.FormatMessage (formatID, pCertStore->GetLocalizedName ());
                }
                break;
        
            default:
                {
                    UINT formatID = 0;
                    switch (pCertStore->GetStoreType ())
                    {
                    case ACRS_STORE:
                        formatID = IDS_STATUS_X_AUTOENROLLMENT_OBJECTS;
                        break;

                    case TRUST_STORE:
                        if ( bIsGPE )
                        {
                            formatID = IDS_STATUS_X_CTLS;
                        }
                        else
                            formatID = IDS_STATUS_X_CERTS;
                        break;

                    default:
                        formatID = IDS_STATUS_X_CERTS;
                        break;
                    }

                    statusText.FormatMessage (formatID, 
                            (LPCWSTR) pCertStore->GetLocalizedName (), nCertCount); 
                }
                 break;
        }

        hr = pConsole2->SetStatusText ((LPWSTR)(LPCWSTR) statusText);

        pConsole2->Release ();
    }

    _TRACE (-1, L"Leaving DisplayCertificateCountByStore- %s \n", 
            (LPCWSTR) pCertStore->GetStoreName ());
    return hr;
}


CString GetF1HelpFilename()
{
   static CString helpFileName;

   if ( helpFileName.IsEmpty () )
   {
       UINT result = ::GetSystemWindowsDirectory (
            helpFileName.GetBufferSetLength (MAX_PATH+1), MAX_PATH);
       ASSERT(result != 0 && result <= MAX_PATH);
       helpFileName.ReleaseBuffer ();
       if ( result != 0 && result <= MAX_PATH )
           helpFileName += CM_CONTEXT_HELP;
   }

   return helpFileName;
}

//+---------------------------------------------------------------------------
//
//  Function:   LocaleStrCmp
//
//  Synopsis:   Do a case insensitive string compare that is safe for any
//              locale.
//
//  Arguments:  [ptsz1] - strings to compare
//              [ptsz2]
//
//  Returns:    -1, 0, or 1 just like lstrcmpi
//
//  History:    10-28-96   DavidMun   Created
//
//  Notes:      This is slower than lstrcmpi, but will work when sorting
//              strings even in Japanese.
//
//----------------------------------------------------------------------------

int LocaleStrCmp(LPCWSTR ptsz1, LPCWSTR ptsz2)
{
    ASSERT (ptsz1 && ptsz2);
    if ( !ptsz1 || !ptsz2 )
        return 0;

    int iRet = 0;

    iRet = CompareString(LOCALE_USER_DEFAULT,
                         NORM_IGNORECASE        |
                           NORM_IGNOREKANATYPE  |
                           NORM_IGNOREWIDTH,
                         ptsz1,
                         -1,
                         ptsz2,
                         -1);

    if (iRet)
    {
        iRet -= 2;  // convert to lstrcmpi-style return -1, 0, or 1

        if ( 0 == iRet )
        {
            UNICODE_STRING unistr1;

            // security review 2/26/2002 BryanWal ok
            ::RtlInitUnicodeString (&unistr1, ptsz1);

            UNICODE_STRING unistr2;
            // security review 2/26/2002 BryanWal ok
            ::RtlInitUnicodeString (&unistr2, ptsz2);

            iRet = ::RtlCompareUnicodeString(
                &unistr1,
                &unistr2,
                FALSE );
        }
    }
    else
    {
        _TRACE (0, L"CompareString (%s, %s) failed: 0x%x\n", ptsz1, ptsz2, GetLastError ());
    }
    return iRet;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

HPROPSHEETPAGE MyCreatePropertySheetPage(AFX_OLDPROPSHEETPAGE* psp)
{
    ASSERT (psp);
    if ( !psp )
        return 0;

    PROPSHEETPAGE_V3 sp_v3 = {0};
    // security review 2/26/2002 BryanWal ok
    ::CopyMemory (&sp_v3, psp, psp->dwSize);
    sp_v3.dwSize = sizeof(sp_v3);

    return (::CreatePropertySheetPage (&sp_v3));
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#include <winldap.h>
#include <ntldap.h>
#include <dsrole.h>
#include <dsgetdc.h>
#include <accctrl.h>

#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmerr.h>

//--------------------------------------------------------------------------
//
//       Defines
//
//--------------------------------------------------------------------------
#define DS_RETEST_SECONDS                   3
#define CVT_BASE                            (1000 * 1000 * 10)
#define CVT_SECONDS                         (1)
#define CERTTYPE_SECURITY_DESCRIPTOR_NAME   L"NTSecurityDescriptor"
#define TEMPLATE_CONTAINER_NAME             L"CN=Certificate Templates,CN=Public Key Services,CN=Services,"
#define SCHEMA_CONTAINER_NAME               L"CN=Schema,"

HRESULT myHError(HRESULT hr)
{

    if (S_OK != hr && S_FALSE != hr && !FAILED(hr))
    {
        hr = HRESULT_FROM_WIN32(hr);
        if ( SUCCEEDED (hr) )
        {
            // A call failed without properly setting an error condition!
            hr = E_UNEXPECTED;
        }
    }
    return(hr);
}


void CheckDomainVersion ()
{
    _TRACE (1, L"Entering CheckDomainVersion()\n");

    bool bMachineIsStandAlone = false;
    
    // Find out if we're joined to a domain.
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC    pInfo = 0;
    DWORD dwErr = ::DsRoleGetPrimaryDomainInformation (
            0,
            DsRolePrimaryDomainInfoBasic, 
            (PBYTE*) &pInfo);
    if ( ERROR_SUCCESS == dwErr )
    {
        switch (pInfo->MachineRole)
        {
        case DsRole_RoleStandaloneWorkstation:
        case DsRole_RoleStandaloneServer:
            bMachineIsStandAlone = true;
            break;

        case DsRole_RoleMemberWorkstation:
        case DsRole_RoleMemberServer:
        case DsRole_RoleBackupDomainController:
        case DsRole_RolePrimaryDomainController:
            bMachineIsStandAlone = false;
            break;

        default:
            break;
        }
    }
    else
    {
        _TRACE (0, L"DsRoleGetPrimaryDomainInformation () failed: 0x%x\n", dwErr);
    }

    if ( !bMachineIsStandAlone )
    {
        CDSBasePathsInfo    dsInfo;
        if ( SUCCEEDED (dsInfo.InitFromName (pInfo->DomainNameFlat)) )
        {
            if ( dsInfo.GetSchemaVersion () <= 0x0000000d )
            {
                g_bSchemaIsW2K = true;
            }
        }
    }

    if ( pInfo )
        NetApiBufferFree (pInfo);

    _TRACE (1, L"Entering CheckDomainVersion ()\n");
}

VOID DataToHex(PBYTE pSrc, CString & dest, int cb, bool bIncludeSpaces)
{
//  _TRACE (1, L"Entering DataToHex\n");
    ASSERT (pSrc);
    if ( !pSrc )
        return;

    unsigned char ch = 0;
    WCHAR   szDest[3];
    UINT    uLen = 0;

    dest.Empty ();

    while (cb-- > 0) 
    {
#pragma warning (once: 4244)        
        ch = 0x00FF & (unsigned char) (*pSrc++);
        // ISSUE - change to wsnprintf
        // NTRAID Bug9 538774 Security: certmgr.dll : convert to strsafe string functions
        wsprintf(szDest, _T("%02X"), ch);
        dest += szDest;
        uLen++;
        if ( bIncludeSpaces && !(uLen % 2) && cb )
            dest += _T(" ");
    }
//  _TRACE (-1, L"Leaving DataToHex\n");
}


BOOL GetCertificateChain (CERT_CONTEXT* pCertContext, CERT_CONTEXT_LIST& certChainList)
{
    ASSERT (pCertContext);
    if ( !pCertContext )
        return FALSE;

    // Clean up the cert context list
    while (!certChainList.IsEmpty () )
    {
        pCertContext = certChainList.RemoveHead ();
        if ( pCertContext )
            ::CertFreeCertificateContext (pCertContext);
    }


    CERT_CHAIN_PARA certChainPara;
    // security review 2/26/2002 BryanWal ok
    ::ZeroMemory (&certChainPara, sizeof (certChainPara));
    certChainPara.cbSize = sizeof (CERT_CHAIN_PARA);
    certChainPara.RequestedUsage.Usage.cUsageIdentifier = 1;
    certChainPara.RequestedUsage.Usage.rgpszUsageIdentifier = new LPSTR[1];
    if ( !certChainPara.RequestedUsage.Usage.rgpszUsageIdentifier )
        return FALSE; // E_OUTOFMEMORY;
    certChainPara.RequestedUsage.Usage.rgpszUsageIdentifier[0] = szOID_EFS_RECOVERY;

    PCCERT_CHAIN_CONTEXT    pChainContext = 0;
    BOOL    bValidated = ::CertGetCertificateChain (
            HCCE_LOCAL_MACHINE,             // HCERTCHAINENGINE hChainEngine,
            pCertContext,
            0,                              // LPFILETIME pTime,
            0,                              // HCERTSTORE hAdditionalStore,
            &certChainPara,
            0,                              // dwFlags,
            0,                              // pvReserved,
            &pChainContext);
    if ( bValidated )
    {
        // Check to see if cert is self-signed
        PCERT_SIMPLE_CHAIN pChain = pChainContext->rgpChain[pChainContext->cChain - 1];
        if ( pChain )
        {
            PCERT_CHAIN_ELEMENT pElement = pChain->rgpElement[pChain->cElement - 1];
            if ( pElement )
            {
                BOOL bSelfSigned = pElement->TrustStatus.dwInfoStatus & CERT_TRUST_IS_SELF_SIGNED;

                DWORD dwErrorStatus = pChainContext->TrustStatus.dwErrorStatus;

                bValidated = ((0 == dwErrorStatus) || 
                    (dwErrorStatus == CERT_TRUST_IS_UNTRUSTED_ROOT) && bSelfSigned);
                if ( bValidated )
                {
                    //
                    // Enumerate all certs in the chain
                    // Search for the cert in the global list
                    // If not found, then add to the end of the list
                    //
                    for (DWORD dwIndex = 0; dwIndex < pChainContext->cChain; dwIndex++)
                    {
                        DWORD i = 0;
                        while (i < pChainContext->rgpChain[dwIndex]->cElement)
                        {
                            PCCERT_CONTEXT  pChainCertContext = 
                                    pChainContext->rgpChain[dwIndex]->rgpElement[i]->pCertContext;
                            certChainList.AddTail (
                                    const_cast<CERT_CONTEXT*>
                                    (::CertDuplicateCertificateContext (pChainCertContext)));
                            i++;
                        }
                    }


                    ::CertFreeCertificateChain(pChainContext);
                    pChainContext = 0;
                }
            }
            else
                bValidated = FALSE;
        }
        else
            bValidated = FALSE;
    }
    else
        bValidated = FALSE;

    if ( pChainContext )
       ::CertFreeCertificateChain(pChainContext);

    delete [] certChainPara.RequestedUsage.Usage.rgpszUsageIdentifier;

    return bValidated;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\cmponent.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:         cmponent.cpp
//
//  Contents:   Implementation of CCertMgrComponent
//
//----------------------------------------------------------------------------

#include "stdafx.h"

#include <gpedit.h>
#include <wintrust.h>
#include <sceattch.h>
#include "compdata.h" // CCertMgrComponentData
#include "dataobj.h"
#include "cmponent.h" // CCertMgrComponent
#include "storegpe.h"
#include "users.h"
#include "addsheet.h"
#include "StoreRSOP.h"
#include "SaferEntry.h"


#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

USE_HANDLE_MACROS ("CERTMGR (cmponent.cpp)")
#include "stdcmpnt.cpp" // CComponent

extern bool g_bSchemaIsW2K;

extern GUID g_guidExtension;
extern GUID g_guidRegExt;
extern GUID g_guidSnapin;

// CERTMGR_USAGE, CERTMGR_USAGE, CERTMGR_USAGE, CERTMGR_CERT_CONTAINER
UINT m_aColumns0[CERT_NUM_COLS+1] =
    {IDS_COLUMN_SUBJECT, IDS_COLUMN_ISSUER, IDS_COLUMN_EXPIRATION_DATE, 
        IDS_COLUMN_PURPOSE, IDS_COLUMN_FRIENDLY_NAME, IDS_COLUMN_STATUS, 
        IDS_COLUMN_TEMPLATE_NAME, 0};
// CERTMGR_SNAPIN
UINT m_aColumns1[2] =
    {IDS_COLUMN_LOG_CERTIFICATE_STORE,0};
// CERTMGR_CERTIFICATE, CERTMGR_CRL, CERTMGR_CTL
UINT m_aColumns2[2] =
    {0,0};
// CERTMGR_CRL_CONTAINER
UINT m_aColumns3[4] =
    {IDS_COLUMN_ISSUER, IDS_COLUMN_EFFECTIVE_DATE, IDS_COLUMN_NEXT_UPDATE, 0};
// CERTMGR_CTL_CONTAINER
UINT m_aColumns4[6] =
    {IDS_COLUMN_ISSUER, IDS_COLUMN_EFFECTIVE_DATE, IDS_COLUMN_PURPOSE, IDS_COLUMN_FRIENDLY_NAME, 0};

UINT m_aColumns5[2] =
    {IDS_COLUMN_OBJECT_TYPE, 0};

// CERTMGR_SAFER_USER_LEVELS, CERTMGR_SAFER_COMPUTER_LEVELS
UINT m_aColumns6[SAFER_LEVELS_NUM_COLS+1] =
    {IDS_COLUMN_NAME, IDS_COLUMN_DESCRIPTION, 0};

// CERTMGR_SAFER_USER_ENTRIES, CERTMGR_SAFER_COMPUTER_ENTRIES
UINT m_aColumns7[SAFER_ENTRIES_NUM_COLS+1] =
{IDS_COLUMN_NAME, IDS_COLUMN_TYPE, IDS_COLUMN_LEVEL, IDS_COLUMN_DESCRIPTION, IDS_COLUMN_LAST_MODIFIED_DATE, 0};

UINT* m_Columns[CERTMGR_NUMTYPES] =
    {   
        m_aColumns1, // CERTMGR_SNAPIN
        m_aColumns2, // CERTMGR_CERTIFICATE (result)
        m_aColumns5, // CERTMGR_LOG_STORE
        m_aColumns5, // CERTMGR_PHYS_STORE
        m_aColumns0, // CERTMGR_USAGE
        m_aColumns3, // CERTMGR_CRL_CONTAINER
        m_aColumns4, // CERTMGR_CTL_CONTAINER
        m_aColumns0, // CERTMGR_CERT_CONTAINER
        m_aColumns2, // CERTMGR_CRL (result)
        m_aColumns2, // CERTMGR_CTL (result)
        m_aColumns2, // CERTMGR_AUTO_CERT_REQUEST
        m_aColumns5, // CERTMGR_CERT_POLICIES_USER,
        m_aColumns5, // CERTMGR_CERT_POLICIES_COMPUTER,
        m_aColumns5, // CERTMGR_LOG_STORE_GPE
        m_aColumns5, // CERTMGR_LOG_STORE_RSOP
        m_aColumns1, // CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS
        m_aColumns1, // CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS
        m_aColumns5, // CERTMGR_SAFER_COMPUTER_ROOT
        m_aColumns5, // CERTMGR_SAFER_USER_ROOT
        m_aColumns6, // CERTMGR_SAFER_COMPUTER_LEVELS
        m_aColumns6, // CERTMGR_SAFER_USER_LEVELS
        m_aColumns7, // CERTMGR_SAFER_COMPUTER_ENTRIES
        m_aColumns7, // CERTMGR_SAFER_USER_ENTRIES
        m_aColumns2, // CERTMGR_SAFER_COMPUTER_LEVEL,
        m_aColumns2, // CERTMGR_SAFER_USER_LEVEL,
        m_aColumns2, // CERTMGR_SAFER_COMPUTER_ENTRY,
        m_aColumns2, // CERTMGR_SAFER_USER_ENTRY,
        m_aColumns2, // CERTMGR_SAFER_COMPUTER_TRUSTED_PUBLISHERS
        m_aColumns2, // CERTMGR_SAFER_USER_TRUSTED_PUBLISHERS
        m_aColumns2, // CERTMGR_SAFER_COMPUTER_DEFINED_FILE_TYPES
        m_aColumns2, // CERTMGR_SAFER_USER_DEFINED_FILE_TYPES
        m_aColumns2, // CERTMGR_SAFER_USER_ENFORCEMENT
        m_aColumns2  // CERTMGR_SAFER_COMPUTER_ENFORCEMENT
    };


UINT** g_aColumns = 0;  // for framework
int** g_aColumnWidths = 0;  // for framework
const int SINGLE_COL_WIDTH = 450;

CCertMgrComponent::CCertMgrComponent ()
:   m_pViewedCookie (NULL),
    m_bUsageStoresEnumerated (false),
    m_pPastedDO (NULL),
    m_bShowArchivedCertsStateWhenLogStoresEnumerated (false),
    m_nSelectedCertColumn (0),
    m_nSelectedCRLColumn (0),
    m_nSelectedCTLColumn (0),
    m_nSelectedSaferEntryColumn (0),
    m_pLastUsageCookie (0),
    m_pToolbar (0)
{
     AFX_MANAGE_STATE (AfxGetStaticModuleState ( ));
    _TRACE (1, L"Entering CCertMgrComponent::CCertMgrComponent\n");

    const int ISSUED_TO_BY_WIDTH = 200;
    const int FRIENDLY_NAME_WIDTH = 125;
    const int DATE_WIDTH = 100;
    const int PURPOSE_WIDTH = 125;
    const int STATUS_WIDTH = 50;
    const int TEMPLATE_WIDTH = 100;
    const int SAFER_LEVEL_NAME_WIDTH = 150;
    const int SAFER_LEVEL_DESCRIPTION_WIDTH = 400;
    const int SAFER_ENTRY_NAME_WIDTH = 250;
    const int SAFER_ENTRY_TYPE_WIDTH = 75;
    const int SAFER_ENTRY_LEVEL_WIDTH = 100;
    const int SAFER_ENTRY_DESCRIPTION_WIDTH = 200;
    const int SAFER_ENTRY_LAST_MODIFIED_DATE_WIDTH = 200;

    // security review 2/26/2002 BryanWal ok
    ::ZeroMemory (m_ColumnWidths, sizeof (UINT*) * CERTMGR_NUMTYPES);
    m_ColumnWidths[CERTMGR_SNAPIN] = new UINT[1];
    if ( m_ColumnWidths[CERTMGR_SNAPIN] )
        m_ColumnWidths[CERTMGR_SNAPIN][0] = SINGLE_COL_WIDTH;

    m_ColumnWidths[CERTMGR_USAGE] = new UINT[CERT_NUM_COLS];
    if ( m_ColumnWidths[CERTMGR_USAGE] )
    {
        m_ColumnWidths[CERTMGR_USAGE][COLNUM_CERT_SUBJECT] = ISSUED_TO_BY_WIDTH;    // issued to
        m_ColumnWidths[CERTMGR_USAGE][COLNUM_CERT_ISSUER] = ISSUED_TO_BY_WIDTH;     // issued by
        m_ColumnWidths[CERTMGR_USAGE][COLNUM_CERT_EXPIRATION_DATE] = DATE_WIDTH;    // expiration date
        m_ColumnWidths[CERTMGR_USAGE][COLNUM_CERT_PURPOSE] = PURPOSE_WIDTH;         // purpose
        m_ColumnWidths[CERTMGR_USAGE][COLNUM_CERT_CERT_NAME] = FRIENDLY_NAME_WIDTH; // friendly name
        m_ColumnWidths[CERTMGR_USAGE][COLNUM_CERT_STATUS] = STATUS_WIDTH;           // status
        m_ColumnWidths[CERTMGR_USAGE][COLNUM_CERT_TEMPLATE] = TEMPLATE_WIDTH;       // template
    }

    m_ColumnWidths[CERTMGR_PHYS_STORE] = new UINT[1];
    if ( m_ColumnWidths[CERTMGR_PHYS_STORE] )
        m_ColumnWidths[CERTMGR_PHYS_STORE][0] = SINGLE_COL_WIDTH;

    m_ColumnWidths[CERTMGR_LOG_STORE] = new UINT[1];
    if ( m_ColumnWidths[CERTMGR_LOG_STORE] )
        m_ColumnWidths[CERTMGR_LOG_STORE][0] = SINGLE_COL_WIDTH;

    m_ColumnWidths[CERTMGR_CERTIFICATE] = new UINT[1];
    if ( m_ColumnWidths[CERTMGR_CERTIFICATE] )
        m_ColumnWidths[CERTMGR_CERTIFICATE][0] = SINGLE_COL_WIDTH;

    m_ColumnWidths[CERTMGR_CRL_CONTAINER] = new UINT[CRL_NUM_COLS];
    if ( m_ColumnWidths[CERTMGR_CRL_CONTAINER] )
    {
        m_ColumnWidths[CERTMGR_CRL_CONTAINER][0] = ISSUED_TO_BY_WIDTH; // issued by
        m_ColumnWidths[CERTMGR_CRL_CONTAINER][1] = DATE_WIDTH;  // effective date
        m_ColumnWidths[CERTMGR_CRL_CONTAINER][2] = DATE_WIDTH;  // next update
    }

    m_ColumnWidths[CERTMGR_CTL_CONTAINER] = new UINT[CTL_NUM_COLS];
    if ( m_ColumnWidths[CERTMGR_CTL_CONTAINER] )
    {
        m_ColumnWidths[CERTMGR_CTL_CONTAINER][0] = ISSUED_TO_BY_WIDTH;  // issued by
        m_ColumnWidths[CERTMGR_CTL_CONTAINER][1] = DATE_WIDTH;  // effective date
        m_ColumnWidths[CERTMGR_CTL_CONTAINER][2] = PURPOSE_WIDTH;   // purpose
        m_ColumnWidths[CERTMGR_CTL_CONTAINER][3] = FRIENDLY_NAME_WIDTH; // friendly name
    }

    m_ColumnWidths[CERTMGR_CERT_CONTAINER] = new UINT[CERT_NUM_COLS];
    if ( m_ColumnWidths[CERTMGR_CERT_CONTAINER] )
    {
        m_ColumnWidths[CERTMGR_CERT_CONTAINER][COLNUM_CERT_SUBJECT] = ISSUED_TO_BY_WIDTH;   // issued to
        m_ColumnWidths[CERTMGR_CERT_CONTAINER][COLNUM_CERT_ISSUER] = ISSUED_TO_BY_WIDTH;    // issued by
        m_ColumnWidths[CERTMGR_CERT_CONTAINER][COLNUM_CERT_EXPIRATION_DATE] = DATE_WIDTH;   // expiration date
        m_ColumnWidths[CERTMGR_CERT_CONTAINER][COLNUM_CERT_PURPOSE] = PURPOSE_WIDTH;        // purpose
        m_ColumnWidths[CERTMGR_CERT_CONTAINER][COLNUM_CERT_CERT_NAME] = FRIENDLY_NAME_WIDTH;// friendly name
        m_ColumnWidths[CERTMGR_CERT_CONTAINER][COLNUM_CERT_STATUS] = STATUS_WIDTH;          // status
        m_ColumnWidths[CERTMGR_CERT_CONTAINER][COLNUM_CERT_TEMPLATE] = TEMPLATE_WIDTH;      // template
    }

    m_ColumnWidths[CERTMGR_CRL] = new UINT[1];
    if ( m_ColumnWidths[CERTMGR_CRL] )
        m_ColumnWidths[CERTMGR_CRL][0] = SINGLE_COL_WIDTH;

    m_ColumnWidths[CERTMGR_CTL] = new UINT[1];
    if ( m_ColumnWidths[CERTMGR_CTL] )
        m_ColumnWidths[CERTMGR_CTL][0] = SINGLE_COL_WIDTH;

     m_ColumnWidths[CERTMGR_LOG_STORE_GPE] = new UINT[1];
    if ( m_ColumnWidths[CERTMGR_LOG_STORE_GPE] )
        m_ColumnWidths[CERTMGR_LOG_STORE_GPE][0] = SINGLE_COL_WIDTH;

     m_ColumnWidths[CERTMGR_LOG_STORE_RSOP] = new UINT[1];
    if ( m_ColumnWidths[CERTMGR_LOG_STORE_RSOP] )
        m_ColumnWidths[CERTMGR_LOG_STORE_RSOP][0] = SINGLE_COL_WIDTH;

     m_ColumnWidths[CERTMGR_AUTO_CERT_REQUEST] = new UINT[1];
    if ( m_ColumnWidths[CERTMGR_AUTO_CERT_REQUEST] )
        m_ColumnWidths[CERTMGR_AUTO_CERT_REQUEST][0] = SINGLE_COL_WIDTH;

    m_ColumnWidths[CERTMGR_CERT_POLICIES_USER] = new UINT[1];
    if ( m_ColumnWidths[CERTMGR_CERT_POLICIES_USER] )
        m_ColumnWidths[CERTMGR_CERT_POLICIES_USER][0] = SINGLE_COL_WIDTH;

    m_ColumnWidths[CERTMGR_CERT_POLICIES_COMPUTER] = new UINT[1];
    if ( m_ColumnWidths[CERTMGR_CERT_POLICIES_COMPUTER] )
        m_ColumnWidths[CERTMGR_CERT_POLICIES_COMPUTER][0] = SINGLE_COL_WIDTH;

    m_ColumnWidths[CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS] = new UINT[1];
    if ( m_ColumnWidths[CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS] )
        m_ColumnWidths[CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS][0] = SINGLE_COL_WIDTH;

    m_ColumnWidths[CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS] = new UINT[1];
    if ( m_ColumnWidths[CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS] )
        m_ColumnWidths[CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS][0] = SINGLE_COL_WIDTH;

    m_ColumnWidths[CERTMGR_SAFER_COMPUTER_ROOT] = new UINT[1];
    if ( m_ColumnWidths[CERTMGR_SAFER_COMPUTER_ROOT] )
        m_ColumnWidths[CERTMGR_SAFER_COMPUTER_ROOT][0] = SINGLE_COL_WIDTH;

    m_ColumnWidths[CERTMGR_SAFER_USER_ROOT] = new UINT[1];
    if ( m_ColumnWidths[CERTMGR_SAFER_USER_ROOT] )
        m_ColumnWidths[CERTMGR_SAFER_USER_ROOT][0] = SINGLE_COL_WIDTH;

    m_ColumnWidths[CERTMGR_SAFER_COMPUTER_LEVELS] = new UINT[SAFER_LEVELS_NUM_COLS];
    if ( m_ColumnWidths[CERTMGR_SAFER_COMPUTER_LEVELS] )
    {
        m_ColumnWidths[CERTMGR_SAFER_COMPUTER_LEVELS][COLNUM_SAFER_LEVEL_NAME] = SAFER_LEVEL_NAME_WIDTH;
        m_ColumnWidths[CERTMGR_SAFER_COMPUTER_LEVELS][COLNUM_SAFER_LEVEL_DESCRIPTION] = SAFER_LEVEL_DESCRIPTION_WIDTH;
    }

    m_ColumnWidths[CERTMGR_SAFER_USER_LEVELS] = new UINT[SAFER_LEVELS_NUM_COLS];
    if ( m_ColumnWidths[CERTMGR_SAFER_USER_LEVELS] )
    {
        m_ColumnWidths[CERTMGR_SAFER_USER_LEVELS][COLNUM_SAFER_LEVEL_NAME] = SAFER_LEVEL_NAME_WIDTH;
        m_ColumnWidths[CERTMGR_SAFER_USER_LEVELS][COLNUM_SAFER_LEVEL_DESCRIPTION] = SAFER_LEVEL_DESCRIPTION_WIDTH;
    }

    m_ColumnWidths[CERTMGR_SAFER_COMPUTER_ENTRIES] = new UINT[SAFER_ENTRIES_NUM_COLS];
    if ( m_ColumnWidths[CERTMGR_SAFER_COMPUTER_ENTRIES] )
    {
        m_ColumnWidths[CERTMGR_SAFER_COMPUTER_ENTRIES][COLNUM_SAFER_ENTRIES_NAME] = SAFER_ENTRY_NAME_WIDTH;
        m_ColumnWidths[CERTMGR_SAFER_COMPUTER_ENTRIES][COLNUM_SAFER_ENTRIES_TYPE] = SAFER_ENTRY_TYPE_WIDTH;
        m_ColumnWidths[CERTMGR_SAFER_COMPUTER_ENTRIES][COLNUM_SAFER_ENTRIES_LEVEL] = SAFER_ENTRY_LEVEL_WIDTH;
        m_ColumnWidths[CERTMGR_SAFER_COMPUTER_ENTRIES][COLNUM_SAFER_ENTRIES_DESCRIPTION] = SAFER_ENTRY_DESCRIPTION_WIDTH;
        m_ColumnWidths[CERTMGR_SAFER_COMPUTER_ENTRIES][COLNUM_SAFER_ENTRIES_LAST_MODIFIED_DATE] = SAFER_ENTRY_LAST_MODIFIED_DATE_WIDTH;
    }

    m_ColumnWidths[CERTMGR_SAFER_USER_ENTRIES] = new UINT[SAFER_ENTRIES_NUM_COLS];
    if ( m_ColumnWidths[CERTMGR_SAFER_USER_ENTRIES] )
    {
        m_ColumnWidths[CERTMGR_SAFER_USER_ENTRIES][COLNUM_SAFER_ENTRIES_NAME] = SAFER_ENTRY_NAME_WIDTH;
        m_ColumnWidths[CERTMGR_SAFER_USER_ENTRIES][COLNUM_SAFER_ENTRIES_TYPE] = SAFER_ENTRY_TYPE_WIDTH;
        m_ColumnWidths[CERTMGR_SAFER_USER_ENTRIES][COLNUM_SAFER_ENTRIES_LEVEL] = SAFER_ENTRY_LEVEL_WIDTH;
        m_ColumnWidths[CERTMGR_SAFER_USER_ENTRIES][COLNUM_SAFER_ENTRIES_DESCRIPTION] = SAFER_ENTRY_DESCRIPTION_WIDTH;
        m_ColumnWidths[CERTMGR_SAFER_USER_ENTRIES][COLNUM_SAFER_ENTRIES_LAST_MODIFIED_DATE] = SAFER_ENTRY_LAST_MODIFIED_DATE_WIDTH;
    }

    m_ColumnWidths[CERTMGR_SAFER_COMPUTER_LEVEL] = new UINT[1];
    if ( m_ColumnWidths[CERTMGR_SAFER_COMPUTER_LEVEL] )
        m_ColumnWidths[CERTMGR_SAFER_COMPUTER_LEVEL][0] = SINGLE_COL_WIDTH;

    m_ColumnWidths[CERTMGR_SAFER_USER_LEVEL] = new UINT[1];
    if ( m_ColumnWidths[CERTMGR_SAFER_USER_LEVEL] )
        m_ColumnWidths[CERTMGR_SAFER_USER_LEVEL][0] = SINGLE_COL_WIDTH;

    m_ColumnWidths[CERTMGR_SAFER_COMPUTER_ENTRY] = new UINT[1];
    if ( m_ColumnWidths[CERTMGR_SAFER_COMPUTER_ENTRY] )
        m_ColumnWidths[CERTMGR_SAFER_COMPUTER_ENTRY][0] = SINGLE_COL_WIDTH;

    m_ColumnWidths[CERTMGR_SAFER_USER_ENTRY] = new UINT[1];
    if ( m_ColumnWidths[CERTMGR_SAFER_USER_ENTRY] )
        m_ColumnWidths[CERTMGR_SAFER_USER_ENTRY][0] = SINGLE_COL_WIDTH;

    m_ColumnWidths[CERTMGR_SAFER_COMPUTER_TRUSTED_PUBLISHERS] = new UINT[1];
    if ( m_ColumnWidths[CERTMGR_SAFER_COMPUTER_TRUSTED_PUBLISHERS] )
        m_ColumnWidths[CERTMGR_SAFER_COMPUTER_TRUSTED_PUBLISHERS][0] = SINGLE_COL_WIDTH;

    m_ColumnWidths[CERTMGR_SAFER_USER_TRUSTED_PUBLISHERS] = new UINT[1];
    if ( m_ColumnWidths[CERTMGR_SAFER_USER_TRUSTED_PUBLISHERS] )
        m_ColumnWidths[CERTMGR_SAFER_USER_TRUSTED_PUBLISHERS][0] = SINGLE_COL_WIDTH;

    m_ColumnWidths[CERTMGR_SAFER_COMPUTER_DEFINED_FILE_TYPES] = new UINT[1];
    if ( m_ColumnWidths[CERTMGR_SAFER_COMPUTER_DEFINED_FILE_TYPES] )
        m_ColumnWidths[CERTMGR_SAFER_COMPUTER_DEFINED_FILE_TYPES][0] = SINGLE_COL_WIDTH;

    m_ColumnWidths[CERTMGR_SAFER_USER_DEFINED_FILE_TYPES] = new UINT[1];
    if ( m_ColumnWidths[CERTMGR_SAFER_USER_DEFINED_FILE_TYPES] )
        m_ColumnWidths[CERTMGR_SAFER_USER_DEFINED_FILE_TYPES][0] = SINGLE_COL_WIDTH;

    m_ColumnWidths[CERTMGR_SAFER_USER_ENFORCEMENT] = new UINT[1];
    if ( m_ColumnWidths[CERTMGR_SAFER_USER_ENFORCEMENT] )
        m_ColumnWidths[CERTMGR_SAFER_USER_ENFORCEMENT][0] = SINGLE_COL_WIDTH;

    m_ColumnWidths[CERTMGR_SAFER_COMPUTER_ENFORCEMENT] = new UINT[1];
    if ( m_ColumnWidths[CERTMGR_SAFER_COMPUTER_ENFORCEMENT] )
        m_ColumnWidths[CERTMGR_SAFER_COMPUTER_ENFORCEMENT][0] = SINGLE_COL_WIDTH;

    _TRACE (-1, L"Leaving CCertMgrComponent::CCertMgrComponent\n");
}

CCertMgrComponent::~CCertMgrComponent ()
{
    _TRACE (1, L"Entering CCertMgrComponent::~CCertMgrComponent\n");
    VERIFY ( SUCCEEDED (ReleaseAll ()) );

    CloseAndReleaseUsageStores ();

    for (int i = 0; i < CERTMGR_NUMTYPES; i++)
    {
        if ( m_ColumnWidths[i] )
            delete [] m_ColumnWidths[i];
    }

    if ( m_pLastUsageCookie )
        m_pLastUsageCookie->Release ();

    if ( m_pToolbar )
        m_pToolbar->Release ();

    _TRACE (-1, L"Leaving CCertMgrComponent::~CCertMgrComponent\n");
}

HRESULT CCertMgrComponent::ReleaseAll ()
{
    _TRACE (1, L"Entering CCertMgrComponent::ReleaseAll\n");

    HRESULT hr = CComponent::ReleaseAll ();
    _TRACE (-1, L"Leaving CCertMgrComponent::ReleaseAll: 0x%x\n", hr);
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// IComponent Implementation

HRESULT CCertMgrComponent::LoadStrings ()
{
    _TRACE (1, L"Entering CCertMgrComponent::LoadStrings\n");
    _TRACE (-1, L"Leaving CCertMgrComponent::LoadStrings\n");
    return S_OK;
}

HRESULT CCertMgrComponent::LoadColumns ( CCertMgrCookie* pcookie )
{
    _TRACE (1, L"Entering CCertMgrComponent::LoadColumns\n");
     TEST_NONNULL_PTR_PARAM (pcookie);
    HRESULT hr = S_OK;
    CString str;


    switch ( pcookie->m_objecttype )
    {
    case CERTMGR_SNAPIN:
        if ( IDM_STORE_VIEW == QueryComponentDataRef ().m_activeViewPersist )
            VERIFY (str.LoadString (IDS_COLUMN_LOG_CERTIFICATE_STORE) );
        else
            VERIFY (str.LoadString (IDS_COLUMN_PURPOSE) );
        hr = m_pHeader->InsertColumn (0,
                const_cast<LPWSTR> ((LPCWSTR) str), LVCFMT_LEFT, m_ColumnWidths
                [CERTMGR_SNAPIN][0]);
        break;

    case CERTMGR_LOG_STORE:
        if ( QueryComponentDataRef ().m_bShowPhysicalStoresPersist )
            VERIFY (str.LoadString (IDS_COLUMN_PHYS_CERTIFICATE_STORE) );
        else
            VERIFY (str.LoadString (IDS_COLUMN_OBJECT_TYPE) );
        hr = m_pHeader->InsertColumn (0,
                const_cast<LPWSTR> ((LPCWSTR) str), LVCFMT_LEFT,
                m_ColumnWidths[CERTMGR_LOG_STORE][0]);
        break;

    case CERTMGR_LOG_STORE_GPE:
        {
            CCertStoreGPE* pStore = reinterpret_cast <CCertStoreGPE*> (pcookie);
            if ( pStore )
            {
                switch (pStore->GetStoreType ())
                {
                case EFS_STORE:
                    if ( pStore->IsNullEFSPolicy () )
                    {
                        VERIFY (str.LoadString (IDS_STATUS));
                        hr = m_pHeader->InsertColumn (0,
                                const_cast<LPWSTR> ((LPCWSTR) str), LVCFMT_LEFT,
                                SINGLE_COL_WIDTH);
                    }
                    else
                        hr = LoadColumnsFromArrays ( (INT) (CERTMGR_CERT_CONTAINER));
                    break;

                case ROOT_STORE:
                    hr = LoadColumnsFromArrays ( (INT) (CERTMGR_CERT_CONTAINER));
                    break;

                case TRUST_STORE:
                    hr = LoadColumnsFromArrays ( (INT) (CERTMGR_CTL_CONTAINER));
                    break;

                case ACRS_STORE:
                    VERIFY (str.LoadString (IDS_COLUMN_AUTO_CERT_REQUEST));
                    hr = m_pHeader->InsertColumn (0,
                            const_cast<LPWSTR> ((LPCWSTR) str), LVCFMT_LEFT,
                            m_ColumnWidths[CERTMGR_AUTO_CERT_REQUEST][0]);
                    break;

                default:
                    break;
                }
            }
            else
                {
                     _TRACE (0, L"Unexpected error: reinterpret_cast <CCertStoreGPE*> (pcookie) failed.\n");
                     hr = E_UNEXPECTED;
                }
        }
        break;

    case CERTMGR_LOG_STORE_RSOP:
        {
            CCertStoreRSOP* pStore = reinterpret_cast <CCertStoreRSOP*> (pcookie);
            if ( pStore )
            {
                switch (pStore->GetStoreType ())
                {
                case EFS_STORE:
                    if ( pStore->IsNullEFSPolicy () )
                    {
                        VERIFY (str.LoadString (IDS_STATUS));
                        hr = m_pHeader->InsertColumn (0,
                                const_cast<LPWSTR> ((LPCWSTR) str), LVCFMT_LEFT,
                                SINGLE_COL_WIDTH);
                    }
                    else
                        hr = LoadColumnsFromArrays ( (INT) (CERTMGR_CERT_CONTAINER));
                    break;

                case ROOT_STORE:
                    hr = LoadColumnsFromArrays ( (INT) (CERTMGR_CERT_CONTAINER));
                    break;

                case TRUST_STORE:
                    hr = LoadColumnsFromArrays ( (INT) (CERTMGR_CTL_CONTAINER));
                    break;

                case ACRS_STORE:
                    VERIFY (str.LoadString (IDS_COLUMN_AUTO_CERT_REQUEST));
                    hr = m_pHeader->InsertColumn (0,
                            const_cast<LPWSTR> ((LPCWSTR) str), LVCFMT_LEFT,
                            m_ColumnWidths[CERTMGR_AUTO_CERT_REQUEST][0]);
                    break;

                default:
                    break;
                }
            }
            else
                {
                     _TRACE (0, L"Unexpected error: reinterpret_cast <CCertStoreGPE*> (pcookie) failed.\n");
                     hr = E_UNEXPECTED;
                }
        }
        break;

    default:
        hr = LoadColumnsFromArrays ( (INT) (pcookie->m_objecttype));
        break;
    }


    _TRACE (-1, L"Leaving CCertMgrComponent::LoadColumns: 0x%x\n", hr);
    return hr;
}


/* This is generated by UpdateAllViews () */
HRESULT CCertMgrComponent::OnViewChange (LPDATAOBJECT pDataObject, LPARAM /*data*/, LPARAM hint)
{
    _TRACE (1, L"Entering CCertMgrComponent::OnViewChange\n");
     HRESULT hr = S_OK;
    if ( pDataObject )
    {
        if ( HINT_CERT_ENROLLED_USAGE_MODE & hint )
        {
            // Force reenumeration of usage stores
            m_bUsageStoresEnumerated = false;
        }

        if ( (HINT_CHANGE_VIEW_TYPE & hint) ||
            (HINT_CHANGE_STORE_TYPE & hint) ||
            (HINT_SHOW_ARCHIVE_CERTS & hint) ||
            (HINT_CHANGE_COMPUTER & hint) ||
            (HINT_REFRESH_STORES & hint) )
        {
            hr = QueryComponentDataRef ().RefreshScopePane (0);
        }
        else if ( HINT_EFS_ADD_DEL_POLICY & hint )
        {
            // Delete existing columns and add new columns
            if ( m_pResultData )
            {
                m_pResultData->DeleteAllRsltItems ();
            }
            else
            {
                _TRACE (0, L"Unexpected error: m_pResultData was NULL\n");
            }
            do {
                hr = m_pHeader->DeleteColumn (0);
            } while ( SUCCEEDED (hr) );

            CCertMgrCookie* pCookie = ConvertCookie (pDataObject);
            if ( pCookie )
                hr = LoadColumns (pCookie);
            else
            {
                _TRACE (0, L"Unexpected error: ConvertCookie () returned NULL\n");
                hr = E_UNEXPECTED;
            }
        }
        else if ( (HINT_PASTE_COOKIE & hint) ||
                (HINT_IMPORT & hint) )
        {
            // Do nothing
        }
        else
        {
            hr = QueryComponentDataRef ().RefreshScopePane (pDataObject);
            if ( IDM_USAGE_VIEW == QueryComponentDataRef ().m_activeViewPersist && 
                    m_pLastUsageCookie)
            {
                hr = DisplayCertificateCountByUsage (
                        m_pLastUsageCookie->GetObjectName (),
                        m_pLastUsageCookie->GetCertCount ());
            }
        }

        if ( SUCCEEDED (hr) )
        {
            hr = RefreshResultPane ();
        }

        CCertMgrComponentData&  compData = QueryComponentDataRef ();
        CCertMgrCookie* pCookie = compData.ConvertCookie (pDataObject);
        if ( pCookie )
        {
            switch (pCookie->m_objecttype)
            {
            case CERTMGR_CERTIFICATE:
                {
                    CCertificate* pCert = reinterpret_cast <CCertificate*> (pCookie);
                    if ( pCert )
                    {
                        if ( IDM_STORE_VIEW == QueryComponentDataRef ().m_activeViewPersist )
                        {
                            hr = DisplayCertificateCountByStore (m_pConsole, 
                                    pCert->GetCertStore ());
                        }
                        else
                        {
                            ASSERT (m_pLastUsageCookie);
                            if ( m_pLastUsageCookie )
                            {
                                 hr = DisplayCertificateCountByUsage (
                                        m_pLastUsageCookie->GetObjectName (),
                                        m_pLastUsageCookie->GetCertCount ());
                            }
                        }
                    }
                }
                break;

            case CERTMGR_LOG_STORE:
            case CERTMGR_PHYS_STORE:
            case CERTMGR_LOG_STORE_GPE:
            case CERTMGR_LOG_STORE_RSOP:
                {
                    CCertStore* pStore = reinterpret_cast <CCertStore*> (pCookie);
                    if ( pStore )
                    {
                        pStore->GetStoreHandle (); // to initialize read-only flag
                        if ( pStore->IsReadOnly () )
                            m_pConsoleVerb->SetVerbState (MMC_VERB_PASTE, ENABLED, FALSE);
                        else
                            m_pConsoleVerb->SetVerbState (MMC_VERB_PASTE, ENABLED, TRUE);
                        hr = DisplayCertificateCountByStore (m_pConsole, pStore,
                                (CERTMGR_LOG_STORE_GPE == pCookie->m_objecttype || 
                                CERTMGR_LOG_STORE_RSOP == pCookie->m_objecttype));
                        pStore->Close ();
                    }
                    else
                        hr = E_UNEXPECTED;
                }
                break;

            case CERTMGR_USAGE:
                {
                    CUsageCookie* pUsage = reinterpret_cast <CUsageCookie*> (pCookie);
                    if ( pUsage )
                    {
                        hr = DisplayCertificateCountByUsage (pCookie->GetObjectName (),
                        pUsage->GetCertCount ());
                    }
                    else
                        hr = E_UNEXPECTED;
                }
                break;

            case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
            case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
                ASSERT (0);
                break;

            case CERTMGR_SNAPIN:
            case CERTMGR_CRL_CONTAINER:
            case CERTMGR_CTL_CONTAINER:
            case CERTMGR_CERT_CONTAINER:
            case CERTMGR_CRL:
            case CERTMGR_CTL:
            case CERTMGR_AUTO_CERT_REQUEST:
            case CERTMGR_CERT_POLICIES_USER:
            case CERTMGR_CERT_POLICIES_COMPUTER:
            default:
                {
                    IConsole2*  pConsole2 = 0;
                    hr = m_pConsole->QueryInterface (
                            IID_PPV_ARG(IConsole2, &pConsole2));
                    if (SUCCEEDED (hr))
                    {
                        hr = pConsole2->SetStatusText (L"");
                        if ( !SUCCEEDED (hr) )
                        {
                            _TRACE (0, L"IConsole2::SetStatusText () failed: %x", hr);
                        }
                        pConsole2->Release ();
                    }
                }
                break;
            }
        }
    }
    else
    {
        hr = E_POINTER;
        _TRACE (0, L"Unexpected error: paramater pDataObject was NULL\n");
    }

    _TRACE (-1, L"Leaving CCertMgrComponent::OnViewChange: 0x%x\n", hr);
    return hr;
}

HRESULT CCertMgrComponent::Show ( CCookie* pcookie, LPARAM arg, HSCOPEITEM /*hScopeItem*/, LPDATAOBJECT /*pDataObject*/)
{
    _TRACE (1, L"Entering CCertMgrComponent::Show\n");
    HRESULT hr = S_OK;
     TEST_NONNULL_PTR_PARAM (pcookie);

    if ( !arg )
    {
        if ( !m_pResultData )
        {
            _TRACE (0, L"Unexpected error: m_pResultData was NULL\n");
            return E_UNEXPECTED;
        }

        m_pViewedCookie = reinterpret_cast <CCertMgrCookie*> (pcookie);
        if ( m_pViewedCookie )
            hr = SaveWidths (m_pViewedCookie);
        m_pViewedCookie = 0;
        return S_OK;
    }

    if ( m_pResultData )
    {
        MMC_RESULT_VIEW_STYLE dwRemoveStyle = (MMC_RESULT_VIEW_STYLE) 0;
        MMC_RESULT_VIEW_STYLE dwAddStyle = (MMC_RESULT_VIEW_STYLE) 0;
        CCertMgrCookie* pCertMgrCookie = dynamic_cast <CCertMgrCookie*> (pcookie);
        if ( pCertMgrCookie )
        {
            switch (pCertMgrCookie->m_objecttype)
            {
            case CERTMGR_CERTIFICATE:
            case CERTMGR_LOG_STORE:
            case CERTMGR_PHYS_STORE:
            case CERTMGR_CRL:
            case CERTMGR_CTL:
            case CERTMGR_AUTO_CERT_REQUEST:
            case CERTMGR_CERT_POLICIES_USER:
            case CERTMGR_CERT_POLICIES_COMPUTER:
            case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
            case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
            case CERTMGR_SAFER_COMPUTER_ROOT:
            case CERTMGR_SAFER_USER_ROOT:
            case CERTMGR_SAFER_COMPUTER_LEVEL:
            case CERTMGR_SAFER_USER_LEVEL:
            case CERTMGR_SAFER_COMPUTER_ENTRY:
            case CERTMGR_SAFER_USER_ENTRY:
            case CERTMGR_SAFER_COMPUTER_TRUSTED_PUBLISHERS:
            case CERTMGR_SAFER_USER_TRUSTED_PUBLISHERS:
            case CERTMGR_SAFER_COMPUTER_DEFINED_FILE_TYPES:
            case CERTMGR_SAFER_USER_DEFINED_FILE_TYPES:
            case CERTMGR_SAFER_USER_ENFORCEMENT:
            case CERTMGR_SAFER_COMPUTER_ENFORCEMENT:
                dwAddStyle = MMC_NOSORTHEADER;
                break;

            case CERTMGR_SNAPIN:
            case CERTMGR_USAGE:
            case CERTMGR_CRL_CONTAINER:
            case CERTMGR_CTL_CONTAINER:
            case CERTMGR_CERT_CONTAINER:
            case CERTMGR_LOG_STORE_GPE:
            case CERTMGR_LOG_STORE_RSOP:
            case CERTMGR_SAFER_COMPUTER_LEVELS:
            case CERTMGR_SAFER_USER_LEVELS:
            case CERTMGR_SAFER_COMPUTER_ENTRIES:
            case CERTMGR_SAFER_USER_ENTRIES:
                dwRemoveStyle = MMC_NOSORTHEADER;
                break;

            default:
                ASSERT (0);
                break;
            }
            m_pResultData->ModifyViewStyle (
                    (MMC_RESULT_VIEW_STYLE) (MMC_ENSUREFOCUSVISIBLE | MMC_SHOWSELALWAYS | dwAddStyle), 
                    dwRemoveStyle);
        }
    }

    m_pViewedCookie = reinterpret_cast <CCertMgrCookie*> (pcookie);
     if ( m_pViewedCookie )
    {
        // Load default columns and widths
        LoadColumns (m_pViewedCookie);

        // Restore persisted column widths
        switch (m_pViewedCookie->m_objecttype)
        {
        case CERTMGR_SNAPIN:
        case CERTMGR_USAGE:
        case CERTMGR_PHYS_STORE:
        case CERTMGR_LOG_STORE:
        case CERTMGR_CRL_CONTAINER:
        case CERTMGR_CTL_CONTAINER:
        case CERTMGR_CERT_CONTAINER:
        case CERTMGR_LOG_STORE_GPE:
        case CERTMGR_LOG_STORE_RSOP:
        case CERTMGR_CERT_POLICIES_USER:
        case CERTMGR_CERT_POLICIES_COMPUTER:
        case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
        case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
            break;

        case CERTMGR_CERTIFICATE:
        case CERTMGR_CRL:
        case CERTMGR_CTL:
        case CERTMGR_AUTO_CERT_REQUEST:
        default:
            _TRACE (0, L"Invalid or unexpected m_objecttype in switch: 0x%x\n", m_pViewedCookie->m_objecttype);
            break;
        }

        hr = PopulateListbox (m_pViewedCookie);
    }

    _TRACE (-1, L"Leaving CCertMgrComponent::Show: 0x%x\n", hr);
    return hr;
}

HRESULT CCertMgrComponent::Show ( CCookie* pcookie, LPARAM arg, HSCOPEITEM hScopeItem)
{
    _TRACE (1, L"Entering CCertMgrComponent::Show\n");
    _TRACE (0, L"Unexpected: We should never enter this method.\n");
    _TRACE (-1, L"Leaving CCertMgrComponent::Show\n");
    return Show (pcookie, arg, hScopeItem, 0);
}


HRESULT CCertMgrComponent::OnNotifyAddImages (
        LPDATAOBJECT /*pDataObject*/,
        LPIMAGELIST lpImageList,
        HSCOPEITEM /*hSelectedItem*/)
{
    _TRACE (1, L"Entering CCertMgrComponent::OnNotifyAddImages\n");
    long    lViewMode = 0;
     HRESULT hr = S_OK;

    if ( m_pResultData )
     {
         QueryComponentDataRef ().SetResultData (m_pResultData);

         hr = m_pResultData->GetViewMode (&lViewMode);  
         if ( SUCCEEDED (hr) )
         {
            BOOL    bLoadLargeIcons = (LVS_ICON == lViewMode);

            hr = QueryComponentDataRef ().LoadIcons (lpImageList, bLoadLargeIcons);
         }
     }
     else
     {
          _TRACE (0, L"Unexpected error: m_pResultData is NULL\n");
          hr = E_UNEXPECTED;
     }
    _TRACE (-1, L"Leaving CCertMgrComponent::OnNotifyAddImages: 0x%x\n", hr);
    return hr;
}

HRESULT CCertMgrComponent::EnumCertificates (CCertStore& rCertStore)
{
    _TRACE (1, L"Entering CCertMgrComponent::EnumCertificates\n");

    CWaitCursor             cursor;
     PCCERT_CONTEXT         pCertContext = 0;
    HRESULT                 hr = 0;
    CCertificate*           pCert = 0;
    RESULTDATAITEM          rdItem;
    CCertMgrComponentData&  dataRef = QueryComponentDataRef ();
    CCookie&                rootCookie = dataRef.QueryBaseRootCookie ();

    // security review 2/26/2002 BryanWal ok
    ::ZeroMemory (&rdItem, sizeof (rdItem));
    rdItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
    rdItem.nImage = iIconCertificate;
    rdItem.nCol = 0;
    rdItem.str = MMC_TEXTCALLBACK;


    //  Iterate through the list of certificates in the system store,
    //  allocate new certificates with the CERT_CONTEXT returned,
    //  and store them in the certificate list.
    while ( 1 )
    {
        pCertContext = rCertStore.EnumCertificates (pCertContext);
        if ( !pCertContext )
        {
            if ( EFS_STORE == rCertStore.GetStoreType () )
            {
                if ( rCertStore.IsNullEFSPolicy () )
                {
                    CComPtr<IUnknown> spUnknown;
                    hr = m_pConsole->QueryResultView(&spUnknown);
                    if ( SUCCEEDED (hr) )
                    {
                        CComPtr<IMessageView> spMessageView;
                        hr = spUnknown->QueryInterface (IID_PPV_ARG (IMessageView, &spMessageView));
                        if (SUCCEEDED(hr))
                        {
                            CString szTitle;
                            CString szMessage;

                            VERIFY (szTitle.LoadString (IDS_EFS_NO_POLICY_TITLE));
                            if ( dataRef.m_bIsRSOP )
                                VERIFY (szMessage.LoadString (IDS_EFS_NO_POLICY_TEXT_RSOP));
                            else
                                VERIFY (szMessage.LoadString (IDS_EFS_NO_POLICY_TEXT));

                            spMessageView->SetTitleText (szTitle);
                            spMessageView->SetBodyText (szMessage);
                            spMessageView->SetIcon (Icon_Warning);
                        }
                    }
                }
            }
            break;
        }
        pCert =
            new CCertificate (pCertContext, &rCertStore);
        if ( !pCert )
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        rootCookie.m_listResultCookieBlocks.AddHead (pCert);
        rdItem.lParam = (LPARAM) pCert;
        pCert->m_resultDataID = m_pResultData;
        hr = m_pResultData->InsertItem (&rdItem);
          if ( FAILED (hr) )
          {
             _TRACE (0, L"IResultData::InsertItem () failed: 0x%x\n", hr);
          }
    }
    rCertStore.Close ();

    _TRACE (-1, L"Leaving CCertMgrComponent::EnumCertificates: 0x%x\n", hr);
    return hr;
}

HRESULT CCertMgrComponent::PopulateListbox (CCertMgrCookie* pCookie)
{
    _TRACE (1, L"Entering CCertMgrComponent::PopulateListbox\n");
    if ( !pCookie )
        return E_POINTER;

    HRESULT     hr = S_OK;
    CWaitCursor cursor;
    CCertMgrComponentData& dataRef = QueryComponentDataRef ();

    switch ( pCookie->m_objecttype )
    {
    case CERTMGR_PHYS_STORE:
    case CERTMGR_LOG_STORE:
        break;

    case CERTMGR_LOG_STORE_GPE:
    case CERTMGR_LOG_STORE_RSOP:
        {
            CCertStore* pStore = reinterpret_cast <CCertStore*> (pCookie);
            if ( pStore )
            {
                switch (pStore->GetStoreType () )
                {
                case EFS_STORE:
                case ROOT_STORE:
                    hr = EnumCertificates (*pStore);
                    if ( SUCCEEDED (hr) )
                    {
                        m_currResultNodeType = CERTMGR_CERTIFICATE;
                        m_pResultData->Sort (m_nSelectedCertColumn, 0, 
                                (long) m_currResultNodeType);
                    }
                    break;

                case ACRS_STORE:
                    hr = EnumCTLs (*pStore);
                    if ( SUCCEEDED (hr) )
                    {
                        m_currResultNodeType = CERTMGR_AUTO_CERT_REQUEST;
                        m_pResultData->Sort (m_nSelectedCTLColumn, 0, 
                                (long) m_currResultNodeType);
                    }
                    break;

                case TRUST_STORE:
                    hr = EnumCTLs (*pStore);
                    if ( SUCCEEDED (hr) )
                    {
                        m_currResultNodeType = CERTMGR_CTL;
                        m_pResultData->Sort (m_nSelectedCTLColumn, 0, 
                                (long) m_currResultNodeType);
                    }
                    break;


                default:
                     _TRACE (0, L"Error: Unexpected store type: 0x%x\n", pStore->GetStoreType ());
                          hr = E_UNEXPECTED;
                    break;
                }

                if ( SUCCEEDED (hr) )
                    hr = DisplayCertificateCountByStore (m_pConsole, pStore, true);
            }
            else
                hr = E_POINTER;
        }
        break;

    case CERTMGR_CERT_CONTAINER:
        {
            CContainerCookie*   pContainer = reinterpret_cast <CContainerCookie*> (pCookie);
            if ( pContainer )
            {
                hr = EnumCertificates (pContainer->GetCertStore ());
                if ( SUCCEEDED (hr) )
                {
                    m_currResultNodeType = CERTMGR_CERTIFICATE;
                    m_pResultData->Sort (m_nSelectedCertColumn, 0, 
                            (long) m_currResultNodeType);
                    hr = DisplayCertificateCountByStore (m_pConsole, &pContainer->GetCertStore (), false);
                }
            }
        }
        break;

    case CERTMGR_USAGE:
        {
            CUsageCookie* pUsageCookie = reinterpret_cast <CUsageCookie*> (pCookie);
            if ( pUsageCookie )
            {
                hr = EnumCertsByUsage (pUsageCookie);
                if ( SUCCEEDED (hr) )
                {
                    m_currResultNodeType = CERTMGR_CERTIFICATE;
                    m_pResultData->Sort (m_nSelectedCertColumn, 0, 
                            (long) m_currResultNodeType);
                }
            }
        }
        break;

    case CERTMGR_CRL_CONTAINER:
        {
            CContainerCookie*   pContainer = reinterpret_cast <CContainerCookie*> (pCookie);
            if ( pContainer )
            {
                PCCRL_CONTEXT   pCRLContext = 0;
                CCRL*           pCRL = 0;
                RESULTDATAITEM  rdItem;
                CCookie&        rootCookie = dataRef.QueryBaseRootCookie ();


                // security review 2/26/2002 BryanWal ok
                ::ZeroMemory (&rdItem, sizeof (rdItem));
                rdItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
                rdItem.nImage = iIconCRL;
                rdItem.nCol = 0;

                //  Iterate through the list of certificates in the system store,
                //  allocate new certificates with the CERT_CONTEXT returned,
                //  and store them in the certificate list.
                DWORD   dwFlags = 0;
                while ( 1 )
                {
                    pCRLContext = pContainer->GetCertStore ().GetCRL (NULL,
                            pCRLContext, &dwFlags);
                    if ( !pCRLContext )
                        break;
                    pCRL =
                        new CCRL (pCRLContext, pContainer->GetCertStore ());
                    if ( !pCRL )
                    {
                        hr = E_OUTOFMEMORY;
                        break;
                    }

                    rootCookie.m_listResultCookieBlocks.AddHead (pCRL);
                    rdItem.str = MMC_TEXTCALLBACK;
                    rdItem.lParam = (LPARAM) pCRL;
                    pCRL->m_resultDataID = m_pResultData;
                    hr = m_pResultData->InsertItem (&rdItem);
                          if ( FAILED (hr) )
                          {
                             _TRACE (0, L"IResultData::InsertItem () failed: 0x%x\n", hr);
                          }
                }
                if ( SUCCEEDED (hr) )
                {
                    m_currResultNodeType = CERTMGR_CRL;
                    m_pResultData->Sort (m_nSelectedCRLColumn, 0, 
                            (long) m_currResultNodeType);
                }
            }
        }
        break;

    case CERTMGR_CTL_CONTAINER:
        {
            CContainerCookie*   pContainer = reinterpret_cast <CContainerCookie*> (pCookie);
            if ( pContainer )
            {
                hr = EnumCTLs (pContainer->GetCertStore ());
                if ( SUCCEEDED (hr) )
                {
                    m_currResultNodeType = CERTMGR_CTL;
                    m_pResultData->Sort (m_nSelectedCTLColumn, 0, 
                            (long) m_currResultNodeType);
                    hr = DisplayCertificateCountByStore (m_pConsole, &pContainer->GetCertStore (), false);
                }
            }
        }
        break;


    case CERTMGR_CERT_POLICIES_USER:
    case CERTMGR_CERT_POLICIES_COMPUTER:
        // Only this node if machine is joined to a Whistler or later domain
        if ( !dataRef.m_bMachineIsStandAlone && !g_bSchemaIsW2K )
        {
            RESULTDATAITEM  rdItem;
            CCookie&        rootCookie = dataRef.QueryBaseRootCookie ();


            // security review 2/26/2002 BryanWal ok
            ::ZeroMemory (&rdItem, sizeof (rdItem));
            rdItem.mask = RDI_STR | RDI_PARAM | RDI_IMAGE;
            rdItem.nImage = iIconAutoEnroll;
            rdItem.nCol = 0;

            CString objectName;
            VERIFY (objectName.LoadString (IDS_PKP_AUTOENROLLMENT_SETTINGS));
            CCertMgrCookie* pNewCookie = new CCertMgrCookie (
                    CERTMGR_CERT_POLICIES_COMPUTER == pCookie->m_objecttype ? 
                        CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS :
                        CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS,
                    pCookie->QueryNonNULLMachineName (),
                    objectName);
            if ( !pNewCookie )
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            rootCookie.m_listResultCookieBlocks.AddHead (pNewCookie);
            rdItem.str = MMC_TEXTCALLBACK ;
            rdItem.lParam = (LPARAM) pNewCookie;
            pNewCookie->m_resultDataID = m_pResultData;
            hr = m_pResultData->InsertItem (&rdItem);
            if ( FAILED (hr) )
            {
                 _TRACE (0, L"IResultData::InsertItem () failed: 0x%x\n", hr);
            }
        }
        break;

    case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
    case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
        ASSERT (0);
        break;

    case CERTMGR_SAFER_COMPUTER_LEVELS:
        {
            CPolicyKey  policyKey (dataRef.m_pGPEInformation, 
                    SAFER_HKLM_REGBASE, true);
            hr = AddSaferLevels (true, 
                    pCookie->QueryNonNULLMachineName (), policyKey.GetKey ());
        }
        break;

    case CERTMGR_SAFER_USER_LEVELS:
        {
            CPolicyKey  policyKey (dataRef.m_pGPEInformation, 
                    SAFER_HKLM_REGBASE, false);
            hr = AddSaferLevels (false, 
                    pCookie->QueryNonNULLMachineName (), policyKey.GetKey ());
        }
        break;

    case CERTMGR_SAFER_COMPUTER_ENTRIES:
    case CERTMGR_SAFER_USER_ENTRIES:
        {
            CSaferEntries* pSaferEntries = dynamic_cast <CSaferEntries*> (pCookie);
            if ( pSaferEntries )
            {
                hr = SaferEnumerateEntries (
                        CERTMGR_SAFER_COMPUTER_ENTRIES == pCookie->m_objecttype,
                        pSaferEntries);
                if (SUCCEEDED (hr) )
                    m_pResultData->Sort (m_nSelectedCertColumn, 0, 
                            (long) m_currResultNodeType);
            }
        }
        break;

    case CERTMGR_SAFER_COMPUTER_ROOT:
    case CERTMGR_SAFER_USER_ROOT:
        {
            CSaferRootCookie* pSaferRootCookie = dynamic_cast <CSaferRootCookie*> (pCookie);
            if ( pSaferRootCookie )
            {
                if ( (pSaferRootCookie->m_bCreateSaferNodes && dataRef.m_bSaferSupported) 
                        || dataRef.m_bIsRSOP )
                {
                    RESULTDATAITEM  rdItem;
                    CCookie&        rootCookie = dataRef.QueryBaseRootCookie ();


                    // security review 2/26/2002 BryanWal ok
                    ::ZeroMemory (&rdItem, sizeof (rdItem));
                    rdItem.mask = RDI_STR | RDI_PARAM | RDI_IMAGE;
                    rdItem.nImage = iIconSettings;
                    rdItem.nCol = 0;

                    CString         objectName;
                    CCertMgrCookie* pNewCookie = 0;

                    if ( SUCCEEDED (hr) )
                    {
                        VERIFY (objectName.LoadString (IDS_SAFER_ENFORCEMENT));
                        pNewCookie = new CCertMgrCookie (
                                CERTMGR_SAFER_COMPUTER_ROOT == pCookie->m_objecttype ? 
                                    CERTMGR_SAFER_COMPUTER_ENFORCEMENT :
                                    CERTMGR_SAFER_USER_ENFORCEMENT,
                                pCookie->QueryNonNULLMachineName (),
                                objectName);
                        if ( !pNewCookie )
                        {
                            hr = E_OUTOFMEMORY;
                            break;
                        }

                        rootCookie.m_listResultCookieBlocks.AddHead (pNewCookie);
                        rdItem.str = MMC_TEXTCALLBACK ;
                        rdItem.lParam = (LPARAM) pNewCookie;
                        pNewCookie->m_resultDataID = m_pResultData;
                        hr = m_pResultData->InsertItem (&rdItem);
                        if ( FAILED (hr) )
                        {
                             _TRACE (0, L"IResultData::InsertItem () failed: 0x%x\n", hr);
                        }
                    }

                    if ( SUCCEEDED (hr) )
                    {
                        VERIFY (objectName.LoadString (IDS_SAFER_DEFINED_FILE_TYPES));
                        pNewCookie = new CCertMgrCookie (
                                CERTMGR_SAFER_COMPUTER_ROOT == pCookie->m_objecttype ? 
                                    CERTMGR_SAFER_COMPUTER_DEFINED_FILE_TYPES :
                                    CERTMGR_SAFER_USER_DEFINED_FILE_TYPES,
                                pCookie->QueryNonNULLMachineName (),
                                objectName);
                        if ( !pNewCookie )
                        {
                            hr = E_OUTOFMEMORY;
                            break;
                        }

                        rootCookie.m_listResultCookieBlocks.AddHead (pNewCookie);

                        rdItem.str = MMC_TEXTCALLBACK ;
                        rdItem.lParam = (LPARAM) pNewCookie;
                        pNewCookie->m_resultDataID = m_pResultData;
                        hr = m_pResultData->InsertItem (&rdItem);
                        if ( FAILED (hr) )
                        {
                             _TRACE (0, L"IResultData::InsertItem () failed: 0x%x\n", hr);
                        }
                    }

                    if ( SUCCEEDED (hr) )
                    {
                        VERIFY (objectName.LoadString (IDS_SAFER_TRUSTED_PUBLISHERS));
                        pNewCookie = new CCertMgrCookie (
                                CERTMGR_SAFER_COMPUTER_ROOT == pCookie->m_objecttype ? 
                                    CERTMGR_SAFER_COMPUTER_TRUSTED_PUBLISHERS :
                                    CERTMGR_SAFER_USER_TRUSTED_PUBLISHERS,
                                pCookie->QueryNonNULLMachineName (),
                                objectName);
                        if ( !pNewCookie )
                        {
                            hr = E_OUTOFMEMORY;
                            break;
                        }

                        rootCookie.m_listResultCookieBlocks.AddHead (pNewCookie);

                        rdItem.str = MMC_TEXTCALLBACK ;
                        rdItem.lParam = (LPARAM) pNewCookie;
                        pNewCookie->m_resultDataID = m_pResultData;
                        hr = m_pResultData->InsertItem (&rdItem);
                        if ( FAILED (hr) )
                        {
                             _TRACE (0, L"IResultData::InsertItem () failed: 0x%x\n", hr);
                        }
                    }
                }
                else
                {
                    CComPtr<IUnknown> spUnknown;
                    hr = m_pConsole->QueryResultView(&spUnknown);
                    if ( SUCCEEDED (hr) )
                    {
                        CComPtr<IMessageView> spMessageView;
                        hr = spUnknown->QueryInterface (IID_PPV_ARG (IMessageView, &spMessageView));
                        if (SUCCEEDED(hr))
                        {
                            CString szTitle;
                            CString szMessage;

                            VERIFY (szTitle.LoadString (IDS_SAFER_NO_POLICY_TITLE));
                            VERIFY (szMessage.LoadString (IDS_SAFER_NO_POLICY_TEXT));

                            spMessageView->SetTitleText (szTitle);
                            spMessageView->SetBodyText (szMessage);
                            spMessageView->SetIcon (Icon_Warning);
                        }
                    }
                }
            }
        }
        break;

    default:
        break;
    }

    _TRACE (-1, L"Leaving CCertMgrComponent::PopulateListbox: 0x%x\n", hr);
    return hr;
}

HRESULT CCertMgrComponent::RefreshResultPane ()
{
    _TRACE (1, L"Entering CCertMgrComponent::RefreshResultPane\n");
    HRESULT hr = S_OK;

    if ( m_pResultData )
    {
        // Does this return E_UNEXPECTED when there are no items?
        HRESULT hr1 = m_pResultData->DeleteAllRsltItems ();
        if ( FAILED (hr1) )
        {
               _TRACE (0, L"IResultData::DeleteAllRsltItems () failed: 0x%x\n", hr1);
        }
    }
    else
     {
          _TRACE (0, L"Unexpected error: m_pResultData is NULL\n");
        hr = E_UNEXPECTED;
     }

    if ( m_pViewedCookie )
    {
        hr = PopulateListbox (m_pViewedCookie);
    }

    _TRACE (-1, L"Leaving CCertMgrComponent::RefreshResultPane: 0x%x\n", hr);
    return hr;
}

STDMETHODIMP CCertMgrComponent::GetDisplayInfo (RESULTDATAITEM * pResult)
{   
//  _TRACE (1, L"Entering CCertMgrComponent::GetDisplayInfo\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    HRESULT hr = S_OK;


    if ( pResult && !pResult->bScopeItem ) //&& (pResult->mask & RDI_PARAM) )
    {
        CCookie* pResultCookie = reinterpret_cast<CCookie*> (pResult->lParam);
        ASSERT (pResultCookie);
        if ( !pResultCookie || IsBadWritePtr ((LPVOID) pResultCookie, sizeof (CCookie)) )
            return E_UNEXPECTED;

        CCookie* pActiveCookie = ActiveBaseCookie (pResultCookie);
        ASSERT (pActiveCookie);
        if ( !pActiveCookie || IsBadWritePtr ((LPVOID) pActiveCookie, sizeof (CCookie)) )
            return E_UNEXPECTED;

        CCertMgrCookie* pCookie = reinterpret_cast <CCertMgrCookie*>(pActiveCookie);
        ASSERT (pCookie);
        switch (pCookie->m_objecttype)
        {
        case CERTMGR_SAFER_COMPUTER_LEVELS:
        case CERTMGR_SAFER_COMPUTER_ENTRIES:
        case CERTMGR_SAFER_USER_LEVELS:
        case CERTMGR_SAFER_USER_ENTRIES:
            // iIconSaferHashEntry
            // iIconSaferURLEntry
            // iIconSaferNameEntry
            ASSERT (0);
            break;

        case CERTMGR_SAFER_COMPUTER_LEVEL:
        case CERTMGR_SAFER_USER_LEVEL:
            if (pResult->mask & RDI_STR)
            {
                if ( COLNUM_SAFER_LEVEL_NAME == pResult->nCol )
                {
                    m_szDisplayInfoResult = pCookie->GetObjectName ();
                    pResult->str = const_cast<LPWSTR> ( (LPCWSTR) m_szDisplayInfoResult);
                }
                else if ( COLNUM_SAFER_LEVEL_DESCRIPTION == pResult->nCol )
                {
                    CSaferLevel* pLevel = dynamic_cast <CSaferLevel*> (pCookie);
                    if ( pLevel )
                    {
                        m_szDisplayInfoResult = pLevel->GetDescription ();
                        pResult->str = const_cast<LPWSTR> ( (LPCWSTR) m_szDisplayInfoResult);
                    }
                }
            }
            if ( pResult->mask & RDI_IMAGE )
            {
                CSaferLevel* pLevel = dynamic_cast <CSaferLevel*> (pCookie);
                if ( pLevel && pLevel->IsDefault () )
                {
                    QueryComponentDataRef ().m_dwDefaultSaferLevel = 
                            pLevel->GetLevel ();
                    pResult->nImage = iIconDefaultSaferLevel;
                }
                else
                    pResult->nImage = iIconSaferLevel;
            }
            break;

        case CERTMGR_SAFER_COMPUTER_ENTRY:
        case CERTMGR_SAFER_USER_ENTRY:
            if (pResult->mask & RDI_STR)
            {
                CSaferEntry* pSaferEntry = dynamic_cast <CSaferEntry*> (pCookie);
                if ( pSaferEntry )
                {
                    switch (pResult->nCol)
                    {
                    case COLNUM_SAFER_ENTRIES_NAME:
                        m_szDisplayInfoResult = pSaferEntry->GetDisplayName ();
                        pResult->str = const_cast<LPWSTR> ( (LPCWSTR) m_szDisplayInfoResult);
                        break;

                    case COLNUM_SAFER_ENTRIES_TYPE:
                        m_szDisplayInfoResult = pSaferEntry->GetTypeString ();
                        pResult->str = const_cast<LPWSTR> ( (LPCWSTR) m_szDisplayInfoResult);
                        break;

                    case COLNUM_SAFER_ENTRIES_LEVEL:
                        m_szDisplayInfoResult = pSaferEntry->GetLevelFriendlyName ();
                        pResult->str = const_cast<LPWSTR> ( (LPCWSTR) m_szDisplayInfoResult);
                        break;

                    case COLNUM_SAFER_ENTRIES_DESCRIPTION:
                        m_szDisplayInfoResult = pSaferEntry->GetDescription ();
                        pResult->str = const_cast<LPWSTR> ( (LPCWSTR) m_szDisplayInfoResult);
                        break;

                    case COLNUM_SAFER_ENTRIES_LAST_MODIFIED_DATE:
                        m_szDisplayInfoResult = pSaferEntry->GetShortLastModified ();
                        pResult->str = const_cast<LPWSTR> ( (LPCWSTR) m_szDisplayInfoResult);
                        break;

                    default:
                        ASSERT (0);
                        break;
                    }
                }
            }
            if ( pResult->mask & RDI_IMAGE )
            {
                CSaferEntry* pEntry = dynamic_cast <CSaferEntry*> (pCookie);
                if ( pEntry )
                {
                    switch (pEntry->GetType () )
                    {
                    case SAFER_ENTRY_TYPE_HASH:
                        pResult->nImage = iIconSaferHashEntry;
                        break;

                    case SAFER_ENTRY_TYPE_PATH:
                        pResult->nImage = iIconSaferNameEntry;
                        break;

                    case SAFER_ENTRY_TYPE_URLZONE:
                        pResult->nImage = iIconSaferURLEntry;
                        break;

                    case SAFER_ENTRY_TYPE_CERT:
                        pResult->nImage = iIconSaferCertEntry;
                        break;

                    default:
                        ASSERT (0);
                        break;
                    }
                }
            }
            break;


        case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
        case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
            if (pResult->mask & RDI_STR)
            {
                if ( 0 == pResult->nCol )
                {
                    m_szDisplayInfoResult = pCookie->GetObjectName ();
                    pResult->str = const_cast<LPWSTR> ( (LPCWSTR) m_szDisplayInfoResult);
                }
            }
            if (pResult->mask & RDI_IMAGE)
                pResult->nImage = iIconAutoEnroll;
            break;

        case CERTMGR_SAFER_COMPUTER_TRUSTED_PUBLISHERS:
        case CERTMGR_SAFER_USER_TRUSTED_PUBLISHERS:
        case CERTMGR_SAFER_COMPUTER_DEFINED_FILE_TYPES:
        case CERTMGR_SAFER_USER_DEFINED_FILE_TYPES:
        case CERTMGR_SAFER_COMPUTER_ENFORCEMENT:
        case CERTMGR_SAFER_USER_ENFORCEMENT:
            if (pResult->mask & RDI_STR)
            {
                if ( 0 == pResult->nCol )
                {
                    m_szDisplayInfoResult = pCookie->GetObjectName ();
                    pResult->str = const_cast<LPWSTR> ( (LPCWSTR) m_szDisplayInfoResult);
                }
            }
            if (pResult->mask & RDI_IMAGE)
                pResult->nImage = iIconSettings;
            break;

        case CERTMGR_CERTIFICATE:
            {
                CCertificate* pCert = reinterpret_cast <CCertificate*> (pCookie);
                ASSERT (pCert);
                if ( pCert )
                {
                    if (pResult->mask & RDI_STR)
                    {
                        // Note:  text is first stored in class variable so that the buffer is
                        // somewhat persistent.  Copying the buffer pointer directly to the
                        // pResult->str would result in the buffer being freed before the pointer
                        // is used.
                        switch (pResult->nCol)
                        {
                        case COLNUM_CERT_ISSUER:
                            m_szDisplayInfoResult = pCert->GetIssuerName ();
                            if ( m_szDisplayInfoResult.IsEmpty () )
                            {
                                m_szDisplayInfoResult = pCert->GetAlternateIssuerName ();
                                if ( m_szDisplayInfoResult.IsEmpty () )
                                    SetTextNotAvailable ();
                            }
                            break;

                        case COLNUM_CERT_SUBJECT:
                            m_szDisplayInfoResult = pCert->GetSubjectName ();
                            if ( m_szDisplayInfoResult.IsEmpty () )
                            {
                                m_szDisplayInfoResult = pCert->GetAlternateSubjectName ();
                                if ( m_szDisplayInfoResult.IsEmpty () )
                                    SetTextNotAvailable ();
                            }
                            break;

                        case COLNUM_CERT_EXPIRATION_DATE:
                            m_szDisplayInfoResult = pCert->GetValidNotAfter ();
                            break;

                        case COLNUM_CERT_PURPOSE:
                            m_szDisplayInfoResult = pCert->GetEnhancedKeyUsage ();
                            break;

                        case COLNUM_CERT_CERT_NAME:
                            m_szDisplayInfoResult = pCert->GetFriendlyName ();
                            break;

                        case COLNUM_CERT_STATUS:
                            m_szDisplayInfoResult = pCert->FormatStatus ();
                            break;

                        // NTRAID# 247237   Cert UI: Cert Snapin: Certificates snapin should show  template name
                        case COLNUM_CERT_TEMPLATE:
                            m_szDisplayInfoResult = pCert->GetTemplateName ();
                            break;

                        default:
                            ASSERT (0);
                            break;
                        }

                        pResult->str = const_cast<LPWSTR> ( (LPCWSTR) m_szDisplayInfoResult);
                    }
                    if (pResult->mask & RDI_IMAGE)
                        pResult->nImage = iIconCertificate;
                }
            }
            break;

        case CERTMGR_CTL:
            {
                CCTL* pCTL = reinterpret_cast <CCTL*> (pCookie);
                ASSERT (pCTL);
                if ( pCTL )
                {
                    if (pResult->mask & RDI_STR)
                    {
                        // Note:  text is first stored in class variable so that the buffer is
                        // somewhat persistent.  Copying the buffer pointer directly to the
                        // pResult->str would result in the buffer being freed before the pointer
                        // is used.
                        switch (pResult->nCol)
                        {
                        case COLNUM_CTL_ISSUER:
                            m_szDisplayInfoResult = pCTL->GetIssuerName ();
                            if ( m_szDisplayInfoResult.IsEmpty () )
                            {
                                SetTextNotAvailable ();
                            }
                            break;


                        case COLNUM_CTL_EFFECTIVE_DATE:
                            m_szDisplayInfoResult = pCTL->GetEffectiveDate ();
                            if ( m_szDisplayInfoResult.IsEmpty () )
                            {
                                SetTextNotAvailable ();
                            }
                            break;

                        case COLNUM_CTL_PURPOSE:
                            m_szDisplayInfoResult = pCTL->GetPurpose ();
                            if ( m_szDisplayInfoResult.IsEmpty () )
                            {
                                SetTextNotAvailable ();
                            }
                            break;

                        case COLNUM_CTL_FRIENDLY_NAME:
                            m_szDisplayInfoResult = pCTL->GetFriendlyName ();
                            if ( m_szDisplayInfoResult.IsEmpty () )
                            {
                                SetTextNotAvailable ();
                            }
                            break;

                        default:
                            ASSERT (0);
                            break;
                        }

                        pResult->str = const_cast<LPWSTR> ( (LPCWSTR) m_szDisplayInfoResult);
                    }
                    if (pResult->mask & RDI_IMAGE)
                        pResult->nImage = iIconCTL;
                }
            }
            break;

        case CERTMGR_CRL:
            {
                CCRL* pCRL = reinterpret_cast <CCRL*> (pCookie);
                ASSERT (pCRL);
                if ( pCRL )
                {
                    if (pResult->mask & RDI_STR)
                    {
                        // Note:  text is first stored in class variable so that the buffer is
                        // somewhat persistent.  Copying the buffer pointer directly to the
                        // pResult->str would result in the buffer being freed before the pointer
                        // is used.
                        switch (pResult->nCol)
                        {
                        case COLNUM_CRL_ISSUER:
                            m_szDisplayInfoResult = pCRL->GetIssuerName ();
                            if ( m_szDisplayInfoResult.IsEmpty () )
                            {
                                SetTextNotAvailable ();
                            }
                            break;


                        case COLNUM_CRL_EFFECTIVE_DATE:
                            m_szDisplayInfoResult = pCRL->GetEffectiveDate ();
                            if ( m_szDisplayInfoResult.IsEmpty () )
                            {
                                SetTextNotAvailable ();
                            }
                            break;

                        case COLNUM_CRL_NEXT_UPDATE:
                            m_szDisplayInfoResult = pCRL->GetNextUpdate ();
                            if ( m_szDisplayInfoResult.IsEmpty () )
                            {
                                SetTextNotAvailable ();
                            }
                            break;

                        default:
                            ASSERT (0);
                            break;
                        }

                        pResult->str = const_cast<LPWSTR> ( (LPCWSTR) m_szDisplayInfoResult);
                    }
                    if (pResult->mask & RDI_IMAGE)
                        pResult->nImage = iIconCRL;
                }
            }
            break;

        case CERTMGR_AUTO_CERT_REQUEST:
            {
                CAutoCertRequest* pACR = reinterpret_cast <CAutoCertRequest*> (pCookie);
                ASSERT (pACR);
                if ( pACR )
                {
                    if (pResult->mask & RDI_STR)
                    {
                        // Note:  text is first stored in class variable so that the buffer is
                        // somewhat persistent.  Copying the buffer pointer directly to the
                        // pResult->str would result in the buffer being freed before the pointer
                        // is used.
                        switch (pResult->nCol)
                        {
                        case 0:
                            {
                                CString name;

                                if ( SUCCEEDED (pACR->GetCertTypeName (name)) )
                                    m_szDisplayInfoResult = name;
                                else
                                    SetTextNotAvailable ();
                            }
                            break;

                        default:
                            ASSERT (0);
                            break;
                        }

                        pResult->str = const_cast<LPWSTR> ( (LPCWSTR) m_szDisplayInfoResult);
                    }
                    if (pResult->mask & RDI_IMAGE)
                        pResult->nImage = iIconAutoCertRequest;
                }
            }
            break;
        }
     }
    else
        hr = CComponent::GetDisplayInfo (pResult);

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
// IExtendContextMenu implementation
//
STDMETHODIMP CCertMgrComponent::AddMenuItems (LPDATAOBJECT pDataObject,
                                                          LPCONTEXTMENUCALLBACK pContextMenuCallback,
                                                          long *pInsertionAllowed)
{
    _TRACE (1, L"Entering CCertMgrComponent::AddMenuItems\n");
    HRESULT hr = S_OK;
    hr = QueryComponentDataRef ().AddMenuItems (pDataObject,
            pContextMenuCallback, pInsertionAllowed);
    _TRACE (-1, L"Leaving CCertMgrComponent::AddMenuItems: 0x%x\n", hr);
    return hr;
}


STDMETHODIMP CCertMgrComponent::Command (long nCommandID, LPDATAOBJECT pDataObject)
{
    _TRACE (1, L"Entering CCertMgrComponent::Command\n");
    HRESULT hr = S_OK;

    switch (nCommandID)
    {
    case IDM_OPEN:
    case IDM_TASK_OPEN:
        hr = OnOpen (pDataObject);
        break;

    default:
        hr = QueryComponentDataRef ().Command (nCommandID, pDataObject);
        break;
    }
    _TRACE (-1, L"Leaving CCertMgrComponent::Command: 0x%x\n", hr);
    return hr;
}


HRESULT CCertMgrComponent::OnNotifyDblClick (LPDATAOBJECT pDataObject)
{
    _TRACE (1, L"Entering CCertMgrComponent::OnNotifyDblClick\n");
    HRESULT hr = S_OK;
    ASSERT (pDataObject);

    CCertMgrCookie* pParentCookie =
            QueryComponentDataRef ().ConvertCookie (pDataObject);
    if ( pParentCookie )
    {
        switch ( pParentCookie->m_objecttype )
        {
            case CERTMGR_SNAPIN:
            case CERTMGR_USAGE:
            case CERTMGR_PHYS_STORE:
            case CERTMGR_LOG_STORE:
            case CERTMGR_LOG_STORE_GPE:
            case CERTMGR_LOG_STORE_RSOP:
            case CERTMGR_CRL_CONTAINER:
            case CERTMGR_CTL_CONTAINER:
            case CERTMGR_CERT_CONTAINER:
            case CERTMGR_AUTO_CERT_REQUEST:
            case CERTMGR_CERT_POLICIES_USER:
            case CERTMGR_CERT_POLICIES_COMPUTER:
            case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
            case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
            case CERTMGR_SAFER_COMPUTER_TRUSTED_PUBLISHERS:
            case CERTMGR_SAFER_USER_TRUSTED_PUBLISHERS:
            case CERTMGR_SAFER_COMPUTER_DEFINED_FILE_TYPES:
            case CERTMGR_SAFER_USER_DEFINED_FILE_TYPES:
            case CERTMGR_SAFER_COMPUTER_LEVEL:
            case CERTMGR_SAFER_USER_LEVEL:
            case CERTMGR_SAFER_COMPUTER_ENTRY:
            case CERTMGR_SAFER_USER_ENTRY:
            case CERTMGR_SAFER_USER_ROOT:
            case CERTMGR_SAFER_USER_ENTRIES:
            case CERTMGR_SAFER_COMPUTER_ENTRIES:
            case CERTMGR_SAFER_USER_LEVELS:
            case CERTMGR_SAFER_COMPUTER_LEVELS:
            case CERTMGR_SAFER_COMPUTER_ROOT:
            case CERTMGR_SAFER_COMPUTER_ENFORCEMENT:
            case CERTMGR_SAFER_USER_ENFORCEMENT:
                hr = S_FALSE;
                break;

            case CERTMGR_CERTIFICATE:
                {
                    CCertificate*   pCert = reinterpret_cast <CCertificate*> (pParentCookie);
                    ASSERT (pCert);
                    if ( pCert )
                    {
                        hr = LaunchCommonCertDialog (pCert);
                        if ( hr == CRYPT_E_NOT_FOUND )
                            m_pConsole->UpdateAllViews (pDataObject, 0, 0);
                    }
                    else
                        hr = E_UNEXPECTED;
                }
                hr = S_OK;
                break;


            case CERTMGR_CTL:
                {
                    CCTL*   pCTL = reinterpret_cast <CCTL*> (pParentCookie);
                    ASSERT (pCTL);
                    if ( pCTL )
                        hr = LaunchCommonCTLDialog (pCTL);
                    else
                        hr = E_UNEXPECTED;
                }
                hr = S_OK;
                break;

            case CERTMGR_CRL:
                {
                    CCRL*   pCRL = reinterpret_cast <CCRL*> (pParentCookie);
                    ASSERT (pCRL);
                    if ( pCRL )
                        hr = LaunchCommonCRLDialog (pCRL);
                    else
                        hr = E_UNEXPECTED;
                }
                hr = S_OK;
                break;

            default:
                _TRACE (0, L"CCertMgrComponentData::EnumerateScopeChildren bad parent type\n");
                ASSERT (FALSE);
                hr = S_OK;
                break;
        }
    }
    else
        hr =  E_UNEXPECTED;


    _TRACE (-1, L"Leaving CCertMgrComponent::OnNotifyDblClick: 0x%x\n", hr);
    return hr;
}


HRESULT CCertMgrComponent::OnNotifySelect (LPDATAOBJECT pDataObject, BOOL fSelected)
{
    _TRACE (1, L"Entering CCertMgrComponent::OnNotifySelect - fSelected == %d.\n", fSelected);
     ASSERT (m_pConsoleVerb && 0xdddddddd != (UINT_PTR) m_pConsoleVerb);
    if ( !m_pConsoleVerb || 0xdddddddd == (UINT_PTR) m_pConsoleVerb )
        return E_FAIL;

    if ( ((LPDATAOBJECT) -1) == pDataObject )
        return E_FAIL;


    HRESULT hr = S_OK;
    CCertMgrComponentData& compData = QueryComponentDataRef ();
    compData.SetResultData (m_pResultData);
    BOOL    bIsFileView = !(compData.m_szFileName.IsEmpty ());

    // Don't add menu items if this is a serialized file

    CertificateManagerObjectType objectType = compData.GetObjectType (pDataObject);
    if ( objectType >= 0)
    {
        CCertMgrCookie* pCookie = ConvertCookie (pDataObject);
        if ( pCookie )
        {
            pCookie->SetSelected (fSelected ? true : false);
            switch (objectType)
            {
            case CERTMGR_SNAPIN:
                if ( fSelected )
                {
                    m_pConsoleVerb->SetDefaultVerb (MMC_VERB_OPEN);
                    m_pConsoleVerb->SetVerbState (MMC_VERB_REFRESH, ENABLED, TRUE);
                }
                else
                {
                    m_pConsoleVerb->SetVerbState (MMC_VERB_REFRESH, ENABLED, FALSE);
                }
                m_currResultNodeType = CERTMGR_INVALID;
                break;

            case CERTMGR_USAGE:
                m_currResultNodeType = CERTMGR_CERTIFICATE;
                {
                    CUsageCookie* pUsage = reinterpret_cast <CUsageCookie*> (pCookie);
                    ASSERT (pUsage);
                    if ( pUsage )
                    {
                        if ( m_pLastUsageCookie )
                            m_pLastUsageCookie->Release ();
                        m_pLastUsageCookie = pUsage;
                        m_pLastUsageCookie->AddRef ();
                        hr = DisplayCertificateCountByUsage (pCookie->GetObjectName (),
                                pUsage->GetCertCount ());
                    }
                    else
                        hr = E_UNEXPECTED;
                }
                if ( fSelected )
                {
                    m_pConsoleVerb->SetDefaultVerb (MMC_VERB_OPEN);
                    m_pConsoleVerb->SetVerbState (MMC_VERB_REFRESH, ENABLED, TRUE);
                }
                else
                {
                    m_pConsoleVerb->SetVerbState (MMC_VERB_REFRESH, ENABLED, FALSE);
                }
                break;

            case CERTMGR_PHYS_STORE:
            case CERTMGR_LOG_STORE:
                if ( fSelected )
                {
                    m_pConsoleVerb->SetDefaultVerb (MMC_VERB_OPEN);
                    m_pConsoleVerb->SetVerbState (MMC_VERB_REFRESH, ENABLED, TRUE);
                }
                else
                    m_pConsoleVerb->SetVerbState (MMC_VERB_REFRESH, ENABLED, FALSE);
                if ( !bIsFileView )
                {
                    CCertStore* pStore = reinterpret_cast <CCertStore*> (pCookie);
                    ASSERT (pStore);
                    if ( pStore )
                    {
                        pStore->GetStoreHandle (); // to initialize read-only flag
                        if ( pStore->IsReadOnly () ) //|| !fSelected)
                            m_pConsoleVerb->SetVerbState (MMC_VERB_PASTE, ENABLED, FALSE);
                        else
                            m_pConsoleVerb->SetVerbState (MMC_VERB_PASTE, ENABLED, TRUE);
                        if ( fSelected )
                            hr = DisplayCertificateCountByStore (m_pConsole, pStore);
                        pStore->Close ();
                    }
                    else
                        hr = E_UNEXPECTED;
                }
                m_currResultNodeType = CERTMGR_INVALID;
                break;
            
            case CERTMGR_LOG_STORE_GPE:
            case CERTMGR_LOG_STORE_RSOP:
                if ( fSelected && CERTMGR_LOG_STORE_RSOP != QueryComponentDataRef ().GetObjectType (pDataObject) )
                {
                    m_pConsoleVerb->SetDefaultVerb (MMC_VERB_OPEN);
                    m_pConsoleVerb->SetVerbState (MMC_VERB_REFRESH, ENABLED, TRUE);
                }
                else
                    m_pConsoleVerb->SetVerbState (MMC_VERB_REFRESH, ENABLED, FALSE);
                if ( !bIsFileView )
                {
                    CCertStoreGPE* pStore = reinterpret_cast <CCertStoreGPE*> (pCookie);
                    ASSERT (pStore);
                    if ( pStore )
                    {
                        hr = DisplayCertificateCountByStore (m_pConsole, pStore, true);

                        switch (pStore->GetStoreType ())
                        {
                        case ROOT_STORE:
                            if ( fSelected )
                                m_pConsoleVerb->SetVerbState (MMC_VERB_PROPERTIES, ENABLED, TRUE);
                            else
                                m_pConsoleVerb->SetVerbState (MMC_VERB_PROPERTIES, ENABLED, FALSE);
                            m_currResultNodeType = CERTMGR_CERTIFICATE;
                            break;

                        case EFS_STORE:
                            if ( fSelected )
                                m_pConsoleVerb->SetVerbState (MMC_VERB_PROPERTIES, ENABLED, TRUE);
                            else
                                m_pConsoleVerb->SetVerbState (MMC_VERB_PROPERTIES, ENABLED, FALSE);
                            m_currResultNodeType = CERTMGR_CERTIFICATE;
                            break;

                        case TRUST_STORE:
                            m_currResultNodeType = CERTMGR_CTL;
                            break;

                        case ACRS_STORE:
                            m_currResultNodeType = CERTMGR_AUTO_CERT_REQUEST;
                            break;

                        default:
                            ASSERT (0);
                            m_currResultNodeType = CERTMGR_INVALID;
                            break;
                        }
                        
                        if ( pStore->IsReadOnly () ) //|| !fSelected )
                            m_pConsoleVerb->SetVerbState (MMC_VERB_PASTE, ENABLED, FALSE);
                        else if ( ACRS_STORE != pStore->GetStoreType () )
                        {
                            // Do not allow cut and paste for ACRS store.
                            m_pConsoleVerb->SetVerbState (MMC_VERB_PASTE, ENABLED, TRUE);
                            if ( !fSelected &&
                                    CERTMGR_LOG_STORE_GPE != pStore->m_objecttype )
                            {
                                pStore->Commit ();
                            }
                        }
                    }
                    else
                        hr = E_UNEXPECTED;
                }
                break;
            
            case CERTMGR_CERTIFICATE:
                {
                    CCertificate* pCert = reinterpret_cast <CCertificate*> (pCookie);
                    ASSERT (pCert);
                    if ( pCert )
                    {
                        if ( fSelected )
                        {
                            if ( IDM_STORE_VIEW == QueryComponentDataRef ().m_activeViewPersist )
                            {
                                hr = DisplayCertificateCountByStore (
                                        m_pConsole, pCert->GetCertStore ());
                            }
                            else
                            {
                                // Display by count in each purpose
                                ASSERT (m_pLastUsageCookie);
                                if ( m_pLastUsageCookie )
                                {
                                     hr = DisplayCertificateCountByUsage (
                                            m_pLastUsageCookie->GetObjectName (),
                                            m_pLastUsageCookie->GetCertCount ());
                                }
                            }
                        }

                        if ( fSelected )
                            m_pConsoleVerb->SetVerbState (MMC_VERB_COPY, ENABLED, TRUE);
                        else
                            m_pConsoleVerb->SetVerbState (MMC_VERB_COPY, ENABLED, FALSE);
                        if ( !bIsFileView )
                        {
                            if ( fSelected )
                                m_pConsoleVerb->SetVerbState (MMC_VERB_PROPERTIES, ENABLED, TRUE);
                            else
                                m_pConsoleVerb->SetVerbState (MMC_VERB_PROPERTIES, ENABLED, FALSE);

                            CCertStore* pCertStore = pCert->GetCertStore ();
                            if ( pCertStore )
                            {
                                if ( pCertStore->IsReadOnly () || !fSelected )
                                    m_pConsoleVerb->SetVerbState (MMC_VERB_DELETE, ENABLED, FALSE);
                                else
                                {
                                    if ( pCert->CanDelete () )
                                        m_pConsoleVerb->SetVerbState (MMC_VERB_DELETE, ENABLED, TRUE);
                                    else
                                        m_pConsoleVerb->SetVerbState (MMC_VERB_DELETE, ENABLED, FALSE);

                                    if ( !fSelected &&
                                            CERTMGR_LOG_STORE_GPE == pCertStore->m_objecttype )
                                    {
                                        pCertStore->Commit ();
                                    }
                                }
                            }
                        }
                    }
                    else
                        hr = E_UNEXPECTED;
                }
                m_currResultNodeType = CERTMGR_CERTIFICATE;
                break;

            case CERTMGR_CRL_CONTAINER:
                if ( fSelected )
                {
                    m_pConsoleVerb->SetDefaultVerb (MMC_VERB_OPEN);
                    m_pConsoleVerb->SetVerbState (MMC_VERB_REFRESH, ENABLED, TRUE);
                }
                else
                    m_pConsoleVerb->SetVerbState (MMC_VERB_REFRESH, ENABLED, FALSE);
                if ( !bIsFileView )
                {
                    CContainerCookie* pCont = reinterpret_cast <CContainerCookie*> (pCookie);
                    ASSERT (pCont);
                    if ( pCont )
                    {
                        if ( pCont->GetCertStore ().IsReadOnly () ) //|| !fSelected )
                            m_pConsoleVerb->SetVerbState (MMC_VERB_PASTE, ENABLED, FALSE);
                        else
                        {
                            m_pConsoleVerb->SetVerbState (MMC_VERB_PASTE, ENABLED, TRUE);
                            if ( !fSelected )
                                pCont->GetCertStore ().Commit ();
                        }
                    }
                    else
                        hr = E_UNEXPECTED;
                }
                m_currResultNodeType = CERTMGR_CRL;
                break;

            case CERTMGR_CTL_CONTAINER:
                if ( fSelected )
                {
                    m_pConsoleVerb->SetDefaultVerb (MMC_VERB_OPEN);
                    m_pConsoleVerb->SetVerbState (MMC_VERB_REFRESH, ENABLED, TRUE);
                }
                else
                    m_pConsoleVerb->SetVerbState (MMC_VERB_REFRESH, ENABLED, FALSE);
                if ( !bIsFileView )
                {
                    CContainerCookie* pCont = reinterpret_cast <CContainerCookie*> (pCookie);
                    ASSERT (pCont);
                    if ( pCont )
                    {
                        if ( pCont->GetCertStore ().IsReadOnly () ) //|| !fSelected )
                            m_pConsoleVerb->SetVerbState (MMC_VERB_PASTE, ENABLED, FALSE);
                        else
                        {
                            m_pConsoleVerb->SetVerbState (MMC_VERB_PASTE, ENABLED, TRUE);
                            if ( !fSelected )
                                pCont->GetCertStore ().Commit ();
                        }
                    }
                    else
                        hr = E_UNEXPECTED;
                }
                m_currResultNodeType = CERTMGR_CTL;
                break;

            case CERTMGR_CERT_CONTAINER:
                if ( fSelected )
                {
                    m_pConsoleVerb->SetDefaultVerb (MMC_VERB_OPEN);
                    m_pConsoleVerb->SetVerbState (MMC_VERB_REFRESH, ENABLED, TRUE);
                }
                else
                    m_pConsoleVerb->SetVerbState (MMC_VERB_REFRESH, ENABLED, FALSE);
                if ( !bIsFileView )
                {
                    CContainerCookie* pCont = reinterpret_cast <CContainerCookie*> (pCookie);
                    ASSERT (pCont);
                    if ( pCont )
                    {
                        if ( fSelected )
                            hr = DisplayCertificateCountByStore (
                                    m_pConsole, &pCont->GetCertStore ());
                        if ( pCont->GetCertStore ().IsReadOnly () ) //|| !fSelected )
                            m_pConsoleVerb->SetVerbState (MMC_VERB_PASTE, ENABLED, FALSE);
                        else
                        {
                            m_pConsoleVerb->SetVerbState (MMC_VERB_PASTE, ENABLED, TRUE);
                            if ( !fSelected )
                                pCont->GetCertStore ().Commit ();
                        }
                    }
                    else
                        hr = E_UNEXPECTED;
                }
                m_currResultNodeType = CERTMGR_CERTIFICATE;
                break;

            case CERTMGR_CRL:
                if ( fSelected )
                    m_pConsoleVerb->SetVerbState (MMC_VERB_COPY, ENABLED, TRUE);
                else
                    m_pConsoleVerb->SetVerbState (MMC_VERB_COPY, ENABLED, FALSE);
                {
                    CCRL* pCRL = reinterpret_cast <CCRL*> (pCookie);
                    ASSERT (pCRL);
                    if ( pCRL )
                    {
                        if ( pCRL->GetCertStore ().IsReadOnly () || !fSelected )
                            m_pConsoleVerb->SetVerbState (MMC_VERB_DELETE, ENABLED, FALSE);
                        else
                        {
                            m_pConsoleVerb->SetVerbState (MMC_VERB_DELETE, ENABLED, TRUE);
                            if ( !fSelected &&
                                    CERTMGR_LOG_STORE_GPE == pCRL->GetCertStore ().m_objecttype )
                            {
                                pCRL->GetCertStore ().Commit ();
                            }
                        }
                    }
                    else
                        hr = E_UNEXPECTED;
                }
                m_currResultNodeType = CERTMGR_CRL;
                break;

            case CERTMGR_AUTO_CERT_REQUEST:
                if ( fSelected )
                {
                    m_pConsoleVerb->SetVerbState (MMC_VERB_PROPERTIES, ENABLED, TRUE);
                    m_pConsoleVerb->SetDefaultVerb (MMC_VERB_PROPERTIES);
                }
                else
                    m_pConsoleVerb->SetVerbState (MMC_VERB_PROPERTIES, ENABLED, FALSE);

                {
                    CAutoCertRequest* pAutoCert = reinterpret_cast <CAutoCertRequest*> (pCookie);
                    ASSERT (pAutoCert);
                    if ( pAutoCert )
                    {
                        if ( pAutoCert->GetCertStore ().IsReadOnly () || !fSelected )
                            m_pConsoleVerb->SetVerbState (MMC_VERB_DELETE, ENABLED, FALSE);
                        else
                        {
                            m_pConsoleVerb->SetVerbState (MMC_VERB_DELETE, ENABLED, TRUE);
                            if ( !fSelected &&
                                    CERTMGR_LOG_STORE_GPE == pAutoCert->GetCertStore ().m_objecttype )
                            {
                                pAutoCert->GetCertStore ().Commit ();
                            }
                        }
                    }
                    else
                        hr = E_UNEXPECTED;
                }
                m_currResultNodeType = CERTMGR_AUTO_CERT_REQUEST;
                break;

            case CERTMGR_CTL:
                if ( !bIsFileView )
                {
                    CCTL* pCTL = reinterpret_cast <CCTL*> (pCookie);
                    ASSERT (pCTL);
                    if ( pCTL )
                    {
                        if ( pCTL->GetCertStore ().IsReadOnly () || !fSelected )
                            m_pConsoleVerb->SetVerbState (MMC_VERB_DELETE, ENABLED, FALSE);
                        else
                        {
                            m_pConsoleVerb->SetVerbState (MMC_VERB_DELETE, ENABLED, TRUE);
                            if ( !fSelected &&
                                    CERTMGR_LOG_STORE_GPE == pCTL->GetCertStore ().m_objecttype )
                            {
                                pCTL->GetCertStore ().Commit ();
                            }
                        }

                        // Don't allow auto cert requests to be copied. They can't be
                        // pasted anywhere.
                        if ( ACRS_STORE != pCTL->GetCertStore ().GetStoreType () )
                            m_pConsoleVerb->SetVerbState (MMC_VERB_COPY, ENABLED, TRUE);
                    }
                    else
                        hr = E_UNEXPECTED;
                }
                m_currResultNodeType = CERTMGR_CTL;
                if ( QueryComponentDataRef ().m_bIsRSOP )
                {
                    if ( fSelected )
                        m_pConsoleVerb->SetVerbState (MMC_VERB_PROPERTIES, ENABLED, TRUE);
                    else
                        m_pConsoleVerb->SetVerbState (MMC_VERB_PROPERTIES, ENABLED, FALSE);
                }
                break;

            case CERTMGR_CERT_POLICIES_COMPUTER:
            case CERTMGR_CERT_POLICIES_USER:
                m_currResultNodeType = CERTMGR_INVALID;
                if ( fSelected )
                {
                    // NTRAID# 456367 SAFER RSOP:  Delete menu item appears in the 
                    // context menu for SAFER rules in RSOP mode.
                    CCertMgrComponentData& dataRef = QueryComponentDataRef ();
                    m_pConsoleVerb->SetDefaultVerb (MMC_VERB_OPEN);
                    m_pConsoleVerb->SetVerbState (MMC_VERB_REFRESH, ENABLED, !dataRef.m_bIsRSOP);
                }
                else
                {
                    m_pConsoleVerb->SetVerbState (MMC_VERB_REFRESH, ENABLED, FALSE);
                }
                break;

            case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
            case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
            case CERTMGR_SAFER_COMPUTER_LEVEL:
            case CERTMGR_SAFER_USER_LEVEL:
            case CERTMGR_SAFER_COMPUTER_TRUSTED_PUBLISHERS:
            case CERTMGR_SAFER_USER_TRUSTED_PUBLISHERS:
            case CERTMGR_SAFER_COMPUTER_DEFINED_FILE_TYPES:
            case CERTMGR_SAFER_USER_DEFINED_FILE_TYPES:
            case CERTMGR_SAFER_COMPUTER_ENFORCEMENT:
            case CERTMGR_SAFER_USER_ENFORCEMENT:
                if ( fSelected )
                {
                    m_pConsoleVerb->SetVerbState (MMC_VERB_PROPERTIES, ENABLED, TRUE);
                    m_pConsoleVerb->SetDefaultVerb (MMC_VERB_PROPERTIES);
                }
                else
                {
                    m_pConsoleVerb->SetVerbState (MMC_VERB_PROPERTIES, ENABLED, FALSE);
                }
                break;

            case CERTMGR_SAFER_COMPUTER_ENTRY:
            case CERTMGR_SAFER_USER_ENTRY:
                if ( fSelected )
                {
                    // NTRAID# 456367 SAFER RSOP:  Delete menu item appears in the 
                    // context menu for SAFER rules in RSOP mode.
                    CCertMgrComponentData& dataRef = QueryComponentDataRef ();
            
                    m_pConsoleVerb->SetVerbState (MMC_VERB_PROPERTIES, ENABLED, TRUE);
                    m_pConsoleVerb->SetDefaultVerb (MMC_VERB_PROPERTIES);
                    m_pConsoleVerb->SetVerbState (MMC_VERB_DELETE, ENABLED, !dataRef.m_bIsRSOP);
                    m_pConsoleVerb->SetVerbState (MMC_VERB_REFRESH, ENABLED, !dataRef.m_bIsRSOP);
                }
                else
                {
                    m_pConsoleVerb->SetVerbState (MMC_VERB_PROPERTIES, ENABLED, FALSE);
                    m_pConsoleVerb->SetVerbState (MMC_VERB_DELETE, ENABLED, FALSE);
                    m_pConsoleVerb->SetVerbState (MMC_VERB_REFRESH, ENABLED, FALSE);
                }
                break;

            case CERTMGR_SAFER_COMPUTER_ENTRIES:
            case CERTMGR_SAFER_USER_ENTRIES:
                if ( fSelected )
                {
                    // NTRAID# 456367 SAFER RSOP:  Delete menu item appears in the 
                    // context menu for SAFER rules in RSOP mode.
                    CCertMgrComponentData& dataRef = QueryComponentDataRef ();
                    m_pConsoleVerb->SetVerbState (MMC_VERB_REFRESH, ENABLED, !dataRef.m_bIsRSOP);
                    m_pConsoleVerb->SetVerbState (MMC_VERB_PASTE, ENABLED, !dataRef.m_bIsRSOP);
                    m_pConsoleVerb->SetDefaultVerb (MMC_VERB_OPEN);
                }
                else
                {
                    m_pConsoleVerb->SetVerbState (MMC_VERB_REFRESH, ENABLED, FALSE);
                    m_pConsoleVerb->SetVerbState (MMC_VERB_PASTE, ENABLED, FALSE);
                }
                break;

            case CERTMGR_SAFER_COMPUTER_LEVELS:
            case CERTMGR_SAFER_USER_LEVELS:
                if ( fSelected )
                    m_pConsoleVerb->SetDefaultVerb (MMC_VERB_OPEN);
                break;

            case CERTMGR_SAFER_COMPUTER_ROOT:
            case CERTMGR_SAFER_USER_ROOT:
                if ( fSelected )
                    m_pConsoleVerb->SetDefaultVerb (MMC_VERB_OPEN);
                {
                    CString szStatusText;
                    CCertMgrComponentData&  dataRef = QueryComponentDataRef (); 

                    if ( !dataRef.m_bIsRSOP && !dataRef.m_bSaferSupported )
                    {
                        szStatusText.LoadString (IDS_SAFER_NOT_SUPPORTED);
                    }
                    IConsole2*  pConsole2 = 0;
                    hr = m_pConsole->QueryInterface (
                            IID_PPV_ARG(IConsole2, &pConsole2));
                    if (SUCCEEDED (hr))
                    {
                        hr = pConsole2->SetStatusText (const_cast <LPOLESTR>((PCWSTR) szStatusText));
                        if ( !SUCCEEDED (hr) )
                        {
                            _TRACE (0, L"IConsole::SetStatusText () failed: %x", hr);
                        }
                        pConsole2->Release ();
                    }
                }
                break;

            default:
                m_currResultNodeType = CERTMGR_INVALID;
                hr = E_UNEXPECTED;
                break;
            }
        }
    }
    else if ( CERTMGR_MULTISEL == objectType )
    {
        if ( fSelected )
            m_pConsoleVerb->SetVerbState (MMC_VERB_COPY, ENABLED, TRUE);
        else
            m_pConsoleVerb->SetVerbState (MMC_VERB_COPY, ENABLED, FALSE);

        bool    bDeleteSet = false;


        CCertMgrDataObject* pDO = reinterpret_cast <CCertMgrDataObject*>(pDataObject);
        ASSERT (pDO);
        if ( pDO )
        {
            // Is multiple select, get all selected items and delete - confirm
            // first deletion only.
            CCertMgrCookie* pCookie = 0;
            pDO->Reset();
            while (pDO->Next(1, reinterpret_cast<MMC_COOKIE*>(&pCookie), NULL) != S_FALSE)
            {
                switch (pCookie->m_objecttype )
                {
                case CERTMGR_CERTIFICATE:
                    {
                        CCertificate* pCert = reinterpret_cast <CCertificate*> (pCookie);
                        ASSERT (pCert);
                        if ( (pCert && !pCert->CanDelete ()) || !fSelected )
                        {
                            m_pConsoleVerb->SetVerbState (MMC_VERB_DELETE, ENABLED, FALSE);
                            bDeleteSet = true;
                            break;
                        }
                    }
                    break;

                // NTRAID# 409138 SAFER:  Multi-selected safer rules have 
                // "cut" and "copy" in their context menu
                case CERTMGR_SAFER_COMPUTER_ENTRY:
                case CERTMGR_SAFER_USER_ENTRY:
                case CERTMGR_AUTO_CERT_REQUEST:
                    m_pConsoleVerb->SetVerbState (MMC_VERB_COPY, ENABLED, FALSE);
                    break;
            
                default:
                    break;
                }
                break;
            }
        }

        if ( !bDeleteSet && fSelected )
            m_pConsoleVerb->SetVerbState (MMC_VERB_DELETE, ENABLED, TRUE);

        m_currResultNodeType = CERTMGR_MULTISEL;
    }
        
    _TRACE (-1, L"Leaving CCertMgrComponent::OnNotifySelect: 0x%x\n", hr);
    return hr;
}

STDMETHODIMP CCertMgrComponent::CreatePropertyPages (
    LPPROPERTYSHEETCALLBACK pCallBack,
     LONG_PTR handle,       // This handle must be saved in the property page object to notify the parent when modified
    LPDATAOBJECT pDataObject)
{
    _TRACE (1, L"Entering CCertMgrComponent::CreatePropertyPages\n");
    HRESULT hr = S_OK;

    hr = QueryComponentDataRef ().CreatePropertyPages (pCallBack, handle, pDataObject);
    _TRACE (-1, L"Leaving CCertMgrComponent::CreatePropertyPages: 0x%x\n", hr);
    return hr;
}

STDMETHODIMP CCertMgrComponent::QueryPagesFor (LPDATAOBJECT pDataObject)
{
    _TRACE (1, L"Entering CCertMgrComponent::QueryPagesFor\n");
    HRESULT hr = S_OK;
    hr = QueryComponentDataRef ().QueryPagesFor (pDataObject);
    _TRACE (-1, L"Leaving CCertMgrComponent::QueryPagesFor: 0x%x\n", hr);
    return hr;
}


HRESULT CCertMgrComponent::OnNotifyRefresh (LPDATAOBJECT pDataObject)
{
    _TRACE (1, L"Entering CCertMgrComponent::OnNotifyRefresh\n");
    ASSERT (pDataObject);
    if ( !pDataObject )
        return E_POINTER;

    HRESULT hr = S_OK;

    CCertMgrCookie* pCookie = ConvertCookie (pDataObject);
    if ( !pCookie )
        return E_UNEXPECTED;

    CCertMgrComponentData&  dataRef = QueryComponentDataRef ();
    
    switch (pCookie->m_objecttype)
    {
    case CERTMGR_CERT_POLICIES_USER:
    case CERTMGR_CERT_POLICIES_COMPUTER:
        if ( dataRef.m_bIsRSOP )
        {
            // Delete all the scope items and force a reexpansion
            
            hr = dataRef.DeleteScopeItems (pCookie->m_hScopeItem);

            hr = dataRef.BuildWMIList (0, 
                    CERTMGR_CERT_POLICIES_COMPUTER == pCookie->m_objecttype);
            if ( SUCCEEDED (hr) )
            {
                GUID    guid;
                hr = dataRef.ExpandScopeNodes (
                        pCookie, pCookie->m_hScopeItem,
                        _T (""), 0, guid);
            }
        }
        break;

    case CERTMGR_SNAPIN:
        {
            // Close and release the usage stores if any.
            CloseAndReleaseUsageStores ();
            m_bUsageStoresEnumerated = false;

            // Delete all the scope items and force a reexpansion
            hr = dataRef.DeleteScopeItems ();

            if ( dataRef.m_bIsRSOP )
            {
                ASSERT (0);  // do we ever hit this?
                hr = dataRef.BuildWMIList (0, true);
            }

            if ( SUCCEEDED (hr) )
            {
                GUID    guid;
                hr = dataRef.ExpandScopeNodes (
                        dataRef.m_pRootCookie, dataRef.m_hRootScopeItem,
                        _T (""), 0, guid);
            }
        }
        break;

    case CERTMGR_PHYS_STORE:
    case CERTMGR_LOG_STORE:
        {
            CCertStore* pCertStore = reinterpret_cast <CCertStore*> (pCookie);
            ASSERT (pCertStore);
            if ( pCertStore )
                pCertStore->Resync ();

            HSCOPEITEM  hScopeItem = pCookie->m_hScopeItem;
            ASSERT (hScopeItem);
            if ( hScopeItem )
            {
                hr = dataRef.DeleteChildren (hScopeItem);
                GUID    guid;
                hr = dataRef.ExpandScopeNodes (
                        pCookie, hScopeItem, _T (""), 0, guid);
                if ( SUCCEEDED (hr) )
                {
                    hr = RefreshResultPane ();
                    ASSERT (SUCCEEDED (hr));
                }
            }
        }
        break;

    case CERTMGR_CRL_CONTAINER:
    case CERTMGR_CTL_CONTAINER:
    case CERTMGR_CERT_CONTAINER:
        {
            CContainerCookie* pContainer = reinterpret_cast <CContainerCookie*> (pCookie);
            ASSERT (pContainer);
            if ( pContainer )
            {
                pContainer->GetCertStore ().Resync ();
            }
        }
        hr = RefreshResultPane ();
        ASSERT (SUCCEEDED (hr));
        break;


    case CERTMGR_LOG_STORE_GPE:
        {
            CCertStore* pCertStore = reinterpret_cast <CCertStore*> (pCookie);
            ASSERT (pCertStore);
            if ( pCertStore )
                pCertStore->Resync ();
        }
        hr = RefreshResultPane ();
        ASSERT (SUCCEEDED (hr));
        break;

    case CERTMGR_LOG_STORE_RSOP:
        // must be refreshed at root node
        ASSERT (0);
        break;

    case CERTMGR_USAGE:
        // Close all the stores.  This will force them to be
        // re-enumerated later.
        CloseAndReleaseUsageStores ();
        m_bUsageStoresEnumerated = false;
        hr = RefreshResultPane ();
        ASSERT (SUCCEEDED (hr));
        break;


    case CERTMGR_AUTO_CERT_REQUEST:
        hr = RefreshResultPane ();
        ASSERT (SUCCEEDED (hr));
        break;

    case CERTMGR_CERTIFICATE:
        {
            CCertificate* pCert = reinterpret_cast <CCertificate*> (pCookie);
            ASSERT (pCert);
            if ( pCert )
            {
                CCertStore* pStore = pCert->GetCertStore ();
                if ( pStore )
                    pStore->Resync ();
            }
        }
        hr = RefreshResultItem (pCookie);
        ASSERT (SUCCEEDED (hr));
        break;

    case CERTMGR_CTL:
        {
            CCTL* pCTL = reinterpret_cast <CCTL*> (pCookie);
            ASSERT (pCTL);
            if ( pCTL )
            {
                pCTL->GetCertStore ().Resync ();
            }
        }
        hr = RefreshResultItem (pCookie);
        ASSERT (SUCCEEDED (hr));
        break;

    case CERTMGR_CRL:
        {
            CCRL* pCRL = reinterpret_cast <CCRL*> (pCookie);
            ASSERT (pCRL);
            if ( pCRL )
            {
                pCRL->GetCertStore ().Resync ();
            }
        }
        hr = RefreshResultItem (pCookie);
        ASSERT (SUCCEEDED (hr));
        break;

    case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
    case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
        ASSERT (0);
        break;

    case CERTMGR_SAFER_COMPUTER_ENTRIES:
    case CERTMGR_SAFER_USER_ENTRIES:
        {
            bool    bAllowRefresh = true;

            RESULTDATAITEM  rdItem;
            // security review 2/26/2002 BryanWal ok
            ::ZeroMemory (&rdItem, sizeof (rdItem));
            rdItem.nIndex = -1;
            rdItem.mask = RDI_STATE | RDI_PARAM | RDI_INDEX;
            do
            {
                hr = m_pResultData->GetNextItem (&rdItem);
                if ( SUCCEEDED (hr) )
                {
                    CCertMgrCookie* pCurrCookie = (CCertMgrCookie*) rdItem.lParam;
                    if ( pCurrCookie )
                    {
                        if ( pCurrCookie->HasOpenPropertyPages () )
                        {
                            CString text;
                            CString caption;

                            VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
                            VERIFY (text.LoadString (IDS_CANT_REFRESH_PAGES_OPEN));
                            int     iRetVal = 0;
                            VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption,
                                    MB_OK, &iRetVal)));
                            bAllowRefresh = false;
                            break;
                        }
                    }
                }
            } while ( SUCCEEDED (hr) && -1 != rdItem.nIndex );


            if ( !bAllowRefresh )
                break;
        }

        hr = RefreshResultPane ();
        ASSERT (SUCCEEDED (hr));
        break;

    case CERTMGR_SAFER_COMPUTER_ENTRY:
    case CERTMGR_SAFER_USER_ENTRY:
        hr = RefreshResultPane ();
        ASSERT (SUCCEEDED (hr));
        break;

    default:
        ASSERT (0);
        hr = E_UNEXPECTED;
        break;
    }

    _TRACE (-1, L"Leaving CCertMgrComponent::OnNotifyRefresh: 0x%x\n", hr);
    return hr;
}

void CCertMgrComponent::SetTextNotAvailable ()
{
    _TRACE (1, L"Entering CCertMgrComponent::SetTextNotAvailable\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    m_szDisplayInfoResult.LoadString (IDS_NOT_AVAILABLE);
    _TRACE (-1, L"Leaving CCertMgrComponent::SetTextNotAvailable\n");
}


HRESULT CCertMgrComponent::DeleteCookie (
        CCertMgrCookie* pCookie, 
        LPDATAOBJECT pDataObject, 
        bool bRequestConfirmation, 
        bool bIsMultipleSelect, 
        bool bDoCommit)
{
    _TRACE (1, L"Entering CCertMgrComponent::DeleteCookie\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    HRESULT hr = S_OK;
    CString text;
    CString caption;
    int     iRetVal = IDYES;

    switch (pCookie->m_objecttype)
    {
    case CERTMGR_CERTIFICATE:
        {
            CCertificate* pCert = reinterpret_cast <CCertificate*> (pCookie);
            ASSERT (pCert);
            if ( pCert )
            {
                if ( bRequestConfirmation )
                {
                    switch ( pCert->GetStoreType () )
                    {
                    case ROOT_STORE:
                        if ( bIsMultipleSelect )
                        {
                            if ( IDM_USAGE_VIEW == QueryComponentDataRef ().m_activeViewPersist )
                                VERIFY (text.LoadString (IDS_CONFIRM_DELETE_MULT_CERT_BY_PURPOSE));
                            else
                                VERIFY (text.LoadString (IDS_CONFIRM_DELETE_ROOT_MULTI_CERT));
                        }
                        else
                            VERIFY (text.LoadString (IDS_CONFIRM_DELETE_ROOT_CERT));
                        break;

                    case CA_STORE:
                        if ( bIsMultipleSelect )
                        {
                            if ( IDM_USAGE_VIEW == QueryComponentDataRef ().m_activeViewPersist )
                                VERIFY (text.LoadString (IDS_CONFIRM_DELETE_MULT_CERT_BY_PURPOSE));
                            else
                                VERIFY (text.LoadString (IDS_CONFIRM_DELETE_CA_MULTI_CERT));
                        }
                        else
                            VERIFY (text.LoadString (IDS_CONFIRM_DELETE_CA_CERT));
                        break;

                    case MY_STORE:
                        if ( bIsMultipleSelect )
                        {
                            if ( IDM_USAGE_VIEW == QueryComponentDataRef ().m_activeViewPersist )
                                VERIFY (text.LoadString (IDS_CONFIRM_DELETE_MULT_CERT_BY_PURPOSE));
                            else
                                VERIFY (text.LoadString (IDS_CONFIRM_DELETE_MY_MULTI_CERT));
                        }
                        else
                            VERIFY (text.LoadString (IDS_CONFIRM_DELETE_MY_CERT));
                        break;

                    default:
                        if ( bIsMultipleSelect )
                        {
                            if ( IDM_USAGE_VIEW == QueryComponentDataRef ().m_activeViewPersist )
                                VERIFY (text.LoadString (IDS_CONFIRM_DELETE_MULT_CERT_BY_PURPOSE));
                            else
                                VERIFY (text.LoadString (IDS_CONFIRM_DELETE_MULTI));
                        }
                        else
                            VERIFY (text.LoadString (IDS_CONFIRM_DELETE));
                        break;
                    }
                    VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
                    hr = m_pConsole->MessageBox (text, caption, MB_ICONWARNING | MB_YESNO, &iRetVal);
                    ASSERT (SUCCEEDED (hr));
                }

                if ( IDYES == iRetVal )
                {
                    CWaitCursor waitCursor;
                    pCert->GetCertStore (); // to initialize handle

                    hr = DeleteCertFromResultPane (pCert, pDataObject, bDoCommit);
                }
                else
                    hr = E_FAIL;
            }
        }
        break;

    case CERTMGR_CRL:
        {
            CCRL* pCRL = reinterpret_cast <CCRL*> (pCookie);
            ASSERT (pCRL);
            if ( pCRL )
            {
                if ( m_pPastedDO != pDataObject )
                {
                    VERIFY (text.LoadString (IDS_CONFIRM_DELETE_CRL));
                    VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
                    hr = m_pConsole->MessageBox (text, caption, MB_ICONWARNING | MB_YESNO, &iRetVal);
                    ASSERT (SUCCEEDED (hr));
                }

                if ( IDYES == iRetVal )
                {
                          CWaitCursor waitCursor;
                    hr = DeleteCRLFromResultPane (pCRL, pDataObject);
                    if ( SUCCEEDED (hr) )
                        pCRL->GetCertStore ().Commit ();
                }
                else
                    hr = E_FAIL;
            }
        }
        break;

    case CERTMGR_CTL:
        {
            CCTL* pCTL = reinterpret_cast <CCTL*> (pCookie);
            ASSERT (pCTL);
            if ( pCTL )
            {
                if ( bRequestConfirmation )
                {
                    VERIFY (text.LoadString (IDS_CONFIRM_DELETE_CTL));
                    VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
                    hr = m_pConsole->MessageBox (text, caption, MB_ICONWARNING | MB_YESNO, &iRetVal);
                    ASSERT (SUCCEEDED (hr));
                }

                if ( IDYES == iRetVal )
                {
                          CWaitCursor waitCursor;
                    hr = QueryComponentDataRef ().DeleteCTLFromResultPane (pCTL,
                            pDataObject);
                    if ( SUCCEEDED (hr) )
                    {
                        pCTL->GetCertStore ().Commit ();
                    }
                }
                else
                    hr = E_FAIL;
            }
        }
        break;

    case CERTMGR_AUTO_CERT_REQUEST:
        {
            CAutoCertRequest* pACR = reinterpret_cast <CAutoCertRequest*> (pCookie);
            ASSERT (pACR);
            if ( pACR )
            {
                if ( bRequestConfirmation )
                {
                    VERIFY (text.LoadString (IDS_CONFIRM_DELETE_ACR));
                    VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
                    hr = m_pConsole->MessageBox (text, caption, MB_ICONWARNING | MB_YESNO, &iRetVal);
                    ASSERT (SUCCEEDED (hr));
                }

                if ( IDYES == iRetVal )
                {
                    hr = QueryComponentDataRef ().DeleteCTLFromResultPane (pACR,
                            pDataObject);
                    if ( SUCCEEDED (hr) )
                    {
                        pACR->GetCertStore ().Commit ();
                    }
                }
                else
                    hr = E_FAIL;
            }
        }
        break;

    case CERTMGR_SAFER_COMPUTER_ENTRY:
    case CERTMGR_SAFER_USER_ENTRY:
        {
            CSaferEntry* pSaferEntry = reinterpret_cast <CSaferEntry*> (pCookie);
            ASSERT (pSaferEntry);
            if ( pSaferEntry )
            {
                if ( bRequestConfirmation )
                {
                    if ( bIsMultipleSelect )
                        VERIFY (text.LoadString (IDS_CONFIRM_DELETE_MULTI_SAFER_ENTRY));
                    else
                        VERIFY (text.LoadString (IDS_CONFIRM_DELETE_SAFER_ENTRY));

                    VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
                    hr = m_pConsole->MessageBox (text, caption, MB_ICONWARNING | MB_YESNO, &iRetVal);
                    ASSERT (SUCCEEDED (hr));
                }

                if ( IDYES == iRetVal )
                {
                    CWaitCursor waitCursor;

                    hr = DeleteSaferEntryFromResultPane (pSaferEntry, pDataObject, bDoCommit);
                }
                else
                    hr = E_FAIL;
            }
        }
        break;

    default:
        ASSERT (0);
        hr = E_UNEXPECTED;
        break;
    }

    _TRACE (-1, L"Leaving CCertMgrComponent::DeleteCookie: 0x%x\n", hr);
    return hr;
}

void CCertMgrComponent::DeleteCertFromContextList (
        CCertMgrCookie *pCookie, 
        CERT_CONTEXT_LIST& EFSCertContextList)
{
    if ( CERTMGR_CERTIFICATE == pCookie->m_objecttype )
    {
        CCertificate* pCert = dynamic_cast <CCertificate*> (pCookie);
        if ( pCert )
        {
            for (POSITION nextPos = EFSCertContextList.GetHeadPosition (); nextPos; )
            {
                POSITION curPos = nextPos;
                CERT_CONTEXT* pCertContext = EFSCertContextList.GetNext (nextPos);
                if ( pCertContext )
                {
                    if ( ::CertCompareCertificate (
                            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                            pCert->GetCertContext ()->pCertInfo,
                            pCertContext->pCertInfo) )
                    {
                        EFSCertContextList.RemoveAt (curPos);
                        ::CertFreeCertificateContext (pCertContext);
                        break;
                    }
                }
            }
        }
    }
}

bool CCertMgrComponent::DoChainDeletion (
        CCertMgrCookie* pCookie, 
        CCertStore** ppEFSStore)
{
    ASSERT (pCookie && ppEFSStore);
    if ( !pCookie || !ppEFSStore )
        return false;

    bool    bDoChainDeletion = false;

    if ( CERTMGR_CERTIFICATE == pCookie->m_objecttype )
    {
        CCertificate* pCert = dynamic_cast <CCertificate*> (pCookie);
        if ( pCert && 
                pCert->GetCertStore () && 
                EFS_STORE == pCert->GetCertStore ()->GetStoreType () )
        {
            *ppEFSStore = pCert->GetCertStore ();
            bDoChainDeletion = true;
        }
    }

    return bDoChainDeletion;
}

void CCertMgrComponent::CreateCertChainsFromMultiSelect (CCertMgrDataObject* pDO, CCertMgrCookie* pCookie)
{
    _TRACE (1, L"Entering CCertMgrComponent::CreateCertChainsFromMultiSelect\n");
    // If this is the EFS store, prepare to delete all cert chain certs from
    // the CA and TRUST store
    // 1.  Enumerate all certs to be deleted
    // 2.  Enumerate all certs in EFS store
    // 3.  Remove certs to be deleted from list of certs in EFS store
    // 4.  Get all cert chains from remaining EFS certs and save in list
    // 5.  As each cert is deleted, get its cert chain.  For each 
    //      cert from the chain that is not found in the list, remove
    //      from CA store.
    bool                bDoChainDeletion = false;
    CERT_CONTEXT_LIST   EFSCertContextList; 

    CCertStore* pEFSStore = 0;
    pDO->Reset ();
    if ( pDO->Next(1, reinterpret_cast<MMC_COOKIE*>(&pCookie), NULL) != S_FALSE )
    {
        bDoChainDeletion = DoChainDeletion (pCookie, &pEFSStore);
    }
    
    if ( bDoChainDeletion && pEFSStore )
    {
        CERT_CONTEXT* pCertContext = 0;
        // enumerate EFS store
        while ( 1 )
        {
            pCertContext = const_cast <CERT_CONTEXT*> (pEFSStore->EnumCertificates (pCertContext));
            if ( pCertContext )
            {
                EFSCertContextList.AddTail (
                        const_cast <CERT_CONTEXT*> (::CertDuplicateCertificateContext (pCertContext)));
            }
            else
                break;
        }

        // eliminate certs to be deleted
        pDO->Reset ();
        while ( pDO->Next(1, reinterpret_cast<MMC_COOKIE*>(&pCookie), NULL) != S_FALSE )
        {
            DeleteCertFromContextList (pCookie, EFSCertContextList);
        }
    }

    // Build required cert chain certs - these must not be deleted from the CA 
    // store
    GetNotToBeDeletedCertChains (EFSCertContextList);
    
    // Clean up the cert context list
    CERT_CONTEXT* pCertContext = 0;
    while (!EFSCertContextList.IsEmpty () )
    {
        pCertContext = EFSCertContextList.RemoveHead ();
        if ( pCertContext )
            ::CertFreeCertificateContext (pCertContext);
    }
    _TRACE (-1, L"Leaving CCertMgrComponent::CreateCertChainsFromMultiSelect\n");
}

void CCertMgrComponent::CreateCertChainsFromSingleSelect (CCertMgrCookie* pCookie)
{
    _TRACE (1, L"Entering CCertMgrComponent::CreateCertChainsFromSingleSelect\n");
    // If this is the EFS store, prepare to delete all cert chain certs from
    // the CA and TRUST store
    // 1.  Enumerate all certs to be deleted
    // 2.  Enumerate all certs in EFS store
    // 3.  Remove certs to be deleted from list of certs in EFS store
    // 4.  Get all cert chains from remaining EFS certs and save in list
    // 5.  As each cert is deleted, get its cert chain.  For each 
    //      cert from the chain that is not found in the list, remove
    //      from CA store.
    CERT_CONTEXT_LIST   EFSCertContextList; 

    CCertStore* pEFSStore = 0;
    bool bDoChainDeletion = DoChainDeletion (pCookie, &pEFSStore); 
    
    if ( bDoChainDeletion && pEFSStore )
    {
        CERT_CONTEXT* pCertContext = 0;
        // enumerate EFS store
        while ( 1 )
        {
            pCertContext = const_cast <CERT_CONTEXT*> (pEFSStore->EnumCertificates (pCertContext));
            if ( pCertContext )
            {
                EFSCertContextList.AddTail (
                        const_cast <CERT_CONTEXT*> (::CertDuplicateCertificateContext (pCertContext)));
            }
            else
                break;
        }

        DeleteCertFromContextList (pCookie, EFSCertContextList);
    }

    // Build required cert chain certs - these must not be deleted from the CA 
    // store
    GetNotToBeDeletedCertChains (EFSCertContextList);
    
    // Clean up the cert context list
    CERT_CONTEXT* pCertContext = 0;
    while (!EFSCertContextList.IsEmpty () )
    {
        pCertContext = EFSCertContextList.RemoveHead ();
        if ( pCertContext )
            ::CertFreeCertificateContext (pCertContext);
    }
    _TRACE (-1, L"Leaving CCertMgrComponent::CreateCertChainsFromSingleSelect\n");
}



void CCertMgrComponent::GetNotToBeDeletedCertChains (CERT_CONTEXT_LIST& EFSCertContextList)
{
    _TRACE (1, L"Entering CCertMgrComponentData::GetNotToBeDeletedCertChains\n");
    CERT_CONTEXT*   pCertContext = 0;

    // for each cert context
    for (POSITION nextPos = EFSCertContextList.GetHeadPosition (); nextPos; )
    {
        pCertContext = EFSCertContextList.GetNext (nextPos);
        if ( pCertContext )
        {
            CERT_CONTEXT_LIST   certChainList;
            BOOL bValidated = GetCertificateChain (pCertContext, certChainList);
            if ( bValidated )
            {
                for (POSITION chainPos = certChainList.GetHeadPosition (); chainPos; )
                {
                    bool            bFound = false;
                    PCCERT_CONTEXT  pChainCertContext = 
                            certChainList.GetNext (chainPos);
                    if ( pChainCertContext )
                    {
                        for (POSITION pos = m_certChainsThatCantBeDeleted.GetHeadPosition (); 
                                pos; )
                        {
                            CERT_CONTEXT* pNonDelChainCertContext = m_certChainsThatCantBeDeleted.GetNext (pos);
                            if ( pNonDelChainCertContext )
                            {
                                if ( ::CertCompareCertificate (
                                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                        pNonDelChainCertContext->pCertInfo,
                                        pChainCertContext->pCertInfo) )
                                {
                                    bFound = true;
                                    break;
                                }
                            }
                        }

                        if ( !bFound )
                        {
                            m_certChainsThatCantBeDeleted.AddTail (
                                    const_cast<CERT_CONTEXT*>
                                    (::CertDuplicateCertificateContext (pCertContext)));
                        }
                    }
                }
            }

            // Clean up list
            CERT_CONTEXT* pDeleteContext = 0;
            while (!certChainList.IsEmpty () )
            {
                pDeleteContext = certChainList.RemoveHead ();
                if ( pDeleteContext )
                    ::CertFreeCertificateContext (pCertContext);
            }
        }
    }

    _TRACE (-1, L"LeavingLeaving CCertMgrComponentData::GetNotToBeDeletedCertChains\n");
}


HRESULT CCertMgrComponent::OnNotifyDelete (LPDATAOBJECT pDataObject)
{
    _TRACE (1, L"Entering CCertMgrComponent::OnNotifyDelete\n");
    ASSERT (pDataObject);
    if ( !pDataObject )
        return E_POINTER;

    HRESULT                 hr = S_OK;
    CCertMgrComponentData&  dataRef = QueryComponentDataRef ();
    CCertMgrCookie*         pCookie =
            dataRef.ConvertCookie (pDataObject);
    if ( pCookie )
    {
        CWaitCursor waitCursor;
        if ( ((CCertMgrCookie*) MMC_MULTI_SELECT_COOKIE) == pCookie )
        {

            // Is multiple select, get all selected items and delete each one
            CCertMgrDataObject* pDO = reinterpret_cast <CCertMgrDataObject*>(pDataObject);
            ASSERT (pDO);
            if ( pDO )
            {
                // Is multiple select, get all selected items and delete - confirm
                // first deletion only.  Don't commit until all are deleted.
                bool        bRequestConfirmation = true;

                CCertStore* pCertStore = 0;
                // NTRAID# 129428   Cert UI: Cert snapin: Deleting large 
                // number of certificates from the stores takes over 3 minutes
                // Change this to false to do commit only at end.
                bool        bDoCommit = false;

                CreateCertChainsFromMultiSelect (pDO, pCookie);

                pDO->Reset();
                while (pDO->Next(1, reinterpret_cast<MMC_COOKIE*>(&pCookie), NULL) != S_FALSE &&
                        SUCCEEDED (hr) )
                {
                    if ( pCookie->HasOpenPropertyPages () )
                    {
                        CString text;
                        CString caption;

                        VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
                        text.FormatMessage (IDS_CANT_DELETE_OBJECT_PAGES_OPEN, 
                                pCookie->GetObjectName ()); 
                        int     iRetVal = 0;
                        VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption,
                                MB_OK, &iRetVal)));
                        hr = E_FAIL;
                        break;
                    }
                }

                if ( SUCCEEDED (hr) )
                {
                    // If this is the store view, don't commit with each delete but commit
                    // all at once at the end.
                    pDO->Reset();
                    while (pDO->Next(1, reinterpret_cast<MMC_COOKIE*>(&pCookie), NULL) != S_FALSE &&
                            SUCCEEDED (hr) )
                    {
                        if ( bRequestConfirmation ) // first time through
                        {
                            if ( CERTMGR_SAFER_COMPUTER_ENTRY == pCookie->m_objecttype ||
                                    CERTMGR_SAFER_USER_ENTRY == pCookie->m_objecttype )
                            {
                            }
                            // Get the affected store.  The store is the same for all the
                            // certs in the list if the view mode is by store
                            else if ( IDM_STORE_VIEW == dataRef.m_activeViewPersist )
                            {
                                bDoCommit = false;
                                switch (pCookie->m_objecttype)
                                {
                                case CERTMGR_CERTIFICATE:
                                    {
                                        CCertificate* pCert = dynamic_cast<CCertificate*> (pCookie);
                                        if ( pCert )
                                        {
                                            pCertStore = pCert->GetCertStore ();
                                        }
                                    }
                                    break;

                                case CERTMGR_CRL:
                                    {
                                        CCRL* pCRL = dynamic_cast<CCRL*> (pCookie);
                                        if ( pCRL )
                                            pCertStore = &(pCRL->GetCertStore ());
                                    }
                                    break;

                                case CERTMGR_CTL:
                                    {
                                        CCTL* pCTL = dynamic_cast<CCTL*> (pCookie);
                                        if ( pCTL )
                                            pCertStore = &(pCTL->GetCertStore ());
                                    }
                                    break;

                                case CERTMGR_AUTO_CERT_REQUEST:
                                    {
                                        CAutoCertRequest* pAutoCertReq = dynamic_cast <CAutoCertRequest*> (pCookie);
                                        if ( pAutoCertReq )
                                            pCertStore = &(pAutoCertReq->GetCertStore ());
                                    }
                                    break;

                                default:
                                    ASSERT (0);
                                    break;
                                }
                            }
                        }

                        hr = DeleteCookie (pCookie, pDataObject, bRequestConfirmation, true, bDoCommit);
                        bRequestConfirmation = false;
                    }


                    if ( pCertStore )
                    {
                        hr = pCertStore->Commit ();
                        if ( SUCCEEDED (hr) )
                            pCertStore->Resync ();
                    }
                    else if ( dataRef.m_pGPEInformation && 
                        (CERTMGR_SAFER_COMPUTER_ENTRY == pCookie->m_objecttype ||
                        CERTMGR_SAFER_USER_ENTRY == pCookie->m_objecttype ) )
                    {
                        hr = dataRef.m_pGPEInformation->PolicyChanged (
                                CERTMGR_SAFER_COMPUTER_ENTRY == pCookie->m_objecttype ? TRUE : FALSE,
                                FALSE, &g_guidExtension, &g_guidSnapin);
                        hr = dataRef.m_pGPEInformation->PolicyChanged (
                                CERTMGR_SAFER_COMPUTER_ENTRY == pCookie->m_objecttype ? TRUE : FALSE,
                                FALSE, &g_guidRegExt, &g_guidSnapin);
                    }
                }
            }
        }
        else
        {
            if ( pCookie->HasOpenPropertyPages () )
            {
                CString text;
                CString caption;

                VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
                text.FormatMessage (IDS_CANT_DELETE_OBJECT_PAGES_OPEN, 
                        pCookie->GetObjectName ()); 
                int     iRetVal = 0;
                VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption,
                        MB_OK, &iRetVal)));
                hr = E_FAIL;
            }
            else
            {
                CreateCertChainsFromSingleSelect (pCookie);

                // If m_pPastedDO == pDataObject then this delete is the
                // result of a paste.
                // In that event, we don't want a confirmation message.
                hr = DeleteCookie (pCookie, pDataObject, m_pPastedDO != pDataObject, false, true);
            }
        }
    }

    if ( m_pPastedDO == pDataObject )
        m_pPastedDO = 0;

//    if ( SUCCEEDED (hr) )
//      hr = m_pConsole->UpdateAllViews (pDataObject, 0, 0);

    // Clean up the not-to-be-deleted cert context list
    CERT_CONTEXT* pCertContext = 0;
    while (!m_certChainsThatCantBeDeleted.IsEmpty () )
    {
        pCertContext = m_certChainsThatCantBeDeleted.RemoveHead ();
        if ( pCertContext )
            ::CertFreeCertificateContext (pCertContext);
    }

    _TRACE (-1, L"Leaving CCertMgrComponent::OnNotifyDelete: 0x%x\n", hr);
    return hr;
}


HRESULT CCertMgrComponent::DeleteCertFromResultPane (
        CCertificate * pCert, 
        LPDATAOBJECT pDataObject, 
        bool bDoCommit)
{
    _TRACE (1, L"Entering CCertMgrComponent::DeleteCertFromResultPane\n");
    HRESULT         hr = S_OK;
    SPECIAL_STORE_TYPE  storeType = pCert->GetCertStore ()->GetStoreType ();
    if ( pCert->DeleteFromStore (bDoCommit) )
    {
        CCertMgrComponentData& dataRef = QueryComponentDataRef ();

        if ( EFS_STORE == storeType )
        {
            dataRef.RemoveCertChainFromPolicy(pCert->GetCertContext (),
                    m_certChainsThatCantBeDeleted);
        }

        if ( IDM_USAGE_VIEW == dataRef.m_activeViewPersist && m_pLastUsageCookie )
        {
            m_pLastUsageCookie->SetCertCount (m_pLastUsageCookie->GetCertCount () - 1);
        }
        HRESULTITEM itemID;
        hr = m_pResultData->FindItemByLParam ( (LPARAM) pCert, &itemID);
        if ( SUCCEEDED (hr) )
        {
            hr = m_pResultData->DeleteItem (itemID, 0);
        }

        // If we can't succeed in removing this one item, then update the whole panel.
        if ( !SUCCEEDED (hr) )
        {
            hr = m_pConsole->UpdateAllViews (pDataObject, 0, 0);
        }
    }
    else
    {
        DWORD   dwErr = GetLastError ();
        CString text;
        CString caption;
        CCertStore* pStore = pCert->GetCertStore ();

        if ( pStore )
        {
            VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
            text.FormatMessage (IDS_CANT_DELETE_CERT_FROM_SYSTEM_STORE, 
                    pStore->GetLocalizedName (), 
                    GetSystemMessage (dwErr));
            int     iRetVal = 0;
            VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption,
                    MB_OK, &iRetVal)));
        }
        hr = HRESULT_FROM_WIN32 (dwErr);
    }

    _TRACE (-1, L"Leaving CCertMgrComponent::DeleteCertFromResultPane: 0x%x\n", hr);
    return hr;
}

HRESULT CCertMgrComponent::DeleteCRLFromResultPane (CCRL * pCRL, LPDATAOBJECT pDataObject)
{
    _TRACE (1, L"Entering CCertMgrComponent::DeleteCRLFromResultPane\n");
    HRESULT         hr = S_OK;
    if ( pCRL->DeleteFromStore () )
    {
        hr = pCRL->GetCertStore ().Commit ();
        ASSERT (SUCCEEDED (hr));
        if ( SUCCEEDED (hr) )
        {
            HRESULTITEM itemID;
            hr = m_pResultData->FindItemByLParam ( (LPARAM) pCRL, &itemID);
            if ( SUCCEEDED (hr) )
            {
                hr = m_pResultData->DeleteItem (itemID, 0);
            }
            else
            {
                _TRACE (0, L"IResultData::FindItemByLParam () failed: 0x%x (%s)\n",
                        hr, (PCWSTR) GetSystemMessage (hr));
            }

            // If we can't succeed in removing this one item, then update the whole panel.
            if ( !SUCCEEDED (hr) )
            {
                hr = m_pConsole->UpdateAllViews (pDataObject, 0, 0);
            }
        }
    }
    else
    {
        DisplayAccessDenied ();
    }
    _TRACE (-1, L"Leaving CCertMgrComponent::DeleteCRLFromResultPane: 0x%x\n", hr);
    return hr;
}

typedef struct _ENUM_ARG {
     DWORD                  dwFlags;
    CCertMgrComponent*      m_pComp;
    LPCWSTR                 m_pcszMachineName;
    LPCONSOLE               m_pConsole;
} ENUM_ARG, *PENUM_ARG;

static BOOL WINAPI EnumIComponentSysCallback (
     IN const void* pwszSystemStore,
     IN DWORD dwFlags,
     IN PCERT_SYSTEM_STORE_INFO /*pStoreInfo*/,
     IN OPTIONAL void* /*pvReserved*/,
     IN OPTIONAL void* pvArg
     )
{
    _TRACE (1, L"Entering EnumIComponentSysCallback\n");
     PENUM_ARG pEnumArg = (PENUM_ARG) pvArg;

    // Create new cookies
    SPECIAL_STORE_TYPE  storeType = GetSpecialStoreType ((LPWSTR) pwszSystemStore);

    if ( pEnumArg->m_pComp->QueryComponentDataRef ().ShowArchivedCerts () )
        dwFlags |= CERT_STORE_ENUM_ARCHIVED_FLAG;

    //
    // We will not expose the ACRS store for machines or users.  It is not
    // interesting or useful at this level.  All Auto Cert Requests should
    // be managed only at the policy level.
    //
    if ( ACRS_STORE != storeType )
    {
        CCertStore* pNewCookie = new CCertStore (
                CERTMGR_LOG_STORE,
                CERT_STORE_PROV_SYSTEM,
                dwFlags,
                pEnumArg->m_pcszMachineName,
                (LPCWSTR) pwszSystemStore,
                (LPCWSTR) pwszSystemStore,
                _T (""),
                storeType,
                dwFlags,
                pEnumArg->m_pConsole);
        if ( pNewCookie )
            pEnumArg->m_pComp->m_usageStoreList.AddTail (pNewCookie);
    }

    _TRACE (-1, L"Leaving EnumIComponentSysCallback\n");
     return TRUE;
}



HRESULT CCertMgrComponent::EnumerateLogicalStores (CCertMgrCookie& parentCookie)
{
    _TRACE (1, L"Entering CCertMgrComponent::EnumerateLogicalStores\n");
    CWaitCursor             cursor;
    HRESULT                 hr = S_OK;
    ENUM_ARG                enumArg;
    CCertMgrComponentData&  compData = QueryComponentDataRef ();
    DWORD                   dwFlags = compData.GetLocation ();

    // security review 2/26/2002 BryanWal ok
    ::ZeroMemory (&enumArg, sizeof (enumArg));
    enumArg.dwFlags = dwFlags;
    enumArg.m_pComp = this;
    enumArg.m_pcszMachineName = parentCookie.QueryNonNULLMachineName ();
    enumArg.m_pConsole = m_pConsole;
    CString location;
    void*   pvPara = 0;

    // empty out the store list first
    CCertStore* pCertStore = 0;
    while (!m_usageStoreList.IsEmpty () )
    {
        pCertStore = m_usageStoreList.RemoveHead ();
        ASSERT (pCertStore);
        if ( pCertStore )
        {
            pCertStore->SetDirty ();
            pCertStore->Commit ();
            pCertStore->Release ();
        }
    }

    if ( !compData.GetManagedService ().IsEmpty () )
    {
        if ( !compData.GetManagedComputer ().IsEmpty () )
        {
            location = compData.GetManagedComputer () + _T("\\") +
                    compData.GetManagedComputer ();
            pvPara = (void *) (LPCWSTR) location;
        }
        else
            pvPara = (void *) (LPCWSTR) compData.GetManagedService ();
    }
    else if ( !compData.GetManagedComputer ().IsEmpty () )
    {
        pvPara = (void *) (LPCWSTR) compData.GetManagedComputer ();
    }

    CString fileName = compData.GetCommandLineFileName ();
    if ( fileName.IsEmpty () )
    {
        // Ensure creation of MY store
        HCERTSTORE hTempStore = ::CertOpenStore (CERT_STORE_PROV_SYSTEM,
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, NULL,
                dwFlags | CERT_STORE_SET_LOCALIZED_NAME_FLAG,
                MY_SYSTEM_STORE_NAME);
        if ( hTempStore )  // otherwise, store is read only
        {
            VERIFY (::CertCloseStore (hTempStore, CERT_CLOSE_STORE_CHECK_FLAG));
        }
        else
        {
            _TRACE (0, L"CertOpenStore (%s) failed: 0x%x\n", 
                    MY_SYSTEM_STORE_NAME, GetLastError ());     
        }

        if ( !::CertEnumSystemStore (dwFlags, pvPara, &enumArg,
                EnumIComponentSysCallback) )
        {
            DWORD   dwErr = GetLastError ();
            CString text;
            CString caption;

            VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
            if ( ERROR_ACCESS_DENIED == dwErr )
            {
                VERIFY (text.LoadString (IDS_NO_PERMISSION));

            }
            else
            {
                text.FormatMessage (IDS_CANT_ENUMERATE_SYSTEM_STORES, GetSystemMessage (dwErr));
            }
            int     iRetVal = 0;
            VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption,
                    MB_OK, &iRetVal)));
            hr = HRESULT_FROM_WIN32 (dwErr);
        }
    }
    else
    {
        // Create new cookies

        CCertStore* pNewCookie = new CCertStore (
                CERTMGR_LOG_STORE,
                CERT_STORE_PROV_FILENAME_W,
                0, //dwFlags,
                parentCookie.QueryNonNULLMachineName (),
                fileName, fileName, _T (""), NO_SPECIAL_TYPE,
                QueryComponentDataRef ().GetLocation (),
                m_pConsole);
        if ( pNewCookie )
            m_usageStoreList.AddTail (pNewCookie);
    }

    _TRACE (-1, L"Leaving CCertMgrComponent::EnumerateLogicalStores: 0x%x\n", hr);
    return hr;
}


HRESULT CCertMgrComponent::EnumCertsByUsage (CUsageCookie * pUsageCookie)
{
    _TRACE (1, L"Entering CCertMgrComponent::EnumCertsByUsage\n");
    ASSERT (pUsageCookie);
    if ( !pUsageCookie )
        return E_POINTER;
    CCertMgrComponentData&  compData = QueryComponentDataRef ();

    HRESULT hr = m_pResultData->DeleteAllRsltItems ();
    if ( SUCCEEDED (hr) )
    {
        compData.RemoveResultCookies (m_pResultData);
    }

    if ( m_bShowArchivedCertsStateWhenLogStoresEnumerated !=
            compData.ShowArchivedCerts () )
    {
        m_bShowArchivedCertsStateWhenLogStoresEnumerated =
                compData.ShowArchivedCerts ();
        m_bUsageStoresEnumerated = false;
        CloseAndReleaseUsageStores ();
    }
    // Enumerate system stores, if not already done
    if ( !m_bUsageStoresEnumerated && pUsageCookie )
    {
        hr = EnumerateLogicalStores (*pUsageCookie);
        m_bUsageStoresEnumerated = true;
    }


    // Iterate through stores and find certs for given Oid.
    CCertStore* pCertStore = 0;
    CCookie&    rootCookie = compData.QueryBaseRootCookie ();
    int         nCertCount = 0;

    for (POSITION pos = m_usageStoreList.GetHeadPosition (); pos; )
    {
        pCertStore = m_usageStoreList.GetNext (pos);
        ASSERT (pCertStore);
        if ( pCertStore )
        {
            int     nOIDCount = pUsageCookie->GetOIDCount ();
            ASSERT (nOIDCount > 0);
            if ( nOIDCount <= 0 )
                continue;

            CERT_ENHKEY_USAGE   enhKeyUsage;
            enhKeyUsage.cUsageIdentifier = nOIDCount;
            enhKeyUsage.rgpszUsageIdentifier = new LPSTR [nOIDCount];
            if ( enhKeyUsage.rgpszUsageIdentifier )
            {
                for (int nIndex = 0; nIndex < nOIDCount; nIndex++)
                {
                    enhKeyUsage.rgpszUsageIdentifier[nIndex] =
                             (!nIndex) ?
                            pUsageCookie->GetFirstOID () :
                            pUsageCookie->GetNextOID ();
                }

                PCCERT_CONTEXT  pPrevCertContext = 0;
                PCCERT_CONTEXT  pCertContext = 0;
                CCertificate*   pCert = 0;
                DWORD           dwErr = 0;
                RESULTDATAITEM  rdItem;
                void*           pvPara = (void *) &enhKeyUsage;

                // security review 2/26/2002 BryanWal ok
                ::ZeroMemory (&rdItem, sizeof (rdItem));
                rdItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
                rdItem.nImage = iIconCertificate;
                rdItem.nCol = 0;

                bool    bDone = false;
                while ( !bDone )
                {
                    pCertContext = pCertStore->FindCertificate (
                            CERT_FIND_VALID_ENHKEY_USAGE_FLAG |
                                CERT_FIND_OPTIONAL_ENHKEY_USAGE_FLAG, // | CERT_FIND_OR_ENHKEY_USAGE_FLAG ,
                            CERT_FIND_ENHKEY_USAGE,
                            pvPara,
                            pPrevCertContext);
                    if ( !pCertContext )
                    {
                        dwErr = GetLastError ();
                        switch (dwErr)
                        {
                        case CRYPT_E_NOT_FOUND: // We're done.  No more certificates.
                            break;

                        case 0:     // no error to display
                            break;

                        case E_INVALIDARG:
                            if ( !pCertStore->GetStoreHandle () )
                            {
                                CString text;
                                CString caption;
                                int     iRetVal = IDNO;

                                text.FormatMessage 
                                        (IDS_CANNOT_OPEN_CERT_STORE_TO_FIND_CERT_BY_PURPOSE,
                                        pCertStore->GetLocalizedName ());
                                VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
                                hr = m_pConsole->MessageBox (text, caption,
                                        MB_ICONWARNING | MB_OK, &iRetVal);
                                break;
                            }
                            // fall through

                        default:
                            compData.DisplaySystemError (dwErr);
                            break;
                        }
                        bDone = true;
                        continue;
                    }
                    pCert =
                        new CCertificate (pCertContext, pCertStore);

                    if ( !pCert )
                    {
                        // Do this twice.  Must reduce ref count by 2
                        ::CertFreeCertificateContext (pCertContext);
                        ::CertFreeCertificateContext (pCertContext);
                        hr = E_OUTOFMEMORY;
                        break;
                    }
                    nCertCount++;

                    rootCookie.m_listResultCookieBlocks.AddHead (pCert);
                    rdItem.str = MMC_CALLBACK;
                    rdItem.lParam = (LPARAM) pCert;
                    pCert->m_resultDataID = m_pResultData;
                    hr = m_pResultData->InsertItem (&rdItem);
                    ASSERT (SUCCEEDED (hr));


                    pPrevCertContext = pCertContext;
                }
                pCertStore->Close ();
                delete [] enhKeyUsage.rgpszUsageIdentifier;
            }
            else
            {
                hr = E_OUTOFMEMORY;
                break;
            }
        }
    }

    pUsageCookie->SetCertCount (nCertCount);
    hr = DisplayCertificateCountByUsage (
            pUsageCookie->GetObjectName (),
            pUsageCookie->GetCertCount ());
    _TRACE (-1, L"Leaving CCertMgrComponent::EnumCertsByUsage: 0x%x\n", hr);
    return hr;
}


// This compare is used to sort the items in the listview
//
// Parameters:
//
// lUserParam - user param passed in when IResultData::Sort () was called
// prdc->prdch1->cookie - first item to compare
// prdc->prdch2->cookie - second item to compare
// pnResult [in, out]- contains the col on entry,
//             -1, 0, 1 based on comparison for return value.
//
// Note: Assume sort is ascending when comparing.

STDMETHODIMP CCertMgrComponent::Compare (RDCOMPARE* prdc, int* pnResult)
{
    if ( !prdc )
        return E_INVALIDARG;

    HRESULT                 hr = S_OK;

    if ( pnResult && prdc->prdch1->cookie && prdc->prdch2->cookie )
    {

        if ( CERTMGR_MULTISEL == m_currResultNodeType )
        {
            CCertMgrCookie* pCookie = reinterpret_cast<CCertMgrCookie*> (prdc->prdch1->cookie);
            if ( pCookie )
            {
                // result node type is CERTMGR_MULTISEL.  Must be changed to
                // a real result node type so that we can sort
                switch (pCookie->m_objecttype)
                {
                case CERTMGR_CERTIFICATE:
                case CERTMGR_CTL:
                case CERTMGR_CRL: 
                case CERTMGR_AUTO_CERT_REQUEST:
                case CERTMGR_SAFER_COMPUTER_ENTRY:
                case CERTMGR_SAFER_USER_ENTRY:
                    m_currResultNodeType = pCookie->m_objecttype;
                    break;

                default:
                    break;
                }
            }
        }


        // NTRAID# 464606  SAFER: Can't sort security levels by description.
        // Sometimes m_currResultNodeType doesn't come in with the right type 
        // because the node hasn't actually been selected prior to sorting.
        // When this happens, set bTypeFound to false, set m_currResultNodeType
        // to the cookie's type.
        // If the sort is successfully completed, set nPasses to 0 to break out
        // of the loop.
        // If we have to reset m_currResultNodeType and it still fails, nPasses
        // will have already been decremented to 0.  In any case, we only want
        // two passes through the while loop at most.

        CCertMgrCookie* pCookieA = reinterpret_cast <CCertificate*> (prdc->prdch1->cookie);
        CCertMgrCookie* pCookieB = reinterpret_cast <CCertificate*> (prdc->prdch2->cookie);
        bool            bTypeFound = true;
        int             nPasses = 2;

        while (nPasses--)
        {
            if ( !bTypeFound )
                m_currResultNodeType = pCookieA->m_objecttype;

            switch (m_currResultNodeType)
            {
            case CERTMGR_CERTIFICATE:
                if ( CERTMGR_CERTIFICATE == pCookieA->m_objecttype &&
                    CERTMGR_CERTIFICATE == pCookieB->m_objecttype )
                {
                    m_nSelectedCertColumn = prdc->nColumn;
                    CCertificate* pCertA = reinterpret_cast <CCertificate*> (prdc->prdch1->cookie);
                    CCertificate* pCertB = reinterpret_cast <CCertificate*> (prdc->prdch2->cookie);
                    switch ( prdc->nColumn )
                    {
                    case COLNUM_CERT_SUBJECT:
                        *pnResult = LocaleStrCmp (pCertA->GetSubjectName (),
                                pCertB->GetSubjectName ());
                        break;

                    case COLNUM_CERT_ISSUER:
                        *pnResult = LocaleStrCmp (pCertA->GetIssuerName (),
                                pCertB->GetIssuerName ());
                        break;

                    case COLNUM_CERT_EXPIRATION_DATE:
                        *pnResult = pCertA->CompareExpireDate (*pCertB);
                        break;

                    case COLNUM_CERT_PURPOSE:
                        *pnResult = LocaleStrCmp (pCertA->GetEnhancedKeyUsage (),
                                         pCertB->GetEnhancedKeyUsage ());
                        break;

                    case COLNUM_CERT_CERT_NAME:
                        *pnResult = LocaleStrCmp (pCertA->GetFriendlyName (),
                                         pCertB->GetFriendlyName ());
                        break;

                    case COLNUM_CERT_STATUS:
                        *pnResult = LocaleStrCmp (pCertA->FormatStatus (), 
                                pCertB->FormatStatus ());
                        break;

                    // NTRAID# 247237   Cert UI: Cert Snapin: Certificates snapin should show  template name
                    case COLNUM_CERT_TEMPLATE:
                        *pnResult = LocaleStrCmp (pCertA->GetTemplateName (), 
                                pCertB->GetTemplateName ());
                        break;

                    default:
                        ASSERT (0);
                        break;
                    }
                    nPasses = 0;
                }
                else
                    bTypeFound = false;
                break;

            case CERTMGR_CRL:
                if ( CERTMGR_CRL == pCookieA->m_objecttype &&
                    CERTMGR_CRL == pCookieB->m_objecttype )
                {
                    m_nSelectedCRLColumn = prdc->nColumn;
                    CCRL* pCRLA = reinterpret_cast <CCRL*> (prdc->prdch1->cookie);
                    CCRL* pCRLB = reinterpret_cast <CCRL*> (prdc->prdch2->cookie);
                    switch ( prdc->nColumn )
                    {
                    case COLNUM_CRL_EFFECTIVE_DATE:
                        *pnResult = pCRLA->CompareEffectiveDate (*pCRLB);
                        break;

                    case COLNUM_CRL_ISSUER:
                        *pnResult = LocaleStrCmp (pCRLA->GetIssuerName (),
                                         pCRLB->GetIssuerName ());
                        break;

                    case COLNUM_CRL_NEXT_UPDATE:
                        *pnResult = pCRLA->CompareNextUpdate (*pCRLB);
                        break;

                    default:
                        ASSERT (0);
                        break;
                    }
                    nPasses = 0;
                }
                else
                    bTypeFound = false;
                break;

            case CERTMGR_CTL:
                if ( CERTMGR_CTL == pCookieA->m_objecttype &&
                    CERTMGR_CTL == pCookieB->m_objecttype )
                {
                    m_nSelectedCTLColumn = prdc->nColumn;
                    CCTL* pCTLA = reinterpret_cast <CCTL*> (prdc->prdch1->cookie);
                    CCTL* pCTLB = reinterpret_cast <CCTL*> (prdc->prdch2->cookie);
                    switch ( prdc->nColumn )
                    {
                    case COLNUM_CTL_ISSUER:
                        *pnResult = LocaleStrCmp (pCTLA->GetIssuerName (),
                                         pCTLB->GetIssuerName ());
                        break;

                    case COLNUM_CTL_EFFECTIVE_DATE:
                        *pnResult = pCTLA->CompareEffectiveDate (*pCTLB);
                        break;

                    case COLNUM_CTL_PURPOSE:
                        *pnResult = LocaleStrCmp (pCTLA->GetPurpose (),
                                         pCTLB->GetPurpose ());
                        break;

                    case COLNUM_CTL_FRIENDLY_NAME:
                    default:
                        ASSERT (0);
                        break;
                    }
                    nPasses = 0;
                }
                else
                    bTypeFound = false;
                break;

            case CERTMGR_AUTO_CERT_REQUEST:
                if ( CERTMGR_AUTO_CERT_REQUEST == pCookieA->m_objecttype &&
                    CERTMGR_AUTO_CERT_REQUEST == pCookieB->m_objecttype )
                {
                    CAutoCertRequest* pAutoCertA = reinterpret_cast <CAutoCertRequest*> (prdc->prdch1->cookie);
                    CAutoCertRequest* pAutoCertB = reinterpret_cast <CAutoCertRequest*> (prdc->prdch2->cookie);
                    switch ( prdc->nColumn )
                    {
                    case 0:
                        {
                            CString strA;
                            CString strB;

                            VERIFY (SUCCEEDED (pAutoCertA->GetCertTypeName (strA)));
                            VERIFY (SUCCEEDED (pAutoCertB->GetCertTypeName (strB)));
                                    *pnResult = LocaleStrCmp (strA, strB);
                        }
                        break;

                    default:
                        ASSERT (0);
                        break;
                    }
                    nPasses = 0;
                }
                else
                    bTypeFound = false;
                break;

            case CERTMGR_SAFER_COMPUTER_ENTRY:
            case CERTMGR_SAFER_USER_ENTRY:
                if ( (CERTMGR_SAFER_COMPUTER_ENTRY == pCookieA->m_objecttype &&
                    CERTMGR_SAFER_COMPUTER_ENTRY == pCookieB->m_objecttype) ||
                    (CERTMGR_SAFER_USER_ENTRY == pCookieA->m_objecttype &&
                    CERTMGR_SAFER_USER_ENTRY == pCookieB->m_objecttype) )
                {
                    CSaferEntry* pSaferEntryA = reinterpret_cast <CSaferEntry*> (prdc->prdch1->cookie);
                    CSaferEntry* pSaferEntryB = reinterpret_cast <CSaferEntry*> (prdc->prdch2->cookie);
                    m_nSelectedSaferEntryColumn = prdc->nColumn;
                    switch (prdc->nColumn)
                    {
                    case COLNUM_SAFER_ENTRIES_NAME:
                        *pnResult = LocaleStrCmp (pSaferEntryA->GetObjectName (),
                                pSaferEntryB->GetObjectName ());
                        break;

                    case COLNUM_SAFER_ENTRIES_TYPE:
                        *pnResult = LocaleStrCmp (pSaferEntryA->GetTypeString (),
                                pSaferEntryB->GetTypeString ());
                        break;

                    case COLNUM_SAFER_ENTRIES_LEVEL:
                        *pnResult = LocaleStrCmp (pSaferEntryA->GetLevelFriendlyName (),
                                pSaferEntryB->GetLevelFriendlyName ());
                        break;

                    case COLNUM_SAFER_ENTRIES_DESCRIPTION:
                        *pnResult = LocaleStrCmp (pSaferEntryA->GetDescription (),
                                pSaferEntryB->GetDescription ());
                        break;

                    case COLNUM_SAFER_ENTRIES_LAST_MODIFIED_DATE:
                        *pnResult = pSaferEntryA->CompareLastModified (*pSaferEntryB);
                        break;
                   }
                    nPasses = 0;
                }
                else
                    bTypeFound = false;
                break;

            case CERTMGR_SAFER_COMPUTER_LEVEL:
            case CERTMGR_SAFER_USER_LEVEL:
                if ( (CERTMGR_SAFER_COMPUTER_LEVEL == pCookieA->m_objecttype &&
                    CERTMGR_SAFER_COMPUTER_LEVEL == pCookieB->m_objecttype) ||
                    (CERTMGR_SAFER_USER_LEVEL == pCookieA->m_objecttype &&
                    CERTMGR_SAFER_USER_LEVEL == pCookieB->m_objecttype) )
                {
                    CSaferLevel* pSaferLevelA = reinterpret_cast <CSaferLevel*> (prdc->prdch1->cookie);
                    CSaferLevel* pSaferLevelB = reinterpret_cast <CSaferLevel*> (prdc->prdch2->cookie);
                    switch (prdc->nColumn)
                    {
                    case COLNUM_SAFER_LEVEL_NAME:
                        if ( pSaferLevelA->GetLevel () > pSaferLevelB->GetLevel () )
                            *pnResult = 1;
                        else if ( pSaferLevelA->GetLevel () < pSaferLevelB->GetLevel () )
                            *pnResult = -1;
                        else
                            *pnResult = 0;
                        break;

                    case COLNUM_SAFER_LEVEL_DESCRIPTION:
                        *pnResult = LocaleStrCmp (pSaferLevelA->GetDescription (),
                                pSaferLevelB->GetDescription ());
                        break;

                    default:
                        break;
                    }
                    nPasses = 0;
                }
                else
                    bTypeFound = false;
                break;

            case CERTMGR_LOG_STORE:
            case CERTMGR_PHYS_STORE:
                if ( (CERTMGR_LOG_STORE == pCookieA->m_objecttype &&
                    CERTMGR_LOG_STORE == pCookieB->m_objecttype) ||
                    (CERTMGR_PHYS_STORE == pCookieA->m_objecttype &&
                    CERTMGR_PHYS_STORE == pCookieB->m_objecttype) )
                {
                    CCertStore* pStoreA = reinterpret_cast <CCertStore*> (prdc->prdch1->cookie);
                    CCertStore* pStoreB = reinterpret_cast <CCertStore*> (prdc->prdch2->cookie);
                    m_nSelectedSaferEntryColumn = prdc->nColumn;
                    if (0 == prdc->nColumn )
                    {
                        *pnResult = LocaleStrCmp (pStoreA->GetLocalizedName (),
                                pStoreB->GetLocalizedName ());
                    }
                    nPasses = 0;
                }
                else
                    bTypeFound = false;
                break;

            case CERTMGR_USAGE:
                if ( CERTMGR_USAGE == pCookieA->m_objecttype &&
                    CERTMGR_USAGE == pCookieB->m_objecttype )
                {
                    CUsageCookie* pUsageA = reinterpret_cast <CUsageCookie*> (prdc->prdch1->cookie);
                    CUsageCookie* pUsageB = reinterpret_cast <CUsageCookie*> (prdc->prdch2->cookie);
                    m_nSelectedSaferEntryColumn = prdc->nColumn;
                    if (0 == prdc->nColumn )
                    {
                        *pnResult = LocaleStrCmp (pUsageA->GetObjectName (),
                                pUsageB->GetObjectName ());
                    }
                    nPasses = 0;
                }
                else
                    bTypeFound = false;
                break;

            default:
                bTypeFound = false;
                break;
            }
        }
    }
    
    return hr;
}


HRESULT CCertMgrComponent::EnumCTLs (CCertStore& rCertStore)
{
    _TRACE (1, L"Entering CCertMgrComponent::EnumCTLs\n");
    CCertMgrComponentData&  compdata = QueryComponentDataRef ();
    RESULTDATAITEM          rdItem;
    CWaitCursor             cursor;
     PCCTL_CONTEXT          pCTLContext = 0;
    HRESULT                 hr = 0;
    CCTL*                   pCTL = 0;
    CCookie&                rootCookie = compdata.QueryBaseRootCookie ();
    CTypedPtrList<CPtrList, CCertStore*> storeList;

    // Only enumerate the logical stores if this is not the GPE or RSOP.  If it is the
    // GPE, add the Trust and Root store.
    if ( !compdata.m_pGPEInformation && !compdata.m_bIsRSOP )
    {
        hr = compdata.EnumerateLogicalStores (&storeList);
        ASSERT (SUCCEEDED (hr));
    }
    else
    {
        if ( compdata.m_pGPERootStore )
        {
            compdata.m_pGPERootStore->AddRef ();
            storeList.AddTail (compdata.m_pGPERootStore);
        }
        if ( compdata.m_pGPETrustStore )
        {
            compdata.m_pGPETrustStore->AddRef ();
            storeList.AddTail (compdata.m_pGPETrustStore);
        }
    }
    if ( compdata.m_pFileBasedStore )
    {
        compdata.m_pFileBasedStore->AddRef ();
        storeList.AddTail (compdata.m_pFileBasedStore);
    }

    // security review 2/26/2002 BryanWal ok
    ::ZeroMemory (&rdItem, sizeof (rdItem));
    rdItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
    rdItem.nCol = 0;    // Must always be 0
    while ( 1 )
    {
        pCTLContext = rCertStore.EnumCTLs (pCTLContext);
        if ( !pCTLContext )
            break;
        if ( ACRS_STORE == rCertStore.GetStoreType () )
        {
            pCTL =
                new CAutoCertRequest (pCTLContext, rCertStore);
        }
        else
        {
            pCTL =
                new CCTL (pCTLContext, rCertStore, CERTMGR_CTL, &storeList);
        }
        if ( !pCTL )
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        if ( ACRS_STORE != rCertStore.GetStoreType () )
            rdItem.nImage = iIconCTL;
        else
            rdItem.nImage = 0;

        rootCookie.m_listResultCookieBlocks.AddHead (pCTL);
        rdItem.str = MMC_TEXTCALLBACK;
        rdItem.lParam = (LPARAM) pCTL;
        pCTL->m_resultDataID = m_pResultData;
        hr = m_pResultData->InsertItem (&rdItem);
        ASSERT (SUCCEEDED (hr));
    }
    rCertStore.Close ();

    CCertStore* pStore = 0;

    // Clean up store list
    while (!storeList.IsEmpty () )
    {
        pStore = storeList.RemoveHead ();
        ASSERT (pStore);
        if ( pStore )
        {
            pStore->Close ();
            pStore->Release ();
        }
    }

    _TRACE (-1, L"Leaving CCertMgrComponent::EnumCTLs: 0x%x\n", hr);
    return hr;
}


STDMETHODIMP CCertMgrComponent::Notify (LPDATAOBJECT pDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    _TRACE (1, L"Entering CCertMgrComponent::Notify\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    HRESULT hr = S_OK;

    // NTRAID# 678670 SAFER UI:  AV When Create New Policies is used as a TaskPad task...
    // NTRAID# 677512 SAFER UI:  Access Violation when creating new safer policy
    // NTRAID# 677529 SAFER UI:  Access Violation while deleting software restriction policies
    // The component data console pointer could be bad and should be set to a 
    // valid current pointer.
    if ( MMCN_ACTIVATE != event || 0 != arg )   // If MMC_ACTIVATE and window is 
                                                // being activated or any other notification
        SetComponentDataConsolePointer (m_pConsole);

    switch (event)
    {
        case MMCN_CUTORMOVE:
            hr = OnNotifyCutOrMove (arg);
            break;

        case MMCN_QUERY_PASTE:
            hr = OnNotifyQueryPaste (pDataObject, arg, param);
            break;

        case MMCN_PASTE:
            hr = OnNotifyPaste (pDataObject, arg, param);
            break;

        case MMCN_SHOW:
        // CODEWORK this is hacked together quickly
        {
            CCookie* pCookie = NULL;
            hr = ExtractData (pDataObject,
                    CDataObject::m_CFRawCookie,
                    &pCookie,
                    sizeof(pCookie));
            if ( SUCCEEDED (hr) )
            {
                hr = Show (ActiveBaseCookie (pCookie), arg,
                (HSCOPEITEM) param, pDataObject);
            }
        }
        break;

        case MMCN_CANPASTE_OUTOFPROC:
            hr = OnNotifyCanPasteOutOfProc (reinterpret_cast<LPBOOL>(param));
            break;

        default:
            hr = CComponent::Notify (pDataObject, event, arg, param);
            break;
    }

    _TRACE (-1, L"Leaving CCertMgrComponent::Notify: 0x%x\n", hr);
    return hr;
}


void CCertMgrComponent::SetComponentDataConsolePointer (LPCONSOLE pConsole)
{
    CCertMgrComponentData& dataRef = QueryComponentDataRef ();
    if ( dataRef.m_pComponentConsole != pConsole )
    {
        if ( dataRef.m_pComponentConsole )
             SAFE_RELEASE (dataRef.m_pComponentConsole);
        dataRef.m_pComponentConsole = pConsole;
        dataRef.m_pComponentConsole->AddRef ();
    }
}

void CCertMgrComponent::DisplayAccessDenied ()
{
    _TRACE (1, L"Entering CCertMgrComponent::DisplayAccessDenied\n");
    DWORD   dwErr = GetLastError ();
    ASSERT (E_ACCESSDENIED == dwErr);
    if ( E_ACCESSDENIED == dwErr )
    {
        LPVOID lpMsgBuf;
        
        // security review 2/26/2002 BryanWal ok - message is from system
        ::FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                GetLastError (),
                MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                 (LPWSTR) &lpMsgBuf,     0,     NULL );
            
        // Display the string.
        CString caption;
        VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
        int     iRetVal = 0;
        VERIFY (SUCCEEDED (m_pConsole->MessageBox ( (LPWSTR) lpMsgBuf, caption,
            MB_ICONWARNING | MB_OK, &iRetVal)));

        // Free the buffer.
        LocalFree (lpMsgBuf);
    }
    _TRACE (-1, L"Leaving CCertMgrComponent::DisplayAccessDenied\n");
}

HRESULT CCertMgrComponent::OnNotifyPaste (LPDATAOBJECT pDataObject, LPARAM arg, LPARAM param)
{
    _TRACE (1, L"Entering CCertMgrComponent::OnNotifyPaste\n");
    ASSERT (pDataObject && arg);
    if ( !pDataObject || !arg )
        return E_POINTER;

    HRESULT                 hr = S_OK;
    CCertMgrComponentData&  dataRef = QueryComponentDataRef ();
    HSCOPEITEM              hScopeItem = -1;
    bool                    bContainsCerts = false;
    bool                    bContainsCTLs = false;
    bool                    bContainsCRLs = false;

    CCertMgrCookie* pTargetCookie = dataRef.ConvertCookie (pDataObject);
    ASSERT (pTargetCookie);
    if ( pTargetCookie )
    {
        CCertStore*         pCertStore = 0;
        SPECIAL_STORE_TYPE  storeType = NO_SPECIAL_TYPE;

        switch (pTargetCookie->m_objecttype)
        {
        case CERTMGR_PHYS_STORE:
        case CERTMGR_LOG_STORE:
        case CERTMGR_LOG_STORE_GPE:
        case CERTMGR_LOG_STORE_RSOP:
            {
                pCertStore = reinterpret_cast <CCertStore*>
                        (pTargetCookie);
                ASSERT (pCertStore);
                if ( pCertStore )
                {
                    pCertStore->AddRef ();
                    storeType = pCertStore->GetStoreType ();
                    hScopeItem = pCertStore->m_hScopeItem;
                    bContainsCerts = pCertStore->ContainsCertificates ();
                    bContainsCRLs = pCertStore->ContainsCRLs ();
                    bContainsCTLs = pCertStore->ContainsCTLs ();
                    ASSERT (-1 != hScopeItem);
                }
                else
                    hr = E_POINTER;
            }
            break;

        case CERTMGR_CRL_CONTAINER:
            {
                bContainsCRLs = true;
                CContainerCookie* pCont = reinterpret_cast <CContainerCookie*>
                        (pTargetCookie);
                ASSERT (pCont);
                if ( pCont )
                {
                    pCertStore = &(pCont->GetCertStore ());
                    pCertStore->AddRef ();
                    storeType = pCont->GetStoreType ();
                }
                else
                    hr = E_POINTER;
            }
            break;

        case CERTMGR_CTL_CONTAINER:
            {
                bContainsCTLs = true;
                CContainerCookie* pCont = reinterpret_cast <CContainerCookie*>
                        (pTargetCookie);
                ASSERT (pCont);
                if ( pCont )
                {
                    pCertStore = &(pCont->GetCertStore ());
                    pCertStore->AddRef ();
                    storeType = pCont->GetStoreType ();
                }
                else
                    hr = E_POINTER;
            }
            break;

        case CERTMGR_CERT_CONTAINER:
            {
                bContainsCerts = true;
                CContainerCookie* pCont = reinterpret_cast <CContainerCookie*>
                        (pTargetCookie);
                ASSERT (pCont);
                if ( pCont )
                {
                    pCertStore = &(pCont->GetCertStore ());
                    pCertStore->AddRef ();
                    storeType = pCont->GetStoreType ();
                }
                else
                    hr = E_POINTER;
            }
            break;

        case CERTMGR_CERTIFICATE:
            {
                CCertificate* pCert = reinterpret_cast <CCertificate*> (pTargetCookie);
                ASSERT (pCert);
                if ( pCert )
                {
                    pCertStore = pCert->GetCertStore ();
                    pCertStore->AddRef ();
                    storeType = pCert->GetStoreType ();
                }
                else
                    hr = E_POINTER;
            }
            break;

        case CERTMGR_CRL:
            {
                CCRL* pCRL = reinterpret_cast <CCRL*> (pTargetCookie);
                ASSERT (pCRL);
                if ( pCRL )
                {
                    pCertStore = &(pCRL->GetCertStore ());
                    pCertStore->AddRef ();
                }
                else
                    hr = E_POINTER;
            }
            break;

        case CERTMGR_CTL:
            {
                CCTL* pCTL = reinterpret_cast <CCTL*> (pTargetCookie);
                ASSERT (pCTL);
                if ( pCTL )
                {
                    pCertStore = &(pCTL->GetCertStore ());
                    pCertStore->AddRef ();
                }
                else
                    hr = E_POINTER;
            }
            break;

        case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
        case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
            ASSERT (0);
            break;

        case CERTMGR_SAFER_COMPUTER_ENTRIES:
        case CERTMGR_SAFER_USER_ENTRIES:
            {
                param = 0; // do not allow cut/move of originating cert
                CSaferEntries* pSaferEntries = dynamic_cast <CSaferEntries*> (pTargetCookie);
                if ( pSaferEntries )
                {
                    CCertStore* pGPEStore = 0;
                    bool    bIsComputer = 
                        (CERTMGR_SAFER_COMPUTER_ENTRIES == pTargetCookie->m_objecttype);
                    DWORD dwDefaultLevelID = CSaferLevel::ReturnDefaultLevel (
                        dataRef.m_pGPEInformation, 
                        bIsComputer ? true : false, 
                        bIsComputer ? dataRef.m_rsopObjectArrayComputer : dataRef.m_rsopObjectArrayUser);

                    if ( SAFER_LEVELID_DISALLOWED== dwDefaultLevelID )
                        hr = pSaferEntries->GetTrustedPublishersStore (&pGPEStore);
                    else
                        hr = pSaferEntries->GetDisallowedStore (&pGPEStore);
                    if ( SUCCEEDED (hr) )
                    {
                        pCertStore = pGPEStore;
                    }
                }
            }
            break;

        default:
            hr = E_UNEXPECTED;
            break;
        }


        if ( !SUCCEEDED (hr) )
            return hr;

        CCertMgrCookie* pPastedCookie =
                dataRef.ConvertCookie ((LPDATAOBJECT) arg);
        if ( pPastedCookie && pCertStore )
        {
            if ( ((CCertMgrCookie*) MMC_MULTI_SELECT_COOKIE) == pPastedCookie )
            {
                LPDATAOBJECT*   ppDO = reinterpret_cast<LPDATAOBJECT*>((LPDATAOBJECT) param);
                 CCookiePtrArray    rgCookiesCopied;

                // Is multiple select, get all selected items and paste each one
                LPDATAOBJECT    pMSDO = (LPDATAOBJECT) arg;
                if ( pMSDO )
                {
                    CCertMgrDataObject* pDO = reinterpret_cast <CCertMgrDataObject*>(pMSDO);
                    ASSERT (pDO);
                    if ( pDO )
                    {
                        bool            bRequestConfirmation = true;
                        CCertMgrCookie* pCookie = 0;
                        pDO->Reset();
                        while (pDO->Next(1, reinterpret_cast<MMC_COOKIE*>(&pCookie), NULL) != S_FALSE)
                        {
                            hr = PasteCookie (pCookie, pTargetCookie, *pCertStore,
                                    storeType, bContainsCerts, bContainsCRLs, bContainsCTLs,
                                    hScopeItem, bRequestConfirmation, true,
                                    pDataObject);
                            if ( SUCCEEDED (hr) && ppDO && S_FALSE != hr )
                                rgCookiesCopied.Add (pCookie);
                            else if ( FAILED (hr) )
                                break;
                            bRequestConfirmation = false;
                        }
                    }
                    else
                        return E_UNEXPECTED;
                }
                else
                    return E_UNEXPECTED;


                if ( pCertStore && SUCCEEDED (hr) )
                {
                    pCertStore->Commit ();
                }
                else
                    pCertStore->Resync ();

                if ( !bContainsCerts ) 
                {
                    // not necessary for certs - they're 
                    //added to the end
                    m_pConsole->UpdateAllViews (pDataObject, 0, HINT_PASTE_COOKIE);
                }

                if ( !ppDO )
                    return S_OK;

                *ppDO = 0;



                 if ( rgCookiesCopied.GetSize () == 0 )
                    return S_FALSE;

                CComObject<CCertMgrDataObject>* pObject = 0;
                hr = CComObject<CCertMgrDataObject>::CreateInstance(&pObject);
                ASSERT(SUCCEEDED(hr));
                if (FAILED(hr))
                    return hr;

                ASSERT(pObject != NULL);
                if (pObject == NULL)
                    return E_OUTOFMEMORY;

                hr = pObject->Initialize (
                        pPastedCookie,
                        CCT_UNINITIALIZED,
                        FALSE,
                        0,
                        L"",
                        L"",
                        L"",
                        dataRef);

                for (int i=0; i < rgCookiesCopied.GetSize(); ++i)
                {
                    pObject->AddCookie(rgCookiesCopied[i]);
                }

                hr = pObject->QueryInterface(
                        IID_PPV_ARG (IDataObject, ppDO));

                return hr;
            }
            else
            {
                hr = PasteCookie (pPastedCookie, pTargetCookie, *pCertStore,
                        storeType, bContainsCerts, bContainsCRLs, bContainsCTLs,
                        hScopeItem, true, false,
                        pDataObject);
                if ( pCertStore && SUCCEEDED (hr) )
                {
                    if ( param )   // a non-NULL value indicates that a cut/move is desired
                    {
                        LPDATAOBJECT    srcDO = (LPDATAOBJECT) arg;
                        LPDATAOBJECT*   ppDO = reinterpret_cast<LPDATAOBJECT*>(param);
                        hr = srcDO->QueryInterface(
                                IID_PPV_ARG (IDataObject, ppDO));
                    }
                    m_pPastedDO = (LPDATAOBJECT) arg;
                    pCertStore->Commit ();
                }
                else
                    pCertStore->Resync ();
                if ( !bContainsCerts ) 
                {
                    // not necessary for certs - they're 
                    //added to the end
                    m_pConsole->UpdateAllViews (pDataObject, 0, HINT_PASTE_COOKIE);
                }
            }
        }

        if ( pCertStore )
        {
            pCertStore->Release ();
            pCertStore = 0;
        }
    }

    _TRACE (-1, L"Leaving CCertMgrComponent::OnNotifyPaste: 0x%x\n", hr);
    return hr;
}

HRESULT CCertMgrComponent::PasteCookie (
        CCertMgrCookie* pPastedCookie,
        CCertMgrCookie* pTargetCookie,
        CCertStore& rCertStore,
        SPECIAL_STORE_TYPE storeType,
        bool bContainsCerts,
        bool bContainsCRLs,
        bool bContainsCTLs,
        HSCOPEITEM hScopeItem,
        bool bRequestConfirmation,
        bool bIsMultipleSelect,
        LPDATAOBJECT pDataObject)
{
    _TRACE (1, L"Entering CCertMgrComponent::PasteCookie\n");
    HRESULT hr = S_OK;
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    switch (pPastedCookie->m_objecttype)
    {
    case CERTMGR_CERTIFICATE:
        {
            CCertificate* pCert = reinterpret_cast <CCertificate*>(pPastedCookie);
            ASSERT (pCert);
            if ( pCert )
            {
                DWORD   dwFlags = 0;
                CCertStore* pStore = pCert->GetCertStore ();
                if ( pStore )
                {
                    if ( CERT_SYSTEM_STORE_LOCAL_MACHINE == QueryComponentDataRef ().m_dwLocationPersist )
                        dwFlags = CRYPT_FIND_MACHINE_KEYSET_FLAG;
                    bool bDeletePrivateKey = DeletePrivateKey (rCertStore, *pStore);
                    if ( bRequestConfirmation &&
                            pCert->GetStoreType () == MY_STORE &&
                            bDeletePrivateKey &&
                            ::CryptFindCertificateKeyProvInfo (
                                pCert->GetCertContext (), dwFlags, 0) )
                    {
                        CString text;
                        CString caption;
                        int     iRetVal = IDNO;

                        if ( bIsMultipleSelect )
                            VERIFY (text.LoadString (IDS_WARNING_MULTI_CERT_COPY_W_PRIVATE_KEY_MULTI));
                        else
                            VERIFY (text.LoadString (IDS_WARNING_CERT_COPY_W_PRIVATE_KEY));
                        VERIFY (caption.LoadString (IDS_CERTIFICATE_COPY));
                        hr = m_pConsole->MessageBox (text, caption,
                                MB_ICONWARNING | MB_YESNO, &iRetVal);
                        ASSERT (SUCCEEDED (hr));
                        if ( iRetVal == IDNO )
                            return E_FAIL;
                    }

                    hr = CopyPastedCert (pCert, rCertStore, storeType, bDeletePrivateKey, 
                            pTargetCookie, pDataObject);
                    if ( SUCCEEDED (hr) && S_FALSE != hr )
                    {
                        hr = pTargetCookie->Commit ();
                        if ( SUCCEEDED (hr) )
                        {
                            if ( !bContainsCerts )
                                hr = QueryComponentDataRef ().CreateContainers (
                                        hScopeItem, rCertStore);
                        }
                    }
                }
            }
            else
                hr = E_POINTER;
        }
        break;

    case CERTMGR_CRL:
        {
            CCRL* pCRL = reinterpret_cast <CCRL*>(pPastedCookie);
            ASSERT (pCRL);
            if ( pCRL )
            {
                hr = CopyPastedCRL (pCRL, rCertStore);
                if ( SUCCEEDED (hr) )
                {
                    pTargetCookie->Commit ();
                    if ( !bContainsCRLs )
                        hr = QueryComponentDataRef ().CreateContainers (hScopeItem,
                                rCertStore);
                }
            }
            else
                hr = E_POINTER;
        }
        break;

    case CERTMGR_CTL:
        {
            CCTL* pCTL = reinterpret_cast <CCTL*>(pPastedCookie);
            ASSERT (pCTL);
            if ( pCTL )
            {
                hr = CopyPastedCTL (pCTL, rCertStore);
                if ( SUCCEEDED (hr) )
                {
                    pTargetCookie->Commit ();
                    if ( !bContainsCTLs )
                        hr = QueryComponentDataRef ().CreateContainers (hScopeItem,
                                rCertStore);
                }
            }
            else
                hr = E_POINTER;
        }
        break;

    case CERTMGR_AUTO_CERT_REQUEST:
        {
            CAutoCertRequest* pAutoCert = reinterpret_cast <CAutoCertRequest*>(pPastedCookie);
            ASSERT (pAutoCert);
            if ( pAutoCert )
            {
                hr = CopyPastedCTL (pAutoCert, rCertStore);
                if ( SUCCEEDED (hr) )
                {
                    pTargetCookie->Commit ();
                    if ( !bContainsCTLs )
                        hr = QueryComponentDataRef ().CreateContainers (hScopeItem,
                                rCertStore);
                }
            }
            else
                hr = E_POINTER;
        }
        break;

    default:
        break;
    }

    _TRACE (-1, L"Leaving CCertMgrComponent::PasteCookie: 0x%x\n", hr);
    return hr;
}

HRESULT CCertMgrComponent::OnNotifyQueryPaste(
        LPDATAOBJECT pDataObject, 
        LPARAM arg, 
        LPARAM /*param*/)
{
    _TRACE (1, L"Entering CCertMgrComponent::OnNotifyQueryPaste\n");
    ASSERT (pDataObject && arg);
    if ( !pDataObject || !arg )
        return E_POINTER;

    HRESULT hr = S_FALSE;
    CCertMgrComponentData& dataRef = QueryComponentDataRef ();

    // NTRAID# 456366 SAFER RSOP:  Dragging certificates into "Additional 
    // Rules" should be prevented in RSOP mode.
    if ( dataRef.m_bIsRSOP )  // no paste allowed if RSOP
        return hr;

    CCertMgrCookie* pTargetCookie = dataRef.ConvertCookie (pDataObject);
    ASSERT (pTargetCookie);
    if ( pTargetCookie )
    {
        CCertMgrCookie* pPastedCookie =
                dataRef.ConvertCookie ((LPDATAOBJECT) arg);
        if ( pPastedCookie )
        {
            // If this is multi-selection, get the first selected object
            // and substitute it for the pasted cookie.
            if ( ((CCertMgrCookie*) MMC_MULTI_SELECT_COOKIE) == pPastedCookie )
            {
                LPDATAOBJECT    pMSDO = (LPDATAOBJECT) arg;
                if ( pMSDO )
                {
                    CCertMgrDataObject* pDO = reinterpret_cast <CCertMgrDataObject*>(pMSDO);
                    ASSERT (pDO);
                    if ( pDO )
                    {
                        pDO->Reset();
                        if (pDO->Next(1, reinterpret_cast<MMC_COOKIE*>(&pPastedCookie), NULL) == S_FALSE)
                        {
                            return E_UNEXPECTED;
                        }
                    }
                    else
                        return E_UNEXPECTED;
                }
                else
                    return E_UNEXPECTED;

            }

            switch (pPastedCookie->m_objecttype)
            {
            case CERTMGR_CERTIFICATE:
                switch (pTargetCookie->m_objecttype)
                {
                case CERTMGR_PHYS_STORE:
                case CERTMGR_LOG_STORE:
                    {
                        CCertStore* pTargetStore = reinterpret_cast <CCertStore*> (pTargetCookie);
                        if ( pTargetStore )
                        {
                            CCertStore* pSourceStore = 
                                    reinterpret_cast <CCertificate*> (pPastedCookie)->GetCertStore ();
                            
                            if ( pSourceStore )
                            {
                                if ( pTargetStore->IsReadOnly () )
                                    hr = S_FALSE;
                                else if ( *pSourceStore == *pTargetStore )
                                    hr = S_FALSE;
                                else
                                    hr = S_OK;
                            }
                            else
                                hr = E_UNEXPECTED;
                        }
                        else
                            hr = E_UNEXPECTED;
                    }
                    break;

                case CERTMGR_CERT_CONTAINER:
                    {
                        CContainerCookie* pContainer = reinterpret_cast <CContainerCookie*> (pTargetCookie);
                        if ( pContainer )
                        {
                            CCertStore* pSourceStore = 
                                    reinterpret_cast <CCertificate*> (pPastedCookie)->GetCertStore ();
                            
                            if ( pSourceStore )
                            {
                                if ( pContainer->GetCertStore ().IsReadOnly () )
                                    hr = S_FALSE;
                                else if ( *pSourceStore == pContainer->GetCertStore () )
                                    hr = S_FALSE;
                                else
                                    hr = S_OK;
                            }
                            else
                                hr = E_UNEXPECTED;
                        }
                        else
                            hr = E_UNEXPECTED;
                    }
                    break;

                case CERTMGR_CERTIFICATE:
                    {
                        CCertificate* pCert = reinterpret_cast <CCertificate*> (pTargetCookie);
                        if ( pCert )
                        {
                            CCertStore* pSourceStore = 
                                    reinterpret_cast <CCertificate*> (pPastedCookie)->GetCertStore ();
                            CCertStore* pTargetStore = pCert->GetCertStore ();
                            
                            if ( pSourceStore && pTargetStore )
                            {
                                if ( pTargetStore->IsReadOnly () )
                                    hr = S_FALSE;
                                else if ( *pSourceStore == *pTargetStore )
                                    hr = S_FALSE;
                                else
                                    hr = S_OK;
                            }
                            else
                                hr = E_UNEXPECTED;
                        }
                        else
                            hr = E_UNEXPECTED;
                    }
                    break;

                case CERTMGR_LOG_STORE_GPE:
                    {
                        CCertStoreGPE* pTargetStore =
                                reinterpret_cast <CCertStoreGPE*> (pTargetCookie);
                        ASSERT (pTargetStore);
                        if ( pTargetStore )
                        {
                            if ( TRUST_STORE == pTargetStore->GetStoreType () )
                                hr = S_FALSE;
                            else
                            {
                                CCertStore* pSourceStore = 
                                        reinterpret_cast <CCertificate*> (pPastedCookie)->GetCertStore ();
                                if ( pSourceStore )
                                {
                                    if ( *pSourceStore == *pTargetStore )
                                        hr = S_FALSE;
                                    else if ( pTargetStore->CanContain (pPastedCookie->m_objecttype) &&
                                            !pTargetStore->IsReadOnly () )
                                        hr = S_OK;
                                    else
                                        hr = S_OK;
                                }
                                else
                                    hr = E_UNEXPECTED;
                            }
                        }
                        else
                            hr = E_UNEXPECTED;
                    }
                    break;

                case CERTMGR_LOG_STORE_RSOP:
                    {
                        CCertStoreRSOP* pTargetStore =
                                reinterpret_cast <CCertStoreRSOP*> (pTargetCookie);
                        ASSERT (pTargetStore);
                        if ( pTargetStore )
                        {
                            CCertStore* pSourceStore = 
                                    reinterpret_cast <CCertificate*> (pPastedCookie)->GetCertStore ();
                            if ( pSourceStore )
                            {
                                if ( *pSourceStore == *pTargetStore )
                                    hr = S_FALSE;
                                else if ( pTargetStore->CanContain (pPastedCookie->m_objecttype) &&
                                        !pTargetStore->IsReadOnly () )
                                    hr = S_OK;
                                else
                                    hr = S_OK;
                            }
                            else
                                hr = E_UNEXPECTED;
                        }
                        else
                            hr = E_UNEXPECTED;
                    }
                    break;

                case CERTMGR_SAFER_COMPUTER_ENTRIES:
                case CERTMGR_SAFER_USER_ENTRIES:
                    hr = S_OK;
                    break;

                default:
                    break;
                }
                break;

            case CERTMGR_CRL:
                switch (pTargetCookie->m_objecttype)
                {
                case CERTMGR_PHYS_STORE:
                case CERTMGR_LOG_STORE:
                    {
                        CCertStore* pTargetStore = reinterpret_cast <CCertStore*> (pTargetCookie);
                        if ( pTargetStore )
                        {
                            CCertStore& rSourceStore = 
                                    reinterpret_cast <CCRL*> (pPastedCookie)->GetCertStore ();
                            if ( pTargetStore->IsReadOnly () )
                                hr = S_FALSE;
                            else if ( rSourceStore == *pTargetStore )
                                hr = S_FALSE;
                            else
                                hr = S_OK;
                        }
                        else
                            hr = E_UNEXPECTED;
                    }
                    break;

                case CERTMGR_CRL_CONTAINER:
                    {
                        CContainerCookie* pContainer = reinterpret_cast <CContainerCookie*> (pTargetCookie);
                        if ( pContainer )
                        {
                            CCertStore& rSourceStore = 
                                    reinterpret_cast <CCRL*> (pPastedCookie)->GetCertStore ();
                            
                            if ( pContainer->GetCertStore ().IsReadOnly () )
                                hr = S_FALSE;
                            else if ( rSourceStore == pContainer->GetCertStore () )
                                hr = S_FALSE;
                            else
                                hr = S_OK;
                        }
                        else
                            hr = E_UNEXPECTED;
                    }
                    break;

                case CERTMGR_CRL:
                    {
                        CCRL* pCRL = reinterpret_cast <CCRL*> (pTargetCookie);
                        if ( pCRL )
                        {
                            CCertStore* pSourceStore = 
                                    reinterpret_cast <CCertificate*> (pPastedCookie)->GetCertStore ();
                            CCertStore& rTargetStore = pCRL->GetCertStore ();

                            if ( pSourceStore )
                            {
                                if ( rTargetStore.IsReadOnly () )
                                    hr = S_FALSE;
                                else if ( *pSourceStore == rTargetStore )
                                    hr = S_FALSE;
                                else
                                    hr = S_OK;
                            }
                            else
                                hr = E_UNEXPECTED;
                        }
                        else
                            hr = E_UNEXPECTED;
                    }
                    break;

                default:
                    break;
                }
                break;

            case CERTMGR_CTL:
                switch (pTargetCookie->m_objecttype)
                {
                case CERTMGR_PHYS_STORE:
                case CERTMGR_LOG_STORE:
                    {
                        CCertStore* pTargetStore = reinterpret_cast <CCertStore*> (pTargetCookie);
                        if ( pTargetStore )
                        {
                            CCertStore& rSourceStore = 
                                    reinterpret_cast <CCTL*> (pPastedCookie)->GetCertStore ();
                            if ( pTargetStore->IsReadOnly () )
                                hr = S_FALSE;
                            else if ( rSourceStore == *pTargetStore )
                                hr = S_FALSE;
                            else
                                hr = S_OK;
                        }
                        else
                            hr = E_UNEXPECTED;
                    }
                    break;

                case CERTMGR_CTL_CONTAINER:
                    {
                        CContainerCookie* pContainer = reinterpret_cast <CContainerCookie*> (pTargetCookie);
                        if ( pContainer )
                        {
                            CCertStore& rSourceStore = 
                                    reinterpret_cast <CCTL*> (pPastedCookie)->GetCertStore ();
                            
                            if ( pContainer->GetCertStore ().IsReadOnly () )
                                hr = S_FALSE;
                            else if ( rSourceStore == pContainer->GetCertStore () )
                                hr = S_FALSE;
                            else
                                hr = S_OK;
                        }
                        else
                            hr = E_UNEXPECTED;
                    }
                    break;

                case CERTMGR_CTL:
                    {
                        CCTL* pCTL = reinterpret_cast <CCTL*> (pTargetCookie);
                        if ( pCTL )
                        {
                            CCertStore* pSourceStore = 
                                    reinterpret_cast <CCertificate*> (pPastedCookie)->GetCertStore ();
                            CCertStore& rTargetStore = pCTL->GetCertStore ();
                            
                            if ( pSourceStore )
                            {
                                if ( rTargetStore.IsReadOnly () )
                                    hr = S_FALSE;
                                else if ( *pSourceStore == rTargetStore )
                                    hr = S_FALSE;
                                else
                                    hr = S_OK;
                            }
                            else
                                hr = E_UNEXPECTED;
                        }
                        else
                            hr = E_UNEXPECTED;
                    }
                    break;

                case CERTMGR_LOG_STORE_GPE:
                case CERTMGR_LOG_STORE_RSOP:
                    {
                        CCertStore* pTargetStore =
                                reinterpret_cast <CCertStore*> (pTargetCookie);
                        ASSERT (pTargetStore);
                        if ( pTargetStore )
                        {
                            CCertStore& rSourceStore = 
                                    reinterpret_cast <CCTL*> (pPastedCookie)->GetCertStore ();
                            if ( rSourceStore == *pTargetStore )
                                hr = S_FALSE;
                            else if ( pTargetStore->CanContain (pPastedCookie->m_objecttype) &&
                                    !pTargetStore->IsReadOnly () )
                                hr = S_OK;
                            else
                                hr = S_OK;
                        }
                        else
                            hr = E_UNEXPECTED;
                    }
                    break;

                default:
                    break;
                }
                break;

            case CERTMGR_AUTO_CERT_REQUEST:
                switch (pTargetCookie->m_objecttype)
                {
                case CERTMGR_LOG_STORE_GPE:
                case CERTMGR_LOG_STORE_RSOP:
                    {
                        CCertStore* pTargetStore =
                                reinterpret_cast <CCertStore*> (pTargetCookie);
                        ASSERT (pTargetStore);
                        if ( pTargetStore )
                        {
                            if ( ACRS_STORE == pTargetStore->GetStoreType ()  &&
                                    !pTargetStore->IsReadOnly ())
                                hr = S_OK;
                        }
                        else
                            hr = E_UNEXPECTED;
                    }
                    break;

                default:
                    break;
                }
                break;

            case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
            case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
                ASSERT (0);
                break;

            default:
                break;
            }
        }
    }


    _TRACE (-1, L"Leaving CCertMgrComponent::OnNotifyQueryPaste: 0x%x\n", hr);
    return hr;
}

HRESULT CCertMgrComponent::CopyPastedCert(
        CCertificate * pCert, 
        CCertStore& rCertStore, 
        const SPECIAL_STORE_TYPE /*storeType*/, 
        bool bDeletePrivateKey,
        CCertMgrCookie* pTargetCookie,
        LPDATAOBJECT pDataObject)
{
    _TRACE (1, L"Entering CCertMgrComponent::CopyPastedCert\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    HRESULT hr = S_OK;

    ASSERT (pCert);
    if ( pCert )
    {
        PCCERT_CONTEXT  pCertContext = pCert->GetCertContext ();
        ASSERT (pCertContext);
        if ( pCertContext )
        {
            bool bCertWasReplaced = false;

            hr = rCertStore.AddCertificateContext (pCertContext,
                    m_pConsole, bDeletePrivateKey, 0, &bCertWasReplaced);
            if ( FAILED (hr) && S_FALSE != hr )
            {
                if ( HRESULT_FROM_WIN32 (CRYPT_E_EXISTS) != hr )
                {
                    CString text;
                    CString caption;
                    int     iRetVal = 0;
                    if ( E_INVALIDARG == hr && !rCertStore.GetStoreHandle () )
                    {
                        text.FormatMessage (IDS_CERT_CANNOT_BE_PASTED_CANT_OPEN_STORE, 
                                rCertStore.GetLocalizedName ());
                    }
                    else
                    {
                        text.FormatMessage (IDS_CERT_CANNOT_BE_PASTED, 
                                rCertStore.GetLocalizedName (), 
                                GetSystemMessage (hr));
                    }
                    VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
                    m_pConsole->MessageBox (text, caption,
                            MB_OK, &iRetVal);
                }
            }
            else
            {
                if ( CERTMGR_CERT_CONTAINER == pTargetCookie->m_objecttype )
                {
                    CContainerCookie* pContainerCookie = dynamic_cast <CContainerCookie*> (pTargetCookie);
                    if ( pContainerCookie )
                    {
                        if ( pContainerCookie->IsSelected () )
                        {
                            if ( !bCertWasReplaced )
                            {
                                // Add certificate to result pane
                                RESULTDATAITEM          rdItem;
                                CCookie&                rootCookie = 
                                        QueryComponentDataRef ().QueryBaseRootCookie ();

                                // security review 2/26/2002 BryanWal ok
                                ::ZeroMemory (&rdItem, sizeof (rdItem));
                                rdItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM | RDI_STATE;
                                rdItem.nImage = iIconCertificate;
                                rdItem.nCol = 0;
                                rdItem.nState = LVIS_SELECTED | LVIS_FOCUSED;
                                rdItem.str = MMC_TEXTCALLBACK;

                                CCertificate* pNewCert = new CCertificate (
                                        ::CertDuplicateCertificateContext (pCertContext),
                                        &rCertStore);
                                if ( pNewCert )
                                {
                                    rootCookie.m_listResultCookieBlocks.AddHead (pNewCert);
                                    rdItem.lParam = (LPARAM) pNewCert;
                                    pCert->m_resultDataID = m_pResultData;
                                    hr = m_pResultData->InsertItem (&rdItem);
                                    if ( FAILED (hr) )
                                    {
                                         _TRACE (0, L"IResultData::InsertItem () failed: 0x%x\n", hr);
                                    }
                                    else
                                    {
                                         hr = DisplayCertificateCountByStore (m_pConsole, 
                                                &rCertStore, false);
                                    }
                                }
                                else
                                    hr = E_OUTOFMEMORY;
                                ASSERT (SUCCEEDED (hr));
                            }
                            else
                            {
                                // Cert was replaced. Since a deletion needs to
                                // be performed, it's easier just to refresh 
                                // the pane
                                hr = m_pConsole->UpdateAllViews (pDataObject, 0, 0);
                            }
                        }
                    }
                }
            }
        }
        else
            hr = E_UNEXPECTED;
    }
    else
        hr = E_POINTER;

    _TRACE (-1, L"Leaving CCertMgrComponent::CopyPastedCert: 0x%x\n", hr);
    return hr;
}



HRESULT CCertMgrComponent::CopyPastedCTL(CCTL * pCTL, CCertStore& rCertStore)
{
    _TRACE (1, L"Entering CCertMgrComponent::CopyPastedCTL\n");
    HRESULT hr = S_OK;

    ASSERT (pCTL);
    if ( pCTL )
    {
        PCCTL_CONTEXT   pCTLContext = pCTL->GetCTLContext ();
        ASSERT (pCTLContext);
        if ( pCTLContext )
        {
            bool    bResult = rCertStore.AddCTLContext (pCTLContext);
            if ( !bResult )
            {
                DWORD   dwErr = GetLastError ();
                if ( CRYPT_E_EXISTS == dwErr )
                {
                    CString text;
                    CString caption;
                    int     iRetVal = 0;


                    VERIFY (text.LoadString (IDS_DUPLICATE_CTL));
                    VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
                    hr = m_pConsole->MessageBox (text, caption,
                            MB_OK, &iRetVal);
                    ASSERT (SUCCEEDED (hr));
                    hr = E_FAIL;
                }
                else
                {
                    ASSERT (0);
                    hr = HRESULT_FROM_WIN32 (dwErr);
                }
            }
        }
        else
            hr = E_UNEXPECTED;
    }
    else
        hr = E_POINTER;

    _TRACE (-1, L"Leaving CCertMgrComponent::CopyPastedCTL: 0x%x\n", hr);
    return hr;
}


HRESULT CCertMgrComponent::CopyPastedCRL(CCRL * pCRL, CCertStore& rCertStore)
{
    _TRACE (1, L"Entering CCertMgrComponent::CopyPastedCRL\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    HRESULT hr = S_OK;

    ASSERT (pCRL);
    if ( pCRL )
    {
        PCCRL_CONTEXT   pCRLContext = pCRL->GetCRLContext ();
        ASSERT (pCRLContext);
        if ( pCRLContext )
        {
            bool    bResult = rCertStore.AddCRLContext (pCRLContext);
            if ( !bResult )
            {
                DWORD   dwErr = GetLastError ();
                if ( CRYPT_E_EXISTS == dwErr )
                {
                    CString text;
                    CString caption;
                    int     iRetVal = 0;


                    VERIFY (text.LoadString (IDS_DUPLICATE_CRL));
                    VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
                    hr = m_pConsole->MessageBox (text, caption,
                            MB_OK, &iRetVal);
                    ASSERT (SUCCEEDED (hr));
                    hr = E_FAIL;
                }
                else
                {
                    ASSERT (0);
                    hr = HRESULT_FROM_WIN32 (dwErr);
                }
            }
        }
        else
            hr = E_UNEXPECTED;
    }
    else
        hr = E_POINTER;

    _TRACE (-1, L"Leaving CCertMgrComponent::CopyPastedCRL: 0x%x\n", hr);
    return hr;
}


STDMETHODIMP CCertMgrComponent::GetResultViewType(MMC_COOKIE cookie,
        BSTR* ppViewType,
        long* pViewOptions) 
{
    _TRACE (1, L"Entering CCertMgrComponent::GetResultViewType\n");
    HRESULT                 hr = S_FALSE;
    CCertMgrComponentData&  dataRef = QueryComponentDataRef ();
    CCertMgrCookie*         pScopeCookie = reinterpret_cast <CCertMgrCookie*> (cookie);
    if ( pScopeCookie )
    {
        switch (pScopeCookie->m_objecttype)
        {
        case CERTMGR_CERT_CONTAINER:
        case CERTMGR_CTL_CONTAINER:
        case CERTMGR_CRL_CONTAINER:
        case CERTMGR_USAGE:
        case CERTMGR_SAFER_COMPUTER_ENTRIES:
        case CERTMGR_SAFER_USER_ENTRIES:
            if ( !dataRef.m_bIsRSOP )
                *pViewOptions |= MMC_VIEW_OPTIONS_MULTISELECT;
            *ppViewType = NULL;
            break;

        case CERTMGR_LOG_STORE_GPE:
        case CERTMGR_LOG_STORE_RSOP:
            {
                CCertStore* pStore = reinterpret_cast <CCertStore*> (pScopeCookie);
                if ( pStore && 
                        EFS_STORE == pStore->GetStoreType () 
                        && pStore->IsNullEFSPolicy () )
                {
                    *pViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS;

                    LPOLESTR psz = NULL;
                    StringFromCLSID(CLSID_MessageView, &psz);

                    USES_CONVERSION;

                    if (psz != NULL)
                    {
                        *ppViewType = psz;
                        hr = S_OK;
                    }
                }
                else
                {
                    if ( !dataRef.m_bIsRSOP )
                        *pViewOptions |= MMC_VIEW_OPTIONS_MULTISELECT;
                    *ppViewType = NULL;
                }
            }
            break;

        case CERTMGR_SAFER_COMPUTER_ROOT:
        case CERTMGR_SAFER_USER_ROOT:
            {
                CSaferRootCookie* pSaferRootCookie = dynamic_cast <CSaferRootCookie*> (pScopeCookie);
                if ( pSaferRootCookie )
                {
                    if ( pSaferRootCookie->m_bCreateSaferNodes )
                    {
                        *ppViewType = NULL;
                    }
                    else
                    {
                        *pViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS;

                        LPOLESTR psz = NULL;
                        StringFromCLSID(CLSID_MessageView, &psz);

                        USES_CONVERSION;

                        if (psz != NULL)
                        {
                            *ppViewType = psz;
                            hr = S_OK;
                        }
                    }
                }
            }
            break;

        default:
            *ppViewType = NULL;
            break;
        }
    }

    _TRACE (-1, L"Leaving CCertMgrComponent::GetResultViewType: 0x%x\n", hr);
     return hr;
}


STDMETHODIMP CCertMgrComponent::Initialize(LPCONSOLE lpConsole)
{
    _TRACE (1, L"Entering CCertMgrComponent::Initialize\n");
    HRESULT  hr = CComponent::Initialize (lpConsole);
    if ( SUCCEEDED (hr) )
    {
        ASSERT (m_pHeader);
        CCertMgrComponentData& dataRef = QueryComponentDataRef ();
        dataRef.m_pHeader = m_pHeader;

        SetComponentDataConsolePointer (m_pConsole);
    }

    _TRACE (-1, L"Leaving CCertMgrComponent::Initialize: 0x%x\n", hr);
    return hr;
}


HRESULT CCertMgrComponent::LoadColumnsFromArrays (INT objecttype )
{
    _TRACE (1, L"Entering CCertMgrComponent::LoadColumnsFromArrays\n");
     ASSERT (m_pHeader);

    CString str;
    for ( INT i = 0; 0 != m_Columns[objecttype][i]; i++)
    {
        VERIFY(str.LoadString (m_Columns[objecttype][i]));
        m_pHeader->InsertColumn(i, const_cast<LPWSTR>((LPCWSTR)str), LVCFMT_LEFT,
            m_ColumnWidths[objecttype][i]);
    }

    _TRACE (-1, L"Leaving CCertMgrComponent::LoadColumnsFromArrays: S_OK\n");
    return S_OK;
}

HRESULT CCertMgrComponent::SaveWidths(CCertMgrCookie * pCookie)
{
    _TRACE (1, L"Entering CCertMgrComponent::SaveWidths\n");
    HRESULT hr = S_OK;

    m_fDirty = TRUE;

    ASSERT (pCookie);
    if ( pCookie )
    {
        switch (m_pViewedCookie->m_objecttype)
        {
        case CERTMGR_SNAPIN:
        case CERTMGR_USAGE:
        case CERTMGR_PHYS_STORE:
        case CERTMGR_LOG_STORE:
        case CERTMGR_CRL_CONTAINER:
        case CERTMGR_CTL_CONTAINER:
        case CERTMGR_CERT_CONTAINER:
        case CERTMGR_LOG_STORE_GPE:
        case CERTMGR_LOG_STORE_RSOP:
        case CERTMGR_CERT_POLICIES_USER:
        case CERTMGR_CERT_POLICIES_COMPUTER:
        case CERTMGR_SAFER_COMPUTER_ROOT:
        case CERTMGR_SAFER_USER_ROOT:
        case CERTMGR_SAFER_COMPUTER_LEVELS:
        case CERTMGR_SAFER_USER_LEVELS:
        case CERTMGR_SAFER_COMPUTER_ENTRIES:
        case CERTMGR_SAFER_USER_ENTRIES:
            {
                const UINT* pColumns = m_Columns[m_pViewedCookie->m_objecttype];
                ASSERT(pColumns);
                int    nWidth = 0;

                for (UINT iIndex = 0; iIndex < pColumns[iIndex]; iIndex++)
                {
                    hr = m_pHeader->GetColumnWidth ((int) iIndex, &nWidth);
                    if ( SUCCEEDED (hr) )
                    {
                        m_ColumnWidths[m_pViewedCookie->m_objecttype][iIndex] =
                                (UINT) nWidth;
                    }
                    else
                        break;
                }
            }
            break;

        case CERTMGR_CERTIFICATE:
        case CERTMGR_CRL:
        case CERTMGR_CTL:
        case CERTMGR_AUTO_CERT_REQUEST:
        case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
        case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
        case CERTMGR_SAFER_COMPUTER_LEVEL:
        case CERTMGR_SAFER_USER_LEVEL:
        case CERTMGR_SAFER_COMPUTER_ENTRY:
        case CERTMGR_SAFER_USER_ENTRY:
        default:
            ASSERT (0);
            break;
        }
    }
    else
        hr = E_POINTER;

    _TRACE (-1, L"Leaving CCertMgrComponent::SaveWidths: 0x%x\n", hr);
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
#define _dwMagicword    10001  // Internal version number
STDMETHODIMP CCertMgrComponent::Load(IStream __RPC_FAR *pIStream)
{
    _TRACE (1, L"Entering CCertMgrComponent::Load\n");
    HRESULT hr = S_OK;

#ifndef DONT_PERSIST
    ASSERT (pIStream);
    XSafeInterfacePtr<IStream> pIStreamSafePtr( pIStream );

    // Read the magic word from the stream
    DWORD dwMagicword = 0;
    hr = pIStream->Read (&dwMagicword, sizeof(dwMagicword), NULL);
    if ( FAILED(hr) )
    {
        ASSERT( FALSE );
        return hr;
    }
    if (dwMagicword != _dwMagicword)
    {
        // We have a version mismatch
        _TRACE (0, L"INFO: CCertMgrComponentData::Load() - Wrong Magicword.  You need to re-save your .msc file.\n");
        return S_OK;
    }

    int numCols = 0;

    for (int iIndex = 0; iIndex < CERTMGR_NUMTYPES && SUCCEEDED (hr); iIndex++)
    {
        switch (iIndex)
        {
        case CERTMGR_USAGE:
        case CERTMGR_CERT_CONTAINER:
            numCols = CERT_NUM_COLS;
            break;

        case CERTMGR_CRL_CONTAINER:
            numCols = CRL_NUM_COLS;
            break;

        case CERTMGR_CTL_CONTAINER:
            numCols = CTL_NUM_COLS;
            break;

        case CERTMGR_SNAPIN:
        case CERTMGR_PHYS_STORE:
        case CERTMGR_LOG_STORE:
        case CERTMGR_LOG_STORE_GPE:
        case CERTMGR_LOG_STORE_RSOP:
        case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
        case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
        case CERTMGR_SAFER_COMPUTER_ROOT:
        case CERTMGR_SAFER_USER_ROOT:
        case CERTMGR_SAFER_COMPUTER_TRUSTED_PUBLISHERS:
        case CERTMGR_SAFER_USER_TRUSTED_PUBLISHERS:
        case CERTMGR_SAFER_COMPUTER_DEFINED_FILE_TYPES:
        case CERTMGR_SAFER_USER_DEFINED_FILE_TYPES:
        case CERTMGR_SAFER_COMPUTER_ENFORCEMENT:
        case CERTMGR_SAFER_USER_ENFORCEMENT:
            numCols = 1;
            break;

        case CERTMGR_SAFER_COMPUTER_LEVELS:
        case CERTMGR_SAFER_USER_LEVELS:
            numCols = SAFER_LEVELS_NUM_COLS;
            break;

        case CERTMGR_SAFER_COMPUTER_ENTRIES:
        case CERTMGR_SAFER_USER_ENTRIES:
            numCols = SAFER_ENTRIES_NUM_COLS;
            break;

        case CERTMGR_CERTIFICATE:
        case CERTMGR_CRL:
        case CERTMGR_CTL:
        case CERTMGR_AUTO_CERT_REQUEST:
        case CERTMGR_CERT_POLICIES_USER:
        case CERTMGR_CERT_POLICIES_COMPUTER:
        case CERTMGR_SAFER_COMPUTER_LEVEL:
        case CERTMGR_SAFER_USER_LEVEL:
        case CERTMGR_SAFER_COMPUTER_ENTRY:
        case CERTMGR_SAFER_USER_ENTRY:
            continue;

        default:
            ASSERT (0);
            break;
        }

        for (int colNum = 0; colNum < numCols; colNum++)
        {
            hr = pIStream->Read (&(m_ColumnWidths[iIndex][colNum]),
                    sizeof (UINT), NULL);
            ASSERT (SUCCEEDED (hr));
            if ( FAILED(hr) )
            {
                ASSERT (FALSE);
                break;
            }
        }
    }
#endif
    _TRACE (-1, L"Leaving CCertMgrComponent::Load: 0x%x\n", hr);
    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CCertMgrComponent::Save(
        IStream __RPC_FAR *pIStream, 
        BOOL /*fSameAsLoad*/)
{
    _TRACE (1, L"Entering CCertMgrComponent::Save\n");
    HRESULT hr = S_OK;


#ifndef DONT_PERSIST
    ASSERT (pIStream);
    XSafeInterfacePtr<IStream> pIStreamSafePtr (pIStream);

    // Store the magic word to the stream
    DWORD dwMagicword = _dwMagicword;
    hr = pIStream->Write (&dwMagicword, sizeof(dwMagicword), NULL);
    ASSERT (SUCCEEDED (hr));
    if ( FAILED (hr) )
        return hr;


    int numCols = 0;

    for (int iIndex = 0; iIndex < CERTMGR_NUMTYPES && SUCCEEDED (hr); iIndex++)
    {
        switch (iIndex)
        {
        case CERTMGR_USAGE:
        case CERTMGR_CERT_CONTAINER:
            numCols = CERT_NUM_COLS;
            break;

        case CERTMGR_CRL_CONTAINER:
            numCols = CRL_NUM_COLS;
            break;

        case CERTMGR_CTL_CONTAINER:
            numCols = CTL_NUM_COLS;
            break;

        case CERTMGR_SNAPIN:
        case CERTMGR_PHYS_STORE:
        case CERTMGR_LOG_STORE:
        case CERTMGR_LOG_STORE_GPE:
        case CERTMGR_LOG_STORE_RSOP:
        case CERTMGR_CERT_POLICIES_USER:
        case CERTMGR_CERT_POLICIES_COMPUTER:
        case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
        case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
        case CERTMGR_SAFER_COMPUTER_ROOT:
        case CERTMGR_SAFER_USER_ROOT:
        case CERTMGR_SAFER_COMPUTER_TRUSTED_PUBLISHERS:
        case CERTMGR_SAFER_USER_TRUSTED_PUBLISHERS:
        case CERTMGR_SAFER_COMPUTER_DEFINED_FILE_TYPES:
        case CERTMGR_SAFER_USER_DEFINED_FILE_TYPES:
        case CERTMGR_SAFER_COMPUTER_ENFORCEMENT:
        case CERTMGR_SAFER_USER_ENFORCEMENT:
            numCols = 1;
            break;

        case CERTMGR_SAFER_COMPUTER_ENTRIES:
        case CERTMGR_SAFER_USER_ENTRIES:
            numCols = SAFER_ENTRIES_NUM_COLS;
            break;

        case CERTMGR_SAFER_COMPUTER_LEVELS:
        case CERTMGR_SAFER_USER_LEVELS:
            numCols = SAFER_LEVELS_NUM_COLS;
            break;

        case CERTMGR_CERTIFICATE:
        case CERTMGR_CRL:
        case CERTMGR_CTL:
        case CERTMGR_AUTO_CERT_REQUEST:
        case CERTMGR_SAFER_COMPUTER_LEVEL:
        case CERTMGR_SAFER_USER_LEVEL:
        case CERTMGR_SAFER_COMPUTER_ENTRY:
        case CERTMGR_SAFER_USER_ENTRY:
            continue;

        default:
            ASSERT (0);
            break;
        }

        for (int colNum = 0; colNum < numCols; colNum++)
        {
            hr = pIStream->Write (&(m_ColumnWidths[iIndex][colNum]),
                    sizeof (UINT), NULL);
            ASSERT (SUCCEEDED (hr));
            if ( FAILED(hr) )
            {
                ASSERT (FALSE);
                break;
            }
        }
    }
#endif

    _TRACE (-1, L"Leaving CCertMgrComponent::Save: 0x%x\n", hr);
    return S_OK;
}

HRESULT CCertMgrComponent::OnNotifyCutOrMove(LPARAM arg)
{
    _TRACE (1, L"Entering CCertMgrComponent::OnNotifyCutOrMove\n");
    if ( !arg )
        return E_POINTER;

    LPDATAOBJECT pDataObject = reinterpret_cast <IDataObject*> (arg);
    ASSERT (pDataObject);
    if ( !pDataObject )
        return E_UNEXPECTED;


    HRESULT         hr = S_OK;

    CCertMgrCookie* pCookie =
            QueryComponentDataRef ().ConvertCookie (pDataObject);
    if ( pCookie )
    {
        if ( ((CCertMgrCookie*) MMC_MULTI_SELECT_COOKIE) == pCookie )
        {
            CCertMgrDataObject* pDO = reinterpret_cast <CCertMgrDataObject*>(pDataObject);
            ASSERT (pDO);
            if ( pDO )
            {
//                CCertStore& rCertStore = pCookie->GetCertStore ();
                pDO->Reset();
                while (pDO->Next(1, reinterpret_cast<MMC_COOKIE*>(&pCookie), NULL) != S_FALSE)
                {
                    hr = DeleteCookie (pCookie, pDataObject, false, true, false);
                }

//                hr = rCertStore.Commit ();
//              if ( SUCCEEDED (hr) )
//                  rCertStore.Resync ();
            }
            else
                hr = E_FAIL;
        }
        else
        {
            hr = DeleteCookie (pCookie, pDataObject, false, false, true);
        }
        if ( SUCCEEDED (hr) )
            RefreshResultPane ();
    }

    _TRACE (-1, L"Leaving CCertMgrComponent::OnNotifyCutOrMove: 0x%x\n", hr);
    return hr;
}



CCertMgrCookie* CCertMgrComponent::ConvertCookie(LPDATAOBJECT pDataObject)
{
    CCertMgrCookie* pCookie = 0;

    pCookie = QueryComponentDataRef ().ConvertCookie (pDataObject);
    return pCookie;
}

HRESULT CCertMgrComponent::OnOpen (LPDATAOBJECT pDataObject)
{
    _TRACE (1, L"Entering CCertMgrComponent::OnOpen\n");
    HRESULT hr = S_OK;
    ASSERT (pDataObject);
    CCertMgrCookie* pParentCookie = ConvertCookie (pDataObject);
    if ( pParentCookie )
    {
        switch (pParentCookie->m_objecttype)
        {
        case CERTMGR_CERTIFICATE:
            {
                CCertificate*   pCert = reinterpret_cast <CCertificate*> (pParentCookie);
                ASSERT (pCert);
                if ( pCert )
                {
                    hr = LaunchCommonCertDialog (pCert);
                    if ( hr == CRYPT_E_NOT_FOUND )
                        m_pConsole->UpdateAllViews (pDataObject, 0, 0);
                }
                else
                    hr = E_UNEXPECTED;
            }
            break;

        case CERTMGR_CTL:
            {
                CCTL*   pCTL = reinterpret_cast <CCTL*> (pParentCookie);
                ASSERT (pCTL);
                if ( pCTL )
                {
                    hr = LaunchCommonCTLDialog (pCTL);
                    if ( SUCCEEDED (hr) )
                        hr = RefreshResultItem (pParentCookie);
                }
                else
                    hr = E_UNEXPECTED;
            }
            break;

        case CERTMGR_CRL:
            {
                CCRL*   pCRL = reinterpret_cast <CCRL*> (pParentCookie);
                ASSERT (pCRL);
                if ( pCRL )
                {
                    hr = LaunchCommonCRLDialog (pCRL);
                    if ( SUCCEEDED (hr) )
                        hr = RefreshResultItem (pParentCookie);
                }
                else
                    hr = E_UNEXPECTED;
            }
            break;

            break;

        default:
            ASSERT (0);
            break;
        }
    }
    else
        hr = E_UNEXPECTED;

    _TRACE (-1, L"Leaving CCertMgrComponent::OnOpen: 0x%x\n", hr);
    return hr;
}


HRESULT CCertMgrComponent::LaunchCommonCertDialog (CCertificate* pCert)
{
    _TRACE (1, L"Entering CCertMgrComponent::LaunchCommonCertDialog\n");
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    ASSERT (pCert);
    if ( !pCert )
        return E_POINTER;

    HRESULT hr = S_OK;
    if ( pCert->IsCertStillInStore () )
    {
        CWaitCursor waitCursor;
        HWND        hwndParent = 0;
        
        hr = m_pConsole->GetMainWindow (&hwndParent);
        ASSERT (SUCCEEDED (hr));
        CCertMgrComponentData&  dataRef = QueryComponentDataRef ();
        CTypedPtrList<CPtrList, CCertStore*>    storeList;

        //  Add the Root store first on a remote machine.
        if ( !IsLocalComputername (dataRef.GetManagedComputer ()) )
        {
            storeList.AddTail (new CCertStore (CERTMGR_LOG_STORE,
                    CERT_STORE_PROV_SYSTEM,
                    CERT_SYSTEM_STORE_LOCAL_MACHINE,
                    (LPCWSTR) dataRef.GetManagedComputer (),
                    ROOT_SYSTEM_STORE_NAME,
                    ROOT_SYSTEM_STORE_NAME,
                    _T (""), ROOT_STORE,
                    CERT_SYSTEM_STORE_LOCAL_MACHINE,
                    m_pConsole));
        }

        hr = dataRef.EnumerateLogicalStores (&storeList);
        if ( SUCCEEDED (hr) )
        {
              POSITION pos = 0;
              POSITION prevPos = 0;

              // Validate store handles
            for (pos = storeList.GetHeadPosition ();
                    pos;)
            {
                   prevPos = pos;
                CCertStore* pStore = storeList.GetNext (pos);
                ASSERT (pStore);
                if ( pStore )
                {
                    // Do not open the userDS store
                    if ( USERDS_STORE == pStore->GetStoreType () )
                    {
                        storeList.RemoveAt (prevPos);
                        pStore->Release ();
                        pStore = 0;
                    }
                    else
                    {
                        if ( !pStore->GetStoreHandle () )
                        {
                            int      iRetVal = 0;
                            CString caption;
                            CString text;

                            text.FormatMessage (IDS_CANT_OPEN_STORE_AND_FAIL, pStore->GetLocalizedName ());
                            VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
                            hr = E_FAIL;
                            VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption, 
                                  MB_ICONWARNING | MB_OK, &iRetVal)));
                            break;
                        }
                    }
                }
            }

              // Proceed only if all handles are valid 
              if ( SUCCEEDED (hr) )
              {
                 CRYPTUI_VIEWCERTIFICATE_STRUCT vcs;
                 // security review 2/26/2002 BryanWal ok
                 ::ZeroMemory (&vcs, sizeof (vcs));
                 vcs.dwSize = sizeof (vcs);
                 vcs.hwndParent = hwndParent;

                 //  Set these flags only on a remote machine.
                 if ( !IsLocalComputername (dataRef.GetManagedComputer ()) )
                     vcs.dwFlags = CRYPTUI_DONT_OPEN_STORES | CRYPTUI_WARN_UNTRUSTED_ROOT;
                 else
                     vcs.dwFlags = 0;

                 // All dialogs should be read-only under RSOP
                 if ( dataRef.m_bIsRSOP || pCert->IsReadOnly () )
                     vcs.dwFlags |= CRYPTUI_DISABLE_EDITPROPERTIES;

                 // NTRAID # 546105 PKP GrpPol:  Revoked certs that are 
                 // installed into EFS policy do not indicate "revoked" in 
                 // properties.
                 // If this is RSOP or Group Policy and the store is EFS, then 
                 // check revocation
                 if ( (dataRef.m_bIsRSOP || dataRef.m_pGPEInformation) && 
                        pCert->GetCertStore () &&
                        EFS_STORE == pCert->GetCertStore ()->GetStoreType () )
                 {
                     vcs.dwFlags |= CRYPTUI_ENABLE_REVOCATION_CHECKING;
                 }

                 vcs.pCertContext = pCert->GetNewCertContext ();
                 vcs.cStores = (DWORD)storeList.GetCount ();
                 vcs.rghStores = new HCERTSTORE[vcs.cStores];
                 if ( vcs.rghStores )
                 {
                     CCertStore*        pStore = 0;
                     DWORD          index = 0;

                     for (pos = storeList.GetHeadPosition ();
                             pos && index < vcs.cStores;
                             index++)
                     {
                         pStore = storeList.GetNext (pos);
                         ASSERT (pStore);
                         if ( pStore )
                         {
                             vcs.rghStores[index] = pStore->GetStoreHandle ();
                         }
                     }

                     BOOL fPropertiesChanged = FALSE;
                     _TRACE (0, L"Calling CryptUIDlgViewCertificate()\n");
                     CThemeContextActivator activator;
                     BOOL bResult = ::CryptUIDlgViewCertificate (&vcs, &fPropertiesChanged);
                     if ( bResult )
                     {
                         if ( fPropertiesChanged )
                         {
                             pStore = pCert->GetCertStore ();
                             if ( pStore )
                             {
                                 pStore->SetDirty ();
                                 pStore->Commit ();
                                 pStore->Close ();
                                 if ( IDM_USAGE_VIEW == dataRef.m_activeViewPersist )
                                 {
                                     // In case purposes were changed and the cert needs to be removed
                                     RefreshResultPane ();
                                 }
                                 else
                                     RefreshResultItem (pCert);
                             }
                         }
                     }

                     delete vcs.rghStores;
                 }
                 else
                     hr = E_OUTOFMEMORY;
            }

            while (!storeList.IsEmpty () )
            {
                CCertStore* pStore = storeList.RemoveHead ();
                if ( pStore )
                {
                    pStore->Close ();
                    pStore->Release ();
                }
            }
        }
    }
    else
    {
        CString text;
        CString caption;

        VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
        VERIFY (text.LoadString (
                IDS_CANCEL_BECAUSE_CERT_HAS_BEEN_DELETED));
        int     iRetVal = 0;
        VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption,
                MB_OK, &iRetVal)));

        hr = CRYPT_E_NOT_FOUND;
    }

    _TRACE (-1, L"Leaving CCertMgrComponent::LaunchCommonCertDialog: 0x%x\n", hr);
    return hr;
}

HRESULT CCertMgrComponent::RefreshResultItem (CCertMgrCookie* pCookie)
{
    _TRACE (1, L"Entering CCertMgrComponent::RefreshResultItem\n");
    HRESULT hr = S_OK;
    if ( pCookie )
    {
        HRESULTITEM itemID = 0;

        if ( m_pResultData )
        {
            pCookie->Refresh ();
            hr = m_pResultData->FindItemByLParam ( (LPARAM) pCookie, &itemID);
            if ( SUCCEEDED (hr) )
            {
                hr = m_pResultData->UpdateItem (itemID);
                if ( FAILED (hr) )
                {
                    _TRACE (0, L"IResultData::UpdateItem () failed: 0x%x\n", hr);          
                }
            }
            else
            {
                _TRACE (0, L"IResultData::FindItemByLParam () failed: 0x%x\n", hr);          
            }
        }
        else
        {
            _TRACE (0, L"Unexpected error: m_pResultData was NULL\n");
            hr = E_FAIL;
        }
    }
    else
    {
        _TRACE (0, L"Unexpected error: pCookie parameter was NULL\n");
        hr = E_POINTER;
    }

    _TRACE (-1, L"Leaving CCertMgrComponent::RefreshResultItem: 0x%x\n", hr);
    return hr;
}


HRESULT CCertMgrComponent::LaunchCommonCTLDialog (CCTL* pCTL)
{
    _TRACE (1, L"Entering CCertMgrComponent::LaunchCommonCTLDialog\n");
     HRESULT hr = S_OK;
    if ( pCTL )
     {
         CRYPTUI_VIEWCTL_STRUCT vcs;
         HWND                   hwndParent = 0;
         
          hr = m_pConsole->GetMainWindow (&hwndParent);
         if ( FAILED (hr) )
          {
               _TRACE (0, L"IConsole::GetMainWindow () failed: 0x%x\n", hr);
          }
         // security review 2/26/2002 BryanWal ok
         ::ZeroMemory (&vcs, sizeof (vcs));
         vcs.dwSize = sizeof (vcs);
         vcs.hwndParent = hwndParent;
         vcs.dwFlags = 0;

         // All dialogs should be read-only under RSOP
         if ( QueryComponentDataRef ().m_bIsRSOP )
             vcs.dwFlags |= CRYPTUI_DISABLE_EDITPROPERTIES;

         vcs.pCTLContext = pCTL->GetCTLContext ();

         CThemeContextActivator activator;
         VERIFY (::CryptUIDlgViewCTL (&vcs));
     }
     else
          hr = E_POINTER;

    _TRACE (-1, L"Leaving CCertMgrComponent::LaunchCommonCTLDialog: 0x%x\n", hr);
    return hr;
}


HRESULT CCertMgrComponent::LaunchCommonCRLDialog (CCRL* pCRL)
{
    _TRACE (1, L"Entering CCertMgrComponent::LaunchCommonCRLDialog\n");
    ASSERT (pCRL);
    CRYPTUI_VIEWCRL_STRUCT  vcs;
    HWND                    hwndParent;
    HRESULT                 hr = m_pConsole->GetMainWindow (&hwndParent);
    ASSERT (SUCCEEDED (hr));

    // security review 2/26/2002 BryanWal ok
    ::ZeroMemory (&vcs, sizeof (vcs));
    vcs.dwSize = sizeof (vcs);
    vcs.hwndParent = hwndParent;
    vcs.dwFlags = 0;

    // All dialogs should be read-only under RSOP
    if ( QueryComponentDataRef ().m_bIsRSOP )
        vcs.dwFlags |= CRYPTUI_DISABLE_EDITPROPERTIES;

    vcs.pCRLContext = pCRL->GetCRLContext ();

    CThemeContextActivator activator;
    VERIFY (::CryptUIDlgViewCRL (&vcs));

    _TRACE (-1, L"Leaving CCertMgrComponent::LaunchCommonCRLDialog: 0x%x\n", hr);
    return hr;
}




void CCertMgrComponent::CloseAndReleaseUsageStores()
{
    _TRACE (1, L"Entering CCertMgrComponent::CloseAndReleaseUsageStores\n");
    CCertStore* pCertStore = 0;
    while (!m_usageStoreList.IsEmpty () )
    {
        pCertStore = m_usageStoreList.RemoveHead ();
        ASSERT (pCertStore);
        if ( pCertStore )
            pCertStore->Release ();
    }
    _TRACE (-1, L"Leaving CCertMgrComponent::CloseAndReleaseUsageStores\n");
}

bool CCertMgrComponent::DeletePrivateKey(CCertStore& rCertStoreDest, CCertStore& rCertStoreSrc)
{
    _TRACE (1, L"Entering CCertMgrComponent::DeletePrivateKey\n");
    bool bDeletePrivateKey = false;


    // Do not copy the private key if the stores are on different machines or
    // if the destination store is in the GPO.
    if ( rCertStoreDest.m_strMachineName  != rCertStoreSrc.m_strMachineName )
        bDeletePrivateKey = true;
    else if ( !rCertStoreDest.GetLocation () ) // Store is GPO store
        bDeletePrivateKey = true;
    

    _TRACE (-1, L"Leaving CCertMgrComponent::DeletePrivateKey\n");
    return bDeletePrivateKey;
}


/////////////////////////////////////////////////////////////////////
// Virtual function called by CComponent::IComponent::Notify(MMCN_PROPERTY_CHANGE)
// OnPropertyChange() is generated by MMCPropertyChangeNotify( param )
HRESULT CCertMgrComponent::OnPropertyChange (LPARAM param)
{
    _TRACE (1, L"Entering CCertMgrComponent::OnPropertyChange\n");
    HRESULT                 hr = S_OK;
    CCertMgrComponentData&  dataRef = QueryComponentDataRef ();

    // NTRAID# 464886 MMC->certmgr.dlll: AV when use 'New window from here'
    if ( 0 != &dataRef )
        hr = dataRef.OnPropertyChange (param);

    _TRACE (-1, L"Leaving CCertMgrComponent::OnPropertyChange: 0x%x\n", hr);
    return hr;
}


HRESULT CCertMgrComponent::DisplayCertificateCountByUsage(const CString & usageName, int nCertCnt) const
{
    _TRACE (1, L"Entering CCertMgrComponent::DisplayCertificateCountByUsage\n");
     AFX_MANAGE_STATE (AfxGetStaticModuleState ( ));
    ASSERT (!usageName.IsEmpty ());
    ASSERT (nCertCnt >= 0);
     IConsole2* pConsole2 = 0;
     HRESULT        hr = m_pConsole->QueryInterface (
            IID_PPV_ARG (IConsole2, &pConsole2));
     if (SUCCEEDED (hr))
     {
        CString statusText;


          switch (nCertCnt)
          {
               case 0:
                statusText.FormatMessage (IDS_STATUS_NO_CERTS_USAGE, usageName);
                     break;

               case 1:
                statusText.FormatMessage (IDS_STATUS_ONE_CERT_USAGE, usageName);
                     break;

               default:
                WCHAR   wszCertCount[34];

                // security review 2/26/2002 BryanWal ok - buffer increased to 34.
                // 33 is max size for int64 plus null terminator
                AfxFormatString2 (statusText, IDS_STATUS_X_CERTS_USAGE,
                        _itow (nCertCnt, wszCertCount, 10), (LPCWSTR) usageName);
                     break;
          }

          hr = pConsole2->SetStatusText ((LPWSTR)(LPCWSTR) statusText); 

          pConsole2->Release ();
     }

    _TRACE (-1, L"Leaving CCertMgrComponent::DisplayCertificateCountByUsage: 0x%x\n", hr);
    return hr;
}

HRESULT CCertMgrComponent::OnNotifySnapinHelp (LPDATAOBJECT pDataObject)
{
    HRESULT hr = S_OK;

    CComQIPtr<IDisplayHelp,&IID_IDisplayHelp>   spDisplayHelp = m_pConsole;
    if ( !!spDisplayHelp )
    {
        CString strHelpTopic;

        UINT nLen = ::GetSystemWindowsDirectory (strHelpTopic.GetBufferSetLength(2 * MAX_PATH), 2 * MAX_PATH);
        strHelpTopic.ReleaseBuffer();
        if ( nLen )
        {
            /*
            * Help on the stores / purposes should start HTML help with Certficate Manager / Concepts / Understanding Certificate   Manager / Certificate stores.
            topic is CMconcepts.chm::/sag_CMunCertStor.htm
            * Help on the Certificates / CTL / CRL nodes on the scope pane should open Certificate Manager / Concepts /     Understanding Certificate Manager.
            topic is CMconcepts.chm::/sag_CMunderstandWks.htm
            * Help on certificates / CTL / CRL objects on the result pane should open Certificate Manager / Concepts / Using Certificate    Manager.
            topic is CMconcepts.chm::/sag_CMusingWks.htm
            * Help on the Certificate Manager node should launch help with Certificate Manager.
            topic is CMconcepts.chm::/sag_CMtopNode.htm
            */
            CString helpFile;
            CString helpTopic;
            CCertMgrComponentData&  compData = QueryComponentDataRef ();
            CCertMgrCookie* pCookie = compData.ConvertCookie (pDataObject);
            if ( pCookie )
            {
                switch (pCookie->m_objecttype)
                {
                    case CERTMGR_LOG_STORE_GPE:
                    case CERTMGR_LOG_STORE_RSOP:
                        {
                            CCertStore* pStore = dynamic_cast<CCertStore*>(pCookie);
                            if ( pStore && EFS_STORE == pStore->GetStoreType () )
                            {
                                helpFile = EFS_LINKED_HELP_FILE;
                                helpTopic = EFS_HELP_TOPIC;
                            }
                            else
                            {
                                helpFile = PKP_LINKED_HELP_FILE;
                                helpTopic = PKP_HELP_TOPIC;
                            }
                        }
                        break;

                    case CERTMGR_CERT_POLICIES_USER:
                    case CERTMGR_CERT_POLICIES_COMPUTER:
                    case CERTMGR_AUTO_CERT_REQUEST:
                    case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
                    case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
                        helpFile = PKP_LINKED_HELP_FILE;
                        helpTopic = PKP_HELP_TOPIC;
                        break;

                    case CERTMGR_LOG_STORE:
                    case CERTMGR_PHYS_STORE:
                    case CERTMGR_USAGE:
                        helpFile = CM_LINKED_HELP_FILE;
                        helpTopic = CM_HELP_TOPIC;
                        break;

                    case CERTMGR_CRL_CONTAINER:
                    case CERTMGR_CTL_CONTAINER:
                    case CERTMGR_CERT_CONTAINER:
                        helpFile = CM_LINKED_HELP_FILE;
                        helpTopic = CM_HELP_TOPIC;
                        break;

                    case CERTMGR_CERTIFICATE:
                    {
                        CCertificate* pCert = reinterpret_cast <CCertificate*> (pCookie);
                        if ( pCert )
                        {
                            CCertStore* pStore = pCert->GetCertStore ();
                            if ( pStore )
                            {
                                if ( EFS_STORE == pStore->GetStoreType () )
                                {
                                    helpFile = PKP_LINKED_HELP_FILE;
                                    helpTopic = PKP_HELP_TOPIC;
                                }
                                else
                                {
                                    helpFile = CM_LINKED_HELP_FILE;
                                    helpTopic = CM_HELP_TOPIC;
                                }
                            }
                        }
                    }
                    break;

                    case CERTMGR_CRL:
                    {
                        CCRL* pCRL = reinterpret_cast <CCRL*> (pCookie);
                        if ( pCRL )
                        {
                            if ( EFS_STORE == pCRL->GetCertStore ().GetStoreType () )
                            {
                                helpFile = PKP_LINKED_HELP_FILE;
                                helpTopic = PKP_HELP_TOPIC;
                            }
                            else
                            {
                                helpFile = CM_LINKED_HELP_FILE;
                                helpTopic = CM_HELP_TOPIC;
                            }
                        }
                    }
                    break;

                    case CERTMGR_CTL:
                    {
                        CCTL* pCTL = reinterpret_cast <CCTL*> (pCookie);
                        if ( pCTL )
                        {
                            if ( EFS_STORE == pCTL->GetCertStore ().GetStoreType () )
                            {
                                helpFile = PKP_LINKED_HELP_FILE;
                                helpTopic = PKP_HELP_TOPIC;
                            }
                            else
                            {
                                helpFile = CM_LINKED_HELP_FILE;
                                helpTopic = CM_HELP_TOPIC;
                            }
                        }
                    }
                    break;

                    case CERTMGR_SAFER_COMPUTER_ROOT:
                    case CERTMGR_SAFER_USER_ROOT:
                    case CERTMGR_SAFER_COMPUTER_LEVELS:
                    case CERTMGR_SAFER_USER_LEVELS:
                    case CERTMGR_SAFER_COMPUTER_ENTRIES:
                    case CERTMGR_SAFER_USER_ENTRIES:
                    case CERTMGR_SAFER_COMPUTER_LEVEL:
                    case CERTMGR_SAFER_USER_LEVEL:
                    case CERTMGR_SAFER_COMPUTER_ENTRY:
                    case CERTMGR_SAFER_USER_ENTRY:
                    case CERTMGR_SAFER_COMPUTER_TRUSTED_PUBLISHERS:
                    case CERTMGR_SAFER_USER_TRUSTED_PUBLISHERS:
                    case CERTMGR_SAFER_COMPUTER_DEFINED_FILE_TYPES:
                    case CERTMGR_SAFER_USER_DEFINED_FILE_TYPES:
                    case CERTMGR_SAFER_COMPUTER_ENFORCEMENT:
                    case CERTMGR_SAFER_USER_ENFORCEMENT:
                        helpFile = SAFER_WINDOWS_LINKED_HELP_FILE;
                        helpTopic = SAFER_HELP_TOPIC;
                        break;

                    case CERTMGR_SNAPIN:
                    default:
                        helpFile = CM_LINKED_HELP_FILE;
                        helpTopic = CM_HELP_TOPIC;
                        break;
                }
            }   


            strHelpTopic += L"\\help\\";
            strHelpTopic += helpFile;
            strHelpTopic += L"::/";
            strHelpTopic += helpTopic;


            hr = spDisplayHelp->ShowTopic ((LPWSTR)(LPCWSTR) strHelpTopic);
        }
        else
            hr = E_FAIL;
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\certifct.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       certifct.h
//
//  Contents:   
//
//----------------------------------------------------------------------------

#if !defined(AFX_CERTIFCT_H__9D512D04_126D_11D1_B5D3_00C04FB94F17__INCLUDED_)
#define AFX_CERTIFCT_H__9D512D04_126D_11D1_B5D3_00C04FB94F17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "cookie.h"
#include "nodetype.h"

#define MY_ENCODING_TYPE (PKCS_7_ASN_ENCODING | X509_ASN_ENCODING)

/////////////////////////////////////////////////////////////////////////////
// CCertificate

class CCertificate : public CCertMgrCookie
{
public:
	CCertificate(const PCCERT_CONTEXT pCertContext, CCertStore* pCertStore);
	virtual ~CCertificate();


public:
	bool IsCertStillInStore() const;
	CString GetTemplateName();
	bool CanDelete();
	int CompareExpireDate (const CCertificate& cert) const;
	BOOL DeleteFromStore (bool bDoCommit);
	CString FormatStatus();
	CString GetAlternateSubjectName ();
	CString GetAlternateIssuerName ();
	PCCERT_CONTEXT GetCertContext () const;
	CCertStore* GetCertStore () const;
	CString GetDescription ();
	CString GetEnhancedKeyUsage ();
	CString GetFriendlyName ();
	CString GetMD5Hash ();
	CString GetIssuerName ();
	CString GetShortLastModified ();
	CString GetLongLastModified ();
    HRESULT GetLastModifiedFileTime (FILETIME& ft);
	PCCERT_CONTEXT GetNewCertContext ();
	CString GetSerialNumber ();
	CString GetSHAHash ();
	const SPECIAL_STORE_TYPE GetStoreType () const;
	CString GetSubjectName ();
	CString GetValidNotAfter ();
	CString GetValidNotBefore ();
	bool IsArchived();
	bool IsReadOnly ();
	bool IsValid ();
	virtual void Refresh ();
	HRESULT SetDescription (const CString& szDescription);
    HRESULT SetLastModified ();
    BOOL operator==(CCertificate&);
    void SetStore (CCertStore* pStore);

private:
    CString DecodeV1TemplateName (PCERT_EXTENSION pCertExtension);
    CString DecodeV2TemplateName (PCERT_INFO pCertInfo);
    CString OriginalDecodeV2TemplateName (PCERT_EXTENSION pCertExtension);
    HRESULT FormatSerialNoString(LPWSTR *ppString, CRYPT_INTEGER_BLOB const *pblob);
	bool FormatEnhancedKeyUsagePropertyString (CString& string);
	HRESULT ConvertAltNameToString (LPCWSTR szOID, const DWORD dwNameChoice, CString &altName);
    CString CCertificate::GetLastModified(DWORD dwDateFlags, bool bRetryIfNotPresent = true);

private:	// data
	bool                    m_bIsArchived;
	bool                    m_bCanDelete;
	CCertStore*             m_pCertStore;
	CString GetGenericHash (DWORD dwPropId);
	CString                 m_szSHAHash;
	CString                 m_szMD5Hash;
	CString                 m_szFriendlyName;
	CString					m_szEnhancedKeyUsage;
	CString					m_szPolicyURL;
	CString					m_szAuthorityKeyID;
	CString					m_szSubjectKeyID;
	CString					m_szSerNum;
	CString					m_szAltSubjectName;
	CString					m_szAltIssuerName;
	CString					m_szValidNotBefore;
	CString					m_szValidNotAfter;
	CString					m_szSubjectName;
	CString					m_szIssuerName;
	PCERT_INFO				m_pCertInfo;
	PCCERT_CONTEXT			m_pCertContext;
	DWORD					m_fieldChecked;
    CString                 m_szDescription;
    CString                 m_szTemplateName;
};

#endif // !defined(AFX_CERTIFCT_H__9D512D04_126D_11D1_B5D3_00C04FB94F17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\cmutils.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       cmutils.h
//
//  Contents:   
//
//----------------------------------------------------------------------------
#ifndef __CMUTILS_H
#define __CMUTILS_H
#include "cookie.h"

typedef CArray<CCertMgrCookie*, CCertMgrCookie*> CCookiePtrArray;

// Get subject or issuer name from a certificate context
CString GetNameString (PCCERT_CONTEXT pCertContext, DWORD dwFlag);

// Convert win32 error code to a text message and display
void DisplaySystemError (HWND hParent, DWORD dwErr);
CString GetSystemMessage (DWORD dwErr);

// Convert an OID to a displayable name
bool MyGetOIDInfo (CString & string, LPCSTR pszObjId);

// The certificate has File Encryption key usage
bool CertHasEFSKeyUsage (PCCERT_CONTEXT pCertContext);

HRESULT FormatDate (
        FILETIME utcDateTime, 
        CString & pszDateTime, 
        DWORD dwDateFlags = 0,
        bool bGetTime = false);
HRESULT ConvertNameBlobToString(CERT_NAME_BLOB nameBlob, CString & pszName);


bool IsWindowsNT ();

LRESULT RegDelnode (HKEY hKeyRoot, CString pszSubKey);

HRESULT DisplayCertificateCountByStore (LPCONSOLE pConsole, CCertStore* pCertStore, bool bIsGPE = false);

// Help File for F1 and ? help
CString GetF1HelpFilename();

#ifndef szOID_EFS_RECOVERY
#define szOID_EFS_RECOVERY      "1.3.6.1.4.1.311.10.3.4.1"
#endif

#define IID_PPV_ARG(Type, Expr) IID_##Type, \
	reinterpret_cast<void**>(static_cast<Type **>(Expr))

extern LPCWSTR  CM_HELP_TOPIC;
extern LPCWSTR  CM_HELP_FILE;
extern LPCWSTR  CM_LINKED_HELP_FILE;
extern LPCWSTR  PKP_LINKED_HELP_FILE;
extern LPCWSTR  PKP_HELP_FILE;
extern LPCWSTR  PKP_HELP_TOPIC;
extern LPCWSTR  SAFER_WINDOWS_HELP_FILE;
extern LPCWSTR  SAFER_WINDOWS_LINKED_HELP_FILE;
extern LPCWSTR  SAFER_HELP_TOPIC;
extern LPCWSTR  CM_CONTEXT_HELP;
extern LPCWSTR  WINDOWS_HELP;
extern LPCWSTR EFS_LINKED_HELP_FILE;
extern LPCWSTR EFS_HELP_TOPIC;

HRESULT RenewCertificate (
        CCertificate* pCert, 
        bool bNewKey, 
        const CString& machineName, 
        DWORD dwLocation,
        const CString& managedComputer, 
        const CString& managedService, 
        HWND hwndParent, 
        LPCONSOLE pConsole,
        LPDATAOBJECT pDataObject);

int LocaleStrCmp(PCWSTR ptsz1, PCWSTR ptsz2); // calls CompareString () API.

#define	STR_BLOBCOUNT           L"BlobCount"
#define	STR_BLOB                L"Blob"
#define	STR_BLOB0               L"Blob0"
#define	STR_BLOBLENGTH          L"BlobLength"
#define	STR_WQL                 L"WQL"
#define	STR_SELECT_STATEMENT    L"SELECT * FROM RSOP_RegistryPolicySetting"
#define	STR_PROP_VALUENAME      L"valueName"
#define	STR_PROP_REGISTRYKEY    L"registryKey"
#define	STR_PROP_VALUE          L"value"
#define STR_PROP_PRECEDENCE     L"precedence"
#define STR_PROP_GPOID          L"GPOID"
#define	STR_REGKEY_CERTIFICATES L"\\Certificates"
#define	STR_REGKEY_CTLS         L"\\CTLs"
#define	STR_REGKEY_CRLS         L"\\CRLs"

#define DEBUGKEY    L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AdminDebug\\CertMgr"
#define SAFER_CODEID_KEY \
            SAFER_HKLM_REGBASE L"\\" SAFER_CODEIDS_REGSUBKEY

// Registry path to the trusted publisher store
#define CERT_TRUST_PUB_SAFER_GROUP_POLICY_TRUSTED_PUBLISHER_STORE_REGPATH    \
    CERT_GROUP_POLICY_SYSTEM_STORE_REGPATH L"\\TrustedPublisher"

// Registry path to the disallowed store
#define CERT_TRUST_PUB_SAFER_GROUP_POLICY_DISALLOWED_STORE_REGPATH    \
    CERT_GROUP_POLICY_SYSTEM_STORE_REGPATH L"\\Disallowed"

// Registry path to the EFS settings
#define EFS_SETTINGS_REGPATH    L"Software\\Policies\\Microsoft\\Windows NT\\CurrentVersion\\EFS"

// Registry value for EFS settings
#define EFS_SETTINGS_REGVALUE   L"EfsConfiguration"

// Enabling themes
#ifdef UNICODE
#define PROPSHEETPAGE_V3 PROPSHEETPAGEW_V3
#else
#define PROPSHEETPAGE_V3 PROPSHEETPAGEA_V3
#endif

HPROPSHEETPAGE MyCreatePropertySheetPage(AFX_OLDPROPSHEETPAGE* psp);

class CThemeContextActivator
{
public:
    CThemeContextActivator() : m_ulActivationCookie(0)
        { SHActivateContext (&m_ulActivationCookie); }

    ~CThemeContextActivator()
        { SHDeactivateContext (m_ulActivationCookie); }

private:
    ULONG_PTR m_ulActivationCookie;
};

void CheckDomainVersion ();

VOID DataToHex (PBYTE pSrc, CString & dest, int cb, bool bIncludeSpaces = true);

typedef CTypedPtrList<CPtrList, CERT_CONTEXT*>  CERT_CONTEXT_LIST;

BOOL GetCertificateChain (CERT_CONTEXT* pCertContext, CERT_CONTEXT_LIST& certChainList);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\compdata.cpp ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       compdata.cpp
//
//  Contents:   Implementation of CCertMgrComponentData
//
//----------------------------------------------------------------------------

#include "stdafx.h"

USE_HANDLE_MACROS ("CERTMGR (compdata.cpp)")
#include <gpedit.h>
#include "compdata.h"
#include "dataobj.h"
#include "cookie.h"
#include "snapmgr.h"
#include "Certifct.h"
#include "dlgs.h"
#include "SelAcct.h"
#include "FindDlg.h"
#pragma warning(push, 3)
#include <wintrust.h>
#include <cryptui.h>
#include <sceattch.h>
#pragma warning(pop)
#include "selservc.h"
#include "acrgenpg.h"
#include "acrspsht.h"
#include "acrswlcm.h"
#include "acrstype.h"

#include "acrslast.h"
#include "addsheet.h"
#include "gpepage.h"
#include "storegpe.h"
#include "uuids.h"
#include "StoreRSOP.h"
#include "PolicyPrecedencePropertyPage.h"
#include "AutoenrollmentPropertyPage.h"
#include "SaferEntry.h"
#include "SaferUtil.h"
#include "SaferDefinedFileTypesPropertyPage.h"
#include "EFSGeneralPropertyPage.h"


#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#include "stdcdata.cpp" // CComponentData implementation

extern  HINSTANCE   g_hInstance;

extern GUID g_guidExtension;
extern GUID g_guidRegExt;
extern GUID g_guidSnapin;

//
// CCertMgrComponentData
//

extern  CString g_szFileName; // If not empty, was called from command-line.

CCertMgrComponentData::CCertMgrComponentData ()
    : m_pRootCookie (0),
    m_activeViewPersist (IDM_STORE_VIEW),
    m_hRootScopeItem (0),
    m_bShowPhysicalStoresPersist (0),
    m_bShowArchivedCertsPersist (0),
    m_fAllowOverrideMachineName (0),
    m_dwFlagsPersist (0),
    m_dwLocationPersist (0),
    m_pResultData (0),
    m_pGPEInformation (0),
    m_pRSOPInformationComputer (0),
    m_pRSOPInformationUser (0),
    m_bIsUserAdministrator (FALSE),
    m_dwSCEMode (SCE_MODE_UNKNOWN),
    m_pHeader (0),
    m_bMultipleObjectsSelected (false) ,
    m_pCryptUIMMCCallbackStruct (0),
    m_pGPERootStore (0),
    m_pGPETrustStore (0),
    m_pFileBasedStore (0),
    m_pGPEACRSUserStore (0),
    m_pGPEACRSComputerStore (0),
    m_fInvalidComputer (false),
    m_bMachineIsStandAlone (true),
    m_pComponentConsole (0),
    m_bIsRSOP (false),
    m_pIWbemServicesComputer (0),
    m_pIWbemServicesUser (0),
    m_pbstrLanguage (SysAllocString (STR_WQL)),
    m_pbstrQuery (SysAllocString (STR_SELECT_STATEMENT)),
    m_pbstrValueName (SysAllocString (STR_PROP_VALUENAME)),
    m_pbstrRegistryKey (SysAllocString (STR_PROP_REGISTRYKEY)),
    m_pbstrValue (SysAllocString (STR_PROP_VALUE)),
    m_pbstrPrecedence (SysAllocString (STR_PROP_PRECEDENCE)),
    m_pbstrGPOid (SysAllocString (STR_PROP_GPOID)),
    m_dwRSOPFlagsComputer (0),
    m_dwRSOPFlagsUser (0),
    m_dwDefaultSaferLevel (0),
    m_pdwSaferLevels (0),
    m_bSaferSupported (false),
    m_nOpenSaferPageRefCount (0)
{
    _TRACE (1, L"Entering CCertMgrComponentData::CCertMgrComponentData\n");
    m_pRootCookie = new CCertMgrCookie (CERTMGR_SNAPIN);

    // Get name of logged-in user
    DWORD   dwSize = 0;
    BOOL bRet = ::GetUserName (0, &dwSize);
    if ( dwSize > 0 )
    {
        bRet = ::GetUserName (m_szLoggedInUser.GetBufferSetLength (dwSize), &dwSize);
        ASSERT (bRet);
        m_szLoggedInUser.ReleaseBuffer ();
    }

    // Get name of this computer
    dwSize = MAX_COMPUTERNAME_LENGTH + 1 ;
    bRet = ::GetComputerName (m_szThisComputer.GetBufferSetLength (MAX_COMPUTERNAME_LENGTH + 1 ), &dwSize);
    ASSERT (bRet);
    m_szThisComputer.ReleaseBuffer ();

    // Find out if logged-in users is an Administrator
    IsUserAdministrator (m_bIsUserAdministrator);

    if ( !g_szFileName.IsEmpty () )
    {
        m_szFileName = g_szFileName;
        g_szFileName = _T ("");
        m_dwLocationPersist = 0;
    }

    // Find out if we're joined to a domain.
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC    pInfo = 0;
    DWORD dwErr = ::DsRoleGetPrimaryDomainInformation (
            0,
            DsRolePrimaryDomainInfoBasic, 
            (PBYTE*) &pInfo);
    if ( ERROR_SUCCESS == dwErr )
    {
        switch (pInfo->MachineRole)
        {
        case DsRole_RoleStandaloneWorkstation:
        case DsRole_RoleStandaloneServer:
            m_bMachineIsStandAlone = true;
            break;

        case DsRole_RoleMemberWorkstation:
        case DsRole_RoleMemberServer:
        case DsRole_RoleBackupDomainController:
        case DsRole_RolePrimaryDomainController:
            m_bMachineIsStandAlone = false;
            break;

        default:
            break;
        }
    }
    else
    {
        _TRACE (0, L"DsRoleGetPrimaryDomainInformation () failed: 0x%x\n", dwErr);
    }
    NetApiBufferFree (pInfo);

    _TRACE (-1, L"Leaving CCertMgrComponentData::CCertMgrComponentData\n");
}

CCertMgrComponentData::~CCertMgrComponentData ()
{
    _TRACE (1, L"Entering CCertMgrComponentData::~CCertMgrComponentData\n");
    if ( m_pCryptUIMMCCallbackStruct )
    {
        ::MMCFreeNotifyHandle (m_pCryptUIMMCCallbackStruct->lNotifyHandle);
        ((LPDATAOBJECT)(m_pCryptUIMMCCallbackStruct->param))->Release ();
        ::GlobalFree (m_pCryptUIMMCCallbackStruct);
        m_pCryptUIMMCCallbackStruct = 0;
    }

    if ( m_pGPERootStore )
    {
        m_pGPERootStore->Release ();
        m_pGPERootStore = 0;
    }
    if ( m_pGPETrustStore )
    {
        m_pGPETrustStore->Release ();
        m_pGPETrustStore = 0;
    }
    if ( m_pFileBasedStore )
    {
        m_pFileBasedStore->Release ();
        m_pFileBasedStore = 0;
    }

    if ( m_pGPEACRSUserStore )
    {
        m_pGPEACRSUserStore->Release ();
        m_pGPEACRSUserStore = 0;
    }

    if ( m_pGPEACRSComputerStore )
    {
        m_pGPEACRSComputerStore->Release ();
        m_pGPEACRSComputerStore = 0;
    }

    CCookie& rootCookie = QueryBaseRootCookie ();
    while ( !rootCookie.m_listResultCookieBlocks.IsEmpty() )
    {
        (rootCookie.m_listResultCookieBlocks.RemoveHead())->Release();
    }
    if ( m_pGPEInformation )
    {
        m_pGPEInformation->Release ();
        m_pGPEInformation = 0;
    }

    if ( m_pRSOPInformationComputer )
    {
        m_pRSOPInformationComputer->Release ();
        m_pRSOPInformationComputer = 0;
    }
    if ( m_pRSOPInformationUser )
    {
        m_pRSOPInformationUser->Release ();
        m_pRSOPInformationUser = 0;
    }

    if ( m_pResultData )
    {
        m_pResultData->Release ();
        m_pResultData = 0;
    }

    if ( m_pComponentConsole )
    {
        SAFE_RELEASE (m_pComponentConsole);
        m_pComponentConsole = 0;
    }

    if (m_pbstrLanguage)
        SysFreeString (m_pbstrLanguage);

    if (m_pbstrQuery)
        SysFreeString (m_pbstrQuery);

    if (m_pbstrRegistryKey)
        SysFreeString (m_pbstrRegistryKey);

    if (m_pbstrValueName)
        SysFreeString (m_pbstrValueName);

    if (m_pbstrValue)
        SysFreeString (m_pbstrValue);

    if ( m_pbstrPrecedence )
        SysFreeString (m_pbstrPrecedence);

    if ( m_pbstrGPOid )
        SysFreeString (m_pbstrGPOid);

    int     nIndex = 0;
    INT_PTR nUpperBound = m_rsopObjectArrayComputer.GetUpperBound ();

    while ( nUpperBound >= nIndex )
    {
        CRSOPObject* pCurrObject = m_rsopObjectArrayComputer.GetAt (nIndex);
        if ( pCurrObject )
        {
            delete pCurrObject;
        }
        nIndex++;
    }
    m_rsopObjectArrayComputer.RemoveAll ();


    nIndex = 0;
    nUpperBound = m_rsopObjectArrayUser.GetUpperBound ();
    while ( nUpperBound >= nIndex )
    {
        CRSOPObject* pCurrObject = m_rsopObjectArrayUser.GetAt (nIndex);
        if ( pCurrObject )
        {
            delete pCurrObject;
        }
        nIndex++;
    }
    m_rsopObjectArrayUser.RemoveAll ();

    if ( m_pIWbemServicesComputer )
        m_pIWbemServicesComputer->Release ();

    if ( m_pIWbemServicesUser )
        m_pIWbemServicesUser->Release ();

    if ( m_pRootCookie )
        m_pRootCookie->Release ();

    if ( m_pdwSaferLevels )
        delete m_pdwSaferLevels;

    _TRACE (-1, L"Leaving CCertMgrComponentData::~CCertMgrComponentData\n");
}

DEFINE_FORWARDS_MACHINE_NAME ( CCertMgrComponentData, (m_pRootCookie) )

CCookie& CCertMgrComponentData::QueryBaseRootCookie ()
{
    _TRACE (0, L"Entering and leaving CCertMgrComponentData::QueryBaseRootCookie\n");
    ASSERT (m_pRootCookie);
    return (CCookie&) *m_pRootCookie;
}


STDMETHODIMP CCertMgrComponentData::CreateComponent (LPCOMPONENT* ppComponent)
{
    _TRACE (1, L"Entering CCertMgrComponentData::CreateComponent\n");

    ASSERT (ppComponent);

    CComObject<CCertMgrComponent>* pObject = 0;
    CComObject<CCertMgrComponent>::CreateInstance (&pObject);
    ASSERT (pObject);
    pObject->SetComponentDataPtr ( (CCertMgrComponentData*) this);

    HRESULT hr = pObject->QueryInterface (IID_PPV_ARG (IComponent, ppComponent));
    _TRACE (1, L"Entering CCertMgrComponentData::CreateComponent\n");
    return hr;
}

HRESULT CCertMgrComponentData::LoadIcons (LPIMAGELIST pImageList, BOOL /*fLoadLargeIcons*/)
{
    _TRACE (1, L"Entering CCertMgrComponentData::LoadIcons\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());

    // Structure to map a Resource ID to an index of icon
    struct RESID2IICON
    {
        UINT uIconId;   // Icon resource ID
        int iIcon;      // Index of the icon in the image list
    };
    const static RESID2IICON rgzLoadIconList[] =
    {
        // Misc icons
        { IDI_CERTIFICATE, iIconCertificate },
        { IDI_CTL, iIconCTL },
        { IDI_CRL, iIconCRL },
        { IDI_AUTO_CERT_REQUEST, iIconAutoCertRequest },
        { IDI_AUTOENROLL, iIconAutoEnroll },
        { IDI_SAFER_LEVEL, iIconSaferLevel },
        { IDI_DEFAULT_SAFER_LEVEL, iIconDefaultSaferLevel },
        { IDI_SAFER_HASH_ENTRY, iIconSaferHashEntry },
        { IDI_SAFER_URL_ENTRY, iIconSaferURLEntry },
        { IDI_SAFER_NAME_ENTRY, iIconSaferNameEntry },
        { IDI_SETTINGS, iIconSettings },
        { IDI_SAFER_CERT_ENTRY, iIconSaferCertEntry },
        { 0, 0} // Must be last
    };


    for (int i = 0; rgzLoadIconList[i].uIconId != 0; i++)
    {
        HICON hIcon = ::LoadIcon (AfxGetInstanceHandle (),
                MAKEINTRESOURCE (rgzLoadIconList[i].uIconId));
        ASSERT (hIcon && "Icon ID not found in resources");
        /*HRESULT hr =*/ pImageList->ImageListSetIcon ( (PLONG_PTR) hIcon,
                rgzLoadIconList[i].iIcon);
//      ASSERT (SUCCEEDED (hr) && "Unable to add icon to ImageList");
    }

    _TRACE (-1, L"Leaving CCertMgrComponentData::LoadIcons\n");
    return S_OK;
}


HRESULT CCertMgrComponentData::OnNotifyExpand (LPDATAOBJECT pDataObject, BOOL bExpanding, HSCOPEITEM hParent)
{
    _TRACE (1, L"Entering CCertMgrComponentData::OnNotifyExpand\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    CWaitCursor waitCursor;
    ASSERT (pDataObject && hParent && m_pConsoleNameSpace);
    if (!bExpanding)
        return S_OK;

    static bool bDomainVersionChecked = false;

    if ( !bDomainVersionChecked ) 
    {
        if ( !m_bMachineIsStandAlone )  // only check if joined to a domain
            CheckDomainVersion ();
        bDomainVersionChecked = true;
    }

    GUID guidObjectType;
    HRESULT hr = ExtractObjectTypeGUID (pDataObject, &guidObjectType);
    ASSERT (SUCCEEDED (hr));
    if ( IsSecurityConfigurationEditorNodetype (guidObjectType) )
    {
        hr = ExtractData (pDataObject, CCertMgrDataObject::m_CFSCEModeType,
                &m_dwSCEMode, sizeof (DWORD));
        ASSERT (SUCCEEDED (hr));
        if ( SUCCEEDED (hr) )
        {
            switch (m_dwSCEMode)
            {
            case SCE_MODE_DOMAIN_USER:  // User Settings
            case SCE_MODE_OU_USER:
            case SCE_MODE_LOCAL_USER:
            case SCE_MODE_DOMAIN_COMPUTER:  // Computer Settings
            case SCE_MODE_OU_COMPUTER:
            case SCE_MODE_LOCAL_COMPUTER:
                m_bIsRSOP = false;
                if ( !m_pGPEInformation )
                {
                    IUnknown* pIUnknown = 0;

                    hr = ExtractData (pDataObject,
                        CCertMgrDataObject::m_CFSCE_GPTUnknown,
                        &pIUnknown, sizeof (IUnknown*));
                    ASSERT (SUCCEEDED (hr));
                    if ( SUCCEEDED (hr) )
                    {
                        hr = pIUnknown->QueryInterface (
                                IID_PPV_ARG (IGPEInformation, &m_pGPEInformation));
                        ASSERT (SUCCEEDED (hr));
#if DBG
                        if ( SUCCEEDED (hr) )
                        {
                            const int cbLen = 512;
                            WCHAR   szName[cbLen];
                            hr = m_pGPEInformation->GetName (szName, cbLen);
                            if ( SUCCEEDED (hr) )
                            {
                                _TRACE (0, L"IGPEInformation::GetName () returned: %s",
                                        szName);
                            }
                            else
                            {
                                _TRACE (0, L"IGPEInformation::GetName () failed: 0x%x\n", hr);
                            }
                        }
#endif
                        pIUnknown->Release ();
                    }
                }

                if ( SUCCEEDED (hr) )
                {
                    switch (m_dwSCEMode)
                    {
                    case SCE_MODE_DOMAIN_USER:
                    case SCE_MODE_OU_USER:
                    case SCE_MODE_LOCAL_USER:
                        hr = ExpandScopeNodes (NULL, hParent, _T (""),
                            CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY, NODEID_User);
                        break;

                    case SCE_MODE_DOMAIN_COMPUTER:
                    case SCE_MODE_OU_COMPUTER:
                    case SCE_MODE_LOCAL_COMPUTER:
                        hr = ExpandScopeNodes (NULL, hParent, _T (""),
                            CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY, NODEID_Machine);
                        break;

                    default:
                        ASSERT (0);
                        hr = E_FAIL;
                        break;
                    }
                }
                break;

            case SCE_MODE_RSOP_USER:
            case SCE_MODE_RSOP_COMPUTER:
                m_bIsRSOP = true;
                hr = BuildWMIList (pDataObject, SCE_MODE_RSOP_COMPUTER == m_dwSCEMode);
                if ( SUCCEEDED (hr) )
                {
                    switch (m_dwSCEMode)
                    {
                    case SCE_MODE_RSOP_USER:
                        hr = ExpandScopeNodes (NULL, hParent, _T (""),
                            CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY, 
                            NODEID_User);
                        break;

                    case SCE_MODE_RSOP_COMPUTER:
                        hr = ExpandScopeNodes (NULL, hParent, _T (""),
                            CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY, 
                            NODEID_Machine);
                        break;

                    default:
                        ASSERT (0);
                        hr = E_FAIL;
                        break;
                    }
                }
                break;

            default:
                // we are not extending other nodes
                break;
            }
        }

        return hr;
    }

    // Beyond this point we are not dealing with extension node types.
    {
        CCertMgrCookie* pParentCookie = ConvertCookie (pDataObject);
        if ( pParentCookie )
        {
            hr = ExpandScopeNodes (pParentCookie, hParent, _T (""), 0, guidObjectType);
        }
        else
            hr = E_UNEXPECTED;
    }


    _TRACE (-1, L"Leaving CCertMgrComponentData::OnNotifyExpand: 0x%x\n", hr);
    return hr;
}


HRESULT CCertMgrComponentData::OnNotifyRelease (LPDATAOBJECT /*pDataObject*/, HSCOPEITEM hItem)
{
    _TRACE (1, L"Entering CCertMgrComponentData::OnNotifyRelease\n");

    HRESULT hr = DeleteChildren (hItem);

    //
    // In RSoP, we may get called to refresh the scope pane when the query
    // is re-executed -- if this happens, current nodes will be removed and
    // we must reset all of our cached information.  We reset the relevant
    // information below
    //
    if ( hItem && (!m_hRootScopeItem || m_hRootScopeItem == hItem) )
    {
        if ( m_pGPERootStore )
        {
            m_pGPERootStore->Release ();
            m_pGPERootStore = 0;
        }

        if ( m_pGPETrustStore )
        {
            m_pGPETrustStore->Release ();
            m_pGPETrustStore = 0;
        }

        if ( m_pGPEACRSComputerStore )
        {
            m_pGPEACRSComputerStore->Release ();
            m_pGPEACRSComputerStore = 0;
        }

        if ( m_pGPEACRSUserStore )
        {
            m_pGPEACRSUserStore->Release ();
            m_pGPEACRSUserStore = 0;
        }

        if ( m_pRSOPInformationComputer )
        {
            m_pRSOPInformationComputer->Release();
            m_pRSOPInformationComputer = 0;
        }
            
        if ( m_pRSOPInformationUser )
        {
            m_pRSOPInformationUser->Release();
            m_pRSOPInformationUser = 0;
        }
    }

    _TRACE (-1, L"Leaving CCertMgrComponentData::OnNotifyRelease: 0x%x\n", hr);
    return hr;
}


BSTR CCertMgrComponentData::QueryResultColumnText (CCookie& basecookie, int nCol)
{
//  _TRACE (1, L"Entering CCertMgrComponentData::QueryResultColumnText\n");
    CCertMgrCookie& cookie = (CCertMgrCookie&) basecookie;
    BSTR    strResult = L"";

#ifndef UNICODE
#error not ANSI-enabled
#endif
    switch ( cookie.m_objecttype )
    {
        case CERTMGR_SNAPIN:
        case CERTMGR_USAGE:
        case CERTMGR_CRL_CONTAINER:
        case CERTMGR_CTL_CONTAINER:
        case CERTMGR_CERT_CONTAINER:
        case CERTMGR_CERT_POLICIES_USER:
        case CERTMGR_CERT_POLICIES_COMPUTER:
        case CERTMGR_SAFER_COMPUTER_ROOT:
        case CERTMGR_SAFER_USER_ROOT:
        case CERTMGR_SAFER_COMPUTER_LEVELS:
        case CERTMGR_SAFER_USER_LEVELS:
        case CERTMGR_SAFER_COMPUTER_ENTRIES:
        case CERTMGR_SAFER_USER_ENTRIES:
            if ( 0 == nCol )
                strResult = const_cast<BSTR> (cookie.GetObjectName ());
            break;

        case CERTMGR_SAFER_COMPUTER_LEVEL:
        case CERTMGR_SAFER_USER_LEVEL:
            if ( 0 == nCol )
                strResult = const_cast<BSTR> (cookie.GetObjectName ());
            break;

        case CERTMGR_SAFER_COMPUTER_ENTRY:
        case CERTMGR_SAFER_USER_ENTRY:
            ASSERT (0);
            break;

        case CERTMGR_PHYS_STORE:
        case CERTMGR_LOG_STORE:
        case CERTMGR_LOG_STORE_GPE:
        case CERTMGR_LOG_STORE_RSOP:
            if (COLNUM_CERT_SUBJECT == nCol)
            {
                CCertStore* pStore = reinterpret_cast <CCertStore*> (&cookie);
                ASSERT (pStore);
                if ( pStore )
                {
                    // NTRAID# 455988 PKP: RSOP mode depicts localized store 
                    // name under PublicKeyPolicies.  Store names are different
                    // in GP editor

//                    if ( m_pGPEInformation || m_bIsRSOP )
//                        strResult = const_cast<BSTR> (pStore->GetObjectName () );
//                    else
                        strResult = const_cast<BSTR> (pStore->GetLocalizedName ());
                }
            }
            break;

        case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
        case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
            ASSERT (0);
            break;

        case CERTMGR_CERTIFICATE:
        case CERTMGR_CRL:
        case CERTMGR_CTL:
        case CERTMGR_AUTO_CERT_REQUEST:
            _TRACE (0, L"CCertMgrComponentData::QueryResultColumnText bad parent type\n");
            ASSERT (0);
            break;

        default:
            ASSERT (0);
            break;
    }

//  _TRACE (-1, L"Leaving CCertMgrComponentData::QueryResultColumnText\n");
    return strResult;
}

int CCertMgrComponentData::QueryImage (CCookie& basecookie, BOOL /*fOpenImage*/)
{
//  _TRACE (1, L"Entering CCertMgrComponentData::QueryImage\n");
    int             nIcon = 0;

    CCertMgrCookie& cookie = (CCertMgrCookie&)basecookie;
    switch ( cookie.m_objecttype )
    {
        case CERTMGR_SNAPIN:
            nIcon = iIconCertificate;
            break;

        case CERTMGR_USAGE:
        case CERTMGR_PHYS_STORE:
        case CERTMGR_LOG_STORE:
        case CERTMGR_LOG_STORE_GPE:
        case CERTMGR_LOG_STORE_RSOP:
        case CERTMGR_CTL_CONTAINER:
        case CERTMGR_CERT_CONTAINER:
        case CERTMGR_CRL_CONTAINER:
        case CERTMGR_CERT_POLICIES_USER:
        case CERTMGR_CERT_POLICIES_COMPUTER:
        case CERTMGR_SAFER_COMPUTER_ROOT:
        case CERTMGR_SAFER_USER_ROOT:
        case CERTMGR_SAFER_COMPUTER_LEVELS:
        case CERTMGR_SAFER_USER_LEVELS:
        case CERTMGR_SAFER_COMPUTER_ENTRIES:
        case CERTMGR_SAFER_USER_ENTRIES:
            break;

        case CERTMGR_CERTIFICATE:
        case CERTMGR_CRL:
        case CERTMGR_CTL:
        case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
        case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
            ASSERT (0); // not expected in scope pane
            break;

        default:
            _TRACE (0, L"CCertMgrComponentData::QueryImage bad parent type\n");
            ASSERT (0);
            break;
    }
//  _TRACE (-1, L"Leaving CCertMgrComponentData::QueryImage\n");
    return nIcon;
}


///////////////////////////////////////////////////////////////////////////////
/// IExtendPropertySheet

STDMETHODIMP CCertMgrComponentData::QueryPagesFor (LPDATAOBJECT pDataObject)
{
    _TRACE (1, L"Entering CCertMgrComponentData::QueryPagesFor\n");
    HRESULT hr = S_OK;
    ASSERT (pDataObject);

    if ( pDataObject )
    {
        DATA_OBJECT_TYPES dataobjecttype = CCT_SCOPE;
        hr = ExtractData (pDataObject,
                CCertMgrDataObject::m_CFDataObjectType,
                 &dataobjecttype, sizeof (dataobjecttype));
        if ( SUCCEEDED (hr) )
        {
            switch (dataobjecttype)
            {
            case CCT_SNAPIN_MANAGER:
                if ( !m_bIsUserAdministrator )
                {
                    // Non-admins may manage only their own certs
                    m_dwLocationPersist = CERT_SYSTEM_STORE_CURRENT_USER;
                    hr = S_FALSE;
                }   
                break;

            case CCT_RESULT:
                {
                    hr = S_FALSE;
                    CCertMgrCookie* pParentCookie = ConvertCookie (pDataObject);
                    if ( pParentCookie )
                    {
                        switch (pParentCookie->m_objecttype)
                        {
                        case CERTMGR_CERTIFICATE:
                        case CERTMGR_AUTO_CERT_REQUEST:
                        case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
                        case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
                        case CERTMGR_SAFER_COMPUTER_LEVEL:
                        case CERTMGR_SAFER_USER_LEVEL:
                        case CERTMGR_SAFER_COMPUTER_TRUSTED_PUBLISHERS:
                        case CERTMGR_SAFER_USER_TRUSTED_PUBLISHERS:
                        case CERTMGR_SAFER_COMPUTER_DEFINED_FILE_TYPES:
                        case CERTMGR_SAFER_USER_DEFINED_FILE_TYPES:
                        case CERTMGR_SAFER_COMPUTER_ENTRY:
                        case CERTMGR_SAFER_USER_ENTRY:
                        case CERTMGR_SAFER_COMPUTER_ENFORCEMENT:
                        case CERTMGR_SAFER_USER_ENFORCEMENT:
                            hr = S_OK;
                            break;

                        case CERTMGR_CTL:
                            if ( m_bIsRSOP )
                                hr = S_OK;
                            break;

                        default:
                            break;
                        }
                    }
                }
                break;

            case CCT_SCOPE:
                {
                    CCertMgrCookie* pParentCookie = ConvertCookie (pDataObject);
                    if ( pParentCookie )
                    {
                        switch ( pParentCookie->m_objecttype )
                        {
                        case CERTMGR_LOG_STORE_GPE:
                        case CERTMGR_LOG_STORE_RSOP:
                            {
                                CCertStore* pStore = reinterpret_cast <CCertStore*> (pParentCookie);
                                ASSERT (pStore);
                                if ( pStore )
                                {
                                    switch (pStore->GetStoreType ())
                                    {
                                    case ROOT_STORE:
                                    case EFS_STORE:
                                        hr = S_OK;
                                        break;

                                    default:
                                        break;
                                    }
                                }
                                else
                                    hr = S_FALSE;
                            }
                            break;

                        default:
                            hr = S_FALSE;
                            break;
                        }
                    }
                    else
                    {
                        hr = S_FALSE;
                    }
                }
                break;

            default:
                hr = S_FALSE;
                break;
            }
        }
    }
    else
        hr = E_POINTER;
    

    _TRACE (-1, L"Leaving CCertMgrComponentData::QueryPagesFor: 0x%x\n", hr);
    return hr;
}

STDMETHODIMP CCertMgrComponentData::CreatePropertyPages (
    LPPROPERTYSHEETCALLBACK pCallback,
    LONG_PTR handle,        // This handle must be saved in the property page object to notify the parent when modified
    LPDATAOBJECT pDataObject)
{
    _TRACE (1, L"Entering CCertMgrComponentData::CreatePropertyPages\n");
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;


    ASSERT (pCallback && pDataObject);
    if ( pCallback && pDataObject )
    {
        DATA_OBJECT_TYPES dataobjecttype = CCT_SCOPE;
        hr = ExtractData (pDataObject,
                CCertMgrDataObject::m_CFDataObjectType,
                 &dataobjecttype, sizeof (dataobjecttype));
        switch (dataobjecttype)
        {
        case CCT_SNAPIN_MANAGER:
            hr = AddSnapMgrPropPages (pCallback);
            break;

        case CCT_RESULT:
            {
                CCertMgrCookie* pParentCookie = ConvertCookie (pDataObject);
                if ( pParentCookie )
                {
                    switch (pParentCookie->m_objecttype)
                    {
                    case CERTMGR_CERTIFICATE:
                        {
                            CCertificate* pCert = reinterpret_cast <CCertificate*> (pParentCookie);
                            ASSERT (pCert);
                            if ( pCert )
                            {
                                if ( pCert->IsCertStillInStore () )
                                {
                                    // Anything, except ACRS
                                    hr = AddCertPropPages (pCert, pCallback, 
                                            pDataObject, handle);
                                }
                                else
                                {
                                    CString text;
                                    CString caption;

                                    VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
                                    VERIFY (text.LoadString (
                                            IDS_CANCEL_BECAUSE_CERT_HAS_BEEN_DELETED));
                                    int     iRetVal = 0;
                                    VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption,
                                            MB_OK, &iRetVal)));

                                    m_pConsole->UpdateAllViews (pDataObject, 0, 0);
                                    hr = E_FAIL;
                                }
                            }
                            else
                                hr = E_FAIL;
                        }
                        break;

                    case CERTMGR_AUTO_CERT_REQUEST:
                        {
                            CAutoCertRequest* pACR = reinterpret_cast <CAutoCertRequest*> (pParentCookie);
                            ASSERT (pACR);
                            if ( pACR )
                            {
                                hr = AddACRSCTLPropPages (pACR, pCallback);
                            }
                            else
                                hr = E_FAIL;
                        }
                        break;

                    case CERTMGR_CTL:
                        {
                            CCTL* pCTL = reinterpret_cast <CCTL*> (pParentCookie);
                            ASSERT (pCTL);
                            if ( pCTL )
                            {
                                hr = AddCTLPropPages (pCTL, pCallback);
                            }
                            else
                                hr = E_FAIL;
                        }
                        break;

                    case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
                    case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
                        hr = AddAutoenrollmentSettingsPropPages (pCallback,        
                                CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS == 
                                        pParentCookie->m_objecttype);
                        break;
                    
                    case CERTMGR_SAFER_COMPUTER_LEVEL:
                    case CERTMGR_SAFER_USER_LEVEL:
                        hr = AddSaferLevelPropPage (pCallback,
                                dynamic_cast <CSaferLevel*>(pParentCookie),
                                handle,
                                pDataObject);
                        break;

                    case CERTMGR_SAFER_COMPUTER_TRUSTED_PUBLISHERS:
                    case CERTMGR_SAFER_USER_TRUSTED_PUBLISHERS:
                        hr = AddSaferTrustedPublisherPropPages (pCallback,        
                                CERTMGR_SAFER_COMPUTER_TRUSTED_PUBLISHERS == 
                                    pParentCookie->m_objecttype);
                        break;

                    case CERTMGR_SAFER_COMPUTER_DEFINED_FILE_TYPES:
                    case CERTMGR_SAFER_USER_DEFINED_FILE_TYPES:
                        hr = AddSaferDefinedFileTypesPropPages (pCallback,        
                                CERTMGR_SAFER_COMPUTER_DEFINED_FILE_TYPES == 
                                    pParentCookie->m_objecttype);
                        break;

                    case CERTMGR_SAFER_COMPUTER_ENFORCEMENT:
                    case CERTMGR_SAFER_USER_ENFORCEMENT:
                        hr = AddSaferEnforcementPropPages (pCallback,        
                                CERTMGR_SAFER_COMPUTER_ENFORCEMENT == 
                                    pParentCookie->m_objecttype);
                        break;

                    case CERTMGR_SAFER_COMPUTER_ENTRY:
                    case CERTMGR_SAFER_USER_ENTRY:
                        hr = AddSaferEntryPropertyPage (pCallback, 
                                pParentCookie, pDataObject, handle);
                        break;

                    default:
                        break;
                    }
                }
                else
                    hr = E_UNEXPECTED;
            }
            break;

        case CCT_SCOPE:
            {
                CCertMgrCookie* pParentCookie = ConvertCookie (pDataObject);
                if ( pParentCookie )
                {
                    switch ( pParentCookie->m_objecttype )
                    {
                    case CERTMGR_LOG_STORE_GPE:
                    case CERTMGR_LOG_STORE_RSOP:
                        {
                            CCertStore* pStore = reinterpret_cast <CCertStore*> (pParentCookie);
                            ASSERT (pStore);
                            if ( pStore )
                            {
                                if ( ROOT_STORE == pStore->GetStoreType () )
                                {
                                    hr = AddGPEStorePropPages (pCallback, pStore);
                                }
                                else if ( EFS_STORE == pStore->GetStoreType () )
                                {
                                    hr = AddEFSSettingsPropPages (pCallback,        
                                            pStore->IsMachineStore ());
                                }
                            }
                            else
                                hr = E_FAIL;
                        }
                        break;
                    
                    case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
                    case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
                        ASSERT (0);
                        break;

                    default:
                        break;
                    }
                }
                else
                    hr = E_UNEXPECTED;
            }
            break;


        default:
            break;
        }
    }
    else
        hr = E_POINTER;

    _TRACE (-1, L"Leaving CCertMgrComponentData::CreatePropertyPages: 0x%x\n", hr);
    return hr;
}


HRESULT CCertMgrComponentData::AddSnapMgrPropPages (LPPROPERTYSHEETCALLBACK pCallback)
{
    _TRACE (1, L"Entering CCertMgrComponentData::AddSnapMgrPropPages\n");
    HRESULT         hr = S_OK;
    ASSERT (pCallback);
    if ( pCallback )
    {
        //
        // Note that once we have established that this is a CCT_SNAPIN_MANAGER cookie,
        // we don't care about its other properties.  A CCT_SNAPIN_MANAGER cookie is
        // equivalent to a BOOL flag asking for the Node Properties page instead of a
        // managed object property page.  JonN 10/9/96
        //
        if ( m_bIsUserAdministrator )
        {
            CSelectAccountPropPage * pSelAcctPage =
                    new CSelectAccountPropPage (IsWindowsNT ());
            if ( pSelAcctPage )
            {
                pSelAcctPage->AssignLocationPtr (&m_dwLocationPersist);
                HPROPSHEETPAGE hSelAcctPage = MyCreatePropertySheetPage (&pSelAcctPage->m_psp);
                if ( hSelAcctPage )
                {
                    hr = pCallback->AddPage (hSelAcctPage);
                    ASSERT (SUCCEEDED (hr));
                    if ( FAILED (hr) )
                        VERIFY (::DestroyPropertySheetPage (hSelAcctPage));
                }
                else
                    delete pSelAcctPage;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            // In Windows 95 or Windows 98,users will only be able to manage the
            // local machine.
            if ( IsWindowsNT () )
            {
                CCertMgrChooseMachinePropPage * pChooseMachinePage = new CCertMgrChooseMachinePropPage ();
                if ( pChooseMachinePage )
                {
                    pChooseMachinePage->AssignLocationPtr (&m_dwLocationPersist);

                    // Initialize state of object
                    ASSERT (m_pRootCookie);
                    if ( m_pRootCookie )
                    {
                        pChooseMachinePage->InitMachineName (m_pRootCookie->QueryTargetServer ());
                        pChooseMachinePage->SetOutputBuffers (
                            OUT &m_strMachineNamePersist,
                            OUT &m_fAllowOverrideMachineName,
                            OUT &m_pRootCookie->m_strMachineName);  // Effective machine name

                        HPROPSHEETPAGE hChooseMachinePage = MyCreatePropertySheetPage (&pChooseMachinePage->m_psp);
                        if ( hChooseMachinePage )
                        {
                            hr = pCallback->AddPage (hChooseMachinePage);
                            ASSERT (SUCCEEDED (hr));
                            if ( FAILED (hr) )
                                VERIFY (::DestroyPropertySheetPage (hChooseMachinePage));
                        }
                        else
                            delete pChooseMachinePage;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

                CSelectServiceAccountPropPage* pServicePage = new
                        CSelectServiceAccountPropPage (&m_szManagedServicePersist,
                            &m_szManagedServiceDisplayName,
                            m_strMachineNamePersist);
                if ( pServicePage )
                {
//                  pServicePage->SetCaption (IDS_MS_CERT_MGR); // access violation when called

                    HPROPSHEETPAGE hServicePage = MyCreatePropertySheetPage (&pServicePage->m_psp);
                    if ( hServicePage )
                    {
                        hr = pCallback->AddPage (hServicePage);
                        ASSERT (SUCCEEDED (hr));
                        if ( FAILED (hr) )
                            VERIFY (::DestroyPropertySheetPage (hServicePage));

                    }
                    else
                        delete pServicePage;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
        else
        {
            // Non-administrators may view their own certs only.
            m_dwLocationPersist = CERT_SYSTEM_STORE_CURRENT_USER;
        }


    }
    else
        hr = E_POINTER;

    _TRACE (-1, L"Leaving CCertMgrComponentData::AddSnapMgrPropPages: 0x%x\n", hr);
    return hr;
}


HRESULT CCertMgrComponentData::AddACRSCTLPropPages (CAutoCertRequest* pACR, LPPROPERTYSHEETCALLBACK pCallback)
{
    _TRACE (1, L"Entering CCertMgrComponentData::AddACRSCTLPropPages\n");
    HRESULT         hr = S_OK;
    ASSERT (pACR && pCallback);
    if ( pACR && pCallback )
    {
        CACRGeneralPage * pACRPage = new CACRGeneralPage (*pACR);
        if ( pACRPage )
        {
            HPROPSHEETPAGE hACRPage = MyCreatePropertySheetPage (&pACRPage->m_psp);
            if ( hACRPage )
            {
                hr = pCallback->AddPage (hACRPage);
                ASSERT (SUCCEEDED (hr));
                if ( FAILED (hr) )
                    VERIFY (::DestroyPropertySheetPage (hACRPage));
            }
            else
                delete pACRPage;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        if ( m_bIsRSOP )
        {
            CString szSHA1Hash (L"\\ACRS\\CTLs\\");
            szSHA1Hash += pACR->GetSHAHash ();
            hr = FindRSOPObjectByHashAndDisplayPrecedencePage (szSHA1Hash, 
                        pACR->GetCertStore ().IsComputerType (), pCallback);
        }
    }
    else
        hr = E_POINTER;

    _TRACE (-1, L"Leaving CCertMgrComponentData::AddACRSCTLPropPages: 0x%x\n", hr);
    return hr;
}

HRESULT CCertMgrComponentData::FindRSOPObjectByHashAndDisplayPrecedencePage (
            const CString& szHash, 
            const bool bIsComputer, 
            LPPROPERTYSHEETCALLBACK pCallback)
{
    HRESULT hr = S_OK;
    CString szRegKey;

    // NOTE: rsop object array is sorted first by registry key, then by precedence
    const CRSOPObjectArray* pObjectArray = 
            bIsComputer ? 
            GetRSOPObjectArrayComputer () : GetRSOPObjectArrayUser ();
    INT_PTR nUpperBound = pObjectArray->GetUpperBound ();
    int     nIndex = 0;

    // The CTLs are identified by their SHA1 hash. Find the 
    // RSOP object containing this CTL's SHA1 hash value and
    // use that to determine the precedence.
    while ( nUpperBound >= nIndex )
    {
        CRSOPObject* pObject = pObjectArray->GetAt (nIndex);
        if ( pObject )
        {
            if ( -1 != pObject->GetRegistryKey ().Find (szHash) )
            {
                // If value equals to "Blob" or "Blob0", then we've 
                // found our node
                // security review 2/26/2002 BryanWal ok
                if ( !wcscmp (STR_BLOB, pObject->GetValueName ()) ||
                        !wcscmp (STR_BLOB0, pObject->GetValueName ()) )
                {
                    szRegKey = pObject->GetRegistryKey ();
                    break;
                }
            }
        }
        else
            break;

        nIndex++;
    }

    // Only show the property page if the correct RSOP object was found
    if ( !szRegKey.IsEmpty () )
    {
        CPolicyPrecedencePropertyPage * pPrecedencePage = 
                new CPolicyPrecedencePropertyPage (this, szRegKey,
                        STR_BLOB,
                        bIsComputer);
        if ( pPrecedencePage )
        {
            HPROPSHEETPAGE hPrecedencePage = MyCreatePropertySheetPage (&pPrecedencePage->m_psp);
            if ( hPrecedencePage )
            {
                hr = pCallback->AddPage (hPrecedencePage);
                ASSERT (SUCCEEDED (hr));
                if ( FAILED (hr) )
                    VERIFY (::DestroyPropertySheetPage (hPrecedencePage));
            }
            else
                delete pPrecedencePage;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}
 
HRESULT CCertMgrComponentData::AddCTLPropPages (CCTL* pCTL, LPPROPERTYSHEETCALLBACK pCallback)
{
    _TRACE (1, L"Entering CCertMgrComponentData::AddCTLPropPages\n");
    HRESULT         hr = S_OK;
    ASSERT (pCTL && pCallback);
    if ( pCTL && pCallback )
    {
        if ( m_bIsRSOP )
        {
            CString szSHA1Hash (L"\\Trust\\CTLs\\");
            szSHA1Hash += pCTL->GetSHAHash ();
            hr = FindRSOPObjectByHashAndDisplayPrecedencePage (szSHA1Hash, 
                        pCTL->GetCertStore ().IsComputerType (), pCallback);
        }
    }
    else
        hr = E_POINTER;

    _TRACE (-1, L"Leaving CCertMgrComponentData::AddCTLPropPages: 0x%x\n", hr);
    return hr;
}

 
HRESULT CCertMgrComponentData::AddEFSSettingsPropPages (
    LPPROPERTYSHEETCALLBACK pCallback,
    bool fIsComputerType)
{
    _TRACE (1, L"Entering CCertMgrComponentData::AddEFSSettingsPropPages\n");
    HRESULT         hr = S_OK;
    ASSERT (pCallback);
    if ( pCallback )
    {
        CEFSGeneralPropertyPage * pEFSPage = new CEFSGeneralPropertyPage (
                this, fIsComputerType);
        if ( pEFSPage )
        {
            HPROPSHEETPAGE hEFSPage = MyCreatePropertySheetPage (&pEFSPage->m_psp);
            if ( hEFSPage )
            {
                hr = pCallback->AddPage (hEFSPage);
                ASSERT (SUCCEEDED (hr));
                if ( SUCCEEDED (hr) )
                {
                    if ( m_bIsRSOP )
                    {
                        CString storePath = EFS_SETTINGS_REGPATH;
                        CPolicyPrecedencePropertyPage * pPrecedencePage = 
                                new CPolicyPrecedencePropertyPage (this, storePath,
                                        EFS_SETTINGS_REGVALUE,
                                        fIsComputerType);
                        if ( pPrecedencePage )
                        {
                            HPROPSHEETPAGE hPrecedencePage = MyCreatePropertySheetPage (&pPrecedencePage->m_psp);
                            if ( hPrecedencePage )
                            {
                                hr = pCallback->AddPage (hPrecedencePage);
                                ASSERT (SUCCEEDED (hr));
                                if ( FAILED (hr) )
                                    VERIFY (::DestroyPropertySheetPage (hPrecedencePage));
                            }
                            else
                                delete pPrecedencePage;
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }
                }
                else
                    VERIFY (::DestroyPropertySheetPage (hEFSPage));
            }
            else
                delete pEFSPage;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
        hr = E_POINTER;

    _TRACE (-1, L"Leaving CCertMgrComponentData::AddEFSSettingsPropPages: 0x%x\n", hr);
    return hr;
}

HRESULT CCertMgrComponentData::AddAutoenrollmentSettingsPropPages (
    LPPROPERTYSHEETCALLBACK pCallback,
    bool fIsComputerType)
{
    _TRACE (1, L"Entering CCertMgrComponentData::AddAutoenrollmentSettingsPropPages\n");
    HRESULT         hr = S_OK;
    ASSERT (pCallback);
    if ( pCallback )
    {
        CAutoenrollmentPropertyPage * pAutoEnrollmentPage = new CAutoenrollmentPropertyPage (
                this, fIsComputerType);
        if ( pAutoEnrollmentPage )
        {
            HPROPSHEETPAGE hAutoEnrollmentPage = MyCreatePropertySheetPage (&pAutoEnrollmentPage->m_psp);
            if ( hAutoEnrollmentPage )
            {
                hr = pCallback->AddPage (hAutoEnrollmentPage);
                ASSERT (SUCCEEDED (hr));
                if ( SUCCEEDED (hr) )
                {
                    if ( m_bIsRSOP )
                    {
                        CString storePath = AUTO_ENROLLMENT_KEY;
                        CPolicyPrecedencePropertyPage * pPrecedencePage = 
                                new CPolicyPrecedencePropertyPage (this, storePath,
                                        AUTO_ENROLLMENT_POLICY,
                                        fIsComputerType);
                        if ( pPrecedencePage )
                        {
                            HPROPSHEETPAGE hPrecedencePage = MyCreatePropertySheetPage (&pPrecedencePage->m_psp);
                            if ( hPrecedencePage )
                            {
                                hr = pCallback->AddPage (hPrecedencePage);
                                ASSERT (SUCCEEDED (hr));
                                if ( FAILED (hr) )
                                    VERIFY (::DestroyPropertySheetPage (hPrecedencePage));
                            }
                            else
                                delete pPrecedencePage;
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }
                }
                else
                    VERIFY (::DestroyPropertySheetPage (hAutoEnrollmentPage));
            }
            else
                delete pAutoEnrollmentPage;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
        hr = E_POINTER;

    _TRACE (-1, L"Leaving CCertMgrComponentData::AddAutoenrollmentSettingsPropPages: 0x%x\n", hr);
    return hr;
}

HRESULT CCertMgrComponentData::AddGPEStorePropPages (
        LPPROPERTYSHEETCALLBACK pCallback, 
        CCertStore* pStore)
{
    _TRACE (1, L"Entering CCertMgrComponentData::AddGPEStorePropPages\n");
    HRESULT         hr = S_OK;
    ASSERT (pCallback && pStore);
    if ( !pCallback || !pStore)
        return E_POINTER;
    ASSERT (m_pGPEInformation || m_pRSOPInformationComputer || m_pRSOPInformationUser );
    if ( !m_pGPEInformation && !m_pRSOPInformationComputer && !m_pRSOPInformationUser )
        return E_UNEXPECTED;

    bool bIsComputerType = pStore->IsMachineStore ();

    CGPERootGeneralPage * pGPERootPage = new CGPERootGeneralPage (this, bIsComputerType);
    if ( pGPERootPage )
    {
        HPROPSHEETPAGE hGPERootPage = MyCreatePropertySheetPage (&pGPERootPage->m_psp);
        if ( hGPERootPage )
        {
            hr = pCallback->AddPage (hGPERootPage);
            ASSERT (SUCCEEDED (hr));
            if ( FAILED (hr) )
                VERIFY (::DestroyPropertySheetPage (hGPERootPage));
        }
        else
            delete pGPERootPage;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if ( SUCCEEDED (hr) )
    {
        if ( m_bIsRSOP )
        {
            CString storePath = CERT_GROUP_POLICY_SYSTEM_STORE_REGPATH;
            storePath += L"\\";
            storePath += pStore->GetStoreName ();

            CPolicyPrecedencePropertyPage * pPrecedencePage = 
                    new CPolicyPrecedencePropertyPage (this, storePath, 
                            CERT_PROT_ROOT_FLAGS_VALUE_NAME, bIsComputerType);
            if ( pPrecedencePage )
            {
                HPROPSHEETPAGE hPrecedencePage = MyCreatePropertySheetPage (&pPrecedencePage->m_psp);
                if ( hPrecedencePage )
                {
                    hr = pCallback->AddPage (hPrecedencePage);
                    ASSERT (SUCCEEDED (hr));
                    if ( FAILED (hr) )
                        VERIFY (::DestroyPropertySheetPage (hPrecedencePage));
                }
                else
                    delete pPrecedencePage;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    _TRACE (-1, L"Leaving CCertMgrComponentData::AddGPEStorePropPages: 0x%x\n", hr);
    return hr;
}


HRESULT CCertMgrComponentData::AddCertPropPages (
            CCertificate * pCert, 
            LPPROPERTYSHEETCALLBACK pCallback, 
            LPDATAOBJECT pDataObject, 
            LONG_PTR lNotifyHandle)
{
    _TRACE (1, L"Entering CCertMgrComponentData::AddCertPropPages\n");
    HRESULT         hr = S_OK;
    CWaitCursor     waitCursor;
    ASSERT (pCert);
    ASSERT (pCallback);
    if ( pCert && pCallback )
    {
        PROPSHEETPAGEW*                             ppsp = 0;
        DWORD                                       dwPageCnt = 0;
        CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCT    sps;
        HCERTSTORE*                                 pPropPageStores = new HCERTSTORE[1];

        if ( pPropPageStores )
        {
            m_pCryptUIMMCCallbackStruct = (PCRYPTUI_MMCCALLBACK_STRUCT)
                    ::GlobalAlloc (GMEM_FIXED, sizeof (CRYPTUI_MMCCALLBACK_STRUCT));
            if ( m_pCryptUIMMCCallbackStruct )
            {
                m_pCryptUIMMCCallbackStruct->pfnCallback = &MMCPropertyChangeNotify;
                m_pCryptUIMMCCallbackStruct->lNotifyHandle = lNotifyHandle;
                pDataObject->AddRef ();
                m_pCryptUIMMCCallbackStruct->param = (LPARAM) pDataObject;

                CCertStore* pStore = pCert->GetCertStore ();
                if ( pStore )
                {
                    pPropPageStores[0] = pStore->GetStoreHandle ();
                    // security review 2/26/2002 BryanWal ok
                    ::ZeroMemory (&sps, sizeof (sps));
                    sps.dwSize = sizeof (sps);
                    sps.pMMCCallback = m_pCryptUIMMCCallbackStruct;
                    sps.pCertContext = pCert->GetNewCertContext ();
                    sps.cStores = 1;
                    sps.rghStores = pPropPageStores;

                    // All dialogs should be read-only under RSOP
                    if ( m_bIsRSOP || pCert->IsReadOnly () )
                        sps.dwFlags |= CRYPTUI_DISABLE_EDITPROPERTIES;
            
                    _TRACE (0, L"Calling CryptUIGetCertificatePropertiesPages()\n");
                    BOOL bReturn = ::CryptUIGetCertificatePropertiesPages (
                        &sps,
                        NULL,
                        &ppsp,
                        &dwPageCnt);
                    ASSERT (bReturn);
                    if ( bReturn )
                    {
                        HPROPSHEETPAGE  hPage = 0;
                        for (DWORD dwIndex = 0; dwIndex < dwPageCnt; dwIndex++)
                        {
                            _TRACE (0, L"Calling CreatePropertySheetPage()\n");
                            // Not necessary to call MyCreatePropertySheetPage here
                            // as these are not MFC-based property pages
                            hPage = ::CreatePropertySheetPage (&ppsp[dwIndex]);
                            if ( hPage )
                            {
                                hr = pCallback->AddPage (hPage);
                                ASSERT (SUCCEEDED (hr));
                                if ( FAILED (hr) )
                                {
                                    VERIFY (::DestroyPropertySheetPage (hPage));
                                    break;
                                }
                            }
                            else
                            {
                                hr = HRESULT_FROM_WIN32 (GetLastError ());
                                break;
                            }
                        }
                    }
                    else
                    {
                        hr = E_UNEXPECTED;
                        GlobalFree (m_pCryptUIMMCCallbackStruct);
                        ::CertFreeCertificateContext (sps.pCertContext);
                    }
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            if ( E_OUTOFMEMORY == hr && ppsp )
                free (ppsp);    // source uses malloc

            delete [] pPropPageStores;
        }
        else
            hr = E_OUTOFMEMORY;

        if ( m_bIsRSOP )
        {
            CString szSHA1Hash (L"\\Certificates\\");
            szSHA1Hash += pCert->GetSHAHash ();
            hr = FindRSOPObjectByHashAndDisplayPrecedencePage (szSHA1Hash, 
                        pCert->GetCertStore ()->IsComputerType (),
                        pCallback);

        }
    }
    else
        hr = E_POINTER;


    _TRACE (-1, L"Leaving CCertMgrComponentData::AddCertPropPages: 0x%x\n", hr);
    return hr;
}


HRESULT CCertMgrComponentData::AddContainersToScopePane (
        HSCOPEITEM hParent,
        CCertMgrCookie& parentCookie,
        bool bDeleteAndExpand)
{
    _TRACE (1, L"Entering CCertMgrComponentData::AddContainersToScopePane\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());

    LPCONSOLENAMESPACE2 pConsoleNameSpace2 = 0;
    HRESULT hr = m_pConsoleNameSpace->QueryInterface (
            IID_PPV_ARG (IConsoleNameSpace2, &pConsoleNameSpace2));
    if ( SUCCEEDED (hr) && pConsoleNameSpace2 )
    {
        hr = pConsoleNameSpace2->Expand (hParent);
        ASSERT (SUCCEEDED (hr));
        pConsoleNameSpace2->Release ();
        pConsoleNameSpace2 = 0;
    }

    if ( CERTMGR_PHYS_STORE == parentCookie.m_objecttype ||
            (CERTMGR_LOG_STORE == parentCookie.m_objecttype && !m_bShowPhysicalStoresPersist) )
    {
        CCertStore* pStore =
                reinterpret_cast <CCertStore*> (&parentCookie);
        ASSERT (pStore);
        if ( pStore )
        {
            CString objectName;
            if ( pStore->ContainsCRLs () &&
                    !ContainerExists (hParent, CERTMGR_CRL_CONTAINER) )
            {
                VERIFY (objectName.LoadString (IDS_CERTIFICATE_REVOCATION_LIST));
                hr = AddScopeNode (new CContainerCookie (
                        *pStore,
                        CERTMGR_CRL_CONTAINER,
                        pStore->QueryNonNULLMachineName (),
                        objectName), L"", hParent);
            }

            if ( SUCCEEDED (hr) && pStore->ContainsCTLs () &&
                    !ContainerExists (hParent, CERTMGR_CTL_CONTAINER) )
            {
                VERIFY (objectName.LoadString (IDS_CERTIFICATE_TRUST_LIST));
                hr = AddScopeNode (new CContainerCookie (
                        *pStore,
                        CERTMGR_CTL_CONTAINER,
                        pStore->QueryNonNULLMachineName (),
                        objectName), L"", hParent);
            }
            
            if ( SUCCEEDED (hr) && pStore->ContainsCertificates () &&
                    !ContainerExists (hParent, CERTMGR_CERT_CONTAINER) )
            {
                VERIFY (objectName.LoadString (IDS_CERTIFICATES));
                hr = AddScopeNode (new CContainerCookie (
                        *pStore,
                        CERTMGR_CERT_CONTAINER,
                        pStore->QueryNonNULLMachineName (),
                        objectName), L"", hParent);
            }
        }
        else
            hr = E_UNEXPECTED;
    }
    else if ( CERTMGR_LOG_STORE == parentCookie.m_objecttype && m_bShowPhysicalStoresPersist )
    {
        if ( bDeleteAndExpand )
        {
            hr = DeleteChildren (hParent);
            if ( SUCCEEDED (hr) )
            {
                GUID    guid;
                hr = ExpandScopeNodes (&parentCookie, hParent, _T (""), 0, guid);
            }
        }
    }

    _TRACE (-1, L"Leaving CCertMgrComponentData::AddContainersToScopePane: 0x%x\n", hr);
    return hr;
}

typedef struct _ENUM_ARG {
    DWORD                   m_dwFlags;
    LPCONSOLENAMESPACE      m_pConsoleNameSpace;
    HSCOPEITEM              m_hParent;
    CCertMgrComponentData*  m_pCompData;
    PCWSTR                  m_pcszMachineName;
    CCertMgrCookie*         m_pParentCookie;
    SPECIAL_STORE_TYPE      m_storeType;
    LPCONSOLE               m_pConsole;
} ENUM_ARG, *PENUM_ARG;

static BOOL WINAPI EnumPhyCallback (
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN PCWSTR pwszStoreName,
    IN PCERT_PHYSICAL_STORE_INFO pStoreInfo,
    IN OPTIONAL void* /*pvReserved*/,
    IN OPTIONAL void *pvArg
    )
{
    _TRACE (1, L"Entering EnumPhyCallback\n");

    if ( ! (pStoreInfo->dwFlags & CERT_PHYSICAL_STORE_OPEN_DISABLE_FLAG) )
    {
        PENUM_ARG pEnumArg = (PENUM_ARG) pvArg;
        SCOPEDATAITEM tSDItem;

        // security review 2/26/2002 BryanWal ok
        ::ZeroMemory (&tSDItem,sizeof (tSDItem));
        tSDItem.mask = SDI_STR | SDI_IMAGE | SDI_STATE | SDI_PARAM | SDI_PARENT;
        tSDItem.displayname = MMC_CALLBACK;
        tSDItem.relativeID = pEnumArg->m_hParent;
        tSDItem.nState = 0;

        if ( pEnumArg->m_pCompData->ShowArchivedCerts () )
            dwFlags |= CERT_STORE_ENUM_ARCHIVED_FLAG;

        // Create new cookies
        CCertStore* pNewCookie = new CCertStore (
                CERTMGR_PHYS_STORE,
                CERT_STORE_PROV_PHYSICAL,
                dwFlags,
                pEnumArg->m_pcszMachineName,
                pwszStoreName, (PCWSTR) pvSystemStore, pwszStoreName,
                pEnumArg->m_storeType,
                dwFlags,
                pEnumArg->m_pConsole);
        if ( pNewCookie )
        {
    //      pEnumArg->m_pParentCookie->m_listScopeCookieBlocks.AddHead (
    //               (CBaseCookieBlock*) pNewCookie);
            // WARNING cookie cast
            tSDItem.lParam = reinterpret_cast<LPARAM> ( (CCookie*) pNewCookie);
            tSDItem.nImage = pEnumArg->m_pCompData->QueryImage (*pNewCookie, FALSE);
            HRESULT hr = pEnumArg->m_pConsoleNameSpace->InsertItem (&tSDItem);
            ASSERT (SUCCEEDED (hr));
            if ( SUCCEEDED (hr) )
                pNewCookie->m_hScopeItem = tSDItem.ID;
        }
    }

    _TRACE (-1, L"Leaving EnumPhyCallback\n");
    return TRUE;
}

HRESULT CCertMgrComponentData::AddPhysicalStoresToScopePane (HSCOPEITEM hParent, CCertMgrCookie& parentCookie, const SPECIAL_STORE_TYPE storeType)
{
    _TRACE (1, L"Entering CCertMgrComponentData::AddPhysicalStoresToScopePane\n");
    CWaitCursor cursor;
    HRESULT     hr = S_OK;
    DWORD       dwFlags = 0;
    ENUM_ARG    enumArg;


    dwFlags &= ~CERT_SYSTEM_STORE_LOCATION_MASK;
    dwFlags |= CERT_STORE_READONLY_FLAG | m_dwLocationPersist;

    // security review 2/26/2002 BryanWal ok
    ::ZeroMemory (&enumArg, sizeof (enumArg));
    enumArg.m_dwFlags = dwFlags;
    enumArg.m_pConsoleNameSpace = m_pConsoleNameSpace;
    enumArg.m_hParent = hParent;
    enumArg.m_pCompData = this;
    enumArg.m_pcszMachineName = parentCookie.QueryNonNULLMachineName ();
    enumArg.m_pParentCookie = &parentCookie;
    enumArg.m_storeType = storeType;
    enumArg.m_pConsole = m_pConsole;

    if (!::CertEnumPhysicalStore (
                (PWSTR) (PCWSTR) parentCookie.GetObjectName (),
                dwFlags,
                &enumArg,
                EnumPhyCallback))
    {
        DWORD   dwErr = GetLastError ();
        DisplaySystemError (dwErr);
        hr = HRESULT_FROM_WIN32 (dwErr);
    }

    _TRACE (-1, L"Leaving CCertMgrComponentData::AddPhysicalStoresToScopePane: 0x%x\n", hr);
    return hr;
}

static BOOL WINAPI EnumIComponentDataSysCallback (
    IN const void* pwszSystemStore,
    IN DWORD dwFlags,
    IN PCERT_SYSTEM_STORE_INFO /*pStoreInfo*/,
    IN OPTIONAL void* /*pvReserved*/,
    IN OPTIONAL void *pvArg
    )
{
    _TRACE (1, L"Entering EnumIComponentDataSysCallback\n");
    PENUM_ARG       pEnumArg = (PENUM_ARG) pvArg;
    SCOPEDATAITEM   tSDItem;
    // security review 2/26/2002 BryanWal ok
    ::ZeroMemory (&tSDItem,sizeof (tSDItem));
    tSDItem.mask = SDI_STR | SDI_IMAGE | SDI_STATE | SDI_PARAM | SDI_PARENT;
    tSDItem.displayname = MMC_CALLBACK;
    tSDItem.relativeID = pEnumArg->m_hParent;
    tSDItem.nState = 0;


    // Create new cookies
    SPECIAL_STORE_TYPE  storeType = GetSpecialStoreType ((PWSTR) pwszSystemStore);

    //
    // We will not expose the ACRS store for machines or users.  It is not
    // interesting or useful at this level.  All Auto Cert Requests should
    // be managed only at the policy level.
    //
    if ( ACRS_STORE != storeType )
    {
        if ( pEnumArg->m_pCompData->ShowArchivedCerts () )
            dwFlags |= CERT_STORE_ENUM_ARCHIVED_FLAG;
        CCertStore* pNewCookie = new CCertStore (
                CERTMGR_LOG_STORE,
                CERT_STORE_PROV_SYSTEM,
                dwFlags,
                pEnumArg->m_pcszMachineName,
                 (PCWSTR) pwszSystemStore,
                 (PCWSTR) pwszSystemStore,
                _T (""),
                storeType,
                pEnumArg->m_dwFlags,
                pEnumArg->m_pConsole);
        if ( pNewCookie )
        {
            pEnumArg->m_pParentCookie->m_listScopeCookieBlocks.AddHead (
                    (CBaseCookieBlock*) pNewCookie);
            // WARNING cookie cast
            tSDItem.lParam = reinterpret_cast<LPARAM> ( (CCookie*) pNewCookie);
            tSDItem.nImage = pEnumArg->m_pCompData->QueryImage (*pNewCookie, FALSE);
            HRESULT hr = pEnumArg->m_pConsoleNameSpace->InsertItem (&tSDItem);
            ASSERT (SUCCEEDED (hr));
            if ( SUCCEEDED (hr) )
                pNewCookie->m_hScopeItem = tSDItem.ID;
        }
    }

    _TRACE (-1, L"Leaving EnumIComponentDataSysCallback\n");
    return TRUE;
}



HRESULT CCertMgrComponentData::AddLogicalStoresToScopePane (HSCOPEITEM hParent, CCertMgrCookie& parentCookie)
{
    _TRACE (1, L"Entering CCertMgrComponentData::AddLogicalStoresToScopePane\n");
    CWaitCursor cursor;
    HRESULT     hr = S_OK;

    // If m_dwLocationPersist is 0 but the file name is empty, this means the
    // user launched certmgr.msc without providing a target file.  Launch
    // certificates snapin as the current user instead.
    if ( !m_dwLocationPersist )
    {
        if ( m_szFileName.IsEmpty () )
            m_dwLocationPersist = CERT_SYSTEM_STORE_CURRENT_USER;

        ChangeRootNodeName (L"");
    }

    DWORD       dwFlags = m_dwLocationPersist;
    ENUM_ARG    enumArg;

    // security review 2/26/2002 BryanWal ok
     ::ZeroMemory (&enumArg, sizeof (enumArg));
    enumArg.m_dwFlags = dwFlags;
    enumArg.m_pConsoleNameSpace = m_pConsoleNameSpace;
    enumArg.m_hParent = hParent;
    enumArg.m_pCompData = this;
    enumArg.m_pcszMachineName = parentCookie.QueryNonNULLMachineName ();
    enumArg.m_pParentCookie = &parentCookie;
    enumArg.m_pConsole = m_pConsole;
    CString location;
    void*   pvPara = 0;
    
    switch (m_dwLocationPersist)
    {
    case CERT_SYSTEM_STORE_CURRENT_USER:
    case CERT_SYSTEM_STORE_LOCAL_MACHINE:
        if ( !m_szManagedServicePersist.IsEmpty () )
            m_szManagedServicePersist.Empty ();
        break;

    case CERT_SYSTEM_STORE_CURRENT_SERVICE:
    case CERT_SYSTEM_STORE_SERVICES:
        break;

    case 0:     // in the event of a file store
        break;

    default:
        ASSERT (0);
        break;
    }

    if ( !m_szManagedServicePersist.IsEmpty () )
    {
        if ( m_szManagedComputer.CompareNoCase (m_szThisComputer) )    //!=
        {
            location = m_szManagedComputer + _T ("\\") +
                    m_szManagedServicePersist;
            pvPara = (void *) (PCWSTR) location;
        }
        else
            pvPara = (void *) (PCWSTR) m_szManagedServicePersist;
    }
    else if ( m_szManagedComputer.CompareNoCase (m_szThisComputer) )   //!=
    {
        pvPara = (void *) (PCWSTR) m_szManagedComputer;
    }


    if ( m_szFileName.IsEmpty () )
    {
        // Ensure creation of MY store
        HCERTSTORE hTempStore = ::CertOpenStore (CERT_STORE_PROV_SYSTEM,
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                NULL,
                dwFlags | CERT_STORE_SET_LOCALIZED_NAME_FLAG,
                MY_SYSTEM_STORE_NAME);
        if ( hTempStore )  // otherwise, store is read only
        {
            VERIFY (::CertCloseStore (hTempStore, CERT_CLOSE_STORE_CHECK_FLAG));
        }
        else
        {
            _TRACE (0, L"CertOpenStore (%s) failed: 0x%x\n", 
                    MY_SYSTEM_STORE_NAME, GetLastError ());     
        }

        if ( !::CertEnumSystemStore (dwFlags, pvPara, &enumArg,
                EnumIComponentDataSysCallback) )
        {
            DWORD   dwErr = GetLastError ();
            CString text;
            CString caption;

            VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
            if ( ERROR_ACCESS_DENIED == dwErr )
            {
                VERIFY (text.LoadString (IDS_NO_PERMISSION));

            }
            else
            {
                text.FormatMessage (IDS_CANT_ENUMERATE_SYSTEM_STORES, GetSystemMessage (dwErr));
            }
            int     iRetVal = 0;
            VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption,
                    MB_OK, &iRetVal)));
            hr = HRESULT_FROM_WIN32 (dwErr);

            if ( ERROR_BAD_NETPATH == dwErr )
            {
                m_fInvalidComputer = true;
            }
        }
    }
    else
    {
        //  CertOpenStore with provider type of:
        //  CERT_STORE_PROV_FILE or CERT_STORE_PROV_FILENAME_A
        //  or CERT_STORE_PROV_FILENAME_W.
        //  See online documentation or wincrypt.h for more info.
        // Create new cookies
        dwFlags = 0;
        if ( ShowArchivedCerts () )
            dwFlags |= CERT_STORE_ENUM_ARCHIVED_FLAG;
        
        ASSERT (!m_pFileBasedStore);
        m_pFileBasedStore = new CCertStore (
                    CERTMGR_LOG_STORE,
                    CERT_STORE_PROV_FILENAME_W,
                    dwFlags,
                    parentCookie.QueryNonNULLMachineName (),
                    m_szFileName, m_szFileName, L"", NO_SPECIAL_TYPE,
                    m_dwLocationPersist,
                    m_pConsole);
        if ( m_pFileBasedStore )
        {
            m_pFileBasedStore->AddRef ();
            hr = AddScopeNode (m_pFileBasedStore,
                    L"", hParent);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    _TRACE (-1, L"Leaving CCertMgrComponentData::AddLogicalStoresToScopePane: 0x%x\n", hr);
    return hr;
}


    // If the callback returns FALSE, stops the enumeration.
BOOL EnumOIDInfo (PCCRYPT_OID_INFO pInfo, void *pvArg)
{
    _TRACE (1, L"Entering EnumOIDInfo\n");
    ENUM_ARG*       pEnumArg = (ENUM_ARG*) pvArg;
    SCOPEDATAITEM   tSDItem;
    // security review 2/26/2002 BryanWal ok
    ::ZeroMemory (&tSDItem, sizeof (tSDItem));
    tSDItem.mask = SDI_STR | SDI_IMAGE | SDI_STATE | SDI_PARAM | SDI_PARENT;
    tSDItem.displayname = MMC_CALLBACK;
    tSDItem.relativeID = pEnumArg->m_hParent;
    tSDItem.nState = 0;

    // See if this usage is already listed by name.  If so, just add the
    // additional OID, otherwise, create a new cookie.
    CUsageCookie* pUsageCookie =
            pEnumArg->m_pCompData->FindDuplicateUsage (pEnumArg->m_hParent,
            pInfo->pwszName);
    if ( !pUsageCookie )
    {
        pUsageCookie= new CUsageCookie (CERTMGR_USAGE,
            pEnumArg->m_pcszMachineName,
            pInfo->pwszName);
        if ( pUsageCookie )
        {
            pEnumArg->m_pCompData->GetRootCookie ()->m_listScopeCookieBlocks.AddHead ( (CBaseCookieBlock*) pUsageCookie);

            // WARNING cookie cast
            tSDItem.mask |= SDI_CHILDREN;
            tSDItem.cChildren = 0;
            tSDItem.lParam = reinterpret_cast<LPARAM> ( (CCookie*) pUsageCookie);
            tSDItem.nImage = pEnumArg->m_pCompData->QueryImage (*pUsageCookie, FALSE);
            HRESULT hr = pEnumArg->m_pConsoleNameSpace->InsertItem (&tSDItem);
            ASSERT (SUCCEEDED (hr));
        }
    }
    pUsageCookie->AddOID (pInfo->pszOID);


    _TRACE (-1, L"Leaving EnumOIDInfo\n");
    return TRUE;
}


HRESULT CCertMgrComponentData::AddUsagesToScopePane (HSCOPEITEM hParent, CCertMgrCookie& parentCookie)
{
    _TRACE (1, L"Entering CCertMgrComponentData::AddUsagesToScopePane\n");
    HRESULT     hr = S_OK;
    ENUM_ARG    enumArg;

    // security review 2/26/2002 BryanWal ok
    ::ZeroMemory (&enumArg, sizeof (enumArg));
    enumArg.m_dwFlags = 0;
    enumArg.m_pConsoleNameSpace = m_pConsoleNameSpace;
    enumArg.m_hParent = hParent;
    enumArg.m_pCompData = this;
    enumArg.m_pcszMachineName = parentCookie.QueryNonNULLMachineName ();
    enumArg.m_pParentCookie = &parentCookie;
    enumArg.m_pConsole = m_pConsole;
    BOOL bResult = ::CryptEnumOIDInfo (CRYPT_ENHKEY_USAGE_OID_GROUP_ID, 0,
            &enumArg, EnumOIDInfo);
    ASSERT (bResult);


    _TRACE (-1, L"Leaving CCertMgrComponentData::AddUsagesToScopePane: 0x%x\n", hr);
    return hr;
}


BOOL IsMMCMultiSelectDataObject(IDataObject* pDataObject)
{
    _TRACE (1, L"Entering IsMMCMultiSelectDataObject\n");
    if (pDataObject == NULL)
        return FALSE;

    CLIPFORMAT s_cf = 0;
    if (s_cf == 0)
    {
        USES_CONVERSION;
        // security review 2/26/2002 BryanWal ok
        s_cf = (CLIPFORMAT)RegisterClipboardFormat(W2T(CCF_MMC_MULTISELECT_DATAOBJECT));
    }

    FORMATETC fmt = {s_cf, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    BOOL bResult = ((pDataObject->QueryGetData(&fmt) == S_OK));
    _TRACE (-1, L"Leaving IsMMCMultiSelectDataObject - return %d\n", bResult);
    return bResult;
}



STDMETHODIMP CCertMgrComponentData::Command (long nCommandID, LPDATAOBJECT pDataObject)
{
    _TRACE (1, L"Entering CCertMgrComponentData::Command\n");
    HRESULT hr = S_OK;

    switch (nCommandID)
    {
    case IDM_TASK_RENEW_SAME_KEY:
        hr = OnRenew (pDataObject, false);
        break;

    case IDM_TASK_RENEW_NEW_KEY:
        hr = OnRenew (pDataObject, true);
        break;

    case IDM_TASK_IMPORT:
        hr = OnImport (pDataObject);
        break;

    case IDM_TASK_EXPORT:
        hr = OnExport (pDataObject);
        break;

    case IDM_CTL_EDIT:
        hr = OnCTLEdit (pDataObject);
        break;

    case IDM_EDIT_ACRS:
        hr = OnACRSEdit (pDataObject);
        break;

    case IDM_NEW_CTL:
        hr = OnNewCTL (pDataObject);
        break;

    case IDM_TASK_CTL_EXPORT:
    case IDM_TASK_CRL_EXPORT:
        hr = OnExport (pDataObject);
        break;

    case IDM_TASK_EXPORT_STORE:
        hr = OnExport (pDataObject);
        break;

    case IDM_TOP_FIND:
    case IDM_TASK_FIND:
        hr = OnFind (pDataObject);
        break;

    case IDM_TASK_PULSEAUTOENROLL:
        hr = OnPulseAutoEnroll();
        break;

    case IDM_TOP_CHANGE_COMPUTER:
    case IDM_TASK_CHANGE_COMPUTER:
        hr = OnChangeComputer (pDataObject);
        break;

    case IDM_ENROLL_NEW_CERT:
        hr = OnEnroll (pDataObject, true);
        break;

    case IDM_ENROLL_NEW_CERT_SAME_KEY:
        hr = OnEnroll (pDataObject, false);
        break;

    case IDM_ENROLL_NEW_CERT_NEW_KEY:
        hr = OnEnroll (pDataObject, true);
        break;

    case IDM_OPTIONS:
        hr = OnOptions (pDataObject);
        break;

    case IDM_INIT_POLICY:
        hr = OnInitEFSPolicy (pDataObject);
        break;

    case IDM_DEL_POLICY:
        {
            AFX_MANAGE_STATE (AfxGetStaticModuleState ());
            CString text;
            CString caption;
            int     iRetVal = 0;


            VERIFY (text.LoadString (IDS_CONFIRM_DELETE_EFS_POLICY));
            VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
            hr = m_pConsole->MessageBox (text, caption,
                    MB_YESNO, &iRetVal);
            ASSERT (SUCCEEDED (hr));    
            if ( SUCCEEDED (hr) && IDYES == iRetVal )
                hr = OnDeleteEFSPolicy (pDataObject, true);
        }
        break;

    case IDM_ADD_DOMAIN_ENCRYPTED_RECOVERY_AGENT:
    case IDM_ADD_DOMAIN_ENCRYPTED_RECOVERY_AGENT1:
    case IDM_ADD_DOMAIN_ENCRYPTED_RECOVERY_AGENT2:
        hr = OnAddDomainEncryptedDataRecoveryAgent (pDataObject);
        break;

    case IDM_CREATE_DOMAIN_ENCRYPTED_RECOVERY_AGENT:
        hr = OnEnroll (pDataObject, true, false);   // do not show UI
        break;

    case IDM_NEW_ACRS:
        hr = OnNewACRS (pDataObject);
        break;

    case IDM_SAFER_LEVEL_SET_DEFAULT:
        hr = OnSetSaferLevelDefault (pDataObject);
        break;

    case IDM_SAFER_NEW_ENTRY_PATH:
    case IDM_SAFER_NEW_ENTRY_HASH:
    case IDM_SAFER_NEW_ENTRY_CERTIFICATE:
    case IDM_SAFER_NEW_ENTRY_INTERNET_ZONE:
        hr = OnNewSaferEntry (nCommandID, pDataObject);
        break;

    case IDM_TOP_CREATE_NEW_SAFER_POLICY:
    case IDM_TASK_CREATE_NEW_SAFER_POLICY:
        hr = OnCreateNewSaferPolicy (pDataObject);
        break;

    case IDM_TOP_DELETE_NEW_SAFER_POLICY:
    case IDM_TASK_DELETE_NEW_SAFER_POLICY:
        hr = OnDeleteSaferPolicy (pDataObject);
        break;

    case -1:    // Received on forward/back buttons from toolbar
        break;

    default:
        ASSERT (0);
        break;
    }

    _TRACE (-1, L"Leaving CCertMgrComponentData::Command: 0x%x\n", hr);
    return hr;
}

HRESULT CCertMgrComponentData::OnNewACRS (LPDATAOBJECT pDataObject)
{
    _TRACE (1, L"Entering CCertMgrComponentData::OnNewACRS\n");
    ASSERT (pDataObject);
    if ( !pDataObject )
        return E_POINTER;
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    HRESULT         hr = S_OK;
    CCertMgrCookie* pCookie = ConvertCookie (pDataObject);
    ASSERT (pCookie);
    if ( pCookie )
    {
        if ( CERTMGR_LOG_STORE_GPE == pCookie->m_objecttype )
        {
            CCertStoreGPE* pStore = reinterpret_cast <CCertStoreGPE*> (pCookie);
            ASSERT (pStore);
            if ( pStore )
            {
                HWND    hwndConsole = 0;
                hr = m_pConsole->GetMainWindow (&hwndConsole);
                ASSERT (SUCCEEDED (hr));
                if ( SUCCEEDED (hr) )
                {
                    ACRSWizardPropertySheet sheet (pStore, NULL);

                    ACRSWizardWelcomePage   welcomePage;
                    ACRSWizardTypePage      typePage;
                    ACRSCompletionPage      completionPage;
 
                    sheet.AddPage (&welcomePage);
                    sheet.AddPage (&typePage);
                    sheet.AddPage (&completionPage);
 
                    if ( sheet.DoWizard (hwndConsole) )
                    {
                        pStore->SetDirty ();
                        hr = m_pConsole->UpdateAllViews (pDataObject, 0, 0);
                        ASSERT (SUCCEEDED (hr));
                    }
                }
            }
            else
                hr = E_UNEXPECTED;
        }
        else
            hr = E_UNEXPECTED;
 
    }
    else
        hr = E_UNEXPECTED;
 
    _TRACE (-1, L"Leaving CCertMgrComponentData::OnNewACRS: 0x%x\n", hr);
    return hr;
}


HRESULT CCertMgrComponentData::RefreshScopePane (LPDATAOBJECT pDataObject)
{
    _TRACE (1, L"Entering CCertMgrComponentData::RefreshScopePane\n");
    HRESULT hr = S_OK;
    CCertMgrCookie* pCookie = 0;
    
    if ( pDataObject )
        pCookie = ConvertCookie (pDataObject);
    if ( !pDataObject || pCookie )
    {
        // If m_hRootScopeItem is NULL, then this is an extension and we don't want to go in here.
        if ( !pDataObject || (m_hRootScopeItem && pCookie->m_hScopeItem == m_hRootScopeItem) )
        {
            hr = DeleteScopeItems ();
            ASSERT (SUCCEEDED (hr));
            if ( 1 ) //SUCCEEDED (hr) )
            {
                GUID    guid;
                hr = ExpandScopeNodes (m_pRootCookie, m_hRootScopeItem, 
                        _T (""), 0, guid);
            }
            else if ( E_UNEXPECTED == hr )
            {
                ASSERT (0);
            }
            else if ( E_INVALIDARG == hr )
            {
                ASSERT (0);
            }

        }
        else
        {
            switch (pCookie->m_objecttype)
            {
            case CERTMGR_LOG_STORE_GPE:
            case CERTMGR_LOG_STORE_RSOP:
            case CERTMGR_USAGE:
            case CERTMGR_LOG_STORE:
            case CERTMGR_PHYS_STORE:
            case CERTMGR_CRL_CONTAINER:
            case CERTMGR_CTL_CONTAINER:
            case CERTMGR_CERT_CONTAINER:
                hr = DeleteChildren (pCookie->m_hScopeItem);
                break;

            default:
                break;
            }
        }
    }
    _TRACE (-1, L"Leaving CCertMgrComponentData::RefreshScopePane: 0x%x\n", hr);
    return hr;
}


HRESULT CCertMgrComponentData::ExpandScopeNodes (
        CCertMgrCookie* pParentCookie,
        HSCOPEITEM      hParent,
        const CString&  strServerName,
        DWORD           dwLocation,
        const GUID&     guidObjectType)
{
    _TRACE (1, L"Entering CCertMgrComponentData::ExpandScopeNodes\n");
    ASSERT (hParent);
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    CWaitCursor waitCursor;
    HRESULT     hr = S_OK;

    if ( pParentCookie )
    {
        CString     objectName;

        switch ( pParentCookie->m_objecttype )
        {
            // These node types have no children yet
            case CERTMGR_SNAPIN:
                // We don't expect the handle of the root scope item to change, ever!
                ASSERT ( m_hRootScopeItem ? (m_hRootScopeItem == hParent) : 1);
                if ( !m_hRootScopeItem )
                    m_hRootScopeItem = hParent;

                switch (m_activeViewPersist)
                {
                case IDM_USAGE_VIEW:
                    hr = AddUsagesToScopePane (hParent, *pParentCookie);
                    break;

                case IDM_STORE_VIEW:
                    hr = AddLogicalStoresToScopePane (hParent, *pParentCookie);
                    break;

                default:
                    ASSERT (0);
                    hr = E_UNEXPECTED;
                    break;
                }
                break;

            // This node type has no children
            case CERTMGR_USAGE:
            case CERTMGR_CRL_CONTAINER:
            case CERTMGR_CTL_CONTAINER:
            case CERTMGR_CERT_CONTAINER:
                break;

            case CERTMGR_PHYS_STORE:
                // Create one each of a CRL_CONTAINER node, CTL_CONTAINER 
                // node and CERT container node.
                hr = AddContainersToScopePane (hParent, *pParentCookie, 
                        false);
                break;

            case CERTMGR_LOG_STORE_RSOP:
            case CERTMGR_LOG_STORE_GPE:
                // This is the Group Policy Editor extension
                // This node type has no children
                break;

            case CERTMGR_LOG_STORE:
                if ( m_bShowPhysicalStoresPersist )
                {   
                    SPECIAL_STORE_TYPE  storeType = NO_SPECIAL_TYPE;
                    CCertStore* pCertStoreCookie =
                            reinterpret_cast <CCertStore*> (pParentCookie);
                    ASSERT (pCertStoreCookie);
                    if ( pCertStoreCookie )
                        storeType = pCertStoreCookie->GetStoreType ();
                    hr = AddPhysicalStoresToScopePane (hParent, *pParentCookie,
                            storeType);
                }
                else
                {
                    // Create one each of a CRL_CONTAINER node, CTL_CONTAINER 
                    // node and CERT container node.
                    hr = AddContainersToScopePane (hParent, *pParentCookie, 
                            false);
                }
                break;

            case CERTMGR_CERT_POLICIES_USER:
                // Don't add these nodes for local machine policy
                if ( SCE_MODE_LOCAL_COMPUTER != m_dwSCEMode )
                {
                    // Add "Trusted Certificate Authorities"
                    VERIFY (objectName.LoadString (IDS_CERTIFICATE_TRUST_LISTS));

                    if ( SUCCEEDED (hr) )
                    {
                        if ( m_pGPEInformation )
                        {
                            hr = AddScopeNode (new CCertStoreGPE (
                                    CERT_SYSTEM_STORE_RELOCATE_FLAG,
                                    _T (""),
                                     (PCWSTR) objectName,
                                    TRUST_SYSTEM_STORE_NAME,
                                    _T (""),
                                    m_pGPEInformation,
                                    NODEID_User,
                                    m_pConsole),
                                    strServerName,
                                    hParent);
                        }
                        else if ( m_pRSOPInformationUser )
                        {
                            hr = AddScopeNode (new CCertStoreRSOP (
                                    CERT_SYSTEM_STORE_RELOCATE_FLAG,
                                    _T (""),
                                     (PCWSTR) objectName,
                                    TRUST_SYSTEM_STORE_NAME,
                                    _T (""),
                                    m_rsopObjectArrayUser,
                                    NODEID_User,
                                    m_pConsole),
                                    strServerName,
                                    hParent);
                        }
                    }
                }
                break;

            case CERTMGR_CERT_POLICIES_COMPUTER:
                // Add only this node for local machine policy
                // Add "Encrypting File System"
                
                VERIFY (objectName.LoadString (IDS_ENCRYPTING_FILE_SYSTEM_NODE_NAME));

                if ( m_pGPEInformation )
                {
                    hr = AddScopeNode (new CCertStoreGPE (
                            CERT_SYSTEM_STORE_RELOCATE_FLAG,
                            _T (""),
                             (PCWSTR) objectName,
                            EFS_SYSTEM_STORE_NAME,
                            _T (""),
                            m_pGPEInformation,
                            NODEID_Machine,
                            m_pConsole),
                            strServerName,
                            hParent);
                }
                else if ( m_pRSOPInformationComputer )
                {
                    hr = AddScopeNode (new CCertStoreRSOP (
                            CERT_SYSTEM_STORE_RELOCATE_FLAG,
                            _T (""),
                             (PCWSTR) objectName,
                            EFS_SYSTEM_STORE_NAME,
                            _T (""),
                            m_rsopObjectArrayComputer,
                            NODEID_Machine,
                            m_pConsole),
                            strServerName,
                            hParent);
                }

                if ( SCE_MODE_LOCAL_COMPUTER != m_dwSCEMode )
                {
                    // Add these policies if this is the domain policy
                    if ( SUCCEEDED (hr) )
                    {
                        // Add "Automatic Certificate Request Settings"
                        VERIFY (objectName.LoadString (IDS_AUTOMATIC_CERT_REQUEST_SETTINGS_NODE_NAME));
                        if ( m_pGPEInformation )
                        {
                            m_pGPEACRSComputerStore = new CCertStoreGPE (
                                        CERT_SYSTEM_STORE_RELOCATE_FLAG,
                                        _T (""),
                                         (PCWSTR) objectName,
                                        ACRS_SYSTEM_STORE_NAME,
                                        _T (""),
                                        m_pGPEInformation,
                                        NODEID_Machine,
                                        m_pConsole);
                        }
                        else if ( m_pRSOPInformationComputer )
                        {
                            m_pGPEACRSComputerStore = new CCertStoreRSOP (
                                    CERT_SYSTEM_STORE_RELOCATE_FLAG,
                                    _T (""),
                                     (PCWSTR) objectName,
                                    ACRS_SYSTEM_STORE_NAME,
                                    _T (""),
                                    m_rsopObjectArrayComputer,
                                    NODEID_Machine,
                                    m_pConsole);
                        }
                        if ( m_pGPEACRSComputerStore )
                        {
                            m_pGPEACRSComputerStore->AddRef ();
                            hr = AddScopeNode (m_pGPEACRSComputerStore,
                                    strServerName, hParent);
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }


                    if ( SUCCEEDED (hr) )
                    {
                        // Add "Domain Root Certificate Authorities"
                        VERIFY (objectName.LoadString (IDS_DOMAIN_ROOT_CERT_AUTHS_NODE_NAME));

                        ASSERT (!m_pGPERootStore);
                        if ( m_pGPEInformation )
                        {
                            m_pGPERootStore = new CCertStoreGPE (
                                    CERT_SYSTEM_STORE_RELOCATE_FLAG,
                                    _T (""),
                                     (PCWSTR) objectName,
                                    ROOT_SYSTEM_STORE_NAME,
                                    _T (""),
                                    m_pGPEInformation,
                                    NODEID_Machine,
                                    m_pConsole);
                        }
                        else if ( m_pRSOPInformationComputer )
                        {
                            m_pGPERootStore = new CCertStoreRSOP (
                                    CERT_SYSTEM_STORE_RELOCATE_FLAG,
                                    _T (""),
                                     (PCWSTR) objectName,
                                    ROOT_SYSTEM_STORE_NAME,
                                    _T (""),
                                    m_rsopObjectArrayComputer,
                                    NODEID_Machine,
                                    m_pConsole);
                        }

                        if ( m_pGPERootStore )
                        {
                            m_pGPERootStore->AddRef ();
                            hr = AddScopeNode (m_pGPERootStore,
                                    strServerName, hParent);
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }

                    if ( SUCCEEDED (hr) )
                    {
                        // Add "Trusted Certificate Authorities"
                        VERIFY (objectName.LoadString (IDS_CERTIFICATE_TRUST_LISTS));

                        ASSERT (!m_pGPETrustStore);
                        if ( m_pGPEInformation )
                        {
                            m_pGPETrustStore = new CCertStoreGPE (
                                    CERT_SYSTEM_STORE_RELOCATE_FLAG,
                                    _T (""),
                                     (PCWSTR) objectName,
                                    TRUST_SYSTEM_STORE_NAME,
                                    _T (""),
                                    m_pGPEInformation,
                                    NODEID_Machine,
                                    m_pConsole);
                        }
                        else if ( m_pRSOPInformationComputer )
                        {
                            m_pGPETrustStore = new CCertStoreRSOP (
                                    CERT_SYSTEM_STORE_RELOCATE_FLAG,
                                    _T (""),
                                     (PCWSTR) objectName,
                                    TRUST_SYSTEM_STORE_NAME,
                                    _T (""),
                                    m_rsopObjectArrayComputer,
                                    NODEID_Machine,
                                    m_pConsole);
                        }
                        if ( m_pGPETrustStore )
                        {
                            m_pGPETrustStore->AddRef ();
                            hr = AddScopeNode (m_pGPETrustStore,
                                    strServerName, hParent);
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }
                }
                break;

            case CERTMGR_SAFER_COMPUTER_ROOT:
            case CERTMGR_SAFER_USER_ROOT:
                {
                    CSaferRootCookie* pSaferRootCookie = 
                            dynamic_cast <CSaferRootCookie*> (pParentCookie);
                    if ( pSaferRootCookie )
                    {
                        pSaferRootCookie->m_bExpandedOnce = true;
                        bool bIsComputer = 
                                (CERTMGR_SAFER_COMPUTER_ROOT == pParentCookie->m_objecttype);
                        if ( !m_bIsRSOP )
                        {
                            // Find out if Safer is supported by the OS
                            m_bSaferSupported = false;
                            SAFER_LEVEL_HANDLE hLevel = 0;
                            CPolicyKey policyKey (m_pGPEInformation, 
                                    SAFER_HKLM_REGBASE, 
                                    CERTMGR_SAFER_COMPUTER_ROOT == pParentCookie->m_objecttype);
                            SetRegistryScope (policyKey.GetKey (), 
                                    CERTMGR_SAFER_COMPUTER_ROOT == pParentCookie->m_objecttype);

                            BOOL  bRVal = SaferCreateLevel (SAFER_SCOPEID_REGISTRY,
                                    SAFER_LEVELID_FULLYTRUSTED,
                                    SAFER_LEVEL_OPEN,
                                    &hLevel,
                                    policyKey.GetKey ());
                            if ( bRVal )
                            {
                                m_bSaferSupported = true;
                                VERIFY (SaferCloseLevel (hLevel));
                            }
                            else
                            {
                                DWORD dwErr = GetLastError ();
                                _TRACE (0, L"SaferCreateLevel () failed: 0x%x\n", dwErr);
                            }

                            // Install default file types
                            if ( m_bSaferSupported && m_pGPEInformation )
                            {
                                HKEY    hGroupPolicyKey = 0;
                                hr = m_pGPEInformation->GetRegistryKey (
                                        bIsComputer ? 
                                        GPO_SECTION_MACHINE : GPO_SECTION_USER,
                                        &hGroupPolicyKey);
                                if ( SUCCEEDED (hr) )
                                {
                                    // Check to see if safer defaults have already 
                                    // been defined.  If not, prompt the user
                                    // for confirmation.  If the response is "no"
                                    // then do not create the nodes
                                    PCWSTR pszKeyName = bIsComputer ? 
                                            SAFER_COMPUTER_CODEIDS_REGKEY :
                                            SAFER_USER_CODEIDS_REGKEY;

                                    HKEY hCodeIDsKey = 0;
                                    LONG lResult = RegOpenKeyEx (hGroupPolicyKey,
                                            pszKeyName, 0, KEY_READ, &hCodeIDsKey);
                                    if ( ERROR_FILE_NOT_FOUND == lResult )
                                    {
                                        pSaferRootCookie->m_bCreateSaferNodes = false;
                                        ::RegCloseKey (hGroupPolicyKey);
                                        break;
                                    }
                                    else if ( hCodeIDsKey )
                                    {
                                        ::RegCloseKey (hCodeIDsKey);
                                        hCodeIDsKey = 0;
                                    }
                                    ::RegCloseKey (hGroupPolicyKey);
                                }
                            }
                        }

                        if ( m_bSaferSupported || m_bIsRSOP )
                        {
                            // Add "Levels" node
                            VERIFY (objectName.LoadString (IDS_SAFER_LEVELS_NODE_NAME));
                            hr = AddScopeNode (new CCertMgrCookie (
                                    bIsComputer ?
                                        CERTMGR_SAFER_COMPUTER_LEVELS : CERTMGR_SAFER_USER_LEVELS,
                                    0,
                                    (PCWSTR) objectName), strServerName, hParent);

                            // Add "Entries" node
                            if ( SUCCEEDED (hr) )
                            {
                                VERIFY (objectName.LoadString (IDS_SAFER_ENTRIES_NODE_NAME));
                                hr = AddScopeNode (new CSaferEntries (
                                        bIsComputer,
                                        strServerName, 
                                        objectName, 
                                        m_pGPEInformation, 
                                        bIsComputer ? m_pRSOPInformationComputer : m_pRSOPInformationUser, 
                                        bIsComputer ? m_rsopObjectArrayComputer : m_rsopObjectArrayUser,
                                        m_pConsole), 
                                        strServerName, hParent);

                                if ( SUCCEEDED (hr) )
                                {
                                    hr = SaferEnumerateLevels (bIsComputer);
                                }
                            }
                        }
                    }
                }
                break;

            case CERTMGR_SAFER_COMPUTER_LEVELS:
                break;

            case CERTMGR_SAFER_USER_LEVELS:
                // TODO: Enumerate user levels
                break;

            case CERTMGR_SAFER_COMPUTER_ENTRIES:
                // TODO: Enumerate computer entries
                break;

            case CERTMGR_SAFER_USER_ENTRIES:
                // TODO: Enumerate user entries
                break;

            case CERTMGR_CERTIFICATE:  // not expected in scope pane
            case CERTMGR_CRL:
            case CERTMGR_CTL:
            case CERTMGR_AUTO_CERT_REQUEST:
            case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
            case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
                ASSERT (0);
                hr = E_UNEXPECTED;
                break;

            default:
                _TRACE (0, L"CCertMgrComponentData::EnumerateScopeChildren bad parent type\n");
                ASSERT (0);
                hr = S_OK;
                break;
        }
    }
    else
    {
        // If parentCookie not passed in, then this is an extension snap-in
        m_dwLocationPersist = dwLocation;


        if ( m_pGPEInformation || m_pRSOPInformationComputer || m_pRSOPInformationUser )
        {
            CString objectName;


            if ( ::IsEqualGUID (guidObjectType, NODEID_Machine) )
            {
                if ( SUCCEEDED (hr) )
                {
                    CLSID classID;  
                    GetClassID (&classID);
                    
                    if ( ::IsEqualGUID (classID, CLSID_CertificateManagerPKPOLExt) )
                    {
                        // Add "Public Key Policies" node
                        VERIFY (objectName.LoadString (IDS_PUBLIC_KEY_POLICIES_NODE_NAME));
                        hr = AddScopeNode (new CCertMgrCookie (
                                CERTMGR_CERT_POLICIES_COMPUTER,
                                0,
                                (PCWSTR) objectName), 
                                strServerName, hParent);
                    }
                    else if ( ::IsEqualGUID (classID, CLSID_SaferWindowsExtension) )
                    {
                        // Add "Software Restriction Policies" node
                        VERIFY (objectName.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
                        hr = AddScopeNode (new CSaferRootCookie (
                                CERTMGR_SAFER_COMPUTER_ROOT,
                                0,
                                (PCWSTR) objectName), 
                                strServerName, hParent);
                    }
                }

            }
            else if ( ::IsEqualGUID (guidObjectType, NODEID_User) )
            {
                if ( SUCCEEDED (hr) )
                {
                    CLSID classID;  
                    GetClassID (&classID);
                    
                    if ( ::IsEqualGUID (classID, CLSID_CertificateManagerPKPOLExt) )
                    {
                        // Add "Public Key Policies" node
                        VERIFY (objectName.LoadString (IDS_PUBLIC_KEY_POLICIES_NODE_NAME));
                        hr = AddScopeNode (new CCertMgrCookie (
                                CERTMGR_CERT_POLICIES_USER,
                                0,
                                (PCWSTR) objectName), strServerName, hParent);
                    }
                    else if ( ::IsEqualGUID (classID, CLSID_SaferWindowsExtension) )
                    {
                        if ( SCE_MODE_LOCAL_USER != m_dwSCEMode )
                        {
                            // Add "Software Restriction Policies" node
                            VERIFY (objectName.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
                            hr = AddScopeNode (new CSaferRootCookie (
                                    CERTMGR_SAFER_USER_ROOT,
                                    0,
                                    (PCWSTR) objectName), strServerName, hParent);
                        }
                    }
                }
            }
        }
   }

    _TRACE (-1, L"Leaving CCertMgrComponentData::ExpandScopeNodes: 0x%x\n", hr);
    return hr;
}


HRESULT CCertMgrComponentData::DeleteScopeItems (HSCOPEITEM hScopeItem /* = 0 */)
{
    _TRACE (1, L"Entering CCertMgrComponentData::DeleteScopeItems\n");
    HRESULT hr = S_OK;

    if ( m_pGPERootStore )
    {
        m_pGPERootStore->Release ();
        m_pGPERootStore = 0;
    }

    if ( m_pGPETrustStore )
    {
        m_pGPETrustStore->Release ();
        m_pGPETrustStore = 0;
    }

    if ( m_pGPEACRSComputerStore )
    {
        m_pGPEACRSComputerStore->Release ();
        m_pGPEACRSComputerStore = 0;
    }

    if ( m_pGPEACRSUserStore )
    {
        m_pGPEACRSUserStore->Release ();
        m_pGPEACRSUserStore = 0;
    }

    if ( m_pFileBasedStore )
    {
        m_pFileBasedStore->Release ();
        m_pFileBasedStore = 0;
    }

    hr = DeleteChildren (hScopeItem ? hScopeItem : m_hRootScopeItem);

    _TRACE (-1, L"Leaving CCertMgrComponentData::DeleteScopeItems: 0x%x\n", hr);
    return hr;
}


HRESULT CCertMgrComponentData::DeleteChildren (HSCOPEITEM hParent)
{
    _TRACE (1, L"Entering CCertMgrComponentData::DeleteChildren\n");
    if ( !hParent )
        return S_OK;

    HSCOPEITEM      hChild = 0;
    HSCOPEITEM      hNextChild = 0;
    MMC_COOKIE      lCookie = 0;
    CCertMgrCookie* pCookie = 0;
    HRESULT         hr = S_OK;
    CCookie&        rootCookie = QueryBaseRootCookie ();

    // Optimization:  If we're deleting everything below the root, free all
    // the result items here so we don't have to go looking for them later by
    // store
    if ( hParent == m_hRootScopeItem )
    {
        LPRESULTDATA    pResultData = 0;
        hr = GetResultData (&pResultData);
        if ( SUCCEEDED (hr) )
        {
            hr = pResultData->DeleteAllRsltItems ();
            if ( SUCCEEDED (hr) || E_UNEXPECTED == hr ) // returns E_UNEXPECTED if console shutting down
            {
                RemoveResultCookies (pResultData);
            }
            else
            {
                _TRACE (0, L"IResultData::DeleteAllRsltItems () failed: 0x%x\n", hr);        
            }
            pResultData->Release ();
        }
    }


    hr = m_pConsoleNameSpace->GetChildItem (hParent, &hChild, &lCookie);
    ASSERT (SUCCEEDED (hr) || E_FAIL == hr);    // appears to return E_FAIL when there are no children
    while ( SUCCEEDED (hr) && hChild )
    {
        pCookie = reinterpret_cast <CCertMgrCookie*> (lCookie);

        hr = DeleteChildren (hChild);
        if ( !SUCCEEDED (hr) )
            break;

        hNextChild = 0;
        hr = m_pConsoleNameSpace->GetNextItem (hChild, &hNextChild, &lCookie);
        ASSERT (SUCCEEDED (hr));

        hr = m_pConsoleNameSpace->DeleteItem (hChild, TRUE);
        ASSERT (SUCCEEDED (hr));

        switch (pCookie->m_objecttype)
        {
        case CERTMGR_LOG_STORE:
        case CERTMGR_LOG_STORE_GPE:
        case CERTMGR_LOG_STORE_RSOP:
        case CERTMGR_PHYS_STORE:
            {
                // If this is a store, delete all the result nodes that belong to this
                // store.  We can tell if objects were enumerated from this store simply
                // by comparing the store handles.
                CCertStore* pStore = reinterpret_cast <CCertStore*> (pCookie);
                ASSERT (pStore);
                if ( pStore )
                {
                    // If the store is not 'open' (it's HCERTSTORE handle is still '0')
                    // then we can skip checking this list.  We haven't enumerated anything
                    // in this store.
                    if ( pStore->IsOpen () )
                    {
                        POSITION            pos1 = 0;
                        POSITION            pos2 = 0;
                        CBaseCookieBlock*   pResultCookie = 0;
                        HCERTSTORE          hStoreHandle = pStore->GetStoreHandle ();

                        // As an optimization, if DeleteChildren was originally called with
                        // the root scope item, all the result cookies have already been
                        // deleted since we're going to delete them all anyway.
                        for (pos1 = rootCookie.m_listResultCookieBlocks.GetHeadPosition();
                            (pos2 = pos1) != NULL; )
                        {
                            pResultCookie = rootCookie.m_listResultCookieBlocks.GetNext (pos1);
                            ASSERT (pResultCookie);
                            if ( pResultCookie )
                            {
                                hr = ReleaseResultCookie (pResultCookie,
                                        rootCookie, hStoreHandle, pos2);
                            }
                        }                       
                        pStore->Close ();
                    }
                }
            }
            // fall through

        case CERTMGR_CRL_CONTAINER:
        case CERTMGR_CTL_CONTAINER:
        case CERTMGR_CERT_CONTAINER:
        case CERTMGR_USAGE:
        case CERTMGR_SAFER_COMPUTER_ENTRIES:
        case CERTMGR_SAFER_USER_ENTRIES:
            {
                POSITION            pos1 = 0;
                POSITION            pos2 = 0;
                CBaseCookieBlock*   pResultCookie = 0;

                // Find and remove this cookie from the scope cookie list
                for (pos1 = rootCookie.m_listScopeCookieBlocks.GetHeadPosition();
                    pos1 != NULL; )
                {
                    pos2 = pos1;
                    pResultCookie = rootCookie.m_listScopeCookieBlocks.GetNext (pos1);
                    ASSERT (pResultCookie);
                    if ( pResultCookie )
                    {
                        if ( pResultCookie->QueryBaseCookie (0) == pCookie )
                        {
                            rootCookie.m_listScopeCookieBlocks.RemoveAt (pos2);
                            pResultCookie->Release ();
                            break;
                        }
                    }
                }                       
            }
            break;

        default:
            break;
        }

        hChild = hNextChild;
    }


    _TRACE (-1, L"Leaving CCertMgrComponentData::DeleteChildren: 0x%x\n", hr);
    return hr;
}


CertificateManagerObjectType CCertMgrComponentData::GetObjectType (LPDATAOBJECT pDataObject)
{
    _TRACE (1, L"Entering CCertMgrComponentData::GetObjectType\n");
    CertificateManagerObjectType    objType = CERTMGR_INVALID;

    ASSERT (pDataObject);
    CCertMgrCookie* pCookie = ConvertCookie (pDataObject);
    if ( ((CCertMgrCookie*) MMC_MULTI_SELECT_COOKIE) == pCookie )
        objType = CERTMGR_MULTISEL;
    else if ( pCookie )
        objType = pCookie->m_objecttype;

    _TRACE (-1, L"Leaving CCertMgrComponentData::GetObjectType\n");
    return objType;
}



HRESULT CCertMgrComponentData::OnPulseAutoEnroll()
{
    _TRACE (1, L"Entering CCertMgrComponentData::OnPulseAutoEnroll\n");
    HRESULT hr = S_OK;
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());

        HANDLE hEvent = NULL;
        LPWSTR wszEventName;

        
        // pulse autoenroll event here, choose between machine or user
        
        // user or machine pulse?
        wszEventName = L"Global\\" MACHINE_AUTOENROLLMENT_TRIGGER_EVENT;
        if (CERT_SYSTEM_STORE_CURRENT_USER == m_dwLocationPersist)
            wszEventName = USER_AUTOENROLLMENT_TRIGGER_EVENT;
        
        hEvent=OpenEvent(EVENT_MODIFY_STATE, false, wszEventName);
        if (NULL==hEvent) 
        {
            DWORD dwErr = GetLastError();

            CString text;
            CString caption;

            VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
            text.FormatMessage (IDS_CANT_OPEN_AUTOENROLL_EVENT, GetSystemMessage (dwErr));

            int     iRetVal = 0;
            VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption, MB_OK, &iRetVal)));

            hr=HRESULT_FROM_WIN32(dwErr);
            _TRACE (0, L"OpenEvent(%s) failed with 0x%08X.\n", wszEventName, hr);
            goto error;
        }
        
        if (!SetEvent(hEvent)) 
        {
            DWORD dwErr = GetLastError();
            DisplaySystemError (dwErr);
            hr=HRESULT_FROM_WIN32(dwErr);
            _TRACE (0, L"SetEvent failed with 0x%08X.\n", hr);
            goto error;
        }


error:
      if (NULL!=hEvent) 
         CloseHandle(hEvent);

    _TRACE (-1, L"Leaving CCertMgrComponentData::OnPulseAutoEnroll: 0x%x\n", hr);
    return hr;
}

HRESULT CCertMgrComponentData::OnFind (LPDATAOBJECT pDataObject)
{
    _TRACE (1, L"Entering CCertMgrComponentData::OnFind\n");
    HRESULT hr = S_OK;
    ASSERT (pDataObject);
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    HWND        hParent = 0;


    ASSERT (pDataObject);
    CCertMgrCookie* pParentCookie = ConvertCookie (pDataObject);
    if ( pParentCookie )
    {
        switch (pParentCookie->m_objecttype)
        {
        case CERTMGR_SNAPIN:
        case CERTMGR_PHYS_STORE:
        case CERTMGR_LOG_STORE:
        case CERTMGR_LOG_STORE_GPE:
        case CERTMGR_LOG_STORE_RSOP:
        case CERTMGR_USAGE:
            {
                // Get parent window handle and attach to a CWnd object
                hr = m_pConsole->GetMainWindow (&hParent);
                ASSERT (SUCCEEDED (hr));
                if ( SUCCEEDED (hr) )
                {
                    CWnd    parentWnd;
                    VERIFY (parentWnd.Attach (hParent));
                    CFindDialog findDlg (&parentWnd,
                            pParentCookie->QueryNonNULLMachineName (),
                            m_szFileName,
                            this);
                    CThemeContextActivator activator;
                    INT_PTR iReturn = findDlg.DoModal ();
                    ASSERT (-1 != iReturn && IDABORT != iReturn);
                    if ( -1 == iReturn || IDABORT == iReturn )
                        hr = E_UNEXPECTED;
                    else
                    {
                        if ( findDlg.ConsoleRefreshRequired () )
                        {
                            hr = m_pConsole->UpdateAllViews (pDataObject, 0, 
                                    HINT_REFRESH_STORES);
                        }
                    }

                    parentWnd.Detach ();

                    
                }
            }
            break;

        case CERTMGR_CERTIFICATE:
        case CERTMGR_CRL:
        case CERTMGR_CTL:
        case CERTMGR_AUTO_CERT_REQUEST:
            ASSERT (0);
            hr = E_UNEXPECTED;
            break;

        case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
        case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
            ASSERT (0);
            break;

        case CERTMGR_CRL_CONTAINER:
        case CERTMGR_CTL_CONTAINER:
        case CERTMGR_CERT_CONTAINER:
            break;

        default:
            ASSERT (0);
            hr = E_UNEXPECTED;
        }
    }

    _TRACE (-1, L"Leaving CCertMgrComponentData::OnFind: 0x%x\n", hr);
    return hr;
}

HRESULT CCertMgrComponentData::OnChangeComputer (LPDATAOBJECT pDataObject)
{
    if ( !pDataObject )
        return E_POINTER;

    _TRACE (1, L"Entering CCertMgrComponentData::OnChangeComputer\n");
    HRESULT hr = S_OK;
    ASSERT (pDataObject);
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());


    ASSERT (pDataObject);
    CCertMgrCookie* pParentCookie = ConvertCookie (pDataObject);
    if ( pParentCookie && CERTMGR_SNAPIN == pParentCookie->m_objecttype )
    {
        HWND    hWndParent = NULL;
        hr = m_pConsole->GetMainWindow (&hWndParent);
        CString machineName;
        hr = ComputerNameFromObjectPicker (hWndParent, machineName);
        if ( S_OK == hr )  // S_FALSE means user pressed "Cancel"
        {
            machineName.MakeUpper ();

            // added IsLocalComputername 1/27/99 JonN
            // If the user chooses the local computer, treat that as if they had chosen
            // "Local Computer" in Snapin Manager.  This means that there is no way to
            // reset the snapin to target explicitly at this computer without either
            // reloading the snapin from Snapin Manager, or going to a different computer.
            // When the Choose Target Computer UI is revised, we can make this more
            // consistent with Snapin Manager.
            if ( IsLocalComputername( machineName ) )
                machineName = L"";

            QueryRootCookie().SetMachineName (machineName);

            // Set the persistent name.  If we are managing the local computer
            // this name should be empty.
            m_strMachineNamePersist = machineName;

            hr = ChangeRootNodeName (machineName);
            if ( SUCCEEDED(hr) )
            {
                hr = m_pConsole->UpdateAllViews (pDataObject, 0, HINT_CHANGE_COMPUTER);
            }
        }
    }
    else
        hr = E_UNEXPECTED;


    _TRACE (-1, L"Leaving CCertMgrComponentData::OnChangeComputer: 0x%x\n", hr);
    return hr;
}


HRESULT CCertMgrComponentData::IsUserAdministrator (BOOL & bIsAdministrator)
{
    _TRACE (1, L"Entering CCertMgrComponentData::IsUserAdministrator\n");
    HRESULT hr = S_OK;
    DWORD   dwErr = 0;

    bIsAdministrator = FALSE;
    if ( IsWindowsNT () )
    {
        PSID                        psidAdministrators;
        SID_IDENTIFIER_AUTHORITY    siaNtAuthority = SECURITY_NT_AUTHORITY;

        // security review 2/26/2002 BryanWal ok
        BOOL bResult = ::AllocateAndInitializeSid (&siaNtAuthority, 2,
                SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
                0, 0, 0, 0, 0, 0, &psidAdministrators);
        if ( bResult )
        {
            bResult = CheckTokenMembership (0, psidAdministrators,
                    &bIsAdministrator);
            ASSERT (bResult);
            if ( !bResult )
            {
                dwErr = GetLastError ();
                DisplaySystemError (dwErr);
                hr = HRESULT_FROM_WIN32 (dwErr);
            }
            FreeSid (psidAdministrators);
        }
        else
        {
            dwErr = GetLastError ();
            DisplaySystemError (dwErr);
            hr = HRESULT_FROM_WIN32 (dwErr);
        }
    }

    _TRACE (-1, L"Leaving CCertMgrComponentData::IsUserAdministrator: 0x%x\n", hr);
    return hr;
}


void CCertMgrComponentData::DisplaySystemError (DWORD dwErr)
{
    _TRACE (1, L"Entering CCertMgrComponentData::DisplaySystemError\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    LPVOID lpMsgBuf;
    
    // security review 2/26/2002 BryanWal ok - message is from system
    ::FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            dwErr,
            MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
             (PWSTR) &lpMsgBuf,    0,    NULL );
        
    // Display the string.
    CString caption;
    VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
    int     iRetVal = 0;
    if ( m_pConsole )
    {
        HRESULT hr = m_pConsole->MessageBox ( (PWSTR) lpMsgBuf, caption,
            MB_ICONWARNING | MB_OK, &iRetVal);
        ASSERT (SUCCEEDED (hr));
    }
    else
    {
        CThemeContextActivator activator;
        ::MessageBox (NULL, (PWSTR) lpMsgBuf, caption, MB_ICONWARNING | MB_OK);
    }
    // Free the buffer.
    LocalFree (lpMsgBuf);
    _TRACE (-1, L"Leaving CCertMgrComponentData::DisplaySystemError\n");
}

CString CCertMgrComponentData::GetCommandLineFileName () const
{
    _TRACE (0, L"Entering and leaving CCertMgrComponentData::GetCommandLineFileName\n");
    return m_szFileName;
}

//
// GetManagedComputer ()
//
// Returns the name of the managed computer.  If we are managing the local machine
// returns an empty string. (As required by a number of Crypt32 APIs
//
CString CCertMgrComponentData::GetManagedComputer () const
{
    _TRACE (0, L"Entering and leaving CCertMgrComponentData::GetManagedComputer\n");
    if ( m_szManagedComputer.CompareNoCase (m_szThisComputer) )  // !=
    {
        return m_szManagedComputer;
    }
    else
        return _T ("");
}

CString CCertMgrComponentData::GetManagedService () const
{
    _TRACE (0, L"Entering and leaving CCertMgrComponentData::GetManagedService\n");
    return m_szManagedServicePersist;
}

DWORD CCertMgrComponentData::GetLocation () const
{
    _TRACE (0, L"Entering and leaving CCertMgrComponentData::GetLocation\n");
    return m_dwLocationPersist;
}

LPCONSOLENAMESPACE CCertMgrComponentData::GetConsoleNameSpace () const
{
    _TRACE (0, L"Entering and leaving CCertMgrComponentData::GetConsoleNameSpace\n");
    return m_pConsoleNameSpace;
}


CUsageCookie* CCertMgrComponentData::FindDuplicateUsage (HSCOPEITEM hParent, PCWSTR pszName)
{
    _TRACE (1, L"Entering CCertMgrComponentData::FindDuplicateUsage\n");
    ASSERT (pszName);
    if ( !pszName )
        return 0;


    CUsageCookie*   pUsageCookie = 0;

    MMC_COOKIE      lCookie = 0;
    HSCOPEITEM      hChildItem = 0;
    bool            bFound = false;

    HRESULT hr = m_pConsoleNameSpace->GetChildItem (hParent, &hChildItem, &lCookie);
    ASSERT (SUCCEEDED (hr));
    while ( hChildItem && SUCCEEDED (hr) )
    {
        pUsageCookie = reinterpret_cast <CUsageCookie*> (lCookie);
        if ( !wcscoll (pszName, pUsageCookie->GetObjectName ()) )
        {
            bFound = true;
            break;
        }

        hr = m_pConsoleNameSpace->GetNextItem (hChildItem, &hChildItem, &lCookie);
        ASSERT (SUCCEEDED (hr));
    }

    _TRACE (-1, L"Leaving CCertMgrComponentData::FindDuplicateUsage\n");
    if ( bFound )
        return pUsageCookie;
    else
        return NULL;
}


bool CCertMgrComponentData::IsSecurityConfigurationEditorNodetype (const GUID& refguid) const
{
    _TRACE (0, L"Entering and leaving CCertMgrComponentData::IsSecurityConfigurationEditorNodetype\n");
    return ::IsEqualGUID (refguid, cNodetypeSceTemplate) ? true : false;
}


HRESULT CCertMgrComponentData::OnEnroll (
            LPDATAOBJECT pDataObject, 
            bool bNewKey, 
            bool bShowUI /* = true */)
{
    _TRACE (1, L"Entering CCertMgrComponentData::OnEnroll\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    ASSERT (pDataObject);
    if ( !pDataObject )
        return E_POINTER;

    HRESULT         hr = S_OK;
    CCertMgrCookie* pParentCookie = ConvertCookie (pDataObject);
    if ( pParentCookie )
    {
        CCertStore*     pStore = 0;
        CCertificate*   pCert = 0;
        CCertStoreGPE*  pGPEStore = 0;
        bool            bParentIsStoreOrContainer = false;
        HSCOPEITEM      hScopeItem = 0;
        bool            bEFSPolicyTurnedOn = false;

        switch (pParentCookie->m_objecttype)
        {
        case CERTMGR_CERTIFICATE:
            pCert = reinterpret_cast <CCertificate*> (pParentCookie);
            ASSERT (pCert);
            break;

        case CERTMGR_PHYS_STORE:
        case CERTMGR_LOG_STORE:
            if ( !m_pGPEInformation )  // If we are not extending the GPE/SCE
            {
                hScopeItem = pParentCookie->m_hScopeItem; // = 0;
                pStore = reinterpret_cast <CCertStore*> (pParentCookie);
                ASSERT (pStore);
            }
            bParentIsStoreOrContainer = true;
            break;

        case CERTMGR_CERT_CONTAINER:
            if ( !m_pGPEInformation )  // If we are not extending the GPE/SCE
            {
                CContainerCookie* pContainer = reinterpret_cast <CContainerCookie*> (pParentCookie);
                ASSERT (pContainer);
                if ( pContainer )
                {
                    MMC_COOKIE lCookie = 0;
                    hr = m_pConsoleNameSpace->GetParentItem (
                            pContainer->m_hScopeItem, &hScopeItem, &lCookie);
                    ASSERT (SUCCEEDED (hr));
                    pStore = &pContainer->GetCertStore ();
                }
            }
            bParentIsStoreOrContainer = true;
            break;

        case CERTMGR_USAGE:
            break;

        case CERTMGR_LOG_STORE_RSOP:
            ASSERT (0);
            return E_FAIL;
            break;

        case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
        case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
            ASSERT (0);
            break;

        case CERTMGR_LOG_STORE_GPE:
            pGPEStore = reinterpret_cast <CCertStoreGPE*> (pParentCookie);
            ASSERT (pGPEStore);
            if ( pGPEStore )
            {
                if ( pGPEStore->IsNullEFSPolicy () )
                {
                    pGPEStore->AllowEmptyEFSPolicy ();
                    bEFSPolicyTurnedOn = true;

                }
            }
            else
                return E_FAIL;
            break;

        default:
            ASSERT (0);
            return E_UNEXPECTED;
        }
        HWND            hwndParent = 0;
        hr = m_pConsole->GetMainWindow (&hwndParent);
        ASSERT (SUCCEEDED (hr));
        CRYPTUI_WIZ_CERT_REQUEST_PVK_CERT   pvkCert;
        CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW    pvkNew;
        CRYPTUI_WIZ_CERT_REQUEST_INFO       certRequestInfo;
        CRYPT_KEY_PROV_INFO                 provInfo;

        // For EFS Recovery Agent
        CRYPTUI_WIZ_CERT_TYPE               certType;
        PWSTR                               rgwszCertType = wszCERTTYPE_EFS_RECOVERY;
        
        // security review 2/26/2002 BryanWal ok
        ::ZeroMemory (&certRequestInfo, sizeof (certRequestInfo));
        certRequestInfo.dwSize = sizeof (certRequestInfo);
        certRequestInfo.dwPurpose = CRYPTUI_WIZ_CERT_ENROLL;

        // User wants to manage user account
        //  pass in NULL to machine name and to account name
        // User wants to manage local machine account
        //  pass in NULL for account name and result of ::GetComputerName ()
        //  to machine name
        // User want to manage remote machine
        //  pass in NULL for account name and machine name for machineName
        // User wants to manage remote account on remote machine
        //  pass in account name for accountName and machine name for machineName
        switch (m_dwLocationPersist)
        {
        case CERT_SYSTEM_STORE_CURRENT_SERVICE:
        case CERT_SYSTEM_STORE_SERVICES:
            certRequestInfo.pwszMachineName = (PCWSTR) m_szManagedComputer;
            certRequestInfo.pwszAccountName = (PCWSTR) m_szManagedServicePersist;
            break;

        case CERT_SYSTEM_STORE_CURRENT_USER:
            certRequestInfo.pwszMachineName = NULL;
            certRequestInfo.pwszAccountName = NULL;
            break;

        case CERT_SYSTEM_STORE_LOCAL_MACHINE:
            certRequestInfo.pwszMachineName = (PCWSTR) m_szManagedComputer;
            certRequestInfo.pwszAccountName = NULL;
            break;

        case CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY:
        case CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY:
            certRequestInfo.pwszMachineName = NULL;
            certRequestInfo.pwszAccountName = NULL;
            certRequestInfo.pwszDesStore = 0;
            certRequestInfo.dwCertOpenStoreFlag = 0;
            break;

        default:
            ASSERT (0);
            return E_UNEXPECTED;
            break;
        }


        if ( !pCert || bNewKey )
        {
            // Request a certificate with a new key
            certRequestInfo.dwPvkChoice = CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_NEW;
            // security review 2/26/2002 BryanWal ok
            ::ZeroMemory (&pvkNew, sizeof (pvkNew));
            pvkNew.dwSize = sizeof (pvkNew);
            certRequestInfo.pPvkNew = &pvkNew;
            if ( CERT_SYSTEM_STORE_LOCAL_MACHINE == m_dwLocationPersist )
            {
                // security review 2/26/2002 BryanWal ok
                ::ZeroMemory (&provInfo, sizeof (provInfo));

                provInfo.dwFlags = CRYPT_MACHINE_KEYSET;
                pvkNew.pKeyProvInfo = &provInfo;
            }

            if ( pGPEStore && EFS_STORE == pGPEStore->GetStoreType () )
            {
                // This creates an Encryption Recovery Agent.
                // security review 2/26/2002 BryanWal ok
                ::ZeroMemory (&certType, sizeof (certType));
                certType.dwSize = sizeof (CRYPTUI_WIZ_CERT_TYPE);
                certType.cCertType = 1;
                certType.rgwszCertType = &rgwszCertType;
                
                
                certRequestInfo.dwCertChoice = CRYPTUI_WIZ_CERT_REQUEST_CERT_TYPE;
                certRequestInfo.pCertType = &certType;
                // security review 2/26/2002 BryanWal ok
                ::ZeroMemory (&provInfo, sizeof (provInfo));
                provInfo.pwszProvName = MS_DEF_PROV_W;
                provInfo.dwProvType = PROV_RSA_FULL;

                pvkNew.pKeyProvInfo = &provInfo;
                pvkNew.dwGenKeyFlags = CRYPT_EXPORTABLE;
            }
        }
        else
        {
            // Request a certificate with the same key as an existing certificate
            if ( IsLocalComputername (m_szManagedComputer) )
            {
                // Find out if the cert has a private key before continuing.
                DWORD   dwFlags = 0;

                if ( CERT_SYSTEM_STORE_LOCAL_MACHINE == m_dwLocationPersist )
                    dwFlags = CRYPT_FIND_MACHINE_KEYSET_FLAG;
                if ( !::CryptFindCertificateKeyProvInfo (
                        pCert->GetCertContext (), dwFlags, 0) )
                {
                    DWORD   dwErr = GetLastError ();
                    _TRACE (0, L"CryptFindCertificateKeyProvInfo () failed: 0x%x\n",
                            dwErr);
                    CString text;
                    CString caption;
                    CThemeContextActivator activator;

                    text.FormatMessage (IDS_NO_PRIVATE_KEY, 
                            GetSystemMessage (dwErr));
                    VERIFY (caption.LoadString (IDS_REQUEST_CERT_SAME_KEY));
                    ::MessageBox (hwndParent, text, caption, MB_OK);
                    return hr;
                }
            }
            certRequestInfo.dwPvkChoice = CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_CERT;
            // security review 2/26/2002 BryanWal ok
            ::ZeroMemory (&pvkCert, sizeof (pvkCert));
            pvkCert.dwSize = sizeof (pvkCert);
            pvkCert.pCertContext = pCert->GetCertContext ();
            certRequestInfo.pPvkCert = &pvkCert;
        }

        certRequestInfo.pwszCertDNName = NULL;

        // Now that all the preliminaries are out of they way and the data is
        // all set up, call the enrollment wizard.
        DWORD           status = 0;
        PCCERT_CONTEXT  pNewCertContext = 0;
        BOOL            bResult = FALSE;
        CThemeContextActivator activator;


        DWORD   dwErr = 0;
        while (1)
        {
            // this must be inside the while statement as bNewKey can change
            DWORD           dwFlags = 0;
            if ( !bShowUI )
                dwFlags |= CRYPTUI_WIZ_NO_UI;
            if ( bNewKey )
                dwFlags |= CRYPTUI_WIZ_CERT_REQUEST_REQUIRE_NEW_KEY;

            bResult = ::CryptUIWizCertRequest (
                    dwFlags,
                    hwndParent, 
                    NULL,
                    &certRequestInfo, 
                    &pNewCertContext, 
                    &status);
            dwErr = GetLastError ();
            if ( !bResult && NTE_TOKEN_KEYSET_STORAGE_FULL == HRESULT_FROM_WIN32 (dwErr) )
            {
                // NTRAID# 299089 Enrollment Wizard: Should return some 
                // meaningful message when users fail to enroll/renew on a 
                // smart card
                if ( !bNewKey )
                    break;

                CString text;
                CString caption;
                int     iRetVal = 0;

                VERIFY (text.LoadString (IDS_SMARTCARD_FULL_REUSE_PRIVATE_KEY));
                VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
                hr = m_pConsole->MessageBox (text, caption,
                        MB_YESNO, &iRetVal);
                ASSERT (SUCCEEDED (hr));
                if ( IDYES == iRetVal )
                {
                    bNewKey = false;
                }
                else
                    break;
            }
            else
                break;
        }

        if ( !bResult && !bShowUI )
        {
            CString text;
            CString caption;
            int     iRetVal = 0;

            text.FormatMessage (IDS_CANNOT_CREATE_DATA_RECOVERY_AGENT, 
                    GetSystemMessage (dwErr));
            VERIFY (caption.LoadString (IDS_PUBLIC_KEY_POLICIES_NODE_NAME));
            if ( m_pConsole )
            {
                hr = m_pConsole->MessageBox (text, caption, MB_OK, &iRetVal);
                ASSERT (SUCCEEDED (hr));
            }
        }
        else if ( bResult && (CRYPTUI_WIZ_CERT_REQUEST_STATUS_SUCCEEDED == status) && pNewCertContext )
        {
            if ( bEFSPolicyTurnedOn )
            {
                // Force scope item selection to for call to 
                // IComponent::QueryResultViewType ()
                hr = m_pComponentConsole->SelectScopeItem (pGPEStore->m_hScopeItem);
                hr = m_pConsole->UpdateAllViews (pDataObject, 0, HINT_EFS_ADD_DEL_POLICY);
                hr = OnNotifyExpand (pDataObject, TRUE, pGPEStore->m_hScopeItem);
            }

            ASSERT (!(pStore && pGPEStore)); // these can't both be true
            if ( pStore )
            {
                pStore->IncrementCertCount ();
                pStore->SetDirty ();
                pStore->Resync ();
                
            }
            else if ( pGPEStore )
            {
                pGPEStore->InvalidateCertCount ();
                pGPEStore->SetDirty ();
                pGPEStore->Resync ();


                if ( EFS_STORE == pGPEStore->GetStoreType () )
                {
                    hr = CompleteEFSRecoveryAgent (pGPEStore, pNewCertContext);
                }
            }
            else if ( pCert && pCert->GetCertStore ())
            {
                pCert->GetCertStore ()->Resync ();
            }

            if ( !m_pGPEInformation )  // If we are not extending the GPE/SCE
            {
                if ( bParentIsStoreOrContainer )
                {
                    ASSERT (hScopeItem);
                    ASSERT (pStore);
                    hr = CreateContainers (hScopeItem, *pStore);

                    // Display the new cert only if the container node is selected
                    if ( CERTMGR_CERT_CONTAINER == pParentCookie->m_objecttype && 
                            pParentCookie->IsSelected () )
                    {
                        // Add certificate to result pane
                        RESULTDATAITEM          rdItem;
                        CCookie&                rootCookie = QueryBaseRootCookie ();

                        // security review 2/26/2002 BryanWal ok
                        ::ZeroMemory (&rdItem, sizeof (rdItem));
                        rdItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM | RDI_STATE;
                        rdItem.nImage = iIconCertificate;
                        rdItem.nCol = 0;
                        rdItem.nState = LVIS_SELECTED | LVIS_FOCUSED;
                        rdItem.str = MMC_TEXTCALLBACK;

                        PCCERT_CONTEXT pFoundCertContext = 
                                pStore->FindCertificate (0, CERT_FIND_EXISTING,
                                (void*) pNewCertContext, NULL);
                        if ( pFoundCertContext )
                        {
                            pCert = new CCertificate (pFoundCertContext, pStore);
                            if ( pCert )
                            {
                                rootCookie.m_listResultCookieBlocks.AddHead (pCert);
                                rdItem.lParam = (LPARAM) pCert;
                                pCert->m_resultDataID = m_pResultData;
                                hr = m_pResultData->InsertItem (&rdItem);
                                if ( FAILED (hr) )
                                {
                                     _TRACE (0, L"IResultData::InsertItem () failed: 0x%x\n", hr);
                                }
                                else
                                {
                                    hr = DisplayCertificateCountByStore (
                                            m_pComponentConsole, pStore, false);
                                }
                            }
                            else
                                hr = E_OUTOFMEMORY;

                            ::CertFreeCertificateContext (pFoundCertContext);
                        }
                        else
                        {
                            hr = HRESULT_FROM_WIN32 (GetLastError ());
                        }

                        ASSERT (SUCCEEDED (hr));
                    }
                    hr = DisplayCertificateCountByStore (m_pComponentConsole, pStore);
                }
                else
                {
                    hr = m_pConsole->UpdateAllViews (pDataObject, 0, 
                            HINT_CERT_ENROLLED_USAGE_MODE);
                    ASSERT (SUCCEEDED (hr));
                }
            }
            else
            {
                hr = m_pConsole->UpdateAllViews (pDataObject, 0, 0);
                ASSERT (SUCCEEDED (hr));
                hr = DisplayCertificateCountByStore (m_pComponentConsole, pGPEStore, true);
            }
            ::CertFreeCertificateContext (pNewCertContext);
        }
        else if ( bEFSPolicyTurnedOn )
        {
            // If we allowed policy creation just for this enrollment, but
            // nothing was enrolled, go ahead and delete the policy.
            hr = OnDeleteEFSPolicy (pDataObject, false);
        }

    }
    else
        hr = E_POINTER;

    _TRACE (-1, L"Leaving CCertMgrComponentData::OnEnroll: 0x%x\n", hr);
    return hr;
}


HRESULT RenewCertificate (
        CCertificate* pCert, 
        bool bNewKey, 
        const CString& machineName, 
        DWORD dwLocation,
        const CString& managedComputer, 
        const CString& managedService, 
        HWND hwndParent, 
        LPCONSOLE pConsole,
        LPDATAOBJECT pDataObject)
{
    HRESULT hr = S_OK;

    if ( pCert )
    {
        CRYPTUI_WIZ_CERT_REQUEST_PVK_CERT   pvkCert;
        CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW    pvkNew;
        CRYPTUI_WIZ_CERT_REQUEST_INFO       certRequestInfo;
        CRYPT_KEY_PROV_INFO                 provInfo;


        // security review 2/26/2002 BryanWal ok
        ::ZeroMemory (&certRequestInfo, sizeof (certRequestInfo));
        certRequestInfo.dwSize = sizeof (certRequestInfo);
        certRequestInfo.dwPurpose = CRYPTUI_WIZ_CERT_RENEW;
        // User wants to manage user account
        //  pass in NULL to machine name and to account name
        // User wants to manage local machine account
        //  pass in NULL for account name and result of ::GetComputerName ()
        //  to machine name
        // User want to manage remote machine
        //  pass in NULL for account name and machine name for machineName
        // User wants to manage remote account on remote machine
        //  pass in account name for accountName and machine name for machineName
        // TODO: Ensure that this is NULL if the local machine
        BOOL    bIsLocalMachine = IsLocalComputername (machineName);
        switch (dwLocation)
        {
        case CERT_SYSTEM_STORE_CURRENT_SERVICE:
        case CERT_SYSTEM_STORE_SERVICES:
            certRequestInfo.pwszMachineName = (PCWSTR) managedComputer;
            certRequestInfo.pwszAccountName = (PCWSTR) managedService;
            break;

        case CERT_SYSTEM_STORE_CURRENT_USER:
            certRequestInfo.pwszMachineName = NULL;
            certRequestInfo.pwszAccountName = NULL;
            break;

        case CERT_SYSTEM_STORE_LOCAL_MACHINE:
            certRequestInfo.pwszMachineName = (PCWSTR) managedComputer;
            certRequestInfo.pwszAccountName = NULL;
            break;

        default:
            ASSERT (0);
            return E_UNEXPECTED;
            break;
        }
        certRequestInfo.pRenewCertContext = pCert->GetCertContext ();
        if ( bNewKey )
        {
            certRequestInfo.dwPvkChoice = CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_NEW;
            // security review 2/26/2002 BryanWal ok
            ::ZeroMemory (&pvkNew, sizeof (pvkNew));
            pvkNew.dwSize = sizeof (pvkNew);
            if ( CERT_SYSTEM_STORE_LOCAL_MACHINE == dwLocation )
            {
                // security review 2/26/2002 BryanWal ok
                ::ZeroMemory (&provInfo, sizeof (provInfo));
                provInfo.dwFlags = CRYPT_MACHINE_KEYSET;
                pvkNew.pKeyProvInfo = &provInfo;
            }
            certRequestInfo.pPvkNew = &pvkNew;
        }
        else
        {
            if ( bIsLocalMachine )
            {
                DWORD   dwFlags = 0;

                if ( CERT_SYSTEM_STORE_LOCAL_MACHINE == dwLocation )
                    dwFlags = CRYPT_FIND_MACHINE_KEYSET_FLAG;
                if ( !::CryptFindCertificateKeyProvInfo (
                        pCert->GetCertContext (), dwFlags, 0) )
                {
                    DWORD   dwErr = GetLastError ();
                    _TRACE (0, L"CryptFindCertificateKeyProvInfo () failed: 0x%x\n",
                            dwErr);
                    CString text;
                    CString caption;
                    CThemeContextActivator activator;

                    text.FormatMessage (IDS_NO_PRIVATE_KEY, 
                            GetSystemMessage (dwErr));
                    VERIFY (caption.LoadString (IDS_RENEW_CERT_SAME_KEY));
                    ::MessageBox (hwndParent, text, caption, MB_OK);
                    return hr;
                }
            }

            certRequestInfo.dwPvkChoice = CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_CERT;
            // security review 2/26/2002 BryanWal ok
            ::ZeroMemory (&pvkCert, sizeof (pvkCert));
            pvkCert.dwSize = sizeof (pvkCert);
            pvkCert.pCertContext = pCert->GetCertContext ();
            certRequestInfo.pPvkCert = &pvkCert;
        }
            

        DWORD           status = 0;
        PCCERT_CONTEXT  pNewCertContext = 0;
        BOOL            bResult = FALSE;
        CThemeContextActivator activator;           

        while (1)
        {
            bResult = ::CryptUIWizCertRequest (
                bNewKey ? CRYPTUI_WIZ_CERT_REQUEST_REQUIRE_NEW_KEY : 0,
                    hwndParent, NULL,
                    &certRequestInfo, &pNewCertContext, &status);
            if ( !bResult && HRESULT_FROM_WIN32 (NTE_TOKEN_KEYSET_STORAGE_FULL) == GetLastError () )
            {
                // NTRAID# 299089 Enrollment Wizard: Should return some 
                // meaningful message when users fail to enroll/renew on a 
                // smart card
                if ( !bNewKey )
                    break;

                CString text;
                CString caption;
                int     iRetVal = 0;

                VERIFY (text.LoadString (IDS_SMARTCARD_FULL_REUSE_PRIVATE_KEY));
                VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
                if ( pConsole )
                {
                    hr = pConsole->MessageBox (text, caption, MB_YESNO, &iRetVal);
                    ASSERT (SUCCEEDED (hr));
                }
                else
                {
                    CThemeContextActivator activator;
                    iRetVal = ::MessageBox (hwndParent, text, caption, MB_OK);
                }
                if ( IDYES == iRetVal )
                {
                    bNewKey = false;
                }
                else
                    break;
            }
            else
                break;
        }

        if ( bResult && (CRYPTUI_WIZ_CERT_REQUEST_STATUS_SUCCEEDED == status) && pNewCertContext )
        {
            CCertStore* pStore = pCert->GetCertStore ();
            if ( pStore )
            {
                pStore->SetDirty ();
                pStore->Resync ();
                if ( pConsole )
                    hr = pConsole->UpdateAllViews (pDataObject, 0, 0);
            }

            CertFreeCertificateContext (pNewCertContext);
            ASSERT (SUCCEEDED (hr));
        }
    }
    else
        hr = E_POINTER;

    return hr;
}

HRESULT CCertMgrComponentData::OnRenew (LPDATAOBJECT pDataObject, bool bNewKey)
{
    _TRACE (1, L"Entering CCertMgrComponentData::OnRenew\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    HRESULT         hr = S_OK;
    HWND            hwndParent = 0;
    VERIFY (SUCCEEDED (m_pConsole->GetMainWindow (&hwndParent)));
    CCertMgrCookie* pParentCookie = ConvertCookie (pDataObject);
    if ( pParentCookie && CERTMGR_CERTIFICATE == pParentCookie->m_objecttype )
    {
        CCertificate* pCert = reinterpret_cast <CCertificate*> (pParentCookie);
        ASSERT (pCert);
        if ( pCert )
        {
            hr = RenewCertificate (pCert, bNewKey, m_strMachineNamePersist, 
                    m_dwLocationPersist, m_szManagedComputer, 
                    m_szManagedServicePersist, hwndParent, m_pConsole, pDataObject);
        }
    }
    else
        hr = E_POINTER;

    _TRACE (-1, L"Leaving CCertMgrComponentData::OnRenew: 0x%x\n", hr);
    return hr;
}


CCertMgrCookie* CCertMgrComponentData::ConvertCookie (LPDATAOBJECT pDataObject)
{
    CCertMgrCookie* pParentCookie = 0;
    CCookie*        pBaseParentCookie = 0;
    HRESULT         hr = ExtractData (pDataObject,
            CCertMgrDataObject::m_CFRawCookie,
             &pBaseParentCookie,
             sizeof (pBaseParentCookie) );
    if ( SUCCEEDED (hr) )
    {
        pParentCookie = ActiveCookie (pBaseParentCookie);
        ASSERT (pParentCookie);
    }
    return pParentCookie;
}


HRESULT CCertMgrComponentData::OnImport (LPDATAOBJECT pDataObject)
{
    _TRACE (1, L"Entering CCertMgrComponentData::OnImport\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    HRESULT hr = S_OK;
    ASSERT (m_szFileName.IsEmpty ());
    if ( !m_szFileName.IsEmpty () )
        return E_UNEXPECTED;
    ASSERT (pDataObject);
    if ( !pDataObject )
        return E_POINTER;
    

    DWORD           dwFlags = 0;
    
    if ( CERT_SYSTEM_STORE_CURRENT_USER == m_dwLocationPersist )
    {
        // We're managing the user's certificate store
        dwFlags |= CRYPTUI_WIZ_IMPORT_TO_CURRENTUSER;
    }
    else 
    {
        // We're managing certificates on a machine
        dwFlags |= CRYPTUI_WIZ_IMPORT_TO_LOCALMACHINE;

        if ( !IsLocalComputername (m_szManagedComputer) )
        {
            // We're managing certificates on a remote machine
            dwFlags |= CRYPTUI_WIZ_IMPORT_REMOTE_DEST_STORE;
        }
    }

    HCERTSTORE      hDestStore = 0;
    CCertStore*     pDestStore = 0;
    HSCOPEITEM      hScopeItem = 0;
    int             nOriginalCertCount = 0;
    int             nOriginalCTLCount = 0;

    CCertMgrCookie* pParentCookie = ConvertCookie (pDataObject);
    if ( pParentCookie )
    {
        hScopeItem = pParentCookie->m_hScopeItem;
        switch (pParentCookie->m_objecttype)
        {
        case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
        case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
            ASSERT (0);
            break;

        case CERTMGR_LOG_STORE_RSOP:
            ASSERT (0);
            return E_FAIL;
            break;

        case CERTMGR_LOG_STORE_GPE:
            {
                dwFlags |= CRYPTUI_WIZ_IMPORT_NO_CHANGE_DEST_STORE;
                pDestStore = reinterpret_cast <CCertStore*> (pParentCookie);
                ASSERT (pDestStore);
                if ( pDestStore )
                {
                    nOriginalCertCount = pDestStore->GetCertCount ();
                    hDestStore = pDestStore->GetStoreHandle ();

                    switch (pDestStore->GetStoreType ())
                    {
                    case ACRS_STORE:
                        break;
                            
                    case TRUST_STORE:
                        dwFlags |= CRYPTUI_WIZ_IMPORT_ALLOW_CTL;
                        nOriginalCTLCount = pDestStore->GetCTLCount ();
                        break;

                    case ROOT_STORE:
                        dwFlags |= CRYPTUI_WIZ_IMPORT_ALLOW_CERT;
                        break;

                    case EFS_STORE:
                        break;

                    default:
                        ASSERT (0);
                        break;
                    }
                }
                else
                    hr = E_UNEXPECTED;
            }
            break;

        case CERTMGR_LOG_STORE:
        case CERTMGR_PHYS_STORE:
            {
                pDestStore = reinterpret_cast <CCertStore*> (pParentCookie);
                ASSERT (pDestStore);
                if ( pDestStore )
                {
                    if ( TRUST_STORE == pDestStore->GetStoreType () )
                        nOriginalCTLCount = pDestStore->GetCTLCount ();
                    else
                        nOriginalCertCount = pDestStore->GetCertCount ();
                        
                    hDestStore = pDestStore->GetStoreHandle ();
                }
                else
                    hr = E_UNEXPECTED;
            }
            break;

        case CERTMGR_CERT_CONTAINER:
        case CERTMGR_CTL_CONTAINER:
            {
                CContainerCookie*   pContainer = reinterpret_cast <CContainerCookie*> (pParentCookie);
                ASSERT (pContainer);
                if ( pContainer )
                {
                    MMC_COOKIE lCookie = 0;
                    hr = m_pConsoleNameSpace->GetParentItem (
                            pContainer->m_hScopeItem, &hScopeItem, &lCookie);
                    ASSERT (SUCCEEDED (hr));
                    pDestStore = &pContainer->GetCertStore ();
                    if ( CERTMGR_CERT_CONTAINER == pParentCookie->m_objecttype )
                        nOriginalCertCount = pDestStore->GetCertCount ();
                    else
                        nOriginalCTLCount = pDestStore->GetCTLCount ();
                    hDestStore = pDestStore->GetStoreHandle ();
                }
                else
                    hr = E_UNEXPECTED;
            }
            break;

        case CERTMGR_USAGE:
            pDestStore = 0;
            hDestStore = 0;
            break;

        default:
            ASSERT (0);
            hr = E_UNEXPECTED;
        }
    }
    else
        hr = E_UNEXPECTED;


    if ( SUCCEEDED (hr) )
    {
        HWND                hwndParent = 0;
        hr = m_pConsole->GetMainWindow (&hwndParent);
        ASSERT (SUCCEEDED (hr));

        // Now that all the data is set up and everything is in readiness,
        // call the Import Wizard
        CThemeContextActivator activator;
        BOOL bResult = ::CryptUIWizImport (dwFlags, hwndParent, 0, NULL, hDestStore);
        if ( bResult )
        {
            bool        bWizardCancelled = false;
            CCertStore* pStore = 0;

            switch (pParentCookie->m_objecttype)
            {
            case CERTMGR_LOG_STORE_RSOP:
                ASSERT (0);
                return E_FAIL;
                break;

            case CERTMGR_LOG_STORE_GPE:
            case CERTMGR_LOG_STORE:
            case CERTMGR_PHYS_STORE:
                {
                    pStore = reinterpret_cast <CCertStore*> (pParentCookie);
                    ASSERT (pStore);
                    if ( pStore )
                    {
                        if ( TRUST_STORE == pStore->GetStoreType () )
                        {
                            if ( pStore->GetCTLCount () != nOriginalCTLCount )
                            {
                                pStore->SetDirty ();
                                hr = pStore->Commit ();
                            }
                            else
                                bWizardCancelled = true;
                        }
                        else
                        {
                            pStore->InvalidateCertCount ();
                            if ( pStore->GetCertCount () != nOriginalCertCount )
                            {
                                pStore->SetDirty ();
                                hr = pStore->Commit ();
                            }
                            else
                                bWizardCancelled = true;
                        }
                    }
                    else
                        hr = E_UNEXPECTED;
                }
                break;

            case CERTMGR_CERT_CONTAINER:
            case CERTMGR_CTL_CONTAINER:
                {
                    CContainerCookie*   pContainer = reinterpret_cast <CContainerCookie*> (pParentCookie);
                    ASSERT (pContainer);
                    if ( pContainer )
                    {
                        pStore = &pContainer->GetCertStore ();
                        
                        if ( CERTMGR_CERT_CONTAINER == pParentCookie->m_objecttype )
                        {
                            pStore->InvalidateCertCount ();
                            if ( pStore->GetCertCount () != nOriginalCertCount )
                            {
                                pStore->SetDirty ();
                                hr = pStore->Commit ();
                            }
                            else
                                bWizardCancelled = true;
                        }
                        else
                        {
                            if ( pStore->GetCTLCount () != nOriginalCTLCount )
                            {
                                pStore->SetDirty ();
                                hr = pStore->Commit ();
                            }
                            else
                                bWizardCancelled = true;
                        }

                    }
                    else
                        hr = E_UNEXPECTED;
                }
                break;

            case CERTMGR_USAGE:
                break;

            default:
                ASSERT (0);
                hr = E_UNEXPECTED;
            }

            if ( !bWizardCancelled )
            {
                if ( pStore )
                {
                    if ( SUCCEEDED (hr) )
                        pStore->Resync ();
                }
                
                if ( CERTMGR_LOG_STORE == pParentCookie->m_objecttype ||
                        (CERTMGR_LOG_STORE == pParentCookie->m_objecttype && !m_bShowPhysicalStoresPersist) )
                {
                    if ( pStore )
                        hr = CreateContainers (hScopeItem, *pStore);
                }

                hr = m_pConsole->UpdateAllViews (pDataObject, 0, HINT_IMPORT);
                ASSERT (SUCCEEDED (hr));
            }
        }
        if ( pDestStore )
            pDestStore->Close ();
    }
    _TRACE (-1, L"Leaving CCertMgrComponentData::OnImport: 0x%x\n", hr);
    return hr;
}

HRESULT CCertMgrComponentData::OnExport (LPDATAOBJECT pDataObject)
{
    _TRACE (1, L"Entering CCertMgrComponentData::OnExport\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    HRESULT hr = S_OK;

    LPDATAOBJECT    pMSDO = ExtractMultiSelect (pDataObject);
    m_bMultipleObjectsSelected = false;

    if ( pMSDO )
    {
        // Iterate through list of selected objects -
        // Add them to a memory store
        // Export to PFX file through wizard with new
        // "export from store - certs only" flag
        m_bMultipleObjectsSelected = true;
        HCERTSTORE  hCertStore = ::CertOpenStore (CERT_STORE_PROV_MEMORY,
                0, NULL, 0, NULL);
        ASSERT (hCertStore);
        if ( hCertStore )
        {
            CCertMgrCookie*     pCookie = 0;
            CCertMgrDataObject* pDO = reinterpret_cast <CCertMgrDataObject*>(pMSDO);
            ASSERT (pDO);
            if ( pDO )
            {
                BOOL    bResult = FALSE;
                pDO->Reset();
                while (pDO->Next(1, reinterpret_cast<MMC_COOKIE*>(&pCookie), NULL) != S_FALSE)
                {
                    if ( CERTMGR_CERTIFICATE == pCookie->m_objecttype )
                    {
                        CCertificate* pCert = reinterpret_cast <CCertificate*> (pCookie);
                        ASSERT (pCert);
                        if ( pCert )
                        {
                            bResult = ::CertAddCertificateContextToStore (
                                    hCertStore,
                                    ::CertDuplicateCertificateContext (pCert->GetCertContext ()),
                                    CERT_STORE_ADD_NEW, 0);
                            ASSERT (bResult);
                            if ( !bResult )
                                break;
                        }
                    }
                    else if ( CERTMGR_CTL == pCookie->m_objecttype )
                    {
                        CCTL* pCTL = reinterpret_cast <CCTL*> (pCookie);
                        ASSERT (pCTL);
                        if ( pCTL )
                        {
                            bResult = ::CertAddCTLContextToStore (
                                    hCertStore,
                                    ::CertDuplicateCTLContext (pCTL->GetCTLContext ()),
                                    CERT_STORE_ADD_NEW, 0);
                            ASSERT (bResult);
                            if ( !bResult )
                                break;
                        }
                    }
                }

                // Call Export Wizard
                CRYPTUI_WIZ_EXPORT_INFO cwi;
                // security review 2/26/2002 BryanWal ok
                ::ZeroMemory (&cwi, sizeof (cwi));
                cwi.dwSize = sizeof (cwi);
                cwi.dwSubjectChoice = CRYPTUI_WIZ_EXPORT_CERT_STORE;
                cwi.hCertStore = hCertStore;

                HWND    hwndParent = 0;
                hr = m_pConsole->GetMainWindow (&hwndParent);
                ASSERT (SUCCEEDED (hr));
                CThemeContextActivator activator;
                bResult = ::CryptUIWizExport (
                        0,
                        hwndParent,
                        0,
                        &cwi,
                        NULL);

                VERIFY (::CertCloseStore (hCertStore, CERT_CLOSE_STORE_CHECK_FLAG));
            }
            else
                hr = E_FAIL;

            return hr;
        }
        else
        {
            DWORD   dwErr = GetLastError ();
            _TRACE (0, L"CertOpenStore (%s) failed: 0x%x\n", 
                    CERT_STORE_PROV_MEMORY, dwErr);     
            hr = HRESULT_FROM_WIN32 (dwErr);
            return hr;
        }
    }


    CRYPTUI_WIZ_EXPORT_INFO cwi;
    CCertificate*           pCert = 0;
    CCRL*                   pCRL = 0;
    CCTL*                   pCTL = 0;
    CCertStore*             pCertStore = 0;
    CCertMgrCookie*         pCookie = ConvertCookie (pDataObject);
    ASSERT (pCookie);
    if ( !pCookie )
        return E_UNEXPECTED;

    // security review 2/26/2002 BryanWal ok
    ::ZeroMemory (&cwi, sizeof (cwi));
    cwi.dwSize = sizeof (cwi);
    switch (pCookie->m_objecttype)
    {
    case CERTMGR_CERTIFICATE:
        cwi.dwSubjectChoice = CRYPTUI_WIZ_EXPORT_CERT_CONTEXT;
        pCert = reinterpret_cast <CCertificate*> (pCookie);
        ASSERT (pCert);
        if ( pCert )
            cwi.pCertContext = pCert->GetCertContext ();
        else
            return E_UNEXPECTED;
        break;

    case CERTMGR_CRL:
        cwi.dwSubjectChoice = CRYPTUI_WIZ_EXPORT_CRL_CONTEXT;
        pCRL = reinterpret_cast <CCRL*> (pCookie);
        ASSERT (pCRL);
        if ( pCRL )
            cwi.pCRLContext = pCRL->GetCRLContext ();
        else
            return E_UNEXPECTED;
        break;

    case CERTMGR_CTL:
        cwi.dwSubjectChoice = CRYPTUI_WIZ_EXPORT_CTL_CONTEXT;
        pCTL = reinterpret_cast <CCTL*> (pCookie);
        ASSERT (pCTL);
        if ( pCTL )
            cwi.pCTLContext = pCTL->GetCTLContext ();
        else
            return E_UNEXPECTED;
        break;

    case CERTMGR_LOG_STORE:
    case CERTMGR_PHYS_STORE:
        cwi.dwSubjectChoice = CRYPTUI_WIZ_EXPORT_CERT_STORE;
        pCertStore = reinterpret_cast <CCertStore*> (pCookie);
        ASSERT (pCertStore);
        if ( pCertStore )
            cwi.hCertStore = pCertStore->GetStoreHandle ();
        else
            return E_UNEXPECTED;
        break;

    default:
        ASSERT (0);
        return E_UNEXPECTED;
    }

    HWND    hwndParent = 0;
    hr = m_pConsole->GetMainWindow (&hwndParent);
    ASSERT (SUCCEEDED (hr));
    CThemeContextActivator activator;
    ::CryptUIWizExport (
            0,
            hwndParent,
            0,
            &cwi,
            NULL);

    if ( pCertStore )
        pCertStore->Close ();
    _TRACE (-1, L"Leaving CCertMgrComponentData::OnExport: 0x%x\n", hr);
    return hr;
}

                    
HRESULT CCertMgrComponentData::OnNewCTL (LPDATAOBJECT pDataObject)
{
    _TRACE (1, L"Entering CCertMgrComponentData::OnNewCTL\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    ASSERT (pDataObject);
    if ( !pDataObject )
        return E_POINTER;
    HRESULT             hr = S_OK;
    CCertMgrCookie*     pCookie = ConvertCookie (pDataObject);
    ASSERT (pCookie);
    if ( !pCookie )
        return E_UNEXPECTED;

    CCertStore* pStore = 0;
    CContainerCookie* pCont = 0;

    switch ( pCookie->m_objecttype )
    {
    case CERTMGR_CTL_CONTAINER:
        {
            pCont = reinterpret_cast <CContainerCookie*> (pCookie);
            ASSERT (pCont);
            if ( pCont )
            {
                pStore = &(pCont->GetCertStore ());
            }
            else
                return E_UNEXPECTED;
        }
        break;

    case CERTMGR_LOG_STORE_RSOP:
        ASSERT (0);
        return E_UNEXPECTED;
        break;

    case CERTMGR_LOG_STORE:
    case CERTMGR_LOG_STORE_GPE:
    case CERTMGR_PHYS_STORE:
        {
            pStore = reinterpret_cast <CCertStore*> (pCookie);
            ASSERT (pStore);
            if ( !pStore )
                return E_UNEXPECTED;
        }
        break;

    default:
        ASSERT (0);
        return E_UNEXPECTED;
    }

    ASSERT (pStore);
    if ( !pStore )
        return E_UNEXPECTED;

    pStore->Lock ();

    CRYPTUI_WIZ_BUILDCTL_DEST_INFO  destInfo;

    // security review 2/26/2002 BryanWal ok
    ::ZeroMemory (&destInfo, sizeof (destInfo));
    destInfo.dwSize = sizeof (destInfo);
    destInfo.dwDestinationChoice = CRYPTUI_WIZ_BUILDCTL_DEST_CERT_STORE;
    destInfo.hCertStore = pStore->GetStoreHandle ();
    ASSERT (destInfo.hCertStore);
    if ( !destInfo.hCertStore )
        return E_UNEXPECTED;

    HWND    hwndParent = 0;
    hr = m_pConsole->GetMainWindow (&hwndParent);
    ASSERT (SUCCEEDED (hr));
    PCCTL_CONTEXT   pCTLContext = 0;
    CThemeContextActivator activator;
    BOOL    bResult = ::CryptUIWizBuildCTL (
            CRYPTUI_WIZ_BUILDCTL_SKIP_DESTINATION,
            hwndParent,
            0,
            NULL,
            &destInfo,
            &pCTLContext);
    if ( bResult )
    {
        // If pCTLContext, then the wizard completed
        if ( pCTLContext )
        {
            pStore->SetDirty ();
            pStore->Commit ();
            hr = m_pConsole->UpdateAllViews (pDataObject, 0, 0);
            ASSERT (SUCCEEDED (hr));
            ::CertFreeCTLContext (pCTLContext);
        }
    }

    pStore->Unlock ();
    pStore->Close ();
    _TRACE (-1, L"Leaving CCertMgrComponentData::OnNewCTL: 0x%x\n", hr);
    return hr;
}

HRESULT CCertMgrComponentData::OnACRSEdit (LPDATAOBJECT pDataObject)
{
    _TRACE (1, L"Entering CCertMgrComponentData::OnACRSEdit\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    HRESULT             hr = S_OK;
    CCertMgrCookie*     pCookie = ConvertCookie (pDataObject);
    ASSERT (pCookie);
    if ( !pCookie )
        return E_UNEXPECTED;

    switch ( pCookie->m_objecttype )
    {
    case CERTMGR_AUTO_CERT_REQUEST:
        {
            CAutoCertRequest* pACR = reinterpret_cast <CAutoCertRequest*> (pCookie);
            ASSERT (pACR);
            if ( pACR )
            {
                CCertStore& rStore = pACR->GetCertStore ();
                CCertStoreGPE* pStore = reinterpret_cast <CCertStoreGPE*> (&rStore);
                ASSERT (pStore);
                if ( pStore )
                {
                    HWND        hwndConsole = 0;
                    hr = m_pConsole->GetMainWindow (&hwndConsole);
                    ASSERT (SUCCEEDED (hr));
                    if ( SUCCEEDED (hr) )
                    {
                        ACRSWizardPropertySheet sheet (pStore, pACR);

                        ACRSWizardWelcomePage   welcomePage;
                        ACRSWizardTypePage      typePage;
                        ACRSCompletionPage      completionPage;

                        sheet.AddPage (&welcomePage);
                        sheet.AddPage (&typePage);
                        sheet.AddPage (&completionPage);

                        if ( sheet.DoWizard (hwndConsole) )
                        {
                            pStore->SetDirty ();
                            hr = DeleteCTLFromResultPane (pACR, pDataObject);
                            hr = m_pConsole->UpdateAllViews (pDataObject, 0, 0);
                            ASSERT (SUCCEEDED (hr));
                        }
                    }
                }
                else
                    hr = E_UNEXPECTED;
            }
            else
                return E_UNEXPECTED;
        }
        break;

    default:
        ASSERT (0);
        return E_UNEXPECTED;
    }

    _TRACE (-1, L"Leaving CCertMgrComponentData::OnACRSEdit: 0x%x\n", hr);
    return hr;
}

HRESULT CCertMgrComponentData::OnCTLEdit (LPDATAOBJECT pDataObject)
{
    _TRACE (1, L"Entering CCertMgrComponentData::OnCTLEdit\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    ASSERT (pDataObject);
    if ( !pDataObject )
        return E_POINTER;
    HRESULT             hr = S_OK;
    CCertMgrCookie*     pCookie = ConvertCookie (pDataObject);
    ASSERT (pCookie);
    if ( !pCookie )
        return E_UNEXPECTED;

    switch ( pCookie->m_objecttype )
    {
    case CERTMGR_CTL:
        {
            CCTL* pCTL = reinterpret_cast <CCTL*> (pCookie);
            ASSERT (pCTL);
            if ( pCTL )
            {
                CCertStore& rStore = pCTL->GetCertStore ();
                CRYPTUI_WIZ_BUILDCTL_SRC_INFO   srcInfo;

                // security review 2/26/2002 BryanWal ok
                ::ZeroMemory (&srcInfo, sizeof (srcInfo));
                srcInfo.dwSize = sizeof (srcInfo);
                srcInfo.pCTLContext = pCTL->GetCTLContext ();
                srcInfo.dwSourceChoice = CRYPTUI_WIZ_BUILDCTL_SRC_EXISTING_CTL;

                HWND    hwndParent = 0;
                hr = m_pConsole->GetMainWindow (&hwndParent);
                ASSERT (SUCCEEDED (hr));
                PCCTL_CONTEXT   pNewCTLContext = 0;
                CThemeContextActivator activator;
                BOOL    bResult = ::CryptUIWizBuildCTL (
                        CRYPTUI_WIZ_BUILDCTL_SKIP_DESTINATION,
                        hwndParent,
                        0,
                        &srcInfo,
                        NULL,
                        &pNewCTLContext);
                ASSERT (bResult);
                if ( bResult && pNewCTLContext )
                {
                    rStore.SetDirty ();
                    // Delete old CTL and add the new one.
                    if ( pCTL->DeleteFromStore () )
                    {
                        if ( !rStore.AddCTLContext (pNewCTLContext) )
                        {
                            DWORD   dwErr = GetLastError ();
                            if ( CRYPT_E_EXISTS == dwErr )
                            {
                                CString text;
                                CString caption;
                                int     iRetVal = 0;


                                VERIFY (text.LoadString (IDS_DUPLICATE_CTL));
                                VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
                                hr = m_pConsole->MessageBox (text, caption,
                                        MB_OK, &iRetVal);
                                ASSERT (SUCCEEDED (hr));
                                hr = E_FAIL;
                            }
                            else
                            {
                                DisplaySystemError (dwErr);
                                hr = HRESULT_FROM_WIN32 (dwErr);
                            }
                        }
                        rStore.Commit ();
                        hr = m_pConsole->UpdateAllViews (pDataObject, 0, 0);
                        ASSERT (SUCCEEDED (hr));
                    }
                    else
                    {
                        DWORD   dwErr = GetLastError ();
                        DisplaySystemError (dwErr);
                        hr = HRESULT_FROM_WIN32 (dwErr);
                    }
                }
            }
            else
                return E_UNEXPECTED;
        }
        break;

    default:
        ASSERT (0);
        return E_UNEXPECTED;
    }

    _TRACE (-1, L"Leaving CCertMgrComponentData::OnCTLEdit: 0x%x\n", hr);
    return hr;
}


HRESULT CCertMgrComponentData::OnAddDomainEncryptedDataRecoveryAgent (LPDATAOBJECT pDataObject)
{
    _TRACE (1, L"Entering CCertMgrComponentData::OnAddDomainEncryptedDataRecoveryAgent\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    ASSERT (pDataObject);
    if ( !pDataObject )
        return E_POINTER;

    HRESULT         hr = S_OK;
    CCertMgrCookie* pCookie = ConvertCookie (pDataObject);
    ASSERT (pCookie);
    if ( pCookie )
    {
        CCertStoreGPE* pStore = reinterpret_cast <CCertStoreGPE*> (pCookie);
        ASSERT (pStore && EFS_STORE == pStore->GetStoreType ());
        if ( pStore && EFS_STORE == pStore->GetStoreType () )
        {
            HWND    hwndConsole = 0;
            hr = m_pConsole->GetMainWindow (&hwndConsole);
            ASSERT (SUCCEEDED (hr));
            if ( SUCCEEDED (hr) )
            {
                CUsers          EFSUsers;
                CAddEFSWizSheet efsAddSheet (IDS_ADDTITLE, EFSUsers, m_bMachineIsStandAlone);

                if ( efsAddSheet.DoWizard (hwndConsole) )
                {
                    pStore->SetDirty ();

                    bool            bWasEmpty = false;
                    CString         szUserName;
                    CString         szCertName;
                    PUSERSONFILE    pUser = EFSUsers.StartEnum ();

                    if ( pStore->IsNullEFSPolicy () )
                    {
                        bWasEmpty = true;
                        pStore->AllowEmptyEFSPolicy ();                     
                        hr = m_pConsole->UpdateAllViews (pDataObject, 0, HINT_EFS_ADD_DEL_POLICY);
                        ASSERT (SUCCEEDED (hr));
                    }

                    // If the store is an empty store, we need to delete it before adding
                    // the first cert.  Otherwise CertAddCertificateContextToStore () fails
                    // with E_ACCESS_DENIED
                    if ( 0 == pStore->GetCertCount () )
                        pStore->DeleteEFSPolicy (false);

                    while ( pUser )
                    {
                        hr = pStore->AddCertificateContext (
                                pUser->m_pCertContext, m_pConsole, false);
                        if ( SUCCEEDED (hr) )
                        {
                            pStore->AddCertToList (pUser->m_pCertContext, pUser->m_UserSid);

                            hr = ValidateCertChain (pUser->m_pCertContext);
                            hr = m_pConsole->UpdateAllViews (pDataObject, 0, 0);
                            ASSERT (SUCCEEDED (hr));
                        }
                        else
                            break;
                        pUser = EFSUsers.GetNextUser (pUser, szUserName, szCertName);
                    }
                    pStore->Commit ();
                    hr = DisplayCertificateCountByStore (m_pComponentConsole, pStore, true);

                    if ( bWasEmpty )
                    {
                        // Force scope item selection to force call to 
                        // IComponent::QueryResultViewType ()
                        hr = m_pComponentConsole->SelectScopeItem (pCookie->m_hScopeItem);
                        hr = m_pConsole->UpdateAllViews (pDataObject, 0, 0);
                        hr = OnNotifyExpand (pDataObject, TRUE, pCookie->m_hScopeItem);
                    }
                }
            }
        }
        else
            hr = E_UNEXPECTED;
    }
    _TRACE (-1, L"Leaving CCertMgrComponentData::OnAddDomainEncryptedDataRecoveryAgent: 0x%x\n", hr);
    return hr;
}


// This code from Robert Reichel
/*++

Routine Description:

    This routine returns the TOKEN_USER structure for the
    current user, and optionally, the AuthenticationId from his
    token.

Arguments:

    AuthenticationId - Supplies an optional pointer to return the
        AuthenticationId.

Return Value:

    On success, returns a pointer to a TOKEN_USER structure.

    On failure, returns NULL.  Call GetLastError() for more
    detailed error information.

--*/

PTOKEN_USER EfspGetTokenUser ()
{
    _TRACE (1, L"Entering EfspGetTokenUser\n");
    HANDLE              hToken = 0;
    DWORD               dwReturnLength = 0;
    PTOKEN_USER         pTokenUser = NULL;

    BOOL    bResult = ::OpenProcessToken (GetCurrentProcess (), TOKEN_QUERY, &hToken);
    if ( bResult )
    {
        // security review 2/26/2002 BryanWal ok
        bResult  = ::GetTokenInformation (
                     hToken,
                     TokenUser,
                     NULL,
                     0,
                     &dwReturnLength);
        if ( !bResult && dwReturnLength > 0 )
        {
            pTokenUser = (PTOKEN_USER) malloc (dwReturnLength);

            if (pTokenUser)
            {
                // security review 2/26/2002 BryanWal ok
                bResult = ::GetTokenInformation (
                             hToken,
                             TokenUser,
                             pTokenUser,
                             dwReturnLength,
                             &dwReturnLength);
                if ( !bResult)
                {
                    DWORD dwErr = GetLastError ();
                    DisplaySystemError (NULL, dwErr);
                    free (pTokenUser);
                    pTokenUser = NULL;
                }
            }
        }
        else
        {
            DWORD dwErr = GetLastError ();
            DisplaySystemError (NULL, dwErr);
        }

        ::CloseHandle (hToken);
    }
    else
    {
        DWORD   dwErr = GetLastError ();
        DisplaySystemError (NULL, dwErr);
    }

    _TRACE (-1, L"Leaving EfspGetTokenUser\n");
    return pTokenUser;
}


HRESULT CCertMgrComponentData::CompleteEFSRecoveryAgent(CCertStoreGPE* pStore, PCCERT_CONTEXT pCertContext)
{
    _TRACE (1, L"Entering CCertMgrComponentData::CompleteEFSRecoveryAgent\n");
    HRESULT hr = S_OK;
    ASSERT (pCertContext);
    if ( !pCertContext || !pStore )
        return E_POINTER;

    // This is using to Enroll to create a new EFS Recovery Agent.
    // Get PSID of logged-in user and save to store


    // If the store is an empty store, we need to delete it before adding
    // the first cert.  Otherwise CertAddCertificateContextToStore () fails
    // with E_ACCESS_DENIED
    if ( 0 == pStore->GetCertCount () )
        pStore->DeleteEFSPolicy (false);
    hr = pStore->AddCertificateContext (pCertContext, m_pConsole, false);
    if ( SUCCEEDED (hr) )
    {
        pStore->Commit ();

        PTOKEN_USER pTokenUser = ::EfspGetTokenUser ();
        if ( pTokenUser )
        {
            pStore->AddCertToList (pCertContext, pTokenUser->User.Sid);
            free (pTokenUser);
        }

        if ( SUCCEEDED (hr) )
        {
            hr = ValidateCertChain (pCertContext);
        }
    }
    else
    {
        int     iRetVal = 0;
        CString text;
        CString caption;

        text.FormatMessage (IDS_CANT_ADD_CERT, pStore->GetLocalizedName (), 
                GetSystemMessage (hr));
        VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));

        m_pConsole->MessageBox (text, caption,
            MB_OK | MB_ICONWARNING, &iRetVal);
    }


// Exportable keys are not currently supported. We can uncomment this code if this
// feature becomes available again in the future.
/*
    int     iRetVal = 0;
    CString text;
    CString caption;

    VERIFY (text.LoadString (IDS_EXPORT_AND_DELETE_EFS_KEY));
    VERIFY (caption.LoadString (IDS_CREATE_AUTO_CERT_REQUEST));

    hr = m_pConsole->MessageBox (text, caption,
        MB_YESNO | MB_ICONQUESTION, &iRetVal);
    ASSERT (SUCCEEDED (hr));
    if ( SUCCEEDED (hr) && IDYES == iRetVal )
    {
        // Remove the private key from the cert.
        hr = CertSetCertificateContextProperty (pCertContext,
                CERT_KEY_PROV_INFO_PROP_ID, 0, 0);
        ASSERT (SUCCEEDED (hr));

        // Bring up the common file open dialog to get a filename
        // and the standard password dialog to get a password so
        // that I can write out the PFX file.
        HWND    hwndConsole = 0;
        hr = m_pConsole->GetMainWindow (&hwndConsole);
        ASSERT (SUCCEEDED (hr));
        if ( SUCCEEDED (hr) )
        {
            CString szFilter;
            VERIFY (szFilter.LoadString (IDS_SAVE_PFX_FILTER));

            CWnd    mainWindow;
            if ( mainWindow.Attach (hwndConsole) )
            {
                CFileDialog*    pFileDlg = new CFileDialog (FALSE,  // use as File Save As
                        L"pfx",         // default extension
                        NULL,               // preferred file name
                        OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_CREATEPROMPT | OFN_NOREADONLYRETURN,
                        (PCWSTR) szFilter,  
                        &mainWindow);
                if ( pFileDlg )
                {
                    CThemeContextActivator activator;
                    if ( IDOK == pFileDlg->DoModal () )
                    {
                        CString                             pathName = pFileDlg->GetPathName ();
                        CRYPTUI_WIZ_EXPORT_INFO             cwi;
                        CRYPTUI_WIZ_EXPORT_CERTCONTEXT_INFO cci;

                        ::ZeroMemory (&cwi, sizeof (cwi));
                        cwi.dwSize = sizeof (cwi);
                        cwi.pwszExportFileName = (PCWSTR) pathName;
                        cwi.dwSubjectChoice = CRYPTUI_WIZ_EXPORT_CERT_CONTEXT;
                        cwi.pCertContext = pCertContext;

                        ::ZeroMemory (&cci, sizeof (cci));
                        cci.dwSize = sizeof (cci);
                        cci.dwExportFormat = CRYPTUI_WIZ_EXPORT_FORMAT_PFX;
                        cci.fExportChain = TRUE;
                        cci.fExportPrivateKeys = TRUE;

                        CPassword   passwordDlg;


                        // Launch password dialog
                        CThemeContextActivator activator;
                        if ( IDOK == passwordDlg.DoModal () )
                        {
                            if ( !wcslen (passwordDlg.GetPassword ()) )
                            {
                                // If password string is empty, pass NULL.
                                cci.pwszPassword = 0;
                            }
                            else
                                cci.pwszPassword = passwordDlg.GetPassword ();

                            CThemeContextActivator activator;
                            BOOL  bResult = ::CryptUIWizExport (
                                    CRYPTUI_WIZ_NO_UI,
                                    0,      // hwndParent ignored
                                    0,      // pwszWizardTitle ignored
                                    &cwi,
                                    (void*) &cci);
                            if ( bResult )
                            {
                                hr = DeleteKeyFromRSABASE (pCertContext);
                            }
                            else
                            {
                                DWORD   dwErr = GetLastError ();
                                DisplaySystemError (dwErr);
                            }
                        }
                    }

                    delete pFileDlg;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

            }
            else
                ASSERT (0);
            VERIFY (mainWindow.Detach () == hwndConsole);
        }
    }
*/

    _TRACE (-1, L"Leaving CCertMgrComponentData::CompleteEFSRecoveryAgent: 0x%x\n", hr);
    return hr;
}

HRESULT CCertMgrComponentData::AddScopeNode(CCertMgrCookie * pNewCookie, const CString & strServerName, HSCOPEITEM hParent)
{
    _TRACE (1, L"Entering CCertMgrComponentData::AddScopeNode\n");
    ASSERT (pNewCookie);
    if ( !pNewCookie )
        return E_POINTER;

    HRESULT hr = S_OK;


    SCOPEDATAITEM tSDItem;

    // security review 2/26/2002 BryanWal ok
    ::ZeroMemory (&tSDItem,sizeof (tSDItem));
    tSDItem.mask = SDI_STR | SDI_IMAGE | SDI_STATE | SDI_PARAM | SDI_PARENT;
    tSDItem.displayname = MMC_CALLBACK;
    tSDItem.relativeID = hParent;
    tSDItem.nState = 0;

    switch (pNewCookie->m_objecttype)
    {
    case CERTMGR_USAGE:
    case CERTMGR_CRL_CONTAINER:
    case CERTMGR_CTL_CONTAINER:
    case CERTMGR_CERT_CONTAINER:
    case CERTMGR_LOG_STORE_GPE:
    case CERTMGR_LOG_STORE_RSOP:
    case CERTMGR_SAFER_COMPUTER_LEVELS:
    case CERTMGR_SAFER_USER_LEVELS:
    case CERTMGR_SAFER_COMPUTER_ENTRIES:
    case CERTMGR_SAFER_USER_ENTRIES:
        tSDItem.mask |= SDI_CHILDREN;
        tSDItem.cChildren = 0;
        break;

    case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
    case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
        ASSERT (0);
        break;

    default:
        break;
    }
    if ( pNewCookie != m_pRootCookie && m_pRootCookie )
        m_pRootCookie->m_listScopeCookieBlocks.AddHead ( (CBaseCookieBlock*) pNewCookie);
    if ( !strServerName.IsEmpty () )
        pNewCookie->m_strMachineName = strServerName;
    tSDItem.lParam = reinterpret_cast<LPARAM> ( (CCookie*) pNewCookie);
    tSDItem.nImage = QueryImage (*pNewCookie, FALSE);
    hr = m_pConsoleNameSpace->InsertItem (&tSDItem);
    if ( SUCCEEDED (hr) )
        pNewCookie->m_hScopeItem = tSDItem.ID;

    _TRACE (-1, L"Leaving CCertMgrComponentData::AddScopeNode: 0x%x\n", hr);
    return hr;
}

HRESULT CCertMgrComponentData::DeleteKeyFromRSABASE(PCCERT_CONTEXT pCertContext)
{
    _TRACE (1, L"Entering CCertMgrComponentData::DeleteKeyFromRSABASE\n");
    ASSERT (pCertContext);
    if ( !pCertContext )
        return E_POINTER;
    HRESULT hr = S_OK;
    DWORD   cbData = 0;

    BOOL bResult = ::CertGetCertificateContextProperty (pCertContext,
            CERT_KEY_PROV_INFO_PROP_ID, 0, &cbData);
    ASSERT (bResult);
    if ( bResult )
    {
        PCRYPT_KEY_PROV_INFO pKeyProvInfo = (PCRYPT_KEY_PROV_INFO) ::LocalAlloc (LPTR, cbData);
        if ( pKeyProvInfo )
        {
            bResult = ::CertGetCertificateContextProperty (pCertContext,
                    CERT_KEY_PROV_INFO_PROP_ID, pKeyProvInfo, &cbData);
            ASSERT (bResult);
            if ( bResult )
            {
                HCRYPTPROV  hProv = 0;
                bResult = ::CryptAcquireContext (&hProv,
                        pKeyProvInfo->pwszContainerName,
                        pKeyProvInfo->pwszProvName,
                        pKeyProvInfo->dwProvType,
                        CRYPT_DELETEKEYSET);
                ASSERT (bResult);
                if ( !bResult )
                {
                    DWORD   dwErr = GetLastError ();
                    hr = HRESULT_FROM_WIN32 (dwErr);
                    DisplaySystemError (dwErr);
                }
            }
            else
            {
                DWORD   dwErr = GetLastError ();
                hr = HRESULT_FROM_WIN32 (dwErr);
                DisplaySystemError (dwErr);
            }

            ::LocalFree (pKeyProvInfo);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        DWORD   dwErr = GetLastError ();
        hr = HRESULT_FROM_WIN32 (dwErr);
        DisplaySystemError (dwErr);
    }


    _TRACE (-1, L"Leaving CCertMgrComponentData::DeleteKeyFromRSABASE: 0x%x\n", hr);
    return hr;
}

HRESULT CCertMgrComponentData::ReleaseResultCookie (
        CBaseCookieBlock *  pResultCookie,
        CCookie&            rootCookie,
        HCERTSTORE          hStoreHandle,
        POSITION            pos2)
{
//  _TRACE (1, L"Entering CCertMgrComponentData::ReleaseResultCookie\n");
    CCertMgrCookie* pCookie = reinterpret_cast <CCertMgrCookie*> (pResultCookie);
    ASSERT (pCookie);
    if ( pCookie )
    {
        switch (pCookie->m_objecttype)
        {
        case CERTMGR_CERTIFICATE:
            {
                CCertificate* pCert = reinterpret_cast <CCertificate*> (pCookie);
                ASSERT (pCert);
                if ( pCert && pCert->GetCertStore () )
                {
                    if ( pCert->GetCertStore ()->GetStoreHandle () == hStoreHandle )
                    {
                        // pCookie and pCert point to the same object
                        pResultCookie = rootCookie.m_listResultCookieBlocks.GetAt (pos2);
                        ASSERT (pResultCookie);
                        rootCookie.m_listResultCookieBlocks.RemoveAt (pos2);
                        if ( pResultCookie )
                        {
                            pResultCookie->Release ();
                        }
                    }
                    pCert->GetCertStore ()->Close ();
                }
            }
            break;

        case CERTMGR_CTL:
        case CERTMGR_AUTO_CERT_REQUEST:
            {
                CCTL* pCTL = reinterpret_cast <CCTL*> (pCookie);
                ASSERT (pCTL);
                if ( pCTL )
                {
                    if ( pCTL->GetCertStore ().GetStoreHandle () == hStoreHandle )
                    {
                        // pCookie and pCert point to the same object
                        pResultCookie = rootCookie.m_listResultCookieBlocks.GetAt (pos2);
                        ASSERT (pResultCookie);
                        rootCookie.m_listResultCookieBlocks.RemoveAt (pos2);
                        if ( pResultCookie )
                        {
                            pResultCookie->Release ();
                        }
                    }
                    pCTL->GetCertStore ().Close ();
                }
            }
            break;

        case CERTMGR_CRL:
            {
                CCRL* pCRL = reinterpret_cast <CCRL*> (pCookie);
                ASSERT (pCRL);
                if ( pCRL )
                {
                    if ( pCRL->GetCertStore ().GetStoreHandle () == hStoreHandle )
                    {
                        // pCookie and pCert point to the same object
                        pResultCookie = rootCookie.m_listResultCookieBlocks.GetAt (pos2);
                        ASSERT (pResultCookie);
                        rootCookie.m_listResultCookieBlocks.RemoveAt (pos2);
                        if ( pResultCookie )
                        {
                            pResultCookie->Release ();
                        }
                    }
                    pCRL->GetCertStore ().Close ();
                }
            }
            break;

        default:
//          _TRACE (0, L"CCertMgrComponentData::ReleaseResultCookie () - bad cookie type: 0x%x\n", 
//                    pCookie->m_objecttype); 
            break;
        }
    }

//  _TRACE (-1, L"Leaving CCertMgrComponentData::ReleaseResultCookie: S_OK\n");
    return S_OK;
}

void CCertMgrComponentData::SetResultData(LPRESULTDATA pResultData)
{
    _TRACE (1, L"Entering CCertMgrComponentData::SetResultData\n");
    ASSERT (pResultData);
    if ( pResultData && pResultData != m_pResultData )
    {
        if ( m_pResultData )
            m_pResultData->Release ();
        m_pResultData = pResultData;
        m_pResultData->AddRef ();
    }
    _TRACE (-1, L"Leaving CCertMgrComponentData::SetResultData\n");
}

HRESULT CCertMgrComponentData::GetResultData(LPRESULTDATA* ppResultData)
{
    HRESULT hr = S_OK;

    if ( !ppResultData )
        hr = E_POINTER;
    else if ( !m_pResultData )
    {
        if ( m_pConsole )
        {
            hr = m_pConsole->QueryInterface(IID_PPV_ARG (IResultData, &m_pResultData));
            _ASSERT (SUCCEEDED (hr));
        }
        else
            hr = E_FAIL;
    }
    
    if ( SUCCEEDED (hr) && m_pResultData )
    {
        *ppResultData = m_pResultData;
        m_pResultData->AddRef ();
    }

    return hr;
}
///////////////////////////////////////////////////////////////////////////////
//
// Check to see if a child scope pane object exists of the desired type
// immediately below hParent
//
///////////////////////////////////////////////////////////////////////////////
bool CCertMgrComponentData::ContainerExists(HSCOPEITEM hParent, CertificateManagerObjectType objectType)
{
    _TRACE (1, L"Entering CCertMgrComponentData::ContainerExists\n");
    bool            bExists = false;
    CCertMgrCookie* pCookie = 0;
    HSCOPEITEM      hChild = 0;
    MMC_COOKIE      lCookie = 0;
    HRESULT         hr = m_pConsoleNameSpace->GetChildItem (hParent,
            &hChild, &lCookie);
    ASSERT (SUCCEEDED (hr));
    while ( SUCCEEDED (hr) && hChild )
    {
        pCookie = reinterpret_cast <CCertMgrCookie*> (lCookie);
        ASSERT (pCookie);
        if ( pCookie )
        {
            if ( pCookie->m_objecttype == objectType )
            {
                bExists = true;
                break;
            }
        }
        hr = m_pConsoleNameSpace->GetNextItem (hChild, &hChild, &lCookie);
        ASSERT (SUCCEEDED (hr));
    }

    _TRACE (-1, L"Leaving CCertMgrComponentData::ContainerExists\n");
    return bExists;
}


void CCertMgrComponentData::DisplayAccessDenied ()
{
    _TRACE (1, L"Entering CCertMgrComponentData::DisplayAccessDenied\n");
    DWORD   dwErr = GetLastError ();
    ASSERT (E_ACCESSDENIED == dwErr);
    if ( E_ACCESSDENIED == dwErr )
    {
        LPVOID lpMsgBuf = 0;
        
        // security review 2/26/2002 BryanWal ok
        ::FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                GetLastError (),
                MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                 (PWSTR) &lpMsgBuf,    0,    NULL );
            
        // Display the string.
        CString caption;
        VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
        int     iRetVal = 0;
        VERIFY (SUCCEEDED (m_pConsole->MessageBox ( (PWSTR) lpMsgBuf, caption,
            MB_ICONWARNING | MB_OK, &iRetVal)));

        // Free the buffer.
        LocalFree (lpMsgBuf);
    }
    _TRACE (-1, L"Leaving CCertMgrComponentData::DisplayAccessDenied\n");
}


HRESULT CCertMgrComponentData::DeleteCTLFromResultPane (CCTL * pCTL, LPDATAOBJECT pDataObject)
{
    _TRACE (1, L"Entering CCertMgrComponentData::DeleteCTLFromResultPane\n");
    ASSERT (pCTL);
    ASSERT (pDataObject);
    if ( !pCTL || !pDataObject )
        return E_POINTER;

    HRESULT         hr = S_OK;
    if ( pCTL->DeleteFromStore () )
    {
        hr = pCTL->GetCertStore ().Commit ();
        ASSERT (SUCCEEDED (hr));
        if ( SUCCEEDED (hr) )
        {
            HRESULTITEM itemID  = 0;
            hr = m_pResultData->FindItemByLParam ( (LPARAM) pCTL, &itemID);
            if ( SUCCEEDED (hr) )
            {
                hr = m_pResultData->DeleteItem (itemID, 0);
                ASSERT (SUCCEEDED (hr));
            }
        
            // If we can't succeed in removing this one item, then update the whole panel.
            if ( !SUCCEEDED (hr) )
            {
                hr = m_pConsole->UpdateAllViews (pDataObject, 0, 0);
            }
        }
    }
    else
    {
        DisplayAccessDenied ();
    }

    _TRACE (-1, L"LeavingLeaving CCertMgrComponentData::DeleteCTLFromResultPane: 0x%x\n", hr);
    return hr;
}


CString CCertMgrComponentData::GetThisComputer() const
{
    _TRACE (0, L"Entering and leaving CCertMgrComponentData::GetThisComputer\n");
    return m_szThisComputer;
}

typedef struct _ENUM_LOG_ARG {
    DWORD                           m_dwFlags;
    CTypedPtrList<CPtrList, CCertStore*>* m_pStoreList;
    PCWSTR                          m_pcszMachineName;
    CCertMgrComponentData*          m_pCompData;
    LPCONSOLE                       m_pConsole;
} ENUM_LOG_ARG, *PENUM_LOG_ARG;



static BOOL WINAPI EnumLogCallback (
    IN const void* pwszSystemStore,
    IN DWORD dwFlags,
    IN PCERT_SYSTEM_STORE_INFO /*pStoreInfo*/,
    IN OPTIONAL void* /*pvReserved*/,
    IN OPTIONAL void *pvArg
    )
{
    _TRACE (1, L"Entering EnumLogCallback\n");
    BOOL            bResult = TRUE;
    PENUM_LOG_ARG   pEnumArg = (PENUM_LOG_ARG) pvArg;

    // Create new cookies
    SPECIAL_STORE_TYPE  storeType = GetSpecialStoreType ((PWSTR) pwszSystemStore);

    //
    // We will not expose the ACRS store for machines or users.  It is not
    // interesting or useful at this level.  All Auto Cert Requests should
    // be managed only at the policy level.
    //
    if ( ACRS_STORE != storeType )
    {
        if ( pEnumArg->m_pCompData->ShowArchivedCerts () )
            dwFlags |= CERT_STORE_ENUM_ARCHIVED_FLAG;
        CCertStore* pStore = new CCertStore (
                CERTMGR_LOG_STORE,
                CERT_STORE_PROV_SYSTEM,
                dwFlags,
                pEnumArg->m_pcszMachineName,
                (PCWSTR) pwszSystemStore,
                (PCWSTR) pwszSystemStore,
                _T (""), storeType,
                pEnumArg->m_dwFlags,
                pEnumArg->m_pConsole);
        if ( pStore )
        {
            pEnumArg->m_pStoreList->AddTail (pStore);
        }
    }

    _TRACE (-1, L"Leaving EnumLogCallback\n");
    return bResult;
}


HRESULT CCertMgrComponentData::EnumerateLogicalStores (CTypedPtrList<CPtrList, CCertStore*>*    pStoreList)
{
    _TRACE (1, L"Entering CCertMgrComponentData::EnumerateLogicalStores\n");
    CWaitCursor             cursor;
    HRESULT                 hr = S_OK;
    ENUM_LOG_ARG            enumArg;
    DWORD                   dwFlags = GetLocation ();

    // security review 2/26/2002 BryanWal ok
    ::ZeroMemory (&enumArg, sizeof (enumArg));
    enumArg.m_dwFlags = dwFlags;
    enumArg.m_pStoreList = pStoreList;
    enumArg.m_pcszMachineName =
            QueryRootCookie ().QueryNonNULLMachineName ();
    enumArg.m_pCompData = this;
    enumArg.m_pConsole = m_pConsole;
    CString location;
    void*   pvPara = 0;

    

    if ( !GetManagedService ().IsEmpty () )
    {
        if ( !GetManagedComputer ().IsEmpty () )
        {
            location = GetManagedComputer () + _T("\\") +
                    GetManagedComputer ();
            pvPara = (void *) (PCWSTR) location;
        }
        else
            pvPara = (void *) (PCWSTR) GetManagedService ();
    }
    else if ( !GetManagedComputer ().IsEmpty () )
    {
        pvPara = (void *) (PCWSTR) GetManagedComputer ();
    }

    CString fileName = GetCommandLineFileName ();
    if ( fileName.IsEmpty () )
    {
        // Ensure creation of MY store
        HCERTSTORE hTempStore = ::CertOpenStore (CERT_STORE_PROV_SYSTEM,
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                NULL,
                dwFlags | CERT_STORE_SET_LOCALIZED_NAME_FLAG,
                MY_SYSTEM_STORE_NAME);
        if ( hTempStore )  // otherwise, store is read only
        {
            VERIFY (::CertCloseStore (hTempStore, CERT_CLOSE_STORE_CHECK_FLAG));
        }
        else
        {
            _TRACE (0, L"CertOpenStore (%s) failed: 0x%x\n", 
                        MY_SYSTEM_STORE_NAME, GetLastError ());     
        }

        if ( !::CertEnumSystemStore (dwFlags, pvPara, &enumArg, EnumLogCallback) )
        {
            DWORD   dwErr = GetLastError ();
            CString text;
            CString caption;

            VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
            if ( ERROR_ACCESS_DENIED == dwErr )
            {
                VERIFY (text.LoadString (IDS_NO_PERMISSION));

            }
            else
            {
                text.FormatMessage (IDS_CANT_ENUMERATE_SYSTEM_STORES, GetSystemMessage (dwErr));
            }
            int     iRetVal = 0;
            VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption,
                    MB_OK, &iRetVal)));
            hr = HRESULT_FROM_WIN32 (dwErr);
            hr = HRESULT_FROM_WIN32 (dwErr);
        }
    }
    else
    {
        // Create new cookies
        dwFlags = 0;

        // If there is a class file-based store, use that, otherwise allocate
        // a new one.
        CCertStore* pStore = m_pFileBasedStore;
        if ( !pStore )
            pStore = new CCertStore (
                CERTMGR_LOG_STORE,
                CERT_STORE_PROV_FILENAME_W,
                dwFlags,
                QueryRootCookie ().QueryNonNULLMachineName (),
                fileName, fileName, _T (""), NO_SPECIAL_TYPE,
                m_dwLocationPersist,
                m_pConsole);
        else
            pStore->AddRef ();
        if ( pStore )
        {
            pStoreList->AddTail (pStore);
        }
    }

    _TRACE (-1, L"LeavingLeaving CCertMgrComponentData::EnumerateLogicalStores: 0x%x\n", hr);
    return hr;
}

HRESULT CCertMgrComponentData::OnNotifyPreload(
        LPDATAOBJECT /*lpDataObject*/, 
        HSCOPEITEM hRootScopeItem)
{
    _TRACE (1, L"Entering CCertMgrComponentData::OnNotifyPreload\n");
    ASSERT (m_fAllowOverrideMachineName);
    HRESULT hr = S_OK;

    QueryBaseRootCookie ().m_hScopeItem = hRootScopeItem;

    // The machine name will be changed only if the stores are machine-based
    // stores.
    switch (m_dwLocationPersist)
    {
    case CERT_SYSTEM_STORE_LOCAL_MACHINE:
    case CERT_SYSTEM_STORE_CURRENT_SERVICE:
    case CERT_SYSTEM_STORE_SERVICES:
        {
            
            CString     machineName = QueryRootCookie ().QueryNonNULLMachineName();

            hr = ChangeRootNodeName (machineName);
        }
        break;

    default:
        break;
    }

    _TRACE (-1, L"LeavingLeaving CCertMgrComponentData::OnNotifyPreload: 0x%x\n", hr);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  ChangeRootNodeName ()
//
//  Purpose:    Change the text of the root node
//
//  Input:      newName - the new machine name that the snapin manages
//  Output:     Returns S_OK on success
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CCertMgrComponentData::ChangeRootNodeName(const CString & newName)
{
    _TRACE (1, L"Entering CCertMgrComponentData::ChangeRootNodeName\n");

    if ( !QueryBaseRootCookie ().m_hScopeItem )
    {
        if ( m_hRootScopeItem )
            QueryBaseRootCookie ().m_hScopeItem = m_hRootScopeItem;
        else
            return E_UNEXPECTED;
    }

    CString     formattedName;

    switch (m_dwLocationPersist)
    {
    case CERT_SYSTEM_STORE_LOCAL_MACHINE:
        {
            CString     machineName (newName);

            // If machineName is empty, then this manages the local machine.  Get
            // the local machine name.  Then format the computer name with the snapin
            // name
            if ( IsLocalComputername (machineName) )
            {
                formattedName.LoadString (IDS_SCOPE_SNAPIN_TITLE_LOCAL_MACHINE);
                m_szManagedComputer = L"";
            }
            else
            {
                machineName.MakeUpper ();
                formattedName.FormatMessage (IDS_SCOPE_SNAPIN_TITLE_MACHINE, machineName);
                m_szManagedComputer = machineName;
            }
        }
        break;

    case CERT_SYSTEM_STORE_CURRENT_SERVICE:
    case CERT_SYSTEM_STORE_SERVICES:
        {
            CString     machineName (newName);

            // If machineName is empty, then this manages the local machine.  Get
            // the local machine name.  Then format the computer name with the snapin
            // name
            if ( IsLocalComputername (machineName) )
            {
                // Get this machine name and add it to the string.
                formattedName.FormatMessage (IDS_SCOPE_SNAPIN_TITLE_SERVICE_LOCAL_MACHINE,
                        m_szManagedServiceDisplayName);
                m_szManagedComputer = L"";
            }
            else
            {
                formattedName.FormatMessage (IDS_SCOPE_SNAPIN_TITLE_SERVICE,
                        m_szManagedServiceDisplayName, machineName);
                m_szManagedComputer = machineName;
            }
        }
        break;

    case CERT_SYSTEM_STORE_CURRENT_USER:
        VERIFY (formattedName.LoadString (IDS_SCOPE_SNAPIN_TITLE_USER));
        break;

    case 0:
        VERIFY (formattedName.LoadString (IDS_SCOPE_SNAPIN_TITLE_FILE));
        break;

    default:
        return S_OK;
    }


    SCOPEDATAITEM   item;
    // security review 2/26/2002 BryanWal ok
    ::ZeroMemory (&item, sizeof (item));
    item.mask = SDI_STR;
    item.displayname = (PWSTR) (PCWSTR) formattedName;
    item.ID = QueryBaseRootCookie ().m_hScopeItem;

    HRESULT hr = m_pConsoleNameSpace->SetItem (&item);
    if ( FAILED (hr) )
    {
        _TRACE (0, L"IConsoleNameSpace2::SetItem () failed: 0x%x\n", hr);        
    }
    if ( SUCCEEDED (hr) )
        m_fInvalidComputer = false;

    _TRACE (-1, L"LeavingLeaving CCertMgrComponentData::ChangeRootNodeName: 0x%x\n", hr);
    return hr;
}

HRESULT CCertMgrComponentData::CreateContainers(
            HSCOPEITEM hScopeItem, 
            CCertStore& rTargetStore)
{
    _TRACE (1, L"Entering CCertMgrComponentData::CreateContainers\n");
    HRESULT hr = S_OK;

    // If the container was a cert store and it does not
    // already have Certs/CRLs/CTLs, instantiate a new CRL container
    // in the scope pane.
    if ( -1 != hScopeItem )
    {
        SCOPEDATAITEM item;

        // security review 2/26/2002 BryanWal ok
        ::ZeroMemory (&item, sizeof (item));
        item.mask = SDI_STATE;
        item.nState = 0;
        item.ID = hScopeItem;

        hr = m_pConsoleNameSpace->SetItem (&item);
        if ( FAILED (hr) )
        {
            _TRACE (0, L"IConsoleNameSpace2::SetItem () failed: 0x%x\n", hr);        
        }
        if ( CERTMGR_LOG_STORE_GPE != rTargetStore.m_objecttype && 
                CERTMGR_LOG_STORE_RSOP != rTargetStore.m_objecttype)
        {
            AddContainersToScopePane (hScopeItem,
                    rTargetStore, true);
        }
    }

    _TRACE (-1, L"LeavingLeaving CCertMgrComponentData::CreateContainers: 0x%x\n", hr);
    return hr;
}



HRESULT CCertMgrComponentData::OnOptions(LPDATAOBJECT pDataObject)
{
    _TRACE (1, L"Entering CCertMgrComponentData::OnOptions\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    HWND        hParent = 0;


    // Get parent window handle and attach to a CWnd object
    HRESULT hr = m_pConsole->GetMainWindow (&hParent);
    ASSERT (SUCCEEDED (hr));
    if ( SUCCEEDED (hr) )
    {
        int             activeView = m_activeViewPersist;
        BOOL            bShowPhysicalStores = m_bShowPhysicalStoresPersist;
        BOOL            bShowArchivedCerts = m_bShowArchivedCertsPersist;
        CWnd            parentWnd;
        VERIFY (parentWnd.Attach (hParent));
        CViewOptionsDlg optionsDlg (&parentWnd,
                this);

        CThemeContextActivator activator;
        INT_PTR iReturn = optionsDlg.DoModal ();
        ASSERT (-1 != iReturn);
        if ( -1 == iReturn )
            hr = (HRESULT)iReturn;

        if ( IDOK == iReturn )
        {
            long    hint = 0;

            if ( activeView != m_activeViewPersist )
            {
                hint |= HINT_CHANGE_VIEW_TYPE;
                if ( IDM_USAGE_VIEW == m_activeViewPersist )
                {
                    // view by usage
                    ASSERT (m_pHeader);
                    if ( m_pHeader && GetObjectType (pDataObject) == CERTMGR_SNAPIN )
                    {
                        CString str;
                        VERIFY (str.LoadString (IDS_COLUMN_PURPOSE) );
                        hr = m_pHeader->SetColumnText (0,
                                const_cast<PWSTR> ( (PCWSTR) str));
                    }
                }
                else
                {
                    // View by stores
                    ASSERT (m_pHeader);
                    if ( m_pHeader && GetObjectType (pDataObject) == CERTMGR_SNAPIN )
                    {
                        CString str;
                        VERIFY (str.LoadString (IDS_COLUMN_LOG_CERTIFICATE_STORE));
                        hr = m_pHeader->SetColumnText (0,
                                const_cast<PWSTR> ( (PCWSTR) str));
                    }
                }
            }

            if ( bShowPhysicalStores != m_bShowPhysicalStoresPersist )
                hint |= HINT_CHANGE_STORE_TYPE;
            
            if ( bShowArchivedCerts != m_bShowArchivedCertsPersist )
                hint |= HINT_SHOW_ARCHIVE_CERTS;

            if ( hint )
            {
                hr = m_pConsole->UpdateAllViews (pDataObject, 0, hint);
                ASSERT (SUCCEEDED (hr));
                m_fDirty = TRUE;
            }
        }
        parentWnd.Detach ();
    }

    _TRACE (-1, L"LeavingLeaving CCertMgrComponentData::OnOptions: 0x%x\n", hr);
    return hr;
}

bool CCertMgrComponentData::ShowArchivedCerts() const
{
    _TRACE (0, L"Entering and leaving CCertMgrComponentData::ShowArchivedCerts\n");
    if ( m_bShowArchivedCertsPersist )
        return true;
    else
        return false;
}


HRESULT CCertMgrComponentData::OnPropertyChange (LPARAM param)
{
    _TRACE (1, L"Entering CCertMgrComponentData::OnPropertyChange\n");
    ASSERT (param);
    if ( !param )
        return E_FAIL;
        
    HRESULT         hr = S_OK;
    LPDATAOBJECT    pDataObject = reinterpret_cast<LPDATAOBJECT>(param);
    bool            bHandled = false;

    CCertMgrCookie* pCookie = ConvertCookie (pDataObject);
    if ( pCookie )
    {
        switch (pCookie->m_objecttype)
        {
        case CERTMGR_SAFER_COMPUTER_ENTRY:
        case CERTMGR_SAFER_USER_ENTRY:
            {
                HRESULTITEM itemID = 0;

                if ( m_pResultData )
                {
                    pCookie->Refresh ();
                    hr = m_pResultData->FindItemByLParam ( (LPARAM) pCookie, &itemID);
                    if ( SUCCEEDED (hr) )
                    {
                        hr = m_pResultData->UpdateItem (itemID);
                        if ( FAILED (hr) )
                        {
                            _TRACE (0, L"IResultData::UpdateItem () failed: 0x%x\n", hr);          
                        }
                    }
                    else
                    {
                        _TRACE (0, L"IResultData::FindItemByLParam () failed: 0x%x\n", hr);          
                    }
                }
                else
                {
                    _TRACE (0, L"Unexpected error: m_pResultData was NULL\n");
                    hr = E_FAIL;
                }
                bHandled = true;
            }
            break;

        case CERTMGR_SAFER_COMPUTER_LEVEL:
        case CERTMGR_SAFER_USER_LEVEL:
            if ( m_pConsole )
                hr = m_pConsole->UpdateAllViews (pDataObject, 0, 0);
            break;

        default:
            break;
        }
    }

    if ( !bHandled && m_pCryptUIMMCCallbackStruct )
    {

        if ( pDataObject == reinterpret_cast<LPDATAOBJECT>(m_pCryptUIMMCCallbackStruct->param) )
        {
            ::MMCFreeNotifyHandle (m_pCryptUIMMCCallbackStruct->lNotifyHandle);
            pCookie = ConvertCookie (pDataObject);
            if ( pCookie )
            {
                ASSERT (CERTMGR_CERTIFICATE == pCookie->m_objecttype);
                if ( CERTMGR_CERTIFICATE == pCookie->m_objecttype )
                {
                    CCertificate* pCert = reinterpret_cast<CCertificate*>(pCookie);
                    ASSERT (pCert);
                    if ( pCert && pCert->GetCertStore () )
                    {
                        pCert->GetCertStore ()->SetDirty ();
                        pCert->GetCertStore ()->Commit ();
                        pCert->GetCertStore ()->Close ();
                    }
                }
            }
            
            pDataObject->Release ();
            ::GlobalFree (m_pCryptUIMMCCallbackStruct);
            m_pCryptUIMMCCallbackStruct = 0;
            m_pConsole->UpdateAllViews (pDataObject, 0, 0);
        }
    }
    

    _TRACE (-1, L"LeavingLeaving CCertMgrComponentData::OnPropertyChange: 0x%x\n", hr);
    return hr;
}

HRESULT CCertMgrComponentData::OnDeleteEFSPolicy(LPDATAOBJECT pDataObject, bool bCommitChanges)
{
    _TRACE (1, L"Entering CCertMgrComponentData::OnDeleteEFSPolicy\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    ASSERT (pDataObject);
    if ( !pDataObject )
        return E_POINTER;

    HRESULT         hr = S_OK;
    CCertMgrCookie* pCookie = ConvertCookie (pDataObject);
    ASSERT (pCookie);
    if ( pCookie )
    {
        CCertStoreGPE* pStore = reinterpret_cast <CCertStoreGPE*> (pCookie);
        ASSERT (pStore && EFS_STORE == pStore->GetStoreType () && !pStore->IsNullEFSPolicy () );
        if ( pStore && EFS_STORE == pStore->GetStoreType () && !pStore->IsNullEFSPolicy ()  )
        {
            pStore->DeleteEFSPolicy (bCommitChanges);

            // Force scope item selection to force call to 
            // IComponent::QueryResultViewType ()
            hr = m_pComponentConsole->SelectScopeItem (pStore->m_hScopeItem);
            hr = m_pConsole->UpdateAllViews (pDataObject, 0, HINT_EFS_ADD_DEL_POLICY);
            hr = OnNotifyExpand (pDataObject, TRUE, pStore->m_hScopeItem);
        }
    }

    _TRACE (-1, L"LeavingLeaving CCertMgrComponentData::OnDeleteEFSPolicy: 0x%x\n", hr);
    return hr;
}

HRESULT CCertMgrComponentData::OnInitEFSPolicy(LPDATAOBJECT pDataObject)
{
    _TRACE (1, L"Entering CCertMgrComponentData::OnInitEFSPolicy\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    ASSERT (pDataObject);
    if ( !pDataObject )
        return E_POINTER;

    HRESULT         hr = S_OK;
    CCertMgrCookie* pCookie = ConvertCookie (pDataObject);
    ASSERT (pCookie);
    if ( pCookie )
    {
        CCertStoreGPE* pStore = reinterpret_cast <CCertStoreGPE*> (pCookie);
        ASSERT (pStore && EFS_STORE == pStore->GetStoreType () && pStore->IsNullEFSPolicy () );
        if ( pStore && EFS_STORE == pStore->GetStoreType () && pStore->IsNullEFSPolicy () )
        {
            pStore->SetDirty ();
            pStore->AllowEmptyEFSPolicy ();
            pStore->PolicyChanged ();
            pStore->Commit ();
            hr = m_pConsole->UpdateAllViews (pDataObject, 0, HINT_EFS_ADD_DEL_POLICY);
        }
    }

    _TRACE (-1, L"LeavingLeaving CCertMgrComponentData::OnInitEFSPolicy: 0x%x\n", hr);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CCertMgrComponentData::RemoveResultCookies
//
// Remove and delete all the result cookies corresponding to the LPRESULTDATA
// object passed in.  Thus all cookies added to pResultData are released and
// removed from the master list.
//
///////////////////////////////////////////////////////////////////////////////
void CCertMgrComponentData::RemoveResultCookies(LPRESULTDATA pResultData)
{
    _TRACE (1, L"Entering CCertMgrComponentData::RemoveResultCookies\n");
    CCertMgrCookie* pCookie = 0;

    CCookie& rootCookie = QueryBaseRootCookie ();

    POSITION        curPos = 0;

    for (POSITION nextPos = rootCookie.m_listResultCookieBlocks.GetHeadPosition (); nextPos; )
    {
        curPos = nextPos;
        pCookie = reinterpret_cast <CCertMgrCookie*> (rootCookie.m_listResultCookieBlocks.GetNext (nextPos));
        ASSERT (pCookie);
        if ( pCookie )
        {
            if ( pCookie->m_resultDataID == pResultData )
            {
                pCookie->Release ();
                rootCookie.m_listResultCookieBlocks.RemoveAt (curPos);
            }
        }
    }
    _TRACE (-1, L"Leaving CCertMgrComponentData::RemoveResultCookies\n");
}


HRESULT CCertMgrComponentData::ValidateCertChain(PCCERT_CONTEXT pCertContext)
{
    _TRACE (1, L"Entering CCertMgrComponentData::ValidateCertChain\n");
    HRESULT hr = S_OK;
    ASSERT (pCertContext);
    if ( !pCertContext )
        return E_POINTER;

    CERT_CONTEXT_LIST   certChainList;
    BOOL bValidated = GetCertificateChain (
            const_cast<CERT_CONTEXT*>(pCertContext), 
            certChainList);
    if ( !bValidated )
    {
        int     iRetVal = 0;
        CString text;
        CString caption;

        VERIFY (text.LoadString (IDS_CERT_COULD_NOT_BE_VALIDATED));
        VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));

        hr = m_pConsole->MessageBox (text, caption,
            MB_OK, &iRetVal);
    }

    // Clean up list
    CERT_CONTEXT* pDeleteContext = 0;
    while (!certChainList.IsEmpty () )
    {
        pDeleteContext = certChainList.RemoveHead ();
        if ( pDeleteContext )
            ::CertFreeCertificateContext (pCertContext);
    }


    _TRACE (-1, L"LeavingLeaving CCertMgrComponentData::ValidateCertChain: 0x%x\n", hr);
    return hr;
}

HRESULT CCertMgrComponentData::RemoveCertChainFromPolicy(
            PCCERT_CONTEXT pCertContext, 
            CERT_CONTEXT_LIST& certChainsThatCantBeDeleted)
{
    _TRACE (1, L"Entering CCertMgrComponentData::RemoveCertChainFromPolicy\n");
    HRESULT hr = S_OK;
    ASSERT (pCertContext);
    if ( !pCertContext )
        return E_POINTER;

    CERT_CONTEXT_LIST   certChainList;
    BOOL bValidated = GetCertificateChain (
            const_cast<CERT_CONTEXT*>(pCertContext), 
            certChainList);
    if ( bValidated )
    {
        // Add this cert context to the chain
        certChainList.AddTail (
                const_cast<CERT_CONTEXT*>
                (::CertDuplicateCertificateContext (pCertContext)));

        CCertStoreGPE   CAStore (
                            CERT_SYSTEM_STORE_RELOCATE_FLAG,
                            _T (""),
                            _T (""),
                            CA_SYSTEM_STORE_NAME,
                            _T (""),
                            m_pGPEInformation,
                            NODEID_Machine,
                            m_pConsole);

        for (POSITION pos = certChainList.GetHeadPosition (); pos;)
        {
            PCCERT_CONTEXT pCertChainContext = certChainList.GetNext (pos);
            // Do not remove chain-certs whose EFS 
            // agents are still in the EFS store
            bool    bFound = false;
            for (POSITION posND = certChainsThatCantBeDeleted.GetHeadPosition (); 
                    posND; )
            {
                CERT_CONTEXT* pNonDelChainCertContext = certChainsThatCantBeDeleted.GetNext (posND);
                if ( pNonDelChainCertContext )
                {
                    if ( ::CertCompareCertificate (
                            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                            pCertChainContext->pCertInfo,
                            pNonDelChainCertContext->pCertInfo) )
                    {
                        bFound = true;
                        break;
                    }
                }
            }

            // Was found in the list of certs that cant be deleted
            // Try the next one.
            if ( bFound )
                continue;

            // Wasn't found in the list that can't be deleted.
            // Go ahead and delete
            DWORD   cbData = 20;
            BYTE    certHash[20];
            BOOL bReturn = ::CertGetCertificateContextProperty (
                    pCertContext,
                    CERT_SHA1_HASH_PROP_ID,
                    certHash,
                    &cbData);
            ASSERT (bReturn);
            if ( bReturn )
            {
                CRYPT_DATA_BLOB blob = {sizeof (certHash), certHash};
                PCCERT_CONTEXT pFoundCertContext = CertFindCertificateInStore(
                    CAStore.GetStoreHandle (),
                    0,
                    0,
                    CERT_FIND_SHA1_HASH,
                    &blob,
                    0);
                if ( pFoundCertContext )
                {
                    ::CertDeleteCertificateFromStore (pFoundCertContext);
                }
            }
        }

        CAStore.Commit ();
    }

    // Clean up list
    CERT_CONTEXT* pDeleteContext = 0;
    while (!certChainList.IsEmpty () )
    {
        pDeleteContext = certChainList.RemoveHead ();
        if ( pDeleteContext )
            ::CertFreeCertificateContext (pCertContext);
    }

    _TRACE (-1, L"LeavingLeaving CCertMgrComponentData::RemoveCertChainFromPolicy: 0x%x\n", hr);
    return hr;
}

STDMETHODIMP CCertMgrComponentData::GetLinkedTopics(LPOLESTR* lpCompiledHelpFiles)
{
    HRESULT hr = S_OK;


    if ( lpCompiledHelpFiles )
    {
        CString strLinkedTopic;

        UINT nLen = ::GetSystemWindowsDirectory (strLinkedTopic.GetBufferSetLength(2 * MAX_PATH), 2 * MAX_PATH);
        strLinkedTopic.ReleaseBuffer();
        if ( nLen )
        {
            strLinkedTopic += L"\\help\\";
            strLinkedTopic += m_strLinkedHelpFile;

            *lpCompiledHelpFiles = reinterpret_cast<LPOLESTR>
                    (CoTaskMemAlloc((strLinkedTopic.GetLength() + 1)* sizeof(wchar_t)));

            if ( *lpCompiledHelpFiles )
            {
                // security review 2/26/2002 BryanWal ok
                wcscpy(*lpCompiledHelpFiles, (PWSTR)(PCWSTR)strLinkedTopic);
            }
            else
                hr = E_OUTOFMEMORY;
        }
        else
            hr = E_FAIL;
    }
    else
        return E_POINTER;


    return hr;
}

STDMETHODIMP CCertMgrComponentData::GetHelpTopic(LPOLESTR* lpCompiledHelpFile)
{
    return CComponentData::GetHelpTopic (lpCompiledHelpFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\cmponent.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       cmponent.h
//
//  Contents:
//
//----------------------------------------------------------------------------
// cmponent.h : Declaration of CCertMgrComponent

#ifndef __CMPONENT_H_INCLUDED__
#define __CMPONENT_H_INCLUDED__

#include <cryptui.h>
#include <winsafer.h>
#include "cookie.h"  // CCertMgrCookie
#include "certifct.h"
#include "ctl.h"
#include "crl.h"
#include "SaferUtil.h"
#include "SaferEntry.h"



enum {
    MIN_MENU_ID = 99,
	IDM_USAGE_VIEW = 100,
	IDM_STORE_VIEW = 101,
	IDM_TASK_RENEW_NEW_KEY,
	IDM_TASK_RENEW_SAME_KEY,
	IDM_TASK_IMPORT,
	IDM_TASK_EXPORT,
	IDM_TASK_CTL_EXPORT,
	IDM_TASK_EXPORT_STORE,
	IDM_OPEN,
	IDM_TASK_OPEN,
	IDM_TASK_FIND,
	IDM_TOP_FIND,
	IDM_ENROLL_NEW_CERT,
    IDM_ENROLL_NEW_CERT_SAME_KEY,
	IDM_ENROLL_NEW_CERT_NEW_KEY,
	IDM_CTL_EDIT,
	IDM_NEW_CTL,
	IDM_ADD_DOMAIN_ENCRYPTED_RECOVERY_AGENT,
	IDM_ADD_DOMAIN_ENCRYPTED_RECOVERY_AGENT1,
	IDM_ADD_DOMAIN_ENCRYPTED_RECOVERY_AGENT2,
	IDM_CREATE_DOMAIN_ENCRYPTED_RECOVERY_AGENT,
	IDM_EDIT_ACRS,
	IDM_TASK_CRL_EXPORT,
	IDM_OPTIONS,
	IDM_INIT_POLICY,
	IDM_DEL_POLICY,
    IDM_TOP_CHANGE_COMPUTER,
    IDM_TASK_CHANGE_COMPUTER,
    IDM_NEW_ACRS,
    IDM_SAFER_LEVEL_SET_DEFAULT,
    IDM_SAFER_NEW_ENTRY_PATH,
    IDM_SAFER_NEW_ENTRY_HASH,
    IDM_SAFER_NEW_ENTRY_CERTIFICATE,
    IDM_SAFER_NEW_ENTRY_INTERNET_ZONE,
    IDM_TASK_PULSEAUTOENROLL,
    IDM_TOP_CREATE_NEW_SAFER_POLICY,
    IDM_TASK_CREATE_NEW_SAFER_POLICY,
    IDM_TOP_DELETE_NEW_SAFER_POLICY,
    IDM_TASK_DELETE_NEW_SAFER_POLICY,
    MAX_MENU_ID
};

// forward declarations
class CCertMgrDataObject;
class CCertMgrComponentData;


class CCertMgrComponent :
	public CComponent,
	public IExtendContextMenu,
	public ICertificateManager,
	public IExtendPropertySheet,
	public IResultDataCompareEx,
	public PersistStream
{
public:
	CCertMgrComponent();
	virtual ~CCertMgrComponent();
BEGIN_COM_MAP(CCertMgrComponent)
	COM_INTERFACE_ENTRY(ICertificateManager)
	COM_INTERFACE_ENTRY(IExtendContextMenu)
	COM_INTERFACE_ENTRY(IExtendPropertySheet)
	COM_INTERFACE_ENTRY(IResultDataCompareEx)
    // security review 2/26/2002 BryanWal ok
	COM_INTERFACE_ENTRY(IPersistStream)
	COM_INTERFACE_ENTRY_CHAIN(CComponent)
END_COM_MAP()

#if DBG==1
	ULONG InternalAddRef()
	{
        return CComObjectRoot::InternalAddRef();
	}
	ULONG InternalRelease()
	{
        return CComObjectRoot::InternalRelease();
	}
    int dbg_InstID;
#endif // DBG==1



// IExtendContextMenu
public:
  STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject,
                          LPCONTEXTMENUCALLBACK pCallbackUnknown,
                          long *pInsertionAllowed);
  STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);

// IResultDataCompareEx
  STDMETHOD(Compare)(RDCOMPARE* prdc, int* pnResult);

    // STDMETHOD(Compare)(LPARAM lUserParam, MMC_COOKIE cookieA, MMC_COOKIE cookieB, int* pnResult);

// IComponent implemented in CComponent
	// support methods for IComponent
	virtual HRESULT ReleaseAll();
	virtual HRESULT OnPropertyChange( LPARAM param );
	virtual HRESULT OnViewChange (LPDATAOBJECT pDataObject, LPARAM data, LPARAM hint);
	virtual HRESULT Show(CCookie* pcookie, LPARAM arg, HSCOPEITEM hScopeItem, LPDATAOBJECT pDataObject);
	virtual HRESULT Show(CCookie* pcookie, LPARAM arg, HSCOPEITEM hScopeItem);
	virtual HRESULT OnNotifyAddImages( LPDATAOBJECT pDataObject,
	                                   LPIMAGELIST lpImageList,
	                                   HSCOPEITEM hSelectedItem );

	HRESULT PopulateListbox(CCertMgrCookie* pcookie);
	HRESULT RefreshResultPane();

	static HRESULT LoadStrings();
    HRESULT LoadColumns( CCertMgrCookie* pcookie );

	CCertMgrComponentData& QueryComponentDataRef()
	{
		return (CCertMgrComponentData&)QueryBaseComponentDataRef();
	}

public:
	STDMETHOD(GetDisplayInfo)(RESULTDATAITEM* pResultDataItem);
	CCertMgrCookie* m_pViewedCookie; // CODEWORK I hate to have to do this...
	static const GUID m_ObjectTypeGUIDs[CERTMGR_NUMTYPES];
	static const BSTR m_ObjectTypeStrings[CERTMGR_NUMTYPES];

	inline CCertMgrCookie* ActiveCookie( CCookie* pBaseCookie )
	{
		return (CCertMgrCookie*)ActiveBaseCookie( pBaseCookie );
	}

// IExtendPropertySheet
	STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK pCall, LONG_PTR handle, LPDATAOBJECT pDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT pDataObject);

	CTypedPtrList<CPtrList, CCertStore*>	m_usageStoreList;

	// PersistStream
    HRESULT STDMETHODCALLTYPE Load(IStream __RPC_FAR *pStg);
    HRESULT STDMETHODCALLTYPE Save(IStream __RPC_FAR *pStgSave, BOOL fSameAsLoad);

private:
    bool DoChainDeletion (
            CCertMgrCookie* pCookie, 
            CCertStore** ppEFSStore);
    void DeleteCertFromContextList (
            CCertMgrCookie *pCookie, 
            CERT_CONTEXT_LIST& EFSCertContextList);
    void GetNotToBeDeletedCertChains (
            CERT_CONTEXT_LIST& EFSCertContextList);
    void CreateCertChainsFromMultiSelect (
            CCertMgrDataObject* pDO, 
            CCertMgrCookie* pCookie);
    void CreateCertChainsFromSingleSelect (
            CCertMgrCookie* pCookie);
    HRESULT AddLevel (
                const CString& szLevel, 
                DWORD dwLevel, 
                bool fIsMachine, 
                PCWSTR pszServerName);
	HRESULT AddSaferLevels (
                bool bIsComputer, 
                PCWSTR pszServerName,
                HKEY hGroupPolicyKey);
	bool m_bShowArchivedCertsStateWhenLogStoresEnumerated;
	LPDATAOBJECT					m_pPastedDO;
	CertificateManagerObjectType	m_currResultNodeType;
	bool							m_bUsageStoresEnumerated;
	CString							m_szDisplayInfoResult;
	UINT*							m_ColumnWidths[CERTMGR_NUMTYPES];
    int                             m_nSelectedCertColumn;
    int                             m_nSelectedCRLColumn;
    int                             m_nSelectedCTLColumn;
    int                             m_nSelectedSaferEntryColumn;
    CUsageCookie*                   m_pLastUsageCookie;
    LPTOOLBAR                       m_pToolbar;
    CERT_CONTEXT_LIST           	m_certChainsThatCantBeDeleted;

	void SetTextNotAvailable ();

protected:

    HRESULT SaferFinishEntryAndAdd (SAFER_ENTRY_TYPE previousType, 
                PSAFER_IDENTIFICATION_HEADER pCaiCommon, 
                bool bIsComputer, 
                long dwLevel,
                CSaferEntries* pSaferEntries, 
                const CString& szPreviousKey);
    HRESULT InsertNewSaferEntry (
                SAFER_ENTRY_TYPE type, 
                bool bIsMachine, 
                PCWSTR pwcszObjectName, 
                PSAFER_IDENTIFICATION_HEADER pCaiCommon,
                DWORD dwLevel,
                CSaferEntries* pSaferEntries,
                IGPEInformation* pGPEInformation,
                CCertificate* pCert,
                PCWSTR pszRSOPRegistryKey = 0);
    HRESULT EnumSaferCertificates (
                bool bIsMachine, 
                CCertStore& rCertStore, 
                CSaferEntries* pSaferEntries);
    HRESULT SaferEnumerateNonCertEntries (HKEY hGroupPolicyKey, bool bIsComputer);
    HRESULT SaferEnumerateRSOPNonCertEntries (
                bool bIsComputer,
                CSaferEntries* pSaferEntries);
    HRESULT SaferEnumerateCertEntries (
                bool bIsComputer,
                CSaferEntries* pSaferEntries);
	HRESULT SaferGetSingleEntry (
                bool bIsMachine, 
                SAFER_LEVEL_HANDLE hLevel, 
                GUID& rEntryGuid,
                DWORD dwLevelID);
	HRESULT SaferEnumerateEntriesAtLevel (bool bIsMachine, HKEY hGroupPolicyKey, DWORD dwLevel);
	HRESULT SaferEnumerateEntries (bool bIsComputer,
                CSaferEntries* pSaferEntries);
	HRESULT DisplayCertificateCountByUsage (const CString& usageName, int nCertCnt) const;
	bool DeletePrivateKey (CCertStore& rCertStoreDest, CCertStore& rCertStoreSrc);
	void CloseAndReleaseUsageStores ();
	HRESULT PasteCookie (
				CCertMgrCookie* pPastedCookie,
				CCertMgrCookie* pTargetCookie,
				CCertStore& rCertStore,
				SPECIAL_STORE_TYPE storeType,
				bool bContainsCerts,
				bool bContainsCRLs,
				bool bContainsCTLs,
				HSCOPEITEM hScopeItem,
				bool bRequestConfirmation,
				bool bIsMultipleSelect,
                LPDATAOBJECT pDataObject);
	HRESULT	DeleteCookie (
				CCertMgrCookie* pCookie,
				LPDATAOBJECT pDataObject,
				bool bRequestConfirmation,
				bool bIsMultipleSelect,
                bool bDoCommit);
	HRESULT RefreshResultItem (CCertMgrCookie* pCookie);
	HRESULT LaunchCommonCertDialog (CCertificate* pCert);
	HRESULT LaunchCommonCTLDialog (CCTL* pCTL);
	HRESULT LaunchCommonCRLDialog (CCRL* pCRL);
	virtual HRESULT OnOpen (LPDATAOBJECT pDataObject);
	CCertMgrCookie* ConvertCookie (LPDATAOBJECT pDataObject);
	HRESULT OnNotifyCutOrMove (LPARAM arg);
	HRESULT SaveWidths (CCertMgrCookie* pCookie);
	HRESULT LoadColumnsFromArrays (INT objecttype);
	STDMETHOD(Initialize)(LPCONSOLE lpConsole);
    STDMETHOD(GetResultViewType)(MMC_COOKIE cookie, BSTR* ppViewType, long* pViewOptions);
	HRESULT CopyPastedCRL (CCRL* pCRL, CCertStore& rCertStore);
	HRESULT CopyPastedCTL (CCTL* pCTL, CCertStore& rCertStore);
	HRESULT CopyPastedCert (
				CCertificate* pCert,
				CCertStore& rCertStore,
				const SPECIAL_STORE_TYPE storeType,
				bool bDeletePrivateKey,
                CCertMgrCookie* pTargetCookie,
                LPDATAOBJECT pDataObject);
	HRESULT OnNotifyQueryPaste (LPDATAOBJECT pDataObject, LPARAM arg, LPARAM param);
	HRESULT OnNotifyPaste (LPDATAOBJECT pDataObject, LPARAM arg, LPARAM param);
	void DisplayAccessDenied();
    STDMETHOD(Notify)(LPDATAOBJECT pDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
	HRESULT EnumCTLs (CCertStore& rCertStore);
	HRESULT EnumerateLogicalStores (CCertMgrCookie& parentCookie);
	HRESULT EnumCertsByUsage (CUsageCookie* pUsageCookie);
	HRESULT EnumCertificates (CCertStore& rCertStore);
	HRESULT DeleteCRLFromResultPane (CCRL * pCRL, LPDATAOBJECT pDataObject);
	HRESULT DeleteCertFromResultPane (
                CCertificate* pCert, 
                LPDATAOBJECT pDataObject, 
                bool bDoCommit);
	HRESULT DeleteSaferEntryFromResultPane (
                CSaferEntry * pSaferEntry, 
                LPDATAOBJECT pDataObject, 
                bool bDoCommit);
	virtual HRESULT OnNotifyDelete (LPDATAOBJECT pDataObject);
	virtual HRESULT OnNotifyRefresh (LPDATAOBJECT pDataObject);
	virtual HRESULT OnNotifySelect( LPDATAOBJECT pDataObject, BOOL fSelected);
	virtual HRESULT OnNotifySnapinHelp (LPDATAOBJECT pDataObject);
	virtual HRESULT OnNotifyDblClick( LPDATAOBJECT pDataObject );
    virtual HRESULT OnNotifyCanPasteOutOfProc (LPBOOL pbCanHandle);
    void SetComponentDataConsolePointer (LPCONSOLE m_pConsole);
}; // class CCertMgrComponent


// Enumeration for the icons used
enum
	{
	iIconDefault = 0,
	iIconCertificate,
	iIconCTL,
	iIconCRL,
	iIconAutoCertRequest,
    iIconAutoEnroll,
    iIconSaferLevel,
    iIconDefaultSaferLevel,
    iIconSaferHashEntry,
    iIconSaferURLEntry,
    iIconSaferNameEntry,
    iIconSettings,
    iIconSaferCertEntry,
	iIconLast		// Must be last
	};

typedef enum _COLNUM_CERTIFICATE {
	COLNUM_CERT_SUBJECT = 0,
	COLNUM_CERT_ISSUER,
	COLNUM_CERT_EXPIRATION_DATE,
	COLNUM_CERT_PURPOSE,
	COLNUM_CERT_CERT_NAME,
	COLNUM_CERT_STATUS,
    COLNUM_CERT_TEMPLATE,
	CERT_NUM_COLS
} COLNUM_ROOT;

typedef enum _COLNUM_CRL {
	COLNUM_CRL_ISSUER = 0,
	COLNUM_CRL_EFFECTIVE_DATE,
	COLNUM_CRL_NEXT_UPDATE,
	CRL_NUM_COLS
} COLNUM_CRL;

typedef enum _COLNUM_CTL {
	COLNUM_CTL_ISSUER = 0,
	COLNUM_CTL_EFFECTIVE_DATE,
	COLNUM_CTL_PURPOSE,
	COLNUM_CTL_FRIENDLY_NAME,
	CTL_NUM_COLS
} COLNUM_CTL;

typedef enum _COLNUM_SAFER_LEVELS {
    COLNUM_SAFER_LEVEL_NAME = 0,
    COLNUM_SAFER_LEVEL_DESCRIPTION,
    SAFER_LEVELS_NUM_COLS
} COLNUM_SAFER_LEVELS;

typedef enum _COLNUM_SAFER_ENTRIES {
    COLNUM_SAFER_ENTRIES_NAME = 0,
    COLNUM_SAFER_ENTRIES_TYPE,
    COLNUM_SAFER_ENTRIES_LEVEL,
    COLNUM_SAFER_ENTRIES_DESCRIPTION,
    COLNUM_SAFER_ENTRIES_LAST_MODIFIED_DATE,
    SAFER_ENTRIES_NUM_COLS
} COLNUM_SAFER_ENTRIES;


#endif // ~__CMPONENT_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\compdata.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       compdata.h
//
//  Contents:
//
//----------------------------------------------------------------------------

#ifndef __COMPDATA_H_INCLUDED__
#define __COMPDATA_H_INCLUDED__

#include "cmponent.h" // LoadIconsIntoImageList
#include "certifct.h"
#include "CTL.h"
#include "CRL.h"
#include "AutoCert.h"
#include "certmgrd.h"
#include "options.h"
#include "cookie.h"	// Added by ClassView
#include "StoreRSOP.h"
#include "RSOPObject.h"
#include "SaferLevel.h"
#include "SaferEntryCertificatePropertyPage.h"
#include "SaferEntryPathPropertyPage.h"
#include "SaferEntryHashPropertyPage.h"
#include "SaferEntryInternetZonePropertyPage.h"


#define HINT_CHANGE_VIEW_TYPE	        0x00000001
#define HINT_CHANGE_STORE_TYPE	        0x00000002
#define HINT_SHOW_ARCHIVE_CERTS	        0x00000004
#define HINT_PASTE_COOKIE		        0x00000008
#define HINT_EFS_ADD_DEL_POLICY	        0x00000010
#define HINT_IMPORT				        0x00000020
#define HINT_CHANGE_COMPUTER            0x00000040
#define HINT_REFRESH_STORES             0x00000080
#define HINT_CERT_ENROLLED_USAGE_MODE   0x00000100


class CCertStoreGPE;	// forward declaration
class CFindDialog;		// forward declaration

class CCertMgrComponentData:
	public CComponentData,
	public IExtendContextMenu,
	public IExtendPropertySheet,
	public PersistStream,
	public CHasMachineName
{
friend CCertMgrComponent;
friend CViewOptionsDlg;
friend CFindDialog;
friend CSaferEntryCertificatePropertyPage;
friend CSaferEntryPathPropertyPage;
friend CSaferEntryHashPropertyPage;
friend CSaferEntryInternetZonePropertyPage;

public:
    IGPEInformation* GetGPEInformation ()
    {
        if ( m_pGPEInformation )
            m_pGPEInformation->AddRef ();

        return m_pGPEInformation;
    }

    IRSOPInformation* GetRSOPInformation (bool bIsComputer)
    {
        if ( bIsComputer )
        {
            if ( m_pRSOPInformationComputer )
                m_pRSOPInformationComputer->AddRef ();

            return m_pRSOPInformationComputer;
        }
        else
        {
            if ( m_pRSOPInformationUser )
                m_pRSOPInformationUser->AddRef ();

            return m_pRSOPInformationUser;
        }
    }

	CertificateManagerObjectType GetObjectType (LPDATAOBJECT pDataObject);

// Use DECLARE_NOT_AGGREGATABLE(CCertMgrComponentData)
// if you don't want your object to support aggregation
//DECLARE_AGGREGATABLE(CCertMgrComponentData)
//DECLARE_REGISTRY(CCertMgrComponentData, _T("CERTMGR.CertMgrObject.1"), _T("CERTMGR.CertMgrObject.1"), IDS_CERTMGR_DESC, THREADFLAGS_BOTH)

	CCertMgrComponentData();
	virtual ~CCertMgrComponentData();
BEGIN_COM_MAP(CCertMgrComponentData)
	COM_INTERFACE_ENTRY(IExtendPropertySheet)
    // security review 2/27/2002 BryanWal ok
	COM_INTERFACE_ENTRY(IPersistStream)
	COM_INTERFACE_ENTRY_CHAIN(CComponentData)
	COM_INTERFACE_ENTRY(IExtendContextMenu)
END_COM_MAP()

#if DBG==1
	ULONG InternalAddRef()
	{
        return CComObjectRoot::InternalAddRef();
	}
	ULONG InternalRelease()
	{
        return CComObjectRoot::InternalRelease();
	}
    int dbg_InstID;
#endif // DBG==1

// IComponentData
	STDMETHOD(CreateComponent)(LPCOMPONENT* ppComponent);
	STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);

// IExtendPropertySheet
	STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK pCall, LONG_PTR handle, LPDATAOBJECT pDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT pDataObject);

// IExtendContextMenu
public:
    const CRSOPObjectArray* GetRSOPObjectArrayComputer () const
    {
        return &m_rsopObjectArrayComputer;
    }
    const CRSOPObjectArray* GetRSOPObjectArrayUser () const
    {
        return &m_rsopObjectArrayUser;
    }

    CCertMgrCookie* GetRootCookie ()
    {
        return 	m_pRootCookie;
    }

	void RemoveResultCookies (LPRESULTDATA pResultData);
	bool ShowArchivedCerts () const;
	HRESULT CreateContainers (
			HSCOPEITEM hScopeItem,
			CCertStore& rTargetStore);
	HRESULT EnumerateLogicalStores (CTypedPtrList<CPtrList, CCertStore*>*	pStoreList);
	CString GetThisComputer() const;
	void SetResultData (LPRESULTDATA pResultData);
	CUsageCookie* FindDuplicateUsage (HSCOPEITEM hParent, LPCWSTR pszName);
	LPCONSOLENAMESPACE GetConsoleNameSpace () const;
	DWORD GetLocation () const;
	CString GetManagedComputer () const;
	CString GetManagedService () const;
	CString GetCommandLineFileName () const;
	HRESULT RefreshScopePane (LPDATAOBJECT pDataObject);
	STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject,
                          LPCONTEXTMENUCALLBACK pCallbackUnknown,
                          long *pInsertionAllowed);
	STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);

    HRESULT STDMETHODCALLTYPE Load(IStream __RPC_FAR *pStg);
    HRESULT STDMETHODCALLTYPE Save(IStream __RPC_FAR *pStgSave, BOOL fSameAsLoad);

	// needed for Initialize()
	virtual HRESULT LoadIcons(LPIMAGELIST pImageList, BOOL fLoadLargeIcons);

	// needed for Notify()
	virtual HRESULT OnNotifyExpand(LPDATAOBJECT pDataObject, BOOL bExpanding, HSCOPEITEM hParent);

	// needed for GetDisplayInfo(), must be defined by subclass
	virtual BSTR QueryResultColumnText(CCookie& basecookieref, int nCol );
	virtual int QueryImage(CCookie& basecookieref, BOOL fOpenImage);

	virtual CCookie& QueryBaseRootCookie();

	inline CCertMgrCookie* ActiveCookie( CCookie* pBaseCookie )
	{
		return (CCertMgrCookie*)ActiveBaseCookie( pBaseCookie );
	}

	inline CCertMgrCookie& QueryRootCookie()
	{
        ASSERT (m_pRootCookie);
	    return *m_pRootCookie;
	}

	virtual HRESULT OnNotifyRelease(LPDATAOBJECT pDataObject, HSCOPEITEM hItem);


	// CHasMachineName
	DECLARE_FORWARDS_MACHINE_NAME( (m_pRootCookie) )

    // ISnapinHelp2
    STDMETHOD(GetLinkedTopics)(LPOLESTR* lpCompiledHelpFiles);
    STDMETHOD(GetHelpTopic)(LPOLESTR* lpCompiledHelpFile);

    bool ComputerIsStandAlone () const
    {
        return m_bMachineIsStandAlone;
    }

    void IncrementOpenSaferPageCount ()
    {
        ASSERT (m_nOpenSaferPageRefCount >= 0);
        m_critSec.Lock ();
        m_nOpenSaferPageRefCount++;
        m_critSec.Unlock ();
    }

    void DecrementOpenSaferPageCount ()
    {
        ASSERT (m_nOpenSaferPageRefCount > 0);
        m_critSec.Lock ();
        if ( m_nOpenSaferPageRefCount > 0 )
            m_nOpenSaferPageRefCount--;
        m_critSec.Unlock ();
    }

    int GetOpenSaferPageCount () const
    {
        return m_nOpenSaferPageRefCount;
    }

protected:
    bool                m_bSaferSupported;
    DWORD*              m_pdwSaferLevels;
	DWORD               m_dwDefaultSaferLevel;
    CRSOPObjectArray    m_rsopObjectArrayComputer;
    CRSOPObjectArray    m_rsopObjectArrayUser;
	LPCONSOLE           m_pComponentConsole;
	IGPEInformation*	m_pGPEInformation;

	HRESULT				AddACRSCTLPropPages (
								CAutoCertRequest*	pACR,
								LPPROPERTYSHEETCALLBACK pCallBack);
	HRESULT				AddAutoenrollmentSettingsPropPages (
								LPPROPERTYSHEETCALLBACK pCallBack,
                                bool fIsComputerType);
	HRESULT				ValidateCertChain (
								PCCERT_CONTEXT		pCertContext);
	HRESULT				AddCertPropPages (
								CCertificate*		pCert,
								LPPROPERTYSHEETCALLBACK pCallBack,
								LPDATAOBJECT		pDataObject,
								LONG_PTR			lNotifyHandle);
    HRESULT             AddCTLPropPages (
                                CCTL* pCTL, 
                                LPPROPERTYSHEETCALLBACK pCallback);
    HRESULT             AddEFSSettingsPropPages (
                                LPPROPERTYSHEETCALLBACK pCallback,
                                bool fIsComputerType);
	HRESULT				AddGPEStorePropPages(
								LPPROPERTYSHEETCALLBACK pCallBack,
                                CCertStore* pStore);
    HRESULT             AddSingleMenuItem (
                                LPCONTEXTMENUCALLBACK pContextMenuCallback, 
                                LONG lInsertionPointID,
                                int menuTextID,
                                int menuHintID,
                                int menuID);
    HRESULT             AddSaferEnforcementPropPages (
								LPPROPERTYSHEETCALLBACK pCallBack,
                                bool bIsComputerType);
	HRESULT				AddSaferDefinedFileTypesPropPages (
								LPPROPERTYSHEETCALLBACK pCallBack,
                                bool bIsComputerType);
    HRESULT             AddSaferEntryPropertyPage (
                                LPPROPERTYSHEETCALLBACK pCallback, 
                                CCertMgrCookie* pCookie,
                                LPDATAOBJECT pDataObject, 
                                LONG_PTR lNotifyHandle);
    HRESULT             AddSaferNewEntryMenuItems (
                                LPCONTEXTMENUCALLBACK pContextMenuCallback, 
                                LONG lInsertionPointID);
	HRESULT				AddSaferTrustedPublisherPropPages (
								LPPROPERTYSHEETCALLBACK pCallBack,
                                bool fIsMachineType);
	HRESULT				AddScopeNode (
								CCertMgrCookie*		pCookie,
								const CString&		strServerName,
								HSCOPEITEM			hParent);
	HRESULT				AddSeparator (
								LPCONTEXTMENUCALLBACK pContextMenuCallback);
	HRESULT				AddSnapMgrPropPages (
								LPPROPERTYSHEETCALLBACK pCallBack);
    HRESULT             BuildWMIList (LPDATAOBJECT pDataObject, bool bIsComputer);
	HRESULT				ChangeRootNodeName (
								const CString&		newName);
	HRESULT				CompleteEFSRecoveryAgent (
								CCertStoreGPE*		pStore,
								PCCERT_CONTEXT		pCertContext);
	bool				ContainerExists (
								HSCOPEITEM			hParent,
								CertificateManagerObjectType objectType);
	CCertMgrCookie*		ConvertCookie (
								LPDATAOBJECT		pDataObject);
	HRESULT				DeleteChildren (
								HSCOPEITEM			hParent);
	HRESULT				DeleteCTLFromResultPane (
								CCTL*				pCTL,
								LPDATAOBJECT		pDataObject);
	HRESULT				DeleteKeyFromRSABASE (
								PCCERT_CONTEXT		pCertContext);
	HRESULT				DeleteScopeItems (HSCOPEITEM hScopeItem = 0);
	void				DisplayAccessDenied();
	void				DisplaySystemError (
								DWORD				dwErr);
	HRESULT				ExpandScopeNodes (
								CCertMgrCookie*		pParentCookie,
								HSCOPEITEM			hParent,
								const CString&		strServerName,
								DWORD				dwLocation,
								const GUID&			guidObjectType);
    virtual bool FoundInRSOPFilter (BSTR /*bstrKey*/) const
    {
        return false;
    }
	HRESULT				GetResultData (LPRESULTDATA* ppResultData);
	bool				IsSecurityConfigurationEditorNodetype (
								const GUID&			refguid) const;
	HRESULT				IsUserAdministrator (
								BOOL&				bIsAdministrator);
	HRESULT				OnACRSEdit (
								LPDATAOBJECT		pDataObject);
	HRESULT				OnAddDomainEncryptedDataRecoveryAgent(
								LPDATAOBJECT		pDataObject);
	HRESULT				OnCTLEdit (
								LPDATAOBJECT		pDataObject);
	HRESULT				OnDeleteEFSPolicy (
								LPDATAOBJECT		pDataObject,
								bool				bCommitChanges);
	HRESULT				OnEnroll (
								LPDATAOBJECT		pDataObject,
								bool				bNewKey,
                                bool                bShowUI = true);
	HRESULT				OnExport (
								LPDATAOBJECT		pDataObject);

    HRESULT             OnPulseAutoEnroll();

	HRESULT				OnFind (
								LPDATAOBJECT		pDataObject);
	HRESULT				OnChangeComputer (
								LPDATAOBJECT		pDataObject);
	HRESULT				OnImport (
								LPDATAOBJECT		pDataObject);
	HRESULT				OnInitEFSPolicy (
								LPDATAOBJECT		pDataObject);
 	HRESULT				OnNewACRS (
 								LPDATAOBJECT		pDataObject);
	HRESULT				OnNewCTL (
								LPDATAOBJECT		pDataObject);
    HRESULT             OnCreateNewSaferPolicy (
                                LPDATAOBJECT        pDataObject);
    HRESULT             OnDeleteSaferPolicy (
                                LPDATAOBJECT        pDataObject);
	HRESULT             OnNewSaferEntry (
                                long nCommandID, 
                                LPDATAOBJECT pDataObject);
	HRESULT				OnNotifyPreload(
								LPDATAOBJECT		pDataObject,
								HSCOPEITEM			hRootScopeItem);
	HRESULT				OnOptions (LPDATAOBJECT pDataObject);
	virtual HRESULT		OnPropertyChange (LPARAM param);
	HRESULT				OnRenew (
								LPDATAOBJECT		pDataObject,
								bool				bNewKey);
	HRESULT				QueryMultiSelectDataObject(
								MMC_COOKIE			cookie,
								DATA_OBJECT_TYPES	type,
                                   LPDATAOBJECT*		ppDataObject);
	HRESULT				ReleaseResultCookie (
								CBaseCookieBlock *	pResultCookie,
								CCookie&			rootCookie,
								HCERTSTORE			hStoreHandle,
								POSITION			pos2);
    HRESULT             RemoveCertChainFromPolicy (
                                PCCERT_CONTEXT pCertContext,
                                CERT_CONTEXT_LIST& certChainsThatCantBeDeleted);

	// The following members are used to support Command Line override.
	// This code was copied from ..\mmcfmgmt\compdata.h.

	enum	// Bit fields for m_dwFlagsPersist
	{
		mskfAllowOverrideMachineName = 0x0001
	};
	DWORD m_dwFlagsPersist;				// General-purpose flags to be persisted into .msc file
	CString m_strMachineNamePersist;	// Machine name to persist into .msc file
	BOOL m_fAllowOverrideMachineName;	// TRUE => Allow the machine name to be overriden by the command line
    CString m_strLinkedHelpFile;  // Return in GetLinkedTopic ()
	
	void SetPersistentFlags(DWORD dwFlags)
	{
		m_dwFlagsPersist = dwFlags;
		m_fAllowOverrideMachineName = !!(m_dwFlagsPersist & mskfAllowOverrideMachineName);
	}

	DWORD GetPersistentFlags()
	{
		if (m_fAllowOverrideMachineName)
			m_dwFlagsPersist |= mskfAllowOverrideMachineName;
		else
			m_dwFlagsPersist &= ~mskfAllowOverrideMachineName;
		return m_dwFlagsPersist;
	}

	LPHEADERCTRL	m_pHeader;

private:
	DWORD           m_dwRSOPFlagsComputer;
	DWORD           m_dwRSOPFlagsUser;
	bool            m_bIsRSOP;
	bool            m_bMachineIsStandAlone;
	bool            m_fInvalidComputer;
	CCertStore*		m_pFileBasedStore;
	CCertStore*	    m_pGPERootStore;
	CCertStore*	    m_pGPETrustStore;
	CCertStore*	    m_pGPEACRSUserStore;
	CCertStore*	    m_pGPEACRSComputerStore;
	PCRYPTUI_MMCCALLBACK_STRUCT	m_pCryptUIMMCCallbackStruct;
	bool            m_bMultipleObjectsSelected;
	HRESULT AddCertificateTaskMenuItems (LPCONTEXTMENUCALLBACK pContextMenuCallback,
			const bool bIsMyStore, bool bIsReadOnly, CCertificate* pCert);
	HRESULT AddCTLTaskMenuItems (LPCONTEXTMENUCALLBACK pContextMenuCallback, bool bIsReadOnly);
	HRESULT AddContainersToScopePane (
                HSCOPEITEM hParent, 
                CCertMgrCookie& parentCookie, 
                bool bDeleteAndExpand);
	HRESULT AddPhysicalStoresToScopePane (HSCOPEITEM hParent, CCertMgrCookie& parentCookie, const SPECIAL_STORE_TYPE storeType);
	HRESULT AddLogicalStoresToScopePane (HSCOPEITEM hParent, CCertMgrCookie& parentCookie);
    HRESULT AddSaferLevelPropPage (
                LPPROPERTYSHEETCALLBACK pCallback, 
                CSaferLevel* pSaferLevel, 
                LONG_PTR lNotifyHandle,
                LPDATAOBJECT pDataObject);
	HRESULT AddUsagesToScopePane (HSCOPEITEM hParent, CCertMgrCookie& parentCookie);
    HRESULT FindRSOPObjectByHashAndDisplayPrecedencePage (
                const CString& szHash, 
                const bool bIsComputer, 
                LPPROPERTYSHEETCALLBACK pCallback);
    HRESULT GetValuesAndInsertInRSOPObjectList (
                IWbemClassObject* pObject, 
                CRSOPObjectArray& rRsopObjectArray,
                bool bIsComputer);
    HRESULT GetGPOFriendlyName (PCWSTR pwszOID, PWSTR *ppwszGPOName, bool bIsComputer);
    HRESULT OnSetSaferLevelDefault (LPDATAOBJECT pDataObject);
    HRESULT SaferEnumerateLevels (bool bIsMachine);

	DWORD			    m_dwSCEMode;
	CString			    m_szManagedServiceDisplayName;
	BOOL			    m_bIsUserAdministrator;
	CString			    m_szManagedServicePersist;
	CString			    m_szFileName;
	BOOL			    m_bShowPhysicalStoresPersist;
	BOOL			    m_bShowArchivedCertsPersist;
	CString			    m_szManagedComputer;
	CString			    m_szThisComputer;
	CString			    m_szLoggedInUser;
	CString			    m_szManagedUser;
	DWORD			    m_dwLocationPersist;
	HSCOPEITEM		    m_hRootScopeItem;
	CCertMgrCookie*     m_pRootCookie;
	int				    m_activeViewPersist;
	LPRESULTDATA        m_pResultData;
    IRSOPInformation*   m_pRSOPInformationComputer;
    IRSOPInformation*   m_pRSOPInformationUser;
    IWbemServices *     m_pIWbemServicesComputer;
    IWbemServices *     m_pIWbemServicesUser;
    BSTR                m_pbstrLanguage;
    BSTR                m_pbstrQuery;
    BSTR                m_pbstrValueName;
    BSTR                m_pbstrRegistryKey;
    BSTR                m_pbstrValue;
    BSTR                m_pbstrPrecedence;
    BSTR                m_pbstrGPOid;
    int                 m_nOpenSaferPageRefCount;
    CCriticalSection    m_critSec;
}; // CCertMgrComponentData


/////////////////////////////////////////////////////////////////////
class CCertMgrSnapin: public CCertMgrComponentData,
	public CComCoClass<CCertMgrSnapin, &CLSID_CertificateManager>
{
public:
	CCertMgrSnapin() : CCertMgrComponentData () 
    {
	    SetHtmlHelpFileName (CM_HELP_FILE);
        m_strLinkedHelpFile = CM_LINKED_HELP_FILE;
    };
	virtual ~CCertMgrSnapin() {};

// Use DECLARE_NOT_AGGREGATABLE(CCertMgrSnapin) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(CCertMgrSnapin)
DECLARE_REGISTRY(CCertMgrSnapin, _T("CERTMGR.CertMgrObject.1"), _T("CERTMGR.CertMgrObject.1"), IDS_CERTMGR_DESC, THREADFLAGS_BOTH)
	virtual BOOL IsServiceSnapin() { return FALSE; }

// IPersistStream or IPersistStorage
	STDMETHOD(GetClassID)(CLSID __RPC_FAR *pClassID)
	{
		*pClassID = CLSID_CertificateManager;
		return S_OK;
	}
};


class CCertMgrPKPolExtension: public CCertMgrComponentData,
	public CComCoClass<CCertMgrPKPolExtension, &CLSID_CertificateManagerPKPOLExt>
{
public:
	CCertMgrPKPolExtension() : CCertMgrComponentData () 
    {
        SetHtmlHelpFileName (PKP_HELP_FILE);
        m_strLinkedHelpFile = PKP_LINKED_HELP_FILE;
    };
	virtual ~CCertMgrPKPolExtension() {};

// Use DECLARE_NOT_AGGREGATABLE(CCertMgrPKPolExtension) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(CCertMgrPKPolExtension)
DECLARE_REGISTRY(CCertMgrPKPolExtension, _T("CERTMGR.CertMgrPKPolExtObject.1"), _T("CERTMGR.CertMgrPKPolExtObject.1"), IDS_CERTMGR_DESC, THREADFLAGS_BOTH)
	virtual BOOL IsServiceSnapin() { return FALSE; }
	virtual BOOL IsExtensionSnapin() { return TRUE; }

// IPersistStream or IPersistStorage
	STDMETHOD(GetClassID)(CLSID __RPC_FAR *pClassID)
	{
		*pClassID = CLSID_CertificateManagerPKPOLExt;
		return S_OK;
	}

    virtual bool FoundInRSOPFilter (BSTR bstrKey) const;
};

class CSaferWindowsExtension: public CCertMgrComponentData,
	public CComCoClass<CSaferWindowsExtension, &CLSID_SaferWindowsExtension>
{
public:
	CSaferWindowsExtension();
	virtual ~CSaferWindowsExtension() {};

// Use DECLARE_NOT_AGGREGATABLE(CSaferWindowsExtension) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(CSaferWindowsExtension)
DECLARE_REGISTRY(CSaferWindowsExtension, _T("CERTMGR.CertMgrSaferWindowsExtensionObject.1"), 
                 _T("CERTMGR.CertMgrSaferWindowsExtensionObject.1"), IDS_CERTMGR_SAFER_WINDOWS_DESC, THREADFLAGS_BOTH)
	virtual BOOL IsServiceSnapin() { return FALSE; }
	virtual BOOL IsExtensionSnapin() { return TRUE; }

// IPersistStream or IPersistStorage
	STDMETHOD(GetClassID)(CLSID __RPC_FAR *pClassID)
	{
		*pClassID = CLSID_SaferWindowsExtension;
		return S_OK;
	}

    virtual bool FoundInRSOPFilter (BSTR bstrKey) const;
};

#endif // ~__COMPDATA_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\complete.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       complete.cpp
//
//  Contents:
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "Complete.h"
#include "AddSheet.h"

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAddEFSWizComplete property page


CAddEFSWizComplete::CAddEFSWizComplete() : CWizard97PropertyPage(CAddEFSWizComplete::IDD)
{
	//{{AFX_DATA_INIT(CAddEFSWizComplete)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	InitWizard97 (TRUE);
}

CAddEFSWizComplete::~CAddEFSWizComplete()
{
}

void CAddEFSWizComplete::DoDataExchange(CDataExchange* pDX)
{
	CWizard97PropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddEFSWizComplete)
	DDX_Control(pDX, IDC_BIGBOLD, m_bigBoldStatic);
	DDX_Control(pDX, IDC_ADDLIST, m_UserAddList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddEFSWizComplete, CWizard97PropertyPage)
	//{{AFX_MSG_MAP(CAddEFSWizComplete)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddEFSWizComplete message handlers

BOOL CAddEFSWizComplete::OnSetActive() 
{
	BOOL bResult = CWizard97PropertyPage::OnSetActive ();

	if ( bResult )
	{
		GetParent ()->PostMessage (PSM_SETWIZBUTTONS, 0, PSWIZB_FINISH | PSWIZB_BACK);

		SetUserList();
	}

	return bResult;
}

void CAddEFSWizComplete::SetUserList()
{
    CAddEFSWizSheet*	pAddSheet = reinterpret_cast <CAddEFSWizSheet *> (m_pWiz);
	ASSERT (pAddSheet);
	if ( !pAddSheet )
		return;

    PUSERSONFILE	Token = NULL;
    CString			UserName;
    CString			DnName;

    try {
        CString UnKnownUser;
        CString NoCertName;

        VERIFY (UnKnownUser.LoadString(IDS_UNKNOWNUSER));
        VERIFY (NoCertName.LoadString(IDS_NOCERTNAME));
        Token = pAddSheet->StartEnum();
        while (Token)
		{
            Token = pAddSheet->GetNextUser(Token, UserName, DnName);
            if ( (!UserName.IsEmpty()) || (!DnName.IsEmpty()))
			{
                LV_ITEM fillItem;

                fillItem.mask = LVIF_TEXT;
                fillItem.iItem = 0;
                fillItem.iSubItem = 0;

                if (UserName.IsEmpty())
				{
                    fillItem.pszText = UnKnownUser.GetBuffer(UnKnownUser.GetLength() + 1);
                } 
				else 
				{
                    fillItem.pszText = UserName.GetBuffer(UserName.GetLength() + 1);
                }
                fillItem.iItem = m_UserAddList.InsertItem(&fillItem);
                if (UserName.IsEmpty())
				{
                    UnKnownUser.ReleaseBuffer();
                } 
				else 
				{
                    UserName.ReleaseBuffer();
                }
                if (fillItem.iItem != -1 )
				{
                    fillItem.iSubItem = 1;
                    if (DnName.IsEmpty())
					{
                        fillItem.pszText = NoCertName.GetBuffer(NoCertName.GetLength() + 1);
                    } 
					else 
					{
                        fillItem.pszText = DnName.GetBuffer(DnName.GetLength() + 1);
                    }
                    m_UserAddList.SetItem(&fillItem);
                    if (DnName.IsEmpty())
					{
                        NoCertName.ReleaseBuffer();
                    } 
					else 
					{
                        DnName.ReleaseBuffer();
                    }
                }

            }
        }
	}
    catch(...){
                m_UserAddList.DeleteAllItems( );
    }

}

LRESULT CAddEFSWizComplete::OnWizardBack() 
{
    m_UserAddList.DeleteAllItems( );	
	return CWizard97PropertyPage::OnWizardBack();
}

BOOL CAddEFSWizComplete::OnWizardFinish() 
{
    CAddEFSWizSheet*	pAddSheet = reinterpret_cast <CAddEFSWizSheet *> (m_pWiz);
	ASSERT (pAddSheet);
	if ( !pAddSheet )
		return FALSE;

    pAddSheet->AddNewUsers();	
	return CWizard97PropertyPage::OnWizardFinish();
}

BOOL CAddEFSWizComplete::OnInitDialog() 
{
	CWizard97PropertyPage::OnInitDialog();
	
	m_bigBoldStatic.SetFont (&GetBigBoldFont ());

    CString UserNameTitle;
    CString UserDnTitle;
    RECT	ListRect;
    DWORD	ColWidth = 0;


    try {	
	    m_UserAddList.GetClientRect(&ListRect);
        ColWidth = (ListRect.right - ListRect.left)/2;
        VERIFY (UserNameTitle.LoadString(IDS_USERCOLTITLE));
        VERIFY (UserDnTitle.LoadString(IDS_DNCOLTITLE));
        m_UserAddList.InsertColumn(0, UserNameTitle, LVCFMT_LEFT, ColWidth );
        m_UserAddList.InsertColumn(1, UserDnTitle, LVCFMT_LEFT, ColWidth );
    }
    catch (...){
    }
	
    DWORD   color = GetSysColor (COLOR_WINDOW);
    VERIFY (m_UserAddList.SetBkColor (color));
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\complete.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998-2001.
//
//  File:       complete.h
//
//  Contents:
//
//----------------------------------------------------------------------------
#if !defined(AFX_COMPLETE_H__F3A2938F_54B9_11D1_BB63_00A0C906345D__INCLUDED_)
#define AFX_COMPLETE_H__F3A2938F_54B9_11D1_BB63_00A0C906345D__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Complete.h : header file
//
#include "Wiz97PPg.h"

/////////////////////////////////////////////////////////////////////////////
// CAddEFSWizComplete dialog

class CAddEFSWizComplete : public CWizard97PropertyPage
{

// Construction
public:
	CAddEFSWizComplete();
	virtual ~CAddEFSWizComplete();

// Dialog Data
	//{{AFX_DATA(CAddEFSWizComplete)
	enum { IDD = IDD_ADD_EFS_AGENT_COMPLETION };
	CStatic	m_bigBoldStatic;
	CListCtrl	m_UserAddList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CAddEFSWizComplete)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardBack();
	virtual BOOL OnWizardFinish();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CAddEFSWizComplete)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	void SetUserList(void);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_COMPLETE_H__F3A2938F_54B9_11D1_BB63_00A0C906345D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\componentdatamenus.cpp ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       ComponentDataMenus.cpp
//
//  Contents:   Implementation of menu stuff CCertMgrComponentData
//
//----------------------------------------------------------------------------

#include "stdafx.h"

USE_HANDLE_MACROS ("CERTMGR (compdata.cpp)")
#include <gpedit.h>
#include "compdata.h"
#include "dataobj.h"
#include "cookie.h"
#include "Certifct.h"


#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern bool g_bSchemaIsW2K;

///////////////////////////////////////////////////////////////////////////////
// IExtendContextMenu implementation
//
STDMETHODIMP CCertMgrComponentData::AddMenuItems (LPDATAOBJECT pDataObject,
                                            LPCONTEXTMENUCALLBACK pContextMenuCallback,
                                            long *pInsertionAllowed)
{
    if ( ((LPDATAOBJECT) -1) == pDataObject )
        return E_FAIL;

    _TRACE (1, L"Entering CCertMgrComponentData::AddMenuItems\n");
    HRESULT	hr = S_OK;


	BOOL							bIsFileView = !m_szFileName.IsEmpty ();
	CCertMgrCookie*					pCookie = 0;

	LPDATAOBJECT	pMSDO = ExtractMultiSelect (pDataObject);
	m_bMultipleObjectsSelected = false;

	if ( pMSDO )
	{
		m_bMultipleObjectsSelected = true;

		CCertMgrDataObject* pDO = reinterpret_cast <CCertMgrDataObject*>(pMSDO);
		ASSERT (pDO);
		if ( pDO )
		{
			// Get first cookie - all items should be the same?
			// Is this a valid assumption?
			// TODO: Verify
			pDO->Reset();
			if ( pDO->Next(1, reinterpret_cast<MMC_COOKIE*>(&pCookie), NULL) == S_FALSE )
				return S_FALSE;
		}
		else
			return E_UNEXPECTED;

	}
	else
		pCookie = ConvertCookie (pDataObject);
	ASSERT (pCookie);
	if ( !pCookie )
		return E_UNEXPECTED;

	CertificateManagerObjectType	objType = pCookie->m_objecttype;

	// Don't add any menu items if the computer is known not to be valid.
	if ( !m_fInvalidComputer )
	{
		//  Don't add menu items if this is a serialized file
  		if ( *pInsertionAllowed & CCM_INSERTIONALLOWED_TOP )
  		{
			switch (objType)
			{
			case CERTMGR_CERTIFICATE:
				if ( !m_bMultipleObjectsSelected )
				{
					CCertificate* pCert = reinterpret_cast <CCertificate*> (pCookie);
					ASSERT (pCert);
					if ( pCert )
					{
		                hr = AddSingleMenuItem (pContextMenuCallback, 
                                CCM_INSERTIONPOINTID_PRIMARY_TOP,
                                IDS_VIEW,
                                IDS_VIEW_HINT,
                                IDM_OPEN);
					}
					else
						hr = E_FAIL;
				}
				break;
			
			case CERTMGR_CRL:
				if ( !m_bMultipleObjectsSelected )
                    hr = AddSingleMenuItem (pContextMenuCallback, 
                            CCM_INSERTIONPOINTID_PRIMARY_TOP,
                            IDS_VIEW,
                            IDS_CRL_VIEW_HINT,
                            IDM_OPEN);
				break;

			case CERTMGR_CTL:
				if ( !m_bMultipleObjectsSelected )
                    hr = AddSingleMenuItem (pContextMenuCallback, 
                            CCM_INSERTIONPOINTID_PRIMARY_TOP,
                            IDS_VIEW,
                            IDS_CTL_VIEW_HINT,
                            IDM_OPEN);
				break;

			case CERTMGR_SNAPIN:
                if ( CERT_SYSTEM_STORE_CURRENT_USER != m_dwLocationPersist && m_hRootScopeItem )
                {
	                hr = AddSingleMenuItem (pContextMenuCallback, 
                            CCM_INSERTIONPOINTID_PRIMARY_TOP,
                            IDS_CHANGE_COMPUTER,
                            IDS_CHANGE_COMPUTER_HINT,
                            IDM_TOP_CHANGE_COMPUTER);
                }
                // fall through

			case CERTMGR_PHYS_STORE:
			case CERTMGR_USAGE:
			case CERTMGR_LOG_STORE:
				ASSERT (!m_bMultipleObjectsSelected);
	            hr = AddSingleMenuItem (pContextMenuCallback, 
                        CCM_INSERTIONPOINTID_PRIMARY_TOP,
                        IDS_FIND,
                        IDS_FIND_HINT,
                        IDM_TOP_FIND);
				break;

            case CERTMGR_LOG_STORE_RSOP:
                break;

            case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
            case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
                break;

			case CERTMGR_LOG_STORE_GPE:
				ASSERT (!m_bMultipleObjectsSelected);
				{
					CCertStoreGPE* pStore = reinterpret_cast <CCertStoreGPE*>
							 (pCookie);
					ASSERT (pStore);
					if ( pStore )
					{
						switch (pStore->GetStoreType ())
						{
						case TRUST_STORE:
						case ROOT_STORE:
							if ( pStore->GetStoreHandle () )
							{
                                if ( !pStore->IsReadOnly () )
	                                hr = AddSingleMenuItem (pContextMenuCallback, 
                                            CCM_INSERTIONPOINTID_PRIMARY_TOP,
                                            IDS_IMPORT,
                                            IDS_IMPORT_HINT,
                                            IDM_TASK_IMPORT);

								pStore->Close ();
							}
							break;

						case EFS_STORE:
						    if ( pStore->GetStoreHandle () )
						    {
                                if ( !pStore->IsReadOnly () )
                                    hr = AddSingleMenuItem (pContextMenuCallback, 
                                            CCM_INSERTIONPOINTID_PRIMARY_TOP,
                                            IDS_ADD_DATA_RECOVERY_AGENT,
                                            IDS_ADD_DOMAIN_ENCRYPTED_RECOVERY_AGENT_HINT,
                                            IDM_ADD_DOMAIN_ENCRYPTED_RECOVERY_AGENT);
                                if ( !m_bMachineIsStandAlone )
                                {
                                    if ( !pStore->IsReadOnly () )
                                        hr = AddSingleMenuItem (pContextMenuCallback, 
                                                CCM_INSERTIONPOINTID_PRIMARY_TOP,
                                                IDS_CREATE,
                                                IDS_CREATE_DOMAIN_ENCRYPTED_RECOVERY_AGENT_HINT,
                                                IDM_CREATE_DOMAIN_ENCRYPTED_RECOVERY_AGENT);
                                }

							    pStore->Close ();
						    }
						    else if ( pStore->IsNullEFSPolicy () )
						    {
                                if ( !pStore->IsReadOnly () )
                                    hr = AddSingleMenuItem (pContextMenuCallback, 
                                            CCM_INSERTIONPOINTID_PRIMARY_TOP,
                                            IDS_ADD_DATA_RECOVERY_AGENT,
                                            IDS_ADD_DOMAIN_ENCRYPTED_RECOVERY_AGENT_HINT,
                                            IDM_ADD_DOMAIN_ENCRYPTED_RECOVERY_AGENT);
                                if ( !m_bMachineIsStandAlone )
                                {
                                    if ( !pStore->IsReadOnly () )
                                        hr = AddSingleMenuItem (pContextMenuCallback, 
                                                CCM_INSERTIONPOINTID_PRIMARY_TOP,
                                                IDS_CREATE,
                                                IDS_CREATE_DOMAIN_ENCRYPTED_RECOVERY_AGENT_HINT,
                                                IDM_CREATE_DOMAIN_ENCRYPTED_RECOVERY_AGENT);
                                }

							    pStore->Close ();
						    }
                            break;

                        default:
                            break;
                        }
					}
				}
				break;

			case CERTMGR_CRL_CONTAINER:
			case CERTMGR_CTL_CONTAINER:
			case CERTMGR_CERT_CONTAINER:
				ASSERT (!m_bMultipleObjectsSelected);
                break;

            case CERTMGR_SAFER_COMPUTER_LEVEL:
            case CERTMGR_SAFER_USER_LEVEL:
                if ( m_pGPEInformation )
                {
					CSaferLevel* pLevel = reinterpret_cast <CSaferLevel*>
							 (pCookie);
					ASSERT (pLevel);
					if ( pLevel )
					{
                        // RAID#265590	Safer Windows:  "Set as default" menu 
                        // item is enabled in the context menu of a security 
                        // level when the security level is already the default.
                        if ( ( SAFER_LEVELID_DISALLOWED == pLevel->GetLevel () ||
                                SAFER_LEVELID_FULLYTRUSTED == pLevel->GetLevel () ||
                                SAFER_LEVELID_NORMALUSER == pLevel->GetLevel ())
                                && !pLevel->IsDefault () &&
                                m_pGPEInformation)
                        {
                            hr = AddSingleMenuItem (pContextMenuCallback, 
                                    CCM_INSERTIONPOINTID_PRIMARY_TOP,
                                    IDS_SAFER_SET_DEFAULT,
                                    IDS_SAFER_SET_DEFAULT_HINT,
                                    IDM_SAFER_LEVEL_SET_DEFAULT);
                        }
                    }
                }
                break;

            case CERTMGR_SAFER_COMPUTER_ENTRIES:
            case CERTMGR_SAFER_USER_ENTRIES:
                if ( m_pGPEInformation )
                    hr = AddSaferNewEntryMenuItems (pContextMenuCallback, 
                            CCM_INSERTIONPOINTID_PRIMARY_TOP);
                break;

            case CERTMGR_SAFER_COMPUTER_ROOT:
            case CERTMGR_SAFER_USER_ROOT:
                {
                    CSaferRootCookie* pSaferRootCookie = dynamic_cast <CSaferRootCookie*> (pCookie);
                    if ( pSaferRootCookie )
                    {
                        // Don't add these menu options if the Safer node 
                        // hasn't been expanded at least once, otherwise, we
                        // can't tell if there is already a safer policy or not.
                        if ( !m_bIsRSOP && pSaferRootCookie->m_bExpandedOnce )
                        {
                            if ( pSaferRootCookie->m_bCreateSaferNodes )
                                hr = AddSingleMenuItem (pContextMenuCallback, 
                                        CCM_INSERTIONPOINTID_PRIMARY_TOP,
                                        IDS_DELETE_SAFER_POLICY,
                                        IDS_DELETE_SAFER_POLICY_HINT,
                                        IDM_TOP_DELETE_NEW_SAFER_POLICY);
                            else
                                hr = AddSingleMenuItem (pContextMenuCallback, 
                                        CCM_INSERTIONPOINTID_PRIMARY_TOP,
                                        IDS_NEW_SAFER_POLICY,
                                        IDS_NEW_SAFER_POLICY_HINT,
                                        IDM_TOP_CREATE_NEW_SAFER_POLICY);
                        }
                    }
                }
                break;

			default:
				break;
			}
  		}
  		if ( *pInsertionAllowed & CCM_INSERTIONALLOWED_NEW	)
  		{
			if ( CERTMGR_LOG_STORE_GPE == objType )
			{
				ASSERT (!m_bMultipleObjectsSelected);
				CCertStoreGPE* pStore = reinterpret_cast <CCertStoreGPE*>
						 (pCookie);
				ASSERT (pStore);
				if ( pStore && pStore->GetStoreHandle () )
				{
					switch (pStore->GetStoreType ())
					{
					case TRUST_STORE:
                        if ( !pStore->IsReadOnly () )
                            hr = AddSingleMenuItem (pContextMenuCallback, 
                                    CCM_INSERTIONPOINTID_PRIMARY_NEW,
                                    IDS_NEW_CTL,
                                    IDS_NEW_CTL_HINT,
                                    IDM_NEW_CTL);
						break;

					case ACRS_STORE:
                        if ( !pStore->IsReadOnly () )
		                    hr = AddSingleMenuItem (pContextMenuCallback, 
                                    CCM_INSERTIONPOINTID_PRIMARY_NEW,
                                    IDS_NEW_AUTO_CERT_REQUEST,
                                    IDS_NEW_AUTO_CERT_REQUEST_HINT,
                                    IDM_NEW_ACRS);
    					break;

					case EFS_STORE:
                        if ( !pStore->IsReadOnly () )
                            hr = AddSingleMenuItem (pContextMenuCallback, 
                                    CCM_INSERTIONPOINTID_PRIMARY_NEW,
                                    IDS_ENCRYPTED_RECOVERY_AGENT,
                                    IDS_ADD_DOMAIN_ENCRYPTED_RECOVERY_AGENT_HINT,
                                    IDM_ADD_DOMAIN_ENCRYPTED_RECOVERY_AGENT2);
						break;

					default:
						break;
					}
					pStore->Close ();
				}
			}
  		}
  		if ( *pInsertionAllowed & CCM_INSERTIONALLOWED_TASK )
  		{
			switch (objType)
			{
			case CERTMGR_CERTIFICATE:
                if ( !m_bIsRSOP )
				{
					CCertificate* pCert =
							reinterpret_cast <CCertificate*> (pCookie);
					ASSERT (pCert);
					if ( pCert && pCert->GetCertStore () )
					{
						hr = AddCertificateTaskMenuItems (
								pContextMenuCallback,
								 (pCert->GetStoreType () == MY_STORE),
								 pCert->GetCertStore ()->IsReadOnly (),
								 pCert);
					}
				}
				break;

			case CERTMGR_CRL:
				if ( !m_bMultipleObjectsSelected )
				{
                    hr = AddSingleMenuItem (pContextMenuCallback, 
                            CCM_INSERTIONPOINTID_PRIMARY_TASK,
                            IDS_EXPORT,
                            IDS_CRL_EXPORT_HINT,
                            IDM_TASK_CRL_EXPORT);
                    if ( !m_bIsRSOP )
		                hr = AddSingleMenuItem (pContextMenuCallback, 
                                CCM_INSERTIONPOINTID_PRIMARY_TASK,
                                IDS_VIEW,
                                IDS_VIEW_HINT,
                                IDM_TASK_OPEN);
				}
				break;

			case CERTMGR_AUTO_CERT_REQUEST:
				if ( !m_bMultipleObjectsSelected && !m_bIsRSOP )
				{
					CAutoCertRequest* pAutoCert =
							reinterpret_cast <CAutoCertRequest*> (pCookie);
					ASSERT (pAutoCert);
					if ( pAutoCert )
					{
						if ( !pAutoCert->GetCertStore ().IsReadOnly () )
	                        hr = AddSingleMenuItem (pContextMenuCallback, 
                                    CCM_INSERTIONPOINTID_PRIMARY_TASK,
                                    IDS_EDIT,
                                    IDS_ACR_EDIT_HINT,
                                    IDM_EDIT_ACRS);
					}
				}
				break;

			case CERTMGR_CTL:
                if ( !m_bIsRSOP )
    			{
					CCTL* pCTL =
							reinterpret_cast <CCTL*> (pCookie);
					ASSERT (pCTL);
					if ( pCTL )
					{
						hr = AddCTLTaskMenuItems (pContextMenuCallback, pCTL->GetCertStore ().IsReadOnly ());
					}
				}
				break;

			case CERTMGR_SNAPIN:
				ASSERT (!m_bMultipleObjectsSelected);
	            hr = AddSingleMenuItem (pContextMenuCallback, 
                        CCM_INSERTIONPOINTID_PRIMARY_TASK,
                        IDS_FIND,
                        IDS_FIND_HINT,
                        IDM_TASK_FIND);
                if ( SUCCEEDED (hr) && 
                        CERT_SYSTEM_STORE_CURRENT_USER != m_dwLocationPersist &&
                        m_hRootScopeItem )
                {
	                hr = AddSingleMenuItem (pContextMenuCallback, 
                            CCM_INSERTIONPOINTID_PRIMARY_TASK,
                            IDS_CHANGE_COMPUTER,
                            IDS_CHANGE_COMPUTER_HINT,
                            IDM_TASK_CHANGE_COMPUTER);
                }
               
                // must be targetting current user OR LOCAL machine, must be joined to domain
                if( SUCCEEDED (hr) && 
                        !m_bMachineIsStandAlone &&
                        ((CERT_SYSTEM_STORE_CURRENT_USER == m_dwLocationPersist) || (CERT_SYSTEM_STORE_LOCAL_MACHINE == m_dwLocationPersist)) &&
                        IsLocalComputername (m_strMachineNamePersist))
                {
                    // NTRAID# 451902 Certmgr: XP client in Win2K Schema -- 
                    // should not give user option to pulse user autoenrollment
                    if ( g_bSchemaIsW2K && CERT_SYSTEM_STORE_CURRENT_USER == m_dwLocationPersist )
                        break;

	                hr = AddSingleMenuItem (pContextMenuCallback, 
                            CCM_INSERTIONPOINTID_PRIMARY_TASK,
                            IDS_PULSEAUTOENROLL,
                            IDS_PULSEAUTOENROLL_HINT,
                            IDM_TASK_PULSEAUTOENROLL);
                }
                break;

            case CERTMGR_USAGE:
                ASSERT (!m_bMultipleObjectsSelected);
	            hr = AddSingleMenuItem (pContextMenuCallback, 
                        CCM_INSERTIONPOINTID_PRIMARY_TASK,
                        IDS_FIND,
                        IDS_FIND_HINT,
                        IDM_TASK_FIND);
                if ( !bIsFileView )
                {
                    // Bug 254166 Certificate snapin:  options which permit remote machine enrollment/renewal must be removed
                    if ( IsLocalComputername (m_strMachineNamePersist) && !m_bIsRSOP )
                    {
                        hr = AddSeparator (pContextMenuCallback);
					    // NOTE: New certs will be added only to MY store.

                        if ( !m_bMachineIsStandAlone && CERT_SYSTEM_STORE_SERVICES != m_dwLocationPersist )
	                        hr = AddSingleMenuItem (pContextMenuCallback, 
                                    CCM_INSERTIONPOINTID_PRIMARY_TASK,
                                    IDS_ENROLL_NEW_CERT,
                                    IDS_ENROLL_NEW_CERT_HINT,
                                    IDM_ENROLL_NEW_CERT);
                        if ( SUCCEEDED (hr) )
                        {
	                        hr = AddSingleMenuItem (pContextMenuCallback, 
                                    CCM_INSERTIONPOINTID_PRIMARY_TASK,
                                    IDS_IMPORT,
                                    IDS_IMPORT_HINT,
                                    IDM_TASK_IMPORT);
                        }
                    }
				}
				break;

			case CERTMGR_PHYS_STORE:
				ASSERT (!m_bMultipleObjectsSelected);
	            hr = AddSingleMenuItem (pContextMenuCallback, 
                        CCM_INSERTIONPOINTID_PRIMARY_TASK,
                        IDS_FIND,
                        IDS_FIND_HINT,
                        IDM_TASK_FIND);
				if ( !bIsFileView && !m_bIsRSOP)
				{
					hr = AddSeparator (pContextMenuCallback);
					{
						CCertStore* pStore =
								reinterpret_cast <CCertStore*> (pCookie);
						ASSERT (pStore);
						if ( pStore && pStore->GetStoreHandle () )
						{
                            // Bug 254166 Certificate snapin:  options which permit remote machine enrollment/renewal must be removed
							if ( pStore->GetStoreType () == MY_STORE &&
                                    IsLocalComputername (m_szManagedComputer) &&
                                    !m_bMachineIsStandAlone )
                            {
								if ( !pStore->IsReadOnly () && CERT_SYSTEM_STORE_SERVICES != m_dwLocationPersist )
    	                            hr = AddSingleMenuItem (pContextMenuCallback, 
                                            CCM_INSERTIONPOINTID_PRIMARY_TASK,
                                            IDS_ENROLL_NEW_CERT,
                                            IDS_ENROLL_NEW_CERT_HINT,
                                            IDM_ENROLL_NEW_CERT);
                            }
                            if ( SUCCEEDED (hr) )
                                if ( !pStore->IsReadOnly () )
	                                hr = AddSingleMenuItem (pContextMenuCallback, 
                                            CCM_INSERTIONPOINTID_PRIMARY_TASK,
                                            IDS_IMPORT,
                                            IDS_IMPORT_HINT,
                                            IDM_TASK_IMPORT);
							pStore->Close ();
						}
					}
	                hr = AddSingleMenuItem (pContextMenuCallback, 
                            CCM_INSERTIONPOINTID_PRIMARY_TASK,
                            IDS_EXPORT_STORE,
                            IDS_EXPORT_STORE_HINT,
                            IDM_TASK_EXPORT_STORE);
				}
				break;

			case CERTMGR_LOG_STORE:
				ASSERT (!m_bMultipleObjectsSelected);
	            hr = AddSingleMenuItem (pContextMenuCallback, 
                        CCM_INSERTIONPOINTID_PRIMARY_TASK,
                        IDS_FIND,
                        IDS_FIND_HINT,
                        IDM_TASK_FIND);
				if ( !bIsFileView && !m_bIsRSOP )
				{
					hr = AddSeparator (pContextMenuCallback);
					{
						CCertStore* pStore =
								reinterpret_cast <CCertStore*> (pCookie);
						ASSERT (pStore);
						if ( pStore && pStore->GetStoreHandle () )
						{
                            // Bug 254166 Certificate snapin:  options which permit remote machine enrollment/renewal must be removed
							if ( pStore->GetStoreType () == MY_STORE  && 
                                    IsLocalComputername (m_szManagedComputer) &&
                                    !m_bMachineIsStandAlone )
							{
							    if ( !pStore->IsReadOnly () && CERT_SYSTEM_STORE_SERVICES != m_dwLocationPersist )
	                                hr = AddSingleMenuItem (pContextMenuCallback, 
                                            CCM_INSERTIONPOINTID_PRIMARY_TASK,
                                            IDS_ENROLL_NEW_CERT,
                                            IDS_ENROLL_NEW_CERT_HINT,
                                            IDM_ENROLL_NEW_CERT);
							}
                            if ( !pStore->IsReadOnly () )
	                            hr = AddSingleMenuItem (pContextMenuCallback, 
                                        CCM_INSERTIONPOINTID_PRIMARY_TASK,
                                        IDS_IMPORT,
                                        IDS_IMPORT_HINT,
                                        IDM_TASK_IMPORT);
							pStore->Close ();
						}
					}
				}
				break;

			case CERTMGR_LOG_STORE_RSOP:
                break;

            case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
            case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
                break;

			case CERTMGR_LOG_STORE_GPE:
				ASSERT (!m_bMultipleObjectsSelected);
				{
					CCertStoreGPE* pStore = reinterpret_cast <CCertStoreGPE*>
							 (pCookie);
					ASSERT (pStore);
					if ( pStore )
					{
						switch (pStore->GetStoreType ())
						{
						case TRUST_STORE:
						case ROOT_STORE:
							if ( pStore->GetStoreHandle () && !m_bIsRSOP )
							{
                                if ( !pStore->IsReadOnly () )
	                                hr = AddSingleMenuItem (pContextMenuCallback, 
                                            CCM_INSERTIONPOINTID_PRIMARY_TASK,
                                            IDS_IMPORT,
                                            IDS_IMPORT_HINT,
                                            IDM_TASK_IMPORT);
								pStore->Close ();
							}
							break;

						case EFS_STORE:
						    if ( pStore->GetStoreHandle () )
						    {
                                if ( !pStore->IsReadOnly () )
                                    hr = AddSingleMenuItem (pContextMenuCallback, 
                                            CCM_INSERTIONPOINTID_PRIMARY_TASK,
                                            IDS_ADD_DATA_RECOVERY_AGENT,
                                            IDS_ADD_DOMAIN_ENCRYPTED_RECOVERY_AGENT_HINT,
                                            IDM_ADD_DOMAIN_ENCRYPTED_RECOVERY_AGENT1);
                                if ( !m_bMachineIsStandAlone )
                                {
                                    if ( !pStore->IsReadOnly () )
                                        hr = AddSingleMenuItem (pContextMenuCallback, 
                                                CCM_INSERTIONPOINTID_PRIMARY_TASK,
                                                IDS_CREATE,
                                                IDS_CREATE_DOMAIN_ENCRYPTED_RECOVERY_AGENT_HINT,
                                                IDM_CREATE_DOMAIN_ENCRYPTED_RECOVERY_AGENT);
                                }
                                hr = AddSingleMenuItem (pContextMenuCallback, 
                                        CCM_INSERTIONPOINTID_PRIMARY_TASK,
                                        IDS_DEL_POLICY,
                                        IDS_DEL_POLICY_HINT,
                                        IDM_DEL_POLICY);
							    pStore->Close ();
						    }
						    else if ( pStore->IsNullEFSPolicy () )
						    {
                                if ( !pStore->IsReadOnly () )
                                    hr = AddSingleMenuItem (pContextMenuCallback, 
                                            CCM_INSERTIONPOINTID_PRIMARY_TASK,
                                            IDS_ADD_DATA_RECOVERY_AGENT,
                                            IDS_ADD_DOMAIN_ENCRYPTED_RECOVERY_AGENT_HINT,
                                            IDM_ADD_DOMAIN_ENCRYPTED_RECOVERY_AGENT1);
                                if ( !m_bMachineIsStandAlone )
                                {
                                    if ( !pStore->IsReadOnly () )
                                        hr = AddSingleMenuItem (pContextMenuCallback, 
                                                CCM_INSERTIONPOINTID_PRIMARY_TASK,
                                                IDS_CREATE,
                                                IDS_CREATE_DOMAIN_ENCRYPTED_RECOVERY_AGENT_HINT,
                                                IDM_CREATE_DOMAIN_ENCRYPTED_RECOVERY_AGENT);
                                }

                                hr = AddSingleMenuItem (pContextMenuCallback, 
                                        CCM_INSERTIONPOINTID_PRIMARY_TASK,
                                        IDS_INIT_POLICY,
                                        IDS_INIT_POLICY_HINT,
                                        IDM_INIT_POLICY);


							    pStore->Close ();
						    }
                            break;

                        default:
                            break;
                        }
					}
				}
				break;

			case CERTMGR_CRL_CONTAINER:
				ASSERT (!m_bMultipleObjectsSelected);
				break;

			case CERTMGR_CTL_CONTAINER:
				ASSERT (!m_bMultipleObjectsSelected);
				if ( !bIsFileView && !m_bIsRSOP )
				{
					CContainerCookie* pContainer =
							reinterpret_cast <CContainerCookie*> (pCookie);
					ASSERT (pContainer);
					if ( pContainer )
					{
                        if ( !pContainer->GetCertStore ().IsReadOnly () )
	                        hr = AddSingleMenuItem (pContextMenuCallback, 
                                    CCM_INSERTIONPOINTID_PRIMARY_TASK,
                                    IDS_IMPORT,
                                    IDS_IMPORT_HINT,
                                    IDM_TASK_IMPORT);
					}
				}
				break;

			case CERTMGR_CERT_CONTAINER:
				ASSERT (!m_bMultipleObjectsSelected);
				if ( !bIsFileView && !m_bIsRSOP )
				{
					CContainerCookie* pContainer =
							reinterpret_cast <CContainerCookie*> (pCookie);
					ASSERT (pContainer);
					if ( pContainer )
					{
                        // Bug 254166 Certificate snapin:  options which permit remote machine enrollment/renewal must be removed
						if ( pContainer->GetStoreType () == MY_STORE &&
                                IsLocalComputername (m_szManagedComputer) &&
                                !m_bMachineIsStandAlone )
						{
							if ( !pContainer->GetCertStore ().IsReadOnly () && CERT_SYSTEM_STORE_SERVICES != m_dwLocationPersist)
    	                        hr = AddSingleMenuItem (pContextMenuCallback, 
                                        CCM_INSERTIONPOINTID_PRIMARY_TASK,
                                        IDS_ENROLL_NEW_CERT,
                                        IDS_ENROLL_NEW_CERT_HINT,
                                        IDM_ENROLL_NEW_CERT);
						}
                        if ( !pContainer->GetCertStore ().IsReadOnly () )
	                        hr = AddSingleMenuItem (pContextMenuCallback, 
                                    CCM_INSERTIONPOINTID_PRIMARY_TASK,
                                    IDS_IMPORT,
                                    IDS_IMPORT_HINT,
                                    IDM_TASK_IMPORT);
					}
				}
				break;

            case CERTMGR_SAFER_COMPUTER_LEVEL:
            case CERTMGR_SAFER_USER_LEVEL:
                if ( m_pGPEInformation )
                {
					CSaferLevel* pLevel = reinterpret_cast <CSaferLevel*>
							 (pCookie);
					ASSERT (pLevel);
					if ( pLevel )
					{
                        // RAID#265590	Safer Windows:  "Set as default" menu 
                        // item is enabled in the context menu of a security 
                        // level when the security level is already the default.
                        if ( (SAFER_LEVELID_DISALLOWED == pLevel->GetLevel () ||
                                SAFER_LEVELID_FULLYTRUSTED == pLevel->GetLevel () ||
                                SAFER_LEVELID_NORMALUSER == pLevel->GetLevel ()) 
                                && !pLevel->IsDefault () )
                        {
                            hr = AddSingleMenuItem (pContextMenuCallback, 
                                    CCM_INSERTIONPOINTID_PRIMARY_TASK,
                                    IDS_SAFER_SET_DEFAULT,
                                    IDS_SAFER_SET_DEFAULT_HINT,
                                    IDM_SAFER_LEVEL_SET_DEFAULT);
                        }
                    }
                }
                break;

            case CERTMGR_SAFER_COMPUTER_ENTRIES:
            case CERTMGR_SAFER_USER_ENTRIES:
                if ( m_pGPEInformation )
                    hr = AddSaferNewEntryMenuItems (pContextMenuCallback, 
                            CCM_INSERTIONPOINTID_PRIMARY_TASK);
                break;

            case CERTMGR_SAFER_COMPUTER_ROOT:
            case CERTMGR_SAFER_USER_ROOT:
                {
                    CSaferRootCookie* pSaferRootCookie = dynamic_cast <CSaferRootCookie*> (pCookie);
                    if ( pSaferRootCookie )
                    {
                        // Don't add these menu options if the Safer node 
                        // hasn't been expanded at least once, otherwise, we
                        // can't tell if there is already a safer policy or not.
                        if ( !m_bIsRSOP && pSaferRootCookie->m_bExpandedOnce )
                        {
                            if ( pSaferRootCookie->m_bCreateSaferNodes )
                                hr = AddSingleMenuItem (pContextMenuCallback, 
                                        CCM_INSERTIONPOINTID_PRIMARY_TASK,
                                        IDS_DELETE_SAFER_POLICY,
                                        IDS_DELETE_SAFER_POLICY_HINT,
                                        IDM_TASK_DELETE_NEW_SAFER_POLICY);
                            else
                                hr = AddSingleMenuItem (pContextMenuCallback, 
                                        CCM_INSERTIONPOINTID_PRIMARY_TASK,
                                        IDS_NEW_SAFER_POLICY,
                                        IDS_NEW_SAFER_POLICY_HINT,
                                        IDM_TASK_CREATE_NEW_SAFER_POLICY);
                        }
                    }
                }
                break;

            default:
                break;
			}
  		}
  		if ( *pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW )
  		{
			switch (objType)
			{	
			case CERTMGR_CERTIFICATE:
			case CERTMGR_CRL:
			case CERTMGR_CTL:
			case CERTMGR_AUTO_CERT_REQUEST:
				break;

			case CERTMGR_SNAPIN:
			case CERTMGR_PHYS_STORE:
			case CERTMGR_USAGE:
			case CERTMGR_LOG_STORE:
				ASSERT (!m_bMultipleObjectsSelected);
                hr = AddSingleMenuItem (pContextMenuCallback, 
                        CCM_INSERTIONPOINTID_PRIMARY_VIEW,
                        IDS_OPTIONS,
                        IDS_OPTIONS_HINT,
                        IDM_OPTIONS);
				break;

			default:
				break;
			}
   		}
	}
    else
    {
		//  Computer name is not valid.  Only allow "Change Computer"
  		if ( *pInsertionAllowed & CCM_INSERTIONALLOWED_TOP )
  		{
			if ( CERTMGR_SNAPIN == objType )
			{
                if ( CERT_SYSTEM_STORE_CURRENT_USER != m_dwLocationPersist )
                {
	                hr = AddSingleMenuItem (pContextMenuCallback, 
                            CCM_INSERTIONPOINTID_PRIMARY_TOP,
                            IDS_CHANGE_COMPUTER,
                            IDS_CHANGE_COMPUTER_HINT,
                            IDM_TOP_CHANGE_COMPUTER);
                }
            }
        }
  		if ( *pInsertionAllowed & CCM_INSERTIONALLOWED_TASK )
  		{
			if ( CERTMGR_SNAPIN == objType )
			{
                if ( CERT_SYSTEM_STORE_CURRENT_USER != m_dwLocationPersist )
                {
	                hr = AddSingleMenuItem (pContextMenuCallback, 
                            CCM_INSERTIONPOINTID_PRIMARY_TASK,
                            IDS_CHANGE_COMPUTER,
                            IDS_CHANGE_COMPUTER_HINT,
                            IDM_TASK_CHANGE_COMPUTER);
                }
            }
  		}
    }

	_TRACE (-1, L"Leaving CCertMgrComponentData::AddMenuItems: 0x%x\n", hr);
	return hr;
}


HRESULT CCertMgrComponentData::AddCertificateTaskMenuItems (
		LPCONTEXTMENUCALLBACK pContextMenuCallback, 
        const bool bIsMyStore, 
        bool bIsReadOnly,
		CCertificate* /*pCert*/)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddCertificateTaskMenuItems\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	ASSERT (pContextMenuCallback);
	HRESULT			hr = S_OK;

	if ( !m_bMultipleObjectsSelected )
	{
		hr = AddSingleMenuItem (pContextMenuCallback, 
                CCM_INSERTIONPOINTID_PRIMARY_TASK,
                IDS_VIEW,
                IDS_VIEW_HINT,
                IDM_TASK_OPEN);

		AddSeparator (pContextMenuCallback);

		if ( m_szFileName.IsEmpty () )
		{
            // Bug 254166 Certificate snapin:  options which permit remote machine enrollment/renewal must be removed
			if ( bIsMyStore && 
                    CERT_SYSTEM_STORE_SERVICES != m_dwLocationPersist &&
                    IsLocalComputername (m_szManagedComputer) &&
                    !m_bMachineIsStandAlone &&
                    !bIsReadOnly )
			{
	            hr = AddSingleMenuItem (pContextMenuCallback, 
                        CCM_INSERTIONPOINTID_PRIMARY_TASK,
                        IDS_ENROLL_CERT_WITH_NEW_KEY,
                        IDS_ENROLL_CERT_WITH_NEW_KEY_HINT,
                        IDM_ENROLL_NEW_CERT_NEW_KEY);

	            hr = AddSingleMenuItem (pContextMenuCallback, 
                        CCM_INSERTIONPOINTID_PRIMARY_TASK,
                        IDS_ENROLL_CERT_WITH_SAME_KEY,
                        IDS_ENROLL_CERT_WITH_SAME_KEY_HINT,
                        IDM_ENROLL_NEW_CERT_SAME_KEY);

	            hr = AddSingleMenuItem (pContextMenuCallback, 
                        CCM_INSERTIONPOINTID_PRIMARY_TASK,
                        IDS_RENEW_NEW_KEY,
                        IDS_RENEW_NEW_KEY_HINT,
                        IDM_TASK_RENEW_NEW_KEY);

	            hr = AddSingleMenuItem (pContextMenuCallback, 
                        CCM_INSERTIONPOINTID_PRIMARY_TASK,
                        IDS_RENEW_SAME_KEY,
                        IDS_RENEW_SAME_KEY_HINT,
                        IDM_TASK_RENEW_SAME_KEY);
			}
		}
	}

	hr = AddSingleMenuItem (pContextMenuCallback, 
            CCM_INSERTIONPOINTID_PRIMARY_TASK,
            IDS_EXPORT,
            IDS_EXPORT_HINT,
            IDM_TASK_EXPORT);

	_TRACE (-1, L"Leaving CCertMgrComponentData::AddCertificateTaskMenuItems: 0x%x\n", hr);
	return hr;
}

HRESULT CCertMgrComponentData::AddCTLTaskMenuItems (LPCONTEXTMENUCALLBACK pContextMenuCallback, bool bIsReadOnly)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddCTLTaskMenuItems\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	ASSERT (pContextMenuCallback);
	HRESULT			hr = S_OK;

	if ( !m_bMultipleObjectsSelected )
		hr = AddSingleMenuItem (pContextMenuCallback, 
                CCM_INSERTIONPOINTID_PRIMARY_TASK,
                IDS_VIEW,
                IDS_CTL_VIEW_HINT,
                IDM_TASK_OPEN);

    hr = AddSingleMenuItem (pContextMenuCallback, 
            CCM_INSERTIONPOINTID_PRIMARY_TASK,
            IDS_EXPORT,
            IDS_EXPORT_HINT,
            IDM_TASK_CTL_EXPORT);

	if ( !m_bMultipleObjectsSelected && !bIsReadOnly )
	{
	    hr = AddSingleMenuItem (pContextMenuCallback, 
                CCM_INSERTIONPOINTID_PRIMARY_TASK,
                IDS_EDIT,
                IDS_CTL_EDIT_HINT,
                IDM_CTL_EDIT);
	}

	_TRACE (-1, L"Leaving CCertMgrComponentData::AddCTLTaskMenuItems: 0x%x\n", hr);
	return hr;
}


HRESULT CCertMgrComponentData::AddSeparator (LPCONTEXTMENUCALLBACK pContextMenuCallback)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddSeparator\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	ASSERT (pContextMenuCallback);
	CONTEXTMENUITEM	menuItem;

    // security review 2/22/2002 BryanWal ok
	::ZeroMemory (&menuItem, sizeof (menuItem));
	menuItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
	menuItem.fSpecialFlags = 0;
	menuItem.strName = _T ("Separator");			// Dummy name
	menuItem.strStatusBarText = _T ("Separator");// Dummy status text
	menuItem.lCommandID = ID_SEPARATOR;			// Command ID
	menuItem.fFlags = MF_SEPARATOR;				// most important the flag
	HRESULT	hr = pContextMenuCallback->AddItem (&menuItem);

	_TRACE (-1, L"Leaving CCertMgrComponentData::AddSeparator: 0x%x\n", hr);
	return hr;
}


HRESULT CCertMgrComponentData::AddSingleMenuItem (
            LPCONTEXTMENUCALLBACK pContextMenuCallback, 
            LONG lInsertionPointID,
            int menuTextID,
            int menuHintID,
            int menuID)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddSingleMenuItem\n");
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	ASSERT (pContextMenuCallback);
    if ( !pContextMenuCallback )
        return E_POINTER;

    switch (lInsertionPointID)
    {
    case CCM_INSERTIONPOINTID_PRIMARY_VIEW:
    case CCM_INSERTIONPOINTID_PRIMARY_TASK:
    case CCM_INSERTIONPOINTID_PRIMARY_TOP:
    case CCM_INSERTIONPOINTID_PRIMARY_NEW:
        break;

    default:
        ASSERT (0);
        return E_INVALIDARG;
    }

    ASSERT (menuTextID > 0);
    if ( menuTextID <= 0 )
        return E_INVALIDARG;


    ASSERT (menuHintID > 0);
    if ( menuHintID <= 0 )
        return E_INVALIDARG;

    ASSERT (menuID > MIN_MENU_ID && menuID < MAX_MENU_ID);
    if ( menuID <= MIN_MENU_ID || menuID >= MAX_MENU_ID )
        return E_INVALIDARG;

    HRESULT			hr = S_OK;
	CONTEXTMENUITEM	menuItem;
	CString			szMenu;
	CString			szHint;

	// unchanging settings
    // security review 2/22/2002 BryanWal ok
	::ZeroMemory (&menuItem, sizeof (menuItem));
	menuItem.lInsertionPointID = lInsertionPointID;
	menuItem.fFlags = 0;

	VERIFY (szMenu.LoadString (menuTextID));
	menuItem.strName = (PWSTR) (PCWSTR) szMenu;
	VERIFY (szHint.LoadString (menuHintID));
	menuItem.strStatusBarText = (PWSTR) (PCWSTR) szHint;
	menuItem.lCommandID = menuID;

	hr = pContextMenuCallback->AddItem (&menuItem);
	ASSERT (SUCCEEDED (hr));

	_TRACE (-1, L"Leaving CCertMgrComponentData::AddSingleMenuItem: 0x%x\n", hr);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\componentdatarsop.cpp ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       ComponentDataRSOP.cpp
//
//  Contents:   Implementation of RSOP portions CCertMgrComponentData
//
//----------------------------------------------------------------------------

#include "stdafx.h"

#include <gpedit.h>
#include "compdata.h"
#include "dataobj.h"
#include "cookie.h"
#include "Certifct.h"
#pragma warning(push, 3)
#include <wintrust.h>
#include <cryptui.h>
#include <sceattch.h>
#pragma warning(pop)
#include "StoreRSOP.h"

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//
// CCertMgrComponentData
//


HRESULT CCertMgrComponentData::BuildWMIList (LPDATAOBJECT pDataObject, bool bIsComputer)
{
    _TRACE (1, L"Entering CCertMgrComponentData::BuildWMIList (%s)\n", bIsComputer ? L"computer" : L"user");
    HRESULT hr = S_OK;

#if DBG
    if ( bIsComputer )
    {
        _TRACE (0, L"m_rsopObjectArrayComputer contains %d objects\n", 
                m_rsopObjectArrayComputer.GetUpperBound ());
    }
    else
    {
        _TRACE (0, L"m_rsopObjectArrayUser contains %d objects\n", 
                m_rsopObjectArrayUser.GetUpperBound ());
    }
#endif
    int     nIndex = 0;
    if ( bIsComputer )
    {
        INT_PTR nUpperBound = m_rsopObjectArrayComputer.GetUpperBound ();
        while ( nUpperBound >= nIndex )
        {
            CRSOPObject* pCurrObject = m_rsopObjectArrayComputer.GetAt (nIndex);
            if ( pCurrObject )
            {
                delete pCurrObject;
            }
            nIndex++;
        }
        m_rsopObjectArrayComputer.RemoveAll ();
    }
    else
    {
        INT_PTR nUpperBound = m_rsopObjectArrayUser.GetUpperBound ();
        while ( nUpperBound >= nIndex )
        {
            CRSOPObject* pCurrObject = m_rsopObjectArrayUser.GetAt (nIndex);
            if ( pCurrObject )
            {
                delete pCurrObject;
            }
            nIndex++;
        }
        m_rsopObjectArrayUser.RemoveAll ();
    }

    if ( ((bIsComputer && !m_pRSOPInformationComputer) || 
                (!bIsComputer && !m_pRSOPInformationUser) ) 
            && pDataObject )
    {
	    IUnknown* pIUnknown = 0;

	    hr = ExtractData (pDataObject,
		    CCertMgrDataObject::m_CFSCE_RSOPUnknown,
		    &pIUnknown, sizeof (IUnknown*));
	    ASSERT (SUCCEEDED (hr));
	    if ( SUCCEEDED (hr) )
	    {
            if ( bIsComputer )
            {
		        hr = pIUnknown->QueryInterface (
				        IID_PPV_ARG (IRSOPInformation, &m_pRSOPInformationComputer));
            }
            else
            {
		        hr = pIUnknown->QueryInterface (
				        IID_PPV_ARG (IRSOPInformation, &m_pRSOPInformationUser));
            }
		    ASSERT (SUCCEEDED (hr));
            if ( SUCCEEDED (hr) )
            {
                if ( bIsComputer )
                {
                    hr = m_pRSOPInformationComputer->GetFlags (&m_dwRSOPFlagsComputer);
                }
                else
                {
                     hr = m_pRSOPInformationUser->GetFlags (&m_dwRSOPFlagsUser);
                }
                ASSERT (SUCCEEDED (hr));

                int cchMaxLength = 512;
                LPOLESTR    pszNameSpace = (LPOLESTR) LocalAlloc (LPTR, cchMaxLength * sizeof (WCHAR));
                if ( pszNameSpace )
                {
                    DWORD   dwSection = 0;

                    switch (m_dwSCEMode)
                    {
                    case SCE_MODE_LOCAL_USER:
                    case SCE_MODE_DOMAIN_USER:
                    case SCE_MODE_OU_USER:
                    case SCE_MODE_REMOTE_USER:
                    case SCE_MODE_RSOP_USER:
                        dwSection = GPO_SECTION_USER;
                        break;

                    case SCE_MODE_LOCAL_COMPUTER:
                    case SCE_MODE_DOMAIN_COMPUTER:
                    case SCE_MODE_OU_COMPUTER:
                    case SCE_MODE_RSOP_COMPUTER:
                    case SCE_MODE_REMOTE_COMPUTER:
                        dwSection = GPO_SECTION_MACHINE;
                        break;

                    default:
                        ASSERT (0);
                        return E_UNEXPECTED;
                    }
                    if ( bIsComputer )
                    {
                        hr = m_pRSOPInformationComputer->GetNamespace (
                                dwSection, 
                                pszNameSpace,
                                cchMaxLength);
                    }
                    else
                    {
                        hr = m_pRSOPInformationUser->GetNamespace (
                                dwSection, 
                                pszNameSpace,
                                cchMaxLength);
                    }
                    if ( SUCCEEDED (hr) )
                    {
                        IWbemLocator *pIWbemLocator = 0;
                        // ISSUE
                        // NTRAID 544154 TRACKING:  PKP GrpPol:  Verify that WMI communication with the store can be secured
                        hr = ::CoCreateInstance (CLSID_WbemLocator, 
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                IID_PPV_ARG(IWbemLocator, &pIWbemLocator));
                        if ( SUCCEEDED (hr) )
                        {
                            BSTR    bstrNameSpace = SysAllocString (pszNameSpace);
                            if ( bstrNameSpace )
                            {
                                if ( bIsComputer )
                                {
                                    hr = pIWbemLocator->ConnectServer (bstrNameSpace,
                                            NULL, NULL, 0, 0, NULL, NULL,
                                            &m_pIWbemServicesComputer);
                                }
                                else
                                {
                                    hr = pIWbemLocator->ConnectServer (bstrNameSpace,
                                            NULL, NULL, 0, 0, NULL, NULL,
                                            &m_pIWbemServicesUser);
                                }
					            if ( FAILED (hr) )
					            {
						            _TRACE (0, L"IWbemLocator::ConnectServer (%s) failed: 0x%x(%s)\n", 
								            bstrNameSpace, hr, (PCWSTR) GetSystemMessage (hr));
					            }
                                SysFreeString (bstrNameSpace);
                            }
				            else
					            hr = E_OUTOFMEMORY;
				            pIWbemLocator->Release ();
                        }
                    }
                    LocalFree (pszNameSpace);
                }
                else
                    hr = E_OUTOFMEMORY;
            }
	    }
    }

    if ( SUCCEEDED (hr) && ((bIsComputer && m_pIWbemServicesComputer) || 
            (!bIsComputer && m_pIWbemServicesUser)) )
    {
        IEnumWbemClassObject * pEnum = 0;
        IWbemClassObject *pObject = 0;
        ULONG   ulRet = 0;


        //
        // Execute the query
        //
        if ( bIsComputer )
        {
            hr = m_pIWbemServicesComputer->ExecQuery (m_pbstrLanguage, m_pbstrQuery, 
  