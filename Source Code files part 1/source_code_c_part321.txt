holds state used
                 to enumerate the bus.

    DataBufferSize - The size buffer we need.

    Resources - Pointer to an enumerator resources structure. 

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG SpecificLuSize;
    PRAID_ADAPTER_EXTENSION Adapter;
    
    PAGED_CODE();

    Adapter = Enumerator->Adapter;
    ASSERT_ADAPTER (Adapter);
    
    //
    // Allocate SRB if necessary; if one has already been allocated,
    // recycle it.
    //

    Status = STATUS_SUCCESS;
    
    if (Resources->Srb == NULL) {
        Resources->Srb = RaidAllocateSrb (Adapter->DeviceObject);
        if (Resources->Srb == NULL) {
            return STATUS_NO_MEMORY;
        }
    } else {
        RaidPrepareSrbForReuse (Resources->Srb);
    }

    if (Resources->SenseInfo == NULL) {
        Resources->SenseInfo = RaidAllocatePool (NonPagedPool,
                                                 SENSE_BUFFER_SIZE,
                                                 SENSE_TAG,
                                                 Adapter->DeviceObject);
        if (Resources->SenseInfo == NULL) {
            return STATUS_NO_MEMORY;
        }
    }

    if (Resources->Irp == NULL) {
        Resources->Irp = IoAllocateIrp (1, FALSE);
        if (Resources->Irp == NULL) {
            return STATUS_NO_MEMORY;
        }
    } else {
        IoReuseIrp (Resources->Irp, STATUS_UNSUCCESSFUL);
    }

    if (Resources->DataBuffer != NULL) {
        RaidFreePool (Resources->DataBuffer, REPORT_LUNS_TAG);
    }

    Resources->DataBuffer = RaidAllocatePool (NonPagedPool,
                                              DataBufferSize,
                                              REPORT_LUNS_TAG,
                                              Adapter->DeviceObject);

    if (Resources->DataBuffer == NULL) {
        return STATUS_NO_MEMORY;
    }
    Resources->DataBufferLength = DataBufferSize;

    if (Resources->Mdl != NULL) {
        IoFreeMdl (Resources->Mdl);
    }

    Resources->Mdl = IoAllocateMdl (Resources->DataBuffer,
                                    Resources->DataBufferLength,
                                    FALSE,
                                    FALSE,
                                    NULL);
    return Status;
}

VOID
RaidBusEnumeratorBuildReportLuns(
    IN PBUS_ENUMERATOR Enumerator,
    IN RAID_ADDRESS Address,
    IN PBUS_ENUM_RESOURCES Resources,
    IN ULONG DataBufferSize,
    OUT PSCSI_REQUEST_BLOCK* SrbBuffer
    )
/*++

Routine Description:

    Build a REPORT LUNS command.

Arguments:

    Enumerator -

    Address - SCSI Address the inquiry is for.

    Resources - Resources to use for the inquiry command.

    DataBufferSize - Specifies size of the SRB's data buffer.

Return Value:

    None.

--*/
{
    PSCSI_REQUEST_BLOCK Srb;
    struct _REPORT_LUNS * ReportLuns;
    PLUN_LIST LunList;

    PAGED_CODE();

    ASSERT (SrbBuffer != NULL);
    
    Srb = Resources->Srb;
    LunList = (PLUN_LIST)Resources->DataBuffer;
    ReportLuns = NULL;

    ASSERT (Srb != NULL);
    ASSERT (LunList != NULL);
    
    RtlZeroMemory (LunList, DataBufferSize);

    RaidInitializeReportLunsSrb (Srb,
                                 Address.PathId,
                                 Address.TargetId,
                                 Address.Lun,
                                 LunList,
                                 DataBufferSize);

    ReportLuns = (struct _REPORT_LUNS *) &Srb->Cdb;

    Srb->SrbExtension = NULL;

    //
    // Initialize the sense info buffer.
    //

    Srb->SenseInfoBuffer = Resources->SenseInfo;
    Srb->SenseInfoBufferLength = SENSE_BUFFER_SIZE;

    Srb->DataBuffer = Resources->DataBuffer;
    Srb->DataTransferLength = DataBufferSize;

    Srb->SrbFlags |= SRB_FLAGS_NO_QUEUE_FREEZE;
    Srb->SrbFlags |= (SRB_FLAGS_BYPASS_FROZEN_QUEUE |
                      SRB_FLAGS_BYPASS_LOCKED_QUEUE);
    
    *SrbBuffer = Srb;
}

NTSTATUS
RaidBusEnumeratorProbeLunZero(
    IN PVOID Context,
    IN RAID_ADDRESS Address
    )
/*++

Routine Description:

    This routine sends an INQUIRY command to LUN zero of a given target to
    determine if LUN zero is present.

Arguments:

    Context - Supplies the context passed into the AdapterEnumerateBus
              routine, which, in our case, is a pointer to a BUS_ENUMERATOR
              structure.

    Address - SCSI target address of logical unit to be enumerated.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PBUS_ENUMERATOR Enumerator;
    BUS_ENUM_UNIT EnumUnit;
    BOOLEAN Found;

    PAGED_CODE();

    Enumerator = (PBUS_ENUMERATOR) Context;
    ASSERT_ENUM (Enumerator);
    RtlZeroMemory (&EnumUnit, sizeof (EnumUnit));

    Status = RaidBusEnumeratorGetUnit (Enumerator, Address, &EnumUnit);
    ASSERT (NT_SUCCESS (Status));

    RaidBusEnumeratorGenericInquiry (&RaidEnumProbeLunZeroCallback,
                                     Enumerator,
                                     Address,
                                     &EnumUnit,
                                     RAID_INQUIRY_RETRY_COUNT);

    RaidBusEnumeratorReleaseUnit (Enumerator, &EnumUnit);
    
    return (EnumUnit.Found) ? STATUS_SUCCESS : STATUS_NO_SUCH_DEVICE;
}

VOID
RaidBusEnumeratorGetLunList(
    IN PVOID Context,
    IN RAID_ADDRESS Address,
    IN OUT PUCHAR LunList
    )
/*++

Routine Description:

    This routine initializes a list that tells the caller which LUNs to scan
    on the specified target.

Arguments:

    Context - Supplies the context passed into the AdapterEnumerateBus
              routine, which, in our case, is a pointer to a BUS_ENUMERATOR
              structure.

    Address - SCSI target address of logical unit to be enumerated.

    LunList - An array of bytes.  On exit, each non-zero byte indicates to the
              caller, that an INQUIRY command should be sent to the corresp-
              onding LUN.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PBUS_ENUMERATOR Enumerator;
    BUS_ENUM_UNIT EnumUnit;
    RAID_ADDRESS UnitAddress;
    PRAID_UNIT_EXTENSION Unit;
    UCHAR Lun;

    PAGED_CODE();

    Enumerator = (PBUS_ENUMERATOR) Context;
    ASSERT_ENUM (Enumerator);
    RtlZeroMemory (&EnumUnit, sizeof (EnumUnit));

    Status = RaidBusEnumeratorGetUnit (Enumerator, Address, &EnumUnit);
    ASSERT (NT_SUCCESS (Status));

    //
    // First, see if the target can provide us with a list of LUNs to scan.
    //

    Status = RaidBusEnumeratorGetLunListFromTarget (Enumerator,
                                                    Address,
                                                    &EnumUnit,
                                                    LunList);

    //
    // If the target could not provide us with a LUN list, check if there is
    // even a device present at LUN zero.  If there is not, zero out the list
    // of LUNs to scan.
    //

    if (!NT_SUCCESS (Status)) {
        Status = RaidBusEnumeratorProbeLunZero (Context, Address);

        //
        // If the probe of LUN zero succeeded, mark all the LUNs of this
        // target to be scanned. Otherwise, mark them so they will not be
        // scanned.
        //
        
        if (NT_SUCCESS (Status)) {
            RtlFillMemory (LunList, SCSI_MAXIMUM_LUNS_PER_TARGET, 1);
        } else {
            RtlZeroMemory (LunList, SCSI_MAXIMUM_LUNS_PER_TARGET);
        }
    }

    RaidBusEnumeratorReleaseUnit (Enumerator, &EnumUnit);

    //
    // Also, rescan any devices where there already was a device in case
    // a LUN went away.
    // 
    
    UnitAddress = Address;
    for (Lun = 0; Lun < SCSI_MAXIMUM_LUNS_PER_TARGET; Lun++) {
        UnitAddress.Lun = Lun;
        Unit = RaidAdapterFindUnit (Enumerator->Adapter, UnitAddress);
        if (Unit != NULL) {
            LunList [Lun] = TRUE;
        }
    }
}

NTSTATUS
RaidBusEnumeratorProcessProbeLunZero(
    IN PBUS_ENUMERATOR Enumerator,
    IN PSCSI_REQUEST_BLOCK Srb,
    OUT PBUS_ENUM_UNIT EnumUnit
    )
/*++

Routine Description:

    This routine processes an Inquiry command by checking if a valid device
    is present at LUN zero.

Arguments:

    Enumerator - Supplies the enumerator the inquiry command is for.

    Srb - Supples the completed SCSI request block for this inquiry.

    EnumUnit - Supplies per-unit enumeration data that is modified by this
        routine.

Return Value:

    NTSTATUS code.

--*/
{
    PINQUIRYDATA InquiryData;
    PBUS_ENUM_RESOURCES Resources;

    if (SRB_STATUS (Srb->SrbStatus) != SRB_STATUS_SUCCESS) {
        return RaidSrbStatusToNtStatus (Srb->SrbStatus);
    }

    Resources = &Enumerator->Resources;
    InquiryData = (PINQUIRYDATA)Resources->DataBuffer;

    //
    // NOTE: Filter out any invalid device.  For now, assume any response
    //       from LUN zero indicates goodness.
    //

    //
    // The inquiry data is now owned by the identification packet, so
    // NULL it out in the Resources structure.
    //
    
    EnumUnit->Identity.InquiryData = InquiryData;
    EnumUnit->Found = TRUE;
    
    Resources->DataBuffer = NULL;
    Resources->DataBufferLength = 0;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\busenum.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    BusEnum.h

Abstract:

    Declaration of bus enumerator class.

Author:

    Matthew D Hendel (math) 21-Feb-2001

Revision History:

--*/


#pragma once


//
// Resources maintained while enumerating the bus. We carry resources
// through the enumeration to avoid repeadedly allocating then freeing
// the same resources over and over again.
//

typedef struct _BUS_ENUM_RESOURCES {
    PIRP Irp;
    PMDL Mdl;
    PSCSI_REQUEST_BLOCK Srb;
    PVOID SenseInfo;
    PVOID DataBuffer;
    ULONG DataBufferLength;
    PRAID_UNIT_EXTENSION Unit;
} BUS_ENUM_RESOURCES, *PBUS_ENUM_RESOURCES;



typedef enum _BUS_ENUM_UNIT_STATE {
    EnumUnmatchedUnit,          // Not yet matched
    EnumNewUnit,                // No matching entry in the enum list
    EnumMatchedUnit             // Found matching entry in enum list
} BUS_ENUM_UNIT_STATE;


//
// State information for the enumerator itself.
//

typedef struct _BUS_ENUMERATOR {

    //
    // Pointer to the adapter extension this
    
    PRAID_ADAPTER_EXTENSION Adapter;

    //
    // Resources used for enumeration. These change over time.
    //
    
    BUS_ENUM_RESOURCES Resources;

    //
    // Second set of resources used in issuing REPORT LUNS commands.
    //

    BUS_ENUM_RESOURCES ReportLunsResources;

    //
    // List of new adapters found during this enumeration. These are
    // adapters that have no matching entries on any other per-adapter list.
    //

    LIST_ENTRY EnumList;

} BUS_ENUMERATOR, *PBUS_ENUMERATOR;



//
// The RAID_BC_UNIT contains the per-unit state we need to maintain while
// eunmerating the bus.
//

typedef struct _BUS_ENUM_UNIT {

    //
    // Whether the device supports device Ids.
    //
    
    BOOLEAN SupportsDeviceId;

    //
    // Whether the device supports serial numbers.
    //
    
    BOOLEAN SupportsSerialNumber;

    //
    // SCSI/RAID address for the device.
    //
    
    RAID_ADDRESS Address;

    //
    // If this unit cooresponds ot an already enumerated unit, this 
    // this field points to the already existing unit. Otherwise, it's
    // NULL.
    //

    PRAID_UNIT_EXTENSION Unit;

    //
    // Link to next entry in the entry list.
    //
    
    LIST_ENTRY EnumLink;

    //
    // Identity of this unit.
    //
    
    STOR_SCSI_IDENTITY Identity;

    //
    // Current state for this unit.
    //
    
    BUS_ENUM_UNIT_STATE State;

    //
    // Whether this is a new unit or not.
    //
    
    BOOLEAN NewUnit;

    //
    // Whether any data was found at the unit or not.
    //
    
    BOOLEAN Found;
    
} BUS_ENUM_UNIT, *PBUS_ENUM_UNIT;


VOID
RaidCreateBusEnumerator(
    IN PBUS_ENUMERATOR Enumerator
    );

NTSTATUS
RaidInitializeBusEnumerator(
    IN PBUS_ENUMERATOR Enumerator,
    IN PRAID_ADAPTER_EXTENSION Adapter
    );

VOID
RaidDeleteBusEnumerator(
    IN PBUS_ENUMERATOR Enum
    );

VOID
RaidBusEnumeratorAddUnit(
    IN PBUS_ENUMERATOR Enumerator,
    IN PRAID_UNIT_EXTENSION Unit
    );

NTSTATUS
RaidBusEnumeratorVisitUnit(
    IN PVOID Context,
    IN RAID_ADDRESS Address
    );

LOGICAL
RaidBusEnumeratorProcessModifiedNodes(
    IN PBUS_ENUMERATOR Enumerator
    );

NTSTATUS
RaidBusEnumeratorProbeLunZero(
    IN PVOID Context,
    IN RAID_ADDRESS Address
    );

VOID
RaidBusEnumeratorGetLunList(
    IN PVOID Context,
    IN RAID_ADDRESS Address,
    IN OUT PUCHAR LunList
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\debug.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    Debuging functions for RAIDPORT driver.

Author:

    Matthew D Hendel (math) 24-Apr-2000

Revision History:

--*/

#pragma once

#if !DBG

#define ASSERT_PDO(Pdo)
#define ASSERT_UNIT(Unit)
#define ASSERT_ADAPTER(Adapter)
#define ASSERT_XRB(Xrb)

#define DebugPower(x)
#define DebugPnp(x)
#define DebugScsi(x)

#else // DBG

#define VERIFY(_x) ASSERT(_x)

#define ASSERT_PDO(DeviceObject)\
    ASSERT((DeviceObject) != NULL &&\
           (DeviceObject)->DeviceObjectExtension->DeviceNode == NULL)

#define ASSERT_UNIT(Unit)\
    ASSERT((Unit) != NULL &&\
            (Unit)->ObjectType == RaidUnitObject)

#define ASSERT_ADAPTER(Adapter)\
    ASSERT((Adapter) != NULL &&\
            (Adapter)->ObjectType == RaidAdapterObject)

#define ASSERT_XRB(Xrb)\
    ASSERT ((Xrb) != NULL &&\
            (((PEXTENDED_REQUEST_BLOCK)Xrb)->Signature == XRB_SIGNATURE));
    
VOID
DebugPrintInquiry(
    IN PINQUIRYDATA InquiryData,
    IN SIZE_T InquiryDataSize
    );

VOID
DebugPrintSrb(
    IN PSCSI_REQUEST_BLOCK Srb
    );

VOID
StorDebugPower(
    IN PCSTR Format,
    ...
    );

VOID
StorDebugPnp(
    IN PCSTR Format,
    ...
    );

VOID
StorDebugScsi(
    IN PCSTR Format,
    ...
    );

#define STOR_DEBUG_POWER_MASK   (0x80000000)
#define STOR_DEBUG_PNP_MASK     (0x40000000)
#define STOR_DEBUG_SCSI_MASK    (0x20000000)
#define STOR_DEBUG_IOCTL_MASK   (0x10000000)

#define DebugPower(x)   StorDebugPower x
#define DebugPnp(x)     StorDebugPnp x
#define DebugScsi(x)    StorDebugScsi x

#endif // DBG

//
// Allocation tags for checked build.
//

#define INQUIRY_TAG             ('21aR')    // Ra12
#define MAPPED_ADDRESS_TAG      ('MAaR')    // RaAM
#define CRASHDUMP_TAG           ('DCaR')    // RaCD
#define ID_TAG                  ('IDaR')    // RaDI
#define DEFERRED_ITEM_TAG       ('fDaR')    // RaDf
#define STRING_TAG              ('SDaR')    // RaDS
#define DEVICE_RELATIONS_TAG    ('RDaR')    // RaDR
#define HWINIT_TAG              ('IHaR')    // RaHI
#define MINIPORT_EXT_TAG        ('EMaR')    // RaME
#define PORTCFG_TAG             ('CPaR')    // RaPC
#define PORT_DATA_TAG           ('DPaR')    // RaPD
#define PENDING_LIST_TAG        ('LPaR')    // RaPL
#define QUERY_TEXT_TAG          ('TQaR')    // RaQT
#define REMLOCK_TAG             ('mRaR')    // RaRm
#define RESOURCE_LIST_TAG       ('LRaR')    // RaRL
#define SRB_TAG                 ('rSaR')    // RaSr
#define SRB_EXTENSION_TAG       ('ESaR')    // RaSE
#define TAG_MAP_TAG             ('MTaR')    // RaTM
#define XRB_TAG                 ('rXaR')    // RaXr
#define UNIT_EXT_TAG            ('EUaR')    // RaUE
#define SENSE_TAG               ('NSaR')    // RaSN
#define WMI_EVENT_TAG           ('MWaR')    // RaMW
#define REPORT_LUNS_TAG         ('lRaR')    // RaRl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\common.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    common.h
    
Abstract:

    Common definitions for both Adapter (FDO) and Unit (PDO) objects.
Author:

    Matthew D Hendel (math) 20-Apr-2000

Revision History:

--*/

#pragma once

typedef enum _RAID_OBJECT_TYPE {
    RaidUnknownObject   = -1,
    RaidAdapterObject   = 0,
    RaidUnitObject      = 1,
    RaidDriverObject    = 2
} RAID_OBJECT_TYPE;

    
//
// The common extension is the portion of the extension that is common to
// the RAID_DRIVER_EXTENSION, RAID_ADAPTER_EXTENSION and RAID_UNIT_EXTENSION.
//

typedef struct _RAID_COMMON_EXTENSION {
    RAID_OBJECT_TYPE ObjectType;
} RAID_COMMON_EXTENSION, *PRAID_COMMON_EXTENSION;


RAID_OBJECT_TYPE
RaGetObjectType(
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
IsAdapter(
    IN PVOID Extension
    );

BOOLEAN
IsDriver(
    IN PVOID Extension
    );
    
BOOLEAN
IsUnit(
    IN PVOID Extension
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\deferred.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    deferred.h

Abstract:

    Definition of the RAID deferred queue class.

Author:

    Matthew D Hendel (math) 26-Oct-2000

Revision History:

--*/

#pragma once

struct _PRAID_DEFERRED_HEADER;

typedef
VOID
(*PRAID_PROCESS_DEFERRED_ITEM_ROUTINE)(
    IN PDEVICE_OBJECT DeviceObject,
    IN struct _RAID_DEFERRED_HEADER* Item
    );

typedef struct _RAID_DEFERRED_QUEUE {
    USHORT Depth;
    USHORT ItemSize;
    KDPC Dpc;
    SLIST_HEADER FreeList;
    SLIST_HEADER RunningList;
    PRAID_PROCESS_DEFERRED_ITEM_ROUTINE ProcessDeferredItem;
} RAID_DEFERRED_QUEUE, *PRAID_DEFERRED_QUEUE;


typedef struct _RAID_DEFERRED_HEADER {
    SLIST_ENTRY Link;
    LONG Pool;
} RAID_DEFERRED_HEADER, *PRAID_DEFERRED_HEADER;


VOID
RaidCreateDeferredQueue(
    IN PRAID_DEFERRED_QUEUE Queue
    );

NTSTATUS
RaidInitializeDeferredQueue(
    IN OUT PRAID_DEFERRED_QUEUE Queue,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG Depth,
    IN ULONG ItemSize,
    IN PRAID_PROCESS_DEFERRED_ITEM_ROUTINE ProcessDeferredItem
    );

VOID
RaidDeleteDeferredQueue(
    IN PRAID_DEFERRED_QUEUE Queue
    );
    
NTSTATUS
RAidAdjustDeferredQueueDepth(
    IN PRAID_DEFERRED_QUEUE Queue,
    IN ULONG Depth
    );
    
PVOID
RaidAllocateDeferredItem(
    IN PRAID_DEFERRED_QUEUE Queue
    );
    
VOID
RaidFreeDeferredItem(
    IN PRAID_DEFERRED_QUEUE Queue,
    IN PRAID_DEFERRED_HEADER Item
    );
    
VOID
RaidQueueDeferredItem(
    IN PRAID_DEFERRED_QUEUE Queue,
    IN PRAID_DEFERRED_HEADER Item
    );
    
VOID
RaidDeferredQueueDpcRoutine(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PRAID_DEFERRED_QUEUE Queue,
    IN PVOID Context2
    );

VOID
RaidInitializeDeferredItem(
    IN PRAID_DEFERRED_HEADER Item
    );

PVOID
RaidAllocateDeferredItemFromFixed(
    IN PRAID_DEFERRED_HEADER Item
    );

LOGICAL
RaidProcessDeferredItemsWorker(
    IN PRAID_DEFERRED_QUEUE Queue,
    IN PDEVICE_OBJECT DeviceObject
    );

//
// Inline routines
//

LOGICAL
INLINE
RaidProcessDeferredItemsForDpc(
    IN PRAID_DEFERRED_QUEUE Queue,
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Process any outstanding items on the deferred queue. This routine is
    only callable from within a DPC routine. Other callers that need to
    check for deferred items to process should use RaidProcessDeferredItems.

Arguments:

    Queue - Deferred queue to process from.

    DeviceObject - Supplies the DeviceObject associated with this
        deferred queue.

Return Value:

    TRUE - If there was an item on the deferred queue that was processed.

    FALSE - Otherwise.

--*/
{
    LOGICAL Processed;


    Processed = RaidProcessDeferredItemsWorker (Queue, DeviceObject);
    
    return Processed;
}


LOGICAL
INLINE
RaidProcessDeferredItems(
    IN PRAID_DEFERRED_QUEUE Queue,
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Process any outstanding items on the deferred queue. Unlike
    RaidProcessDeferredItemsForDpc, this routine checks for recursion,
    and therefore may be called from within routines called back
    from the DPC.

Arguments:

    Queue - Deferred queue to process from.

Return Value:

    TRUE - If there was an item on the deferred queue that was processed.

    FALSE - Otherwise.

--*/
{
    LOGICAL Processed;

    Processed = RaidProcessDeferredItemsWorker (Queue, DeviceObject);

    return Processed;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\deferred.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    deferred.c

Abstract:

    Implementation of the RAID deferred queue class.

Author:

    Matthew D Hendel (math) 26-Oct-2000

Revision History:

--*/

#include "precomp.h"


//
// Free/allocated signatures.
//

#define DEFERRED_QUEUE_POOL_ALLOCATED   (0x08072002)
#define DEFERRED_QUEUE_POOL_FREE        (0x08072003)
#define DEFERRED_QUEUE_FIXED_ALLOCATED  (0x08072004)
#define DEFERRED_QUEUE_FIXED_FREE       (0x08072005)


//
// The deferred queue is used to queue non-IO related events.
//

VOID
RaidCreateDeferredQueue(
    IN PRAID_DEFERRED_QUEUE Queue
    )
/*++

Routine Description:

    Create an empty deferred queue. After a deferred queue has been created
    it can be delete by calling RaidDeleteDeferedQueue.

Arguments:

    Queue - Deferred queue to initialize.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    RtlZeroMemory (Queue, sizeof (RAID_DEFERRED_QUEUE));
    InitializeSListHead (&Queue->FreeList);
    InitializeSListHead (&Queue->RunningList);
}


NTSTATUS
RaidInitializeDeferredQueue(
    IN OUT PRAID_DEFERRED_QUEUE Queue,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG Depth,
    IN ULONG ItemSize,
    IN PRAID_PROCESS_DEFERRED_ITEM_ROUTINE ProcessDeferredItem
    )

/*++

Routine Description:

    Initialize a deferred queue.

Arguments:

    Queue - Supplies the deferred queue to initialize.

    DeviceObject - Supplies the device object the deferred queue is
            created on. Since the deferred queue is created using a
            device queue, the supplied device object is also the
            device object we will create the DPC on.

    Depth - Supplies the depth of the deferred queue.

    ItemSize - Supplies the size of each element on the deferred queue.

    ProcessDeferredItem - Supplies the routine that will be called when
            a deferred item is ready to be handled.

Return Value:

    NTSTATUS code.

--*/

{
    ULONG i;
    PRAID_DEFERRED_HEADER Item;
    
    PAGED_CODE();

    ASSERT (Depth < MAXUSHORT);
    ASSERT (ItemSize < MAXUSHORT);

    if (ItemSize < sizeof (RAID_DEFERRED_HEADER)) {
        return STATUS_INVALID_PARAMETER_4;
    }
        
    //
    // Initialize the queue.
    //
    
    Queue->Depth = (USHORT)Depth;
    Queue->ProcessDeferredItem = ProcessDeferredItem;
    Queue->ItemSize = (USHORT)ItemSize;
    KeInitializeDpc (&Queue->Dpc, RaidDeferredQueueDpcRoutine, DeviceObject);

    //
    // And allocated entries.
    //
    
    for (i = 0; i < Depth; i++) {
        Item = RaidAllocatePool (NonPagedPool,
                                 Queue->ItemSize,
                                 DEFERRED_ITEM_TAG,
                                 DeviceObject);

        if (Item == NULL) {
            return STATUS_NO_MEMORY;
        }

        Item->Pool = DEFERRED_QUEUE_POOL_FREE;
        InterlockedPushEntrySList (&Queue->FreeList, &Item->Link);
    }

    return STATUS_SUCCESS;
}


VOID
RaidDeleteDeferredQueue(
    IN PRAID_DEFERRED_QUEUE Queue
    )
/*++

Routine Description:

    Delete the deferred queue.

Arguments:

    Queue - Deferred queue to delete.

Return Value:

    None.

--*/
{
    PSLIST_ENTRY Entry;
    PRAID_DEFERRED_HEADER Item;
    
    PAGED_CODE();

    #if DBG
        Entry = InterlockedPopEntrySList (&Queue->RunningList);
        ASSERT (Entry == NULL);
    #endif

    for (Entry = InterlockedPopEntrySList (&Queue->FreeList);
         Entry != NULL;
         Entry = InterlockedPopEntrySList (&Queue->FreeList)) {

        Item = CONTAINING_RECORD (Entry, RAID_DEFERRED_HEADER, Link);
        RaidFreePool (Item, DEFERRED_ITEM_TAG);
    }

    DbgFillMemory (Queue,
                   sizeof (RAID_DEFERRED_QUEUE),
                   DBG_DEALLOCATED_FILL);
}
    

NTSTATUS
RaidAdjustDeferredQueueDepth(
    IN PRAID_DEFERRED_QUEUE Queue,
    IN ULONG Depth
    )
/*++

Routine Description:

    Grow or shrink the depth of the deferred queue.

Arguments:

    Queue - Supplies the queue whose depth should be changed.

    Depth - Supplies the new depth.

Return Value:

    NTSTATUS code.

Bugs:

    We ignore shrink requests for now.

--*/
{
    ULONG i;
    PRAID_DEFERRED_HEADER Item;

    PAGED_CODE ();

    if (Depth > Queue->Depth) {

        for (i = 0; i < Depth - Queue->Depth; i++) {
            Item = RaidAllocatePool (NonPagedPool,
                                     Queue->ItemSize,
                                     DEFERRED_ITEM_TAG,
                                     (PDEVICE_OBJECT)Queue->Dpc.DeferredContext);

            if (Item == NULL) {
                return STATUS_NO_MEMORY;
            }

            Item->Pool = DEFERRED_QUEUE_POOL_FREE;
            
            InterlockedPushEntrySList (&Queue->FreeList, &Item->Link);

        }
        
    } else {
        //
        // Reduction of the Queue depth is NYI.
        //
    }

    return STATUS_SUCCESS;
}
        
    
PVOID
RaidAllocateDeferredItem(
    IN PRAID_DEFERRED_QUEUE Queue
    )
/*++

Routine Description:

    Allocate a deferred item.

Arguments:

    Queue - Supplies the deferred queue to allocate from.

Return Value:

    If the return value is non-NULL, it represents a pointer a deferred
    item buffer.

    If the return value is NULL, we couldn't allocate a deferred item.

--*/
{
    PSLIST_ENTRY Entry;
    PRAID_DEFERRED_HEADER Item;

    Entry = InterlockedPopEntrySList (&Queue->FreeList);
    Item = CONTAINING_RECORD (Entry, RAID_DEFERRED_HEADER, Link);

    if (Item != NULL) {
        ASSERT (Item->Pool == DEFERRED_QUEUE_POOL_FREE);
        Item->Pool = DEFERRED_QUEUE_POOL_ALLOCATED;
    }

    return Item;
}


VOID
RaidInitializeDeferredItem(
    IN PRAID_DEFERRED_HEADER Item
    )
/*++

Routine Description:

    Initialize a fixed deferred item.

Arguments:

    Item - Supplies the deferred item to initialize.

Return Value:

    None.

Notes:

    This routine should be inlined.

--*/
{
    Item->Pool = DEFERRED_QUEUE_FIXED_FREE;
}

PVOID
RaidAllocateDeferredItemFromFixed(
    IN PRAID_DEFERRED_HEADER Item
    )
/*++

Routine Description:

    Claim a fixed deferred item for use by the deferred queue.

Arguments:

    Item - Supplies a deferred item to claim. If the item has already been
        claimed, the routine will return NULL.

Return Value:

    Pointer the deferred item header, or NULL if the item has already
    been allocated.

--*/
{
    LONG Free;

    //
    // Allocate the deferred item if it has not already been allocated.
    //
    
    Free = InterlockedCompareExchange (&Item->Pool,
                                       DEFERRED_QUEUE_FIXED_ALLOCATED,
                                       DEFERRED_QUEUE_FIXED_FREE);
                    
    if (Free != DEFERRED_QUEUE_FIXED_FREE) {

        //
        // This means we were unable to allocate the deferred request;
        // just fail here.
        //
        
        ASSERT (Free == DEFERRED_QUEUE_FIXED_ALLOCATED);
        REVIEW();
        return NULL;
    }

    return Item;
}

VOID
RaidFreeDeferredItem(
    IN PRAID_DEFERRED_QUEUE Queue,
    IN PRAID_DEFERRED_HEADER Item
    )
/*++

Routine Description:

    Free a deferred queue item previously allocated by RaidAllocateDeferred-
    Item.

Arguments:

    Queue - Supplies the deferred queue to free to.

    Item - Supplies the item to free.

Return Value:

    None.

Note:

    An item that has been queued cannot be freed. Instead the caller must
    wait until it has completed.
    
--*/
{
    LONG Pool;

    Pool = InterlockedCompareExchange (&Item->Pool,
                                       DEFERRED_QUEUE_FIXED_FREE,
                                       DEFERRED_QUEUE_FIXED_ALLOCATED);


    if (Pool != DEFERRED_QUEUE_FIXED_ALLOCATED) {
        ASSERT (Pool == DEFERRED_QUEUE_POOL_ALLOCATED);
        Item->Pool = DEFERRED_QUEUE_POOL_FREE;
        InterlockedPushEntrySList (&Queue->FreeList, &Item->Link);
    }
}
    

VOID
RaidQueueDeferredItem(
    IN PRAID_DEFERRED_QUEUE Queue,
    IN PRAID_DEFERRED_HEADER Item
    )
/*++

Routine Description:

    Queue a deferred item to the deferred queue.

Arguments:

    Queue - Supplies the deferred queue to enqueue the item to.

    Item - Supplies the item to be enqueued.

Return Value:

    None.

--*/
{
    InterlockedPushEntrySList (&Queue->RunningList, &Item->Link);
    KeInsertQueueDpc (&Queue->Dpc, Queue, NULL);
}

VOID
RaidDeferredQueueDpcRoutine(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PRAID_DEFERRED_QUEUE Queue,
    IN PVOID Context2
    )
/*++

Routine Description:

    Deferred queue DPC routine.

Arguments:

    Dpc - Dpc that is executing.

    DeviceObject - DeviceObject that the DPC is for.

    Queue - Deferred queue this DPC is for.

    Context2 - Not used.

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER (Dpc);

    VERIFY_DISPATCH_LEVEL();
    ASSERT (Queue != NULL);
    ASSERT (Context2 == NULL);

    RaidProcessDeferredItemsForDpc (Queue, DeviceObject);
}


LOGICAL
RaidProcessDeferredItemsWorker(
    IN PRAID_DEFERRED_QUEUE Queue,
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Process any outstanding items on the deferred queue. The routine does
    not track recursion, but rather is the lower level private function
    used by RaidProcessDeferredItemsForDpc and RaidProcessDeferredItems.

Arguments:

    Queue - Deferred queue to process from.

    DeviceObject - Supplies the DeviceObject associated with this
        deferred queue.

Return Value:

    TRUE - If there was an item on the deferred queue that was processed.

    FALSE - Otherwise.

--*/
{
    PSLIST_ENTRY Entry;
    PRAID_DEFERRED_HEADER Item;
    LOGICAL Processed;

    Processed = FALSE;
    
    while (Entry = InterlockedPopEntrySList (&Queue->RunningList)) {
        Processed = TRUE;
        Item = CONTAINING_RECORD (Entry, RAID_DEFERRED_HEADER, Link);
        ASSERT (Item->Pool == DEFERRED_QUEUE_POOL_ALLOCATED ||
                Item->Pool == DEFERRED_QUEUE_FIXED_ALLOCATED);
        Queue->ProcessDeferredItem (DeviceObject, Item);

        RaidFreeDeferredItem (Queue, Item);
    }

    return Processed;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\dma.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	dma.h

Abstract:

	Declaration of raidport's notion of a DMA object.

Author:

	Matthew D Hendel (math) 01-May-2000

Revision History:

--*/

#pragma once

typedef struct _RAID_DMA_ADAPTER {
	PDMA_ADAPTER DmaAdapter;
	ULONG NumberOfMapRegisters;
	PVOID MapRegisterBase;
} RAID_DMA_ADAPTER, *PRAID_DMA_ADAPTER;


//
// Initialization and destruction.
//

VOID
RaidCreateDma(
	OUT PRAID_DMA_ADAPTER Dma
	);

NTSTATUS
RaidInitializeDma(
	IN PRAID_DMA_ADAPTER Dma,
	IN PDEVICE_OBJECT LowerDeviceObject,
	IN PPORT_CONFIGURATION_INFORMATION PortConfiguration
	);

VOID
RaidDeleteDma(
	IN PRAID_DMA_ADAPTER Dma
	);

//
// Operations on the DMA object.
//

BOOLEAN
RaidIsDmaInitialized(
	IN PRAID_DMA_ADAPTER Dma
	);

NTSTATUS
RaidDmaAllocateCommonBuffer(
	IN PRAID_DMA_ADAPTER Dma,
	IN ULONG NumberOfBytes,
	OUT PRAID_MEMORY_REGION Region
	);

VOID
RaidDmaFreeCommonBuffer(
	IN PRAID_DMA_ADAPTER Dma,
	IN PRAID_MEMORY_REGION Region
	);
	
NTSTATUS
RaidDmaAllocateUncachedExtension(
	IN PRAID_DMA_ADAPTER Dma,
	IN ULONG NumberOfBytes,
	IN ULONG64 MinimumPhysicalAddress,
	IN ULONG64 MaximumPhysicalAddress,
	IN ULONG64 BoundarAddressIn,
	OUT PRAID_MEMORY_REGION Region
	);

VOID
RaidDmaFreeUncachedExtension(
    IN PRAID_DMA_ADAPTER Dma,
    IN PRAID_MEMORY_REGION Region
    );

NTSTATUS
RaidDmaGetScatterGatherList(
	IN PRAID_DMA_ADAPTER Dma,
    IN PDEVICE_OBJECT DeviceObject,
	IN PMDL Mdl,
	IN PVOID CurrentVa,
	IN ULONG Length,
	IN PDRIVER_LIST_CONTROL ExecutionRoutine,
	IN PVOID Context,
	IN BOOLEAN WriteToDevice
	);
				  
NTSTATUS
RaidDmaBuildScatterGatherList(
	IN PRAID_DMA_ADAPTER Dma,
	IN PDEVICE_OBJECT DeviceObject,
	IN PMDL Mdl,
	IN PVOID CurrentVa,
	IN ULONG Length,
	IN PDRIVER_LIST_CONTROL ExecutionRoutine,
	IN PVOID Context,
	IN BOOLEAN WriteToDevice,
	IN PVOID ScatterGatherBuffer,
	IN ULONG ScatterGatherBufferLength
	);

VOID
RaidDmaPutScatterGatherList(
	IN PRAID_DMA_ADAPTER Dma,
	IN PSCATTER_GATHER_LIST ScatterGatherList,
	IN BOOLEAN WriteToDevice
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\dma.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dma.c

Abstract:

    Implementation of RAIDPORT's idea of a DMA object.

Author:

    Matthew D Hendel (math) 01-May-2000

Revision History:

--*/


#include "precomp.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RaidCreateDma)
#pragma alloc_text(PAGE, RaidInitializeDma)
#pragma alloc_text(PAGE, RaidIsDmaInitialized)
#pragma alloc_text(PAGE, RaidDeleteDma)
#endif // ALLOC_PRAGMA


VOID
RaidCreateDma(
    OUT PRAID_DMA_ADAPTER Dma
    )
/*++

Routine Description:

    Create an object representing a dma adapter and initialize it to a
    null state.

Arguments:

    Dma - Pointer to the dma object to initialize.

Return Value:

    None.

--*/
{
    PAGED_CODE ();
    RtlZeroMemory (Dma, sizeof (*Dma));
}


NTSTATUS
RaidInitializeDma(
    IN PRAID_DMA_ADAPTER Dma,
    IN PDEVICE_OBJECT LowerDeviceObject,
    IN PPORT_CONFIGURATION_INFORMATION PortConfiguration
    )
/*++

Routine Description:

    Initialize a dma object from information in the port configuration.x

Arguments:

    Dma - Pointer to the dma object to initialize.

    LowerDeviceObject - The lower device object in the stack.

    PortConfiguration - Pointer to a port configuration object that will
            be used to initialize the dma adapter.
    
Return Value:

    NTSTATUS code.

--*/
{
    DEVICE_DESCRIPTION DeviceDescription;

    PAGED_CODE ();
    ASSERT (LowerDeviceObject != NULL);
    ASSERT (PortConfiguration != NULL);
    
    ASSERT (Dma->DmaAdapter == NULL);
    
    RtlZeroMemory (&DeviceDescription, sizeof (DeviceDescription));
    DeviceDescription.Version = DEVICE_DESCRIPTION_VERSION;
    DeviceDescription.DmaChannel = PortConfiguration->DmaChannel;
    DeviceDescription.InterfaceType = PortConfiguration->AdapterInterfaceType;
    DeviceDescription.BusNumber = PortConfiguration->SystemIoBusNumber;
    DeviceDescription.DmaWidth = PortConfiguration->DmaWidth;
    DeviceDescription.DmaSpeed = PortConfiguration->DmaSpeed;
    DeviceDescription.ScatterGather = PortConfiguration->ScatterGather;
    DeviceDescription.Master = PortConfiguration->Master;
    DeviceDescription.DmaPort = PortConfiguration->DmaPort;
    DeviceDescription.Dma32BitAddresses = PortConfiguration->Dma32BitAddresses;
    DeviceDescription.AutoInitialize = FALSE;
    DeviceDescription.DemandMode = PortConfiguration->DemandMode;
    DeviceDescription.MaximumLength = PortConfiguration->MaximumTransferLength;
    DeviceDescription.Dma64BitAddresses = PortConfiguration->Dma64BitAddresses;

    Dma->DmaAdapter = IoGetDmaAdapter (LowerDeviceObject,
                                       &DeviceDescription,
                                       &Dma->NumberOfMapRegisters);

    if (Dma->DmaAdapter == NULL) {
        ASSERT (FALSE);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    return STATUS_SUCCESS;
}


BOOLEAN
RaidIsDmaInitialized(
    IN PRAID_DMA_ADAPTER Dma
    )
/*++

Routine Description:

    Test whether the dma adapter object has been initialized.

Arguments:

    Dma - Pointer to the dma object to test.

Return Value:

    TRUE - If the dma adapter has been initialized

    FALSE - If it has not.

--*/
{
    PAGED_CODE ();
    ASSERT (Dma != NULL);

    return (Dma->DmaAdapter != NULL);
}



VOID
RaidDeleteDma(
    IN PRAID_DMA_ADAPTER Dma
    )
/*++

Routine Description:

    Delete a dma adapter object and deallocate any resources associated
    with it.

Arguments:

    Dma - Pointer to the dma adapter to delete.

Return Value:

    None.

--*/
{
    PAGED_CODE ();
    
    if (Dma->DmaAdapter) {
        Dma->DmaAdapter->DmaOperations->PutDmaAdapter (Dma->DmaAdapter);
        RtlZeroMemory (Dma, sizeof (*Dma));
    }
}

NTSTATUS
RaidDmaAllocateCommonBuffer(
    IN PRAID_DMA_ADAPTER Dma,
    IN ULONG NumberOfBytes,
    OUT PRAID_MEMORY_REGION Region
    )
/*++

Routine Description:

    Allocate common buffer that is shared between the processor and the device.

    Note, that unlike uncached extension, which we guarantee to be below
    the 4GB boundary, general purpose uncached extension may lie anywhere
    in physical memory so long as it does not cross the 4GB boundary.
    
Arguments:

    Dma - Dma adapter that will share the allocated common memory.

    NumberOfBytes - Number of bytes to allocate.

    Region - Pointer to an initialized RAID_REGION object where the
            memory region will be stored.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PVOID Buffer;
    PHYSICAL_ADDRESS PhysicalAddress;
    
    PAGED_CODE();

    ASSERT (Dma != NULL);
    ASSERT (Dma->DmaAdapter->DmaOperations->AllocateCommonBuffer != NULL);

    //
    // Call into the DMA operations to allocate common buffer.
    //
    
    Buffer = Dma->DmaAdapter->DmaOperations->AllocateCommonBuffer(
                    Dma->DmaAdapter,
                    NumberOfBytes,
                    &PhysicalAddress,
                    TRUE);

    if (Buffer == NULL) {
        Status = STATUS_NO_MEMORY;
    } else {

        //
        // Verify that the the returned memory must not cross the 4GB boundary.
        //
        
        ASSERT (((PhysicalAddress.QuadPart ^
                 (PhysicalAddress.QuadPart + NumberOfBytes - 1)) & 0xFFFFFFFF00000000) == 0);
                     
        //
        // Initialize the region with the proper information.
        //

        RaidInitializeRegion (Region,
                              Buffer,
                              PhysicalAddress,
                              NumberOfBytes);
        Status = STATUS_SUCCESS;
    }

    return Status;
}
    
VOID
RaidDmaFreeCommonBuffer(
    IN PRAID_DMA_ADAPTER Dma,
    IN PRAID_MEMORY_REGION Region
    )
/*++

Routine Description:

    Free common buffer previously allocated by RaidDmaAllocateCommonBuffer.

Arguments:

    Dma - Pointer to the DMA adapter to free memory for.

    Region - Pointer to the region of memory to free.

Return Value:

    None.

--*/
{
    ASSERT (Dma != NULL);
    ASSERT (Dma->DmaAdapter->DmaOperations->FreeCommonBuffer != NULL);

    PAGED_CODE();

    Dma->DmaAdapter->DmaOperations->FreeCommonBuffer (
            Dma->DmaAdapter,
            RaidRegionGetSize (Region),
            RaidRegionGetPhysicalBase (Region),
            RaidRegionGetVirtualBase (Region),
            TRUE);

    //
    // Tell the region that we are no longer using the memory.
    //
    
    RaidDereferenceRegion (Region);
}
    
NTSTATUS
RaidDmaAllocateUncachedExtension(
    IN PRAID_DMA_ADAPTER Dma,
    IN ULONG NumberOfBytes,
    IN ULONG64 MinimumPhysicalAddress,
    IN ULONG64 MaximumPhysicalAddress,
    IN ULONG64 BoundaryAddressParam,
    OUT PRAID_MEMORY_REGION Region
    )
/*++

Routine Description:

    Allocate uncached extension to be shared between the processor and
    the device.

Arguments:

    Dma - Dma adapter that will share the allocated common memory.

    NumberOfBytes - Number of bytes to allocate.

    Region - Pointer to an initialized RAID_REGION object where the
            memory region will be stored.
    
Return Value:

    NTSTATUS code.

Notes:

    Miniports need uncached extension to live below 4GB, even if they
    support 64-bit addressing. Therefore, we do not use the
    AllocateCommonBuffer DMA routines (which don't understand this), but
    roll our own routine using MmAllocateContiguousMemorySpecifyCache.

--*/
{
    NTSTATUS Status;
    PVOID Buffer;
    PHYSICAL_ADDRESS PhysicalAddress;
    PHYSICAL_ADDRESS LowerPhysicalAddress;
    PHYSICAL_ADDRESS UpperPhysicalAddress;
    PHYSICAL_ADDRESS BoundaryAddress;
    
    PAGED_CODE();

    ASSERT (Dma != NULL);
    ASSERT (MinimumPhysicalAddress < MaximumPhysicalAddress);

    //
    // At some point in the past, we told vendors that uncached extension
    // would never be above 4GB. Therefore, we need to explicitly allocate
    // this ourselves instead of having the HAL do it for us.
    //
    
    LowerPhysicalAddress.QuadPart = MinimumPhysicalAddress;
    UpperPhysicalAddress.QuadPart = MaximumPhysicalAddress;
    BoundaryAddress.QuadPart      = BoundaryAddressParam;
    

    //
    // We always use MmCached since all of our current architectures have
    // coherent caches.
    //
    
    Buffer = MmAllocateContiguousMemorySpecifyCache (
                        NumberOfBytes,
                        LowerPhysicalAddress,
                        UpperPhysicalAddress,
                        BoundaryAddress,
                        MmCached);

    PhysicalAddress = MmGetPhysicalAddress (Buffer);

    if (Buffer == NULL) {
        Status = STATUS_NO_MEMORY;
    } else {
        RaidInitializeRegion (Region,
                              Buffer,
                              PhysicalAddress,
                              NumberOfBytes);
        Status = STATUS_SUCCESS;
    }

    return Status;
}

VOID
RaidDmaFreeUncachedExtension(
    IN PRAID_DMA_ADAPTER Dma,
    IN PRAID_MEMORY_REGION Region
    )
/*++

Routine Description:

    Free common buffer allocated by RaidDmaAllocateCommonBuffer.

Arguments:

    Dma - Pointer to the DMA adapter to free memory for.

    Region - Pointer to the region of memory to free.

Return Value:

    None.

--*/
{
    ASSERT (Dma != NULL);

    PAGED_CODE();


    MmFreeContiguousMemory (RaidRegionGetVirtualBase (Region));

    //
    // Tell the region that we are no longer using the memory.
    //
    
    RaidDereferenceRegion (Region);
}


NTSTATUS
RaidDmaBuildScatterGatherList(
    IN PRAID_DMA_ADAPTER Dma,
    IN PDEVICE_OBJECT DeviceObject,
    IN PMDL Mdl,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN PDRIVER_LIST_CONTROL ExecutionRoutine,
    IN PVOID Context,
    IN BOOLEAN WriteToDevice,
    IN PVOID ScatterGatherBuffer,
    IN ULONG ScatterGatherBufferLength
    )
/*++

Routine Description:

    This routine should be used instead of GetScatterGatherList.
    GetScatterGatherList does a pool allocation to allocate the SG list.
    This routine, in contrast, takes a buffer parameter which is to be used
    for the SG list.

Arguments:

    See BuildScatterGatherList in the DDK (when available) or
    HalBuildScatterGatherList.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;

    VERIFY_DISPATCH_LEVEL();
    
    ASSERT (Dma != NULL);
    ASSERT (Dma->DmaAdapter->DmaOperations->BuildScatterGatherList != NULL);

    Status = Dma->DmaAdapter->DmaOperations->BuildScatterGatherList(
                    Dma->DmaAdapter,
                    DeviceObject,
                    Mdl,
                    CurrentVa,
                    Length,
                    ExecutionRoutine,
                    Context,
                    WriteToDevice,
                    ScatterGatherBuffer,
                    ScatterGatherBufferLength);

    return Status;
}


NTSTATUS
RaidDmaGetScatterGatherList(
    IN PRAID_DMA_ADAPTER Dma,
    IN PDEVICE_OBJECT DeviceObject,
    IN PMDL Mdl,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN PDRIVER_LIST_CONTROL ExecutionRoutine,
    IN PVOID Context,
    IN BOOLEAN WriteToDevice
    )
{
    NTSTATUS Status;

    VERIFY_DISPATCH_LEVEL();

    ASSERT (Dma != NULL);
    ASSERT (Dma->DmaAdapter->DmaOperations->GetScatterGatherList != NULL);

    Status = Dma->DmaAdapter->DmaOperations->GetScatterGatherList(
                    Dma->DmaAdapter,
                    DeviceObject,
                    Mdl,
                    CurrentVa,
                    Length,
                    ExecutionRoutine,
                    Context,
                    WriteToDevice);

    return Status;
}


VOID
RaidDmaPutScatterGatherList(
    IN PRAID_DMA_ADAPTER Dma,
    IN PSCATTER_GATHER_LIST ScatterGatherList,
    IN BOOLEAN WriteToDevice
    )
{
    ASSERT (Dma != NULL);
    ASSERT (Dma->DmaAdapter->DmaOperations->PutScatterGatherList != NULL);

    VERIFY_DISPATCH_LEVEL();

    Dma->DmaAdapter->DmaOperations->PutScatterGatherList(
            Dma->DmaAdapter,
            ScatterGatherList,
            WriteToDevice);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\debug.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	debug.c

Abstract:

	Debugging routines for RAIDPORT driver.

Author:

	Matthew D Hendel (math) 29-Apr-2000

Revision History:

--*/

#include "precomp.h"

#if DBG

VOID
DebugPrintInquiry(
	IN PINQUIRYDATA InquiryData,
	IN SIZE_T InquiryDataSize
	)
{

	PCHAR DeviceType;
	PCHAR Qualifier;

	switch (InquiryData->DeviceType) {
		case DIRECT_ACCESS_DEVICE: DeviceType = "disk"; break;
		case SEQUENTIAL_ACCESS_DEVICE: DeviceType = "tape"; break;
		case PRINTER_DEVICE: DeviceType = "printer"; break;
		case PROCESSOR_DEVICE: DeviceType = "processor"; break;
		case WRITE_ONCE_READ_MULTIPLE_DEVICE: DeviceType = "worm"; break;
		case READ_ONLY_DIRECT_ACCESS_DEVICE: DeviceType = "cdrom"; break;
		case SCANNER_DEVICE: DeviceType = "scanner"; break;
		case OPTICAL_DEVICE: DeviceType = "optical disk"; break;
		case MEDIUM_CHANGER: DeviceType = "jukebox"; break;
		case COMMUNICATION_DEVICE: DeviceType = "network"; break;
		case LOGICAL_UNIT_NOT_PRESENT_DEVICE: DeviceType = "lux"; break;
		default: DeviceType = "unknown";
	}

	switch (InquiryData->DeviceTypeQualifier) {
		case DEVICE_QUALIFIER_ACTIVE: Qualifier = "active"; break;
		case DEVICE_QUALIFIER_NOT_ACTIVE: Qualifier = "not active"; break;
		case DEVICE_QUALIFIER_NOT_SUPPORTED: Qualifier = "not supported"; break;
		default: Qualifier = "unknown";
	}

	DebugTrace (("%8.8s %16.16s %4.4s; %s %s\n",
				  InquiryData->VendorId,
				  InquiryData->ProductId,
				  InquiryData->ProductRevisionLevel,
				  DeviceType,
				  Qualifier));
}


PCSTR SrbFunctionName [] = {
	"EXECUTE_SCSI",
	"CLAIM_DEVICE",
	"IO_CONTROL",
	"RECEIVE_EVENT",
	"RELEASE_QUEUE",
	"ATTACH_DEVICE",
	"RELEASE_DEVICE",
	"SHUTDOWN",
	"FLUSH",
	"ABORT_COMMAND",
	"RELEASE_RECOVER",
	"RESET_BUS",
	"RESET_DEVICE",
	"TERMINATE_IO",
	"FLUSH_QUEUE",
	"REMOVE_DEVICE",
	"WMI",
	"LOCK_QUEUE",
	"UNLOCK_QUEUE"
};

PCSTR
DebugSrbFunction(
	IN UCHAR Function
	)
{
	if (Function < ARRAY_COUNT (SrbFunctionName)) {
		return SrbFunctionName [Function];
	} else {
		return "Unknown Srb Function";
	}
}


VOID
DebugPrintSrb(
	IN PSCSI_REQUEST_BLOCK Srb
	)
{
	DebugTrace (("SRB %p %s\n",
					Srb,
					DebugSrbFunction (Srb->Function)));
	DebugTrace (("SRB: Target %2.2x %2.2x %2.2x, Q %2.2x\n",
					(LONG)Srb->PathId,
				    (LONG)Srb->TargetId,
					(LONG)Srb->Lun,
					(LONG)Srb->QueueTag));
	DebugTrace (("SRB: Data %p Len %d\n",
					Srb->DataBuffer,
					Srb->DataTransferLength));
	DebugTrace (("SRB: Sense %p Len %d\n",
					Srb->SenseInfoBuffer,
					Srb->SenseInfoBufferLength));
	DebugTrace (("SRB: Ext %p\n",Srb->SrbExtension));

	if (Srb->Function == SRB_FUNCTION_EXECUTE_SCSI &&
		Srb->CdbLength >= 1) {
		DebugTrace (("SRB: ScsiOp %2.2x\n", (LONG)Srb->Cdb[0]));
	}
}


VOID
StorDebugPower(
    IN PCSTR Format,
    ...
    )
{
    va_list ap;

    va_start (ap, Format);
    vStorDebugPrintEx (STOR_DEBUG_POWER_MASK,
                       Format,
                       ap);
    va_end (ap);
}

VOID
StorDebugPnp(
    IN PCSTR Format,
    ...
    )
{
    va_list ap;

    va_start (ap, Format);
    vStorDebugPrintEx (STOR_DEBUG_PNP_MASK,
                       Format,
                       ap);
    va_end (ap);
}

VOID
StorDebugScsi(
    IN PCSTR Format,
    ...
    )
{
    va_list ap;

    va_start (ap, Format);
    vStorDebugPrintEx (STOR_DEBUG_SCSI_MASK,
                       Format,
                       ap);
    va_end (ap);
}


#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\driver.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    driver.c

Abstract:

    Implements the driver object for the raid port driver.

Author:

    Matthew D Hendel (math) 04-Apr-2000

Environment:

    Kernel mode only.

--*/


#include "precomp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RaCreateDriver)
#pragma alloc_text(PAGE, RaDeleteDriver)
#pragma alloc_text(PAGE, RaInitializeDriver)
#pragma alloc_text(PAGE, RaDriverCreateIrp)
#pragma alloc_text(PAGE, RaDriverCloseIrp)
#pragma alloc_text(PAGE, RaDriverDeviceControlIrp)
#pragma alloc_text(PAGE, RaDriverPnpIrp)
#pragma alloc_text(PAGE, RaDriverSystemControlIrp)
#pragma alloc_text(PAGE, RaSaveDriverInitData)
#pragma alloc_text(PAGE, RaFindDriverInitData)
#endif // ALLOC_PRAGMA


VOID
RaCreateDriver(
    OUT PRAID_DRIVER_EXTENSION Driver
    )
/*++

Routine Description:

    Create a driver extension object and initialize to a null state.

Arguments:

    Driver - The driver extension obejct to create.

Return Value:

    None.

--*/
{
    PAGED_CODE ();

    RtlZeroMemory (Driver, sizeof (*Driver));
    Driver->ObjectType = RaidDriverObject;
    InitializeListHead (&Driver->HwInitList);
    InitializeListHead (&Driver->AdapterList.List);
    KeInitializeSpinLock (&Driver->AdapterList.Lock);
}

NTSTATUS
RaInitializeDriver(
    IN PRAID_DRIVER_EXTENSION Driver,
    IN PDRIVER_OBJECT DriverObject,
    IN PRAID_PORT_DATA PortData,
    IN PUNICODE_STRING RegistryPath
    )
{
    NTSTATUS Status;
    NTSTATUS Status2;
    UNICODE_STRING mpioRegPath;
    
    PAGED_CODE ();

    //
    // Initialize the Driver object.
    //
    
    DriverObject->MajorFunction[ IRP_MJ_CREATE ] = RaDriverCreateIrp;
    DriverObject->MajorFunction[ IRP_MJ_CLOSE ]  = RaDriverCloseIrp;
    DriverObject->MajorFunction[ IRP_MJ_DEVICE_CONTROL ] = RaDriverDeviceControlIrp;
    DriverObject->MajorFunction[ IRP_MJ_SCSI ] = RaDriverScsiIrp;
    DriverObject->MajorFunction[ IRP_MJ_PNP ] = RaDriverPnpIrp;
    DriverObject->MajorFunction[ IRP_MJ_POWER ] = RaDriverPowerIrp;
    DriverObject->MajorFunction[ IRP_MJ_SYSTEM_CONTROL ] = RaDriverSystemControlIrp;

    DriverObject->DriverExtension->AddDevice = RaDriverAddDevice;

    DriverObject->DriverStartIo = NULL;
    DriverObject->DriverUnload = RaDriverUnload;

    //
    // Initialize our extension and port data.
    //
    
    Driver->DriverObject = DriverObject;
    Driver->PortData = PortData;

    Status = RaDuplicateUnicodeString (&Driver->RegistryPath,
                                       RegistryPath,
                                       NonPagedPool,
                                       DriverObject);
    if (NT_SUCCESS(Status)) {
    
        //
        // Build the registry path to where the multipath supported device
        // list lives.
        //

        RtlInitUnicodeString(&mpioRegPath, MPIO_DEVICE_LIST_PATH);

        //
        // Call into the port-library to acquire the list. Failure to do so
        // shouldn't be considered fatal as either MPIO is not supported (hence no list)
        // and the system should still boot, albeit in a somewhat crippled fashion.
        //
        
        Status2 = PortGetMPIODeviceList(&mpioRegPath,
                                        &Driver->MPIOSupportedDeviceList);
       
        if (!NT_SUCCESS(Status2)) {

            //
            // Do something?  
            //
        }
    }        

    //
    // Attach this driver to the port's driver list.
    //
    
    RaidAddPortDriver (PortData, Driver);

    return STATUS_SUCCESS;
}

VOID
RaDeleteDriver(
    IN PRAID_DRIVER_EXTENSION Driver
    )
/*++

Routine Description:

    Delete a driver extension object and deallocate any resources
    associated with it.

Arguments:

    Driver - The driver extension object to delete.

Return Value:

    None.

--*/
{
    PAGED_CODE ();

    ASSERT (Driver->AdapterCount == 0);
    ASSERT (Driver->ObjectType == RaidDriverObject);

    Driver->ObjectType = -1;
    RtlFreeUnicodeString (&Driver->RegistryPath);

    //
    // Remove the driver from the port's list.
    //
    
    if (Driver->DriverLink.Flink) {
        ASSERT (Driver->PortData);
        RaidRemovePortDriver (Driver->PortData, Driver);
    }

    //
    // Release the reference to the port data object.
    //

    if (Driver->PortData) {
        RaidReleasePortData (Driver->PortData);
    }
}



NTSTATUS
RaDriverUnload(
    IN PDRIVER_OBJECT DriverObject
    )
{
    NTSTATUS Status;
    PRAID_DRIVER_EXTENSION Driver;
    
    //
    // Deallocate driver extension.
    //
    
    Driver = IoGetDriverObjectExtension (DriverObject, DriverEntry);
    ASSERT (Driver != NULL);
    RaDeleteDriver (Driver);
    
    return STATUS_SUCCESS;
}


NTSTATUS
RaDriverAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++

Routine Description:

    Add a new adapter.

Arguments:

    DriverObject - Driver object that owns the adapter.

    PhysicalDeviceObject - PDO associated with the adapter.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_DRIVER_EXTENSION Driver;
    PDEVICE_OBJECT DeviceObject;
    PDEVICE_OBJECT LowerDeviceObject;
    KLOCK_QUEUE_HANDLE LockHandle;
    UNICODE_STRING DeviceName;
    ULONG AdapterNumber;

    ASSERT (DriverObject != NULL);
    ASSERT (PhysicalDeviceObject != NULL);


    DebugTrace (("AddDevice: DriverObject %p, PhysicalDeviceObject %p\n",
                 DriverObject,
                 PhysicalDeviceObject));


    Adapter = NULL;
    DeviceObject = NULL;
    LowerDeviceObject = NULL;
    RtlInitEmptyUnicodeString (&DeviceName, NULL, 0);

    AdapterNumber = RaidCreateDeviceName (PhysicalDeviceObject, &DeviceName);
    
    //
    // Create the FDO for this PDO.
    //

    Status = IoCreateDevice (DriverObject,
                             sizeof (RAID_ADAPTER_EXTENSION),
                             &DeviceName,
                             FILE_DEVICE_CONTROLLER,
                             FILE_DEVICE_SECURE_OPEN,
                             FALSE,
                             &DeviceObject);

    if (!NT_SUCCESS (Status)) {
        goto done;
    }


    //
    // Create the adapter.
    //
    
    Adapter = DeviceObject->DeviceExtension;
    RaidCreateAdapter (Adapter);

    //
    // Get the driver object's extension.
    //
    
    Driver = IoGetDriverObjectExtension (DriverObject, DriverEntry);

    //
    // Attach ourselves to the device stack.
    //
    
    LowerDeviceObject = IoAttachDeviceToDeviceStack (DeviceObject,
                                                     PhysicalDeviceObject);
                                
    if (LowerDeviceObject == NULL) {
        Status = STATUS_UNSUCCESSFUL;
        goto done;
    }

    //
    // Initialize the Adapter's extension.
    // 

    Status = RaidInitializeAdapter (Adapter,
                                    DeviceObject,
                                    Driver,
                                    LowerDeviceObject,
                                    PhysicalDeviceObject,
                                    &DeviceName,
                                    AdapterNumber);

    if (!NT_SUCCESS (Status)) {
        goto done;
    }

    //
    // Add the adapter to the driver's adapter list.
    //

    KeAcquireInStackQueuedSpinLock (&Driver->AdapterList.Lock, &LockHandle);
    InsertHeadList (&Driver->AdapterList.List, &Adapter->NextAdapter);
    Driver->AdapterList.Count++;
    KeReleaseInStackQueuedSpinLock (&LockHandle);

    //
    // Start the driver.
    //

    SET_FLAG (DeviceObject->Flags, DO_DIRECT_IO);
    CLEAR_FLAG (DeviceObject->Flags, DO_DEVICE_INITIALIZING);

done:

    if (!NT_SUCCESS (Status) && Adapter != NULL) {
        RaidDeleteAdapter (Adapter);
        IoDeleteDevice (DeviceObject);
    }

    return Status;
}

//
// First level dispatch routines.
//

NTSTATUS
RaDriverCreateIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This is the top level dispatch handler for the create irp.

Arguments:

    DeviceObject - The device object that is receiving the irp.

    Irp - The irp to process.

Return Value:

    NTSTATUS code

--*/
{
    NTSTATUS Status;
    ULONG Type;

    PAGED_CODE ();
    ASSERT (DeviceObject != NULL);
    ASSERT (Irp != NULL);

    DebugTrace (("DeviceObject %p, Irp %p Create\n",
                 DeviceObject,
                 Irp));

    RaidSetIrpState (Irp, RaidPortProcessingIrp);
    Type = RaGetObjectType (DeviceObject);

    switch (Type) {
    
        case RaidAdapterObject:
            Status = RaidAdapterCreateIrp (DeviceObject->DeviceExtension, Irp);
            break;

        case RaidUnitObject:
            Status = RaUnitCreateIrp (DeviceObject->DeviceExtension, Irp);
            break;

        default:
            ASSERT (FALSE);
            Status = STATUS_UNSUCCESSFUL;
    }

    DebugTrace (("DeviceObject %p, Irp %p, Create, ret = %08x\n",
                 DeviceObject,
                 Irp,
                 Status));

    return Status;
}


NTSTATUS
RaDriverCloseIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Top level handler function for the close irp. Forward the irp to the
    adapter or unit specific handler.
    
Arguments:

    DeviceObject - The device object the irp is for.

    Irp - The close irp to handle.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG Type;

    PAGED_CODE ();
    ASSERT (DeviceObject != NULL);
    ASSERT (Irp != NULL);

    DebugTrace (("DeviceObject %p, Irp %p, Close\n",
                 DeviceObject,
                 Irp));

    RaidSetIrpState (Irp, RaidPortProcessingIrp);
    Type = RaGetObjectType (DeviceObject);

    switch (Type) {
    
        case RaidAdapterObject:
            Status = RaidAdapterCloseIrp (DeviceObject->DeviceExtension, Irp);
            break;

        case RaidUnitObject:
            Status = RaUnitCloseIrp (DeviceObject->DeviceExtension, Irp);
            break;

        default:
            ASSERT (FALSE);
            Status = STATUS_UNSUCCESSFUL;
    }

    DebugTrace (("DeviceObject %p, Irp %p, Close, ret = %08x\n",
                 DeviceObject,
                 Irp,
                 Status));

    return Status;
}


NTSTATUS
RaDriverDeviceControlIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Dispatch function for the device control irp. Dispatch the irp to an
    adapter or unit specific handler function.

Arguments:

    DeviceObject - DeviceObject this irp is for.

    Irp - Irp to handle.

Return Value:

    NTSTATUS code.

--*/
{    
    NTSTATUS Status;
    ULONG Type;

    PAGED_CODE ();
    ASSERT (DeviceObject != NULL);
    ASSERT (Irp != NULL);

    DebugTrace (("DeviceObject %p, Irp %p, DeviceControl\n",
                 DeviceObject,
                 Irp));

    RaidSetIrpState (Irp, RaidPortProcessingIrp);
    Type = RaGetObjectType (DeviceObject);

    switch (Type) {
    
        case RaidAdapterObject:
            Status = RaidAdapterDeviceControlIrp (DeviceObject->DeviceExtension, Irp);
            break;

        case RaidUnitObject:
            Status = RaUnitDeviceControlIrp (DeviceObject->DeviceExtension, Irp);
            break;

        default:
            ASSERT (FALSE);
            Status = STATUS_UNSUCCESSFUL;
    }

    DebugTrace (("DeviceObject %p, Irp %p, DeviceControl, ret = %08x\n",
                 DeviceObject,
                 Irp,
                 Status));

    return Status;
}

NTSTATUS
RaDriverScsiIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler routine for scsi irps.

Arguments:

    DeviceObject - DeviceObject the irp is for.

    Irp - The irp to handle.

Return Value:

    NTSTATUS code.

Environment:

    DISPATCH_LEVEL or below.

--*/
{
    ULONG Type;
    NTSTATUS Status;

    ASSERT (DeviceObject != NULL);
    ASSERT (Irp != NULL);


    DebugScsi (("DeviceObject %p, Irp %p, Scsi\n",
                 DeviceObject,
                 Irp));

    //
    // Forward the IRP to the adapter or Unit handler
    // function.
    //
    
    RaidSetIrpState (Irp, RaidPortProcessingIrp);
    Type = RaGetObjectType (DeviceObject);

    switch (Type) {

        case RaidAdapterObject:
            Status = RaidAdapterScsiIrp (DeviceObject->DeviceExtension, Irp);
            break;

        case RaidUnitObject:
            Status = RaUnitScsiIrp (DeviceObject->DeviceExtension, Irp);
            break;

        default:
            ASSERT (FALSE);
            Status = STATUS_UNSUCCESSFUL;
    }

    DebugScsi (("DeviceObject %p, Irp %p, Scsi, ret = %08x\n",
                 DeviceObject,
                 Irp,
                 Status));

    return Status;
}


NTSTATUS
RaDriverPnpIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This function dispatches IRP_MJ_PNP IRPs to the Adapter Object or
    Logical Unit Object handlers.

Arguments:

    DeviceObject - DeviceObject to handle this irp.

    Irp - Irp to handle.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG Type;

    PAGED_CODE ();
    ASSERT (DeviceObject != NULL);
    ASSERT (Irp != NULL);
    
    DebugTrace (("DeviceObject %p, Irp %p PnP, Minor %x\n",
                 DeviceObject,
                 Irp,
                 RaidMinorFunctionFromIrp (Irp)));

    RaidSetIrpState (Irp, RaidPortProcessingIrp);
    Type = RaGetObjectType (DeviceObject);

    switch (Type) {
    
        case RaidAdapterObject:
            Status = RaidAdapterPnpIrp (DeviceObject->DeviceExtension, Irp);
            break;

        case RaidUnitObject:
            Status = RaUnitPnpIrp (DeviceObject->DeviceExtension, Irp);
            break;

        default:
            ASSERT (FALSE);
            Status = STATUS_UNSUCCESSFUL;

    }

    DebugTrace (("DeviceObject %p, Irp %p PnP, ret = %08x\n",
                 DeviceObject,
                 Irp,
                 Status));

    return Status;
}


NTSTATUS
RaDriverPowerIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Dispatch routine for power irps. The irps are dispatched to adapter
    or unit specific handler functions.

Arguments:

    DeviceObject - DeviceObject this irp is for.

    Irp - Irp to handle.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG Type;

    ASSERT (DeviceObject != NULL);
    ASSERT (Irp != NULL);
    
    DebugTrace (("DeviceObject %p, Irp %p, Power\n",
                 DeviceObject,
                 Irp));

    RaidSetIrpState (Irp, RaidPortProcessingIrp);
    Type = RaGetObjectType (DeviceObject);
    
    switch (Type) {
    
        case RaidAdapterObject:
            Status = RaidAdapterPowerIrp (DeviceObject->DeviceExtension, Irp);
            break;

        case RaidUnitObject:
            Status = RaUnitPowerIrp (DeviceObject->DeviceExtension, Irp);
            break;

        default:
            ASSERT (FALSE);
            Status = STATUS_UNSUCCESSFUL;
    }

    DebugTrace (("DeviceObject %p, Irp %p, Power, ret = %08x\n",
                 DeviceObject,
                 Irp,
                 Status));

    return Status;
}


NTSTATUS
RaDriverSystemControlIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Dispatch routine for WMI irps.

Arguments:

    DeviceObject - DeviceObject the irp is for.

    Irp - WMI irp to handle.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG Type;

    PAGED_CODE ();
    ASSERT (DeviceObject != NULL);
    ASSERT (Irp != NULL);
    
    DebugTrace (("DeviceObject %p, Irp %p, WMI\n",
                 DeviceObject,
                 Irp));

    RaidSetIrpState (Irp, RaidPortProcessingIrp);
    
    Status = RaWmiDispatchIrp(DeviceObject, Irp);

    DebugTrace (("DeviceObject %p, Irp %p, WMI, ret = %08x\n",
                 DeviceObject,
                 Irp,
                 Status));

    return Status;
}

NTSTATUS
RaSaveDriverInitData(
    IN PRAID_DRIVER_EXTENSION Driver,
    PHW_INITIALIZATION_DATA HwInitializationData
    )
{
    NTSTATUS Status;
    PRAID_HW_INIT_DATA HwInitData;
    
    PAGED_CODE ();
    ASSERT (HwInitializationData != NULL);


    HwInitData = ExAllocatePoolWithTag (NonPagedPool,
                                        sizeof (*HwInitData),
                                        HWINIT_TAG);

    if (HwInitData == NULL) {
        return STATUS_NO_MEMORY;
    }
    
    RtlCopyMemory (&HwInitData->Data,
                   HwInitializationData,
                   sizeof (*HwInitializationData));

    //
    // NB: In a checked build we should check that an entry with this
    // BusInterface is not already on the list.
    //
    
    InsertHeadList (&Driver->HwInitList, &HwInitData->ListEntry);

    return STATUS_SUCCESS;
}
    

VOID
RaFreeDriverInitData(
    IN PRAID_DRIVER_EXTENSION Driver,
    IN PHW_INITIALIZATION_DATA HwInitializationData
    )
{
    PRAID_HW_INIT_DATA HwInitData;

    PAGED_CODE();

    HwInitData = CONTAINING_RECORD (HwInitializationData,
                                    RAID_HW_INIT_DATA,
                                    Data);

    DbgFillMemory (HwInitData,
                   sizeof (RAID_HW_INIT_DATA),
                   DBG_DEALLOCATED_FILL);

    ExFreePoolWithTag (HwInitData, HWINIT_TAG);
}


PHW_INITIALIZATION_DATA
RaFindDriverInitData(
    IN PRAID_DRIVER_EXTENSION Driver,
    IN INTERFACE_TYPE InterfaceType
    )
{
    PLIST_ENTRY NextEntry;
    PRAID_HW_INIT_DATA HwInitData;

    PAGED_CODE ();

    //
    // Search the driver's HwInitList for this.
    //

    for ( NextEntry = Driver->HwInitList.Flink;
          NextEntry != &Driver->HwInitList;
          NextEntry = NextEntry->Flink ) {
         
        HwInitData = CONTAINING_RECORD (NextEntry,
                                        RAID_HW_INIT_DATA,
                                        ListEntry);

        if (HwInitData->Data.AdapterInterfaceType == InterfaceType) {

            //
            // NB: Should this be removed??
            //
            
//            RemoveEntryList (&HwInit->ListEntry);
            return &HwInitData->Data;
        }
    }

    return NULL;
}


PWCHAR
StorSearchUnicodeStringReverse(
    IN PUNICODE_STRING String,
    IN WCHAR Char
    )
{
    PWCHAR Ptr;
    ULONG i;

    //
    // Empty string: return NULL.
    //
    
    if (String->Buffer == NULL || String->Length == 0) {
        return NULL;
    }

    //
    // NB: Length and MaximumLength is in bytes, not wchars.
    //
    
    for (i = String->Length / sizeof (WCHAR); i; i--) {
        if (String->Buffer [i - 1] == Char) {
            return &String->Buffer [i - 1];
        }
    }

    //
    // Didn't find the character, return NULL.
    //

    return NULL;
}
    
        
    
VOID
RaidDriverGetName(
    IN PRAID_DRIVER_EXTENSION Driver,
    OUT PUNICODE_STRING DriverName
    )
/*++

Routine Description:

    Get the driver name from the RAID driver extension.

Arguments:

    Driver - Driver extension to get the driver name from.

    DriverName - Supplies driver buffer where the name should be
        stored. The name MUST NOT BE MODIFIED, and MUST NOT BE FREED.

Return Value:

    None.

--*/
{
    PWSTR BaseName;
    PUNICODE_STRING FullName;

    ASSERT (Driver != NULL);
    
    PAGED_CODE();

    FullName = &Driver->RegistryPath;

    //
    // Verify that the UNICODE_STRING is also NULL terminated.
    //
    
    ASSERT_UNC_STRING_IS_SZ (FullName);

    //
    // Get the name of the driver from the service key name.
    //

    BaseName = StorSearchUnicodeStringReverse (FullName, L'\\');
    if (BaseName == NULL) {
        BaseName = FullName->Buffer;
    } else {
        ASSERT (*BaseName == L'\\');
        BaseName++;
    }

    //
    // Initialize a new Unicode string using the same (partial) buffer.
    //
    
    DriverName->Length = (USHORT)((((PCHAR)FullName->Buffer + FullName->Length) -
                           (PCHAR)BaseName));
    DriverName->MaximumLength = DriverName->Length + sizeof (WCHAR);
    DriverName->Buffer = BaseName;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\exqueue.c ===
/*++ EXTENDED_DEVICE_QUEUE

Copyright (c) 2000  Microsoft Corporation

Module Name:

    exqueue.c

Abstract:

    This module implements an extended device queue. The extended device
    queue extendes the traditional NT DEVICE_QUEUE object by adding
    several properties and operations to it to support a wider variety of
    devices.

Properties:

        Depth - Specifies the number of outstanding requests that can be
                pending on this device at a time. Any requests over Depth
                will put the queue in the busy state. Queue depth is set
                during object creation and can by dynamically adjusted at
                any time using RaidSetExDeviceQueueDepth.

Operations:

        RaidFreezeExDeviceQueue - Prevent incoming entries from executing
                by holding them in device queue. When the device queue is
                frozen, only entries that specify the ByPassQueue flag
                will not be queued.

        RaidResumeExDeviceQueue - Reverses calling RaidFreezeExDeviceQueue
                by allowing entries to leave the device queue.

        RaidNormalizeExDeviceQueue - After freezing and resuming the
                device queue or after adjusting the device queue depth,
                the device queue can have multiple entries in it's device
                queue but not be busy. This function "reinserts" elements
                into the queue until either the queue is busy again or
                the queue is empty.
Author:

    Matthew D Hendel (math) 15-June-2000

Revision History:

--*/

#include "precomp.h"

#if DBG
VOID
ASSERT_EXQ(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue
    )
{
    ASSERT (DeviceQueue->Size == sizeof (EXTENDED_DEVICE_QUEUE));
    ASSERT (DeviceQueue->DeviceRequests >= 0);
    ASSERT (DeviceQueue->ByPassRequests >= 0);
    ASSERT (DeviceQueue->OutstandingRequests >= 0);

    if (DeviceQueue->Flags.SolitaryOutstanding) {
        ASSERT (DeviceQueue->OutstandingRequests == 1);
    }
}

#else
#define ASSERT_EXQ(DeviceQueue)
#endif

PEX_DEVICE_QUEUE_ENTRY
INLINE
RaidpExQueuePeekItem(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue
    )
{
    PLIST_ENTRY Entry;
    PEX_DEVICE_QUEUE_ENTRY DeviceEntry;
    
    if (IsListEmpty (&DeviceQueue->DeviceListHead)) {
        return NULL;
    }

    switch (DeviceQueue->SchedulingAlgorithm) {

        case CScanScheduling:

            if (DeviceQueue->DeviceListCurrent) {
                Entry = DeviceQueue->DeviceListCurrent;
            } else {
                Entry = DeviceQueue->DeviceListHead.Flink;
            }

            break;

        case FifoScheduling:
        default:
            Entry = DeviceQueue->DeviceListHead.Flink;
    }

    
    DeviceEntry = CONTAINING_RECORD (Entry,
                                     EX_DEVICE_QUEUE_ENTRY,
                                     DeviceListEntry);
    return DeviceEntry;
}

VOID
INLINE
RaidpExQueueInsertItem(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue,
    IN PEX_DEVICE_QUEUE_ENTRY Entry,
    IN ULONG SortKey
    )
{
    PLIST_ENTRY ListEntry;
    PLIST_ENTRY ListHead;
    PEX_DEVICE_QUEUE_ENTRY QueueEntry;

    ListHead = &DeviceQueue->DeviceListHead;
    switch (DeviceQueue->SchedulingAlgorithm) {

        case CScanScheduling:
            for (ListEntry = ListHead->Blink;
                 ListEntry != ListHead;
                 ListEntry = ListEntry->Blink) {

                 QueueEntry = CONTAINING_RECORD(ListEntry,
                                                EX_DEVICE_QUEUE_ENTRY,
                                                DeviceListEntry);

                if (SortKey >= QueueEntry->SortKey) {
                    break;
                }
            }
            Entry->SortKey = SortKey;
            InsertHeadList (ListEntry, &Entry->DeviceListEntry);
            break;

        case FifoScheduling:
        default:
            InsertTailList (ListHead, &Entry->DeviceListEntry);
    }

    //
    // Update the status of the SolitaryReady flag.
    //
    
    QueueEntry = RaidpExQueuePeekItem (DeviceQueue);

    if (QueueEntry) {
        DeviceQueue->Flags.SolitaryReady = QueueEntry->Solitary;
    } else {
        DeviceQueue->Flags.SolitaryReady = FALSE;
    }
}


PEX_DEVICE_QUEUE_ENTRY
INLINE
RaidpExQueueRemoveItem(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue
    )
{
    PLIST_ENTRY Entry;
    PLIST_ENTRY Current;
    PEX_DEVICE_QUEUE_ENTRY DeviceEntry;
    PEX_DEVICE_QUEUE_ENTRY HeadEntry;
    //
    // Must have elements on the list if we're removing one of them.
    //
    
    ASSERT (!IsListEmpty (&DeviceQueue->DeviceListHead));

    switch (DeviceQueue->SchedulingAlgorithm) {

        case CScanScheduling:

            if (DeviceQueue->DeviceListCurrent) {
                Entry = DeviceQueue->DeviceListCurrent;
            } else {
                Entry = DeviceQueue->DeviceListHead.Flink;
            }

            Current = Entry->Flink;
            RemoveEntryList (Entry);

            if (Current == &DeviceQueue->DeviceListHead) {
                DeviceQueue->DeviceListCurrent = NULL;
            } else {
                DeviceQueue->DeviceListCurrent = Current;
            }

            break;

        case FifoScheduling:
        default:
            Entry = RemoveHeadList (&DeviceQueue->DeviceListHead);
    }

    
    //
    // Update the status of the SolitaryReady flag.
    //
    
    HeadEntry = RaidpExQueuePeekItem (DeviceQueue);

    if (HeadEntry) {
        DeviceQueue->Flags.SolitaryReady = HeadEntry->Solitary;
    } else {
        DeviceQueue->Flags.SolitaryReady = FALSE;
    }

    DeviceEntry = CONTAINING_RECORD (Entry,
                                     EX_DEVICE_QUEUE_ENTRY,
                                     DeviceListEntry);

    return DeviceEntry;
}


BOOLEAN
INLINE
IsDeviceQueueFrozen(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue
    )
/*++

Routine Description:

    Check if a device queue is frozen. A device queue is frozen when it's
    freeze count is non-zero.

Arguments:

    DeviceQueue - DeviceQueue to test.

Return Value:

    TRUE - If the device queue is frozen.

    FALSE - If the device queue is not frozen.

--*/
{
    return (DeviceQueue->FreezeCount > 0 ||
            DeviceQueue->InternalFreezeCount > 0);
}


BOOLEAN
INLINE
IsDeviceQueueBusy(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue
    )
/*++

Routine Description:

    Check if a device queue is busy. A device queue is busy when it's
    currently processing as many requests as it can handle, otherwise it
    is not busy. The Depth field of the device queue holds the number of
    requests a device 

Arguments:

    DeviceQueue - Supplies device queue to check for busy condition.

Return Value:

    TRUE - If the device queue is busy.

    FALSE - If the device queue is not busy.

--*/
{
    ASSERT_EXQ (DeviceQueue);

    if (DeviceQueue->BusyCount != 0 ||
        (DeviceQueue->OutstandingRequests >= DeviceQueue->Depth)) {
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOLEAN
INLINE
QuerySubmitItem(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue
    )
{
    if (DeviceQueue->Gateway != NULL) {
        return StorSubmitIoGatewayItem (DeviceQueue->Gateway);
    }

    return TRUE;
}

BOOLEAN
INLINE
NotifyCompleteItem(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue
    )
{
    if (DeviceQueue->Gateway != NULL) {
        return StorRemoveIoGatewayItem (DeviceQueue->Gateway);
    }

    return FALSE;
}


VOID
RaidInitializeExDeviceQueue(
    OUT PEXTENDED_DEVICE_QUEUE DeviceQueue,
    IN PSTOR_IO_GATEWAY Gateway, OPTIONAL
    IN ULONG Depth,
    IN SCHEDULING_ALGORITHM SchedulingAlgorithm
    )
/*++

Routine Description:

    Initialize an extended device queue object.

Arguments:

    DeviceQueue - Returns a pointer to the initialized device queue.

    Gateway - Supplies an optional pointer to a gateway object used
            to monitor and control several device queues that queue
            items to a single piece of hardware.
            

    Depth - Supplies the starting depth of the device queue.

    SchedulingAlgorithm - 

Return Value:

    None.

--*/
{
    RtlZeroMemory (DeviceQueue, sizeof (EXTENDED_DEVICE_QUEUE));
    InitializeListHead (&DeviceQueue->DeviceListHead);
    InitializeListHead (&DeviceQueue->ByPassListHead);
    KeInitializeSpinLock (&DeviceQueue->Lock);
    DeviceQueue->Depth = Depth;
    DeviceQueue->Size = sizeof (EXTENDED_DEVICE_QUEUE);
    DeviceQueue->Gateway = Gateway;
    DeviceQueue->SchedulingAlgorithm = SchedulingAlgorithm;
}


BOOLEAN
RaidInsertExDeviceQueue(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY KEntry,
    IN ULONG Flags,
    IN ULONG SortKey
    )
/*++

Routine Description:

    Insert an element into the the device queue. The eight separate cases
    depending on the status of the device queue (busy/ready, frozen/not
    frozen, bypass/not bypass) are listed below. Making an entry
    outstanding means incrementing the count of outstanding requests and
    returning TRUE, to allow the request to execute immediately. Adding
    to the device queue means placing the entry at the end of the device
    queue and returning FALSE to signify that the request will be
    executed later. Adding to the bypass queue means adding the entry to
    the end of the bypass queue and returning FALSE to signify that the
    request will be executed later.

        Frozen  ByPass  Busy        Action
        --------------------------------------------------
          N       N       N         Make outstanding
          N       N       Y         Add to device queue
          N       Y       N         Make outstanding
          N       Y       Y         Add to bypass queue
          Y       N       N         Add to device queue
          Y       N       Y         Add to device queue
          Y       Y       N         Make outstanding
          Y       Y       Y         Add to bypass queue

Arguments:

    DeviceQueue - Supplies the extended device queue.

    Entry - Supplies pointer to the device queue entry to queue.

    ByPass - Supplies a flag specifying whether this is a bypass
            request (if TRUE) or not (if FALSE).

    SortKey - Sort key for implementation of C-SCAN algorithm.

Return Value:

    TRUE - If the queue is not busy and the request should be started
            immediately.

    FALSE - If the queue is busy, and the request should be executed
            later.

--*/
{
    BOOLEAN Inserted;
    BOOLEAN Frozen;
    BOOLEAN Busy;
    LOGICAL ByPass;
    LOGICAL Solitary;
    KLOCK_QUEUE_HANDLE LockHandle;
    PEX_DEVICE_QUEUE_ENTRY Entry;

    Entry = (PEX_DEVICE_QUEUE_ENTRY)KEntry;

    RaidAcquireExDeviceQueueSpinLock (DeviceQueue, &LockHandle);

    //
    // If this is a solitary request we need to do some special processing.
    //

    Frozen = IsDeviceQueueFrozen (DeviceQueue);
    Busy = IsDeviceQueueBusy (DeviceQueue);
    ByPass = TEST_FLAG (Flags, EXQ_BYPASS_REQUEST);
    Solitary = TEST_FLAG (Flags, EXQ_SOLITARY_REQUEST);

    //
    // If there is a solitary request waiting to be issued, treat the
    // queue as though it were frozen.
    //
    
    if (DeviceQueue->Flags.SolitaryReady) {
        Frozen = TRUE;
    }

    //
    // If this is a solitary request.
    //
    
    if (Solitary && !ByPass) {

        Entry->Solitary = TRUE;

        if (DeviceQueue->OutstandingRequests == 0 &&
            !Frozen &&
            QuerySubmitItem (DeviceQueue)) {

            //
            // Since the outstanding count is zero the logical unit should
            // never be busy.
            //
            
            ASSERT (!Busy);

            Inserted = FALSE;
            DeviceQueue->OutstandingRequests++;
            InterlockedIncrement (&DeviceQueue->InternalFreezeCount);
            DeviceQueue->Flags.SolitaryOutstanding = TRUE;

        } else {

            Inserted = TRUE;
            RaidpExQueueInsertItem (DeviceQueue, Entry, SortKey);
            DeviceQueue->DeviceRequests++;
        }

        Entry->Inserted = Inserted;

    } else if ( (!Frozen && !ByPass && !Busy) ||
                (!Frozen &&  ByPass && !Busy) ||
                ( Frozen &&  ByPass && !Busy) ) {

        //
        // If the adapter is not busy, the request can be handled
        // immediately, so put it on the outstanding list. Otherwise,
        // it must be queued for processing later.
        //

        if (QuerySubmitItem (DeviceQueue)) {
            Inserted = FALSE;
            DeviceQueue->OutstandingRequests++;
        } else {
            Inserted = TRUE;
            RaidpExQueueInsertItem (DeviceQueue, Entry, SortKey);
            DeviceQueue->DeviceRequests++;
        }
        
    } else if ( (!Frozen && !ByPass &&  Busy) ||
                ( Frozen && !ByPass && !Busy) ||
                ( Frozen && !ByPass &&  Busy) ) {

        //
        // The non-bypass request cannot be handled at this time.
        // Place the request on the device queue.
        //

        Inserted = TRUE;
        RaidpExQueueInsertItem (DeviceQueue, Entry, SortKey);
        DeviceQueue->DeviceRequests++;

    } else {

        ASSERT ( (!Frozen && ByPass && Busy) ||
                 ( Frozen && ByPass && Busy) );

        //
        // The bypass request cannot be hanled at this time.
        // Place thre request on the bypass queue.
        //

        Inserted = TRUE;
        InsertTailList (&DeviceQueue->ByPassListHead,
                        &Entry->DeviceListEntry);
        DeviceQueue->ByPassRequests++;
    }

    Entry->Inserted = Inserted;
    RaidReleaseExDeviceQueueSpinLock (DeviceQueue, &LockHandle);

    return Inserted;
}


PKDEVICE_QUEUE_ENTRY
RaidNormalizeExDeviceQueue(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue
    )
/*++

Routine Description:

    Normalize a device queue after a frozen queue has been resumed or the
    depth of the device queue has been increased.

    After a frozen queue has been resumed or the depth of a device queue
    has been increased, the device queue can have elements queued to it,
    but the queue itself is not busy or frozen. This function
    "normalizes" the device queue by removing "extra" items from the
    queue until it becomes busy or empty.

    If the queue is busy at the time of normalization, the function will
    queue the entry to be handled later.  Otherwise, the function will
    return the entry to be executed immediately.

        BusyFrozen    ByPass      Device        Action
        ---------------------------------------------------------
            N           N           N           Nothing
            N           N           Y           Requeue device entry
            N           Y           N           Requeue bypass entry
            N           Y           Y           Requeue bypass entry
            Y           N           N           Nothing
            Y           N           Y           Nothing
            Y           Y           N           Nothing
            Y           Y           Y           Nothing

Arguments:

    DeviceQueue - Supplies the device queue to remove the element from.

Return Value:

    A NULL pointer is returned if the entry if the device queue is
    currently busy. Otherwise, a pointer to the entry that was reinserted
    is returned.  The equivelent of StartPacket should be called when
    a non-NULL value is returned.

--*/
{
    KLOCK_QUEUE_HANDLE LockHandle;
    PLIST_ENTRY NextEntry;
    PEX_DEVICE_QUEUE_ENTRY DeviceEntry;
    BOOLEAN BusyFrozen;
    BOOLEAN Device;
    BOOLEAN ByPass;
    
    RaidAcquireExDeviceQueueSpinLock (DeviceQueue, &LockHandle);

    //
    // Set BusyFrozen if the queue is either busy or frozen. Also if
    // there is a solitary outstanding request, we should consider the
    // queue frozen.
    //
    
    BusyFrozen = (IsDeviceQueueBusy (DeviceQueue) ||
                  IsDeviceQueueFrozen (DeviceQueue));
                  
    Device = !IsListEmpty (&DeviceQueue->DeviceListHead);
    ByPass = !IsListEmpty (&DeviceQueue->ByPassListHead);


    //
    // If there is a solitary request waiting to be issued, do so.
    //

    if (DeviceQueue->Flags.SolitaryReady &&
        DeviceQueue->OutstandingRequests == 0 &&
        !BusyFrozen) {

        ASSERT (Device);

        //
        // If the gateway isn't busy, pull the item off and return it;
        // otherwise don't.
        //
        
        if (QuerySubmitItem (DeviceQueue)) {

            DeviceEntry = RaidpExQueueRemoveItem (DeviceQueue);
            DeviceQueue->DeviceRequests--;
            DeviceQueue->OutstandingRequests++;
            DeviceEntry->Inserted = FALSE;
            InterlockedIncrement (&DeviceQueue->InternalFreezeCount);
            DeviceQueue->Flags.SolitaryOutstanding = TRUE;
        } else {
            DeviceEntry = NULL;
        }

        //
        // If not busy, not frozen, not solitary outstanding,
        // there is not an entry on the bypass queue and there is an entry
        // in the device queue.
        //
    
    } else if (!BusyFrozen && !ByPass && Device &&
               !DeviceQueue->Flags.SolitaryOutstanding) {

        //
        // There is an extra entry on the device queue. If the
        // adapter is free, remove the item from the device queue
        // and put it on the outstanding list. Otherwise, leave
        // it on the queue.
        //

        if (QuerySubmitItem (DeviceQueue)) {

            DeviceEntry = RaidpExQueueRemoveItem (DeviceQueue);
            DeviceQueue->DeviceRequests--;
            DeviceQueue->OutstandingRequests++;
            DeviceEntry->Inserted = FALSE;

        } else {
            DeviceEntry = NULL;
        }


        //
        // If not busy, not frozen, not a solitary outstanding request
        // and there is a bypass request.
        //
        
    } else if ( (!BusyFrozen && ByPass &&
                 !DeviceQueue->Flags.SolitaryOutstanding) ) {

        //
        // There is an extra entry on the bypass queue. If the
        // adapter is free, remove the item from the bypass queue
        // and put it on the outstanding list. Otherwise, leave
        // it on the bypass queue.
        //

        if (QuerySubmitItem (DeviceQueue)) {
            NextEntry = RemoveHeadList (&DeviceQueue->ByPassListHead);
            DeviceQueue->ByPassRequests--;
            DeviceQueue->OutstandingRequests++;

            DeviceEntry = CONTAINING_RECORD (NextEntry,
                                             EX_DEVICE_QUEUE_ENTRY,
                                             DeviceListEntry);
            DeviceEntry->Inserted = FALSE;

        } else {
            DeviceEntry = NULL;
        }

    } else {

        //
        // There are no extra entries.
        //

        ASSERT ((!BusyFrozen && !ByPass && !Device) || BusyFrozen);
        DeviceEntry = NULL;
    }

    RaidReleaseExDeviceQueueSpinLock (DeviceQueue, &LockHandle);

    return (PKDEVICE_QUEUE_ENTRY)DeviceEntry;
}
    

PKDEVICE_QUEUE_ENTRY
RaidRemoveExDeviceQueue(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue,
    IN PBOOLEAN RestartQueue,
    OUT PBOOLEAN RestartLun
    )
/*++

Routine Description:

    This routine removes an entry from the head of the device queue, if
    there is one available. If the device queue is frozen, only bypass
    entries are canidates for removal. The following table gives the actions
    for the eight separate cases depending on whether there are entries
    in the bypass queue (ByPass), device queue (Device) and whether the
    queue is frozen (Frozen):

          Frozen  ByPass  Device    Action
          ---------------------------------------------------------
            N       N       N       Remove outstanding
            N       N       Y       Remove device
            N       Y       N       Remove bypass
            N       Y       Y       Remove bypass
            Y       N       N       Remove outstanding
            Y       N       Y       Remove outstanding
            Y       Y       N       Remove bypass
            Y       Y       Y       Remove bypass

Arguments:

    DeviceQueue - Supplies a pointer to the device queue.

Return Value:

    If the device queue is empty, NULL is returned. Otherwise, a pointer
    to a device queue entry to be executed is returned.

--*/
{
    KLOCK_QUEUE_HANDLE LockHandle;
    PLIST_ENTRY NextEntry;
    PEX_DEVICE_QUEUE_ENTRY DeviceEntry;
    BOOLEAN BusyFrozen;
    BOOLEAN ByPass;
    BOOLEAN Device;

    ASSERT (RestartQueue != NULL);
    VERIFY_DISPATCH_LEVEL();

    RaidAcquireExDeviceQueueSpinLock (DeviceQueue, &LockHandle);

    
    BusyFrozen = (IsDeviceQueueFrozen (DeviceQueue) ||
                  IsDeviceQueueBusy (DeviceQueue) ||
                  StorIsIoGatewayBusy (DeviceQueue->Gateway) ||
                  StorIsIoGatewayPaused (DeviceQueue->Gateway));
              
    ByPass = !IsListEmpty (&DeviceQueue->ByPassListHead);
    Device = !IsListEmpty (&DeviceQueue->DeviceListHead);

    //
    // If we're ready for the awaiting solitary request, make it outstanding
    // now.
    //
    
    if (DeviceQueue->Flags.SolitaryReady &&
        DeviceQueue->OutstandingRequests == 1 &&
        !BusyFrozen) {

        //
        // If SolitaryReady is true, there must be requests on the
        // device queue.
        //
        
        ASSERT (Device);
        DeviceEntry = RaidpExQueueRemoveItem (DeviceQueue);
        DeviceQueue->DeviceRequests--;

        DeviceEntry->Inserted = FALSE;
        InterlockedIncrement (&DeviceQueue->InternalFreezeCount);
        DeviceQueue->Flags.SolitaryOutstanding = TRUE;

        RaidReleaseExDeviceQueueSpinLock (DeviceQueue, &LockHandle);
        return (PKDEVICE_QUEUE_ENTRY)DeviceEntry;
    }

    //
    // If we're completing the solitary request, unpause the queue and
    // flip the SolitaryOutstanding flag.
    //
    
    if (DeviceQueue->Flags.SolitaryOutstanding) {

        LONG Count;
        
        ASSERT (DeviceQueue->OutstandingRequests == 1);
        Count = InterlockedDecrement (&DeviceQueue->InternalFreezeCount);
        DeviceQueue->Flags.SolitaryOutstanding = FALSE;
        ASSERT (Count >= 0);
        if (Count == 0) {
            *RestartLun = TRUE;
        }
    }

    if ( (!BusyFrozen && !ByPass && !Device) ||
         ( BusyFrozen && !ByPass && !Device) ||
         ( BusyFrozen && !ByPass &&  Device) ) {

        //
        // There are no available entries on the bypass or device queues or
        // we are busy or frozen. Remove the entry from the outstanding
        // requests.
        //

        DeviceQueue->OutstandingRequests--;
        
        if (DeviceQueue->BusyCount) {
            DeviceQueue->BusyCount--;
        }

        *RestartQueue = NotifyCompleteItem (DeviceQueue);
        DeviceEntry = NULL;

    } else if ( (!BusyFrozen && !ByPass && Device) ) {

        //
        // There are entries on the device queue, and we're not frozen
        // or busy.
        //
            
        DeviceEntry = RaidpExQueueRemoveItem (DeviceQueue);
        DeviceEntry->Inserted = FALSE;
        DeviceQueue->DeviceRequests--;
        *RestartQueue = FALSE;

    } else {

        //
        // There is an available entry on the bypass queue, and we're
        // not frozen or busy.
        //

        ASSERT (ByPass);
        
        NextEntry = RemoveHeadList (&DeviceQueue->ByPassListHead);
        DeviceEntry = CONTAINING_RECORD (NextEntry,
                                         EX_DEVICE_QUEUE_ENTRY,
                                         DeviceListEntry);
        DeviceEntry->Inserted = FALSE;
        DeviceQueue->ByPassRequests--;
        *RestartQueue = FALSE;
    }

#if DBG
    if (DeviceQueue->DeviceRequests != 0 &&
        DeviceQueue->OutstandingRequests == 0 &&
        DeviceEntry == NULL && !BusyFrozen) {

        //
        // If this happens, we have outstanding queued requests, but
        // we have not removed them from the queue. After this, the
        // state machine will hang with queued requests that never get
        // removed from the queue.
        //
        
        ASSERT (FALSE);
    }
#endif


    RaidReleaseExDeviceQueueSpinLock (DeviceQueue, &LockHandle);

    return (PKDEVICE_QUEUE_ENTRY)DeviceEntry;
}


PKDEVICE_QUEUE_ENTRY
RaidRemoveExDeviceQueueIfPending(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue
    )
/*++

Routine Description:

    Remove the next pending entry from the non-bypass list, if one
    is available. If not, return NULL. Pending entries are entries
    that have been physically queued to the device queue (as opposed
    to outstanding requests, which are not inserted in the queue).

    NB: This function works properly on both a frozen and unfrozen
        device queue.

Arguments:

    DeviceQueue - Supplies a device queue that the pending entry should
            be removed from.

Return Value:

    NULL - If there are no pending entries on the queue.

    Non-NULL - Pointer to a pending queue entry that has been
            removed from the queue.

--*/
{
    PLIST_ENTRY NextEntry;
    PEX_DEVICE_QUEUE_ENTRY DeviceEntry;
    KLOCK_QUEUE_HANDLE LockHandle;

    RaidAcquireExDeviceQueueSpinLock (DeviceQueue, &LockHandle);

    //
    // If the device list is not empty, remove the head and
    // return the entry. Otherwise, return NULL.
    //
    
    if (!IsListEmpty (&DeviceQueue->DeviceListHead)) {
        DeviceEntry = RaidpExQueueRemoveItem (DeviceQueue);
        DeviceEntry->Inserted = FALSE;
        DeviceQueue->DeviceRequests--;
    } else {
        DeviceEntry = NULL;
    }

    RaidReleaseExDeviceQueueSpinLock (DeviceQueue, &LockHandle);

    return (PKDEVICE_QUEUE_ENTRY)DeviceEntry;
}

LOGICAL
RaidFreezeExDeviceQueue(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue
    )
/*++

Routine Description:

    Freeze the device queue, disallowing further requests from leaving
    the queue. When the queue is frozen, only bypass requests are allowed
    to leave the queue.

Arguments:

    DeviceQueue - Supplies a pointer to the device queue to freeze.

Return Value:

    TRUE - if the queue was not frozen prior to the call.

    FALSE - if the queue was frozen prior to the call.
    

Notes:

    The queue may be frozen multiple times.

Environment:

    The device queue may be frozen at any IRQL.
    
--*/
{
    LONG Count;
    
    Count = InterlockedIncrement (&DeviceQueue->FreezeCount);

    return (Count == 0);
}


LOGICAL
RaidResumeExDeviceQueue(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue
    )
/*++

Routine Description:

    Resume a frozen queue.

    NB: Unless all of the elements of the queue are flushed, sometime
    after resuming the queue, the function RaidNormalizeExDeviceQueue
    should be called to remove frozen entries from the queue.

Arguments:

    DeviceQueue - Supplies a pointer to the device queue to resume.

Return Value:

    TRUE if the resume actually restarted the queue; FALSE otherwise.

--*/
{
    LONG Count;

    Count = InterlockedDecrement (&DeviceQueue->FreezeCount);

    if (Count < 0) {

        //
        // An attempt was made to resume a queue that was not frozen.
        // Blow off the resume request and continue on. Return FALSE
        // from the function since we did not actually restart
        // the queue.
        //

        DebugWarn (("Attempt to resume an unfrozen queue.\n"));
        InterlockedIncrement (&DeviceQueue->FreezeCount);
        return FALSE;
    }

    return (Count == 0);
}


VOID
RaidReturnExDeviceQueue(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY Entry
    )
/*++

Routine Description:

    Return the IO packet to the head of the queue. Presumably this is
    because the IO packet failed to complete properly and needs to
    be retried.

    NB: The item is queued to the FRONT of the queue, not the BACK.

Arguments:

    DeviceQueue - Supplies a pointer to the device queue the item
        is to be returned to.

    Entry - Supplies pointer ot the device queue entry to return to
        the queue.

Return Value:

    None.

--*/
{
    KLOCK_QUEUE_HANDLE LockHandle;
    ULONG CurrentOutstanding;

    ASSERT_EXQ (DeviceQueue);
    
    RaidAcquireExDeviceQueueSpinLock (DeviceQueue, &LockHandle);

    DeviceQueue->OutstandingRequests--;
    if (DeviceQueue->BusyCount) {
        DeviceQueue->BusyCount--;
    }
    InsertHeadList (&DeviceQueue->DeviceListHead, &Entry->DeviceListEntry);
    DeviceQueue->DeviceRequests++;


    RaidReleaseExDeviceQueueSpinLock (DeviceQueue, &LockHandle);

}
    

VOID
RaidSetExDeviceQueueDepth(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue,
    IN ULONG Depth
    )
/*++

Routine Description:

    Adjust the depth of the device queue.

    NB: If the depth is adjusted upwards, after adjusting the queue depth
    the function RaidReinsertExDeviceQueue should be called to remove
    extra items from the queue.

Arguments:

    DeviceQueue - Supplies a pointer to a device queue to adjust.

    Depth - Supplies the new depth of the device queue.

Return Value:

    None.

--*/
{
    KLOCK_QUEUE_HANDLE LockHandle;

    //
    // It would be nice to perform this using interlocked operations
    // instead of holding a spinlock.
    //
    
    RaidAcquireExDeviceQueueSpinLock (DeviceQueue, &LockHandle);
    DeviceQueue->Depth = Depth;
    RaidReleaseExDeviceQueueSpinLock (DeviceQueue, &LockHandle);
}

VOID
RaidBusyExDeviceQueue(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue,
    IN ULONG RequestsToComplete
    )
{
    KLOCK_QUEUE_HANDLE LockHandle;

    //
    // It would be nice to perform this using interlocked operations
    // instead of holding a spinlock.
    //

    RaidAcquireExDeviceQueueSpinLock (DeviceQueue, &LockHandle);
    if ((LONG)RequestsToComplete > DeviceQueue->OutstandingRequests) {
        DeviceQueue->BusyCount = DeviceQueue->OutstandingRequests;
    } else {
        DeviceQueue->BusyCount = RequestsToComplete;
    }
    RaidReleaseExDeviceQueueSpinLock (DeviceQueue, &LockHandle);
}

VOID
RaidReadyExDeviceQueue(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue
    )
{
    KLOCK_QUEUE_HANDLE LockHandle;

    //
    // It would be nice to perform this using interlocked operations
    // instead of holding a spinlock.
    //

    RaidAcquireExDeviceQueueSpinLock (DeviceQueue, &LockHandle);
    DeviceQueue->BusyCount = 0;
    RaidReleaseExDeviceQueueSpinLock (DeviceQueue, &LockHandle);
}

VOID
RaidGetExDeviceQueueProperties(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue,
    OUT PEXTENDED_DEVICE_QUEUE_PROPERTIES Properties
    )
/*++

Routine Description:

    Get properties for the device queue.

Arguments:

    DeviceQueue - Supplies a pointer to the device queue to get
            properties for.

    Properties - Returns properties for the device queue.

Return Value:

    None.

--*/
{
    KLOCK_QUEUE_HANDLE LockHandle;

    RaidAcquireExDeviceQueueSpinLock (DeviceQueue, &LockHandle);

    Properties->Frozen = IsDeviceQueueFrozen (DeviceQueue);
    Properties->Busy = IsDeviceQueueBusy (DeviceQueue);
    Properties->Depth = DeviceQueue->Depth;
    Properties->OutstandingRequests = DeviceQueue->OutstandingRequests;
    Properties->DeviceRequests = DeviceQueue->DeviceRequests;
    Properties->ByPassRequests = DeviceQueue->ByPassRequests;

    RaidReleaseExDeviceQueueSpinLock (DeviceQueue, &LockHandle);
}



VOID
RaidAcquireExDeviceQueueSpinLock(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue,
    OUT PKLOCK_QUEUE_HANDLE LockHandle
    )
/*++

Routine Description:

    Acquire the device queue spinlock.

Arguments:

    DeviceQueue - Supplies a pointer to the device queue to acquire the
            spinlock for.

    LockHandle - Returns a pointer to the lock handle for this spinlock.

Return Value:

    None.

--*/
{
    KeAcquireInStackQueuedSpinLockAtDpcLevel (&DeviceQueue->Lock, LockHandle);
    ASSERT_EXQ (DeviceQueue);
}

VOID
RaidReleaseExDeviceQueueSpinLock(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue,
    IN PKLOCK_QUEUE_HANDLE LockHandle
    )
/*++

Routine Description:

    Release the device queue spinlock.

Arguments:

    DeviceQueue - Supplies a pointer to the device queue to release the
            spinlock to.

    LockHandle - Supplies a pointer to the lock handle returned when
            the spinlock was acquired.

Return Value:

    None.

--*/
{
    ASSERT_EXQ (DeviceQueue);
    KeReleaseInStackQueuedSpinLockFromDpcLevel (LockHandle);
}


VOID
RaidDeleteExDeviceQueueEntry(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue
    )
/*++

Routine Description:

    Delete an outstanding request from the device queue. Put differently,
    remove it from the device queue without attempting to remove the
    next entry.

Arguments:

    DeviceQueue - Supplies the device queue to remove the entry from.

Return Value:

    None.

--*/
{
    KLOCK_QUEUE_HANDLE LockHandle;
    LONG Count;
    
    //
    // It would be nice to perform this using interlocked operations
    // instead of holding a spinlock.
    //

    RaidAcquireExDeviceQueueSpinLock (DeviceQueue, &LockHandle);

    //
    // If we're removing the solitary outstanding request from the outstanding
    // queue, clear the solitary outstanding flag.
    //
    
    if (DeviceQueue->Flags.SolitaryOutstanding) {
        ASSERT (DeviceQueue->OutstandingRequests == 1);
        Count = InterlockedDecrement (&DeviceQueue->InternalFreezeCount);
        ASSERT (Count >= 0);
        DeviceQueue->Flags.SolitaryOutstanding = FALSE;
    }

    DeviceQueue->OutstandingRequests--;
    NotifyCompleteItem (DeviceQueue);
    RaidReleaseExDeviceQueueSpinLock (DeviceQueue, &LockHandle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\eventq.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    eventq.h

Abstract:

    Declaration of a timed event queue class.

Author:

    Matthew D Hendel (math) 28-Mar-2001

Revision History:

--*/

#pragma once


//
// Event queue entry
//

typedef
VOID
(*STOR_REMOVE_EVENT_ROUTINE)(
    IN struct _STOR_EVENT_QUEUE* Queue,
    IN struct _STOR_EVENT_QUEUE_ENTRY* Entry
    );
    
typedef
VOID
(*STOR_EVENT_QUEUE_PURGE_ROUTINE)(
    IN struct _STOR_EVENT_QUEUE* Queue,
    IN PVOID Context,
    IN struct _STOR_EVENT_QUEUE_ENTRY* Entry,
    IN STOR_REMOVE_EVENT_ROUTINE RemoveEventRoutine
    );

typedef struct _STOR_EVENT_QUEUE_ENTRY {
    LIST_ENTRY NextLink;
    ULONG Timeout;
} STOR_EVENT_QUEUE_ENTRY, *PSTOR_EVENT_QUEUE_ENTRY;


//
// Event queue class
//

typedef struct _STOR_EVENT_QUEUE {

    //
    // List of timed requests. The element at the head of the list
    // is the one cooresponding to the timeout we are currenlty
    // timing against.
    //
    
    LIST_ENTRY List;

    //
    // List spinlock.
    //
    
    KSPIN_LOCK Lock;

    //
    // Timeout value in seconds.
    //
    
    ULONG Timeout;
    
} STOR_EVENT_QUEUE, *PSTOR_EVENT_QUEUE;


//
// Functions
//

VOID
StorCreateEventQueue(
    IN PSTOR_EVENT_QUEUE Queue
    );

VOID
StorInitializeEventQueue(
    IN PSTOR_EVENT_QUEUE Queue
    );

VOID
StorDeleteEventQueue(
    IN PSTOR_EVENT_QUEUE Queue
    );

VOID
StorPurgeEventQueue(
    IN PSTOR_EVENT_QUEUE Queue,
    IN STOR_EVENT_QUEUE_PURGE_ROUTINE PurgeRoutine,
    IN PVOID Context
    );

VOID
StorInsertEventQueue(
    IN PSTOR_EVENT_QUEUE Queue,
    IN PSTOR_EVENT_QUEUE_ENTRY Entry,
    IN ULONG Timeout
    );

VOID
StorRemoveEventQueue(
    IN PSTOR_EVENT_QUEUE Queue,
    IN PSTOR_EVENT_QUEUE_ENTRY Entry
    );

NTSTATUS
StorTickEventQueue(
    IN PSTOR_EVENT_QUEUE Queue
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\exqueue.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    exqueue.h

Abstract:

    This module implements an extended device queue. See exqueue.c for
    more details.

Author:

    Matthew D Hendel (math) 15-June-2000

Revision History:

--*/

#pragma once

//
// PERF NOTE: The device queue is implemented as a doubly linked list.
// While this works great for a FIFO device queue, for a CSCAN device
// queue we end up walking the list to insert the item in correct order.
// If the device queue gets very deep, there are a number of data
// structures that are better suited adding and removing elements in a
// CSCAN queue (priority queue, RB tree).
//

typedef enum _SCHEDULING_ALGORITHM {
    FifoScheduling =  0x01,
    CScanScheduling = 0x02
} SCHEDULING_ALGORITHM;


//
// Private types
//

typedef struct _EXTENDED_DEVICE_QUEUE {
    CSHORT Type;
    CSHORT Size;
    LIST_ENTRY DeviceListHead;
    PLIST_ENTRY DeviceListCurrent;
    LIST_ENTRY ByPassListHead;
    KSPIN_LOCK Lock;
    LONG Depth;    
    LONG OutstandingRequests;
    LONG DeviceRequests;
    LONG ByPassRequests;
    LONG FreezeCount;
    LONG InternalFreezeCount;
    LONG BusyCount;
    PSTOR_IO_GATEWAY Gateway;
    SCHEDULING_ALGORITHM SchedulingAlgorithm;

    struct {
        LOGICAL SolitaryReady : 1;
        LOGICAL SolitaryOutstanding : 1;
    } Flags;
    
} EXTENDED_DEVICE_QUEUE, *PEXTENDED_DEVICE_QUEUE;

typedef struct _EXTENDED_DEVICE_QUEUE_PROPERTIES {
    ULONG Depth;
    BOOLEAN Frozen;
    BOOLEAN Busy;
    ULONG OutstandingRequests;
    ULONG DeviceRequests;
    ULONG ByPassRequests;
    SCHEDULING_ALGORITHM SchedulingAlgorithm;
} EXTENDED_DEVICE_QUEUE_PROPERTIES, *PEXTENDED_DEVICE_QUEUE_PROPERTIES;

//
// Data types for exqueue callbacks.
//


//
// A bypass request is a request that should bypass the device queue.
//

#define EXQ_BYPASS_REQUEST          (0x00001)

//
// A solitary request is one that can only be issued to the LUN while no other
// requests are outstanding.
//

#define EXQ_SOLITARY_REQUEST        (0x00002)

VOID
RaidInitializeExDeviceQueue(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue,
    IN PSTOR_IO_GATEWAY Gateway, OPTIONAL
    IN ULONG Depth,
    IN SCHEDULING_ALGORITHM SchedulingAlgorithm
    );

BOOLEAN
RaidInsertExDeviceQueue(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY Entry,
    IN ULONG Flags,
    IN ULONG SortQueueKey
    );

PKDEVICE_QUEUE_ENTRY
RaidNormalizeExDeviceQueue(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue
    );
    
PKDEVICE_QUEUE_ENTRY
RaidRemoveExDeviceQueue(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue,
    OUT PBOOLEAN RestartQueue,
    OUT PBOOLEAN RestartLun
    );

PKDEVICE_QUEUE_ENTRY
RaidRemoveExDeviceQueueByKey(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue,
    OUT PBOOLEAN RestartQueue,
    IN ULONG SortQueueKey
    );
    
PKDEVICE_QUEUE_ENTRY
RaidRemoveExDeviceQueueIfPending(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue
    );

LOGICAL
RaidFreezeExDeviceQueue(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue
    );

LOGICAL
RaidResumeExDeviceQueue(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue
    );

LOGICAL
INLINE
RaidIsExQueueFrozen(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue
    )
{
    return (DeviceQueue->FreezeCount > 0);
}
    

VOID
RaidReturnExDeviceQueue(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY Entry
    );

VOID
RaidAcquireExDeviceQueueSpinLock(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue,
    OUT PKLOCK_QUEUE_HANDLE LockHandle
    );

VOID
RaidReleaseExDeviceQueueSpinLock(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue,
    IN PKLOCK_QUEUE_HANDLE LockHandle
    );

VOID
RaidGetExDeviceQueueProperties(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue,
    OUT PEXTENDED_DEVICE_QUEUE_PROPERTIES Properties
    );

VOID
RaidSetExDeviceQueueDepth(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue,
    IN ULONG NewDepth
    );
    
VOID
RaidBusyExDeviceQueue(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue,
    IN ULONG RequestsToComplete
    );

VOID
RaidReadyExDeviceQueue(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue
    );

VOID
RaidDeleteExDeviceQueueEntry(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\driver.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    driver.h

Abstract:

    Definition of the RAID_DRIVER_EXTENSION object and related functions.

Author:

    Matthew D Hendel (math) 19-Apr-2000

Revision History:

--*/

#pragma once


typedef struct _RAID_HW_INIT_DATA {
    HW_INITIALIZATION_DATA Data;
    LIST_ENTRY ListEntry;
} RAID_HW_INIT_DATA, *PRAID_HW_INIT_DATA;

#define MPIO_DEVICE_LIST_PATH L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control\\MPDEV"
//
// The RAID_DRIVER_EXTENSION is the extension for the driver.
//

typedef struct _RAID_DRIVER_EXTENSION {

    //
    // The object type for this extension. This must be RaidDriverObject.
    //
    
    RAID_OBJECT_TYPE ObjectType;

    //
    // Back pointer to the object containing this driver.
    //
    
    PDRIVER_OBJECT DriverObject;

    //
    // Back pointer to the PORT_DATA object that owns this driver object.
    //

    PRAID_PORT_DATA PortData;
    
    //
    // This is the list of drivers currently loaded.
    //
    
    LIST_ENTRY DriverLink;

    //
    // The Registry path passed into the miniport's DriverEntry.
    //

    UNICODE_STRING RegistryPath;

    //
    // List of adapters owned by this driver.
    //
    
    struct {

        //
        // List head.
        //
        
        LIST_ENTRY List;

        //
        // Count of entries.
        //
        
        ULONG Count;

        //
        // Spinlock protecting access to the list and count.
        //
        
        KSPIN_LOCK Lock;

    } AdapterList;
        
    //
    // Number of adapters that are attached to this driver.
    //
    
    ULONG AdapterCount;

    //
    // List of hardware initialization structures, passed in to
    // ScsiPortInitialize. These are necessary to process our AddDevice
    // call.
    //
    
    LIST_ENTRY HwInitList;
    

    //
    // List of multipath-supported devices.
    //

    UNICODE_STRING MPIOSupportedDeviceList;

} RAID_DRIVER_EXTENSION, *PRAID_DRIVER_EXTENSION;


//
// Operations on the RAID_DRIVER_EXTENSION object.
//

//
// Creation and destruction.
//

VOID
RaCreateDriver(
    OUT PRAID_DRIVER_EXTENSION Driver
    );

NTSTATUS
RaInitializeDriver(
    IN PRAID_DRIVER_EXTENSION Driver,
    IN PDRIVER_OBJECT DriverObject,
    IN PRAID_PORT_DATA PortData,
    IN PUNICODE_STRING RegistryPath
    );

VOID
RaDeleteDriver(
    IN PRAID_DRIVER_EXTENSION Driver
    );

//
// Driver operations
//

NTSTATUS
RaDriverAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

PHW_INITIALIZATION_DATA
RaFindDriverInitData(
    IN PRAID_DRIVER_EXTENSION Driver,
    IN INTERFACE_TYPE InterfaceType
    );

NTSTATUS
RaSaveDriverInitData(
    IN PRAID_DRIVER_EXTENSION Driver,
    IN PHW_INITIALIZATION_DATA HwInitializationData
    );

VOID
RaFreeDriverInitData(
    IN PRAID_DRIVER_EXTENSION Driver,
    IN OUT PHW_INITIALIZATION_DATA HwInitializationData
    );
//
// Handler functions
//

NTSTATUS
RaDriverUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
RaDriverCreateIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RaDriverCloseIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RaDriverDeviceControlIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RaDriverScsiIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
    
NTSTATUS
RaDriverPnpIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RaDriverPowerIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RaDriverSystemControlIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//
// Misc functions
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );


ULONG
RaidPortInitialize(
    IN PVOID Argument1,
    IN PVOID Argument2,
    IN PHW_INITIALIZATION_DATA HwInitializationData,
    IN PVOID HwContext OPTIONAL
    );

VOID
RaidDriverGetName(
    IN PRAID_DRIVER_EXTENSION Driver,
    OUT PUNICODE_STRING DriverName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\eventq.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    eventq.c

Abstract:

    Implementation of an event queue class used for timing out events issued
    to a hardware device.

    The event queue class implements the same algorithm as SCSIPORT to time
    events. The timeout is not strictly followed, but is used in conjunction
    with adding and removing items from the queue to time-out requests.

    For example, if three requests are issued to the queue, we would see the
    following:

    Before, no requests are pending.

    Issue:

    Request 1, Timeout = 4 seconds      Queue Timeout = -1, set to 4
    Request 2, Timeout = 2 seconds      Queue Timeout = 4, leave
    Request 3, Timeout = 4 seconds      Queue Timeout = 4, leave


    Complete:

    Request 1. Since Request 1 was at the head of the list, reset the timeout
    to the timeout for the next item in the queue, i.e., set Queue Timeout
    to 2 (#2's timeout)
    
    Request 3, Since Request 3 was not at the head of the list, do not
    reset the timeout.

    (wait 2 seconds)

    Time request 2 out.

Notes:

    There are better alorithms for timing out. Since we do not retry requests,
    but rather reset the entire bus, this is a sufficient algorithm.

Author:

    Matthew D Hendel (math) 28-Mar-2001


Revision History:

--*/


#include "precomp.h"
#include "eventq.h"


enum {

    //
    // The timeout is set to QueueTimeoutNone if and only if
    // we have an empty queue list.
    //
    
    QueueTimeoutNone        = -1,

    //
    // The timeout is set to QueueTimeoutTimedOut if and only if
    // we have timed out, but not yet purged the event queue.
    //
    
    QueueTimeoutTimedOut    = -2
};

//
// Implementation
//

#if DBG
VOID
INLINE
DbgCheckQueue(
    IN PSTOR_EVENT_QUEUE Queue
    )
{
    //
    // NOTE: Queue spinlock must be acquired by the calling routine.
    //
    
    if (Queue->Timeout == QueueTimeoutNone) {
        ASSERT (IsListEmpty (&Queue->List));
    }
}
#else // !DBG
#define DbgCheckQueue(Queue)
#endif

VOID
StorCreateEventQueue(
    IN PSTOR_EVENT_QUEUE Queue
    )
/*++

Routine Description:

    Create an empty event queue.

Arguments:

    Queue - Supplies the buffer where the event queue should be created.

Return Value:

    None.

--*/
{
    PAGED_CODE();
    ASSERT (Queue != NULL);
    InitializeListHead (&Queue->List);
    KeInitializeSpinLock (&Queue->Lock);
    Queue->Timeout = QueueTimeoutNone;
}



VOID
StorInitializeEventQueue(
    IN PSTOR_EVENT_QUEUE Queue
    )
{
    PAGED_CODE();
    ASSERT (Queue != NULL);
}


VOID
StorDeleteEventQueue(
    IN PSTOR_EVENT_QUEUE Queue
    )
/*++

Routine Description:

    Delete an event queue. The event queue must be empty to be deleted.

Arguments:

    Queue - Supplies the event queue to delete.

Return Value:

    None.

--*/
{
    ASSERT (IsListEmpty (&Queue->List));
    DbgFillMemory (Queue, sizeof (STOR_EVENT_QUEUE), DBG_DEALLOCATED_FILL);
}



VOID
StorInsertEventQueue(
    IN PSTOR_EVENT_QUEUE Queue,
    IN PSTOR_EVENT_QUEUE_ENTRY QueueEntry,
    IN ULONG Timeout
    )
/*++

Routine Description:

    Insert an item into a timed event queue.

Arguments:

    Queue - Supplies the event queue to insert the element into.

    Entry - Supplies the element to be inserted.

    Timeout - Supplies the timeout for the request.

Return Value:

    None.

--*/
{
    //
    // If we were passed a bogus timeout value, fix it up and continue on.
    //
    
    if (Timeout == 0 ||
        Timeout == QueueTimeoutNone ||
        Timeout == QueueTimeoutTimedOut) {

        //
        // CLASSPNP has a bug where it sends down requests with
        // zero timeout. Fix these up to have a 10 second timeout.
        //

        Timeout = DEFAULT_IO_TIMEOUT;
    }

    QueueEntry->Timeout = Timeout;

    KeAcquireSpinLockAtDpcLevel (&Queue->Lock);
    DbgCheckQueue (Queue);

    InsertTailList (&Queue->List, &QueueEntry->NextLink);

    //
    // If there are no outstanding requests (QueueTimeoutNone) or
    // the queue is recovering from a timeout (QueueTimeoutTimedOut)
    // reset the timeout to the new timeout. Otherwise, leave the
    // timeout to what it was, it will be updated when a request
    // is completed.
    //
    
    if (Queue->Timeout == QueueTimeoutNone ||
        Queue->Timeout == QueueTimeoutTimedOut) {
        Queue->Timeout = Timeout;
    }

    DbgCheckQueue (Queue);
    KeReleaseSpinLockFromDpcLevel (&Queue->Lock);
}


VOID
StorRemoveEventQueueInternal(
    IN PSTOR_EVENT_QUEUE Queue,
    IN PSTOR_EVENT_QUEUE_ENTRY QueueEntry
    )
/*++

Routine Description:

    Remove the specified entry from the event queue. This is done
    without holding the event queue spinlock -- the calling function
    must hold the lock.

Arguments:

    Queue - Event queue to remove item from.

    Entry - Item to remove.

Return Value:

    None.

--*/
{
    LOGICAL Timed;
    PLIST_ENTRY Entry;

    ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // The caller of this routine must hold the spinlock.
    //
    // NB: On a UP machine, the spinlock will never be acquired
    // because we're at DISPATCH level. So the test is only correct
    // on an MP machine.
    //
    
    ASSERT (KeNumberProcessors == 1 ||
            KeTestSpinLock (&Queue->Lock) == FALSE);
    DbgCheckQueue (Queue);

    //
    // If Entry is at the head of the queue.
    //
    
    if (Queue->List.Flink == &QueueEntry->NextLink) {
        Timed = TRUE;
    } else {
        Timed = FALSE;
    }

    RemoveEntryList (&QueueEntry->NextLink);

    DbgFillMemory (QueueEntry,
                   sizeof (STOR_EVENT_QUEUE_ENTRY),
                   DBG_DEALLOCATED_FILL);
    
    if (Timed) {
        if (IsListEmpty (&Queue->List)) {
            Queue->Timeout = QueueTimeoutNone;
        } else {

            //
            // Start timer from element at the head of the list.
            //

            Entry = Queue->List.Flink;
            QueueEntry = CONTAINING_RECORD (Entry,
                                            STOR_EVENT_QUEUE_ENTRY,
                                            NextLink);
            Queue->Timeout = QueueEntry->Timeout;
        }
    }

    //
    // This spinlock still must be held.
    //
    // NB: On a UP machine, the spinlock will not be acquired because
    // we're already at DISPATCH level. So the spinlock test is only
    // valid/required on an MP machine.
    //
    
    ASSERT (KeNumberProcessors == 1 ||
            KeTestSpinLock (&Queue->Lock) == FALSE);
    DbgCheckQueue (Queue);
}

VOID
StorRemoveEventQueue(
    IN PSTOR_EVENT_QUEUE Queue,
    IN PSTOR_EVENT_QUEUE_ENTRY QueueEntry
    )
/*++

Routine Description:

    Remove a specific item from the event queue.

Arguments:

    Queue - Event queue to remove the item from.

    Entry - Event to remove.


Return Value:

    None.

--*/
{
    ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);

    KeAcquireSpinLockAtDpcLevel (&Queue->Lock);
    StorRemoveEventQueueInternal (Queue, QueueEntry);
    KeReleaseSpinLockFromDpcLevel (&Queue->Lock);
}



NTSTATUS
StorTickEventQueue(
    IN PSTOR_EVENT_QUEUE Queue
    )
/*++

Routine Description:

    Reduce the event queue timeout by one tick.

Arguments:

    Queue - Supplies the queue to decrement the timeout for.

Return Value:

    STATUS_SUCCESS - If the timer expiration has not expired.

    STATUS_IO_TIMEOUT - If the timer expiration has expired.

--*/
{
    NTSTATUS Status;
    
    KeAcquireSpinLockAtDpcLevel (&Queue->Lock);
    DbgCheckQueue (Queue);

    if (Queue->Timeout == QueueTimeoutNone ||
        Queue->Timeout == QueueTimeoutTimedOut) {
        Status = STATUS_SUCCESS;
    } else {
        if (--Queue->Timeout == 0) {
            Status = STATUS_IO_TIMEOUT;
            Queue->Timeout = QueueTimeoutTimedOut;
        } else {
            Status = STATUS_SUCCESS;
        }
    }

    DbgCheckQueue (Queue);
    KeReleaseSpinLockFromDpcLevel (&Queue->Lock);

    return Status;
}


VOID
INLINE
CopyList(
    IN PLIST_ENTRY NewListHead,
    IN PLIST_ENTRY OldListHead
    )
/*++

Routine Description:

    Shallow copies a list from one list head to another. Upon return the
    list that was at OldListHead is accessible through NewListHead, and
    OldListHead is initialized as an empty list.

Arguments:

    NewListHead - Destination list head.

    OldListHead - Source list head.

Return Value:

    None.

--*/
{


    if (!IsListEmpty (OldListHead)) {

        //
        // Copy the contents of the list head.
        //

        *NewListHead = *OldListHead;

        //
        // Fixup the broken pointers.
        //
    
        NewListHead->Flink->Blink = NewListHead;
        NewListHead->Blink->Flink = NewListHead;

    } else {

        InitializeListHead (NewListHead);
    }

    //
    // Finally, initialize the old list to empty.
    //
    
    InitializeListHead (OldListHead);
}



VOID
StorPurgeEventQueue(
    IN PSTOR_EVENT_QUEUE Queue,
    IN STOR_EVENT_QUEUE_PURGE_ROUTINE PurgeRoutine,
    IN PVOID Context
    )
/*++

Routine Description:

    Purge all outstanding requests from the pending queue.

Arguments:

    Queue - Queue to purge.

    PurgeRoutine - Callback routine called to purge an event.

    Context - Context for the purge routine.

Return Value:

    None.

Environment:

    Routine must be called from DISPATCH_LEVEL or below.

--*/
{
    KIRQL Irql;
    PLIST_ENTRY NextEntry;
    PSTOR_EVENT_QUEUE_ENTRY QueueEntry;

    ASSERT (KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT (PurgeRoutine != NULL);

    KeAcquireSpinLock (&Queue->Lock, &Irql);

    NextEntry = Queue->List.Flink;
    while (NextEntry != &Queue->List) {

        QueueEntry = CONTAINING_RECORD (NextEntry,
                                        STOR_EVENT_QUEUE_ENTRY,
                                        NextLink);

        NextEntry = NextEntry->Flink;
        
        PurgeRoutine (Queue,
                      Context,
                      QueueEntry,
                      StorRemoveEventQueueInternal);
    }

    KeReleaseSpinLock (&Queue->Lock, Irql);
        

#if 0
    ASSERT (KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT (PurgeRoutine != NULL);

    KeAcquireSpinLock (&Queue->Lock, &Irql);

    //
    // Copy the list head pointer from the old list to the new list and
    // fix it up.
    //

    CopyList (&ListHead, &Queue->List);

    //
    // The queue has been purged, so reset the timeout to QueueTimeoutNone.
    //
    
    Queue->Timeout = QueueTimeoutNone;

    KeReleaseSpinLock (&Queue->Lock, Irql);
    

    while (!IsListEmpty (&ListHead)) {

        NextEntry = RemoveHeadList (&ListHead);
    
        QueueEntry = CONTAINING_RECORD (NextEntry,
                                        STOR_EVENT_QUEUE_ENTRY,
                                        NextLink);

        //
        // NULL out the Flink and Blink so we know not to double remove
        // this element from the list.
        //
        
        QueueEntry->NextLink.Flink = NULL;
        QueueEntry->NextLink.Blink = NULL;

        PurgeRoutine (Queue, Context, QueueEntry);
    }
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\ext.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

	ext.h

Abstract:

	Extended typedef's that should be rolled back into wdm.h and
	ntddk.h.

Author:

	Matthew D Hendel (math) 21-Feb-2001

Revision History:

--*/
#pragma once

#define ULONG_MAX	(0xFFFFFFFFUL)

#if !defined(_AMD64_) && !defined(_IA64_)
#include "pshpack4.h"
#endif

#if defined(_WIN64)
#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)
#else
#define POINTER_ALIGNMENT
#endif


//
// Create parameter
//

typedef struct _IRP_STACK_CREATE {
	PIO_SECURITY_CONTEXT SecurityContext;
	ULONG Options;
	USHORT POINTER_ALIGNMENT FileAttributes;
	USHORT ShareAccess;
	ULONG POINTER_ALIGNMENT EaLength;
} IRP_STACK_CREATE, *PIRP_STACK_CREATE;


//
// Read parameter
//

typedef struct _IRP_STACK_READ {
	ULONG Length;
	ULONG POINTER_ALIGNMENT Key;
	LARGE_INTEGER ByteOffset;
} IRP_STACK_READ, *PIRP_STACK_READ;


//
// Write parameter
//

typedef struct _IRP_STACK_WRITE {
	ULONG Length;
	ULONG POINTER_ALIGNMENT Key;
	LARGE_INTEGER ByteOffset;
} IRP_STACK_WRITE, *PIRP_STACK_WRITE;


//
// QueryFile parameter
//

typedef struct _IRP_STACK_QUERY_FILE {
	ULONG Length;
	FILE_INFORMATION_CLASS POINTER_ALIGNMENT FileInformationClas;
} IRP_STACK_QUERY_FILE, *PIRP_STACK_QUERY_FILE;


//
// SetFile parameter
//

typedef struct _IRP_STACK_SET_FILE {
	ULONG Length;
	FILE_INFORMATION_CLASS POINTER_ALIGNMENT FileInformationClass;
	PFILE_OBJECT FileObject;
	union {
		struct {
			BOOLEAN ReplaceIfExists;
			BOOLEAN AdvanceOnly;
		};
		ULONG ClusterCount;
		HANDLE DeleteHandle;
	};
} IRP_STACK_SET_FILE, *PIRP_STACK_SET_FILE;


//
// QueryVolume parameter
//

typedef struct _IRP_STACK_QUERY_VOLUME {
	ULONG Length;
	FS_INFORMATION_CLASS POINTER_ALIGNMENT FsInformationClass;
} IRP_STACK_QUERY_VOLUME, *PIRP_STACK_QUERY_VOLUME;


//
// DeviceIoControl parameter
//

typedef struct _IRP_STACK_DEVICE_IO_CONTROL {
	ULONG OutputBufferLength;
	ULONG POINTER_ALIGNMENT InputBufferLength;
	ULONG POINTER_ALIGNMENT IoControlCode;
	PVOID Type3InputBuffer;
} IRP_STACK_DEVICE_IO_CONTROL, *PIRP_STACK_DEVICE_IO_CONTROL;


//
// MountVolume parameter
//

typedef struct _IRP_STACK_MOUNT_VOLUME {
	PVOID DoNotUse1;
	PDEVICE_OBJECT DeviceObject;
} IRP_STACK_MOUNT_VOLUME, *PIRP_STACK_MOUNT_VOLUME;


//
// VerifyVolume parameter
//

typedef struct _IRP_STACK_VERIFY_VOLUME {
	PVOID DoNotUse1;
	PDEVICE_OBJECT DeviceObject;
} IRP_STACK_VERIFY_VOLUME, *PIRP_STACK_VERIFY_VOLUME;


//
// Scsi Parameter
//

typedef struct _IRP_STACK_SCSI {
	struct _SCSI_REQUEST_BLOCK *Srb;
} IRP_STACK_SCSI, *PIRP_STACK_SCSI;


//
// QueryDeviceRelations parameter
//

typedef struct _IRP_STACK_QUERY_DEVICE_RELATIONS {
	DEVICE_RELATION_TYPE Type;
} IRP_STACK_QUERY_DEVICE_RELATIONS, *PIRP_STACK_QUERY_DEVICE_RELATIONS;


//
// QueryInterface parameter
//

typedef struct _IRP_STACK_QUERY_INTERFACE {
	CONST GUID *InterfaceType;
	USHORT Size;
	USHORT Version;
	PINTERFACE Interface;
	PVOID InterfaceSpecificData;
} IRP_STACK_QUERY_INTERFACE, *PIRP_STACK_QUERY_INTERFACE;


//
// DeviceCapabilities parameter
//

typedef struct _IRP_STACK_DEVICE_CAPABILITIES {
	PDEVICE_CAPABILITIES Capabilities;
} IRP_STACK_DEVICE_CAPABILITIES, *PIRP_STACK_DEVICE_CAPABILITIES;


//
// FilterResourceRequirements parameter
//

typedef struct _IRP_STACK_FILTER_RESOURCE_REQUIREMENTS {
	PIO_RESOURCE_REQUIREMENTS_LIST IoResourceRequirementList;
} IRP_STACK_FILTER_RESOURCE_REQUIREMENTS, *PIRP_STACK_FILTER_RESOURCE_REQUIREMENTS;


//
// ReadWriteConfig parameter
//

typedef struct _IRP_STACK_READ_WRITE_CONFIG {
	ULONG WhichSpace;
	PVOID Buffer;
	ULONG Offset;
	ULONG POINTER_ALIGNMENT Length;
} IRP_STACK_READ_WRITE_CONFIG, *PIRP_STACK_READ_WRITE_CONFIG;


//
// SetLock parameter
//

typedef struct _IRP_STACK_SET_LOCK {
	BOOLEAN Lock;
} IRP_STACK_SET_LOCK, *PIRP_STACK_SET_LOCK;


//
// QueryId parameter
//

typedef struct _IRP_STACK_QUERY_ID {
	BUS_QUERY_ID_TYPE IdType;
} IRP_STACK_QUERY_ID, *PIRP_STACK_QUERY_ID;


//
// QueryDeviceText parameter
//

typedef struct _IRP_STACK_QUERY_DEVICE_TEXT {
	DEVICE_TEXT_TYPE DeviceTextType;
	LCID POINTER_ALIGNMENT LocaleId;
} IRP_STACK_QUERY_DEVICE_TEXT, *PIRP_STACK_QUERY_DEVICE_TEXT;


//
// UsageNotification parameter
//

typedef struct _IRP_STACK_USAGE_NOTIFICATION {
	BOOLEAN InPath;
	BOOLEAN Reserved[3];
	DEVICE_USAGE_NOTIFICATION_TYPE POINTER_ALIGNMENT Type;
} IRP_STACK_USAGE_NOTIFICATION, *PIRP_STACK_USAGE_NOTIFICATION;

//
// WaitWake parameter
//

typedef struct _IRP_STACK_WAIT_WAKE {
	SYSTEM_POWER_STATE PowerState;
} IRP_STACK_WAIT_WAKE, *PIRP_STACK_WAIT_WAKE;


//
// PowerSequence parameter
//

typedef struct _IRP_STACK_POWER_SEQUENCE {
	PPOWER_SEQUENCE PowerSequence;
} IRP_STACK_POWER_SEQUENCE, *PIRP_STACK_POWER_SEQUENCE;


//
// Power parameter
//

typedef struct _IRP_STACK_POWER {
	ULONG SystemContext;
	POWER_STATE_TYPE POINTER_ALIGNMENT Type;
	POWER_STATE POINTER_ALIGNMENT State;
	POWER_ACTION POINTER_ALIGNMENT ShutdownType;
} IRP_STACK_POWER, *PIRP_STACK_POWER;


//
// StartDevice parameter
//

typedef struct _IRP_STACK_START_DEVICE {
	PCM_RESOURCE_LIST AllocatedResources;
	PCM_RESOURCE_LIST AllocatedResourcesTranslated;
} IRP_STACK_START_DEVICE, *PIRP_STACK_START_DEVICE;


//
// WMI parameter
//

typedef struct _IRP_STACK_WMI {
	ULONG_PTR ProviderId;
	PVOID DataPath;
	ULONG BufferSize;
	PVOID Buffer;
} IRP_STACK_WMI, *PIRP_STACK_WMI;


//
// Others parameter
//

typedef struct _IRP_STACK_OTHERS {
	PVOID Argument1;
	PVOID Argument2;
	PVOID Argument3;
	PVOID Argument4;
} IRP_STACK_OTHERS, *PIRP_STACK_OTHERS;



//
// The following macro verifies that a defined type is the same size
// as the on embedded in the IRP_STACK_LOCATION. This ensures that if
// somebody changes one, they have to change the other.
//

#define VERIFY_IRP_STACK_PARAMETER(TYPE, FIELD)\
	C_ASSERT (sizeof(TYPE) ==											\
			  sizeof (((PIO_STACK_LOCATION)NULL)->Parameters.FIELD))


//
// Verify all structures are proper size.
//

VERIFY_IRP_STACK_PARAMETER (IRP_STACK_CREATE, Create);
VERIFY_IRP_STACK_PARAMETER (IRP_STACK_READ, Read);
VERIFY_IRP_STACK_PARAMETER (IRP_STACK_QUERY_FILE, QueryFile);
VERIFY_IRP_STACK_PARAMETER (IRP_STACK_SET_FILE, SetFile);
VERIFY_IRP_STACK_PARAMETER (IRP_STACK_QUERY_VOLUME, QueryVolume);
VERIFY_IRP_STACK_PARAMETER (IRP_STACK_DEVICE_IO_CONTROL, DeviceIoControl);
VERIFY_IRP_STACK_PARAMETER (IRP_STACK_MOUNT_VOLUME, MountVolume);
VERIFY_IRP_STACK_PARAMETER (IRP_STACK_VERIFY_VOLUME, VerifyVolume);VERIFY_IRP_STACK_PARAMETER (IRP_STACK_SCSI, Scsi);
VERIFY_IRP_STACK_PARAMETER (IRP_STACK_QUERY_DEVICE_RELATIONS, QueryDeviceRelations);
VERIFY_IRP_STACK_PARAMETER (IRP_STACK_QUERY_INTERFACE, QueryInterface);
VERIFY_IRP_STACK_PARAMETER (IRP_STACK_DEVICE_CAPABILITIES, DeviceCapabilities);
VERIFY_IRP_STACK_PARAMETER (IRP_STACK_FILTER_RESOURCE_REQUIREMENTS, FilterResourceRequirements);
VERIFY_IRP_STACK_PARAMETER (IRP_STACK_READ_WRITE_CONFIG, ReadWriteConfig);
VERIFY_IRP_STACK_PARAMETER (IRP_STACK_QUERY_ID, QueryId);
VERIFY_IRP_STACK_PARAMETER (IRP_STACK_QUERY_DEVICE_TEXT, QueryDeviceText);
VERIFY_IRP_STACK_PARAMETER (IRP_STACK_USAGE_NOTIFICATION, UsageNotification);
VERIFY_IRP_STACK_PARAMETER (IRP_STACK_WAIT_WAKE, WaitWake);
VERIFY_IRP_STACK_PARAMETER (IRP_STACK_POWER_SEQUENCE, PowerSequence);
VERIFY_IRP_STACK_PARAMETER (IRP_STACK_POWER, Power);
VERIFY_IRP_STACK_PARAMETER (IRP_STACK_START_DEVICE, StartDevice);
VERIFY_IRP_STACK_PARAMETER (IRP_STACK_WMI, WMI);
VERIFY_IRP_STACK_PARAMETER (IRP_STACK_OTHERS, Others);

#undef VERIFY_IRP_STACK_PARAMETER

#if !defined(_AMD64_) && !defined(_IA64_)
#include "poppack.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\global.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    global.c

Abstract:

    Global data and functions to operate on global data for the raid port
    driver.

Author:

    Matthew D Hendel (math) 07-Apri-2000

Revision History:

--*/

#include "precomp.h"

//
// Initialize pre-defined GUIDs.
//

#include <initguid.h>
#include <devguid.h>
#include <ntddstor.h>
#include <wdmguid.h>


#ifdef ALLOC_PRAGMA
#endif // ALLOC_PRAGMA

//
// Global data
//

PRAID_PORT_DATA RaidpPortData = NULL;

#if DBG
ULONG TestRaidPort = TRUE;
#endif

//
// In low resource conditions, it's possible to generate errors that cannot
// be successfully logged. In these cases, increment a counter of errors
// that we've dropped.
//

LONG RaidUnloggedErrors = 0;



#if defined (RAID_LOG_LIST_SIZE)

//
// Event log of interesting events. 
//

ULONG RaidLogListIndex = -1;
ULONG RaidLogListSize = RAID_LOG_LIST_SIZE;
RAID_LOG_ENTRY RaidLogList[RAID_LOG_LIST_SIZE];

#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    return STATUS_SUCCESS;
}


ULONG
StorPortInitialize(
    IN PVOID Argument1,
    IN PVOID Argument2,
    IN PHW_INITIALIZATION_DATA HwInitializationData,
    IN PVOID HwContext OPTIONAL
    )
/*++

Routine Description:

    This routine initializes the raid port driver.

Arguments:

    Argument1 - DriverObject passed into the Miniport's DriverEntry
            routine.

    Argument2 - RegistryPath parameters passed into the Miniport's
            DriverEntry routine.

    HwInitializationData - Miniport initialization structure.

    HwContext -
    
Return Value:

    NTSTATUS code.

--*/
{
    ULONG Status;
    PDRIVER_OBJECT DriverObject;
    PUNICODE_STRING RegistryPath;
    PRAID_DRIVER_EXTENSION Driver;
    PRAID_PORT_DATA PortData;

    PAGED_CODE ();

    Driver = NULL;


#if DBG
    if (TestRaidPort == 0) {
        TestRaidPort = -1;
        KdBreakPoint();
    }
    
    if (TestRaidPort != 1) {
        return STATUS_UNSUCCESSFUL;
    }

#endif

    //
    // Initialize the DPFLTR stuff.
    //
    
    StorSetDebugPrefixAndId ("STOR: ", DPFLTR_STORPORT_ID);
    
    DebugTrace (("RaidPortInitialize: %p %p %p %p\n",
                  Argument1,
                  Argument2,
                  HwInitializationData,
                  HwContext));


    DriverObject = Argument1;
    RegistryPath = Argument2;

    //
    // We require Argument1, Argument2 and HwInitializeData to be correct.
    //
    
    if (DriverObject == NULL ||
        RegistryPath == NULL ||
        HwInitializationData == NULL) {
        
        return STATUS_INVALID_PARAMETER;
    }

    if (HwInitializationData->HwInitializationDataSize > sizeof (HW_INITIALIZATION_DATA)) {
        return STATUS_REVISION_MISMATCH;
    }

    if (HwInitializationData->HwInitialize == NULL ||
        HwInitializationData->HwFindAdapter == NULL ||
        HwInitializationData->HwStartIo == NULL ||
        HwInitializationData->HwResetBus == NULL) {

        return STATUS_REVISION_MISMATCH;
    }

    //
    // Do driver global initialization.
    //
    
    PortData = RaidGetPortData ();

    if (PortData == NULL) {
        return STATUS_NO_MEMORY;
    }

    //
    // Allocate the Driver Extension, if necessary.
    //

    Driver = IoGetDriverObjectExtension (DriverObject, DriverEntry);

    if (Driver == NULL) {

        Status = IoAllocateDriverObjectExtension (DriverObject,
                                                  DriverEntry,
                                                  sizeof (*Driver),
                                                  &Driver);
        if (!NT_SUCCESS (Status)) {
            goto done;
        }

        RaCreateDriver (Driver);
        Status = RaInitializeDriver (Driver,
                                     DriverObject,
                                     PortData,
                                     RegistryPath);

        if (!NT_SUCCESS (Status)) {
            goto done;
        }

    } else {

        //
        // In a checked build, sanity check that we actually got the correct
        // driver.
        //
        
        ASSERT (Driver->ObjectType == RaidDriverObject);
        ASSERT (Driver->DriverObject == DriverObject);
        Status = STATUS_SUCCESS;
    }
    
    //
    // We need the HwInitializationData for the IRP_MJ_PNP routines. Store
    // it for later use.
    //

    Status = RaSaveDriverInitData (Driver, HwInitializationData);

done:

    if (!NT_SUCCESS (Status)) {

        //
        // Delete any resources associated with the driver.
        //

        if (Driver != NULL) {
            RaDeleteDriver (Driver);
        }

        //
        // There is no need (or way) to delete the memory consumed by
        // the driver extension. This will be done for us by IO manager
        // when the driver is unloaded.
        //

        Driver = NULL;
    }

    return Status;
}

//
// Functions on raid global data structurs.
//

PRAID_PORT_DATA
RaidGetPortData(
    )
/*++

Routine Description:

    Create a RAID_PORT_DATA object if one has not already been created,
    and return a referenced pointer to the port data object.

Arguments:

    None.

Return Value:

    Pointer to a referenced RAID_PORT_DATA structure on success, NULL on
    failure.

--*/

{
    NTSTATUS Status;
    PRAID_PORT_DATA PortData;
    
    PAGED_CODE ();

    //
    // NOTE: This will not work if we support multiple drivers initializing at one time.
    //
    
    if (RaidpPortData == NULL) {
        PortData = ExAllocatePoolWithTag (NonPagedPool,
                                          sizeof (RAID_PORT_DATA),
                                          PORT_DATA_TAG);
        if (PortData == NULL) {
            return NULL;
        }
        
        //
        // Initilize the adapter list, the adapter list spinlock
        // and the adapter list count.
        //

        InitializeListHead (&PortData->DriverList.List);
        KeInitializeSpinLock (&PortData->DriverList.Lock);
        PortData->DriverList.Count = 0;
        PortData->ReferenceCount = 1;

        ASSERT (RaidpPortData == NULL);
        RaidpPortData = PortData;
    } else {
        InterlockedIncrement (&RaidpPortData->ReferenceCount);
    }

    return RaidpPortData;
}

VOID
RaidReleasePortData(
    IN PRAID_PORT_DATA PortData
    )
{
    LONG Count;
    
    Count = InterlockedDecrement (&PortData->ReferenceCount);
    ASSERT (Count >= 0);

    ASSERT (RaidpPortData == PortData);
    
    if (Count == 0) {

        RaidpPortData = NULL;
        
        //
        // Refcount is zero: delete the port data object.
        //

        //
        // All driver's should have been removed from the driver
        // list before deleting the port data.
        //
        
        ASSERT (PortData->DriverList.Count == 0);
        ASSERT (IsListEmpty (&PortData->DriverList.List));

        DbgFillMemory (PortData, sizeof (*PortData), DBG_DEALLOCATED_FILL);
        ExFreePoolWithTag (PortData, PORT_DATA_TAG);
    }
}

NTSTATUS
RaidAddPortDriver(
    IN PRAID_PORT_DATA PortData,
    IN PRAID_DRIVER_EXTENSION Driver
    )
{
    KLOCK_QUEUE_HANDLE LockHandle;
    
    KeAcquireInStackQueuedSpinLock (&PortData->DriverList.Lock, &LockHandle);

#if DBG

    //
    // Check that this driver isn't already on the driver list.
    //

    {
        PLIST_ENTRY NextEntry;
        PRAID_DRIVER_EXTENSION TempDriver;

        for ( NextEntry = PortData->DriverList.List.Flink;
              NextEntry != &PortData->DriverList.List;
              NextEntry = NextEntry->Flink ) {

            TempDriver = CONTAINING_RECORD (NextEntry,
                                            RAID_DRIVER_EXTENSION,
                                            DriverLink);

            ASSERT (TempDriver != Driver);
        }
    }
#endif

    InsertHeadList (&PortData->DriverList.List, &Driver->DriverLink);
    (PortData->DriverList.Count)++;

    KeReleaseInStackQueuedSpinLock (&LockHandle);

    return STATUS_SUCCESS;
}

NTSTATUS
RaidRemovePortDriver(
    IN PRAID_PORT_DATA PortData,
    IN PRAID_DRIVER_EXTENSION Driver
    )
{
    KLOCK_QUEUE_HANDLE LockHandle;

    KeAcquireInStackQueuedSpinLock (&PortData->DriverList.Lock, &LockHandle);
    RemoveEntryList (&Driver->DriverLink);
    (PortData->DriverList.Count)--;
    KeReleaseInStackQueuedSpinLock (&LockHandle);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\global.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

	global.h

Abstract:

	Definitions and prototypes for the RAID_GLOBAL object.

Author:

	Matthew D Hendel (math) 19-Apr-2000

Revision History:

--*/

#pragma once


typedef struct _RAID_PORT_DATA {

	//
	// Refernece count for the global data object.
	//
	
	ULONG ReferenceCount;

	//
	// List of all drivers using raid port driver.
	//

	struct {
	
		LIST_ENTRY List;

		//
		// Spinlock for the driver list.
		//
	
		KSPIN_LOCK Lock;

		//
		// Count of items on the driver list.
		//
	
		ULONG Count;

	} DriverList;

} RAID_PORT_DATA, *PRAID_PORT_DATA;
    
    

//
// Public Functions
//

PRAID_PORT_DATA
RaidGetPortData(
	);

VOID
RaidReleasePortData(
	IN OUT PRAID_PORT_DATA PortData
	);

NTSTATUS
RaidAddPortDriver(
	IN PRAID_PORT_DATA PortData,
	IN PRAID_DRIVER_EXTENSION Driver
	);

NTSTATUS
RaidRemovePortDriver(
	IN PRAID_PORT_DATA PortData,
	IN PRAID_DRIVER_EXTENSION Driver
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\id.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    Id.h

Abstract:

    Data structures and functions related to STOR identification.

Author:

    Matthew D Hendel (math) 11-May-2001

Revision History:

--*/

#pragma once

typedef struct _STOR_SCSI_ADDRESS {
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    UCHAR Reserved;
} STOR_SCSI_ADDRESS, *PSTOR_SCSI_ADDRESS;

//
// Typedef's for older implementations
//

typedef STOR_SCSI_ADDRESS RAID_ADDRESS;
typedef PSTOR_SCSI_ADDRESS PRAID_ADDRESS;

extern const RAID_ADDRESS RaidNullAddress;

LONG
INLINE
StorScsiAddressToLong(
    IN STOR_SCSI_ADDRESS Address
    )
{
    return (Address.PathId << 16 | Address.TargetId << 8 | Address.Lun);
}

LONG
INLINE
StorScsiAddressToLong2(
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun
    )
{
    return ((PathId << 16) | (TargetId << 8) | Lun);
}


VOID
INLINE
StorLongToScsiAddress(
    IN LONG Address,
    IN PSTOR_SCSI_ADDRESS ScsiAddress
    )
{
    ScsiAddress->PathId = (UCHAR)(Address >> 16);
    ScsiAddress->TargetId = (UCHAR)(Address >> 8);
    ScsiAddress->Lun = (UCHAR)Address;
}

VOID
INLINE
StorLongToScsiAddress2(
    IN LONG Address,
    IN PUCHAR PathId,
    IN PUCHAR TargetId,
    IN PUCHAR Lun
    )
{
    *PathId = (UCHAR)(Address >> 16);
    *TargetId = (UCHAR)(Address >> 8);
    *Lun = (UCHAR)Address;
}

PVOID
INLINE
RaidAddressToKey(
    IN RAID_ADDRESS Address
    )
{
    return (PVOID)(LONG_PTR)(StorScsiAddressToLong (Address));
}



LONG
INLINE
StorCompareScsiAddress(
    IN STOR_SCSI_ADDRESS Address1,
    IN STOR_SCSI_ADDRESS Address2
    )
{
    LONG Key1;
    LONG Key2;

    Key1 = StorScsiAddressToLong (Address1);
    Key2 = StorScsiAddressToLong (Address2);

    return (Key1 - Key2);
}


UCHAR
INLINE
StorGetAddressPathId(
    IN STOR_SCSI_ADDRESS Address
    )
{
    return Address.PathId;
}

UCHAR
INLINE
StorGetAddressTargetId(
    IN STOR_SCSI_ADDRESS Address
    )
{
    return Address.TargetId;
}

UCHAR
INLINE
StorGetAddressLun(
    IN STOR_SCSI_ADDRESS Address
    )
{
    return Address.Lun;
}



//
// Device Identity
//

typedef struct _STOR_SCSI_IDENTITY {
    PINQUIRYDATA InquiryData;
    ANSI_STRING SerialNumber;
    PVPD_IDENTIFICATION_PAGE DeviceId;
} STOR_SCSI_IDENTITY, *PSTOR_SCSI_IDENTITY;



NTSTATUS
INLINE
StorCreateScsiIdentity(
    IN PSTOR_SCSI_IDENTITY Identity,
    IN POOL_TYPE PoolType,
    IN PINQUIRYDATA InquiryData,
    IN PVPD_IDENTIFICATION_PAGE DeviceId,
    IN PVPD_SERIAL_NUMBER_PAGE SerialNumber,
    IN PDEVICE_OBJECT DeviceObject
    )
{
    NTSTATUS Status;
    
    ASSERT (Identity != NULL);

    RtlZeroMemory (Identity, sizeof (STOR_SCSI_IDENTITY));
    
    if (InquiryData != NULL) {
        Identity->InquiryData = RaidAllocatePool (PoolType,
                                                  INQUIRYDATABUFFERSIZE,
                                                  INQUIRY_TAG,
                                                  DeviceObject);
        RtlCopyMemory (Identity->InquiryData,
                       InquiryData,
                       INQUIRYDATABUFFERSIZE);
    }

    if (DeviceId != NULL) {
        Identity->DeviceId = RaidAllocatePool (PoolType,
                                               DeviceId->PageLength,
                                               INQUIRY_TAG,
                                               DeviceObject);
        RtlCopyMemory (Identity->DeviceId,
                       DeviceId,
                       DeviceId->PageLength);
    }

    if (SerialNumber != NULL) {
        Status = StorCreateAnsiString (&Identity->SerialNumber,
                                       SerialNumber->SerialNumber,
                                       SerialNumber->PageLength,
                                       NonPagedPool,            //??
                                       DeviceObject);
        if (!NT_SUCCESS (Status)) {
            return Status;
        }
    }

    return STATUS_SUCCESS;
}



VOID
INLINE
StorDeleteScsiIdentity(
    IN PSTOR_SCSI_IDENTITY Identity
    )
{
    if (Identity->InquiryData != NULL) {
        DbgFillMemory (Identity->InquiryData,
                       DBG_DEALLOCATED_FILL,
                       INQUIRYDATABUFFERSIZE);
        RaidFreePool (Identity->InquiryData, INQUIRY_TAG);
    }

    StorFreeAnsiString (&Identity->SerialNumber);

    if (Identity->DeviceId) {
        DbgFillMemory (Identity->DeviceId,
                       DBG_DEALLOCATED_FILL,
                       sizeof (*Identity->DeviceId));
        RaidFreePool (Identity->DeviceId, INQUIRY_TAG);
    }

    RtlZeroMemory (Identity, sizeof (STOR_SCSI_IDENTITY));
}


LONG
INLINE
StorCompareScsiDeviceId(
    IN PVPD_IDENTIFICATION_PAGE DeviceId1,
    IN PVPD_IDENTIFICATION_PAGE DeviceId2
    )
/*++

Routine Description:

    If DeviceId1 < DeviceId2, return < 0
    If DeviceId1 > DeviceId2, return > 0
    If DeviceId2 == DeviceId2, return 0

    Note: this is a dictionary ordering. Therefore, if the device IDs
    match up to the length of the smaller (shorter) device ID, the
    larger (longer) device ID is considered larger. See below.

    (empty)
    "foo"
    "foolish"
    "foolishness"

Arguments:

    DeviceId1 - First device ID for comparison.

    DeviceId2 - Second device ID for comparison.

Return Value:

    NTSTATUS code.

--*/
{
    ULONG Length;
    LONG Comparison;

    PAGED_CODE();

    //
    // Preserve dictionary order in the presence of NULL device IDs.
    //
    
    if (DeviceId1 == NULL && DeviceId2 == NULL) {
        return 0;
    } else if (DeviceId1 == NULL) {
        return -1;
    } else if (DeviceId2 == NULL) {
        return 1;
    }
    
    ASSERT (DeviceId1->PageCode == 0x83);
    ASSERT (DeviceId2->PageCode == 0x83);

    //
    // NB: This comparison tacitly assumes that the device IDs will not
    // for a specific device will not change at all over time, including
    // changes in the ordering that multiple device IDs are returned.
    // Presumably, there is some device that will not follow this model.
    //

    Length = min (DeviceId1->PageLength, DeviceId1->PageLength);

    Comparison = memcmp (DeviceId1, DeviceId2, Length);

    //
    // If they were equal, then the longer one is by definition "greater".
    //
    
    if (Comparison == 0) {
        if (DeviceId1->PageLength > DeviceId2->PageLength) {
            Comparison = 1;
        } else if (DeviceId1->PageLength < DeviceId2->PageLength) {
            Comparison = -1;
        }
    }

    return Comparison;
}


//
// COMPARE_INQUIRY_FIELDS doesn't compare the SIP-specific fields, or
// the Peripheral Qualifier field.
//

#define COMPARE_INQUIRY_FIELDS(InquiryData, InquiryData2, OP)\
   (InquiryData->DeviceType         OP  InquiryData2->DeviceType          && \
    InquiryData->ANSIVersion        OP  InquiryData2->ANSIVersion         && \
    InquiryData->ResponseDataFormat OP  InquiryData2->ResponseDataFormat  && \
    InquiryData->HiSupport          OP  InquiryData2->HiSupport           && \
    InquiryData->NormACA            OP  InquiryData2->NormACA             && \
    InquiryData->TerminateTask      OP  InquiryData2->TerminateTask       && \
    InquiryData->AERC               OP  InquiryData2->AERC                && \
    InquiryData->MediumChanger      OP  InquiryData2->MediumChanger       && \
    InquiryData->MultiPort          OP  InquiryData2->MultiPort           && \
    InquiryData->EnclosureServices  OP  InquiryData2->EnclosureServices   && \
    InquiryData->SoftReset          OP  InquiryData2->SoftReset           && \
    InquiryData->CommandQueue       OP  InquiryData2->CommandQueue        && \
    InquiryData->LinkedCommands     OP  InquiryData2->LinkedCommands      && \
    InquiryData->RelativeAddressing OP  InquiryData2->RelativeAddressing  && \
    memcmp (InquiryData->VendorId,   InquiryData2->VendorId, 8)  OP 0     && \
    memcmp (InquiryData->ProductId,  InquiryData2->ProductId, 6) OP 0     && \
    memcmp (InquiryData->ProductRevisionLevel,                               \
            InquiryData2->ProductRevisionLevel, 4)               OP 0)


LONG
INLINE
StorCompareInquiryData(
    IN PINQUIRYDATA InquiryData,
    IN PINQUIRYDATA InquiryData2
    )
{
    LONG Comparison;

    //
    // This is really grungy, but it does work correctly.
    //
    
    if (COMPARE_INQUIRY_FIELDS (InquiryData, InquiryData2, <)) {
        Comparison = -1;
    } else if (COMPARE_INQUIRY_FIELDS (InquiryData, InquiryData2, >)) {
        Comparison = 1;
    } else {
        Comparison = 0;
    }

    return Comparison;
}
    

LONG
INLINE
StorCompareScsiIdentity(
    IN PSTOR_SCSI_IDENTITY Identity1,
    IN PSTOR_SCSI_IDENTITY Identity2
    )
{
    LONG Comparison;

    //
    // The peripherial qualifier can change without the device changing,
    // so don't include it in the comparison. This is why we do this clumsy
    // two part comparison below.
    //
    
    Comparison = memcmp (((PUCHAR)Identity1->InquiryData) + 1,
                         ((PUCHAR)Identity2->InquiryData) + 1,
                         INQUIRYDATABUFFERSIZE-1);

    if (Comparison != 0) {
        return Comparison;
    }
    
    Comparison = Identity1->InquiryData->DeviceType -
                 Identity2->InquiryData->DeviceType;
                 
    if (Comparison != 0) {
        return Comparison;
    }
    
    Comparison = RtlCompareString (&Identity1->SerialNumber,
                                   &Identity2->SerialNumber,
                                   FALSE);
    if (Comparison != 0) {
        return Comparison;
    }

    Comparison = StorCompareScsiDeviceId (Identity1->DeviceId,
                                          Identity2->DeviceId);

    return Comparison;
}


PCSCSI_DEVICE_TYPE
INLINE
StorGetIdentityDeviceType(
    IN PSTOR_SCSI_IDENTITY Identity
    )
{
    PINQUIRYDATA InquiryData;
    
    InquiryData = Identity->InquiryData;
    ASSERT (InquiryData != NULL);
    return PortGetDeviceType (InquiryData->DeviceType);
}



NTSTATUS
INLINE
StorGetIdentityVendorId(
    IN PSTOR_SCSI_IDENTITY Identity,
    IN OUT PCHAR VendorId,
    IN ULONG VendorIdLength,
    IN LOGICAL TruncatePadding
    )
{
    ULONG Length;
    PINQUIRYDATA InquiryData;

    InquiryData = Identity->InquiryData;
    ASSERT (InquiryData != NULL);
    
    Length = min (VendorIdLength, sizeof (InquiryData->VendorId));

    if (TruncatePadding) {
        RaCopyPaddedString (VendorId,
                            VendorIdLength,
                            InquiryData->VendorId,
                            sizeof (InquiryData->VendorId));
    } else {

        RtlCopyMemory (VendorId,
                       InquiryData->VendorId,
                       Length);
    }

    return STATUS_SUCCESS;
}

    
NTSTATUS
INLINE
StorGetIdentityProductId(
    IN PSTOR_SCSI_IDENTITY Identity,
    IN OUT PCHAR ProductId,
    IN ULONG ProductIdLength,
    IN LOGICAL TruncatePadding
    )
{
    ULONG Length;
    PINQUIRYDATA InquiryData;

    InquiryData = Identity->InquiryData;
    ASSERT (InquiryData != NULL);
    
    Length = min (ProductIdLength, sizeof (InquiryData->ProductId));

    if (TruncatePadding) {
        RaCopyPaddedString (ProductId,
                            ProductIdLength,
                            InquiryData->ProductId,
                            sizeof (InquiryData->ProductId));
    } else {

        RtlCopyMemory (ProductId,
                       InquiryData->ProductId,
                       Length);
    }

    return STATUS_SUCCESS;
}

    
NTSTATUS
INLINE
StorGetIdentityRevision(
    IN PSTOR_SCSI_IDENTITY Identity,
    IN OUT PCHAR Revision,
    IN ULONG RevisionLength,
    IN LOGICAL TruncatePadding
    )
{
    ULONG Length;
    PINQUIRYDATA InquiryData;

    InquiryData = Identity->InquiryData;
    ASSERT (InquiryData != NULL);
    
    Length = min (RevisionLength, sizeof (InquiryData->ProductRevisionLevel));

    if (TruncatePadding) {
        RaCopyPaddedString (Revision,
                            RevisionLength,
                            InquiryData->ProductRevisionLevel,
                            sizeof (InquiryData->ProductRevisionLevel));
    } else {

        RtlCopyMemory (Revision,
                       InquiryData->ProductRevisionLevel,
                       Length);
    }

    return STATUS_SUCCESS;
}

PINQUIRYDATA
INLINE
StorGetIdentityInquiryData(
    IN PSTOR_SCSI_IDENTITY Identity
    )
{
    ASSERT (Identity->InquiryData != NULL);
    return Identity->InquiryData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\inline.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    inline.h

Abstract:

    Implementations of inline functions for RAID port driver.

Author:

    Matthew D Hendel (math) 08-June-2000

Revision History:

--*/

#pragma once



//
// Trace logging
//

//
// Enum defs need to be present in both CHK and FRE builds, even though
// trace logging is not present in FRE builds.
//

typedef enum _DBG_LOG_REASON {
    LogCallMiniport       = 0, // Calling into miniport with request
    LogMiniportCompletion = 1, // Miniport called StorPortNotificaiton / RequestComplete
    LogRequestComplete    = 2, // Port driver is completing request
    LogSubmitRequest      = 3, // Enter into storport with the request

    LogPauseDevice        = 4, // Logical unit has been paused
    LogResumeDevice       = 5, // Logical unit has been resumed
    LogPauseAdapter       = 6, // Adapter has been paused
    LogResumeAdapter      = 7  // Adapter has been resumed
} DBG_LOG_REASON;

#if defined (RAID_LOG_LIST_SIZE)

typedef struct _RAID_LOG_ENTRY {
    DBG_LOG_REASON Reason;
    PVOID Parameter1;
    PVOID Parameter2;
    PVOID Parameter3;
    PVOID Parameter4;
    LARGE_INTEGER Timestamp;
} RAID_LOG_ENTRY, *PRAID_LOG_ENTRY;

extern RAID_LOG_ENTRY RaidLogList[RAID_LOG_LIST_SIZE];
extern ULONG RaidLogListIndex;

VOID
INLINE
DbgLogRequest(
    IN ULONG Reason,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3,
    IN PVOID Parameter4
    )
{
    PRAID_LOG_ENTRY LogEntry;
    LONG Index;

//
//BUGUBG: for now only track pauses and resumes.
if (Reason == LogCallMiniport ||
    Reason == LogMiniportCompletion ||
    Reason == LogRequestComplete ||
    Reason == LogSubmitRequest) {

    return ;
}

    Index = (InterlockedIncrement (&RaidLogListIndex) % RAID_LOG_LIST_SIZE);
    LogEntry = &RaidLogList[Index];

    LogEntry->Reason = Reason;
    KeQuerySystemTime (&LogEntry->Timestamp);
    LogEntry->Parameter1 = Parameter1;
    LogEntry->Parameter2 = Parameter2;
    LogEntry->Parameter3 = Parameter3;
    LogEntry->Parameter4 = Parameter4;

}

LONG
INLINE
DbgGetAddressLongFromXrb(
    IN PEXTENDED_REQUEST_BLOCK Xrb
    )
{
    PRAID_UNIT_EXTENSION Unit;
    
    if (Xrb->Unit == NULL) {
        return 0;
    }

    Unit = Xrb->Unit;
    return (StorScsiAddressToLong (Unit->Address));
}

#else // !RAID_LOG_LIST_SIZE

VOID
FORCEINLINE
DbgLogRequest(
    IN ULONG Reason,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3,
    IN PVOID Parameter4
    )
{
    UNREFERENCED_PARAMETER (Reason);
    UNREFERENCED_PARAMETER (Parameter1);
    UNREFERENCED_PARAMETER (Parameter2);
    UNREFERENCED_PARAMETER (Parameter3);
    UNREFERENCED_PARAMETER (Parameter4);
}

LONG
FORCEINLINE
DbgGetAddressLongFromXrb(
    IN PEXTENDED_REQUEST_BLOCK Xrb
    )
{
    UNREFERENCED_PARAMETER (Xrb);
    return 0;
}
#endif



//
// Structure for acquiring the StartIo lock. In half-duplex mode acquiring
// the StartIo lock -> acuqiring the interrupt lock. In full-duplex mode,
// acquiring the StartIo lock -> acquiring a simple spinlock.
//

typedef union _LOCK_CONTEXT {
    KLOCK_QUEUE_HANDLE LockHandle;
    KIRQL OldIrql;
} LOCK_CONTEXT, *PLOCK_CONTEXT;



//
// Functions for the RAID_FIXED_POOL object.
// 

//
// NB: We should modify the fixed pool to detect overruns and underruns
// in checked builds.
//

VOID
INLINE
RaidInitializeFixedPool(
    OUT PRAID_FIXED_POOL Pool,
    IN PVOID Buffer,
    IN ULONG NumberOfElements,
    IN SIZE_T SizeOfElement
    )
{
    PAGED_CODE ();

    ASSERT (Buffer != NULL);
    
    DbgFillMemory (Buffer,
                   SizeOfElement * NumberOfElements,
                   DBG_DEALLOCATED_FILL);
    Pool->Buffer = Buffer;
    Pool->NumberOfElements = NumberOfElements;
    Pool->SizeOfElement = SizeOfElement;
}

VOID
INLINE
RaidDeleteFixedPool(
    IN PRAID_FIXED_POOL Pool
    )
{
    //
    // The caller is responsible for deleting the memory in the pool, hence
    // this routine is a noop.
    //
}


PVOID
INLINE
RaidGetFixedPoolElement(
    IN PRAID_FIXED_POOL Pool,
    IN ULONG Index
    )
{
    PVOID Element;

    ASSERT (Index < Pool->NumberOfElements);
    Element = (((PUCHAR)Pool->Buffer) + Index * Pool->SizeOfElement);

    return Element;
}


PVOID
INLINE
RaidAllocateFixedPoolElement(
    IN PRAID_FIXED_POOL Pool,
    IN ULONG Index
    )
{
    PVOID Element;

    Element = RaidGetFixedPoolElement (Pool, Index);
    ASSERT (*(PUCHAR)Element == DBG_DEALLOCATED_FILL);
    DbgFillMemory (Element,
                   Pool->SizeOfElement,
                   DBG_UNINITIALIZED_FILL);

    return Element;
}

VOID
INLINE
RaidFreeFixedPoolElement(
    IN PRAID_FIXED_POOL Pool,
    IN ULONG Index
    )
{
    PUCHAR Element;
    
    Element = (((PUCHAR)Pool->Buffer) + Index * Pool->SizeOfElement);
    
    DbgFillMemory (Element,
                   Pool->SizeOfElement,
                   DBG_DEALLOCATED_FILL);
}



//
// Operations for the adapter object.
//

ULONG
INLINE
RiGetNumberOfBuses(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
{
    ULONG BusCount;
    
    ASSERT (Adapter != NULL);
    BusCount = Adapter->Miniport.PortConfiguration.NumberOfBuses;

    ASSERT (BusCount <= 255);
    return BusCount;
}

ULONG
INLINE
RaGetSrbExtensionSize(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
{
    ASSERT (Adapter != NULL);

    //
    // Force Srb extension alignment to 64KB boundaries.
    //
    
    return ALIGN_UP (Adapter->Miniport.PortConfiguration.SrbExtensionSize,
                     LONGLONG);
}

ULONG
INLINE
RiGetMaximumTargetId(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
{
    ASSERT (Adapter != NULL);
    return Adapter->Miniport.PortConfiguration.MaximumNumberOfTargets;
}

ULONG
INLINE
RiGetMaximumLun(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
{
    ASSERT (Adapter != NULL);
    return Adapter->Miniport.PortConfiguration.MaximumNumberOfLogicalUnits;
}

HANDLE
INLINE
RaidAdapterGetBusKey(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN ULONG BusId
    )
{
    ASSERT (Adapter != NULL);
    ASSERT (BusId < ARRAY_COUNT (Adapter->BusKeyArray));
    return Adapter->BusKeyArray [BusId];
}

VOID
INLINE
RaidAdapterEnableInterrupts(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
{
    ASSERT_ADAPTER (Adapter);
    Adapter->Flags.InterruptsEnabled = TRUE;
}

VOID
INLINE
RaidAdapterDisableInterrupts(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
{
    ASSERT_ADAPTER (Adapter);
    Adapter->Flags.InterruptsEnabled = FALSE;
}

LOGICAL
INLINE
RaidAdapterQueryInterruptsEnabled(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
{
    ASSERT_ADAPTER (Adapter);
    return (LOGICAL)Adapter->Flags.InterruptsEnabled;
}

PPORT_CONFIGURATION_INFORMATION
INLINE
RaidGetPortConfigurationInformation(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
{
    return (&Adapter->Miniport.PortConfiguration);
}

UCHAR
INLINE
RaidAdapterGetInitiatorBusId(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN UCHAR BusId
    )
{
    PPORT_CONFIGURATION_INFORMATION Config;
    
    ASSERT (BusId < SCSI_MAXIMUM_BUSES);

    Config = RaidGetPortConfigurationInformation (Adapter);
    return Config->InitiatorBusId[ BusId ];
}

VOID
INLINE
RaidAcquireUnitListLock(
    IN PRAID_UNIT_LIST UnitList,
    IN PLOCK_CONTEXT LockContext
    )
{
    KeAcquireInStackQueuedSpinLock (&UnitList->Lock, &LockContext->LockHandle);
}

VOID
INLINE
RaidReleaseUnitListLock(
    IN PRAID_UNIT_LIST UnitList,
    IN PLOCK_CONTEXT LockContext
    )
{
    KeReleaseInStackQueuedSpinLock (&LockContext->LockHandle);
}
    

//
// Inline functions for the RAID_MINIPORT object.
//


PRAID_ADAPTER_EXTENSION
INLINE
RaMiniportGetAdapter(
    IN PRAID_MINIPORT Miniport
    )
{
    ASSERT (Miniport != NULL);
    return Miniport->Adapter;
}


BOOLEAN
INLINE
RaCallMiniportStartIo(
    IN PRAID_MINIPORT Miniport,
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    BOOLEAN Succ;
    
    ASSERT (Miniport != NULL);
    ASSERT (Srb != NULL);
    ASSERT (Miniport->HwInitializationData != NULL);
    ASSERT (Miniport->HwInitializationData->HwStartIo != NULL);

    ASSERT_XRB (Srb->OriginalRequest);

    Succ = Miniport->HwInitializationData->HwStartIo(
                &Miniport->PrivateDeviceExt->HwDeviceExtension,
                Srb);

    return Succ;
}

BOOLEAN
INLINE
RaCallMiniportBuildIo(
    IN PRAID_MINIPORT Miniport,
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    BOOLEAN Succ;
    
    ASSERT_XRB (Srb->OriginalRequest);
    ASSERT (Miniport->HwInitializationData != NULL);

    //
    // If a HwBuildIo routine is present, call into it, otherwise,
    // vacuously return success.
    //
    
    if (Miniport->HwInitializationData->HwBuildIo) {
        Succ = Miniport->HwInitializationData->HwBuildIo (
                    &Miniport->PrivateDeviceExt->HwDeviceExtension,
                    Srb);
    } else {
        Succ = TRUE;
    }

    return Succ;
}
                

BOOLEAN
INLINE
RaCallMiniportInterrupt(
    IN PRAID_MINIPORT Miniport
    )
{
    BOOLEAN Succ;
    
    ASSERT (Miniport != NULL);
    ASSERT (Miniport->HwInitializationData != NULL);
    ASSERT (Miniport->HwInitializationData->HwInterrupt != NULL);
    
    Succ = Miniport->HwInitializationData->HwInterrupt (
                &Miniport->PrivateDeviceExt->HwDeviceExtension);

    return Succ;

}

NTSTATUS
INLINE
RaCallMiniportHwInitialize(
    IN PRAID_MINIPORT Miniport
    )
{
    BOOLEAN Succ;
    PHW_INITIALIZE HwInitialize;

    ASSERT (Miniport != NULL);
    ASSERT (Miniport->HwInitializationData != NULL);
    
    HwInitialize = Miniport->HwInitializationData->HwInitialize;
    ASSERT (HwInitialize != NULL);

    Succ = HwInitialize (&Miniport->PrivateDeviceExt->HwDeviceExtension);

    return RaidNtStatusFromBoolean (Succ);
}

NTSTATUS
INLINE
RaCallMiniportStopAdapter(
    IN PRAID_MINIPORT Miniport
    )
{
    SCSI_ADAPTER_CONTROL_STATUS ControlStatus;
    ASSERT (Miniport != NULL);
    ASSERT (Miniport->HwInitializationData != NULL);

    ASSERT (Miniport->HwInitializationData->HwAdapterControl != NULL);

    ControlStatus = Miniport->HwInitializationData->HwAdapterControl(
                        &Miniport->PrivateDeviceExt->HwDeviceExtension,
                        ScsiStopAdapter,
                        NULL);

    return (ControlStatus == ScsiAdapterControlSuccess ? STATUS_SUCCESS :
                                                         STATUS_UNSUCCESSFUL);
}

NTSTATUS
INLINE
RaCallMiniportResetBus(
    IN PRAID_MINIPORT Miniport,
    IN UCHAR PathId
    )
{
    BOOLEAN Succ;
    
    ASSERT (Miniport != NULL);
    ASSERT (Miniport->HwInitializationData != NULL);
    ASSERT (Miniport->HwInitializationData->HwResetBus != NULL);

    Succ = Miniport->HwInitializationData->HwResetBus(
                        &Miniport->PrivateDeviceExt->HwDeviceExtension,
                        PathId);

    return (Succ ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);
}


//
// Misc inline functions
//


PRAID_MINIPORT
INLINE
RaHwDeviceExtensionGetMiniport(
    IN PVOID HwDeviceExtension
    )
/*++

Routine Description:

    Get the miniport associated with a specific HwDeviceExtension.

Arguments:

    HwDeviceExtension - Device extension to get the miniport for.

Return Value:

    Pointer to a RAID miniport object on success.

    NULL on failure.

--*/
{
    PRAID_HW_DEVICE_EXT PrivateDeviceExt;

    ASSERT (HwDeviceExtension != NULL);

    PrivateDeviceExt = CONTAINING_RECORD (HwDeviceExtension,
                                          RAID_HW_DEVICE_EXT,
                                          HwDeviceExtension);
    ASSERT (PrivateDeviceExt->Miniport != NULL);
    return PrivateDeviceExt->Miniport;
}




VOID
INLINE
RaidSrbMarkPending(
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    Srb->SrbStatus = SRB_STATUS_PENDING;
}

ULONG
INLINE
RaidMinorFunctionFromIrp(
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION IrpStack;

    ASSERT (Irp != NULL);
    
    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    return IrpStack->MinorFunction;
}

ULONG
INLINE
RaidMajorFunctionFromIrp(
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION IrpStack;

    ASSERT (Irp != NULL);
    
    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    return IrpStack->MajorFunction;
}

ULONG
INLINE
RaidIoctlFromIrp(
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION IrpStack;
    
    ASSERT (RaidMajorFunctionFromIrp (Irp) == IRP_MJ_DEVICE_CONTROL);

    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    return IrpStack->Parameters.DeviceIoControl.IoControlCode;
}


PEXTENDED_REQUEST_BLOCK
INLINE
RaidXrbFromIrp(
    IN PIRP Irp
    )
{
    return (RaidGetAssociatedXrb (RaidSrbFromIrp (Irp)));
}


PSCSI_REQUEST_BLOCK
INLINE
RaidSrbFromIrp(
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION IrpStack;

    ASSERT (RaidMajorFunctionFromIrp (Irp) == IRP_MJ_SCSI);

    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    return IrpStack->Parameters.Scsi.Srb;
}

UCHAR
INLINE
RaidSrbFunctionFromIrp(
    IN PIRP Irp
    )
{
    return RaidSrbFromIrp (Irp)->Function;
}

UCHAR
INLINE
RaidScsiOpFromIrp(
    IN PIRP Irp
    )
{
    PCDB Cdb;
    PSCSI_REQUEST_BLOCK Srb;

    Srb = RaidSrbFromIrp (Irp);
    Cdb = (PCDB) &Srb->Cdb;

    return Cdb->CDB6GENERIC.OperationCode;
}
    

NTSTATUS
INLINE
RaidNtStatusFromScsiStatus(
    IN ULONG ScsiStatus
    )
{
    switch (ScsiStatus) {
        case SRB_STATUS_PENDING: return STATUS_PENDING;
        case SRB_STATUS_SUCCESS: return STATUS_SUCCESS;
        default:                 return STATUS_UNSUCCESSFUL;
    }
}

NTSTATUS
INLINE
RaidNtStatusFromBoolean(
    IN BOOLEAN Succ
    )
{
    return (Succ ?  STATUS_SUCCESS : STATUS_UNSUCCESSFUL);
}


//
// From common.h
//

INLINE
RAID_OBJECT_TYPE
RaGetObjectType(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PRAID_COMMON_EXTENSION Common;

    ASSERT (DeviceObject != NULL);
    Common = (PRAID_COMMON_EXTENSION) DeviceObject->DeviceExtension;
    ASSERT (Common->ObjectType == RaidAdapterObject ||
            Common->ObjectType == RaidUnitObject ||
            Common->ObjectType == RaidDriverObject);

    return Common->ObjectType;
}

BOOLEAN
INLINE
IsAdapter(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    return (RaGetObjectType (DeviceObject) == RaidAdapterObject);
}

PRAID_ADAPTER_EXTENSION
INLINE
GetAdapter(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    ASSERT (DeviceObject != NULL);
    ASSERT (IsAdapter (DeviceObject));
    return (PRAID_ADAPTER_EXTENSION)DeviceObject->DeviceExtension;
}
    
INLINE
BOOLEAN
IsDriver(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    return (RaGetObjectType (DeviceObject) == RaidDriverObject);
}

INLINE
BOOLEAN
IsUnit(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    return (RaGetObjectType (DeviceObject) == RaidUnitObject);
}

PRAID_UNIT_EXTENSION
INLINE
GetUnit(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    ASSERT (DeviceObject != NULL);
    ASSERT (IsUnit (DeviceObject));
    return (PRAID_UNIT_EXTENSION)DeviceObject->DeviceExtension;
}

PIRP
INLINE
GetIrp(
    IN PVOID Irp
    )
{
    PIRP TypedIrp;

    ASSERT (Irp != NULL);
    TypedIrp = (PIRP)Irp;
    ASSERT (TypedIrp->Type == IO_TYPE_IRP);
    return TypedIrp;
}

//
// From power.h
//

VOID
INLINE
RaInitializePower(
    IN PRAID_POWER_STATE Power
    )
{
}

VOID
INLINE
RaSetDevicePowerState(
    IN PRAID_POWER_STATE Power,
    IN DEVICE_POWER_STATE DeviceState
    )
{
    ASSERT (Power != NULL);
    Power->DeviceState = DeviceState;
}

VOID
INLINE
RaSetSystemPowerState(
    IN PRAID_POWER_STATE Power,
    IN SYSTEM_POWER_STATE SystemState
    )
{
    ASSERT (Power != NULL);
    Power->SystemState = SystemState;
}

POWER_STATE_TYPE
INLINE
RaidPowerTypeFromIrp(
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION IrpStack;
    
    ASSERT (RaidMajorFunctionFromIrp (Irp) == IRP_MJ_POWER);
    ASSERT (RaidMinorFunctionFromIrp (Irp) == IRP_MN_QUERY_POWER ||
            RaidMinorFunctionFromIrp (Irp) == IRP_MN_SET_POWER);

    IrpStack = IoGetCurrentIrpStackLocation (Irp);

    return IrpStack->Parameters.Power.Type;
}


POWER_STATE
INLINE
RaidPowerStateFromIrp(
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION IrpStack;
    
    ASSERT (RaidMajorFunctionFromIrp (Irp) == IRP_MJ_POWER);
    ASSERT (RaidMinorFunctionFromIrp (Irp) == IRP_MN_QUERY_POWER ||
            RaidMinorFunctionFromIrp (Irp) == IRP_MN_SET_POWER);

    IrpStack = IoGetCurrentIrpStackLocation (Irp);

    return IrpStack->Parameters.Power.State;
}


POWER_ACTION
INLINE
RaidPowerActionFromIrp(
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION IrpStack;

    ASSERT (RaidMajorFunctionFromIrp (Irp) == IRP_MJ_POWER);
    ASSERT (RaidMinorFunctionFromIrp (Irp) == IRP_MN_QUERY_POWER ||
            RaidMinorFunctionFromIrp (Irp) == IRP_MN_SET_POWER);

    IrpStack = IoGetCurrentIrpStackLocation (Irp);

    return IrpStack->Parameters.Power.ShutdownType;
}


NTSTATUS
INLINE
StorQueueWorkItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_WORKITEM_ROUTINE WorkRoutine,
    IN WORK_QUEUE_TYPE WorkQueue,
    IN PVOID Context
    )
{
    PIO_WORKITEM WorkItem;
    
    WorkItem = IoAllocateWorkItem (DeviceObject);

    if (WorkItem == NULL) {
        return STATUS_NO_MEMORY;
    }
    
    IoQueueWorkItem (WorkItem,
                     WorkRoutine,
                     WorkQueue,
                     Context);

    return STATUS_SUCCESS;
}


DEVICE_POWER_STATE
INLINE
StorSetDevicePowerState(
    IN PDEVICE_OBJECT DeviceObject,
    IN DEVICE_POWER_STATE DeviceState
    )
/*++

Routine Description:

    Set the device power state for a specified device.

Arguments:

    DeviceObject - Target device object to set the power state for.

    DeviceState - Specifies the device state to set.

Return Value:

    Previous device power state.

--*/
{
    POWER_STATE PrevState;
    POWER_STATE PowerState;

    PowerState.DeviceState = DeviceState;
    PrevState = PoSetPowerState (DeviceObject,
                                 DevicePowerState,
                                 PowerState);

    return PrevState.DeviceState;
}

//
// From srb.h
//

PEXTENDED_REQUEST_BLOCK
INLINE
RaidGetAssociatedXrb(
    IN PSCSI_REQUEST_BLOCK Srb
    )
/*++

Routine Description:

    Get the XRB associated with the SRB parameter.

Arguments:

    Srb - Srb whose associated XRB is to be returned.

Return Value:

    The XRB associated with this SRB, or NULL if there is none.

--*/
{
    ASSERT_XRB (Srb->OriginalRequest);
    return (PEXTENDED_REQUEST_BLOCK) Srb->OriginalRequest;
}

VOID
INLINE
RaSetAssociatedXrb(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PEXTENDED_REQUEST_BLOCK Xrb
    )
{
    Srb->OriginalRequest = Xrb;
}
    


//
// From resource.h
//


ULONG
INLINE
RaidGetResourceListCount(
    IN PRAID_RESOURCE_LIST ResourceList
    )
{
    //
    // NB: We only support CM_RESOURCE_LIST's with one element.
    //
    
    if ((ResourceList->AllocatedResources) == NULL) {
        return 0;
    }

    ASSERT (ResourceList->AllocatedResources->Count == 1);
    return ResourceList->AllocatedResources->List[0].PartialResourceList.Count;
}


VOID
INLINE
RaidpGetResourceListIndex(
    IN PRAID_RESOURCE_LIST ResourceList,
    IN ULONG Index,
    OUT PULONG ListNumber,
    OUT PULONG NewIndex
    )
{

    //
    // NB: We only support CM_RESOURCE_LIST's with one element.
    //

    ASSERT (ResourceList->AllocatedResources->Count == 1);
    
    *ListNumber = 0;
    *NewIndex = Index;
}

LOGICAL
INLINE
IsMappedSrb(
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    return (Srb->Function == SRB_FUNCTION_IO_CONTROL ||
            Srb->Function == SRB_FUNCTION_WMI);
}

LOGICAL
INLINE
IsExcludedFromMapping(
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    //
    // We never map system VA to back read and write requests. If you need
    // this functionality, get a better adapter.
    //
    
    if (Srb->Function == SRB_FUNCTION_EXECUTE_SCSI &&
        (Srb->Cdb[0] == SCSIOP_READ || Srb->Cdb[0] == SCSIOP_WRITE)) {
        return TRUE;
    } else {
        return FALSE;
    }
}


LOGICAL
INLINE
RaidAdapterRequiresMappedBuffers(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
{
    return (Adapter->Miniport.PortConfiguration.MapBuffers);
}


VOID
INLINE
InterlockedAssign(
    IN PLONG Destination,
    IN LONG Value
    )
/*++

Routine Description:

    Interlocked assignment routine. This routine doesn't add anything
    over doing straight assignment, but it highlights that this variable
    is accessed through interlocked operations.

    In retail, this will compile to nothing.

Arguments:

    Destination - Pointer of interlocked variable to is to be assigned to.

    Value - Value to assign.

Return Value:

    None.

--*/
{
    *Destination = Value;
}

LONG
INLINE
InterlockedQuery(
    IN PULONG Destination
    )
/*++

Routine Description:

    Interlocked query routine. This routine doesn't add anything over
    doing stright query, but it highlights that this variable is accessed
    through interlocked operations.

    In retail, this will compile to nothing.

Arguments:

    Destination - Pointer to interlocked variable that is to be returned.

Return Value:

    Value of interlocked variable.

--*/
{
    return *Destination;
}

PVOID
INLINE
RaidAdapterGetHwDeviceExtension(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
{
    return &Adapter->Miniport.PrivateDeviceExt->HwDeviceExtension;
}


VOID
INLINE
RaidAdapterAcquireStartIoLock(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN OUT PLOCK_CONTEXT LockContext
    )
/*++

Routine Description:

    Acquire either the StartIo lock or the Interrupt spinlock depending
    on whether we're in Full or Half duplex mode.

Arguments:

    Adapter - Adapter object on which to acquire the lock.

    LockContext - Context of the lock to acquire. This us used as a context
            for releasing the lock.

Return Value:

    None.
    
--*/
{
    if (Adapter->IoModel == StorSynchronizeHalfDuplex) {
        LockContext->OldIrql = KeAcquireInterruptSpinLock (Adapter->Interrupt);
    } else {
        KeAcquireInStackQueuedSpinLock (&Adapter->StartIoLock,
                                        &LockContext->LockHandle);
    }

#if DBG && 0

    //
    // Enable this for debugging deadlocks in with the StartIo lock.
    //
    
    Adapter->StartIoLockOwner = _ReturnAddress();
#endif
}



VOID
INLINE
RaidAdapterReleaseStartIoLock(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN OUT PLOCK_CONTEXT LockContext
    )
/*++

Routine Description:

    Release a lock previously acquired with RaidAdapterAcquireStartIoLock.

Arguments:

    Adapter - Adapter object on which the lock was acquired.

    LockContext - Context information showing how to release the lock.

Return Value:

    None.

Note:

    The Acquire/Release functions assume that the IoModel did not change
    between the time the lock was acquired and released. If this assumption
    changes, the way these functions operate will have to change.
    
--*/
{
#if DBG && 0

    //
    // Enable this for debugging deadlocks with the StartIo lock.
    //
    
    Adapter->StartIoLockOwner = _ReturnAddress();
#endif

    if (Adapter->IoModel == StorSynchronizeHalfDuplex) {
        KeReleaseInterruptSpinLock (Adapter->Interrupt, LockContext->OldIrql);
    } else {
        KeReleaseInStackQueuedSpinLock (&LockContext->LockHandle);
    }
}




VOID
INLINE
RaidAdapterAcquireHwInitializeLock(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PLOCK_CONTEXT LockContext
    )
/*++

Routine Description:

    Acquire either the StartIo lock or the Interrupt spinlock depending
    on the adaper's configuration.

Arguments:

    Adapter - Adapter object on which to acquire the lock.

    LockContext - Context of the lock to acquire. This us used as a context
            for releasing the lock.

Return Value:

    None.

--*/
{
    if (Adapter->Interrupt) {
        LockContext->OldIrql = KeAcquireInterruptSpinLock (Adapter->Interrupt);
    } else {
        RaidAdapterAcquireStartIoLock (Adapter, LockContext);
    }
}


VOID
INLINE
RaidAdapterReleaseHwInitializeLock(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PLOCK_CONTEXT LockContext
    )
/*++

Routine Description:

    Release the lock acquired by RaidAdapterAcquireHwInitializeLock.

Arguments:

    Adapter - Adapter object on which to release the lock.

    LockContext - Context of the lock to release.
    
Return Value:

    None.

--*/
{
    if (Adapter->Interrupt) {
        KeReleaseInterruptSpinLock (Adapter->Interrupt, LockContext->OldIrql);
    } else {
        RaidAdapterReleaseStartIoLock (Adapter, LockContext);
    }
}

ULONG
INLINE
RaGetListLengthFromLunList(
    IN PLUN_LIST LunList
    )
/*++

Routine Description:

    Returns the length, in bytes, of the LUN list in the supplied LUN_LIST
    structure.

Arguments:

    LunList - Pointer to a LUN_LIST structure.

Return Value:

    The length of the LUN list in bytes.

--*/
{
    ULONG ListLength;

    ListLength  = LunList->LunListLength[3] << 0;
    ListLength |= LunList->LunListLength[2] << 8;
    ListLength |= LunList->LunListLength[1] << 16;
    ListLength |= LunList->LunListLength[0] << 24;

    return ListLength;
}

ULONG
INLINE
RaGetNumberOfEntriesFromLunList(
    IN PLUN_LIST LunList
    )
/*++

Routine Description:

    Returns the number of entries in that are present in the supplied LunList.

Arguments:

    LunList - Pointer to a LUN_LIST structure.

Return Value:

    Then number of LUN entries in the supplied LUN_LIST structure.

--*/
{
    ULONG ListLength;
    ULONG NumberOfEntries;

    ListLength = RaGetListLengthFromLunList(LunList);
    NumberOfEntries = ListLength / sizeof (LunList->Lun[0]);

    return NumberOfEntries;
}

USHORT
INLINE
RaGetLUNFromLunList(
    IN PLUN_LIST LunList,
    IN ULONG Index
    )
/*++

Routine Description:

    Returns the LUN at the specified index in the supplied LUN_LIST.

Arguments:

    LunList - Pointer to a LUN_LIST structure.

    Index - Identiries which entry in the LUN_LIST we need the LUN for.

Return Value:

    The LUN of the specified entry.

--*/
{
    USHORT Lun;

    Lun  = LunList->Lun[Index][1] << 0;
    Lun |= LunList->Lun[Index][0] << 8;
    Lun &= 0x3fff;

    return Lun;
}

//
// Unit queue manipulation routines
//

VOID
INLINE
RaidPauseUnitQueue(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Low level primitive to pause a logical units queue. A unit may be
    paused multiple times. The notion of "freezing" and "thawing" a
    logical unit's queue is implemented in terms of pausing.

Arguments:

    Unit - Supplies a logical unit to pause.

Return Value:

    None.

--*/
{
    DbgLogRequest (LogPauseDevice, _ReturnAddress(), NULL, NULL, NULL);
    RaidFreezeIoQueue (&Unit->IoQueue);
}


LOGICAL
INLINE
RaidResumeUnitQueue(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Resume a previously paused logical unit queue. The logical unit will
    not actually resume I/O operations until the pause count reaches zero.

    It is illegal to resume a unit that has not been paused.

Arguments:

    Unit - Supplies a logical unit which has previously been paused using
        RaidResumeUnitQueue.

Return Value:

    None.

--*/
{
    LOGICAL Resumed;
    
    Resumed = RaidResumeIoQueue (&Unit->IoQueue);
    DbgLogRequest (LogResumeDevice,
                   _ReturnAddress(),
                   (PVOID)(ULONG_PTR)Resumed,
                   NULL,
                   NULL);

    return Resumed;
}


VOID
INLINE
RaidFreezeUnitQueue(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Freeze the logical unit queue. Freezing the logical unit queue is
    done only during an error. The class driver releases the logical
    unit queue with a SRB_FUNCTION_RELEASE_QUEUE srb.

    The logical unit queue cannot handle recursive freezes.

Arguments:

    Unit - Supplies the logical unit to freeze.

Return Value:

    None.

--*/
{
    ASSERT (!Unit->Flags.QueueFrozen);
    RaidPauseUnitQueue (Unit);
    Unit->Flags.QueueFrozen = TRUE;
}


VOID
INLINE
RaidThawUnitQueue(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Thaw a logical unit queue previously frozen with RaidFreezeUnitQueue
    function.

Arguments:

    Unit - Supplies the logical unit to thaw.

Return Value:

    None.

--*/
{
    ASSERT (Unit->Flags.QueueFrozen);

    Unit->Flags.QueueFrozen = FALSE;
    RaidResumeUnitQueue (Unit);
}

LOGICAL
INLINE
RaidIsUnitQueueFrozen(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Check if the logical unit queue is frozen.

Arguments:

    Unit - Unit to check if frozen.

Return Value:

    TRUE if it is frozen, FALSE otherwise.

--*/
{
    return Unit->Flags.QueueFrozen;
}


VOID
INLINE
RaidLockUnitQueue(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Lock a logical unit queue based on a request from the class driver.
    This is done in response to a SRB_FUNCTION_LOCK_QUEUE request.

    The port drivers do not support recursive locks.

Arguments:

    Unit - Supplies the logical unit of to lock.

Return Value:

    None.

--*/
{
    ASSERT (!Unit->Flags.QueueLocked);
    RaidPauseUnitQueue (Unit);
    Unit->Flags.QueueLocked = TRUE;
}


VOID
INLINE
RaidUnlockUnitQueue(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Unlock a logical unit queue in response to a SRB_FUNCTION_UNLOCK_QUEUE
    request.

Arguments:

    Unit - Supplies the logical unit to unlock.

Return Value:

    None.

--*/
{
    ASSERT (Unit->Flags.QueueLocked);
    RaidResumeUnitQueue (Unit);
    Unit->Flags.QueueLocked = FALSE;
}

LOGICAL
INLINE
RaidIsUnitQueueLocked(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Test if the logical unit's queue is locked.
    
Arguments:

    Unit - Logical unit to test on.

Return Value:

    TRUE if the logical unit's queue is locked, FALSE otherwise.

--*/
{
    return Unit->Flags.QueueLocked;
}

    
//
// From unit.h
//

LOGICAL
INLINE
IsSolitaryRequest(
    IN PSCSI_REQUEST_BLOCK Srb
    )
/*++

Routine Description:

    A solitary request is one that cannot be issued to the bus while other
    requests are outstanding. For example, untagged requests and requests
    with QUEUE_ACTION_ENABLE not set.

Arguments:

    Srb - Supplies SRB to test.

Return Value:

    TRUE - If the supplied SRB is a solitary request.

    FALSE - If the supplied SRB is not a solitary request.

--*/
{
    //
    // If the SRB_FLAGS_NO_QUEUE_FREEZE and the SRB_FLAGS_QUEUE_ACTION_ENABLE
    // flags are set, then this is NOT a solitary request, otherwise, it is.
    //
    
    if (TEST_FLAG (Srb->SrbFlags, SRB_FLAGS_NO_QUEUE_FREEZE) &&
        TEST_FLAG (Srb->SrbFlags, SRB_FLAGS_QUEUE_ACTION_ENABLE)) {

        return FALSE;
    }

    //
    // Buypass request are also never solitary requests.
    //
    
    if (TEST_FLAG (Srb->SrbFlags, SRB_FLAGS_BYPASS_FROZEN_QUEUE) ||
        TEST_FLAG (Srb->SrbFlags, SRB_FLAGS_BYPASS_LOCKED_QUEUE)) {

        return FALSE;
    }

    //
    // Bus/target/lun reset request must never be solitary requests; otherwise,
    // we'll attempt to wait for the bus/target/lun queue to drain before
    // executing the command.
    //
    
    if (Srb->Function == SRB_FUNCTION_RESET_BUS ||
        Srb->Function == SRB_FUNCTION_RESET_DEVICE ||
        Srb->Function == SRB_FUNCTION_RESET_LOGICAL_UNIT) {

        return FALSE;
    }
        

    //
    // Otherwise, this is a solitary request.
    //
    
    return TRUE;
}



LONG
INLINE
RaidPauseAdapterQueue(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
{
    LONG Count;
    
    Count = StorPauseIoGateway (&Adapter->Gateway);
    DbgLogRequest (LogPauseAdapter,
                   _ReturnAddress(),
                   (PVOID)((ULONG_PTR)Count),
                   NULL,
                   NULL);
    return Count;
}

LONG
INLINE
RaidResumeAdapterQueue(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
{
    LONG Count;

    Count = StorResumeIoGateway (&Adapter->Gateway);
    DbgLogRequest (LogResumeAdapter,
                   _ReturnAddress(),
                   (PVOID)(ULONG_PTR)Count,
                   NULL,
                   NULL);

    return Count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\ioqueue.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ioqueue.h

Abstract:

    Declaration of the raid IO_QUEUE object. This object serves much the
    same function as the standard NT IO queue associated with a driver.
    The difference is this ioqueue is built upon the EXTENDED_DEVICE_QUEUE
    object that adds support for queuing multiple entries to a device at
    the same time and for freezing and resuming the device queue.

Author:

    Matthew D Hendel (math) 22-June-2000

Revision History:

--*/

#pragma once

typedef
VOID
(*PRAID_DRIVER_STARTIO)(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

typedef struct _IO_QUEUE {

    //
    // Device object this ioqueue is for.
    //
    // Protected by: read-only.
    //
    
    PDEVICE_OBJECT DeviceObject;

    //
    // StartIo routine for this ioqueue.
    //
    // Protected by: read-only.
    //
    
    
    PRAID_DRIVER_STARTIO StartIo;

    //
    // Extended device queue that implements this ioqueue.
    //
    // Protected by: DeviceQueue.
    //
    
    EXTENDED_DEVICE_QUEUE DeviceQueue;

    //
    // Flag specifying that the queue has changed in some fundamental
    // manner, like the depth has changed or the queue has been
    // resumed after a freeze.
    //
    // Protected by: interlocked access.
    //
    
    ULONG QueueChanged;
    
} IO_QUEUE, *PIO_QUEUE;


typedef
VOID
(*PIO_QUEUE_PURGE_ROUTINE)(
    IN PIO_QUEUE IoQueue,
    IN PVOID Context,
    IN PIRP Irp
    );

VOID
RaidInitializeIoQueue(
    OUT PIO_QUEUE IoQueue,
    IN PDEVICE_OBJECT DeviceObject,
    IN PSTOR_IO_GATEWAY Gateway,
    IN PRAID_DRIVER_STARTIO StartIo,
    IN ULONG QueueDepth
    );
    
LOGICAL
RaidStartIoPacket(
    IN PIO_QUEUE IoQueue,
    IN PIRP Irp,
    IN ULONG Flags,
    IN PDRIVER_CANCEL CancelFunction OPTIONAL,
    IN PVOID Context
    );

LOGICAL
RaidStartNextIoPacket(
    IN PIO_QUEUE IoQueue,
    IN BOOLEAN Cancleable,
    IN PVOID Context,
    OUT PBOOLEAN RestartQueues
    );

VOID
RaidFreezeIoQueue(
    IN PIO_QUEUE IoQueue
    );

LOGICAL
RaidResumeIoQueue(
    IN PIO_QUEUE IoQueue
    );

LOGICAL
INLINE
RaidIsIoQueueFrozen(
    IN PIO_QUEUE IoQueue
    )
{
    return RaidIsExQueueFrozen (&IoQueue->DeviceQueue);
}

PIRP
RaidRemoveIoQueue(
    IN PIO_QUEUE IoQueue
    );

VOID
RaidRestartIoQueue(
    IN PIO_QUEUE IoQueue
    );

VOID
RaidPurgeIoQueue(
    IN PIO_QUEUE IoQueue,
    IN PIO_QUEUE_PURGE_ROUTINE PurgeRoutine,
    IN PVOID Context
    );

ULONG
RaidGetIoQueueDepth(
    IN PIO_QUEUE IoQueue
    );

ULONG
RaidSetIoQueueDepth(
    IN PIO_QUEUE IoQueue,
    IN ULONG Depth
    );

VOID
INLINE
RaidBusyIoQueue(
    IN PIO_QUEUE IoQueue,
    IN ULONG RequestsToComplete
    )
{
    RaidBusyExDeviceQueue (&IoQueue->DeviceQueue, RequestsToComplete);
}

VOID
INLINE
RaidReadyIoQueue(
    IN PIO_QUEUE IoQueue
    )
{
    RaidReadyExDeviceQueue (&IoQueue->DeviceQueue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\init.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    init.c

Abstract:

    Global initialization for storport.sys.

Author:

    Bryan Cheung (t-bcheun) 29-August-2001

Revision History:

--*/

#include "precomp.h"

//
// Externals
//
extern LOGICAL StorPortVerifierInitialized;
extern ULONG SpVrfyLevel;
extern LOGICAL RaidVerifierEnabled;


//
// Functions
//

NTSTATUS
DllInitialize(
    IN PUNICODE_STRING RegistryPath
    )
{
    HANDLE VerifierKey;
    UNICODE_STRING Name;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS Status;
    ULONG ResultLength;
    UCHAR Buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG)];
    PKEY_VALUE_PARTIAL_INFORMATION ValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)Buffer;

    //
    // Check the verification level.  
    //
    
    if (SpVrfyLevel == SP_VRFY_NONE) {
        return STATUS_SUCCESS;
    }

    
    //
    // Read the global verification level from the registry.  If the value is
    // not present or if the value indicates 'no verification', no verifier 
    // initialization is performed.
    //

    RtlInitUnicodeString(&Name, STORPORT_CONTROL_KEY STORPORT_VERIFIER_KEY);
    InitializeObjectAttributes(&ObjectAttributes,
                               &Name,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = ZwOpenKey(&VerifierKey, KEY_READ, &ObjectAttributes);

    if (NT_SUCCESS(Status)) {

        RtlInitUnicodeString(&Name, L"VerifyLevel");
        Status = ZwQueryValueKey(VerifierKey,
                                 &Name,
                                 KeyValuePartialInformation,
                                 ValueInfo,
                                 sizeof(Buffer),
                                 &ResultLength);

        if (NT_SUCCESS(Status)) {

            if (ValueInfo->Type == REG_DWORD) {

                if (ResultLength >= sizeof(ULONG)) {

                    SpVrfyLevel |= ((PULONG)(ValueInfo->Data))[0];

                    if (SpVrfyLevel != SP_VRFY_NONE &&
                        StorPortVerifierInitialized == 0) {

                        //
                        // Ok, we found a verifier level and it did not tell us
                        // not to verify.  Go ahead and initialize scsiport's
                        // verifier.
                        //

                        if (SpVerifierInitialization()) {
                            StorPortVerifierInitialized = TRUE;
                            RaidVerifierEnabled = TRUE;
                        }
                    }
                }
            }
        }

        ZwClose(VerifierKey);
    }

#if 0
    
    if (SpVrfyLevel != SP_VRFY_NONE && StorPortVerifierInitialized == 0) {
        if (SpVerifierInitialization()) {
            StorPortVerifierInitialized = 1;
        }
    }
#endif

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\miniport.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    miniport.c

Abstract:

    Implementation of the RAID_MINIPORT object.

Author:

    Matthew D Hendel (math) 19-Apr-2000

Revision History:

--*/


#include "precomp.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RaCreateMiniport)
#pragma alloc_text(PAGE, RaDeleteMiniport)
#pragma alloc_text(PAGE, RaInitializeMiniport)
#pragma alloc_text(PAGE, RaInitializeMiniport)
#pragma alloc_text(PAGE, RiAllocateMiniportDeviceExtension)
#endif // ALLOC_PRAGMA


VOID
RaCreateMiniport(
    OUT PRAID_MINIPORT Miniport
    )
/*++

Routine Description:

    Create a miniport object and initialize it to a null state.

Arguments:

    Miniport - Pointer to the miniport to initialize.

Return Value:

    None.

--*/
{
    PAGED_CODE ();
    ASSERT (Miniport != NULL);

    RaCreateConfiguration (&Miniport->PortConfiguration);
    Miniport->HwInitializationData = NULL;
    Miniport->PrivateDeviceExt = NULL;
    Miniport->Adapter = NULL;
    Miniport->Flags.InFindAdapter = FALSE;
}


VOID
RaDeleteMiniport(
    IN PRAID_MINIPORT Miniport
    )

/*++

Routine Description:

    Delete and deallocate any resources associated with teh
    miniport object.

Arguments:

    Miniport - Pointer to the miniport to delete.

Return Value:

    None.

--*/

{
    PAGED_CODE ();
    ASSERT (Miniport != NULL);
    
    RaDeleteConfiguration (&Miniport->PortConfiguration);
    Miniport->HwInitializationData = NULL;
    Miniport->Adapter = NULL;

    if (Miniport->PrivateDeviceExt != NULL) {
        ExFreePoolWithTag (Miniport->PrivateDeviceExt,
                           MINIPORT_EXT_TAG);
        Miniport->PrivateDeviceExt = NULL;
    }
}


NTSTATUS
RaInitializeMiniport(
    IN OUT PRAID_MINIPORT Miniport,
    IN PHW_INITIALIZATION_DATA HwInitializationData,
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PRAID_RESOURCE_LIST ResourceList,
    IN ULONG BusNumber
    )
/*++

Routine Description:

    Initialize a miniport object.

Arguments:

    Miniport - Pointer to the miniport to initialize.

    HwInitializationData - The hardware initialization data
            passed in when this device called ScsiPortInitialize.

    Adapter - Pointer to the parent adapter that owns this
            miniport.

    ResourceList - The resources assigned to this device.

    BusNumber - The bus this device is on.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    SIZE_T ExtensionSize;
    
    PAGED_CODE ();
    ASSERT (Miniport != NULL);
    ASSERT (HwInitializationData != NULL);
    ASSERT (Adapter != NULL);
    ASSERT (ResourceList != NULL);
    //ASSERT (BusNumber != -1);

    PAGED_CODE ();

    Miniport->Adapter = Adapter;
    Miniport->HwInitializationData = HwInitializationData;

    Status = RiAllocateMiniportDeviceExtension (Miniport);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // Initialize a port configuration object for the adapter
    // This will need to be in a RW buffer, because the miniport
    // may modify it.
    //

    Status = RaInitializeConfiguration (&Miniport->PortConfiguration,
                                        HwInitializationData,
                                        BusNumber);
    if (!NT_SUCCESS (Status)) {
        return Status;
    }
    
    if (ResourceList->AllocatedResources) {

        Status = RaAssignConfigurationResources (&Miniport->PortConfiguration,
                                                 ResourceList->AllocatedResources,
                                                 HwInitializationData->NumberOfAccessRanges);

    }

    return Status;
}

NTSTATUS
RiAllocateMiniportDeviceExtension(
    IN PRAID_MINIPORT Miniport
    )
/*++

Routine Description:

    Allocate a miniport device extension.

Arguments:

    Miniport - Pointer to the miniport to allocate the device
            extension for.

Return Value:

    NTSTATUS code

--*/
{
    SIZE_T ExtensionSize;

    PAGED_CODE ();
    ASSERT (Miniport != NULL);

    ASSERT (Miniport->PrivateDeviceExt == NULL);
    
    ExtensionSize = FIELD_OFFSET (RAID_HW_DEVICE_EXT, HwDeviceExtension) +
                    Miniport->HwInitializationData->DeviceExtensionSize;

    Miniport->PrivateDeviceExt = ExAllocatePoolWithTag (NonPagedPool,
                                                         ExtensionSize,
                                                         MINIPORT_EXT_TAG );

    if (Miniport->PrivateDeviceExt == NULL) {
        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory (Miniport->PrivateDeviceExt, ExtensionSize);
    Miniport->PrivateDeviceExt->Miniport = Miniport;

    return STATUS_SUCCESS;
}

NTSTATUS
RaidNtStatusFromSpStatus(
    IN ULONG SpStatus
    )
{
    switch (SpStatus) {
        case SP_RETURN_NOT_FOUND:
            return STATUS_NOT_FOUND;

        case SP_RETURN_FOUND:
            return STATUS_SUCCESS;

        case SP_RETURN_ERROR:
            return STATUS_ADAPTER_HARDWARE_ERROR;

        case SP_RETURN_BAD_CONFIG:
            return STATUS_DEVICE_CONFIGURATION_ERROR;

        default:
            return STATUS_INTERNAL_ERROR;
    }
}


NTSTATUS
RaCallMiniportFindAdapter(
    IN PRAID_MINIPORT Miniport,
    IN PUCHAR Parameter
    )
/*++

Routine Description:

    Call the miniport's FindAdapter routine.

Arguments:

    Miniport - Miniport to call FindAdapter on.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG SpStatus;
    BOOLEAN CallAgain;
    PPORT_CONFIGURATION_INFORMATION PortConfig;

    ASSERT (Miniport != NULL);
    ASSERT (Miniport->HwInitializationData != NULL);
    ASSERT (Miniport->HwInitializationData->HwFindAdapter != NULL);
    
    PortConfig = &Miniport->PortConfiguration;
    CallAgain = FALSE;
    
    ASSERT (Miniport->Adapter != NULL);

    //
    // Deal with miniports that don't handle NULL parameter string.
    //
    
    if (Parameter == NULL) {
        Parameter = "";
    }

    //
    // Track whether we're in HwFindAdapter or not. Used for
    // the storport verifier.
    //
    
    Miniport->Flags.InFindAdapter = TRUE;
    SpStatus = Miniport->HwInitializationData->HwFindAdapter(
                    &Miniport->PrivateDeviceExt->HwDeviceExtension,
                    NULL,
                    NULL,
                    Parameter,
                    PortConfig,
                    &CallAgain);

    Miniport->Flags.InFindAdapter = FALSE;

    //
    // Only support adapters that do bus mastering DMA and have
    // reasonable scatter/gather support.
    //
    
    if (!PortConfig->NeedPhysicalAddresses ||
        !PortConfig->TaggedQueuing ||
        !PortConfig->ScatterGather ||
        !PortConfig->Master) {

        DebugPrint (("Legacy Device is not supported:\n"));
        DebugPrint (("Device does not support Bus Master DMA or Scatter/Gather\n"));
        Status = STATUS_NOT_SUPPORTED;
    } else {
        Status = RaidNtStatusFromSpStatus (SpStatus);
    }

    return Status;
}


NTSTATUS
RaCallMiniportAdapterControl(
    IN PRAID_MINIPORT Miniport,
    IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
    IN PVOID Parameters
    )
{
    NTSTATUS Status;
    PHW_ADAPTER_CONTROL HwAdapterControl;
    SCSI_ADAPTER_CONTROL_STATUS Result;
    
    ASSERT (Miniport != NULL);
    ASSERT (Miniport->HwInitializationData != NULL);

    HwAdapterControl = Miniport->HwInitializationData->HwAdapterControl;

    if (HwAdapterControl == NULL) {
        return STATUS_NOT_SUPPORTED;
    }

    Result = HwAdapterControl (&Miniport->PrivateDeviceExt->HwDeviceExtension,
                               ControlType,
                               Parameters);

    if (Result == ScsiAdapterControlSuccess) {
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_UNSUCCESSFUL;
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\miniport.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

	miniport.h

Abstract:

	Definition of RAID_MINIPORT object and it's operations.

Author:

	Matthew D Hendel (math) 20-Apr-2000

Revision History:

--*/

#pragma once

typedef struct _RAID_HW_DEVICE_EXT {

	//
	// Back pointer to the containing miniport.
	//
	
	struct _RAID_MINIPORT* Miniport;

	//
	// Variable length array containing the device extension proper.
	//

	UCHAR HwDeviceExtension[0];

} RAID_HW_DEVICE_EXT, *PRAID_HW_DEVICE_EXT;


typedef struct _RAID_MINIPORT {

	//
	// Back pointer to the containing adapter object.
	//

	PRAID_ADAPTER_EXTENSION Adapter;
	

	//
    // Saved copy of the port configuration information we sent down
    // to the driver.
    //

    PORT_CONFIGURATION_INFORMATION PortConfiguration;

    //
    // Saved copy of the HwInitializationData passed in to 
    // ScsiPortInitialize.
    //

    PHW_INITIALIZATION_DATA HwInitializationData;

	//
	// The miniport's Hw Device Extension and a back-pointer to the miniport.
	//
	
	PRAID_HW_DEVICE_EXT PrivateDeviceExt;

	//
	// Flags for the minport.
	//

	struct {

		//
		// Are we currently executing in HwFindAdapter.
		//
		// Used for the verifier.
		//
		
		BOOLEAN InFindAdapter : 1;

	} Flags;

} RAID_MINIPORT, *PRAID_MINIPORT;



//
// Creation and destruction
//

VOID
RaCreateMiniport(
	OUT PRAID_MINIPORT Miniport
	);

NTSTATUS
RaInitializeMiniport(
	IN OUT PRAID_MINIPORT Miniport,
	IN PHW_INITIALIZATION_DATA HwInitializationData,
	IN PRAID_ADAPTER_EXTENSION Adapter,
	IN PRAID_RESOURCE_LIST ResourceList,
	IN ULONG BusNumber
	);

VOID
RaDeleteMiniport(
	IN PRAID_MINIPORT Miniport
	);

//
// Operations on the miniport object
//

NTSTATUS
RaCallMiniportFindAdapter(
	IN PRAID_MINIPORT Miniport,
	IN PUCHAR Parameter
	);

NTSTATUS
RaCallMiniportHwInitialize(
	IN PRAID_MINIPORT Miniport
	);

BOOLEAN
RaCallMiniportStartIo(
	IN PRAID_MINIPORT Miniport,
	IN PSCSI_REQUEST_BLOCK Srb
	);

BOOLEAN
RaCallMiniportInterrupt(
	IN PRAID_MINIPORT Miniport
	);


NTSTATUS
RaCallMiniportStopAdapter(
	IN PRAID_MINIPORT Miniport
	);
	
NTSTATUS
RaCallMiniportAdapterControl(
	IN PRAID_MINIPORT Miniport,
	IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
	IN PVOID Parameters
	);
	
PRAID_ADAPTER_EXTENSION
RaGetMiniportAdapter(
	IN PRAID_MINIPORT Miniport
	);

PRAID_MINIPORT
RaGetHwDeviceExtensionMiniport(
	IN PVOID HwDeviceExtension
	);


//
// Private operations on the miniport.
//

NTSTATUS
RiAllocateMiniportDeviceExtension(
	IN PRAID_MINIPORT Miniport
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\ioqueue.c ===
/*++ IO_QUEUE

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ioqueue.c

Abstract:

    Implementation of the raid IO_QUEUE object.

Author:

    Matthew D Hendel (math) 22-June-2000

Revision History:

Comments:

    The IoQueue class serves basically the same function as the NT I/O
    queue that is a part of the driver's device object. We use a
    different queue because SCSI has different serialization requirements
    than the standard NT driver model supports. (See the
    EXTENDED_DEVICE_QUEUE object for more information on these differences.)

Future:

    We may want to consider is integrating the EXTENDED_DEVICE_QUEUE
    class and the IO_QUEUE class into the same class. Though logically,
    these can be implemented separately (as they are done in the kernel)
    we may be able to get performance enhancements and code quality
    improvements by putting these in the same class. The only interface
    the port driver is concerned with is the IO_QUEUE interface.

    It would be nice if resource allocation (of queue tags) and the IO
    queue were more closely integrated. As it is, the tag allocation and
    the IO queue both primarily track the number of outstanding requests
    and there is some danger that these numbers could get out of sync.

--*/



#include "precomp.h"


#ifdef ALLOC_PRAGMA
#endif // ALLOC_PRAGMA



#if DBG
VOID
ASSERT_IO_QUEUE(
    PIO_QUEUE IoQueue
    )
{
    ASSERT (IoQueue->DeviceObject != NULL);
    ASSERT (IoQueue->StartIo != NULL);
    ASSERT (IoQueue->QueueChanged == TRUE ||
            IoQueue->QueueChanged == FALSE);
}
#else
#define ASSERT_IO_QUEUE(IoQueue)
#endif

VOID
RaidInitializeIoQueue(
    OUT PIO_QUEUE IoQueue,
    IN PDEVICE_OBJECT DeviceObject,
    IN PSTOR_IO_GATEWAY Gateway,
    IN PRAID_DRIVER_STARTIO StartIo,
    IN ULONG QueueDepth
    )
/*++

Routine Description:

    Initialize an IO_QUEUE object.

Arguments:

    IoQueue - Supplies a pointer to the IO_QUEUE object to initialize.

    DeviceObject - Supplies a pointer to a device object that this
            IoQueue is for.

    Gateway - Supplies the IO Gateway to manage the interaction between
            the different device queues.

    StartIo - Supplies a pointer to a StartIo function that will be
            called when there are irps that need to be handled.

    QueueDepth - Supplies the initial queue depth for the IoQueue. This
            value can by dynamically changed at a later time.

Return Value:

    NTSTATUS code.

--*/
{
    PAGED_CODE ();
    
    IoQueue->DeviceObject = DeviceObject;
    IoQueue->StartIo = StartIo;
    IoQueue->QueueChanged = FALSE;

    RaidInitializeExDeviceQueue (&IoQueue->DeviceQueue,
                                 Gateway,
                                 QueueDepth,
                                 FifoScheduling);
}

    
LOGICAL
RaidStartIoPacket(
    IN PIO_QUEUE IoQueue,
    IN PIRP Irp,
    IN ULONG Flags,
    IN PDRIVER_CANCEL CancelFunction OPTIONAL,
    IN PVOID Context
    )
/*++

Routine Description:

    Attempt to start an IO Request for this driver. If resources are
    available, the IoQueue's StartIo routine will be executed
    synchronously before RaidStartIoPacket returns. Otherwise the request
    will be queued until resources are available.

Arguments:

    IoQueue - IoQueue this IO is for.

    Irp - Irp to execute.

    Flags - Supplies flags to send down to the device queue.
    
    CancelFunction - Pointer to a cancelation function for the associated
            IRP.

Return Value:

    TRUE - If the IO was started.

    FALSE - If it was not started.

--*/
{
    KIRQL OldIrql;
    KIRQL CancelIrql;
    BOOLEAN Inserted;
    PSCSI_REQUEST_BLOCK Srb;
    LOGICAL Started;

    //
    // NB: Cancelation is NYI
    //
    
    ASSERT_IO_QUEUE (IoQueue);
    ASSERT (CancelFunction == NULL);

    Srb = RaidSrbFromIrp (Irp);
    ASSERT (Srb != NULL);

    Started = FALSE;
    KeRaiseIrql (DISPATCH_LEVEL, &OldIrql);

    //
    // Mark the irp as awaiting resources until we can execute
    // the startio routine.
    //
    
    RaidSetIrpState (Irp, RaidPendingResourcesIrp);

    Inserted = RaidInsertExDeviceQueue (&IoQueue->DeviceQueue,
                                        &Irp->Tail.Overlay.DeviceQueueEntry,
                                        Flags,
                                        Srb->QueueSortKey);
    if (!Inserted) {

        //
        // Mark it as not having waited on resources. This makes it
        // possible to figure out whether we waited in the IO queue or
        // not.
        //
        
        RaidSetIrpState (Irp, RaidPortProcessingIrp);
        IoQueue->StartIo (IoQueue->DeviceObject, Irp, Context);
        Started = TRUE;

    } else {

        //
        // Lower storage stack doesn't support cancel.
        //
    }

    KeLowerIrql (OldIrql);

    return Started;
}

    
LOGICAL
RaidStartNextIoPacket(
    IN PIO_QUEUE IoQueue,
    IN BOOLEAN Cancelable,
    IN PVOID Context,
    OUT PBOOLEAN RestartQueue
    )
/*++

Routine Description:

    StartNextPacket dequeues the next IRP on the IoQueue (if any), and
    calls the IoQueue's StartIo routine for that IRP.

    In addition, if the IoQueue has changed, this routine will remove any
    "extra" items from the device queue and call the IoQueue's StartIo
    routine for those extra items. In this sense, "extra" items on the io
    queue are items on the queue when the queue is not busy. This happens
    when the io queue is increased in size while it's busy, or when the
    queue is frozen and items get queued to it, and then it's resumed.
    
Arguments:

    IoQueue -

    Cancelable -

    Context -

Return Value:

    TRUE - If we started the next io operation.

    FALSE - Otherwise.

--*/
{
    PIRP Irp;
    KIRQL CancelIrql;
    PKDEVICE_QUEUE_ENTRY Packet;
    LOGICAL Started;
    BOOLEAN RestartLun;
    
    //
    // NB: Cancelation is NYI
    //

    ASSERT (KeGetCurrentIrql () == DISPATCH_LEVEL);
    ASSERT (Cancelable == FALSE);

    Started = FALSE;
    RestartLun = FALSE;
    
    //
    // If the queue has changed, remove any extra elements on the queue.
    // Extra queue elements can exist on a queue that has been frozen and
    // resumed or when the queue depth increased. In either of these
    // cases, the queue can be in the ready state, but have elements on
    // either the device or bypass queue. In either of these cases, we
    // need to do the same thing: pull elements off of the queue until
    // there are no more elements in the queue or until we have saturated
    // the device (are in the busy state).
    //
    
    if (InterlockedExchange (&IoQueue->QueueChanged, FALSE)) {

        for (Packet = RaidNormalizeExDeviceQueue (&IoQueue->DeviceQueue);
             Packet != NULL;
             Packet = RaidNormalizeExDeviceQueue (&IoQueue->DeviceQueue)) {

            Irp = CONTAINING_RECORD (Packet,
                                     IRP,
                                     Tail.Overlay.DeviceQueueEntry);

            IoQueue->StartIo (IoQueue->DeviceObject, Irp, NULL);
        }
    }

    //
    // Remove the next entry from the device queue, and call StartIo
    // with that entry.
    //
    
    Packet = RaidRemoveExDeviceQueue (&IoQueue->DeviceQueue,
                                      RestartQueue,
                                      &RestartLun);

    if (RestartLun) {
        for (Packet = RaidNormalizeExDeviceQueue (&IoQueue->DeviceQueue);
             Packet != NULL;
             Packet = RaidNormalizeExDeviceQueue (&IoQueue->DeviceQueue)) {

            Irp = CONTAINING_RECORD (Packet,
                                     IRP,
                                     Tail.Overlay.DeviceQueueEntry);

            IoQueue->StartIo (IoQueue->DeviceObject, Irp, NULL);
        }
    }
        
    if (Packet) {
        Irp = CONTAINING_RECORD (Packet,
                                 IRP,
                                 Tail.Overlay.DeviceQueueEntry);

        ASSERT (Irp->Type == IO_TYPE_IRP);
        IoQueue->StartIo (IoQueue->DeviceObject, Irp, Context);
        Started = TRUE;
    }

    return Started;
}

VOID
RaidFreezeIoQueue(
    IN PIO_QUEUE IoQueue
    )
/*++

Routine Description:

    Freeze the IoQueue. After the IoQueue has been frozen, only bypass
    requests will be executed.

Arguments:

    IoQueue - IoQueue to freeze.

Return Value:

    None.

--*/
{
    //
    // Freeze the underlying device queue object.
    //
    
    RaidFreezeExDeviceQueue (&IoQueue->DeviceQueue);
}


LOGICAL
RaidResumeIoQueue(
    IN PIO_QUEUE IoQueue
    )
/*++

Routine Description:

    Resume a frozen IoQueue.

Arguments:

    IoQueue - IoQueue to resume.

Return Value:

    TRUE - If we resumed the queue.

    FALSE - If we did not resume the queue because the resume count is
        non-zero.

--*/
{
    LOGICAL Resumed;

    Resumed = RaidResumeExDeviceQueue (&IoQueue->DeviceQueue);

    if (Resumed) {
        InterlockedExchange (&IoQueue->QueueChanged, TRUE);
    }

    return Resumed;
}


PIRP
RaidRemoveIoQueue(
    IN PIO_QUEUE IoQueue
    )
/*++

Routine Description:

    If there is a non-bypass element on the device queue, remove and
    return it, otherwise, return NULL.

Arguments:

    IoQueue - Supplies the IoQueue to remove the entry from.

Return Value:

    NULL - If there are no more entries in the non-bypass queue.

    Non-NULL - Supplies a pointer to an IRP removed from the device
            queue.

--*/
{
    PKDEVICE_QUEUE_ENTRY Packet;
    PIRP Irp;

    Packet = RaidRemoveExDeviceQueueIfPending (&IoQueue->DeviceQueue);

    if (Packet) {
        Irp = CONTAINING_RECORD (Packet,
                                 IRP,
                                 Tail.Overlay.DeviceQueueEntry);
    } else {
        Irp = NULL;
    }

    return Irp;
}



VOID
RaidRestartIoQueue(
    IN PIO_QUEUE IoQueue
    )
{
    PKDEVICE_QUEUE_ENTRY Packet;
    PIRP Irp;
    
    //
    // NOTE: As an optimization, we should have ReinsertExDeviceQueue
    // return a boolean telling whether we did not normalize because
    // (1) there were no elements or (2) the adapter was busy. Returning
    // this boolean to the caller will give it the ability to stop
    // restarting queues in the unit list if the adapter can accept
    // no more requests.
    //
    
    Packet = RaidNormalizeExDeviceQueue (&IoQueue->DeviceQueue);

    if (Packet) {
        Irp = CONTAINING_RECORD (Packet,
                                 IRP,
                                 Tail.Overlay.DeviceQueueEntry);

        IoQueue->StartIo (IoQueue->DeviceObject, Irp, NULL);
    }
}

    
VOID
RaidPurgeIoQueue(
    IN PIO_QUEUE IoQueue,
    IN PIO_QUEUE_PURGE_ROUTINE PurgeRoutine,
    IN PVOID Context
    )
{
    PIRP Irp;
    
    ASSERT (PurgeRoutine != NULL);
    
    for (Irp = RaidRemoveIoQueue (IoQueue);
         Irp != NULL;
         Irp = RaidRemoveIoQueue (IoQueue)) {

         PurgeRoutine (IoQueue, Context, Irp);
    }
}

ULONG
RaidGetIoQueueDepth(
    IN PIO_QUEUE IoQueue
    )
/*++

Routine Description:

    This routine will return the depth of the IoQueue.  Currently this is just
    a query of the Exqueue for it's properties which includes the Depth.

Arguments:

    IoQueue - Supplies the IoQueue whose Depth should be found. 

Return Value:

    The current Maximum Depth of the queue.

--*/
{
    EXTENDED_DEVICE_QUEUE_PROPERTIES Properties;

    //
    // Get the ExQueue's properties.
    //
    RaidGetExDeviceQueueProperties (&IoQueue->DeviceQueue,
                                    &Properties);

    return Properties.Depth;
}

ULONG
RaidSetIoQueueDepth(
    IN PIO_QUEUE IoQueue,
    IN ULONG Depth
    )
/*++

Routine Description:

    This routine will set the number of outstanding requests for the IoQueue
    to Depth.  In reality this currently is just a wrapper for the ExQueue
    function that sets the Depth.

Arguments:

    IoQueue - Supplies the IoQueue whose Depth should be set.

    Depth - Indicates the number of outstanding requests allowed.

Return Value:

    The Queue Depth that IoQueue will now use.

--*/
{
    ULONG CurrentDepth;

    //
    // Get the current set Depth.
    //
    CurrentDepth = RaidGetIoQueueDepth (IoQueue);

    //
    // Handle the silly requests.
    //
    
    if (Depth == 0) {
        return CurrentDepth;
    }  

    if (Depth >= TAG_QUEUE_SIZE) {
        return CurrentDepth;
    }        

    //
    // For now, simply call the ExQueue function to trim this to Depth.
    // 

    RaidSetExDeviceQueueDepth (&IoQueue->DeviceQueue,
                               Depth);
    return Depth;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\portcfg.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	portcfg.h

Abstract:

	Declaration of operations on the PORT_CONFIGURATION_INFORMATION object.

Author:

	Matthew D Hendel (math) 20-Apr-2000b

Revision History:

--*/

#pragma once


//
// Creation and destruction of the configuration object.
//

VOID
RaCreateConfiguration(
	IN PPORT_CONFIGURATION_INFORMATION PortConfiguration
	);

NTSTATUS
RaInitializeConfiguration(
	OUT PPORT_CONFIGURATION_INFORMATION PortConfiguration,
	IN PHW_INITIALIZATION_DATA HwInitializationData,
	IN ULONG BusNumber
	);

VOID
RaDeleteConfiguration(
	IN PPORT_CONFIGURATION_INFORMATION PortConfiguration
	);

//
// Operations
//

NTSTATUS
RaAssignConfigurationResources(
	IN OUT PPORT_CONFIGURATION_INFORMATION PortConfiguration,
	IN PCM_RESOURCE_LIST AllocatedResources,
	IN ULONG NumberOfAccessRanges
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\port.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    port.c

Abstract:

    This module defines the miniport -> port interface the
    StorPort minidriver uses to communicate with the driver.

Author:

    Matthew D Hendel (math) 24-Apr-2000

Revision History:

--*/


#include "precomp.h"




//
// Globals
//

//
// StorMiniportQuiet specifies whether we ignore print out miniport debug
// prints (FALSE) or not (TRUE). This is important for miniports that
// print out excessive debugging information.
//

#if DBG
LOGICAL StorMiniportQuiet = FALSE;
#endif

extern ULONG RaidVerifierEnabled;


//
// Private functions
//

PRAID_ADAPTER_EXTENSION
RaidpPortGetAdapter(
    IN PVOID HwDeviceExtension
    )
/*++

Routine Description:

    Get the adapter from the HW Device extension.

Arguments:

    HwDeviceExtension - HW Device extension.

Return Value:

    Non-NULL - Adapter object.

    NULL - If the associated adapter extension could not be found.

--*/
{
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_MINIPORT Miniport;
    
    Miniport = RaHwDeviceExtensionGetMiniport(HwDeviceExtension);
    Adapter = RaMiniportGetAdapter (Miniport);

    return Adapter;
}


//
// Public functions
//


BOOLEAN
StorPortPause(
    IN PVOID HwDeviceExtension,
    IN ULONG Timeout
    )
/*++

Routine Description:

    Pause an adapter for some period of time. All requests to the adapter
    will be held until the timeout expires or the device resumes.  All
    requests to all targets attached to the HBA will be held until the
    target is resumed or the timeout expires.

    Since the pause and resume functions have to wait until the processor
    has returned to DISPATCH_LEVEL to execute, they are not particularly
    fast.

Arguments:

    HwDeviceExtension - Device extension of the Adapter to pause.

    Timeout - Time out in (Seconds?) when the device should be resumed.

Return Value:

    TRUE on success, FALSE on failure.

--*/
{
    PRAID_DEFERRED_HEADER Entry;
    PRAID_DEFERRED_ELEMENT Item;
    PRAID_ADAPTER_EXTENSION Adapter;

    Adapter = RaidpPortGetAdapter (HwDeviceExtension);

    if (Adapter == NULL) {
        return FALSE;
    }

    Entry = RaidAllocateDeferredItem (&Adapter->DeferredQueue);

    if (Entry == NULL) {
        InterlockedIncrement (&RaidUnloggedErrors);
        return FALSE;
    }

    Item = CONTAINING_RECORD (Entry, RAID_DEFERRED_ELEMENT, Header);
    Item->Type = RaidDeferredPause;
    Item->Pause.Timeout = Timeout;

    //
    // Synchronously put the adapter into a paused state.
    //

    RaidPauseAdapterQueue (Adapter);

    //
    // Queue a work item to setup the DPC that will resume the adapter when
    // the specified time interval expires.
    //
    
    RaidQueueDeferredItem (&Adapter->DeferredQueue, &Item->Header);

    return TRUE;
}



BOOLEAN
StorPortResume(
    IN PVOID HwDeviceExtension
    )
/*++

Routine Description:

    Resume a paused adapter.

Arguments:

    HwDeviceExtension - Device extension of the adapter to pause.

Return Value:

    TRUE on success, FALSE on failure.

--*/
{
    PRAID_DEFERRED_HEADER Entry;
    PRAID_DEFERRED_ELEMENT Item;
    PRAID_ADAPTER_EXTENSION Adapter;
    
    Adapter = RaidpPortGetAdapter (HwDeviceExtension);

    if (Adapter == NULL) {
        return FALSE;
    }
    
    Entry = RaidAllocateDeferredItem (&Adapter->DeferredQueue);

    if (Entry == NULL) {
        InterlockedIncrement (&RaidUnloggedErrors);
        return FALSE;
    }

    Item = CONTAINING_RECORD (Entry, RAID_DEFERRED_ELEMENT, Header);

    Item->Type = RaidDeferredResume;

    //
    // Queue a work item to stop the timer, resume the adapter and restart
    // the adapter queues.
    //

    RaidQueueDeferredItem (&Adapter->DeferredQueue, &Item->Header);

    return TRUE;
}

BOOLEAN
StorPortPauseDevice(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN ULONG Timeout
    )
/*++

Routine Description:

    Pause a specific logical unit.

Arguments:

    HwDeviceExtension - Supplies the device extension for the HBA.

    PathId, TargetId, Lun - Supplies the SCSI target address for to be paused.

    Timeout - Supplies the timeout.

Return Value:

    TRUE - Success, FALSE for failure.

--*/
{
    PRAID_DEFERRED_HEADER Entry;
    PRAID_DEFERRED_ELEMENT Item;
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_UNIT_EXTENSION Unit;
    RAID_ADDRESS Address;
    
    Adapter = RaidpPortGetAdapter (HwDeviceExtension);

    if (Adapter == NULL) {
        return FALSE;
    }

    Address.PathId = PathId;
    Address.TargetId = TargetId;
    Address.Lun = Lun;
    
    Unit = RaidAdapterFindUnit (Adapter, Address);
    if (Unit == NULL) {
        DebugWarn (("Could not find logical unit for (%d %d %d)\n",
                    "    Pause unit request ignored.\n",
                    (ULONG)Address.PathId,
                    (ULONG)Address.TargetId,
                    (ULONG)Address.Lun));
        return FALSE;
    }


    Entry = &Unit->DeferredList.PauseDevice.Header;
    Entry = RaidAllocateDeferredItemFromFixed (Entry);

    if (Entry == NULL) {
        InterlockedIncrement (&RaidUnloggedErrors);
        return FALSE;
    }

    Item = CONTAINING_RECORD (Entry, RAID_DEFERRED_ELEMENT, Header);

    Item->Type = RaidDeferredPauseDevice;
    Item->Address = Address;
    Item->Pause.Timeout = Timeout;
    
    //
    // Mark the queue as paused.
    //
    
    RaidPauseUnitQueue (Unit);

    //
    // Issue a deferred routine to perform the rest of the stuff.
    //
    
    RaidQueueDeferredItem (&Adapter->DeferredQueue, &Item->Header);

    return TRUE;
}

BOOLEAN
StorPortResumeDevice(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun
    )
/*++

Routine Description:

    Resume a logical unit from a paused state.

Arguments:

    HwDeviceExtension -

    PathId, TargetId, Lun - Address of the SCSI device to pause.

Return Value:

    BOOLEAN - TRUE on success, FALSE on failure.

--*/
{
    PRAID_DEFERRED_HEADER Entry;
    PRAID_DEFERRED_ELEMENT Item;
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_UNIT_EXTENSION Unit;
    RAID_ADDRESS Address;
    
    Adapter = RaidpPortGetAdapter (HwDeviceExtension);

    if (Adapter == NULL) {
        return FALSE;
    }

    Address.PathId = PathId;
    Address.TargetId = TargetId;
    Address.Lun = Lun;
    
    Unit = RaidAdapterFindUnit (Adapter, Address);
    if (Unit == NULL) {
        return FALSE;
    }

    Entry = &Unit->DeferredList.ResumeDevice.Header;
    Entry = RaidAllocateDeferredItemFromFixed (Entry);

    if (Entry == NULL) {
        InterlockedIncrement (&RaidUnloggedErrors);
        return FALSE;
    }

    Item = CONTAINING_RECORD (Entry, RAID_DEFERRED_ELEMENT, Header);

    Item->Type = RaidDeferredResumeDevice;
    Item->Address = Address;
    
    //
    // Queue a deferred routine to perform the timer stuff. Even if we didn't
    // resume the queue, we will still need to cancel the timer.
    //
    
    RaidQueueDeferredItem (&Adapter->DeferredQueue, &Item->Header);

    return TRUE;
}


BOOLEAN
RaidpLinkDown(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    The miniport has notified us the the link is down and will likely be down
    for some time.  We will pause the adapter and indicate that the link is
    down.

    For now, link down conditions just piggy-back the pause functionality with
    the addition of the LinkUp flag being set to false.  This will cause us
    to hold and requests until the adapter is resumed.  If the adapter is
    resumed and the LinkUp flag is not restored to TRUE, we'll fail all the
    requests we were holding and any new ones that arrive.
    
Arguments:

    Adapter - Pointer to the adapter extension.
    
Return Value:

    TRUE on success, FALSE on failure.

--*/
{
    BOOLEAN Paused;
    Paused = StorPortPause (Adapter->Miniport.PrivateDeviceExt,
                            Adapter->LinkDownTimeoutValue);
    if (Paused) {
        InterlockedExchange (&Adapter->LinkUp, FALSE);
    }

    return Paused;
}

BOOLEAN
RaidpLinkUp(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    The miniport has notified us the the link has been restored.  We should
    only receive this notification when the link is down.  We indicate that
    the link is up and resume the adapter.  This will resubmit all held
    requests.  We also initiate a rescan just to ensure that the configuration
    has not changed.
    
Arguments:

    Adapter - Pointer to the adapter extension.
    
Return Value:

    TRUE on success, FALSE on failure.

--*/
{
    BOOLEAN Resumed;

    InterlockedExchange (&Adapter->LinkUp, TRUE);
    Resumed = StorPortResume (Adapter->Miniport.PrivateDeviceExt);
    if (Resumed) {

        //
        // Invalidate device relations on a link up notification so filters and
        // and MPIO can know that the link is restored.  This works because
        // these components can sift through the QDR data and figure out that
        // a device/path is still operational.
        //

        IoInvalidateDeviceRelations (Adapter->PhysicalDeviceObject, 
                                     BusRelations);
    }

    return Resumed;
}

BOOLEAN
StorPortDeviceBusy(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN ULONG RequestsToComplete
    )
/*++

Routine Description:

    Notify the port driver that the specified target is currently busy
    handling outstanding requests. The port driver will not issue any new
    requests to the logical unit until the logical unit's queue has been
    drained to a sufficient level where processing may continue.

    This is not considered an erroneous condition; no error log is
    generated.
    
Arguments:

    HwDeviceExtension -
    
    PathId, TargetId, Lun - Supplies the SCSI target address of the
        device to busy.
    
    ReqsToComplete - 

Return Value:

    TRUE on success, FALSE on failure.

--*/
{
    PRAID_DEFERRED_HEADER Entry;
    PRAID_DEFERRED_ELEMENT Item;
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_UNIT_EXTENSION Unit;
    RAID_ADDRESS Address;
    
    Adapter = RaidpPortGetAdapter (HwDeviceExtension);

    if (Adapter == NULL) {
        return FALSE;
    }

    Address.PathId = PathId;
    Address.TargetId = TargetId;
    Address.Lun = Lun;
    
    Unit = RaidAdapterFindUnit (Adapter, Address);
    if (Unit == NULL) {
        return FALSE;
    }

    Entry = &Unit->DeferredList.DeviceBusy.Header;
    Entry = RaidAllocateDeferredItemFromFixed (Entry);

    if (Entry == NULL) {
        InterlockedIncrement (&RaidUnloggedErrors);
        return FALSE;
    }

    Item = CONTAINING_RECORD (Entry, RAID_DEFERRED_ELEMENT, Header);

    Item->Type = RaidDeferredDeviceBusy;
    Item->Address = Address;
    Item->DeviceBusy.RequestsToComplete = RequestsToComplete;

    RaidQueueDeferredItem (&Adapter->DeferredQueue, &Item->Header);

    return TRUE;
}


BOOLEAN
StorPortDeviceReady(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun
    )
/*++

Routine Description:

    Notify the port driver that the device is again ready to handle new
    requests. It is not generally necessary to notify the target
    that new request are desired.

Arguments:

    HwDeviceExtension -

    PathId, TargetId, Lun - Supplies the SCSI target address of the device
        to ready.

Return Value:

    TRUE on success, FALSE on failure.
    
--*/
{
    PRAID_DEFERRED_HEADER Entry;
    PRAID_DEFERRED_ELEMENT Item;
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_UNIT_EXTENSION Unit;
    RAID_ADDRESS Address;
    
    Adapter = RaidpPortGetAdapter (HwDeviceExtension);

    if (Adapter == NULL) {
        return FALSE;
    }

    Address.PathId = PathId;
    Address.TargetId = TargetId;
    Address.Lun = Lun;
    
    Unit = RaidAdapterFindUnit (Adapter, Address);
    if (Unit == NULL) {
        return FALSE;
    }

    Entry = &Unit->DeferredList.DeviceReady.Header;
    Entry = RaidAllocateDeferredItemFromFixed (Entry);

    if (Entry == NULL) {
        InterlockedIncrement (&RaidUnloggedErrors);
        return FALSE;
    }

    Item = CONTAINING_RECORD (Entry, RAID_DEFERRED_ELEMENT, Header);

    Item->Type = RaidDeferredDeviceReady;
    Item->Address = Address;

    RaidQueueDeferredItem (&Adapter->DeferredQueue, &Item->Header);

    return TRUE;
}


BOOLEAN
StorPortBusy(
    IN PVOID HwDeviceExtension,
    IN ULONG RequestsToComplete
    )
/*++

Routine Description:

    Notify the port driver thet the HBA is currenlty busy handling
    outstanding requests. The port driver will hold any requests until
    the HBA has completed enough outstanding requests so that it may
    continue processing requests.

Arguments:

    HwDeviceExtension -

    ReqsToComplete -

Return Value:

    TRUE on success, FALSE on failure.

--*/
{
    PRAID_DEFERRED_HEADER Entry;
    PRAID_DEFERRED_ELEMENT Item;
    PRAID_ADAPTER_EXTENSION Adapter;
    
    Adapter = RaidpPortGetAdapter (HwDeviceExtension);

    if (Adapter == NULL) {
        return FALSE;
    }

    Entry = RaidAllocateDeferredItem (&Adapter->DeferredQueue);

    if (Entry == NULL) {
        InterlockedIncrement (&RaidUnloggedErrors);
        return FALSE;
    }

    Item = CONTAINING_RECORD (Entry, RAID_DEFERRED_ELEMENT, Header);

    Item->Type = RaidDeferredBusy;
    Item->Busy.RequestsToComplete = RequestsToComplete;
    
    RaidQueueDeferredItem (&Adapter->DeferredQueue, &Item->Header);

    return TRUE;
}

BOOLEAN
StorPortReady(
    IN PVOID HwDeviceExtension
    )
/*++

Routine Description:

    Notify the port driver that the HBA is no longer busy.

Arguments:

    HwDeviceExtension - 
    
Return Value:

    TRUE on success, FALSE on failure.

--*/
{
    PRAID_DEFERRED_HEADER Entry;
    PRAID_DEFERRED_ELEMENT Item;
    PRAID_ADAPTER_EXTENSION Adapter;
    
    Adapter = RaidpPortGetAdapter (HwDeviceExtension);

    if (Adapter == NULL) {
        return FALSE;
    }

    Entry = RaidAllocateDeferredItem (&Adapter->DeferredQueue);

    if (Entry == NULL) {
        InterlockedIncrement (&RaidUnloggedErrors);
        return FALSE;
    }

    Item = CONTAINING_RECORD (Entry, RAID_DEFERRED_ELEMENT, Header);

    Item->Type = RaidDeferredReady;

    RaidQueueDeferredItem (&Adapter->DeferredQueue, &Item->Header);

    return TRUE;
}



BOOLEAN
StorPortSynchronizeAccess(
    IN PVOID HwDeviceExtension,
    IN PSTOR_SYNCHRONIZED_ACCESS SynchronizedAccessRoutine,
    IN PVOID Context
    )
{
    BOOLEAN Succ;
    KIRQL OldIrql;
    PRAID_ADAPTER_EXTENSION Adapter;
    
    //
    // NOTE: At this time we should not call this routine from
    // the HwBuildIo routine.
    // 

    Adapter = RaidpPortGetAdapter (HwDeviceExtension);

    if (Adapter == NULL) {
        return FALSE;
    }

    if (Adapter->IoModel == StorSynchronizeFullDuplex) {
        OldIrql = KeAcquireInterruptSpinLock (Adapter->Interrupt);
    }

    Succ = SynchronizedAccessRoutine (HwDeviceExtension, Context);

    if (Adapter->IoModel == StorSynchronizeFullDuplex) {
        KeReleaseInterruptSpinLock (Adapter->Interrupt, OldIrql);
    }

    return Succ;
}



PSTOR_SCATTER_GATHER_LIST
StorPortGetScatterGatherList(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )
/*++

Routine Description:

    Return the SG list associated with the specified SRB.

Arguments:

    HwDeviceExtension - Supplies the HW device extension this SRB is
        assoicated with.

    Srb - Supplies the SRB to return the SG list for.
    
Return Value:

    If non-NULL, the scatter-gather list assoicated with this SRB.

    If NULL, failure.

--*/
{
    PEXTENDED_REQUEST_BLOCK Xrb;
    PVOID RemappedSgList;

    ASSERT (HwDeviceExtension != NULL);

    //
    // NB: Put in a DBG check that the HwDeviceExtension matches the
    // HwDeviceExtension assoicated with the SRB.
    //

    Xrb = RaidGetAssociatedXrb (Srb);
    ASSERT (Xrb != NULL);

    return (PSTOR_SCATTER_GATHER_LIST)Xrb->SgList;
}
    

PVOID
StorPortGetLogicalUnit(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun
    )
/*++

Routine Description:

    Given a PathId, Targetid and Lun, get the Logical Unit extension
    associated with that triplet.

    NB: To improve speed, we could add StorPortGetLogicalUnitBySrb which
    gets the logical unit from a given SRB. The latter function is much
    easier to implement (no walking of lists).

Arguments:

    HwDeviceExtension -

    PathId - SCSI PathId.

    TargetId - SCSI TargetId.

    Lun - SCSI Logical Unit number.

Return Value:

    NTSTATUS code.

--*/
{
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_UNIT_EXTENSION Unit;
    RAID_ADDRESS Address;
    PVOID UnitExtension;

    UnitExtension = NULL;
    Adapter = RaidpPortGetAdapter (HwDeviceExtension);

    if (Adapter == NULL) {
        return NULL;
    }

    Address.PathId = PathId;
    Address.TargetId = TargetId;
    Address.Lun = Lun;
    
    Unit = RaidAdapterFindUnit (Adapter, Address);

    if (Unit) {
        UnitExtension = Unit->UnitExtension;
    }

    return UnitExtension;
}

VOID
StorPortNotification(
    IN SCSI_NOTIFICATION_TYPE NotificationType,
    IN PVOID HwDeviceExtension,
    ...
    )
{
    PRAID_ADAPTER_EXTENSION Adapter;
    PSCSI_REQUEST_BLOCK Srb;
    PHW_INTERRUPT HwTimerRoutine;
    ULONG Timeout;
    va_list ap;

    Adapter = RaidpPortGetAdapter (HwDeviceExtension);
    
    va_start(ap, HwDeviceExtension);

    switch (NotificationType) {

        case RequestComplete:
            Srb = va_arg (ap, PSCSI_REQUEST_BLOCK);
            RaidAdapterRequestComplete (Adapter, RaidGetAssociatedXrb (Srb));
            break;

        case ResetDetected:
            //
            // Pause the adapter for four seconds.
            //
            StorPortPause (HwDeviceExtension, DEFAULT_RESET_HOLD_TIME);
            break;

        case BusChangeDetected:
            //
            // Request a bus rescan and invalidate the current
            // device relations when we drop to DISPATCH_LEVEL again.
            //

            Adapter->Flags.InvalidateBusRelations = TRUE;
            Adapter->Flags.RescanBus = TRUE;
            KeInsertQueueDpc (&Adapter->BusChangeDpc, NULL, NULL);
            break;

        case NextRequest:
            //
            // One of the requirements for StorPort that the miniport
            // can handle the next request by the time it returns
            // from StartIo. Therefore, this notification is irrelevent.
            // Maybe use it for debugging purposes (can a specific
            // MINIPORT easily be converted to a StorPort miniport).
            //
            break;

        case NextLuRequest:
            //
            // See above comment.
            //
            break;


        case RequestTimerCall:
            HwTimerRoutine = va_arg (ap, PHW_INTERRUPT);
            Timeout = va_arg (ap, ULONG);
            RaidAdapterRequestTimerDeferred (Adapter,
                                             HwTimerRoutine,
                                             Timeout);
            break;
            
        case WMIEvent: {
            //
            // The miniport wishes to post a WMI event for the adapter
            // or a specified SCSI target.
            //

            PRAID_DEFERRED_HEADER Entry;
            PRAID_WMI_DEFERRED_ELEMENT Item;
            PWNODE_EVENT_ITEM          wnodeEventItem;
            UCHAR                   pathId;
            UCHAR                   targetId;
            UCHAR                   lun;            

            wnodeEventItem     = va_arg(ap, PWNODE_EVENT_ITEM);
            pathId             = va_arg(ap, UCHAR);

            //
            // if pathID is 0xFF, that means that the WmiEevent is from the
            // adapter, no targetId or lun is neccesary
            //
            if (pathId != 0xFF) {
                targetId = va_arg(ap, UCHAR);
                lun      = va_arg(ap, UCHAR);
            }

            //
            // Validate the event first.  Then attempt to obtain a free
            // deferred item structure so that we may store
            // this request and process it at DPC level later.  If none
            // are obtained or the event is bad, we ignore the request.
            //

            if ((wnodeEventItem == NULL) ||
                (wnodeEventItem->WnodeHeader.BufferSize >
                 WMI_MINIPORT_EVENT_ITEM_MAX_SIZE)) {
                break;
            }


            Entry = RaidAllocateDeferredItem (&Adapter->WmiDeferredQueue);

            if (Entry == NULL) {
                break;
            }

            Item = CONTAINING_RECORD (Entry, RAID_WMI_DEFERRED_ELEMENT, Header);

            Item->PathId        = pathId;

            //
            // If pathId was 0xFF, then there is no defined value for
            // targetId or lun
            //
            if (pathId != 0xFF) {
                Item->TargetId      = targetId;
                Item->Lun           = lun;
            }

            RtlCopyMemory(&Item->WnodeEventItem,
                          wnodeEventItem,
                          wnodeEventItem->WnodeHeader.BufferSize);

            RaidQueueDeferredItem (&Adapter->WmiDeferredQueue, &Item->Header);
            break;
        }            


        case WMIReregister:
            //
            // NB: Fix this.
            //
            break;

        case LinkUp:
            RaidpLinkDown (Adapter);
            break;

        case LinkDown:
            RaidpLinkUp (Adapter);
            break;

#if DBG
        case 0xDEAD: {
            ULONG Reason;
            PSCSI_REQUEST_BLOCK Srb;
            PEXTENDED_REQUEST_BLOCK Xrb;
            PIRP Irp;
            PVOID Parameter2;
            PVOID Parameter3;
            PVOID Parameter4;
            
            Srb = va_arg (ap, PSCSI_REQUEST_BLOCK);
            Reason = va_arg (ap, ULONG);
            Parameter2 = va_arg (ap, PVOID);
            Parameter3 = va_arg (ap, PVOID);
            Parameter4 = va_arg (ap, PVOID);

            if (Srb) {
                Xrb = RaidGetAssociatedXrb (Srb);
                Irp = Xrb->Irp;
            } else {
                Irp = NULL;
            }

            DbgLogRequest (Reason,
                           Irp,
                           Parameter2,
                           Parameter3,
                           Parameter4);
            break;
        }
#endif
            
        default:
            ASSERT (FALSE);

    }

    va_end(ap);

}

VOID
StorPortLogError(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb OPTIONAL,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN ULONG ErrorCode,
    IN ULONG UniqueId
    )
/*++

Routine Description:

    This routine saves the error log information, and queues a DPC if
    necessary.

Arguments:

    HwDeviceExtension - Supplies the HBA miniport driver's adapter data
            storage.

    Srb - Supplies an optional pointer to srb if there is one.

    TargetId, Lun and PathId - specify device address on a SCSI bus.

    ErrorCode - Supplies an error code indicating the type of error.

    UniqueId - Supplies a unique identifier for the error.

Return Value:

    None.

--*/
{
    PRAID_ADAPTER_EXTENSION Adapter;

    //
    // Check out the reason for the error.
    //
    
    Adapter = RaidpPortGetAdapter (HwDeviceExtension);

    if (Adapter == NULL) {
        return ;
    }   

    RaidAdapterLogIoErrorDeferred (Adapter,
                                   PathId,
                                   TargetId,
                                   Lun,
                                   ErrorCode,
                                   UniqueId);
}

VOID
StorPortCompleteRequest(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN UCHAR SrbStatus
    )
/*++

Routine Description:

    Complete all active requests for the specified logical unit.

Arguments:

    DeviceExtenson - Supplies the HBA miniport driver's adapter data storage.

    TargetId, Lun and PathId - specify device address on a SCSI bus.

    SrbStatus - Status to be returned in each completed SRB.

Return Value:

    None.

--*/
{
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_UNIT_EXTENSION Unit;
    RAID_ADDRESS Address;
    BOOLEAN Inserted;

    //
    // Check out the reason for the error.
    //
    
    Adapter = RaidpPortGetAdapter (HwDeviceExtension);

    if (Adapter == NULL) {
        return;
    }   

    //
    // If this request is for a lun, pause just the lun that we're
    // completing requests for. Otherwise, pause the HBA until
    // the completion can happen.
    //
    
    if (PathId   != SP_UNTAGGED &&
        TargetId != SP_UNTAGGED &&
        Lun      != SP_UNTAGGED) {

        Address.PathId = PathId;
        Address.TargetId = TargetId;
        Address.Lun = Lun;

        Unit = RaidAdapterFindUnit (Adapter, Address);

        if (Unit == NULL) {
            DebugWarn (("Could not find logical unit for (%d %d %d)\n",
                        "    StorPortCompleteRequest ignored.\n",
                        (ULONG)PathId,
                        (ULONG)TargetId,
                        (ULONG)Lun));
            return ;
        }

        ASSERT_UNIT (Unit);
        RaidPauseUnitQueue (Unit);

    } else {
        RaidPauseAdapterQueue (Adapter);
    }

    Inserted = KeInsertQueueDpc (&Adapter->CompletionDpc,
                                 (PVOID)(ULONG_PTR)StorScsiAddressToLong2 (PathId, TargetId, Lun),
                                 (PVOID)(ULONG_PTR)SrbStatus);


    //
    // We will fail to insert the DPC only when there is already one
    // outstanding. This is fine, it means we haven't been able to process
    // the completion request yet.
    //

    if (!Inserted) {
        if (PathId   != SP_UNTAGGED &&
            TargetId != SP_UNTAGGED &&
            Lun      != SP_UNTAGGED) {

            ASSERT_UNIT (Unit);
            RaidResumeUnitQueue (Unit);
        } else {
            RaidResumeAdapterQueue (Adapter);
        }
    }
}

BOOLEAN
StorPortSetDeviceQueueDepth(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN ULONG Depth
    )
/*++

Routine Description:

    Set the maximum depth of the device queue identified by PathId, TargetId, Lun. 
    The queue depth is between 1 and 255.

Arguments:

    HwDeviceExtension - Supplies device extension for the HBA to operate on.
    PathId, TargetId, Lun - Supplies the path, target and lun to operate on.
    Depth - Supplies the new depth to set to. Must be between 0 and 255.

Return Values:

    TRUE - If the depth was set.
    
--*/
{
    PRAID_ADAPTER_EXTENSION adapter;
    PRAID_UNIT_EXTENSION unit;
    RAID_ADDRESS address;
    ULONG currentDepth;
    ULONG intendedDepth;
    BOOLEAN depthSet = FALSE;

    adapter = RaidpPortGetAdapter (HwDeviceExtension);

    if (adapter == NULL) {
        return FALSE; 
    }

    address.PathId = PathId;
    address.TargetId = TargetId;
    address.Lun = Lun;

    //
    // Try to get the unit that the address represents.
    //
    unit = RaidAdapterFindUnit (adapter, address);

    if (unit == NULL) {
        return FALSE;
    }    

    //
    // If the request is outside this device's Max. Depth, reject it.
    //
    if (Depth > unit->MaxQueueDepth) {
        return FALSE;
    }

    //
    // Determine the current queue depth.
    //
    currentDepth = RaidGetIoQueueDepth(&unit->IoQueue);

    //
    // Determine whether the call should be made.
    //
    if (currentDepth == Depth) {

        //
        // Queue is already at the requested depth.
        // 
        depthSet = TRUE;

    } else {

        //
        // Attempt the set. 
        // 
        currentDepth = RaidSetIoQueueDepth(&unit->IoQueue,
                                           Depth);

        //
        // Check whether it actually worked. The above routine has the necessary checks
        // to filter out bogus requests.
        // 
        if (currentDepth == Depth) {
            
            depthSet = TRUE;
        }
    }    

    return depthSet;
}
    


PUCHAR
StorPortAllocateRegistryBuffer(
    IN PVOID HwDeviceExtension,
    IN PULONG Length
    )
/*++

Routine Description:

    This routine will be called by the miniport to allocate a buffer that can be used 
    to Read/Write registry data. 

    Length is updated to reflect the actual size of the allocation.
    
    Only one registry buffer can be outstanding to each instantiation of a miniport at
    one time. So further allocations without the corresponding Free will fail.

Arguments:

    HwDeviceExtension - The miniport's Device Extension.
    Length - The requested/updated length of the buffer.

Return Value:

    The buffer or NULL if some error prevents the allocation. Length is updated to reflect
    the actual size.

--*/
{
    PRAID_ADAPTER_EXTENSION adapter;
    PPORT_REGISTRY_INFO registryInfo;
    PUCHAR buffer;
    NTSTATUS status;

    adapter = RaidpPortGetAdapter (HwDeviceExtension);
    registryInfo = &adapter->RegistryInfo;
   
    //
    // Set the length of the allocation.
    //
    registryInfo->LengthNeeded = *Length;
    
    //
    // Call the library to allocate the buffer for the miniport.
    //
    status = PortAllocateRegistryBuffer(registryInfo);

    if (NT_SUCCESS(status)) {

        //
        // Update the miniport's length.
        // 
        *Length = registryInfo->AllocatedLength;

        //
        // Return the buffer.
        // 
        buffer = registryInfo->Buffer;
    } else {

        //
        // Some error occurred. Return a NULL buffer and
        // update the miniport's Length to 0.
        // 
        buffer = NULL;
        *Length = 0;
    }
    
    return buffer;
}    


VOID
StorPortFreeRegistryBuffer(
    IN PVOID HwDeviceExtension,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    Frees the buffer allocated via PortAllocateRegistryBuffer. A side-effect of this
    is that it now will allow further calls to AllocateRegistryBuffer to succeed. 

    Only one registry buffer can be outstanding to each instantiation of a miniport at
    one time.

Arguments:

    HwDeviceExtension - The miniport's Device Extension.
    Buffer - The memory to free. 

Return Value:

    NONE

--*/
{
    PRAID_ADAPTER_EXTENSION adapter;
    PPORT_REGISTRY_INFO registryInfo;
    PUCHAR buffer;
    NTSTATUS status;

    adapter = RaidpPortGetAdapter (HwDeviceExtension);
    registryInfo = &adapter->RegistryInfo;
    
    //
    // Call the library to do the cleanup.
    //
    status = PortFreeRegistryBuffer(registryInfo);

    ASSERT(NT_SUCCESS(status));

    return;
}


BOOLEAN
StorpPortRegistryValidate(
    IN PPORT_REGISTRY_INFO RegistryInfo,
    IN PUCHAR Buffer,
    IN PULONG BufferLength
    )
{
    LONG offset;

    //
    // Determine the offset into the buffer.
    //
    offset = (LONG)((LONG_PTR)(Buffer - RegistryInfo->Buffer));

    //
    // Filter out any blatantly obvious length problems.
    // The library function will do further error checking on the buffer and
    // it's state.
    //
    if (*BufferLength > RegistryInfo->AllocatedLength) {

        //
        // Set the caller's length to that of the allocation, for lack of
        // something better.
        // 
        *BufferLength = RegistryInfo->AllocatedLength;
        return FALSE;

    } else if (*BufferLength == 0) {

        //
        // Perhaps succeeding a zero-length request would be appropriate, but this might
        // help limit errors in the miniport, if they aren't checking lengths correctly.
        // 
        return FALSE;
        
    } else if (Buffer == NULL) {

        //
        // No buffer, no operation.
        // 
        return FALSE;

    } else if (offset < 0) {

        //
        // Surely, this will 'never' happen. Miniport calculated a buffer before the 
        // allocation.
        //
        return FALSE;

    } else if ((offset + *BufferLength) > RegistryInfo->AllocatedLength) {

        //
        // Either the offset or offset+length falls outside the allocation.
        //
        return FALSE;
    }    

    //
    // Things look to be OK.
    //
    return TRUE;
}

 


BOOLEAN
StorPortRegistryRead(
    IN PVOID HwDeviceExtension,
    IN PUCHAR ValueName,
    IN ULONG Global,
    IN ULONG Type,
    IN PUCHAR Buffer,
    IN PULONG BufferLength
    )
/*++

Routine Description:

    This routine is used by the miniport to read the registry data at 
    HKLM\System\CurrentControlSet\Services\<serviceName>\Parameters\Device(N)\ValueName

    If Global it will use Device\ValueName otherwise the Ordinal will be determined and
    Device(N)\ValueName data will be returned if the buffer size is sufficient.

    The data is converted into a NULL-terminiated ASCII string from the UNICODE.
    
Arguments:

    HwDeviceExtension - The miniport's Device Extension.
    ValueName - The name of the data to be returned.
    Global - Indicates whether this is adapter-specific or relates to all adapters.
    Buffer - Storage for the returned data.
    BufferLength - Size, in bytes, of the buffer provided.

Return Value:

    TRUE - If the data at ValueName has been converted into ASCII and copied into buffer.
    BufferLength is updated to reflect the size of the return data.
    FALSE - An error occurred. If BUFFER_TOO_SMALL, BufferLength is updated to reflect the
    size that should be used, otherwise BufferLength is set to 0.

--*/
{
    PRAID_ADAPTER_EXTENSION adapter;
    PPORT_REGISTRY_INFO registryInfo;
    PUNICODE_STRING registryPath;
    UNICODE_STRING registryKeyName;
    UNICODE_STRING unicodeValue;
    PUCHAR buffer;
    NTSTATUS status;
    ULONG maxLength;
    LONG offset;
    BOOLEAN success = FALSE;

    //
    // Have to ensure that we are at PASSIVE.
    //
    if (KeGetCurrentIrql() != PASSIVE_LEVEL) {
        *BufferLength = 0;
        return FALSE;
    }

    adapter = RaidpPortGetAdapter (HwDeviceExtension);
    registryInfo = &adapter->RegistryInfo;
    registryPath = &adapter->Driver->RegistryPath;

    if (!StorpPortRegistryValidate(registryInfo,
                                  Buffer,
                                  BufferLength)) {
        //
        // Something about the buffer, the length, or the placement is incorrect.
        // The BufferLength might have gotten updated to reflect a recoverable problem.
        // 
        return FALSE;
    }    
       
    //
    // Determine the offset into the buffer.
    //
    offset = (LONG)((ULONG_PTR)Buffer - (ULONG_PTR)registryInfo->Buffer);

    //
    // Update the buffer length, based on the caller's parameter.
    //
    registryInfo->CurrentLength = *BufferLength;

    //
    // Set the offset with the allocated buffer.
    //
    registryInfo->Offset = offset;

    //
    // Preset length to zero in case of any errors.
    // 
    *BufferLength = 0;
    success = FALSE;

    //
    // Call the library to build the full keyname.
    // 
    status = PortBuildRegKeyName(registryPath,
                                 &registryKeyName,
                                 adapter->PortNumber,
                                 Global);
    
    if (NT_SUCCESS(status)) {

        //
        // Convert ValueName to Unicode.
        //
        status = PortAsciiToUnicode(ValueName, &unicodeValue);

        if (!NT_SUCCESS(status)) {

            //
            // Return an error to the miniport.
            // 
            return FALSE;
        }    
        
        //
        // Call the library to do the read.
        //
        status = PortRegistryRead(&registryKeyName,
                                  &unicodeValue,
                                  Type,
                                  registryInfo);
        if (NT_SUCCESS(status)) {

            //
            // Set the length to the size of the returned data.
            // 
            *BufferLength = registryInfo->CurrentLength; 
            success = TRUE;

        } else if (status == STATUS_BUFFER_TOO_SMALL) {

            //
            // LengthNeeded has been updated to show how big the buffer
            // should be for this operation. Return that to the miniport.
            //
            *BufferLength = registryInfo->LengthNeeded;

        } else {

            //
            // Some other error.
            //
            *BufferLength = 0;
        }

        //
        // Free the string allocated when converting ValueName.
        //
        RtlFreeUnicodeString(&unicodeValue);
    }

    return success;
        
}



BOOLEAN
StorPortRegistryWrite(
    IN PVOID HwDeviceExtension,
    IN PUCHAR ValueName,
    IN ULONG Global,
    IN ULONG Type,
    IN PUCHAR Buffer, 
    IN ULONG BufferLength
    )
/*++

Routine Description:

    This routine is called by the miniport to write the contents of Buffer to 
    HKLM\System\CurrentControlSet\Services\<serviceName>\Parameters\Device(N)\ValueName.

    If Global, it will use Device\ValueName, otherwise the Ordinal will be determined and 
    Device(N)\ValueName will be written with the contents of Buffer.

    The data is first converted from ASCII to UNICODE. 

Arguments:

    HwDeviceExtension - The miniport's Device Extension.
    ValueName - The name of the data to be written.
    Global - Indicates whether this is adapter-specific or relates to all adapters.
    Buffer - Storage containing the data to write. 
    BufferLength - Size, in bytes, of the buffer provided.

Return Value:

    TRUE - If the data was written successfully.
    FALSE - There was an error. 
    
--*/
{
    PRAID_ADAPTER_EXTENSION adapter;
    PPORT_REGISTRY_INFO registryInfo;
    PUNICODE_STRING registryPath;
    UNICODE_STRING registryKeyName;
    UNICODE_STRING unicodeValue;
    PUCHAR buffer;
    NTSTATUS status;
    ULONG maxLength;
    LONG offset;
    BOOLEAN success = FALSE;

    //
    // Have to ensure that we are at PASSIVE.
    //
    if (KeGetCurrentIrql() != PASSIVE_LEVEL) {
        return FALSE;
    }

    adapter = RaidpPortGetAdapter (HwDeviceExtension);
    registryInfo = &adapter->RegistryInfo;
    registryPath = &adapter->Driver->RegistryPath;

    if (!StorpPortRegistryValidate(registryInfo,
                                  Buffer,
                                  &BufferLength)) {
        //
        // Something about the buffer, the length, or the placement is incorrect.
        // The BufferLength might have gotten updated to reflect a recoverable problem.
        // 
        return FALSE;
    }    

    //
    // Determine the offset into the buffer.
    //
    offset = (LONG)((ULONG_PTR)Buffer - (ULONG_PTR)registryInfo->Buffer);

    //
    // Update the buffer length, based on the caller's parameter.
    //
    registryInfo->CurrentLength = BufferLength;

    //
    // Set the offset with the allocated buffer.
    //
    registryInfo->Offset = offset;

    //
    // Call the library to build the full keyname.
    // 
    status = PortBuildRegKeyName(registryPath,
                                 &registryKeyName,
                                 adapter->PortNumber,
                                 Global);
    
    if (!NT_SUCCESS(status)) {
        return success;
    }    

    //
    // Convert ValueName to Unicode.
    //
    status = PortAsciiToUnicode(ValueName, &unicodeValue);
    if (!NT_SUCCESS(status)) {
        return success;
    }    

    //
    // Call the port library to do the work.
    //
    status = PortRegistryWrite(&registryKeyName,
                               &unicodeValue,
                               Type,
                               registryInfo);
    if (NT_SUCCESS(status)) {

        //
        // Indicate that it was successful.
        //
        success = TRUE;
    }

    //
    // Need to free the buffer allocated when converting ValueName.
    //
    RtlFreeUnicodeString(&unicodeValue);

    return success;
}



VOID
StorPortMoveMemory(
    IN PVOID WriteBuffer,
    IN PVOID ReadBuffer,
    IN ULONG Length
    )

/*++

Routine Description:

    Copy from one buffer into another.

Arguments:

    ReadBuffer - source

    WriteBuffer - destination

    Length - number of bytes to copy

Return Value:

    None.

--*/

{
    RtlMoveMemory (WriteBuffer, ReadBuffer, Length);
}



//
// NB: Figure out how to pull in NTRTL.
//

ULONG
vDbgPrintExWithPrefix(
    IN PCH Prefix,
    IN ULONG ComponentId,
    IN ULONG Level,
    IN PCH Format,
    va_list arglist
    );
                        

VOID
StorPortDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR Format,
    ...
    )
{
    va_list arglist;

#if DBG    
    if (StorMiniportQuiet) {
        return;
    }
#endif    
    
    va_start (arglist, Format);
    vDbgPrintExWithPrefix ("STORMINI: ",
                           DPFLTR_STORMINIPORT_ID,
                           DebugPrintLevel,
                           Format,
                           arglist);
    va_end (arglist);
}


PSCSI_REQUEST_BLOCK
StorPortGetSrb(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN LONG QueueTag
    )

/*++

Routine Description:

    This routine retrieves an active SRB for a particuliar logical unit.

Arguments:

    HwDeviceExtension -

    PathId, TargetId, Lun - identify logical unit on SCSI bus.

    QueueTag - -1 indicates request is not tagged.

Return Value:

    SRB, if one exists. Otherwise, NULL.

--*/

{
    //
    // This function is NOT supported by storport.
    //
    
    return NULL;
}

#define CHECK_POINTER_RANGE(LowerBound,Address,Size)\
                            ((PUCHAR)(LowerBound) <= (PUCHAR)(Address) &&\
                            (PUCHAR)Address < ((PUCHAR)(LowerBound) + Size))

STOR_PHYSICAL_ADDRESS
StorPortGetPhysicalAddress(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PVOID VirtualAddress,
    OUT ULONG *Length
    )

/*++

Routine Description:

    Convert virtual address to physical address for DMA.  The only things the
    miniport is allowed to get the physical address of are:

        o HwDeviceExtension - Srb may be NULL or not.

        o Srb->DataBuffer field - Srb must be supplied.

        o Srb->SenseInfoBuffer field - Srb must be supplied.

        o Srb->SrbExtension field - Srb must be supplied. NOTE: this is
          new behavior for StorPort vs. SCSIPORT.
        
Arguments:

    HwDeviceExtension -

    Srb -

    VirtualAddress -

    Length -

Return Value:

    PhysicalAddress or NULL physical address on failure.

--*/

{
    PHYSICAL_ADDRESS Physical;
    PRAID_ADAPTER_EXTENSION Adapter;
    ULONG Offset;


    ASSERT (Length != NULL);

    Adapter = RaidpPortGetAdapter (HwDeviceExtension);

    if (RaidRegionInVirtualRange (&Adapter->UncachedExtension,
                                  VirtualAddress)) {

        //
        // We're within the uncached extension.
        //

        RaidRegionGetPhysicalAddress (&Adapter->UncachedExtension,
                                      VirtualAddress,
                                      &Physical,
                                      Length);

    } else if (Srb == NULL) {

        //
        // Temporary hack
        //

        DebugPrint (("**** Stor Miniport Error ****\n"));
        DebugPrint (("StorPortGetPhysicalAddress called with Srb parameter = NULL\n"));
        DebugPrint (("and VirtualAddress not in range of UncachedExtension\n"));
        DebugPrint (("If this is a VA in the Srb DataBuffer, SenseInfoBuffer or\n"));
        DebugPrint (("SrbExtension, you must pass the SRB in as a parameter.\n"));
        DebugPrint (("This is new behavior for storport.\n"));
        DebugPrint (("See StorPort release notes for more information.\n\n"));

        Physical = MmGetPhysicalAddress (VirtualAddress);
        *Length = RaGetSrbExtensionSize (Adapter);

    } else if (CHECK_POINTER_RANGE (Srb->DataBuffer, VirtualAddress,
                                    Srb->DataTransferLength)) {
        //
        // Within the Srb's DataBuffer, get the scatter-gather element
        // and it's size.
        //

        ULONG i;
        PEXTENDED_REQUEST_BLOCK Xrb;
        PSCATTER_GATHER_LIST ScatterList;
        

        Xrb = RaidGetAssociatedXrb (Srb);

        ScatterList = Xrb->SgList;
        Offset = (ULONG)((ULONG_PTR)VirtualAddress - (ULONG_PTR)Srb->DataBuffer);
        i = 0;
        while (Offset >= ScatterList->Elements[i].Length) {
            ASSERT (i < ScatterList->NumberOfElements);
            Offset -= ScatterList->Elements[i].Length;
            i++;
        }

        *Length = ScatterList->Elements[i].Length - Offset;
        Physical.QuadPart = ScatterList->Elements[i].Address.QuadPart + Offset;

    } else if (CHECK_POINTER_RANGE (Srb->SenseInfoBuffer, VirtualAddress,
                                    Srb->SenseInfoBufferLength)) {

        //
        // Within the sense info buffer.
        //
        
        Offset = (ULONG)((ULONG_PTR)VirtualAddress - (ULONG_PTR)Srb->SenseInfoBuffer);
        Physical = MmGetPhysicalAddress (VirtualAddress);
        *Length = Srb->SenseInfoBufferLength - Offset;

    } else if (CHECK_POINTER_RANGE (Srb->SrbExtension, VirtualAddress,
                                    RaGetSrbExtensionSize (Adapter))) {

        //
        // Within the Srb's extension region.
        //
        
        Offset = (ULONG)((ULONG_PTR)VirtualAddress - (ULONG_PTR)Srb->SrbExtension);
        Physical = MmGetPhysicalAddress (VirtualAddress);
        *Length = RaGetSrbExtensionSize (Adapter) - Offset;

    } else {

        //
        // Out of range.
        //
        
        Physical.QuadPart = 0;
        *Length = 0;
    }

    return Physical;
}


PVOID
StorPortGetVirtualAddress(
    IN PVOID HwDeviceExtension,
    IN STOR_PHYSICAL_ADDRESS PhysicalAddress
    )

/*++

Routine Description:

    This routine is returns a virtual address associated with a physical
    address, if the physical address was obtained by a call to
    ScsiPortGetPhysicalAddress.

Arguments:

    PhysicalAddress

Return Value:

    Virtual address

--*/

{
    //
    // NB: This is not as safe as the way SCSIPORT does this.
    //
    
    return MmGetVirtualForPhysical (PhysicalAddress);
}


BOOLEAN
StorPortValidateRange(
    IN PVOID HwDeviceExtension,
    IN INTERFACE_TYPE BusType,
    IN ULONG SystemIoBusNumber,
    IN STOR_PHYSICAL_ADDRESS IoAddress,
    IN ULONG NumberOfBytes,
    IN BOOLEAN InIoSpace
    )
/*++

Routine Description:

    This routine should take an IO range and make sure that it is not already
    in use by another adapter. This allows miniport drivers to probe IO where
    an adapter could be, without worrying about messing up another card.

Arguments:

    HwDeviceExtension - Used to find scsi managers internal structures

    BusType - EISA, PCI, PC/MCIA, MCA, ISA, what?

    SystemIoBusNumber - Which system bus?

    IoAddress - Start of range

    NumberOfBytes - Length of range

    InIoSpace - Is range in IO space?

Return Value:

    TRUE if range not claimed by another driver.

--*/
{
    //
    // This is for Win9x compatability.
    //
    
    return TRUE;
}


VOID
StorPortStallExecution(
    IN ULONG Delay
    )
{
    KeStallExecutionProcessor(Delay);
}



STOR_PHYSICAL_ADDRESS
StorPortConvertUlongToPhysicalAddress(
    ULONG_PTR UlongAddress
    )

{
    STOR_PHYSICAL_ADDRESS physicalAddress;

    physicalAddress.QuadPart = UlongAddress;
    return(physicalAddress);
}


//
// Leave these routines at the end of the file.
//

PVOID
StorPortGetDeviceBase(
    IN PVOID HwDeviceExtension,
    IN INTERFACE_TYPE BusType,
    IN ULONG SystemIoBusNumber,
    IN STOR_PHYSICAL_ADDRESS Address,
    IN ULONG NumberOfBytes,
    IN BOOLEAN InIoSpace
    )

/*++

Routine Description:

    This routine maps an IO address to system address space.
    Use ScsiPortFreeDeviceBase to unmap address.

Arguments:

    HwDeviceExtension - used to find port device extension.

    BusType - what type of bus - eisa, mca, isa

    SystemIoBusNumber - which IO bus (for machines with multiple buses).

    Address - base device address to be mapped.

    NumberOfBytes - number of bytes for which address is valid.

    IoSpace - indicates an IO address.

Return Value:

    Mapped address.

--*/

{
    NTSTATUS Status;
    PVOID MappedAddress;
    PRAID_ADAPTER_EXTENSION Adapter;
    PHYSICAL_ADDRESS CardAddress;

    //
    // REVIEW: Since we are a PnP driver, we do not have to deal with
    // miniport's who ask for addresses they are not assigned, right?
    //

    //
    // REVIEW: SCSIPORT takes a different path for reinitialization.
    //
    
    Adapter = RaidpPortGetAdapter (HwDeviceExtension);

    //
    // Translate the address.
    //
    
    Status = RaidTranslateResourceListAddress (
                    &Adapter->ResourceList,
                    BusType,
                    SystemIoBusNumber,
                    Address,
                    NumberOfBytes,
                    InIoSpace,
                    &CardAddress
                    );

    if (!NT_SUCCESS (Status)) {
        DebugPrint (("GetDeviceBase failed addr = %I64x, %s Space\n",
                     Address.QuadPart,
                     InIoSpace ? "Io" : "Memory"));
        return NULL;
    }

    //
    // If this is a CmResourceTypeMemory resource, we need to map it into
    // memory.
    //
    
    if (!InIoSpace) {
        MappedAddress = MmMapIoSpace (CardAddress, NumberOfBytes, FALSE);

        Status = RaidAllocateAddressMapping (&Adapter->MappedAddressList,
                                             Address,
                                             MappedAddress,
                                             NumberOfBytes,
                                             SystemIoBusNumber,
                                             Adapter->DeviceObject);
        if (!NT_SUCCESS (Status)) {

            //
            // NB: we need to log an error to the event log saying
            // we didn't have enough resources. 
            //
            
            REVIEW();
            return NULL;
        }
    } else {
        MappedAddress = (PVOID)(ULONG_PTR)CardAddress.QuadPart;
    }

    return MappedAddress;
}
                

VOID
StorPortFreeDeviceBase(
    IN PVOID HwDeviceExtension,
    IN PVOID MappedAddress
    )
/*++

Routine Description:

    This routine unmaps an IO address that has been previously mapped
    to system address space using ScsiPortGetDeviceBase().

Arguments:

    HwDeviceExtension - used to find port device extension.

    MappedAddress - address to unmap.

    NumberOfBytes - number of bytes mapped.

    InIoSpace - address is in IO space.

Return Value:

    None

--*/
{

    //
    // NB: Fix this.
    //
}


PVOID
StorPortGetUncachedExtension(
    IN PVOID HwDeviceExtension,
    IN PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    IN ULONG NumberOfBytes
    )
/*++

Routine Description:

    This function allocates a common buffer to be used as the uncached device
    extension for the miniport driver. 

Arguments:

    DeviceExtension - Supplies a pointer to the miniports device extension.

    ConfigInfo - Supplies a pointer to the partially initialized configuraiton
        information.  This is used to get an DMA adapter object.

    NumberOfBytes - Supplies the size of the extension which needs to be
        allocated

Return Value:

    A pointer to the uncached device extension or NULL if the extension could
    not be allocated or was previously allocated.

--*/

{
    NTSTATUS Status;
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_ADAPTER_PARAMETERS Parameters;

    //
    // SCSIPORT also allocates the SRB extension from here. Wonder if
    // that's necessary at this point.
    //

    Adapter = RaidpPortGetAdapter (HwDeviceExtension);

    if (Adapter == NULL) {
        return NULL;
    }

    //
    // The noncached extension has not been allocated. Allocate it.
    //

    if (!RaidIsRegionInitialized (&Adapter->UncachedExtension)) {

        //
        // The DMA Adapter may not have been initialized at this point. If
        // not, initialize it.
        //

        if (!RaidIsDmaInitialized (&Adapter->Dma)) {

            Status = RaidInitializeDma (&Adapter->Dma,
                                        Adapter->PhysicalDeviceObject,
                                        &Adapter->Miniport.PortConfiguration);

            if (!NT_SUCCESS (Status)) {
                return NULL;
            }
        }

        Parameters = &Adapter->Parameters;
        Status = RaidDmaAllocateUncachedExtension (&Adapter->Dma,
                                                   NumberOfBytes,
                                                   Parameters->MinimumUncachedAddress,
                                                   Parameters->MaximumUncachedAddress,
                                                   Parameters->UncachedExtAlignment,
                                                   &Adapter->UncachedExtension);

        //
        // Failed to allocate uncached extension; bail.
        //
        
        if (!NT_SUCCESS (Status)) {
            return NULL;
        }
    }

    //
    // Return the base virtual address of the region.
    //
    
    return RaidRegionGetVirtualBase (&Adapter->UncachedExtension);
}


ULONG
StorPortGetBusData(
    IN PVOID HwDeviceExtension,
    IN ULONG BusDataType,
    IN ULONG SystemIoBusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    )
/*++

Routine Description:

    The function returns the bus data for an adapter slot or CMOS address.

Arguments:

    BusDataType - Supplies the type of bus.

    BusNumber - Indicates which bus.

    Buffer - Supplies the space to store the data.

    Length - Supplies a count in bytes of the maximum amount to return.

Return Value:

    Returns the amount of data stored into the buffer.

--*/
{
    ULONG Bytes;
    PRAID_ADAPTER_EXTENSION Adapter;

    Adapter = RaidpPortGetAdapter (HwDeviceExtension);
    Bytes = RaGetBusData (&Adapter->Bus,
                          BusDataType,
                          Buffer,
                          0,
                          Length);

    return Bytes;
}


ULONG
StorPortSetBusDataByOffset(
    IN PVOID HwDeviceExtension,
    IN ULONG BusDataType,
    IN ULONG SystemIoBusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    The function returns writes bus data to a specific offset within a slot.

Arguments:

    HwDeviceExtension - State information for a particular adapter.

    BusDataType - Supplies the type of bus.

    SystemIoBusNumber - Indicates which system IO bus.

    SlotNumber - Indicates which slot.

    Buffer - Supplies the data to write.

    Offset - Byte offset to begin the write.

    Length - Supplies a count in bytes of the maximum amount to return.

Return Value:

    Number of bytes written.

--*/

{
    ULONG Ret;
    PRAID_ADAPTER_EXTENSION Adapter;

    Adapter = RaidpPortGetAdapter (HwDeviceExtension);
    Ret = RaSetBusData (&Adapter->Bus,
                        BusDataType,
                        Buffer,
                        Offset,
                        Length);

    return Ret;
}
                          

//
// The below I/O access routines are forwarded to the HAL or NTOSKRNL on
// Alpha and Intel platforms.
//


UCHAR
StorPortReadPortUchar(
    IN PVOID HwDeviceExtension,
    IN PUCHAR Port
    )

/*++

Routine Description:

    Read from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.

Return Value:

    Returns the value read from the specified port address.

--*/

{
    return(READ_PORT_UCHAR(Port));
}


USHORT
StorPortReadPortUshort(
    IN PVOID HwDeviceExtension,
    IN PUSHORT Port
    )

/*++

Routine Description:

    Read from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.

Return Value:

    Returns the value read from the specified port address.

--*/

{

    return(READ_PORT_USHORT(Port));

}

ULONG
StorPortReadPortUlong(
    IN PVOID HwDeviceExtension,
    IN PULONG Port
    )

/*++

Routine Description:

    Read from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.

Return Value:

    Returns the value read from the specified port address.

--*/

{

    return(READ_PORT_ULONG(Port));

}

VOID
StorPortReadPortBufferUchar(
    IN PVOID HwDeviceExtension,
    IN PUCHAR Port,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )

/*++

Routine Description:

    Read a buffer of unsigned bytes from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    READ_PORT_BUFFER_UCHAR(Port, Buffer, Count);

}

VOID
StorPortReadPortBufferUshort(
    IN PVOID HwDeviceExtension,
    IN PUSHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Read a buffer of unsigned shorts from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    READ_PORT_BUFFER_USHORT(Port, Buffer, Count);

}

VOID
StorPortReadPortBufferUlong(
    IN PVOID HwDeviceExtension,
    IN PULONG Port,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Read a buffer of unsigned longs from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    READ_PORT_BUFFER_ULONG(Port, Buffer, Count);

}

UCHAR
StorPortReadRegisterUchar(
    IN PVOID HwDeviceExtension,
    IN PUCHAR Register
    )

/*++

Routine Description:

    Read from the specificed register address.

Arguments:

    Register - Supplies a pointer to the register address.

Return Value:

    Returns the value read from the specified register address.

--*/

{

    return(READ_REGISTER_UCHAR(Register));

}

USHORT
StorPortReadRegisterUshort(
    IN PVOID HwDeviceExtension,
    IN PUSHORT Register
    )

/*++

Routine Description:

    Read from the specified register address.

Arguments:

    Register - Supplies a pointer to the register address.

Return Value:

    Returns the value read from the specified register address.

--*/

{

    return(READ_REGISTER_USHORT(Register));

}

ULONG
StorPortReadRegisterUlong(
    IN PVOID HwDeviceExtension,
    IN PULONG Register
    )

/*++

Routine Description:

    Read from the specified register address.

Arguments:

    Register - Supplies a pointer to the register address.

Return Value:

    Returns the value read from the specified register address.

--*/

{

    return(READ_REGISTER_ULONG(Register));

}

VOID
StorPortReadRegisterBufferUchar(
    IN PVOID HwDeviceExtension,
    IN PUCHAR Register,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )

/*++

Routine Description:

    Read a buffer of unsigned bytes from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    READ_REGISTER_BUFFER_UCHAR(Register, Buffer, Count);

}

VOID
StorPortReadRegisterBufferUshort(
    IN PVOID HwDeviceExtension,
    IN PUSHORT Register,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Read a buffer of unsigned shorts from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    READ_REGISTER_BUFFER_USHORT(Register, Buffer, Count);

}

VOID
StorPortReadRegisterBufferUlong(
    IN PVOID HwDeviceExtension,
    IN PULONG Register,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Read a buffer of unsigned longs from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    READ_REGISTER_BUFFER_ULONG(Register, Buffer, Count);

}

VOID
StorPortWritePortUchar(
    IN PVOID HwDeviceExtension,
    IN PUCHAR Port,
    IN UCHAR Value
    )

/*++

Routine Description:

    Write to the specificed port address.

Arguments:

    Port - Supplies a pointer to the port address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{

    WRITE_PORT_UCHAR(Port, Value);

}

VOID
StorPortWritePortUshort(
    IN PVOID HwDeviceExtension,
    IN PUSHORT Port,
    IN USHORT Value
    )

/*++

Routine Description:

    Write to the specificed port address.

Arguments:

    Port - Supplies a pointer to the port address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{

    WRITE_PORT_USHORT(Port, Value);

}

VOID
StorPortWritePortUlong(
    IN PVOID HwDeviceExtension,
    IN PULONG Port,
    IN ULONG Value
    )

/*++

Routine Description:

    Write to the specificed port address.

Arguments:

    Port - Supplies a pointer to the port address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{

    WRITE_PORT_ULONG(Port, Value);


}

VOID
StorPortWritePortBufferUchar(
    IN PVOID HwDeviceExtension,
    IN PUCHAR Port,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )

/*++

Routine Description:

    Write a buffer of unsigned bytes from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    WRITE_PORT_BUFFER_UCHAR(Port, Buffer, Count);

}

VOID
StorPortWritePortBufferUshort(
    IN PVOID HwDeviceExtension,
    IN PUSHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Write a buffer of unsigned shorts from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    WRITE_PORT_BUFFER_USHORT(Port, Buffer, Count);

}

VOID
StorPortWritePortBufferUlong(
    IN PVOID HwDeviceExtension,
    IN PULONG Port,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Write a buffer of unsigned longs from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    WRITE_PORT_BUFFER_ULONG(Port, Buffer, Count);

}

VOID
StorPortWriteRegisterUchar(
    IN PVOID HwDeviceExtension,
    IN PUCHAR Register,
    IN UCHAR Value
    )

/*++

Routine Description:

    Write to the specificed register address.

Arguments:

    Register - Supplies a pointer to the register address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{

    WRITE_REGISTER_UCHAR(Register, Value);

}

VOID
StorPortWriteRegisterUshort(
    IN PVOID HwDeviceExtension,
    IN PUSHORT Register,
    IN USHORT Value
    )

/*++

Routine Description:

    Write to the specificed register address.

Arguments:

    Register - Supplies a pointer to the register address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{

    WRITE_REGISTER_USHORT(Register, Value);
}

VOID
StorPortWriteRegisterBufferUchar(
    IN PVOID HwDeviceExtension,
    IN PUCHAR Register,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )

/*++

Routine Description:

    Write a buffer of unsigned bytes from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    WRITE_REGISTER_BUFFER_UCHAR(Register, Buffer, Count);

}

VOID
StorPortWriteRegisterBufferUshort(
    IN PVOID HwDeviceExtension,
    IN PUSHORT Register,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Write a buffer of unsigned shorts from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    WRITE_REGISTER_BUFFER_USHORT(Register, Buffer, Count);

}

VOID
StorPortWriteRegisterBufferUlong(
    IN PVOID HwDeviceExtension,
    IN PULONG Register,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Write a buffer of unsigned longs from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    WRITE_REGISTER_BUFFER_ULONG(Register, Buffer, Count);

}

VOID
StorPortWriteRegisterUlong(
    IN PVOID HwDeviceExtension,
    IN PULONG Register,
    IN ULONG Value
    )

/*++

Routine Description:

    Write to the specificed register address.

Arguments:

    Register - Supplies a pointer to the register address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{

    WRITE_REGISTER_ULONG(Register, Value);
}

#if defined(_AMD64_)

VOID
StorPortQuerySystemTime (
    OUT PLARGE_INTEGER CurrentTime
    )

/*++

Routine Description:

    This function returns the current system time.

Arguments:

    CurrentTime - Supplies a pointer to a variable that will receive the
        current system time.

Return Value:

    None.

--*/

{

    KeQuerySystemTime(CurrentTime);
    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\power.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    power.h

Abstract:

    Power management objects and declarations for the RAID port driver.

Author:

    Matthew D Hendel (math) 20-Apr-2000

Revision History:

--*/

#pragma once

typedef struct _RAID_POWER_STATE {

    //
    // The system power state.
    //
    
    SYSTEM_POWER_STATE SystemState;

    //
    // The device power state.
    //
    
    DEVICE_POWER_STATE DeviceState;

    //
    // Current Power Irp  . . . NB: What is this for?
    //
    
    PIRP CurrentPowerIrp;

} RAID_POWER_STATE, *PRAID_POWER_STATE;



//
// Creation and destruction.
//

VOID
RaCreatePower(
    OUT PRAID_POWER_STATE Power
    );

VOID
RaDeletePower(
    IN PRAID_POWER_STATE Power
    );


VOID
RaInitializePower(
    IN PRAID_POWER_STATE Power
    );
    
//
// Operations
//

VOID
RaSetDevicePowerState(
    IN PRAID_POWER_STATE Power,
    IN DEVICE_POWER_STATE DeviceState
    );

VOID
RaSetSystemPowerState(
    IN PRAID_POWER_STATE Power,
    IN SYSTEM_POWER_STATE SystemState
    );


NTSTATUS
RaidAdapterQueryPowerIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterSetPowerIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterQueryDevicePowerIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterQueryDevicePowerCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
RaidAdapterWaitForEmptyQueueWorkItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );
    
NTSTATUS
RaidAdapterSetDevicePowerIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterPowerDownDevice(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterPowerUpDevice(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterPowerUpDeviceCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
RaidAdapterQuerySystemPowerIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterQuerySystemPowerCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
RaidAdapterQueryDevicePowerCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    );
    
NTSTATUS
RaidAdapterSetSystemPowerIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterSetSystemPowerCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
RaidAdapterSetDevicePowerCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
RaidUnitQueryPowerIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaidUnitSetPowerIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaidUnitSetDevicePowerIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaidUnitQuerySystemPowerIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaidUnitSetSystemPowerIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\precomp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Precompiled header file for RAID port driver.

Author:

    Matthew D Hendel (math) 20-Apr-2000

Revision History:

--*/


#pragma once

#include <ntddk.h>
#include <stdarg.h>
#include <stdio.h>

#include <storport.h>
#include <ntddscsi.h>
#include <ntdddisk.h>
#include <ntddstor.h>

#include <wmistr.h>

#include <wdmguid.h>
#include <devguid.h>
#include <storlib.h>

typedef struct _RAID_ADAPTER_EXTENSION RAID_ADAPTER_EXTENSION, *PRAID_ADAPTER_EXTENSION;
typedef struct _RAID_UNIT_EXTENSION RAID_UNIT_EXTENSION, *PRAID_UNIT_EXTENSION;
typedef struct _RAID_DRIVER_EXTENSION RAID_DRIVER_EXTENSION, *PRAID_DRIVER_EXTENSION;
typedef struct _EXTENDED_REQUEST_BLOCK EXTENDED_REQUEST_BLOCK, *PEXTENDED_REQUEST_BLOCK;
typedef struct _IO_QUEUE IO_QUEUE, *PIO_QUEUE;
typedef struct _STOR_EVENT_QUEUE STOR_EVENT_QUEUE, *PSTOR_EVENT_QUEUE;
typedef struct _STOR_EVENT_QUEUE_ENTRY STOR_EVENT_QUEUE_ENTRY, *PSTOR_EVENT_QUEUE_ENTRY;

#include "portlib.h"
#include "debug.h"
#include "util.h"
#include "id.h"

#include "exqueue.h"
#include "ioqueue.h"
#include "deferred.h"
#include "eventq.h"

#include "common.h"
#include "global.h"
#include "dma.h"
#include "srb.h"
#include "resource.h"
#include "power.h"
#include "miniport.h"
#include "wmi.h"
#include "portcfg.h"
#include "driver.h"
#include "bus.h"
#include "adapter.h"
#include "unit.h"
#include "BusEnum.h"

#include "ext.h"

#include "inline.h"


#include "verify.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\power.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    power.c
    
Abstract:

    This file implements the Power state machines for the STORPORT driver.

    This is a basic outline of the power code.

    I. Adapter Power

        A. Device Power

            1. Query Device Power

                a) Power Down (handled top down)

                    i) Step 1: Query D-IRP Dispatch Context

                        aa) Acquire Remlock
                        bb) Set Completion Routine
                        cc) Copy IRP Stack Location
                        dd) Pass IRP down (PoCallDriver)

                    ii) Step 2: Query D-IRP Completion Context

                        aa) Check for D-IRP failure
                        bb) Freeze Adapter Queue
                        cc) Queue Work Item to wait for queue to drain
                        dd) ret STATUS_MORE_PROCESSING_REQUIRED

                    iii) Step 3: Query D-IRP Work Routine

                        aa) Wait for adapter queue to drain
                        bb) Start next power IRP (PoStartNextPowerIrp)
                        cc) Complete D-IRP request
                        dd) Release Remlock


                a) Power Down (handled top down)

                    i)   PoStartNextPowerIrp
                    ii)  CopyIrpStackLocation
                    iii) PoCallDriver

                b) Power Up (handled bottom up)

                    i)   Start next power IRP (PoStartNextPowerIrp)
                    ii)  Copy IRP Stack Location
                    ii)  Pass IRP down (PoCallDriver)
                    
            2. Set Device Power

                a) Power Down (handled top down)

                    i) Step 1: Set D-IRP Dispatch Context

                        aa) Acquire Remlock
                        bb) MarkIrpPending
                        cc) Freeze Adapter Queue
                        dd) IoQueueWorkItem
                        ee) MarkIrpPending
                        ff) ret STATUS_PENDING

                    ii) Step 2: Set D-IRP Work Routine

                        aa) Wait for Adapter Queue to drain
                        bb) Change Physical Power State (except in hiber)
                        cc) PoSetPowerState
                        dd) CopyIrpStackLocationToNext
                        ee) PoCallDriver

                    iii) Step 3: Set D-IRP Completion Routine

                        aa) PoStartNextPowerIrp
                        bb) Release Remlock
                        
                    
                b) Power Up (handled bottom up)

                    i) Step 1: Set D-IRP Dispatch Context

                        aa) Acquire Remlock
                        bb) Set completion routine
                        cc) Copy current IRP stack to next
                        dd) Pass IRP down (PoCallDriver)

                    ii) Step 2: Set D-IRP Completion Context

                        aa) Restore Physical Device
                        bb) Set Power State
                        cc) Start next power IRP
                        dd) Complete Request (?!)
                        ee) Release Remlock
            
        B. System Power
        
            1. Query System Power

                a) Step 1: Query S-IRP Dispatch Context

                    i)   Acquire Remlock
                    ii)  Set Completion Routine
                    iii) Copy Irp Stack Location
                    iv)  Pass IRP down (PoCallDriver)

                b)  Step 2: Query S-IRP Completion Routine

                    i)   Check for S-IRP failure
                    ii)  Request Query Power D-IRP for cooresponding S-IRP
                    iii) ret STATUS_MORE_PROCESSING

                c) Step 3: Query D-IRP Completion Routine

                    i)   Start next power IRP (PoStartNextPowerIrp)
                    ii)  Complete S-IRP with D-IRP completion status
                    iii) Release Remlock acquired in Step 1
                    iv)  return completion status
                    
            2. Set System Power

                a) Step 1: Set S-IRP Dispatch Context

                    i)   Acquire Remlock
                    ii)  Set Completion Routine
                    iii) Copy Irp Stack Location
                    iv)  Pass IRP down (PoCallDriver)

                b) Step 2: Set S-IRP Completion Routine

                    i)   Check for S-IRP failure
                    ii)  Request Set Power D-IRP for corresponding S-IRP
                    iii) ret STATUS_MORE_PROCESSING_REQUIRED

                c) Step 3: Set D-IRP Completion Routine

                    i)   Start next power IRP (PoStartNextPowerIrp)
                    ii)  Complete S-IRP with D-IRP completion status
                    iii) Release Remlock acquired in Step 1
                    iv)  return completion status

    II. Logical Unit Power

        A. Device Power

            1. Query Device Power

                a) PoStartNextPowerIrp
                b) IoCompleteRequest

            2. Set Device Power

                a) Power Up

                    i)   Ensure Device still exists; if not, call
                         IoInvalidateDeviceReleations to detect device
                         changes
                    ii)  PoSetPowerState
                    iii) PoStartNextPowerIrp
                    iv)  IoCompleteRequest

                b) Power Down

                    i)   PoSetPowerState
                    ii)  PoStartNextPowerIrp
                    iii) IoCompleteRequest

        B. System Power

            1. Query Power State

                a) PoStartNextPowerIrp
                b) IoCompleteRequest

            2. Set Power State

                a) PoStartNextPowerIrp
                b) IoCompleteRequest

Author:

    Matthew D Hendel (math) 21-Apr-2000

Revision History:

--*/


#include "precomp.h"


#define GET_REMLOCK_TAG(Irp) ((PVOID)((ULONG_PTR)(Irp)^(ULONG_PTR)-1L))

DEVICE_POWER_STATE DeviceStateTable [POWER_SYSTEM_MAXIMUM] =
{
    PowerDeviceD0,  // PowerSystemUnspecified
    PowerDeviceD0,  // PowerSystemWorking
    PowerDeviceD3,  // PowerSystemSleeping1
    PowerDeviceD3,  // PowerSystemSleeping2
    PowerDeviceD3,  // PowerSystemSleeping3
    PowerDeviceD3,  // PowerSystemHibernate
    PowerDeviceD3   // PowerSysetmShutdown
};
    
    
#ifdef ALLOC_PRAGMA
#endif // ALLOC_PRAGMA

//
// Forward declarations.
//

VOID
RaidAdapterPowerUpWorkRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

NTSTATUS
RaidAdapterPowerDownDeviceCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

//
// Creation and destruction.
//

VOID
RaCreatePower(
    IN OUT PRAID_POWER_STATE Power
    )
{
    ASSERT (Power != NULL);

    Power->SystemState = PowerSystemUnspecified;
    Power->DeviceState = PowerDeviceUnspecified;
    Power->CurrentPowerIrp = NULL;
//  KeInitializeEvent (&Power->PowerDownEvent, );
}

VOID
RaDeletePower(
    IN OUT PRAID_POWER_STATE Power
    )
{
}



NTSTATUS
RaidAdapterPowerIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
/*++

Routine Description:

    Dispatch power irps to function specific handlers.

Arguments:

    Adapter - Adapter the irp is for.

    Irp - Irp to handle.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG Minor;
    
    ASSERT (RaidMajorFunctionFromIrp (Irp) == IRP_MJ_POWER);

    Status = IoAcquireRemoveLock (&Adapter->RemoveLock, Irp);

    if (!NT_SUCCESS (Status)) {
        Irp->IoStatus.Information = 0;
        PoStartNextPowerIrp (Irp);
        return RaidCompleteRequest (Irp,  Status);
    }

    Minor = RaidMinorFunctionFromIrp (Irp);
    DebugPower (("Adapter %p, Irp %p, Power, Minor %x\n",
                  Adapter, Irp, Minor));

    switch (Minor) {

        case IRP_MN_QUERY_POWER:
            Status = RaidAdapterQueryPowerIrp (Adapter, Irp);
            break;

        case IRP_MN_SET_POWER:
            Status = RaidAdapterSetPowerIrp (Adapter, Irp);
            break;

        default:
            Status = RaForwardPowerIrp (Adapter->LowerDeviceObject, Irp);
    }

    DebugPower (("Adapter %p, Irp %p, Power, Minor %x, ret = %08x\n",
                  Adapter,
                  Irp,
                  Minor,
                  Status));
    IoReleaseRemoveLock (&Adapter->RemoveLock, Irp);

    return Status;
}


//
// Part I: Adapter Power 
//



NTSTATUS
RaidAdapterQueryPowerIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
/*++

Routine Description:

    Top level query power dispatch routine.
    
Arguments:

    Adapter - Adapter to query for power.

    Irp - Query power irp.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    POWER_STATE_TYPE PowerType;
    POWER_STATE PowerState;

    //
    // Ignore shutdown irps.
    //

    PowerState = RaidPowerStateFromIrp (Irp);

    if (PowerState.SystemState >= PowerSystemShutdown) {
        IoCopyCurrentIrpStackLocationToNext (Irp);
        PoStartNextPowerIrp (Irp);
        Status = PoCallDriver (Adapter->LowerDeviceObject, Irp);

        return Status;
    }
    
    PowerType = RaidPowerTypeFromIrp (Irp);
    DebugPower (("Adapter %p, Irp %p, Query %s Power\n",
                  Adapter,
                  Irp,
                  PowerType == SystemPowerState ? "System" : "Device"));

    switch (PowerType) {

        case SystemPowerState:
            Status = RaidAdapterQuerySystemPowerIrp (Adapter, Irp);
            break;

        case DevicePowerState:
            Status = RaidAdapterQueryDevicePowerIrp (Adapter, Irp);
            break;

        default:
            ASSERT (FALSE);
            Status = STATUS_UNSUCCESSFUL;
    }

    DebugPower (("Adapter %p, Irp %p, Query %s Power, ret = %08x\n",
                  Adapter,
                  Irp,
                  PowerType == SystemPowerState ? "System" : "Device",
                  Status));

    return Status;
}


PCHAR 
DbgGetPowerState(
    IN POWER_STATE_TYPE Type,
    IN POWER_STATE State
    )
{
    if (Type == SystemPowerState) {
        switch (State.SystemState) {
            case PowerSystemUnspecified:
                return "Unspecified";
            case PowerSystemWorking:
                return "Working";
            case PowerSystemSleeping1:
                return "Sleep1";
            case PowerSystemSleeping2:
                return "Sleep2";
            case PowerSystemSleeping3:
                return "Sleep3";
            case PowerSystemHibernate:
                return "Hibernate";
            case PowerSystemShutdown:
                return "Shutdown";
        }
    } else {
        switch (State.DeviceState) {
            case PowerDeviceUnspecified:
                return "Unspecified";
            case PowerDeviceD0:
                return "D0";
            case PowerDeviceD1:
                return "D1";
            case PowerDeviceD2:
                return "D2";
            case PowerDeviceD3:
                return "D3";
        }
    }
    return "Unkown";
}


PCHAR
DbgGetPowerAction(
    IN POWER_ACTION Action
    )
{
    switch (Action) {
        case PowerActionNone:
            return "None";
        case PowerActionReserved:
            return "Reserved";
        case PowerActionSleep:
            return "Sleep";
        case PowerActionHibernate:
            return "Hibernate";
        case PowerActionShutdown:
            return "Shutdown";
        case PowerActionShutdownReset:
            return "Reset";
        case PowerActionShutdownOff:
            return "Off";
        case PowerActionWarmEject:
            return "Eject";
    }
    return  "Unknown";
}


NTSTATUS
RaidAdapterSetPowerIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
/*++

Routine Description:

    Top level set power dispatch routine.

Arguments:

    Adapter - Adapter that will handle this irp.

    Irp - Set power irp to handle.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    POWER_STATE_TYPE PowerType;
    POWER_STATE PowerState;
    
    //
    // Ignore shutdown irps.
    //

    PowerState = RaidPowerStateFromIrp (Irp);

    if (PowerState.SystemState >= PowerSystemShutdown) {
        IoCopyCurrentIrpStackLocationToNext (Irp);
        PoStartNextPowerIrp (Irp);
        Status = PoCallDriver (Adapter->LowerDeviceObject, Irp);

        return Status;
    }
        
    PowerType = RaidPowerTypeFromIrp (Irp);

#if DBG
    {
        POWER_ACTION PowerAction;
        
        PowerAction = RaidPowerActionFromIrp (Irp);

        DebugPower (("Adapter %p, Irp %p, Set %s Power\n",
                  Adapter,
                  Irp,
                  (PowerType == SystemPowerState ? "System" : "Device")));

  }
#endif

    switch (PowerType) {

        case SystemPowerState:
            Status = RaidAdapterSetSystemPowerIrp (Adapter, Irp);
            break;

        case DevicePowerState:
            Status = RaidAdapterSetDevicePowerIrp (Adapter, Irp);
            break;

        default:
            ASSERT (FALSE);
            Status = STATUS_UNSUCCESSFUL;
    }

    DebugPower (("Adapter %p, Irp %p, Set %s Power, ret = %08x\n",
                  Adapter,
                  Irp,
                  PowerType == SystemPowerState ? "System" : "Device",
                  Status));

    return Status;
}


//
// Part I: Adapter Power
//
// Section A: Adapter Device Power
//
// Subsection 1: Query Device Power
//


NTSTATUS
RaidAdapterQueryDevicePowerIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
/*++

Routine Description:

    Query Device Power: Succeed.

Arguments:

    Adapter -

    Irp -

Return Value:

    NTSTATUS code

--*/
{
    NTSTATUS Status;
    
    PoStartNextPowerIrp (Irp);
    IoCopyCurrentIrpStackLocationToNext (Irp);
    Status = PoCallDriver (Adapter->LowerDeviceObject, Irp);

    return Status;
}


//
// Part I: Adapter Power
//
// Section A: Device Power
//
// SubSection 2: Set Device Power
//


NTSTATUS
RaidAdapterSetDevicePowerIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle the set power irp for a device state on the adapter.

Arguments:

    Adapter - Adapter that will handle this irp.

    Irp -  Set power irp to handle.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpStack;
    DEVICE_POWER_STATE CurrentState;
    DEVICE_POWER_STATE RequestedState;  
    
    ASSERT_ADAPTER (Adapter);
    ASSERT (RaidPowerTypeFromIrp (Irp) == DevicePowerState);

    DebugPower (("Adapter %p, Irp %p, Set Device Power\n",
                  Adapter, Irp));
                  
    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    CurrentState = Adapter->Power.DeviceState;
    RequestedState = IrpStack->Parameters.Power.State.DeviceState;

    //
    // We only honor transitions to and from D0.
    //
    
    if (CurrentState == PowerDeviceD0 &&
        RequestedState > PowerDeviceD0) {

        //
        // Powering down.
        //
        
        Status = RaidAdapterPowerDownDevice (Adapter, Irp);

    } else if (CurrentState > PowerDeviceD0 &&
               RequestedState == PowerDeviceD0) {

        //
        // Powering up.
        //
        
        Status = RaidAdapterPowerUpDevice (Adapter, Irp);

    } else {


        REVIEW();
        
        //
        // Requesting equal power state: ignore the request.
        //

        PoStartNextPowerIrp (Irp);
        IoSkipCurrentIrpStackLocation (Irp);
        Status = PoCallDriver (Adapter->LowerDeviceObject, Irp);
    }
        
    DebugPower (("Adapter %p, Irp %p, Set Device Power, ret = %08x\n",
                  Adapter, Irp, Status));

    return Status;
}


//
// Part I: Adapter Power
//
// Section A: Adapter Device Power
//
// Subsection 1: Set Device Power
//
// Sub-subsection a: Power Down
//


NTSTATUS
RaidAdapterPowerDownDevice(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle Set D-IRP for the Adapter (FDO). The routine does the following:

        o  Acquiring a remove lock for the duration of the power irp.
        
        o  Freezing the adapter queue.

        o  Queuing a work item that will wait for the queue to empty.

        o  Marking the IRP pending and returning STATUS PENDING.


    This is step 1 of the 3 step Set D-IRP state machine.

Algorithm:

    <TBD>
    
Arguments:

    Adapter - Adapter object to handle the Set Power D-IRP.
    
    Irp - Set Power D-Irp for the Adapter.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    
    DebugPower (("Adapter %p, Irp %p, Power Down Adapter[1]\n",
                 Adapter, Irp));

    IoAcquireRemoveLock (&Adapter->RemoveLock, GET_REMLOCK_TAG (Irp));

    //
    // Pause the Adapter's queue. This could be done either here or in
    // the work routine (step 2). We pause the gateway here to give
    // the queue some time to drain before the work item gets called.
    // If the pause routine needed to be called at passive level, we
    // would have do this in the work routine.
    // 

    RaidPauseAdapterQueue (Adapter);

    //
    // At this point, the adapter queue is frozen. We need to wait for all
    // outstanding I/O to complete. We cannot do this in the context of the
    // D-IRP, so mark the IRP as pending and queue a work item to wait for
    // outstanding requests to be completed.
    //

    Status = StorQueueWorkItem (Adapter->DeviceObject,
                                RaidAdapterWaitForEmptyQueueWorkItem,
                                DelayedWorkQueue,
                                Irp);

    //
    // If we failed to successfully schedule the work item, we're in
    // trouble. Although the power documentation clearly says we're not
    // allowed to fail the IRP, there's not much else we can do here.
    //
    
    if (!NT_SUCCESS (Status)) {
        ASSERT (FALSE);
        PoStartNextPowerIrp (Irp);
        IoReleaseRemoveLock (&Adapter->RemoveLock, GET_REMLOCK_TAG (Irp));
        Status = RaidCompleteRequest (Irp,  Status);
    } else {
        IoMarkIrpPending (Irp);
        Status = STATUS_PENDING;
    }
    
    DebugPower (("Adapter %p, Irp %p, Power Down Adapter[1], ret = %08x\n",
                  Adapter, Irp, Status));

    return Status;
}


VOID
RaidAdapterWaitForEmptyQueueWorkItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )
/*++

Routine Description:

    This work routine is called at PASSIVE LEVEL to allow us to wait for
    all outstanding IOs to complete. The routine is responsible for the
    following:

        o  Waiting for the adapter queue to drain.

        o  Changing the physical power state of the device (HBA).

        o  Notifying the Power Manager of the new power state.

        o  Passing the IRP down the stack.


    Step 2 of the 3 step Set D-IRP state machine.

Arguments:

    DeviceObject - Adapter object handling the set power D-IRP.

    Context - Set power D-IRP to complete.

Return Values:

    None.
    
Environment:

    PASSIVE_LEVEL, arbitrary thread context.
    
--*/
{
    NTSTATUS Status;
    KEVENT Event;
    PRAID_ADAPTER_EXTENSION Adapter;
    PIRP Irp;
    PIO_STACK_LOCATION IrpStack;
    DEVICE_POWER_STATE RequestedState;  

    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

    Adapter = GetAdapter (DeviceObject);
    ASSERT_ADAPTER (Adapter);
    Irp = GetIrp (Context);
    ASSERT (Irp->Type == IO_TYPE_IRP);

    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    RequestedState = IrpStack->Parameters.Power.State.DeviceState;

    DebugPower (("Adapter %p, Irp %p, Power Down Adapter[2]\n",
                  Adapter, Irp));

    //
    // Setup an event to know when the gateway is empty.
    //
    // NOTE: This could be done more elegantly.
    //

    KeInitializeEvent (&Event,
                       NotificationEvent,
                       FALSE);
    StorSetIoGatewayEmptyEvent (&Adapter->Gateway, &Event);

    //
    // Wait until the queue is empty.
    //
    
    Status = KeWaitForSingleObject (&Event,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    NULL);
    //
    // If we failed for some reason; we want to fail the originating
    // Set D-IRP.
    //

    //
    // NB: the PO documentation is clear that you're not allowed
    // to fail a power-down operation. There's not much else we
    // can do at this point.
    //
    
    if (Status != STATUS_SUCCESS) {
        goto done;
    }


    //
    // NB: Is it necesasry to check if we're in the hibernate path
    // before stopping the adapter?
    //
    
    //
    // Stop the adapter.
    //

    Status = RaidAdapterStop (Adapter);

done:

    //
    // We're in trouble here. We failed some part of our power down request.
    // There's not much we can do here but fail the IRP. Nevertheless, the
    // Power manager is going to be mad at us.
    //
    
    if (!NT_SUCCESS (Status)) {
        ASSERT (FALSE);
        PoStartNextPowerIrp (Irp);
        IoReleaseRemoveLock (&Adapter->RemoveLock, GET_REMLOCK_TAG (Irp));
        RaidCompleteRequest (Irp,  Status);
        return ;
    }

    //
    // Set the internal power state and the power state for the
    // Power manager.
    //
    
    RaSetDevicePowerState (&Adapter->Power, RequestedState);
    StorSetDevicePowerState (Adapter->DeviceObject, RequestedState);

    //
    // Pass the IRP down.
    //

    IoCopyCurrentIrpStackLocationToNext (Irp);
    IoSetCompletionRoutine (Irp,
                            RaidAdapterPowerDownDeviceCompletion,
                            NULL,
                            TRUE,
                            TRUE,
                            TRUE);


    Status = PoCallDriver (Adapter->LowerDeviceObject, Irp);

    DebugPower (("Adapter %p, Irp %p, Power Down Adapter[2], status = %08x\n",
                  Adapter, Irp, Status));
}



NTSTATUS
RaidAdapterPowerDownDeviceCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This callback routine is called when the Set D-IRP has completed. It
    is responsible for:

        o  Starting the next power IRP.

        o  Completing this power IRP.

    This is step 2 of the 3 step Set D-IRP state machine.

Arguments:

    DeviceObject - Device representing an Adapter device.

    Irp - Set Power for power down D-IRP.

    Context - Not used.
    

Return Value:

    NTSTATUS code.

Environment:

    DISPATCH_LEVEL or below.

--*/
{
    PRAID_ADAPTER_EXTENSION Adapter;

    ASSERT (KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT (Context == NULL);

    Adapter = GetAdapter (DeviceObject);
    ASSERT_ADAPTER (Adapter);
    

    DebugPower (("Adapter %p, Irp %p, Power Down Adapter[3]\n",
                  Adapter, Irp));

    //
    // If the IRP was marked as pending, it must be remarked here.
    //
    
    if (Irp->PendingReturned) {
        IoMarkIrpPending (Irp);
    }

    PoStartNextPowerIrp (Irp);
    IoReleaseRemoveLock (&Adapter->RemoveLock, GET_REMLOCK_TAG (Irp));
    
    DebugPower (("Adapter %p, Irp %p, Power Down Device[2], ret = %08x\n",
                  Adapter, Irp, Irp->IoStatus.Status));

    return STATUS_SUCCESS;
}




//
// Part I: Adapter Power
//
// Section A: Adapter Device Power
//
// Subsection 1: Set Device Power
//
// Sub-subsection b: Power UP
//


NTSTATUS
RaidAdapterPowerUpDevice(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
/*++

Routine Description:

    Request to power up the Adapter (FDO).

    This is step 1 of the 3 step Set Power D-IRP state machine.

Arguments:

    Adapter - Adapter to power up.

    Irp - Set device power irp to handle.

Return Value:

    NTSTATUS code.
    
--*/
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpStack;
    DEVICE_POWER_STATE RequestedState;
    
    ASSERT_ADAPTER (Adapter);
    ASSERT (RaidPowerTypeFromIrp (Irp) == DevicePowerState);

    DebugPower (("Adapter %p, Irp %p, Device Power Up[1]\n",
                  Adapter, Irp));

    //
    // Acquire a reference to the remlock so the adapter doesn't go away
    // while we're waiting on this IPR.
    //
    
    IoAcquireRemoveLock (&Adapter->RemoveLock, GET_REMLOCK_TAG (Irp));
    
    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    RequestedState = IrpStack->Parameters.Power.State.DeviceState;

    IoCopyCurrentIrpStackLocationToNext (Irp);
    IoSetCompletionRoutine (Irp,
                            RaidAdapterPowerUpDeviceCompletion,
                            (PVOID)RequestedState,
                            TRUE,
                            TRUE,
                            TRUE);

    Status = PoCallDriver (Adapter->LowerDeviceObject, Irp);

    Status = STATUS_PENDING;
    
    DebugPower (("Adapter %p, Irp %p, Device Power Up[1], ret = %08x\n",
                  Adapter, Irp, Status));

    return Status;
}


NTSTATUS
RaidAdapterPowerUpDeviceCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    Completetion routine for the power-up sequence. The completion routine
    is called after all lower devices have powered up.

    This is step 2 of the 3 step Set Power D-IRP state machine.

Arguments:

    DeviceObject - Device object representing a STOPORT Adapter (FDO) object.

    Irp - Irp representing the power up IRP we are powering up for.

    Context - Requested power state.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PRAID_ADAPTER_EXTENSION Adapter;
    DEVICE_POWER_STATE RequestedState;
    KIRQL Irql;

    ASSERT (IsAdapter (DeviceObject));
    Adapter = (PRAID_ADAPTER_EXTENSION)DeviceObject->DeviceExtension;

    RequestedState = (DEVICE_POWER_STATE)Context;
    ASSERT (PowerDeviceUnspecified < RequestedState &&
            RequestedState < PowerDeviceMaximum);

    DebugPower (("Adapter %p, Irp %p, Device Power Up[2]\n",
                 Adapter, Irp));

    //
    // This completion routine may be called at any level less than DISPATCH
    // LEVEL, but we need to execute at DISPATCH level.
    //
    
    Irql = KeRaiseIrqlToDpcLevel ();
    
    //
    // If the IRP was marked as pending, it must be re-marked here.
    //
    
    if (Irp->PendingReturned) {
        IoMarkIrpPending (Irp);
    }

    //
    // The Set Power D-IRP is not supposed to fail.
    //

    Status = Irp->IoStatus.Status;

    if (!NT_SUCCESS (Status)) {
        ASSERT (FALSE);
        goto done;
    }

    //
    // NB: It would be better to queue a work item and wait for
    // resume the gateway and re-initialize the adapter in the work
    // routine. This would allow that code to be paged, etc.
    // Unfortunately, that does not work. For whatever reason
    // I do not understand, we hang. Instead, do these things
    // synchronously here and remove the work item step.
    //
    // See the Async Power Up section below.
    //
    
    //
    // Restart/wakeup adapter.
    //

    Status = RaidAdapterRestart (Adapter);

    RaidResumeAdapterQueue (Adapter);
    RaidAdapterRestartQueues (Adapter);

    RaSetDevicePowerState (&Adapter->Power, RequestedState);
    StorSetDevicePowerState (Adapter->DeviceObject, RequestedState);


done:

    KeLowerIrql (Irql);

    PoStartNextPowerIrp (Irp);
    Status = STATUS_SUCCESS;
    IoReleaseRemoveLock (&Adapter->RemoveLock, GET_REMLOCK_TAG (Irp));

    
    DebugPower (("Adapter %p, Irp %p, Device Power Up[2], ret = %08x\n",
                 Adapter, Irp, Status));

    return Status;
}


#if defined (ASYNC_POWER_UP)

//
// Async power up queues a work item and waits for the resume gateway and
// adapter wakeup in the work routine. This allows that code to be paged,
// etc. Unfortunately, that does not work. For whatever reason I do not
// understand, we hang. Instead, do these things synchronously here and
// remove the work item step.
//



NTSTATUS
RaidAdapterPowerUpDeviceCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    Completetion routine for the power-up sequence. The completion routine
    is called after all lower devices have powered up.

    This is step 2 of the 3 step Set Power D-IRP state machine.

Arguments:

    DeviceObject - Device object representing a STOPORT Adapter (FDO) object.

    Irp - Irp representing the power up IRP we are powering up for.

    Context - Requested power state.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PRAID_ADAPTER_EXTENSION Adapter;
    DEVICE_POWER_STATE RequestedState;

    ASSERT (IsAdapter (DeviceObject));
    Adapter = (PRAID_ADAPTER_EXTENSION)DeviceObject->DeviceExtension;

    RequestedState = (DEVICE_POWER_STATE)Context;
    ASSERT (PowerDeviceUnspecified < RequestedState &&
            RequestedState < PowerDeviceMaximum);

    DebugPower (("Adapter %p, Irp %p, Device Power Up[2]\n",
                 Adapter, Irp));

    //
    // If the IRP was marked as pending, it must be re-marked here.
    //
    
    if (Irp->PendingReturned) {
        IoMarkIrpPending (Irp);
    }

    //
    // The Set Power D-IRP is not supposed to fail.
    //

    Status = Irp->IoStatus.Status;

    if (!NT_SUCCESS (Status)) {
        ASSERT (FALSE);
        goto done;
    }

    Status = StorQueueWorkItem (Adapter->DeviceObject,
                                RaidAdapterPowerUpWorkRoutine,
                                DelayedWorkQueue,
                                Irp);
done:

    if (!NT_SUCCESS (Status)) {
        PoStartNextPowerIrp (Irp);
        IoReleaseRemoveLock (&Adapter->RemoveLock, GET_REMLOCK_TAG (Irp));
    } else {
        Status = STATUS_MORE_PROCESSING_REQUIRED;
    }

    DebugPower (("Adapter %p, Irp %p, Device Power Up[2], ret = %08x\n",
                 Adapter, Irp, Status));

    return Status;
}


VOID
RaidAdapterPowerUpWorkRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )
/*++

Routine Description:

    Work work routine for the power-up sequence. The work routine is called after
    all lower device objects have powered up.

    This is step 3 of the 3 step Set Power D-IRP state machine.

Arguments:

    DeviceObject - Adapter device object.

    Context - Pointer to IRP that we are processing.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PIRP Irp;
    PRAID_ADAPTER_EXTENSION Adapter;
    DEVICE_POWER_STATE RequestedState;
    PIO_STACK_LOCATION IrpStack;
    
    PAGED_CODE();
    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);
    
    Adapter = GetAdapter (DeviceObject);
    Irp = (PIRP)Context;
    ASSERT (Irp->Type == IO_TYPE_IRP);

    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    ASSERT (IrpStack->MajorFunction == IRP_MJ_POWER);
    ASSERT (IrpStack->MinorFunction == IRP_MN_SET_POWER);
    RequestedState = IrpStack->Parameters.Power.State.DeviceState;
    ASSERT (PowerDeviceUnspecified < RequestedState &&
            RequestedState < PowerDeviceMaximum);

    DebugPower (("Adapter %p, Irp %p, Device Power Up[3]\n",
                 Adapter, Irp));

    //
    // Wakeup the adapter.
    //

    Status = RaidAdapterRestart (Adapter);

    //
    // Unfreeze the queues and resume IO.
    //
    
    RaidResumeAdapterQueue (Adapter);
    RaidAdapterRestartQueues (Adapter);

    //
    // Set our new power state.
    //
    
    RaSetDevicePowerState (&Adapter->Power, RequestedState);
    StorSetDevicePowerState (Adapter->DeviceObject,
                             RequestedState);

    //
    // And complete the request.
    //
    
    PoStartNextPowerIrp (Irp);
    RaidCompleteRequest (Irp,  Status);

    //
    // Release the reference to the remove lock obtained at the
    // beginning of the power-up state machine.
    //
    
    IoReleaseRemoveLock (&Adapter->RemoveLock, GET_REMLOCK_TAG (Irp));

    DebugPower (("Adapter %p, Irp %p, Device Power Up[3], ret = %08x\n",
                 Adapter, Irp, Status));
}
#endif // ASYNC_POWER_UP


//
// Part I: Adapter Power
//
// Section B: System Power
//
// Subsection 1: Query System Power
//


NTSTATUS
RaidAdapterQuerySystemPowerIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
/*++

Routine Description:

    Routine to handle Query S-IRP.

Arguments:

    Adapter -

    Irp -

Algorithm:

    As the power-policy manager, when we receive a Query S-IRP we need to
    issue Query D-IRPs down the stack to prepare the device to power down.
    This involves translating the original S-IRP to a cooresponding
    D-IRP.

    This is step 1 of the 3 step Query S-IRP state machine.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;

    DebugPower (("Adapter %p, Irp %p, Query System Power[1]\n",
                 Adapter, Irp));

    //
    // Acquire a second remlock, preventing the device from being removed
    // until the S-IRP has completed.
    //
    
    IoAcquireRemoveLock (&Adapter->RemoveLock, GET_REMLOCK_TAG (Irp));
    
    IoCopyCurrentIrpStackLocationToNext (Irp);
    IoSetCompletionRoutine (Irp,
                            RaidAdapterQuerySystemPowerCompletionRoutine,
                            NULL,
                            TRUE,
                            TRUE,
                            TRUE);

    Status = PoCallDriver (Adapter->LowerDeviceObject, Irp);


    Status = STATUS_PENDING;
    
    DebugPower (("Adapter %p, Irp %p, Query System Power[1], ret = %08x\n",
                 Adapter, Irp, Status));

    return STATUS_PENDING;
}



NTSTATUS
RaidAdapterQuerySystemPowerCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    Completion routine called when the Query S-IRP completes. If the S-IRP
    was successful, we need to issue a D-IRP down the stack.

    This is step 2 of the 3 step Query S-IRP state machine.

Arguments:

    DeviceObject - DeviceObject representing an adapter.

    Irp - Query S-IRP for the adapter object.

    Context - Not used; will always be NULL.

Return Value:

    NTSTATUS code.

Environment:

    DISPATCH_LEVEL or below.

--*/
{
    NTSTATUS Status;
    PRAID_ADAPTER_EXTENSION Adapter;
    POWER_STATE DevicePowerState;
    POWER_STATE SystemPowerState;

                    

    ASSERT (Context == NULL);
    Adapter = GetAdapter (DeviceObject);

    DebugPower (("Adapter %p, Irp %p, Query System Power[2]\n",
                 Adapter, Irp));

    if (Irp->PendingReturned) {
        IoMarkIrpPending (Irp);
    }

    //
    // If somebody else failed the Query S-IRP, bail out and don't
    // ask for the D-IRP.
    //
    
    if (!NT_SUCCESS (Irp->IoStatus.Status)) {
        Status = Irp->IoStatus.Status;
        REVIEW();
        goto done;
    }

    SystemPowerState = RaidPowerStateFromIrp (Irp);
    DevicePowerState.DeviceState = DeviceStateTable [SystemPowerState.SystemState];

    Status = PoRequestPowerIrp (Adapter->DeviceObject,
                                IRP_MN_QUERY_POWER,
                                DevicePowerState,
                                RaidAdapterQueryDevicePowerCompletionRoutine,
                                Irp,
                                NULL);

    if (!NT_SUCCESS (Status)) {
        REVIEW();
        goto done;
    }

done:

    //
    // If the S-IRP failed or we failed to issue the D-IRP, fail the S-IRP,
    // release the remlock, etc.
    //
    
    if (!NT_SUCCESS (Status)) {
        PoStartNextPowerIrp (Irp);
        IoReleaseRemoveLock (&Adapter->RemoveLock, GET_REMLOCK_TAG (Irp));
    } else {
        Status = STATUS_MORE_PROCESSING_REQUIRED;
    }
        
    DebugPower (("Adapter %p, Irp %p, Query System Power[2], ret = %08x\n",
                 Adapter, Irp, Status));

    return Status;
}


NTSTATUS
RaidAdapterQueryDevicePowerCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:

    The completion routine is called after the D-IRP for a cooresponding S-IRP
    has been completed. This routine must complete the original S-IRP.

    This is step 3 of the 3 step Query S-IRP state machine.

Arguments:

    DeviceObject - Device object representing an adapter.

    MinorFunction - IRP_MN_QUERY_POWER
    
    PowerState - The desired device power state.

    Context - Pointer to the S-IRP that generated the D-IRP that this
            completion routine is for.

    IoStatus - The IoStatus block from the completed D-IRP.

Return Value:

    NTSTATUS code.

Environment:

    DISPATCH_LEVEL or below.

--*/
{
    NTSTATUS Status;
    PRAID_ADAPTER_EXTENSION Adapter;
    PIRP SystemIrp;

    Adapter = GetAdapter (DeviceObject);
    SystemIrp = GetIrp (Context);

    DebugPower (("Adapter %p, Irp %p, Query System Power[3]\n",
                 Adapter, SystemIrp));
    //
    // Allow the next power IRP to start.
    //
    
    PoStartNextPowerIrp (SystemIrp);

    //
    // Complete the S-IRP with the status from the D-IRP. Thus, if the D-IRP
    // fails, the S-IRP will fail, and if the D-IRP succeeds, the S-IRP will
    // succeed.
    //
    
    Status = RaidCompleteRequest (SystemIrp,
                                  
                                  IoStatus->Status);

    //
    // Release the remove lock acquired in RaidAdapterQuerySystemPowerIrp.
    //
    
    IoReleaseRemoveLock (&Adapter->RemoveLock, GET_REMLOCK_TAG (SystemIrp));

    DebugPower (("Adapter %p, Irp %p, Query System Power[3], ret = %08x\n",
                 Adapter, SystemIrp, Status));

    return Status;
}


//
// Part I: Adapter Power
//
// Section B: System Power
//
// Subsection 2: Set System Power
//



NTSTATUS
RaidAdapterSetSystemPowerIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle the Set System Power IRP.

    This is step 1 of the 3 step Query S-IRP state machine.

Arguments:

    Adapter -

    Irp - 

Return Value:

    NTSTATUS code.

Note:

    This function is exactly the same as RaidAdapterQuerySystemPowerIrp.
    We should figure out a way to consolidate these functions.

--*/
{
    NTSTATUS Status;

    DebugPower (("Adapter %p, Irp %p, Set System Power[1] %s %s\n",
                 Adapter, Irp
                 ));
    
    //
    // Acquire a second remlock, preventing the device from being removed
    // until the S-IRP has completed.
    //
    
    IoAcquireRemoveLock (&Adapter->RemoveLock, GET_REMLOCK_TAG (Irp));

    IoCopyCurrentIrpStackLocationToNext (Irp);
    IoSetCompletionRoutine (Irp,
                            RaidAdapterSetSystemPowerCompletion,
                            NULL,
                            TRUE,
                            TRUE,
                            TRUE);

    Status = PoCallDriver (Adapter->LowerDeviceObject, Irp);

    //
    // REVIEW: Required to return pending here? Is it correct to return
    // STATUS_PENIDNG when not marking the IRP as pending(!?)
    //

    Status = STATUS_PENDING;

    DebugPower (("Adapter %p, Irp %p, Set System Power[1], ret = %08x\n",
                 Adapter, Irp, Status));
                 
    return Status;
}


NTSTATUS
RaidAdapterSetSystemPowerCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    Step 2 of the 3 step Set S-IRP state machine.

Arguments:

    DeviceObject -
    
    Irp -

    Context - 

Return Value:

    NTSTATUS code.

Notes:

    This routine is a copy of RaidAdapterQuerySystemPowerCompletionRoutine.
    We should figure out a way to consolidate these two functions.

--*/
{
    NTSTATUS Status;
    PRAID_ADAPTER_EXTENSION Adapter;
    POWER_STATE DevicePowerState;
    POWER_STATE SystemPowerState;

    Adapter = GetAdapter (DeviceObject);

    DebugPower (("Adapter %p, Irp %p, Set System Power[2]\n",
                 Adapter, Irp));

    if (Irp->PendingReturned) {
        IoMarkIrpPending (Irp);
    }

    //
    // If some lower driver failed the Set S-IRP, do not send down the
    // Set D-IRP.
    //
    
    Status = Irp->IoStatus.Status;
    if (!NT_SUCCESS (Status)) {
        REVIEW();
        goto done;
    }

    SystemPowerState = RaidPowerStateFromIrp (Irp);
    DevicePowerState.DeviceState = DeviceStateTable [SystemPowerState.SystemState];
    
    Status = PoRequestPowerIrp (Adapter->DeviceObject, //?? Unit?
                                IRP_MN_SET_POWER,
                                DevicePowerState,
                                RaidAdapterSetDevicePowerCompletionRoutine,
                                Irp,
                                NULL);

    if (!NT_SUCCESS (Status)) {
        REVIEW();
        goto done;
    }

done:

    //
    // If the S-IRP failed or we failed to issue the D-IRP, just fail the
    // originating S-IRP.
    //
    
    if (!NT_SUCCESS (Status)) {
        PoStartNextPowerIrp (Irp);
        IoReleaseRemoveLock (&Adapter->RemoveLock, GET_REMLOCK_TAG (Irp));
    } else {
        Status = STATUS_MORE_PROCESSING_REQUIRED;
    }

    DebugPower (("Adapter %p, Irp %p, Set System Power[2], ret = %08x\n",
                 Adapter, Irp, Status));

    return Status;
}
                                

NTSTATUS
RaidAdapterSetDevicePowerCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:

    Step 3 of the 3 step Set S-IRP state machine.

Arguments:

    DeviceObject - Device object representing an adapter.

    MinorFunction - IRP_MN_SET_POWER

    PowerState - The desired power state.

    Context - Pointer to the originating S-IRP that generated this D-IRP.

    IoStatus - IO_STATUS_BLOCK from the completed D-IRP.

Return Value:

    NTSTATUS code.

Environment:

    DISPATCH_LEVEL or below.

--*/
{
    NTSTATUS Status;
    PRAID_ADAPTER_EXTENSION Adapter;
    PIRP SystemIrp;

    Adapter = GetAdapter (DeviceObject);
    SystemIrp = GetIrp (Context);

    DebugPower (("Adapter %p, Irp %p, Set System Power[3]\n",
                 Adapter, SystemIrp));

    //
    // Allow the next power IRP to start.
    //

    PoStartNextPowerIrp (SystemIrp);

    //
    // Complete the S-IRP with the status from the D-IRP. Thus, if the D-IRP
    // fails, the S-IRP will fail, and if the D-IRP succeeds, the S-IRP will
    // succeed.
    //
    
    Status = RaidCompleteRequest (SystemIrp,
                                  
                                  IoStatus->Status);

    //
    // Release the remove lock acquired in RaidAdapterSetSystemPowerIrp.
    //

    IoReleaseRemoveLock (&Adapter->RemoveLock, GET_REMLOCK_TAG (SystemIrp));

    DebugPower (("Adapter %p, Irp %p, Set System Power[3], ret = %08x\n",
                 Adapter, SystemIrp, Status));

    return Status;
}



//
// Part II: Unit Power
//
// Section A: Device Power
//
// Subsetion 1: Query Device Power
//


NTSTATUS
RaUnitPowerIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler for the unit's power irps.

Arguments:

    Unit - Unit to handle the power irp.

    Irp - Irp to be handled.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG Minor;
    
    ASSERT (RaidMajorFunctionFromIrp (Irp) == IRP_MJ_POWER);

    Status = RaUnitAcquireRemoveLock (Unit, Irp);

    if (!NT_SUCCESS (Status)) {
        Irp->IoStatus.Information = 0;
        PoStartNextPowerIrp (Irp);
        return RaidCompleteRequest (Irp,  Status);
    }

    Minor = RaidMinorFunctionFromIrp (Irp);
    DebugPower (("Unit %p, Irp %p, Power, Minor %x\n",
                  Unit, Irp, Minor));
    
    switch (Minor) {

        case IRP_MN_QUERY_POWER:
            Status = RaidUnitQueryPowerIrp (Unit, Irp);
            break;

        case IRP_MN_SET_POWER:
            Status = RaidUnitSetPowerIrp (Unit, Irp);
            break;

        default:
            PoStartNextPowerIrp (Irp);
            Status = RaidCompleteRequest (Irp,
                                          
                                          STATUS_NOT_SUPPORTED);
    }

    DebugPower (("Unit %p, Irp %p, Power, Minor %x, ret = %08x\n",
                  Unit, Irp, Minor, Status));

    RaUnitReleaseRemoveLock (Unit, Irp);

    return Status;
}



NTSTATUS
RaidUnitQueryPowerIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle IRP_MN_QUERY_POWER irp for the unit.
    
Arguments:

    Unit - Logical unit that must handle the irp.

    Irp - Query power irp to handle.

Return Value:

    NTSTATUS code.

--*/
{
    DebugPower (("Unit %p, Irp %p, Query Power, ret SUCCESS\n",
                 Unit, Irp));
    PoStartNextPowerIrp (Irp);
    return RaidCompleteRequest (Irp,  STATUS_SUCCESS);
}


//
// Part II: Unit Power
//
// Section A: Device Power
//
// Subsection 2: Set Device Power
//


NTSTATUS
RaidUnitSetPowerIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle IRP_MN_SET_POWER irps for the logical unit.

Arguments:

    Unit - Logical unit to handle this irp.

    Irp - Set power irp to handle.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    POWER_STATE_TYPE PowerType;
    POWER_STATE PowerState;
    
    //
    // Ignore shutdown irps.
    //

    PowerState = RaidPowerStateFromIrp (Irp);

    if (PowerState.SystemState >= PowerSystemShutdown) {
        PoStartNextPowerIrp (Irp);
        Status = RaidCompleteRequest (Irp,  STATUS_SUCCESS);
        DebugPower (("Unit %p, Irp %p, Set Power, Ignore Shutdown IRP.\n",
                      Unit, Irp));
        return Status;
    }
    
    PowerType = RaidPowerTypeFromIrp (Irp);
    DebugPower (("Unit %p, Irp %p, Set Power, Type = %x\n",
                 Unit, Irp, PowerType));

    switch (PowerType) {

        case SystemPowerState:
            Status = RaidUnitSetSystemPowerIrp (Unit, Irp);
            break;

        case DevicePowerState:
            Status = RaidUnitSetDevicePowerIrp (Unit, Irp);
            break;

        default:
            ASSERT (FALSE);
            Status = STATUS_UNSUCCESSFUL;
    }

    DebugPower (("Unit %p, Irp %p, Set Power, Type = %x, ret = %08x\n",
                 Unit, Irp, PowerType, Status));
    return Status;
}


NTSTATUS
RaidUnitSetDevicePowerIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler function for the set power irp, for a device state on the unit.

Arguments:

    Unit - Unit that this irp is for.

    Irp - Set power irp to handle.

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpStack;
    DEVICE_POWER_STATE CurrentState;
    DEVICE_POWER_STATE RequestedState;  

    ASSERT_UNIT (Unit);
    ASSERT (RaidPowerTypeFromIrp (Irp) == DevicePowerState);

    DebugPower (("Unit %p, Irp %p, Device Set Power\n",
                  Unit, Irp));

    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    CurrentState = Unit->Power.DeviceState;
    RequestedState = IrpStack->Parameters.Power.State.DeviceState;
    
    RaSetDevicePowerState (&Unit->Power, RequestedState);
    PoStartNextPowerIrp (Irp);
    Status = RaidCompleteRequest (Irp,  STATUS_SUCCESS);

    DebugPower (("Unit %p, Irp %p, Device Set Power, ret = %08x\n",
                  Unit, Irp, Status));

    return Status;
}


//
// Part II: Unit Power
//
// Section B: System Power
//
// Subsection 1: Query System Power
//


NTSTATUS
RaidUnitQuerySystemPowerIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle Query System Power IRP for the Logical Unit (PDO).

Arguments:

    Unit - Unit to handle the Query Power IRP for.

    Irp - Query System Power IRP to handle.

Return Value:

    NTSTATUS code.

--*/
{
    DebugPower (("Unit %p, Irp %p, Query System Power, ret SUCCESS\n",
                 Unit, Irp));

    PoStartNextPowerIrp (Irp);
    return RaidCompleteRequest (Irp,  STATUS_SUCCESS);
}


//
// Part II: Unit Power
//
// Section B: System Power
//
// Subsection 2: Set System Power
//

NTSTATUS
RaidUnitSetSystemPowerIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    DebugPower (("Unit %p, Irp %p, Set System Power, ret SUCCESS\n",
                 Unit, Irp));

    PoStartNextPowerIrp (Irp);
    return RaidCompleteRequest (Irp,  STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\portcfg.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    portcfg.h

Abstract:

    Implementation of operations on the PORT_CONFIGURATION object.

Author:

    Matthew D Hendel (math) 24-Apr-2000

Revision History:

--*/



#include "precomp.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RaCreateConfiguration)
#pragma alloc_text(PAGE, RaDeleteConfiguration)
#pragma alloc_text(PAGE, RaInitializeConfiguration)
#pragma alloc_text(PAGE, RaAssignConfigurationResources)
#endif // ALLOC_PRAGMA



VOID
RaCreateConfiguration(
    IN PPORT_CONFIGURATION_INFORMATION PortConfiguration
    )
/*++

Routine Description:

    Create a port configuration object and initialize it to a null state.

Arguments:

    PortConfiguration - Pointer to the the port configuration object to
            create.

Return Value:

    None.

--*/
{
    PAGED_CODE ();
    ASSERT (PortConfiguration != NULL);

    RtlZeroMemory (PortConfiguration, sizeof (PortConfiguration));
}


VOID
RaDeleteConfiguration(
    IN PPORT_CONFIGURATION_INFORMATION PortConfiguration
    )
/*++

Routine Description:

    Deallocate all resources associated with a port configuration object.x

Arguments:

    PortConfiguration - Pointer to the port configuration objectx to
            delete.

Return Value:

    NTSTATUS code

--*/
{
    PAGED_CODE ();
    ASSERT (PortConfiguration != NULL);
    ASSERT (PortConfiguration->Length == 0 ||
            PortConfiguration->Length == sizeof (PORT_CONFIGURATION_INFORMATION));

    if (PortConfiguration->AccessRanges != NULL) {
        ExFreePoolWithTag (PortConfiguration->AccessRanges, PORTCFG_TAG);
        PortConfiguration->AccessRanges = NULL;
    }

    PortConfiguration->Length = 0;
}


NTSTATUS
RaInitializeConfiguration(
    IN PPORT_CONFIGURATION_INFORMATION PortConfiguration,
    IN PHW_INITIALIZATION_DATA HwInitializationData,
    IN ULONG BusNumber
    )
/*++

Routine Description:

    Initialize a port configuration object from a hardware initialization
    data object.
    
Arguments:

    PortConfiguration - Pointer to the port configuration to be
            initialized.

    HwInitializationData - Pointer to a hardware initialization data that
            will be used to initialize the port configuration.

    BusNumber - The bus number this configuration is for.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG j;
    PCONFIGURATION_INFORMATION Config;
    
    PAGED_CODE ();
    ASSERT (PortConfiguration != NULL);
    ASSERT (HwInitializationData != NULL);

    RtlZeroMemory (PortConfiguration, sizeof (*PortConfiguration));
    PortConfiguration->Length = sizeof(PORT_CONFIGURATION_INFORMATION);
    PortConfiguration->AdapterInterfaceType = HwInitializationData->AdapterInterfaceType;
    PortConfiguration->InterruptMode = Latched;
    PortConfiguration->MaximumTransferLength = SP_UNINITIALIZED_VALUE;
    PortConfiguration->DmaChannel = SP_UNINITIALIZED_VALUE;
    PortConfiguration->DmaPort = SP_UNINITIALIZED_VALUE;
    PortConfiguration->MaximumNumberOfTargets = SCSI_MAXIMUM_TARGETS_PER_BUS;
    PortConfiguration->MaximumNumberOfLogicalUnits = SCSI_MAXIMUM_LOGICAL_UNITS;
    PortConfiguration->WmiDataProvider = TRUE;
    PortConfiguration->Master = TRUE;
    PortConfiguration->Dma32BitAddresses = TRUE;
    PortConfiguration->DemandMode = FALSE;
    PortConfiguration->NeedPhysicalAddresses = TRUE;
    PortConfiguration->TaggedQueuing = TRUE;
    PortConfiguration->MultipleRequestPerLu = TRUE;
    PortConfiguration->RealModeInitialized = FALSE;
    PortConfiguration->BufferAccessScsiPortControlled = TRUE;
    PortConfiguration->AutoRequestSense = TRUE;
    

    //
    // If the system indicates it can do 64-bit physical addressing then tell
    // the miniport it's an option.
    //

#if 1
    PortConfiguration->Dma64BitAddresses = SCSI_DMA64_SYSTEM_SUPPORTED;
#else
    if (Sp64BitPhysicalAddresses == TRUE) {
        PortConfiguration->Dma64BitAddresses = SCSI_DMA64_SYSTEM_SUPPORTED;
    } else {
        PortConfiguration->Dma64BitAddresses = 0;
    }
#endif

    //
    // Save away the some of the attributes.
    //

    PortConfiguration->ReceiveEvent = HwInitializationData->ReceiveEvent;
    PortConfiguration->SrbExtensionSize = HwInitializationData->SrbExtensionSize;
    PortConfiguration->SpecificLuExtensionSize = HwInitializationData->SpecificLuExtensionSize;

    //
    // The port configuration should add these:
    //
    //      MaximumNumberOfTargets
    //      NumberOfBuses
    //      CachesData
    //      ReceiveEvent
    //      WmiDataProvider
    //
    // Which should then be accessed ONLY through the port configuration
    // not, and never the HwInitializationData.
    //
    

    //
    // Allocate the access ranges.
    //
    
    PortConfiguration->NumberOfAccessRanges = HwInitializationData->NumberOfAccessRanges;

    PortConfiguration->AccessRanges =
            ExAllocatePoolWithTag (NonPagedPool,
                                   PortConfiguration->NumberOfAccessRanges * sizeof (ACCESS_RANGE),
                                   PORTCFG_TAG);

    if (PortConfiguration->AccessRanges == NULL) {
        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory (PortConfiguration->AccessRanges,
                   PortConfiguration->NumberOfAccessRanges * sizeof (ACCESS_RANGE));

    //
    // Indicate the current AT disk usage.
    //

    Config = IoGetConfigurationInformation();

    PortConfiguration->AtdiskPrimaryClaimed = Config->AtDiskPrimaryAddressClaimed;
    PortConfiguration->AtdiskSecondaryClaimed = Config->AtDiskSecondaryAddressClaimed;

    for (j = 0; j < 8; j++) {
        PortConfiguration->InitiatorBusId[j] = (CCHAR)SP_UNINITIALIZED_VALUE;
    }

    PortConfiguration->NumberOfPhysicalBreaks = 17; // SP_DEFAULT_PHYSICAL_BREAK_VALUE;

    //
    // Record the system bus number.
    //

    //
    // For a non-legacy adapter, is the bus number actually relevant?
    //
    
    PortConfiguration->SystemIoBusNumber = BusNumber;
    PortConfiguration->SlotNumber = 0;
    
    return STATUS_SUCCESS;
}


NTSTATUS
RaAssignConfigurationResources(
    IN OUT PPORT_CONFIGURATION_INFORMATION PortConfiguration,
    IN PCM_RESOURCE_LIST AllocatedResources,
    IN ULONG NumberOfAccessRanges
    )
/*++

Routine Description:

    Assign resources to a port configuration object.

Arguments:

    PortConfiguration - Pointer to the port configuration we are
            assigning resources to.

    AllocaedResources - The resources to assign.

    NumberOfAccessRanges - The number of access ranges.

Return Value:

    NTSTATUS code.

--*/
{
    ULONG RangeNumber;
    ULONG i;
    PACCESS_RANGE AccessRange;
    PCM_FULL_RESOURCE_DESCRIPTOR ResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialData;

    PAGED_CODE();

    RangeNumber = 0;
    ResourceList = AllocatedResources->List;
    
    for (i = 0; i < ResourceList->PartialResourceList.Count; i++) {
    
        PartialData = &ResourceList->PartialResourceList.PartialDescriptors[ i ];

        switch (PartialData->Type) {
        
            case CmResourceTypePort:

                //
                // Verify range count does not exceed what the
                // miniport indicated.
                //

                if (NumberOfAccessRanges > RangeNumber) {

                    //
                    // Get next access range.
                    //

                    AccessRange = &((*(PortConfiguration->AccessRanges))[RangeNumber]);

                    AccessRange->RangeStart = PartialData->u.Port.Start;
                    AccessRange->RangeLength = PartialData->u.Port.Length;
                    AccessRange->RangeInMemory = FALSE;

                    RangeNumber++;
                }
            break;

        case CmResourceTypeInterrupt:
        
            PortConfiguration->BusInterruptLevel = PartialData->u.Interrupt.Level;
            PortConfiguration->BusInterruptVector = PartialData->u.Interrupt.Vector;

            //
            // Check interrupt mode.
            //

            if (PartialData->Flags == CM_RESOURCE_INTERRUPT_LATCHED) {
                PortConfiguration->InterruptMode = Latched;
            } else if (PartialData->Flags == CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE) {
                PortConfiguration->InterruptMode = LevelSensitive;
            }
            break;

        case CmResourceTypeMemory:

            //
            // Verify range count does not exceed what the
            // miniport indicated.
            //

            if (NumberOfAccessRanges > RangeNumber) {

                 //
                 // Get next access range.
                 //

                 AccessRange = &((*(PortConfiguration->AccessRanges))[RangeNumber]);

                 AccessRange->RangeStart = PartialData->u.Memory.Start;
                 AccessRange->RangeLength = PartialData->u.Memory.Length;
                 AccessRange->RangeInMemory = TRUE;
                 RangeNumber++;
            }
            break;

        case CmResourceTypeDma:
            PortConfiguration->DmaChannel = PartialData->u.Dma.Channel;
            PortConfiguration->DmaPort = PartialData->u.Dma.Port;
            break;

        case CmResourceTypeDeviceSpecific: {

            PCM_SCSI_DEVICE_DATA ScsiData;
            
            if (PartialData->u.DeviceSpecificData.DataSize <
                sizeof (CM_SCSI_DEVICE_DATA)) {

                ASSERT (FALSE);
                break;
            }

            ScsiData = (PCM_SCSI_DEVICE_DATA)(PartialData + 1);
            PortConfiguration->InitiatorBusId[0] = ScsiData->HostIdentifier;
            break;
            }
        }
    }

    return STATUS_SUCCESS;
}
    




//
// After calling HwFindAdapter, we need to check the following
// fields from the PortConfig:
//
//      SrbExtensionSize
//      SpecificLuExtensionSize
//      MaximumNumberOfTargets
//      NumberOfBuses
//      CachesData
//      ReceiveEvent
//      TaggedQueuing
//      MultipleRequestsPerLu
//      WmiDataProvider
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\resource.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    resource.c

Abstract:

    Implementation of the RAIDPORT RAID_RESOURCE_LIST object.

Author:

    Matthew D Hendel (math) 24-Apr-2000

Revision History:

--*/


#include "precomp.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RaidCreateResourceList)
#pragma alloc_text(PAGE, RaidInitializeResourceList)
#pragma alloc_text(PAGE, RaidDeleteResourceList)
//#pragma alloc_text(PAGE, RaidTranslateResourceListAddress)
//#pragma alloc_text(PAGE, RaidGetResourceListElement)
#endif // ALLOC_PRAGMA



VOID
RaidCreateResourceList(
    OUT PRAID_RESOURCE_LIST ResourceList
    )
/*++

Routine Description:

    Initialize a raid resource list object to a null state.
    
Arguments:

    ResourceList - Pointer to the resource list to initialize.

Return Value:

    None.

--*/
{
    PAGED_CODE ();
    ASSERT (ResourceList != NULL);

    ResourceList->AllocatedResources = NULL;
    ResourceList->TranslatedResources = NULL;
}

NTSTATUS
RaidInitializeResourceList(
    IN OUT PRAID_RESOURCE_LIST ResourceList,
    IN PCM_RESOURCE_LIST AllocatedResources,
    IN PCM_RESOURCE_LIST TranslatedResources
    )
/*++

Routine Description:

    Initialize the allocated and translated resources for a raid resource
    list.

Arguments:

    ResourcList - Pointer to the resource list to initialize.

    AllocatedResources - Pointer to the allocated resources that will be
            copied to the resource lists private buffer.

    TranslatedResources - Pointer to the tranlsated resources that will
            be copied to the resoure lists private buffer.

Return Value:

    NTSTATUS code.

--*/
{

    PAGED_CODE ();

    if ((ResourceList == NULL) ||
        (AllocatedResources == NULL) ||
        (TranslatedResources == NULL)) {

        //
        // Nothing to do
        //
        return STATUS_SUCCESS;

    }

    ASSERT (ResourceList != NULL);
    ASSERT (AllocatedResources != NULL);
    ASSERT (TranslatedResources != NULL);

    ASSERT (AllocatedResources->Count == 1);
    ASSERT (AllocatedResources->List[0].PartialResourceList.Count ==
            TranslatedResources->List[0].PartialResourceList.Count);

    ResourceList->AllocatedResources =
            RaDuplicateCmResourceList (NonPagedPool,
                                        AllocatedResources,
                                        RESOURCE_LIST_TAG);

    ResourceList->TranslatedResources =
            RaDuplicateCmResourceList (NonPagedPool,
                                        TranslatedResources,
                                        RESOURCE_LIST_TAG);

    if (!ResourceList->AllocatedResources ||
        !ResourceList->TranslatedResources) {
        
        return STATUS_NO_MEMORY;
    }

    return STATUS_SUCCESS;
}

VOID
RaidDeleteResourceList(
    IN PRAID_RESOURCE_LIST ResourceList
    )
/*++

Routine Description:

    Delete any resources allocate by the resource list.

Arguments:

    ResourceList - Pointer to the resource list to delete.

Return Value:

    None.

--*/
{
    PAGED_CODE ();
    ASSERT (ResourceList != NULL);

    if (ResourceList->AllocatedResources) {
        ExFreePoolWithTag (ResourceList->AllocatedResources, RESOURCE_LIST_TAG);
        ResourceList->AllocatedResources = NULL;
    }

    if (ResourceList->TranslatedResources) {
        ExFreePoolWithTag (ResourceList->TranslatedResources, RESOURCE_LIST_TAG);
        ResourceList->TranslatedResources = NULL;
    }
}

NTSTATUS
RaidTranslateResourceListAddress(
    IN PRAID_RESOURCE_LIST ResourceList,
    IN INTERFACE_TYPE RequestedBusType,
    IN ULONG RequestedBusNumber,
    IN PHYSICAL_ADDRESS RangeStart,
    IN ULONG RangeLength,
    IN BOOLEAN IoSpace,
    OUT PPHYSICAL_ADDRESS Address
    )
/*++

Routine Description:

    Translate an address.

Arguments:

    ResourceList - The resource list to use for the translation.

    BusType - The type of bus this address is on.

    BusNumber - The bus number of the bus.

    RangeStart - The starting address.

    RangeLength - The length of the range to translate.

    IoSpace - Boolean indicating this is in IO space (TRUE) or
            memory space (FALSE).

    Address - Buffer to hold the resultant, translated address.
    
Return Value:

    NTSTATUS code.

--*/
{
    ULONG Count;
    ULONG i;
    INTERFACE_TYPE BusType;
    ULONG BusNumber;
    ULONGLONG AddrLow;
    ULONGLONG AddrHigh;
    ULONGLONG TestLow;
    ULONGLONG TestHigh;
    UCHAR ResourceType;
    BOOLEAN Found;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR Allocated;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR Translated;
    
//    PAGED_CODE ();

    Allocated = NULL;
    Translated = NULL;
    
    if (IoSpace) {
        ResourceType = CmResourceTypePort;
    } else {
        ResourceType = CmResourceTypeMemory;
    }
    
    //
    // Search through the allocated resource list trying to match the
    // requested resource.
    //

    Found = FALSE;
    Address->QuadPart = 0;
    Count =  RaidGetResourceListCount (ResourceList);

    for (i = 0; i < Count; i++) {

        RaidGetResourceListElement (ResourceList,
                                             i,
                                             &BusType,
                                             &BusNumber,
                                             &Allocated,
                                             &Translated);

        //
        // We had to have found the address on the correct bus.
        //
        
        if (BusType != RequestedBusType ||
            BusNumber != RequestedBusNumber) {

            continue;
        }

        AddrLow = RangeStart.QuadPart;
        AddrHigh = AddrLow + RangeLength;
        TestLow = Allocated->u.Generic.Start.QuadPart;
        TestHigh = TestLow + Allocated->u.Generic.Length;

        //
        // Test if the address is within range.
        //
        
        if (TestLow > AddrLow || TestHigh < AddrHigh) {
            continue;
        }

        //
        // Translate the address
        //
        
        Found = TRUE;
        Address->QuadPart = Translated->u.Generic.Start.QuadPart + (AddrLow - TestLow);
        break;
    }

    return (Found ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);
}


VOID
RaidGetResourceListElement(
    IN PRAID_RESOURCE_LIST ResourceList,
    IN ULONG Index,
    OUT PINTERFACE_TYPE InterfaceType,
    OUT PULONG BusNumber,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR* AllocatedResource, OPTIONAL
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR* TranslatedResource OPTIONAL
    )
/*++

Routine Description:

    Get the nth resource element from the resource list.

Arguments:

    ResourceList - Pointer to the resource list to retrieve the element from.

    Index - Index of the element to retrieve.

    InterfaceType - Bus interface type of the resource.

    BusNumber - Bus number of the bus.

    AllocatedResource - Supplies a pointer to where we can copy
            the allocate resource element reference, if non-null.

    TranslatedResource - Supplies a pointer to where we can copy
            the translated resource element reference, if
            non-null.

Return Value:

    None.

--*/
{
    ULONG ListNumber;
    PCM_FULL_RESOURCE_DESCRIPTOR Descriptor;

//    PAGED_CODE (); // Put Back when we fix reinit on hiber

    ASSERT (Index < RaidGetResourceListCount (ResourceList));

    RaidpGetResourceListIndex (ResourceList, Index, &ListNumber, &Index);
    
    *InterfaceType = ResourceList->AllocatedResources->List[ListNumber].InterfaceType;
    *BusNumber = ResourceList->AllocatedResources->List[ListNumber].BusNumber;
    
    if (AllocatedResource) {
        Descriptor = &ResourceList->AllocatedResources->List[ListNumber];
        *InterfaceType = Descriptor->InterfaceType;
        *BusNumber = Descriptor->BusNumber;
        *AllocatedResource = &Descriptor->PartialResourceList.PartialDescriptors[Index];
    }

    if (TranslatedResource) {
        Descriptor = &ResourceList->TranslatedResources->List[ListNumber];
        *InterfaceType = Descriptor->InterfaceType;
        *BusNumber = Descriptor->BusNumber;
        *TranslatedResource = &Descriptor->PartialResourceList.PartialDescriptors[Index];    
    }
}

        
NTSTATUS
RaidGetResourceListInterrupt(
    IN PRAID_RESOURCE_LIST ResourceList,
    OUT PULONG Vector,
    OUT PKIRQL Irql,
    OUT KINTERRUPT_MODE* InterruptMode,
    OUT PBOOLEAN Shared,
    OUT PKAFFINITY Affinity
    )
/*++

Routine Description:

    Get the translated interrupt resource from the resource list. We
    assume there is exactly one interrupt resource in the resource list.

    If there is more than one interrupt in the list, this function will
    ASSERT.  If there are no interrupts in the resource list, the
    function will return STATUS_NOT_FOUND.

Arguments:

    ResourceList - Supplies pointer to the resource list we will search
            for the interrupt resource in.

    Vector - Returns the interrupt vector for the interrupt.

    Irql - Returns the IRQL for the interrupt.

    InterruptMode - Returns the mode for the interrupt (Latched or
            LevelSensitive).

    Shared - Returns whether the interrupt is sharable (TRUE) or not (FALSE).

    Affinity - Returns the processor affinity of the interrupt.

Return Value:

    NTSTATUS code.

--*/
{
    ULONG i;
    ULONG Count;
    INTERFACE_TYPE BusType;
    ULONG BusNumber;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR Translated;
    
    PAGED_CODE();

    if (ResourceList == NULL) {
        //
        // Nothing to do
        //
        return STATUS_SUCCESS;
    }

    Count = RaidGetResourceListCount (ResourceList);

#if DBG

    //
    // In a checked build, verify that we were only assigned
    // a single interrupt.
    //
    
    {
        CM_PARTIAL_RESOURCE_DESCRIPTOR TranslatedSav;
        BOOLEAN Found;

        Found = FALSE;
        for (i = 0; i < Count; i++) {

            RaidGetResourceListElement (ResourceList,
                                        i,
                                        &BusType,
                                        &BusNumber,
                                        NULL,
                                        &Translated);

            if (Translated->Type == CmResourceTypeInterrupt) {

                if (!Found) {
                    RtlCopyMemory (&TranslatedSav, Translated,
                                   sizeof (CM_PARTIAL_RESOURCE_DESCRIPTOR));
                } else {

                    DebugPrint (("**** Found multiple interrupts in assigned resources!\n"));
                    DebugPrint (("**** Level = %x, Vector = %x, Affinity = %x\n",
                                 Translated->u.Interrupt.Level,
                                 Translated->u.Interrupt.Vector,
                                 Translated->u.Interrupt.Affinity));
                    DebugPrint (("**** Level = %x, Vector = %x, Affinity = %x\n",
                                 TranslatedSav.u.Interrupt.Level,
                                 TranslatedSav.u.Interrupt.Vector,
                                 TranslatedSav.u.Interrupt.Affinity));
                    KdBreakPoint();
                }
            }
        }
    }

#endif // DBG
                                   

    for (i = 0; i < Count; i++) {

        RaidGetResourceListElement (ResourceList,
                                    i,
                                    &BusType,
                                    &BusNumber,
                                    NULL,
                                    &Translated);

        if (Translated->Type == CmResourceTypeInterrupt) {

            ASSERT (Translated->u.Interrupt.Level < 256);
            *Irql = (KIRQL)Translated->u.Interrupt.Level;
            *Vector = Translated->u.Interrupt.Vector;
            *Affinity = Translated->u.Interrupt.Affinity;

            if (Translated->ShareDisposition == CmResourceShareShared) {
                *Shared = TRUE;
            } else {
                *Shared = FALSE;
            }

            if (Translated->Flags == CM_RESOURCE_INTERRUPT_LATCHED) {
                *InterruptMode = Latched;
            } else {
                ASSERT (Translated->Flags == CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE);
                *InterruptMode = LevelSensitive;
            }

            return STATUS_SUCCESS;
        }
    }

    return STATUS_NOT_FOUND;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\resource.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

	resource.h

Abstract:

	The RAID_RESOURCE_LIST class wraps allocated and translated
	CM_RESOURCE_LIST structures passed into the driver during it's
	StartDevice routine.

Author:

	Matthew D Hendel (math) 19-Apr-2000

Revision History:

--*/

#pragma once

typedef struct _RAID_RESOURCE_LIST {

    //
    // Raw resource list
    //
    
    PCM_RESOURCE_LIST AllocatedResources;

    //
    // Translated resource list.
    //
    
    PCM_RESOURCE_LIST TranslatedResources;

} RAID_RESOURCE_LIST, *PRAID_RESOURCE_LIST;



//
// Creation and destruction
//

VOID
RaidCreateResourceList(
	OUT PRAID_RESOURCE_LIST ResourceList
	);

NTSTATUS
RaidInitializeResourceList(
    IN OUT PRAID_RESOURCE_LIST ResourceList,
    IN PCM_RESOURCE_LIST AllocatedResources,
    IN PCM_RESOURCE_LIST TranslatedResources
    );

VOID
RaidDeleteResourceList(
	IN PRAID_RESOURCE_LIST ResourceList
	);


//
// Operations on the RAID_RESOURCE_LIST object.
//

ULONG
RaidGetResourceListCount(
	IN PRAID_RESOURCE_LIST ResourceList
	);

VOID
RaidGetResourceListElement(
	IN PRAID_RESOURCE_LIST ResourceList,
	IN ULONG Index,
	OUT PINTERFACE_TYPE InterfaceType,
	OUT PULONG BusNumber,
	OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR* AllocatedResource,
	OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR* TranslatedResource
	);

NTSTATUS
RaidTranslateResourceListAddress(
	IN PRAID_RESOURCE_LIST ResourceList,
	IN INTERFACE_TYPE InterfaceType,
	IN ULONG BusNumber,
	IN PHYSICAL_ADDRESS RangeStart,
	IN ULONG RangeLength,
	IN BOOLEAN IoSpace,
	OUT PPHYSICAL_ADDRESS Address
	);

NTSTATUS
RaidGetResourceListInterrupt(
	IN PRAID_RESOURCE_LIST ResourceList,
    OUT PULONG Vector,
    OUT PKIRQL Irql,
    OUT KINTERRUPT_MODE* InterruptMode,
    OUT PBOOLEAN Shared,
    OUT PKAFFINITY Affinity
	);

ULONG
RaidGetResourceListCount(
	IN PRAID_RESOURCE_LIST ResourceList
	);

//
// Private resource list operations
//

VOID
RaidpGetResourceListIndex(
    IN PRAID_RESOURCE_LIST ResourceList,
    IN ULONG Index,
    OUT PULONG ListNumber,
    OUT PULONG NewIndex
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\srb.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    srb.c

Abstract:

    Implementation of SRB object.

Author:

    Matthew D Hendel (math) 04-May-2000

Revision History:

--*/

#include "precomp.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RaidBuildMdlForXrb)
#pragma alloc_text(PAGE, RaidPrepareSrbForReuse)
#pragma alloc_text(PAGE, RaidInitializeInquirySrb)
#endif // ALLOC_PRAGMA

extern ULONG RaidVerifierEnabled;



PEXTENDED_REQUEST_BLOCK
RaidAllocateXrb(
    IN PNPAGED_LOOKASIDE_LIST XrbList,
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Allocate and initialize a SCSI EXTENDED_REQUEST_BLOCK.

Arguments:

    XrbList - If non-NULL, Pointer to the nonpaged lookaside list
            the XRB should be allocated from. If NULL, signifies
            that the XRB should be allocated from nonpaged Pool.

    DeviceObject - Supplies a device object used to log memory
            allocation failures.

Return Value:

    If the function is successful, an initialized Xrb is returned.
    Otherwise NULL.

Environment:

    DISPATCH_LEVEL only.

--*/
{
    PEXTENDED_REQUEST_BLOCK Xrb;

    ASSERT (DeviceObject != NULL);
    
    if (XrbList) {
        Xrb = ExAllocateFromNPagedLookasideList (XrbList);

        if (Xrb == NULL) {
            NYI();
            //
            // NB: Must log a memory error here.
            //
        }
    } else {
        Xrb = RaidAllocatePool (NonPagedPool,
                                sizeof (EXTENDED_REQUEST_BLOCK),
                                XRB_TAG,
                                DeviceObject);
    }

    if (Xrb == NULL) {
        return NULL;
    }
    
    RtlZeroMemory (Xrb, sizeof (EXTENDED_REQUEST_BLOCK));
    Xrb->Signature = XRB_SIGNATURE;
    Xrb->Pool = XrbList;

    return Xrb;
}



VOID
RaidXrbDeallocateResources(
    IN PEXTENDED_REQUEST_BLOCK Xrb,
    IN LOGICAL DispatchLevel
    )
/*++

Routine Description:

    Private helper function that deallocates all resources associated
    with an Xrb. This function is used by RaFreeXrb() and
    RaPrepareXrbForReuse() to deallocate any resources the Xrb is
    holding.

Arguments:

    Xrb - Xrb to deallocate resources for.

    DispatchLevel - TRUE if we are at DISSPATCH_LEVEL, FALSE if we are not
        necessarily at dispatch level. It is not an error (although a very
        small performance hit) to pass in FALSE for this parameter when
        we are at DISPATCH_LEVEL.

Return Value:

    None.

Environment:

    DISPATCH_LEVEL or below.

--*/
{
    BOOLEAN WriteRequest;
    PNPAGED_LOOKASIDE_LIST Pool;
    KIRQL Irql;


    if (Xrb->SgList != NULL) {
        ASSERT (Xrb->Adapter != NULL);
        WriteRequest = TEST_FLAG (Xrb->Srb->SrbFlags, SRB_FLAGS_DATA_OUT);

        //
        // If the verifier is enabled, free the Mdl for the remapped
        // ScatterGather list.
        //
        
        if (RaidVerifierEnabled) {
            RaidFreeRemappedScatterGatherListMdl (Xrb);
        }

        //
        // If we were not at DISPATCH_LEVEL raise the IRQL to DISPATCH before
        // freeing the scatter/gather list.
        //
        
        if (!DispatchLevel) {
            Irql = KeRaiseIrqlToDpcLevel ();
        }
        
        RaidDmaPutScatterGatherList (&Xrb->Adapter->Dma,
                                     Xrb->SgList,
                                     WriteRequest);

        //
        // Return the IRQL if necessary.
        //
        
        if (!DispatchLevel) {
            KeLowerIrql (Irql);
        }
    }

    //
    // NB: The DMA verifier assumes that the MDL associated with an SG list
    // is valid when the SG list is freed. Otherwise, we'll get a false
    // verifier error. Since it doesn't matter to us what order these are
    // freed in, free the SG list first, then the MDL.
    //

    if (Xrb->Mdl && Xrb->OwnedMdl) {
        IoFreeMdl (Xrb->Mdl);
        Xrb->Mdl = NULL;
        Xrb->OwnedMdl = FALSE;
    }
}



VOID
RaidFreeXrb(
    IN PEXTENDED_REQUEST_BLOCK Xrb,
    IN LOGICAL DispatchLevel
    )
/*++

Routine Description:

    Free the Xrb and deallocate any resources associated with it.

Arguments:

    Xrb - Xrb to deallocate.

    DispatchLevel - TRUE if we are at DISSPATCH_LEVEL, FALSE if we are not
        necessarily at dispatch level. It is not an error (although a very
        small performance hit) to pass in FALSE for this parameter when
        we are at DISPATCH_LEVEL.

Return Value:

    None.

Environment:

    DISPATCH_LEVEL or below.

--*/
{
    PNPAGED_LOOKASIDE_LIST Pool;

    RaidXrbDeallocateResources (Xrb, DispatchLevel);
    Pool = Xrb->Pool;
    DbgFillMemory (Xrb,
                   sizeof (EXTENDED_REQUEST_BLOCK),
                   DBG_DEALLOCATED_FILL);

    if (Pool) {
        ExFreeToNPagedLookasideList (Pool, Xrb);
    } else {
        RaidFreePool (Xrb, XRB_TAG);
    }
}



NTSTATUS
RaidBuildMdlForXrb(
    IN PEXTENDED_REQUEST_BLOCK Xrb,
    IN PVOID Buffer,
    IN SIZE_T BufferSize
    )
/*++

Routine Description:

    Build an MDL for the XRB describing the buffer region passed in. An
    XRB can have only one MDL per XRB.

Arguments:

    Xrb - XRB that will own the MDL.

    Buffer - Virtual Address of the buffer to build the MDL for.

    BufferSize - Size of the buffer to build the MDL for.

Return Value:

    NTSTATUS code.

--*/
{
    PAGED_CODE ();

    //
    // The MDL field of the XRB should be NULL before we allocate a new MDL.
    // Otherwise, we are likely to leak a MDL that the XRB already
    // has created.
    //
    
    ASSERT (Xrb->Mdl == NULL);
    
    Xrb->Mdl = IoAllocateMdl (Buffer, (ULONG)BufferSize, FALSE, FALSE, NULL);
    if (Xrb->Mdl == NULL) {
        return STATUS_NO_MEMORY;
    }

    //
    // By specifying that we own the MDL, we force it to be deleted
    // when we delete the XRB.
    //
    
    Xrb->OwnedMdl = TRUE;
    MmBuildMdlForNonPagedPool (Xrb->Mdl);

    return STATUS_SUCCESS;
}


VOID
RaidXrbSetSgList(
    IN PEXTENDED_REQUEST_BLOCK Xrb,
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PSCATTER_GATHER_LIST SgList
    )
{
    ASSERT (Xrb->Adapter == NULL || Xrb->Adapter == Adapter);
    ASSERT (Xrb->SgList == NULL);

    Xrb->Adapter = Adapter;
    Xrb->SgList = SgList;
}
    

VOID
RaidPrepareXrbForReuse(
    IN PEXTENDED_REQUEST_BLOCK Xrb,
    IN LOGICAL DispatchLevel
    )
/*++

Routine Description:

    Prepare the Xrb to be reused.

Arguments:

    Xrb - Pointer to Xrb that will be reused.

    DispatchLevel - TRUE if we are at DISSPATCH_LEVEL, FALSE if we are not
        necessarily at dispatch level. It is not an error (although a very
        small performance hit) to pass in FALSE for this parameter when
        we are at DISPATCH_LEVEL.

Return Value:

    None.

Environment:

    Kernel Mode, DISPATCH_LEVEL or below.

--*/
{
    PNPAGED_LOOKASIDE_LIST Pool;

    RaidXrbDeallocateResources (Xrb, DispatchLevel);
    Pool = Xrb->Pool;
    RtlZeroMemory (Xrb, sizeof (EXTENDED_REQUEST_BLOCK));
    Xrb->Signature = XRB_SIGNATURE;
    Xrb->Pool = Pool;
}


VOID
RaidXrbSetCompletionRoutine(
    IN PEXTENDED_REQUEST_BLOCK Xrb,
    IN XRB_COMPLETION_ROUTINE XrbCompletion
    )
{
    ASSERT (Xrb->CompletionRoutine == NULL);
    Xrb->CompletionRoutine = XrbCompletion;
}


//
// Operations for SRBs
//


PSCSI_REQUEST_BLOCK
RaidAllocateSrb(
    IN PVOID IoObject
    )
/*++

Routine Description:

    Allocate and initialize a srb to a NULL state.
    
Arguments:

    DeviceObject - Supplies a device object for logging memory allocation
            errors.

Return Value:

    If successful, a poiter to an allocated SRB initialize to a null
    state.  Otherwise, NULL.

Environment:

    This function is in the reset path. It is used to allocate SRBs for
    logical-unit-reset and target-reset. Therefore, it cannot be paged.

--*/
{
    PSCSI_REQUEST_BLOCK Srb;

    //
    // Allocate the srb from nonpaged pool.
    //
    
    Srb = RaidAllocatePool (NonPagedPool,
                            sizeof (SCSI_REQUEST_BLOCK),
                            SRB_TAG,
                            IoObject);
    if (Srb == NULL) {
        return NULL;
    }

    RtlZeroMemory (Srb, sizeof (SCSI_REQUEST_BLOCK));

    return Srb;
}

VOID
RaidFreeSrb(
    IN PSCSI_REQUEST_BLOCK Srb
    )
/*++

Routine Description:

    Free a Srb back to pool.

Arguments:

    Srb - Srb to free.

Return Value:

    None.

Environment:

    This function is in the reset path. It is used to allocate SRBs for
    logical-unit-reset and target reset. Therefore, it cannot be paged.

--*/

{
    PAGED_CODE ();

    ASSERT (Srb != NULL);
    ASSERT (Srb->SrbExtension == NULL);
    ASSERT (Srb->OriginalRequest == NULL);
    ASSERT ((Srb->SenseInfoBuffer == NULL) ||
            (Srb->Function == SRB_FUNCTION_WMI));

    DbgFillMemory (Srb,
                   sizeof (SCSI_REQUEST_BLOCK),
                   DBG_DEALLOCATED_FILL);
    RaidFreePool (Srb, SRB_TAG);
}

VOID
RaidPrepareSrbForReuse(
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    PVOID SrbExtension;
    PVOID SenseInfo;

    PAGED_CODE ();

    SenseInfo = Srb->SenseInfoBuffer;
    SrbExtension = Srb->SrbExtension;
    RtlZeroMemory (Srb, sizeof (*Srb));
    Srb->SenseInfoBuffer = SenseInfo;
    Srb->SrbExtension = SrbExtension;
}


NTSTATUS
RaidInitializeInquirySrb(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN PVOID Buffer,
    IN SIZE_T BufferSize
    )
/*++

Routine Description:

    Initialize a scsi inquiry srb.

Arguments:

    Srb - Pointer to the srb to initialize.

    PathId - Identifies the scsi path id for this srb.

    TargetId - Identifies the scsi target id for this srb.

    Lun - Identifies the scsi logical unit this srb is for.

    Buffer - The buffer the INQUIRY data will be read into.

    BufferSize - The size of the INQUIRY buffer. This should be
            at least INQUIRYDATABUFFERSIZE, but can be larger if
            more data is required.

Return Value:

    NTSTATUS code.

--*/
{
    struct _CDB6INQUIRY* Cdb;
    
    
    PAGED_CODE ();
    ASSERT (Srb != NULL);
    ASSERT (Buffer != NULL);
    ASSERT (BufferSize != 0);

    //  
    // NB: Should be be using the SCSI-2 or SCSI-3 INQUIRY?  This is
    // implemented using SCSI-2.
    //
    
    //
    // The buffer should be at least the size of the minimum
    // INQUIRY buffer size. It can be larger if we are requesting
    // extra data.
    //
    
    if (BufferSize < INQUIRYDATABUFFERSIZE) {
        ASSERT (FALSE);
        return STATUS_INVALID_PARAMETER_6;
    }
    
    //
    // The caller must have either just allocated this srb or
    // called RaPrepareSrbForReuse() on the srb. In either of
    // these cases, the Function and CdbLength should be zero.
    //

    ASSERT (Srb->Function == 0);
    ASSERT (Srb->CdbLength == 0);

    Srb->Length = sizeof (SCSI_REQUEST_BLOCK);
    Srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
    Srb->PathId = PathId;
    Srb->TargetId = TargetId;
    Srb->Lun = Lun;
    Srb->SrbFlags = SRB_FLAGS_DATA_IN | SRB_FLAGS_DISABLE_SYNCH_TRANSFER;
    Srb->DataBuffer = Buffer;
    Srb->DataTransferLength = (ULONG)BufferSize;

    //
    // The timeout will usually be reset by an upper layer, so it's ok
    // that we use a hard-coded constant here.
    //
    
    Srb->TimeOutValue = DEFAULT_IO_TIMEOUT;

    ASSERT (Srb->SrbStatus == 0);
    ASSERT (Srb->ScsiStatus == 0);
    
    Srb->CdbLength = 6;
    Cdb = (struct _CDB6INQUIRY*)Srb->Cdb;

    Cdb->OperationCode = SCSIOP_INQUIRY;
    Cdb->AllocationLength = (UCHAR)BufferSize;
    Cdb->LogicalUnitNumber = Lun;

    //
    // These fields should have been zero'd out by the srb allocation
    // routine or the RaPrepareSrbForReuse routine.
    //
    
    ASSERT (Cdb->PageCode == 0);
    ASSERT (Cdb->Reserved1 == 0);
    ASSERT (Cdb->IReserved == 0);
    ASSERT (Cdb->Control == 0);

    return STATUS_SUCCESS;
}



//
// Routines for SRB extensions
//

PVOID
RaidAllocateSrbExtension(
    IN PRAID_FIXED_POOL Pool,
    IN ULONG QueueTag
    )
/*++

Routine Description:

    Allocate a srb extension and initialize it to NULL.

Arguments:

    Pool - Fixed pool to allocate the srb extension from.

    QueueTag - Index into the extenion pool that should be allocated.

Return Value:

    Pointer to an initialized SRB Extension if the function was
    successful.

    NULL otherwise.

Environment:

    DISPATCH_LEVEL or below.

--*/
{
    PVOID Extension;

    Extension = RaidAllocateFixedPoolElement (Pool, QueueTag);
    RtlZeroMemory (Extension, Pool->SizeOfElement);

    return Extension;
}

VOID
RaidFreeSrbExtension(
    IN PRAID_FIXED_POOL Pool,
    IN ULONG QueueTag
    )
/*++

Routine Description:

    Free a Srb extension.

Arguments:

    Pool - Fixed pool to free the srb extension to.

    QueueTag - Index into the extension pool that should be freed.

Return Value:

    None.

--*/
{
    RaidFreeFixedPoolElement (Pool, QueueTag);
}

VOID
RaidXrbSignalCompletion(
    IN PEXTENDED_REQUEST_BLOCK Xrb
    )
/*++

Routine Description:

    Callback routine that signals that a synchronous XRB has been completed.

Arguments:

    Xrb - Xrb to signal completion for.

Return Value:

    None.

--*/
{
    ASSERT_XRB (Xrb);
    KeSetEvent (&Xrb->u.CompletionEvent, IO_NO_INCREMENT, FALSE);
}

NTSTATUS
RaidInitializeReportLunsSrb(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN PVOID Buffer,
    IN SIZE_T BufferSize
    )
/*++

Routine Description:

    Initialize a scsi REPORT LUNS srb.

Arguments:

    Srb - Pointer to the srb to initialize.

    PathId - Identifies the scsi path id for this srb.

    TargetId - Identifies the scsi target id for this srb.

    Lun - Identifies the scsi logical unit this srb is for.

    Buffer - The buffer the INQUIRY data will be read into.

    BufferSize - The size of the INQUIRY buffer. This should be
            at least INQUIRYDATABUFFERSIZE, but can be larger if
            more data is required.

Return Value:

    NTSTATUS code.

--*/
{
    struct _REPORT_LUNS * Cdb;
    
    PAGED_CODE ();
    ASSERT (Srb != NULL);
    ASSERT (Buffer != NULL);
    ASSERT (BufferSize != 0);

    //
    // The caller must have either just allocated this srb or
    // called RaPrepareSrbForReuse() on the srb. In either of
    // these cases, the Function and CdbLength should be zero.
    //

    ASSERT (Srb->Function == 0);
    ASSERT (Srb->CdbLength == 0);

    Srb->Length = sizeof (SCSI_REQUEST_BLOCK);
    Srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
    Srb->PathId = PathId;
    Srb->TargetId = TargetId;
    Srb->Lun = Lun;
    Srb->SrbFlags = SRB_FLAGS_DATA_IN | SRB_FLAGS_DISABLE_SYNCH_TRANSFER;
    Srb->DataBuffer = Buffer;
    Srb->DataTransferLength = (ULONG)BufferSize;

    //
    // The timeout will usually be reset by an upper layer, so it's ok
    // that we use a hard-coded constant here.
    //
    
    Srb->TimeOutValue = DEFAULT_IO_TIMEOUT;

    ASSERT (Srb->SrbStatus == 0);
    ASSERT (Srb->ScsiStatus == 0);
    
    Srb->CdbLength = 12;
    Cdb = (struct _REPORT_LUNS *)Srb->Cdb;

    RtlZeroMemory(Cdb, Srb->CdbLength);

    Cdb->OperationCode = SCSIOP_REPORT_LUNS;
    Cdb->AllocationLength[0] = (UCHAR)(((ULONG)BufferSize >> 24) & 0xff);
    Cdb->AllocationLength[1] = (UCHAR)(((ULONG)BufferSize >> 16) & 0xff);
    Cdb->AllocationLength[2] = (UCHAR)(((ULONG)BufferSize >> 8) & 0xff);
    Cdb->AllocationLength[3] = (UCHAR)(((ULONG)BufferSize >> 0) & 0xff);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\unit.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    unit.h

Abstract:

    Definintion and declaration of the RAID_UNIT (PDO) object.
    
Author:

    Matthew D Hendel (math) 20-Apr-2000

Revision History:

--*/

#pragma once

//
// These are the resources necessary to execute a single IO
// request.
//

typedef struct _RAID_IO_RESOURCES {

    //
    // SCSI_REQUEST_BLOCK::QueueTag
    //
    
    ULONG QueueTag;

    //
    // SCSI_REQUEST_BLOCK::SrbExtension
    //
    
    PVOID SrbExtension;

    //
    // SCSI_REQUEST_BLOCK::OriginalRequest
    //
    
    PEXTENDED_REQUEST_BLOCK Xrb;

} RAID_IO_RESOURCES, *PRAID_IO_RESOURCES;



//
// This is the logical unit (PDO) object extension.
//

typedef struct _RAID_UNIT_EXTENSION {

    //
    // The device object type. Must be RaidUnitObject for the raid unit
    // extension.
    //
    // Protected by: RemoveLock
    //
    
    RAID_OBJECT_TYPE ObjectType;

    //
    // The device object that owns this extension.
    //
    // Protected by: RemoveLock
    //

    PDEVICE_OBJECT DeviceObject;

    //
    // Pointer to the adapter that owns this unit.
    //
    // Protected by: RemoveLock
    //

    PRAID_ADAPTER_EXTENSION Adapter;

    //
    // Slow lock for any data not protected by another lock.
    //
    // NB: The slow lock should not be used to access
    // anything on the i/o path. Hence the name.
    //
    // Protected by: SlowLock
    //
    
    KSPIN_LOCK SlowLock;
    
    //
    // PnP device state.
    //
    // Protected by: Interlocked access
    //

    DEVICE_STATE DeviceState;

    //
    // List of all the units on this adapter.
    //
    // Protected by: ADAPTER::UnitList::Lock
    //
    
    LIST_ENTRY NextUnit;

    //
    // A hash-table containing all units on this adapter.
    //
    // Protected by: Read access must hold the interrupt lock.
    //               Write access must hold the Adapter UnitList lock
    //               AND the interrupt lock.
    //

    STOR_DICTIONARY_ENTRY UnitTableLink;

    //
    // The RAID address of the unit.
    //
    // Protected by: 
    //

    RAID_ADDRESS Address;

    //
    // Inquiry Data
    //
    // Protected by:
    //

    STOR_SCSI_IDENTITY Identity;

    //
    // Flags for the unit device.
    //
    // Protected by: SlowLock
    //
    
    struct {

        //
        // Flag specifying whether the device has been
        // claimed or not.
        //
        
        BOOLEAN DeviceClaimed : 1;

        //
        // The LU's device queue is frozen on an error.
        //
        
        BOOLEAN QueueFrozen : 1;

        //
        // The LU's device queue is locked at the request
        // of the class driver.
        //
        
        BOOLEAN QueueLocked : 1;

        //
        // Did the last bus enumeration include this unit? If so, we cannot
        // delete the unit in response to an IRP_MN_REMOVE request; rather,
        // we have to wait until the bus is enumerated again OR the adapter
        // is removed.
        //
        
        BOOLEAN Enumerated : 1;

        //
        // Flag specifying that the unit is physically present (TRUE),
        // or not (FALSE).
        //
        
        BOOLEAN Present : 1;

        //
        // Flag specifying whether the unit is temporary or not. That is,
        // is the unit being used as a temporary unit for enumerating
        // the bus (TRUE) or not.
        //
        
        BOOLEAN Temporary : 1;
        
        //
        // Has WMI been initialized for this device object?
        //

        BOOLEAN WmiInitialized : 1;        
        
    } Flags;


	//
	// The next two fields are a hand-rolled remove lock.
	//

	//
	// The event is signaled when there are zero outstanding requests.
	//
	
	KEVENT ZeroOutstandingEvent;

	//
	// This is the current outstanding request count.
	//
	//
	// Protected by: Interlocked access.
	//
	
	LONG OutstandingCount;

    //
    // Count of devices that are in the paging/hiber/dump path.
    // We use a single count for all three paging, hiber and dump,
    // since there is no need (at this time) to distinguish between
    // the three.
    //
    // Protected by: Interlocked access
    //

    ULONG PagingPathCount;
	ULONG CrashDumpPathCount;
	ULONG HiberPathCount;

    //
    // Elements for tagged queuing.
    //
    // Protected by: TagList
    //
    
    QUEUE_TAG_LIST TagList;
    
    //
    // SrbExtensions are allocated out of this pool. The memory for
    // this pool is allocated early on from common buffer.
    //
    // Protected by: TagList
    //

    RAID_MEMORY_REGION SrbExtensionRegion;
    
    RAID_FIXED_POOL SrbExtensionPool;

#if 0
    //
    // REVIEW - Does sense info get allocated by port or class.
    //
    
    //
    // The sense info buffer for a srb is allocated from this pool. Like
    // the SrbExtensionPool, it is a fixed size pool allocated from
    // common buffer.
    //
    // Protected by: TagList
    //

    RAID_FIXED_POOL SenseInfoPool;

    //
    // Create a lookaside list Xrbs.
    //
    // Protected by: XrbList
    //
#endif

    NPAGED_LOOKASIDE_LIST XrbList;

    //
    // An I/O queue for unit requests.
    //
    // Protected by: IoQueue
    //
    
    IO_QUEUE IoQueue;

    //
    // The device's maximum queue depth. Miniports can adjust the depth
    // based on the conditions of the bus/device, but can never go
    // above this.
    //
    
    ULONG MaxQueueDepth;
    
    //
    // Power state information for the unit.
    //
    // Protected by: Multiple power irps are not
    // sent to the unit.
    //

    RAID_POWER_STATE Power;

    //
    // Queue of items currently pending in the adapter.
    //
    // Protected by: Self.
    //

    STOR_EVENT_QUEUE PendingQueue;

    //
    // Timer for entries in the pending queue.
    //
    // Protected by: only modified in start/stop unit routiens.
    //
    
    KTIMER PendingTimer;

    //
    // DPC routine for entries in the pending queue.
    //
    // Protected by: modified in start/stop unit routines.
    //
    
    KDPC PendingDpc;

    //
    // Pause timer.
    //
    // Protected by: modified in start/stop unit routines.
    //
    
    KTIMER PauseTimer;

	//
    // Pause DPC routine.
    //
    // Protected by: modified in start/stop unit routines.
    //
    
    KDPC PauseTimerDpc;

    //
    // Points to an array that holds the VAs of all the common blocks.
    //

    PRAID_MEMORY_REGION CommonBufferVAs;

    //
    // Common Buffer Size
    //

    ULONG CommonBufferSize;

    //
    // Indicates the number of common buffer blocks that have been allocated.
    //

    ULONG CommonBufferBlocks;

    //
    // Logical Unit Extension
    //
    // Protected by: Read only after initialization.
    //

    PVOID UnitExtension;

	//
	// Default timeout value for I/Os issued by the port driver to the
	// logical unit.
	//
	
	ULONG DefaultTimeout;

	//
	// Fixed elements for the deferred list.
	//
	
	struct {
		RAID_DEFERRED_ELEMENT PauseDevice;
		RAID_DEFERRED_ELEMENT ResumeDevice;
		RAID_DEFERRED_ELEMENT DeviceBusy;
		RAID_DEFERRED_ELEMENT DeviceReady;
	} DeferredList;


	//
	// ResetCount is the count of outstanding SRB_FUNCTION_RESET_XXX commands
	// that have been sent to the logical unit (BUS, DEVICE, LOGICAL_UNIT).
	// This count is used to determine how we should reset on a timeout.
	// If there is an outstanding reset command, we use the HwResetBus
	// callback instead of issuing a reset SRB.
	//
	
	LONG ResetCount;

	//
	// Pre-allocated set of resources used for resets.
	//
	
	RAID_IO_RESOURCES ResetResources;

	//
	// Binary value specifying if the reset resources have been acquired (1)
	// not (0).
	//
	// Protected by: Interlocked access.
	//
	
	LONG ResetResourcesAcquired;

} RAID_UNIT_EXTENSION, *PRAID_UNIT_EXTENSION;



//
// This structure is used to handle the IOCTL_STORAGE_QUERY_PROPERTY ioctl.
//

typedef struct _RAID_DEVICE_DESCRIPTOR {

    //
    // Common STORAGE_DEVICE_DESCRIPTOR header.
    //
    
    STORAGE_DEVICE_DESCRIPTOR Storage;

    //
    // SCSI VendorId directly from the SCSI InquiryData.
    //
    
    CHAR VendorId [SCSI_VENDOR_ID_LENGTH];

    //
    // SCSI ProuctId directly from the SCSI InquiryData.
    //

    CHAR ProductId [SCSI_PRODUCT_ID_LENGTH];

    //
    // SCSI ProductRevision directly from the SCSI InquiryData.
    //

    CHAR ProductRevision [SCSI_REVISION_ID_LENGTH];

    //
    // SCSI SerialNumber.
    //

    CHAR SerialNumber [SCSI_SERIAL_NUMBER_LENGTH];

} RAID_DEVICE_DESCRIPTOR;




//
// Creation and destruction
//


NTSTATUS
RaidCreateUnit(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    OUT PRAID_UNIT_EXTENSION* Unit
    );

VOID
RaidUnitAssignAddress(
    IN PRAID_UNIT_EXTENSION Unit,
    IN RAID_ADDRESS Address
    );

VOID
RaidUnitAssignIdentity(
    IN PRAID_UNIT_EXTENSION Unit,
    IN OUT PSTOR_SCSI_IDENTITY Identity
    );

VOID
RaidDeleteUnit(
    IN PRAID_UNIT_EXTENSION Unit
    );

VOID
RaidPrepareUnitForReuse(
    IN PRAID_UNIT_EXTENSION Unit
    );
    

NTSTATUS
RaCreateUnitPools(
    IN PRAID_UNIT_EXTENSION Unit
    );

VOID
RaUnitAsyncError(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PEXTENDED_REQUEST_BLOCK Xrb
    );

VOID
RaUnitStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );
    
//
// Callback and Handler routines
//

NTSTATUS
RaUnitCreateIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitCloseIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

//
// PnP Irps
//

NTSTATUS
RaUnitPnpIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitQueryCapabilitiesIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );
    
NTSTATUS
RaUnitQueryDeviceRelationsIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitQueryIdIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitSucceedPnpIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitIgnorePnpIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitStartDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitStopDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitQueryStopDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitCancelStopDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitRemoveDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitQueryRemoveDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );
    
NTSTATUS
RaUnitCancelRemoveDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitSurpriseRemovalIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitDeviceUsageNotificationIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitDeviceUsageNotificationCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP DependentIrp,
    IN PVOID Context
	);

NTSTATUS
RaUnitQueryDeviceTextIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitQueryPnpDeviceStateIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );
    
NTSTATUS
RaUnitDisableDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );
    
NTSTATUS
RaUnitDeleteDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

//
// IRP_MJ_SCSI Commands
//


NTSTATUS
RaUnitScsiIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitExecuteScsiSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitClaimDeviceSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitIoControlSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitReleaseQueueSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitReceiveEventSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitAttachDeviceSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitReleaseDeviceSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitShutdownSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitFlushSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitAbortCommandSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitReleaseRecoverySrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitResetBusSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitResetDeviceSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitTerminateIoSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitFlushQueueSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitRemoveDeviceSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitWmiSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitLockQueueSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitUnlockQueueSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitUnknownSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );


//
// IRP_MJ_DEVICE_CONTROL IRP handlers.
//


NTSTATUS
RaUnitDeviceControlIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitScsiPassThroughIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitScsiMiniportIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitScsiGetInquiryDataIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitScsiGetCapabilitesIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitScsiPassThroughDirectIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitScsiGetAddressIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitScsiRescanBusIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitScsiGetDumpPointersIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitScsiFreeDumpPointersIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitStorageResetBusIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitStorageQueryPropertyIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitUnknownIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaidUnitResetLogicalUnit(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaidUnitResetUnit(
    IN PRAID_UNIT_EXTENSION Unit
    );

NTSTATUS
RaidUnitResetTarget(
    IN PRAID_UNIT_EXTENSION Unit
    );

//
// Power
//
    
NTSTATUS
RaUnitPowerIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

//
// Other
//


NTSTATUS
RaidUnitGetDeviceId(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PWSTR* DeviceIdBuffer
    );

NTSTATUS
RaidUnitGetInstanceId(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PWSTR* InstanceIdBuffer
    );
    
NTSTATUS
RaidUnitGetHardwareIds(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PWSTR* HardwareIdsBuffer
    );
    
NTSTATUS
RaidUnitGetCompatibleIds(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PWSTR* CompatibleIdsBuffer
    );
    

NTSTATUS
RaUnitBusQueryInstanceIdIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitBusQueryHardwareIdsIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitBusQueryCompatibleIdsIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaGetUnitStorageDeviceProperty(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PSTORAGE_DEVICE_DESCRIPTOR DescriptorBuffer,
    IN OUT PULONG BufferLength
    );

NTSTATUS
RaGetUnitStorageDeviceIdProperty (
    IN PRAID_UNIT_EXTENSION Unit,
    IN PSTORAGE_DEVICE_ID_DESCRIPTOR DescriptorBuffer,
    IN OUT PULONG BufferLength
    );

//
// Private operations
//

NTSTATUS
RaidUnitClaimIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp,
    IN PRAID_IO_RESOURCES IoResources OPTIONAL
    );

VOID
RaidUnitReleaseIrp(
    IN PIRP Irp,
    OUT PRAID_IO_RESOURCES IoResources OPTIONAL
    );

NTSTATUS
RaidUnitQueryPowerIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaidUnitSetPowerIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaidUnitSetSystemPowerIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaidUnitSetDevicePowerIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

VOID
RaidpUnitEnterD3Completion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PIRP SystemPowerIrp,
    IN PIO_STATUS_BLOCK IoStatus
    );

VOID
RaidUnitRestartQueue(
    IN PRAID_UNIT_EXTENSION Unit
    );
    
VOID
RaUnitAddToPendingList(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

VOID
RaUnitRemoveFromPendingList(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

VOID
RaidUnitProcessBusyRequest(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PEXTENDED_REQUEST_BLOCK Xrb
    );

VOID
RaidUnitProcessBusyRequestAtDirql(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PEXTENDED_REQUEST_BLOCK Xrb
    );

BOOLEAN
RaidUnitSetEnumerated(
    IN PRAID_UNIT_EXTENSION Unit,
    IN BOOLEAN Enumerated
    );

VOID
RaidAdapterRemoveUnit(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PRAID_UNIT_EXTENSION Unit
    );

PVOID
RaidGetKeyFromUnit(
    IN PSTOR_DICTIONARY_ENTRY Entry
    );

NTSTATUS
RaidUnitSubmitRequest(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

RAID_ADDRESS
INLINE
RaidUnitGetAddress(
    IN PRAID_UNIT_EXTENSION Unit
    )
{
    return Unit->Address;
}

VOID
RaidUnitPendingDpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

NTSTATUS
RaidUnitHierarchicalReset(
    IN PRAID_UNIT_EXTENSION Unit
    );

LOGICAL
RaidUnitNotifyHardwareGone(
    IN PRAID_UNIT_EXTENSION Unit
    );
    
NTSTATUS
RaidUnitCancelPendingRequestsAsync(
    IN PRAID_UNIT_EXTENSION Unit
    );

NTSTATUS
RaidCancelRequestsWorkRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

NTSTATUS
RaidUnitCancelPendingRequests(
    IN PRAID_UNIT_EXTENSION Unit
    );
    
VOID
RaidZeroUnit(
    IN PRAID_UNIT_EXTENSION Unit
    );

NTSTATUS
RaidUnitAllocateResources(
    IN PRAID_UNIT_EXTENSION Unit
    );

NTSTATUS
RaidUnitFreeResources(
    IN PRAID_UNIT_EXTENSION Unit
    );

NTSTATUS
RaidUnitAllocateSrbExtensionPool(
    IN PRAID_UNIT_EXTENSION Unit,
    IN OUT PULONG NumberOfElements,
    IN BOOLEAN AcceptLowerCount
    );

NTSTATUS
RaidUnitAllocateSrbExtensionPoolVerify(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PULONG NumberOfElements,
    IN LOGICAL AcceptLowerCount
    );
	
VOID
RaidUnitFreeSrbExtensionPoolVerify(
    IN PRAID_UNIT_EXTENSION Unit
    );

VOID
RaidStartUnit(
	IN PRAID_UNIT_EXTENSION Unit
	);

VOID
RaidUnitPauseTimerDpcRoutine(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context1,
    IN PVOID Context2
    );

VOID
RaidSetUnitPauseTimer(
    IN PRAID_UNIT_EXTENSION Unit,
    IN ULONG Timeout
    );

VOID
RaidCancelTimerResumeUnit(
	IN PRAID_UNIT_EXTENSION Unit
	);

VOID
RaidUnitBusy(
    IN PRAID_UNIT_EXTENSION Unit,
    IN ULONG RequestsToComplete
    );

VOID
RaidUnitReady(
    IN PRAID_UNIT_EXTENSION Unit
    );

NTSTATUS
RaidUnitRegisterInterfaces(
    IN PRAID_UNIT_EXTENSION Unit
    );

NTSTATUS
RaidUnitUnRegisterInterfaces(
    IN PRAID_UNIT_EXTENSION Unit
    );

NTSTATUS
RaUnitSetQueueDepth(
    IN PRAID_UNIT_EXTENSION Unit
    );

VOID
RaidUnitRequestTimeout(
    IN PRAID_UNIT_EXTENSION Unit
    );

NTSTATUS
RaUnitAcquireRemoveLock(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

VOID
RaUnitReleaseRemoveLock(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitWaitForRemoveLock(
	IN PRAID_UNIT_EXTENSION Unit
	);

NTSTATUS
RaUnitAdapterRemove(
    IN PRAID_UNIT_EXTENSION Unit
    );

NTSTATUS
RaUnitAdapterSurpriseRemove(
    IN PRAID_UNIT_EXTENSION Unit
    );

NTSTATUS
RaUnitAllocateResetIoResources(
    IN PRAID_UNIT_EXTENSION Unit,
    OUT PRAID_IO_RESOURCES IoResources
    );

LOGICAL
INLINE
RaUnitIsResetResources(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PRAID_IO_RESOURCES IoResources
	)
{
	if (Unit->ResetResourcesAcquired &&
		IoResources->QueueTag == (UCHAR)Unit->ResetResources.QueueTag) {
		return TRUE;
	}

	return FALSE;
}

VOID
RaidUnitCompleteRequest(
    IN PEXTENDED_REQUEST_BLOCK Xrb
    );

VOID
RaUnitStartResetIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
RaidUnitCompleteResetRequest(
    IN PEXTENDED_REQUEST_BLOCK Xrb
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\unit.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    unit.c

Abstract:

    Implementation of the operations on the logical unit for the RAIDPORT
    driver.

Author:

    Matthew D Hendel (math) 19-Apr-2000

Revision History:

--*/


#include "precomp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RaUnitPnpIrp)
#pragma alloc_text(PAGE, RaUnitStartDeviceIrp)
#pragma alloc_text(PAGE, RaUnitStopDeviceIrp)
#pragma alloc_text(PAGE, RaUnitQueryStopDeviceIrp)
#pragma alloc_text(PAGE, RaUnitCancelStopDeviceIrp)
#pragma alloc_text(PAGE, RaUnitRemoveDeviceIrp)
#pragma alloc_text(PAGE, RaUnitQueryRemoveDeviceIrp)
#pragma alloc_text(PAGE, RaUnitCancelRemoveDeviceIrp)
#pragma alloc_text(PAGE, RaUnitSurpriseRemovalIrp)
#pragma alloc_text(PAGE, RaUnitQueryCapabilitiesIrp)
#pragma alloc_text(PAGE, RaUnitQueryPnpDeviceStateIrp)
#pragma alloc_text(PAGE, RaUnitDeviceUsageNotificationIrp)
#pragma alloc_text(PAGE, RaUnitQueryDeviceRelationsIrp)
#pragma alloc_text(PAGE, RaUnitQueryIdIrp)
#pragma alloc_text(PAGE, RaUnitQueryDeviceTextIrp)
#pragma alloc_text(PAGE, RaUnitIgnorePnpIrp)
#pragma alloc_text(PAGE, RaUnitSucceedPnpIrp)
#pragma alloc_text(PAGE, RaUnitUnknownSrb)
#pragma alloc_text(PAGE, RaUnitDeviceControlIrp)
#pragma alloc_text(PAGE, RaUnitScsiGetAddressIoctl)
#pragma alloc_text(PAGE, RaUnitStorageQueryPropertyIoctl)
#pragma alloc_text(PAGE, RaUnitUnknownIoctl)
#pragma alloc_text(PAGE, RaGetUnitStorageDeviceProperty)
#pragma alloc_text(PAGE, RaGetUnitStorageDeviceIdProperty)


#pragma alloc_text(PAGEVRFY, RaidUnitAllocateSrbExtensionPoolVerify)
#pragma alloc_text(PAGEVRFY, RaidUnitFreeSrbExtensionPoolVerify)
#endif // ALLOC_PRAGMA


//
// Globals
//

//
// Chained IO consolidates the free cycle of IO Request N with the allocation
// cycle of IO Request N+1, thus reducing back-to-back free and allocate
// requests.
//

LOGICAL RaidChainedIo = TRUE;


//
// Routines
//

NTSTATUS
RaidCreateUnit(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    OUT PRAID_UNIT_EXTENSION* UnitBuffer
    )
/*++

Routine Description:

    Create a null raid unit object.

Arguments:

    Adapter -

    UnitBuffer -
    
Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PRAID_UNIT_EXTENSION Unit;
    PDEVICE_OBJECT DeviceObject;

    ASSERT_ADAPTER (Adapter);
    ASSERT (UnitBuffer != NULL);
    
    PAGED_CODE ();


    Status = IoCreateDevice (Adapter->DeviceObject->DriverObject,
                             sizeof (RAID_UNIT_EXTENSION),
                             NULL, // DeviceName,
                             FILE_DEVICE_MASS_STORAGE,
                             (FILE_AUTOGENERATED_DEVICE_NAME |
                              FILE_DEVICE_SECURE_OPEN),
                             FALSE,
                             &DeviceObject);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    Unit = DeviceObject->DeviceExtension;
    RaidZeroUnit (Unit);
    Unit->Adapter = Adapter;
    Unit->DeviceObject = DeviceObject;

    SET_FLAG (DeviceObject->Flags, DO_DIRECT_IO);
    SET_FLAG (DeviceObject->Flags, DO_BUS_ENUMERATED_DEVICE);

    Unit->DeviceObject->AlignmentRequirement =
            Adapter->DeviceObject->AlignmentRequirement;


    //
    // Since the Unit is the child PDO from the adapter, we never
    // get an AddDevice call. Hence, we start in the stopped state.
    //
    
    Unit->DeviceState = DeviceStateNotPresent;

    //
    // Allocate all resources associated with the logical unit.
    //

    Status = RaidUnitAllocateResources (Unit);

    if (!NT_SUCCESS (Status)) {
        REVIEW();
        return Status;
    }

    //
    // The unit queue is locked until we start the device.
    //
    
    RaidLockUnitQueue (Unit);

    *UnitBuffer = Unit;
    
    return STATUS_SUCCESS;
}


VOID
RaidZeroUnit(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Return a logical unit to a NULL status.

Arguments:

    Unit - Logical unit to NULL.

Return Value:

    None.

--*/
{
    RtlZeroMemory (Unit, sizeof (RAID_UNIT_EXTENSION));
    Unit->ObjectType = RaidUnitObject;
    RaCreateTagList (&Unit->TagList);
    RaidCreateRegion (&Unit->SrbExtensionRegion);
    RaCreatePower (&Unit->Power);
    RaSetSystemPowerState (&Unit->Power, PowerSystemWorking);
    RaSetDevicePowerState (&Unit->Power, PowerDeviceD0);
    StorCreateEventQueue (&Unit->PendingQueue);
    Unit->Address = RaidNullAddress;
    Unit->DefaultTimeout = DEFAULT_IO_TIMEOUT;

    RaidInitializeDeferredItem (&Unit->DeferredList.PauseDevice.Header);
    RaidInitializeDeferredItem (&Unit->DeferredList.ResumeDevice.Header);
    RaidInitializeDeferredItem (&Unit->DeferredList.DeviceBusy.Header);
    RaidInitializeDeferredItem (&Unit->DeferredList.DeviceReady.Header);
}



VOID
RaidStartUnit(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Prepare the logical unit to receive IOs.

Arguments:

    Unit - Logical unit to start.

Return Value:

    None.

NOTE: Explain how this differs from the PNP Start IRP.

--*/
{
    NTSTATUS Status;
    
    PAGED_CODE();

    ASSERT_UNIT (Unit);
    ASSERT (Unit->DeviceObject != NULL);

    //
    // Handle any cases where the default queue is not correct.
    //
    
    Status = RaUnitSetQueueDepth(Unit);
    ASSERT (NT_SUCCESS (Status));

    ASSERT (memcmp (&Unit->Address, &RaidNullAddress, sizeof (RaidNullAddress)) != 0);

    //
    // Tell PNP that we're done initializing.
    //
    
    CLEAR_FLAG (Unit->DeviceObject->Flags, DO_DEVICE_INITIALIZING);
}


VOID
RaidDeleteUnit(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    This routine deallocates any resources associated with a RAID Unit
    object, preparing the buffer for reuse. This routine must be called
    for every unit before the unit's memory is deallocated.

Arguments:

    Unit - Unit to be deleted.

Return Value:

    NTSTATUS code.

--*/
{
    PDEVICE_OBJECT DeviceObject;
    NTSTATUS Status;
    DEVICE_STATE DeviceState;
    
    PAGED_CODE ();
    ASSERT_UNIT (Unit);


    Status = RaidUnitFreeResources (Unit);
    ASSERT (NT_SUCCESS (Status));

    //
    // We may get further remove requests to the logical unit after we have
    // called IoDeleteDevice. To handle this case, we keep the device state
    // valid, even though the remainder of the device has been reclaimed.
    // If we get an IRP it is ok to access the device extension even if
    // we have previously called IoDeleteDevice. These spurious remove IRPs
    // may be completed in any manner.
    //
    
    DeviceObject = Unit->DeviceObject;
    DeviceState = Unit->DeviceState;

    DbgFillMemory (Unit,
                   sizeof (RAID_UNIT_EXTENSION),
                   DBG_DEALLOCATED_FILL);
    Unit->DeviceState = DeviceState;
    
    IoDeleteDevice (DeviceObject);
    
}



VOID
RaidUnitAssignAddress(
    IN PRAID_UNIT_EXTENSION Unit,
    IN RAID_ADDRESS Address
    )
/*++

Routine Description:

    Assign a logical unit's RAID (SCSI) Address. Addresses CAN be modified
    dynamically, although the user should be careful that all outstanding
    requests are completed before any attempt is made to modify the
    Address.

Arguments:

    Unit - Supplies the logical unit to assign the SCSI address to.

    Address - Supplies the SCSI address to assign.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    //
    // Verify that there are no outstanding requests on this Unit.
    //

    Unit->Address = Address;
}

VOID
RaidUnitAssignIdentity(
    IN PRAID_UNIT_EXTENSION Unit,
    IN OUT PSTOR_SCSI_IDENTITY Identity
    )
/*++

Routine Description:

    Assign a logical unit's identity. The identity includes the SCSI
    INQUIRY data, plus pages 80 and 80 of the Vital Product Data.

Arguments:

    Unit - Supplies the logical unit whose identity is to be assigned.

    Identity - Supplies a pointer to the identity to be assigned. By
            calling this call, the caller grants ownership of the
            identity data to the logical unit. It must not access this
            buffer after calling this function.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    //
    // Verify that there are no outstanding requests on this Unit.
    //

    RtlCopyMemory (&Unit->Identity, Identity, sizeof (STOR_SCSI_IDENTITY));
    RtlZeroMemory (Identity, sizeof (STOR_SCSI_IDENTITY));
}



NTSTATUS
RaidUnitAllocateResources(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Allocate all resources necessary for a logical unit to function.

Arguments:

    Unit - Supplies the logical unit to allocate resources for.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG NumberOfElements;
    ULONG SrbExtensionSize;
    PVOID SrbExtensionBuffer;
    PHYSICAL_ADDRESS PhysicalAddress;
    LARGE_INTEGER LargeTimeout;
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_IO_RESOURCES ResetResources;
    ULONG ResetTag;

    PAGED_CODE();
    
    Adapter = Unit->Adapter;

    //
    // The remove lock is 1-biased.
    //
    
    Unit->OutstandingCount = 1;
    KeInitializeEvent (&Unit->ZeroOutstandingEvent,
                       SynchronizationEvent,
                       FALSE);

    //
    // If verifier is enabled and configured to allocate common buffer space
    // in separate blocks, call out to the verifier routine to do the
    // allocation.
    //
    
    NumberOfElements = TAG_QUEUE_SIZE + 1;
    
    Status = RaidUnitAllocateSrbExtensionPool (Unit,
                                               &NumberOfElements,
                                               TRUE);
    ASSERT (NT_SUCCESS (Status));

    //
    // Xrb lookaside list.
    //

    ExInitializeNPagedLookasideList (&Unit->XrbList,
                                     NULL,
                                     NULL,
                                     0,
                                     sizeof (EXTENDED_REQUEST_BLOCK),
                                     XRB_TAG,
                                     0);

    RaInitializeTagList (&Unit->TagList,
                         NumberOfElements,
                         Unit->DeviceObject);

    //
    // Initialize the pending queue.
    //
    
    StorInitializeEventQueue (&Unit->PendingQueue);

    KeInitializeDpc (&Unit->PendingDpc,
                     RaidUnitPendingDpcRoutine,
                     Unit->DeviceObject);

    KeInitializeTimer (&Unit->PendingTimer);

    //
    // Initialize the pause timer.
    //

    KeInitializeTimer (&Unit->PauseTimer);

    KeInitializeDpc (&Unit->PauseTimerDpc,
                     RaidUnitPauseTimerDpcRoutine,
                     Unit->DeviceObject);
   
    //
    // Set timer to fire once per second.
    //

    LargeTimeout.QuadPart = 1;
    LargeTimeout.QuadPart *= SECONDS;
    LargeTimeout.QuadPart *= RELATIVE_TIMEOUT;
    
    KeSetTimerEx (&Unit->PendingTimer,
                  LargeTimeout,
                  1 * 1000,             // milli
                  &Unit->PendingDpc);
    
    KeInitializeSpinLock (&Unit->SlowLock);

    //
    // Initialize an IO_QUEUE for the unit object. We initialize the IO queue
    // to NumberOfElements - 1 so that the final element in the queue can
    // be pre-allocate as a reset resource.
    //
    
    RaidInitializeIoQueue (&Unit->IoQueue,
                           Unit->DeviceObject,
                           &Unit->Adapter->Gateway,
                           RaUnitStartIo,
                           NumberOfElements - 1);
    //
    // Create logical unit extension, if necessary.
    //

    if (Adapter->Miniport.PortConfiguration.SpecificLuExtensionSize) {
        ULONG Size;

        Size = Adapter->Miniport.PortConfiguration.SpecificLuExtensionSize;
        Unit->UnitExtension = RaidAllocatePool (NonPagedPool,
                                                Size,
                                                UNIT_EXT_TAG,
                                                Unit->DeviceObject);
                                                
        if (Unit->UnitExtension == NULL) {
            return STATUS_NO_MEMORY;
        }

        RtlZeroMemory (Unit->UnitExtension, Size);
    }


    //
    // Pre-allocate reset resources.
    //

    ResetTag = NumberOfElements - 1;
    ResetTag = RaAllocateSpecificTag (&Unit->TagList, ResetTag);
    ASSERT (ResetTag);

    ResetResources = &Unit->ResetResources;
    ResetResources->QueueTag = ResetTag;
    ResetResources->SrbExtension = RaidAllocateSrbExtension (
                                        &Unit->SrbExtensionPool,
                                        ResetTag);
    ResetResources->Xrb = RaidAllocateXrb (&Unit->XrbList,
                                           Unit->DeviceObject);
    ASSERT (ResetResources->Xrb != NULL);

    return STATUS_SUCCESS;
}


NTSTATUS
RaidUnitAllocateSrbExtensionPool(
    IN PRAID_UNIT_EXTENSION Unit,
    IN OUT PULONG NumberOfElements,
    IN BOOLEAN AcceptLowerCount
    )
/*++

Routine Description:

    Allocate memory for the SRB extension region.

Arguments:

    Unit - Supplies logical unit to allocate memory for.

    NumberOfElements - Supplies the number of elements requested for this
        logical unit. On success, returns the number of elements actually
        allocated.

    AcceptLowerCount - If TRUE, we will accept a lower count of SRB
        extension elements than requested in NumberOfElements. Otherwise,
        we will fail if we were not able to allocate the requested
        number of elements.

Return Value:

    NTSTATUS code.

--*/
{
    ULONG Count;
    ULONG SrbExtensionSize;
    ULONG BufferSize;
    NTSTATUS Status;
    PRAID_ADAPTER_PARAMETERS Parameters;


    PAGED_CODE();

    SrbExtensionSize = RaGetSrbExtensionSize (Unit->Adapter);
    Count = *NumberOfElements;

    //
    // Loop retrying the allocation on lower and lower sizes until we
    // find a size that works.
    //
    // NB: There is a better way to do this. Instead of lowering the count
    // we break the region into smaller sizes. Another way of doing this
    // is to allocate the srb extension pool on the HBA instead of the
    // unit, sharing the SrbExtension Pool. This makes a number of things
    // more difficult.
    //
    
    do {

        //
        // Srb extension pool.
        //
        
        BufferSize = Count * SrbExtensionSize;
        Status = RaidDmaAllocateCommonBuffer (&Unit->Adapter->Dma,
                                              BufferSize,
                                              &Unit->SrbExtensionRegion);

        //
        // Failed the first allocation attempt: try a lower value.
        //
        
        if (Status == STATUS_NO_MEMORY ||
            Status == STATUS_INSUFFICIENT_RESOURCES) {
            Count /= 2;
        }

    } while (AcceptLowerCount &&
             Status == STATUS_NO_MEMORY &&
             Count > 0);

    if (!NT_SUCCESS (Status)) {
        return STATUS_NO_MEMORY;
    }

    RaidInitializeFixedPool (&Unit->SrbExtensionPool,
                             RaidRegionGetVirtualBase (&Unit->SrbExtensionRegion),
                             Count,
                             SrbExtensionSize);

    *NumberOfElements = Count;

    return STATUS_SUCCESS;
}


NTSTATUS
RaidUnitAllocateSrbExtensionPoolVerify(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PULONG NumberOfElements,
    IN LOGICAL AcceptLowerCount
    )
/*++

Routine Description:

    Allocate all resources necessary for a logical unit to function.

Arguments:

    Unit - Supplies the logical unit to allocate resources for.

Return Value:

    NTSTATUS code.

Notes:

    This function is for use by the driver verifier.

    This function needs to be rewritten.

--*/
{
    NTSTATUS Status;
    ULONG BlockSize;
    ULONG i;
    ULONG Length;
    PALLOCATE_COMMON_BUFFER AllocateCommonBuffer;
    IN PRAID_DMA_ADAPTER Dma;
    PVOID Buffer = NULL;
    PRAID_MEMORY_REGION BlkAddr;
    PRAID_FIXED_POOL Pool;
    PVOID *SrbExtension = NULL;
    PHYSICAL_ADDRESS PhysicalAddress;
    PRAID_ADAPTER_EXTENSION Adapter;
    ULONG Count;

    TEXT_SECTION (PAGEVRFY);
    
    Adapter = Unit->Adapter;
    Count = *NumberOfElements;
    ASSERT (Count != 0);
        
    
    //
    // We maintain an array in order to find our common buffer
    // blocks at various times.  
    //

    Length = sizeof(RAID_MEMORY_REGION) * Count;

    BlkAddr = RaidAllocatePool (NonPagedPool,
                                Length,
                                SRB_EXTENSION_TAG,
                                Unit->DeviceObject);

    if (BlkAddr == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory (BlkAddr, Length);

    Unit->CommonBufferVAs = BlkAddr;
    Unit->CommonBufferBlocks = Count;

    //
    // Calculate the block size for a SRB extension block.
    //

    BlockSize = (ULONG)ROUND_TO_PAGES(RaGetSrbExtensionSize (Adapter));

    //
    // Add a page for holding bookkeeping information.
    //

    BlockSize += PAGE_SIZE;

    Unit->CommonBufferSize = BlockSize;

    //
    // Allocate each block individually and link them all together into
    // a list.  If we fail to allocate any of the blocks, we clean everything
    // up and return failure.
    //

    Dma = &Unit->Adapter->Dma; 
    ASSERT (Dma != NULL);
    ASSERT (Dma->DmaAdapter->DmaOperations->AllocateCommonBuffer != NULL);

    for (i = 0; i < Count; i++) {

        Buffer = Dma->DmaAdapter->DmaOperations->AllocateCommonBuffer(
                        Dma->DmaAdapter,
                        BlockSize,
                        &PhysicalAddress,
                        FALSE);

        if (Buffer == NULL) {
            break;
        }

        RtlZeroMemory (Buffer, BlockSize);

        //
        // Initialize the region with the proper information.
        //

        RaidInitializeRegion ((BlkAddr + i),
                              Buffer,
                              PhysicalAddress,
                              BlockSize);

        
        //
        // Link the new block onto the front of the chain.
        //

        *((PVOID *)Buffer) = SrbExtension;
        SrbExtension = (PVOID *)Buffer;
    }

    if (!AcceptLowerCount && i < Count) {
        RaidFreePool (Unit->CommonBufferVAs, SRB_EXTENSION_TAG);
        Unit->CommonBufferVAs = NULL;
        Unit->CommonBufferBlocks = 0;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Reset this to the actual count.
    //

    Count = i;
    Unit->CommonBufferBlocks = Count;
        
        

    ASSERT (Buffer != NULL);

    Pool = &Unit->SrbExtensionPool;

    Pool->Buffer = (PUCHAR)SrbExtension;
    Pool->NumberOfElements = Count;
    Pool->SizeOfElement = BlockSize;


    //
    // Create a second VA mapping of the common buffer area so we can make the 
    // range of addresses invalid when the miniport is not supposed to touch
    // it. This will allow us to catch misbehaving miniports.
    //

    RaidRemapCommonBufferForMiniport (Unit);

    return STATUS_SUCCESS;

}


VOID
RaidUnitFreeSrbExtensionPoolVerify(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Release all resources associated with a logical unit.

Arguments:

    Unit - Supplies the logical unit to release resources for.

Return Value:

    NTSTATUS code.

--*/
{
    ULONG i;
    PSP_VA_MAPPING_INFO MappingInfo;
    PRAID_MEMORY_REGION BlkAddr = Unit->CommonBufferVAs;

    TEXT_SECTION (PAGEVRFY);
    
    for (i = 0; i < Unit->CommonBufferBlocks; i++) {

        //
        // If there is a second VA range for the common block, free the
        // MDL(s).
        //

        MappingInfo = GET_VA_MAPPING_INFO(Unit, BlkAddr[i].VirtualBase);

        if (MappingInfo->SrbExtMdl != NULL) {
            MmProtectMdlSystemAddress(MappingInfo->SrbExtMdl, PAGE_READWRITE);
            MmUnlockPages(MappingInfo->SrbExtMdl);
            IoFreeMdl(MappingInfo->SrbExtMdl);
        }

        //
        // Free the memory.
        //


        RaidDmaFreeCommonBuffer (&Unit->Adapter->Dma,
                                (BlkAddr + i));
        RaidDeleteFixedPool (&Unit->SrbExtensionPool);
    }
}


NTSTATUS
RaidUnitFreeResources(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Release all resources associated with a logical unit.

Arguments:

    Unit - Supplies the logical unit to release resources for.

Return Value:

    NTSTATUS code.

--*/
{
    PVOID Buffer;

    PAGED_CODE();
    
    //
    // Free the XRB lookaside list.
    //

    if (Unit->XrbList.L.Size != 0) {
        ExDeleteNPagedLookasideList (&Unit->XrbList);
    }

    //
    // Free the SRB extension region and pool, if necessary.
    //
    
    if (StorIsVerifierEnabled ()) {
    
        RaidUnitFreeSrbExtensionPoolVerify (Unit);
        
    } else {

        if (RaidIsRegionInitialized (&Unit->SrbExtensionRegion)) {
            
            RaidDmaFreeCommonBuffer (&Unit->Adapter->Dma,
                                     &Unit->SrbExtensionRegion);
            RaidDeleteFixedPool (&Unit->SrbExtensionPool);

        }
    }

    StorDeleteEventQueue (&Unit->PendingQueue);
    StorDeleteScsiIdentity (&Unit->Identity);
    RaDeleteTagList (&Unit->TagList);

    if (Unit->UnitExtension != NULL) {
        RaidFreePool (Unit->UnitExtension, UNIT_EXT_TAG);
        Unit->UnitExtension = NULL;
    }

    //
    // Deregister with WMI if we are registered.
    //

    if (Unit->Flags.WmiInitialized == TRUE) {
        IoWMIRegistrationControl(Unit->DeviceObject, WMIREG_ACTION_DEREGISTER);
        Unit->Flags.WmiInitialized = FALSE;
    }

    KeCancelTimer (&Unit->PendingTimer);
    KeCancelTimer (&Unit->PauseTimer);

//    StorDeleteEventQueue (&Unit->PendingQueue);

    return STATUS_SUCCESS;
}



//
// Handler functions.
//

NTSTATUS
RaUnitCreateIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    PAGED_CODE ();

    return RaidHandleCreateCloseIrp (Unit->DeviceState, Irp);
}

NTSTATUS
RaUnitCloseIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    PAGED_CODE ();

    return RaidHandleCreateCloseIrp (Unit->DeviceState, Irp);
}

BOOLEAN
RaUnitAllowPnpRequest(
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine determines whether to allow the request to be processed 
    when the Unit is being removed.

Arguments:

    Irp - Pnp irp to handle.

Return Value:

    TRUE - If the request should be allowed through.

--*/
{
    ULONG minorFunction;

    //
    // Ensure this is a PnP Irp.
    //
    ASSERT (RaidMajorFunctionFromIrp (Irp) == IRP_MJ_PNP);
    
     //
     // Extract the IRP_MN_XXX from the Irp.
     //
     minorFunction = RaidMinorFunctionFromIrp(Irp);
     
     //
     // If the request has anything to do with removes, let it through.
     //
     if ((minorFunction == IRP_MN_REMOVE_DEVICE) ||
         (minorFunction == IRP_MN_CANCEL_REMOVE_DEVICE) ||
         (minorFunction == IRP_MN_SURPRISE_REMOVAL)) {
   
         return TRUE;
     }
     return FALSE;
}

NTSTATUS
RaUnitPnpIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    This is the PnP dispatch routine for the Raid Unit object.  It's
    purpose it to forward the irp on to sub-dispatch routines for the
    specific irp.

Arguments:

    Unit - The unit object this irp is for.

    Irp - Pnp irp to handle.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG Minor;
    BOOLEAN RemlockHeld;
    
    PAGED_CODE ();
    ASSERT (RaidMajorFunctionFromIrp (Irp) == IRP_MJ_PNP);

    Status = RaUnitAcquireRemoveLock (Unit, Irp);

    if (!NT_SUCCESS (Status)) {
        Irp->IoStatus.Information = 0;
        return RaidCompleteRequest (Irp, Status);
    } 

    RemlockHeld = TRUE;
    Minor = RaidMinorFunctionFromIrp (Irp);

    DebugPnp (("Unit %p, Irp %p, Pnp, Minor %x\n",
                 Unit,
                 Irp,
                 Minor));

    //
    // Dispatch the IRP to one of our handlers.
    //

    switch (Minor) {

        case IRP_MN_START_DEVICE:
            Status = RaUnitStartDeviceIrp (Unit, Irp);
            break;
        
        case IRP_MN_STOP_DEVICE:
            Status = RaUnitStopDeviceIrp (Unit, Irp);
            break;

        case IRP_MN_QUERY_STOP_DEVICE:
            Status = RaUnitQueryStopDeviceIrp (Unit, Irp);
            break;
            
        case IRP_MN_CANCEL_STOP_DEVICE:
            Status = RaUnitCancelStopDeviceIrp (Unit, Irp);
            break;

        case IRP_MN_REMOVE_DEVICE:
            Status = RaUnitRemoveDeviceIrp (Unit, Irp);
            RemlockHeld = FALSE;
            break;
            
        case IRP_MN_QUERY_REMOVE_DEVICE:
            Status = RaUnitQueryRemoveDeviceIrp (Unit, Irp);
            break;
            
        case IRP_MN_CANCEL_REMOVE_DEVICE:
            Status = RaUnitCancelRemoveDeviceIrp (Unit, Irp);
            break;

        case IRP_MN_SURPRISE_REMOVAL:
            Status = RaUnitSurpriseRemovalIrp (Unit, Irp);
            RemlockHeld = FALSE;
            break;
            
        case IRP_MN_QUERY_CAPABILITIES:
            Status = RaUnitQueryCapabilitiesIrp (Unit, Irp);
            break;

        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            Status = RaUnitQueryPnpDeviceStateIrp (Unit, Irp);
            break;

        case IRP_MN_DEVICE_USAGE_NOTIFICATION:
            Status = RaUnitDeviceUsageNotificationIrp (Unit, Irp);
            break;
            
        case IRP_MN_QUERY_DEVICE_RELATIONS:
            Status = RaUnitQueryDeviceRelationsIrp (Unit, Irp);
            break;

        case IRP_MN_QUERY_ID:
            Status = RaUnitQueryIdIrp (Unit, Irp);
            break;

        case IRP_MN_QUERY_DEVICE_TEXT:
            Status = RaUnitQueryDeviceTextIrp (Unit, Irp);
            break;

        case IRP_MN_QUERY_RESOURCES:
        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
            Status = RaUnitSucceedPnpIrp(Unit, Irp);
            break;

        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
        case IRP_MN_QUERY_BUS_INFORMATION:
        case IRP_MN_QUERY_INTERFACE:
        case IRP_MN_READ_CONFIG:
        case IRP_MN_WRITE_CONFIG:
        case IRP_MN_EJECT:
        case IRP_MN_SET_LOCK:
        default:
            Status = RaUnitIgnorePnpIrp (Unit, Irp);
            break;
    }

    DebugPnp (("Unit %p, Irp %p, Pnp Minor %x, ret = %08x\n",
                 Unit,
                 Irp,
                 Minor,
                 Status));

    if (RemlockHeld) {
        RaUnitReleaseRemoveLock (Unit, Irp);
    }

    return Status;
}


NTSTATUS
RaUnitSetQueueDepth(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    This routine will set the Depth of the IoQueue (and indirectly the ExQueue
    behind it) based on whatever characteristics of Unit that make it such
    that the queue depth should be changed.

    Currently, only tape devices are handled.

Arguments:

    Unit - The device to examine and update it's queue, if applicable. 

Return Value:

    SUCCESS - if the queue was unchanged, or it was updated correctly.

    UNSUCCESSFUL - if an error occurred while updating the queue depth.

--*/
{
    ULONG intendedDepth;
    ULONG depth;
    NTSTATUS status = STATUS_UNSUCCESSFUL;

    //
    // The only check for now is whether this is a tape device or not. Others
    // may need to be applied.
    // 

    if (Unit->Identity.InquiryData->DeviceType == SEQUENTIAL_ACCESS_DEVICE) { 

        //
        // Set the Q-Depth to 1, as when a Check Condition occurs any other
        // requests out on the device will be resumed, once the CA is cleared.
        // This can lead to a state where the backup app. gets very confused about
        // the device's position.
        //
        intendedDepth = 1;

        //
        // Set the unit's max depth value, so that the unit can disallow
        // any requests to exceed it. 
        //
        Unit->MaxQueueDepth = 1;

    } else {

        //
        // Start off with a value well below max. This should be realistic for most
        // LUNs.
        // 
        intendedDepth = 20;
        
        //
        // Set the unit's max depth value, so that the unit can disallow
        // any requests to up the depth past the max.
        //
        Unit->MaxQueueDepth = TAG_QUEUE_SIZE;
    }

    //
    // Set the depth.
    // 
    depth = RaidSetIoQueueDepth(&Unit->IoQueue,
                                intendedDepth);


    if (intendedDepth == depth) {

        //
        // Either the depth was successfully set, or no changes were made.
        //
        status = STATUS_SUCCESS;
    }

    return status;
}    

NTSTATUS
RaUnitStartDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler function for the unit stop device pnp irp.

Arguments:

    Unit - Unit to start.

    Irp - Start device irp.

Return Value:

    NTSTATUS code.

--*/

{
    NTSTATUS Status;
    DEVICE_STATE PriorState;
    
    PAGED_CODE ();

    //
    // Initialize WMI for the Device.
    //
    
    RaUnitInitializeWMI (Unit);

    //
    // Register the DeviceMap entry.
    //
    
    RaidUnitRegisterInterfaces (Unit);

    //
    // Unlock the unit queue.
    //
    
    if (RaidIsUnitQueueLocked (Unit)) {
        RaidUnlockUnitQueue (Unit);
    }

    PriorState = StorSetDeviceState (&Unit->DeviceState, DeviceStateWorking);
    ASSERT (PriorState == DeviceStateStopped ||
            PriorState == DeviceStateDisabled);

    return RaidCompleteRequest (Irp, STATUS_SUCCESS);
}

NTSTATUS
RaidUnitRegisterInterfaces(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Registers any device interfaces associated with the logical unit.
    
Arguments:

    Unit - Logical unit.

Return Value:

    NTSTATUS code.

--*/
{
    HANDLE BusKey;
    HANDLE TargetKey;
    NTSTATUS Status;
    RAID_ADDRESS Address;
    PSTOR_SCSI_IDENTITY Identity;
    PVPD_IDENTIFICATION_PAGE DeviceId;
    ULONG DeviceIdLength;

    ASSERT_UNIT (Unit);
    
    PAGED_CODE();

    //
    // The only interface we support for the LUN is the DeviceMap.
    //
    
    Address = Unit->Address;
    BusKey = RaidAdapterGetBusKey (Unit->Adapter, Address.PathId);

    //
    // Build the target entry.
    //
    
    Status = PortMapBuildTargetEntry (BusKey,
                                      Address.TargetId,
                                      &TargetKey);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // Build the LUN entry.
    //

    Identity = &Unit->Identity;
    DeviceId = Identity->DeviceId;
    if (DeviceId) {
        DeviceIdLength = min (DeviceId->PageLength,
                              sizeof (VPD_IDENTIFICATION_PAGE));
    } else {
        DeviceIdLength = 0;
    }
    
    PortMapBuildLunEntry (TargetKey,
                          Address.Lun,
                          Identity->InquiryData,
                          &Identity->SerialNumber,
                          DeviceId,
                          DeviceIdLength,
                          NULL);

    ZwClose (TargetKey);

    return STATUS_SUCCESS;
}

NTSTATUS
RaidUnitUnRegisterInterfaces(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Unregister any interfaces registered through RaidUnitRegisterInterfaces.
    At this time the DeviceMap interface is the only one we support.

Arguments:

    Unit - Logical unit to unregister interfaces for.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG PortNumber;
    RAID_ADDRESS Address;

    PAGED_CODE();

    Address = Unit->Address;
    PortNumber = Unit->Adapter->PortNumber;

    Status = PortMapDeleteLunEntry (PortNumber,
                                    Address.PathId,
                                    Address.TargetId,
                                    Address.Lun);
    return Status;
}
    

NTSTATUS
RaUnitStopDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler function for the unit stop device pnp irp.

Arguments:

    Unit - Unit to stop.

    Irp - Stop device irp.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    DEVICE_STATE PriorState;
    
    PAGED_CODE ();

    PriorState = StorSetDeviceState (&Unit->DeviceState, DeviceStateStopped);
    ASSERT (PriorState == DeviceStatePendingStop);

    RaidLockUnitQueue (Unit);

    return RaidCompleteRequest (Irp, STATUS_SUCCESS);



}

NTSTATUS
RaUnitQueryStopDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler function for the unit query stop device irp.

Arguments:

    Unit - Unit to query for stop.

    Irp - Query stop device irp.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    DEVICE_STATE PriorState;
    
    PAGED_CODE ();

    //
    // NB: Even if we fail this IRP, we must still enter the PendingStop
    // state because the PnP manager will send us cancel stop after this.
    //
    
    PriorState = StorSetDeviceState (&Unit->DeviceState, DeviceStatePendingStop);
    ASSERT (PriorState == DeviceStateWorking);
    
    if (Unit->PagingPathCount == 0) {
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_DEVICE_BUSY;
    }
    
    return RaidCompleteRequest (Irp,  Status);
}


NTSTATUS
RaUnitCancelStopDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler function for unit cancel stop device irp.

Arguments:

    Unit - Unit to cancel stop for.

    Irp - Cancel stop device irp.

Return Value:

    NTSTATUS code.

--*/
{
    DEVICE_STATE PriorState;
    
    PAGED_CODE ();

    PriorState = StorSetDeviceState (&Unit->DeviceState, DeviceStateWorking);

    //
    // We can receive a cancel stop without having ever receiving a
    // pending stop. This is ok, either way we want to go back to
    // working state.
    //
    
    ASSERT (PriorState == DeviceStatePendingStop ||
            PriorState == DeviceStateWorking);

    return RaidCompleteRequest (Irp,  STATUS_SUCCESS);
}

NTSTATUS
RaUnitRemoveDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler function for the unit remove device irp.

Arguments:

    Unit - Unit to remove.

    Irp - Remove irp.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    
    PAGED_CODE();

    DebugPnp (("Unit %p, Irp %p, Pnp, Minor: Remove\n",
                  Unit, Irp));

    //
    // According to the DDK it's possible to receive a PNP remove after
    // have already called IoDeleteDevice. In this case, we may complete
    // the additional remove IRP with any status we choose.
    //
    
    if (Unit->DeviceState == DeviceStateDeleted) {
        REVIEW();
        DebugPnp (("Unit %p, Irp %p, Pnp, Minor: Remove - completing IRP in deleted state STATUS_NO_SUCH_DEVICE\n",
                     Unit, Irp));
        return RaidCompleteRequest (Irp, STATUS_NO_SUCH_DEVICE);
    }
    
    if (Unit->Flags.Present) {
        Status = RaUnitDisableDeviceIrp (Unit, Irp);
    } else {
        Status = RaUnitDeleteDeviceIrp (Unit, Irp);
    }

    DebugPnp (("Unit %p, Irp %p, Pnp, Minor: Remove, ret = %08x\n",
                 Unit, Irp, Status));

    return Status;
}

NTSTATUS
RaUnitDisableDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler for an IRP_MN_REMOVE PNP IRP when the IRP is a disable request.
    This is the case when:

     1) We receive a remove and we're in pending remove state.

     2) The device was reported in the last QDR.

     3) The parent FDO was not surprise removed.

    In this case we move to the "disabled" state where requests are failed,
    but resources are not yet deleted. When we get the final request for
    removal, we will delete resources.

    NB: There is not an explicit state for "disabled" in the PNP state machine;
    it must be determined by the PDO itself that we're disabled vs. actually
    removed.

Arguments:

    Unit - Logical unit to be disabled.

    Irp - Irp representing the IRP_MN_REMOVE irp.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    DEVICE_STATE PriorState;
    
    PAGED_CODE();

    ASSERT (RaidMajorFunctionFromIrp (Irp) == IRP_MJ_PNP);
    ASSERT (RaidMinorFunctionFromIrp (Irp) == IRP_MN_REMOVE_DEVICE);
    
    PriorState = StorSetDeviceState (&Unit->DeviceState, DeviceStateDisabled);

    //
    // If there was a claim on this device, there is no more.
    //

    Unit->Flags.DeviceClaimed = FALSE;

    RaUnitReleaseRemoveLock (Unit, Irp);

    Status = RaUnitWaitForRemoveLock (Unit);
    ASSERT (Status == STATUS_SUCCESS);
    

    return RaidCompleteRequest (Irp, Status);
}

NTSTATUS
RaUnitDeleteDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler for IRP_MN_REMOVE_IRP pnp IRP when the irp is a delete request.
    This is the case when it is not a disable IRP (see above).

    This routine will get called in two distinct cases:

     1) child first

     2) parent surprised removed. In this case the child has already been
        removed from the adapter's list and the Adapter field of the Unit
        will be NULL.

Arguments:

    Unit - Logical unit to be deleted.

    Irp - Irp representing the IRP_MN_REMOVE Irp.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    DEVICE_STATE PriorState;
    
    PAGED_CODE();

    ASSERT (RaidMajorFunctionFromIrp (Irp) == IRP_MJ_PNP);
    ASSERT (RaidMinorFunctionFromIrp (Irp) == IRP_MN_REMOVE_DEVICE);

    PriorState = StorSetDeviceState (&Unit->DeviceState, DeviceStateDeleted);

    RaUnitReleaseRemoveLock (Unit, Irp);

    Status = RaUnitWaitForRemoveLock (Unit);
    ASSERT (Status == STATUS_SUCCESS);

    //
    // The Adapter will be NULL when this is a remove IRP following an adapter
    // surprise remove. Otherwise, this will be non-NULL.
    //
        
    if (Unit->Adapter != NULL) {
        RaidAdapterRemoveUnit (Unit->Adapter, Unit);
    } else {

        //
        // Following adapter surprise remove.
        //
        
        REVIEW();
    }

    RaidDeleteUnit (Unit);

    return RaidCompleteRequest (Irp, Status);
}

NTSTATUS
RaUnitQueryRemoveDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler function for the unit query remove device irp.

Arguments:

    Unit - Unit to query remove for.

    Irp - Query remove irp.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    DEVICE_STATE PriorState;

    PAGED_CODE ();

    if (Unit->PagingPathCount != 0 ||
        Unit->HiberPathCount  != 0 ||
        Unit->CrashDumpPathCount != 0) {

        Status = STATUS_DEVICE_BUSY;

    } else {
        
        PriorState = StorSetDeviceState (&Unit->DeviceState,
                                         DeviceStatePendingRemove);
        ASSERT (PriorState == DeviceStateWorking ||
                PriorState == DeviceStateStopped ||
                PriorState == DeviceStateDisabled);
        Status = STATUS_SUCCESS;
    }

    return RaidCompleteRequest (Irp,  Status);
}


NTSTATUS
RaUnitAdapterRemove(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    This routine is called by the adapter when it receives it's remove
    IRP. In this case, the logical unit needs to go through it's delete
    procedure, since it will not receive another chance to delete itself.

    NB: If the lun is surprise-removed, then it will receive a final remove
    IRP, so it must do nothing here.

Arguments:

    Unit - Unit whose adapter is being removed.

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    DEVICE_STATE PriorState;
    
    PAGED_CODE();

    //
    // If the unit has received a surprise remove IRP, it should not delete
    // itself when the adapter is removed. Instead it should wait until
    // it receives it's final remove IRP.
    //
    
    if (Unit->DeviceState == DeviceStateSurpriseRemoval) {
        REVIEW();
        return STATUS_SUCCESS;
    }

    PriorState = StorSetDeviceState (&Unit->DeviceState, DeviceStateDeleted);
    ASSERT (PriorState == DeviceStateDisabled);

    Status = RaUnitWaitForRemoveLock (Unit);
    ASSERT (Status == STATUS_SUCCESS);

    RaidDeleteUnit (Unit);

    return STATUS_SUCCESS;
}

NTSTATUS
RaUnitAdapterSurpriseRemove(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    This routine is called by the adapter when it receives it's surprise
    remove IRP. In this case, the logical unit must prepare to be actually
    removed when it receives the next remove IRP. It does this by clearing
    its Present bit (called Missing or ReportedMissing in other drivers) so
    that it gets deleted on the next remove IRP.

Arguments:

    Unit - Logical unit whose parent received the surprise remove IRP.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    //
    // We should not get this if we are in the deleted state.
    //
    
    ASSERT (Unit->DeviceState != DeviceStateDeleted);

    //
    // When the parent is surprised removed, we mark the child as
    // not present so that when we receive the child's remove IRP
    // we will interpret it as a delete request.
    //
    
    Unit->Flags.Present = FALSE;

    //
    // NOTE: is it possible for a logical unit to get a remove IRP after a
    // parent has been removed. Therefore, we NULL out the adapter field
    // of the logical unit here, so that when we get the child's remove
    // IRP we will not attempt to access the parent.
    //
    
    Unit->Adapter = NULL;

    //
    // This entry must have been removed from the unit list before calling
    // the surprise remove function.
    //
    
    ASSERT (Unit->NextUnit.Flink == &Unit->NextUnit &&
            Unit->NextUnit.Blink == &Unit->NextUnit);

    ASSERT (Unit->UnitTableLink.Flink == &Unit->UnitTableLink &&
            Unit->UnitTableLink.Blink == &Unit->UnitTableLink);

    return STATUS_SUCCESS;
}
    

NTSTATUS
RaUnitCancelRemoveDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler function for the unit remove device irp.

Arguments:

    Unit - Unit to cancel remove device for.

    Irp - Cancel remove device irp.

Return Value:

    NTSTATUS code.

--*/
{
    DEVICE_STATE PriorState;
    
    PAGED_CODE ();

    PriorState = StorSetDeviceState (&Unit->DeviceState, DeviceStateWorking);

    ASSERT (PriorState == DeviceStatePendingRemove ||
            PriorState == DeviceStateWorking);
            
    return RaidCompleteRequest (Irp,  STATUS_SUCCESS);
}


NTSTATUS
RaUnitSurpriseRemovalIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler function for the unit surprise removal irp.

Arguments:

    Unit - Unit to surprise remove.

    Irp - Surprise removal irp.

Return Value:

    NTSTATUS code

--*/
{
    NTSTATUS Status;

    PAGED_CODE ();

    //
    // Need to review this path.
    //
    
    StorSetDeviceState (&Unit->DeviceState, DeviceStateSurpriseRemoval);

    //
    // The unit must have been marked as not present if we are being surprise
    // removed.
    //
    
    ASSERT (Unit->Flags.Present == FALSE);

    //
    // Release the reference acquired as a part of entry into dispatch routine.
    //
    
    RaUnitReleaseRemoveLock (Unit, Irp);
    
    //
    // Next, wait for any outstanding requests to be completed.
    //

    Status = RaUnitWaitForRemoveLock (Unit);
    ASSERT (Status == STATUS_SUCCESS);
    
    return RaidCompleteRequest (Irp,  STATUS_SUCCESS);
}
    

NTSTATUS
RaUnitQueryCapabilitiesIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler routine for the query capabilities PnP irp on the unit object.

Arguments:

    Unit - Unit to query.

    Irp - Query capabilities irp to handle.

Return Value:

    NTSTATUS code.

--*/
{
    PDEVICE_CAPABILITIES Capabilities;
    PCSCSI_DEVICE_TYPE DeviceType;
    PIO_STACK_LOCATION IrpStack;
    
    PAGED_CODE ();
    ASSERT_UNIT (Unit);

    //
    // Setup parameters
    //
    
    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    Capabilities = IrpStack->Parameters.DeviceCapabilities.Capabilities;

    Capabilities->RawDeviceOK = 1;
    DeviceType = StorGetIdentityDeviceType (&Unit->Identity);

    //
    // Storage devices install silently.
    //
    
    if (DeviceType->IsStorage) {
        Capabilities->SilentInstall = TRUE;
    }

    Capabilities->Address = StorGetAddressTargetId (Unit->Address);

    return RaidCompleteRequest (Irp,  STATUS_SUCCESS);
}



NTSTATUS
RaUnitQueryPnpDeviceStateIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle the query device state irp for the logical unit.

Arguments:

    Unit - Unit to handle this irp.

    Irp - Query device state irp to handle.

Return Value:

    NTSTATUS code.

--*/
{
    PPNP_DEVICE_STATE DeviceState;

    PAGED_CODE ();
    ASSERT_UNIT (Unit);

    //
    // Obtain the address for the PNP device state buffer, and update
    // the state.
    //
    
    DeviceState = (PPNP_DEVICE_STATE)&Irp->IoStatus.Information;

    //
    // If the logical unit is on the paging path, tell PNP we can't disable it.
    //
    
    if (Unit->PagingPathCount) {
        SET_FLAG (*DeviceState, PNP_DEVICE_NOT_DISABLEABLE);
    }

    return RaidCompleteRequest (Irp,  STATUS_SUCCESS);
}



NTSTATUS
RaUnitDeviceUsageNotificationIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP MasterIrp
    )
/*++

Routine Description:

    Handle the PnP device usage notification irp.

Arguments:

    Unit - Unit the irp is for.

    MasterIrp - Device usage irp to handle.

Return Value:

    NTSTATUS code.

Comments:

    Look at how pci.sys does this -- it's much cleaner.

--*/
{
    NTSTATUS Status;
    PIO_STACK_LOCATION MasterIrpStack;
    PIRP DependentIrp;
    PIO_STACK_LOCATION DependentIrpStack;
    PRAID_ADAPTER_EXTENSION Adapter;
    
    PAGED_CODE ();
    ASSERT_UNIT (Unit);

    Adapter = Unit->Adapter;
    MasterIrpStack = IoGetCurrentIrpStackLocation (MasterIrp);

    DependentIrp = IoAllocateIrp (Adapter->DeviceObject->StackSize + 3, FALSE);

    if (DependentIrp == NULL) {
        Status = STATUS_NO_MEMORY;
        goto done;
    }

    //
    // Setup the top level stack location for PNP, DeviceUsageNotification.
    //
    
    DependentIrpStack = IoGetNextIrpStackLocation (DependentIrp);

    //
    // Acquire a remove lock for the dependent IRP.
    //
    
    RaUnitAcquireRemoveLock (Unit, DependentIrp);

    //
    // Setup the dependent IRP.
    //
    
    DependentIrp->Tail.Overlay.Thread = MasterIrp->Tail.Overlay.Thread;
    DependentIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    DependentIrpStack = IoGetNextIrpStackLocation (DependentIrp);
    RtlCopyMemory (DependentIrpStack,
                   MasterIrpStack,
                   sizeof (IO_STACK_LOCATION));

    //
    // We're pending because we're not completing immediately.
    //
    
    IoMarkIrpPending (MasterIrp);
    Status = STATUS_PENDING;

    IoSetCompletionRoutine (DependentIrp,
                            RaUnitDeviceUsageNotificationCompletion,
                            MasterIrp,
                            TRUE,
                            TRUE,
                            TRUE);


    //
    // Pass this down to the Adapter (FDO).
    //
    
    IoCallDriver (Adapter->DeviceObject, DependentIrp);

done:

    return Status;
}


NTSTATUS
RaUnitDeviceUsageNotificationCompletion(
    IN PDEVICE_OBJECT DeviceObject_Do_Not_Use,
    IN PIRP DependentIrp,
    IN PVOID Context
    )
/*++

Routine Description:


Arguments:

    DeviceObject - Do not use. This is often NULL (!?).

    DependentIrp -

    Context - MasterIrp

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PIRP MasterIrp;
    PRAID_UNIT_EXTENSION Unit;
    PULONG UsageCount;
    BOOLEAN Increment;
    PIO_STACK_LOCATION IrpStack;
    DEVICE_USAGE_NOTIFICATION_TYPE UsageType;

    //
    // Initialize variables.
    //

    MasterIrp = (PIRP)Context;
    ASSERT (MasterIrp->Type == IO_TYPE_IRP);

    IrpStack = IoGetCurrentIrpStackLocation (MasterIrp);
    Unit = GetUnit (IrpStack->DeviceObject);
    UsageType = IrpStack->Parameters.UsageNotification.Type;
    Increment = IrpStack->Parameters.UsageNotification.InPath;

    
    //
    // If the dependent IRP failed, also fail the master IRP.
    //
    
    if (!NT_SUCCESS (DependentIrp->IoStatus.Status)) {
        Status = DependentIrp->IoStatus.Status;
        goto done;
    }

    //
    // The dependent IRP succeeded, update the master device's path counts,
    // and succeed the master IRP.
    //
    
    switch (UsageType) {

        case DeviceUsageTypePaging:
            UsageCount = &Unit->PagingPathCount;
            break;

        case DeviceUsageTypeHibernation:
            UsageCount = &Unit->HiberPathCount;
            break;

        case DeviceUsageTypeDumpFile:
            UsageCount = &Unit->CrashDumpPathCount;
            break;

        default:
            Status = STATUS_NOT_SUPPORTED;
            goto done;
    }

    //
    // Adjust the paging path count and update the device state.
    //
    
    IoAdjustPagingPathCount (UsageCount, Increment);
    IoInvalidateDeviceState (Unit->DeviceObject);
    Status = STATUS_SUCCESS;

done:

    //
    // Finally, release the remove lock and complete the master
    // IRP with the dependent IRP's completion status.
    //

    RaUnitReleaseRemoveLock (Unit, DependentIrp);
    Status = RaidCompleteRequest (MasterIrp,  Status);

    return Status;
}
    

NTSTATUS
RaUnitQueryDeviceRelationsIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle query device relations irp for the unit. The unit only
    supports querying TargetDeviceRelations.

Arguments:

    Unit - Unit to query.

    Irp - Query device relations irp.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PDEVICE_RELATIONS DeviceRelations;
    PIO_STACK_LOCATION IrpStack;
    DEVICE_RELATION_TYPE Type;

    PAGED_CODE ();

    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    Type = IrpStack->Parameters.QueryDeviceRelations.Type;

    if (Type == TargetDeviceRelation) {
        DeviceRelations = RaidAllocatePool (PagedPool,
                                            sizeof (DEVICE_RELATIONS),
                                            DEVICE_RELATIONS_TAG,
                                            Unit->DeviceObject);

        if (DeviceRelations != NULL) {
            DeviceRelations->Count = 1;
            DeviceRelations->Objects[0] = Unit->DeviceObject;
            ObReferenceObject (Unit->DeviceObject);
            Irp->IoStatus.Information = (ULONG_PTR) DeviceRelations;
            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_NO_MEMORY;
        }
    } else {
        //
        // We must complete the request with it's current status.
        //
        Status = Irp->IoStatus.Status;
    }

    return RaidCompleteRequest (Irp,  Status);
}

NTSTATUS
RaUnitQueryIdIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle query id request for the unit.

Arguments:

    Unit - Unit to handle the request.

    Irp - Query id request to handle.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    BUS_QUERY_ID_TYPE IdType;
    PIO_STACK_LOCATION IrpStack;
    PWSTR Id;
    
    
    PAGED_CODE ();
    ASSERT_UNIT (Unit);
    
    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    IdType = IrpStack->Parameters.QueryId.IdType;
    Id = NULL;
    
    switch (IdType) {

        case BusQueryDeviceID:
            Status = RaidUnitGetDeviceId (Unit, &Id);
            break;

        case BusQueryInstanceID:
            Status = RaidUnitGetInstanceId (Unit, &Id);
            break;

        case BusQueryHardwareIDs:
            Status = RaidUnitGetHardwareIds (Unit, &Id);
            break;

        case BusQueryCompatibleIDs:
            Status = RaidUnitGetCompatibleIds (Unit, &Id);
            break;

        default:
            Status = Irp->IoStatus.Status;
            Id = NULL;
    }

    Irp->IoStatus.Information = (ULONG_PTR) Id;
    return RaidCompleteRequest (Irp,  Status);
}


VOID
DbgPrintIds(
    IN BUS_QUERY_ID_TYPE IdType,
    IN PWSTR Id
    )
{
    ULONG i;
    PWSTR String;
    
    switch (IdType) {

        case BusQueryDeviceID:
            DbgPrint ("STOR: DeviceId: %ws\n", Id);
            break;

        case BusQueryInstanceID:
            DbgPrint ("STOR: InstanceId: %ws\n", Id);
            break;

        case BusQueryHardwareIDs:
            for (String = Id, i=0;
                 String[0] != UNICODE_NULL;
                 String += (wcslen (String) + 1), i++) {

                DbgPrint ("STOR: HardwareId[%d] %ws\n", i, String);
            }
            break;

        case BusQueryCompatibleIDs:
            for (String = Id, i=0;
                 !String[0] != UNICODE_NULL;
                 String += (wcslen (String) + 1), i++) {

                DbgPrint ("STOR: CompatibleId[%d] %ws\n", i, String);
            }
            break;
    }
}

NTSTATUS
RaUnitQueryDeviceTextIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{

    NTSTATUS Status;
    PWCHAR Buffer;
    CHAR VendorId [SCSI_VENDOR_ID_LENGTH + 1];
    CHAR ProductId [SCSI_PRODUCT_ID_LENGTH + 1];
    PCSCSI_DEVICE_TYPE DeviceType;   
    PIO_STACK_LOCATION IrpStack;
    DEVICE_TEXT_TYPE Type;
    
    PAGED_CODE ();

    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    Type = IrpStack->Parameters.QueryDeviceText.DeviceTextType;
    
    Buffer = RaidAllocatePool (PagedPool,
                               256 * sizeof (WCHAR),
                               QUERY_TEXT_TAG,
                               Unit->DeviceObject);

    if (Buffer == NULL) {
        return RaidCompleteRequest (Irp,  STATUS_NO_MEMORY);
    }
    
    switch (Type) {

        case DeviceTextDescription:
            //
            // We use "<VENDOR> SCSI <DEVICE-TYPE> Device", like SCSIPORT.
            //

            StorGetIdentityVendorId (&Unit->Identity,
                                     VendorId,
                                     sizeof (VendorId),
                                     TRUE);

            StorGetIdentityProductId (&Unit->Identity,
                                      ProductId,
                                      sizeof (ProductId),
                                      TRUE);

            DeviceType = StorGetIdentityDeviceType (&Unit->Identity);
            swprintf (Buffer,
                      L"%hs %hs SCSI %hs Device",
                      VendorId,
                      ProductId,
                      DeviceType->Name);
                      
            Status = STATUS_SUCCESS;
        break;

        case DeviceTextLocationInformation:
            //
            // We use "Bus Number <PathId>, Target ID <TargetId>, LUN <LUN>",
            // like SCSIPORT.
            //
            swprintf (Buffer,
                      L"Bus Number %d, Target Id %d, LUN %d",
                      Unit->Address.PathId,
                      Unit->Address.TargetId,
                      Unit->Address.Lun);
                      
            Status = STATUS_SUCCESS;
        break;

        default:
            ExFreePool (Buffer);
            Buffer = NULL;
            Status = STATUS_NOT_SUPPORTED;
    }

    Irp->IoStatus.Information = (ULONG_PTR)Buffer;
    return RaidCompleteRequest (Irp,  Status);
}

       
NTSTATUS
RaUnitIgnorePnpIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    PAGED_CODE ();

    return RaidCompleteRequest (Irp,  Irp->IoStatus.Status);
}
    
NTSTATUS
RaUnitSucceedPnpIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    PAGED_CODE ();

    return RaidCompleteRequest (Irp,  STATUS_SUCCESS);
}

NTSTATUS
RaUnitCheckRemoveStateForDisabled(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    ULONG MajorFunction;
    ULONG MinorFunction;
    UCHAR SrbFunction;

    if (Irp == NULL) {
        return STATUS_DELETE_PENDING;
    }

    MajorFunction = RaidMajorFunctionFromIrp (Irp);
    MinorFunction = RaidMinorFunctionFromIrp (Irp);

    if (MajorFunction == IRP_MJ_SCSI) {
        SrbFunction   = RaidSrbFunctionFromIrp (Irp);
    }

    //
    // If SCSI IRP and special enumeration tag, then allow it through or if
    // SCSI IRP and Claim Device SRB, allow through, else if PNP IRP allow
    // through.
    //
    
    if ((MajorFunction == IRP_MJ_SCSI &&
         MinorFunction == STOR_MN_ENUMERATION_IRP) ||
        (MajorFunction == IRP_MJ_SCSI &&
         SrbFunction == SRB_FUNCTION_CLAIM_DEVICE) ||
        MajorFunction == IRP_MJ_PNP) {

        return STATUS_SUCCESS;
    }

    return STATUS_DELETE_PENDING;
}

NTSTATUS
RaUnitCheckRemoveState(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Check if this IRP can be processed or if it must be failed. This is the
    work-horse routine that is called when acquiring and releasing the
    remove lock.

Arguments:

    Unit - Logical unit to check remove state on.

    Irp - Pointer to the IRP that will be checked.

Return Value:

    STATUS_DELETE_PENDING if the device is being removed or other NTSTATUS
    code.

--*/
{
    NTSTATUS Status;
    DEVICE_STATE DeviceState;
    ULONG MajorFunction;
    ULONG MinorFunction;

    DeviceState = Unit->DeviceState;
    
    //
    // If we're in deleted state, fail, if we're in disabled state, fail
    // unless this is a special port driver enum IRP, otherwise succeed.
    //

    switch (DeviceState) {

        case DeviceStateDeleted:

            Status = STATUS_DELETE_PENDING;
            break;

        case DeviceStateDisabled:

            Status = RaUnitCheckRemoveStateForDisabled (Unit, Irp);
            break;

        default:
            Status = STATUS_SUCCESS;
    }

    return Status;
}


NTSTATUS
RaUnitAcquireRemoveLock(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Acquire the logical unit's remove lock.

Arguments:

    Unit - Pointer to logical unit extension.

    Irp - Pointer to IO request packet.

Return Value:

    STATUS_DELETE_PENDIG - If the device is being removed.

    STATUS_SUCCESS - If the remove lock was successfully acquired.

--*/
{
    NTSTATUS Status;
    LONG Count;

    //
    // Increment upon entry to avoid race conditions. If we discover that
    // we're in the process of deleting, we'll decrement when exiting.
    //
    
    Count = InterlockedIncrement (&Unit->OutstandingCount);
    ASSERT (Count > 0);

    //
    // Check if this IRP should be allowed to go down.
    //
    
    Status = RaUnitCheckRemoveState (Unit, Irp);

    //
    // If we're removed, decrement the I/O count and set the empty event.
    //
    
    if (!NT_SUCCESS (Status)) {
        Count = InterlockedDecrement (&Unit->OutstandingCount);
        if (Count == 0) {
            KeSetEvent (&Unit->ZeroOutstandingEvent,
                        0,
                        FALSE);
        }
    }
    
    return Status;
}

VOID
RaUnitReleaseRemoveLock(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Release a reference to the remove lock previously acquired in
    RaUnitAcquireRemoveLock.

Arguments:

    Unit - Unit the removelock was acquired on.

    Irp - Irp the remove lock was acquired for. The IRP is used for tracking
        purposes only, and may be an already completed IRP.

Return Value:

    NTSTATUS code.

--*/
{
    LONG Count;

    UNREFERENCED_PARAMETER (Irp);

    Count = InterlockedDecrement (&Unit->OutstandingCount);
    ASSERT (Count >= 0);

    if (Count == 0) {
        KeSetEvent (&Unit->ZeroOutstandingEvent,
                    0,
                    FALSE);
                    
    }
}

NTSTATUS
RaUnitWaitForRemoveLock(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Wait for the remove lock to be freed. 

Arguments:

    Unit - Logical unit the remove lock is on.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    LONG Count;

    PAGED_CODE();

    //
    // The remove lock is 1-biased, so we always decrement it when
    // waiting for it to become free.
    //
    
    Count = InterlockedDecrement (&Unit->OutstandingCount);

    if (Count > 0) {
        Status = StorWaitForSingleObject (&Unit->ZeroOutstandingEvent,
                                          FALSE,
                                          NULL);
    } else {
        ASSERT (Count == 0);
        Status = STATUS_SUCCESS;
    }

    //
    // This restores the remlock count that was removed in waiting for
    // the zero outstanding event to fire, so the remlock is still usable.
    //
    
    InterlockedIncrement (&Unit->OutstandingCount);

    return Status;
}

    

NTSTATUS
RaUnitScsiIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Dispatch routine for SCSI irps. 

Arguments:

    Unit - Unit to handle the scsi irp.

    Irp - Scsi irp to handle.

Return Value:

    NTSTATUS code.

Environment:

    DISPATCH_LEVEL or below.

--*/
{
    NTSTATUS Status;
    PSCSI_REQUEST_BLOCK Srb;

    ASSERT (RaidMajorFunctionFromIrp (Irp) == IRP_MJ_SCSI);

    //
    // If the unit is in the process of being removed by Pnp, OR is not
    // physically present, fail the SCSI IRP.
    //
    
    Status = RaUnitAcquireRemoveLock (Unit, Irp);

    if (!NT_SUCCESS (Status)) {
        Srb = RaidSrbFromIrp (Irp);
        Srb->SrbStatus = RaidNtStatusToSrbStatus (Status);
        Irp->IoStatus.Information = 0;
        return RaidCompleteRequest (Irp,  Status);
    }

    Srb = RaidSrbFromIrp (Irp);

    DebugScsi (("Unit %p, Irp %p, Scsi, SrbFunc %x\n",
                 Unit,
                 Irp,
                 Srb->Function));
                    
    switch (Srb->Function) {

        case SRB_FUNCTION_EXECUTE_SCSI:
            Status = RaUnitExecuteScsiSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_CLAIM_DEVICE:
            Status = RaUnitClaimDeviceSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_RELEASE_DEVICE:
            Status = RaUnitReleaseDeviceSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_RESET_BUS:
            Status = RaUnitResetBusSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_FLUSH_QUEUE:
            Status = RaUnitFlushQueueSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_RELEASE_QUEUE: 
            Status = RaUnitReleaseQueueSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_LOCK_QUEUE:
            Status = RaUnitLockQueueSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_UNLOCK_QUEUE:
            Status = RaUnitUnlockQueueSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_FLUSH:
            Status = RaUnitFlushSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_SHUTDOWN:
            Status = RaUnitShutdownSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_IO_CONTROL:
            Status = RaUnitIoControlSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_WMI:
            Status = RaUnitWmiSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_RESET_LOGICAL_UNIT:
            Status = RaidUnitResetLogicalUnit (Unit, Irp);
            break;

        case SRB_FUNCTION_RESET_DEVICE:
            Status = RaUnitResetDeviceSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_ATTACH_DEVICE:
        case SRB_FUNCTION_RECEIVE_EVENT:
        case SRB_FUNCTION_ABORT_COMMAND:
        case SRB_FUNCTION_RELEASE_RECOVERY:
        case SRB_FUNCTION_TERMINATE_IO:
        case SRB_FUNCTION_REMOVE_DEVICE:
        default:
            Status = RaUnitUnknownSrb (Unit, Irp);

    }

    DebugScsi (("Unit %p, Irp %p, Scsi, ret = %08x\n",
                 Unit,
                 Irp,
                 Status));

    RaUnitReleaseRemoveLock (Unit, Irp);

    return Status;
}


NTSTATUS
RaidUnitSubmitRequest(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Submit a request to the miniport through the queuing mechanism.

Arguments:

    Unit - Pointer of logical unit that request will be submitted to.

    Irp - Pointer to the request to be submitted.
    
Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG Flags;
    PSCSI_REQUEST_BLOCK Srb;

    Srb = RaidSrbFromIrp (Irp);
    IoMarkIrpPending (Irp);
    RaidSrbMarkPending (Srb);

    //
    // We only expect two kinds of SRBs to be send down.
    //
    
    ASSERT (Srb->Function == SRB_FUNCTION_EXECUTE_SCSI ||
            Srb->Function == SRB_FUNCTION_IO_CONTROL ||
            Srb->Function == SRB_FUNCTION_RESET_LOGICAL_UNIT ||
            Srb->Function == SRB_FUNCTION_RESET_DEVICE ||
            Srb->Function == SRB_FUNCTION_RESET_BUS ||
            Srb->Function == SRB_FUNCTION_FLUSH ||
            Srb->Function == SRB_FUNCTION_SHUTDOWN);

    DbgLogRequest (LogSubmitRequest,
                   Irp,
                   (PVOID)(ULONG_PTR)StorScsiAddressToLong (Unit->Address),
                   NULL,
                   NULL);
    Flags = 0;

    //
    // Check for bypass requests.
    //
    
    if (TEST_FLAG (Srb->SrbFlags, SRB_FLAGS_BYPASS_LOCKED_QUEUE) ||
        TEST_FLAG (Srb->SrbFlags, SRB_FLAGS_BYPASS_FROZEN_QUEUE)) {
        Flags |= EXQ_BYPASS_REQUEST;
    }

    //
    // If this is a solitary request, set the solitary request flag.
    //
    
    if (IsSolitaryRequest (Srb)) {
        Flags |= EXQ_SOLITARY_REQUEST;
    }


    RaidStartIoPacket (&Unit->IoQueue,
                       Irp,
                       Flags,
                       NULL,
                       NULL);

    Status = STATUS_PENDING;
    return Status;
}


NTSTATUS
RaidUnitSubmitResetRequest(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Submit a request that will allocate reset resources. Thus, this request
    is submitted directly to StartIo instead of potentially queuing the
    request.

Arguments:

    Unit - Logical unit that request will be sent to.

    Irp - Irp to be submitted.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    KIRQL Irql;
    RAID_IO_RESOURCES IoResources;
    PSCSI_REQUEST_BLOCK Srb;

    Srb = RaidSrbFromIrp (Irp);
    IoMarkIrpPending (Irp);
    RaidSrbMarkPending (Srb);

    //
    // Allocate resources for this request.
    //
    
    Status = RaUnitAllocateResetIoResources (Unit, &IoResources);

    //
    // Failure: complete the request and exit the routine.
    //
    
    if (!NT_SUCCESS (Status)) {
        Srb->SrbStatus = RaidNtStatusToSrbStatus (Status);
        Irp->IoStatus.Information = 0;
        return RaidCompleteRequest (Irp, Status);
    }

    DbgLogRequest (LogSubmitRequest,
                   Irp,
                   (PVOID)(ULONG_PTR)StorScsiAddressToLong (Unit->Address),
                   NULL,
                   NULL);

    KeRaiseIrql (DISPATCH_LEVEL, &Irql);
    
    RaUnitStartResetIo (Unit->DeviceObject,
                        Irp,
                        &IoResources);

    KeLowerIrql (Irql);
    
    Status = STATUS_PENDING;

    return Status;
}


NTSTATUS
RaUnitExecuteScsiSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle the SRB_FUNCTION_EXECUTE_SCSI command by queuing the request
    on the LUN queue.

Arguments:

    Unit - Unit to execute the srb on.

    Irp - Irp to execute.

Return Value:

    STATUS_PENDING - On success.

    Other NTSTATUS code - On failure.

    NB: STATUS_SUCCESS should NEVER be returned from this function.

Environment:

    DISPATCH_LEVEL or below.

--*/
{
    return RaidUnitSubmitRequest (Unit, Irp);
}

NTSTATUS
RaUnitResetBusSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle a SRB_FUNCTION_RESET_BUS srb. This is done by submitting the
    request to the miniport.

Arguments:

    Unit - Unit the bus reset request is for.

    Irp - Irp representing a bus-reset command.

Return Value:

    NTSTATUS code.

--*/
{
    RaidPauseAdapterQueue (Unit->Adapter);
    return RaidUnitSubmitResetRequest (Unit, Irp);
}


NTSTATUS
RaUnitResetDeviceSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle a SRB_FUNCTION_RESET_DEVICE srb. This is done by submitting the
    request to the miniport.

Arguments:

    Unit - Unit the bus reset request is for.

    Irp - Irp representing a reset-device command.

Return Value:

    NTSTATUS code.

--*/
{
    RaidPauseAdapterQueue (Unit->Adapter);
    return RaidUnitSubmitResetRequest (Unit, Irp);
}


NTSTATUS
RaidUnitResetLogicalUnit(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle a SRB_FUNCTION_RESET_LOGICAL_UNIT srb. This is done by submitting
    the request to the miniport.

Arguments:

    Unit - Unit the bus reset request is for.

    Irp - Irp representing a reset-logicical-unit command.

Return Value:

    NTSTATUS code.

--*/
{
    RaidPauseUnitQueue (Unit);
    return RaidUnitSubmitResetRequest (Unit, Irp);
}


NTSTATUS
RaidUnitAllocateIoResources(
    IN PRAID_UNIT_EXTENSION Unit,
    OUT PRAID_IO_RESOURCES IoResources
    )
/*++

Routine Description:

    Allocate a block of IO resources for an I/O.

Arguments:

    Unit - Logical unit on which to allocate resources.

    IoResources - Block of allocated IoResources.

Return Value:

    NTSTATUS code.

--*/
{
    RtlZeroMemory (IoResources, sizeof (RAID_IO_RESOURCES));
    
    //
    // In the current driver architecture, the allocation of the QueueTag
    // can never fail. So don't bother to check for failure.
    //
    
    IoResources->QueueTag = RaAllocateTag (&Unit->TagList);
    ASSERT (IoResources->QueueTag != -1);

    //
    // When the queue tag is allocated, the srb extension slot is reserved.
    // Therefore, the srb extension allocation also cannot fail.
    //
    IoResources->SrbExtension =
        RaidAllocateSrbExtension (&Unit->SrbExtensionPool,
                                  IoResources->QueueTag);
    
    ASSERT (IoResources->SrbExtension != NULL);

    //
    // PERF NOTE: RaidAllocateXrb uses a lookaside list for allocations
    // which locks the bus. We could remove the bus lock by using
    // a fixed pool instead of a lookaside list and not locking at all.
    //

    IoResources->Xrb = RaidAllocateXrb (&Unit->XrbList,
                                        Unit->DeviceObject);
    ASSERT (IoResources->Xrb != NULL);

    return STATUS_SUCCESS;
}


NTSTATUS
RaUnitAllocateResetIoResources(
    IN PRAID_UNIT_EXTENSION Unit,
    OUT PRAID_IO_RESOURCES IoResources
    )
/*++

Routine Description:

    Allocate dynamic resources.

Arguments:

    Unit - Pointer to logical unit that resources will be allocated on.

    IoResources - Supplies buffer where resources will be copied upon success.

Return Value:

    NTSTATUS code.

--*/
{
    LONG Acquired;

    Acquired = InterlockedCompareExchange (&Unit->ResetResourcesAcquired,
                                           1,
                                           0);

    if (Acquired != 0) {

        //
        // A reset is already in progress.
        //
        
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory (IoResources,
                   &Unit->ResetResources,
                   sizeof (RAID_IO_RESOURCES));

    return STATUS_SUCCESS;
}

VOID
RaUnitFreeResetIoResources(
    IN PRAID_UNIT_EXTENSION Unit,
    OUT PRAID_IO_RESOURCES IoResources
    )
/*++

Routine Description:

    Free the reset resources previously allocated in RaUnitAllocateResetResources.

Arguments:

    Unit - Logical unit to free the reset resources to.

    IoResources - Reset resources to be freed.
    

Return Value:

    None.

--*/
{
    ASSERT (Unit->ResetResourcesAcquired == 1);
    Unit->ResetResourcesAcquired = 0;

    ASSERT (IoResources->QueueTag == Unit->ResetResources.QueueTag);
}


VOID
RaidUnitFreeIoResources(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PRAID_IO_RESOURCES IoResources
    )
/*++

Routine Description:

    Free IoResources allocated by RaidUnitAllocateIoResources or
    RaidUnitAllocateDynamicIoResources.

Arguments:

    Unit - Logical unit on which resources should be freed.

    IoResources - Pointer to IoResource block to free.

Return Value:

    None.

--*/
{

    VERIFY_DISPATCH_LEVEL();

    RaidFreeSrbExtension (&Unit->SrbExtensionPool, IoResources->QueueTag);
    
    //
    // Free the queue tag.
    //

    RaFreeTag (&Unit->TagList, IoResources->QueueTag);

    //
    // Free the XRB.
    //
    
    RaidFreeXrb (IoResources->Xrb, TRUE);

    DbgFillMemory (IoResources,
                   sizeof (RAID_IO_RESOURCES),
                   DBG_DEALLOCATED_FILL);
}



NTSTATUS
RaidUnitClaimIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp,
    IN PRAID_IO_RESOURCES IoResources OPTIONAL
    )
/*++

Routine Description:

    This routine will allocate any resources necessary to accomplish the
    IO for this specific IRP. At this point, these resources are generally
    SRB resources: queue tag, srb extension, Xrb.

    After an IRP is claimed, it must be released using RaidUnitReleaseIrp.

    This function is only necessary for IRP_MJ_SCSI IRPs.
    
Arguments:

    Unit - Specifies a unit that this SRB should be claimed by.

    Irp - Specifies an IRP to claim.

    IoResources - Preallocated resources to use for this IO.

Return Value:

    NTSTATUS code.

Note:

    This function is generally called from the unit's StartIo routine.

--*/
{
    NTSTATUS Status;
    PEXTENDED_REQUEST_BLOCK Xrb;
    PSCSI_REQUEST_BLOCK Srb;
    RAID_IO_RESOURCES IoResourcesBuffer;
        

    Srb = RaidSrbFromIrp (Irp);
    ASSERT (Srb != NULL);

    //
    // Each irp maintains a reference on the remove lock while being
    // processed. If this lock cannot be acquired, it means we are
    // in the process of being removed, so return status to fail
    // the irp.
    //
    
    Status = RaUnitAcquireRemoveLock (Unit, Irp);
    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // If we weren't given any resources, allocate necessary resources.
    // Otherwise, we'll reuse the resources from the previous IRP.
    //
    
    if (IoResources == NULL) {
        IoResources = &IoResourcesBuffer;
        Status = RaidUnitAllocateIoResources (Unit, IoResources);
    }

    //
    // If we failed to allocate resources, return failure.
    //
    
    if (!NT_SUCCESS (Status)) {
        RaUnitReleaseRemoveLock (Unit, Irp);
        return Status;
    }

    //
    // Quick check that the allocated IoResources is valid.
    //
    
    ASSERT (IoResources != NULL);
    ASSERT (IoResources->Xrb != NULL);
    ASSERT (IoResources->SrbExtension != NULL);
    
    //
    // Fill in the SCSI target information.
    //

    Srb->TargetId = Unit->Address.TargetId;
    Srb->PathId = Unit->Address.PathId;
    Srb->Lun = Unit->Address.Lun;
    Srb->QueueTag = (UCHAR)IoResources->QueueTag;

    //
    // Fill in Xrb fields.
    //

    Xrb = IoResources->Xrb;
    Xrb->Irp = Irp;
    Xrb->Srb = Srb;
    Xrb->Unit = Unit;
    Xrb->Mdl = Irp->MdlAddress;

    //
    // Set the XRB state to port-processing.
    //
    
    RaidSetXrbState (Xrb, XrbPortProcessing);
    
    //
    // Save SRB fields that we may modify.
    //
    
    Xrb->SrbData.OriginalRequest = Srb->OriginalRequest;
    Xrb->SrbData.DataBuffer = Srb->DataBuffer;

    //
    // Link the Srb to the Xrb and backlink the Xrb to the Srb.
    //
    
    Srb->OriginalRequest = Xrb;

    //
    // Set the Srb extension.
    //

    Srb->SrbExtension = IoResources->SrbExtension;

    //
    // Perform any buffer mapping that may be necessary.
    //
    
    RaidAdapterMapBuffers (Unit->Adapter, Irp);

    //
    // Add the IRP to the unit pending list.
    //
    
    RaUnitAddToPendingList (Unit, Irp);
    
    return STATUS_SUCCESS;
}


VOID
RaidUnitReleaseIrp(
    IN PIRP Irp,
    OUT PRAID_IO_RESOURCES IoResources OPTIONAL
    )
/*++

Routine Description:

    Undo any modifications to the IRP and SRB that were done by
    RaidUnitClaimIrp.

    This function is generally called from the Dpc routine before the
    IRP has been completed.

Arguments:

    Irp - Irp to release.

    IoResources - Buffer to return resources.

Return Value:

    None.

--*/
{
    PRAID_UNIT_EXTENSION Unit;
    PSCSI_REQUEST_BLOCK Srb;
    PEXTENDED_REQUEST_BLOCK Xrb;
    BOOLEAN FreeResources;
    RAID_IO_RESOURCES IoResourcesBuffer;

    VERIFY_DISPATCH_LEVEL();

    Srb = RaidSrbFromIrp (Irp);
    Xrb = RaidGetAssociatedXrb (Srb);
    Unit = Xrb->Unit;
    ASSERT_UNIT (Unit);

    //
    // First, remove the irp from the pending list.
    //
    
    RaUnitRemoveFromPendingList (Unit, Irp);

    //
    // If we were passed in NULL for IoResources parameter, free the
    // associated resources. Otherwise, return the resources in the
    // IoResources parameter.
    //
    
    if (IoResources == NULL) {
        IoResources = &IoResourcesBuffer;
        FreeResources = TRUE;
    } else {
        FreeResources = FALSE;
    }

    //
    // Note the resources that may need to be freed.
    //
    
    IoResources->QueueTag = Srb->QueueTag;
    IoResources->SrbExtension = Srb->SrbExtension;
    IoResources->Xrb = Xrb;

    //
    // Undo any modifications we made to the srb.
    //

    Srb->OriginalRequest = Xrb->SrbData.OriginalRequest;
    Srb->DataBuffer = Xrb->SrbData.DataBuffer;
    Srb->SrbExtension = NULL;

    RaidPrepareXrbForReuse (Xrb, TRUE);

    if (FreeResources) {
        RaidUnitFreeIoResources (Unit, IoResources);
        RtlZeroMemory (IoResources, sizeof (RAID_IO_RESOURCES));
    }

    //
    // The request maintains a reference to the remove lock while being
    // processed. Release it here.
    //
    
    RaUnitReleaseRemoveLock (Unit, Irp);
}


VOID
FORCEINLINE
RaidUnitCompleteRequestHook(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PEXTENDED_REQUEST_BLOCK Xrb
    )
{
    PSCSI_REQUEST_BLOCK Srb;

    Srb = Xrb->Srb;
    
    switch (Srb->Function) {

        case SRB_FUNCTION_RESET_LOGICAL_UNIT:
            InterlockedDecrement (&Unit->ResetCount);
            RaidResumeUnitQueue (Unit);
            RaidUnitRestartQueue (Unit);
            break;
            
        case SRB_FUNCTION_RESET_BUS:
        case SRB_FUNCTION_RESET_DEVICE:
            InterlockedDecrement (&Unit->ResetCount);
            RaidResumeAdapterQueue (Unit->Adapter);
            RaidAdapterRestartQueues (Unit->Adapter);
            break;
    }
}

VOID
RaidUnitCompleteRequest(
    IN PEXTENDED_REQUEST_BLOCK Xrb
    )
/*++

Routine Description:

    This routine is called by the adapter's DPC routine after an
    asynchronous IO has completed. It needs to complete the underlying
    IRP and deallocate any resources associated with the IRP.

Arguments:

    Xrb - Xrb to be completed.

Return Value:

    None.

Environment:

    DISPATCH_LEVEL only.

--*/
{
    PIRP Irp;
    PSCSI_REQUEST_BLOCK Srb;
    PRAID_UNIT_EXTENSION Unit;
    BOOLEAN RestartQueues;
    LOGICAL Started;
    RAID_IO_RESOURCES IoResources;

    ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);
    ASSERT_XRB (Xrb);

    Irp = Xrb->Irp;
    Srb = Xrb->Srb;
    Unit = Xrb->Unit;

    ASSERT (Irp != NULL);
    ASSERT (Srb != NULL);
    ASSERT_UNIT (Unit);


    if (SRB_STATUS (Srb->SrbStatus) == SRB_STATUS_SUCCESS) {

        //
        // The IO was successful. Mark the IRP as successful, release
        // resources associated with the IRP and complete the request.
        //

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = Srb->DataTransferLength;

        //
        // Release any resources owned by this IRP/SRB, and fixup
        // any modifications we made to the SRB.
        //

        if (RaidChainedIo) {
            RaidUnitReleaseIrp (Irp, &IoResources);
        } else {
            RaidUnitReleaseIrp (Irp, NULL);
        }

        //
        // Complete the request
        //

        DebugScsi (("Unit %p, Irp %p, completing = %08x\n",
                     Unit,
                     Irp,
                     Irp->IoStatus.Status));

        
        DbgLogRequest (LogRequestComplete,
                       Irp,
                       (PVOID)(ULONG_PTR)(Irp->IoStatus.Status),
                       (PVOID)(ULONG_PTR)(Srb->SrbStatus),
                       NULL);

        RaidCompleteRequestEx (Irp,
                               IO_DISK_INCREMENT,
                               Irp->IoStatus.Status);

        //
        // Start the next io packet.
        //

        if (RaidChainedIo) {
            Started = RaidStartNextIoPacket (&Unit->IoQueue,
                                             FALSE,
                                             &IoResources,
                                             &RestartQueues);
            if (!Started) {
                RaidUnitFreeIoResources (Unit, &IoResources);
            }
        } else {
            RaidStartNextIoPacket (&Unit->IoQueue,
                                   FALSE,
                                   NULL,
                                   &RestartQueues);
        }

        if (RestartQueues) {
            RaidAdapterRestartQueues (Unit->Adapter);
        }
        
    } else {

        //
        // Error: Leave all the detail of handling the error, including
        // whether the IRP should be released and completed or not, to
        // the error handling routine.
        //
           
        RaUnitAsyncError (Unit, Xrb);
    }

}


VOID
FORCEINLINE
RaidUnitIssueRequestHook(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PEXTENDED_REQUEST_BLOCK Xrb
    )
{
    PSCSI_REQUEST_BLOCK Srb;

    Srb = Xrb->Srb;
    
    switch (Srb->Function) {

        case SRB_FUNCTION_RESET_BUS:
        case SRB_FUNCTION_RESET_DEVICE:
        case SRB_FUNCTION_RESET_LOGICAL_UNIT:
            InterlockedIncrement (&Unit->ResetCount);
            break;
    }
}



VOID
RaUnitStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context OPTIONAL
    )
/*++

Routine Description:

    Start the next irp on the specified logical unit.

Arguments:

    DeviceObject - DeviceObject associated with the logical unit
            to start the next irp on.

    Irp - Irp to execute.

    Context - Optional context for this call.

Return Value:

    None. All errors will be handled asynchronously in the DPC routine.

Environment:

    Called from DISPATCH_LEVEL only.

--*/
{
    NTSTATUS Status;
    PRAID_UNIT_EXTENSION Unit;
    PEXTENDED_REQUEST_BLOCK Xrb;
    PRAID_ADAPTER_EXTENSION Adapter;
    PSCSI_REQUEST_BLOCK Srb;
    PRAID_IO_RESOURCES IoResources;

    VERIFY_DISPATCH_LEVEL();
    
    Unit = (PRAID_UNIT_EXTENSION)DeviceObject->DeviceExtension;
    ASSERT_UNIT (Unit);
    Adapter = Unit->Adapter;
    ASSERT_ADAPTER (Adapter);
    IoResources = (PRAID_IO_RESOURCES)Context;

    Srb = RaidSrbFromIrp (Irp);

    //
    // Check if the device has been removed; if it has, fail the request
    // here. This is important because routines can issue I/O without going
    // through the normal Scsi processing. During busy processing, for example,
    // this happens. The call below is equivalent to acquiring and removing
    // the removelock for the given IRP.
    //
    
    Status = RaUnitCheckRemoveState (Unit, Irp);

    if (!NT_SUCCESS (Status)) {
        Srb->SrbStatus = RaidNtStatusToSrbStatus (Status);
        Irp->IoStatus.Information = 0;
        RaidUnitFreeIoResources (Unit, IoResources);
        DebugScsi (("Unit %p, Irp %p, completing %08x\n",
                     Unit->DeviceObject, Irp, Irp->IoStatus.Status));
        RaidCompleteRequest (Irp, Status);
        return;
    }
    
    //
    // Process any items on the deferred queue. This will force any
    // freeze requests to happen here, without waiting for a DPC
    // to be scheduled.
    //

    RaidAdapterProcessDeferredItems (Adapter);

    //
    // Allocate any resources necessary, and modify the associated SRB
    // to be for this LU.
    //

    Status = RaidUnitClaimIrp (Unit, Irp, (PRAID_IO_RESOURCES)Context);

    if (!NT_SUCCESS (Status)) {
        Srb->SrbStatus = RaidNtStatusToSrbStatus (Status);
        Irp->IoStatus.Information = 0;
        RaidUnitFreeIoResources (Unit, IoResources);
        DebugScsi (("Unit %p, Irp %p, completing %08x\n",
                     Unit->DeviceObject, Irp, Irp->IoStatus.Status));
        RaidCompleteRequest (Irp,  Status);
        return;
    }

    //
    // The IoResource are now associated with the IRP; NULL out the pointer
    // so we don't accidentially use them.
    //
    
    IoResources = NULL;

    //
    // If the link is down, fail all requests except those associated with
    // bus enumeration.
    //

    if (Unit->Adapter->LinkUp == FALSE) {
        if (Srb->Cdb[0] != SCSIOP_INQUIRY && 
            Srb->Cdb[0] != SCSIOP_REPORT_LUNS) {
            Srb->SrbStatus = SRB_STATUS_LINK_DOWN;
            Irp->IoStatus.Information = 0;
            Status = STATUS_NO_SUCH_DEVICE;
            DebugScsi (("Unit %p, Irp %p, completing %08x b/c link is down\n",
                         Unit->DeviceObject, Irp));
            RaidUnitReleaseIrp (Irp, NULL);
            RaidCompleteRequest (Irp,  Status);
            return;
        }
    }

    //
    // Get associated Xrb.
    //

    Xrb = RaidXrbFromIrp (Irp);

    //
    // Allow any request specific processing to happen, if necessary.
    //
    
    RaidUnitIssueRequestHook (Unit, Xrb);

    //
    // Set a completion routine for the Xrb.
    //

    RaidXrbSetCompletionRoutine (Xrb, RaidUnitCompleteRequest);
    
    //
    // Issue the Execute request to the adapter.
    //

    Status = RaidAdapterExecuteXrb (Unit->Adapter, Xrb);

    if (NT_SUCCESS (Status)) {

        //
        // Remove any further items from the deferred queue. These
        // could have been queued during the processing of the XRB.
        //

        RaidAdapterProcessDeferredItems (Unit->Adapter);
    
    } else {

        //
        // This means we weren't even able to submit the request to the
        // miniport. There's nothing to do but fail the request.
        //

        Srb = RaidSrbFromIrp (Irp);
        RaidUnitReleaseIrp (Irp, NULL);
        Irp->IoStatus.Information = 0;
        Srb->SrbStatus = RaidNtStatusToSrbStatus (Status);
        RaidCompleteRequest (Irp, Status);
    }
}


VOID
RaUnitStartResetIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    Start the next irp on the specified logical unit.

Arguments:

    DeviceObject - DeviceObject associated with the logical unit
            to start the next irp on.

    Irp - Irp to execute.

    Context - Optional context for this call.

Return Value:

    None. All errors will be handled asynchronously in the DPC routine.

Environment:

    Called from DISPATCH_LEVEL only.

--*/
{
    NTSTATUS Status;
    PRAID_UNIT_EXTENSION Unit;
    PEXTENDED_REQUEST_BLOCK Xrb;
    PRAID_ADAPTER_EXTENSION Adapter;
    PSCSI_REQUEST_BLOCK Srb;
    PRAID_IO_RESOURCES IoResources;
    LOGICAL IrpClaimed;

    VERIFY_DISPATCH_LEVEL();
    
    Unit = (PRAID_UNIT_EXTENSION)DeviceObject->DeviceExtension;
    ASSERT_UNIT (Unit);
    Adapter = Unit->Adapter;
    ASSERT_ADAPTER (Adapter);
    IoResources = (PRAID_IO_RESOURCES)Context;
    ASSERT (IoResources != NULL);

    Srb = RaidSrbFromIrp (Irp);
    IrpClaimed = FALSE;

    //
    // Check if the device has been removed; if it has, fail the request
    // here. This is important because routines can issue I/O without going
    // through the normal Scsi processing. During busy processing, for example,
    // this happens. The call below is equivalent to acquiring and removing
    // the removelock for the given IRP.
    //
    
    Status = RaUnitCheckRemoveState (Unit, Irp);

    if (!NT_SUCCESS (Status)) {
        goto done;
    }
    
    //
    // Allocate any resources necessary, and modify the associated SRB
    // to be for this LU.
    //

    Status = RaidUnitClaimIrp (Unit, Irp, (PRAID_IO_RESOURCES)Context);

    if (!NT_SUCCESS (Status)) {
        goto done;
    }

    //
    // The IoResource are now associated with the IRP; NULL out the pointer
    // so we don't accidentially use them. Also, this tells the failure
    // code at the end of the function to use RaidReleaseIrp instead of
    // RaidUnitFreeIoResources to cleanup after the request.
    //
    
    IoResources = NULL;

    //
    // Increment the reset count. (Maybe with the reset resources, this
    // could be unnecessary.)
    //
    
    InterlockedIncrement (&Unit->ResetCount);

    //
    // Get associated Xrb.
    //

    Xrb = RaidXrbFromIrp (Irp);

    //
    // Set a completion routine for the Xrb.
    //

    RaidXrbSetCompletionRoutine (Xrb, RaidUnitCompleteResetRequest);
    
    //
    // Issue the Execute request to the adapter.
    //

    Status = RaidAdapterExecuteXrb (Unit->Adapter, Xrb);

done:

    //
    // If we failed, cleanup the resources and complete the request.
    //

    if (!NT_SUCCESS (Status)) {
        if (IoResources) {
            RaidUnitFreeIoResources (Unit, IoResources);
        } else {
            RaidUnitReleaseIrp (Irp, NULL);
        }
        Irp->IoStatus.Information = 0;
        Srb->SrbStatus = RaidNtStatusToSrbStatus (Status);
        DebugScsi (("Unit %p, Irp %p, completing %08x\n",
                     Unit->DeviceObject, Irp, Irp->IoStatus.Status));
        RaidCompleteRequest (Irp,  Status);
    }
}


VOID
RaidUnitCompleteResetRequest(
    IN PEXTENDED_REQUEST_BLOCK Xrb
    )
/*++

Routine Description:


Arguments:

    Xrb - Xrb to be completed.

Return Value:

    None.

Environment:

    DISPATCH_LEVEL only.

--*/
{
    PIRP Irp;
    PSCSI_REQUEST_BLOCK Srb;
    PRAID_UNIT_EXTENSION Unit;
    BOOLEAN RestartQueues;
    LOGICAL Started;
    RAID_IO_RESOURCES IoResources;

    ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);
    ASSERT_XRB (Xrb);

    Irp = Xrb->Irp;
    Srb = Xrb->Srb;
    Unit = Xrb->Unit;

    ASSERT (Irp != NULL);
    ASSERT (Srb != NULL);
    ASSERT_UNIT (Unit);

    RaidUnitCompleteRequestHook (Unit, Xrb);
    
    //
    // The IO was successful. Mark the IRP as successful, release
    // resources associated with the IRP and complete the request.
    //

    Irp->IoStatus.Status = RaidSrbStatusToNtStatus (Srb->SrbStatus);
    Irp->IoStatus.Information = Srb->DataTransferLength;

    //
    // Remove the IRP/SRB/XRB from storport's lists. Have ReleaseIrp
    // return the resources to us so we can free them separately.
    //

    RaidUnitReleaseIrp (Irp, &IoResources);

    //
    // RaidUnitReleaseIrp must have returned the correct I/O resources
    // that cooresponds to the reset resources.
    //
    
    ASSERT (RaUnitIsResetResources (Unit, &IoResources));
    RaUnitFreeResetIoResources (Unit, &IoResources);

    //
    // Complete the request
    //

    DebugScsi (("Unit %p, Irp %p, completing = %08x\n",
                 Unit,
                 Irp,
                 Irp->IoStatus.Status));

    
    DbgLogRequest (LogRequestComplete,
                   Irp,
                   (PVOID)(ULONG_PTR)(Irp->IoStatus.Status),
                   (PVOID)(ULONG_PTR)(Srb->SrbStatus),
                   NULL);

    RaidCompleteRequest (Irp,
                         Irp->IoStatus.Status);

}


NTSTATUS
RaUnitClaimDeviceSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    If the device is unclaimed, claim it, otherwise return STATUS_DEVICE_BUSY
    as an error.

Arguments:

    Unit - The unit to claim.

    Irp - The irp representing the claim device irp.

Return Value:

    NTSTATUS code.

Environment:

    DISPATCH_LEVEL or below.

--*/
{
    NTSTATUS Status;
    KLOCK_QUEUE_HANDLE LockHandle;
    PSCSI_REQUEST_BLOCK Srb;
    
    KeAcquireInStackQueuedSpinLock (&Unit->SlowLock, &LockHandle);

    Srb = RaidSrbFromIrp (Irp);
    if (!Unit->Flags.DeviceClaimed) {
        Unit->Flags.DeviceClaimed = TRUE;
        //
        // Though this seems wrong, it's what SCSIPORT does. Should
        // clarify the interface.
        //
        Srb->DataBuffer = Unit->DeviceObject;
        Srb->SrbStatus = SRB_STATUS_SUCCESS;
        Status = STATUS_SUCCESS;
    } else {
        Srb->DataBuffer = NULL;
        Srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
        Srb->InternalStatus = STATUS_DEVICE_BUSY;
        Status = STATUS_DEVICE_BUSY;
    }

    KeReleaseInStackQueuedSpinLock (&LockHandle);

    return RaidCompleteRequest (Irp, Status);
}


NTSTATUS
RaUnitReleaseDeviceSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Release the claim on this unit.

Arguments:

    Unit - The unit which must have been claimed.

    Irp - The release device irp.
    
Return Value:

    NTSTATUS code.

Environment:

    DISPATCH_LEVEL or below.

--*/
{
    NTSTATUS Status;
    PSCSI_REQUEST_BLOCK Srb;
    KLOCK_QUEUE_HANDLE LockHandle;
    
    Srb = RaidSrbFromIrp (Irp);
    
    KeAcquireInStackQueuedSpinLock (&Unit->SlowLock, &LockHandle);

    //
    // The class driver is not allowed to release the device multiple
    // times.
    //
    
    ASSERT (Unit->Flags.DeviceClaimed);
    Unit->Flags.DeviceClaimed = FALSE;

    KeReleaseInStackQueuedSpinLock (&LockHandle);

    Srb->SrbStatus = SRB_STATUS_SUCCESS;
    Status = STATUS_SUCCESS;

    return RaidCompleteRequest (Irp,  Status);
}

NTSTATUS
RaUnitIoControlSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle an ioctl SRB sent to the miniport.

Arguments:

    Unit - Logical unit the ioctl SRB is for.

    Irp - IRP representing an SRB ioctl.

Return Value:

    NTSTATUS code.

--*/
{
    return RaidUnitSubmitRequest (Unit, Irp);
}



NTSTATUS
RaUnitReleaseQueueSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    PSCSI_REQUEST_BLOCK Srb;
    
    RaidThawUnitQueue (Unit);

    Srb = RaidSrbFromIrp (Irp);
    Srb->SrbStatus = SRB_STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    return RaidCompleteRequest (Irp,  STATUS_SUCCESS);
}

NTSTATUS
RaUnitFlushQueueSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP FlushIrp
    )
/*++

Routine Description:

    Flush the pending queue, canceling all requests.

Arguments:

    Unit - Supplies pointer to unit to flush.

    FlushIrp - Supplies the IRP representing the flush queue request.

Return Value:

    NTSTATUS code.

Environment:

    DISPATCH_LEVEL or below.

--*/
{
    PIRP Irp;
    PSCSI_REQUEST_BLOCK Srb;
    

    ASSERT (RaidIsUnitQueueFrozen (Unit));

    //
    // Flush all entries.
    //
    
    for (Irp = RaidRemoveIoQueue (&Unit->IoQueue);
         Irp != NULL;
         Irp = RaidRemoveIoQueue (&Unit->IoQueue)) {

        Srb = RaidSrbFromIrp (Irp);
        Srb->SrbStatus = SRB_STATUS_REQUEST_FLUSHED;
        Irp->IoStatus.Information = 0;
        RaidCompleteRequest (Irp,  STATUS_UNSUCCESSFUL);
    }

    RaidThawUnitQueue (Unit);

    Srb = RaidSrbFromIrp (Irp);
    Srb->SrbStatus = SRB_STATUS_SUCCESS;
    FlushIrp->IoStatus.Information = 0;
    return RaidCompleteRequest (FlushIrp,  STATUS_SUCCESS);
}

NTSTATUS
RaUnitFlushSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NTSTATUS Status;
    PSCSI_REQUEST_BLOCK Srb;

    
    if (!Unit->Adapter->Miniport.PortConfiguration.CachesData) {

        //
        // If the HBA doesn't cache data, there's nothing to do.
        //

        Srb = RaidSrbFromIrp (Irp);
        Srb->SrbStatus = SRB_STATUS_SUCCESS;
        Irp->IoStatus.Information = 0;
        Status = RaidCompleteRequest (Irp,  STATUS_SUCCESS);

    } else {

        //
        // Otherwise, submit this to the miniport.
        //

        Status = RaidUnitSubmitRequest (Unit, Irp);
    }

    return Status;
}

NTSTATUS
RaUnitShutdownSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler routine for SRB_FUNCTION_SHUTDOWN SRB.

Arguments:

    Unit - Supplies the logical unit that is to be shutdown.

    Irp - Supplies the IRP representing the shutdown request.

Return Value:

    NTSTATUS code.

--*/
{
    return RaidUnitSubmitRequest (Unit, Irp);
}

NTSTATUS
RaUnitWmiSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NYI();
    return RaidCompleteRequest (Irp,  STATUS_INVALID_DEVICE_REQUEST);
}

NTSTATUS
RaUnitLockQueueSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    //
    // Lock the device queue, queuing all pending IRPs for processing
    // later. This is used in Power Management.
    //

    RaidLockUnitQueue (Unit);

    return RaidCompleteRequest (Irp,  STATUS_SUCCESS);
}

NTSTATUS
RaUnitUnlockQueueSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle SRB_FUNCTION_UNLOCK_QUEUE srb.

Arguments:

    Unit - Logical unit IRP is for.

    Irp - SRB_FUNCTION_UNLOCK_QUEUE Srb.

Return Value:

    NTSTATUS code.

--*/
{
    //
    // Unlock the unit device queue, allowing all queued IRPs to continue
    // processing. This is used in Power Management.
    //

    RaidUnlockUnitQueue (Unit);

    //
    // Restart the LUN queue if necessary.
    //
    
    RaidUnitRestartQueue (Unit);

    return RaidCompleteRequest (Irp,  STATUS_SUCCESS);
}

NTSTATUS
RaUnitUnknownSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NTSTATUS Status;
    PSCSI_REQUEST_BLOCK Srb;

    PAGED_CODE ();

    //
    // Fail requests we do not handle.
    //

    Srb = RaidSrbFromIrp (Irp);
    Srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
    Status = STATUS_NOT_SUPPORTED;
    Srb->InternalStatus = Status;

    return RaidCompleteRequest (Irp,  Status);
}



NTSTATUS
RaUnitDeviceControlIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Dispatch routine for device control (ioctl) irps.

Arguments:

    Unit - Unit to handle this irp.

    Irp - Device control irp to handle.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG Ioctl;

    PAGED_CODE ();

    Status = RaUnitAcquireRemoveLock (Unit, Irp);

    if (!NT_SUCCESS (Status)) {
        Irp->IoStatus.Information = 0;
        return RaidCompleteRequest (Irp,  Status);
    }
    
    Ioctl = RaidIoctlFromIrp (Irp);
    DebugTrace (("Unit %p, Irp %p, Ioctl = %08x\n",
                  Unit,
                  Irp,
                  Ioctl));
                 
    switch (Ioctl) {

        //
        // SCSI Ioctls
        //
        
        case IOCTL_SCSI_PASS_THROUGH:
            Status = RaUnitScsiPassThroughIoctl (Unit, Irp);
            break;

        case IOCTL_SCSI_PASS_THROUGH_DIRECT:
            Status = RaUnitScsiPassThroughIoctl (Unit, Irp);
            break;

        case IOCTL_SCSI_GET_ADDRESS:
            Status = RaUnitScsiGetAddressIoctl (Unit, Irp);
            break;

        case IOCTL_SCSI_GET_DUMP_POINTERS:
            Status = RaUnitScsiGetDumpPointersIoctl (Unit, Irp);
            break;

        case IOCTL_SCSI_FREE_DUMP_POINTERS:
            Status = RaUnitScsiFreeDumpPointersIoctl (Unit, Irp);
            break;

        case IOCTL_STORAGE_QUERY_PROPERTY:
            Status = RaUnitStorageQueryPropertyIoctl (Unit, Irp);
            break;

        default:
            Status = RaUnitUnknownIoctl (Unit, Irp);
    }

    DebugTrace (("Unit %p, Irp %p, Ioctl = %08x, ret = %08x\n", 
                  Unit,
                  Irp,
                  Ioctl,
                  Status));

    RaUnitReleaseRemoveLock (Unit, Irp);

    return Status;
}


//
// IRP_MJ_DEVICE_CONTROL IRP handlers.
//

NTSTATUS
RaUnitScsiPassThroughIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler routine for pass-through and pass-through direct ioctls for
    the logical unit. This routine merely adds data to some of the fields
    in the pass-through structure and passes the request down to the
    adapter.

Arguments:

    Unit - Logical unit the pass-through IRP is for.

    Irp - Irp representing a pass-through or pass-through direct IRP.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PRAID_ADAPTER_EXTENSION Adapter;

    PAGED_CODE();

    Adapter = Unit->Adapter;

    //
    // Call out to the port driver library to initialize the address.  If the
    // input buffer is not valid, an error is returned.
    //
    
    Status = PortSetPassThroughAddress (Irp,
                                        Unit->Address.PathId,
                                        Unit->Address.TargetId,
                                        Unit->Address.Lun);

    //
    // If PassThrough is NULL, fail the IRP.
    //
    
    if (!NT_SUCCESS(Status)) {
        return RaidCompleteRequest (Irp,
                                    STATUS_INVALID_DEVICE_REQUEST);
    }

    //
    // Send the IRP to the adapter. NB: This takes advantage of the
    // fact that the adapter FDO handles the request and doesn't pass
    // it onto the adapter PDO.
    //

    IoSkipCurrentIrpStackLocation (Irp);
    Status = IoCallDriver (Adapter->DeviceObject, Irp);

    return Status;
}

NTSTATUS
RaUnitScsiGetAddressIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NTSTATUS Status;
    PSCSI_ADDRESS ScsiAddress;
    ULONG BufferLength;
    PIO_STACK_LOCATION IrpStack;
    
    PAGED_CODE ();

    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    ScsiAddress = Irp->AssociatedIrp.SystemBuffer;
    BufferLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;

    if (BufferLength < sizeof (SCSI_ADDRESS)) {
        Status = STATUS_BUFFER_TOO_SMALL;
    } else {
        ScsiAddress->Length = sizeof (SCSI_ADDRESS);
        ScsiAddress->PortNumber = (UCHAR)Unit->Adapter->PortNumber;
        ScsiAddress->PathId = Unit->Address.PathId;
        ScsiAddress->TargetId = Unit->Address.TargetId;
        ScsiAddress->Lun = Unit->Address.Lun;

        Irp->IoStatus.Information = sizeof (SCSI_ADDRESS);
        Status = STATUS_SUCCESS;
    }

    return RaidCompleteRequest (Irp,  Status);
}



NTSTATUS
RaUnitScsiGetDumpPointersIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Create a DUMP_POINTERS structure describing any resources necessary
    for crashdump and hiber.

Arguments:

    Unit - Unit the ioctl is for.

    Irp - Get dump pointers ioctl.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PDUMP_POINTERS DumpPointers;
    PPORT_CONFIGURATION_INFORMATION Configuration;
    PIO_STACK_LOCATION IrpStack;
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_DMA_ADAPTER Dma;
    ULONG DumpSize;


    PAGED_CODE();

    Adapter = Unit->Adapter;
    Dma = &Adapter->Dma;
    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    
    //
    // Only kernel mode is allowed to get the dump pointers.
    //

    if (Irp->RequestorMode != KernelMode) {
        Status = STATUS_ACCESS_DENIED;
        goto done;
    }

    if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength <
         sizeof (DUMP_POINTERS)) {
        Status = STATUS_BUFFER_TOO_SMALL;
        Irp->IoStatus.Information = sizeof (DUMP_POINTERS);
        goto done;
    }

    DumpPointers = (PDUMP_POINTERS)Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory (DumpPointers, sizeof (DUMP_POINTERS));

    //
    // Diskdump requires a complete copy of the configuration information.
    // This must be nonpaged. Also, this memory is never freed, since in
    // practice we never call FreeDumpStack.
    //
    
    Configuration = RaidAllocatePool (NonPagedPool,
                                      sizeof (PORT_CONFIGURATION_INFORMATION),
                                      CRASHDUMP_TAG,
                                      Unit->DeviceObject);

    if (Configuration == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto done;
    }

    //
    // Initialize DMA information.
    //
    
    DumpPointers->AdapterObject = (PVOID)Dma->DmaAdapter;

    //
    // This is head of a list of MAPPED_ADDRESS structures that
    // diskdump uses to map io addresses.
    //
    
    DumpPointers->MappedRegisterBase = &Adapter->MappedAddressList;

    //
    // Copy the private port configuration.
    //

    RtlCopyMemory (Configuration,
                   &Adapter->Miniport.PortConfiguration,
                   sizeof (PORT_CONFIGURATION_INFORMATION));
    
    Configuration->SlotNumber = Adapter->SlotNumber;
    Configuration->SystemIoBusNumber = Adapter->BusNumber;
    DumpPointers->DumpData = Configuration;

    DumpPointers->UseDiskDump = TRUE;
    DumpPointers->DeviceObject = Adapter->DeviceObject;

    //
    // Set AllocateCommonBuffers to TRUE so the dump engine will
    // allocate common buffers for us.
    //
    
    DumpPointers->AllocateCommonBuffers = TRUE;

    //
    // We set the CommonBufferVa and Pa to NULL because they are never used
    // by the crashdump engine.
    //

    DumpPointers->CommonBufferVa = NULL;
    DumpPointers->CommonBufferPa.QuadPart = 0;

    //
    // Initialize the CommonBufferSize to a reasonable size for the dump
    // engine.
    //
    
    DumpSize = RaGetSrbExtensionSize (Adapter);

    if (DumpSize == 0) {
        DumpSize = 16;
    }

    //
    // Enough room for 16 SRBs.
    //
    
    DumpSize *= 16;
    DumpSize += RaidRegionGetSize (&Adapter->UncachedExtension);

    DumpPointers->CommonBufferSize = (ULONG)ROUND_TO_PAGES (DumpSize);

    Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = sizeof (DUMP_POINTERS);

done:

    return RaidCompleteRequest (Irp,  Status);
}



NTSTATUS
RaUnitScsiFreeDumpPointersIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Free any resources associated with the crashdump, hiber DUMP_POINTERS
    structure previously allocated by the get dump pointers ioctl.

Arguments:

    Unit - Unit this ioctl is for.

    Irp - Free dump pointers irp.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PDUMP_POINTERS DumpPointers;
    PIO_STACK_LOCATION IrpStack;
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_DMA_ADAPTER Dma;

    PAGED_CODE ();

    Adapter = Unit->Adapter;
    Dma = &Adapter->Dma;
    IrpStack = IoGetCurrentIrpStackLocation (Irp);

    //
    // Only kernel mode is allowed to get or free the dump pointers.
    //
    
    if (Irp->RequestorMode != KernelMode) {
        Status = STATUS_ACCESS_DENIED;
        goto done;
    }

    if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength <
         sizeof (DUMP_POINTERS)) {
        Status = STATUS_INVALID_PARAMETER;
        goto done;
    }

    DumpPointers= (PDUMP_POINTERS)Irp->AssociatedIrp.SystemBuffer;

    //
    // Do some basic validation that we were actually passed in
    // a valid DUMP_POINTERS structure.
    //
    
    ASSERT (DumpPointers->AdapterObject == (PVOID)Dma->DmaAdapter);
    ASSERT (DumpPointers->MappedRegisterBase == Dma->MapRegisterBase);
    ASSERT (DumpPointers->CommonBufferSize == 0);
    ASSERT (DumpPointers->CommonBufferVa == NULL);

    RaidFreePool (DumpPointers->DumpData, CRASHDUMP_TAG);
    RtlZeroMemory (DumpPointers, sizeof (DUMP_POINTERS));
    Status = STATUS_SUCCESS;

done:

    return RaidCompleteRequest (Irp,  Status);
}



NTSTATUS
RaidUnitResetUnit(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Reset a logical unit.

Arguments:

    Unit - Logical unit to reset.

Return Value:

    NTSTATUS code.

Environment:

     This function is in the reset path, and therefore cannot be paged.
     
--*/
{
    NTSTATUS Status;
    PIRP Irp;
    PSCSI_REQUEST_BLOCK Srb;
    KEVENT Event;
    IO_STATUS_BLOCK IoStatus;
    RAID_ADDRESS Address;
    PRAID_ADAPTER_EXTENSION Adapter;

    //
    // Initialization to NULL
    //

    Irp = NULL;
    Srb = NULL;

    //
    // Validate that we're not doing this for an invalid address.
    //
    
    Address = RaidUnitGetAddress (Unit);
    ASSERT (StorCompareScsiAddress (Address, RaidNullAddress) != 0);

    //
    // Build a SRB for this request.
    //

    Srb = RaidAllocateSrb (Unit->DeviceObject);

    if (Srb == NULL) {
        Status = STATUS_NO_MEMORY;
        goto cleanup;
    }

    //
    // Build the SRB.
    //

    Srb->Length = sizeof (SCSI_REQUEST_BLOCK);
    Srb->Function = SRB_FUNCTION_RESET_LOGICAL_UNIT;
    Srb->PathId = Unit->Address.PathId;
    Srb->TargetId = Unit->Address.TargetId;
    Srb->Lun = Unit->Address.Lun;
    Srb->SrbFlags = SRB_FLAGS_NO_QUEUE_FREEZE
                  | SRB_FLAGS_BYPASS_FROZEN_QUEUE
                  | SRB_FLAGS_BYPASS_LOCKED_QUEUE;
 
    Srb->QueueTag = -1;
    Srb->DataBuffer = NULL;
    Srb->DataTransferLength = 0;
    Srb->OriginalRequest = Irp;
    Srb->TimeOutValue = max (MINIMUM_RESET_TIMEOUT, Unit->DefaultTimeout);

    //
    // Initialize the event we will wait on.
    //
    
    KeInitializeEvent (&Event,
                       NotificationEvent,
                       FALSE);
    //
    // Allocate and initialize the IRP for this request.
    //
    
    Irp = StorBuildSynchronousScsiRequest (Unit->DeviceObject,
                                           Srb,
                                           &Event,
                                           &IoStatus);

    
    if (Irp == NULL) {
        Status = STATUS_NO_MEMORY;
        goto cleanup;
    }

    //
    // Submit the to the logical unit. This request IS submitted through
    // the logical unit queuing logic.
    //

    Status = IoCallDriver (Unit->DeviceObject, Irp);

    if (Status == STATUS_PENDING) {
        KeWaitForSingleObject (&Event,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL);

        Status = IoStatus.Status;
    }

    //
    // NB: If successful, we should pause for RESET_HOLD_TIME
    // here.
    //

cleanup:

    if (Srb != NULL) {
        RaidFreeSrb (Srb);
        Srb = NULL;
    }

    return Status;
}



NTSTATUS
RaidUnitResetTarget(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Reset a target.

Arguments:

    Unit - Unit that the target is a part if.

Return Value:

    NTSTATUS code.

Environment:

    This function is in the reset path, and therefore cannot be paged.

--*/
{
    NTSTATUS Status;
    PIRP Irp;
    PSCSI_REQUEST_BLOCK Srb;
    KEVENT Event;
    IO_STATUS_BLOCK IoStatus;
    RAID_ADDRESS Address;

    //
    // Initialization to NULL
    //

    Irp = NULL;
    Srb = NULL;

    Address = RaidUnitGetAddress (Unit);
    ASSERT (StorCompareScsiAddress (Address, RaidNullAddress) != 0);
    
    //
    // Build a SRB for this request.
    //

    Srb = RaidAllocateSrb (Unit->DeviceObject);

    if (Srb == NULL) {
        Status = STATUS_NO_MEMORY;
        goto cleanup;
    }

    //
    // Build the SRB.
    //

    Srb->Length = sizeof (SCSI_REQUEST_BLOCK);
    Srb->Function = SRB_FUNCTION_RESET_DEVICE;
    Srb->PathId = Unit->Address.PathId;
    Srb->TargetId = Unit->Address.TargetId;
    Srb->Lun = 0;
    Srb->SrbFlags = SRB_FLAGS_NO_QUEUE_FREEZE |
                    SRB_FLAGS_BYPASS_FROZEN_QUEUE |
                    SRB_FLAGS_BYPASS_LOCKED_QUEUE;
    Srb->QueueTag = -1;
    Srb->DataBuffer = NULL;
    Srb->DataTransferLength = 0;
    Srb->OriginalRequest = Irp;
    Srb->TimeOutValue = max (MINIMUM_RESET_TIMEOUT, Unit->DefaultTimeout);

    //
    // Initialize the event we will wait on.
    //
    
    KeInitializeEvent (&Event,
                       NotificationEvent,
                       FALSE);
    //
    // Allocate and initialize the IRP for this request.
    //
    
    Irp = StorBuildSynchronousScsiRequest (Unit->DeviceObject,
                                           Srb,
                                           &Event,
                                           &IoStatus);

    
    if (Irp == NULL) {
        Status = STATUS_NO_MEMORY;
        goto cleanup;
    }


    //
    // Submit the to the logical unit. This request IS submitted through
    // the logical unit queuing logic.
    //

    Status = IoCallDriver (Unit->DeviceObject, Irp);

    if (Status == STATUS_PENDING) {
        KeWaitForSingleObject (&Event,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL);

        Status = IoStatus.Status;
    }

    //
    // NB: If successful, we should pause for RESET_HOLD_TIME
    // here.
    //

cleanup:

    if (Srb != NULL) {
        RaidFreeSrb (Srb);
        Srb = NULL;
    }

    return Status;
}


NTSTATUS
RaUnitStorageQueryDevicePropertyIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle IOCTL_STORAGE_QUERY_PROPERTY with PropertyId of
    StorageDeviceProperty sent to the LUN.

Arguments:

    Unit - Supplies the unit/pdo the ioctl is for.

    Irp - Supplies the IRP representing the IOCTL.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpStack;
    PSTORAGE_PROPERTY_QUERY Query;
    PVOID Buffer;
    ULONG BufferSize;

    PAGED_CODE();

    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    Query = Irp->AssociatedIrp.SystemBuffer;
    Buffer = Irp->AssociatedIrp.SystemBuffer;
    BufferSize = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;

    ASSERT (BufferSize >= FIELD_OFFSET (STORAGE_PROPERTY_QUERY, AdditionalParameters));

    switch (Query->QueryType) {

        case PropertyExistsQuery:
            Status = STATUS_SUCCESS;
            break;

        case PropertyStandardQuery:
            Status = RaGetUnitStorageDeviceProperty (Unit,
                                                     Buffer,
                                                     &BufferSize);
            if (NT_SUCCESS (Status)) {
                Irp->IoStatus.Information = BufferSize;
            } else {
                Irp->IoStatus.Information = 0;
            }
            break;

        default:
            Status = STATUS_NOT_SUPPORTED;
    }

    return RaidCompleteRequest (Irp,  Status);
}


NTSTATUS
RaUnitStorageQueryDeviceIdPropertyIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle IOCTL_STORAGE_QUERY_PROPERTY with PropertyId of
    StorageDeviceIdProperty sent to the LUN.

Arguments:

    Unit - Supplies the unit/pdo the ioctl is for.

    Irp - Supplies the IRP representing the IOCTL.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpStack;
    PSTORAGE_PROPERTY_QUERY Query;
    PVOID Buffer;
    ULONG BufferSize;

    PAGED_CODE();
    
    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    Query = Irp->AssociatedIrp.SystemBuffer;
    Buffer = Irp->AssociatedIrp.SystemBuffer;
    BufferSize = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;

    ASSERT (BufferSize >= FIELD_OFFSET (STORAGE_PROPERTY_QUERY, AdditionalParameters));
    
    //
    // Determine whether the Page 0x83 data is available for this unit.
    //

    if (Unit->Identity.DeviceId == NULL) {
        return RaidCompleteRequest (Irp,
                                    
                                    STATUS_NOT_SUPPORTED);
    }

    switch (Query->QueryType) {

        case PropertyExistsQuery:
            Status = STATUS_SUCCESS;
            break;

        case PropertyStandardQuery:
            Status = RaGetUnitStorageDeviceIdProperty (Unit,
                                                       Buffer, 
                                                       &BufferSize);
            if (NT_SUCCESS(Status)) {
                Irp->IoStatus.Information = BufferSize;
            }
            break;

        default:
            Status = STATUS_NOT_SUPPORTED;
    }

    return RaidCompleteRequest (Irp,  Status);
}


NTSTATUS
RaUnitStorageQueryPropertyIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle IOCTL_STORAGE_QUERY_PROPERTY sent to the lun.

Arguments:

    Unit - Logical unit to handle the ioctl.

    Irp - Query property IRP.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG BufferSize;
    PIO_STACK_LOCATION IrpStack;
    PSTORAGE_PROPERTY_QUERY Query;


    PAGED_CODE ();
    ASSERT_UNIT (Unit);

    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    Query = Irp->AssociatedIrp.SystemBuffer;    
    BufferSize = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;


    if (BufferSize < FIELD_OFFSET (STORAGE_PROPERTY_QUERY, AdditionalParameters)) {
        Irp->IoStatus.Information = 0;
        return RaidCompleteRequest (Irp,
                                    STATUS_INVALID_PARAMETER_1);
    }

    switch (Query->PropertyId) {

        case StorageDeviceProperty:
            Status = RaUnitStorageQueryDevicePropertyIoctl (Unit, Irp);
            break;

        case StorageDeviceIdProperty:
            Status = RaUnitStorageQueryDeviceIdPropertyIoctl (Unit, Irp);
            break;

        default:

            //
            // Send unknown property request down the stack.
            //
            
            IoSkipCurrentIrpStackLocation (Irp);
            Status = IoCallDriver (Unit->Adapter->DeviceObject, Irp);
    }

    return Status;
}

NTSTATUS
RaUnitUnknownIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    PAGED_CODE ();

    return RaidCompleteRequest (Irp,
                                STATUS_INVALID_DEVICE_REQUEST);
}


NTSTATUS
RaidUnitGetDeviceId(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PWSTR* DeviceIdBuffer
    )
{
    NTSTATUS Status;
    PWCHAR DeviceId;
    PCSCSI_DEVICE_TYPE DeviceType;
    CHAR VendorId [SCSI_VENDOR_ID_LENGTH + 1];
    CHAR ProductId [SCSI_PRODUCT_ID_LENGTH + 1];
    CHAR Revision [SCSI_REVISION_ID_LENGTH + 1];
    ULONG i;

    PAGED_CODE ();
    ASSERT_UNIT (Unit);

    DeviceId = RaidAllocatePool (PagedPool,
                                 DEVICE_ID_LENGTH * sizeof (WCHAR),
                                 ID_TAG,
                                 Unit->DeviceObject);

    if (DeviceId != NULL) {

        DeviceType = StorGetIdentityDeviceType (&Unit->Identity);

        StorGetIdentityVendorId (&Unit->Identity,
                                 VendorId,
                                 sizeof (VendorId),
                                 TRUE);

        StorGetIdentityProductId (&Unit->Identity,
                                  ProductId,
                                  sizeof (ProductId),
                                  TRUE);

        StorGetIdentityRevision (&Unit->Identity,
                                 Revision,
                                 sizeof (Revision),
                                 TRUE);

        swprintf (DeviceId,
             L"SCSI\\%hs&Ven_%hs&Prod_%hs&Rev_%hs",
             DeviceType->Name,
             VendorId,
             ProductId,
             Revision);

        RaFixupIds (DeviceId, FALSE);

        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_NO_MEMORY;
    }

    *DeviceIdBuffer = DeviceId;

    return Status;
}


NTSTATUS
RaidUnitGetInstanceId(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PWSTR* InstanceIdBuffer
    )
{
    NTSTATUS Status;
    PWCHAR InstanceId;
    ULONG Count;

    PAGED_CODE ();
    ASSERT_UNIT (Unit);

    InstanceId = RaidAllocatePool (PagedPool,
                                   INSTANCE_ID_LENGTH * sizeof (WCHAR),
                                   ID_TAG,
                                   Unit->DeviceObject);

    if (InstanceId != NULL) {

        Count = swprintf (InstanceId,
                          L"%x%x%x",
                          Unit->Address.PathId,
                          Unit->Address.TargetId,
                          Unit->Address.Lun
                          );

        //
        // Sanity check that we didn't overflow our buffer.
        //
        
        ASSERT ((Count + 1) < INSTANCE_ID_LENGTH);
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_NO_MEMORY;
    }

    *InstanceIdBuffer = InstanceId;

    return Status;
}


BOOLEAN
RaidUnitIsMultiPathSupported(
    IN PDRIVER_OBJECT DriverObject,        
    IN PINQUIRYDATA InquiryData
    )
/*++

Routine Description:

    This routine is used to determine whether the device represented by InquiryData is
    being supported by MPIO. 

Arguments:

    DriverObject - This driver's DrvObj. Contains the DriveObjectExtension.
    InquiryData - Scsi inquiry data.

Return Value:

    TRUE - If MPIO is installed for the device.

--*/
{
    PRAID_DRIVER_EXTENSION driverExt;
    UCHAR vendorId[9];
    UCHAR productId[17];
    BOOLEAN supported = FALSE;

    //
    // Check whether the device is even supported (disk).
    //

    if (InquiryData->DeviceType == DIRECT_ACCESS_DEVICE) {

        //
        // Get the driver object ext., which contains the supported list.
        //

        driverExt = IoGetDriverObjectExtension(DriverObject,
                                               DriverEntry);
        if (driverExt) {

            //
            // Get local null-terminated copies of the inquiry data.
            //
            
            RtlZeroMemory(&vendorId, 9);
            RtlZeroMemory(&productId, 17);
            
            RtlCopyMemory(vendorId, InquiryData->VendorId, 8);
            RtlCopyMemory(productId, InquiryData->ProductId, 16);

            //
            // Check to see whether this device is in the list.
            //

            supported = PortIsDeviceMPIOSupported(&driverExt->MPIOSupportedDeviceList,
                                                  vendorId,
                                                  productId);
        }    
    }
    
    return supported;
}

NTSTATUS
RaidUnitGetHardwareIds(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PWSTR* HardwareIdsBuffer
    )
{
    NTSTATUS Status;
    PWCHAR HardwareIds;
    ULONG Count;
    PWCHAR Buffer;
    PCSCSI_DEVICE_TYPE DeviceType;
    PINQUIRYDATA InquiryData;

    PAGED_CODE ();
    ASSERT_UNIT (Unit);

    HardwareIds = RaidAllocatePool (PagedPool,
                                    HARDWARE_ID_LENGTH * sizeof (WCHAR),
                                    ID_TAG,
                                    Unit->DeviceObject);
                                         

    if (HardwareIds != NULL) {

        Buffer = HardwareIds;
        InquiryData = StorGetIdentityInquiryData (&Unit->Identity);
        DeviceType = PortGetDeviceType (InquiryData->DeviceType);

        //
        // bus + device + vendor + product + revision
        //
        // For example: "SCSI\DiskSEAGATE_ST318451FC______0001"
        //
        //
        
        Count = swprintf (Buffer,
                          L"SCSI\\%hs%8.8hs%16.16hs%4.4hs",
                          DeviceType->Name,
                          InquiryData->VendorId,
                          InquiryData->ProductId,
                          InquiryData->ProductRevisionLevel);

        Buffer += (Count + 1);

        //
        // bus + device + vendor + product
        //
        // For example: "SCSI\DiskSEAGATE_ST318451FC______"
        //

        Count = swprintf (Buffer,
                          L"SCSI\\%hs%8.8hs%16.16hs",
                          DeviceType->Name,
                          InquiryData->VendorId,
                          InquiryData->ProductId);

        Buffer += (Count + 1);

        //
        // bus + device + vendor
        //
        // For example: "SCSI\DiskSEAGATE_"
        //

        Count = swprintf (Buffer,
                          L"SCSI\\%hs%8.8hs",
                          DeviceType->Name,
                          InquiryData->VendorId);

        Buffer += (Count + 1);

        //
        // bus + vendor + product + revision[0]
        //
        // For example: "SCSI\SEAGATE_ST318451FC______0"

        Count = swprintf (Buffer,
                          L"SCSI\\%8.8hs%16.16hs%hc",
                          InquiryData->VendorId,
                          InquiryData->ProductId,
                          InquiryData->ProductRevisionLevel[0]);

        Buffer += (Count + 1);

        //
        // vendor + product + revision[0]
        //
        // For example: "SEAGATE_ST318451FC______0___"
        //

        Count = swprintf (Buffer,
                          L"%8.8hs%16.16hs%hc",
                          InquiryData->VendorId,
                          InquiryData->ProductId,
                          InquiryData->ProductRevisionLevel[0]);
                          
        Buffer += (Count + 1);
        
        //
        // generic device
        //
        // For example: "GenDisk" or "MPIODisk" if mpio is supporting the device.
        // 
        // Determine whether this is a GenDisk or not.
        //
        if (RaidUnitIsMultiPathSupported(Unit->Adapter->DeviceObject->DriverObject,
                                         InquiryData)) {

            //
            // This is on the mpio support list. Build the MPIODisk Generic ID against
            // which mpdev.sys loads.
            //
            
            Count = swprintf (Buffer,
                              L"%hs",
                              "MPIODisk");
        } else {    

            //
            // Not mpio supported. Build the regular name (ie GenDisk).
            //

            Count = swprintf (Buffer,
                              L"%hs",
                              DeviceType->GenericName);
        }            

        Buffer += (Count + 1);

        *Buffer++ = UNICODE_NULL;
        RaFixupIds (HardwareIds, TRUE);
        Status = STATUS_SUCCESS;

        ASSERT ((LONG)(Buffer - HardwareIds) < HARDWARE_ID_LENGTH);

    } else {

        Status = STATUS_NO_MEMORY;
    }

    *HardwareIdsBuffer = HardwareIds;

    return Status;
}


NTSTATUS
RaidUnitGetCompatibleIds(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PWSTR* CompatibleIdsBuffer
    )
{
    NTSTATUS Status;
    PWCHAR CompatibleIds;
    PWCHAR Buffer;
    ULONG Count;
    PCSCSI_DEVICE_TYPE DeviceType;

    PAGED_CODE ();

    CompatibleIds = RaidAllocatePool (PagedPool,
                                      COMPATIBLE_ID_LENGTH * sizeof (WCHAR),
                                      ID_TAG,
                                      Unit->DeviceObject);

    if (CompatibleIds != NULL) {

        Buffer = CompatibleIds;
        DeviceType = StorGetIdentityDeviceType (&Unit->Identity);

        //
        // First is, SCSI\<DEVICE>
        //
        
        Count = swprintf (Buffer, L"SCSI\\%hs", DeviceType->Name);
        Buffer += (Count + 1);

        //
        // Second is SCSI\RAW
        //
        
        Count = swprintf (Buffer, L"SCSI\\RAW");
        Buffer += (Count + 1);

        //
        // Append the final UNICODE_NULL because this is a multi-sz string.
        //
        
        *Buffer++ = UNICODE_NULL;

        //
        // Remove invalid characters.
        //
        
        RaFixupIds (CompatibleIds, TRUE);

        //
        // Sanity check that we didn't overflow our allocated buffer.
        //
        
        ASSERT ((ULONG)(Buffer - CompatibleIds) < COMPATIBLE_ID_LENGTH);

        Status = STATUS_SUCCESS;

    } else {
        Status = STATUS_NO_MEMORY;
    }

    *CompatibleIdsBuffer = CompatibleIds;

    return Status;
}


NTSTATUS
RaGetUnitStorageDeviceProperty(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PSTORAGE_DEVICE_DESCRIPTOR DescriptorBuffer,
    IN OUT PULONG BufferLength
    )
/*++

Routine Description:

    Create a device descriptor based on the information in the device
    extension. Copy as much data as possible into the Decescriptor and
    update the DescriptorLength to indicate the number of bytes copied

Arguments:

    Unit - Supplies Unit we are querying property for.

    DescriptorBuffer - Pointer to a buffer where the data for this
            property will be copied. The buffer size is determined by the
            input value of the BufferLength parameter.

    BufferLength - On input, supplies the length of the buffer, on output
            return the number of bytes copied.

Return Value:

    NTSTATUS code.

--*/
{
    PRAID_DRIVER_EXTENSION Driver;
    PINQUIRYDATA InquiryData;
    PSTOR_SCSI_IDENTITY Identity;
    RAID_DEVICE_DESCRIPTOR Descriptor;
    ULONG Length;


    PAGED_CODE();
    ASSERT_UNIT (Unit);
    ASSERT (DescriptorBuffer != NULL);


    InquiryData = StorGetIdentityInquiryData (&Unit->Identity);

    Identity = &Unit->Identity;

    //
    // Zero the temporary descriptor buffer out. Note that since
    // we don't explicitly zero out or NULL-terminated strings
    // below, the zeroing is necessary.
    //

    RtlZeroMemory (&Descriptor, sizeof (Descriptor));

    //
    // Length is the number of bytes we will copy into the descriptor
    // buffer. The Size field in the storage descriptor is the size
    // of the descriptor we want to copy -- not the number of bytes
    // copied. This is important.
    //
    
    Length = min (((ULONG)sizeof (Descriptor)), *BufferLength);

    Descriptor.Storage.Version = sizeof (STORAGE_DEVICE_DESCRIPTOR);
    Descriptor.Storage.Size = sizeof (Descriptor);
    Descriptor.Storage.DeviceType = InquiryData->DeviceType;
    Descriptor.Storage.DeviceTypeModifier = InquiryData->DeviceTypeModifier;
    Descriptor.Storage.RemovableMedia = InquiryData->RemovableMedia;
    Descriptor.Storage.CommandQueueing = InquiryData->CommandQueue; 
    Descriptor.Storage.BusType = Unit->Adapter->Parameters.BusType;

    //
    // Copy the VendorId and initialize it's field offset.
    //
    
    RtlCopyMemory (Descriptor.VendorId,
                   InquiryData->VendorId,
                   sizeof (Descriptor.VendorId) - 1);

    Descriptor.Storage.VendorIdOffset =
            FIELD_OFFSET (RAID_DEVICE_DESCRIPTOR, VendorId);

    //
    // Copy the ProductId and initialize it's field offset.
    //
    
    RtlCopyMemory (Descriptor.ProductId,
                   InquiryData->ProductId,
                   sizeof (Descriptor.ProductId) - 1);

    Descriptor.Storage.ProductIdOffset =
            FIELD_OFFSET (RAID_DEVICE_DESCRIPTOR, ProductId);

    //
    // Copy the RevisionLevel and initialize it's offset.
    //

    RtlCopyMemory (Descriptor.ProductRevision,
                   InquiryData->ProductRevisionLevel,
                   sizeof (Descriptor.ProductRevision) - 1);

    Descriptor.Storage.ProductRevisionOffset =
            FIELD_OFFSET (RAID_DEVICE_DESCRIPTOR, ProductRevision);


    //
    // Copy the serial number.
    //
    
    if (Identity->SerialNumber.MaximumLength) {

        ASSERT(Identity->SerialNumber.Buffer);

        Descriptor.Storage.SerialNumberOffset = 
            FIELD_OFFSET (RAID_DEVICE_DESCRIPTOR, SerialNumber);

        RtlZeroMemory(Descriptor.SerialNumber, 
                      sizeof(Descriptor.SerialNumber));

        RtlCopyMemory(Descriptor.SerialNumber,
                      Identity->SerialNumber.Buffer,
                      sizeof (Identity->SerialNumber));
    } else {
        Descriptor.Storage.SerialNumberOffset = 0;
    }


    //
    // Copy the temporary descriptor back to the buffer, and update the
    // length parameter.
    //
    
    RtlCopyMemory (DescriptorBuffer, &Descriptor, Length);
    *BufferLength = Length;

    return STATUS_SUCCESS;
}

NTSTATUS
RaGetUnitStorageDeviceIdProperty (
    IN PRAID_UNIT_EXTENSION Unit,
    IN PSTORAGE_DEVICE_ID_DESCRIPTOR DescriptorBuffer,
    IN OUT PULONG BufferLength
    )
/*++

Routine Description:

    This routine builds the DEVICE_ID_DESCRIPTOR based on the raw 0x83 data for Unit,
    if the data is available.
   
    NOTE: This is pretty much ripped off from scsiport.

Arguments:

    Unit - The Logical Unit for which the descriptor is needed.
    DescriptorBuffer - storage for the return data.
    BufferLength - Available buffer size, updated to actual data size.

Return Value:

    INVALID_PARAMETER if BufferLength is too small.
    SUCCESS 

--*/
{
    PVPD_IDENTIFICATION_PAGE idPage = Unit->Identity.DeviceId;
    ULONG idOffset;

    ULONG maxLength = *BufferLength;
    PUCHAR destOffset;

    LONG identifierLength;
    ULONG identifierCount = 0;

    PAGED_CODE();

    ASSERT(DescriptorBuffer != NULL);
    ASSERT(Unit->Identity.DeviceId != NULL);

    if(maxLength < sizeof(STORAGE_DESCRIPTOR_HEADER)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Initialize the header of the descriptor.
    //

    RtlZeroMemory(DescriptorBuffer, maxLength);
    DescriptorBuffer->Version = sizeof(STORAGE_DEVICE_ID_DESCRIPTOR);
    DescriptorBuffer->Size = FIELD_OFFSET(STORAGE_DEVICE_ID_DESCRIPTOR, Identifiers);

    //
    // Prepare to copy the identifiers directly into the buffer.
    //

    destOffset = DescriptorBuffer->Identifiers;

    //
    // Walk through the id page.  Count the number of descriptors and
    // calculate the size of the descriptor page.
    //

    for (idOffset = 0; idOffset < idPage->PageLength;) {
        PVPD_IDENTIFICATION_DESCRIPTOR src;
        USHORT identifierSize;

        //
        // Get the next page 0x83 descriptor.
        // 
        src = (PVPD_IDENTIFICATION_DESCRIPTOR) &(idPage->Descriptors[idOffset]);

        //
        // Set the size - size of the 'header', plus the actual identifier.
        // 
        identifierSize = FIELD_OFFSET(STORAGE_IDENTIFIER, Identifier);
        identifierSize += src->IdentifierLength;

        //
        // Align the identifier size to 32-bits.
        //

        identifierSize += sizeof(ULONG);
        identifierSize &= ~(sizeof(ULONG) - 1);

        identifierCount += 1;

        DescriptorBuffer->Size += identifierSize;

        if (DescriptorBuffer->Size <= maxLength) {
            PSTORAGE_IDENTIFIER dest;

            //
            // There is remaining length in the buffer, so build the descriptor.
            // 
            dest = (PSTORAGE_IDENTIFIER) destOffset;

            dest->CodeSet = src->CodeSet;
            dest->Type = src->IdentifierType;
            dest->Association = src->Association;

            dest->IdentifierSize = src->IdentifierLength;
            dest->NextOffset = identifierSize;

            RtlCopyMemory(dest->Identifier,
                          src->Identifier,
                          src->IdentifierLength);

            destOffset += dest->NextOffset;
        }

        idOffset += sizeof(PVPD_IDENTIFICATION_DESCRIPTOR);
        idOffset += src->IdentifierLength;
    }

    if (*BufferLength >= FIELD_OFFSET(STORAGE_DEVICE_ID_DESCRIPTOR,
                                        Identifiers)) {

        DescriptorBuffer->NumberOfIdentifiers = identifierCount;
    }

    *BufferLength = min(DescriptorBuffer->Size, *BufferLength);

    return STATUS_SUCCESS;

}


VOID
RaidSetUnitPauseTimer(
    IN PRAID_UNIT_EXTENSION Unit,
    IN ULONG TimeoutInSeconds
    )
/*++

Routine Description:

    Pause the logical unit queue with a timeout.

Arguments:

    Unit - Logical unit to pause.

    Timeout - Timeout for the pause.

Return Value:

    None.

--*/
{
    BOOLEAN Reset;
    LOGICAL Resumed;
    LARGE_INTEGER LargeTimeout;

    LargeTimeout.QuadPart = TimeoutInSeconds;
    LargeTimeout.QuadPart *= RELATIVE_TIMEOUT;
    LargeTimeout.QuadPart *= SECONDS;

    Reset = KeSetTimer (&Unit->PauseTimer,
                        LargeTimeout,
                        &Unit->PauseTimerDpc);

    if (Reset) {

        //
        // The timer was already in use, which means we successfully
        // cancelled it. By cancelling it, we loose the dereference owned
        // by the timer routine. Perform that deref here.
        //

        Resumed = RaidResumeUnitQueue (Unit);

        //
        // It is theoritically possible that by the time we resumed the
        // LUN queue our timeout has already fired. (Short timeout period
        // coupled with long interrupt in between, maybe?) If this happens
        // we will resume the unit queue, so we have to restart it. I've
        // put a review here because I'd like to take a look at this case;
        // it would be very unusual indeed.
        
        if (Resumed) {
            REVIEW();
            RaidUnitRestartQueue (Unit);
        }
    }
}

                        
VOID
RaidCancelTimerResumeUnit(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Cancel the outstanding pause timer and resume the logical unit queue if
    necessary.

    This function will work correctly even if an already canceled timer is
    canceled.
    
Arguments:

    Unit - Unit to cancel the pause timer on.

Return Value:

    None.

--*/
{
    LOGICAL Resumed;
    BOOLEAN Canceled;
    
    //
    // Cancel the timeout counter.
    //
    
    Canceled = KeCancelTimer (&Unit->PauseTimer);

    //
    // If we were successful, resume the logical unit queues.
    //

    if (Canceled) {

        //
        // If the pause count hit zero, restart the LUN queue.
        //

        Resumed = RaidResumeUnitQueue (Unit);

        if (Resumed) {
            RaidUnitRestartQueue (Unit);
        }
    }
}


VOID
RaidUnitProcessBusyRequest(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PEXTENDED_REQUEST_BLOCK Xrb
    )
/*++

Routine Description:

    Process a request that has come to us as busy.

Arguments:

    Unit - Supplies the logical unit that this request was submitted to.

    Xrb - Supplies the request.

Return Value:

    None.

--*/
{
    PSCSI_REQUEST_BLOCK Srb;
    PIRP Irp;
    PEXTENDED_DEVICE_QUEUE ExQueue;
    PSTOR_IO_GATEWAY Gateway;
    RAID_IO_RESOURCES IoResources;
    LOGICAL Started;
    ULONG Flags;
    
    Srb = Xrb->Srb;
    Irp = Xrb->Irp;

    //
    // SRB_STATUS_BUSY signals an adapter is busy.
    //

    ASSERT (SRB_STATUS (Srb->SrbStatus) == SRB_STATUS_BUSY ||
            SRB_STATUS (Srb->SrbStatus) == SRB_STATUS_LINK_DOWN ||
            Srb->ScsiStatus == SCSISTAT_BUSY ||
            Srb->ScsiStatus == SCSISTAT_QUEUE_FULL);

    RaidUnitReleaseIrp (Irp, &IoResources);

    //
    // After releasing the Irp, we no longer have a Xrb to play with.
    //
    
    Xrb = NULL;

    //
    // Remove the IRP from the list of outstanding IRPs
    //
    
    RaidDeleteExDeviceQueueEntry (&Unit->IoQueue.DeviceQueue);

    //
    // Then resubmit it.
    //

    Flags = 0;
    
    //
    // Mark this as a bypass request if appropiate.
    //

    if (TEST_FLAG (Srb->SrbFlags, SRB_FLAGS_BYPASS_FROZEN_QUEUE) ||
        TEST_FLAG (Srb->SrbFlags, SRB_FLAGS_BYPASS_LOCKED_QUEUE)) {
        Flags |= EXQ_BYPASS_REQUEST;
    }

    //
    // If this is a solitary request, set the solitary request flag.
    //
    
    if (IsSolitaryRequest (Srb)) {
        Flags |= EXQ_SOLITARY_REQUEST;
    }

    Started = RaidStartIoPacket (&Unit->IoQueue,
                                 Irp,
                                 Flags,
                                 NULL,
                                 &IoResources);
                       

    if (!Started) {
        RaidUnitFreeIoResources (Unit, &IoResources);

        //
        // The queues need to be restarted in the case that
        //   (a) we were performing a solitary request and
        //   (b) there is a solitary pending
        //
        //    We may be able to do this differently, more elegantly.
        //

        RaidUnitRestartQueue (Unit);
    }
}


LOGICAL
INLINE
IsBusy(
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    return (SRB_STATUS (Srb->SrbStatus) == SRB_STATUS_BUSY ||
            Srb->ScsiStatus == SCSISTAT_BUSY ||
            Srb->ScsiStatus == SCSISTAT_QUEUE_FULL);
}

LOGICAL
INLINE
IsLinkDown(
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    return (SRB_STATUS (Srb->SrbStatus) == SRB_STATUS_LINK_DOWN);
}

VOID
RaUnitAsyncError(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PEXTENDED_REQUEST_BLOCK Xrb
    )
/*++

Routine Description:

    This routine handles errors asynchronous errors.

Arguments:

    Unit - Supplies Logical Unit that Xrb is for.

    Xrb - Supplies Xrb that caused an error.

Return Value:

    None.

--*/
{

    PIRP Irp;
    PSCSI_REQUEST_BLOCK Srb;
    BOOLEAN RestartQueues;

    ASSERT_XRB (Xrb);

    Irp = Xrb->Irp;
    Srb = Xrb->Srb;
    RestartQueues = FALSE;

    DebugScsi (("Unit %p Srb %p, generated err = %08x\n",
                  Unit,
                  Srb,
                  SRB_STATUS (Srb->SrbStatus)));

    //
    // If the request asked us to freeze the logical unit's queue and
    // the queue is not already frozen, freeze it.
    //
    // It is necessary to check if it's already frozen because some
    // requests can bypass the queue. Double freezing or locking of
    // the queue is not supported.
    //
    
    if (!TEST_FLAG (Srb->SrbFlags, SRB_FLAGS_NO_QUEUE_FREEZE) &&
        !RaidIsUnitQueueFrozen (Unit)) {

        //
        // Freeze the queue so the class driver has a chance to process
        // the error.
        //

        RaidFreezeUnitQueue (Unit);
        SET_FLAG (Srb->SrbStatus, SRB_STATUS_QUEUE_FROZEN);
    }

    //
    // Check for busy or link down.  In either case, we resubmit the request.
    // The request will be requeued and restarted later.
    //

    if (IsBusy (Srb) || IsLinkDown (Srb)) {
        RaidUnitProcessBusyRequest (Unit, Xrb);
        return;
    }

    //
    // Propagate the translated error condition in the IRP.
    //
    
    Irp->IoStatus.Status = RaidSrbStatusToNtStatus (Srb->SrbStatus);

    if (SRB_STATUS (Srb->SrbStatus) == SRB_STATUS_DATA_OVERRUN) {
        Irp->IoStatus.Information = Srb->DataTransferLength;
    } else {
        Irp->IoStatus.Information = 0;
    }

    //
    // Release any resources associated with the IRP.
    //

    RaidUnitReleaseIrp (Irp, NULL);

    //
    // Finally, complete the request.
    //
    
    DebugScsi (("Unit %p, Irp %p, completing = %08x\n",
                 Unit,
                 Irp,
                 Irp->IoStatus.Status));

    DbgLogRequest (LogRequestComplete,
                   Irp,
                   (PVOID)(ULONG_PTR)(Irp->IoStatus.Status),
                   (PVOID)(ULONG_PTR)(Srb->SrbStatus),
                   NULL);
                    
    RaidCompleteRequest (Irp, Irp->IoStatus.Status);

    RaidStartNextIoPacket (&Unit->IoQueue,
                           FALSE,
                           NULL,
                           &RestartQueues);

    if (RestartQueues) {
        RaidAdapterRestartQueues (Unit->Adapter);
    }
}


VOID
RaidUnitRestartQueue(
    IN PRAID_UNIT_EXTENSION Unit
    )
{
    RaidRestartIoQueue(&Unit->IoQueue); 
}


VOID
RaUnitAddToPendingList(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Add the specified IO request to the pending list.

Arguments:

    Unit - Logical unit whose event queue the IRP should be added to.

    Irp - Irp that should be added.

Return Value:

    None.

--*/
{
    PEXTENDED_REQUEST_BLOCK Xrb;

    Xrb = RaidXrbFromIrp (Irp);
    ASSERT (Xrb != NULL);
    ASSERT (Xrb->Srb != NULL);

    //
    // Signal that this XRB must be removed from the event queue.
    //
    
    Xrb->RemoveFromEventQueue = TRUE;
    StorInsertEventQueue (&Unit->PendingQueue,
                          &Xrb->PendingLink,
                          Xrb->Srb->TimeOutValue);
    
}


VOID
RaUnitRemoveFromPendingList(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Remove the specified element from the pending list.

Arguments:

    Unit - Logical unit whose pending list the IRP is on.

    Irp - Irp that should be removed.

Return Value:

    None.

--*/
{
    PEXTENDED_REQUEST_BLOCK Xrb;

    Xrb = RaidXrbFromIrp (Irp);
    ASSERT (Xrb != NULL);

    //
    // Only remove the IRP if the RemoveFromPendingQueue flag is still
    // set. Otherwise, somebody (purge routine) is likely holding the
    // event queue spinlock and we will hang. The element will be
    // automatically removed from the event queue as a part of the
    // purge routine.
    //
    
    if (Xrb->RemoveFromEventQueue) {
        StorRemoveEventQueue (&Unit->PendingQueue, &Xrb->PendingLink);
    }
}


BOOLEAN
RaidUnitIsEnumerated(
    IN PRAID_UNIT_EXTENSION Unit
    )
{
    //
    // This should be an atomic operation, so there is no need to
    // acquire the SlowLock.
    //
    
    return Unit->Flags.Enumerated;
}


BOOLEAN
RaidUnitSetEnumerated(
    IN PRAID_UNIT_EXTENSION Unit,
    IN BOOLEAN Enumerated
    )
{
    BOOLEAN PreviouslyEnumerated;
    KLOCK_QUEUE_HANDLE LockHandle;
    
    KeAcquireInStackQueuedSpinLock (&Unit->SlowLock, &LockHandle);
    PreviouslyEnumerated = Unit->Flags.Enumerated;
    Unit->Flags.Enumerated = Enumerated;
    KeReleaseInStackQueuedSpinLock (&LockHandle);

    return PreviouslyEnumerated;
}


PVOID
RaidGetKeyFromUnit(
    IN PSTOR_DICTIONARY_ENTRY Entry
    )
{
    PVOID Key;
    PRAID_UNIT_EXTENSION Unit;
    
    Unit = CONTAINING_RECORD (Entry,
                              RAID_UNIT_EXTENSION,
                              UnitTableLink);

    ASSERT_UNIT (Unit);

    Key = RaidAddressToKey (Unit->Address);

    return (PVOID) Key;
}


VOID
RaidHierarchicalResetWorkRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )

/*++

Routine Description:

    This function is called from a work-queue item, to perform a hierarchical
    bus reset.

Arguments:

    DeviceObject - Device object representing a logical unit.

    Context - The work-item to free when we've completed.

Return Value:

    None.

Environment:

    This function is in the reset path, therefore cannot be paged.

--*/

{
    PRAID_UNIT_EXTENSION Unit;
    PIO_WORKITEM WorkItem;
    
    Unit = DeviceObject->DeviceExtension;
    WorkItem = (PIO_WORKITEM)Context;
    ASSERT_UNIT (Unit);
    ASSERT (WorkItem != NULL);

    RaidUnitHierarchicalReset (Unit);
    IoFreeWorkItem (WorkItem);
}



VOID
RaidUnitPendingDpcRoutine(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    This routine is invoked every second to check if we have timed out
    

Arguments:

    Dpc - Dpc object.

    DeviceObject - Device object for the logical unit.

    SystemArgument1 - Not used.

    SystemArgument2 - Not used.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PRAID_UNIT_EXTENSION Unit;
    
    VERIFY_DISPATCH_LEVEL();

    Unit = (PRAID_UNIT_EXTENSION) DeviceObject->DeviceExtension;
    ASSERT_UNIT (Unit);


    //
    // Tick the outstanding timer. If an IO has timed out, we will
    // get back STATUS_IO_TIMEOUT, otherwise STATUS_SUCCESS.
    //
    
    Status = StorTickEventQueue (&Unit->PendingQueue);

    //
    // If we were successful, leave.
    //
    
    if (NT_SUCCESS (Status)) {
        return;
    }

    //
    // Otherwise, a request has timed out.
    //
    
    RaidUnitRequestTimeout (Unit);
}


VOID
RaidUnitRequestTimeout(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    This routine is called when we detect a request has timed out. We need
    to perform either a hierarchical reset or a bus reset.

Arguments:

    Unit - Logical unit that a request has timeout out on.

Return Value:

    None.

--*/
{
    RAID_ADDRESS Address;
    PIO_WORKITEM WorkItem;

    Address = RaidUnitGetAddress (Unit);
    
    DebugWarn (("WARNING: One or more I/Os timed out. Attempting to recover\n"));
    DebugWarn (("WARNING: by resetting %d %d %d\n",
                 (ULONG)Address.PathId,
                 (ULONG)Address.TargetId,
                 (ULONG)Address.Lun));

    //
    // NB: Is it necessary to log an event here?
    //
    
    //
    // We have an outstanding reset command which failed to complete
    // in the required time period. At this point, use the hammer
    // (synchronous bus reset) reset it.
    //
    
    if (Unit->ResetCount != 0) {
        DebugPrint (("ERROR: An outstanding reset command is queued to %d, %d, %d\n",
                      Address.PathId,
                      Address.TargetId,
                      Address.Lun));
        DebugPrint (("ERROR: Resetting the bus instead\n"));
        RaidAdapterResetBus (Unit->Adapter,
                             StorGetAddressPathId (Unit->Address));

        return ;
    }

    //
    // We cannot reset the logical unit at dispatch level because we need
    // to queue a synchronous request to the logical unit's device queue.
    // Therefore, queue a work item to do the reset for us. If we fail to
    // create a work-item, then fall back and do a full bus reset, because
    // we can do this synchronously at dispatch level.
    //
    // Note: if we add HwResetTarget and HwResetBus commands to the port
    // configuration information, then we could avoid having to queue
    // a work-item here.
    //

    WorkItem = IoAllocateWorkItem (Unit->DeviceObject);

    if (WorkItem != NULL) {
        IoQueueWorkItem (WorkItem,
                         RaidHierarchicalResetWorkRoutine,
                         CriticalWorkQueue,
                         WorkItem);
    } else {

        //
        // Failed to create a work-item, so fall back and reset the
        // entire bus.
        //

        RaidAdapterResetBus (Unit->Adapter,
                             StorGetAddressPathId (Unit->Address));
    }
}

NTSTATUS
RaidUnitHierarchicalReset(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Perform a hierarchical reset on the logical unit.

Arguments:

    Unit - Logical unit to reset.

Return Value:

    NTSTATUS code.

Environment:

    This function is in the reset path, and therefore may not be paged.

--*/
{
    NTSTATUS Status;

    PAGED_CODE();
    
    //
    // First, try to reset the logical unit.
    //
    
    Status = RaidUnitResetUnit (Unit);

    //
    // If that worked, we're done.
    //
    
    if (NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // Next, try to reset the target.
    //
    
    Status = RaidUnitResetTarget (Unit);

    //
    // That worked, we're done.
    //
    
    if (NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // A less severe form of reset failed to work properly. Give up,
    // and just reset the bus here.
    //
    
    Status = RaidAdapterResetBus (Unit->Adapter,
                                  StorGetAddressPathId (Unit->Address));

    return Status;
}



LOGICAL
RaidUnitNotifyHardwareGone(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    This routine is invoked by the enumeration code when a logical unit
    goes away.

Arguments:

    Unit - Logical unit that went away.

Return Value:

    TRUE - If PnP should be notified of the removal.

    FALSE - If PnP does not need to be notified.

--*/
{
    NTSTATUS Status;
    LOGICAL ChangeDetected;
    KIRQL OldIrql;

    ChangeDetected = FALSE;
    
    if (Unit->Flags.Present) {
        Unit->Flags.Present = FALSE;
        OldIrql = KeRaiseIrqlToDpcLevel ();
        Status = RaidUnitCancelPendingRequestsAsync (Unit);
        KeLowerIrql (OldIrql);
    }

    if (Unit->Flags.Enumerated) {
        ChangeDetected = TRUE;
    }

    return ChangeDetected;
}


NTSTATUS
RaidUnitCancelPendingRequestsAsync(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Asynchronously remove all queued requests from the logical unit. 

Arguments:

    Unit - Logical unit to remove queued requests for.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PIO_WORKITEM WorkItem;
    
    WorkItem = IoAllocateWorkItem (Unit->DeviceObject);

    if (WorkItem != NULL) {

        //
        // Acquire a remove lock so we are not removed before this event
        // can fire.
        //
        
        RaUnitAcquireRemoveLock (Unit, NULL);
        
        IoQueueWorkItem (WorkItem,
                         RaidCancelRequestsWorkRoutine,
                         CriticalWorkQueue,
                         WorkItem);
        Status = STATUS_SUCCESS;
    } else {
        //
        // Low memory: we failed to allocate the work item, so perform
        // the operation(s) synchronously.
        //
        REVIEW();
        Status = RaidUnitCancelPendingRequests (Unit);
    }

    return Status;
}



NTSTATUS
RaidCancelRequestsWorkRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )
/*++

Routine Description:

    Called from a work queue; this routine synchronously cancels all
    queued requests on a device queue.

Arguments:

    DeviceObject - Device object of queue to flush.

    Context - Context representing the work item.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PRAID_UNIT_EXTENSION Unit;
    PIO_WORKITEM WorkItem;
    KIRQL Irql;

    Unit = DeviceObject->DeviceExtension;
    WorkItem = (PIO_WORKITEM)Context;
    ASSERT_UNIT (Unit);
    ASSERT (WorkItem != NULL);

    Irql = KeRaiseIrqlToDpcLevel ();

    //
    // This should clear out the queue and return the already-setup failing
    // status.
    // 

    Status = RaidUnitCancelPendingRequests (Unit);

    //
    // Release the remove lock reference acquired before queuing the work
    // routine.
    //
    
    RaUnitReleaseRemoveLock (Unit, NULL);

    KeLowerIrql (Irql);

    IoFreeWorkItem (WorkItem);

    return Status;
}



NTSTATUS
RaidUnitCancelPendingRequests(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Synchronously cancel all pending requests and outstanding requests.

Arguments:

    Unit - Logical unit to cancel pending requests for.

Return Value:

    NTSTATUS code.

--*/
{
    PIRP Irp;
    PSCSI_REQUEST_BLOCK Srb;
    PVOID CompletionStatus;

    CompletionStatus = (PVOID) SRB_STATUS_NO_DEVICE;

    //
    // NOTE: We do NOT purge the outstanding queue. Instead, we allow these
    // to fail. Purging the outstanding queue is fraught with complexities
    // and race conditions. Instead, allow the requets to timeout, then
    // fail them when we retry.
    //

    //
    // Purge pending requets.
    //
    
    RaidPurgeIoQueue (&Unit->IoQueue,
                      RaidCancelIrp,
                      CompletionStatus);


    return STATUS_SUCCESS;
}



VOID
RaidUnitPauseTimerDpcRoutine(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context1,
    IN PVOID Context2
    )
/*++

Routine Description:

    This routine is called when a logical unit is un-paused.

Arguments:

    Dpc - The deferred procedure call this request is for.

    DeviceObject - The device object associated with the timer.

    Context1, Context2 - Unused.
    
Return Value:

    None.

--*/
{
    PRAID_UNIT_EXTENSION Unit;
    LOGICAL Resumed;

    VERIFY_DISPATCH_LEVEL();

    Unit = (PRAID_UNIT_EXTENSION) DeviceObject->DeviceExtension;
    ASSERT_UNIT (Unit);

    //
    // Timeout has expired, resume the IO queue.
    //
    
    Resumed = RaidResumeUnitQueue (Unit);

    //
    // If our pause count has hit zero, resume the logical unit queue.
    //
    
    if (Resumed) {
        RaidUnitRestartQueue (Unit);
    }
}

VOID
RaidUnitBusy(
    IN PRAID_UNIT_EXTENSION Unit,
    IN ULONG RequestsToComplete
    )
/*++

Routine Description:

    Put a logical unit into the busy state. The logical unit remains
    busy until it has completed the number of requests specified by
    RequestsToComplete or when it's outstanding queue reaches zero.

Arguments:

    Unit - Supplies the logical unit to make busy.

    RequestsToComplete - Specifies the number of requests to complete.

Return Value:

    NTSTATUS code

--*/
{
    RaidBusyIoQueue (&Unit->IoQueue, RequestsToComplete);
}

VOID
RaidUnitReady(
    IN PRAID_UNIT_EXTENSION Unit
    )
{
    RaidReadyIoQueue (&Unit->IoQueue);
    RaidUnitRestartQueue (Unit);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\srb.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    srb.h

Abstract:

    Declarations of the SRB object and it's related operations.
    
Author:

    Matthew D Hendel (math) 04-May-2000

Revision History:

--*/

#pragma once


#define XRB_SIGNATURE               (0x1F2E3D4C)
#define SRB_EXTENSION_SIGNATURE     (0x11FF22EE)

//
// Physical break value is the number of elements necessary in an SG list
// to map a 64K buffer.
//

#define PHYSICAL_BREAK_VALUE        (17)

#define SCATTER_GATHER_BUFFER_SIZE                              \
    (sizeof (SCATTER_GATHER_LIST) +                             \
     sizeof (SCATTER_GATHER_ELEMENT) * PHYSICAL_BREAK_VALUE)    \

//
// The srb completion routine is called when the io for a srb is
// completed.
//

typedef
VOID
(*XRB_COMPLETION_ROUTINE)(
    IN PEXTENDED_REQUEST_BLOCK Xrb
    );


//  
// The Extended Request Block (XRB) is the raid port's notion of an i/o
// request.  It wraps the srb by inserting itself into the
// OriginalRequest field of the SRB, adding fields we need to process the
// SRB. In SCSIPORT this is the SRB_DATA field.
//
  

typedef struct _EXTENDED_REQUEST_BLOCK {

    //
    // The first three fields are private XRB data, and should only be
    // accessed by XRB specific functions.
    //
    
    //
    // Signature value used to identify an XRB.
    //
    
    ULONG Signature;

    //
    // Pool this Xrb was allocated from.
    //

    PNPAGED_LOOKASIDE_LIST Pool;

    struct {

        //
        // The OwnedMdl flag signals to the XRB routines that the MDL is
        // allocated by the Port driver and needs to be freed. This flag
        // is for internal use only.
        //
        
        BOOLEAN OwnedMdl : 1;

        //
        // Should the XRB's completion routine remove the element from
        // the event queue, or will it be implicitly removed by, e.g.,
        // a purge routine.
        //
        
        BOOLEAN RemoveFromEventQueue : 1;
        
        //
        // While there is an XRB, the XRB state must track the IRP state.
        //
        
        UCHAR State : 3;

    };


    //
    // The remainder of the fields are publicly accessible.
    //

    //
    // The next element in the completed queue.
    //
    // Protected by: Interlocked access.
    //
    
    SLIST_ENTRY CompletedLink;

    //
    // The next element in the pending queue.
    //
    // Protected by: event queue spinlock.
    //
    // NOTE: this field is valid until we remove the element in the DPC
    // routine even though LOGICALLY the element is not on the pending
    // queue as soon as it is placed on the completed list.
    //
    
    STOR_EVENT_QUEUE_ENTRY PendingLink;
    
    //
    // The MDL assoicated with this SRB's DataBuffer.
    //
    
    PMDL Mdl;

    //
    // If this SRB supports Scatter/Gather IO, this will be the 
    // ScatterGather list.
    //
    
    PSCATTER_GATHER_LIST SgList;

    //
    // The MDL assocaited with the Remapped ScatterGather list.
    //

    PMDL RemappedSgListMdl;
    
    //
    // If the verifier is enabled, this is the remapped ScatterGather
    // list.
    //

    PSCATTER_GATHER_LIST RemappedSgList;

    //
    // The IRP this SRB is for.
    //

    PIRP Irp;

    //
    // Pointer back to the SRB this XRB is for.
    //

    PSCSI_REQUEST_BLOCK Srb;

    //
    // Data that is overwritten by raidport that should be restored
    // before completing the IRP.
    //
    
    struct {

        //
        // The OriginalRequest field from the srb. We use this field
        // to store the xrb when passing requests to the miniport.
        // The value needs to be saved so it can be restored when
        // we complete the request.
        //

        PVOID OriginalRequest;

        //
        // The DataBuffer field from the srb.
        //
        
        PVOID DataBuffer;

    } SrbData;
        

    //
    // The adapter or unit this request is for.
    //

    PRAID_ADAPTER_EXTENSION Adapter;

    //
    // The logical unit this request is for. May be NULL if this is
    // a request made by the adapter, for example, during enumeration.
    //
    
    PRAID_UNIT_EXTENSION Unit;


    //
    // Scatter/gather list buffer.
    //
        
    UCHAR ScatterGatherBuffer [ SCATTER_GATHER_BUFFER_SIZE ];

    //
    // Should the SRB be completed by the DPC
    //
    
    XRB_COMPLETION_ROUTINE CompletionRoutine;

    //
    // Data used by the different completion events
    //
    
    union {

        //
        // This is an event that a creator of a SRB can wait on when performing
        // synchronous IO.
        //

        KEVENT CompletionEvent;

    } u;

} EXTENDED_REQUEST_BLOCK, *PEXTENDED_REQUEST_BLOCK;





//
// Creation and destruction operations for XRBs.
//

PEXTENDED_REQUEST_BLOCK
RaidAllocateXrb(
    IN PNPAGED_LOOKASIDE_LIST List,
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
RaidFreeXrb(
    IN PEXTENDED_REQUEST_BLOCK,
    IN LOGICAL DispatchLevel
    );

VOID
RaidPrepareXrbForReuse(
    IN PEXTENDED_REQUEST_BLOCK Xrb,
    IN LOGICAL DispatchLevel
    );  
    
//
// Other operations for XRBS.
//

VOID
RaidXrbSetSgList(
    IN PEXTENDED_REQUEST_BLOCK Xrb,
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PSCATTER_GATHER_LIST SgList
    );


VOID
RaidXrbSetCompletionRoutine(
    IN PEXTENDED_REQUEST_BLOCK Xrb,
    IN XRB_COMPLETION_ROUTINE CompletionRoutine
    );
    
NTSTATUS
RaidBuildMdlForXrb(
    IN PEXTENDED_REQUEST_BLOCK Xrb,
    IN PVOID Buffer,
    IN SIZE_T BufferSize
    );

//
// Creation and destruction routines for SRBs.
//

PSCSI_REQUEST_BLOCK
RaidAllocateSrb(
    IN PVOID IoObject
    );

VOID
RaidFreeSrb(
    IN PSCSI_REQUEST_BLOCK Srb
    );

VOID
RaidPrepareSrbForReuse(
    IN PSCSI_REQUEST_BLOCK Srb
    );

NTSTATUS
RaidInitializeInquirySrb(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN PVOID Buffer,
    IN SIZE_T BufferSize
    );

PEXTENDED_REQUEST_BLOCK
RaidGetAssociatedXrb(
    IN PSCSI_REQUEST_BLOCK Srb
    );

//
// Managing SRB extensions.
//

PVOID
RaidAllocateSrbExtension(
    IN PRAID_FIXED_POOL Pool,
    IN ULONG QueueTag
    );

VOID
RaidFreeSrbExtension(
    IN PRAID_FIXED_POOL Pool,
    IN ULONG QueueTag
    );

//
// Other operations for SRBs and XRBs.
//

NTSTATUS
RaidSrbStatusToNtStatus(
    IN UCHAR SrbStatus
    );
    
VOID
RaidSrbMarkPending(
    IN PSCSI_REQUEST_BLOCK Srb
    );


VOID
RaidXrbSignalCompletion(
    IN PEXTENDED_REQUEST_BLOCK Xrb
    );

NTSTATUS
RaidInitializeReportLunsSrb(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN PVOID Buffer,
    IN SIZE_T BufferSize
    );


//
// The XRB states MUST be track the IRP states, if an IRP is present.
// The correct approach is to consolidate the IRP state and the XRB
// state into one state that lives in the IRP before allocating the XRB
// and in the XRB after allocating it.
//

//
// See util.h for definitions of the XRB states.
//

#define XrbUndefinedState          (0x00)
#define XrbPortProcessing          (0x01)
#define XrbWaitingIoQueueCallback  (0x02)
#define XrbMiniportProcessing      (0x03)
#define XrbPendingCompletion       (0x04)

VOID
INLINE
RaidSetXrbState(
    IN PEXTENDED_REQUEST_BLOCK Xrb,
    IN UCHAR XrbState
    )
{
    Xrb->State = XrbState;
}

UCHAR
INLINE
RaidGetXrbState(
    IN PEXTENDED_REQUEST_BLOCK Xrb
    )
{
    return Xrb->State;
}

LOGICAL
INLINE
RaidXrbIsCompleting(
    IN PEXTENDED_REQUEST_BLOCK Xrb
    )
{
    return (Xrb->State == XrbPendingCompletion);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\verify.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

	verify.h

Abstract:

	Header file for storport verifier functions.

Author:

	Bryan Cheung (t-bcheun) 29-August-2001

Revision History:

--*/


#pragma once


BOOLEAN
SpVerifierInitialization(
    VOID
    );

STORPORT_API
ULONG
StorPortInitializeVrfy(
    IN PVOID Argument1,
    IN PVOID Argument2,
    IN PHW_INITIALIZATION_DATA HwInitializationData,
    IN PVOID Unused
    );

STORPORT_API
VOID
StorPortFreeDeviceBaseVrfy(
	IN PVOID HwDeviceExtension,
	IN PVOID MappedAddress
	);

STORPORT_API
VOID
StorPortGetBusDataVrfy(
	IN PVOID DeviceExtension,
	IN ULONG BusDataType,
	IN ULONG SystemIoBusNumber,
	IN ULONG SlotNumber,
	IN PVOID Buffer,
	IN ULONG Length
	);

STORPORT_API
ULONG
StorPortSetBusDataByOffsetVrfy(
	IN PVOID DeviceExtension,
	IN ULONG BusDataType,
	IN ULONG SystemIoBusNumber,
	IN ULONG SlotNumber,
	IN PVOID Buffer,
	IN ULONG Offset,
	IN ULONG Length
	);

STORPORT_API
PVOID
StorPortGetDeviceBaseVrfy(
	IN PVOID HwDeviceExtension,
	IN INTERFACE_TYPE BusType,
	IN ULONG SystemIoBusNumber,
	IN PHYSICAL_ADDRESS IoAddress,
	IN ULONG NumberOfBytes,
	IN BOOLEAN InIoSpace
	);

STORPORT_API
PVOID
StorPortGetLogicalUnitVrfy(
	IN PVOID HwDeviceExtension,
	IN UCHAR PathId,
	IN UCHAR TargetId,
	IN UCHAR Lun
	);

#if 0
STORPORT_API
PSCSI_REQUEST_BLOCK
StorPortGetSrbVrfy(
	IN PVOID DeviceExtension,
	IN UCHAR PathId,
	IN UCHAR TargetId,
	IN UCHAR Lun,
	IN LONG QueueTag
	);
#endif

STORPORT_API
STOR_PHYSICAL_ADDRESS
StorPortGetPhysicalAddressVrfy(
	IN PVOID HwDeviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb,
	IN PVOID VirtualAddress,
	OUT ULONG *Length
	);

STORPORT_API
PVOID
StorPortGetVirtualAddressVrfy(
	IN PVOID HwDeviceExtension,	
	IN STOR_PHYSICAL_ADDRESS PhysicalAddress
	);

STORPORT_API
PVOID
StorPortGetUncachedExtensionVrfy(
	IN PVOID HwDeviceExtension,
	IN PPORT_CONFIGURATION_INFORMATION ConfigInfo,
	IN ULONG NumberOfBytes
	);

STORPORT_API
VOID
StorPortNotificationVrfy(
	IN SCSI_NOTIFICATION_TYPE NotificationType,
	IN PVOID HwDeviceExtension,
    ...
    );

STORPORT_API
VOID
StorPortLogErrorVrfy(
	IN PVOID HwDeviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb OPTIONAL,
	IN UCHAR PathId,
	IN UCHAR TargetId,
	IN UCHAR Lun,
	IN ULONG ErrorCode,
	IN ULONG UniqueId
	);

STORPORT_API
VOID 
StorPortCompleteRequestVrfy(
	IN PVOID HwDeviceExtension,
	IN UCHAR PathId,
	IN UCHAR TargetId,
	IN UCHAR Lun,
	IN UCHAR SrbStatus
	);

STORPORT_API
VOID	
StorPortMoveMemoryVrfy(
	IN PVOID WriteBuffer,
	IN PVOID ReadBuffer,
	IN ULONG Length
	);


STORPORT_API
VOID
StorPortStallExecutionVrfy(
	IN ULONG Delay
	);

STORPORT_API
STOR_PHYSICAL_ADDRESS
StorPortConvertUlongToPhysicalAddressVrfy(
    ULONG_PTR UlongAddress
    );

#if 0
STORPORT_API
STOR_PHYSICAL_ADDRESS
StorPortConvertUlong64ToPhysicalAddressVrfy(
	IN ULONG64 UlongAddress
	);

STORPORT_API
ULONG64
StorPortConvertPhysicalAddressToUlong64Vrfy(
	IN STOR_PHYSICAL_ADDRESS Address
	);

STORPORT_API
BOOLEAN
StorPortValidateRangeVrfy(
	IN PVOID HwDeviceExtension,
	IN INTERFACE_TYPE BusType,
	IN ULONG SystemIoBusNumber,
	IN STOR_PHYSICAL_ADDRESS IoAddress,
	IN ULONG NumberOfBytes,
	IN BOOLEAn InIoSpace
	);
#endif

STORPORT_API
VOID
StorPortDebugPrintVrfy(
	IN ULONG DebugPrintLevel,
	IN PCCHAR DebugMessage
    );

STORPORT_API
UCHAR
StorPortReadPortUcharVrfy(
    IN PVOID HwDeviceExtension,
    IN PUCHAR Port
    );

STORPORT_API
USHORT
StorPortReadPortUshortVrfy(
    IN PVOID HwDeviceExtension,
    IN PUSHORT Port
    );

STORPORT_API
ULONG
StorPortReadPortUlongVrfy(
    IN PVOID HwDeviceExtension,
    IN PULONG Port
    );

STORPORT_API
VOID
StorPortReadPortBufferUcharVrfy(
    IN PVOID HwDeviceExtension,
    IN PUCHAR Port,
    IN PUCHAR Buffer,
    IN ULONG  Count
    );

STORPORT_API
VOID
StorPortReadPortBufferUshortVrfy(
    IN PVOID HwDeviceExtension,
    IN PUSHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    );

STORPORT_API
VOID
StorPortReadPortBufferUlongVrfy(
    IN PVOID HwDeviceExtension,
    IN PULONG Port,
    IN PULONG Buffer,
    IN ULONG Count
    );

STORPORT_API
UCHAR
StorPortReadRegisterUcharVrfy(
    IN PVOID HwDeviceExtension,
    IN PUCHAR Register
    );

STORPORT_API
USHORT
StorPortReadRegisterUshortVrfy(
    IN PVOID HwDeviceExtension,
    IN PUSHORT Register
    );

STORPORT_API
ULONG
StorPortReadRegisterUlongVrfy(
    IN PVOID HwDeviceExtension,
    IN PULONG Register
    );

STORPORT_API
VOID
StorPortReadRegisterBufferUcharVrfy(
    IN PVOID HwDeviceExtension,
    IN PUCHAR Register,
    IN PUCHAR Buffer,
    IN ULONG  Count
    );

STORPORT_API
VOID
StorPortReadRegisterBufferUshortVrfy(
    IN PVOID HwDeviceExtension,
    IN PUSHORT Register,
    IN PUSHORT Buffer,
    IN ULONG Count
    );

STORPORT_API
VOID
StorPortReadRegisterBufferUlongVrfy(
    IN PVOID HwDeviceExtension,
    IN PULONG Register,
    IN PULONG Buffer,
    IN ULONG Count
    );

STORPORT_API
VOID
StorPortWritePortUcharVrfy(
    IN PVOID HwDeviceExtension,
    IN PUCHAR Port,
    IN UCHAR Value
    );

STORPORT_API
VOID
StorPortWritePortUshortVrfy(
    IN PVOID HwDeviceExtension,
    IN PUSHORT Port,
    IN USHORT Value
    );

STORPORT_API
VOID
StorPortWritePortUlongVrfy(
    IN PVOID HwDeviceExtension,
    IN PULONG Port,
    IN ULONG Value
    );

STORPORT_API
VOID
StorPortWritePortBufferUcharVrfy(
    IN PVOID HwDeviceExtension,
    IN PUCHAR Port,
    IN PUCHAR Buffer,
    IN ULONG  Count
    );

STORPORT_API
VOID
StorPortWritePortBufferUshortVrfy(
    IN PVOID HwDeviceExtension,
    IN PUSHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    );

STORPORT_API
VOID
StorPortWritePortBufferUlongVrfy(
    IN PVOID HwDeviceExtension,
    IN PULONG Port,
    IN PULONG Buffer,
    IN ULONG Count
    );

STORPORT_API
VOID
StorPortWriteRegisterUcharVrfy(
    IN PVOID HwDeviceExtension,
    IN PUCHAR Register,
    IN UCHAR Value
    );

STORPORT_API
VOID
StorPortWriteRegisterUshortVrfy(
    IN PVOID HwDeviceExtension,
    IN PUSHORT Register,
    IN USHORT Value
    );

STORPORT_API
VOID
StorPortWriteRegisterUlongVrfy(
    IN PVOID HwDeviceExtension,
    IN PULONG Register,
    IN ULONG Value
    );

STORPORT_API
VOID
StorPortWriteRegisterBufferUcharVrfy(
    IN PVOID HwDeviceExtension,
    IN PUCHAR Register,
    IN PUCHAR Buffer,
    IN ULONG  Count
    );

STORPORT_API
VOID
StorPortWriteRegisterBufferUshortVrfy(
    IN PVOID HwDeviceExtension,
    IN PUSHORT Register,
    IN PUSHORT Buffer,
    IN ULONG Count
    );

STORPORT_API
VOID
StorPortWriteRegisterBufferUlongVrfy(
    IN PVOID HwDeviceExtension,
    IN PULONG Register,
    IN PULONG Buffer,
    IN ULONG Count
    );

STORPORT_API
BOOLEAN
StorPortPauseDeviceVrfy(
	IN PVOID HwDeviceExtension,
	IN UCHAR PathId,
	IN UCHAR TargetId,
	IN UCHAR Lun,
	IN ULONG TimeOut
	);

STORPORT_API
BOOLEAN
StorPortResumeDeviceVrfy(
	IN PVOID HwDeviceExtension,
	IN UCHAR PathId,
	IN UCHAR TargetId,
	IN UCHAR Lun
	);

STORPORT_API
BOOLEAN
StorPortPauseVrfy(
	IN PVOID HwDeviceExtension,
	IN ULONG TimeOut
	);

STORPORT_API
BOOLEAN
StorPortResumeVrfy(
	IN PVOID HwDeviceExtension
	);

STORPORT_API
BOOLEAN
StorPortDeviceBusyVrfy(
	IN PVOID HwDeviceExtension,
	IN UCHAR PathId,
	IN UCHAR TargetId,
	IN UCHAR Lun,
	IN ULONG RequestsToComplete
	);

STORPORT_API
BOOLEAN
StorPortDeviceReadyVrfy(
	IN PVOID HwDeviceExtension,
	IN UCHAR PathId,
	IN UCHAR TargetId,
	IN UCHAR Lun
	);

STORPORT_API
BOOLEAN
StorPortBusyVrfy(
	IN PVOID HwDeviceExtension,
	IN ULONG RequestsToComplete
	);

STORPORT_API
BOOLEAN
StorPortReadyVrfy(
	IN PVOID HwDeviceExtension
	);

STORPORT_API
PSTOR_SCATTER_GATHER_LIST
StorPortGetScatterGatherListVrfy(
	IN PVOID DeviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb
	);

STORPORT_API
VOID
StorPortSynchronizeAccessVrfy(
	IN PVOID HwDeviceExtension,
	IN PSTOR_SYNCHRONIZED_ACCESS SynchronizedAccessRoutine,
	IN PVOID Context
	);

PVOID
RaidRemapBlock(
    IN PVOID BlockVa,
    IN ULONG BlockSize,
    OUT PMDL* Mdl
    );

VOID
RaidRemapCommonBufferForMiniport(
    IN PRAID_UNIT_EXTENSION Unit
    );

PMDL
INLINE
RaidGetRemappedSrbExt(
    PRAID_UNIT_EXTENSION Unit,
    PVOID Block
    );

typedef struct _SP_VA_MAPPING_INFO {
      PVOID OriginalSrbExtVa;
      ULONG SrbExtLen;
      PMDL SrbExtMdl;
      PVOID RemappedSrbExtVa;
} SP_VA_MAPPING_INFO, *PSP_VA_MAPPING_INFO;

#define GET_VA_MAPPING_INFO(unit, block)\
    (PSP_VA_MAPPING_INFO)((PUCHAR)(block) + ((unit)->CommonBufferSize - PAGE_SIZE))
    
PVOID
RaidGetOriginalSrbExtVa(
    PRAID_UNIT_EXTENSION Unit,
    PVOID Va
    );

PVOID
RaidPrepareSrbExtensionForUse(
    IN PRAID_UNIT_EXTENSION Unit,
    IN OUT PCCHAR SrbExtension
    );

PVOID
RaidAllocateSrbExtensionVrfy(
    IN PRAID_UNIT_EXTENSION Unit,
    IN ULONG QueueTag
    );

VOID
RaidInsertSrbExtension(
    PRAID_UNIT_EXTENSION Unit,
    PCCHAR SrbExtension
    );

PVOID
RaidRemapScatterGatherList(
    IN PSCATTER_GATHER_LIST ScatterList,
    IN PEXTENDED_REQUEST_BLOCK Xrb
    );

VOID
RaidFreeRemappedScatterGatherListMdl(
    IN PEXTENDED_REQUEST_BLOCK Xrb
    );

extern LOGICAL RaidVerifierEnabled;

LOGICAL
INLINE
StorIsVerifierEnabled(
	)
{
	return (RaidVerifierEnabled);
}

//
// STORPORT specified verifier error codes.
// 
#define STORPORT_VERIFIER_BAD_INIT_PARAMS          (0x1000)
#define STORPORT_VERIFIER_STALL_TOO_LONG           (0x1001)
#define STORPORT_VERIFIER_BAD_ACCESS_SEMANTICS     (0x1002)
#define STORPORT_VERIFIER_NOT_PNP_ASSIGNED_ADDRESS (0x1003)
#define STORPORT_VERIFIER_REQUEST_COMPLETED_TWICE  (0x1004)
#define STORPORT_VERIFIER_BAD_VIRTUAL_ADDRESS      (0x1005)

#define SP_VRFY_NONE                               ((ULONG)-1)

#define STORPORT_CONTROL_KEY L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\StorPort\\"
#define STORPORT_VERIFIER_KEY L"Verifier"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\util.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    util.c

Abstract:

    Utility functions for the RAID port driver.

Author:

    Matthew D Hendel (math) 13-Apr-2000

Environment:

    Kernel mode only.

Revision History:

--*/

#include "precomp.h"

#include <initguid.h>
#include <wdmguid.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RaSizeOfCmResourceList)
#pragma alloc_text(PAGE, RaDuplicateCmResourceList)
#pragma alloc_text(PAGE, RaFixupIds)
#pragma alloc_text(PAGE, RaCopyPaddedString)
#pragma alloc_text(PAGE, RaCreateTagList)
#pragma alloc_text(PAGE, RaDeleteTagList)
#pragma alloc_text(PAGE, RaInitializeTagList)
#endif // ALLOC_PRAGMA


//
// Global Data
//

LONG RaidPortNumber = -1;

#if 0
#ifdef ALLOC_PRAGMA
#pragma data_seg("PAGEDATA")
#endif


#ifdef ALLOC_PRAGMA
#pragma data_seg()
#endif
#endif

const RAID_ADDRESS RaidNullAddress = { -1, -1, -1, -1 };

NTSTATUS
RaQueryInterface(
    IN PDEVICE_OBJECT DeviceObject,
    IN PCGUID InterfaceType,
    IN USHORT InterfaceSize,
    IN USHORT InterfaceVersion,
    IN PINTERFACE Interface,
    IN PVOID InterfaceSpecificData
    )
    
/*++

Routine Description:

    This routine sends an IRP_MJ_PNP, IRP_MN_QUERY_INTERFACE to the
    driver specified by DeviceObject and synchronously waits for a reply.

Arguments:

    DeviceObject -

    InterfaceType -

    InterfaceSize -

    InterfaceVersion -

    InterfaceBuffer -

    InterfaceSpecificData - 

Return Value:

    NTSTATUS code.

--*/

{
    NTSTATUS Status;
    PIRP Irp;
    PIO_STACK_LOCATION IrpStack;


    Irp = IoAllocateIrp (DeviceObject->StackSize, FALSE);

    if (Irp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    IrpStack = IoGetNextIrpStackLocation (Irp);
    
    Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    IrpStack->MajorFunction = IRP_MJ_PNP;
    IrpStack->MinorFunction = IRP_MN_QUERY_INTERFACE;

    IrpStack->Parameters.QueryInterface.InterfaceType = InterfaceType;
    IrpStack->Parameters.QueryInterface.Size = InterfaceSize;
    IrpStack->Parameters.QueryInterface.Version = InterfaceVersion;
    IrpStack->Parameters.QueryInterface.Interface = Interface;
    IrpStack->Parameters.QueryInterface.InterfaceSpecificData = InterfaceSpecificData;

    Status = RaSendIrpSynchronous (DeviceObject, Irp);

    IoFreeIrp (Irp);
    Irp = NULL;

    return Status;
}

    
NTSTATUS
RaForwardIrpSynchronous(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    NTSTATUS Status;
    
    IoCopyCurrentIrpStackLocationToNext (Irp);
    Status = RaSendIrpSynchronous (DeviceObject, Irp);

    return Status;
}

VOID
INLINE
RaidInitializeKeTimeout(
    OUT PLARGE_INTEGER Timeout,
    IN ULONG Seconds
    )
/*++

Routine Description:

    Initialize a relative timeout value for use in KeWaitForXXXObject in
    terms of seconds.

Arguments:

    Timeout - Timeout variable to be initialized.

    Seconds - Number of seconds to wait before timing out.

Return Value:

    None.

--*/
{
    Timeout->QuadPart = (LONGLONG)(-1 * 10 * 1000 * (LONGLONG)1000 * Seconds);
}

NTSTATUS
RaForwardIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    NTSTATUS Status;
    
    IoCopyCurrentIrpStackLocationToNext (Irp);
    Status = IoCallDriver (DeviceObject, Irp);

    return Status;
}

NTSTATUS
RaForwardPowerIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    ASSERT (RaidMajorFunctionFromIrp (Irp) == IRP_MJ_POWER);
    PoStartNextPowerIrp (Irp);
    return RaForwardIrp (DeviceObject, Irp);
}
    

NTSTATUS
RiSignalCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    )
{
    KeSetEvent (Event, IO_NO_INCREMENT, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
RaSendIrpSynchronous(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    KEVENT Event;
    NTSTATUS Status;

    ASSERT (DeviceObject != NULL);
    ASSERT (Irp != NULL);
    ASSERT (Irp->StackCount >= DeviceObject->StackSize);


    KeInitializeEvent (&Event, SynchronizationEvent, FALSE);
    
    IoSetCompletionRoutine (Irp,
                            RiSignalCompletion,
                            &Event,
                            TRUE,
                            TRUE,
                            TRUE);
                            
    Status = IoCallDriver (DeviceObject, Irp);

    if (Status == STATUS_PENDING) {

#if DBG
        
        LARGE_INTEGER Timeout;

        RaidInitializeKeTimeout (&Timeout, 30);

        do {

            Status = KeWaitForSingleObject(&Event,
                                           Executive,
                                           KernelMode,
                                           FALSE,
                                           &Timeout);


            if (Status == STATUS_TIMEOUT) {

                //
                // This DebugPrint should almost always be investigated by the
                // party who sent the irp and/or the current owner of the irp.
                // Synchronous Irps should not take this long (currently 30
                // seconds) without good reason.  This points to a potentially
                // serious problem in the underlying device stack.
                //

                DebugPrint(("RaidSendIrpSynchronous (%p) irp %p did not "
                            "complete within %x seconds\n",
                            DeviceObject,
                            Irp,
                            30));

                ASSERT(!" - Irp failed to complete within 30 seconds - ");
            }


        } while (Status == STATUS_TIMEOUT);


#else  // !DBG

        KeWaitForSingleObject(&Event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

#endif // DBG

        Status = Irp->IoStatus.Status;
    }

    return Status;
}


NTSTATUS
StorWaitForSingleObject(
    IN PVOID Object,
    IN BOOLEAN Alertable,
    IN PLONGLONG Timeout
    )
/*++

Routine Description:

    Wait until the object is signaled.

Arguments:

    Object - Dispatcher object to wait for.

    Alertable - Whether the object is alertable (TRUE) or not (FALSE).

    Timeout - The timeout for the object.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    LARGE_INTEGER LargeTimeout;
    PLARGE_INTEGER LargeTimeoutPtr;
    
    if (Timeout == NULL) {
#if DBG
        RaidInitializeKeTimeout (&LargeTimeout, 30);
        LargeTimeoutPtr = &LargeTimeout;
#else
        LargeTimeoutPtr = NULL;
#endif
    } else {
        LargeTimeout.QuadPart = *Timeout;
        LargeTimeoutPtr = &LargeTimeout;
    }

    do {

        Status = KeWaitForSingleObject (Object,
                                        Executive,
                                        KernelMode,
                                        Alertable,
                                        LargeTimeoutPtr);
        if (Status == STATUS_TIMEOUT) {
            ASSERT (!"Failed timeout check\n");
        }
    
    } while ((LargeTimeoutPtr != NULL) && (Status == STATUS_TIMEOUT));

    return Status;
}

NTSTATUS
RaDuplicateUnicodeString(
    OUT PUNICODE_STRING DestString,
    IN PUNICODE_STRING SourceString,
    IN POOL_TYPE Pool,
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Duplicate one unicode string to another.

Arguments:

    DestString - Destination string; the destination will be NULL
        terminated on success.

    SourceString - Source string.

    Pool - Pool that the destination string should be allocated from.

    DeviceObject - Pointer to the devobj where an error should be
        logged in case of failure.

Return Value:

    NTSTATUS code.

--*/
{
    ASSERT (DestString != NULL);
    ASSERT (SourceString != NULL);

    //
    // Allocate the destination string.
    //
    
    DestString->Length = SourceString->Length;
    DestString->MaximumLength = SourceString->Length + sizeof (WCHAR);
    DestString->Buffer = RaidAllocatePool (Pool,
                                           DestString->MaximumLength,
                                           STRING_TAG,
                                           DeviceObject);

    if (DestString->Buffer == NULL) {
        return STATUS_NO_MEMORY;
    }

    //
    // Copy the string.
    //
    
    RtlCopyUnicodeString (DestString, SourceString);
    DestString->Buffer [DestString->Length / sizeof (WCHAR)] = UNICODE_NULL;

    return STATUS_SUCCESS;
}
                                                
                                                
INTERFACE_TYPE
RaGetBusInterface(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    NTSTATUS Status;
    GUID BusType;
    ULONG Size;

    Status = IoGetDeviceProperty( DeviceObject,
                                  DevicePropertyBusTypeGuid,
                                  sizeof (GUID),
                                  &BusType,
                                  &Size );

    if (!NT_SUCCESS (Status)) {
        return InterfaceTypeUndefined;
    }

    if (IsEqualGUID (&BusType, &GUID_BUS_TYPE_PCMCIA)) {
        return Isa;
    } else if (IsEqualGUID (&BusType, &GUID_BUS_TYPE_PCI)) {
        return PCIBus;
    } else if (IsEqualGUID (&BusType, &GUID_BUS_TYPE_ISAPNP)) {
        return Isa;
    } else if (IsEqualGUID (&BusType, &GUID_BUS_TYPE_EISA)) {
        return Eisa;
    }

    return InterfaceTypeUndefined;
}


ULONG
RaSizeOfCmResourceList(
    IN PCM_RESOURCE_LIST ResourceList
    )

/*++

Routine Description:

    This routine returns the size of a CM_RESOURCE_LIST.

Arguments:

    ResourceList - the resource list to be copied

Return Value:

    an allocated copy of the resource list (caller must free) or
    NULL if memory could not be allocated.

--*/

{
    ULONG size = sizeof(CM_RESOURCE_LIST);
    ULONG i;

    PAGED_CODE();

    for(i = 0; i < ResourceList->Count; i++) {

        PCM_FULL_RESOURCE_DESCRIPTOR fullDescriptor = &(ResourceList->List[i]);
        ULONG j;

        //
        // First descriptor is included in the size of the resource list.
        //

        if(i != 0) {
            size += sizeof(CM_FULL_RESOURCE_DESCRIPTOR);
        }

        for(j = 0; j < fullDescriptor->PartialResourceList.Count; j++) {

            //
            // First descriptor is included in the size of the partial list.
            //

            if(j != 0) {
                size += sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);
            }
        }
    }

    return size;
}

PCM_RESOURCE_LIST
RaDuplicateCmResourceList(
    IN POOL_TYPE PoolType,
    IN PCM_RESOURCE_LIST ResourceList,
    IN ULONG Tag
    )
/*++

Routine Description:

    This routine will attempt to allocate memory to copy the supplied
    resource list.  If sufficient memory cannot be allocated then the routine
    will return NULL.

Arguments:

    PoolType - the type of pool to allocate the duplicate from

    ResourceList - the resource list to be copied

    Tag - a value to tag the memory allocation with.  If 0 then untagged
          memory will be allocated.

Return Value:

    an allocated copy of the resource list (caller must free) or
    NULL if memory could not be allocated.

--*/
{
    ULONG size = sizeof(CM_RESOURCE_LIST);
    PVOID buffer;

    PAGED_CODE();

    size = RaSizeOfCmResourceList(ResourceList);

    buffer = ExAllocatePoolWithTag (PoolType, size, Tag);

    if (buffer != NULL) {
        RtlCopyMemory(buffer,
                      ResourceList,
                      size);
    }

    return buffer;
}


VOID
RaFixupIds(
    IN PWCHAR Id,
    IN BOOLEAN MultiSz
    )

/*++

Routine Description:

    This routine replaces any invalid PnP characters in the buffer passed
    in with the valid PnP character '_'.

Arguments:

    Id - A string or MULTI_SZ string that needs to be modified.

    MultiSz - TRUE if this is a MULTI_SZ string, FALSE if this is ax
            normal NULL terminated string.

Return Value:

    None.

--*/

{
    ULONG i;
    PAGED_CODE ();
    
    if (!MultiSz) {

        for (i = 0; Id[i] != UNICODE_NULL; i++) {

            if (Id[i] <= L' ' ||
                Id[i] > (WCHAR) 0x7F ||
                Id[i] == L',') {
            
                Id[i] = L'_';
            }
        }

    } else {

        for (i = 0;
             !(Id[i] == UNICODE_NULL && Id[i+1] == UNICODE_NULL);
             i++) {

            if (Id[i] == UNICODE_NULL) {
                continue;
            }
            
            if (Id[i] <= L' ' ||
                Id[i] > (WCHAR) 0x7F ||
                Id[i] == L',') {
            
                Id[i] = L'_';
            }
        }
    }
}


VOID
RaCopyPaddedString(
    OUT PCHAR Dest,
    IN ULONG DestLength,
    IN PCHAR Source,
    IN ULONG SourceLength
    )
/*++

Routine Description:

    This routine copies a padded string from Source to Dest, truncating
    any trailing spaces.

Arguments:

    Dest - Destination string where the string will be copied.

    DestLength - Length of the destination string.

    Source - Source string where the string will be copied from.

    SourceLength - Length of the source string.

Return Value:

    None.

--*/
{
    BOOLEAN FoundChar;
    LONG i;
    
    PAGED_CODE ();

    //
    // This function copies a padded string from source to dest, truncated
    // any trailing spaces.
    //
    
    ASSERT (SourceLength < DestLength);

    FoundChar = FALSE;
    Dest [SourceLength] = '\000';

    for (i = SourceLength - 1; i != -1 ; i--) {
        if (Source [i] != ' ') {
            FoundChar = TRUE;
            Dest [i] = Source [i];
        } else {
            if (!FoundChar) {
                Dest [i] = '\000';
            } else {
                Dest [i] = Source [i];
            }    
        }
    }
}



//
// Implementation of the QUEUE_TAG_LIST object.
//


#if DBG
VOID
ASSERT_TAG_LIST(
    IN PQUEUE_TAG_LIST TagList
    )
{
    //
    // The list lock should be held 
    //
    
    if (TagList->OutstandingTags != RtlNumberOfSetBits (&TagList->BitMap)) {
        DebugPrint (("OutstandingTags != NumberOfSetBits\n"));
        DebugPrint (("Outstanding = %d, NumberOfSetBits = %d\n",
                     TagList->OutstandingTags,
                     RtlNumberOfSetBits (&TagList->BitMap)));
        KdBreakPoint();
    }
}

#else

#define ASSERT_TAG_LIST(Arg)   (TRUE)

#endif

VOID
RaCreateTagList(
    OUT PQUEUE_TAG_LIST TagList
    )
/*++

Routine Description:

    Create a tagged queue list and initialize it to NULL.

Arguments:

    TagList - TagList to crate.

Return Value:

    NTSTATUS code.

--*/
{
    PAGED_CODE ();
    
    KeInitializeSpinLock (&TagList->Lock);
    TagList->Buffer = NULL;
}

VOID
RaDeleteTagList(
    IN PQUEUE_TAG_LIST TagList
    )
{

    PAGED_CODE ();
    
    if (TagList->Buffer) {
        RaidFreePool (TagList->Buffer, TAG_MAP_TAG);
    }

    DbgFillMemory (TagList, sizeof (*TagList), DBG_DEALLOCATED_FILL);
}
    

NTSTATUS
RaInitializeTagList(
    IN OUT PQUEUE_TAG_LIST TagList,
    IN ULONG TagCount,
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Initialize a queue tag list.

Arguments:

    TagList - List to initialize.

    Count - Number of tags to allocate in the tag list. Elements will be
            allocated in the range 0 - Count - 1 inclusive.

Return Value:

    NTSTATUS code.

--*/
{
    ULONG MapSize;

    PAGED_CODE ();
    
    MapSize = ((TagCount + 1) / 8) + 1;
    MapSize = ALIGN_UP (MapSize, ULONG);

    TagList->Buffer = RaidAllocatePool (NonPagedPool,
                                        MapSize,
                                        TAG_MAP_TAG,
                                        DeviceObject);
    if (TagList->Buffer == NULL) {
        return STATUS_NO_MEMORY;
    }
    
    TagList->Count = TagCount;
    RtlInitializeBitMap (&TagList->BitMap, TagList->Buffer, TagCount);
    RtlClearAllBits (&TagList->BitMap);

    TagList->Hint = 0;
    TagList->HighWaterMark = 0;
    TagList->OutstandingTags = 0;

    return STATUS_SUCCESS;
}

ULONG
RaAllocateSpecificTag(
    IN OUT PQUEUE_TAG_LIST TagList,
    IN ULONG SpecificTag
    )
/*++

Routine Description:

    Allocate a specific tag in the tag list.

Arguments:

    TagList - Pointer to the tag list.

    SpecificTag - Specific tag to allocate.

Return Value:

    Tag or 0xFFFFFFFF if the tag could not be allocated.

--*/
{
    ULONG AllocatedTag;
    KLOCK_QUEUE_HANDLE LockHandle;
    
    KeAcquireInStackQueuedSpinLock (&TagList->Lock, &LockHandle);

    ASSERT_TAG_LIST (TagList);

    //
    // If the bit is free, set it and return.
    //
    
    if (!RtlTestBit (&TagList->BitMap, SpecificTag)) {
        RtlSetBit (&TagList->BitMap, SpecificTag);
        AllocatedTag = SpecificTag;
        TagList->OutstandingTags++;
    } else {
        AllocatedTag = -1;
    }
    KeReleaseInStackQueuedSpinLock (&LockHandle);

    return AllocatedTag;
}
    
ULONG
RaAllocateTag(
    IN OUT PQUEUE_TAG_LIST TagList
    )
/*++

Routine Description:

    Allocate a tag from the tag list and return it. Return -1 if no tag
    is available.
    
Arguments:

    TagList - Tag list that the tag should be allocated from.

Return Value:

    Allocated tag value or -1 for failure.

--*/
{
    ULONG QueueTag;
    KLOCK_QUEUE_HANDLE LockHandle;

    KeAcquireInStackQueuedSpinLock (&TagList->Lock, &LockHandle);

    //
    // Verify that the tag list is consistent.
    //
    
    ASSERT_TAG_LIST (TagList);
    
    //
    // Find the first clear tag in the tag bitmap,
    //

    //
    // NB: RAID 150434: when the bitmap is nearly full and the HintIndex
    // is non-zero, RtlFindClearBitsXXX can fail incorrectly. Until this
    // is resolved use a HintIndex of zero to work-around the bug.
    //
    
    QueueTag = RtlFindClearBitsAndSet (&TagList->BitMap,
                                       1,
                                       TagList->Hint);

#if DBG

    //
    // NB: Remove this test code when RtlFindClearBitsAndSet is working
    // properly.
    //

    if (QueueTag == -1) {
        ULONG i;
        
        KdBreakPoint();

        QueueTag = RtlFindClearBits(&TagList->BitMap, 1, TagList->Hint);
        QueueTag = RtlFindClearBits(&TagList->BitMap, 1, 0);

        for (i = 0; i < TagList->Count; i++) {
            ASSERT (RtlTestBit (&TagList->BitMap, i) == FALSE);
        }
    }

#endif

    //
    // In the current STORPORT usage, we will never request a queue
    // tag unless one is available (hence, QueueTag will never be
    // -1). This conditional protects us if this assumption changes in
    // the future.
    //
    
    if (QueueTag != -1) {
    
        //
        // The Hint value is the next point in the list where we should
        // begin our search.
        //

        TagList->Hint = (QueueTag + 1) % TagList->Count;

        //
        // Update the number of outstanding tags, and, if we're above the
        // highwater mark for the taglist, the maximum number of outstanding
        // tags we had pending at one time.
        //

        TagList->OutstandingTags++;

        if (TagList->OutstandingTags > TagList->HighWaterMark) {
            TagList->HighWaterMark = TagList->OutstandingTags;
        }
    }

    KeReleaseInStackQueuedSpinLock (&LockHandle);

    return QueueTag;
}

VOID
RaFreeTag(
    IN OUT PQUEUE_TAG_LIST TagList,
    IN ULONG QueueTag
    )
/*++

Routine Description:

    Free a tag previously allocated by RaAllocateTag.

Arguments:

    TagList - List to free tag to.

    QueueTag - Tag to free.

Return Value:

    None.

--*/
{
    KLOCK_QUEUE_HANDLE LockHandle;
    
    KeAcquireInStackQueuedSpinLock (&TagList->Lock, &LockHandle);

    //
    // We should never attempt to free a tag that we haven't allocated.
    //
    
    ASSERT (RtlTestBit (&TagList->BitMap, QueueTag));
    RtlClearBit (&TagList->BitMap, QueueTag);

    ASSERT (TagList->OutstandingTags != 0);
    TagList->OutstandingTags--;

    //
    // Verify the tag list's consistency.
    //
    
    ASSERT_TAG_LIST (TagList);

    KeReleaseInStackQueuedSpinLock (&LockHandle);
}

#if 0

BOOLEAN
RaidGetModuleName(
    IN PVOID Address,
    IN OUT PANSI_STRING ModuleName
    )
/*++

Routine Description:

    Get a module name from a code address within the module.

Arguments:

    Address - Code address within a module.

    ModuleName - Supplies a pointer to an ansi string where the
            module name will be stored.

Return Value:

    None.

--*/
{
    PAGED_CODE ();
    
    Status = ZwQuerySystemInformation (SystemModuleInformation,
                                       ModuleInfo,
                                       RequiredLength,
                                       &RequiredLength );

    if (Status != STATUS_INFO_LENGTH_MISMATCH) {
        return FALSE;
    }
    
    ModuleList = RaidAllocatePool (DeviceObject,
                                   PagedPool,
                                   RequiredLength,
                                   RAID_TAG);

    if (!ModuleList) {
        return FALSE;
    }
    
    Status = ZwQuerySystemInformation (SystemModuleInformation,
                                       ModuleInfo,
                                       RequiredLength,
                                       &RequiredLength);
                                               
    if (!NT_SUCCESS (Status)) {
        RaidFreePool (ModuleList, RAID_TAG);
        return FALSE;
    }

    //
    // Walk the module list, searching for an address that matches.
    //
    
    for (i = 0; i < ModuleList->NumberOfModules; i++) {

        Module = &ModuleList[i];

        //
        // If the address is in range
        //
        
        if (Module->ImageBase <= Address &&
            Address < Module->ImageBase + Module->ImageSizs) {

            strcpy (Buffer, ModuleInfo->Modules[i].FullPathName[....]);
        }
    }

}

#endif



NTSTATUS
RaidSrbStatusToNtStatus(
    IN UCHAR SrbStatus
    )
/*++

Routine Description:

    Translate a SCSI Srb status to an NT Status code.

Arguments:

    SrbStatus - Supplies the srb status code to translate.

Return Value:

    NTSTATUS code.

--*/
{
    switch (SRB_STATUS(SrbStatus)) {

        case SRB_STATUS_BUSY:
            return STATUS_DEVICE_BUSY;

        case SRB_STATUS_SUCCESS:
            return STATUS_SUCCESS;

        case SRB_STATUS_INVALID_LUN:
        case SRB_STATUS_INVALID_TARGET_ID:
        case SRB_STATUS_NO_DEVICE:
        case SRB_STATUS_NO_HBA:
            return STATUS_DEVICE_DOES_NOT_EXIST;

        case SRB_STATUS_COMMAND_TIMEOUT:
        case SRB_STATUS_TIMEOUT:
            return STATUS_IO_TIMEOUT;
            
        case SRB_STATUS_SELECTION_TIMEOUT:
            return STATUS_DEVICE_NOT_CONNECTED;

        case SRB_STATUS_BAD_FUNCTION:
        case SRB_STATUS_BAD_SRB_BLOCK_LENGTH:
            return STATUS_INVALID_DEVICE_REQUEST;

        case SRB_STATUS_DATA_OVERRUN:
            return STATUS_BUFFER_OVERFLOW;

        default:
            return STATUS_IO_DEVICE_ERROR;
    }
}

UCHAR
RaidNtStatusToSrbStatus(
    IN NTSTATUS Status
    )
/*++

Routine Description:

    Translate an NT status value into a SCSI Srb status code.

Arguments:

    Status - Supplies the NT status code to translate.

Return Value:

    SRB status code.

--*/
{
    switch (Status) {

        case STATUS_DEVICE_BUSY:
            return SRB_STATUS_BUSY;

        case STATUS_DEVICE_DOES_NOT_EXIST:
            return SRB_STATUS_NO_DEVICE;

        case STATUS_IO_TIMEOUT:
            return SRB_STATUS_TIMEOUT;

        case STATUS_DEVICE_NOT_CONNECTED:
            return SRB_STATUS_SELECTION_TIMEOUT;

        case STATUS_INVALID_DEVICE_REQUEST:
            return SRB_STATUS_BAD_FUNCTION;

        case STATUS_BUFFER_OVERFLOW:
            return SRB_STATUS_DATA_OVERRUN;

        default:
            if (NT_SUCCESS (Status)) {
                return SRB_STATUS_SUCCESS;
            } else {
                return SRB_STATUS_ERROR;
            }
    }
}

        
NTSTATUS
RaidAllocateAddressMapping(
    IN PMAPPED_ADDRESS* ListHead,
    IN PHYSICAL_ADDRESS Address,
    IN PVOID MappedAddress,
    IN ULONG NumberOfBytes,
    IN ULONG BusNumber,
    IN PVOID IoObject
    )
/*++

Routine Description:

    We need to maintain a list of mapped addresses for two reasons:

        1) Because ScsiPortFreeDeviceBase doesn't take as a parameter
            the number of bytes to unmap.

        2) For crashdump to know whether it needs to map the address or
            whether it can reuse an already mapped address.

    Becase diskdump uses the MAPPED_ADDRESS structure, we must maintain
    the address list as a list of MAPPED_ADDRESS structures.
    
Arguments:

    ListHead - Head of the list to add the address mapping to.

    Address - Physical address of address to add.

    MappedAddress - Virtual address of address to add.

    NumberOfBytes - Number of bytes in the range.

    BusNumber - The system bus number this region is for.

Return Value:

    NTSTATUS code.

--*/
{
    PMAPPED_ADDRESS Mapping;

    Mapping = RaidAllocatePool (NonPagedPool,
                                sizeof (MAPPED_ADDRESS),
                                MAPPED_ADDRESS_TAG,
                                IoObject);

    if (Mapping == NULL) {
        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory (Mapping, sizeof (MAPPED_ADDRESS));

    Mapping->NextMappedAddress = *ListHead;
    *ListHead = Mapping;

    Mapping->IoAddress = Address;
    Mapping->MappedAddress = MappedAddress;
    Mapping->NumberOfBytes = NumberOfBytes;
    Mapping->BusNumber = BusNumber;

    return STATUS_SUCCESS;
}
                                           

NTSTATUS
RaidFreeAddressMapping(
    IN PMAPPED_ADDRESS* ListHead,
    IN PVOID MappedAddress
    )
/*++

Routine Description:

    Free a mapped address previously allocated by RaidAllocateMappedAddress.

Arguments:

    ListHead - Address list for the address to free.

    MappedAddress - Address to free.

Return Value:

    NTSTATUS code.

--*/
{
    PMAPPED_ADDRESS* MappingPtr;
    PMAPPED_ADDRESS Mapping;

    PAGED_CODE ();
    
    for (MappingPtr = ListHead;
        *MappingPtr != NULL;
         MappingPtr = &(*MappingPtr)->NextMappedAddress) {

        if ((*MappingPtr)->MappedAddress == MappedAddress) {

            Mapping = *MappingPtr;

            MmUnmapIoSpace (Mapping, Mapping->NumberOfBytes);

            *MappingPtr = Mapping->NextMappedAddress;
            DbgFillMemory (Mapping, sizeof (MAPPED_ADDRESS), DBG_DEALLOCATED_FILL);
            RaidFreePool (Mapping,
                               MAPPED_ADDRESS_TAG);
                                

            return STATUS_SUCCESS;
        }
    }


    return STATUS_NOT_FOUND;
}
    

NTSTATUS
RaidHandleCreateCloseIrp(
    IN DEVICE_STATE DeviceState,
    IN PIRP Irp
    )
/*++

Routine Description:

    Common create logic for Adapter and Unit objects.

Arguments:

    DeviceState - 

    Irp -

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    
    PAGED_CODE ();

    ASSERT (RaidMajorFunctionFromIrp (Irp) == IRP_MJ_CREATE ||
            RaidMajorFunctionFromIrp (Irp) == IRP_MJ_CLOSE);
    
    if (DeviceState == DeviceStateDeleted ||
        DeviceState == DeviceStateDisabled) {

        Status = STATUS_DELETE_PENDING;
        Irp->IoStatus.Information = 0;

    } else {
        Status = STATUS_SUCCESS;
    }

    return RaidCompleteRequest (Irp, Status);
}



VOID
RaidLogAllocationFailure(
    IN PDEVICE_OBJECT DeviceObject,
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    )
{
    PRAID_ALLOCATION_ERROR Error;

    Error = IoAllocateErrorLogEntry (DeviceObject,
                                     sizeof (RAID_ALLOCATION_ERROR));

    if (Error == NULL) {
        InterlockedIncrement (&RaidUnloggedErrors);
    } else {
        
        Error->Packet.SequenceNumber = 0;
        Error->Packet.MajorFunctionCode = 0;
        Error->Packet.RetryCount = 0;

        Error->Packet.ErrorCode = IO_WARNING_ALLOCATION_FAILED;
        Error->Packet.UniqueErrorValue = RAID_ERROR_NO_MEMORY;
        Error->Packet.FinalStatus = STATUS_NO_MEMORY;
        Error->Packet.DumpDataSize = sizeof (RAID_ALLOCATION_ERROR) -
                sizeof (IO_ERROR_LOG_PACKET);
        Error->PoolType = PoolType;
        Error->NumberOfBytes = NumberOfBytes;
        Error->Tag = Tag;

        IoWriteErrorLogEntry (&Error->Packet);
    }
}


PVOID
RaidAllocatePool(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag,
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Allocate memory from pool and log an error in case of failure.

Arguments:

    DeviceObject -

    PoolType -

    NumberOfBytes -

    Tag - 

Return Value:

    Non-NULL if the allocation succeeded.

    NULL if the allocation failed.

--*/
{
    PVOID Data;
     
    ASSERT (KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT (DeviceObject != NULL);
    
    Data = ExAllocatePoolWithTag (PoolType, NumberOfBytes, Tag);

    if (Data == NULL) {
        RaidLogAllocationFailure (DeviceObject,
                                  PoolType,
                                  NumberOfBytes,
                                  Tag);
    }

    return Data;
}

ULONG
RaidScsiErrorToIoError(
    IN ULONG ErrorCode
    )
/*++

Routine Description:

    Translate a SCSIPORT SP error to an IO error.

Arguments:

    ErrorCode - SCSI-port specific error code.

Return Value:

    IO-specific error code.

--*/
{
    switch (ErrorCode) {

        case SP_BUS_PARITY_ERROR:
            return IO_ERR_PARITY;
            
        case SP_BUS_TIME_OUT:
            return IO_ERR_TIMEOUT;

        case SP_IRQ_NOT_RESPONDING:
            return IO_ERR_INCORRECT_IRQL;

        case SP_BAD_FW_ERROR:
            return IO_ERR_BAD_FIRMWARE;

        case SP_BAD_FW_WARNING:
            return IO_ERR_BAD_FIRMWARE;

        case SP_PROTOCOL_ERROR:
        case SP_UNEXPECTED_DISCONNECT:
        case SP_INVALID_RESELECTION:
        case SP_INTERNAL_ADAPTER_ERROR:
        default:
            return IO_ERR_CONTROLLER_ERROR;
    }
}

PVOID
RaidGetSystemAddressForMdl(
    IN PMDL Mdl,
    IN MM_PAGE_PRIORITY Priority,
    IN PVOID DeviceObject
    )
{
    PVOID SystemAddress;

    
    SystemAddress = MmGetSystemAddressForMdlSafe (Mdl, Priority);

    if (SystemAddress == NULL) {

        //
        // Log an allocation failure here.
        //
        
        NYI();
    }

    return SystemAddress;
}
        

NTSTATUS
StorCreateScsiSymbolicLink(
    IN PUNICODE_STRING DeviceName,
    OUT PULONG PortNumber OPTIONAL
    )
/*++

Routine Description:

    Create the appropiate symbolic link between the device name and
    the SCSI device name.

Arguments:

    DeviceName - Supplies the name of the device.

    PortNumber - Supplies a buffer where SCSI port number will be
        returned upon success.

Return Value:

    NTSTATUS code.

--*/
{
    ULONG i;
    NTSTATUS Status;
    UNICODE_STRING ScsiLinkName;
    WCHAR Buffer[64];

    PAGED_CODE();

    for (i = 0; ; i++) {

        swprintf (Buffer, L"\\Device\\ScsiPort%d", i);
        RtlInitUnicodeString (&ScsiLinkName, Buffer);
        Status = IoCreateSymbolicLink (&ScsiLinkName, DeviceName);

        if (Status == STATUS_SUCCESS) {
            break;
        }

        if (Status != STATUS_OBJECT_NAME_COLLISION) {
            return Status;
        }
    }

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    swprintf (Buffer, L"\\DosDevices\\Scsi%d:", i);
    RtlInitUnicodeString (&ScsiLinkName, Buffer);
    IoCreateSymbolicLink (&ScsiLinkName, DeviceName);

    //
    // NB: Why doesn't this need to be synchronized?
    //
    
    IoGetConfigurationInformation()->ScsiPortCount++;

    if (PortNumber) {
        *PortNumber = i;
    }

    return Status;
}


NTSTATUS
StorDeleteScsiSymbolicLink(
    IN ULONG PortNumber
    )
/*++

Routine Description:

    Delete the SCSI symbolic link name created by StorCreateScsiSymbolicLink.

Arguments:

    PortNumber - Port number returned by StorCreateScsiSymbolicLink.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    WCHAR Buffer[64];
    UNICODE_STRING ScsiLinkName;

    //
    // Delete \Device\ScsiPortN name.
    //
    
    swprintf (Buffer, L"\\Device\\ScsiPort%d", PortNumber);
    RtlInitUnicodeString (&ScsiLinkName, Buffer);
    Status = IoDeleteSymbolicLink (&ScsiLinkName);
    ASSERT (NT_SUCCESS (Status));

    //
    // Delete \DosDevices\ScsiN name.
    //
    
    swprintf (Buffer, L"\\DosDevices\\Scsi%d:", PortNumber);
    RtlInitUnicodeString (&ScsiLinkName, Buffer);
    IoDeleteSymbolicLink (&ScsiLinkName);
    ASSERT (NT_SUCCESS (Status));

    return STATUS_SUCCESS;
}

ULONG
RaidCreateDeviceName(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PUNICODE_STRING DeviceName
    )
{
    WCHAR Buffer[32];
    UNICODE_STRING TempDeviceName;
    ULONG PortNumber;

    PAGED_CODE();

    PortNumber = InterlockedIncrement (&RaidPortNumber);

    swprintf (Buffer,
              L"\\Device\\RaidPort%d",
              PortNumber);

    RtlInitUnicodeString (&TempDeviceName, Buffer);
    RaDuplicateUnicodeString (DeviceName,
                              &TempDeviceName,
                              PagedPool,
                              DeviceObject);

    return PortNumber;
}

BOOLEAN
StorCreateAnsiString(
    OUT PANSI_STRING AnsiString,
    IN PCSTR String,
    IN ULONG Length,
    IN POOL_TYPE PoolType,
    IN PVOID IoObject
    )
{
    ASSERT_IO_OBJECT (IoObject);

    if (Length == -1) {
        Length = strlen (String);
    }

    AnsiString->Buffer = RaidAllocatePool (PoolType,
                                           Length,
                                           STRING_TAG,
                                           IoObject);
    if (AnsiString->Buffer == NULL) {
        return FALSE;
    }

    RtlCopyMemory (AnsiString->Buffer, String, Length);
    AnsiString->MaximumLength = (USHORT)Length;
    AnsiString->Length = (USHORT)(Length - 1);
    return TRUE;
}



VOID
StorFreeAnsiString(
    IN PANSI_STRING AnsiString
    )
{
    PAGED_CODE();

    if (AnsiString->Buffer) {
        DbgFillMemory (AnsiString->Buffer,
                       AnsiString->MaximumLength,
                       DBG_DEALLOCATED_FILL);
        RaidFreePool (AnsiString->Buffer, STRING_TAG);
    }

    AnsiString->Buffer = NULL;
    AnsiString->Length = 0;
    AnsiString->MaximumLength = 0;
}



NTSTATUS
StorProbeAndLockPages(
    IN PMDL Mdl,
    IN KPROCESSOR_MODE AccessMode,
    IN LOCK_OPERATION Operation
    )
/*++

Routine Description:

    Same thing as MmProbeAndLockPages except returns an error value
    instead of throwing an exception.

Arguments:

    Mdl, AccessMode, Operation - See MmProbeAndLockPages.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    
    try {
        MmProbeAndLockPages (Mdl, AccessMode, Operation);
        Status = STATUS_SUCCESS;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    return Status;
}

PIRP
StorBuildSynchronousScsiRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PSCSI_REQUEST_BLOCK Srb,
    OUT PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    )
/*++

Routine Description:

    Similiar to IoBuildSynchronousFsdRequest, this routine builds an I/O
    request for a SCSI driver.

    This function assumes the SRB has been properly validate by the higher
    level routines before being called.
    
Arguments:

    DeviceObject - Pointer to device object on which the IO will be performed.

    Srb - SCSI request block describing the IO.

    Event - Pointer to a kernel event structure for synchronization.

    IoStatusBlock - Pointer to the IO status block for completion status.

Return Value:

    The routine returns a pointer to an IRP on success or NULL for failure.

--*/
{
    NTSTATUS Status;
    PMDL Mdl;
    PIRP Irp;
    LOCK_OPERATION IoAccess;
    PIO_STACK_LOCATION Stack;
    

    PAGED_CODE();
    
    Irp = NULL;
    
    Irp = IoAllocateIrp (DeviceObject->StackSize, FALSE);
    if (Irp == NULL) {
        return NULL;
    }

    Irp->Tail.Overlay.Thread = PsGetCurrentThread();
    Stack = IoGetNextIrpStackLocation (Irp);

    Stack->MajorFunction = IRP_MJ_SCSI;
    Stack->MinorFunction = 0;

    //
    // We assume that the buffer(s) have already been validated. Setup
    // the Buffer, BufferSize and IoAccess variables as appropiate for
    // reading or writing data.
    //
    
    if (TEST_FLAG (Srb->SrbFlags, SRB_FLAGS_DATA_IN | SRB_FLAGS_DATA_OUT)) {
        IoAccess = IoModifyAccess;
    } else if (TEST_FLAG (Srb->SrbFlags, SRB_FLAGS_DATA_IN)) {
        IoAccess = IoWriteAccess;
    } else if (TEST_FLAG (Srb->SrbFlags, SRB_FLAGS_DATA_OUT)) {
        IoAccess = IoReadAccess;
    } else {
        IoAccess = -1;
    }
    
    //
    // We assume the port driver does direct IO.
    //
    
    ASSERT (DeviceObject->Flags & DO_DIRECT_IO);

    //
    // If there is a buffer present, build and lock down a MDL describing
    // it.
    //
    
    if (Srb->DataTransferLength != 0) {
    
        //
        // Allocate a MDL that describes the buffer.
        //
        
        Irp->MdlAddress = IoAllocateMdl (Srb->DataBuffer,
                                         Srb->DataTransferLength,
                                         FALSE,
                                         FALSE,
                                         NULL);
        if (Irp->MdlAddress == NULL) {
            Status = STATUS_NO_MEMORY;
            goto done;
        }

        //
        // Probe and lock the buffer.
        //
        
        Status = StorProbeAndLockPages (Irp->MdlAddress, KernelMode, IoAccess);
        if (!NT_SUCCESS (Status)) {
            goto done;
        }
    }

    Stack->Parameters.Scsi.Srb = Srb;
    Irp->UserIosb = IoStatusBlock;
    Irp->UserEvent = Event;
    Status = STATUS_SUCCESS;

    //IopQueueThreadIrp (...);

done:

    if (!NT_SUCCESS (Status)) {
        if (Irp != NULL) {
            IoFreeIrp (Irp);
            Irp = NULL;
        }
    }

    return Irp;
}

VOID
RaidCancelIrp(
    IN PIO_QUEUE IoQueue,
    IN PVOID Context,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the PurgeIoQueue function to cancel each
    IRP in the IO queue.

Arguments:

    IoQueue - The IoQueue this IRP was on.

    Context - Context passed into RaidPurgeIoQueue. Represents the SrbStatus
            with which to cancel the IRP with.

    Irp - IRP to cancel.

Return Value:

    None.

--*/
{
    UCHAR SrbStatus;
    PSCSI_REQUEST_BLOCK Srb;
    
    SrbStatus = (UCHAR)Context;
    Srb = RaidSrbFromIrp (Irp);
    ASSERT (Srb != NULL);
    Srb->SrbStatus = SrbStatus;
    Irp->IoStatus.Status = RaidSrbStatusToNtStatus (SrbStatus);
    Irp->IoStatus.Information = 0;

    RaidCompleteRequest (Irp, Irp->IoStatus.Status);
}


VOID
RaidCompleteRequestCallback(
    IN PSTOR_EVENT_QUEUE Queue,
    IN PVOID Context,
    IN PSTOR_EVENT_QUEUE_ENTRY Entry,
    IN STOR_REMOVE_EVENT_ROUTINE RemoveEventRoutine
    )
/*++

Routine Description:

    This routine is called by the PurgeEventQueue routine to cancel each
    IO in the event queue.

Arguments:

    Queue - The event queue this IO was on.

    Context - Context passed into the RaidPurgeEventQueue function.

    IRP - Irp to cancel.

Return Value:

    None.

--*/
{
    UCHAR SrbStatus;
    PEXTENDED_REQUEST_BLOCK Xrb;

    ASSERT (RemoveEventRoutine != NULL);
    
    SrbStatus = (UCHAR)Context;
    
    Xrb = CONTAINING_RECORD (Entry,
                             EXTENDED_REQUEST_BLOCK,
                             PendingLink);


    //
    // Only complete the request if it has not been completed by the
    // the miniport.
    //

    if (!RaidXrbIsCompleting (Xrb)) {

        ASSERT (Xrb->Srb != NULL);

        //
        // Remove the event from the event queue before calling the
        // completion routine.
        //
        
        RemoveEventRoutine (Queue, Entry);

        //
        // Need the XRB's completion routine to NOT try to remove
        // the element from the event queue during the normal course
        // of events. This will be done automatically when we return
        // from the purge routine.
        //
        
        Xrb->RemoveFromEventQueue = FALSE;

        Xrb->Srb->SrbStatus = SrbStatus;
        Xrb->CompletionRoutine (Xrb);
    }
}


VOID
RaidCompleteMiniportRequestCallback(
    IN PSTOR_EVENT_QUEUE Queue,
    IN PVOID Context,
    IN PSTOR_EVENT_QUEUE_ENTRY Entry,
    IN STOR_REMOVE_EVENT_ROUTINE RemoveEventRoutine
    )
/*++

Routine Description:

    This routine is called by the PurgeEventQueue routine to cancel each
    IO in the event queue.

    The routine will cancel a request ONLY if it is currently queued to
    the miniport. Requests that are not yet queued to the miniport will be
    ignored.

Arguments:

    Queue - The event queue this IO was on.

    Context - Context passed into the RaidPurgeEventQueue function.

    IRP - Irp to cancel.

Return Value:

    TRUE - If we should remove the processed element from the event queue
           upon return.

    FALSE - If we should not remove the processed element from the event
            queue upon return.

--*/
{
    UCHAR SrbStatus;
    PEXTENDED_REQUEST_BLOCK Xrb;

    ASSERT (RemoveEventRoutine != NULL);
    
    SrbStatus = (UCHAR)Context;
    
    Xrb = CONTAINING_RECORD (Entry,
                             EXTENDED_REQUEST_BLOCK,
                             PendingLink);


    //
    // Only complete requests that are currently being processed by
    // the miniport.
    //

    if (RaidGetXrbState (Xrb) == XrbMiniportProcessing) {
        ASSERT (Xrb->Srb != NULL);
        ASSERT (RaidGetIrpState (Xrb->Irp) == RaidMiniportProcessingIrp);

        //
        // Remove the event from the event queue before calling the
        // completion routine.
        //

        RemoveEventRoutine (Queue, Entry);

        //
        // Set the RemoveFromEventQueue flag in the XRB to FALSE to prevent
        // the XRB from attempting to remove the element from the event
        // queue. Attempting to remove from the event queue while we're
        // purging the item will result in a hang when we attempt to
        // reacquire the event queue spinlock.
        //
        //
        
        Xrb->RemoveFromEventQueue = FALSE;
        Xrb->Srb->SrbStatus = SrbStatus;

        //
        // The completion routine will remove the request.
        //
        
        Xrb->CompletionRoutine (Xrb);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\util.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    util.h

Abstract:

    Utilities for RAIDPORT driver.

Author:

    Matthew D Hendel (math) 20-Apr-2000

Revision History:

--*/

#pragma once



typedef enum _DEVICE_STATE {
    DeviceStateNotPresent       = 0,    // FDO only
    DeviceStateWorking          = 1,
    DeviceStateStopped          = 2,
    DeviceStatePendingStop      = 3,
    DeviceStatePendingRemove    = 4,
    DeviceStateSurpriseRemoval  = 5,
    DeviceStateDeleted          = 6,
    DeviceStateDisabled         = 7     // PDO only
} DEVICE_STATE, *PDEVICE_STATE;


DEVICE_STATE
INLINE
StorSetDeviceState(
    IN PDEVICE_STATE DeviceState,
    IN DEVICE_STATE NewDeviceState
    )
{
    DEVICE_STATE PriorState;

    //
    // NB: It is not necessary to perform this operation interlocked as
    // we will never receive multiple PNP irps for the same device object
    // simultaneously.
    //
    
    PriorState = *DeviceState;
    *DeviceState = NewDeviceState;

    return PriorState;
}


//
// Unless otherwise specified, the default timeout for requests originated
// in the port driver is 10 sec.
//

#define DEFAULT_IO_TIMEOUT      (10)

//
// Unless otherwise specified the default link timeout is 30 sec.
//

#define DEFAULT_LINK_TIMEOUT    (30)

//
// When we send down a SRB_FUNCTION_RESET_XXX (lun, target, bus) we must
// specify a reset timeout with the request. This timeout will be at
// minimum MINIMUM_RESET_TIMEOUT, and it may be larger if the default
// timeout for the Unit/HBA is larger.
//

#define MINIMUM_RESET_TIMEOUT   (30)

//
// The time to pause, in seconds, after we issue a bus-reset to an adapter.
//

#define DEFAULT_RESET_HOLD_TIME (4)

//
// Default rescan period is the shortest period we will not initiate a rescan
// on a QDR within.
//

#define DEFAULT_RESCAN_PERIOD   (30 * SECONDS)

//
// Number of elements in the tag queue, numbered 0 through TAG_QUEUE_SIZE - 1.
//

#define TAG_QUEUE_SIZE     (255)


//
// Number of times to retry inquiry commands. RetryCount of two means three
// total attempts.
//

#define RAID_INQUIRY_RETRY_COUNT    (2)

//
// Lengths of various identifiers.
//
                                     
#define SCSI_BUS_NAME_LENGTH            (sizeof ("SCSI"))
#define MAX_DEVICE_NAME_LENGTH          (sizeof ("Sequential"))
#define SCSI_VENDOR_ID_LENGTH           (8)
#define SCSI_PRODUCT_ID_LENGTH          (16)
#define SCSI_REVISION_ID_LENGTH         (4)
#define SCSI_SERIAL_NUMBER_LENGTH       (32)

#define MAX_GENERIC_DEVICE_NAME_LENGTH  (sizeof ("ScsiCardReader"))

#define HARDWARE_B_D_V_LENGTH       (SCSI_BUS_NAME_LENGTH +                 \
                                     MAX_DEVICE_NAME_LENGTH +               \
                                     SCSI_VENDOR_ID_LENGTH + 1)

#define HARDWARE_B_D_V_P_LENGTH     (HARDWARE_B_D_V_LENGTH +                \
                                     SCSI_PRODUCT_ID_LENGTH)

#define HARDWARE_B_D_V_P_R_LENGTH   (HARDWARE_B_D_V_P_LENGTH +              \
                                     SCSI_REVISION_ID_LENGTH)

#define HARDWARE_B_V_P_LENGTH       (SCSI_BUS_NAME_LENGTH +                 \
                                     SCSI_VENDOR_ID_LENGTH +                \
                                     SCSI_PRODUCT_ID_LENGTH + 1)

#define HARDWARE_B_V_P_R0_LENGTH    (SCSI_BUS_NAME_LENGTH +                 \
                                     SCSI_VENDOR_ID_LENGTH +                \
                                     SCSI_PRODUCT_ID_LENGTH +               \
                                     SCSI_REVISION_ID_LENGTH + 1)

#define HARDWARE_V_P_R0_LENGTH      (SCSI_VENDOR_ID_LENGTH +                \
                                     SCSI_PRODUCT_ID_LENGTH +               \
                                     SCSI_REVISION_ID_LENGTH + 1)


#define HARDWARE_ID_LENGTH          (HARDWARE_B_D_V_LENGTH +                \
                                     HARDWARE_B_D_V_P_LENGTH +              \
                                     HARDWARE_B_D_V_P_R_LENGTH +            \
                                     HARDWARE_B_V_P_LENGTH +                \
                                     HARDWARE_B_V_P_R0_LENGTH +             \
                                     HARDWARE_V_P_R0_LENGTH +               \
                                     MAX_GENERIC_DEVICE_NAME_LENGTH + 2)


#define DEVICE_ID_LENGTH            (HARDWARE_B_D_V_P_R_LENGTH +            \
                                     sizeof ("&Ven_") +                     \
                                     sizeof ("&Prod_") +                    \
                                     sizeof ("&Rev_"))


#define INSTANCE_ID_LENGTH          (20)

#define COMPATIBLE_ID_LENGTH        (SCSI_BUS_NAME_LENGTH +                 \
                                     MAX_DEVICE_NAME_LENGTH +               \
                                     1 +                                    \
                                     sizeof ("SCSI\\RAW") +                 \
                                     1 +                                    \
                                     1)                                     \




//
// Max wait is the length to wait for the remlock, in minutes.
// The high water is the estimated high water mark.
//

#define REMLOCK_MAX_WAIT            (1)         // Minutes
#define REMLOCK_HIGH_MARK           (1000)      

//
// Minor code used by the HBA to signal to the LUN that this is
// an enumeration IRP. The major code is IRP_MJ_SCSI.
//

#define STOR_MN_ENUMERATION_IRP     (0xF0)

ULONG
RaidMinorFunctionFromIrp(
    IN PIRP Irp
    );

ULONG
RaidMajorFunctionFromIrp(
    IN PIRP Irp
    );

ULONG
RaidIoctlFromIrp(
    IN PIRP Irp
    );

PSCSI_REQUEST_BLOCK
RaidSrbFromIrp(
    IN PIRP Irp
    );

UCHAR
RaidSrbFunctionFromIrp(
    IN PIRP Irp
    );

UCHAR
RaidScsiOpFromIrp(
    IN PIRP Irp
    );

NTSTATUS
RaidNtStatusFromScsiStatus(
    IN ULONG ScsiStatus
    );

UCHAR
RaidNtStatusToSrbStatus(
    IN NTSTATUS Status
    );

NTSTATUS
RaidNtStatusFromBoolean(
    IN BOOLEAN Succ
    );

POWER_STATE_TYPE
RaidPowerTypeFromIrp(
    IN PIRP Irp
    );

POWER_STATE
RaidPowerStateFromIrp(
    IN PIRP Irp
    );

INTERFACE_TYPE
RaGetBusInterface(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
RaForwardIrpSynchronous(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RaSendIrpSynchronous(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
    
NTSTATUS
RaForwardIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RaForwardPowerIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );  

NTSTATUS
RaDuplicateUnicodeString(
    OUT PUNICODE_STRING DestString,
    IN PUNICODE_STRING SourceString,
    IN POOL_TYPE Pool,
    IN PVOID IoObject
    );

ULONG
RaSizeOfCmResourceList(
    IN PCM_RESOURCE_LIST ResourceList
    );

PCM_RESOURCE_LIST
RaDuplicateCmResourceList(
    IN POOL_TYPE PoolType,
    IN PCM_RESOURCE_LIST ResourceList,
    IN ULONG Tag
    );

NTSTATUS
RaQueryInterface(
    IN PDEVICE_OBJECT DeviceObject,
    IN PCGUID InterfaceType,
    IN USHORT InterfaceSize,
    IN USHORT InterfaceVersion,
    IN PINTERFACE Interface,
    IN PVOID InterfaceSpecificData
    );

VOID
RaFixupIds(
    IN PWCHAR Id,
    IN BOOLEAN MultiSz
    );

VOID
RaCopyPaddedString(
    OUT PCHAR Dest,
    IN ULONG DestLength,
    IN PCHAR Source,
    IN ULONG SourceLength
    );


typedef struct _RAID_FIXED_POOL {

    //
    // Buffer to allocate from.
    //
    
    PUCHAR Buffer;

    //
    // Number of elements in the pool.
    //
    
    ULONG NumberOfElements;

    //
    // Size of each element.
    //
    
    SIZE_T SizeOfElement;

} RAID_FIXED_POOL, *PRAID_FIXED_POOL;



VOID
RaidCreateFixedPool(
    IN PRAID_FIXED_POOL Pool
    );

VOID
RaidInitializeFixedPool(
    OUT PRAID_FIXED_POOL Pool,
    IN PVOID Buffer,
    IN ULONG NumberOfElements,
    IN SIZE_T SizeOfElement
    );

VOID
RaidDeleteFixedPool(
    IN PRAID_FIXED_POOL Pool
    );

PVOID
RaidAllocateFixedPoolElement(
    IN PRAID_FIXED_POOL Pool,
    IN ULONG Index
    );

PVOID
RaidGetFixedPoolElement(
    IN PRAID_FIXED_POOL Pool,
    IN ULONG Index
    );

VOID
RaidFreeFixedPoolElement(
    IN PRAID_FIXED_POOL Pool,
    IN ULONG Element
    );

//
// A list for managing entries in the tagged queue list.
//

typedef struct _QUEUE_TAG_LIST {

    //
    // Spinlock held while accessing the queue list.
    //
    
    KSPIN_LOCK Lock;

    //
    // Number of elements in the list.
    //
    
    ULONG Count;

    //
    // Hint to speed up tag allocation.
    //
    
    ULONG Hint;

    //
    // BitMap to hold the tag values.
    //
    
    RTL_BITMAP BitMap;

    //
    // BitMap Buffer.
    //

    PULONG Buffer;

    //
    // Number of outstanding tags. This could probably be DBG only.
    //

    ULONG OutstandingTags;

    //
    // The maximum number of tags that were outstanding at one time.
    //

    ULONG HighWaterMark;
    
    
} QUEUE_TAG_LIST, *PQUEUE_TAG_LIST;


VOID
RaCreateTagList(
    OUT PQUEUE_TAG_LIST TagList
    );

VOID
RaDeleteTagList(
    IN PQUEUE_TAG_LIST TagList
    );

NTSTATUS
RaInitializeTagList(
    IN OUT PQUEUE_TAG_LIST TagList,
    IN ULONG TagCount,
    IN PVOID IoObject
    );

ULONG
RaAllocateTag(
    IN OUT PQUEUE_TAG_LIST TagList
    );

ULONG
RaAllocateSpecificTag(
    IN OUT PQUEUE_TAG_LIST TagList,
    IN ULONG SpecificTag
    );

VOID
RaFreeTag(
    IN OUT PQUEUE_TAG_LIST TagList,
    IN ULONG Tag
    );
    


//
// RAID_MEMORY_REGION represents a region of physical contiguous memory.
// Generally, this is used for DMA common buffer regions.
//

typedef struct _RAID_MEMORY_REGION {

    //
    // Beginning virtual address of the region.
    //
    
    PUCHAR VirtualBase;

    //
    // Beginning physical address of the region.
    //
    
    PHYSICAL_ADDRESS PhysicalBase;

    //
    // Length of the region. (Is there any need to make this a SIZE_T
    // value?)
    //
    
    ULONG Length;
    
} RAID_MEMORY_REGION, *PRAID_MEMORY_REGION;


//
// Creation and destruction of the memory region.
//

VOID
INLINE
RaidCreateRegion(
    OUT PRAID_MEMORY_REGION Region
    )
{
    RtlZeroMemory (Region, sizeof (RAID_MEMORY_REGION));
}

VOID
INLINE
RaidInitializeRegion(
    IN OUT PRAID_MEMORY_REGION Region,
    IN PVOID VirtualAddress,
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG Length
    )
{
    ASSERT (Region->Length == 0);

    Region->VirtualBase = VirtualAddress;
    Region->PhysicalBase = PhysicalAddress;
    Region->Length = Length;
}

VOID
INLINE
RaidDereferenceRegion(
    IN OUT PRAID_MEMORY_REGION Region
    )
{
    Region->VirtualBase = 0;
    Region->PhysicalBase.QuadPart = 0;
    Region->Length = 0;
}

BOOLEAN
INLINE
RaidIsRegionInitialized(
    IN PRAID_MEMORY_REGION Region
    )
{
    return (Region->Length != 0);
}

VOID
INLINE
RaidDeleteRegion(
    IN OUT PRAID_MEMORY_REGION Region
    )
{
    ASSERT (Region->VirtualBase == 0);
    ASSERT (Region->PhysicalBase.QuadPart == 0);
    ASSERT (Region->Length == 0);
}


//
// Operations on the memory region.
//

PVOID
INLINE
RaidRegionGetVirtualBase(
    IN PRAID_MEMORY_REGION Region
    )
{
    ASSERT (RaidIsRegionInitialized (Region));
    return Region->VirtualBase; 
}

PHYSICAL_ADDRESS
INLINE
RaidRegionGetPhysicalBase(
    IN PRAID_MEMORY_REGION Region
    )
{
    ASSERT (RaidIsRegionInitialized (Region));
    return Region->PhysicalBase;
}

ULONG
INLINE
RaidRegionGetSize(
    IN PRAID_MEMORY_REGION Region
    )
{
    ASSERT (RaidIsRegionInitialized (Region));
    return Region->Length;
}

BOOLEAN
INLINE
RaidRegionInPhysicalRange(
    IN PRAID_MEMORY_REGION Region,
    IN PHYSICAL_ADDRESS PhysicalAddress
    )
{
    return IN_RANGE (Region->PhysicalBase.QuadPart,
                     PhysicalAddress.QuadPart,
                     Region->PhysicalBase.QuadPart + Region->Length);
}

BOOLEAN
INLINE
RaidRegionInVirtualRange(
    IN PRAID_MEMORY_REGION Region,
    IN PVOID VirtualAddress
    )
{
    return IN_RANGE (Region->VirtualBase,
                     (PUCHAR)VirtualAddress,
                     Region->VirtualBase + Region->Length);
}

BOOLEAN
INLINE
RaidRegionGetPhysicalAddress(
    IN PRAID_MEMORY_REGION Region,
    IN PVOID VirtualAddress,
    OUT PPHYSICAL_ADDRESS PhysicalAddress,
    OUT PULONG Length OPTIONAL
    )
/*++

Routine Description:

    Get a physical address for a specific virtual address within
    the region.

Arguments:

    Region - Supplies a pointer to a region object that contain the
            specified virtual address.

    VirtualAddress - Supplies the source virtual address.

    PhysicalAddress - Buffer where the physical address for this virtual
            address will be stored on success.

    Length - Optional out parameter taking the length of the physical
            region that is valid.

Return Value:

    TRUE - If the operation succeeded.

    FALSE - If the virtual address was out of range.

--*/
{
    ULONG Offset;

    //
    // If the virtual address isn't within range, fail.
    //
    
    if (!RaidRegionInVirtualRange (Region, VirtualAddress)) {
        return FALSE;
    }

    Offset = (ULONG)((PUCHAR)VirtualAddress - Region->VirtualBase);
    PhysicalAddress->QuadPart = Region->PhysicalBase.QuadPart + Offset;

    if (Length) {
        *Length = Region->Length - Offset;
    }

    //
    // Check that we did the fixup correctly.
    //
    
    ASSERT (RaidRegionInPhysicalRange (Region, *PhysicalAddress));
    
    return TRUE;
}

    

BOOLEAN
INLINE
RaidRegionGetVirtualAddress(
    IN PRAID_MEMORY_REGION Region,
    IN PHYSICAL_ADDRESS PhysicalAddress,
    OUT PVOID* VirtualAddress,
    OUT PULONG Length OPTIONAL
    )
{
    ULONG Offset;
    
    //
    // If the physical address isn't within range, fail.
    //
    
    if (!RaidRegionInPhysicalRange (Region, PhysicalAddress)) {
        return FALSE;
    }

    Offset = (ULONG)(Region->PhysicalBase.QuadPart - PhysicalAddress.QuadPart);
    VirtualAddress = (PVOID)(Region->VirtualBase + Offset);

    if (Length) {
        *Length = Region->Length - Offset;
    }

    return TRUE;
}


NTSTATUS
RaidAllocateAddressMapping(
    IN PMAPPED_ADDRESS* ListHead,
    IN PHYSICAL_ADDRESS Address,
    IN PVOID MappedAddress,
    IN ULONG NumberOfBytes,
    IN ULONG BusNumber,
    IN PVOID IoObject
    );

NTSTATUS
RaidFreeAddressMapping(
    IN PMAPPED_ADDRESS* ListHead,
    IN PVOID MappedAddress
    );

NTSTATUS
RaidHandleCreateCloseIrp(
    IN DEVICE_STATE DeviceState,
    IN PIRP Irp
    );


//
// Irp state tracking
//

typedef struct _EX_DEVICE_QUEUE_ENTRY {
    LIST_ENTRY DeviceListEntry;
    ULONG SortKey;
    BOOLEAN Inserted;
    UCHAR State;
    struct {
        UCHAR Solitary : 1;
        UCHAR reserved0 : 7;
        
    };
    UCHAR reserved1;
} EX_DEVICE_QUEUE_ENTRY, *PEX_DEVICE_QUEUE_ENTRY;

C_ASSERT (sizeof (EX_DEVICE_QUEUE_ENTRY) == sizeof (KDEVICE_QUEUE_ENTRY));


//
// Port processing irp means the port driver is currently executing
// instructions to complete the irp. The irp is NOT waiting for
// resources on any queue.
//

#define RaidPortProcessingIrp           (0xA8)

//
// Pending resources is when the irp is in an IO queue awaiting
// resources.
//

#define RaidPendingResourcesIrp         (0xA9)

//
// The irp moves into state WaitingIoQueue callback when it's awaiting
// the ioqueue to call it back, e.g., in the solitary request processing
// logic. Most requests will not take on this state, and instead will
// transition directly from RaidPendingResources -> RaidMiniportProcessing.
//

#define RaidWaitingIoQueueCallback      (0xAD)

//
// The irp takes on state Miniport Processing while the miniport has
// control over the irp. That is, between the time we call HwStartIo
// and when the miniport calls ScsiPortNotification with a completion
// status for the irp.
//

#define RaidMiniportProcessingIrp       (0xAA)

//
// The irp takes on the Pending Completion state when it is moved to
// the completed list.
//

#define RaidPendingCompletionIrp        (0xAB)

//
// We set the irp state to Completed just before we call IoCompleteRequest
// for the irp.
//

#define RaidCompletedIrp                (0xAC)


typedef UCHAR RAID_IRP_STATE;

VOID
INLINE
RaidSetIrpState(
    IN PIRP Irp,
    IN RAID_IRP_STATE State
    )
{
    ((PEX_DEVICE_QUEUE_ENTRY)&Irp->Tail.Overlay.DeviceQueueEntry)->State = State;
}

    

RAID_IRP_STATE
INLINE
RaidGetIrpState(
    IN PIRP Irp
    )
{
    return ((PEX_DEVICE_QUEUE_ENTRY)&Irp->Tail.Overlay.DeviceQueueEntry)->State;
}

VOID
INLINE
RaidSetEntryState(
    IN PKDEVICE_QUEUE_ENTRY Entry,
    IN RAID_IRP_STATE State
    )
{
    ((PEX_DEVICE_QUEUE_ENTRY)Entry)->State = State;
}

//
// Completion wrapper function.
//

NTSTATUS
INLINE
RaidCompleteRequestEx (
    IN PIRP Irp,
    IN CCHAR PriorityBoost,
    IN NTSTATUS Status
    )
{
    RAID_IRP_STATE IrpState;

    IrpState = RaidGetIrpState (Irp);

    ASSERT (IrpState == RaidPortProcessingIrp ||
            IrpState == RaidPendingResourcesIrp ||
            IrpState == RaidMiniportProcessingIrp ||
            IrpState == RaidPendingCompletionIrp);

    RaidSetIrpState (Irp, RaidCompletedIrp);
    Irp->IoStatus.Status = Status;

    IoCompleteRequest (Irp, PriorityBoost);

    return Status;
}
    
NTSTATUS
INLINE
RaidCompleteRequest(
    IN PIRP Irp,
    IN NTSTATUS Status
    )
{
    return RaidCompleteRequestEx (Irp, IO_NO_INCREMENT, Status);
}



//
// Error log information
//

typedef struct _RAID_ALLOCATION_ERROR {
    IO_ERROR_LOG_PACKET Packet;
    POOL_TYPE PoolType;
    SIZE_T NumberOfBytes;
    ULONG Tag;
} RAID_ALLOCATION_ERROR, *PRAID_ALLOCATION_ERROR;

typedef struct _RAID_IO_ERROR {
    IO_ERROR_LOG_PACKET Packet;
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    UCHAR _unused;
    ULONG ErrorCode;
    ULONG UniqueId;
} RAID_IO_ERROR, *PRAID_IO_ERROR;


PVOID
RaidAllocatePool(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag,
    IN PVOID IoObject
    );

//
// Memory allocated with RaidAllocatePool MUST be freed by RaidFreePool.
//

#define RaidFreePool ExFreePoolWithTag


#define VERIFY_DISPATCH_LEVEL() ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);


extern LONG RaidUnloggedErrors;

#define RAID_ERROR_NO_MEMORY    (10)

ULONG
RaidScsiErrorToIoError(
    IN ULONG ErrorCode
    );


PVOID
RaidGetSystemAddressForMdl(
    IN PMDL,
    IN MM_PAGE_PRIORITY Priority,
    IN PVOID DeviceObject
    );
    
NTSTATUS
StorCreateScsiSymbolicLink(
    IN PUNICODE_STRING DeviceName,
    OUT PULONG PortNumber OPTIONAL
    );

NTSTATUS
StorDeleteScsiSymbolicLink(
    IN ULONG ScsiPortNumber
    );

ULONG
RaidCreateDeviceName(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PUNICODE_STRING DeviceName
    );

NTSTATUS
StorDuplicateUnicodeString(
    IN PUNICODE_STRING Source,
    IN PUNICODE_STRING Dest
    );

#define RtlDuplicateUnicodeString(X,Y,Z) (StorDuplicateUnicodeString(Y,Z))



VOID
INLINE
ASSERT_IO_OBJECT(
    IN PVOID IoObject
    )
{
    //
    // The IO object must be either a device object or a driver object.
    // NB: Should probably protect this with a read check as well. 
    //
    
    ASSERT (IoObject != NULL);
    ASSERT (((PDEVICE_OBJECT)IoObject)->Type == IO_TYPE_DEVICE ||
            ((PDRIVER_OBJECT)IoObject)->Type == IO_TYPE_DRIVER);
}

BOOLEAN
StorCreateAnsiString(
    OUT PANSI_STRING AnsiString,
    IN PCSTR String,
    IN ULONG Length,
    IN POOL_TYPE PoolType,
    IN PVOID IoObject
    );

VOID
StorFreeAnsiString(
    IN PANSI_STRING String
    );

PIRP
StorBuildSynchronousScsiRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PSCSI_REQUEST_BLOCK Srb,
    OUT PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );


//++
//
// BOOLEAN
// C_MATCH_FIELD_OFFSET(
//     Type1,
//     Type2,
//     FieldName
//     );
//
// Routine Description:
//
//   Verify that a field is at the same offset in one type as another.
//   This is done at compile time, so may be a part of a compile-time
//   C_ASSERT.
//
// Return Values:
//
//    TRUE - if the field offsets match.
//
//    FALSE - if the field offsets do not match.
//
//-- 

#define C_MATCH_FIELD_OFFSET(Type1, Type2, FieldName)\
    (FIELD_OFFSET (Type1, FieldName) == FIELD_OFFSET (Type1, FieldName))


//
// Verify that the kernel's SCATTER_GATHER_ELEMENT is the same as the
// storport.h STOR_SCATTER_GATHER_ELEMENT.
//
    
C_ASSERT (C_MATCH_FIELD_OFFSET (STOR_SCATTER_GATHER_ELEMENT, SCATTER_GATHER_ELEMENT, PhysicalAddress) &&
          C_MATCH_FIELD_OFFSET (STOR_SCATTER_GATHER_ELEMENT, SCATTER_GATHER_ELEMENT, Length) &&
          C_MATCH_FIELD_OFFSET (STOR_SCATTER_GATHER_ELEMENT, SCATTER_GATHER_ELEMENT, Reserved));

//
// Verify that the kernel's SCATTER_GATHER_LIST is the same as the storport.h
// STOR_SCATTER_GATHER_LIST. We just cast the list from one type to the other,
// so the had better be the same.
//

C_ASSERT (C_MATCH_FIELD_OFFSET (STOR_SCATTER_GATHER_LIST, SCATTER_GATHER_LIST, NumberOfElements) &&
          C_MATCH_FIELD_OFFSET (STOR_SCATTER_GATHER_LIST, SCATTER_GATHER_LIST, List));


VOID
RaidCancelIrp(
    IN PIO_QUEUE IoQueue,
    IN PVOID Context,
    IN PIRP Irp
    );

VOID
RaidCompleteRequestCallback(
    IN PSTOR_EVENT_QUEUE Queue,
    IN PVOID Context,
    IN PSTOR_EVENT_QUEUE_ENTRY Entry,
    IN PVOID RemoveEventRoutine
    );

VOID
RaidCompleteMiniportRequestCallback(
    IN PSTOR_EVENT_QUEUE Queue,
    IN PVOID Context,
    IN PSTOR_EVENT_QUEUE_ENTRY Entry,
    IN PVOID RemoveEventRoutine
    );

NTSTATUS
StorWaitForSingleObject(
    IN PVOID Object,
    IN BOOLEAN Alertable,
    IN PLONGLONG Timeout
    );

//
// The TEXT_SECTION macro is used to signify that a specific function resides
// within a specific code section. This is used by the an external tool to
// build the ALLOC_PRAGMA table(s).
//

#define TEXT_SECTION(SectionName)

//
// ASSERT that a UNICODE_STRING is NULL terminated, this is important as some
// functions require it.
//

#define ASSERT_UNC_STRING_IS_SZ(String)\
    ASSERT ((String)->Buffer != NULL &&\
            ((String)->MaximumLength > String->Length) &&\
            ((String)->Buffer [(String)->Length / sizeof (WCHAR)] == UNICODE_NULL))



//
// The type SMALL_INQUIRY_DATA is the first INQUIRYDATABUFFERSIZE bytes of
// the INQUIRY_DATA structure. Explicitly defining this structure avoids
// error prone pointer arithmetic when managing arrays of inquiry data.
//

typedef struct _SMALL_INQUIRY_DATA {
    UCHAR DeviceType : 5;
    UCHAR DeviceTypeQualifier : 3;
    UCHAR DeviceTypeModifier : 7;
    UCHAR RemovableMedia : 1;
    union {
        UCHAR Versions;
        struct {
            UCHAR ANSIVersion : 3;
            UCHAR ECMAVersion : 3;
            UCHAR ISOVersion : 2;
        };
    };
    UCHAR ResponseDataFormat : 4;
    UCHAR HiSupport : 1;
    UCHAR NormACA : 1;
    UCHAR TerminateTask : 1;
    UCHAR AERC : 1;
    UCHAR AdditionalLength;
    UCHAR Reserved;
    UCHAR Addr16 : 1;               // defined only for SIP devices.
    UCHAR Addr32 : 1;               // defined only for SIP devices.
    UCHAR AckReqQ: 1;               // defined only for SIP devices.
    UCHAR MediumChanger : 1;
    UCHAR MultiPort : 1;
    UCHAR ReservedBit2 : 1;
    UCHAR EnclosureServices : 1;
    UCHAR ReservedBit3 : 1;
    UCHAR SoftReset : 1;
    UCHAR CommandQueue : 1;
    UCHAR TransferDisable : 1;      // defined only for SIP devices.
    UCHAR LinkedCommands : 1;
    UCHAR Synchronous : 1;          // defined only for SIP devices.
    UCHAR Wide16Bit : 1;            // defined only for SIP devices.
    UCHAR Wide32Bit : 1;            // defined only for SIP devices.
    UCHAR RelativeAddressing : 1;
    UCHAR VendorId[8];
    UCHAR ProductId[16];
    UCHAR ProductRevisionLevel[4];
} SMALL_INQUIRY_DATA, *PSMALL_INQUIRY_DATA;

//
// Check that we actually did this correctly.
//

C_ASSERT (sizeof (SMALL_INQUIRY_DATA) == INQUIRYDATABUFFERSIZE);

//
// The SCSI_INQUIRY_DATA_INTERNAL structure is used for processing the
// IOCTL_SCSI_GET_INQUIRY_DATA command. It has the SMALL_INQUIRY_DATA
// embedded into the struct to avoid pointer arithmetic.
//

typedef struct _SCSI_INQUIRY_DATA_INTERNAL {
    UCHAR  PathId;
    UCHAR  TargetId;
    UCHAR  Lun;
    BOOLEAN  DeviceClaimed;
    ULONG  InquiryDataLength;
    ULONG  NextInquiryDataOffset;
    SMALL_INQUIRY_DATA InquiryData;
} SCSI_INQUIRY_DATA_INTERNAL, *PSCSI_INQUIRY_DATA_INTERNAL;


//
// This struct is used in the processing of IOCTL_SCSI_GET_INQUIRY_DATA.
//

typedef struct TEMPORARY_INQUIRY_BUS_INFO {
    ULONG NumberOfLogicalUnits;
    ULONG CurrentLun;
    PSCSI_INQUIRY_DATA_INTERNAL InquiryArray;   
} TEMPORARY_INQUIRY_BUS_INFO, *PTEMPORARY_INQUIRY_BUS_INFO;


#define ASSERT_POINTER_ALIGNED(Pointer)\
    ASSERT (ALIGN_DOWN_POINTER (Pointer, sizeof (PVOID)) == (PVOID)Pointer)

//
// It's dumb that we have to have private versions of the ALIGN_XXXX macros,
// but the macros as defined only deal with types, not sizes.
//

#define ALIGN_DOWN_LENGTH(length, size) \
    ((ULONG)(length) & ~((size) - 1))

#define ALIGN_UP_LENGTH(length, size) \
    (ALIGN_DOWN_LENGTH(((ULONG)(length) + (size) - 1), size))

#define ALIGN_DOWN_POINTER_LENGTH(address, size) \
        ((PVOID)((ULONG_PTR)(address) & ~((ULONG_PTR)(size) - 1)))

#define ALIGN_UP_POINTER_LENGTH(address, size) \
        (ALIGN_DOWN_POINTER_LENGTH(((ULONG_PTR)(address) + size - 1), size))


LARGE_INTEGER
FORCEINLINE
LARGE(
    IN ULONG64 Input
    )
{
    LARGE_INTEGER Output;

    Output.QuadPart = Input;
    return Output;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\verify.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	verify.c

Abstract:

	This module implements the driver verifier for the STOR port driver.  

Author:

	Bryan Cheung (t-bcheun) 29-August-2001

Revision History:

--*/



#include "precomp.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, SpVerifierInitialization)
#pragma alloc_text(PAGE, StorPortInitializeVrfy)

#pragma alloc_text(PAGEVRFY, StorPortFreeDeviceBaseVrfy)
#pragma alloc_text(PAGEVRFY, StorPortGetBusDataVrfy)
#pragma alloc_text(PAGEVRFY, StorPortSetBusDataByOffsetVrfy)
#pragma alloc_text(PAGEVRFY, StorPortGetDeviceBaseVrfy)
#pragma alloc_text(PAGEVRFY, StorPortGetLogicalUnitVrfy)
#pragma alloc_text(PAGEVRFY, StorPortGetPhysicalAddressVrfy)
#pragma alloc_text(PAGEVRFY, StorPortGetVirtualAddressVrfy)
#pragma alloc_text(PAGEVRFY, StorPortGetUncachedExtensionVrfy)
#pragma alloc_text(PAGEVRFY, StorPortNotificationVrfy)
#pragma alloc_text(PAGEVRFY, StorPortLogErrorVrfy)
#pragma alloc_text(PAGEVRFY, StorPortCompleteRequestVrfy)
#pragma alloc_text(PAGEVRFY, StorPortMoveMemoryVrfy)
#pragma alloc_text(PAGEVRFY, StorPortStallExecutionVrfy)
#pragma alloc_text(PAGEVRFY, StorPortConvertUlongToPhysicalAddress)
#pragma alloc_text(PAGEVRFY, StorPortDebugPrintVrfy)
#pragma alloc_text(PAGEVRFY, StorPortReadPortUcharVrfy)
#pragma alloc_text(PAGEVRFY, StorPortReadPortUshortVrfy)
#pragma alloc_text(PAGEVRFY, StorPortReadPortUlongVrfy)
#pragma alloc_text(PAGEVRFY, StorPortReadPortBufferUcharVrfy)
#pragma alloc_text(PAGEVRFY, StorPortReadPortBufferUshortVrfy)
#pragma alloc_text(PAGEVRFY, StorPortReadPortBufferUlongVrfy)
#pragma alloc_text(PAGEVRFY, StorPortReadRegisterUcharVrfy)
#pragma alloc_text(PAGEVRFY, StorPortReadRegisterUshortVrfy)
#pragma alloc_text(PAGEVRFY, StorPortReadRegisterUlongVrfy)
#pragma alloc_text(PAGEVRFY, StorPortReadRegisterBufferUcharVrfy)
#pragma alloc_text(PAGEVRFY, StorPortReadRegisterBufferUshortVrfy)
#pragma alloc_text(PAGEVRFY, StorPortReadRegisterBufferUlongVrfy)
#pragma alloc_text(PAGEVRFY, StorPortWritePortUcharVrfy)
#pragma alloc_text(PAGEVRFY, StorPortWritePortUshortVrfy)
#pragma alloc_text(PAGEVRFY, StorPortWritePortUlongVrfy)
#pragma alloc_text(PAGEVRFY, StorPortWritePortBufferUcharVrfy)
#pragma alloc_text(PAGEVRFY, StorPortWritePortBufferUshortVrfy)
#pragma alloc_text(PAGEVRFY, StorPortWritePortBufferUlongVrfy)
#pragma alloc_text(PAGEVRFY, StorPortWriteRegisterUcharVrfy)
#pragma alloc_text(PAGEVRFY, StorPortWriteRegisterUshortVrfy)
#pragma alloc_text(PAGEVRFY, StorPortWriteRegisterUlongVrfy)
#pragma alloc_text(PAGEVRFY, StorPortWriteRegisterBufferUcharVrfy)
#pragma alloc_text(PAGEVRFY, StorPortWriteRegisterBufferUshortVrfy)
#pragma alloc_text(PAGEVRFY, StorPortWriteRegisterBufferUlongVrfy)
#pragma alloc_text(PAGEVRFY, StorPortPauseDeviceVrfy)
#pragma alloc_text(PAGEVRFY, StorPortResumeDeviceVrfy)
#pragma alloc_text(PAGEVRFY, StorPortPauseVrfy)
#pragma alloc_text(PAGEVRFY, StorPortResumeVrfy)
#pragma alloc_text(PAGEVRFY, StorPortDeviceBusyVrfy)
#pragma alloc_text(PAGEVRFY, StorPortDeviceReadyVrfy)
#pragma alloc_text(PAGEVRFY, StorPortBusyVrfy)
#pragma alloc_text(PAGEVRFY, StorPortReadyVrfy)
#pragma alloc_text(PAGEVRFY, StorPortGetScatterGatherListVrfy)
#pragma alloc_text(PAGEVRFY, StorPortSynchronizeAccessVrfy)
#pragma alloc_text(PAGEVRFY, RaidAllocateSrbExtensionVrfy)
#pragma alloc_text(PAGEVRFY, RaidGetOriginalSrbExtVa)
#pragma alloc_text(PAGEVRFY, RaidGetRemappedSrbExt)
#pragma alloc_text(PAGEVRFY, RaidInsertSrbExtension)
#pragma alloc_text(PAGEVRFY, RaidPrepareSrbExtensionForUse)
#pragma alloc_text(PAGEVRFY, RaidRemapBlock)
#pragma alloc_text(PAGEVRFY, RaidRemapCommonBufferForMiniport)
#pragma alloc_text(PAGEVRFY, RaidRemapScatterGatherList)
#pragma alloc_text(PAGEVRFY, RaidFreeRemappedScatterGatherListMdl)
#endif

//
// Indicates whether storport's verifier functionality has been initialized.
//
LOGICAL StorPortVerifierInitialized = FALSE;

//
// Global variable used to control verification aggressiveness.  This value is   
// used in conjunction with a per-adapter registry value, to control what type 
// of verification we don on a particular miniport.
//
ULONG SpVrfyLevel = 0;

//
// Indicates wheter storport verifier is enabled.
//
LOGICAL RaidVerifierEnabled = FALSE;

//
// Global variable used to control how aggressively we seek out stall offenders.  
// Default is a tenth of a second.
//
ULONG SpVrfyMaximumStall = 100000;

//
// Fill value for Srb Extension
//
UCHAR Signature = 0xFE;

//
// Handle to pageable verifier code sections.  We manually lock the verify code 
// into memory if we need it.
//
PVOID VerifierApiCodeSectionHandle = NULL;


#define BEGIN_VERIFIER_THUNK_TABLE(_Name)						\
	const DRIVER_VERIFIER_THUNK_PAIRS _Name[] = {

#define VERIFIER_THUNK_ENTRY(_Function)							\
		{ (PDRIVER_VERIFIER_THUNK_ROUTINE)(_Function),		\
		  (PDRIVER_VERIFIER_THUNK_ROUTINE)(_Function##Vrfy) },

#define END_VERIFIER_THUNK_TABLE()								\
			};
//
// This table represents the functions verify will thunk for us.
//

BEGIN_VERIFIER_THUNK_TABLE(StorPortVerifierFunctionTable)
	VERIFIER_THUNK_ENTRY (StorPortInitialize)
	VERIFIER_THUNK_ENTRY (StorPortFreeDeviceBase) 
	VERIFIER_THUNK_ENTRY (StorPortGetBusData) 
	VERIFIER_THUNK_ENTRY (StorPortSetBusDataByOffset) 
	VERIFIER_THUNK_ENTRY (StorPortGetDeviceBase) 
	VERIFIER_THUNK_ENTRY (StorPortGetLogicalUnit) 
	VERIFIER_THUNK_ENTRY (StorPortGetPhysicalAddress) 
	VERIFIER_THUNK_ENTRY (StorPortGetVirtualAddress) 
	VERIFIER_THUNK_ENTRY (StorPortGetUncachedExtension) 
	VERIFIER_THUNK_ENTRY (StorPortNotification) 
	VERIFIER_THUNK_ENTRY (StorPortLogError) 
	VERIFIER_THUNK_ENTRY (StorPortCompleteRequest) 
	VERIFIER_THUNK_ENTRY (StorPortMoveMemory) 
	VERIFIER_THUNK_ENTRY (StorPortStallExecution) 
	VERIFIER_THUNK_ENTRY (StorPortConvertUlongToPhysicalAddress) 
	VERIFIER_THUNK_ENTRY (StorPortDebugPrint) 
	VERIFIER_THUNK_ENTRY (StorPortReadPortUchar) 
	VERIFIER_THUNK_ENTRY (StorPortReadPortUshort) 
	VERIFIER_THUNK_ENTRY (StorPortReadPortUlong) 
	VERIFIER_THUNK_ENTRY (StorPortReadPortBufferUchar) 
	VERIFIER_THUNK_ENTRY (StorPortReadPortBufferUshort) 
	VERIFIER_THUNK_ENTRY (StorPortReadPortBufferUlong) 
	VERIFIER_THUNK_ENTRY (StorPortReadRegisterUchar) 
	VERIFIER_THUNK_ENTRY (StorPortReadRegisterUshort) 
	VERIFIER_THUNK_ENTRY (StorPortReadRegisterUlong) 
	VERIFIER_THUNK_ENTRY (StorPortReadRegisterBufferUchar) 
	VERIFIER_THUNK_ENTRY (StorPortReadRegisterBufferUshort) 
	VERIFIER_THUNK_ENTRY (StorPortReadRegisterBufferUlong) 
	VERIFIER_THUNK_ENTRY (StorPortWritePortUchar) 
	VERIFIER_THUNK_ENTRY (StorPortWritePortUshort) 
	VERIFIER_THUNK_ENTRY (StorPortWritePortUlong) 
	VERIFIER_THUNK_ENTRY (StorPortWritePortBufferUchar) 
	VERIFIER_THUNK_ENTRY (StorPortWritePortBufferUshort) 
	VERIFIER_THUNK_ENTRY (StorPortWritePortBufferUlong) 
	VERIFIER_THUNK_ENTRY (StorPortWriteRegisterUchar) 
	VERIFIER_THUNK_ENTRY (StorPortWriteRegisterUshort) 
	VERIFIER_THUNK_ENTRY (StorPortWriteRegisterUlong) 
	VERIFIER_THUNK_ENTRY (StorPortWriteRegisterBufferUchar) 
	VERIFIER_THUNK_ENTRY (StorPortWriteRegisterBufferUshort) 
	VERIFIER_THUNK_ENTRY (StorPortWriteRegisterBufferUlong) 
	VERIFIER_THUNK_ENTRY (StorPortPauseDevice) 
	VERIFIER_THUNK_ENTRY (StorPortResumeDevice) 
	VERIFIER_THUNK_ENTRY (StorPortPause) 
	VERIFIER_THUNK_ENTRY (StorPortResume) 
	VERIFIER_THUNK_ENTRY (StorPortDeviceBusy) 
	VERIFIER_THUNK_ENTRY (StorPortDeviceReady) 
	VERIFIER_THUNK_ENTRY (StorPortBusy) 
	VERIFIER_THUNK_ENTRY (StorPortReady) 
	VERIFIER_THUNK_ENTRY (StorPortGetScatterGatherList) 
	VERIFIER_THUNK_ENTRY (StorPortSynchronizeAccess) 
END_VERIFIER_THUNK_TABLE()


BOOLEAN
SpVerifierInitialization(
    VOID
    )

/*++

Routine Description:
    
    This routine initializes the storport's verifier functionality.
    
    Adds several of storport's exported functions to the list of toutines 
    thunked by the system verifier.
    
Arguments:

    VOID
    
Return Value:
    
    TRUE if verifier is successfully initialized.

--*/

{
    ULONG Flags;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // Query the system for verifier information.  This is to ensure that
    // verifier is present and operation on the system.
    //

    
    Status = MmIsVerifierEnabled(&Flags);
    
    if (NT_SUCCESS(Status)) {
        
        //
        // Add storport APIs to the set that will be thunked by the system
        // for verification.
        //

        Status = MmAddVerifierThunks((VOID *) StorPortVerifierFunctionTable, 
                                     sizeof(StorPortVerifierFunctionTable));
        if (NT_SUCCESS(Status)) {

            return TRUE;
        }
    }

    return FALSE;
}

ULONG
StorPortInitializeVrfy(
    IN PVOID Argument1,
    IN PVOID Argument2,
    IN PHW_INITIALIZATION_DATA HwInitializationData,
    IN PVOID Unused
    )
{

        ULONG Result;
                
        PAGED_CODE();

        //
        // Lock the thunked API routines down
        //
        
        #ifdef ALLOC_PRAGMA
            if (VerifierApiCodeSectionHandle == NULL) {
                VerifierApiCodeSectionHandle = MmLockPagableCodeSection(StorPortFreeDeviceBaseVrfy);
            }
        #endif
        
        if (Argument1 == NULL || Argument2 == NULL) {

            //
            // Argument1 and Argument2 must be non-NULL
            //

            KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                          STORPORT_VERIFIER_BAD_INIT_PARAMS,
                          (ULONG_PTR)Argument1,
                          (ULONG_PTR)Argument2,
                          0);
        }

        //
        // Forward the call on to StorPortInitialize/RaidPortInitialize
        //

        Result = StorPortInitialize(Argument1, Argument2, HwInitializationData, Unused);

        return Result;
}

VOID
StorPortFreeDeviceBaseVrfy(
	IN PVOID HwDeviceExtension,
	IN PVOID MappedAddress
	)
{
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_MINIPORT Miniport;
    
    Miniport = RaHwDeviceExtensionGetMiniport(HwDeviceExtension);
    Adapter = RaMiniportGetAdapter (Miniport);


	if (Miniport->Flags.InFindAdapter) {

		StorPortFreeDeviceBase(HwDeviceExtension, MappedAddress);

	} else {

		//
        // StorPortFreeDeviceBase can be called only from miniport driver's
        // HwStorFindAdapter routine
        //

        KeBugCheckEx (SCSI_VERIFIER_DETECTED_VIOLATION,
                      STORPORT_VERIFIER_BAD_ACCESS_SEMANTICS,
                      0,
                      0,
                      0);
	}
}

VOID
StorPortGetBusDataVrfy(
	IN PVOID HwDeviceExtension,
	IN ULONG BusDataType,
	IN ULONG SystemIoBusNumber,
	IN ULONG SlotNumber,
	IN PVOID Buffer,
	IN ULONG Length
	)
{
    
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_MINIPORT Miniport;
    
    Miniport = RaHwDeviceExtensionGetMiniport(HwDeviceExtension);
    Adapter = RaMiniportGetAdapter (Miniport);


    if (Miniport->Flags.InFindAdapter) {
        
        StorPortGetBusData(HwDeviceExtension, 
                           BusDataType, 
                           SystemIoBusNumber, 
                           SlotNumber, 
                           Buffer, 
                           Length);    
    } else {
        
        //
        // StorPortGetBusData can be called only from miniport driver's
        // HwStorFindAdapter routine
        //

        KeBugCheckEx (SCSI_VERIFIER_DETECTED_VIOLATION,
                      STORPORT_VERIFIER_BAD_ACCESS_SEMANTICS,
                      0,
                      0,
                      0);
    
    }
}

ULONG
StorPortSetBusDataByOffsetVrfy(
	IN PVOID DeviceExtension,
	IN ULONG BusDataType,
	IN ULONG SystemIoBusNumber,
	IN ULONG SlotNumber,
	IN PVOID Buffer,
	IN ULONG Offset,
	IN ULONG Length
	)
{
    ULONG NumBytes;
    
    #if 0
    if ((BUS_DATA_TYPE)BusDataType == PCIConfiguration) {

    }
    #endif
    
    //
    // Due to the nature of PnP, SlotNumber is an unnecessary paramter.
    // Specification should be modified to reflect this change, ie. 
    // In place of IN ULONG SlotNumber: IN ULONG Unused and must be 0
    //
    
    NumBytes = StorPortSetBusDataByOffset(DeviceExtension, 
                                          BusDataType, 
                                          SystemIoBusNumber, 
                                          SlotNumber, 
                                          Buffer, 
                                          Offset, 
                                          Length);

    return NumBytes;
}

PVOID
StorPortGetDeviceBaseVrfy(
	IN PVOID HwDeviceExtension,
	IN INTERFACE_TYPE BusType,
	IN ULONG SystemIoBusNumber,
	IN STOR_PHYSICAL_ADDRESS IoAddress,
	IN ULONG NumberOfBytes,
	IN BOOLEAN InIoSpace
	)
{
    PVOID MappedLogicalBaseAddress;

    //
    // This routine only supports addresses that were assigned to the driver
    // by the system PnP manager.  Verification for this requirement is 
    // implemented within the function StorPortGetDeviceBase.
    //

    MappedLogicalBaseAddress = StorPortGetDeviceBase(HwDeviceExtension, 
                                                     BusType, 
                                                     SystemIoBusNumber, 
                                                     IoAddress, 
                                                     NumberOfBytes, 
                                                     InIoSpace);

    if (MappedLogicalBaseAddress == NULL) {

        KeBugCheckEx (SCSI_VERIFIER_DETECTED_VIOLATION,
                      STORPORT_VERIFIER_NOT_PNP_ASSIGNED_ADDRESS,
                      0,
                      0,
                      0);

    }

    return MappedLogicalBaseAddress;
}

PVOID
StorPortGetLogicalUnitVrfy(
	IN PVOID HwDeviceExtension,
	IN UCHAR PathId,
	IN UCHAR TargetId,
	IN UCHAR Lun
	)
{
    PVOID LuStorage;

    LuStorage = StorPortGetLogicalUnit(HwDeviceExtension, 
                                       PathId, 
                                       TargetId, 
                                       Lun);

    return LuStorage;
}

#if 0
PSCSI_REQUEST_BLOCK
StorPortGetSrbVrfy(
	IN PVOID DeviceExtension,
	IN UCHAR PathId,
	IN UCHAR TargetId,
	IN UCHAR Lun,
	IN LONG QueueTag
	)
{
    PSCSI_REQUEST_BLOCK Srb;

    Srb = StorPortGetSrb(DeviceExtension, 
                         PathId, 
                         TargetId, 
                         Lun, 
                         QueueTag);

    return Srb;
}
#endif

STOR_PHYSICAL_ADDRESS
StorPortGetPhysicalAddressVrfy(
	IN PVOID HwDeviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb,
	IN PVOID VirtualAddress,
	OUT ULONG *Length
	)
{
    STOR_PHYSICAL_ADDRESS PhysicalAddress;
    
    PhysicalAddress = StorPortGetPhysicalAddress(HwDeviceExtension, 
                                                 Srb, 
                                                 VirtualAddress, 
                                                 Length);

    return PhysicalAddress;
}

PVOID
StorPortGetVirtualAddressVrfy(
	IN PVOID HwDeviceExtension,	
	IN STOR_PHYSICAL_ADDRESS PhysicalAddress
	)
{
    PVOID VirtualAddress;

    VirtualAddress = StorPortGetVirtualAddress(HwDeviceExtension, 
                                               PhysicalAddress);

    return VirtualAddress;
}

PVOID
StorPortGetUncachedExtensionVrfy(
	IN PVOID HwDeviceExtension,
	IN PPORT_CONFIGURATION_INFORMATION ConfigInfo,
	IN ULONG NumberOfBytes
	)
{
    PVOID UncachedExtension;
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_MINIPORT Miniport;
    
    Miniport = RaHwDeviceExtensionGetMiniport(HwDeviceExtension);
    Adapter = RaMiniportGetAdapter (Miniport);

    if (Miniport->Flags.InFindAdapter && ConfigInfo->Master &&
		RaGetSrbExtensionSize (Adapter)) {
        
        UncachedExtension = StorPortGetUncachedExtension (HwDeviceExtension, 
                                                          ConfigInfo, 
                                                          NumberOfBytes);

    } else {
        
        //
        // This routine can be called only from miniport driver's 
        // HwStorFindAdapter routine and only for a busmaster HBA.
        // A miniport must set the SrbExtensionSize before calling
        // StorPortGetUncachedExtension.
        //
        
        KeBugCheckEx (SCSI_VERIFIER_DETECTED_VIOLATION,
                      STORPORT_VERIFIER_BAD_ACCESS_SEMANTICS,
                      0,
                      0,
                      0);
    
    }

    return UncachedExtension;
}


VOID
StorPortNotificationVrfy(
	IN SCSI_NOTIFICATION_TYPE NotificationType,
	IN PVOID HwDeviceExtension,
    ...
    )
{
    
    PHW_TIMER HwStorTimer;
    PSCSI_REQUEST_BLOCK Srb;
    ULONG MiniportTimerValue;
    PVOID WMIEventItem;
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_MINIPORT Miniport;
    ULONG SrbExtensionSize;
    va_list vl;

    va_start(vl, HwDeviceExtension);
    
    switch (NotificationType) {
    
    case RequestComplete:
        
        Srb = va_arg(vl, PSCSI_REQUEST_BLOCK);

        Miniport = RaHwDeviceExtensionGetMiniport(HwDeviceExtension);
        Adapter = RaMiniportGetAdapter (Miniport);
        SrbExtensionSize = RaGetSrbExtensionSize(Adapter);

        RtlFillMemory(Srb->SrbExtension, SrbExtensionSize, Signature);
        

        #if 0
        //
        // Check that this request has not already been completed.
        //

        if ((Srb->SrbFlags & SRB_FLAGS_IS_ACTIVE) == 0) {
            KeBugCheckEx (SCSI_VERIFIER_DETECTED_VIOLATION,
                          STORPORT_VERIFIER_REQUEST_COMPLETED_TWICE,
                          0,
                          0,
                          0);

        }
        #endif

        //
        // Forward on to the real StorPortNotifiation routine.
        //

        StorPortNotification(NotificationType,
                             HwDeviceExtension,
                             Srb);
        va_end(vl);
        return;
    
    case ResetDetected:

        StorPortNotification(NotificationType,
                             HwDeviceExtension);
        va_end(vl);
        return;
        
    case RequestTimerCall:
        
        HwStorTimer = va_arg(vl, PHW_TIMER);
        MiniportTimerValue = va_arg(vl, ULONG);
        StorPortNotification(NotificationType,
                             HwDeviceExtension,
                             HwStorTimer,
                             MiniportTimerValue);
        va_end(vl);
        return;

    case WMIEvent:

        WMIEventItem = va_arg(vl, PVOID);
        PathId = va_arg(vl, UCHAR);

        /* if PathId != 0xFF, must have values for TargetId and Lun  */

        if (PathId != 0xFF) {
            TargetId = va_arg(vl, UCHAR);
            Lun = va_arg(vl, UCHAR);
            StorPortNotification(NotificationType,
                                 HwDeviceExtension,
                                 WMIEventItem,
                                 PathId,
                                 TargetId,
                                 Lun);
        } else {
            StorPortNotification(NotificationType,
                                 HwDeviceExtension,
                                 WMIEventItem,
                                 PathId);
        }

        va_end(vl);
        return;

    case WMIReregister:

        PathId = va_arg(vl, UCHAR);

        /* if PathId != 0xFF, must have values for TargetId and Lun  */

        if (PathId != 0xFF) {
            TargetId = va_arg(vl, UCHAR);
            Lun = va_arg(vl, UCHAR);
            StorPortNotification(NotificationType,
                                 HwDeviceExtension,
                                 PathId,
                                 TargetId,
                                 Lun);
        } else {
            StorPortNotification(NotificationType,
                                 HwDeviceExtension,
                                 PathId);
        }

        va_end(vl);
        return;

    default:

        StorPortNotification(NotificationType,
                             HwDeviceExtension);
        va_end(vl);
        return;
    }

}


VOID
StorPortLogErrorVrfy(
	IN PVOID HwDeviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb OPTIONAL,
	IN UCHAR PathId,
	IN UCHAR TargetId,
	IN UCHAR Lun,
	IN ULONG ErrorCode,
	IN ULONG UniqueId
	)
{
    StorPortLogError(HwDeviceExtension, 
                     Srb, 
                     PathId, 
                     TargetId, 
                     Lun, 
                     ErrorCode, 
                     UniqueId);
}

VOID 
StorPortCompleteRequestVrfy(
	IN PVOID HwDeviceExtension,
	IN UCHAR PathId,
	IN UCHAR TargetId,
	IN UCHAR Lun,
	IN UCHAR SrbStatus
	)
{
    StorPortCompleteRequest(HwDeviceExtension, 
                            PathId, 
                            TargetId, 
                            Lun, 
                            SrbStatus);
}

VOID	
StorPortMoveMemoryVrfy(
	IN PVOID WriteBuffer,
	IN PVOID ReadBuffer,
	IN ULONG Length
	)
{
    StorPortMoveMemory(WriteBuffer, 
                       ReadBuffer, 
                       Length);
}


VOID
StorPortStallExecutionVrfy(
	IN ULONG Delay
	)
{
    if (Delay > SpVrfyMaximumStall) {
        KeBugCheckEx(SCSI_VERIFIER_DETECTED_VIOLATION,
                     STORPORT_VERIFIER_STALL_TOO_LONG,
                     (ULONG_PTR)Delay,
                     0,
                     0);
        //
        // Need to add STOR_VERIFIER_DETECTED_VIOLATION
        //
    }
    
    StorPortStallExecution(Delay);  
}

STOR_PHYSICAL_ADDRESS
StorPortConvertUlongToPhysicalAddressVrfy(
    ULONG_PTR UlongAddress
    )
{
    STOR_PHYSICAL_ADDRESS PhysicalAddress;

    PhysicalAddress = StorPortConvertUlongToPhysicalAddress(UlongAddress);

    return PhysicalAddress;
}

#if 0
STOR_PHYSICAL_ADDRESS
StorPortConvertUlong64ToPhysicalAddressVrfy(
	IN ULONG64 UlongAddress
	)
{
    StorPortConvertUlong64ToPhysicalAddress(UlongAddress);
}

ULONG64
StorPortConvertPhysicalAddressToUlong64Vrfy(
	IN STOR_PHYSICAL_ADDRESS Address
	)
{
    StorPortConvertPhysicalAddressToUlong64(Address);
}

BOOLEAN
StorPortValidateRangeVrfy(
	IN PVOID HwDeviceExtension,
	IN INTERFACE_TYPE BusType,
	IN ULONG SystemIoBusNumber,
	IN STOR_PHYSICAL_ADDRESS IoAddress,
	IN ULONG NumberOfBytes,
	IN BOOLEAn InIoSpace
	)
{
    StorPortValidateRange(HwDeviceExtension, 
                          BusType, 
                          SystemIoBusNumber, 
                          IoAddress, 
                          NumberOfBytes, 
                          InIoSpace);
}
#endif

UCHAR
StorPortReadPortUcharVrfy(
    IN PVOID HwDeviceExtension,
    IN PUCHAR Port
    )
{
    ULONG Count;
    ULONG i;
    ULONG64 LowerLimit;
    ULONG64 HigherLimit;
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_MINIPORT Miniport;
    PRAID_RESOURCE_LIST ResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR Translated;
    PCM_FULL_RESOURCE_DESCRIPTOR Descriptor;
    NTSTATUS Status;
    
    Miniport = RaHwDeviceExtensionGetMiniport(HwDeviceExtension);
    Adapter = RaMiniportGetAdapter (Miniport);
    ResourceList = &Adapter->ResourceList;

    //
    // Only CM_RESOURCE_LISTs with one element are supported
    //
    
    ASSERT (ResourceList->TranslatedResources->Count == 1);

    Count = ResourceList->TranslatedResources->List[0].PartialResourceList.Count;

    //
    // Iterate throught the range of addresses in the Translated Resources List
    //
    
    for (i = 0; i < Count; i++) {

        Descriptor = &ResourceList->TranslatedResources->List[0];
        Translated = &Descriptor->PartialResourceList.PartialDescriptors[i];

        LowerLimit = Translated->u.Generic.Start.QuadPart;
        HigherLimit = LowerLimit + Translated->u.Generic.Length;

        if ((LowerLimit <= (ULONG64)(LONG64)Port) || (HigherLimit >= (ULONG64)(LONG64)Port)) {

            return(StorPortReadPortUchar(HwDeviceExtension, Port));

        }

    }

    KeBugCheckEx (SCSI_VERIFIER_DETECTED_VIOLATION,
                  STORPORT_VERIFIER_BAD_VIRTUAL_ADDRESS,
                  0,
                  0,
                  0);

}

USHORT
StorPortReadPortUshortVrfy(
    IN PVOID HwDeviceExtension,
    IN PUSHORT Port
    )
{
    ULONG Count;
    ULONG i;
    ULONG64 LowerLimit;
    ULONG64 HigherLimit;
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_MINIPORT Miniport;
    PRAID_RESOURCE_LIST ResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR Translated;
    PCM_FULL_RESOURCE_DESCRIPTOR Descriptor;
    NTSTATUS Status;
    
    Miniport = RaHwDeviceExtensionGetMiniport(HwDeviceExtension);
    Adapter = RaMiniportGetAdapter (Miniport);
    ResourceList = &Adapter->ResourceList;

    //
    // Only CM_RESOURCE_LISTs with one element are supported
    //
    
    ASSERT (ResourceList->TranslatedResources->Count == 1);

    Count = ResourceList->TranslatedResources->List[0].PartialResourceList.Count;

    //
    // Iterate throught the range of addresses in the Translated Resources List
    //
    
    for (i = 0; i < Count; i++) {

        Descriptor = &ResourceList->TranslatedResources->List[0];
        Translated = &Descriptor->PartialResourceList.PartialDescriptors[i];

        LowerLimit = Translated->u.Generic.Start.QuadPart;
        HigherLimit = LowerLimit + Translated->u.Generic.Length;

        if ((LowerLimit <= (ULONG64)(LONG64)Port) || (HigherLimit >= (ULONG64)(LONG64)Port)) {

            return(StorPortReadPortUshort(HwDeviceExtension, Port));


        }

    }

    KeBugCheckEx (SCSI_VERIFIER_DETECTED_VIOLATION,
                  STORPORT_VERIFIER_BAD_VIRTUAL_ADDRESS,
                  0,
                  0,
                  0);

}

ULONG
StorPortReadPortUlongVrfy(
    IN PVOID HwDeviceExtension,
    IN PULONG Port
    )
{
    ULONG Count;
    ULONG i;
    ULONG64 LowerLimit;
    ULONG64 HigherLimit;
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_MINIPORT Miniport;
    PRAID_RESOURCE_LIST ResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR Translated;
    PCM_FULL_RESOURCE_DESCRIPTOR Descriptor;
    NTSTATUS Status;

    Miniport = RaHwDeviceExtensionGetMiniport(HwDeviceExtension);
    Adapter = RaMiniportGetAdapter (Miniport);
    ResourceList = &Adapter->ResourceList;

    //
    // Only CM_RESOURCE_LISTs with one element are supported
    //

    ASSERT (ResourceList->TranslatedResources->Count == 1);
    
    Count = ResourceList->TranslatedResources->List[0].PartialResourceList.Count;

    //
    // Iterate throught the range of addresses in the Translated Resources List
    //

    for (i = 0; i < Count; i++) {

        Descriptor = &ResourceList->TranslatedResources->List[0];
        Translated = &Descriptor->PartialResourceList.PartialDescriptors[i];
        
        LowerLimit = Translated->u.Generic.Start.QuadPart;
        HigherLimit = LowerLimit + Translated->u.Generic.Length;

        if ((LowerLimit <= (ULONG64)(LONG64)Port) || (HigherLimit >= (ULONG64)(LONG64)Port)) {

            return(StorPortReadPortUlong(HwDeviceExtension, Port));


        }

    }

    KeBugCheckEx (SCSI_VERIFIER_DETECTED_VIOLATION,
                  STORPORT_VERIFIER_BAD_VIRTUAL_ADDRESS,
                  0,
                  0,
                  0);

}

VOID
StorPortReadPortBufferUcharVrfy(
    IN PVOID HwDeviceExtension,
    IN PUCHAR Port,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )
{
    ULONG ResourceListCount;
    ULONG i;
    ULONG64 LowerLimit;
    ULONG64 HigherLimit;
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_MINIPORT Miniport;
    PRAID_RESOURCE_LIST ResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR Translated;
    PCM_FULL_RESOURCE_DESCRIPTOR Descriptor;
    NTSTATUS Status;
    
    Miniport = RaHwDeviceExtensionGetMiniport(HwDeviceExtension);
    Adapter = RaMiniportGetAdapter (Miniport);
    ResourceList = &Adapter->ResourceList;

    //
    // Only CM_RESOURCE_LISTs with one element are supported
    //
    
    ASSERT (ResourceList->TranslatedResources->Count == 1);

    ResourceListCount = ResourceList->TranslatedResources->List[0].PartialResourceList.Count;

    //
    // Iterate throught the range of addresses in the Translated Resources List
    //
    
    for (i = 0; i < ResourceListCount; i++) {

        Descriptor = &ResourceList->TranslatedResources->List[0];
        Translated = &Descriptor->PartialResourceList.PartialDescriptors[i];

        LowerLimit = Translated->u.Generic.Start.QuadPart;
        HigherLimit = LowerLimit + Translated->u.Generic.Length;

        if ((LowerLimit <= (ULONG64)(LONG64)Port) || (HigherLimit >= (ULONG64)(LONG64)Port)) {

            StorPortReadPortBufferUchar(HwDeviceExtension, Port, Buffer, Count);

        }

    }

    KeBugCheckEx (SCSI_VERIFIER_DETECTED_VIOLATION,
                  STORPORT_VERIFIER_BAD_VIRTUAL_ADDRESS,
                  0,
                  0,
                  0);


    
}

VOID
StorPortReadPortBufferUshortVrfy(
    IN PVOID HwDeviceExtension,
    IN PUSHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    )
{
    ULONG ResourceListCount;
    ULONG i;
    ULONG64 LowerLimit;
    ULONG64 HigherLimit;
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_MINIPORT Miniport;
    PRAID_RESOURCE_LIST ResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR Translated;
    PCM_FULL_RESOURCE_DESCRIPTOR Descriptor;
    NTSTATUS Status;
    
    Miniport = RaHwDeviceExtensionGetMiniport(HwDeviceExtension);
    Adapter = RaMiniportGetAdapter (Miniport);
    ResourceList = &Adapter->ResourceList;

    //
    // Only CM_RESOURCE_LISTs with one element are supported
    //
    
    ASSERT (ResourceList->TranslatedResources->Count == 1);

    ResourceListCount = ResourceList->TranslatedResources->List[0].PartialResourceList.Count;

    //
    // Iterate throught the range of addresses in the Translated Resources List
    //
    
    for (i = 0; i < ResourceListCount; i++) {

        Descriptor = &ResourceList->TranslatedResources->List[0];
        Translated = &Descriptor->PartialResourceList.PartialDescriptors[i];

        LowerLimit = Translated->u.Generic.Start.QuadPart;
        HigherLimit = LowerLimit + Translated->u.Generic.Length;

        if ((LowerLimit <= (ULONG64)(LONG64)Port) || (HigherLimit >= (ULONG64)(LONG64)Port)) {

            StorPortReadPortBufferUshort(HwDeviceExtension, Port, Buffer, Count);

        }

    }

    KeBugCheckEx (SCSI_VERIFIER_DETECTED_VIOLATION,
                  STORPORT_VERIFIER_BAD_VIRTUAL_ADDRESS,
                  0,
                  0,
                  0);

    
}

VOID
StorPortReadPortBufferUlongVrfy(
    IN PVOID HwDeviceExtension,
    IN PULONG Port,
    IN PULONG Buffer,
    IN ULONG Count
    )
{
    ULONG ResourceListCount;
    ULONG i;
    ULONG64 LowerLimit;
    ULONG64 HigherLimit;
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_MINIPORT Miniport;
    PRAID_RESOURCE_LIST ResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR Translated;
    PCM_FULL_RESOURCE_DESCRIPTOR Descriptor;
    NTSTATUS Status;
    
    Miniport = RaHwDeviceExtensionGetMiniport(HwDeviceExtension);
    Adapter = RaMiniportGetAdapter (Miniport);
    ResourceList = &Adapter->ResourceList;

    //
    // Only CM_RESOURCE_LISTs with one element are supported
    //
    
    ASSERT (ResourceList->TranslatedResources->Count == 1);

    ResourceListCount = ResourceList->TranslatedResources->List[0].PartialResourceList.Count;

    //
    // Iterate throught the range of addresses in the Translated Resources List
    //
    
    for (i = 0; i < ResourceListCount; i++) {

        Descriptor = &ResourceList->TranslatedResources->List[0];
        Translated = &Descriptor->PartialResourceList.PartialDescriptors[i];

        LowerLimit = Translated->u.Generic.Start.QuadPart;
        HigherLimit = LowerLimit + Translated->u.Generic.Length;

        if ((LowerLimit <= (ULONG64)(LONG64)Port) || (HigherLimit >= (ULONG64)(LONG64)Port)) {

            StorPortReadPortBufferUlong(HwDeviceExtension, Port, Buffer, Count);

        }

    }

    KeBugCheckEx (SCSI_VERIFIER_DETECTED_VIOLATION,
                  STORPORT_VERIFIER_BAD_VIRTUAL_ADDRESS,
                  0,
                  0,
                  0);

    
}

UCHAR
StorPortReadRegisterUcharVrfy(
    IN PVOID HwDeviceExtension,
    IN PUCHAR Register
    )
{
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_MINIPORT Miniport;
    PMAPPED_ADDRESS ListIterator;
    ULONG64 LowerLimit;
    ULONG64 HigherLimit;
    NTSTATUS Status;
    
    Miniport = RaHwDeviceExtensionGetMiniport(HwDeviceExtension);
    Adapter = RaMiniportGetAdapter (Miniport);

    //
    // Search through the Mapped Address List to verify Register is
    // in mapped memory-space range returned by StorPortGetDeviceBase
    //

    Status = STATUS_UNSUCCESSFUL;
    ListIterator = Adapter->MappedAddressList;
    
    while (ListIterator != NULL) {
        LowerLimit = (ULONG64)ListIterator->MappedAddress;
        HigherLimit = LowerLimit + ListIterator->NumberOfBytes;
        if ((LowerLimit <= (ULONG64)(LONG64)Register) && (HigherLimit >= (ULONG64)(LONG64)Register)) { 
            
            Status = STATUS_SUCCESS;
            break;
        
        } else {

            ListIterator = ListIterator->NextMappedAddress;
        
        }
    }
    
    if (!NT_SUCCESS (Status)) {
        KeBugCheckEx (SCSI_VERIFIER_DETECTED_VIOLATION,
                      STORPORT_VERIFIER_BAD_VIRTUAL_ADDRESS,
                      0,
                      0,
                      0);

    }

	return (StorPortReadRegisterUchar(HwDeviceExtension, Register));
}

USHORT
StorPortReadRegisterUshortVrfy(
    IN PVOID HwDeviceExtension,
    IN PUSHORT Register
    )
{
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_MINIPORT Miniport;
    PMAPPED_ADDRESS ListIterator;
    ULONG64 LowerLimit;
    ULONG64 HigherLimit;
    NTSTATUS Status;
    
    Miniport = RaHwDeviceExtensionGetMiniport(HwDeviceExtension);
    Adapter = RaMiniportGetAdapter (Miniport);

    //
    // Search through the Mapped Address List to verify Register is
    // in mapped memory-space range returned by StorPortGetDeviceBase
    //

    Status = STATUS_UNSUCCESSFUL;
    ListIterator = Adapter->MappedAddressList;
    
    while (ListIterator != NULL) {
        LowerLimit = (ULONG64)ListIterator->MappedAddress;
        HigherLimit = LowerLimit + ListIterator->NumberOfBytes;
        if ((LowerLimit <= (ULONG64)(LONG64)Register) && (HigherLimit >= (ULONG64)(LONG64)Register)) { 
            
            Status = STATUS_SUCCESS;
            break;
        
        } else {

            ListIterator = ListIterator->NextMappedAddress;
        
        }
    }
    
    if (!NT_SUCCESS (Status)) {
        KeBugCheckEx (SCSI_VERIFIER_DETECTED_VIOLATION,
                      STORPORT_VERIFIER_BAD_VIRTUAL_ADDRESS,
                      0,
                      0,
                      0);

    }

	return(StorPortReadRegisterUshort(HwDeviceExtension, Register));
}

ULONG
StorPortReadRegisterUlongVrfy(
    IN PVOID HwDeviceExtension,
    IN PULONG Register
    )
{   
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_MINIPORT Miniport;
    PMAPPED_ADDRESS ListIterator;
    ULONG64 LowerLimit;
    ULONG64 HigherLimit;
    NTSTATUS Status;
    
    Miniport = RaHwDeviceExtensionGetMiniport(HwDeviceExtension);
    Adapter = RaMiniportGetAdapter (Miniport);

    //
    // Search through the Mapped Address List to verify Register is
    // in mapped memory-space range returned by StorPortGetDeviceBase
    //

    Status = STATUS_UNSUCCESSFUL;
    ListIterator = Adapter->MappedAddressList;
    
    while (ListIterator != NULL) {
        LowerLimit = (ULONG64)ListIterator->MappedAddress;
        HigherLimit = LowerLimit + ListIterator->NumberOfBytes;
        if ((LowerLimit <= (ULONG64)(LONG64)Register) && (HigherLimit >= (ULONG64)(LONG64)Register)) { 
            
            Status = STATUS_SUCCESS;
            break;
        
        }
        else {

            ListIterator = ListIterator->NextMappedAddress;
        
        }
    }
    
    if (!NT_SUCCESS (Status)) {
        KeBugCheckEx (SCSI_VERIFIER_DETECTED_VIOLATION,
                      STORPORT_VERIFIER_BAD_VIRTUAL_ADDRESS,
                      0,
                      0,
                      0);

    }

	return (StorPortReadRegisterUlong(HwDeviceExtension, Register));
}

VOID
StorPortReadRegisterBufferUcharVrfy(
    IN PVOID HwDeviceExtension,
    IN PUCHAR Register,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )
{
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_MINIPORT Miniport;
    PMAPPED_ADDRESS ListIterator;
    ULONG64 LowerLimit;
    ULONG64 HigherLimit;
    NTSTATUS Status;
    
    Miniport = RaHwDeviceExtensionGetMiniport(HwDeviceExtension);
    Adapter = RaMiniportGetAdapter (Miniport);

    //
    // Search through the Mapped Address List to verify Register is
    // in mapped memory-space range returned by StorPortGetDeviceBase
    //

    Status = STATUS_UNSUCCESSFUL;
    ListIterator = Adapter->MappedAddressList;
    
    while (ListIterator != NULL) {
        LowerLimit = (ULONG64)ListIterator->MappedAddress;
        HigherLimit = LowerLimit + ListIterator->NumberOfBytes;
        if ((LowerLimit <= (ULONG64)(LONG64)Register) && (HigherLimit >= (ULONG64)(LONG64)Register)) { 
            
            Status = STATUS_SUCCESS;
            break;
        
        } else {

            ListIterator = ListIterator->NextMappedAddress;
        
        }
    }
    
    if (!NT_SUCCESS (Status)) {
        KeBugCheckEx (SCSI_VERIFIER_DETECTED_VIOLATION,
                      STORPORT_VERIFIER_BAD_VIRTUAL_ADDRESS,
                      0,
                      0,
                      0);

    }

	StorPortReadRegisterBufferUchar (HwDeviceExtension,
									 Register,
									 Buffer,
									 Count);

}

VOID
StorPortReadRegisterBufferUshortVrfy(
    IN PVOID HwDeviceExtension,
    IN PUSHORT Register,
    IN PUSHORT Buffer,
    IN ULONG Count
    )
{
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_MINIPORT Miniport;
    PMAPPED_ADDRESS ListIterator;
    ULONG64 LowerLimit;
    ULONG64 HigherLimit;
    NTSTATUS Status;
    
    Miniport = RaHwDeviceExtensionGetMiniport(HwDeviceExtension);
    Adapter = RaMiniportGetAdapter (Miniport);

    //
    // Search through the Mapped Address List to verify Register is
    // in mapped memory-space range returned by StorPortGetDeviceBase
    //

    Status = STATUS_UNSUCCESSFUL;
    ListIterator = Adapter->MappedAddressList;
    
    while (ListIterator != NULL) {
        LowerLimit = (ULONG64)ListIterator->MappedAddress;
        HigherLimit = LowerLimit + ListIterator->NumberOfBytes;
        if ((LowerLimit <= (ULONG64)(LONG64)Register) && (HigherLimit >= (ULONG64)(LONG64)Register)) { 
            
            Status = STATUS_SUCCESS;
            break;
        
        } else {

            ListIterator = ListIterator->NextMappedAddress;
        
        }
    }
    
    if (!NT_SUCCESS (Status)) {
        KeBugCheckEx (SCSI_VERIFIER_DETECTED_VIOLATION,
                      STORPORT_VERIFIER_BAD_VIRTUAL_ADDRESS,
                      0,
                      0,
                      0);

    }
    
	StorPortReadRegisterBufferUshort(HwDeviceExtension, Register, Buffer, Count);
}

VOID
StorPortReadRegisterBufferUlongVrfy(
    IN PVOID HwDeviceExtension,
    IN PULONG Register,
    IN PULONG Buffer,
    IN ULONG Count
    )
{
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_MINIPORT Miniport;
    PMAPPED_ADDRESS ListIterator;
    ULONG64 LowerLimit;
    ULONG64 HigherLimit;
    NTSTATUS Status;
    
    Miniport = RaHwDeviceExtensionGetMiniport(HwDeviceExtension);
    Adapter = RaMiniportGetAdapter (Miniport);

    //
    // Search through the Mapped Address List to verify Register is
    // in mapped memory-space range returned by StorPortGetDeviceBase
    //

    Status = STATUS_UNSUCCESSFUL;
    ListIterator = Adapter->MappedAddressList;
    
    while (ListIterator != NULL) {
        LowerLimit = (ULONG64)ListIterator->MappedAddress;
        HigherLimit = LowerLimit + ListIterator->NumberOfBytes;
        if ((LowerLimit <= (ULONG64)(LONG64)Register) && (HigherLimit >= (ULONG64)(LONG64)Register)) { 
            
            Status = STATUS_SUCCESS;
            break;
        
        } else {

            ListIterator = ListIterator->NextMappedAddress;
        
        }
    }
    
    if (!NT_SUCCESS (Status)) {
        KeBugCheckEx (SCSI_VERIFIER_DETECTED_VIOLATION,
                      STORPORT_VERIFIER_BAD_VIRTUAL_ADDRESS,
                      0,
                      0,
                      0);

    }
    
	StorPortReadRegisterBufferUlong (HwDeviceExtension,
									 Register,
									 Buffer,
									 Count);
}

VOID
StorPortWritePortUcharVrfy(
    IN PVOID HwDeviceExtension,
    IN PUCHAR Port,
    IN UCHAR Value
    )
{
    ULONG Count;
    ULONG i;
    ULONG64 LowerLimit;
    ULONG64 HigherLimit;
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_MINIPORT Miniport;
    PRAID_RESOURCE_LIST ResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR Translated;
    PCM_FULL_RESOURCE_DESCRIPTOR Descriptor;
    NTSTATUS Status;

    Miniport = RaHwDeviceExtensionGetMiniport(HwDeviceExtension);
    Adapter = RaMiniportGetAdapter (Miniport);
    ResourceList = &Adapter->ResourceList;

    //
    // Only CM_RESOURCE_LISTs with one element are supported
    //

    ASSERT (ResourceList->TranslatedResources->Count == 1);
    
    Count = ResourceList->TranslatedResources->List[0].PartialResourceList.Count;

    //
    // Iterate throught the range of addresses in the Translated Resources List
    //

    for (i = 0; i < Count; i++) {

        Descriptor = &ResourceList->TranslatedResources->List[0];
        Translated = &Descriptor->PartialResourceList.PartialDescriptors[i];
        
        LowerLimit = Translated->u.Generic.Start.QuadPart;
        HigherLimit = LowerLimit + Translated->u.Generic.Length;

        if ((LowerLimit <= (ULONG64)(LONG64)Port) || (HigherLimit >= (ULONG64)(LONG64)Port)) {

            StorPortWritePortUchar(HwDeviceExtension, Port, Value);


        }

    }

    KeBugCheckEx (SCSI_VERIFIER_DETECTED_VIOLATION,
                  STORPORT_VERIFIER_BAD_VIRTUAL_ADDRESS,
                  0,
                  0,
                  0);

}

VOID
StorPortWritePortUshortVrfy(
    IN PVOID HwDeviceExtension,
    IN PUSHORT Port,
    IN USHORT Value
    )
{
    ULONG Count;
    ULONG i;
    ULONG64 LowerLimit;
    ULONG64 HigherLimit;
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_MINIPORT Miniport;
    PRAID_RESOURCE_LIST ResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR Translated;
    PCM_FULL_RESOURCE_DESCRIPTOR Descriptor;
    NTSTATUS Status;

    Miniport = RaHwDeviceExtensionGetMiniport(HwDeviceExtension);
    Adapter = RaMiniportGetAdapter (Miniport);
    ResourceList = &Adapter->ResourceList;

    //
    // Only CM_RESOURCE_LISTs with one element are supported
    //

    ASSERT (ResourceList->TranslatedResources->Count == 1);
    
    Count = ResourceList->TranslatedResources->List[0].PartialResourceList.Count;

    //
    // Iterate throught the range of addresses in the Translated Resources List
    //

    for (i = 0; i < Count; i++) {

        Descriptor = &ResourceList->TranslatedResources->List[0];
        Translated = &Descriptor->PartialResourceList.PartialDescriptors[i];
        
        LowerLimit = Translated->u.Generic.Start.QuadPart;
        HigherLimit = LowerLimit + Translated->u.Generic.Length;

        if ((LowerLimit <= (ULONG64)(LONG64)Port) || (HigherLimit >= (ULONG64)(LONG64)Port)) {

            StorPortWritePortUshort(HwDeviceExtension, Port, Value);


        }

    }

    KeBugCheckEx (SCSI_VERIFIER_DETECTED_VIOLATION,
                  STORPORT_VERIFIER_BAD_VIRTUAL_ADDRESS,
                  0,
                  0,
                  0);

}

VOID
StorPortWritePortUlongVrfy(
    IN PVOID HwDeviceExtension,
    IN PULONG Port,
    IN ULONG Value
    )
{
    ULONG Count;
    ULONG i;
    ULONG64 LowerLimit;
    ULONG64 HigherLimit;
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_MINIPORT Miniport;
    PRAID_RESOURCE_LIST ResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR Translated;
    PCM_FULL_RESOURCE_DESCRIPTOR Descriptor;
    NTSTATUS Status;

    Miniport = RaHwDeviceExtensionGetMiniport(HwDeviceExtension);
    Adapter = RaMiniportGetAdapter (Miniport);
    ResourceList = &Adapter->ResourceList;

    //
    // Only CM_RESOURCE_LISTs with one element are supported
    //

    ASSERT (ResourceList->TranslatedResources->Count == 1);
    
    Count = ResourceList->TranslatedResources->List[0].PartialResourceList.Count;

    //
    // Iterate throught the range of addresses in the Translated Resources List
    //

    for (i = 0; i < Count; i++) {

        Descriptor = &ResourceList->TranslatedResources->List[0];
        Translated = &Descriptor->PartialResourceList.PartialDescriptors[i];
        
        LowerLimit = Translated->u.Generic.Start.QuadPart;
        HigherLimit = LowerLimit + Translated->u.Generic.Length;

        if ((LowerLimit <= (ULONG64)(LONG64)Port) || (HigherLimit >= (ULONG64)(LONG64)Port)) {

            StorPortWritePortUlong(HwDeviceExtension, Port, Value);


        }

    }

    KeBugCheckEx (SCSI_VERIFIER_DETECTED_VIOLATION,
                  STORPORT_VERIFIER_BAD_VIRTUAL_ADDRESS,
                  0,
                  0,
                  0);

}

VOID
StorPortWritePortBufferUcharVrfy(
    IN PVOID HwDeviceExtension,
    IN PUCHAR Port,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )
{
    ULONG ResourceListCount;
    ULONG i;
    ULONG64 LowerLimit;
    ULONG64 HigherLimit;
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_MINIPORT Miniport;
    PRAID_RESOURCE_LIST ResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR Translated;
    PCM_FULL_RESOURCE_DESCRIPTOR Descriptor;
    NTSTATUS Status;

    Miniport = RaHwDeviceExtensionGetMiniport(HwDeviceExtension);
    Adapter = RaMiniportGetAdapter (Miniport);
    ResourceList = &Adapter->ResourceList;

    //
    // Only CM_RESOURCE_LISTs with one element are supported
    //

    ASSERT (ResourceList->TranslatedResources->Count == 1);
    
    ResourceListCount = ResourceList->TranslatedResources->List[0].PartialResourceList.Count;

    //
    // Iterate throught the range of addresses in the Translated Resources List
    //

    for (i = 0; i < ResourceListCount; i++) {

        Descriptor = &ResourceList->TranslatedResources->List[0];
        Translated = &Descriptor->PartialResourceList.PartialDescriptors[i];
        
        LowerLimit = Translated->u.Generic.Start.QuadPart;
        HigherLimit = LowerLimit + Translated->u.Generic.Length;

        if ((LowerLimit <= (ULONG64)(LONG64)Port) || (HigherLimit >= (ULONG64)(LONG64)Port)) {

            StorPortWritePortBufferUchar(HwDeviceExtension, Port, Buffer, Count);


        }

    }

    KeBugCheckEx (SCSI_VERIFIER_DETECTED_VIOLATION,
                  STORPORT_VERIFIER_BAD_VIRTUAL_ADDRESS,
                  0,
                  0,
                  0);

    
}

VOID
StorPortWritePortBufferUshortVrfy(
    IN PVOID HwDeviceExtension,
    IN PUSHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    )
{
    ULONG ResourceListCount;
    ULONG i;
    ULONG64 LowerLimit;
    ULONG64 HigherLimit;
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_MINIPORT Miniport;
    PRAID_RESOURCE_LIST ResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR Translated;
    PCM_FULL_RESOURCE_DESCRIPTOR Descriptor;
    NTSTATUS Status;

    Miniport = RaHwDeviceExtensionGetMiniport(HwDeviceExtension);
    Adapter = RaMiniportGetAdapter (Miniport);
    ResourceList = &Adapter->ResourceList;

    //
    // Only CM_RESOURCE_LISTs with one element are supported
    //

    ASSERT (ResourceList->TranslatedResources->Count == 1);
    
    ResourceListCount = ResourceList->TranslatedResources->List[0].PartialResourceList.Count;

    //
    // Iterate throught the range of addresses in the Translated Resources List
    //

    for (i = 0; i < ResourceListCount; i++) {

        Descriptor = &ResourceList->TranslatedResources->List[0];
        Translated = &Descriptor->PartialResourceList.PartialDescriptors[i];
        
        LowerLimit = Translated->u.Generic.Start.QuadPart;
        HigherLimit = LowerLimit + Translated->u.Generic.Length;

        if ((LowerLimit <= (ULONG64)(LONG64)Port) || (HigherLimit >= (ULONG64)(LONG64)Port)) {

            StorPortWritePortBufferUshort(HwDeviceExtension, Port, Buffer, Count);

        }

    }

    KeBugCheckEx (SCSI_VERIFIER_DETECTED_VIOLATION,
                  STORPORT_VERIFIER_BAD_VIRTUAL_ADDRESS,
                  0,
                  0,
                  0);

}

VOID
StorPortWritePortBufferUlongVrfy(
    IN PVOID HwDeviceExtension,
    IN PULONG Port,
    IN PULONG Buffer,
    IN ULONG Count
    )
{
    ULONG ResourceListCount;
    ULONG i;
    ULONG64 LowerLimit;
    ULONG64 HigherLimit;
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_MINIPORT Miniport;
    PRAID_RESOURCE_LIST ResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR Translated;
    PCM_FULL_RESOURCE_DESCRIPTOR Descriptor;
    NTSTATUS Status;

    Miniport = RaHwDeviceExtensionGetMiniport(HwDeviceExtension);
    Adapter = RaMiniportGetAdapter (Miniport);
    ResourceList = &Adapter->ResourceList;

    //
    // Only CM_RESOURCE_LISTs with one element are supported
    //

    ASSERT (ResourceList->TranslatedResources->Count == 1);
    
    ResourceListCount = ResourceList->TranslatedResources->List[0].PartialResourceList.Count;

    //
    // Iterate throught the range of addresses in the Translated Resources List
    //

    for (i = 0; i < ResourceListCount; i++) {

        Descriptor = &ResourceList->TranslatedResources->List[0];
        Translated = &Descriptor->PartialResourceList.PartialDescriptors[i];
        
        LowerLimit = Translated->u.Generic.Start.QuadPart;
        HigherLimit = LowerLimit + Translated->u.Generic.Length;

        if ((LowerLimit <= (ULONG64)(LONG64)Port) || (HigherLimit >= (ULONG64)(LONG64)Port)) {

            StorPortWritePortBufferUlong(HwDeviceExtension, Port, Buffer, Count);

        }

    }

    KeBugCheckEx (SCSI_VERIFIER_DETECTED_VIOLATION,
                  STORPORT_VERIFIER_BAD_VIRTUAL_ADDRESS,
                  0,
                  0,
                  0);

}

VOID
StorPortWriteRegisterUcharVrfy(
    IN PVOID HwDeviceExtension,
    IN PUCHAR Register,
    IN UCHAR Value
    )
{   
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_MINIPORT Miniport;
    PMAPPED_ADDRESS ListIterator;
    ULONG64 LowerLimit;
    ULONG64 HigherLimit;
    NTSTATUS Status;
    
    Miniport = RaHwDeviceExtensionGetMiniport(HwDeviceExtension);
    Adapter = RaMiniportGetAdapter (Miniport);

    //
    // Search through the Mapped Address List to verify Register is
    // in mapped memory-space range returned by StorPortGetDeviceBase
    //

    Status = STATUS_UNSUCCESSFUL;
    ListIterator = Adapter->MappedAddressList;
    
    while (ListIterator != NULL) {
        LowerLimit = (ULONG64)ListIterator->MappedAddress;
        HigherLimit = LowerLimit + ListIterator->NumberOfBytes;
        if ((LowerLimit <= (ULONG64)(LONG64)Register) && (HigherLimit >= (ULONG64)(LONG64)Register)) { 
            
            Status = STATUS_SUCCESS;
            break;
        
        } else {

            ListIterator = ListIterator->NextMappedAddress;
        
        }
    }
    
    if (!NT_SUCCESS (Status)) {
        KeBugCheckEx (SCSI_VERIFIER_DETECTED_VIOLATION,
                      STORPORT_VERIFIER_BAD_VIRTUAL_ADDRESS,
                      0,
                      0,
                      0);

    }
	StorPortWriteRegisterUchar(HwDeviceExtension, Register, Value);
}

VOID
StorPortWriteRegisterUshortVrfy(
    IN PVOID HwDeviceExtension,
    IN PUSHORT Register,
    IN USHORT Value
    )
{
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_MINIPORT Miniport;
    PMAPPED_ADDRESS ListIterator;
    ULONG64 LowerLimit;
    ULONG64 HigherLimit;
    NTSTATUS Status;
    
    Miniport = RaHwDeviceExtensionGetMiniport(HwDeviceExtension);
    Adapter = RaMiniportGetAdapter (Miniport);

    //
    // Search through the Mapped Address List to verify Register is
    // in mapped memory-space range returned by StorPortGetDeviceBase
    //

    Status = STATUS_UNSUCCESSFUL;
    ListIterator = Adapter->MappedAddressList;
    
    while (ListIterator != NULL) {
        LowerLimit = (ULONG64)ListIterator->MappedAddress;
        HigherLimit = LowerLimit + ListIterator->NumberOfBytes;
        if ((LowerLimit <= (ULONG64)(LONG64)Register) && (HigherLimit >= (ULONG64)(LONG64)Register)) { 
            
            Status = STATUS_SUCCESS;
            break;
        
        }
        else {

            ListIterator = ListIterator->NextMappedAddress;
        
        }
    }
    
    if (!NT_SUCCESS (Status)) {
        KeBugCheckEx (SCSI_VERIFIER_DETECTED_VIOLATION,
                      STORPORT_VERIFIER_BAD_VIRTUAL_ADDRESS,
                      0,
                      0,
                      0);

    }

	StorPortWriteRegisterUshort (HwDeviceExtension, Register, Value);
}

VOID
StorPortWriteRegisterUlongVrfy(
    IN PVOID HwDeviceExtension,
    IN PULONG Register,
    IN ULONG Value
    )
{
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_MINIPORT Miniport;
    PMAPPED_ADDRESS ListIterator;
    ULONG64 LowerLimit;
    ULONG64 HigherLimit;
    NTSTATUS Status;
    
    Miniport = RaHwDeviceExtensionGetMiniport(HwDeviceExtension);
    Adapter = RaMiniportGetAdapter (Miniport);

    //
    // Search through the Mapped Address List to verify Register is
    // in mapped memory-space range returned by StorPortGetDeviceBase
    //

    Status = STATUS_UNSUCCESSFUL;
    ListIterator = Adapter->MappedAddressList;
    
    while (ListIterator != NULL) {
        LowerLimit = (ULONG64)ListIterator->MappedAddress;
        HigherLimit = LowerLimit + ListIterator->NumberOfBytes;
        if ((LowerLimit <= (ULONG64)(LONG64)Register) && (HigherLimit >= (ULONG64)(LONG64)Register)) { 
            
            Status = STATUS_SUCCESS;
            break;
        
        }
        else {

            ListIterator = ListIterator->NextMappedAddress;
        
        }
    }
    
    if (!NT_SUCCESS (Status)) {
        KeBugCheckEx (SCSI_VERIFIER_DETECTED_VIOLATION,
                      STORPORT_VERIFIER_BAD_VIRTUAL_ADDRESS,
                      0,
                      0,
                      0);

    }

	StorPortWriteRegisterUlong (HwDeviceExtension, Register, Value);
}

VOID
StorPortWriteRegisterBufferUcharVrfy(
    IN PVOID HwDeviceExtension,
    IN PUCHAR Register,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )
{
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_MINIPORT Miniport;
    PMAPPED_ADDRESS ListIterator;
    ULONG64 LowerLimit;
    ULONG64 HigherLimit;
    NTSTATUS Status;
    
    Miniport = RaHwDeviceExtensionGetMiniport(HwDeviceExtension);
    Adapter = RaMiniportGetAdapter (Miniport);

    //
    // Search through the Mapped Address List to verify Register is
    // in mapped memory-space range returned by StorPortGetDeviceBase
    //

    Status = STATUS_UNSUCCESSFUL;
    ListIterator = Adapter->MappedAddressList;
    
    while (ListIterator != NULL) {
        LowerLimit = (ULONG64)ListIterator->MappedAddress;
        HigherLimit = LowerLimit + ListIterator->NumberOfBytes;
        if ((LowerLimit <= (ULONG64)(LONG64)Register) && (HigherLimit >= (ULONG64)(LONG64)Register)) { 
            
            Status = STATUS_SUCCESS;
            break;
        
        } else {

            ListIterator = ListIterator->NextMappedAddress;
        
        }
    }
    
    if (!NT_SUCCESS (Status)) {
        KeBugCheckEx (SCSI_VERIFIER_DETECTED_VIOLATION,
                      STORPORT_VERIFIER_BAD_VIRTUAL_ADDRESS,
                      0,
                      0,
                      0);

    }
    
	StorPortWriteRegisterBufferUchar (HwDeviceExtension,
									  Register,
									  Buffer,
									  Count);
}

VOID
StorPortWriteRegisterBufferUshortVrfy(
    IN PVOID HwDeviceExtension,
    IN PUSHORT Register,
    IN PUSHORT Buffer,
    IN ULONG Count
    )
{
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_MINIPORT Miniport;
    PMAPPED_ADDRESS ListIterator;
    ULONG64 LowerLimit;
    ULONG64 HigherLimit;
    NTSTATUS Status;
    
    Miniport = RaHwDeviceExtensionGetMiniport(HwDeviceExtension);
    Adapter = RaMiniportGetAdapter (Miniport);

    //
    // Search through the Mapped Address List to verify Register is
    // in mapped memory-space range returned by StorPortGetDeviceBase
    //

    Status = STATUS_UNSUCCESSFUL;
    ListIterator = Adapter->MappedAddressList;
    
    while (ListIterator != NULL) {
        LowerLimit = (ULONG64)ListIterator->MappedAddress;
        HigherLimit = LowerLimit + ListIterator->NumberOfBytes;
        if ((LowerLimit <= (ULONG64)(LONG64)Register) && (HigherLimit >= (ULONG64)(LONG64)Register)) { 
            
            Status = STATUS_SUCCESS;
            break;
        
        }
        else {

            ListIterator = ListIterator->NextMappedAddress;
        
        }
    }
    
    if (NT_SUCCESS (Status)) {
        StorPortWriteRegisterBufferUshort(HwDeviceExtension, Register, Buffer, Count);
    }
    else {
       
        KeBugCheckEx (SCSI_VERIFIER_DETECTED_VIOLATION,
                      STORPORT_VERIFIER_BAD_VIRTUAL_ADDRESS,
                      0,
                      0,
                      0);

    }

}

VOID
StorPortWriteRegisterBufferUlongVrfy(
    IN PVOID HwDeviceExtension,
    IN PULONG Register,
    IN PULONG Buffer,
    IN ULONG Count
    )
{
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_MINIPORT Miniport;
    PMAPPED_ADDRESS ListIterator;
    ULONG64 LowerLimit;
    ULONG64 HigherLimit;
    NTSTATUS Status;
    
    Miniport = RaHwDeviceExtensionGetMiniport(HwDeviceExtension);
    Adapter = RaMiniportGetAdapter (Miniport);

    //
    // Search through the Mapped Address List to verify Register is
    // in mapped memory-space range returned by StorPortGetDeviceBase
    //

    Status = STATUS_UNSUCCESSFUL;
    ListIterator = Adapter->MappedAddressList;
    
    while (ListIterator != NULL) {
        LowerLimit = (ULONG64)ListIterator->MappedAddress;
        HigherLimit = LowerLimit + ListIterator->NumberOfBytes;
        if ((LowerLimit <= (ULONG64)(LONG64)Register) && (HigherLimit >= (ULONG64)(LONG64)Register)) { 
            
            Status = STATUS_SUCCESS;
            break;
        
        } else {

            ListIterator = ListIterator->NextMappedAddress;
        
        }
    }
    
    if (!NT_SUCCESS (Status)) {
        KeBugCheckEx (SCSI_VERIFIER_DETECTED_VIOLATION,
                      STORPORT_VERIFIER_BAD_VIRTUAL_ADDRESS,
                      0,
                      0,
                      0);

    }

	StorPortWriteRegisterBufferUlong (HwDeviceExtension,
									  Register,
									  Buffer,
									  Count);
}

VOID
StorPortDebugPrintVrfy(
	IN ULONG DebugPrintLevel,
	IN PCCHAR DebugMessage
    )
{
    StorPortDebugPrint(DebugPrintLevel, DebugMessage);
}

BOOLEAN
StorPortPauseDeviceVrfy(
	IN PVOID HwDeviceExtension,
	IN UCHAR PathId,
	IN UCHAR TargetId,
	IN UCHAR Lun,
	IN ULONG TimeOut
	)
{
    BOOLEAN Status;

    Status = StorPortPauseDevice(HwDeviceExtension, PathId, TargetId, Lun, TimeOut);

    return Status;
}

BOOLEAN
StorPortResumeDeviceVrfy(
	IN PVOID HwDeviceExtension,
	IN UCHAR PathId,
	IN UCHAR TargetId,
	IN UCHAR Lun
	)
{   
    BOOLEAN Status;
    
    Status = StorPortResumeDevice(HwDeviceExtension, PathId, TargetId, Lun);

    return Status;
}

BOOLEAN
StorPortPauseVrfy(
	IN PVOID HwDeviceExtension,
	IN ULONG TimeOut
	)
{
    BOOLEAN Status;
    
    Status = StorPortPause(HwDeviceExtension, TimeOut);

    return Status;
}

BOOLEAN
StorPortResumeVrfy(
	IN PVOID HwDeviceExtension
	)
{
    BOOLEAN Status;

    Status = StorPortResume(HwDeviceExtension);

    return Status;
}

BOOLEAN
StorPortDeviceBusyVrfy(
	IN PVOID HwDeviceExtension,
	IN UCHAR PathId,
	IN UCHAR TargetId,
	IN UCHAR Lun,
	IN ULONG RequestsToComplete
	)
{
    BOOLEAN Status;

    Status = StorPortDeviceBusy(HwDeviceExtension, PathId, TargetId, Lun, RequestsToComplete);

    return Status;
}

BOOLEAN
StorPortDeviceReadyVrfy(
	IN PVOID HwDeviceExtension,
	IN UCHAR PathId,
	IN UCHAR TargetId,
	IN UCHAR Lun
	)
{
    BOOLEAN Status;

    Status = StorPortDeviceReady(HwDeviceExtension, PathId, TargetId, Lun);

    return Status;
}

BOOLEAN
StorPortBusyVrfy(
	IN PVOID HwDeviceExtension,
	IN ULONG RequestsToComplete
	)
{
    BOOLEAN Status;

    Status = StorPortBusy(HwDeviceExtension, RequestsToComplete);

    return Status;
}

BOOLEAN
StorPortReadyVrfy(
	IN PVOID HwDeviceExtension
	)
{
    BOOLEAN Status;

    Status = StorPortReady(HwDeviceExtension);

    return Status;
}

PSTOR_SCATTER_GATHER_LIST
StorPortGetScatterGatherListVrfy(
	IN PVOID HwDeviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb
	)
{
    PEXTENDED_REQUEST_BLOCK Xrb;
    PVOID RemappedSgList;

    ASSERT (HwDeviceExtension != NULL);
    //
    // NB: Put in a DBG check that the HwDeviceExtension matches the
    // HwDeviceExtension assoicated with the SRB.
    //
    Xrb = RaidGetAssociatedXrb (Srb);
    ASSERT (Xrb != NULL);

    if (RaidRemapScatterGatherList (Xrb->SgList, Xrb)) {

        RemappedSgList = MmGetSystemAddressForMdlSafe(Xrb->RemappedSgListMdl, NormalPagePriority);

        return (PSTOR_SCATTER_GATHER_LIST)RemappedSgList;

    }

    return (PSTOR_SCATTER_GATHER_LIST)Xrb->SgList;

}
    

VOID
StorPortSynchronizeAccessVrfy(
	IN PVOID HwDeviceExtension,
	IN PSTOR_SYNCHRONIZED_ACCESS SynchronizedAccessRoutine,
	IN PVOID Context
	)
{
    StorPortSynchronizeAccess(HwDeviceExtension, SynchronizedAccessRoutine, Context);
}


PVOID
RaidRemapBlock(
    IN PVOID BlockVa,
    IN ULONG BlockSize,
    OUT PMDL* Mdl
    )
/*++

Routine Description:

    This function attempts to remap the supplied VA range.  If the block is
    remapped, it will be made invalid for reading and writing.

Arguments:

    BlockVa   - Supplies the address of the block of memory to remap.

    BlockSize - Supplies the size of the block of memory to remap.

    Mdl       - Supplies the address into which the function will store
                a pointer to the MDL for the remapped range.  If the MDL
                cannot be allocated or if the range cannot be remapped,
                this will be NULL upon return.

Return Value:

    If the range is successfully remapped, the address of the beginning of
    the remapped range is returned.  Else, NULL is returned.

--*/
{
    PVOID MappedRange;
    NTSTATUS Status;
    PMDL LocalMdl;

    //
    // Try to allocate a new MDL for the range we're trying to remap.
    //

    LocalMdl = IoAllocateMdl(BlockVa, BlockSize, FALSE, FALSE, NULL);
    if (LocalMdl == NULL) {
        *Mdl = NULL;
        return NULL;
    }

    //
    // Try to lock the pages.  This initializes the MDL properly.
    //

    __try {
        MmProbeAndLockPages(LocalMdl, KernelMode, IoModifyAccess);
    } 
    __except(EXCEPTION_EXECUTE_HANDLER) {
        IoFreeMdl(LocalMdl);
        *Mdl = NULL;
        return NULL;
    }

    //
    // Try to remap the range represented by the new MDL.
    //

    MappedRange = MmMapLockedPagesSpecifyCache(LocalMdl,
                                               KernelMode,
                                               MmCached,
                                               NULL,
                                               FALSE,
                                               NormalPagePriority);
    if (MappedRange == NULL) {
        IoFreeMdl(LocalMdl);
        *Mdl = NULL;
        return NULL;
    }

    //
    // If we've gotten this far, we have successfully remapped the range.
    // Now we want to invalidate the entire range so any accesses to it
    // will be trapped by the system.
    //

    Status = MmProtectMdlSystemAddress(LocalMdl, PAGE_NOACCESS);
#if 0

#if DBG==1
    if (!NT_SUCCESS(Status)) {
        DebugPrint((0, "SpRemapBlock: failed to remap block:%p mdl:%p (%x)\n", 
                    BlockVa, LocalMdl, Status));
    }
#endif

#endif

    //
    // Copy the MDL we allocated into the supplied address and return the
    // address of the beginning of the remapped range.
    //

    *Mdl = LocalMdl;
    return MappedRange;
}


VOID
RaidRemapCommonBufferForMiniport(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    This routine attempts to remap all of the common buffer blocks allocated
    for a particular unit.

Arguments:

    Unit - Supplies a pointer to the unit device extension.

--*/
{
    PRAID_MEMORY_REGION BlkAddr = Unit->CommonBufferVAs;
    PSP_VA_MAPPING_INFO MappingInfo;
    PVOID RemappedVa;
    ULONG Size;
    PMDL Mdl;
    ULONG i;

    //
    // Iterate through all of the common buffer blocks, and attemp to remap
    // the SRB extension.
    //

    for (i = 0; i < Unit->CommonBufferBlocks; i++) {
        
        //
        // Get a pointer to the mapping info we keep at the end of the block.
        //

        MappingInfo = GET_VA_MAPPING_INFO(Unit, BlkAddr[i].VirtualBase);

        //
        // Initialize the original VA infor for the SRB extension
        //

        MappingInfo->OriginalSrbExtVa = BlkAddr[i].VirtualBase;
        MappingInfo->SrbExtLen = (ULONG)ROUND_TO_PAGES(RaGetSrbExtensionSize(Unit->Adapter));

        //
        // Try to remap the SRB extension.  If successful, initialize the
        // remapped VA infor for the SRB extension.
        //

        RemappedVa = RaidRemapBlock(MappingInfo->OriginalSrbExtVa,
                                    MappingInfo->SrbExtLen,
                                    &Mdl);

        if (RemappedVa != NULL) {
            MappingInfo->RemappedSrbExtVa = RemappedVa;
            MappingInfo->SrbExtMdl = Mdl;
        }
    }
}



PMDL
INLINE
RaidGetRemappedSrbExt(
    PRAID_UNIT_EXTENSION Unit,
    PVOID Block
    )
{
    PSP_VA_MAPPING_INFO MappingInfo = GET_VA_MAPPING_INFO(Unit, Block);
    return MappingInfo->SrbExtMdl;
}


PVOID
RaidAllocateSrbExtensionVrfy(
    IN PRAID_UNIT_EXTENSION Unit,
    IN ULONG QueueTag
    )
/*++

Routine Description:

    Allocate a SRB Extension and initialize it to NULL.
    
Arguments:

    Unit      - Pointer to an unit device extension.

    QueueTag  - Index into the extension pool that should be allocated.

Return Value:

    Pointer to an initialized SRB Extension if the function was successful.
    
    NULL otherwise.

--*/

{
    PVOID Extension;
    PRAID_FIXED_POOL Pool = &Unit->SrbExtensionPool;

    ASSERT (QueueTag < Pool->NumberOfElements);
    
    //
    // Allocate SRB Extension from list.
    //

    Extension = (PVOID)Pool->Buffer;
    
    //
    // Remove SRB Extension from the list.
    //
    
    //Pool->Buffer = (PVOID *)(Pool->Buffer);

    Pool->Buffer = *((PUCHAR *)(Pool->Buffer));

    Extension = RaidPrepareSrbExtensionForUse(Unit, Extension);

    return Extension;

}


PVOID
RaidGetOriginalSrbExtVa(
    PRAID_UNIT_EXTENSION Unit,
    PVOID Va
    )
/*++

Routine Description:

    This function returns the original mapped virtual address of a common
    block if the supplied VA is for one of the common buffer blocks we've
    allocated.

Arguments:

    Unit - the unit device extension

    Va - virtual address of a common buffer block

Return Value:

    If the supplied VA is the address of one of the common buffer blocks,
    returns the original VA of the block.  Else, returns NULL.

--*/
{
    PRAID_MEMORY_REGION BlkAddr = Unit->CommonBufferVAs;
    PSP_VA_MAPPING_INFO MappingInfo;
    ULONG i;
    
    for (i = 0; i < Unit->CommonBufferBlocks; i++) {
        MappingInfo = GET_VA_MAPPING_INFO(Unit, BlkAddr[i].VirtualBase);
        if (Va == MappingInfo->RemappedSrbExtVa || 
            Va == MappingInfo->OriginalSrbExtVa)
            return MappingInfo->OriginalSrbExtVa;
    }

    return NULL;
}


VOID
RaidInsertSrbExtension(
    PRAID_UNIT_EXTENSION Unit,
    PCCHAR SrbExtension
    )
/*++

Routine Description:

    This routine inserts the supplied SRB extension back into the SRB extension
    list.  The VA of the supplied extension lies within one of our common buffer
    blocks and it may be a remapped VA.  If it is a remapped address, this
    routine invalidates the page(s) comprising the extension after it links the
    extension back into the list.

Arguments:

    Unit      - Pointer to an unit device extension.

    SrbExtension - Pointer to the beginning of an SRB extension within one of
                   our common buffer blocks.  May or may not be within a
                   remapped range.

--*/
{
    ULONG SrbExtensionSize = RaGetSrbExtensionSize(Unit->Adapter);
    ULONG i = 0;
    ULONG length = 0;
    PUCHAR Iterator = SrbExtension;
    
    //
    // Round the srb extension pointer down to the beginning of the page
    // and link the block back into the list.  Note that we're careful
    // to point the list header at the original VA of the block.
    //

    while (length < SrbExtensionSize) {
        if (RtlCompareMemory(&Iterator[i], &Signature, sizeof(UCHAR)) != sizeof(UCHAR)) {
            KeBugCheckEx (SCSI_VERIFIER_DETECTED_VIOLATION,
                      STORPORT_VERIFIER_BAD_VIRTUAL_ADDRESS,
                      0,
                      0,
                      0);
        }
        
        i++;
        length += sizeof(UCHAR);
    }

    SrbExtension = SrbExtension -  ((Unit->CommonBufferSize - PAGE_SIZE) - SrbExtensionSize);
    *((PVOID *) SrbExtension) = Unit->SrbExtensionPool.Buffer;    
    Unit->SrbExtensionPool.Buffer = RaidGetOriginalSrbExtVa(
                                          Unit, 
                                          SrbExtension);
    
    //
    // If the original VA differs from the one supplied, the supplied
    // one is one of our remapped VAs.  In this case, we want to invalidate
    // the range so the system will bugcheck if anyone tries to access it.
    //
                    
    if (Unit->SrbExtensionPool.Buffer != SrbExtension) {
        PMDL Mdl = RaidGetRemappedSrbExt(Unit, Unit->SrbExtensionPool.Buffer);
        ASSERT(Mdl != NULL);
        MmProtectMdlSystemAddress(Mdl, PAGE_NOACCESS);
    }
}


PVOID
RaidPrepareSrbExtensionForUse(
    IN PRAID_UNIT_EXTENSION Unit,
    IN OUT PCCHAR SrbExtension
    )
/*++

Routine Description:

    This function accepts a pointer to the beginning of one of the individual 
    common-buffer blocks allocated by the verifier for SRB extensions, sense 
    buffers, and non-cached extensions.  It calculates the beginning of the 
    SRB extension within the block and, if the block has been remapped, makes 
    the page(s) of the SRB extension read/write valid.

Arguments:

    Unit      - Pointer to an unit device extension.

    SrbExtension - Pointer to the beginning of a common-buffer block.

Return Value:

    If the common buffer block containing the SRB extension has been remapped, 
    returns the address of the beginning of the remapped srb extension, valid 
    for reading and writing.  

    If the block has not been remapped, returns NULL.

    Regardless of whether the block is remapped or not, the supplied pointer
    is fixed up to point to the beginning of the SRB extension within the
    original VA range.

--*/
{
    PCCHAR RemappedSrbExt = NULL;
    NTSTATUS Status;
    PMDL Mdl;
    ULONG SrbExtensionSize = RaGetSrbExtensionSize(Unit->Adapter);

    //
    // If we've remapped the SRB extension, get the second mapping and make it
    // valid.  If we get the second mapping, but cannot make it valid, we just
    // use the original mapping.
    //

    Mdl = RaidGetRemappedSrbExt(Unit, SrbExtension);
    if (Mdl != NULL) {
        Status = MmProtectMdlSystemAddress(Mdl, PAGE_READWRITE);
        if (NT_SUCCESS(Status)) {
            RemappedSrbExt = MmGetSystemAddressForMdlSafe(Mdl, NormalPagePriority);

            //
            // Adjust the remapped srb extension pointer so the end of the 
            // buffer falls on a page boundary.
            //

            RemappedSrbExt += ((Unit->CommonBufferSize - PAGE_SIZE) - SrbExtensionSize);

            RtlZeroMemory (RemappedSrbExt, SrbExtensionSize);

        }
    }
    
    //
    // Adjust the original srb extension pointer so it also ends on a page boundary.
    //

    SrbExtension += ((Unit->CommonBufferSize - PAGE_SIZE) - SrbExtensionSize);

    return RemappedSrbExt;
}




PVOID
RaidRemapScatterGatherList(
    IN PSCATTER_GATHER_LIST ScatterList,
    IN PEXTENDED_REQUEST_BLOCK Xrb
    )
/*++

Routine Description:

    This routine attempts to remap the Scatter Gather List allocated
    for a particular Xrb.  If the block is remapped, it will be made 
    valid only for reading.

Arguments:

    ScatterList - Pointer to the scatter gather list to be remapped.
    
    Xrb - Pointer to the Xrb.

Return Value:

    If the scatter gather list has been remapped, returns the address 
    of the beginning of the remapped scatter gather list, valid only
    for reading.  

    If the block has not been remapped, returns NULL.

--*/
{
    ULONG Length;
    PVOID MappedRange;
    NTSTATUS Status;
    PMDL LocalMdl;


    //
    // Size of scatter gather list.
    //
    
    Length = ((ScatterList->NumberOfElements) * sizeof(SCATTER_GATHER_ELEMENT)) + sizeof(ULONG_PTR) + sizeof(ULONG);

    //
    // Try to allocate a new MDL for the range we're trying to remap.
    //

    LocalMdl = IoAllocateMdl((PVOID)ScatterList, Length, FALSE, FALSE, NULL);
    if (LocalMdl == NULL) {
        Xrb->RemappedSgListMdl = NULL;
        return NULL;
    }

    //
    // Try to lock the pages.  This initializes the MDL properly.
    //

    __try {
        MmProbeAndLockPages(LocalMdl, KernelMode, IoModifyAccess);
    } 
    __except(EXCEPTION_EXECUTE_HANDLER) {
        IoFreeMdl(LocalMdl);
        Xrb->RemappedSgListMdl = NULL;
        return NULL;
    }

    //
    // Try to remap the range represented by the new MDL.
    //

    MappedRange = MmMapLockedPagesSpecifyCache(LocalMdl,
                                               KernelMode,
                                               MmCached,
                                               NULL,
                                               FALSE,
                                               NormalPagePriority);
    if (MappedRange == NULL) {
        IoFreeMdl(LocalMdl);
        Xrb->RemappedSgListMdl = NULL;
        return NULL;
    }

    //
    // If we've gotten this far, we have successfully remapped the range.
    // Now we want to validate the entire range for read only access.
    //

    Status = MmProtectMdlSystemAddress(LocalMdl, PAGE_READONLY);

    //
    // Copy the MDL we allocated into the supplied address and return the
    // address of the beginning of the remapped range.
    //

    Xrb->RemappedSgListMdl = LocalMdl;
    return MappedRange;
}


VOID
RaidFreeRemappedScatterGatherListMdl(
    IN PEXTENDED_REQUEST_BLOCK Xrb
    )
/*++

Routine Description:

    If there is a second VA range for the ScatterGather list, free
    the Mdl.

Arguments:

    Xrb - Pointer to the Xrb.

--*/
{
    if (Xrb->RemappedSgListMdl != NULL) {
        MmProtectMdlSystemAddress(Xrb->RemappedSgListMdl, PAGE_READWRITE);
        MmUnlockPages(Xrb->RemappedSgListMdl);
        IoFreeMdl(Xrb->RemappedSgListMdl);
        Xrb->RemappedSgListMdl = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\wmi.c ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    wmi.c

Abstract:

    This module contains the WMI support code for SCSIPORT's functional and
    physical device objects.

Authors:

    Dan Markarian

Environment:

    Kernel mode only.

Notes:

    None.

Revision History:

    19-Mar-1997, Original Writing, Dan Markarian
    15-Aug-2001, ported to Storport, Neil Sandlin

--*/

#include "precomp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RaWmiDispatchIrp)
#pragma alloc_text(PAGE, RaWmiIrpNormalRequest)
#pragma alloc_text(PAGE, RaWmiIrpRegisterRequest)
#pragma alloc_text(PAGE, RaWmiPassToMiniPort)
#pragma alloc_text(PAGE, RaUnitInitializeWMI)
#endif


//
// Routines
//

NTSTATUS
RaidCompleteWmiIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    NTSTATUS Status;
    
    switch (RaGetObjectType (DeviceObject)) {

        case RaidAdapterObject: {
            PRAID_ADAPTER_EXTENSION Adapter;

            Adapter = DeviceObject->DeviceExtension;
            IoCopyCurrentIrpStackLocationToNext (Irp);
            Status = IoCallDriver (Adapter->LowerDeviceObject, Irp);
            break;
        }

        case RaidUnitObject:
            Status = RaidCompleteRequest (Irp,
                                          Irp->IoStatus.Status);
            break;
    }

    return Status;
}

NTSTATUS
RaWmiDispatchIrp(
    PDEVICE_OBJECT DeviceObject,
    PIRP           Irp
    )
/*++

Routine Description:

   Process an IRP_MJ_SYSTEM_CONTROL request packet.

Arguments:

   DeviceObject - Pointer to the functional or physical device object.

   Irp          - Pointer to the request packet.

Return Value:

   NTSTATUS result code.

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpStack;
    PIRP_STACK_WMI Wmi;
    WMI_PARAMETERS WmiParameters;

    PAGED_CODE();

    Status = STATUS_SUCCESS;

    //
    // Obtain a pointer to the current IRP stack location.
    //

    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    ASSERT (IrpStack->MajorFunction == IRP_MJ_SYSTEM_CONTROL);    
    Wmi = (PIRP_STACK_WMI)&IrpStack->Parameters.WMI;

    //
    // If the IRP is not ours, pass it down the stack.
    //
    
    if ((PDEVICE_OBJECT)Wmi->ProviderId != DeviceObject) {
        return RaidCompleteWmiIrp (DeviceObject, Irp);
    }
        
    DebugTrace(("RaWmiDispatch: MinorFunction %x\n", IrpStack->MinorFunction));
    
    //
    // Copy the WMI parameters into our local WMISRB structure.
    //

    WmiParameters.ProviderId = Wmi->ProviderId;
    WmiParameters.DataPath = Wmi->DataPath;
    WmiParameters.Buffer = Wmi->Buffer;
    WmiParameters.BufferSize = Wmi->BufferSize;
    
    //
    // Determine what the WMI request wants of us.
    //
    switch (IrpStack->MinorFunction) {
        case IRP_MN_QUERY_ALL_DATA:
        case IRP_MN_QUERY_SINGLE_INSTANCE:
        case IRP_MN_CHANGE_SINGLE_INSTANCE:
        case IRP_MN_CHANGE_SINGLE_ITEM:
        case IRP_MN_ENABLE_EVENTS:
        case IRP_MN_DISABLE_EVENTS:
        case IRP_MN_ENABLE_COLLECTION:
        case IRP_MN_DISABLE_COLLECTION:
        case IRP_MN_EXECUTE_METHOD:
            //
            // Execute method
            //
            Status = RaWmiIrpNormalRequest(DeviceObject,
                                           IrpStack->MinorFunction,
                                           &WmiParameters);
            break;
    
        case IRP_MN_REGINFO:
            //
            // Query for registration and registration update information.
            //
            Status = RaWmiIrpRegisterRequest(DeviceObject, &WmiParameters);
            break;
    
        default:
            //
            // Unsupported WMI request.  According to some rule in the WMI 
            // spec we're supposed to send unsupported WMI requests down 
            // the stack even if we're marked as the provider.
            //

            return RaidCompleteWmiIrp (DeviceObject, Irp);
    }

    //
    // Complete this WMI IRP request.
    //
    
    Irp->IoStatus.Status = Status;
    if (NT_SUCCESS (Status)) {
        Irp->IoStatus.Information = WmiParameters.BufferSize;
    } else {
        Irp->IoStatus.Information = 0;
    }

    return RaidCompleteRequest (Irp, Status);
}


NTSTATUS
RaWmiIrpNormalRequest(
    IN     PDEVICE_OBJECT  DeviceObject,
    IN     UCHAR           WmiMinorCode,
    IN OUT PWMI_PARAMETERS WmiParameters
    )

/*++

Routine Description:

    Process an IRP_MJ_SYSTEM_CONTROL request packet (for all requests except
    registration IRP_MN_REGINFO requests).

Arguments:

    DeviceObject  - Pointer to the functional or physical device object.

    WmiMinorCode  - WMI action to perform.

    WmiParameters - Pointer to the WMI request parameters.

Return Value:

    NTSTATUS result code to complete the WMI IRP with.

Notes:

    If this WMI request is completed with STATUS_SUCCESS, the WmiParameters
    BufferSize field will reflect the actual size of the WMI return buffer.

--*/

{
    NTSTATUS Status;
    BOOLEAN WmiMiniPortSupport;

    PAGED_CODE();

    WmiMiniPortSupport = FALSE;
    Status = STATUS_UNSUCCESSFUL;

    switch (RaGetObjectType (DeviceObject)) {
    
        case RaidAdapterObject: {
            PRAID_ADAPTER_EXTENSION Adapter = DeviceObject->DeviceExtension;

            WmiMiniPortSupport = Adapter->Miniport.PortConfiguration.WmiDataProvider;
            break;
        }

        case RaidUnitObject: {
            PRAID_UNIT_EXTENSION Unit = DeviceObject->DeviceExtension;

            WmiMiniPortSupport = Unit->Adapter->Miniport.PortConfiguration.WmiDataProvider;
            break;
        }
    }

    //
    // Pass the request onto the miniport driver, provided the
    // miniport driver does support WMI.
    //

    if (WmiMiniPortSupport) {

        //
        // Send off the WMI request to the miniport.
        //
        Status = RaWmiPassToMiniPort(DeviceObject,
                                     WmiMinorCode,
                                     WmiParameters);

        if (NT_SUCCESS (Status)) {

            //
            // Fill in fields miniport cannot fill in for itself.
            //
            
            if ( WmiMinorCode == IRP_MN_QUERY_ALL_DATA ||
                 WmiMinorCode == IRP_MN_QUERY_SINGLE_INSTANCE ) {

                PWNODE_HEADER wnodeHeader = WmiParameters->Buffer;

                ASSERT( WmiParameters->BufferSize >= sizeof(WNODE_HEADER) );

                KeQuerySystemTime(&wnodeHeader->TimeStamp);
            }
        } else {

            //
            // Translate SRB status into a meaningful NTSTATUS status.
            //
            Status = STATUS_INVALID_DEVICE_REQUEST;
        }
    }

    return Status;
}


NTSTATUS
RaWmiIrpRegisterRequest(
    IN     PDEVICE_OBJECT  DeviceObject,
    IN OUT PWMI_PARAMETERS WmiParameters
    )

/*++

Routine Description:

   Process an IRP_MJ_SYSTEM_CONTROL registration request.

Arguments:

   DeviceObject  - Pointer to the functional or physical device object.

   WmiParameters - Pointer to the WMI request parameters.

Return Value:

   NTSTATUS result code to complete the WMI IRP with.

Notes:

   If this WMI request is completed with STATUS_SUCCESS, the WmiParameters
   BufferSize field will reflect the actual size of the WMI return buffer.

--*/

{
    PRAID_DRIVER_EXTENSION driverExtension = NULL;

    ULONG                      countedRegistryPathSize = 0;
    ULONG                      retSz;
    PWMIREGINFO                spWmiRegInfoBuf = NULL;
    ULONG                      spWmiRegInfoBufSize = 0;
    NTSTATUS                   status = STATUS_SUCCESS;
    BOOLEAN                    wmiUpdateRequest;
    ULONG                      i;
    PDEVICE_OBJECT             pDO;
    BOOLEAN                    WmiMiniPortSupport = FALSE;
    BOOLEAN                    WmiMiniPortInitialized = FALSE;

    WMI_PARAMETERS  paranoidBackup = *WmiParameters;

    PAGED_CODE();

    switch (RaGetObjectType (DeviceObject)) {
    
        case RaidAdapterObject: {
            PRAID_ADAPTER_EXTENSION Adapter = DeviceObject->DeviceExtension;
            WmiMiniPortSupport = Adapter->Miniport.PortConfiguration.WmiDataProvider;
            WmiMiniPortInitialized = Adapter->Flags.WmiMiniPortInitialized;
            }
            break;

        case RaidUnitObject: {
            PRAID_UNIT_EXTENSION Unit = DeviceObject->DeviceExtension;
            WmiMiniPortSupport = Unit->Adapter->Miniport.PortConfiguration.WmiDataProvider;
            WmiMiniPortInitialized = Unit->Adapter->Flags.WmiMiniPortInitialized;
            }
            break;
    }    

    //
    // Validate our assumptions for this function's code.
    //
    ASSERT(WmiParameters->BufferSize >= sizeof(ULONG));

    //
    // Validate the registration mode.
    //
    switch ( (ULONG)(ULONG_PTR)WmiParameters->DataPath ) {
        case WMIUPDATE:
            //
            // No SCSIPORT registration information will be piggybacked
            // on behalf of the miniport for a WMIUPDATE request.
            //
            wmiUpdateRequest = TRUE;
            break;

        case WMIREGISTER:
            wmiUpdateRequest = FALSE;
            break;

        default:
            //
            // Unsupported registration mode.
            //
            ASSERT(FALSE);
            return STATUS_INVALID_PARAMETER;
    }

    //
    // Obtain the driver extension for this miniport (FDO/PDO).
    //
    driverExtension = IoGetDriverObjectExtension(DeviceObject->DriverObject, DriverEntry);

    ASSERT(driverExtension != NULL);
    //
    // Make Prefix Happy -- we'll quit if
    // driverExtension is NULL
    //
    if (driverExtension == NULL) {
        return (STATUS_UNSUCCESSFUL);
    }

    //
    // Pass the WMI registration request to the miniport.  This is not
    // necessary if we know the miniport driver does not support WMI.
    //
    if (WmiMiniPortSupport && WmiMiniPortInitialized) {
        
        //
        // Note that we shrink the buffer size by the size necessary
        // to hold SCSIPORT's own registration information, which we
        // register on behalf of the miniport.   This information is
        // piggybacked into the WMI return buffer after the call  to
        // the miniport.  We ensure that the BufferSize passed to the
        // miniport is no smaller than "sizeof(ULONG)" so that it can
        // tell us the required buffer size should the buffer be too
        // small [by filling in this ULONG].
        //
        // Note that we must also make enough room for a copy of the
        // miniport registry path in the buffer, since the WMIREGINFO
        // structures from the miniport DO NOT set their registry
        // path fields.
        //
        ASSERT(WmiParameters->BufferSize >= sizeof(ULONG));

        //
        // Calculate size of required miniport registry path.
        //
        countedRegistryPathSize = driverExtension->RegistryPath.Length
                                  + sizeof(USHORT);

        //
        // Shrink buffer by the appropriate size. Note that the extra
        // 7 bytes (possibly extraneous) is subtracted to ensure that
        // the piggybacked data added later on is 8-byte aligned (if
        // any).
        //
        if (spWmiRegInfoBufSize && !wmiUpdateRequest) {
            WmiParameters->BufferSize =
                (WmiParameters->BufferSize > spWmiRegInfoBufSize + countedRegistryPathSize + 7 + sizeof(ULONG)) ?
                WmiParameters->BufferSize - spWmiRegInfoBufSize - countedRegistryPathSize - 7 :
            sizeof(ULONG);
        } else { // no data to piggyback
            WmiParameters->BufferSize =
                (WmiParameters->BufferSize > countedRegistryPathSize + sizeof(ULONG)) ?
                WmiParameters->BufferSize - countedRegistryPathSize :
            sizeof(ULONG);
        }

        //
        // Call the minidriver.
        //
        status = RaWmiPassToMiniPort(DeviceObject,
                                     IRP_MN_REGINFO,
                                     WmiParameters);

        ASSERT(WmiParameters->ProviderId == paranoidBackup.ProviderId);
        ASSERT(WmiParameters->DataPath == paranoidBackup.DataPath);
        ASSERT(WmiParameters->Buffer == paranoidBackup.Buffer);
        ASSERT(WmiParameters->BufferSize <= paranoidBackup.BufferSize);

        //
        // Assign WmiParameters->BufferSize to retSz temporarily.
        //
        // Note that on return from the above call, the wmiParameters'
        // BufferSize field has been _modified_ to reflect the current
        // size of the return buffer.
        //
        retSz = WmiParameters->BufferSize;

    } else if (WmiParameters->BufferSize < spWmiRegInfoBufSize &&
               !wmiUpdateRequest) {

        //
        // Insufficient space to hold SCSIPORT WMI registration information
        // alone.  Inform WMI appropriately of the required buffer size.
        //
        *((ULONG*)WmiParameters->Buffer) = spWmiRegInfoBufSize;
        WmiParameters->BufferSize = sizeof(ULONG);

        return STATUS_SUCCESS;

    } else { // no miniport support for WMI, sufficient space for scsiport info

        //
        // Fake having the miniport return zero WMIREGINFO structures.
        //
        retSz = 0;
    }

    //
    // Piggyback SCSIPORT's registration information into the WMI
    // registration buffer.
    //

    if ((status == STATUS_BUFFER_TOO_SMALL) ||
        (NT_SUCCESS(status) && (retSz == sizeof(ULONG)))) {
        
        //
        // Miniport could not fit registration information into the
        // pre-shrunk buffer.
        //
        // Buffer currently contains a ULONG specifying required buffer
        // size of miniport registration info, but does not include the
        // SCSIPORT registration info's size.  Add it in.
        //
        if (spWmiRegInfoBufSize && !wmiUpdateRequest) {

            *((ULONG*)WmiParameters->Buffer) += spWmiRegInfoBufSize;

            //
            // Add an extra 7 bytes (possibly extraneous) which is used to
            // ensure that the piggybacked data structure 8-byte aligned.
            //
            *((ULONG*)WmiParameters->Buffer) += 7;
        }

        //
        // Add in size of the miniport registry path.
        //
        *((ULONG*)WmiParameters->Buffer) += countedRegistryPathSize;

        //
        // Return STATUS_SUCCESS, even though this is a BUFFER TOO
        // SMALL failure, while ensuring retSz = sizeof(ULONG), as
        // the WMI protocol calls us to do.
        //
        retSz  = sizeof(ULONG);
        status = STATUS_SUCCESS;

    } else if ( NT_SUCCESS(status) ) {
        
        //
        // Zero or more WMIREGINFOs exist in buffer from miniport.
        //

        //
        // Piggyback the miniport registry path transparently, if at least one
        // WMIREGINFO was returned by the minport.
        //
        if (retSz) {

            ULONG offsetToRegPath  = retSz;
            PWMIREGINFO wmiRegInfo = WmiParameters->Buffer;

            //
            // Build a counted wide-character string, containing the
            // registry path, into the WMI buffer.
            //
            *( (PUSHORT)( (PUCHAR)WmiParameters->Buffer + retSz ) ) =
                driverExtension->RegistryPath.Length,
            RtlCopyMemory( (PUCHAR)WmiParameters->Buffer + retSz + sizeof(USHORT),
                           driverExtension->RegistryPath.Buffer,
                           driverExtension->RegistryPath.Length);

            //
            // Traverse the WMIREGINFO structures returned by the mini-
            // driver and set the missing RegistryPath fields to point
            // to our registry path location. We also jam in the PDO for
            // the device stack so that the device instance name is used for
            // the wmi instance names.
            //
            pDO = (RaGetObjectType(DeviceObject) == RaidUnitObject) ? DeviceObject :
                            ((PRAID_ADAPTER_EXTENSION)DeviceObject->DeviceExtension)->PhysicalDeviceObject;

            while (1) {
                wmiRegInfo->RegistryPath = offsetToRegPath;

                for (i = 0; i < wmiRegInfo->GuidCount; i++)
                {
                    if ((wmiRegInfo->WmiRegGuid[i].Flags & (WMIREG_FLAG_INSTANCE_BASENAME |
                                                            WMIREG_FLAG_INSTANCE_LIST)) != 0)
                    {                                                            
                        wmiRegInfo->WmiRegGuid[i].InstanceInfo = (ULONG_PTR)pDO;
                        wmiRegInfo->WmiRegGuid[i].Flags &= ~(WMIREG_FLAG_INSTANCE_BASENAME |
                                                          WMIREG_FLAG_INSTANCE_LIST);
                        wmiRegInfo->WmiRegGuid[i].Flags |= WMIREG_FLAG_INSTANCE_PDO;
                    }
                }

                if (wmiRegInfo->NextWmiRegInfo == 0) {
                    break;
                }

                offsetToRegPath -= wmiRegInfo->NextWmiRegInfo;
                wmiRegInfo = (PWMIREGINFO)( (PUCHAR)wmiRegInfo +
                                            wmiRegInfo->NextWmiRegInfo );
            }

            //
            // Adjust retSz to reflect new size of the WMI buffer.
            //
            retSz += countedRegistryPathSize;
            wmiRegInfo->BufferSize = retSz;
        } // else, no WMIREGINFOs registered whatsoever, nothing to piggyback

        //
        // Do we have any SCSIPORT WMIREGINFOs to piggyback?
        //
        if (spWmiRegInfoBufSize && !wmiUpdateRequest) {

            //
            // Adjust retSz so that the data we piggyback is 8-byte aligned
            // (safe if retSz = 0).
            //
            retSz = (retSz + 7) & ~7;

            //
            // Piggyback SCSIPORT's registration info into the buffer.
            //
            RtlCopyMemory( (PUCHAR)WmiParameters->Buffer + retSz,
                           spWmiRegInfoBuf,
                           spWmiRegInfoBufSize);

            //
            // Was at least one WMIREGINFO returned by the minidriver?
            // Otherwise, we have nothing else to add to the WMI buffer.
            //
            if (retSz) { // at least one WMIREGINFO returned by minidriver
                PWMIREGINFO wmiRegInfo = WmiParameters->Buffer;

                //
                // Traverse to the end of the WMIREGINFO structures returned
                // by the miniport.
                //
                while (wmiRegInfo->NextWmiRegInfo) {
                    wmiRegInfo = (PWMIREGINFO)( (PUCHAR)wmiRegInfo +
                                                wmiRegInfo->NextWmiRegInfo );
                }

                //
                // Chain minidriver's WMIREGINFO structures to SCSIPORT's
                // WMIREGINFO structures.
                //
                wmiRegInfo->NextWmiRegInfo = retSz -
                                             (ULONG)((PUCHAR)wmiRegInfo - (PUCHAR)WmiParameters->Buffer);
            }

            //
            // Adjust retSz to reflect new size of the WMI buffer.
            //
            retSz += spWmiRegInfoBufSize;

        } // we had SCSIPORT REGINFO data to piggyback
    } // else, unknown error, complete IRP with this error status

    //
    // Save new buffer size to WmiParameters->BufferSize.
    //
    WmiParameters->BufferSize = retSz;
    return status;
}



NTSTATUS
RaWmiPassToMiniPort(
    IN     PDEVICE_OBJECT  DeviceObject,
    IN     UCHAR           WmiMinorCode,
    IN OUT PWMI_PARAMETERS WmiParameters
    )
/*++

Routine Description:

   This function pass a WMI request to the miniport driver for processing.
   It creates an SRB which is processed normally by the port driver.  This
   call is synchronous.

   Callers of RaWmiPassToMiniPort must be running at IRQL PASSIVE_LEVEL.

Arguments:

   DeviceObject  - Pointer to the functional or physical device object.

   WmiMinorCode  - WMI action to perform.

   WmiParameters - WMI parameters.

Return Value:

   An NTSTATUS code describing the result of handling the WMI request.
   Complete the IRP with this status.

Notes:

   If this WMI request is completed with STATUS_SUCCESS, the WmiParameters
   BufferSize field will reflect the actual size of the WMI return buffer.

--*/
{
    NTSTATUS Status;
    PRAID_ADAPTER_EXTENSION Adapter;
    PSCSI_WMI_REQUEST_BLOCK Srb;
    PEXTENDED_REQUEST_BLOCK Xrb;
    RAID_MEMORY_REGION SrbExtensionRegion;
    ULONG InputLength;
    ULONG OutputLength;
    PWNODE_HEADER wnode;    

    PAGED_CODE();
    
    if (RaGetObjectType(DeviceObject) == RaidUnitObject) {
        Adapter = ((PRAID_UNIT_EXTENSION)DeviceObject->DeviceExtension)->Adapter;
    } else {
        Adapter = DeviceObject->DeviceExtension;
    }
    
    ASSERT_ADAPTER (Adapter);

    Srb = NULL;
    Xrb = NULL;
    RaidCreateRegion (&SrbExtensionRegion);

    //
    // HACK - allocate a chunk of common buffer for the actual request to
    // get processed in. We need to determine the size of buffer to allocate
    // this is the larger of the input or output buffers
    //

    if (WmiMinorCode == IRP_MN_EXECUTE_METHOD)
    {
        wnode = (PWNODE_HEADER)WmiParameters->Buffer;
        InputLength = (WmiParameters->BufferSize > wnode->BufferSize) ?
                       WmiParameters->BufferSize :
                       wnode->BufferSize;
    } else {
        InputLength = WmiParameters->BufferSize;
    }

    //
    // Begin allocation chain
    //

    Srb = (PSCSI_WMI_REQUEST_BLOCK) RaidAllocateSrb (Adapter->DeviceObject);

    if (Srb == NULL) {
        Status = STATUS_NO_MEMORY;
        goto done;
    }

    Xrb = RaidAllocateXrb (NULL, Adapter->DeviceObject);

    if (Xrb == NULL) {
        Status = STATUS_NO_MEMORY;
        goto done;
    }

    Xrb->SrbData.OriginalRequest = Srb->OriginalRequest;
    Srb->OriginalRequest = Xrb;
    Xrb->Srb = (PSCSI_REQUEST_BLOCK) Srb;

    RaidBuildMdlForXrb (Xrb, WmiParameters->Buffer, InputLength);

    //
    // Build the srb
    //

    Srb->Function           = SRB_FUNCTION_WMI;
    Srb->DataBuffer         = WmiParameters->Buffer;
    Srb->DataTransferLength = InputLength;
    Srb->Length             = sizeof(SCSI_REQUEST_BLOCK);
    Srb->WMISubFunction     = WmiMinorCode;
    Srb->DataPath           = WmiParameters->DataPath;
    Srb->SrbFlags           = SRB_FLAGS_DATA_IN | SRB_FLAGS_NO_QUEUE_FREEZE;
    Srb->TimeOutValue       = 10;                                // [ten seconds]    
    
    Xrb->SrbData.DataBuffer = Srb->DataBuffer;    
    
    if (RaGetObjectType(DeviceObject) == RaidUnitObject) {
        //
        // Set the logical unit addressing from this PDO's device extension.
        //
        PRAID_UNIT_EXTENSION Unit = DeviceObject->DeviceExtension;

        Srb->PathId      = Unit->Address.PathId;
        Srb->TargetId    = Unit->Address.TargetId;
        Srb->Lun         = Unit->Address.Lun;

    } else {                                                            // [FDO]
    
        PRAID_UNIT_EXTENSION Unit;
        PLIST_ENTRY NextEntry = Adapter->UnitList.List.Flink;
        
        //
        // This piece of code is the equivalent of scsiport's SpFindSafeLogicalUnit().
        // It just takes the first logical unit, and uses that address.
        //

        Srb->WMIFlags    = SRB_WMI_FLAGS_ADAPTER_REQUEST;
        
        if (NextEntry != &Adapter->UnitList.List) {
        
            Unit = CONTAINING_RECORD (NextEntry, RAID_UNIT_EXTENSION, NextUnit);
            Srb->PathId      = Unit->Address.PathId;
            Srb->TargetId    = Unit->Address.TargetId;
            Srb->Lun         = Unit->Address.Lun;
        } else {            
            //
            // no LUN found
            //
            Srb->PathId      = 0;
            Srb->TargetId    = 0;
            Srb->Lun         = 0;
        }    
    }
    
    //
    // Srb extension
    //

    Status = RaidDmaAllocateCommonBuffer (&Adapter->Dma,
                                          RaGetSrbExtensionSize (Adapter),
                                          &SrbExtensionRegion);

    if (!NT_SUCCESS (Status)) {
        goto done;
    }

    //
    // Get the VA for the SRB's extension
    //

    Srb->SrbExtension = RaidRegionGetVirtualBase (&SrbExtensionRegion);


#if 0

    //
    // BUGUBG: Do we need to map buffers?
    //
    
    //
    // Map buffers, if necessary.
    //

    RaidAdapterMapBuffers (Adapter, Irp);
#endif

    //
    // Initialize the Xrb's completion event and
    // completion routine.
    //

    KeInitializeEvent (&Xrb->u.CompletionEvent,
                       NotificationEvent,
                       FALSE);

    //
    // Set the completion routine for the Xrb. This effectivly makes the
    // XRB synchronous.
    //

    RaidXrbSetCompletionRoutine (Xrb,
                                 RaidXrbSignalCompletion);

    //
    // And execute the Xrb.
    //
    
    DebugTrace(("RaWmiPassToMiniPort - XRB=%x, SRB=%x, SRBEXT=%x\n",
                Xrb, Srb, Srb->SrbExtension));
    DebugTrace(("RaWmiPassToMiniPort - Pathid=%x, Target=%x, Lun=%x\n",
                Srb->PathId, Srb->TargetId, Srb->Lun));

    Status = RaidAdapterRaiseIrqlAndExecuteXrb (Adapter, Xrb);

    if (NT_SUCCESS (Status)) {
        KeWaitForSingleObject (&Xrb->u.CompletionEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL);

        Status = RaidSrbStatusToNtStatus (Srb->SrbStatus);
    }

    DebugTrace(("RaWmiPassToMiniPort - XRB=%x, status=%x\n", Xrb, Status));

done:

    //
    // Set the information length to the min of the output buffer length
    // and the length of the data returned by the SRB.
    //

    if (NT_SUCCESS (Status)) {
        WmiParameters->BufferSize = Srb->DataTransferLength;
    } else {
        WmiParameters->BufferSize = 0;
    }


    //
    // Deallocate everything
    //

    if (RaidIsRegionInitialized (&SrbExtensionRegion)) {
        RaidDmaFreeCommonBuffer (&Adapter->Dma,
                                 &SrbExtensionRegion);
        RaidDeleteRegion (&SrbExtensionRegion);
        Srb->SrbExtension = NULL;
    }


    if (Xrb != NULL) {
        RaidFreeXrb (Xrb, FALSE);
        Srb->OriginalRequest = NULL;
    }


    //
    // The SRB extension and XRB must be released before the
    // SRB is freed.
    //

    if (Srb != NULL) {
        RaidFreeSrb ((PSCSI_REQUEST_BLOCK) Srb);
        Srb = NULL;
    }

    return Status;
}


NTSTATUS
RaUnitInitializeWMI(
    IN PRAID_UNIT_EXTENSION Unit
    )
{
    PRAID_ADAPTER_EXTENSION Adapter = Unit->Adapter;
    //
    // Now that we have a LUN, we can initialize WMI support for the adapter if
    // the miniport supports WMI.  This may be a re-register if we've already
    // registered on behalf of scsiport itself.  We have to wait until we have
    // a LUN when the miniport supports WMI because we send it an SRB to do
    // its own initialization. We can't send it an SRB until we have a logical
    // unit.
    //

    if (Adapter->Flags.WmiMiniPortInitialized == FALSE &&
        Adapter->Miniport.PortConfiguration.WmiDataProvider == TRUE) {

        ULONG action;

        //
        // Decide whether we are registering or reregistering WMI for the FDO.
        //

        action = (Adapter->Flags.WmiInitialized == FALSE) ?
           WMIREG_ACTION_REGISTER : WMIREG_ACTION_REREGISTER;

        //
        // Register/reregister. We can get WMI irps as soon as we do this.
        //

        IoWMIRegistrationControl(Adapter->DeviceObject, action);
        Adapter->Flags.WmiMiniPortInitialized = TRUE;
        Adapter->Flags.WmiInitialized = TRUE;
    }

    //
    // Initialize WMI support.
    //

    if (Unit->Flags.WmiInitialized == FALSE) {

        //
        // Register this device object only if the miniport supports WMI
        //

        if (Adapter->Miniport.PortConfiguration.WmiDataProvider == TRUE) {

            //
            // Register this physical device object as a WMI data provider,
            // instructing WMI that it is ready to receive WMI IRPs.
            //

            IoWMIRegistrationControl(Unit->DeviceObject, WMIREG_ACTION_REGISTER);
            Unit->Flags.WmiInitialized = TRUE;

        }

    }
    return STATUS_SUCCESS;
}    


VOID
RaidAdapterWmiDeferredRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PRAID_DEFERRED_HEADER Entry
    )
{
    PRAID_UNIT_EXTENSION        logicalUnit;
    PDEVICE_OBJECT              providerDeviceObject = NULL;
    PRAID_ADAPTER_EXTENSION     Adapter;
    PRAID_WMI_DEFERRED_ELEMENT  Item;

    VERIFY_DISPATCH_LEVEL();
    ASSERT (Entry != NULL);
    ASSERT (IsAdapter (DeviceObject));

    Adapter = (PRAID_ADAPTER_EXTENSION) DeviceObject->DeviceExtension;
    Item = CONTAINING_RECORD (Entry, RAID_WMI_DEFERRED_ELEMENT, Header);

    //
    // Determine if the WMI data provider is the
    // adapter (FDO; PathId=0xFF) or one of the SCSI
    // targets (PDO; identified by
    // PathId,TargedId,Lun).
    //

    if (Item->PathId == 0xFF) {                    // [FDO]
        if (Adapter->Flags.WmiInitialized) {
            providerDeviceObject = DeviceObject;
        }            
        
    } else {                                                     // [PDO]
        logicalUnit = StorPortGetLogicalUnit(Adapter, Item->PathId, Item->TargetId, Item->Lun);

        if (logicalUnit && logicalUnit->Flags.WmiInitialized) {
            providerDeviceObject = logicalUnit->DeviceObject;
        }
    }

    //
    // Ignore this WMI request if we cannot locate
    // the WMI ProviderId (device object pointer) or
    // WMI is not initialized for some reason,
    // otherwise process the request.
    //

    if (providerDeviceObject) {
        PWNODE_EVENT_ITEM       wnodeEventItem;
        NTSTATUS                status;
 
        wnodeEventItem = RaidAllocatePool(PagedPool,
                                          Item->WnodeEventItem.WnodeHeader.BufferSize,
                                          WMI_EVENT_TAG, 
                                          Adapter->DeviceObject);
                                          
        if (wnodeEventItem) {

            RtlCopyMemory(wnodeEventItem, &Item->WnodeEventItem,
                                          Item->WnodeEventItem.WnodeHeader.BufferSize);                                          
 
            ASSERT(wnodeEventItem->WnodeHeader.Flags & WNODE_FLAG_EVENT_ITEM);
           
            wnodeEventItem->WnodeHeader.ProviderId = IoWMIDeviceObjectToProviderId(providerDeviceObject);
            KeQuerySystemTime(&wnodeEventItem->WnodeHeader.TimeStamp);        

            //
            // IoWMIWriteEvent will free the event item on success
            //

            status = IoWMIWriteEvent(wnodeEventItem);
           
            if (!NT_SUCCESS(status)) {
                RaidFreePool(wnodeEventItem, WMI_EVENT_TAG);
            }
        }

    } // good providerId / WMI initialized


    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\port\wmi.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    wmi.h

Abstract:

    Definition of RAID_WMI object and operations.

Author:

    Matthew D Hendel (math) 20-Apr-2000

Revision History:

--*/

#pragma once

#define WMI_MINIPORT_EVENT_ITEM_MAX_SIZE 128

//
// WMI parameters.
//

typedef struct _WMI_PARAMETERS {
   ULONG_PTR ProviderId; // ProviderId parameter from IRP
   PVOID DataPath;      // DataPath parameter from IRP
   ULONG BufferSize;    // BufferSize parameter from IRP
   PVOID Buffer;        // Buffer parameter from IRP
} WMI_PARAMETERS, *PWMI_PARAMETERS;

//
// Function prototypes
//

NTSTATUS
RaWmiDispatchIrp(
    PDEVICE_OBJECT DeviceObject,
    PIRP           Irp
    );

NTSTATUS
RaWmiIrpNormalRequest(
    IN     PDEVICE_OBJECT  DeviceObject,
    IN     UCHAR           WmiMinorCode,
    IN OUT PWMI_PARAMETERS WmiParameters
    );

NTSTATUS
RaWmiIrpRegisterRequest(
    IN     PDEVICE_OBJECT  DeviceObject,
    IN OUT PWMI_PARAMETERS WmiParameters
    );

NTSTATUS
RaWmiPassToMiniPort(
    IN     PDEVICE_OBJECT  DeviceObject,
    IN     UCHAR           WmiMinorCode,
    IN OUT PWMI_PARAMETERS WmiParameters
    );
    
NTSTATUS
RaUnitInitializeWMI(
    IN PRAID_UNIT_EXTENSION Unit
    );

//
// WMI Event prototypes
//


VOID
RaidAdapterWmiDeferredRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PRAID_DEFERRED_HEADER Item
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\storlib\debug.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    Debugging routines exported by the STOR library.

Author:

    Matthew D Hendel (math) 29-Apr-2000

Revision History:

--*/

#include "precomp.h"

//#include "ntrtl.h"

#if DBG

BOOLEAN StorQuiet = FALSE;
ULONG StorComponentId = -1;
PCSTR StorDebugPrefix = "STOR: ";


//
// NB: These should come from ntrtl.h
//

ULONG
vDbgPrintExWithPrefix(
    IN PCH Prefix,
    IN ULONG ComponentId,
    IN ULONG Level,
    IN PCSTR Format,
    va_list arglist
    );

NTSYSAPI
ULONG
NTAPI
DbgPrompt(
    PCH Prompt,
    PCH Response,
    ULONG MaximumResponseLength
    );

BOOLEAN
StorAssertHelper(
    PCHAR Expression,
    PCHAR File,
    ULONG Line,
    PBOOLEAN Ignore
    )
{
    CHAR Response[2];

    DebugPrint (("*** Assertion failed: %s\n", Expression));
    DebugPrint (("*** Source File: %s, line %ld\n\n", File, Line));

    if (*Ignore == TRUE) {
        DebugPrint (("Ignored\n"));
        return FALSE;
    }

    for (;;) {

        //
        // The following line will print the prefix, not just the space.
        //
        DebugPrint ((" "));
        DbgPrompt( "(B)reak, (S)kip (I)gnore (bsi)? ",
                   Response,
                   sizeof (Response) );

        switch (tolower (Response[0])) {

            case 'b':
                return TRUE;

            case 'i':
                *Ignore = TRUE;
                return FALSE;

            case 's':
                return FALSE;
        }
    }
}


VOID
StorSetDebugPrefixAndId(
    IN PCSTR Prefix,
    IN ULONG ComponentId
    )
/*++

Routine Description:

    Set the default debug prefix to something other than "STOR: ".

Arguments:

    Prefix - Supplies the prefix. The pointer to the prefix is saved
            preserved, so the prefix memory cannot be paged deallocated.
            Generally, using a static string here is best.

    ComponentId -

Return Value:

    None.

--*/
{
    StorDebugPrefix = Prefix;
    StorComponentId = ComponentId;
}

VOID
vStorDebugPrintEx(
    IN ULONG Level,
    IN PCSTR Format,
    va_list arglist
    )
{
    if (Level == DPFLTR_ERROR_LEVEL || !StorQuiet) {
        vDbgPrintExWithPrefix ((PSTR)StorDebugPrefix,
                               StorComponentId,
                               Level,
                               Format,
                               arglist);
    }
}

VOID
StorDebugPrintEx(
    IN ULONG Level,
    IN PCSTR Format,
    ...
    )
{
    va_list ap;

    va_start (ap, Format);
    vStorDebugPrintEx (Level, Format, ap);
    va_end (ap);
}

VOID
StorDebugWarn(
    IN PCSTR Format,
    ...
    )
{
    va_list ap;

    va_start (ap, Format);
    vStorDebugPrintEx (DPFLTR_WARNING_LEVEL,
                       Format,
                       ap);
    va_end (ap);
}

VOID
StorDebugTrace(
    IN PCSTR Format,
    ...
    )
{
    va_list ap;

    va_start (ap, Format);
    vStorDebugPrintEx (DPFLTR_TRACE_LEVEL,
                       Format,
                       ap);
    va_end (ap);
}

VOID
StorDebugPrint(
    IN PCSTR Format,
    ...
    )
{
    va_list ap;

    va_start (ap, Format);
    vStorDebugPrintEx (DPFLTR_ERROR_LEVEL,
                       Format,
                       ap);
    va_end (ap);
}

#endif // DBG


//
// The following are support functions for compiler runtime checks.
//


#if defined (_RTC) || (DBG == 1)

typedef struct _RTC_vardesc {
    int addr;
    int size;
    char *name;
} _RTC_vardesc;

typedef struct _RTC_framedesc {
    int varCount;
    _RTC_vardesc *variables;
} _RTC_framedesc;



VOID
__cdecl
_RTC_InitBase(
    VOID
    )
{
}

VOID
__cdecl
_RTC_Shutdown(
    VOID
    )
{
}

VOID
#if defined (_X86_)
__declspec(naked)
#endif // _X86_
__cdecl
_RTC_CheckEsp(
    )
{

#if defined (_X86_)

    __asm {
        jne esperror    ;
        ret

    esperror:
        ; function prolog

        push ebp
        mov ebp, esp
        sub esp, __LOCAL_SIZE

        push eax        ; save the old return value
        push edx

        push ebx
        push esi
        push edi
    }

    DebugPrint (("*** Callstack Check failure at %p\n", _ReturnAddress()));
    KdBreakPoint();

    __asm {
        ; function epilog

        pop edi
        pop esi
        pop ebx

        pop edx         ; restore the old return value
        pop eax

        mov esp, ebp
        pop ebp
        ret
    }

#endif

}


VOID
FASTCALL
_RTC_CheckStackVars(
    PVOID frame,
    _RTC_framedesc *v
    )
{
    int i;

    for (i = 0; i < v->varCount; i++) {
        int *head = (int *)(((char *)frame) + v->variables[i].addr + v->variables[i].size);
        int *tail = (int *)(((char *)frame) + v->variables[i].addr - sizeof(int));

        if (*tail != 0xcccccccc || *head != 0xcccccccc) {

            DebugPrint(("*** RTC Failure %p: stack corruption near %p (%s)\n",
                     _ReturnAddress(),
                     v->variables[i].addr + (ULONG_PTR)frame,
                     v->variables[i].name));
            KdBreakPoint();
        }
    }
}

VOID
__cdecl
_RTC_UninitUse(
    IN PCSTR varname
    )
{
    DebugPrint(("\n*** RTC Failure %p: uninitialized variable %s.\n",
             _ReturnAddress(),
             varname));
    KdBreakPoint();
}

#endif // _RTC || DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\storlib\dict.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    dict.c

Abstract:

    This module implements a dictionary package. A dictionary is a
    generic mapping of an arbitrary domain to an arbitrary range.

    This implementation uses a hash-table to give constant time insert
    and delete access to the elements in the table, assuming the table is
    relativly close in size to the number of elements in the table.

Author:

    Matthew D Hendel (math) 9-Feb-2001

Revision History:

--*/

#include "precomp.h"

#define DICT_TAG    ('tciD')

#ifdef ExAllocatePool
#undef ExAllocatePool
#define ExAllocatePool(Type, Size) ExAllocatePoolWithTag(Type, Size, DICT_TAG)
#endif

#ifdef ExFreePool
#undef ExFreePool
#define ExFreePool(Type) ExFreePoolWithTag (Type, DICT_TAG)
#endif


NTSTATUS
StorCreateDictionary(
    IN PSTOR_DICTIONARY Dictionary,
    IN ULONG EntryCount,
    IN POOL_TYPE PoolType,
    IN STOR_DICTIONARY_GET_KEY_ROUTINE GetKeyRoutine,
    IN STOR_DICTIONARY_COMPARE_KEY_ROUTINE CompareKeyRoutine, OPTIONAL
    IN STOR_DICTIONARY_HASH_KEY_ROUTINE HashKeyRoutine OPTIONAL
    )
/*++

Routine Description:

    Initialize a dictionary object.

Arguments:

    Dictionary - Supplies the dictionary object to initialize.

    EntryCount - Supplies the initial number of empty slots in the dictioanry
        table. This number can increase via a call to StorSetElementCount.

    PoolType - Pool type of memory to be used.

    GetKeyRoutine - User-supplied routine to get a key from a specific
        element.

    CompareKeyRoutine - User-supplied routine to compare the keys of
        two elements. If this routine is not supplied, the default
        comparison will be used which assumes the values of the keys
        are ULONGs.

    HashKeyRoutine - User-supplied routine to has the key to a ULONG.
        If this routine is not supplied, the default has routine
        merely returns the value of the key as a ULONG.

Return Value:

    NTSTATUS code.

--*/
{
    ULONG i;
    PLIST_ENTRY Entries;

    Dictionary->MaxEntryCount = EntryCount;
    Dictionary->EntryCount = 0;
    Dictionary->PoolType = PoolType;
    Dictionary->GetKeyRoutine = GetKeyRoutine;

    if (CompareKeyRoutine != NULL) {
        Dictionary->CompareKeyRoutine = CompareKeyRoutine;
    } else {
        Dictionary->CompareKeyRoutine = StorCompareUlongKey;
    }

    if (HashKeyRoutine != NULL) {
        Dictionary->HashKeyRoutine = HashKeyRoutine;
    } else {
        Dictionary->HashKeyRoutine = StorHashUlongKey;
    }

    Entries = ExAllocatePool (PoolType,
                              EntryCount * sizeof (LIST_ENTRY));

    if (Entries == NULL) {
        return STATUS_NO_MEMORY;
    }

    //
    // Initialize the table of lists.
    //
    
    for (i = 0; i < EntryCount; i++) {
        InitializeListHead (&Entries[i]);
    }
    
    Dictionary->Entries = Entries;

    return STATUS_SUCCESS;
}

NTSTATUS
StorDeleteDictionary(
    IN PSTOR_DICTIONARY Dictionary
    )
/*++

Routine Description:

    Delete the dictionary and all resources held by the dictionary.

    NB: This routine does not delete all of the individual elements from
    the dictionary -- it can't.  You should delete the elements from the
    dictionary before calling this routine.

Arguments:

    Dictionary - Supplies the dictinoary to delete.

Return Value:

    NTSTATUS code.

--*/
{
    if (Dictionary->EntryCount != 0) {
        ASSERT (FALSE);
        //
        //NB: should we define a new NTSTATUS value for
        //STATUS_NOT_EMPTY condition?
        //
        return STATUS_DIRECTORY_NOT_EMPTY;
    }

    ASSERT (Dictionary->Entries != NULL);
    ExFreePool (Dictionary->Entries);

    return STATUS_SUCCESS;
}

NTSTATUS
StorInsertDictionary(
    IN PSTOR_DICTIONARY Dictionary,
    IN PSTOR_DICTIONARY_ENTRY Entry
    )
/*++

Routine Description:

    Insert an entry into the dictionary.

Arguments:

    Dictionary - Supplies the dictionary to insert into.
    
    Entry - Supplies the entry to insert.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG Index;
    PLIST_ENTRY NextEntry;
    PLIST_ENTRY ListHead;
    LONG Comparison;
    STOR_DICTIONARY_GET_KEY_ROUTINE GetKeyRoutine;
    STOR_DICTIONARY_COMPARE_KEY_ROUTINE CompareRoutine;
    STOR_DICTIONARY_HASH_KEY_ROUTINE HashRoutine;


    GetKeyRoutine = Dictionary->GetKeyRoutine;
    CompareRoutine = Dictionary->CompareKeyRoutine;
    HashRoutine = Dictionary->HashKeyRoutine;
    
    Index = (HashRoutine (GetKeyRoutine (Entry)) % Dictionary->MaxEntryCount);
    ListHead = &Dictionary->Entries[Index];

    //
    // Otherwise, walk the list searching for the place to insert the entry.
    //
    
    for (NextEntry = ListHead->Flink;
         NextEntry != ListHead;
         NextEntry = NextEntry->Flink) {

        Comparison = CompareRoutine (GetKeyRoutine (NextEntry),
                                     GetKeyRoutine (Entry));

        if (Comparison == 0) {

            return STATUS_DUPLICATE_OBJECTID;

        } else if (Comparison < 0) {

            //
            // Insert the entry directly before this entry.


            Entry->Flink = NextEntry;
            Entry->Blink = NextEntry->Blink;
            Entry->Flink->Blink = Entry;
            Entry->Blink->Flink = Entry;

            ASSERT (Entry->Flink->Blink == Entry);
            ASSERT (Entry->Blink->Flink == Entry);

#if DBG
            for (NextEntry = ListHead->Flink;
                 NextEntry != ListHead;
                 NextEntry = NextEntry->Flink) {

                 NOTHING;
            }
#endif

            Dictionary->EntryCount++;
            return STATUS_SUCCESS;

        } else {

            //
            // Continue searching
            //

            ASSERT (Comparison > 0);
        }
    }

    //
    // We'll only exit the loop if there isn't a entry less than the
    // one we're inserting. The list is either empty, or all of the
    // entries in the list are less than the one we're inserting.
    // In either case, the correct action is to add and entry to the
    // end of the list.
    //
    
    Dictionary->EntryCount++;
    InsertTailList (ListHead, Entry);

    return STATUS_SUCCESS;
}
    
        
NTSTATUS
StorFindDictionary(
    IN PSTOR_DICTIONARY Dictionary,
    IN PVOID Key,
    OUT PSTOR_DICTIONARY_ENTRY* EntryBuffer OPTIONAL
    )
/*++

Routine Description:

    Find an entry in the dictionary and, optionally, retun the found
    entry.

Arguments:

    Dictionary - Supplies the dictionary to search through.

    Key - Supplies the key of the entry to search for.

    EntryBuffer - Supplies an optional buffer where the entry will be copied
            if found.

Return Value:

    STATUS_NOT_FOUND - If the entry could not be found.

    STATUS_SUCCESS - If the entry was successfully found.

    Other NTSTATUS code - For other errors.

--*/
{
    NTSTATUS Status;
    LONG Comparison;
    ULONG Index;
    PLIST_ENTRY ListHead;
    PLIST_ENTRY NextEntry;
    STOR_DICTIONARY_GET_KEY_ROUTINE GetKeyRoutine;
    STOR_DICTIONARY_COMPARE_KEY_ROUTINE CompareRoutine;
    STOR_DICTIONARY_HASH_KEY_ROUTINE HashRoutine;

    GetKeyRoutine = Dictionary->GetKeyRoutine;
    CompareRoutine = Dictionary->CompareKeyRoutine;
    HashRoutine = Dictionary->HashKeyRoutine;
    
    Index = HashRoutine (Key) % Dictionary->MaxEntryCount;
    ListHead = &Dictionary->Entries[Index];

    Status = STATUS_NOT_FOUND;

    for (NextEntry = ListHead->Flink;
         NextEntry != ListHead;
         NextEntry = NextEntry->Flink) {

        Comparison = CompareRoutine (GetKeyRoutine (NextEntry), Key);

        if (Comparison == 0) {

            //
            // Found it.
            //

            Status = STATUS_SUCCESS;
            
            if (EntryBuffer) {
                *EntryBuffer = NextEntry;
            }
            
            break;

        } else if (Comparison < 0) {

            //
            // Done searching
            //
            
            Status = STATUS_NOT_FOUND;

            if (EntryBuffer) {
                *EntryBuffer = NULL;
            }
            break;

        } else {

            //
            // Continue searching
            //

            ASSERT (Comparison > 0);
        }
    }

    return Status;

}

NTSTATUS
StorRemoveDictionary(
    IN PSTOR_DICTIONARY Dictionary,
    IN PVOID Key,
    OUT PSTOR_DICTIONARY_ENTRY* EntryBuffer OPTIONAL
    )
/*++

Routine Description:

    Remove an entry from the dictionary.

Arguments:

    Dictioanry - Supplies the dictionary to remove the entry from.

    Key - Supplies the key used to identify the entry.

    EntryBuffer - Optional parameter that supplies a buffer to copy the
            removed entry into.

Return Value:

    STATUS_NOT_FOUND - If the entry was not found.

    STATUS_SUCCESS - If the entry was successfully removed.

    Other NTSTATUS code - other error condition.

--*/
{
    NTSTATUS Status;
    PSTOR_DICTIONARY_ENTRY Entry;

    Entry = NULL;
    Status = StorFindDictionary (Dictionary, Key, &Entry);

    if (NT_SUCCESS (Status)) {
        RemoveEntryList (Entry);
        Dictionary->EntryCount--;
        
    }

    if (EntryBuffer) {
        *EntryBuffer = Entry;
    }
    
    return Status;
}

NTSTATUS
StorAdjustDictionarySize(
    IN PSTOR_DICTIONARY Dictionary,
    IN ULONG MaxEntryCount
    )
/*++

Routine Description:

    Adjust the number of bins in the underlying hash table. Having the
    number of bins relativly large compared to the number of entries in
    the table gives much better performance.

    Adjusting the size of the dictionary is an expensive operation. It
    takes about the same amount of time to adjust the dictionary size as
    it does to delete the dictionary and create a new one.

Arguments:

    Dictionary - Supplies the dictionary whose size is to be adjusted.

    MaxEntryCount - Supplies the new maximum entry count. This can be
            greater or less than the current entry count. (It can
            actually be the same as the current entry count, but
            doing so merely wastes time.)

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG i;
    ULONG OldMaxEntryCount;
    PLIST_ENTRY OldEntries;
    PLIST_ENTRY Entries;
    PLIST_ENTRY Head;
    PLIST_ENTRY Entry;


    OldEntries = Dictionary->Entries;
    OldMaxEntryCount = Dictionary->MaxEntryCount;

    Entries = ExAllocatePool (Dictionary->PoolType,
                              sizeof (LIST_ENTRY) * MaxEntryCount);

    if (Entries == NULL) {
        return STATUS_NO_MEMORY;
    }

    for (i = 0; i < MaxEntryCount; i++) {
        InitializeListHead (&Entries[i]);
    }

    //
    // Save the old dictionary
    //
    
    OldEntries = Dictionary->Entries;
    OldMaxEntryCount = Dictionary->MaxEntryCount;

    //
    // Replace it with the new, empty one
    //
    
    Dictionary->Entries = Entries;
    Dictionary->MaxEntryCount = MaxEntryCount;

    //
    // Remove all the old entries, placing them in the new dictioanry
    //
    
    for (i = 0; i < OldMaxEntryCount; i++) {
        Head = &OldEntries[i];
        while (!IsListEmpty (Head)) {
            Entry = RemoveHeadList (Head);
            Status = StorInsertDictionary (Dictionary, Entry);
            ASSERT (NT_SUCCESS (Status));
        }
    }

    ExFreePool (Entries);

    return STATUS_SUCCESS;
}


VOID
StorEnumerateDictionary(
    IN PSTOR_DICTIONARY Dictionary,
    IN PSTOR_DICTIONARY_ENUMERATOR Enumerator
    )
/*++

Routine Description:

    Enumerate the entries in the dictionary. 

Arguments:

    Dictionary - Supplies the dictionary to enumerate.

    Enumerator - Supplies an enumerator used to enumerate the dictionary.
        To halt the enumeration, the enumerator should return FALSE.

Caveats:

    The entries are listed in ARBITRARY ORDER. This is not an ordered
    enumeration.

    Multiple enumerations of the list can happen at the same time. But
    the list CANNOT BE MODIFIED while it is being enumerated.

Return Value:

    None.
    
--*/
{
    ULONG i;
    PLIST_ENTRY NextEntry;
    PLIST_ENTRY ListHead;
    BOOLEAN Continue;

    REVIEW();

    for (i = 0; i < Dictionary->MaxEntryCount; i++) {
        ListHead = &Dictionary->Entries[i];
        for (NextEntry = ListHead->Flink;
             NextEntry != ListHead;
             NextEntry = NextEntry->Flink) {
            Continue = Enumerator->EnumerateEntry (Enumerator, NextEntry);
            if (!Continue) {
                return ;
            }
        }
    }
}

LONG
StorCompareUlongKey(
    IN PVOID Key1,
    IN PVOID Key2
    )
/*++

Routine Description:

    Compare key routine for ULONG keys.

Arguments:

    Key1 - First key to compare.

    Key2 - Second key to compare.

Return Value:

    -1 - if Key1 < Key2

     0 - if Key1 == Key2

     1 - if Key1 > Key2

--*/
{
    if (Key1 < Key2) {
        return -1;
    } else if (Key1 == Key2) {
        return 0;
    } else {
        return 1;
    }
}

ULONG
StorHashUlongKey(
    IN PVOID Key
    )
/*++

Routine Description:

    Hash routine for ULONG keys.

Arguments:

    Key - Supplies the key to hash.

Return Value:

    Hash code for the key.

--*/
{
    return (ULONG)(ULONG_PTR)Key;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\storlib\precomp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Precompiled header file for storlib library.

Author:

    Matthew D Hendel (math) 13-Feb-2001

Revision History:

--*/


#include <ntddk.h>
#include <stdarg.h>
#include <stdio.h>

#include "storlib.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\test\exqueue.c ===
#include "raidport.h"
#include "..\port\exqueue.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\storlib\gateway.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

	gateway.c

Abstract:

	Declaration of a gateway class that manages multiple interrelated
	sub-devices on a device.

	The IO gateway keeps track of elements queued to a device. The
	gateway is only necessary for device/driver pairs that have multiple
	independent device queues per physical device. A SCSI port driver,
	for example, can queue items on a per-logical-unit basis instead of
	per-HBA basis. The advantage of a per-logical-unit queue is that if a
	logical-unit becomes busy, requests for different logical units can
	be submitted to the adapter while the first logical unit is frozen.

	The gateway object is the object that coordinates the communication
	to the physical HBA.

						 ---
	 -------------		| H |
	| LUN 1 Queue | --> | B |
	 -------------		| A |
						|   |      ----------
	 -------------		| G |     | 	     |
	| LUN 2 Queue | -->	| a | --> | HBA  ----
	 -------------		| t |     |     |
						| e |      ------
	 -------------		| w |
	| LUN 1 Queue | -->	| a |
	 -------------		| y |
						 ---

	The gateway keeps track of whether the HBA is busy or frozen, how
	many outstanding requests are on the HBA, and, when the HBA is busy,
	the algorithm it uses to clear it's busy state.

Author:

	Matthew D Hendel (math) 15-June-2000

Revision History:

--*/

#include "precomp.h"


INLINE
VOID
ASSERT_GATEWAY(
	IN PSTOR_IO_GATEWAY Gateway
	)
{
#if DBG
	ASSERT (Gateway->BusyRoutine != NULL);
	ASSERT (Gateway->BusyCount >= 0);
	ASSERT (Gateway->PauseCount >= 0);
#endif
}

VOID
StorCreateIoGateway(
	IN PSTOR_IO_GATEWAY Gateway,
	IN PSTOR_IO_GATEWAY_BUSY_ROUTINE BusyRoutine,
	IN PVOID BusyContext
    )
/*++

Routine Description:

	Create an IO gateway.

Arguments:

	Gateway - IO Gateway to create.

	BusyAlgorithm - Description of the algorithm to use and associated
			parameters when the gatway is busy.

Return Value:

	None.

--*/
{
	ASSERT (BusyRoutine != NULL);
	
    RtlZeroMemory (Gateway, sizeof (STOR_IO_GATEWAY));

    //
    // The initial high and low water marks are somewhat irrelevant since
    // we will define these when we get busied.
    //
    
    Gateway->HighWaterMark = MAXLONG;
    Gateway->LowWaterMark = MAXLONG;

	Gateway->BusyRoutine = BusyRoutine;
	Gateway->BusyContext = BusyContext;
	
    KeInitializeSpinLock (&Gateway->Lock);
}


BOOLEAN
StorSubmitIoGatewayItem(
	IN PSTOR_IO_GATEWAY Gateway
    )
/*++

Routine Description:

	Attempt to submit an item to the gateway.

Arguments:

	Gateway - Gateway to submit the item to.

Return Value:

	TRUE - If the item can be submitted to the underlying hardware.

	FALSE - If the underlying hardware is currently busy with other
			requests and the request should be held until the hardware is
			ready to process more requets.

--*/
{
    BOOLEAN Ready;
    KLOCK_QUEUE_HANDLE LockHandle;

    //
    // PERF NOTE: This is the only adapter-wide lock aquisition done
    // for an IO. Therefore, we can suppose it is the hottest lock
    // in raidport (this remains to be seen from performance data).
    // We should seriously investigate a way to either eliminate this
    // lock or to turn it into a series of interlocked operations.
    // Do not do any significant processing while this lock is held.
    //
    
    KeAcquireInStackQueuedSpinLockAtDpcLevel (&Gateway->Lock, &LockHandle);

	//
	// If the gateway is busy or paused, do not submit it.
	//
	
    if (Gateway->BusyCount > 0 ||
		Gateway->PauseCount > 0 ||
        Gateway->Outstanding >= Gateway->HighWaterMark) {

        Ready = FALSE;

    } else {

        Gateway->Outstanding++;

        if (Gateway->Outstanding >= Gateway->HighWaterMark) {
            Gateway->BusyCount = TRUE;
        }
        
        Ready = TRUE;
    }

    KeReleaseInStackQueuedSpinLockFromDpcLevel (&LockHandle);

    return Ready;
}



BOOLEAN
StorIsIoGatewayBusy(
	IN PSTOR_IO_GATEWAY Gateway
	)
{
	return (Gateway->BusyCount >= 1);
}

BOOLEAN
StorRemoveIoGatewayItem(
    IN PSTOR_IO_GATEWAY Gateway
    )
/*++

Routine Description:

    Notify the gateway that an item has been completed.

Arguments:

    Gateway - Gateway to submit notification to.

Return Value:

    TRUE -  If the completion of this item transitions the gateway from a
		    busy state to a non-busy state. In this case, the unit queues
		    that submit items to the gateway need to be restarted.

    FALSE - If this completion did not change the busy state of the
			gateway.

--*/
{
    BOOLEAN Restart;
    KLOCK_QUEUE_HANDLE LockHandle;

    //
    // PERF NOTE: This is the only adapter-wide lock used by the system
    // in the IO path. See perf note in RaidAdapterGatewaySubmitItem.
    //
    
    KeAcquireInStackQueuedSpinLockAtDpcLevel (&Gateway->Lock, &LockHandle);
    
    Gateway->Outstanding--;
    ASSERT (Gateway->Outstanding >= 0);

    if ((Gateway->BusyCount > 0) &&
		(Gateway->Outstanding <= Gateway->LowWaterMark)) {

		Gateway->BusyCount = FALSE;
		Restart = TRUE; // (Gateway->BusyCount == 0) ? TRUE : FALSE;

    } else {
        Restart = FALSE;
    }

	//
	// There are no more outstanding requests, so clear the event.
	//
	
	if (Gateway->EmptyEvent && Gateway->Outstanding == 0) {
		KeSetEvent (Gateway->EmptyEvent, IO_NO_INCREMENT, FALSE);
		Gateway->EmptyEvent = NULL;
	}

    KeReleaseInStackQueuedSpinLockFromDpcLevel (&LockHandle);

    return Restart;
}

VOID
StorBusyIoGateway(
    IN PSTOR_IO_GATEWAY Gateway
    )
/*++

Routine Description:

	Place the gateway into the busy state. The gateway will stay busy
	until the number of requests has drained to a specific level.

Arguments:

	Gateway - The gateway to make busy.

Return Value:

	None.

--*/
{
    //
    // The adapter MUST have some outstanding requests if it's claiming
    // to be busy.
    //
    
	//
	// Invoke the supplied busy routine to modify the high/low-water marks.
	//

	if (Gateway->BusyCount) {
		return ;
	}
	
	Gateway->BusyRoutine (Gateway->BusyContext,
						  Gateway->Outstanding - 1,
						  &Gateway->HighWaterMark,
						  &Gateway->LowWaterMark);
							
	Gateway->BusyCount = TRUE;
}

LONG
StorPauseIoGateway(
    IN PSTOR_IO_GATEWAY Gateway
    )
/*++

Routine Description:

    Place the gateway into the paused state. 

Arguments:

    Gateway - Supplies the gateway to pause.

Return Value:

	Pause count for the gateway.

--*/
{
    return InterlockedIncrement (&Gateway->PauseCount);
}

LONG
StorResumeIoGateway(
    IN OUT PSTOR_IO_GATEWAY Gateway
    )
/*++

Routine Description:

	Resume the gateway.

Arguments:

    Gateway - Supplies the gateway to resume.

Return Value:

	Current pause count for the gateway.

--*/
{
	LONG Count;

	Count = InterlockedDecrement (&Gateway->PauseCount);
	ASSERT (Count >= 0);

	return Count;
}

BOOLEAN
StorIsIoGatewayPaused(
    IN PSTOR_IO_GATEWAY Gateway
    )
/*++

Routine Description:

    Returns TRUE if the gateway is currently paused, else FALSE.

Arguments:

    Gateway - Supplies the gateway to check.

Return Value:

    None.

--*/
{
	ASSERT (Gateway->PauseCount >= 0);
    return (Gateway->PauseCount != 0);
}


VOID
StorSetIoGatewayEmptyEvent(
	IN PSTOR_IO_GATEWAY Gateway,
	IN PKEVENT Event
	)
{
	KLOCK_QUEUE_HANDLE LockHandle;
	
	//
	// BUGBUG: This is bad. Instead, the event should be owned by the gateway,
	// we should give it out (and reference count it), so that multiple
	// clients can use it. Need to figure out how to do this so we don't
	// lock the dispatcher database twice per I/O.
	//

	KeAcquireInStackQueuedSpinLock (&Gateway->Lock, &LockHandle);
	if (Gateway->Outstanding == 0) {
		KeSetEvent (Event, IO_NO_INCREMENT, FALSE);
	} else {
		Gateway->EmptyEvent = Event;
	}
	KeReleaseInStackQueuedSpinLock (&LockHandle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\test\tq.c ===
//
// Test/simulation program for the extended device queue
//

#include "raidport.h"
#include "exqueue.h"

#define	SECONDS (1000)

typedef struct _TQ_ITEM {
	ULONG Thread;
	ULONG64 Data;
	ULONG64 Sequence;
	KDEVICE_QUEUE_ENTRY DeviceEntry;
	LIST_ENTRY DpcEntry;
} TQ_ITEM, *PTQ_ITEM;


typedef struct _DPC_QUEUE {
	HANDLE Available;
	HANDLE Mutex;
	LIST_ENTRY Queue;
	ULONG Count;
} DPC_QUEUE, *PDPC_QUEUE;


BOOL Verbose = FALSE;
BOOL Cerbose = TRUE;
DPC_QUEUE DpcQueue;
EXTENDED_DEVICE_QUEUE DeviceQueue;
BOOLEAN Pause = FALSE;
BOOLEAN PauseProducer = FALSE;
ULONG64 GlobalSequence = 0;
DWORD Owner = 0;
BOOL Available = FALSE;


VOID
GetNext(
	OUT PULONG64 Sequence,
	OUT PULONG Data
	)
{
	*Sequence = ++GlobalSequence;
	*Data = (ULONG)rand();
}

#pragma warning (disable:4715)

BOOL
WINAPI
UpdateThread(
	PVOID Unused
	)
{
	for (;;) {

		while (Pause) {
			Sleep (500);
		}
		
		printf ("Seq: %I64d, dev %d bypass %d dpc %d                       \r",
				 GlobalSequence,
				 DeviceQueue.DeviceRequests,
				 DeviceQueue.ByPassRequests,
				 DpcQueue.Count);
		Sleep (2000);
	}

	return FALSE;
}

VOID
CreateDpcQueue(
	PDPC_QUEUE DpcQueue
	)
{
	DpcQueue->Available = CreateEvent (NULL, FALSE, FALSE, NULL);
	DpcQueue->Mutex = CreateMutex (NULL, FALSE, NULL);
	InitializeListHead (&DpcQueue->Queue);
	DpcQueue->Count = 0;
}


VOID
InsertDpcItem(
	IN PDPC_QUEUE DpcQueue,
	IN PLIST_ENTRY Entry
	)
{
	WaitForSingleObject (DpcQueue->Mutex, INFINITE);
	InsertTailList (&DpcQueue->Queue, Entry);
	DpcQueue->Count++;
	Owner = GetCurrentThreadId ();
	Available = TRUE;
	SetEvent (DpcQueue->Available);
	ReleaseMutex (DpcQueue->Mutex);
}

PLIST_ENTRY
RemoveDpcItem(
	IN PDPC_QUEUE DpcQueue
	)
{
	PLIST_ENTRY Entry;
	HANDLE Tuple[2];

	Tuple[0] = DpcQueue->Mutex;
	Tuple[1] = DpcQueue->Available;

	WaitForMultipleObjects (2, Tuple, TRUE, INFINITE);
	Available = FALSE;
	Owner = GetCurrentThreadId ();
	ASSERT (!IsListEmpty (&DpcQueue->Queue));
	Entry = RemoveHeadList (&DpcQueue->Queue);
	DpcQueue->Count--;
	if (!IsListEmpty (&DpcQueue->Queue)) {
		Available = TRUE;
		SetEvent (DpcQueue->Available);
	}
	ReleaseMutex (DpcQueue->Mutex);

	return Entry;
}


BOOL
WINAPI
ProducerThread(
	PVOID Unused
	)
{
	BOOLEAN Inserted;
	PTQ_ITEM Item;
	ULONG Data;
	ULONG64 Sequence;

	srand (GetCurrentThreadId());
	
	for (;;) {

		Sleep (10);

		while (Pause) {
			Sleep (100);
		}

		while (PauseProducer) {
			Sleep (100);
		}
			
		Item = malloc (sizeof (TQ_ITEM));
		ZeroMemory (Item, sizeof (*Item));
		
		GetNext (&Sequence, &Data);
		Item->Thread = GetCurrentThreadId ();
		Item->Sequence = Sequence;
		Item->Data = Data;

		Inserted = RaidInsertExDeviceQueue (&DeviceQueue,
										    &Item->DeviceEntry,
										    FALSE,
											(ULONG)Item->Data);

		if (!Inserted) {

			if (Verbose) {
				printf ("started %x.%I64d\n", Item->Thread, Item->Data);
			}

			InsertDpcItem (&DpcQueue, &Item->DpcEntry);

		} else {
			if (Verbose) {
				printf ("queued %x.%I64d\n", Item->Thread, Item->Data);
			}
		}
	}

	return FALSE;
}

BOOL
WINAPI
ProducerThread100(
	PVOID Unused
	)
{
	BOOLEAN Inserted;
	PTQ_ITEM Item;
	ULONG Data;
	ULONG64 Sequence;

	srand (GetCurrentThreadId());
	
	for (;;) {

		Sleep (0);

		while (Pause) {
			Sleep (100);
		}

		while (PauseProducer) {
			Sleep (100);
		}
			
		Item = malloc (sizeof (TQ_ITEM));
		ZeroMemory (Item, sizeof (*Item));
		
		GetNext (&Sequence, &Data);
		Item->Thread = GetCurrentThreadId ();
		Item->Sequence = Sequence;
		Item->Data = 100;

		Inserted = RaidInsertExDeviceQueue (&DeviceQueue,
										    &Item->DeviceEntry,
										    FALSE,
											(ULONG)Item->Data);

		if (!Inserted) {

			if (Verbose) {
				printf ("started %x.%I64d\n", Item->Thread, Item->Data);
			}

			InsertDpcItem (&DpcQueue, &Item->DpcEntry);

		} else {
			if (Verbose) {
				printf ("queued %x.%I64d\n", Item->Thread, Item->Data);
			}
		}
	}

	return FALSE;
}

BOOL
WINAPI
ErrorProducerThread(
	PVOID Unused
	)
{
	BOOLEAN Inserted;
	PTQ_ITEM Item;
	ULONG64 Sequence;
	ULONG Data;

	for (;;) {

		Sleep (500);
		
		while (Pause) {
			Sleep (10);
		}
			
		Item = malloc (sizeof (TQ_ITEM));
		ZeroMemory (Item, sizeof (*Item));

		GetNext (&Sequence, &Data);
		Item->Thread = GetCurrentThreadId ();
		Item->Sequence = Sequence;
		Item->Data = Data;
		
		Inserted = RaidInsertExDeviceQueue (&DeviceQueue,
										    &Item->DeviceEntry,
										    TRUE,
											(ULONG)Item->Data);

		if (!Inserted) {

			if (Verbose) {
				printf ("started %x.%I64d\n", Item->Thread, Item->Data);
			}

			InsertDpcItem (&DpcQueue, &Item->DpcEntry);

		} else {
			if (Verbose) {
				printf ("queued %x.%I64d\n", Item->Thread, Item->Data);
			}
		}
	}

	return FALSE;
}

VOID
DpcRoutine(
	IN PTQ_ITEM Item
	)
{
	BOOLEAN RestartQueue;
	PKDEVICE_QUEUE_ENTRY Entry;

	if (Verbose || Cerbose) {
		printf ("completed %x.%I64d\n", Item->Thread, Item->Data);
	}

	free (Item);

	Entry = RaidRemoveExDeviceQueue (&DeviceQueue, &RestartQueue);

	if (Entry) {
		Item = CONTAINING_RECORD (Entry, TQ_ITEM, DeviceEntry);
		InsertDpcItem (&DpcQueue, &Item->DpcEntry);
		if (Verbose) {
			printf ("dpc started %x.%I64d\n", Item->Thread, Item->Data);
		}

		//
		// NB: in the port driver, we actually only do this when necessary.
		// The only problem with doing this always is a speed issue, and
		// we're not measuring speed in the simulation program.
		//
		
		for (Entry = RaidNormalizeExDeviceQueue (&DeviceQueue);
			 Entry != NULL;
			 Entry = RaidNormalizeExDeviceQueue (&DeviceQueue)) {

			Item = CONTAINING_RECORD (Entry, TQ_ITEM, DeviceEntry);
			InsertDpcItem (&DpcQueue, &Item->DpcEntry);
		}
		
		
	}
}


BOOL
WINAPI
DpcThread(
	PVOID Unused
	)
{
	PLIST_ENTRY Entry;
	PTQ_ITEM Item;

#if 1
	SetThreadPriority (GetCurrentThread (),
					   THREAD_PRIORITY_ABOVE_NORMAL);
#endif

	for (;;) {

		while (Pause) {
			Sleep (10);
		}

		//
		// Wait for DPC queue to have an item in it
		//

		Entry = RemoveDpcItem (&DpcQueue);
		Item = CONTAINING_RECORD (Entry, TQ_ITEM, DpcEntry);

		DpcRoutine (Item);
	}

	return FALSE;
}

enum {
	NoControl = 0,
	FreezeQueue,
	ResumeQueue
};

volatile ULONG Control = NoControl;

BOOL
WINAPI
ControlThread(
	PVOID Unused
	)
{
	for (;;) {

		Sleep (500);

		switch (Control) {
			case FreezeQueue:
				RaidFreezeExDeviceQueue (&DeviceQueue);
				Control = NoControl;
				break;

			case ResumeQueue:
				RaidResumeExDeviceQueue (&DeviceQueue);
				Control = NoControl;
				break;

			case NoControl:
				break;

			default:
				ASSERT (FALSE);
		}
	}

	return FALSE;
}
	

BOOL
WINAPI
ControlHandler(
	DWORD Val
	)
{
	PLIST_ENTRY NextEntry;
	PTQ_ITEM Item;
	int ch;

	if (Val != CTRL_C_EVENT) {
		return FALSE;
	}

	Pause = TRUE;
	Sleep (1000);
	printf ("\n");

	do {
		printf ("tq> ");
		ch = getchar ();
		printf (" %c\n", ch);

		switch (tolower (ch)) {

			case 'd':

				printf ("Dump of DeviceQueue: %p\n", &DeviceQueue);
				printf ("    Depth %d\n", DeviceQueue.Depth);
				printf ("    Outstanding %d\n", DeviceQueue.OutstandingRequests);
				printf ("    Device %d\n", DeviceQueue.DeviceRequests);
				printf ("    ByPass %d\n", DeviceQueue.ByPassRequests);
				printf ("    Frozen %d\n", DeviceQueue.Frozen);
				break;

			case 'l':
				__try {

					ULONG Count;

					Count = 0;
					for ( NextEntry  = DeviceQueue.DeviceListHead.Flink;
						NextEntry != &DeviceQueue.DeviceListHead;
						NextEntry = NextEntry->Flink ) {
						Count++;

						Item = CONTAINING_RECORD (NextEntry, TQ_ITEM, DeviceEntry);
						printf ("    item %d.%I64d [seq=%d]\n",
								 Item->Thread,
								 Item->Data,
								 Item->Sequence);
					}

					printf ("DeviceList: %d entries\n", Count);
				}

				__except (EXCEPTION_EXECUTE_HANDLER) {
					printf ("ERROR: Inconsistent device list!\n");
				}
				break;

			case 'r':
				Control = ResumeQueue;
				break;

			case 'f':
				Control = FreezeQueue;
				break;

			case 'q':
				exit (0);
				break;

			case 'c':
			case 'g':
				break;

			case 'p':
				if (PauseProducer) {
					printf ("unpausing producers\n");
					PauseProducer = FALSE;
				} else {
					printf ("unpausing producers\n");
					PauseProducer = TRUE;
				}
				break;

			case 'v':
				if (Verbose) {
					Verbose = FALSE;
					printf ("verbose mode off\n");
				} else {
					Verbose = TRUE;
					printf ("verbose mode enabled\n");
				}

			case 'x': {
				ULONG NewDepth;
				printf ("depth> ");
				scanf ("%d", &NewDepth);
				RaidSetExDeviceQueueDepth (&DeviceQueue, NewDepth);
				printf ("stack depth set to %d\n", NewDepth);
				break;
			}

			case '?':
				printf ("    d - dump queue\n");
				printf ("    f - freeze queue\n");
				printf ("    r - resume queue\n");
				printf ("    p - toggle pause of producer threads\n");
				printf ("    u - resume producer threads\n");
				printf ("    g - go\n");
				printf ("    x - set stack depth to new value\n");
				printf ("    v - toggle verbose mode\n");
				printf ("    q - stop\n");
				break;
				
			default:
				printf ("unrecognized operation '%c'\n", ch);
		}

	} while (ch != 'c' && ch != 'g');
				

	Pause = FALSE;
	return TRUE;
}


VOID
__cdecl
main(
	)
{
	DWORD ThreadId;
	ULONG Depth;
	ULONG ProducerThreads;
	ULONG DpcThreads;
	ULONG i;
	SCHEDULING_ALGORITHM SchedulingAlgorithm;
	RAID_ADAPTER_QUEUE AdapterQueue;
	QUEUING_MODEL QueuingModel;

	//
	// Generic adapter queue.
	// 

	QueuingModel.Algorithm = BackOffFullQueue;
	QueuingModel.BackOff.HighWaterPercent = 120;
	QueuingModel.BackOff.LowWaterPercent = 40;

	RaidCreateAdapterQueue (&AdapterQueue, &QueuingModel);
	
	//
	// NB: these should all be parameters
	//
	
	Depth = 1;
	ProducerThreads = 8;
	DpcThreads = 1;
	SchedulingAlgorithm = CScanScheduling;

	printf ("DeviceQueue Test: Depth %d Producers %d DPC Threads %d\n",
			 Depth,
			 ProducerThreads,
			 DpcThreads);

	if (Verbose) {
		printf ("Verbose\n");
	}
	printf ("\n");
	
	CreateDpcQueue (&DpcQueue);
	RaidInitializeExDeviceQueue (&DeviceQueue,
								 &AdapterQueue,
								 Depth,
								 SchedulingAlgorithm);

	SetConsoleCtrlHandler (ControlHandler, TRUE);
	
	for (i = 0; i < DpcThreads; i++) {
		CreateThread (NULL,
					  0,
					  DpcThread,
					  0,
					  0,
					  &ThreadId);
	}
				  
	for (i = 0; i < ProducerThreads; i++) {

		CreateThread (NULL,
					  0,
					  ProducerThread,
					  0,
					  0,
					  &ThreadId);
	}

	CreateThread (NULL,
				  0,
				  ControlThread,
				  0,
				  0,
				  &ThreadId);


	CreateThread (NULL,
				 0,
				 ProducerThread100,
				 0,
				 0,
				 &ThreadId);
#if 0
	CreateThread (NULL,
				  0,
				  ErrorProducerThread,
				  0,
				  0,
				  &ThreadId);

	CreateThread (NULL,
				  0,
				  UpdateThread,
				  0,
				  0,
				  &ThreadId);
				 
#endif
	Sleep (INFINITE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc\ae_init1.c ===
/*
** Copyright (c) 1994-1997 Advanced System Products, Inc.
** All Rights Reserved.
**
** ae_init1.c
**
** for EISA initialization only
*/

#include "ascinc.h"

#if CC_INCLUDE_EISA

/* ----------------------------------------------------------------------
**  Product ID
**  0xC80 - 0x04
**  0xC81 - 0x50
**  0xC82 - 0x74 or 0x75
**  0xC83 - 0x01
**
** ------------------------------------------------------------------ */
ulong  AscGetEisaProductID(
          PortAddr iop_base
       )
{
       PortAddr  eisa_iop ;
       ushort    product_id_high, product_id_low ;
       ulong     product_id ;

       eisa_iop = ASC_GET_EISA_SLOT( iop_base ) | ASC_EISA_PID_IOP_MASK ;
       product_id_low = inpw( eisa_iop ) ;
       product_id_high = inpw( eisa_iop+2 ) ;
       product_id = ( ( ulong)product_id_high << 16 ) | ( ulong )product_id_low ;
       return( product_id ) ;
}

/* -----------------------------------------------------------------
** Description: search EISA host adapter
**
** - search starts with iop_base equals zero( 0 )
**
** return i/o port address found ( non-zero )
** return 0 if not found
** -------------------------------------------------------------- */
PortAddr AscSearchIOPortAddrEISA(
            PortAddr iop_base
         )
{
       ulong  eisa_product_id ;

       if( iop_base == 0 )
       {
           iop_base = ASC_EISA_MIN_IOP_ADDR ;
       }/* if */
       else
       {
           if( iop_base == ASC_EISA_MAX_IOP_ADDR ) return( 0 ) ;
           if( ( iop_base & 0x0050 ) == 0x0050 )
           {
               iop_base += ASC_EISA_BIG_IOP_GAP ;  /* when it is 0zC50 */
           }/* if */
           else
           {
               iop_base += ASC_EISA_SMALL_IOP_GAP ; /* when it is 0zC30 */
           }/* else */
       }/* else */
       while( iop_base <= ASC_EISA_MAX_IOP_ADDR )
       {
/*
** search product id first
*/
            eisa_product_id = AscGetEisaProductID( iop_base ) ;
            if(
                 ( eisa_product_id == ASC_EISA_ID_740 )
              || ( eisa_product_id == ASC_EISA_ID_750 )
              )
            {
                if( AscFindSignature( iop_base ) )
                {
/*
** chip found, clear ID left in latch
** to clear, read any i/o port word that doesn't contain data 0x04c1
** iop_base plus four should do it
*/
                    inpw( iop_base+4 ) ;
                    return( iop_base ) ;
                }/* if */
            }/* if */
            if( iop_base == ASC_EISA_MAX_IOP_ADDR ) return( 0 ) ;
            if( ( iop_base & 0x0050 ) == 0x0050 )
            {
                iop_base += ASC_EISA_BIG_IOP_GAP ;
            }/* if */
            else
            {
                iop_base += ASC_EISA_SMALL_IOP_GAP ;
            }/* else */
       }/* while */
       return( 0 ) ;
}

#endif /* CC_INCLUDE_EISA */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\test\raidport.h ===
#define UTEST	(1)

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#if defined (UTEST)

typedef struct _KDEVICE_QUEUE_ENTRY {
    LIST_ENTRY DeviceListEntry;
    ULONG SortKey;
    BOOLEAN Inserted;
} KDEVICE_QUEUE_ENTRY, *PKDEVICE_QUEUE_ENTRY;

#define KSPIN_LOCK CRITICAL_SECTION
#define KLOCK_QUEUE_HANDLE PCRITICAL_SECTION
#define PKLOCK_QUEUE_HANDLE PCRITICAL_SECTION*
#define KeInitializeSpinLock	InitializeCriticalSection
#define KeAcquireInStackQueuedSpinLockAtDpcLevel(Lock, Handle)\
	do {									\
		*Handle = Lock;						\
		EnterCriticalSection(Lock);			\
	} while (0)
	
#define KeReleaseInStackQueuedSpinLockFromDpcLevel(Handle)\
	LeaveCriticalSection(*Handle)

#define INLINE __inline
#define REVIEW()\
	do {													 \
		OutputDebugString ("Math needs to review this\n");   \
		DebugBreak();										 \
	} while (0)

#endif



#undef ASSERT
#define ASSERT(exp)\
	if (!(exp)) {										\
		static BOOL Ignore = FALSE;					\
		printf ("ASSERT failed, \"%s\" %s %d\n",	\
				 #exp,								\
				 __FILE__,							\
				 __LINE__);							\
													\
		if (!Ignore) {								\
			DebugBreak();							\
		}											\
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\raid\storlib\tdict.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define POOL_TYPE ULONG

#include "defs.h"
#include "dict.h"


typedef struct _TEST_ENTRY {
    ULONG Unused;
    ULONG Key;
    STOR_DICTIONARY_ENTRY Link;
} TEST_ENTRY, *PTEST_ENTRY;

PVOID
WINAPI
TestGetKey(
    IN PSTOR_DICTIONARY_ENTRY Entry
    )
{
    return (PVOID)(CONTAINING_RECORD (Entry, TEST_ENTRY, Link)->Key);
}

void __cdecl main()
{
    STOR_DICTIONARY Dict;
    PTEST_ENTRY Entry;
    LONG i;
    NTSTATUS Status;
    PSTOR_DICTIONARY_ENTRY Link;

    Status = StorCreateDictionary (&Dict,
                                   1,
                                   0,
                                   TestGetKey,
                                   NULL,
                                   NULL);

    if (!NT_SUCCESS (Status)) {
        printf ("Failed to create dictionary!\n");
        exit (1);
    }

    //
    // Insert 1000 elements, verifying they were successfully
    // inserted.
    //
    
    for (i = 0; i < 1000; i++) {
        Entry = malloc (sizeof (TEST_ENTRY));
        RtlZeroMemory (Entry, sizeof (TEST_ENTRY));

        Entry->Key = i;
        Status = StorInsertDictionary (&Dict, &Entry->Link);
        ASSERT (Status == STATUS_SUCCESS);
        
        Status = StorFindDictionary (&Dict, (PVOID)i, NULL);
        ASSERT (Status == STATUS_SUCCESS);
    }

    //
    // Test that they we cannot insert any more items with the same key.
    //
    
    for (i = 0; i < 1000; i++) {
        Entry = malloc (sizeof (TEST_ENTRY));
        RtlZeroMemory (Entry, sizeof (TEST_ENTRY));

        Entry->Key = i;
        Status = StorInsertDictionary (&Dict, &Entry->Link);

        ASSERT (!NT_SUCCESS (Status));

        free (Entry);
    }

    //
    // Remove all items, one at a time.
    //
    
    for (i = 999; i >= 0; i--) {

        Status = StorRemoveDictionary (&Dict, (PVOID)i, &Link);
        ASSERT (Status == STATUS_SUCCESS);
        Entry = CONTAINING_RECORD (Link, TEST_ENTRY, Link);
        ASSERT (Entry->Key == i);
        free (Entry);
    }

    //
    // Verify that there are no more items.
    //
    
    ASSERT (StorGetDictionaryCount (&Dict) == 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc\asc.h ===
/*++

 Copyright (c) 1994-1998 Advanced System Products, Inc.
 All Rights Reserved.

Module Name:

    asc.h

Abstract:

    This module contains the structures, specific to the Advansys
    host bus adapter, used by the SCSI miniport driver. Data structures
    that are part of standard ANSI SCSI will be defined in a header
    file that will be available to all SCSI device drivers.

--*/


//
// Scatter/Gather Segment List Definitions
//


//
// Adapter limits
//

#define MAX_SG_DESCRIPTORS ASC_MAX_SG_LIST
#define MAX_TRANSFER_SIZE  (MAX_SG_DESCRIPTORS - 1) * 4096


//
// Device extension
//

#define CHIP_CONFIG     ASC_DVC_VAR
#define PCHIP_CONFIG ASC_DVC_VAR *

#define CHIP_INFO       ASC_DVC_CFG
#define PCHIP_INFO      ASC_DVC_CFG *

#define NONCACHED_EXTENSION     256

/*
 * Generalized waiting and active request queuing.
 */

/*
 * Implementation specific definitions.
 *
 * REQ and REQP are the generic name for a SCSI request block and pointer.
 * REQPNEXT(reqp) returns reqp's next pointer.
 * REQPTID(reqp) returns reqp's target id.
 */
typedef SCSI_REQUEST_BLOCK      REQ, *REQP;
#define REQPNEXT(reqp)          ((REQP) SRB2PSCB((SCSI_REQUEST_BLOCK *) (reqp)))
#define REQPTID(reqp)           ((reqp)->TargetId)

/* asc_enqueue() flags */
#define ASC_FRONT               1
#define ASC_BACK                2

typedef struct asc_queue {
  ASC_SCSI_BIT_ID_TYPE  tidmask;              /* queue mask */
  REQP                  queue[ASC_MAX_TID+1]; /* queue linked list */
} asc_queue_t;

void                            asc_enqueue(asc_queue_t *, REQP, int);
REQP                            asc_dequeue(asc_queue_t *, int);
int                             asc_rmqueue(asc_queue_t *, REQP);
void                            asc_execute_queue(asc_queue_t *);


//
// Scatter/Gather Segment Descriptor Definition
//
typedef ASC_SCSI_Q SCB, *PSCB;

typedef struct _SGD {
	ULONG   Length;
	ULONG   Address;
} SGD, *PSGD;

typedef struct _SDL {
   ushort               sg_entry_count;
   ushort               q_count;
   ASC_SG_LIST sg_list[MAX_SG_DESCRIPTORS];
} SDL, *PSDL;

#define SEGMENT_LIST_SIZE         MAX_SG_DESCRIPTORS * sizeof(SGD)

/*
 * Hardware Device Extenstion Definition
 */
typedef struct _HW_DEVICE_EXTENSION {
	CHIP_CONFIG     chipConfig;
	CHIP_INFO       chipInfo;                                        
	PVOID           inquiryBuffer;
	asc_queue_t     waiting;        /* Waiting command queue */
	PSCB            done;           /* Done list for adapter */
} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;

/* Macros for accessing HW Device Extension structure fields. */
#define HDE2CONFIG(hde)         (((PHW_DEVICE_EXTENSION) (hde))->chipConfig)
#define HDE2WAIT(hde)           (((PHW_DEVICE_EXTENSION) (hde))->waiting)
#define HDE2DONE(hde)           (((PHW_DEVICE_EXTENSION) (hde))->done)

//
// SRB Extenstion
//
typedef struct _SRB_EXTENSION {
   SCB                    scb;    /* SCSI command block */
   SDL                    sdl;    /* scatter gather descriptor list */
   PSCB                   pscb;   /* next pointer for scb singly linked list */
   PHW_DEVICE_EXTENSION   dext;   /* device extension pointer */
   int                    retry;  /* retry counter */
} SRB_EXTENSION, *PSRB_EXTENSION;

/* Macros for accessing SRB Extension structure fields. */
#define SRB2SCB(srb)    (((PSRB_EXTENSION) ((srb)->SrbExtension))->scb)
#define SRB2SDL(srb)    (((PSRB_EXTENSION) ((srb)->SrbExtension))->sdl)
#define SRB2PSCB(srb)   (((PSRB_EXTENSION) ((srb)->SrbExtension))->pscb)
#define SRB2HDE(srb)    (((PSRB_EXTENSION) ((srb)->SrbExtension))->dext)
#define SRB2RETRY(srb)  (((PSRB_EXTENSION) ((srb)->SrbExtension))->retry)
#define SCB2SRB(scb)    ((PSCSI_REQUEST_BLOCK) ((scb)->q2.srb_ptr))
/* srb_ptr must be valid to use the following macros */
#define SCB2PSCB(scb)   (SRB2PSCB(SCB2SRB(scb)))
#define SCB2HDE(scb)    (SRB2HDE(SCB2SRB(scb)))

//
// Write retry count
//
#define ASC_RETRY_CNT   4


//
// Starting base IO address for ASC10xx chip
//

#define ASC_BEGIN_IO_ADDR       0x00
#define ASC_NEXT_PORT_INCREMENT 0x10

//
//  PCI Definitions
//
#define ASC_PCI_VENDOR_ID       0x10CD
#define ASC_PCI_DEVICE_ID       0x1100
#define ASC_PCI_DEVICE_ID2      0x1200
#define ASC_PCI_DEVICE_ID3      0x1300

#define PCI_MAX_BUS                             (16)

//
// Port Search structure:
//
typedef struct _SRCH_CONTEXT                    // Port search context
{
	PORT_ADDR                lastPort;      // Last port searched
	ULONG                    PCIBusNo;      // Last PCI Bus searched
	ULONG                    PCIDevNo;      // Last PCI Device searched
} SRCH_CONTEXT, *PSRCH_CONTEXT;


//
// ASC library return status
//
#define ASC_SUCCESS     0


//
// GetChipInfo returned status
//

#define ASC_INIT_FAIL           0x1
#define ASC_ERR_IOP_ROTATE      0x2
#define ASC_ERR_EEP_CHKSUM      0x3
#define ASC_ERR_EEPROM_WRITE    0x4

//
// GetChipInfo returned status
//

#define ASC_PUTQ_BUSY                   0x1
#define ASC_PUTQ_ERR                    0x2

//
// ASC RESET command

#define RESET_BUS       0

//
// Structure containing bus dependant constants
//
typedef struct _BUS_INFO
{
    ushort              BusType;            // Our library bus type
    INTERFACE_TYPE      NTType;             // NT's bus type
    BOOLEAN             DMA32Bit;           // T/F Supports 32 bit dma.
    KINTERRUPT_MODE     IntMode;            // Level or edge triggered.
} BUS_INFO, *PBUS_INFO;

/*
 * Asc Library Definitions
 */
#define ASC_TRUE                1
#define ASC_FALSE               0
#define ASC_NOERROR             1
#define ASC_BUSY                0
#define ASC_ERROR               (-1)

/*
 * Debug/Tracing Macros
 */
#if DBG == 0

#define ASC_DBG(lvl, s)
#define ASC_DBG1(lvl, s, a1)
#define ASC_DBG2(lvl, s, a1, a2)
#define ASC_DBG3(lvl, s, a1, a2, a3)
#define ASC_DBG4(lvl, s, a1, a2, a3, a4)
#define ASC_ASSERT(a)

#else /* DBG */

/*
 * Windows NT Debugging
 *
 * NT Debug Message Levels:
 *  1: Errors Only
 *  2: Information
 *  3: Function Tracing
 *  4: Arcane Information
 */

#define ASC_DBG(lvl, s) \
                    DebugPrint(((lvl), (s)))

#define ASC_DBG1(lvl, s, a1) \
                    DebugPrint(((lvl), (s), (a1)))

#define ASC_DBG2(lvl, s, a1, a2) \
                    DebugPrint(((lvl), (s), (a1), (a2)))

#define ASC_DBG3(lvl, s, a1, a2, a3) \
                    DebugPrint(((lvl), (s), (a1), (a2), (a3)))

#define ASC_DBG4(lvl, s, a1, a2, a3, a4) \
                    DebugPrint(((lvl), (s), (a1), (a2), (a3), (a4)))

#define ASC_ASSERT(a) \
    { \
        if (!(a)) { \
            DebugPrint((1, "ASC_ASSERT() Failure: file %s, line %d\n", \
                __FILE__, __LINE__)); \
        } \
    }
#endif /* DBG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc\asc.c ===
/*++

 Copyright (c) 1994-1998 Advanced System Products, Inc.
 All Rights Reserved.

Module Name:

    asc.c

Abstract:

    This is the port driver for the Advansys SCSI Protocol Chips.

Environment:

    kernel mode only

Notes:
    This file is formatted with 4-space tab stops. If you want to
    print without tabs filter them out.

--*/

#include "miniport.h"                   // NT requires
#include "scsi.h"                       // NT requires

#include "a_ddinc.h"                    // Asc Library requires
#include "asclib.h"
#include "asc.h"                        // ASC NT driver specific

PortAddr _asc_def_iop_base[ ASC_IOADR_TABLE_MAX_IX ] = {
  0x100, ASC_IOADR_1, 0x120, ASC_IOADR_2, 0x140, ASC_IOADR_3, ASC_IOADR_4,
  ASC_IOADR_5, ASC_IOADR_6, ASC_IOADR_7, ASC_IOADR_8
} ;

//
// Vendor and Device IDs.
//
UCHAR VenID[4] = {'1', '0', 'C', 'D'};
UCHAR DevID[1] = {'1'};

//
// Function declarations
//

ULONG HwFindAdapterISA(
    IN PVOID HwDeviceExtension,
    IN PVOID Context,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN Again
    );

ULONG HwFindAdapterVL(
    IN PVOID HwDeviceExtension,
    IN PVOID Context,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN Again
    );

ULONG HwFindAdapterEISA(
    IN PVOID HwDeviceExtension,
    IN PVOID Context,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN Again
    );

ULONG HwFindAdapterPCI(
    IN PVOID HwDeviceExtension,
    IN PVOID Context,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN Again
    );

ULONG FoundPCI(
    IN PVOID HwDeviceExtension,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN Again
    );

BOOLEAN HwInitialize(
    IN PVOID HwDeviceExtension
    );

BOOLEAN HwStartIo(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

BOOLEAN HwInterrupt(
    IN PVOID HwDeviceExtension
    );

BOOLEAN HwResetBus(
    IN PVOID HwDeviceExtension,
    IN ULONG PathId
    );

SCSI_ADAPTER_CONTROL_STATUS HwAdapterControl(
    IN PVOID HwDeviceExtension,
    IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
        IN PVOID Paramters
    );

VOID BuildScb(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

int
AscExecuteIO(
    IN PSCSI_REQUEST_BLOCK srb
    );

VOID DvcISRCallBack(
    IN PCHIP_CONFIG chipConfig,
    IN ASC_QDONE_INFO *scbDoneInfo
    );

UCHAR ErrXlate (
    UCHAR ascErrCode
    );

PortAddr HwSearchIOPortAddr(
    PortAddr iop_beg,
    ushort bus_type,
    IN PVOID HwDE,
    IN OUT PPORT_CONFIGURATION_INFORMATION Cfg
    );

ULONG PCIGetBusData(
    IN PVOID DeviceExtension,
    IN ULONG SystemIoBusNumber,
    IN PCI_SLOT_NUMBER SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    );

void
AscCompleteRequest(
    IN PVOID HwDeviceExtension
    );

VOID AscZeroMemory(IN UCHAR *cp, IN ULONG length);

//======================================================================
//
// All procedures start here
//
//======================================================================

/*++

Routine Description:

    Installable driver initialization entry point for system.

Arguments:

    Driver Object

Return Value:

    Status from ScsiPortInitialize()

--*/

ULONG
DriverEntry(
    IN PVOID DriverObject,
    IN PVOID Argument2
    )
{
    HW_INITIALIZATION_DATA      hwInitializationData;
    SRCH_CONTEXT                srchContext;
    ULONG                       Status = 0xFFFFFFFFL;
    ULONG                       tStatus;

    ASC_DBG(2, "Asc: DriverEntry: begin\n");

    //
    // Zero out structure.
    //
    AscZeroMemory((PUCHAR) &hwInitializationData,
        sizeof(HW_INITIALIZATION_DATA));

    //
    // Set size of hwInitializationData.
    //
    hwInitializationData.HwInitializationDataSize =
        sizeof(HW_INITIALIZATION_DATA);

    //
    // Set entry points.
    //
    hwInitializationData.HwInitialize = HwInitialize;
    hwInitializationData.HwResetBus = HwResetBus;
    hwInitializationData.HwStartIo = HwStartIo;
    hwInitializationData.HwInterrupt = HwInterrupt;
    // 'HwAdapterControl' is a SCSI miniport interface added with NT 5.0.
    hwInitializationData.HwAdapterControl = HwAdapterControl;

    //
    // Indicate need buffer mapping and physical addresses.
    //
    hwInitializationData.NeedPhysicalAddresses = TRUE;
    hwInitializationData.MapBuffers = TRUE;
    hwInitializationData.AutoRequestSense = TRUE;

    //
    // Specify size of extensions.
    //
    hwInitializationData.DeviceExtensionSize = sizeof(HW_DEVICE_EXTENSION);
    hwInitializationData.SpecificLuExtensionSize = 0;
    hwInitializationData.NumberOfAccessRanges = 1;
    hwInitializationData.SrbExtensionSize = sizeof(SRB_EXTENSION);


    //
    // Search for ISA
    //
    srchContext.lastPort = 0;
    hwInitializationData.AdapterInterfaceType = Isa;
    hwInitializationData.HwFindAdapter = HwFindAdapterISA;
    Status = ScsiPortInitialize(DriverObject, Argument2,
                (PHW_INITIALIZATION_DATA) &hwInitializationData, &srchContext);

    //
    // Search for VL
    //
    srchContext.lastPort = 0;
    hwInitializationData.AdapterInterfaceType = Isa;
    hwInitializationData.HwFindAdapter = HwFindAdapterVL;
    tStatus = ScsiPortInitialize(DriverObject, Argument2,
                (PHW_INITIALIZATION_DATA) &hwInitializationData, &srchContext);
    if (tStatus < Status)
    {
        Status = tStatus;
    }

    //
    // Search for EISA
    //
    srchContext.lastPort = 0;
    hwInitializationData.AdapterInterfaceType = Eisa;
    hwInitializationData.HwFindAdapter = HwFindAdapterEISA;
    tStatus = ScsiPortInitialize(DriverObject, Argument2,
                (PHW_INITIALIZATION_DATA) &hwInitializationData, &srchContext);
    if (tStatus < Status)
    {
        Status = tStatus;
    }

    //
    // Search for PCI
    //
    srchContext.PCIBusNo = 0;
    srchContext.PCIDevNo = 0;

    hwInitializationData.VendorIdLength = 4;
    hwInitializationData.VendorId = VenID;
    hwInitializationData.DeviceIdLength = 1;
    hwInitializationData.DeviceId = DevID;

    hwInitializationData.AdapterInterfaceType = PCIBus;
    hwInitializationData.HwFindAdapter = HwFindAdapterPCI;
    tStatus = ScsiPortInitialize(DriverObject, Argument2,
                (PHW_INITIALIZATION_DATA) &hwInitializationData, &srchContext);
    if (tStatus < Status)
    {
        Status = tStatus;
    }

    ASC_DBG1(2, "Asc: DriverEntry: Status %d\n", Status);
    //
    // Return the status.
    //
    return( Status );

} // end DriverEntry()

/*++

Routine Description:

    This function is called by the OS-specific port driver after
    the necessary storage has been allocated, to gather information
    about the adapter's configuration.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Context - Register base address
    ConfigInfo - Configuration information structure describing HBA
    This structure is defined in PORT.H.

Return Value:

    ULONG

--*/

ULONG
HwFindAdapterISA(
    IN PVOID HwDeviceExtension,
    IN PVOID Context,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN Again
    )
{
    PORT_ADDR               portFound;
    PSRCH_CONTEXT           psrchContext = Context;
    PHW_DEVICE_EXTENSION    deviceExtension = HwDeviceExtension;
    PCHIP_CONFIG            chipConfig = &deviceExtension->chipConfig;
    USHORT                  initstat;

    ASC_DBG1(2, "HwFindAdapterISA: NumberOfAccessRanges = %d\n",
        ConfigInfo->NumberOfAccessRanges);
    ASC_DBG1(2, "HwFindAdapterISA: RangeStart = %x\n",
        (*ConfigInfo->AccessRanges)[0].RangeStart.QuadPart);
    ASC_DBG1(2, "HwFindAdapterISA: RangeLength = %d\n",
        (*ConfigInfo->AccessRanges)[0].RangeLength);

    if ((*ConfigInfo->AccessRanges)[0].RangeStart.QuadPart != 0)
    {
        //
        // Get the system physical address for this card.
        // The card uses I/O space.
        //
        portFound = (PORT_ADDR) ScsiPortGetDeviceBase(
            HwDeviceExtension,                      // HwDeviceExtension
            ConfigInfo->AdapterInterfaceType,       // AdapterInterfaceType
            ConfigInfo->SystemIoBusNumber,          // SystemIoBusNumber
            (*ConfigInfo->AccessRanges)[0].RangeStart,
            0x10,                                   // NumberOfBytes
            TRUE                                    // InIoSpace
            );
    } else
    {
        *Again = FALSE;

        //
        // Scan though the adapter addresses looking for adapters.
        //
        portFound = psrchContext->lastPort;
        if ((portFound = HwSearchIOPortAddr(portFound, ASC_IS_ISA,
                HwDeviceExtension, ConfigInfo )) == 0)
        {
            return(SP_RETURN_NOT_FOUND);
        }
        psrchContext->lastPort = portFound;

        //
        // Get the system physical address for this card.
        // The card uses I/O space.
        //
        portFound = (PORT_ADDR) ScsiPortGetDeviceBase(
            HwDeviceExtension,                      // HwDeviceExtension
            ConfigInfo->AdapterInterfaceType,       // AdapterInterfaceType
            ConfigInfo->SystemIoBusNumber,          // SystemIoBusNumber
            ScsiPortConvertUlongToPhysicalAddress(portFound),
            0x10,                                   // NumberOfBytes
            TRUE                                    // InIoSpace
            );

        (*ConfigInfo->AccessRanges)[0].RangeStart =
            ScsiPortConvertUlongToPhysicalAddress(portFound);
    }


    //
    // Hardware found; Get the hardware configuration.
    //
    chipConfig->iop_base = portFound;
    chipConfig->cfg = &deviceExtension->chipInfo;
    chipConfig->bus_type = ASC_IS_ISA;
    chipConfig->isr_callback = (Ptr2Func) &DvcISRCallBack;
    chipConfig->exe_callback = 0;
    chipConfig->max_dma_count = 0x000fffff;

    if ((initstat = AscInitGetConfig(chipConfig)) != 0) {
        ASC_DBG1(1, "AscInitGetConfig: warning code %x\n", initstat);
    }

    if (chipConfig->err_code != 0) {
        ASC_DBG1(1, "AscInitGetConfig: err_code code %x\n",
            chipConfig->err_code);
        return(SP_RETURN_ERROR);
    } else {
        ASC_DBG(2, "AscInitGetConfig: successful\n");
    }

    if ((initstat = AscInitSetConfig(chipConfig)) != 0) {
        ASC_DBG1(1, "AscInitSetConfig: warning code %x\n", initstat);
    }

    if (chipConfig->err_code != 0) {
        ASC_DBG1(1, "AscInitSetConfig: err_code code %x\n",
            chipConfig->err_code);
        return(SP_RETURN_ERROR);
    } else {
        ASC_DBG(2, "AscInitSetConfig: successful\n");
    }

    //
    // Fill out ConfigInfo table for WinNT
    //
    (*ConfigInfo->AccessRanges)[0].RangeLength = 16;
    (*ConfigInfo->AccessRanges)[0].RangeInMemory = FALSE;

    ConfigInfo->BusInterruptLevel = chipConfig->irq_no;
    ConfigInfo->NumberOfBuses = 1;
    ConfigInfo->InitiatorBusId[0] = chipConfig->cfg->chip_scsi_id;
    ConfigInfo->MaximumTransferLength = 0x000fffff;
    //
    // 'ResetTargetSupported' is flag added with NT 5.0 that will
    // result in SRB_FUNCTION_RESET_DEVICE SRB requests being sent
    // to the miniport driver.
    //
    ConfigInfo->ResetTargetSupported = TRUE;

    /*
     * Change NumberOfPhysicalBreaks to maximum scatter-gather
     * elements - 1 the adapter can handle based on the BIOS
     * "Host Queue Size" setting.
     *
     * According to the NT DDK miniport drivers are not supposed to
     * change NumberOfPhysicalBreaks if its value on entry is not
     * SP_UNINITIALIZED_VALUE. But AdvanSys has found that performance
     * can be improved by increasing the value to the maximum the
     * adapter can handle.
     *
     * Note: The definition of NumberOfPhysicalBreaks is "maximum
     * scatter-gather elements - 1". NT is broken in that it sets
     * MaximumPhysicalPages, the value class drivers use, to the
     * same value as NumberOfPhysicalBreaks.
     *
     */
    ConfigInfo->NumberOfPhysicalBreaks =
        (((chipConfig->max_total_qng - 2) / 2) * ASC_SG_LIST_PER_Q);
    if (ConfigInfo->NumberOfPhysicalBreaks > ASC_MAX_SG_LIST - 1) {
        ConfigInfo->NumberOfPhysicalBreaks = ASC_MAX_SG_LIST - 1;
    }

    ConfigInfo->ScatterGather = TRUE;
    ConfigInfo->Master = TRUE;
    ConfigInfo->NeedPhysicalAddresses = TRUE;
    ConfigInfo->Dma32BitAddresses = FALSE;
    ConfigInfo->InterruptMode = Latched;
    ConfigInfo->AdapterInterfaceType = Isa;
    ConfigInfo->AlignmentMask = 3;
    ConfigInfo->MaximumNumberOfTargets = 7;
    ConfigInfo->DmaChannel = chipConfig->cfg->isa_dma_channel;
    ConfigInfo->TaggedQueuing = TRUE;

    /*
     * Clear adapter wait queue.
     */
    AscZeroMemory((PUCHAR) &HDE2WAIT(deviceExtension), sizeof(asc_queue_t));
    HDE2DONE(deviceExtension) = 0;

    //
    // Allocate a Noncached Extension to use for overrun handling.
    //
    deviceExtension->inquiryBuffer = (PVOID) ScsiPortGetUncachedExtension(
            deviceExtension,
            ConfigInfo,
            NONCACHED_EXTENSION);

    *Again = TRUE;

    ASC_DBG1(2, "HwFindAdapterISA: IO Base addr %x\n",
        chipConfig->iop_base);
    ASC_DBG1(2, "HwFindAdapterISA: Int Level    %x\n",
        ConfigInfo->BusInterruptLevel);
    ASC_DBG1(2, "HwFindAdapterISA: Initiator ID %x\n",
        ConfigInfo->InitiatorBusId[0]);
    ASC_DBG(2, "HwFindAdapterISA(): SP_RETURN_FOUND\n");
    return SP_RETURN_FOUND;
} // end HwFindAdapterISA()

ULONG
HwFindAdapterVL(
    IN PVOID HwDeviceExtension,
    IN PVOID Context,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN Again
    )
{
    PORT_ADDR               portFound;
    PSRCH_CONTEXT           psrchContext = Context;
    PHW_DEVICE_EXTENSION    deviceExtension = HwDeviceExtension;
    PCHIP_CONFIG            chipConfig = &deviceExtension->chipConfig;
    USHORT                  initstat;

    ASC_DBG1(2, "HwFindAdapterVL: NumberOfAccessRanges = %d\n",
        ConfigInfo->NumberOfAccessRanges);
    ASC_DBG1(2, "HwFindAdapterVL: RangeStart = %x\n",
        (*ConfigInfo->AccessRanges)[0].RangeStart.QuadPart);
    ASC_DBG1(2, "HwFindAdapterVL: RangeLength = %d\n",
        (*ConfigInfo->AccessRanges)[0].RangeLength);


    if ((*ConfigInfo->AccessRanges)[0].RangeStart.QuadPart != 0)
    {
        //
        // Get the system physical address for this card.
        // The card uses I/O space.
        //
        portFound = (PORT_ADDR) ScsiPortGetDeviceBase(
            HwDeviceExtension,                      // HwDeviceExtension
            ConfigInfo->AdapterInterfaceType,       // AdapterInterfaceType
            ConfigInfo->SystemIoBusNumber,          // SystemIoBusNumber
            (*ConfigInfo->AccessRanges)[0].RangeStart,
            0x10,                                   // NumberOfBytes
            TRUE                                    // InIoSpace
            );

    } else
    {
        *Again = FALSE;

        //
        // Scan though the adapter addresses looking for adapters.
        //
        portFound = psrchContext->lastPort;
        if ((portFound = HwSearchIOPortAddr(portFound, ASC_IS_VL,
            HwDeviceExtension, ConfigInfo )) == 0)
        {
            return(SP_RETURN_NOT_FOUND);
        }
        psrchContext->lastPort = portFound;

        //
        // Get the system physical address for this card.
        // The card uses I/O space.
        //
        portFound = (PORT_ADDR) ScsiPortGetDeviceBase(
            HwDeviceExtension,                      // HwDeviceExtension
            ConfigInfo->AdapterInterfaceType,       // AdapterInterfaceType
            ConfigInfo->SystemIoBusNumber,          // SystemIoBusNumber
            ScsiPortConvertUlongToPhysicalAddress(portFound),
            0x10,                                   // NumberOfBytes
            TRUE                                    // InIoSpace
            );

        (*ConfigInfo->AccessRanges)[0].RangeStart =
            ScsiPortConvertUlongToPhysicalAddress(portFound);
    }

    //
    // Hardware found; Get the hardware configuration.
    //
    chipConfig->iop_base = portFound;
    chipConfig->cfg = &(deviceExtension->chipInfo);
    chipConfig->bus_type = ASC_IS_VL;
    chipConfig->isr_callback = (Ptr2Func) &DvcISRCallBack;
    chipConfig->exe_callback = 0;
    chipConfig->max_dma_count = 0xffffffff;

    if ((initstat = AscInitGetConfig(chipConfig)) != 0) {
        ASC_DBG1(1, "AscInitGetConfig: warning code %x\n", initstat);
    }

    if (chipConfig->err_code != 0) {
        ASC_DBG1(1, "AscInitGetConfig: err_code code %x\n",
            chipConfig->err_code);
        return(SP_RETURN_ERROR);
    } else {
        ASC_DBG(2, "AscInitGetConfig: successful\n");
    }

    if ((initstat = AscInitSetConfig(chipConfig)) != 0) {
        ASC_DBG1(1, "AscInitSetConfig: warning code %x\n", initstat);
    }

    if (chipConfig->err_code != 0) {
        ASC_DBG1(1, "AscInitSetConfig: err_code code %x\n",
            chipConfig->err_code);
        return(SP_RETURN_ERROR);
    } else {
        ASC_DBG(2, "AscInitSetConfig: successful\n");
    }

    //
    // Fill out ConfigInfo table for WinNT
    //
    (*ConfigInfo->AccessRanges)[0].RangeLength = 16;
    (*ConfigInfo->AccessRanges)[0].RangeInMemory = FALSE;

    ConfigInfo->BusInterruptLevel = chipConfig->irq_no;
    ConfigInfo->NumberOfBuses = 1;
    ConfigInfo->InitiatorBusId[0] = chipConfig->cfg->chip_scsi_id;
    ConfigInfo->MaximumTransferLength = 0xFFFFFFFF;

    /*
     * Change NumberOfPhysicalBreaks to maximum scatter-gather
     * elements - 1 the adapter can handle based on the BIOS
     * "Host Queue Size" setting.
     *
     * According to the NT DDK miniport drivers are not supposed to
     * change NumberOfPhysicalBreaks if its value on entry is not
     * SP_UNINITIALIZED_VALUE. But AdvanSys has found that performance
     * can be improved by increasing the value to the maximum the
     * adapter can handle.
     *
     * Note: The definition of NumberOfPhysicalBreaks is "maximum
     * scatter-gather elements - 1". NT is broken in that it sets
     * MaximumPhysicalPages, the value class drivers use, to the
     * same value as NumberOfPhysicalBreaks.
     *
     */
    ConfigInfo->NumberOfPhysicalBreaks =
        (((chipConfig->max_total_qng - 2) / 2) * ASC_SG_LIST_PER_Q);
    if (ConfigInfo->NumberOfPhysicalBreaks > ASC_MAX_SG_LIST - 1) {
        ConfigInfo->NumberOfPhysicalBreaks = ASC_MAX_SG_LIST - 1;
    }

    ConfigInfo->ScatterGather = TRUE;
    ConfigInfo->Master = TRUE;
    ConfigInfo->NeedPhysicalAddresses = TRUE;
    ConfigInfo->Dma32BitAddresses = FALSE;
    ConfigInfo->InterruptMode = Latched;
    ConfigInfo->AdapterInterfaceType = Isa;
    ConfigInfo->AlignmentMask = 3;
    ConfigInfo->BufferAccessScsiPortControlled = TRUE;
    ConfigInfo->MaximumNumberOfTargets = 7;
    ConfigInfo->TaggedQueuing = TRUE;

    /*
     * Clear adapter wait queue.
     */
    AscZeroMemory((PUCHAR) &HDE2WAIT(deviceExtension), sizeof(asc_queue_t));

    //
    // Allocate a Noncached Extension to use for overrun handling.
    //
    deviceExtension->inquiryBuffer = (PVOID) ScsiPortGetUncachedExtension(
            deviceExtension,
            ConfigInfo,
            NONCACHED_EXTENSION);

    *Again = TRUE;

    ASC_DBG1(2, "HwFindAdapterVL: IO Base addr %x\n",
        chipConfig->iop_base);
    ASC_DBG1(2, "HwFindAdapterVL: Int Level    %x\n",
        ConfigInfo->BusInterruptLevel);
    ASC_DBG1(2, "HwFindAdapterVL: Initiator ID %x\n",
        ConfigInfo->InitiatorBusId[0]);
    ASC_DBG(2, "HwFindAdapterVL: SP_RETURN_FOUND\n");
    return SP_RETURN_FOUND;
} // end HwFindAdapterVL()

ULONG
HwFindAdapterEISA(
    IN PVOID HwDeviceExtension,
    IN PVOID Context,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN Again
    )
{
    PORT_ADDR               portFound;
    PORT_ADDR               eisaportaddr;
    PVOID                   eisacfgbase;
    PSRCH_CONTEXT           psrchContext = Context;
    PHW_DEVICE_EXTENSION    deviceExtension = HwDeviceExtension;
    PCHIP_CONFIG            chipConfig = &(deviceExtension->chipConfig);
    USHORT                  initstat;
    uchar                   eisairq;

    ASC_DBG1(2, "HwFindAdapterEISA: NumberOfAccessRanges = %d\n",
        ConfigInfo->NumberOfAccessRanges);
    ASC_DBG1(2, "HwFindAdapterEISA: RangeStart = %x\n",
        (*ConfigInfo->AccessRanges)[0].RangeStart.QuadPart);
    ASC_DBG1(2, "HwFindAdapterEISA: RangeLength = %d\n",
        (*ConfigInfo->AccessRanges)[0].RangeLength);

    if ((*ConfigInfo->AccessRanges)[0].RangeStart.QuadPart != 0)
    {
        //
        // Get the system physical address for this card.
        // The card uses I/O space.
        //
        portFound = (PORT_ADDR) ScsiPortGetDeviceBase(
            HwDeviceExtension,                      // HwDeviceExtension
            ConfigInfo->AdapterInterfaceType,       // AdapterInterfaceType
            ConfigInfo->SystemIoBusNumber,          // SystemIoBusNumber
            (*ConfigInfo->AccessRanges)[0].RangeStart,
            0x10,                                   // NumberOfBytes
            TRUE                                    // InIoSpace
            );

        // Save EISA address to obtain IRQ later.
        eisaportaddr =
                ScsiPortConvertPhysicalAddressToUlong(
                 (*ConfigInfo->AccessRanges)[0].RangeStart);
    } else
    {
        *Again = FALSE;

        //
        // Scan though the adapter addresses looking for adapters.
        //
        portFound = psrchContext->lastPort;
        if ((portFound = HwSearchIOPortAddr(portFound, ASC_IS_EISA,
                HwDeviceExtension, ConfigInfo )) == 0)
        {
            return(SP_RETURN_NOT_FOUND);
        }
        psrchContext->lastPort = portFound;

        // Save EISA address to obtain IRQ later.
        eisaportaddr = portFound;

        //
        // Get the system physical address for this card.
        // The card uses I/O space.
        //
        portFound = (PORT_ADDR) ScsiPortGetDeviceBase(
            HwDeviceExtension,                      // HwDeviceExtension
            ConfigInfo->AdapterInterfaceType,       // AdapterInterfaceType
            ConfigInfo->SystemIoBusNumber,          // SystemIoBusNumber
            ScsiPortConvertUlongToPhysicalAddress(portFound),
            0x10,                                   // NumberOfBytes
            TRUE                                    // InIoSpace
            );

        (*ConfigInfo->AccessRanges)[0].RangeStart =
            ScsiPortConvertUlongToPhysicalAddress(portFound);
    }

    //
    // Hardware found; Get the hardware configuration.
    //
    chipConfig->iop_base = portFound;
    chipConfig->cfg = &(deviceExtension->chipInfo);
    chipConfig->bus_type = ASC_IS_EISA;
    chipConfig->isr_callback = (Ptr2Func) &DvcISRCallBack;
    chipConfig->exe_callback = 0;
    chipConfig->max_dma_count = 0x00ffffff;

    if ((initstat = AscInitGetConfig(chipConfig)) != 0) {
        ASC_DBG1(1, "AscInitGetConfig: warning code %x\n", initstat);
    }

    if (chipConfig->err_code != 0) {
        ASC_DBG1(1, "AscInitGetConfig: err_code code %x\n",
            chipConfig->err_code);
        return(SP_RETURN_ERROR);
    } else {
        ASC_DBG(2, "AscInitGetConfig: successful\n");
    }

    /*
     * Read the chip's IRQ from the chip EISA slot configuration space.
     */
    eisacfgbase = ScsiPortGetDeviceBase(
        HwDeviceExtension,                      // HwDeviceExtension
        ConfigInfo->AdapterInterfaceType,       // AdapterInterfaceType
        ConfigInfo->SystemIoBusNumber,          // SystemIoBusNumber
        ScsiPortConvertUlongToPhysicalAddress(
           (ASC_GET_EISA_SLOT(eisaportaddr) | ASC_EISA_CFG_IOP_MASK)),
        2,
        TRUE);

    if (eisacfgbase == NULL)
    {
        eisairq = 0;
    } else
    {
        eisairq = (uchar) (((inpw(eisacfgbase) >> 8) & 0x07) + 10);
        if ((eisairq == 13) || (eisairq > 15))
        {
            /*
             * Valid IRQ numbers are 10, 11, 12, 14, 15.
             */
            eisairq = 0;
        }
        ScsiPortFreeDeviceBase(HwDeviceExtension, eisacfgbase);
    }
    chipConfig->irq_no = eisairq;

    if ((initstat = AscInitSetConfig (chipConfig)) != 0) {
        ASC_DBG1(1, "AscInitSetConfig: warning code %x\n", initstat);
    }

    if (chipConfig->err_code != 0) {
        ASC_DBG1(1, "AscInitSetConfig: err_code code %x\n",
            chipConfig->err_code);
        return(SP_RETURN_ERROR);
    } else {
        ASC_DBG(2, "AscInitSetConfig: successful\n");
    }

    //
    // Fill out ConfigInfo table for WinNT
    //
    (*ConfigInfo->AccessRanges)[0].RangeLength = 16;
    (*ConfigInfo->AccessRanges)[0].RangeInMemory = FALSE;

    ConfigInfo->BusInterruptLevel = chipConfig->irq_no;
    ConfigInfo->NumberOfBuses = 1;
    ConfigInfo->InitiatorBusId[0] = chipConfig->cfg->chip_scsi_id;
    ConfigInfo->MaximumTransferLength = 0xFFFFFFFF;

    /*
     * Change NumberOfPhysicalBreaks to maximum scatter-gather
     * elements - 1 the adapter can handle based on the BIOS
     * "Host Queue Size" setting.
     *
     * According to the NT DDK miniport drivers are not supposed to
     * change NumberOfPhysicalBreaks if its value on entry is not
     * SP_UNINITIALIZED_VALUE. But AdvanSys has found that performance
     * can be improved by increasing the value to the maximum the
     * adapter can handle.
     *
     * Note: The definition of NumberOfPhysicalBreaks is "maximum
     * scatter-gather elements - 1". NT is broken in that it sets
     * MaximumPhysicalPages, the value class drivers use, to the
     * same value as NumberOfPhysicalBreaks.
     *
     */
    ConfigInfo->NumberOfPhysicalBreaks =
        (((chipConfig->max_total_qng - 2) / 2) * ASC_SG_LIST_PER_Q);
    if (ConfigInfo->NumberOfPhysicalBreaks > ASC_MAX_SG_LIST - 1) {
        ConfigInfo->NumberOfPhysicalBreaks = ASC_MAX_SG_LIST - 1;
    }

    ConfigInfo->ScatterGather = TRUE;
    ConfigInfo->Master = TRUE;
    ConfigInfo->NeedPhysicalAddresses = TRUE;
    ConfigInfo->Dma32BitAddresses = FALSE;
    ConfigInfo->InterruptMode = LevelSensitive;
    ConfigInfo->AdapterInterfaceType = Eisa;
    ConfigInfo->AlignmentMask = 3;
    ConfigInfo->BufferAccessScsiPortControlled = TRUE;
    ConfigInfo->MaximumNumberOfTargets = 7;
    ConfigInfo->TaggedQueuing = TRUE;

    /*
     * Clear adapter wait queue.
     */
    AscZeroMemory((PUCHAR) &HDE2WAIT(deviceExtension), sizeof(asc_queue_t));

    //
    // Allocate a Noncached Extension to use for overrun handling.
    //
    deviceExtension->inquiryBuffer = (PVOID) ScsiPortGetUncachedExtension(
            deviceExtension,
            ConfigInfo,
            NONCACHED_EXTENSION);

    *Again = TRUE;

    ASC_DBG1(2, "HwFindAdapterEISA: IO Base addr %x\n",
        chipConfig->iop_base);
    ASC_DBG1(2, "HwFindAdapterEISA: Int Level    %x\n",
        ConfigInfo->BusInterruptLevel);
    ASC_DBG1(2, "HwFindAdapterEISA: Initiator ID %x\n",
        ConfigInfo->InitiatorBusId[0]);
    ASC_DBG(2, "HwFindAdapterEISA(): SP_RETURN_FOUND\n");
    return SP_RETURN_FOUND;
} // end HwFindAdapterEISA()

ULONG
HwFindAdapterPCI(
    IN PVOID HwDeviceExtension,
    IN PVOID Context,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN Again
    )
{
    ASC_DBG1(2, "HwFindAdapterPCI: NumberOfAccessRanges = %d\n",
        ConfigInfo->NumberOfAccessRanges);
    ASC_DBG1(2, "HwFindAdapterPCI: RangeStart = %x\n",
        (*ConfigInfo->AccessRanges)[0].RangeStart.QuadPart);
    ASC_DBG1(2, "HwFindAdapterPCI: RangeLength = %d\n",
        (*ConfigInfo->AccessRanges)[0].RangeLength);

    //
    // If NT provides an address, use it.
    //
    if ((*ConfigInfo->AccessRanges)[0].RangeStart.QuadPart != 0)
    {
        return FoundPCI(HwDeviceExtension, BusInformation,
            ArgumentString, ConfigInfo, Again);
    }
    *Again = FALSE;
    return(SP_RETURN_NOT_FOUND);
} // end HwFindAdapterPCI()

//
//
// This routine handles PCI adapters that are found by NT.
//
//
ULONG
FoundPCI(
    IN PVOID HwDeviceExtension,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN Again
    )
{
    PORT_ADDR               portFound;
    PHW_DEVICE_EXTENSION    deviceExtension = HwDeviceExtension;
    PCHIP_CONFIG            chipConfig = &(deviceExtension->chipConfig);
    USHORT                  initstat;
    PCI_SLOT_NUMBER         SlotNumber;
    PCI_COMMON_CONFIG       pciCommonConfig;
    PCI_COMMON_CONFIG       *pPciCommonConfig = &pciCommonConfig;
    ULONG                   size;

    ASC_DBG(2, "FoundPCI: begin\n");

    SlotNumber.u.AsULONG = 0L;
    SlotNumber.u.bits.DeviceNumber = ConfigInfo->SlotNumber;

    ASC_DBG2(3, "FoundPCI: Checking Bus: %X, Device: %X\n",
        ConfigInfo->SystemIoBusNumber,
        ConfigInfo->SlotNumber);

    if ((size = PCIGetBusData(
            HwDeviceExtension,              // HwDeviceExtension
            ConfigInfo->SystemIoBusNumber,  // SystemIoBusNumber
            SlotNumber,                     // slot number
            pPciCommonConfig,               // buffer pointer with PCI INFO
            sizeof(PCI_COMMON_CONFIG)       // length of buffer
            )) != sizeof(PCI_COMMON_CONFIG)) {
        ASC_DBG1(0, "FoundPCI: Bad PCI Config size: %d\n", size);
        return(SP_RETURN_NOT_FOUND);
    }

    if (((pciCommonConfig.DeviceID != ASC_PCI_DEVICE_ID) &&
         (pciCommonConfig.DeviceID != ASC_PCI_DEVICE_ID2) &&
         (pciCommonConfig.DeviceID != ASC_PCI_DEVICE_ID3)) ||
        (pciCommonConfig.VendorID != ASC_PCI_VENDOR_ID))
    {
        ASC_DBG(1, "FoundPCI: Bad Vendor/Device ID\n");
        return(SP_RETURN_NOT_FOUND);
    }

    portFound =
        (PORT_ADDR)pciCommonConfig.u.type0.BaseAddresses[0] &
        (~PCI_ADDRESS_IO_SPACE);

    if (ScsiPortConvertUlongToPhysicalAddress(portFound).QuadPart
        != (*ConfigInfo->AccessRanges)[0].RangeStart.QuadPart)
    {
        ASC_DBG(1, "FoundPCI: PCI Config addr .NE. RangeStart!\n");
        return(SP_RETURN_NOT_FOUND);
    }

    //
    // Convert to logical base address so we can do IO.
    //
    portFound = (PORT_ADDR) ScsiPortGetDeviceBase(
        HwDeviceExtension,                      // HwDeviceExtension
        ConfigInfo->AdapterInterfaceType,       // AdapterInterfaceType
        ConfigInfo->SystemIoBusNumber,          // SystemIoBusNumber
        (*ConfigInfo->AccessRanges)[0].RangeStart,
        (*ConfigInfo->AccessRanges)[0].RangeLength,
        (BOOLEAN)!(*ConfigInfo->AccessRanges)[0].RangeInMemory);

    if (ConfigInfo->BusInterruptLevel != pciCommonConfig.u.type0.InterruptLine)
    {
        ASC_DBG2(2, "FoundPCI: IRQ Variance ConfigInfo: %X, pciConfig: %X\n",
                ConfigInfo->BusInterruptLevel,
                pciCommonConfig.u.type0.InterruptLine);
    }
    ASC_DBG(2, "FoundPCI: IRQs match\n");

    //
    // Hardware found; Get the hardware configuration.
    //
    chipConfig->iop_base = portFound;
    chipConfig->cfg = &(deviceExtension->chipInfo);
    chipConfig->bus_type = ASC_IS_PCI;
    chipConfig->cfg->pci_device_id = pciCommonConfig.DeviceID;
    chipConfig->isr_callback = (Ptr2Func) &DvcISRCallBack;
    chipConfig->exe_callback = 0;
    chipConfig->max_dma_count = 0xffffffff;
    chipConfig->irq_no = (UCHAR) ConfigInfo->BusInterruptLevel;
    chipConfig->cfg->pci_slot_info =
         (USHORT) ASC_PCI_MKID(ConfigInfo->SystemIoBusNumber,
                    SlotNumber.u.bits.DeviceNumber,
                    SlotNumber.u.bits.FunctionNumber);

    if ((initstat = AscInitGetConfig(chipConfig)) != 0) {
        ASC_DBG1(1, "AscInitGetConfig: warning code %x\n", initstat);
    }

    if (chipConfig->err_code != 0) {
        ASC_DBG1(1, "AscInitGetConfig: err_code code %x\n",
            chipConfig->err_code);
        return(SP_RETURN_ERROR);
    } else {
        ASC_DBG(2, "AscInitGetConfig: successful\n");
    }

    if ((initstat = AscInitSetConfig(chipConfig)) != 0) {
        ASC_DBG1(1, "AscInitSetConfig: warning code %x\n", initstat);
    }

    if (chipConfig->err_code != 0) {
        ASC_DBG1(1, "AscInitSetConfig: err_code code %x\n",
            chipConfig->err_code);
        return(SP_RETURN_ERROR);
    } else {
        ASC_DBG(2, "AscInitSetConfig: successful\n");
    }

    //
    // Fill out ConfigInfo table for WinNT
    //
    (*ConfigInfo->AccessRanges)[0].RangeLength = 16;
    ConfigInfo->NumberOfBuses = 1;
    ConfigInfo->InitiatorBusId[0] = chipConfig->cfg->chip_scsi_id;
    ConfigInfo->MaximumTransferLength = 0xFFFFFFFF;

    /*
     * Change NumberOfPhysicalBreaks to maximum scatter-gather
     * elements - 1 the adapter can handle based on the BIOS
     * "Host Queue Size" setting.
     *
     * According to the NT DDK miniport drivers are not supposed to
     * change NumberOfPhysicalBreaks if its value on entry is not
     * SP_UNINITIALIZED_VALUE. But AdvanSys has found that performance
     * can be improved by increasing the value to the maximum the
     * adapter can handle.
     *
     * Note: The definition of NumberOfPhysicalBreaks is "maximum
     * scatter-gather elements - 1". NT is broken in that it sets
     * MaximumPhysicalPages, the value class drivers use, to the
     * same value as NumberOfPhysicalBreaks.
     *
     */
    ConfigInfo->NumberOfPhysicalBreaks =
        (((chipConfig->max_total_qng - 2) / 2) * ASC_SG_LIST_PER_Q);
    if (ConfigInfo->NumberOfPhysicalBreaks > ASC_MAX_SG_LIST - 1) {
        ConfigInfo->NumberOfPhysicalBreaks = ASC_MAX_SG_LIST - 1;
    }

    ConfigInfo->ScatterGather = TRUE;
    ConfigInfo->Master = TRUE;
    ConfigInfo->NeedPhysicalAddresses = TRUE;
    ConfigInfo->Dma32BitAddresses = TRUE;
    ConfigInfo->InterruptMode = LevelSensitive;
    ConfigInfo->AdapterInterfaceType = PCIBus;
    /*
     * Set the buffer alignment mask to require double word
     * alignment for old PCI chips and no alignment for
     * Ultra PCI chips.
     */
    if ((chipConfig->cfg->pci_device_id == ASC_PCI_DEVICE_ID) ||
        (chipConfig->cfg->pci_device_id == ASC_PCI_DEVICE_ID2)) {
        ConfigInfo->AlignmentMask = 3;
    } else {
        ConfigInfo->AlignmentMask = 0;
    }
    ConfigInfo->BufferAccessScsiPortControlled = TRUE;
    ConfigInfo->MaximumNumberOfTargets = 7;
    ConfigInfo->TaggedQueuing = TRUE;

    /*
     * Clear adapter wait queue.
     */
    AscZeroMemory((PUCHAR) &HDE2WAIT(deviceExtension), sizeof(asc_queue_t));

    //
    // Allocate a Noncached Extension to use for overrun handling.
    //
    deviceExtension->inquiryBuffer = (PVOID) ScsiPortGetUncachedExtension(
            deviceExtension,
            ConfigInfo,
            NONCACHED_EXTENSION);

    *Again = TRUE;

    ASC_DBG1(2, "FoundPCI: IO Base addr %x\n", chipConfig->iop_base);
    ASC_DBG1(2, "FoundPCI: Int Level    %x\n", ConfigInfo->BusInterruptLevel);
    ASC_DBG1(2, "FoundPCI: Initiator ID %x\n", ConfigInfo->InitiatorBusId[0]);
    ASC_DBG(2, "FoundPCI: SP_RETURN_FOUND\n");
    return SP_RETURN_FOUND;
}

BOOLEAN
HwInitialize(
    IN PVOID HwDeviceExtension
    )

/*++

Routine Description:

    This routine is called from ScsiPortInitialize
    to set up the adapter so that it is ready to service requests.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:

    TRUE - if initialization successful.
    FALSE - if initialization unsuccessful.

--*/

{
    PHW_DEVICE_EXTENSION    deviceExtension = HwDeviceExtension;
    PCHIP_CONFIG            chipConfig = HwDeviceExtension;
    uchar                   *inqBuffer = deviceExtension->inquiryBuffer;
    ushort                  initstat;

    ASC_DBG1(2, "HwInitialize: chipConfig %x\n", chipConfig);

    chipConfig->cfg->overrun_buf = inqBuffer;

    if ((initstat = AscInitAsc1000Driver(chipConfig)) != 0) {
        ASC_DBG1(1, "AscInitAsc1000Driver: warning code %x\n", initstat);
    }

    if (chipConfig->err_code != 0) {
        ASC_DBG1(1, "AscInitAsc1000Driver: err_code code %x\n",
            chipConfig->err_code);
        return(SP_RETURN_ERROR);
    } else {
        ASC_DBG(2, "AscInitAsc1000Driver: successful\n");
    }

    ASC_DBG(2, "HwInitialize: TRUE\n");
    return( TRUE );
} // HwInitialize()

/*
 * AscExecuteIO()
 *
 * If ASC_BUSY is returned, the request was not executed and it
 * should be enqueued and tried later.
 *
 * For all other return values the request is active or has
 * been completed.
 */
int
AscExecuteIO(IN PSCSI_REQUEST_BLOCK srb)
{
    PVOID           HwDeviceExtension;
    PCHIP_CONFIG    chipConfig;
    PSCB            scb;
    uchar           PathId, TargetId, Lun;
    uint            status;

    ASC_DBG1(3, "AscExecuteIO: srb %x\n", srb);
    HwDeviceExtension = SRB2HDE(srb);
    chipConfig = &HDE2CONFIG(HwDeviceExtension);

    //
    // Build SCB.
    //
    BuildScb(HwDeviceExtension, srb);
    scb = &SRB2SCB(srb);
    PathId = srb->PathId;
    TargetId = srb->TargetId;
    Lun = srb->Lun;

    //
    // Execute SCSI Command
    //
    status = AscExeScsiQueue(chipConfig, scb);

    if (status == ASC_NOERROR) {
        /*
         * Request successfully started.
         *
         * If more requests can be sent to the Asc Library then
         * call NextRequest or NextLuRequest.
         *
         * NextRequest indicates that another request may be sent
         * to any non-busy target. Since a request was just issued
         * to the target 'TargetId' that target is now busy and won't
         * be sent another request until a RequestComplete is done.
         *
         * NextLuRequest indicates that another request may be sent
         * to any non-busy target as well as the specified target even
         * if the specified target is busy.
         */
        ASC_DBG1(3, "AscExeScsiQueue: srb %x ASC_NOERROR\n", srb);
        ASC_DBG1(3, "AscExecuteIO: srb %x, NextLuRequest\n", srb);
        ScsiPortNotification(NextLuRequest, HwDeviceExtension,
                        PathId, TargetId, Lun);
    } else if (status == ASC_BUSY) {
        ASC_DBG1(1, "AscExeScsiQueue: srb %x ASC_BUSY\n", srb);
        ASC_DBG1(3, "AscExecuteIO: srb %x, NextRequest\n", srb);
        ScsiPortNotification(NextRequest, HwDeviceExtension, NULL);
    } else {
        /*
         * AscExeScsiQueue() returned an error...
         */
        ASC_DBG2(1, "AscExeScsiQueue: srb %x, error code %x\n", srb, status);
        srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
        ASC_DBG1(3, "AscExecuteIO: srb %x, RequestComplete\n", srb);
        ScsiPortNotification(RequestComplete, HwDeviceExtension, srb);
        ASC_DBG1(3, "AscExecuteIO: srb %x, NextRequest\n", srb);
        ScsiPortNotification(NextRequest, HwDeviceExtension, NULL);
    }

    ASC_DBG1(3, "AscExecuteIO: status %d\n", status);
    return status;
}

BOOLEAN
HwStartIo(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK srb
    )

/*++

Routine Description:

    This routine is called from the SCSI port driver to send a
    command to controller or target.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:

    TRUE

--*/

{
    PCHIP_CONFIG    chipConfig;
    PSCB            scb;
    REQP            reqp;
    short           status;
    asc_queue_t     *waitq;

    ASC_DBG(3, "HwStartIo: begin\n");

    scb = &SRB2SCB(srb);
    chipConfig = &HDE2CONFIG(HwDeviceExtension);
    waitq = &HDE2WAIT(HwDeviceExtension);

    switch (srb->Function) {

    case SRB_FUNCTION_ABORT_COMMAND:
        ASC_DBG1(1, "HwStartIo: Abort srb %x \n", srb->NextSrb);
        ASC_DBG1(1, "chipConfig %x\n", chipConfig);

        if (asc_rmqueue(waitq, srb->NextSrb) == ASC_TRUE)
        {
            srb->NextSrb->SrbStatus = SRB_STATUS_ABORTED;
            ScsiPortNotification(RequestComplete, HwDeviceExtension,
                                    srb->NextSrb);
        } else if (status = (AscAbortSRB(chipConfig,
                    (ulong) srb->NextSrb )) == 1) {
            ASC_DBG(2, "Abort Success\n");
            srb->SrbStatus = SRB_STATUS_SUCCESS;
        } else {
            ASC_DBG(1, "Abort error!\n");
            srb->SrbStatus = SRB_STATUS_ABORT_FAILED;
        }

        /*
         * Call AscISR() to process all requests completed by the
         * microcode and then call AscCompleteRequest() to complete
         * these requests to the OS. If AscAbortSRB() succeeded,
         * then one of the requests completed will include the
         * aborted SRB.
         */
        (void) AscISR(chipConfig);
        AscCompleteRequest(HwDeviceExtension);

        /* Complete srb */
        ScsiPortNotification(RequestComplete, HwDeviceExtension, srb);
        ScsiPortNotification(NextRequest, HwDeviceExtension, NULL);
        return TRUE;

    case SRB_FUNCTION_RESET_BUS:
        //
        // Reset SCSI bus.
        //
        ASC_DBG(1, "HwStartIo: Reset Bus\n");
        HwResetBus(chipConfig, 0L);
        srb->SrbStatus = SRB_STATUS_SUCCESS;
        ScsiPortNotification(RequestComplete, HwDeviceExtension, srb);
        ScsiPortNotification(NextRequest, HwDeviceExtension, NULL);
        return TRUE;

    case SRB_FUNCTION_EXECUTE_SCSI:

        ASC_DBG(3, "HwStartIo: Execute SCSI\n");
        /*
         * Set the srb's Device Extension pointer before attempting
                 * to start the IO. It will be needed for any retrys and in
                 * DvcISRCallBack().
         */
        SRB2HDE(srb) = HwDeviceExtension;
        SRB2RETRY(srb)=ASC_RETRY_CNT;
        /* Execute any queued commands for the host adapter. */
        if (waitq->tidmask) {
            asc_execute_queue(waitq);
        }

        /*
         * If the target for the current command has any queued
         * commands or if trying to execute the command returns
         * BUSY, then enqueue the command.
         */
        if ((waitq->tidmask & ASC_TIX_TO_TARGET_ID(srb->TargetId)) ||
            (AscExecuteIO(srb) == ASC_BUSY)) {
            asc_enqueue(waitq, srb, ASC_BACK);
        }

        return TRUE;

    case SRB_FUNCTION_RESET_DEVICE:
        ASC_DBG1(1, "HwStartIo: Reset device: %d\n", srb->TargetId);

                while ((reqp = asc_dequeue(waitq, srb->TargetId)) != NULL)
                {
                        reqp->SrbStatus = SRB_STATUS_BUS_RESET;
                        ScsiPortNotification(RequestComplete,
                            HwDeviceExtension, reqp);
                }

        AscResetDevice(chipConfig, ASC_TIDLUN_TO_IX(srb->TargetId,
                    srb->Lun));

                /*
                 * Call AscISR() to process all requests completed by the
                 * microcode and then call AscCompleteRequest() to complete
                 * these requests to the OS. If AscAbortSRB() succeeded,
                 * then one of the requests completed will include the
                 * aborted SRB.
                 */
                (void) AscISR(chipConfig);
                AscCompleteRequest(HwDeviceExtension);

        srb->SrbStatus = SRB_STATUS_SUCCESS;
        ScsiPortNotification(RequestComplete, HwDeviceExtension, srb);
        ScsiPortNotification(NextRequest, HwDeviceExtension, NULL);
        return TRUE;

    case SRB_FUNCTION_SHUTDOWN:
        /*
         * Shutdown - HwAdapterControl() ScsiStopAdapter performs
         * all needed shutdown of the adapter.
         */
        ASC_DBG(1, "HwStartIo: SRB_FUNCTION_SHUTDOWN\n");
        ScsiPortNotification(RequestComplete, HwDeviceExtension, srb);
        ScsiPortNotification(NextRequest, HwDeviceExtension, NULL);
        return TRUE;

    default:
        //
        // Set error, complete request
        // and signal ready for next request.
        //
        ASC_DBG1(1, "HwStartIo: Function %x: invalid request\n", srb->Function);
        srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
        ScsiPortNotification(RequestComplete, HwDeviceExtension, srb);
        ScsiPortNotification(NextRequest, HwDeviceExtension, NULL);
        return TRUE;

    } // end switch
    /* NOTREACHED */
} /* HwStartIo() */

BOOLEAN
HwInterrupt(
    IN PVOID HwDeviceExtension
    )

/*++

Routine Description:

    This is the interrupt service routine for the SCSI adapter.
    It reads the interrupt register to determine if the adapter is indeed
    the source of the interrupt and clears the interrupt at the device.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:


--*/
{
    PCHIP_CONFIG              chipConfig;
    PSCB                      pscb, tpscb;
    int                       retstatus;
    int                       status;
    PSCSI_REQUEST_BLOCK       srb;
    asc_queue_t               *waitq;

    ASC_DBG(3, "HwInterrupt: begin\n");

    chipConfig = &HDE2CONFIG(HwDeviceExtension);

    if (AscIsIntPending(chipConfig->iop_base) == ASC_FALSE) {
        retstatus = FALSE;
        ASC_DBG(4, "HwInterrupt: AscIsIntPending() FALSE\n");
    } else {
        retstatus = TRUE;
        do {
            switch (status = AscISR(chipConfig)) {
            case ASC_TRUE:
                ASC_DBG(3, "HwInterrupt: AscISR() TRUE\n");
                break;
            case ASC_FALSE:
                ASC_DBG(3, "HwInterrupt: AscISR() FALSE\n");
                break;
            case ASC_ERROR:
            default:
                ASC_DBG2(1,
                    "HwInterrupt: AscISR() ERROR status %d, err_code %d\n",
                        status, chipConfig->err_code);
                break;
            }
        } while (AscIsIntPending(chipConfig->iop_base) == ASC_TRUE);
    }

    /*
     * Execute any waiting requests.
     */
    if ((waitq = &HDE2WAIT(HwDeviceExtension))->tidmask) {
        asc_execute_queue(waitq);
    }

    /*
     * Complete I/O requests queued in DvcISRCallBack();
     */
    AscCompleteRequest(HwDeviceExtension);

    ASC_DBG1(3, "HwInterrupt: end %d\n", retstatus);

    return (BOOLEAN)retstatus;
} // end HwInterrupt()

SCSI_ADAPTER_CONTROL_STATUS
HwAdapterControl(
    IN PVOID HwDeviceExtension,
    IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
    IN PVOID Parameters
    )
/*++

Routine Description:

    HwAdapterControl() interface added in NT 5.0 for
        Plug and Play/Power Management.

Arguments:

    DeviceExtension
    ControlType
        Parameters

Return Value:

    SCSI_ADAPTER_CONTROL_STATUS.

--*/
{
    PCHIP_CONFIG                chipConfig = &HDE2CONFIG(HwDeviceExtension);
    PHW_DEVICE_EXTENSION        deviceExtension = HwDeviceExtension;
    PSCSI_SUPPORTED_CONTROL_TYPE_LIST ControlTypeList;
    asc_queue_t                 *waitq;
    REQP                        reqp;
    int                         i;
    USHORT                      initstat;

    switch (ControlType)
    {
    //
    // Query Adapter.
    //
    case ScsiQuerySupportedControlTypes:
        ASC_DBG(2, "HwAdapterControl: ScsiQuerySupportControlTypes\n");

        ControlTypeList =
            (PSCSI_SUPPORTED_CONTROL_TYPE_LIST) Parameters;
        if (ControlTypeList->MaxControlType < ScsiStopAdapter)
        {
            ASC_DBG(1, "HwAdapterControl: Unsuccessful 1\n");
            return ScsiAdapterControlUnsuccessful;
        }
        ControlTypeList->SupportedTypeList[ScsiStopAdapter] = TRUE;

        if (ControlTypeList->MaxControlType < ScsiSetRunningConfig)
        {
            ASC_DBG(1, "HwAdapterControl: Unsuccessful 2\n");
            return ScsiAdapterControlUnsuccessful;
        }
        ControlTypeList->SupportedTypeList[ScsiSetRunningConfig] = TRUE;

        if (ControlTypeList->MaxControlType < ScsiRestartAdapter)
        {
            ASC_DBG(1, "HwAdapterControl: Unsuccessful 3\n");
            return ScsiAdapterControlUnsuccessful;
        }
        ControlTypeList->SupportedTypeList[ScsiRestartAdapter] = TRUE;

        ASC_DBG(1, "HwAdapterControl: ScsiAdapterControlSuccess\n");
        return ScsiAdapterControlSuccess;
        /* NOTREACHED */

    //
    // Stop Adapter.
    //
    case ScsiStopAdapter:
        ASC_DBG(2, "HwAdapterControl: ScsiStopAdapter\n");

        /*
         * Complete any waiting requests.
         */
        if ((waitq = &HDE2WAIT(HwDeviceExtension))->tidmask)
        {
            for (i = 0; i <= ASC_MAX_TID; i++)
            {
                while ((reqp = asc_dequeue(waitq, i)) != NULL)
                {
                    reqp->SrbStatus = SRB_STATUS_ABORTED;
                    ScsiPortNotification(RequestComplete, HwDeviceExtension,
                        reqp);
                }
            }
        }

        //
        // Disable interrupts and halt the chip.
        //
        AscDisableInterrupt(chipConfig->iop_base);

        if (AscResetChip(chipConfig->iop_base) == 0)
        {
            ASC_DBG(1, "HwAdapterControl: ScsiStopdapter Unsuccessful\n");
            return ScsiAdapterControlUnsuccessful;
        } else
        {
            ASC_DBG(2, "HwAdapterControl: ScsiStopdapter Success\n");
            return ScsiAdapterControlSuccess;
        }
        /* NOTREACHED */

    //
    // ScsiSetRunningConfig.
    //
    // Called before ScsiRestartAdapter. Can use ScsiPort[Get|Set]BusData.
    //
    case ScsiSetRunningConfig:
        ASC_DBG(2, "HwAdapterControl: ScsiSetRunningConfig\n");

        /*
         * Execute Asc Library initialization.
         */
        if ((initstat = AscInitGetConfig(chipConfig)) != 0) {
            ASC_DBG1(1, "AscInitGetConfig: warning code %x\n", initstat);
        }

        if (chipConfig->err_code != 0) {
            ASC_DBG1(1, "AscInitGetConfig: err_code code %x\n",
                chipConfig->err_code);
            return(SP_RETURN_ERROR);
        } else {
            ASC_DBG(2, "AscInitGetConfig: successful\n");
        }

        if ((initstat = AscInitSetConfig(chipConfig)) != 0) {
            ASC_DBG1(1, "AscInitSetConfig: warning code %x\n", initstat);
        }

        if (chipConfig->err_code != 0) {
            ASC_DBG1(1, "AscInitSetConfig: err_code code %x\n",
                chipConfig->err_code);
            return(SP_RETURN_ERROR);
        } else {
            ASC_DBG(2, "AscInitSetConfig: successful\n");
        }

        ASC_DBG(2, "HwAdapterControl: ScsiSetRunningConfig successful\n");
        return ScsiAdapterControlSuccess;
        /* NOTREACHED */

    //
    // Restart Adapter.
    //
    // Cannot use ScsiPort[Get|Set]BusData.
    //
    case ScsiRestartAdapter:
        ASC_DBG(2, "HwAdapterControl: ScsiRestartAdapter\n");

        chipConfig->cfg->overrun_buf = deviceExtension->inquiryBuffer;

        if ((initstat = AscInitAsc1000Driver(chipConfig)) != 0)
        {
            ASC_DBG1(1,
                "AscInitAsc1000Driver: warning code %x\n", initstat);
        }

        if (chipConfig->err_code != 0) {
            ASC_DBG1(1, "AscInitAsc1000Driver: err_code code %x\n",
                chipConfig->err_code);
            return ScsiAdapterControlUnsuccessful;
        } else {
            ASC_DBG(2, "HwAdapterControl: ScsiRestartAdapter success\n");
            return ScsiAdapterControlSuccess;
        }
        /* NOTREACHED */

    //
    // Unsupported Control Operation.
    //
    default:
        return ScsiAdapterControlUnsuccessful;
        /* NOTREACHED */
    }
    /* NOTREACHED */
}

VOID
BuildScb(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK srb
    )

/*++

Routine Description:

    Build SCB for Library routines.

Arguments:

    DeviceExtension
    SRB

Return Value:

    Nothing.

--*/

{
    PSCB            scb;
    PCHIP_CONFIG    chipConfig = &HDE2CONFIG(HwDeviceExtension);
    ULONG           length, xferLength, remainLength;
    ULONG           virtualAddress;
    UCHAR           i;

    //
    // Set target id and LUN.
    //
    scb = &SRB2SCB(srb);    /* scb is part of the srb */
    AscZeroMemory((PUCHAR) scb, sizeof(SCB));
    SCB2SRB(scb) = srb;
    scb->sg_head = (ASC_SG_HEAD *) &SRB2SDL(srb);
    AscZeroMemory((PUCHAR) scb->sg_head, sizeof(SDL));
    ASC_ASSERT(SCB2HDE(scb) == HwDeviceExtension);

    scb->q1.target_lun = srb->Lun;
    scb->q1.target_id = ASC_TID_TO_TARGET_ID(srb->TargetId & 0x7);
    scb->q2.target_ix = ASC_TIDLUN_TO_IX(srb->TargetId & 0x7, srb->Lun);

    //
    // Check if tag queueing enabled. Our host adapter will support
    // tag queuing anyway. However, we will use OS's tag action if
    // available. chip_no is used to store whether the device support
    // tag queuing or not, each target per bit.
    //

    if (srb->SrbFlags & SRB_FLAGS_QUEUE_ACTION_ENABLE ) {
        scb->q2.tag_code = srb->QueueAction;
    } else {
        scb->q2.tag_code = M2_QTAG_MSG_SIMPLE ;
    }

    //
    // Set CDB length and copy to CCB.
    //

    scb->q2.cdb_len = (UCHAR)srb->CdbLength;
    scb->cdbptr = (uchar *) &( srb->Cdb );

    scb->q1.data_cnt = srb->DataTransferLength;

    //
    // Build SDL in SCB if data transfer. Scatter gather list
    // array is allocated per request basis. The location is
    // assigned right after SCB in SrbExtension.
    //

    i = 0;

    // Assume no data transfer

    scb->q1.cntl = 0 ;

    if (srb->DataTransferLength > 0) {

        scb->q1.cntl = QC_SG_HEAD ;
        scb->sg_head->entry_cnt = 0;
        xferLength = srb->DataTransferLength;
        virtualAddress = (ulong) srb->DataBuffer;
        remainLength = xferLength;

        //
        // Build scatter gather list
        //

        do {
            scb->sg_head->sg_list[i].addr = (ulong)
                ScsiPortConvertPhysicalAddressToUlong(
                    ScsiPortGetPhysicalAddress(HwDeviceExtension, srb,
                    (PVOID) virtualAddress, &length));

            if ( length > remainLength ) {
                length = remainLength;
            }
            scb->sg_head->sg_list[i].bytes = length;

            ASC_DBG1(4, "Transfer Data Buffer logical %lx\n", virtualAddress);
            ASC_DBG1(4, "Transfer Data Length            %lx\n", length);
            ASC_DBG1(4, "Transfer Data Buffer physical %lx\n",
                scb->sg_head->sg_list[i].addr);
            //
            // Calculate next virtual address and remaining byte count
            //
            virtualAddress += length;

            if(length >= remainLength) {
                remainLength = 0;
            } else {
                remainLength -= length;
            }
            i++;
        } while ( remainLength > 0);

        scb->sg_head->entry_cnt = i;
    }

    //
    // Convert sense buffer length and buffer into physical address
    //

    if (srb->SrbFlags & SRB_FLAGS_DISABLE_AUTOSENSE ) {
        scb->q1.sense_len = 0;
    } else {
        ASC_DBG1(3, "srb->senseLength %x\n", srb->SenseInfoBufferLength);
        ASC_DBG1(3, "srb->sensePtr    %x\n", srb->SenseInfoBuffer);
        scb->q1.sense_len = (uchar) srb->SenseInfoBufferLength;
        if (srb->SenseInfoBufferLength > 0) {
            scb->q1.sense_addr =
                    ScsiPortConvertPhysicalAddressToUlong(
                    ScsiPortGetPhysicalAddress(HwDeviceExtension, srb,
                    srb->SenseInfoBuffer, &length));
        }
        //
        // Sense buffer can not be scatter-gathered
        //
        if ( srb->SenseInfoBufferLength > length ) {
                ASC_DBG(1, "Sense Buffer Overflow to next page.\n");
            scb->q1.sense_len = (uchar) length;
        }
    }
    return;
} // end BuildScb()

BOOLEAN
HwResetBus(
    IN PVOID HwDeviceExtension,
    IN ULONG PathId
    )

/*++

Routine Description:

    Reset SCSI bus.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:

    Nothing.


--*/

{
    PCHIP_CONFIG    chipConfig;
    REQP            reqp;
    asc_queue_t     *waitq;
    int             i;
    int             retstatus;

    ASC_DBG(1, "HwResetBus: begin\n");

    chipConfig = &HDE2CONFIG(HwDeviceExtension);

    /*
     * Complete all waiting requests.
     */
    if ((waitq = &HDE2WAIT(HwDeviceExtension))->tidmask) {
        for (i = 0; i <= ASC_MAX_TID; i++) {
            while ((reqp = asc_dequeue(waitq, i)) != NULL) {
                reqp->SrbStatus = SRB_STATUS_BUS_RESET;
                ScsiPortNotification(RequestComplete, HwDeviceExtension, reqp);
            }
        }
    }

    /*
     * Perform the bus reset.
     */
    retstatus = AscResetSB(chipConfig);
    ASC_DBG1(2, "HwResetBus: AscResetSB() retstatus %d\n", retstatus);

    /*
     * Call AscISR() to process all requests completed by the
     * microcode and then call AscCompleteRequest() to complete
     * these requests to the OS.
     */
    (void) AscISR(chipConfig);
    AscCompleteRequest(HwDeviceExtension);

    /*
     * Complete all pending requests to the OS.
     *
     * All requests that have been sent to the microcode should have been
     * completed by the call to AscResetSB(). In case there were requests
     * that were misplaced by the microcode and not completed, use the
     * SRB_STATUS_BUS_RESET function with no TID and LUN to clear all
     * pending requests.
     */
ScsiPortCompleteRequest(HwDeviceExtension,
        (UCHAR) PathId,
        SP_UNTAGGED,
        SP_UNTAGGED,
        SRB_STATUS_BUS_RESET);

    return (BOOLEAN)retstatus;
} // end HwResetBus()

//
// Following are the routines required by Asc1000 library. These
// routine will be called from Asc1000 library.
//

void
DvcDisplayString(
    uchar *string
    )
/*++

Routine Description:

    This routine is required for Asc Library. Since NT mini
    port does not display anything, simply provide a dummy routine.

--*/
{
    ASC_DBG1(2, "%s", string);
}

int
DvcEnterCritical(
    void
    )
/*++

    This routine claims critical section. In NT, the OS will handle
    it properly, we simply provide a dummy routine to make Asc1000
    library happy.

--*/
{
    return TRUE;
}

void
DvcLeaveCritical(
    int myHandle
    )
/*++

    This routine exits critical section. In NT, the OS will handle
    it properly, we simply provide a dummy routine to make Asc1000
    library happy.

--*/
{
}

VOID
DvcISRCallBack(
    IN PCHIP_CONFIG chipConfig,
    IN ASC_QDONE_INFO *scbDoneInfo
    )

/*++

Routine Description:

    Callback routine for interrupt handler.

Arguments:

    chipConfig - Pointer to chip configuration structure
    scbDoneInfo - Pointer to a structure contains information about
        the scb just completed

Return Value:

--*/
{
    asc_queue_t       *waitq;
    ASC_REQ_SENSE     *sense;
    uchar             underrun = FALSE;
    PHW_DEVICE_EXTENSION HwDeviceExtension = (PHW_DEVICE_EXTENSION) chipConfig;
    PSCSI_REQUEST_BLOCK srb = (PSCSI_REQUEST_BLOCK) scbDoneInfo->d2.srb_ptr;
    PSCB *ppscb;

    ASC_DBG2(3, "DvcISRCallBack: chipConfig %x, srb %x\n", chipConfig, srb);

    if (srb == NULL) {
        ASC_DBG(1, "DvcISRCallBack: srb is NULL\n");
        return;
    }

    ASC_DBG1(3, "DvcISRCallBack: %X bytes requested\n",
        srb->DataTransferLength);

    ASC_DBG1(3, "DvcISRCallBack: %X bytes remaining\n",
        scbDoneInfo->remain_bytes);
#if DBG
    if (scbDoneInfo->remain_bytes != 0) {
        ASC_DBG2(1, "DvcISRCallBack: underrun/overrun: remain %X, request %X\n",
            scbDoneInfo->remain_bytes, srb->DataTransferLength);
    }
#endif /* DBG */

    //
    // Set Underrun Status in the SRB.
    //
    // If 'DataTransferlength' is set to a non-zero value when
    // the SRB is returned and the SRB_STATUS_DATA_OVERRUN flag
    // is set, then an Underrun condition is indicated. There is
    // no separate SrbStatus flag to indicate an Underrun condition.
    //
    if (srb->DataTransferLength != 0 && scbDoneInfo->remain_bytes != 0 &&
        scbDoneInfo->remain_bytes <= srb->DataTransferLength)
    {
        srb->DataTransferLength -= scbDoneInfo->remain_bytes;
        underrun = TRUE;
    }

    if (scbDoneInfo->d3.done_stat == QD_NO_ERROR) {
        //
        // Command sucessfully completed
        //
        if (underrun == TRUE)
        {
            //
            // Set Underrun Status in the SRB.
            //
            // If 'DataTransferlength' is set to a non-zero value when
            // the SRB is returned and the SRB_STATUS_DATA_OVERRUN flag
            // is set, then an Underrun condition is indicated. There
            // is no separate SrbStatus flag to indicate an Underrun
            // condition.
            //
            srb->SrbStatus = SRB_STATUS_DATA_OVERRUN;
        } else
        {
            srb->SrbStatus = SRB_STATUS_SUCCESS;
        }

        //
        // If an INQUIRY command successfully completed, then call
        // the AscInquiryHandling() function.
        //
        if (srb->Cdb[0] == SCSICMD_Inquiry && srb->Lun == 0 &&
            srb->DataTransferLength >= 8)
        {
            AscInquiryHandling(chipConfig,
                (uchar) (srb->TargetId & 0x7),
                (ASC_SCSI_INQUIRY *) srb->DataBuffer);
        }

        srb->ScsiStatus = 0;

        ASC_DBG(3, "DvcISRCallBack: QD_NO_ERROR\n");

#if DBG
        if (SRB2RETRY(srb) < ASC_RETRY_CNT)
        {
            ASC_DBG2(3,
                 "DvcISRCallBack: srb retry success: srb %x, retry %d\n",
                 srb, SRB2RETRY(srb));
        }
#endif /* DBG */
    } else {

        ASC_DBG4(2,
            "DvcISRCallBack: id %d, done_stat %x, scsi_stat %x, host_stat %x\n",
            ASC_TIX_TO_TID(scbDoneInfo->d2.target_ix),
            scbDoneInfo->d3.done_stat, scbDoneInfo->d3.scsi_stat,
            scbDoneInfo->d3.host_stat);

        /* Notify NT of a Bus Reset */
        if (scbDoneInfo->d3.host_stat == QHSTA_M_HUNG_REQ_SCSI_BUS_RESET) {
            ASC_DBG(1, "DvcISRCallBack: QHSTA_M_HUNG_REQ_SCSI_BUS_RESET\n");
            ScsiPortNotification(ResetDetected, HwDeviceExtension);
        }
        if (scbDoneInfo->d3.done_stat == QD_ABORTED_BY_HOST) {
            //
            // Command aborted by host
            //
            ASC_DBG(2, "DvcISRCallBack: QD_ABORTED_BY_HOST\n");
            srb->SrbStatus = SRB_STATUS_ABORTED;
            srb->ScsiStatus = 0;
        } else if (scbDoneInfo->d3.scsi_stat != SS_GOOD)
        {
            ASC_DBG(1, "DvcISRCallBack: scsi_stat != SS_GOOD\n");
            //
            // Set ScsiStatus for SRB
            //
            srb->SrbStatus = SRB_STATUS_ERROR;
            srb->ScsiStatus = scbDoneInfo->d3.scsi_stat;

            //
            // Treat a SCSI Status Byte of BUSY status as a special case
            // in setting the 'SrbStatus' field. STI (Still Image Capture)
            // drivers need this 'SrbStatus', because the STI interface does
            // not include the 'ScsiStatus' byte. These drivers must rely
            // on the 'SrbStatus' field to determine when the target device
            // returns BUSY.
            //
            if (scbDoneInfo->d3.scsi_stat == SS_TARGET_BUSY)
            {
                srb->SrbStatus = SRB_STATUS_BUSY;
            }
            else if ((scbDoneInfo->d3.host_stat == 0) &&
                     (scbDoneInfo->d3.scsi_stat == SS_CHK_CONDITION))
            {
                srb->SrbStatus |= SRB_STATUS_AUTOSENSE_VALID;
                ASC_DBG1(2,
                    "DvcISRCallBack: srb %x, SRB_STATUS_AUTOSENSE_VALID\n",
                    srb);

                sense = (ASC_REQ_SENSE *)  srb->SenseInfoBuffer;
#if DBG
                if (sense->sense_key == SCSI_SENKEY_MEDIUM_ERR)
                {
                    ASC_DBG2(2,
        "DvcISRCallBack: check condition with medium error: cdb %x retry %d\n",
                        srb->Cdb[0], SRB2RETRY(srb));
                }
#endif /* DBG */
                /*
                 * Perform up to ASC_RETRY_CNT retries for Medium Errors
                 * on Write-10 (0x2A), Write-6 (0x0A), Write-Verify (0x2E),
                 * and Verify (0x2F) commands.
                 */
                if (sense->sense_key == SCSI_SENKEY_MEDIUM_ERR &&
                    (srb->Cdb[0] == 0x2A || srb->Cdb[0] == 0x0A ||
                     srb->Cdb[0] == 0x2E || srb->Cdb[0] == 0x2F) &&
                    SRB2RETRY(srb)-- > 0)
                {
                    ASC_DBG1(2, "DvcISRCallBack: doing retry srb %x\n", srb);
                    waitq = &HDE2WAIT(HwDeviceExtension);
                    /*
                     * Because a retry is being done if
                     * an underrun occured, then restore
                     * 'DataTransferLength' to its original
                     * value so the retry will use the
                     * correct 'DataTransferLength' value.
                     */
                    if (underrun == TRUE)
                    {
                       srb->DataTransferLength += scbDoneInfo->remain_bytes;
                    }
                    if (AscExecuteIO(srb) == ASC_BUSY)
                    {
                        ASC_DBG(2, "DvcISRCallBack: busy - retry queued\n");
                        asc_enqueue(waitq, srb, ASC_FRONT);
                    }
                    else {
                        ASC_DBG(2, "DvcISRCallBack: retry started\n");
                    }
                    return;
                }
            }
        } else {
            //
            // Scsi Status is ok, but host status is not
            //
            srb->SrbStatus = ErrXlate(scbDoneInfo->d3.host_stat);
            srb->ScsiStatus = 0;
        }
    }

#if DBG_SRB_PTR
    /* Check the integrity of the done list. */
    if (*(ppscb = &HDE2DONE(HwDeviceExtension)) != NULL) {
        if (SCB2SRB(*ppscb) == NULL) {
            ASC_DBG1(1, "DvcISRCallBack: SCB2SRB() is NULL 1, *ppscb %x\n",
                *ppscb);
            DbgBreakPoint();
        }
        for (; *ppscb; ppscb = &SCB2PSCB(*ppscb)) {
            if (SCB2SRB(*ppscb) == NULL) {
                ASC_DBG1(1, "DvcISRCallBack: SCB2SRB() is NULL 2, *ppscb %x\n",
                    *ppscb);
                DbgBreakPoint();
            }
        }
    }
#endif /* DBG_SRBPTR */

    /*
     * Add the SCB to end of the completion list. The request will be
     * completed in HwInterrupt().
     */
    for (ppscb = &HDE2DONE(HwDeviceExtension); *ppscb;
         ppscb = &SCB2PSCB(*ppscb)) {
        ;
    }
    *ppscb = &SRB2SCB(srb);
    SRB2PSCB(srb) = NULL;

    return;
}

UCHAR
ErrXlate (UCHAR ascErrCode)

/*++

Routine Description:

    This routine translate Library status into SrbStatus which
    is requried by NT

Arguments:

    ascErrCode - Error code defined by host_stat

Return Value:

    Error code defined by NT SCSI port driver

--*/


{
    switch (ascErrCode) {

    case QHSTA_M_SEL_TIMEOUT:
        return ( SRB_STATUS_SELECTION_TIMEOUT );

    case QHSTA_M_DATA_OVER_RUN:
        return ( SRB_STATUS_DATA_OVERRUN );

    case QHSTA_M_UNEXPECTED_BUS_FREE:
        return ( SRB_STATUS_UNEXPECTED_BUS_FREE );

    case QHSTA_D_HOST_ABORT_FAILED:
        return ( SRB_STATUS_ABORT_FAILED );

    case QHSTA_M_HUNG_REQ_SCSI_BUS_RESET:
        return ( SRB_STATUS_BUS_RESET );

    //
    // Don't know what to report
    //

    default:
        return ( SRB_STATUS_TIMEOUT );

    }
}

/*
 * Description: search EISA host adapter
 *
 * - search starts with iop_base equals zero( 0 )
 *
 * return i/o port address found ( non-zero )
 * return 0 if not found
 */
PortAddr
HwSearchIOPortAddrEISA(
                PortAddr iop_base,
                IN PVOID HwDE,
                IN OUT PPORT_CONFIGURATION_INFORMATION Cfg
            )
{
    ulong eisa_product_id ;
    PVOID new_base ;
    PVOID prodid_base ;
    ushort product_id_high, product_id_low ;

    if( iop_base == 0 ) {
        iop_base = ASC_EISA_MIN_IOP_ADDR ;
    }/* if */
    else {
        if( iop_base == ASC_EISA_MAX_IOP_ADDR ) return( 0 ) ;
        if( ( iop_base & 0x0050 ) == 0x0050 ) {
                iop_base += ASC_EISA_BIG_IOP_GAP ; /* when it is 0zC50 */
        }/* if */
        else {
                iop_base += ASC_EISA_SMALL_IOP_GAP ; /* when it is 0zC30 */
        }/* else */
    }/* else */
    while( iop_base <= ASC_EISA_MAX_IOP_ADDR )
    {
        //
        // Validate range:
        //
        if (ScsiPortValidateRange(HwDE,
            Cfg->AdapterInterfaceType,
            Cfg->SystemIoBusNumber,
            ScsiPortConvertUlongToPhysicalAddress(iop_base),
            16,
            TRUE))
        {
            //
            // First obtain the EISA product ID for the current slot.
            //
            new_base = ScsiPortGetDeviceBase(HwDE,
                Cfg->AdapterInterfaceType,
                Cfg->SystemIoBusNumber,
                ScsiPortConvertUlongToPhysicalAddress(
                   ASC_GET_EISA_SLOT( iop_base ) | ASC_EISA_PID_IOP_MASK),
                4,
                TRUE);

            if (new_base == NULL)
            {
                eisa_product_id = 0;
            } else
            {
                product_id_low = inpw( new_base) ;
                product_id_high = inpw( ((ushort *) new_base) + 2 ) ;
                eisa_product_id = ( ( ulong)product_id_high << 16 ) |
                    ( ulong )product_id_low ;
                ScsiPortFreeDeviceBase(HwDE, new_base);
            }

            //
            // Map the address
            //
            new_base = ScsiPortGetDeviceBase(HwDE,
                Cfg->AdapterInterfaceType,
                Cfg->SystemIoBusNumber,
                ScsiPortConvertUlongToPhysicalAddress(iop_base),
                16,
                TRUE);

            /*
             * search product id first
             */
            if (new_base != NULL)
            {
                if( ( eisa_product_id == ASC_EISA_ID_740 ) ||
                    ( eisa_product_id == ASC_EISA_ID_750 ) ) {
                    if( AscFindSignature( (PortAddr)new_base ) ) {
                        /*
                         * chip found, clear ID left in latch
                         * to clear, read any i/o port word that doesn't
                         * contain data 0x04c1 iop_base plus four should do it
                         */
                        inpw( ((PortAddr)new_base)+4 ) ;
                        ScsiPortFreeDeviceBase(HwDE, new_base);
                        return( iop_base ) ;
                    }/* if */
                }/* if */
                ScsiPortFreeDeviceBase(HwDE, new_base);
            }
        }/* if */
        if( iop_base == ASC_EISA_MAX_IOP_ADDR ) return( 0 ) ;
        if( ( iop_base & 0x0050 ) == 0x0050 ) {
                iop_base += ASC_EISA_BIG_IOP_GAP ;
        }/* if */
        else {
            iop_base += ASC_EISA_SMALL_IOP_GAP ;
        }/* else */
    }/* while */
    return( 0 ) ;
}

/*
 * Description: Search for VL and ISA host adapters (at 9 default addresses).
 *
 * Return 0 if not found.
 */
PortAddr
HwSearchIOPortAddr11(
                PortAddr s_addr,
                IN PVOID HwDE,
                IN OUT PPORT_CONFIGURATION_INFORMATION Cfg
            )
{
    /*
     * VL, ISA
     */
    int     i ;
    PortAddr iop_base ;
    PVOID new_base ;

    for( i = 0 ; i < ASC_IOADR_TABLE_MAX_IX ; i++ ) {
        if( _asc_def_iop_base[ i ] > s_addr ) {
            break ;
        }/* if */
    }/* for */
    for( ; i < ASC_IOADR_TABLE_MAX_IX ; i++ ) {
        iop_base = _asc_def_iop_base[ i ] ;
        //
        // Validate range:
        //
        if (!ScsiPortValidateRange(HwDE,
            Cfg->AdapterInterfaceType,
            Cfg->SystemIoBusNumber,
            ScsiPortConvertUlongToPhysicalAddress(iop_base),
            16,
            TRUE))
        {
            continue;               // No good, skip this one
        }
        //
        // Map the address
        //
        new_base = ScsiPortGetDeviceBase(HwDE,
            Cfg->AdapterInterfaceType,
            Cfg->SystemIoBusNumber,
            ScsiPortConvertUlongToPhysicalAddress(iop_base),
            16,
            TRUE);

        if( AscFindSignature( (PortAddr)new_base ) ) {
            ScsiPortFreeDeviceBase(HwDE, new_base);
            return( iop_base ) ;
        }/* if */
        ScsiPortFreeDeviceBase(HwDE, new_base);
    }/* for */
    return( 0 ) ;
}

/*
 * Description: Search for VL and ISA host adapters.
 *
 * Return 0 if not found.
 */
PortAddr
HwSearchIOPortAddr(
                PortAddr iop_beg,
                ushort bus_type,
                IN PVOID HwDE,
                IN OUT PPORT_CONFIGURATION_INFORMATION Cfg
            )
{
    if( bus_type & ASC_IS_VL ) {
        while( ( iop_beg = HwSearchIOPortAddr11( iop_beg, HwDE, Cfg ) ) != 0 ) {
            if( AscGetChipVersion( iop_beg, bus_type ) <=
                ASC_CHIP_MAX_VER_VL ) {
            return( iop_beg ) ;
            }/* if */
        }/* if */
        return( 0 ) ;
    }/* if */
    if( bus_type & ASC_IS_ISA ) {
        while( ( iop_beg = HwSearchIOPortAddr11( iop_beg, HwDE, Cfg ) ) != 0 ) {
            if( ( AscGetChipVersion( iop_beg, bus_type ) &
                ASC_CHIP_VER_ISA_BIT ) != 0 ) {
            return( iop_beg ) ;
            }/* if */
        }/* if */
        return( 0 ) ;
    }/* if */
    if( bus_type & ASC_IS_EISA ) {
        if( ( iop_beg = HwSearchIOPortAddrEISA( iop_beg, HwDE, Cfg ) ) != 0 ) {
            return( iop_beg ) ;
        }/* if */
        return( 0 ) ;
    }/* if */
    return( 0 ) ;
}

ULONG
PCIGetBusData(
    IN PVOID DeviceExtension,
    IN ULONG SystemIoBusNumber,
    IN PCI_SLOT_NUMBER SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    )
{
    return ScsiPortGetBusData(
                   DeviceExtension,
                   PCIConfiguration,
                   SystemIoBusNumber,
                   SlotNumber.u.AsULONG,
                   Buffer,
                   Length);

}

/*
 * Complete all requests on the adapter done list by
 * DvcISRCallBack().
 */
void
AscCompleteRequest(
    IN PVOID HwDeviceExtension
    )
{
    PSCB                pscb, tpscb;
    PSCSI_REQUEST_BLOCK srb;

    /*
     * Return if the done list is empty.
     */
    if ((pscb = HDE2DONE(HwDeviceExtension)) == NULL) {
        ASC_DBG(4, "AscCompleteRequest: adapter scb_done == NULL\n");
        return;
    }

    HDE2DONE(HwDeviceExtension) = NULL;

    /*
     * Interrupts could now be enabled during the SRB callback
     * without adversely affecting the driver.
     */
    while (pscb) {
        tpscb = SCB2PSCB(pscb);
        SCB2PSCB(pscb) = NULL;
        srb = SCB2SRB(pscb);
        ASC_DBG2(4,
            "AscCompleteRequest: RequestComplete: srb 0x%lx, scb 0x%lx\n",
            srb, pscb);
        ASC_ASSERT(SRB2HDE(srb) != NULL);
        ScsiPortNotification(RequestComplete, SRB2HDE(srb), srb);
        pscb = tpscb;
    }
}

/*
 * Add a 'REQP' to the end of specified queue. Set 'tidmask'
 * to indicate a command is queued for the device.
 *
 * 'flag' may be either ASC_FRONT or ASC_BACK.
 *
 * 'REQPNEXT(reqp)' returns reqp's next pointer.
 */
void
asc_enqueue(asc_queue_t *ascq, REQP reqp, int flag)
{
    REQP    *reqpp;
    int     tid;

    ASC_DBG3(3, "asc_enqueue: ascq %x, reqp %x, flag %d\n", ascq, reqp, flag);
    tid = REQPTID(reqp);
    ASC_ASSERT(flag == ASC_FRONT || flag == ASC_BACK);
    if (flag == ASC_FRONT) {
        REQPNEXT(reqp) = ascq->queue[tid];
        ascq->queue[tid] = reqp;
    } else { /* ASC_BACK */
        for (reqpp = &ascq->queue[tid]; *reqpp; reqpp = &REQPNEXT(*reqpp)) {
            ASC_ASSERT(ascq->tidmask & ASC_TIX_TO_TARGET_ID(tid));
            ;
        }
        *reqpp = reqp;
        REQPNEXT(reqp) = NULL;
    }
    /* The queue has at least one entry, set its bit. */
    ascq->tidmask |= ASC_TIX_TO_TARGET_ID(tid);
    ASC_DBG1(2, "asc_enqueue: reqp %x\n", reqp);
    return;
}

/*
 * Return first queued 'REQP' on the specified queue for
 * the specified target device. Clear the 'tidmask' bit for
 * the device if no more commands are left queued for it.
 *
 * 'REQPNEXT(reqp)' returns reqp's next pointer.
 */
REQP
asc_dequeue(asc_queue_t *ascq, int tid)
{
    REQP    reqp;

    ASC_DBG2(3, "asc_dequeue: ascq %x, tid %d\n", ascq, tid);
    if ((reqp = ascq->queue[tid]) != NULL) {
        ASC_ASSERT(ascq->tidmask & ASC_TIX_TO_TARGET_ID(tid));
        ascq->queue[tid] = REQPNEXT(reqp);
        /* If the queue is empty, clear its bit. */
        if (ascq->queue[tid] == NULL) {
            ascq->tidmask &= ~ASC_TIX_TO_TARGET_ID(tid);
        }
    }
    ASC_DBG1(2, "asc_dequeue: reqp %x\n", reqp);

    return reqp;
}

/*
 * Remove the specified 'REQP' from the specified queue for
 * the specified target device. Clear the 'tidmask' bit for the
 * device if no more commands are left queued for it.
 *
 * 'REQPNEXT(reqp)' returns reqp's the next pointer.
 *
 * Return ASC_TRUE if the command was found and removed,
 * otherwise return ASC_FALSE.
 */
int
asc_rmqueue(asc_queue_t *ascq, REQP reqp)
{
    REQP            *reqpp;
    int             tid;
    int             ret;

    ret = ASC_FALSE;
    tid = REQPTID(reqp);
    for (reqpp = &ascq->queue[tid]; *reqpp; reqpp = &REQPNEXT(*reqpp)) {
        ASC_ASSERT(ascq->tidmask & ASC_TIX_TO_TARGET_ID(tid));
        if (*reqpp == reqp) {
            ret = ASC_TRUE;
            *reqpp = REQPNEXT(reqp);
            REQPNEXT(reqp) = NULL;
            /* If the queue is now empty, clear its bit. */
            if (ascq->queue[tid] == NULL) {
                ascq->tidmask &= ~ASC_TIX_TO_TARGET_ID(tid);
            }
            break; /* Note: *reqpp may now be NULL; don't iterate. */
        }
    }
    ASC_DBG2(3, "asc_rmqueue: reqp %x, ret %d\n", reqp, ret);

    return ret;
}

/*
 * Execute as many queued requests as possible for the specified queue.
 *
 * Calls AscExecuteIO() to execute a REQP.
 */
void
asc_execute_queue(asc_queue_t *ascq)
{
    ASC_SCSI_BIT_ID_TYPE    scan_tidmask;
    REQP                    reqp;
    int                     i;

    ASC_DBG1(2, "asc_execute_queue: ascq %x\n", ascq);
    /*
     * Execute queued commands for devices attached to
     * the current board in round-robin fashion.
     */
    scan_tidmask = ascq->tidmask;
    do {
        for (i = 0; i <= ASC_MAX_TID; i++) {
            if (scan_tidmask & ASC_TIX_TO_TARGET_ID(i)) {
                if ((reqp = asc_dequeue(ascq, i)) == NULL) {
                    scan_tidmask &= ~ASC_TIX_TO_TARGET_ID(i);
                } else if (AscExecuteIO(reqp) == ASC_BUSY) {
                    scan_tidmask &= ~ASC_TIX_TO_TARGET_ID(i);
                    /* Put the request back at front of the list. */
                    asc_enqueue(ascq, reqp, ASC_FRONT);
                }
            }
        }
    } while (scan_tidmask);
    return;
}

VOID
DvcSleepMilliSecond(
    ulong i
    )
/*++

    This routine delays i msec as required by Asc Library.

--*/

{
    ulong j;
    for (j=0; j <i; j++)
        ScsiPortStallExecution(1000L);
}

/*
 * Delay for specificed number of nanoseconds.
 *
 * Granularity is 1 microsecond.
 */
void
DvcDelayNanoSecond(
          ASC_DVC_VAR asc_ptr_type *asc_dvc,
          ulong nano_sec
          )
{
       ulong    micro_sec;

       if ((micro_sec = nano_sec/1000) == 0)
       {
           micro_sec = 1;
       }
       ScsiPortStallExecution(micro_sec);
}

ULONG
DvcGetSGList(
    PCHIP_CONFIG chipConfig,
    uchar *bufAddr,
    ulong   xferLength,
    ASC_SG_HEAD *ascSGHead
)
/*++

    This routine is used to create a Scatter Gather for low level
    driver during device driver initialization

--*/

{
    PHW_DEVICE_EXTENSION HwDeviceExtension = (PHW_DEVICE_EXTENSION) chipConfig;
    ulong   virtualAddress, uncachedStart, length;

    ASC_DBG(4, "DvcGetSGlist: begin\n");

    virtualAddress = (ulong) bufAddr;
    uncachedStart = (ulong) HwDeviceExtension->inquiryBuffer;

    ascSGHead->sg_list[0].addr = (ulong)
    ScsiPortConvertPhysicalAddressToUlong(
    ScsiPortGetPhysicalAddress(HwDeviceExtension,
                    NULL,
                    (PVOID) HwDeviceExtension->inquiryBuffer,
                    &length));

    ASC_DBG1(4, "Uncached Start Phys    = %x\n", ascSGHead->sg_list[0].addr);
    ASC_DBG1(4, "Uncached Start Length = %x\n", length);

    ascSGHead->sg_list[0].addr += (virtualAddress - uncachedStart);
    ascSGHead->sg_list[0].bytes = xferLength;
    ascSGHead->entry_cnt = 1;

    ASC_DBG1(4, "Uncached Start = %x\n", uncachedStart);
    ASC_DBG1(4, "Virtual Addr    = %x\n", virtualAddress);

    ASC_DBG1(4, "Segment 0: Addr = %x\n", ascSGHead->sg_list[0].addr);
    ASC_DBG1(4, "Segment 0: Leng = %x\n", ascSGHead->sg_list[0].bytes);

    ASC_DBG1(4, "DvcGetSGlist: xferLength %d\n", xferLength);
    return( xferLength );
}

void
DvcInPortWords( PortAddr iop, ushort dosfar *buff, int count)
{
    while (count--)
    {
        *(buff++) = ScsiPortReadPortUshort( (PUSHORT)iop );
    }
}

void
DvcOutPortWords( PortAddr iop, ushort dosfar *buff, int count)
{
    while (count--)
    {
        ScsiPortWritePortUshort( (PUSHORT)iop, *(buff++) );
    }
}

void
DvcOutPortDWords( PortAddr iop, ulong dosfar *buff, int count)
{
    DvcOutPortWords(iop, (PUSHORT)buff, count*2);
}

int
DvcDisableCPUInterrupt ( void )
{
    return(0);
}

void
DvcRestoreCPUInterrupt ( int state)
{
    return;
}

//
//  Input a configuration byte.
//
uchar
DvcReadPCIConfigByte(
    ASC_DVC_VAR asc_ptr_type *asc_dvc,
    ushort offset )
{
    PCI_COMMON_CONFIG   pciCommonConfig;
    PCI_SLOT_NUMBER     SlotNumber;

    SlotNumber.u.AsULONG = 0;
    SlotNumber.u.bits.DeviceNumber =
        ASC_PCI_ID2DEV(asc_dvc->cfg->pci_slot_info);
    SlotNumber.u.bits.FunctionNumber =
        ASC_PCI_ID2FUNC(asc_dvc->cfg->pci_slot_info);

    (void) PCIGetBusData(
        (PVOID) asc_dvc,            // HwDeviceExtension
    (ULONG) ASC_PCI_ID2BUS(asc_dvc->cfg->pci_slot_info), // Bus Number
        SlotNumber,                 // slot number
        &pciCommonConfig,           // Buffer
        sizeof(PCI_COMMON_CONFIG)   // Length
        );

    return(*((PUCHAR)(&pciCommonConfig) + offset));
}

//
//  Output a configuration byte.
//
void
DvcWritePCIConfigByte(
    ASC_DVC_VAR asc_ptr_type *asc_dvc,
    ushort offset,
    uchar  byte_data )
{
    PCI_SLOT_NUMBER     SlotNumber;

    SlotNumber.u.AsULONG = 0;
    SlotNumber.u.bits.DeviceNumber =
        ASC_PCI_ID2DEV(asc_dvc->cfg->pci_slot_info);
    SlotNumber.u.bits.FunctionNumber =
        ASC_PCI_ID2FUNC(asc_dvc->cfg->pci_slot_info);


    //
    // Write it out
    //
    (void) ScsiPortSetBusDataByOffset(
    (PVOID)asc_dvc,                         // HwDeviceExtension
    PCIConfiguration,                       // Bus type
    (ULONG) ASC_PCI_ID2BUS(asc_dvc->cfg->pci_slot_info), // Bus Number
    SlotNumber.u.AsULONG,                   // Device and function
    &byte_data,                                     // Buffer
        offset,                                 // Offset
        1                                       // Length
        );
}

/*
 * Zero memory starting at 'cp' for 'length' bytes.
 */
VOID
AscZeroMemory(UCHAR *cp, ULONG length)
{
    ULONG i;

    for (i = 0; i < length; i++)
    {
        *cp++ = 0;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\wmidebug.c ===
/*++

Copyright (c) 1999 Microsoft, Inc

Module Name:

    wmi.c

Abstract:

    This is the common source code for WMI debugging support within a NT
    SCSI miniport. This code implements the WMI specific functionality that
    needed and is independent of the miniport that includes it. To include
    the wmi debugging code in a miniport, the miniport must do the following:
        
    1. Create a file (say wmi.c) that includes any headers needed by the
       the miniport and #define PHWDEVEXT to the name for its hardware device 
       extension. One of the headers needs to #define WMI_TEST_CODE to include
       wmi debug code in the build.
           
    2. Include the following before the hardware device extension structure:
        
#ifdef WMI_TEST_CODE

#define MAX_STRING 255

typedef struct
{
    BOOLEAN boolean;
    UCHAR uchar;
    USHORT ushort;
    ULONG ulong;
    ULONGLONG ulonglong;
    CHAR achar;
    SHORT ashort;
    LONG along;
    LONGLONG longlong;
    WCHAR datetime[25];
    USHORT stringlen;
    WCHAR string[MAX_STRING];
} EC1, *PEC1;

typedef struct
{
    BOOLEAN boolean[8];
    UCHAR uchar[8];
    USHORT ushort[4];
    ULONG ulong[2];
    ULONGLONG ulonglong;
    CHAR achar[8];
    SHORT ashort[4];
    LONG along[2];
    LONGLONG longlong;
    WCHAR datetime[25];
    USHORT stringlen;
    WCHAR string[MAX_STRING];
} EC2, *PEC2;

#define WMI_EVENT_BUFFER_SIZE (sizeof(EC2) + 0x40)
#endif
        
           
    3. Include the following within the hardware device extension structure:
        
#ifdef WMI_TEST_CODE    
    SCSI_WMILIB_CONTEXT WmiLibContext;

    ULONG Ec1Count;
    ULONG Ec1Length[4];
    ULONG Ec1ActualLength[4];
    EC1 Ec1[4];
    
    ULONG Ec2Count;
    ULONG Ec2Length[4];
    ULONG Ec2ActualLength[4];
    EC2 Ec2[4];

    UCHAR EventBuffer[WMI_EVENT_BUFFER_SIZE];
#endif

    4. Include the following in the HwDetect routine
#ifdef WMI_TEST_CODE    
    //
    // Enable and initialize WMI
    ConfigInfo->WmiDataProvider = TRUE;
    WmiInitialize(CardPtr);
#endif    

    5. Dispatch wmi srbs to WmiSrb().
        

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#ifdef WMI_TEST_CODE    


BOOLEAN WmiSampSetEc1(
    PHWDEVEXT CardPtr,
    PUCHAR Buffer,
    ULONG Length,
    ULONG Index
    );

BOOLEAN WmiSampSetEc2(
    PHWDEVEXT CardPtr,
    PUCHAR Buffer,
    ULONG Length,
    ULONG Index
    );



#define WmiSampDateTime L"19940525133015.000000-300"

#define Wmi_MofResourceName        L"MofResource"

#define WmiSampleClass1 0
#define WmiSampleClass2 1
#define WmiSampleClass3 2
#define WmiSampleClass4 3
#define WmiSampleClass5 4
#define WmiSampleClass6 5
#define WmiSampleClass7 6
#define WmiGetSetData   7
#define WmiFireEvent    8
#define WmiEventClass1  9
#define WmiEventClass2  10
#define WmiEventClass3  11
#define WmiEventClass4  12
#define WmiEventClass5  13
#define WmiEventClass6  14
#define WmiEventClass7  15

GUID WmiSampleClass1Guid =         { 0x15d851f1, 0x6539, 0x11d1, 0xa5, 0x29, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10 };
GUID WmiSampleClass2Guid =         { 0x15d851f2, 0x6539, 0x11d1, 0xa5, 0x29, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10 };
GUID WmiSampleClass3Guid =         { 0x15d851f3, 0x6539, 0x11d1, 0xa5, 0x29, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10 };
GUID WmiSampleClass4Guid =         { 0x15d851f4, 0x6539, 0x11d1, 0xa5, 0x29, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10 };
GUID WmiSampleClass5Guid =         { 0x15d851f5, 0x6539, 0x11d1, 0xa5, 0x29, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10 };
GUID WmiSampleClass6Guid =         { 0x15d851f6, 0x6539, 0x11d1, 0xa5, 0x29, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10 };
GUID WmiSampleClass7Guid =         { 0x15d851f7, 0x6539, 0x11d1, 0xa5, 0x29, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10 };
GUID WmiGetSetDataGuid =         { 0x15d851f8, 0x6539, 0x11d1, 0xa5, 0x29, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10 };
GUID WmiFireEventGuid =         { 0x15d851f9, 0x6539, 0x11d1, 0xa5, 0x29, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10 };
GUID WmiEventClass1Guid =         { 0x15d851e1, 0x6539, 0x11d1, 0xa5, 0x29, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10 };
GUID WmiEventClass2Guid =         { 0x15d851e2, 0x6539, 0x11d1, 0xa5, 0x29, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10 };
GUID WmiEventClass3Guid =         { 0x15d851e3, 0x6539, 0x11d1, 0xa5, 0x29, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10 };
GUID WmiEventClass4Guid =         { 0x15d851e4, 0x6539, 0x11d1, 0xa5, 0x29, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10 };
GUID WmiEventClass5Guid =         { 0x15d851e5, 0x6539, 0x11d1, 0xa5, 0x29, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10 };
GUID WmiEventClass6Guid =         { 0x15d851e6, 0x6539, 0x11d1, 0xa5, 0x29, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10 };
GUID WmiEventClass7Guid =         { 0x15d851e7, 0x6539, 0x11d1, 0xa5, 0x29, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10 };

SCSIWMIGUIDREGINFO GuidList[] = 
{
    {
        &WmiSampleClass1Guid,
        1,
        0
    },

    {
        &WmiSampleClass2Guid,
        1,
        0
    },

    {
        &WmiSampleClass3Guid,
        1,
        0
    },

    {
        &WmiSampleClass4Guid,
        1,
        0
    },

    {
        &WmiSampleClass5Guid,
        1,
        0
    },

    {
        &WmiSampleClass6Guid,
        1,
        0
    },

    {
        &WmiSampleClass7Guid,
        1,
        0
    },

    {
        &WmiGetSetDataGuid,
        1,
        0
    },

    {
        &WmiFireEventGuid,
        1,
        0
    },

    {
        &WmiEventClass1Guid,
        1,
        WMIREG_FLAG_EVENT_ONLY_GUID
    },

    {
        &WmiEventClass2Guid,
        1,
        WMIREG_FLAG_EVENT_ONLY_GUID
    },

    {
        &WmiEventClass3Guid,
        1,
        WMIREG_FLAG_EVENT_ONLY_GUID
    },

    {
        &WmiEventClass4Guid,
        1,
        WMIREG_FLAG_EVENT_ONLY_GUID
    },

    {
        &WmiEventClass5Guid,
        1,
        WMIREG_FLAG_EVENT_ONLY_GUID
    },

    {
        &WmiEventClass6Guid,
        1,
        WMIREG_FLAG_EVENT_ONLY_GUID
    },

    {
        &WmiEventClass7Guid,
        1,
        WMIREG_FLAG_EVENT_ONLY_GUID
    },

};

#define WmiGuidCount (sizeof(GuidList) / sizeof(SCSIWMIGUIDREGINFO))

UCHAR
QueryWmiDataBlock(
    IN PVOID Context,
    IN PVOID DispatchContext,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG OutBufferSize,
    OUT PUCHAR Buffer
    );

UCHAR
QueryWmiRegInfo(
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT DispatchContext,
    OUT PWCHAR *MofResourceName
    );
        
UCHAR
WmiFunctionControl (
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT DispatchContext,
    IN ULONG GuidIndex,
    IN SCSIWMI_ENABLE_DISABLE_CONTROL Function,
    IN BOOLEAN Enable
    );

UCHAR
WmiExecuteMethod (
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT DispatchContext,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN OUT PUCHAR Buffer
    );

UCHAR
WmiSetDataItem (
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT DispatchContext,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

UCHAR
WmiSetDataBlock (
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT DispatchContext,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

void WmiInitialize(
    IN  PHWDEVEXT CardPtr
    )
{
    PSCSI_WMILIB_CONTEXT WmiLibContext;
    UCHAR Ec[sizeof(EC2) + 11*sizeof(WCHAR)];
    PEC1 Ec1;
    PEC2 Ec2;
    ULONG i;
    
    WmiLibContext = &CardPtr->WmiLibContext;
    
    WmiLibContext->GuidList = GuidList;
    WmiLibContext->GuidCount = WmiGuidCount;
    WmiLibContext->QueryWmiRegInfo = QueryWmiRegInfo;
    WmiLibContext->QueryWmiDataBlock = QueryWmiDataBlock;
    WmiLibContext->WmiFunctionControl = WmiFunctionControl;
    WmiLibContext->SetWmiDataBlock = WmiSetDataBlock;
    WmiLibContext->SetWmiDataItem = WmiSetDataItem;
    WmiLibContext->ExecuteWmiMethod = WmiExecuteMethod;
    
    CardPtr->Ec1Count = 3;
    CardPtr->Ec2Count = 3;
    for (i = 0; i < 4; i++)
    {
        Ec1 = (PEC1)Ec;
        memset(Ec1, i, sizeof(EC1));            
        ScsiPortMoveMemory(Ec1->string, L"EC1-0", 5*sizeof(WCHAR));
        Ec1->stringlen = 10;
        Ec1->string[4] += (USHORT)i;
        ScsiPortMoveMemory(Ec1->datetime, WmiSampDateTime, 25*sizeof(WCHAR));
            
        WmiSampSetEc1(CardPtr,
                      (PUCHAR)Ec1,
                      FIELD_OFFSET(EC1, string) + 10,
                      i);
                  

        Ec2 = (PEC2)Ec;
        memset(Ec2, i, sizeof(EC2));            
        ScsiPortMoveMemory(Ec2->string, L"EC2-0", 5*sizeof(WCHAR));
        Ec2->stringlen = 10;
        Ec2->string[4] += (USHORT)i;
        ScsiPortMoveMemory(Ec2->datetime, WmiSampDateTime, 25*sizeof(WCHAR));
            
        WmiSampSetEc2(CardPtr,
                      (PUCHAR)Ec2,
                      FIELD_OFFSET(EC2, string) + 10,
                      i);
    }
    
}



BOOLEAN
WmiSrb(
    IN     PHWDEVEXT   CardPtr,
    IN OUT PSCSI_WMI_REQUEST_BLOCK Srb
    )
/*++

Routine Description:

   Process an SRB_FUNCTION_WMI request packet.

   This routine is called from the SCSI port driver synchronized with the
   kernel via StartIo.   On completion of WMI processing, the SCSI
   port driver is notified that the adapter can take another request,  if
   any are available.

Arguments:

   HwCardPtr - HBA miniport driver's adapter data storage.

   Srb               - IO request packet.

Return Value:

   Value to return to Aha154xStartIo caller.   Always TRUE.

--*/
{
   UCHAR status;
   SCSIWMI_REQUEST_CONTEXT dc;
   PSCSIWMI_REQUEST_CONTEXT dispatchContext = &dc;
   ULONG retSize;
   BOOLEAN pending;

   //
   // Validate our assumptions.
   //

   ASSERT(Srb->Function == SRB_FUNCTION_WMI);
   ASSERT(Srb->Length == sizeof(SCSI_WMI_REQUEST_BLOCK));
   ASSERT(Srb->DataTransferLength >= sizeof(ULONG));
   ASSERT(Srb->DataBuffer);

   //
   // Only support wmi for the adapter and not disks
   if (!(Srb->WMIFlags & SRB_WMI_FLAGS_ADAPTER_REQUEST)) {
      Srb->DataTransferLength = 0;
      Srb->SrbStatus = SRB_STATUS_SUCCESS;
      return SRB_STATUS_SUCCESS;
   }

   //
   // Process the incoming WMI request.
   //
   dispatchContext->UserContext = Srb;
       
   DebugPrint((1, "ScsiPortWmiDispatchFunction(%x,\n%x,\n%x,\n%x,\n%x,\n%x,\n%x)\n",
       &CardPtr->WmiLibContext,
               Srb->WMISubFunction,
                       CardPtr,
                               dispatchContext,
                                       Srb->DataPath,
                                               Srb->DataTransferLength,
                                                       Srb->DataBuffer));

   pending = ScsiPortWmiDispatchFunction(&CardPtr->WmiLibContext,
                                            Srb->WMISubFunction,
                                            CardPtr,
                                            dispatchContext,
                                            Srb->DataPath,
                                            Srb->DataTransferLength,
                                            Srb->DataBuffer);
                                        
    ASSERT(pending == FALSE);
       
   // We can do this since we assume it is done synchronously
   retSize =  ScsiPortWmiGetReturnSize(dispatchContext);
   status =  ScsiPortWmiGetReturnStatus(dispatchContext);

   DebugPrint((1,"WmiSrb %x completed %d, retsize 0x%x\n", Srb, status, retSize));
                          
   Srb->DataTransferLength = retSize;
          
   //
   // Adapter ready for next request.
   //

   Srb->SrbStatus = status;

   return TRUE;
}

ULONG WmiSampGetEc1(
    PHWDEVEXT CardPtr,
    PUCHAR Buffer,
    ULONG Index
    )
{
    ScsiPortMoveMemory(Buffer, 
                  &CardPtr->Ec1[Index], 
                  CardPtr->Ec1Length[Index]);
              
    return(CardPtr->Ec1Length[Index]);
}

ULONG WmiSampGetActualEc1(
    PHWDEVEXT CardPtr,
    PUCHAR Buffer,
    ULONG Index
    )
{
    ScsiPortMoveMemory(Buffer, 
                  &CardPtr->Ec1[Index], 
                  CardPtr->Ec1ActualLength[Index]);
              
    return(CardPtr->Ec1ActualLength[Index]);
}

BOOLEAN WmiSampSetEc1(
    PHWDEVEXT CardPtr,
    PUCHAR Buffer,
    ULONG Length,
    ULONG Index
    )
{
    PEC1 New;
    ULONG NewLength;
    
    NewLength = (Length + 7) & ~7;
    
    if (NewLength > sizeof(EC1))
    {
        return(FALSE);
    }
    
    CardPtr->Ec1Length[Index] = NewLength;
    CardPtr->Ec1ActualLength[Index] = Length;
    ScsiPortMoveMemory(&CardPtr->Ec1[Index], 
                  Buffer, 
                  Length);
              
    return(TRUE);
}

ULONG WmiSampGetEc2(
    PHWDEVEXT CardPtr,
    PUCHAR Buffer,
    ULONG Index
    )
{
    ScsiPortMoveMemory(Buffer, 
                  &CardPtr->Ec2[Index], 
                  CardPtr->Ec2Length[Index]);
              
    return(CardPtr->Ec2Length[Index]);
}

ULONG WmiSampGetActualEc2(
    PHWDEVEXT CardPtr,
    PUCHAR Buffer,
    ULONG Index
    )
{
    ScsiPortMoveMemory(Buffer, 
                  &CardPtr->Ec2[Index], 
                  CardPtr->Ec2ActualLength[Index]);
              
    return(CardPtr->Ec2ActualLength[Index]);
}

BOOLEAN WmiSampSetEc2(
    PHWDEVEXT CardPtr,
    PUCHAR Buffer,
    ULONG Length,
    ULONG Index
    )
{
    PEC2 New;
    ULONG NewLength;
    
    NewLength = (Length + 7) & ~7;
    
    if (NewLength > sizeof(EC2))
    {
        return(FALSE);
    }
    
    CardPtr->Ec2Length[Index] = NewLength;
    CardPtr->Ec2ActualLength[Index] = Length;
    ScsiPortMoveMemory(&CardPtr->Ec2[Index], 
                  Buffer, 
                  Length);
    return(TRUE);
}



BOOLEAN
QueryWmiDataBlock(
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT DispatchContext,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    )
{
    PHWDEVEXT CardPtr = (PHWDEVEXT)Context;
    UCHAR status;
    ULONG i;
    ULONG sizeNeeded;
    ULONG sizeUsed;
    ULONG vlSize;

    //
    // Only ever registers 1 instance per guid
    ASSERT((InstanceIndex == 0) &&
           (InstanceCount == 1));

    DebugPrint((1, "QueryWmiDataBlock (%x,\n%x,\n%x,\n%x,\n%x,\n%x,\n%x,\n%x,\n",
        Context,
        DispatchContext,
        GuidIndex,
        InstanceIndex,
        InstanceCount,
                InstanceLengthArray,
        BufferAvail,
        Buffer));
    
    switch(GuidIndex)
    {
        case WmiSampleClass1:
        case WmiSampleClass2:
        case WmiEventClass1:
        case WmiEventClass2:
        {
            // plain EC1
            sizeNeeded = CardPtr->Ec1Length[0];
            if (BufferAvail < sizeNeeded)
            {
                status = SRB_STATUS_DATA_OVERRUN;
            } else {
                *InstanceLengthArray = sizeNeeded;
                WmiSampGetEc1(CardPtr, Buffer, 0);
                status =  SRB_STATUS_SUCCESS;
            }
            break;
        }
        
        case WmiSampleClass3:
        case WmiEventClass3:
        {
            // fixed array of EC1
            sizeNeeded = 0;
            for (i = 0; i < 4; i++)
            {
                //
                // Embedded classes must be naturally aligned, but we
                // maintain naturally aligned lengths not acttual lengths
                sizeNeeded += CardPtr->Ec1Length[i];
            }
            
            if (BufferAvail < sizeNeeded)
            {
                status = SRB_STATUS_DATA_OVERRUN;
            } else {
                *InstanceLengthArray = sizeNeeded;
                for (i = 0; i < 4; i++)
                {
                    sizeUsed = WmiSampGetEc1(CardPtr, Buffer, i);
                    Buffer += sizeUsed;
                }
                status =  SRB_STATUS_SUCCESS;
            }
            break;
        }
        
        case WmiSampleClass4:
        case WmiEventClass4:
        {
            // variable array of EC1
            sizeNeeded = (sizeof(ULONG) + 7) & ~7;
            vlSize = CardPtr->Ec1Count;
            ASSERT(vlSize <= 4);
            for (i = 0; i < vlSize; i++)
            {
                sizeNeeded += CardPtr->Ec1Length[i];
            }
            
            if (BufferAvail < sizeNeeded)
            {
                status = SRB_STATUS_DATA_OVERRUN;
            } else {
                *InstanceLengthArray = sizeNeeded;
                *((PULONG)Buffer) = vlSize;
                Buffer += (sizeof(ULONG) + 7) & ~7;
                for (i = 0; i < vlSize; i++)
                {
                    sizeUsed = WmiSampGetEc1(CardPtr, Buffer, i);
                    Buffer += sizeUsed;
                }
                status =  SRB_STATUS_SUCCESS;
            }
            break;
        }
        
        case WmiSampleClass5:
        case WmiEventClass5:
        {
            // plain EC2
            sizeNeeded = CardPtr->Ec2Length[0];
            if (BufferAvail < sizeNeeded)
            {
                status = SRB_STATUS_DATA_OVERRUN;
            } else {
                *InstanceLengthArray = sizeNeeded;
                WmiSampGetEc2(CardPtr, Buffer, 0);
                status =  SRB_STATUS_SUCCESS;
            }
            break;
        }
        
        case WmiSampleClass6:
        case WmiEventClass6:
        {
            // fixed array EC2
            sizeNeeded = 0;
            for (i = 0; i < 4; i++)
            {
                sizeNeeded += CardPtr->Ec2Length[i];
            }
            
            if (BufferAvail < sizeNeeded)
            {
                status = SRB_STATUS_DATA_OVERRUN;
            } else {
                *InstanceLengthArray = sizeNeeded;
                for (i = 0; i < 4; i++)
                {
                    sizeUsed = WmiSampGetEc2(CardPtr, Buffer, i);
                    Buffer += sizeUsed;
                }
                status =  SRB_STATUS_SUCCESS;
            }
            break;
        }
        
        case WmiSampleClass7:
        case WmiEventClass7:
        {
            // VL array EC2
            sizeNeeded = (sizeof(ULONG) + 7) & ~7;
            vlSize = CardPtr->Ec2Count;
            for (i = 0; i < vlSize; i++)
            {
                sizeNeeded += CardPtr->Ec2Length[i];
            }
            
            if (BufferAvail < sizeNeeded)
            {
                status = SRB_STATUS_DATA_OVERRUN;
            } else {
                *InstanceLengthArray = sizeNeeded;
                *((PULONG)Buffer) = vlSize;
                Buffer += (sizeof(ULONG)+7) & ~7;
                for (i = 0; i < vlSize; i++)
                {
                    sizeUsed = WmiSampGetEc2(CardPtr, Buffer, i);
                    Buffer += sizeUsed;
                }
                status =  SRB_STATUS_SUCCESS;
            }
            break;
        }
        
        case WmiFireEvent:
        case WmiGetSetData:
        {
            // return no data
            sizeNeeded = sizeof(USHORT);
            if (BufferAvail < sizeNeeded)
            {
                status = SRB_STATUS_DATA_OVERRUN;
            } else {
                *InstanceLengthArray = sizeNeeded;
                status =  SRB_STATUS_SUCCESS;
            }
            break;
        }
    
        default:
        {
            status = SRB_STATUS_ERROR;
            break;
        }
    }

    ScsiPortWmiPostProcess(
                                  DispatchContext,
                                  status,
                                  sizeNeeded);

    return FALSE;
}

UCHAR
QueryWmiRegInfo(
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT DispatchContext,
    OUT PWCHAR *MofResourceName
    )
{
    *MofResourceName = Wmi_MofResourceName;    
    return SRB_STATUS_SUCCESS;
}

UCHAR WmiSampSetEc1Worker(
    PHWDEVEXT CardPtr,
    ULONG BufferSize,
    ULONG Index,
    PUCHAR Buffer,
    PULONG BufferUsed
    )
{
    ULONG blockLen;
    UCHAR status;
    PEC1 Ec1;
    
    Ec1 = (PEC1)Buffer;
    if (BufferSize >= FIELD_OFFSET(EC1, string))
    {
        blockLen = FIELD_OFFSET(EC1, string) + Ec1->stringlen;
                
        if (blockLen <= BufferSize)
        {
            if (! WmiSampSetEc1(CardPtr,
                            Buffer,
                            blockLen,
                            Index))
            {
                return(SRB_STATUS_ERROR);
            }
            *BufferUsed = (blockLen+7) & ~7;
            status = SRB_STATUS_SUCCESS;
        } else {
            DebugPrint((1,"Set EC1 buffer too small\n"));
            status = SRB_STATUS_ERROR;
        }                
    } else {
        DebugPrint((1,"Set EC1 buffer size wrong %d\n", BufferSize));
        status = SRB_STATUS_ERROR;
    }
    return(status);
}

UCHAR WmiSampSetEc2Worker(
    PHWDEVEXT CardPtr,
    ULONG BufferSize,
    ULONG Index,
    PUCHAR Buffer,
    PULONG BufferUsed
    )
{
    ULONG blockLen;
    UCHAR status;
    PUSHORT wPtr;
    PEC2 Ec2;
    
    Ec2 = (PEC2)Buffer;
    if (BufferSize >= FIELD_OFFSET(EC2, string))
    {
        blockLen = FIELD_OFFSET(EC2, string) + Ec2->stringlen;
                
        if (blockLen <= BufferSize)
        {
            if (! WmiSampSetEc2(CardPtr,
                            Buffer,
                            blockLen,
                            Index))
            {
                return(SRB_STATUS_ERROR);
            }
            *BufferUsed = (blockLen+7) & ~7;
            status = SRB_STATUS_SUCCESS;
        } else {
            DebugPrint((1,"Set EC2 buffer too small\n"));
            status = SRB_STATUS_ERROR;
        }                
    } else {
        DebugPrint((1,"Set EC2 buffer size wrong %d\n", BufferSize));
        status = SRB_STATUS_ERROR;
    }
    return(status);
}


BOOLEAN
WmiSetDataBlock (
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT DispatchContext,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
{
    PHWDEVEXT CardPtr = (PHWDEVEXT)Context;
    UCHAR status;
    ULONG bufferUsed;
    ULONG i;
    ULONG vlSize;

    DebugPrint((1, "WmiSetDataBlock(%x,\n%x,\n%x,\n%x,\n%x,\n%x)\n",
        Context,
            DispatchContext,
                GuidIndex,
                    InstanceIndex,
                        BufferSize,
                             Buffer));

                         
    switch(GuidIndex)
    {
        case WmiSampleClass1:
        case WmiSampleClass2:
        {
            // plain EC1
            status = WmiSampSetEc1Worker(CardPtr,
                                         BufferSize,
                                         0,
                                         Buffer,
                                         &bufferUsed);
            break;
        }
        
        case WmiSampleClass3:
        {
            // fixed array of EC1
             
            for (i = 0, status = SRB_STATUS_SUCCESS; 
                 (i < 4) && (status == SRB_STATUS_SUCCESS); i++)
            {
                status = WmiSampSetEc1Worker(CardPtr,
                                             BufferSize,
                                             i,
                                             Buffer,
                                             &bufferUsed);
                Buffer += bufferUsed;
                BufferSize -= bufferUsed;
            }
            break;
        }
        
        case WmiSampleClass4:
        {
            // variable array of EC1

            if (BufferSize >= ((sizeof(ULONG) +7) & ~7))
            {
                vlSize = *((PULONG)Buffer);
                Buffer += ((sizeof(ULONG) +7) & ~7);
                
                if ((vlSize >= 1) && (vlSize <= 4))
                {
                    for (i = 0, status = SRB_STATUS_SUCCESS; 
                         (i < vlSize) && (status == SRB_STATUS_SUCCESS); i++)
                    {
                        status = WmiSampSetEc1Worker(CardPtr,
                                             BufferSize,
                                                 i,
                                             Buffer,
                                                 &bufferUsed);
                        Buffer += bufferUsed;
                        BufferSize -= bufferUsed;
                    }
                    if (status == SRB_STATUS_SUCCESS)
                    {
                        CardPtr->Ec1Count = vlSize;
                    }
                } else {
                    DebugPrint((1,"SetEc1 only up to [4] allowed, not %d\n",
                            vlSize));
                    status = SRB_STATUS_ERROR;
                }
            } else {
                DebugPrint((1,"SetEc1 size too small\n"));
                status = SRB_STATUS_ERROR;
            }
                
            break;
        }
        
        case WmiSampleClass5:
        {
            // plain EC2
            status = WmiSampSetEc2Worker(CardPtr,
                                         BufferSize,
                                             0,
                                         Buffer,
                                         &bufferUsed);
            break;
        }
        
        case WmiSampleClass6:
        {
            // fixed array EC2
            for (i = 0, status = SRB_STATUS_SUCCESS; 
                 (i < 4) && (status == SRB_STATUS_SUCCESS); i++)
            {
                status = WmiSampSetEc2Worker(CardPtr,
                                             BufferSize,
                                                 i,
                                             Buffer,
                                             &bufferUsed);
                Buffer += bufferUsed;
                BufferSize -= bufferUsed;
            }
            break;
        }
        
        case WmiSampleClass7:
        {
            // VL array EC2
            if (BufferSize >= sizeof(ULONG))
            {
                vlSize = *((PULONG)Buffer);
                Buffer += (sizeof(ULONG) +7) & ~7;
                if ((vlSize >= 1) && (vlSize <= 4))
                {
                    for (i = 0, status = SRB_STATUS_SUCCESS; 
                         (i < vlSize) && (status == SRB_STATUS_SUCCESS); i++)
                    {
                        status = WmiSampSetEc2Worker(CardPtr,
                                             BufferSize,
                                                 i,
                                             Buffer,
                                             &bufferUsed);
                        Buffer += bufferUsed;
                        BufferSize -= bufferUsed;
                    }
                    if (status == SRB_STATUS_SUCCESS)
                    {
                        CardPtr->Ec1Count = vlSize;
                    }
                } else {
                    DebugPrint((1,"SetEc2 only up to [4] allowed, not %d\n",
                            vlSize));
                    status = SRB_STATUS_ERROR;
                }
            } else {
                DebugPrint((1,"SetEc2 size too small\n"));
                status = SRB_STATUS_ERROR;
            }
                
            break;
        }
        
        default:
        {
            status = SRB_STATUS_ERROR;
            break;
        }
    }
                         
                                             
    ScsiPortWmiPostProcess(
                                  DispatchContext,
                                  status,
                                  0);
    return(FALSE);    
}

BOOLEAN
WmiSetDataItem (
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT DispatchContext,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
{
    UCHAR status;
    
    DebugPrint((1, "WmiSetDataItem(%x,\n%x,\n%x,\n%x,\n%x,\n%x,\n%x)\n",
        Context,
            DispatchContext,
                GuidIndex,
                    InstanceIndex,
                        DataItemId,
                        BufferSize,
                             Buffer));
    switch(GuidIndex)
    {
        case WmiSampleClass1:
        case WmiSampleClass2:
        case WmiSampleClass3:
        case WmiSampleClass4:
        case WmiSampleClass5:
        case WmiSampleClass6:
        case WmiSampleClass7:
        {
            status = SRB_STATUS_ERROR;
            break;
        }
        
        
        default:
        {
            status = SRB_STATUS_ERROR;
            break;
        }
    }

     ScsiPortWmiPostProcess(
                                  DispatchContext,
                                  status,
                                  0);

    return(FALSE);    
}

UCHAR WmiSampFireEvent(
    PHWDEVEXT CardPtr,
    ULONG WnodeType,  // 0 - AllData, 1 - Single Instance
    ULONG DataType,   // 1 - 7 is guid id
    ULONG BlockIndex  // 0 - 3 is block index containing data
    )
{
    PWNODE_HEADER Wnode;
    PWNODE_EVENT_REFERENCE WnodeER;
    ULONG dataSize;
    LPGUID Guid;
    UCHAR status;
    ULONG sizeNeeded;
    
    
    if (BlockIndex > 3)
    {
        return(SRB_STATUS_ERROR);
    }
    
    switch(DataType)
    {
        case 1:
        {
            // EC1
            dataSize = CardPtr->Ec1Length[BlockIndex];
            Guid = &WmiEventClass1Guid;
            break;
        }
        
        case 2:
        {
            // EC1 (embedded)
            dataSize = CardPtr->Ec1Length[BlockIndex];
            Guid = &WmiEventClass2Guid;
            break;
        }
                
        case 5:
        {
            // EC2 (embedded)
            dataSize = CardPtr->Ec2Length[BlockIndex];
            Guid = &WmiEventClass5Guid;
            break;
        }
        

        default:
        {
            return(SRB_STATUS_ERROR);
        }
    }
    
    Wnode = (PWNODE_HEADER)CardPtr->EventBuffer;
    
    sizeNeeded = sizeof(WNODE_EVENT_REFERENCE);

    if (sizeNeeded > WMI_EVENT_BUFFER_SIZE)
    {
        ASSERT(FALSE);
        return(SRB_STATUS_ERROR);
    }
        
    Wnode->Flags =  WNODE_FLAG_EVENT_ITEM |
                    WNODE_FLAG_EVENT_REFERENCE |
                    WNODE_FLAG_STATIC_INSTANCE_NAMES;
    WnodeER = (PWNODE_EVENT_REFERENCE)Wnode;
    WnodeER->TargetGuid = *Guid;
    WnodeER->TargetDataBlockSize = dataSize + sizeof(WNODE_SINGLE_INSTANCE);
    WnodeER->TargetInstanceIndex = 0;
    
    Wnode->Guid = *Guid;
    Wnode->BufferSize = sizeNeeded;
    
    ScsiPortNotification(WMIEvent,
                         CardPtr,
                         Wnode,
                         0xff);
    
    return(SRB_STATUS_SUCCESS);    
}


BOOLEAN
WmiExecuteMethod (
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT DispatchContext,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG BufferAvail,
    IN OUT PUCHAR Buffer
    )
{
    PHWDEVEXT CardPtr = (PHWDEVEXT)Context;
    ULONG sizeNeeded = 0;
    UCHAR status;
    PSCSI_REQUEST_BLOCK srb = (PSCSI_REQUEST_BLOCK)(DispatchContext->UserContext);
    ULONG bufferUsed;
    ULONG blockIndex;
    ULONG UlongPadSize = (sizeof(ULONG) + 7) & ~7;
    
    DebugPrint((1, "WmiExecuteMethod(%x,\n%x,\n%x,\n%x,\n%x,\n%x,\n%x,\n%x)\n",
        Context,
            DispatchContext,
                GuidIndex,
                    InstanceIndex,
                        MethodId,
                        InBufferSize,
                        BufferAvail,
                             Buffer));
                         
                         
    if (GuidIndex == WmiGetSetData)
    {
        switch(MethodId)
        {
            case 1:
            case 7:
            {
                // SetEc1                    

                if (InBufferSize < UlongPadSize)
                {
                    status = SRB_STATUS_ERROR;
                    sizeNeeded = 0;
                    break;
                } else {
                    blockIndex = *((PULONG)Buffer);
                    if (blockIndex > 3)
                    {
                        status = SRB_STATUS_ERROR;
                        break;                        
                    }
                    Buffer += UlongPadSize;
                    InBufferSize -= UlongPadSize;
                }                
                
                status = WmiSampSetEc1Worker(CardPtr,
                                         InBufferSize,
                                             blockIndex,
                                         Buffer,
                                         &bufferUsed);
                sizeNeeded = 0;
                break;
            }
            
            case 2:
            case 8:
            {
                // SetEc2

                if (InBufferSize < UlongPadSize)
                {
                    status = SRB_STATUS_ERROR;
                    sizeNeeded = 0;
                    break;
                } else {
                    blockIndex = *((PULONG)Buffer);
                    if (blockIndex > 3)
                    {
                        status = SRB_STATUS_ERROR;
                        break;                        
                    }
                    Buffer += UlongPadSize;
                    InBufferSize -= UlongPadSize;
                }                
                
                status = WmiSampSetEc2Worker(CardPtr,
                                         InBufferSize,
                                             blockIndex,
                                         Buffer,
                                         &bufferUsed);
                sizeNeeded = 0;
                break;
            }
            
            case 3:
            case 9:
            {
                // GetEc1
                    
                if (InBufferSize != sizeof(ULONG))
                {
                    status = SRB_STATUS_ERROR;
                    sizeNeeded = 0;
                    break;
                } else {
                    blockIndex = *((PULONG)Buffer);
                    if (blockIndex > 3)
                    {
                        status = SRB_STATUS_ERROR;
                        break;                        
                    }
                }                
                
                sizeNeeded = CardPtr->Ec1ActualLength[blockIndex];
                if (BufferAvail < sizeNeeded)
                {
                    status = SRB_STATUS_DATA_OVERRUN;
                } else {
                    WmiSampGetActualEc1(CardPtr, Buffer, blockIndex);
                    status = SRB_STATUS_SUCCESS;
                }
                break;
            }
            
            case 4:
            case 10:
            {
                // GetEc2
                if (InBufferSize != sizeof(ULONG))
                {
                    status = SRB_STATUS_ERROR;
                    sizeNeeded = 0;
                    break;
                } else {
                    blockIndex = *((PULONG)Buffer);
                    if (blockIndex > 3)
                    {
                        status = SRB_STATUS_ERROR;
                        break;                        
                    }
                }                
                
                sizeNeeded = CardPtr->Ec2ActualLength[blockIndex];
                if (BufferAvail < sizeNeeded)
                {
                    status = SRB_STATUS_DATA_OVERRUN;
                } else {
                    WmiSampGetActualEc2(CardPtr, Buffer, blockIndex);
                    status = SRB_STATUS_SUCCESS;
                }
                break;
            }
           
	    
    	    case 13:
	        {
                ScsiPortNotification(WMIReregister,
                         CardPtr,
                         0xff);
                 status = SRB_STATUS_SUCCESS;
				 sizeNeeded = 0;				 
		        break;
    	    }
	    
            case 5:
            case 11:            
            case 6:
            case 12:
            default: 
            {
                status = SRB_STATUS_ERROR;
            }
        }
    } else if (GuidIndex == WmiFireEvent) {
        if (MethodId == 1)
        {
            if (InBufferSize == 3*sizeof(ULONG))
            {
                ULONG wnodeType;
                ULONG dataType;
                ULONG blockIndex;
                
                wnodeType = *(PULONG)Buffer;
                Buffer += sizeof(ULONG);
                
                dataType = *(PULONG)Buffer;
                Buffer += sizeof(ULONG);
                
                blockIndex = *(PULONG)Buffer;
                Buffer += sizeof(ULONG);
                
                status = WmiSampFireEvent(CardPtr,
                                 wnodeType,
                                 dataType,
                                 blockIndex);
                             
                sizeNeeded = 0;

            } else {
                status = SRB_STATUS_ERROR;
            }
        } else {
            status = SRB_STATUS_ERROR;
        }
    } else  {
        status = SRB_STATUS_ERROR;
    }
    
    ScsiPortWmiPostProcess(
                                  DispatchContext,
                                  status,
                                  sizeNeeded);

    return(FALSE);    
}

BOOLEAN
WmiFunctionControl (
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT DispatchContext,
    IN ULONG GuidIndex,
    IN SCSIWMI_ENABLE_DISABLE_CONTROL Function,
    IN BOOLEAN Enable
    )
{
    UCHAR status = SRB_STATUS_SUCCESS;

    //
    // TODO: Verify that expensive guids are being enbled and inexpensive ones
    //       are not, same with events
    DebugPrint((1, "WmiFunctionControl(%x,\n%x,\n%x,\n%x,\n%x)\n\n",
        Context,
            DispatchContext,
                GuidIndex,
                    Function,
                             Enable));
                                 

    ScsiPortWmiPostProcess(
                                  DispatchContext,
                                  status,
                                  0);

    return(FALSE);    
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc\asc1000.h ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** Filename: asc1000.h
**
*/

#ifndef __ASC1000_H_
#define __ASC1000_H_

#include "ascdep.h"

#define ASC_EXE_SCSI_IO_MAX_IDLE_LOOP  0x1000000UL
#define ASC_EXE_SCSI_IO_MAX_WAIT_LOOP  1024


/*
** error code of asc_dvc->err_code
*/
#define ASCQ_ERR_NO_ERROR             0     /* */
#define ASCQ_ERR_IO_NOT_FOUND         1     /* */
#define ASCQ_ERR_LOCAL_MEM            2     /* */
#define ASCQ_ERR_CHKSUM               3     /* */
#define ASCQ_ERR_START_CHIP           4     /* */
#define ASCQ_ERR_INT_TARGET_ID        5     /* */
#define ASCQ_ERR_INT_LOCAL_MEM        6     /* */
#define ASCQ_ERR_HALT_RISC            7     /* */
#define ASCQ_ERR_GET_ASPI_ENTRY       8     /* */
#define ASCQ_ERR_CLOSE_ASPI           9     /* */
#define ASCQ_ERR_HOST_INQUIRY         0x0A  /* */
#define ASCQ_ERR_SAVED_SRB_BAD        0x0B  /* */
#define ASCQ_ERR_QCNTL_SG_LIST        0x0C  /* */
#define ASCQ_ERR_Q_STATUS             0x0D  /* */
#define ASCQ_ERR_WR_SCSIQ             0x0E  /* */
#define ASCQ_ERR_PC_ADDR              0x0F  /* */
#define ASCQ_ERR_SYN_OFFSET           0x10  /* */
#define ASCQ_ERR_SYN_XFER_TIME        0x11  /* */
#define ASCQ_ERR_LOCK_DMA             0x12  /* */
#define ASCQ_ERR_UNLOCK_DMA           0x13  /* */
#define ASCQ_ERR_VDS_CHK_INSTALL      0x14  /* */
#define ASCQ_ERR_MICRO_CODE_HALT      0x15  /* unknown halt error code */
#define ASCQ_ERR_SET_LRAM_ADDR        0x16  /* */
#define ASCQ_ERR_CUR_QNG              0x17  /* */
#define ASCQ_ERR_SG_Q_LINKS           0x18  /* */
#define ASCQ_ERR_SCSIQ_PTR            0x19  /* */
#define ASCQ_ERR_ISR_RE_ENTRY         0x1A  /* */
#define ASCQ_ERR_CRITICAL_RE_ENTRY    0x1B  /* */
#define ASCQ_ERR_ISR_ON_CRITICAL      0x1C  /* */
#define ASCQ_ERR_SG_LIST_ODD_ADDRESS  0x1D  /* */
#define ASCQ_ERR_XFER_ADDRESS_TOO_BIG 0x1E  /* */
#define ASCQ_ERR_SCSIQ_NULL_PTR       0x1F  /* */
#define ASCQ_ERR_SCSIQ_BAD_NEXT_PTR   0x20  /* */
#define ASCQ_ERR_GET_NUM_OF_FREE_Q    0x21  /* */
#define ASCQ_ERR_SEND_SCSI_Q          0x22  /* */
#define ASCQ_ERR_HOST_REQ_RISC_HALT   0x23  /* */
#define ASCQ_ERR_RESET_SDTR           0x24  /* */

/*
** AscInitGetConfig() and AscInitAsc1000Driver()
** return values
*/
#define ASC_WARN_NO_ERROR             0x0000 /* there is no warning */
#define ASC_WARN_IO_PORT_ROTATE       0x0001 /* i/o port addrsss modified */
#define ASC_WARN_EEPROM_CHKSUM        0x0002 /* EEPROM check sum error */
#define ASC_WARN_IRQ_MODIFIED         0x0004 /* IRQ number is modified */
#define ASC_WARN_AUTO_CONFIG          0x0008 /* auto i/o port rotation is on, available after chip version 3 */
#define ASC_WARN_CMD_QNG_CONFLICT     0x0010 /* tag queuing without enabled */
                                             /* disconnection */
#define ASC_WARN_EEPROM_RECOVER       0x0020 /* eeprom data recovery attempted */
#define ASC_WARN_CFG_MSW_RECOVER      0x0040 /* cfg register recover attempted */
#define ASC_WARN_SET_PCI_CONFIG_SPACE 0x0080 /* DvcWritePCIConfigByte() not working */

/*
** AscInitGetConfig() and AscInitAsc1000Driver()
** Init Fatal error code in variable asc_dvc->err_code
*/
#define ASC_IERR_WRITE_EEPROM         0x0001 /* write EEPROM error */
#define ASC_IERR_MCODE_CHKSUM         0x0002 /* micro code check sum error */
#define ASC_IERR_SET_PC_ADDR          0x0004 /* set program counter error */
#define ASC_IERR_START_STOP_CHIP      0x0008 /* start/stop chip failed */
                                             /* probably SCSI flat cable reversed */
#define ASC_IERR_IRQ_NO               0x0010 /* this error will reset irq to */
                                             /* ASC_DEF_IRQ_NO */
#define ASC_IERR_SET_IRQ_NO           0x0020 /* this error will reset irq to */
#define ASC_IERR_CHIP_VERSION         0x0040 /* wrong chip version */
#define ASC_IERR_SET_SCSI_ID          0x0080 /* set SCSI ID failed */
#define ASC_IERR_GET_PHY_ADDR         0x0100 /* get physical address */
#define ASC_IERR_BAD_SIGNATURE        0x0200 /* signature not found, i/o port address may be wrong */
#define ASC_IERR_NO_BUS_TYPE          0x0400 /* bus type field no set */
#define ASC_IERR_SCAM                 0x0800
#define ASC_IERR_SET_SDTR             0x1000
#define ASC_IERR_RW_LRAM              0x8000 /* read/write local RAM error */


/*
** IRQ setting
*/
#define ASC_DEF_IRQ_NO  10   /* minimum IRQ number */
#define ASC_MAX_IRQ_NO  15   /* maximum IRQ number */
#define ASC_MIN_IRQ_NO  10   /* default IRQ number */

/*
** number of queue(s)
*/
#define ASC_MIN_REMAIN_Q        (0x02) /* minimum number of queues remained in main queue links */
#define ASC_DEF_MAX_TOTAL_QNG   (0xF0) /* default total number of queues */
/* #define ASC_DEF_MAX_SINGLE_QNG  (0x02) default number of queued command per device */
#define ASC_MIN_TAG_Q_PER_DVC   (0x04)
#define ASC_DEF_TAG_Q_PER_DVC   (0x04)

/*
** minimum total number of queues
*/
/* #define ASC_MIN_FREE_Q        (( ASC_MAX_SG_QUEUE )+( ASC_MIN_REMAIN_Q )) */
#define ASC_MIN_FREE_Q        ASC_MIN_REMAIN_Q

#define ASC_MIN_TOTAL_QNG     (( ASC_MAX_SG_QUEUE )+( ASC_MIN_FREE_Q )) /* we must insure that a urgent queue with sg list can go through */
/* #define ASC_MIN_TOTAL_QNG  ( (2)+ASC_MIN_FREE_Q ) */ /* for testing 12 queue only */

/*
** the following depends on chip version
*/
#define ASC_MAX_TOTAL_QNG 240 /* maximum total number of queues */
#define ASC_MAX_PCI_ULTRA_INRAM_TOTAL_QNG 16 /* maximum total number of queues without external RAM */
                                             /* with ucode size 2.5KB */
#define ASC_MAX_PCI_ULTRA_INRAM_TAG_QNG   8  /* maximum total number of tagged queues without external RAM */
#define ASC_MAX_PCI_INRAM_TOTAL_QNG  20  /* maximum total number of queues without external RAM */
                                        /* with ucode size 2.5KB */
#define ASC_MAX_INRAM_TAG_QNG   16      /* maximum total number of tagged queues without external RAM */

/*
** default I/O port addresses
*/
/* #define ASC_IOADR_NO    8  */   /* number of default addresses to rotate */
#define ASC_IOADR_TABLE_MAX_IX  11  /* io port default addresses for ISA(PNP) and VL */
#define ASC_IOADR_GAP   0x10     /* io address register space */
#define ASC_SEARCH_IOP_GAP 0x10  /*                        */
#define ASC_MIN_IOP_ADDR   ( PortAddr )0x0100 /* minimum io address */
#define ASC_MAX_IOP_ADDR   ( PortAddr )0x3F0  /*                        */

#define ASC_IOADR_1     ( PortAddr )0x0110
#define ASC_IOADR_2     ( PortAddr )0x0130
#define ASC_IOADR_3     ( PortAddr )0x0150
#define ASC_IOADR_4     ( PortAddr )0x0190
#define ASC_IOADR_5     ( PortAddr )0x0210
#define ASC_IOADR_6     ( PortAddr )0x0230
#define ASC_IOADR_7     ( PortAddr )0x0250
#define ASC_IOADR_8     ( PortAddr )0x0330
#define ASC_IOADR_DEF   ASC_IOADR_8  /* the default BIOS address */

/*
**
**
**
*/

#define ASC_LIB_SCSIQ_WK_SP        256   /* for library scsiq and data buffer working space */
#define ASC_MAX_SYN_XFER_NO        16
/* #define ASC_SYN_XFER_NO            8 , removed since S89, use asc_dvc->max_sdtr_index instead */
/* #define ASC_MAX_SDTR_PERIOD_INDEX  7   */  /* maximum sdtr peroid index */
#define ASC_SYN_MAX_OFFSET         0x0F  /* maximum sdtr offset */
#define ASC_DEF_SDTR_OFFSET        0x0F  /* default sdtr offset */
#define ASC_DEF_SDTR_INDEX         0x00  /* default sdtr period index */
#define ASC_SDTR_ULTRA_PCI_10MB_INDEX  0x02  /* ultra PCI 10mb/sec sdtr index */

#if 1
/* syn xfer time, in nanosecond, for 50M HZ clock */
#define SYN_XFER_NS_0  25  /* 25=0x19 100 ns  10MB/SEC, fast SCSI */
#define SYN_XFER_NS_1  30  /* 30=0x1E 120 ns  8.3MB/sec           */
#define SYN_XFER_NS_2  35  /* 35=0x23 140 ns  7.2MB/sec           */
#define SYN_XFER_NS_3  40  /* 40=0x28 160 ns  6.25MB/sec          */
#define SYN_XFER_NS_4  50  /* 50=0x32 200 ns, 5MB/SEC normal use  */
#define SYN_XFER_NS_5  60  /* 60=0x3C 240 ns  4.16MB/sec          */
#define SYN_XFER_NS_6  70  /* 70=0x46 280 ns  3.6.MB/sec          */
#define SYN_XFER_NS_7  85  /* 85=0x55 340 ns  3MB/sec             */
#else
/* syn xfer time, in nanosecond, for 33M HZ clock */
#define SYN_XFER_NS_0  38  /* 38=0x26 152 ns             */
#define SYN_XFER_NS_1  45  /* 45=0x2D 180 ns             */
#define SYN_XFER_NS_2  53  /* 53=0x35 ns                 */
#define SYN_XFER_NS_3  60  /* 60=0x3C ns                 */
#define SYN_XFER_NS_4  75  /* 75=0x4B ns                 */
#define SYN_XFER_NS_5  90  /* 90=0x5A ns normal use      */
#define SYN_XFER_NS_6  105 /* 105=0x69 ns                */
#define SYN_XFER_NS_7  128 /* 128=0x80 ns                */
#endif

                                   /* at 40MHZ clock */
#define SYN_ULTRA_XFER_NS_0    12  /* 50  ns 20.0 MB/sec, at SCSI 12 is 48ns, 13 is 52ns */
#define SYN_ULTRA_XFER_NS_1    19  /* 75  ns 13.3 MB/sec            */
#define SYN_ULTRA_XFER_NS_2    25  /* 100 ns 10.0 MB/sec            */
#define SYN_ULTRA_XFER_NS_3    32  /* 125 ns 8.00 MB/sec            */
#define SYN_ULTRA_XFER_NS_4    38  /* 150 ns 6.67 MB/SEC            */
#define SYN_ULTRA_XFER_NS_5    44  /* 175 ns 5.71 MB/sec            */
#define SYN_ULTRA_XFER_NS_6    50  /* 200 ns 5.00 MB/sec            */
#define SYN_ULTRA_XFER_NS_7    57  /* 225 ns 4.44 MB/sec            */
#define SYN_ULTRA_XFER_NS_8    63  /* 250 ns 4.00 MB/sec            */
#define SYN_ULTRA_XFER_NS_9    69  /* 275 ns 3.64 MB/sec            */
#define SYN_ULTRA_XFER_NS_10   75  /* 300 ns 3.33 MB/sec            */
#define SYN_ULTRA_XFER_NS_11   82  /* 325 ns 3.08 MB/sec            */
#define SYN_ULTRA_XFER_NS_12   88  /* 350 ns 2.86 MB/sec            */
#define SYN_ULTRA_XFER_NS_13   94  /* 375 ns 2.67 MB/sec            */
#define SYN_ULTRA_XFER_NS_14  100  /* 400 ns 2.50 MB/sec            */
#define SYN_ULTRA_XFER_NS_15  107  /* 425 ns 2.35 MB/sec            */

#if 0
#define SYN_ULTRA_XFER_NS_8   63  /*  4.00 MB/SEC            */
#define SYN_ULTRA_XFER_NS_9   69  /*  3.64 MB/sec            */
#define SYN_ULTRA_XFER_NS_10  75  /*  3.33 MB/sec            */
#define SYN_ULTRA_XFER_NS_11  82  /*  3.08 MB/sec            */
#define SYN_ULTRA_XFER_NS_12  88  /*  2.86 MB/sec            */
#define SYN_ULTRA_XFER_NS_13  94  /*  2.67 MB/sec            */
#define SYN_ULTRA_XFER_NS_14  100 /*  2.5  MB/sec            */
#define SYN_ULTRA_XFER_NS_15  107 /*  2.35 MB/sec            */
#endif


/* #define ASC_SDTR_PERIOD_IX_MIN  7 */  /* below this will be rejected*/


/*
** Extended Message struct
**
** All Extended Messages have the same first 3 byte format.
**
** Note: The EXT_MSG structure size must be a word (16 bit) multiple to
**       be able to use the AscMemWordCopy*Lram() functions.
*/
typedef struct ext_msg {
  uchar msg_type ;                  /* Byte 0 */
  uchar msg_len ;                   /* Byte 1 */
  uchar msg_req ;                   /* Byte 2 */
  union {
    /* SDTR (Synchronous Data Transfer Request) specific fields */
    struct {
      uchar sdtr_xfer_period ;      /* Byte 3 */
      uchar sdtr_req_ack_offset ;   /* Byte 4 */
    } sdtr;
    /* WDTR (Wide Data Transfer Request) specific fields */
    struct {
      uchar wdtr_width ;            /* Byte 3 */
    } wdtr;
    /* MDP (Modify Data Pointer) specific fields */
    struct {
      uchar mdp_b3 ;                /* Byte 3 */
      uchar mdp_b2 ;                /* Byte 4 */
      uchar mdp_b1 ;                /* Byte 5 */
      uchar mdp_b0 ;                /* Byte 6 */
    } mdp;
  } u_ext_msg;
  uchar res ;                       /* Byte 7 (Word Padding) */
} EXT_MSG;

#define xfer_period     u_ext_msg.sdtr.sdtr_xfer_period
#define req_ack_offset  u_ext_msg.sdtr.sdtr_req_ack_offset
#define wdtr_width      u_ext_msg.wdtr.wdtr_width
#define mdp_b3          u_ext_msg.mdp_b3
#define mdp_b2          u_ext_msg.mdp_b2
#define mdp_b1          u_ext_msg.mdp_b1
#define mdp_b0          u_ext_msg.mdp_b0


/*
** pointer to functions for device driver
**
**
**
** typedef void ( *AscIsrCallBack )( uchar *, ASC_QDONE_INFO dosfar * ) ;
** typedef void ( *AscDispFun )( char * ) ;
** typedef void ( *AscSleepMsec )( ulong msec ) ;
*/


typedef struct asc_dvc_cfg {
  ASC_SCSI_BIT_ID_TYPE  can_tagged_qng ;   /* device is capable of doing tag queuing */
/*  uchar    max_qng_scsi1 ;   maximum number of queued SCSI 1 command */
/*  uchar    max_qng_scsi2 ;   maximum number of queued SCSI 2 command */
/*  uchar    mcode_cntl ;      micro code control byte */
  ASC_SCSI_BIT_ID_TYPE  cmd_qng_enabled ; /* use tag queuing if possible */
  ASC_SCSI_BIT_ID_TYPE  disc_enable ;     /* enable disconnection */
  ASC_SCSI_BIT_ID_TYPE  sdtr_enable ;     /* enable SDTR if possible */
  uchar    chip_scsi_id : 4 ;  /* the chip SCSI id */
                               /* default should be 0x80 ( target id 7 ) */
  uchar    isa_dma_speed : 4 ; /* 06H high nibble, ISA Chip DMA Speed  */
                               /*     0 - 10MB - default */
                               /*     1 - 7.69 MB */
                               /*     2 - 6.66 MB */
                               /*     3 - 5.55 MB */
                               /*     4 - 5.00 MB */
                               /*     5 - 4.00 MB */
                               /*     6 - 3.33 MB */
                               /*     7 - 2.50 MB */
  uchar    isa_dma_channel ;   /* DMA channel 5, 6, 7 */
  uchar    chip_version ;     /* chip version */
  ushort   pci_device_id ;    /* PCI device code number */
  ushort   lib_serial_no ;   /* internal serial release number */
  ushort   lib_version ;     /* ASC library version number */
  ushort   mcode_date ;      /* ASC micro code date */
  ushort   mcode_version ;   /* ASC micro code version */
  uchar    max_tag_qng[ ASC_MAX_TID+1 ] ; /* number of request issued to each target ( and its LUN ) */
  uchar dosfar *overrun_buf ; /* virtual address of data overrun buffer */
                              /* overrun size is defined as ASC_OVERRUN_BSIZE */
                              /* during init, will call DvcGetSgList() to get physical address */
  uchar    sdtr_period_offset[ ASC_MAX_TID+1 ] ;

  ushort   pci_slot_info ;     /* high byte device/function number, bits 7-3 device number, bits 2-0 function number */
                               /* low byte bus number */

} ASC_DVC_CFG ;

#define ASC_DEF_DVC_CNTL       0xFFFF /* default dvc_cntl value */
#define ASC_DEF_CHIP_SCSI_ID   7  /* CHIP SCSI ID */
#define ASC_DEF_ISA_DMA_SPEED  4  /* 4 is 5MB per second */

#define ASC_INIT_STATE_NULL          0x0000
#define ASC_INIT_STATE_BEG_GET_CFG   0x0001
#define ASC_INIT_STATE_END_GET_CFG   0x0002
#define ASC_INIT_STATE_BEG_SET_CFG   0x0004
#define ASC_INIT_STATE_END_SET_CFG   0x0008
#define ASC_INIT_STATE_BEG_LOAD_MC   0x0010
#define ASC_INIT_STATE_END_LOAD_MC   0x0020
#define ASC_INIT_STATE_BEG_INQUIRY   0x0040
#define ASC_INIT_STATE_END_INQUIRY   0x0080
#define ASC_INIT_RESET_SCSI_DONE     0x0100
#define ASC_INIT_STATE_WITHOUT_EEP   0x8000

#define ASC_PCI_DEVICE_ID_REV_A      0x1100
#define ASC_PCI_DEVICE_ID_REV_B      0x1200

/*
** BUG FIX control
*/
#define ASC_BUG_FIX_IF_NOT_DWB       0x0001 /* add bytes until end address is dword boundary */
#define ASC_BUG_FIX_ASYN_USE_SYN     0x0002

/* #define ASC_ISAPNP_ADD_NUM_OF_BYTES   7    */  /* */
/* #define ASC_BUG_FIX_ISAPNP_ADD_BYTES  0x0002 */ /* for chip version 0x21 ( ISA PNP ) */
                                                  /* add three bytes when read from target */
                                                  /* active on command 0x08 and 0x28 only */

#define ASYN_SDTR_DATA_FIX_PCI_REV_AB 0x41  /* init SYN regs value for PCI rev B */

#define ASC_MIN_TAGGED_CMD  7  /* minimum number of tagged queues to re-adjust maximum number */
#define ASC_MAX_SCSI_RESET_WAIT      30   /* in seconds */

/*
**
*/
typedef struct asc_dvc_var {
  PortAddr iop_base ; /* 0-1 I/O port address */
  ushort   err_code ; /* 2-3 fatal error code */
  ushort   dvc_cntl ; /* 4-5 device control word, normally 0xffff */
  ushort   bug_fix_cntl ; /* 6-7 BUG fix contrl word, normally zero, bit set turn on fix */
  ushort   bus_type ; /* 8-9 BUS interface type, ISA, VL, PCI, EISA, etc... */
  Ptr2Func isr_callback ; /* 10-13 pointer to function, called in AscISR() to notify a done queue */
  Ptr2Func exe_callback ; /* 14-17 pointer to function, called when a scsiq put into local RAM */
                          /* if value is ZERO, will not be called */

  ASC_SCSI_BIT_ID_TYPE init_sdtr ; /* 18 host adapter should initiate SDTR request */
                        /*   ( bit field for each target ) */
  ASC_SCSI_BIT_ID_TYPE sdtr_done ; /* 19 SDTR is completed ( bit field for each target ) */

  ASC_SCSI_BIT_ID_TYPE use_tagged_qng ; /* 20 use tagged queuing, must be capable of tagged queuing */

  ASC_SCSI_BIT_ID_TYPE unit_not_ready ; /* 21 device is spinning up motor */
                                  /* a start unit command has sent to device */
                                  /* bit will be cleared when start unit command is returned */

  ASC_SCSI_BIT_ID_TYPE queue_full_or_busy ; /* 22 tagged queue full */

  ASC_SCSI_BIT_ID_TYPE  start_motor ;     /* 23 send start motor at init  */
  uchar    scsi_reset_wait ;  /* 24 delay number of second after scsi bus reset */
  uchar    chip_no ;         /*  25 should be assigned by caller */
                             /*   to know which chip is causing the interrupt */
                             /*   has no meaning inside library */
  char     is_in_int ;       /* 26  is (TRUE) if inside ISR */
  uchar    max_total_qng ;   /* 27 maximum total number of queued command allowed */

  uchar    cur_total_qng ;   /* 28 total number of queue issue to RISC */
  /* uchar    sdtr_reject ;      reject if SDTR period below 5MB/sec */
  /* uchar    max_single_qng ;   maximum number of queued command per target id */
                             /*    this is not used anymore */
  uchar    in_critical_cnt ; /* 29 non-zero if in critical section */

  uchar    irq_no ;          /* 30 IRQ number */
  uchar    last_q_shortage ; /* 31 number of queue required, set when request failed */

  ushort   init_state ;      /* 32 indicate which initialization stage */
  uchar    cur_dvc_qng[ ASC_MAX_TID+1 ] ; /* 34-41 number of request issued to each target ( and its LUN ) */
  uchar    max_dvc_qng[ ASC_MAX_TID+1 ] ; /* 42-49 maximum number of request per target device */

  ASC_SCSI_Q dosfar *scsiq_busy_head[ ASC_MAX_TID+1 ] ; /* busy queue */
  ASC_SCSI_Q dosfar *scsiq_busy_tail[ ASC_MAX_TID+1 ] ; /* busy queue */

/*
** BIOS will not use fields below here
**
**  uchar    max_qng[ ASC_MAX_TID+1 ] ;
**  uchar    cur_qng[ ASC_MAX_TID+1 ] ;
**  uchar    sdtr_data[ ASC_MAX_TID+1 ] ;
*/

  uchar    sdtr_period_tbl[ ASC_MAX_SYN_XFER_NO ] ;
  /* ulong    int_count ; */  /* number of request */

/*
** the following field will not be used after initilization
** you may discard the buffer after initialization is done
*/
  ASC_DVC_CFG dosfar *cfg ;  /* pointer to configuration buffer */
  Ptr2Func saved_ptr2func ;  /* reserved for internal working, and for future expansion */
  ASC_SCSI_BIT_ID_TYPE pci_fix_asyn_xfer_always ;
  char     redo_scam ;
  ushort   res2 ;
  uchar    dos_int13_table[ ASC_MAX_TID+1 ] ;
  ulong max_dma_count ;
  ASC_SCSI_BIT_ID_TYPE no_scam ;
  ASC_SCSI_BIT_ID_TYPE pci_fix_asyn_xfer ;
  uchar    max_sdtr_index ;
  uchar    host_init_sdtr_index ; /* added since, S89 */
  ulong    drv_ptr ; /* driver pointer to private structure */
  ulong    uc_break ; /* micro code break point calling function */
  ulong    res7 ;
  ulong    res8 ;
} ASC_DVC_VAR ;

typedef int ( dosfar *ASC_ISR_CALLBACK )( ASC_DVC_VAR asc_ptr_type *, ASC_QDONE_INFO dosfar * ) ;
typedef int ( dosfar *ASC_EXE_CALLBACK )( ASC_DVC_VAR asc_ptr_type *, ASC_SCSI_Q dosfar * ) ;

/*
** this is ued in AscInitScsiTarget( ) to return inquiry data
*/
typedef struct asc_dvc_inq_info {
  uchar type[ ASC_MAX_TID+1 ][ ASC_MAX_LUN+1 ] ;
} ASC_DVC_INQ_INFO ;

typedef struct asc_cap_info {
  ulong lba ;       /* the maximum logical block size */
  ulong blk_size ;  /* the logical block size in bytes */
} ASC_CAP_INFO ;

typedef struct asc_cap_info_array {
  ASC_CAP_INFO  cap_info[ ASC_MAX_TID+1 ][ ASC_MAX_LUN+1 ] ;
} ASC_CAP_INFO_ARRAY ;

/*
** the aspimgr control word at EEPROM word offset 14
** also in ASC_DVC_VAR dvc_cntl field
**
**
** the following is enabled when bit cleared
** used by micro code
*/
#define ASC_MCNTL_NO_SEL_TIMEOUT  ( ushort )0x0001 /* no selection time out */
#define ASC_MCNTL_NULL_TARGET     ( ushort )0x0002 /* null targets simulation */
                                         /* operation always successful */
/*
** the following is enabled when bit set
** used by device driver
*/
#define ASC_CNTL_INITIATOR         ( ushort )0x0001 /* control */
#define ASC_CNTL_BIOS_GT_1GB       ( ushort )0x0002 /* bios will support greater than 1GB disk */
#define ASC_CNTL_BIOS_GT_2_DISK    ( ushort )0x0004 /* bios will support more than 2 disk */
#define ASC_CNTL_BIOS_REMOVABLE    ( ushort )0x0008 /* bios support removable disk drive */
#define ASC_CNTL_NO_SCAM           ( ushort )0x0010 /* do not call SCAM at init time */
/* #define ASC_CNTL_NO_PCI_FIX_ASYN_XFER ( ushort )0x0020 */ /* fix PCI rev A/B async data xfer problem */
                                                       /* default is off, bit set */
#define ASC_CNTL_INT_MULTI_Q       ( ushort )0x0080 /* process more than one queue for every interrupt */

#define ASC_CNTL_NO_LUN_SUPPORT    ( ushort )0x0040

#define ASC_CNTL_NO_VERIFY_COPY    ( ushort )0x0100 /* verify copy to local ram */
#define ASC_CNTL_RESET_SCSI        ( ushort )0x0200 /* reset scsi bus at start up */
#define ASC_CNTL_INIT_INQUIRY      ( ushort )0x0400 /* inquiry target during init */
#define ASC_CNTL_INIT_VERBOSE      ( ushort )0x0800 /* verbose display of initialization */

#define ASC_CNTL_SCSI_PARITY       ( ushort )0x1000
#define ASC_CNTL_BURST_MODE        ( ushort )0x2000

/* #define ASC_CNTL_USE_8_IOP_BASE    ( ushort )0x4000 */
#define ASC_CNTL_SDTR_ENABLE_ULTRA  ( ushort )0x4000 /* bit set is ultra enabled */
                                                     /* default is ultra enabled */
                                                     /* when disable, it need to disable target inited sdtr at 20mb/sec also */
                                                     /* if disabled, use 10mb/sec sdtr instead of 20mb/sec */
/* #define ASC_CNTL_FIX_DMA_OVER_WR  ( ushort )0x4000  restore the overwritten one byte */
/* #define ASC_CNTL_INC_DATA_CNT     ( ushort )0x8000  increase transfer count by one */

/*
** ASC-1000 EEPROM configuration ( 16 words )
*/

/*
** to fix version 3 chip problem, we use EEPROM word from 0 to 15
**
**
*/
/*
** only version 3 has this bug !!!
*/

#define ASC_EEP_DVC_CFG_BEG_VL    2 /* we use eeprom from index 2 for VL version 3 */
#define ASC_EEP_MAX_DVC_ADDR_VL   15 /* number of words used by driver configuration */

#define ASC_EEP_DVC_CFG_BEG      32 /* we use eeprom from index 32 */
#define ASC_EEP_MAX_DVC_ADDR     45 /* number of words used by driver configuration */

#define ASC_EEP_DEFINED_WORDS    10 /* number of eeprom usage word defined */
#define ASC_EEP_MAX_ADDR         63 /* maximum word address from zero */
#define ASC_EEP_RES_WORDS         0 /* number of reserved word */
#define ASC_EEP_MAX_RETRY        20 /* maximum number of retries write eeprom */
#define ASC_MAX_INIT_BUSY_RETRY   8 /* retry at init driver */

/*
** ISA PNP resource size in words
*/
#define ASC_EEP_ISA_PNP_WSIZE    16

typedef struct asceep_config {
  ushort cfg_lsw ;         /* 00 */
  ushort cfg_msw ;         /* 01 */

#if 0
  ushort pnp_resource[ ASC_EEP_ISA_PNP_WSIZE ] ;
#endif

                           /*        for detail see xxxx */
  uchar  init_sdtr ;       /* 02L    host initiate SDTR, default 0x00 */
  uchar  disc_enable ;     /* 02H    disconnection enabled, default 0xFF */

  uchar  use_cmd_qng ;     /* 03L    use command queuing if possible */
                           /*        default 0x00 */
  uchar  start_motor ;     /* 03H    send start motor command, default 0x00 */
  uchar  max_total_qng ;   /*        maximum total number of queued commands                */
  uchar  max_tag_qng ;     /*        maximum number of tag queue command per target id      */
  uchar  bios_scan ;       /* 04L    BIOS will try to scan and take over the device         */
                           /*        if BIOS is enabled, one of the bit here should be set  */
                           /*        default 0x01                                           */
                           /*        if zero, BIOS is disabled, but may still               */
                           /*        occupied a address space, depends on bios_addr         */

  uchar  power_up_wait ;   /*  04H   BIOS delay number of second when first come up */

  uchar  no_scam ;          /* 05L   non-SCAM tolerant device */
  uchar  chip_scsi_id : 4 ; /* 05H   the chip SCSI id */
                            /* default should be 0x80 ( target id 7 ) */
  uchar  isa_dma_speed : 4 ;  /* 06H high nibble, ISA Chip DMA Speed  */
                                                   /*     0 - 10MB - default */
                                                   /*     1 - 7.69 MB */
                                                   /*     2 - 6.66 MB */
                                                   /*     3 - 5.55 MB */
                                                   /*     4 - 5.00 MB */
                                                   /*     5 - 4.00 MB */
                                                   /*     6 - 3.33 MB */
                                                   /*     7 - 2.50 MB */
  uchar  dos_int13_table[ ASC_MAX_TID+1 ] ;

#if 0
  uchar  sdtr_data[ ASC_MAX_TID+1 ] ;  /* 07-10  SDTR value to 8 target devices */
                           /*        lower nibble is SDTR offset ( default 0xf )                           */
                           /*        high nibble is SDTR period index ( default 0, 10MB/sec )              */
                           /*        default value will be 0x0F                                            */
#endif

  uchar  adapter_info[ 6 ] ;       /* 11-13 host adapter information  */
  /* DATE: 5-17-94,  micro code control word will not read from EEPROM */
  /* ushort mcode_cntl ;             set to 0xFFFF                                                         */
                           /*      * bit 0 clear: no selection time out                                    */
                           /*      * bit 1 clear: null target simulation                                   */
                           /*        bit 2:                                                                */
                           /*        bit 3:                                                                */
                           /*        bit 4:                                                                */
                           /*        bit 5:                                                                */
                           /*        bit 6:                                                                */
                           /*        bit 7:                                                                */
                           /*                                                                              */
  ushort cntl ;            /* 14     the control word                                                      */
                           /*        default value is 0xffff                                               */
                           /*                                                                              */
                           /* enabled when bit set, default 0xFF                                           */
                           /*                                                                              */
                           /*  bit 0  set: do not act as initiator                                         */
                           /*              ( acting as target )                                            */
                           /*  bit 1  set: BIOS greater than one giga byte support                         */
                           /*  bit 2  set: BIOS support more than two drives                               */
                           /*              ( DOS 5.0 and later only )                                      */
                           /*  bit 3  set: BIOS do not support removable disk drive                               */
                           /*  bit 4  set:                                                                 */
                           /*  bit 5  set:                                                                 */
                           /*  bit 6  set: do not inquiry logical unit number                              */
                           /*  bit 7  set: interrupt service routine will process more than one queue      */
                           /*  bit 8  set: no local RAM copying verification                               */
                           /*  bit 9  set: reset SCSI bus during initialization                            */
                           /*  bit 10 set: inquiry scsi devices during initialization                      */
                           /*  bit 11 set: no initilization verbose display                                */
                           /*  bit 12 set: SCSI parity enabled                                             */
                           /*  bit 13 set: burst mode disabled                                             */
                           /*  bit 14 set: use only default i/o port address set                           */
                           /*  bit 15 set: */
                           /* for chip version 1 only                                                      */
                           /*        bit 14 set: restore DMA overwritten byte                              */
                           /*        bit 15 set: increment data transfer count by one                      */
                           /*                                                                              */
                           /*    * - always use default setting                                            */
                           /*        do not turn off these bits in normal operation                        */
                           /*        turn off for debuging only !!!                                        */
                           /*                                                                              */
  ushort chksum ;          /* 15     check sum of EEPROM                                                   */
} ASCEEP_CONFIG ;


#define ASC_PCI_CFG_LSW_SCSI_PARITY  0x0800
#define ASC_PCI_CFG_LSW_BURST_MODE   0x0080
#define ASC_PCI_CFG_LSW_INTR_ABLE    0x0020

/*
** the EEP command register
*/
#define ASC_EEP_CMD_READ          0x80 /* read operation             */
#define ASC_EEP_CMD_WRITE         0x40 /* write operation            */
#define ASC_EEP_CMD_WRITE_ABLE    0x30 /* enable write opeartion     */
#define ASC_EEP_CMD_WRITE_DISABLE 0x00 /* disable write opeartion    */

#define ASC_OVERRUN_BSIZE  0x00000048UL /* data overrun buffer size */
  /* is 8 bytes more than acutual size to adjust address to double word boundary */

#define ASC_CTRL_BREAK_ONCE        0x0001 /* */
#define ASC_CTRL_BREAK_STAY_IDLE   0x0002 /* */

/*
** important local memory variables address
*/
#define ASCV_MSGOUT_BEG         0x0000  /* send message out buffer begin */
#define ASCV_MSGOUT_SDTR_PERIOD (ASCV_MSGOUT_BEG+3)
#define ASCV_MSGOUT_SDTR_OFFSET (ASCV_MSGOUT_BEG+4)

#define ASCV_BREAK_SAVED_CODE   ( ushort )0x0006 /* the saved old instruction code */

#define ASCV_MSGIN_BEG          (ASCV_MSGOUT_BEG+8) /* message in buffer begin */
#define ASCV_MSGIN_SDTR_PERIOD  (ASCV_MSGIN_BEG+3)
#define ASCV_MSGIN_SDTR_OFFSET  (ASCV_MSGIN_BEG+4)

#define ASCV_SDTR_DATA_BEG      (ASCV_MSGIN_BEG+8)
#define ASCV_SDTR_DONE_BEG      (ASCV_SDTR_DATA_BEG+8)
#define ASCV_MAX_DVC_QNG_BEG    ( ushort )0x0020 /* maximum number of tagged queue per device */

#define ASCV_BREAK_ADDR           ( ushort )0x0028 /* */
#define ASCV_BREAK_NOTIFY_COUNT   ( ushort )0x002A /* when to call DvcNotifyUcBreak() when hit count reach this value */
#define ASCV_BREAK_CONTROL        ( ushort )0x002C /* */
#define ASCV_BREAK_HIT_COUNT      ( ushort )0x002E /* current break address hit count, clear to zero */
                                                   /* after reach number specified in ASC_BREAK_NOTIFY_COUNT */

/* #define ASCV_LAST_HALTCODE_W ( ushort )0x0030  last saved halt code */
#define ASCV_ASCDVC_ERR_CODE_W  ( ushort )0x0030  /* last saved halt code */
#define ASCV_MCODE_CHKSUM_W   ( ushort )0x0032 /* code section check sum */
#define ASCV_MCODE_SIZE_W     ( ushort )0x0034 /* code size check sum */
#define ASCV_STOP_CODE_B      ( ushort )0x0036 /* stop RISC queue processing */
#define ASCV_DVC_ERR_CODE_B   ( ushort )0x0037 /* for device driver ( not library ) fatal error code */

#define ASCV_OVERRUN_PADDR_D  ( ushort )0x0038 /* data overrun buffer physical address */
#define ASCV_OVERRUN_BSIZE_D  ( ushort )0x003C /* data overrun buffer size variable */

#define ASCV_HALTCODE_W       ( ushort )0x0040 /* halt code */
#define ASCV_CHKSUM_W         ( ushort )0x0042 /* code chksum */
#define ASCV_MC_DATE_W        ( ushort )0x0044 /* microcode version date */
#define ASCV_MC_VER_W         ( ushort )0x0046 /* microcode version number */
#define ASCV_NEXTRDY_B        ( ushort )0x0048 /* next ready cdb */
#define ASCV_DONENEXT_B       ( ushort )0x0049 /* next done cdb */
#define ASCV_USE_TAGGED_QNG_B ( ushort )0x004A /* bit field of use tagged queuing device */
#define ASCV_SCSIBUSY_B       ( ushort )0x004B /* bit field of SCSI busy device */
/* #define ASCV_CDBCNT_B         ( ushort )0x004C  2-24-96 obsolete */  /* total cdb count */
#define ASCV_Q_DONE_IN_PROGRESS_B  ( ushort )0x004C  /* ucode send early interrupt */
#define ASCV_CURCDB_B         ( ushort )0x004D /* current active CDB */
#define ASCV_RCLUN_B          ( ushort )0x004E /* current active CDB */
#define ASCV_BUSY_QHEAD_B     ( ushort )0x004F /* busy queue head */
#define ASCV_DISC1_QHEAD_B    ( ushort )0x0050 /* SCSI 1 queue disconnected head */
/* #define ASCV_SDTR_DONE_B      ( ushort )0x0051 bit set is disconnection priviledge enabled */
#define ASCV_DISC_ENABLE_B    ( ushort )0x0052 /* bit set is disconnection priviledge enabled */
#define ASCV_CAN_TAGGED_QNG_B ( ushort )0x0053 /* bit field of capable tagged queuing device */
#define ASCV_HOSTSCSI_ID_B    ( ushort )0x0055 /* host scsi id */
#define ASCV_MCODE_CNTL_B     ( ushort )0x0056 /* micro code control word */
#define ASCV_NULL_TARGET_B    ( ushort )0x0057

#define ASCV_FREE_Q_HEAD_W    ( ushort )0x0058 /* */
#define ASCV_DONE_Q_TAIL_W    ( ushort )0x005A /* */
#define ASCV_FREE_Q_HEAD_B    ( ushort )(ASCV_FREE_Q_HEAD_W+1)
#define ASCV_DONE_Q_TAIL_B    ( ushort )(ASCV_DONE_Q_TAIL_W+1)

#define ASCV_HOST_FLAG_B      ( ushort )0x005D /* HOST adadpter action flag */

#define ASCV_TOTAL_READY_Q_B  ( ushort )0x0064 /* total number of ready queue(s) */
#define ASCV_VER_SERIAL_B     ( ushort )0x0065 /* micro code modification serial number */
#define ASCV_HALTCODE_SAVED_W ( ushort )0x0066 /* error code, that is go to happened if it is not a bus free */
#define ASCV_WTM_FLAG_B       ( ushort )0x0068 /* watch dog timeout flag */
#define ASCV_RISC_FLAG_B      ( ushort )0x006A /* HOST adadpter action flag */
#define ASCV_REQ_SG_LIST_QP   ( ushort )0x006B /* requesting sg list qp */

/*
** definition of ASCV_HOST_FLAG_B
*/
#define ASC_HOST_FLAG_IN_ISR        0x01  /* host is processing ISR */
#define ASC_HOST_FLAG_ACK_INT       0x02  /* host is acknowledging interrupt */

#define ASC_RISC_FLAG_GEN_INT      0x01  /* risc is generating interrupt */
#define ASC_RISC_FLAG_REQ_SG_LIST  0x02  /* risc is requesting more sg list */

#define IOP_CTRL         (0x0F) /* chip control */
#define IOP_STATUS       (0x0E) /* chip status */
#define IOP_INT_ACK      IOP_STATUS /* write only - interrupt ack */

/*
** bank zero, i/o port address
*/
#define IOP_REG_IFC      (0x0D)   /* interface control register, byte */
                                  /* for ASC-1090, ISA PNP, ver number from 33(0x21) */
                                  /* default value = 0x09 */
#define IOP_SYN_OFFSET    (0x0B)
#define IOP_EXTRA_CONTROL (0x0D)  /* byte register, begin with PCI ultra chip */
#define IOP_REG_PC        (0x0C)
#define IOP_RAM_ADDR      (0x0A)
#define IOP_RAM_DATA      (0x08)
#define IOP_EEP_DATA      (0x06)
#define IOP_EEP_CMD       (0x07)

#define IOP_VERSION       (0x03)
#define IOP_CONFIG_HIGH   (0x04)
#define IOP_CONFIG_LOW    (0x02)
#define IOP_SIG_BYTE      (0x01)
#define IOP_SIG_WORD      (0x00)

/*
** bank one, i/o port address
*/
#define IOP_REG_DC1      (0x0E)
#define IOP_REG_DC0      (0x0C)
#define IOP_REG_SB       (0x0B) /* scsi data bus */
#define IOP_REG_DA1      (0x0A)
#define IOP_REG_DA0      (0x08)
#define IOP_REG_SC       (0x09) /* scsi control */
#define IOP_DMA_SPEED    (0x07)
#define IOP_REG_FLAG     (0x07) /* flag */
#define IOP_FIFO_H       (0x06)
#define IOP_FIFO_L       (0x04)
#define IOP_REG_ID       (0x05)
#define IOP_REG_QP       (0x03) /* queue pointer */
#define IOP_REG_IH       (0x02) /* instruction holding register */
#define IOP_REG_IX       (0x01) /* index register */
#define IOP_REG_AX       (0x00) /* accumuloator */

/*
** ISA IFC
*/
#define IFC_REG_LOCK      (0x00) /* [3:0] write this value to lock read/write permission to all register */
#define IFC_REG_UNLOCK    (0x09) /* [3:0] write this value to unlock read/write permission to all register */

#define IFC_WR_EN_FILTER  (0x10) /* write only, EN filter */
#define IFC_RD_NO_EEPROM  (0x10) /* read only, No EEPROM */
#define IFC_SLEW_RATE     (0x20) /* SCSI slew rate */
#define IFC_ACT_NEG       (0x40) /* turn on this ( default is off ) */
#define IFC_INP_FILTER    (0x80) /* SCSI input filter */

#define IFC_INIT_DEFAULT  ( IFC_ACT_NEG | IFC_REG_UNLOCK )

/*
** chip scsi control signal
*/
#define SC_SEL   ( uchar )(0x80)
#define SC_BSY   ( uchar )(0x40)
#define SC_ACK   ( uchar )(0x20)
#define SC_REQ   ( uchar )(0x10)
#define SC_ATN   ( uchar )(0x08)
#define SC_IO    ( uchar )(0x04)
#define SC_CD    ( uchar )(0x02)
#define SC_MSG   ( uchar )(0x01)

/*
 * Extra control Register Definitions
 * Bank 0, Base Address + 0xD
 */
#define SEC_SCSI_CTL         ( uchar )( 0x80 )
#define SEC_ACTIVE_NEGATE    ( uchar )( 0x40 )
#define SEC_SLEW_RATE        ( uchar )( 0x20 )
#define SEC_ENABLE_FILTER    ( uchar )( 0x10 )


/*
** the LSB of halt code is the error code
** the MSB of halt code is used as control
*/
#define ASC_HALT_EXTMSG_IN     ( ushort )0x8000 /* halt code of extended message */
#define ASC_HALT_CHK_CONDITION ( ushort )0x8100 /* halt code of extended message */
#define ASC_HALT_SS_QUEUE_FULL ( ushort )0x8200 /* halt code of queue full status */
#define ASC_HALT_DISABLE_ASYN_USE_SYN_FIX  ( ushort )0x8300
#define ASC_HALT_ENABLE_ASYN_USE_SYN_FIX   ( ushort )0x8400
#define ASC_HALT_SDTR_REJECTED ( ushort )0x4000 /* halt code of reject SDTR      */
/* #define ASC_HALT_COPY_SG_LIST_FROM_HOST ( ushort )0x2000 */

/* #define ASC_MAX_QNO        0xFF */
#define ASC_MAX_QNO        0xF8   /* queue used from 0x00 to 0xF7, total=0xF8 */
#define ASC_DATA_SEC_BEG   ( ushort )0x0080 /* data section begin */
#define ASC_DATA_SEC_END   ( ushort )0x0080 /* data section end   */
#define ASC_CODE_SEC_BEG   ( ushort )0x0080 /* code section begin */
#define ASC_CODE_SEC_END   ( ushort )0x0080 /* code section end   */
#define ASC_QADR_BEG       (0x4000) /* queue buffer begin */
#define ASC_QADR_USED      ( ushort )( ASC_MAX_QNO * 64 )
#define ASC_QADR_END       ( ushort )0x7FFF /* queue buffer end */
#define ASC_QLAST_ADR      ( ushort )0x7FC0 /* last queue address, not used */
#define ASC_QBLK_SIZE      0x40
#define ASC_BIOS_DATA_QBEG 0xF8   /* BIOS data section is from queue 0xF8     */
                                  /* total size 64*8=512 bytes                */
#define ASC_MIN_ACTIVE_QNO 0x01   /* minimum queue number of active queue     */
/* #define ASC_MAX_ACTIVE_QNO 0xF0   maximum queue number of active queue  */
#define ASC_QLINK_END      0xFF   /* forward pointer of end of queue       */
#define ASC_EEPROM_WORDS   0x10   /* maximum number of words in EEPROM     */
#define ASC_MAX_MGS_LEN    0x10   /*                                       */

#define ASC_BIOS_ADDR_DEF  0xDC00 /* default BIOS address                      */
#define ASC_BIOS_SIZE      0x3800 /* BIOS ROM size                             */
#define ASC_BIOS_RAM_OFF   0x3800 /* BIOS ram address offset from bios address */
#define ASC_BIOS_RAM_SIZE  0x800  /* BIOS ram size in bytes, 2KB               */
#define ASC_BIOS_MIN_ADDR  0xC000 /* BIOS ram size in bytes, 2KB               */
#define ASC_BIOS_MAX_ADDR  0xEC00 /* BIOS ram size in bytes, 2KB               */
#define ASC_BIOS_BANK_SIZE 0x0400 /* BIOS one bank size                        */


#define ASC_MCODE_START_ADDR  0x0080 /* micro code starting address */

/*
**
*/
#define ASC_CFG0_HOST_INT_ON    0x0020 /* VESA burst mode enable    */
#define ASC_CFG0_BIOS_ON        0x0040 /* BIOS is enabled           */
#define ASC_CFG0_VERA_BURST_ON  0x0080 /* VESA burst mode enable    */
#define ASC_CFG0_SCSI_PARITY_ON 0x0800 /* SCSI parity enable        */

#define ASC_CFG1_SCSI_TARGET_ON 0x0080 /* SCSI target mode enable   */
#define ASC_CFG1_LRAM_8BITS_ON  0x0800 /* 8 bit local RAM access    */

/* use this value to clear any unwanted bits in cfg_msw */
#define ASC_CFG_MSW_CLR_MASK    0x3080
                                        /* clear fast EEPROM CLK */
                                        /* clear fast scsi clk */
                                        /* clear scsi target mode */


/*
** chip status
*/
#if 0
/*
**  VL chip version 1
*/

    #define IOP0B_STAT      ( PortAddr )((_io_port_base)+( PortAddr )0x09)
    #define IOP0B_INT_ACK   ( PortAddr )((_io_port_base)+( PortAddr )0x09)

    #define CS_DMA_DONE     ( ASC_CS_TYPE )0x80 /*                                                       */
    #define CS_FIFO_RDY     ( ASC_CS_TYPE )0x40 /*                                                       */
    #define CS_RAM_DONE     ( ASC_CS_TYPE )0x20 /*                                                       */
    #define CS_HALTED       ( ASC_CS_TYPE )0x10 /* risc halted                                           */
    #define CS_SCSI_RESET   ( ASC_CS_TYPE )0x08 /* scsi reset in                                         */
    #define CS_PARITY_ERR   ( ASC_CS_TYPE )0x04 /* parity error                                          */
    #define CS_INT_HALT     ( ASC_CS_TYPE )0x02 /* interrupt with halt, 11-2-93, replaced by scsi reset  */
    #define CS_INT          ( ASC_CS_TYPE )0x01 /* normal interrupt                                      */
    #define ASC_INT_ACK     ( ASC_CS_TYPE )0x01 /* interrupt acknowledge                                 */

#endif

/*
** chip status: read only
** expaned to word size at chip version 2
*/
    #define CSW_TEST1             ( ASC_CS_TYPE )0x8000 /*                         */
    #define CSW_AUTO_CONFIG       ( ASC_CS_TYPE )0x4000 /* i/o port rotation is on */
    #define CSW_RESERVED1         ( ASC_CS_TYPE )0x2000 /*                         */
    #define CSW_IRQ_WRITTEN       ( ASC_CS_TYPE )0x1000 /* set new IRQ toggled high*/
    #define CSW_33MHZ_SELECTED    ( ASC_CS_TYPE )0x0800 /* use 33 Mhz clock        */
    #define CSW_TEST2             ( ASC_CS_TYPE )0x0400 /*                         */
    #define CSW_TEST3             ( ASC_CS_TYPE )0x0200 /*                         */
    #define CSW_RESERVED2         ( ASC_CS_TYPE )0x0100 /*                         */
    #define CSW_DMA_DONE          ( ASC_CS_TYPE )0x0080 /*                         */
    #define CSW_FIFO_RDY          ( ASC_CS_TYPE )0x0040 /*                         */

/*
**  for VL chip version under 2
**
**  #define CSW_RAM_DONE          ( ASC_CS_TYPE )0x0020
**
*/
    #define CSW_EEP_READ_DONE     ( ASC_CS_TYPE )0x0020

    #define CSW_HALTED            ( ASC_CS_TYPE )0x0010 /* asc-1000 is currently halted         */
    #define CSW_SCSI_RESET_ACTIVE ( ASC_CS_TYPE )0x0008 /* scsi bus reset is still high         */
                                                        /* wait until this bit go low to        */
                                                        /* start chip reset ( initialization )  */
    #define CSW_PARITY_ERR        ( ASC_CS_TYPE )0x0004 /* parity error                         */
    #define CSW_SCSI_RESET_LATCH  ( ASC_CS_TYPE )0x0002 /* scsi bus reset is toggled on         */
                                                        /* normally should stay low             */
    #define CSW_INT_PENDING       ( ASC_CS_TYPE )0x0001 /* interrupt is pending,                */
                                                        /* not acknowledged yet                 */

    /*
    ** interrupt acknowledge register: write only
    */
    #define CIW_CLR_SCSI_RESET_INT ( ASC_CS_TYPE )0x1000  /* clear interrupt caused by scsi reset */

    #define CIW_INT_ACK      ( ASC_CS_TYPE )0x0100 /* interrupt acknowledge bit */
    #define CIW_TEST1        ( ASC_CS_TYPE )0x0200 /* for testing               */
    #define CIW_TEST2        ( ASC_CS_TYPE )0x0400 /* for testing               */
    #define CIW_SEL_33MHZ    ( ASC_CS_TYPE )0x0800 /* interrupt acknowledge bit */

    #define CIW_IRQ_ACT      ( ASC_CS_TYPE )0x1000 /* irq activation, toggle once to set new irq */
                                                   /* normally should stay low */

/*
** chip control
*/
#define CC_CHIP_RESET   ( uchar )0x80 /* reset risc chip  */
#define CC_SCSI_RESET   ( uchar )0x40 /* reset scsi bus   */
#define CC_HALT         ( uchar )0x20 /* halt risc chip   */
#define CC_SINGLE_STEP  ( uchar )0x10 /* single step      */
#define CC_DMA_ABLE     ( uchar )0x08 /* host dma enabled */
#define CC_TEST         ( uchar )0x04 /* test bit         */
#define CC_BANK_ONE     ( uchar )0x02 /* bank switch bit  */
#define CC_DIAG         ( uchar )0x01 /* diagnostic bit   */

/*
** ASC 1000
*/
#define ASC_1000_ID0W      0x04C1 /* ASC1000 signature word */
#define ASC_1000_ID0W_FIX  0x00C1 /* ASC1000 signature word */
#define ASC_1000_ID1B      0x25   /* ASC1000 signature byte */

#define ASC_EISA_BIG_IOP_GAP   (0x1C30-0x0C50)  /* = 0x0FE0 */
#define ASC_EISA_SMALL_IOP_GAP (0x0020)  /*  */
#define ASC_EISA_MIN_IOP_ADDR  (0x0C30)  /*  */
#define ASC_EISA_MAX_IOP_ADDR  (0xFC50)  /*  */
#define ASC_EISA_REV_IOP_MASK  (0x0C83)  /* EISA revision number, from 0x01, MSB of product id */
#define ASC_EISA_PID_IOP_MASK  (0x0C80)  /* product ID i/o port address mask */
#define ASC_EISA_CFG_IOP_MASK  (0x0C86)  /* EISA cfg i/o port address mask */
                                      /* old value is 0x0C86 */
#define ASC_GET_EISA_SLOT( iop )  ( PortAddr )( (iop) & 0xF000 ) /* get EISA slot number */

#define ASC_EISA_ID_740    0x01745004UL  /* EISA single channel */
#define ASC_EISA_ID_750    0x01755004UL  /* EISA dual channel */



/* #define NOP_INS_CODE    ( ushort )0x6200 */
#define INS_HALTINT        ( ushort )0x6281 /* halt with interrupt instruction code */
#define INS_HALT           ( ushort )0x6280 /* halt instruction code */
#define INS_SINT           ( ushort )0x6200 /* set interrupt */
#define INS_RFLAG_WTM      ( ushort )0x7380 /* reset watch dog timer */

/* ---------------------------------------------------------
** meaning of control signal at bank 1 port offset 9
** bit7: sel
** bit6: busy
** bit5: ack
** bit4: req
** bit3: atn
** bit2: i/o
** bit1: c/d
** bit0: msg
*/

#define ASC_MC_SAVE_CODE_WSIZE  0x500  /* size of microcode data section in words to save */
#define ASC_MC_SAVE_DATA_WSIZE  0x40   /* size of microcode code section in words to save */

/*
**
*/
typedef struct asc_mc_saved {
    ushort data[ ASC_MC_SAVE_DATA_WSIZE ] ;
    ushort code[ ASC_MC_SAVE_CODE_WSIZE ] ;
} ASC_MC_SAVED ;


/*
** Macro
*/
#define AscGetQDoneInProgress( port )         AscReadLramByte( (port), ASCV_Q_DONE_IN_PROGRESS_B )
#define AscPutQDoneInProgress( port, val )    AscWriteLramByte( (port), ASCV_Q_DONE_IN_PROGRESS_B, val )

#define AscGetVarFreeQHead( port )            AscReadLramWord( (port), ASCV_FREE_Q_HEAD_W )
#define AscGetVarDoneQTail( port )            AscReadLramWord( (port), ASCV_DONE_Q_TAIL_W )
#define AscPutVarFreeQHead( port, val )       AscWriteLramWord( (port), ASCV_FREE_Q_HEAD_W, val )
#define AscPutVarDoneQTail( port, val )       AscWriteLramWord( (port), ASCV_DONE_Q_TAIL_W, val )

#define AscGetRiscVarFreeQHead( port )        AscReadLramByte( (port), ASCV_NEXTRDY_B )
#define AscGetRiscVarDoneQTail( port )        AscReadLramByte( (port), ASCV_DONENEXT_B )
#define AscPutRiscVarFreeQHead( port, val )   AscWriteLramByte( (port), ASCV_NEXTRDY_B, val )
#define AscPutRiscVarDoneQTail( port, val )   AscWriteLramByte( (port), ASCV_DONENEXT_B, val )

#define AscPutMCodeSDTRDoneAtID( port, id, data )  AscWriteLramByte( (port), ( ushort )( ( ushort )ASCV_SDTR_DONE_BEG+( ushort )id ), (data) ) ;
#define AscGetMCodeSDTRDoneAtID( port, id )        AscReadLramByte( (port), ( ushort )( ( ushort )ASCV_SDTR_DONE_BEG+( ushort )id ) ) ;

#define AscPutMCodeInitSDTRAtID( port, id, data )  AscWriteLramByte( (port), ( ushort )( ( ushort )ASCV_SDTR_DATA_BEG+( ushort )id ), data ) ;
#define AscGetMCodeInitSDTRAtID( port, id )        AscReadLramByte( (port), ( ushort )( ( ushort )ASCV_SDTR_DATA_BEG+( ushort )id ) ) ;

#define AscSynIndexToPeriod( index )        ( uchar )( asc_dvc->sdtr_period_tbl[ (index) ] )

/*
** Macro for get/set Bank 0 registers
*/

#define AscGetChipSignatureByte( port )     ( uchar )inp( (port)+IOP_SIG_BYTE )
#define AscGetChipSignatureWord( port )     ( ushort )inpw( (port)+IOP_SIG_WORD )

#define AscGetChipVerNo( port )             ( uchar )inp( (port)+IOP_VERSION )

#define AscGetChipCfgLsw( port )            ( ushort )inpw( (port)+IOP_CONFIG_LOW )
#define AscGetChipCfgMsw( port )            ( ushort )inpw( (port)+IOP_CONFIG_HIGH )
#define AscSetChipCfgLsw( port, data )      outpw( (port)+IOP_CONFIG_LOW, data )
#define AscSetChipCfgMsw( port, data )      outpw( (port)+IOP_CONFIG_HIGH, data )

#define AscGetChipEEPCmd( port )            ( uchar )inp( (port)+IOP_EEP_CMD )
#define AscSetChipEEPCmd( port, data )      outp( (port)+IOP_EEP_CMD, data )
#define AscGetChipEEPData( port )           ( ushort )inpw( (port)+IOP_EEP_DATA )
#define AscSetChipEEPData( port, data )     outpw( (port)+IOP_EEP_DATA, data )

#define AscGetChipLramAddr( port )          ( ushort )inpw( ( PortAddr )((port)+IOP_RAM_ADDR) )
#define AscSetChipLramAddr( port, addr )    outpw( ( PortAddr )( (port)+IOP_RAM_ADDR ), addr )
#define AscGetChipLramData( port )          ( ushort )inpw( (port)+IOP_RAM_DATA )
#define AscSetChipLramData( port, data )    outpw( (port)+IOP_RAM_DATA, data )
#define AscGetChipLramDataNoSwap( port )         ( ushort )inpw_noswap( (port)+IOP_RAM_DATA )
#define AscSetChipLramDataNoSwap( port, data )   outpw_noswap( (port)+IOP_RAM_DATA, data )

#define AscGetChipIFC( port )               ( uchar )inp( (port)+IOP_REG_IFC )
#define AscSetChipIFC( port, data )          outp( (port)+IOP_REG_IFC, data )

#define AscGetChipStatus( port )            ( ASC_CS_TYPE )inpw( (port)+IOP_STATUS )
#define AscSetChipStatus( port, cs_val )    outpw( (port)+IOP_STATUS, cs_val )

#define AscGetChipControl( port )           ( uchar )inp( (port)+IOP_CTRL )
#define AscSetChipControl( port, cc_val )   outp( (port)+IOP_CTRL, cc_val )

#define AscGetChipSyn( port )               ( uchar )inp( (port)+IOP_SYN_OFFSET )
#define AscSetChipSyn( port, data )         outp( (port)+IOP_SYN_OFFSET, data )

#define AscSetPCAddr( port, data )          outpw( (port)+IOP_REG_PC, data )
#define AscGetPCAddr( port )                ( ushort )inpw( (port)+IOP_REG_PC )


#define AscIsIntPending( port )             ( AscGetChipStatus(port) & ( CSW_INT_PENDING | CSW_SCSI_RESET_LATCH ) )
#define AscGetChipScsiID( port )            ( ( AscGetChipCfgLsw(port) >> 8 ) & ASC_MAX_TID )


/* this extra control begin with PCI ultra chip */
#define AscGetExtraControl( port )          ( uchar )inp( (port)+IOP_EXTRA_CONTROL )
#define AscSetExtraControl( port, data )    outp( (port)+IOP_EXTRA_CONTROL, data )

/* AscSetChipScsiID() is a function */

/*
** Macro for read/write BANK 1 registers
*/

#define AscReadChipAX( port )               ( ushort )inpw( (port)+IOP_REG_AX )
#define AscWriteChipAX( port, data )        outpw( (port)+IOP_REG_AX, data )

#define AscReadChipIX( port )               ( uchar )inp( (port)+IOP_REG_IX )
#define AscWriteChipIX( port, data )        outp( (port)+IOP_REG_IX, data )

#define AscReadChipIH( port )               ( ushort )inpw( (port)+IOP_REG_IH )
#define AscWriteChipIH( port, data )        outpw( (port)+IOP_REG_IH, data )

#define AscReadChipQP( port )               ( uchar )inp( (port)+IOP_REG_QP )
#define AscWriteChipQP( port, data )        outp( (port)+IOP_REG_QP, data )

#define AscReadChipFIFO_L( port )           ( ushort )inpw( (port)+IOP_REG_FIFO_L )
#define AscWriteChipFIFO_L( port, data )    outpw( (port)+IOP_REG_FIFO_L, data )
#define AscReadChipFIFO_H( port )           ( ushort )inpw( (port)+IOP_REG_FIFO_H )
#define AscWriteChipFIFO_H( port, data )    outpw( (port)+IOP_REG_FIFO_H, data )

#define AscReadChipDmaSpeed( port )         ( uchar )inp( (port)+IOP_DMA_SPEED )
#define AscWriteChipDmaSpeed( port, data )  outp( (port)+IOP_DMA_SPEED, data )

#define AscReadChipDA0( port )              ( ushort )inpw( (port)+IOP_REG_DA0 )
#define AscWriteChipDA0( port )             outpw( (port)+IOP_REG_DA0, data )
#define AscReadChipDA1( port )              ( ushort )inpw( (port)+IOP_REG_DA1 )
#define AscWriteChipDA1( port )             outpw( (port)+IOP_REG_DA1, data )

#define AscReadChipDC0( port )              ( ushort )inpw( (port)+IOP_REG_DC0 )
#define AscWriteChipDC0( port )             outpw( (port)+IOP_REG_DC0, data )
#define AscReadChipDC1( port )              ( ushort )inpw( (port)+IOP_REG_DC1 )
#define AscWriteChipDC1( port )             outpw( (port)+IOP_REG_DC1, data )

#define AscReadChipDvcID( port )            ( uchar )inp( (port)+IOP_REG_ID )
#define AscWriteChipDvcID( port, data )     outp( (port)+IOP_REG_ID, data )


#endif /* __ASC1000_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc\ascbios.h ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** Filename: ascbios.h
**
**  Definition file for BIOS.
*/

#ifndef __ASC_BIOS_H_
#define __ASC_BIOS_H_

/* ------------------------------------------------------------------------
**       Structure defined for BIOS INT 13h, function 12h
** --------------------------------------------------------------------- */

typedef struct Bios_Info_Block {
        uchar    AdvSig[4] ;      /* 0    Signature                                          */
        uchar    productID[8] ;   /* 4    Product ID                                         */
        ushort   BiosVer ;        /* 12   BIOS Version                                       */
        PortAddr iopBase ;        /* 14 IO port address                                      */
        ushort   underBIOSMap ;   /* 16 Drive map - Under BIOS control                       */
        uchar    numOfDrive ;     /* 18 Num of drive under BIOS control for this controller  */
        uchar    startDrive ;     /* 19 Starting drive number under this BIOS control        */
        ushort   extTranslation ; /* 20 extended translation enable                          */
} BIOS_INFO_BLOCK ;


#define CTRL_A         0x1E01

#define BIOS_VER       0x0100  /* 1.00 */

#endif /* #ifndef __ASC_BIOS_H_  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc\ascinc.h ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** Filename: ascinc.h
**
*/

#ifndef __ASCINC_H_
#define __ASCINC_H_

#include "ascdef.h"
#include "a_osdep.h"   /* os dependent */
#include "a_cc.h"      /* code generation control */
#include "ascdep.h"    /* chip dependent include file  */
#include "ascsidef.h"  /* ASC SCSI definition          */
#include "aspiq.h"     /* ASC QUEUE                    */

/* #include "aaspidef.h" */

#include "asc1000.h"
#include "asclib.h"

#include "a_ddlib.h"

#endif /* #ifndef __ASCINC_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc\ascdep.h ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** ascdep.h
**
*/

#ifndef __ASCDEP_H_
#define __ASCDEP_H_

/* -----------------------------------------------------------------
** Chip Dependent definition
**
** ASC_CHIP_VERSION == 1
**
** ASC_CHIP_VERSION == 2
**
** 1. status is 16 bits (
** 2. IRQ is in CHIP Configuration registers
** 3.
** 4.
** 5.
**
**  VL   - ASC_CHIP_VERSION=3  ( version 1 and 2 should not be used )
**  PCI  - ASC_CHIP_VERSION=9
**  ISA  - ASC_CHIP_VERSION=17 ( 0x11 )
**  EISA - ASC_CHIP_VERSION=35 ( 0x23, use VL version 3 )
**
** ASC_CHIP_VERSION number
** VL   - 3  to 7
** PCI  - 9  to 15
** ISA  - 17 to 23
** ISAPNP - 33 to 39
** EISA - 65 to 71
**
** -------------------------------------------------------------- */

/*
** Some compiler default setting
*/
#ifndef CC_TARGET_MODE
#define CC_TARGET_MODE         FALSE  /* enable target mode ( processor device ) */
#endif /* CC_TARGET_MODE */

#ifndef CC_STRUCT_ALIGNED
#define CC_STRUCT_ALIGNED      FALSE
#endif /* CC_STRUCT_ALIGNED */

#ifndef CC_LITTLE_ENDIAN_HOST
#define CC_LITTLE_ENDIAN_HOST  TRUE   /* host is little-endian machine, Example: IBM PC with Intel CPUs */
#endif /* CC_LITTLE_ENDIAN_HOST */

#ifndef CC_TEST_LRAM_ENDIAN
#define CC_TEST_LRAM_ENDIAN    FALSE
#endif /* if CC_TEST_LRAM_ENDIAN not defined */

#ifndef CC_MEMORY_MAPPED_IO
#define CC_MEMORY_MAPPED_IO    FALSE
#endif /* CC_MEMORY_MAPPIO */

#ifndef CC_WRITE_IO_COUNT
#define CC_WRITE_IO_COUNT      FALSE
#endif

#ifndef CC_CLEAR_DMA_REMAIN
#define CC_CLEAR_DMA_REMAIN    FALSE
#endif

#ifndef CC_ASC_SCSI_Q_USRDEF
#define CC_ASC_SCSI_Q_USRDEF         FALSE
#endif

#ifndef CC_ASC_SCSI_REQ_Q_USRDEF
#define CC_ASC_SCSI_REQ_Q_USRDEF     FALSE
#endif

#ifndef CC_ASCISR_CHECK_INT_PENDING
#define CC_ASCISR_CHECK_INT_PENDING  TRUE  /* ADVW32.386 and PowerPC SIM set this false */
#endif

#ifndef CC_CHK_FIX_EEP_CONTENT
#define CC_CHK_FIX_EEP_CONTENT       TRUE
#endif

#ifndef CC_CHK_AND_COALESCE_SG_LIST
#define CC_CHK_AND_COALESCE_SG_LIST  FALSE
#endif


#ifndef CC_DISABLE_PCI_PARITY_INT
#define CC_DISABLE_PCI_PARITY_INT    TRUE  /* turn CFG_MSW bit 0 - 5 off */
#endif                                     /* generate h/w interrupt if error */

#ifndef CC_PCI_ADAPTER_ONLY
#define CC_PCI_ADAPTER_ONLY          FALSE  /* PowerMac SIM set this TRUE to reduce code size */
#endif

#ifndef CC_INCLUDE_EEP_CONFIG
#define CC_INCLUDE_EEP_CONFIG        TRUE  /* PowerMac SIM set this FALSE */
#endif

#ifndef CC_INIT_INQ_DISPLAY
#define CC_INIT_INQ_DISPLAY          FALSE
#endif

#ifndef CC_INIT_TARGET_TEST_UNIT_READY
#define CC_INIT_TARGET_TEST_UNIT_READY  TRUE  /* PowerMac SIM set this FALSE */
#endif

#ifndef CC_INIT_TARGET_READ_CAPACITY
#define CC_INIT_TARGET_READ_CAPACITY  FALSE
#endif

#if CC_INIT_TARGET_TEST_UNIT_READY
#ifndef CC_INIT_TARGET_START_UNIT
#define CC_INIT_TARGET_START_UNIT       TRUE  /* PowerMac SIM set this FALSE */
#endif /* CC_INIT_TARGET_START_UNIT */
#else
#ifndef CC_INIT_TARGET_START_UNIT
#define CC_INIT_TARGET_START_UNIT       FALSE
#endif /* CC_INIT_TARGET_START_UNIT */
#endif

#ifndef CC_USE_AscResetSB
#define CC_USE_AscResetSB            TRUE
#endif

#ifndef CC_USE_AscResetDevice
#define CC_USE_AscResetDevice        TRUE
#endif

#ifndef CC_USE_AscAbortSRB
#define CC_USE_AscAbortSRB           TRUE
#endif

#ifndef CC_USE_DvcSetMemory
#define CC_USE_DvcSetMemory          FALSE
#endif

#ifndef CC_USE_DvcCopyMemory
#define CC_USE_DvcCopyMemory         FALSE
#endif

/*
 * Warning: Using this option may result in a stack overrun.
 * If this option is set TRUE AscISRCheckQDone() calls from
 * the interrupt handler AscStartUnit() to start another I/O.
 */
#ifndef CC_USE_AscISR_CheckQDone
#define CC_USE_AscISR_CheckQDone     FALSE
#endif

#ifndef CC_USE_AscSearchIOPortAddr100
#define CC_USE_AscSearchIOPortAddr100  FALSE
#endif

#ifndef CC_POWER_SAVER
#define CC_POWER_SAVER               FALSE
#endif

#ifndef CC_INIT_CLEAR_ASC_DVC_VAR
#define CC_INIT_CLEAR_ASC_DVC_VAR    TRUE
#endif

#ifndef CC_CHECK_RESTORE_LRAM_ADDR
#define CC_CHECK_RESTORE_LRAM_ADDR   FALSE
#endif

#ifndef CC_TEST_RW_LRAM
#define CC_TEST_RW_LRAM              FALSE
#endif

#ifndef CC_PCI_ULTRA
#define CC_PCI_ULTRA                 TRUE  /* include ultra scsi code or not */
#endif

#ifndef CC_PLEXTOR_VL
#define CC_PLEXTOR_VL                FALSE /* IRQ 14 routed to IRQ 9 */
#endif

#ifndef CC_INCLUDE_EISA
#define CC_INCLUDE_EISA              TRUE
#endif

#ifndef CC_INCLUDE_VL
#define CC_INCLUDE_VL                TRUE
#endif

#ifndef CC_TMP_USE_EEP_SDTR
#define CC_TMP_USE_EEP_SDTR          FALSE
#endif

#ifndef CC_CHK_COND_REDO_SDTR
#define CC_CHK_COND_REDO_SDTR        TRUE
#endif

#ifndef CC_SET_PCI_CONFIG_SPACE
#define CC_SET_PCI_CONFIG_SPACE  TRUE
#endif

#ifndef CC_FIX_QUANTUM_XP34301_1071
#define CC_FIX_QUANTUM_XP34301_1071  FALSE
#endif

#ifndef CC_CHECK_MCODE_SIZE_AT_COMPILE
#define CC_CHECK_MCODE_SIZE_AT_COMPILE  FALSE
#endif

#ifndef CC_DISABLE_PCI_BURST_MODE
#define CC_DISABLE_PCI_BURST_MODE  FALSE
#endif

#ifndef CC_INIT_SCSI_TARGET
#define CC_INIT_SCSI_TARGET TRUE
#endif

#define ASC_CS_TYPE  unsigned short

/*
** Normal DOS, pointer to  ASC_DVC_VAR is near
** windows need far pointer to ASC_DVC_VAR
*/
#ifndef asc_ptr_type
#define asc_ptr_type
#endif

#ifndef CC_SCAM
#define CC_SCAM  FALSE
#endif

#ifndef ASC_GET_PTR2FUNC
#define ASC_GET_PTR2FUNC( fun )  ( Ptr2Func )( fun )
#endif

/* flip high/low nibbles of a byte */
#define FLIP_BYTE_NIBBLE( x )    ( ((x<<4)& 0xFF) | (x>>4) )

/* -----------------------------------------------------------------
**
** -------------------------------------------------------------- */

/*
**
**  bit definition for asc_dvc->bus_type
**
*/
#define ASC_IS_ISA          (0x0001)
#define ASC_IS_ISAPNP       (0x0081)
#define ASC_IS_EISA         (0x0002)
#define ASC_IS_PCI          (0x0004)
#define ASC_IS_PCI_ULTRA    (0x0104)
#define ASC_IS_PCMCIA       (0x0008)
/* #define ASC_IS_PNP          (0x0010)  */ /* plug and play support */
#define ASC_IS_MCA          (0x0020)
#define ASC_IS_VL           (0x0040)

/*
** ISA plug and play
*/
#define ASC_ISA_PNP_PORT_ADDR  (0x279) /* printer status port, PNP address port */
#define ASC_ISA_PNP_PORT_WRITE (ASC_ISA_PNP_PORT_ADDR+0x800)
                    /* printer status port + 0x800, PNP write data port */

#define ASC_IS_WIDESCSI_16  (0x0100)
#define ASC_IS_WIDESCSI_32  (0x0200)

#define ASC_IS_BIG_ENDIAN   (0x8000) /* default is always Intel convention ( little endian ) */
                                     /* */
/* ---------------------------------------------- */
#define ASC_CHIP_MIN_VER_VL      (0x01)
#define ASC_CHIP_MAX_VER_VL      (0x07)

#define ASC_CHIP_MIN_VER_PCI     (0x09) /* 9, bit 4 set */
#define ASC_CHIP_MAX_VER_PCI     (0x0F) /* 15 */
#define ASC_CHIP_VER_PCI_BIT     (0x08) /* */

#define ASC_CHIP_MIN_VER_ISA     (0x11) /* 17, bit 5 set */
#define ASC_CHIP_MIN_VER_ISA_PNP (0x21) /* bit 6 set */
#define ASC_CHIP_MAX_VER_ISA     (0x27) /* 39 */
#define ASC_CHIP_VER_ISA_BIT     (0x30) /* */
#define ASC_CHIP_VER_ISAPNP_BIT  (0x20) /* */

#define ASC_CHIP_VER_ASYN_BUG    (0x21) /* This version of ISA has async xfer problem */

/*
 * PCI ULTRA Chip Revision Number Definitions
 *
 * Chip Revision Number - Bank 0, Base Address + 3
 */
#define ASC_CHIP_VER_PCI             0x08
#define ASC_CHIP_VER_PCI_ULTRA_3150  (ASC_CHIP_VER_PCI | 0x02)
#define ASC_CHIP_VER_PCI_ULTRA_3050  (ASC_CHIP_VER_PCI | 0x03)

/*
** Note: EISA has same version number as VL
**       the number generated is VL_version + ( ASC_CHIP_MIN_VER_EISA - 1 )
**       a VL version 3 chip when calling AscGetChipVersion()
**       will return version number 35
*/
#define ASC_CHIP_MIN_VER_EISA (0x41) /* 65, bit 7 set */
#define ASC_CHIP_MAX_VER_EISA (0x47) /* 71 */
#define ASC_CHIP_VER_EISA_BIT (0x40) /* */
#define ASC_CHIP_LATEST_VER_EISA   ( ( ASC_CHIP_MIN_VER_EISA - 1 ) + 3 )

#define ASC_MAX_LIB_SUPPORTED_ISA_CHIP_VER   0x21 // new ISA PNP start from 0x21
#define ASC_MAX_LIB_SUPPORTED_PCI_CHIP_VER   0x0A // PCI ultra starts from 0x0a

/* ---------------------------------------------- */
#define ASC_MAX_VL_DMA_ADDR     (0x07FFFFFFL)  /* 27 bit address = 128 MB */
#define ASC_MAX_VL_DMA_COUNT    (0x07FFFFFFL)

#define ASC_MAX_PCI_DMA_ADDR    (0xFFFFFFFFL)  /* 32 bit address = 4GB */
#define ASC_MAX_PCI_DMA_COUNT   (0xFFFFFFFFL)

#define ASC_MAX_ISA_DMA_ADDR    (0x00FFFFFFL)  /* 24 bit address = 16 MB */
#define ASC_MAX_ISA_DMA_COUNT   (0x00FFFFFFL)

#define ASC_MAX_EISA_DMA_ADDR   (0x07FFFFFFL)  /* 27 bit address = 128 MB */
#define ASC_MAX_EISA_DMA_COUNT  (0x07FFFFFFL)

#if !CC_STRUCT_ALIGNED

#define DvcGetQinfo( iop_base, s_addr, outbuf, words)  \
        AscMemWordCopyFromLram( iop_base, s_addr, outbuf, words)


#define DvcPutScsiQ( iop_base, s_addr, outbuf, words) \
        AscMemWordCopyToLram( iop_base, s_addr, outbuf, words)

#endif  /* if struct packing */

/*
**
*/
#ifdef ASC_CHIP_VERSION

/* #error defining ASC_CHIP_VERSION is no longer required ! */

#endif

/*
** ==========================================================================
*/
#if CC_MEMORY_MAPPED_IO

/*
** Macro for memory mapped i/o
*/
#define inp( port )            *( (uchar *)(port) )
#define outp( port, data )     *( (uchar *)(port) ) = ( uchar )( data )

/* #define inp( pb )              ( *( uchar  *)(pb) ) */
/* #define outp( pb, val_byte )   *( uchar  * )(pb) = (val_byte) */

#if CC_LITTLE_ENDIAN_HOST

#define inpw( port )              *( (ushort *)(port) )
#define outpw( port, data )       *( (ushort *)(port) ) = ( ushort )( data )

#else

/*
**
**  wordswap( word_val ) is a function that exchanges high/lower bytes of a word
**  that is word_val of 0x1234 retuns 0x3412
**
**  Warning:
**  the function should be inplemented as a function
**  to avoid i/o port being referenced more than once in macro
**
*/

#define inpw( port )             EndianSwap16Bit( (*((ushort *)(port))) )
#define outpw( port, data )      *( (ushort *)(port) ) = EndianSwap16Bit( (ushort)(data) )

#define inpw_noswap( port )          *( (ushort *)(port) )
#define outpw_noswap( port, data )   *( (ushort *)(port) ) = ( ushort )( data )

#endif /* CC_LITTLE_ENDIAN_HOST */

#endif /* CC_MEMORY_MAPPED_IO */


#ifndef inpw_noswap
#define inpw_noswap( port )         inpw( port )
#endif

#ifndef outpw_noswap
#define outpw_noswap( port, data )  outpw( port, data )
#endif

#endif /* __ASCDEP_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc\ascsidef.h ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** Filename: ASCSIDEF.H
**
*/

#ifndef __ASCSIDEF_H_
#define __ASCSIDEF_H_

/* --------------------------------------------------------------------
** SCSI definition file
**
**
** ------------------------------------------------------------------ */

#define ASC_SCSI_ID_BITS  3   /* bit width of scsi id */
#define ASC_SCSI_TIX_TYPE     uchar
#define ASC_ALL_DEVICE_BIT_SET  0xFF

/* --------------------------------------------------------- */
#ifdef ASC_WIDESCSI_16

#undef  ASC_SCSI_ID_BITS
#define ASC_SCSI_ID_BITS  4
#define ASC_ALL_DEVICE_BIT_SET  0xFFFF

#endif /* if is 16 bit wide scsi */

/* --------------------------------------------------------- */
#ifdef ASC_WIDESCSI_32

#undef  ASC_SCSI_ID_BITS
#define ASC_SCSI_ID_BITS  5
#define ASC_ALL_DEVICE_BIT_SET  0xFFFFFFFFL

#endif /* if is 32 bit wide scsi */

/*
**
*/
#if ASC_SCSI_ID_BITS == 3

#define ASC_SCSI_BIT_ID_TYPE  uchar /* default is byte for 8 bit SCSI bus */
#define ASC_MAX_TID       7
#define ASC_MAX_LUN       7
#define ASC_SCSI_WIDTH_BIT_SET  0xFF

/*
** if is 16 bit wide scsi
*/
#elif ASC_SCSI_ID_BITS == 4

#define ASC_SCSI_BIT_ID_TYPE   ushort
#define ASC_MAX_TID         15
#define ASC_MAX_LUN         7
#define ASC_SCSI_WIDTH_BIT_SET  0xFFFF

/*
** if is 32 bit wide scsi
*/
#elif ASC_SCSI_ID_BITS == 5

#define ASC_SCSI_BIT_ID_TYPE    ulong
#define ASC_MAX_TID         31
#define ASC_MAX_LUN         7
#define ASC_SCSI_WIDTH_BIT_SET  0xFFFFFFFF

#else

#error  ASC_SCSI_ID_BITS definition is wrong

#endif

#define ASC_MAX_SENSE_LEN   32
#define ASC_MIN_SENSE_LEN   14

#define ASC_MAX_CDB_LEN     12 /* maximum command descriptor block */

/* --------------------------------------------------------------
**
** -------------------------------------------------------------*/
#define SCSICMD_TestUnitReady     0x00
#define SCSICMD_Rewind            0x01
#define SCSICMD_Rezero            0x01
#define SCSICMD_RequestSense      0x03
#define SCSICMD_Format            0x04
#define SCSICMD_FormatUnit        0x04
#define SCSICMD_Read6             0x08
#define SCSICMD_Write6            0x0A
#define SCSICMD_Seek6             0x0B
#define SCSICMD_Inquiry           0x12
#define SCSICMD_Verify6           0x13
#define SCSICMD_ModeSelect6       0x15
#define SCSICMD_ModeSense6        0x1A

#define SCSICMD_StartStopUnit     0x1B
#define SCSICMD_LoadUnloadTape    0x1B
#define SCSICMD_ReadCapacity      0x25
#define SCSICMD_Read10            0x28
#define SCSICMD_Write10           0x2A
#define SCSICMD_Seek10            0x2B
#define SCSICMD_Erase10           0x2C
#define SCSICMD_WriteAndVerify10  0x2E
#define SCSICMD_Verify10          0x2F

#define SCSICMD_WriteBuffer       0x3B
#define SCSICMD_ReadBuffer        0x3C
#define SCSICMD_ReadLong          0x3E
#define SCSICMD_WriteLong         0x3F

#define SCSICMD_ReadTOC           0x43
#define SCSICMD_ReadHeader        0x44

#define SCSICMD_ModeSelect10      0x55
#define SCSICMD_ModeSense10       0x5A

/* -------------------------------------------------------------
** peripheral device type
** ---------------------------------------------------------- */
#define SCSI_TYPE_DASD     0x00
#define SCSI_TYPE_SASD     0x01
#define SCSI_TYPE_PRN      0x02
#define SCSI_TYPE_PROC     0x03 /* processor device type */
                                /* HP scanner return this type too */

#define SCSI_TYPE_WORM     0x04 /* some CD-R too */
#define SCSI_TYPE_CDROM    0x05
#define SCSI_TYPE_SCANNER  0x06
#define SCSI_TYPE_OPTMEM   0x07
#define SCSI_TYPE_MED_CHG  0x08
#define SCSI_TYPE_COMM     0x09
#define SCSI_TYPE_UNKNOWN  0x1F
#define SCSI_TYPE_NO_DVC   0xFF


#define ASC_SCSIDIR_NOCHK    0x00
        /* Direction determined by SCSI command, length not check */
#define ASC_SCSIDIR_T2H      0x08
        /* Transfer from SCSI Target to Host adapter, length check */
#define ASC_SCSIDIR_H2T      0x10
        /* Transfer from Host adapter to Target, length check  */
#define ASC_SCSIDIR_NODATA   0x18
        /* No data transfer */

/* -------------------------------------------------------------
** SENSE KEY
** ---------------------------------------------------------- */
#define SCSI_SENKEY_NO_SENSE      0x00
#define SCSI_SENKEY_UNDEFINED     0x01
#define SCSI_SENKEY_NOT_READY     0x02
#define SCSI_SENKEY_MEDIUM_ERR    0x03
#define SCSI_SENKEY_HW_ERR        0x04
#define SCSI_SENKEY_ILLEGAL       0x05
#define SCSI_SENKEY_ATTENTION     0x06
#define SCSI_SENKEY_PROTECTED     0x07
#define SCSI_SENKEY_BLANK         0x08
#define SCSI_SENKEY_V_UNIQUE      0x09
#define SCSI_SENKEY_CPY_ABORT     0x0A
#define SCSI_SENKEY_ABORT         0x0B
#define SCSI_SENKEY_EQUAL         0x0C
#define SCSI_SENKEY_VOL_OVERFLOW  0x0D
#define SCSI_SENKEY_MISCOMP       0x0E
#define SCSI_SENKEY_RESERVED      0x0F

/* -------------------------------------------------------------
** ASC ( Additional sense code )
** ---------------------------------------------------------- */
#define SCSI_ASC_POWER_ON_RESET   0x29 /* power on, reset, bus device reset occured */
#define SCSI_ASC_NOMEDIA          0x3A /* no media present */


/* -------------------------------------------------------------
**
** ---------------------------------------------------------- */
#define ASC_SRB_HOST( x )  ( ( uchar )( ( uchar )( x ) >> 4 ) )
#define ASC_SRB_TID( x )   ( ( uchar )( ( uchar )( x ) & ( uchar )0x0F ) )
/* #define ASC_SRB_DIR( x )   ( ( uchar )( ( uchar )( x ) & 0x18 ) ) */
#define ASC_SRB_LUN( x )   ( ( uchar )( ( uint )( x ) >> 13 ) )

/* take high byte of unit number put it into CDB block index 1 */
#define PUT_CDB1( x )   ( ( uchar )( ( uint )( x ) >> 8 ) )

/*
** SCSI status
*/
#define SS_GOOD              0x00 /* target has successfully completed the command  */
#define SS_CHK_CONDITION     0x02 /* contigent allegiance condition has occured     */
#define SS_CONDITION_MET     0x04 /* the requested operation is satisfied           */
#define SS_TARGET_BUSY       0x08 /* target is busy                                 */
#define SS_INTERMID          0x10 /* intermediate                                   */
#define SS_INTERMID_COND_MET 0x14 /* intermediate-condition met                     */
                                  /* the combination of condition-met ( 0x04 )      */
                                  /* and intermediate ( 0x10 ) statuses             */
#define SS_RSERV_CONFLICT    0x18 /* reservation conflict                           */
#define SS_CMD_TERMINATED    0x22 /* command terminated                             */
                                  /* by terminated I/O process message or           */
                                  /* a contigent allegiance condition has occured   */
#define SS_QUEUE_FULL        0x28 /* queue full                                     */

/* --------------------------------------------------------------
** SCSI messages
** ----------------------------------------------------------- */
#define MS_CMD_DONE    0x00 /* command completed            */

/*
** Extended Messages (Multi-Byte)
**
** Byte 0: 0x01
** Byte 1: Additional Message Length
** Byte 2: Message Code
** Byte 3 - Byte ((Additional Message Length + 2) - 1): Message Data
*/
#define MS_EXTEND      0x01 /* first byte of extended message */
/* SDTR (Synchronous Data Transfer Request) Extended Message */
#define MS_SDTR_LEN    0x03 /* SDTR additional message length */
#define MS_SDTR_CODE   0x01 /* SDTR message code */
/* WDTR (Wide Data Transfer Request) Extended Message */
#define MS_WDTR_LEN    0x02 /* WDTR additional message length */
#define MS_WDTR_CODE   0x03 /* WDTR message code*/
/* MDP (Modify Data Pointer) Extended Message */
#define MS_MDP_LEN    0x05 /* MDP additional message length */
#define MS_MDP_CODE   0x00 /* MDP message code */


/*
**
** One byte Messages
**
** one byte messages, 0x02 - 0x1F
** 0x12 - 0x1F: reserved for one-byte messages
**                                     I T, I-initiator T-target support
**                                          O: Optional, M:mandatory
*/
#define M1_SAVE_DATA_PTR        0x02 /*; O O save data pointer                */
#define M1_RESTORE_PTRS         0x03 /*; O O restore pointers                 */
#define M1_DISCONNECT           0x04 /*; O O disconnect                       */
#define M1_INIT_DETECTED_ERR    0x05 /*; M M initiator detected error         */
#define M1_ABORT                0x06 /*; O M abort                            */
#define M1_MSG_REJECT           0x07 /*; M M message reject                   */
#define M1_NO_OP                0x08 /*; M M no operation                     */
#define M1_MSG_PARITY_ERR       0x09 /*; M M message parity error             */
#define M1_LINK_CMD_DONE        0x0A /*; O O link command completed           */
#define M1_LINK_CMD_DONE_WFLAG  0x0B /*; O O link command completed with flag */
#define M1_BUS_DVC_RESET        0x0C /*; O M bus device reset                 */
#define M1_ABORT_TAG            0x0D /*; O O abort tag                        */
#define M1_CLR_QUEUE            0x0E /*; O O clear queue                      */
#define M1_INIT_RECOVERY        0x0F /*; O O initiate recovery                */
#define M1_RELEASE_RECOVERY     0x10 /*; O O release recovery                 */
#define M1_KILL_IO_PROC         0x11 /*; O O terminate i/o process            */

/*
** Two Byte Messages
**
** first byte of two-byte queue tag messages, 0x20 - 0x2F
** queue tag messages, 0x20 - 0x22
*/
#define M2_QTAG_MSG_SIMPLE      0x20 /* O O simple queue tag     */
#define M2_QTAG_MSG_HEAD        0x21 /* O O head of queue tag    */
#define M2_QTAG_MSG_ORDERED     0x22 /* O O ordered queue tag    */
#define M2_IGNORE_WIDE_RESIDUE  0x23 /* O O ignore wide residue  */

/*
**
*/
#if CC_LITTLE_ENDIAN_HOST
typedef struct {
  uchar peri_dvc_type   : 5 ; /* peripheral device type */
  uchar peri_qualifier  : 3 ; /* peripheral qualifier   */
} ASC_SCSI_INQ0 ;
#else
typedef struct {
  uchar peri_qualifier  : 3 ; /* peripheral qualifier   */
  uchar peri_dvc_type   : 5 ; /* peripheral device type */
} ASC_SCSI_INQ0 ;
#endif

/*
**
*/
#if CC_LITTLE_ENDIAN_HOST
typedef struct {
  uchar dvc_type_modifier : 7 ; /* device type modifier ( for SCSI I ) */
  uchar rmb      : 1 ; /* RMB - removable medium bit          */
} ASC_SCSI_INQ1 ;
#else
typedef struct {
  uchar rmb      : 1 ; /* RMB - removable medium bit          */
  uchar dvc_type_modifier : 7 ; /* device type modifier ( for SCSI I ) */
} ASC_SCSI_INQ1 ;
#endif

/*
**
*/
#if CC_LITTLE_ENDIAN_HOST
typedef struct {
  uchar ansi_apr_ver : 3 ; /* ANSI approved version */
  uchar ecma_ver : 3 ;     /* ECMA version          */
  uchar iso_ver  : 2 ;     /* ISO version           */
} ASC_SCSI_INQ2 ;
#else
typedef struct {
  uchar iso_ver  : 2 ;     /* ISO version           */
  uchar ecma_ver : 3 ;     /* ECMA version          */
  uchar ansi_apr_ver : 3 ; /* ANSI approved version */
} ASC_SCSI_INQ2 ;
#endif

/*
**
*/
#if CC_LITTLE_ENDIAN_HOST
typedef struct {
  uchar rsp_data_fmt : 4 ; /* response data format                                            */
                           /* 0   SCSI 1 */
                           /* 1   CCS */
                           /* 2   SCSI-2 */
                           /* 3-F reserved */
  uchar res      : 2 ;     /* reserved                                                        */
  uchar TemIOP   : 1 ;     /* terminate I/O process bit ( see 5.6.22 )                        */
  uchar aenc     : 1 ;     /* asynchronous event notification ( for Processor device type )   */
} ASC_SCSI_INQ3 ;
#else
typedef struct {
  uchar aenc     : 1 ;     /* asynchronous event notification ( for Processor device type )   */
  uchar TemIOP   : 1 ;     /* terminate I/O process bit ( see 5.6.22 )                        */
  uchar res      : 2 ;     /* reserved                                                        */
  uchar rsp_data_fmt : 4 ; /* response data format                                            */
                           /* 0   SCSI 1 */
                           /* 1   CCS */
                           /* 2   SCSI-2 */
                           /* 3-F reserved */
} ASC_SCSI_INQ3 ;
#endif

/*
**
*/
#if CC_LITTLE_ENDIAN_HOST
typedef struct {
  uchar StfRe   : 1 ; /* soft reset implemented                */
  uchar CmdQue  : 1 ; /* command queuing                       */
  uchar Reserved: 1 ; /* reserved                              */
  uchar Linked  : 1 ; /* linked command for this logical unit  */
  uchar Sync    : 1 ; /* synchronous data transfer             */
  uchar WBus16  : 1 ; /* wide bus 16 bit data transfer         */
  uchar WBus32  : 1 ; /* wide bus 32 bit data transfer         */
  uchar RelAdr  : 1 ; /* relative addressing mode              */
} ASC_SCSI_INQ7 ;
#else
typedef struct {
  uchar RelAdr  : 1 ; /* relative addressing mode              */
  uchar WBus32  : 1 ; /* wide bus 32 bit data transfer         */
  uchar WBus16  : 1 ; /* wide bus 16 bit data transfer         */
  uchar Sync    : 1 ; /* synchronous data transfer             */
  uchar Linked  : 1 ; /* linked command for this logical unit  */
  uchar Reserved: 1 ; /* reserved                              */
  uchar CmdQue  : 1 ; /* command queuing                       */
  uchar StfRe   : 1 ; /* soft reset implemented                */
} ASC_SCSI_INQ7 ;
#endif

/*
**
*/
typedef struct {
  ASC_SCSI_INQ0  byte0 ;          /*                          */
  ASC_SCSI_INQ1  byte1 ;          /*                          */
  ASC_SCSI_INQ2  byte2 ;          /*                          */
  ASC_SCSI_INQ3  byte3 ;          /*                          */
  uchar  add_len ;                /* additional length        */
  uchar  res1 ;                   /* reserved                 */
  uchar  res2 ;                   /* reserved                 */
  ASC_SCSI_INQ7  byte7 ;          /*                          */
  uchar  vendor_id[ 8 ] ;         /* vendor identification    */
  uchar  product_id[ 16 ] ;       /* product identification   */
  uchar  product_rev_level[ 4 ] ; /* product revision level   */
} ASC_SCSI_INQUIRY ;              /* 36 bytes */

/*
**
*/
#if CC_LITTLE_ENDIAN_HOST
typedef struct asc_req_sense {
  uchar err_code: 7 ;         /* 0  bit 0 to 6, if code 70h or 71h            */
  uchar info_valid: 1 ;       /*    bit 7, info1[] information is valid       */

  uchar segment_no ;          /* 1, segment number                            */

  uchar sense_key: 4 ;        /* 2, bit 3 - 0: sense key                      */
  uchar reserved_bit: 1 ;     /*    bit 4 reserved bit                        */
  uchar sense_ILI: 1 ;        /*    bit 5 EOM( end of medium encountered )    */
  uchar sense_EOM: 1 ;        /*    bit 6 ILI( length error )                 */
  uchar file_mark: 1 ;        /*    bit 7 file mark encountered               */

  uchar info1[ 4 ] ;          /* 3-6, information                             */
  uchar add_sense_len ;       /* 7, additional sense length                   */
  uchar cmd_sp_info[ 4 ] ;    /* 8-11, command specific infomation            */
  uchar asc ;                 /* 12, additional sense code                    */
  uchar ascq ;                /* 13, additional sense code qualifier          */
/*
** minimum request sense length stop here
*/
  uchar fruc ;                /* 14, field replaceable unit code              */

  uchar sks_byte0: 7 ;        /* 15,                                          */
  uchar sks_valid : 1 ;       /* 15, SKSV: sense key specific valid           */

  uchar sks_bytes[2] ;        /* 16-17, sense key specific, MSB is SKSV       */
  uchar notused[ 2 ] ;        /* 18-19,                                       */
  uchar ex_sense_code ;       /* 20, extended additional sense code           */
  uchar info2[ 4 ] ;          /* 21-24, additional sense bytes                */
} ASC_REQ_SENSE ;
#else
typedef struct asc_req_sense {
   uchar info_valid: 1 ;       /*    bit 7, info1[] information is valid       */
  uchar err_code: 7 ;         /* 0  bit 0 to 6, if code 70h or 71h            */

  uchar segment_no ;          /* 1, segment number                            */

  uchar file_mark: 1 ;        /*    bit 7 file mark encountered               */
  uchar sense_EOM: 1 ;        /*    bit 6 ILI( length error )                 */
  uchar sense_ILI: 1 ;        /*    bit 5 EOM( end of medium encountered )    */
  uchar reserved_bit: 1 ;     /*    bit 4 reserved bit                        */
  uchar sense_key: 4 ;        /* 2, bit 3 - 0: sense key                      */

  uchar info1[ 4 ] ;          /* 3-6, information                             */
  uchar add_sense_len ;       /* 7, additional sense length                   */
  uchar cmd_sp_info[ 4 ] ;    /* 8-11, command specific infomation            */
  uchar asc ;                 /* 12, additional sense code                    */
  uchar ascq ;                /* 13, additional sense code qualifier          */
/*
** minimum request sense length stop here
*/
  uchar fruc ;                /* 14, field replaceable unit code              */

  uchar sks_valid : 1 ;       /* 15, SKSV: sense key specific valid           */
  uchar sks_byte0: 7 ;        /* 15,                                          */

  uchar sks_bytes[2] ;        /* 16-17, sense key specific, MSB is SKSV       */
  uchar notused[ 2 ] ;        /* 18-19,                                       */
  uchar ex_sense_code ;       /* 20, extended additional sense code           */
  uchar info2[ 4 ] ;          /* 21-24, additional sense bytes                */
} ASC_REQ_SENSE ;
#endif

#endif /* #ifndef __ASCSIDEF_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc\ascdef.h ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** Filename: ascdef.h
**
*/

#ifndef __ASCDEF_H_
#define __ASCDEF_H_

#ifndef __USRDEF_H_

typedef unsigned char   uchar ;
typedef unsigned short  ushort ;
typedef unsigned int    uint ;
typedef unsigned long   ulong ;

typedef unsigned char   BYTE ;
typedef unsigned short  WORD ;
typedef unsigned long   DWORD ;

#ifndef BOOL
typedef int             BOOL ;
#endif

#ifndef NULL
#define NULL     (0)          /* zero          */
#endif

#define  REG     register

#define rchar    REG char
#define rshort   REG short
#define rint     REG int
#define rlong    REG long

#define ruchar   REG uchar
#define rushort  REG ushort
#define ruint    REG uint
#define rulong   REG ulong

#define NULLPTR   ( void *)0   /* null pointer  */
#define FNULLPTR  ( void dosfar *)0UL   /* Far null pointer  */
#define EOF      (-1)         /* end of file   */
#define EOS      '\0'         /* end of string */
#define ERR      (-1)         /* boolean error */
#define UB_ERR   (uchar)(0xFF)         /* unsigned byte error */
#define UW_ERR   (uint)(0xFFFF)        /* unsigned word error */
#define UL_ERR   (ulong)(0xFFFFFFFFUL)   /* unsigned long error */

#define iseven_word( val )  ( ( ( ( uint )val) & ( uint )0x0001 ) == 0 )
#define isodd_word( val )   ( ( ( ( uint )val) & ( uint )0x0001 ) != 0 )
#define toeven_word( val )  ( ( ( uint )val ) & ( uint )0xFFFE )

#define biton( val, bits )   ((( uint )( val >> bits ) & (uint)0x0001 ) != 0 )
#define bitoff( val, bits )  ((( uint )( val >> bits ) & (uint)0x0001 ) == 0 )
#define lbiton( val, bits )  ((( ulong )( val >> bits ) & (ulong)0x00000001UL ) != 0 )
#define lbitoff( val, bits ) ((( ulong )( val >> bits ) & (ulong)0x00000001UL ) == 0 )

  /* convert signed short word to unsigned short word */
#define  absh( val )    ( ( val ) < 0 ? -( val ) : ( val ) )
  /* swap high nibble and lower nibble of a byte */
#define  swapbyte( ch )  ( ( ( (ch) << 4 ) | ( (ch) >> 4 ) ) )

/*
** common sizes
*/
#ifndef GBYTE
#define GBYTE       (0x40000000UL)
#endif

#ifndef MBYTE
#define MBYTE       (0x100000UL)
#endif

#ifndef KBYTE
#define KBYTE       (0x400)
#endif

#define HI_BYTE(x) ( *( ( BYTE *)(&x)+1 ) )  /* Returns high byte of word */
#define LO_BYTE(x) ( *( ( BYTE *)&x ) )      /* Returns low byte of word */

/* added 18 Nov 1993, Jim Nelson */

#define HI_WORD(x) ( *( ( WORD *)(&x)+1 ) )
#define LO_WORD(x) ( *( ( WORD *)&x ) )

#ifndef MAKEWORD
#define MAKEWORD(lo, hi)    ((WORD) (((WORD) lo) | ((WORD) hi << 8)))
#endif

#ifndef MAKELONG
#define MAKELONG(lo, hi)    ((DWORD) (((DWORD) lo) | ((DWORD) hi << 16)))
#endif

#define SwapWords(dWord)        ((DWORD) ((dWord >> 16) | (dWord << 16)))
#define SwapBytes(word)         ((WORD) ((word >> 8) | (word << 8)))

/*
** big-endian to little-endian and back conversions
*/
#define BigToLittle(dWord) \
    ((DWORD) (SwapWords(MAKELONG(SwapBytes(LO_WORD(dWord)), SwapBytes(HI_WORD(dWord))))))
#define LittleToBig(dWord)      BigToLittle(dWord)

/* end JN */

#endif /* #ifndef __USRDEF_H_ */


/* --------------------------------------------------------------------
** PCI CONFIG SPACE
**
**   typedef struct
**   {
**       WORD        vendorID;
**       WORD        deviceID;
**       WORD        command;
**       WORD        status;
**       BYTE        revision;
**       BYTE        classCode[3];
**       BYTE        cacheSize;
**       BYTE        latencyTimer;
**       BYTE        headerType;
**       BYTE        BIST;
**       DWORD       baseAddress[6];
**       WORD        reserved[4];
**       DWORD       optionRomAddr;
**       WORD        reserved2[4];
**       BYTE        irqLine;
**       BYTE        irqPin;
**       BYTE        minGnt;
**       BYTE        maxLatency;
**   } PCI_CONFIG_SPACE;
**
** ------------------------------------------------------------------ */

/*
 * PCI Configuration Space Offsets
 */
#define AscPCIConfigVendorIDRegister      0x0000 /* 1 word */
#define AscPCIConfigDeviceIDRegister      0x0002 /* 1 word */
#define AscPCIConfigCommandRegister       0x0004 /* 1 word */
#define AscPCIConfigStatusRegister        0x0006 /* 1 word */
#define AscPCIConfigRevisionIDRegister    0x0008 /* 1 byte */
#define AscPCIConfigCacheSize             0x000C /* 1 byte */
#define AscPCIConfigLatencyTimer          0x000D /* 1 byte */
#define AscPCIIOBaseRegister              0x0010

#define AscPCICmdRegBits_IOMemBusMaster   0x0007

/*
 * Device Driver Macros
 */
#define ASC_PCI_ID2BUS( id )    ((id) & 0xFF)
#define ASC_PCI_ID2DEV( id )    (((id) >> 11) & 0x1F)
#define ASC_PCI_ID2FUNC( id )   (((id) >> 8) & 0x7)

#define ASC_PCI_MKID( bus, dev, func ) \
     ((((dev) & 0x1F) << 11) | (((func) & 0x7) << 8) | ((bus) & 0xFF))


/*
 * AdvanSys PCI Constants
 */

/* PCI Vendor ID */
#define ASC_PCI_VENDORID                  0x10CD

/* PCI Device IDs */
#define ASC_PCI_DEVICEID_1200A            0x1100      /* SCSI FAST Rev A */
#define ASC_PCI_DEVICEID_1200B            0x1200      /* SCSI FAST Rev B */
#define ASC_PCI_DEVICEID_ULTRA            0x1300      /* SCSI ULTRA */

/*
 * PCI ULTRA Revision IDs
 *
 * AdvanSys ULTRA ICs are differentiated by their PCI Revision ID.
 */
#define ASC_PCI_REVISION_3150             0x02        /* SCSI ULTRA 3150 */
#define ASC_PCI_REVISION_3050             0x03        /* SCSI ULTRA 3050 */


/*
**
** device driver function call return type
**
*/
#define  Asc_DvcLib_Status   int

#define  ASC_DVCLIB_CALL_DONE     (1)  // operation performed
#define  ASC_DVCLIB_CALL_FAILED   (0)  // operation not ferformed
#define  ASC_DVCLIB_CALL_ERROR    (-1) // operation


#endif /* #ifndef __ASCDEF_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc\asc_dvc.c ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** asc_dvc.c
**
*/

#include "a_ver.h"
#include "ascinc.h"

#if CC_SET_PCI_CONFIG_SPACE
/*
 * Read a word from the PCI Configuration Space using the device
 * driver supplied byte read function.
 */
ushort
AscReadPCIConfigWord(
    ASC_DVC_VAR asc_ptr_type *asc_dvc,
    ushort pci_config_offset)
{
    uchar       lsb, msb;

    lsb = DvcReadPCIConfigByte(asc_dvc, pci_config_offset);
    msb = DvcReadPCIConfigByte(asc_dvc, (ushort) (pci_config_offset + 1));

    return ((ushort) ((msb << 8) | lsb));
}
#endif /* CC_SET_PCI_CONFIG_SPACE */


ushort AscInitGetConfig(
          ASC_DVC_VAR asc_ptr_type *asc_dvc
       )
{
       ushort   warn_code ;
       PortAddr iop_base ;
#if CC_SET_PCI_CONFIG_SPACE
       ushort   PCIDeviceID;
       ushort   PCIVendorID;
       uchar    PCIRevisionID;
       uchar    prevCmdRegBits;
#endif /* CC_SET_PCI_CONFIG_SPACE */
#if CC_DISABLE_PCI_BURST_MODE
       ushort   cfg_lsw ;
#endif
       warn_code= 0 ;
       iop_base = asc_dvc->iop_base ;
       asc_dvc->init_state = ASC_INIT_STATE_BEG_GET_CFG ;
       if( asc_dvc->err_code != 0 )
       {
           return( UW_ERR ) ;
       }

#if CC_SET_PCI_CONFIG_SPACE
       if( asc_dvc->bus_type == ASC_IS_PCI )
       {
           PCIVendorID = AscReadPCIConfigWord(asc_dvc,
                                       AscPCIConfigVendorIDRegister);

           PCIDeviceID = AscReadPCIConfigWord(asc_dvc,
                                       AscPCIConfigDeviceIDRegister);

           PCIRevisionID = DvcReadPCIConfigByte(asc_dvc,
                                       AscPCIConfigRevisionIDRegister);

           if (PCIVendorID != ASC_PCI_VENDORID) {
               warn_code |= ASC_WARN_SET_PCI_CONFIG_SPACE ;
           }

           /*
            * All PCI adapters must have the I/O Space (0),
            * Memory Space (1), and Bus Master (2) bits set
            * in the PCI Configuration Command Register.
            */
           prevCmdRegBits = DvcReadPCIConfigByte(asc_dvc,
                                       AscPCIConfigCommandRegister);

           /* If the Bus Mastering bits aren't already set, try to set them. */
           if ((prevCmdRegBits & AscPCICmdRegBits_IOMemBusMaster) !=
               AscPCICmdRegBits_IOMemBusMaster)
           {
               DvcWritePCIConfigByte( asc_dvc, AscPCIConfigCommandRegister,
                  (uchar) (prevCmdRegBits | AscPCICmdRegBits_IOMemBusMaster));

               if ((DvcReadPCIConfigByte(asc_dvc, AscPCIConfigCommandRegister)
                    & AscPCICmdRegBits_IOMemBusMaster)
                   != AscPCICmdRegBits_IOMemBusMaster)
               {
                   warn_code |= ASC_WARN_SET_PCI_CONFIG_SPACE ;
               }
           }

           /*
            * ASC-1200 FAST ICs must set the Latency Timer to zero.
            *
            * ASC ULTRA ICs must set the Latency Timer to at least 0x20.
            */
           if ((PCIDeviceID == ASC_PCI_DEVICEID_1200A) ||
               (PCIDeviceID == ASC_PCI_DEVICEID_1200B))
           {
               DvcWritePCIConfigByte(asc_dvc, AscPCIConfigLatencyTimer, 0x00);
               if (DvcReadPCIConfigByte(asc_dvc, AscPCIConfigLatencyTimer)
                   != 0x00 )
               {
                   warn_code |= ASC_WARN_SET_PCI_CONFIG_SPACE ;
               }
           } else if (PCIDeviceID == ASC_PCI_DEVICEID_ULTRA)
           {
               if (DvcReadPCIConfigByte(asc_dvc, AscPCIConfigLatencyTimer)
                   < 0x20 )
               {
                   DvcWritePCIConfigByte(asc_dvc, AscPCIConfigLatencyTimer,
                       0x20);

                   if (DvcReadPCIConfigByte(asc_dvc, AscPCIConfigLatencyTimer)
                       < 0x20 )
                   {
                       warn_code |= ASC_WARN_SET_PCI_CONFIG_SPACE ;
                   }
               }
           }
       }
#endif /* CC_SET_PCI_CONFIG_SPACE */

       if( AscFindSignature( iop_base ) )
       {
           warn_code |= AscInitAscDvcVar( asc_dvc ) ;

#if CC_INCLUDE_EEP_CONFIG
           if( asc_dvc->init_state & ASC_INIT_STATE_WITHOUT_EEP )
           {
               warn_code |= AscInitWithoutEEP( asc_dvc ) ;
           }
           else
           {
               warn_code |= AscInitFromEEP( asc_dvc ) ;
           }
#else
           warn_code |= AscInitWithoutEEP( asc_dvc ) ;

#endif /* #if CC_INCLUDE_EEP_CONFIG */

           asc_dvc->init_state |= ASC_INIT_STATE_END_GET_CFG ;

           /*csf072795 Insure scsi_reset_wait is a reasonable value */
           if( asc_dvc->scsi_reset_wait > ASC_MAX_SCSI_RESET_WAIT )
           {
               asc_dvc->scsi_reset_wait = ASC_MAX_SCSI_RESET_WAIT ;
           }
       }/* if */
       else
       {
           asc_dvc->err_code = ASC_IERR_BAD_SIGNATURE ;
       }/* else */

#if CC_DISABLE_PCI_BURST_MODE
       if( asc_dvc->bus_type & ASC_IS_PCI )
       {
           cfg_lsw = AscGetChipCfgLsw( iop_base ) ;
           cfg_lsw &= ~ASC_PCI_CFG_LSW_BURST_MODE ;
           AscSetChipCfgLsw( iop_base, cfg_lsw ) ;
       }
#endif
       return( warn_code ) ;
}

/* -----------------------------------------------------------------------
**
** -------------------------------------------------------------------- */
ushort AscInitSetConfig(
          ASC_DVC_VAR asc_ptr_type *asc_dvc
       )
{
       ushort  warn_code ;

       warn_code= 0 ;
       asc_dvc->init_state |= ASC_INIT_STATE_BEG_SET_CFG ;
       if( asc_dvc->err_code != 0 ) return( UW_ERR ) ;
       if( AscFindSignature( asc_dvc->iop_base ) )
       {
           warn_code |= AscInitFromAscDvcVar( asc_dvc ) ;
           asc_dvc->init_state |= ASC_INIT_STATE_END_SET_CFG ;
       }/* if */
       else
       {
           asc_dvc->err_code = ASC_IERR_BAD_SIGNATURE ;
       }/* else */
       return( warn_code ) ;
}

/* -----------------------------------------------------------------------
**
** return warning code and set error code if fatal error occured
** -------------------------------------------------------------------- */
ushort AscInitFromAscDvcVar(
          ASC_DVC_VAR asc_ptr_type *asc_dvc
       )
{
       PortAddr iop_base ;
       ushort   cfg_msw ;
       ushort   warn_code ;
       ushort   pci_device_id ;

       iop_base = asc_dvc->iop_base ;
       pci_device_id = asc_dvc->cfg->pci_device_id ;
       warn_code = 0 ;

       cfg_msw = AscGetChipCfgMsw( iop_base ) ;

       if( ( cfg_msw & ASC_CFG_MSW_CLR_MASK ) != 0 )
       {
           cfg_msw &= ( ~( ASC_CFG_MSW_CLR_MASK ) ) ;
           warn_code |= ASC_WARN_CFG_MSW_RECOVER ;
           AscSetChipCfgMsw( iop_base, cfg_msw ) ;
       }/* if */

       if( ( asc_dvc->cfg->cmd_qng_enabled & asc_dvc->cfg->disc_enable ) !=
           asc_dvc->cfg->cmd_qng_enabled )
       {
           asc_dvc->cfg->disc_enable = asc_dvc->cfg->cmd_qng_enabled ;
           warn_code |= ASC_WARN_CMD_QNG_CONFLICT ;
       }/* if */

#if !CC_PCI_ADAPTER_ONLY

       if( AscGetChipStatus( iop_base ) & CSW_AUTO_CONFIG )
       {
           warn_code |= ASC_WARN_AUTO_CONFIG ;
/*
** when auto configuration is on, BIOS will be disabled
**
*/
       }/* if */

       if( ( asc_dvc->bus_type & ( ASC_IS_ISA | ASC_IS_VL ) ) != 0 )
       {
/*
** for VL, ISA only
*/
           if( AscSetChipIRQ( iop_base, asc_dvc->irq_no, asc_dvc->bus_type )
               != asc_dvc->irq_no )
           {
               asc_dvc->err_code |= ASC_IERR_SET_IRQ_NO ;
           }/* if */
       }/* if */
#endif /* #if !CC_PCI_ADAPTER_ONLY */

/*
**
*/
       if( asc_dvc->bus_type & ASC_IS_PCI )
       {
/*
**
** both PCI Fast and Ultra should enter here
*/
#if CC_DISABLE_PCI_PARITY_INT
               cfg_msw &= 0xFFC0 ;
               AscSetChipCfgMsw( iop_base, cfg_msw ) ;
#endif /* CC_DISABLE_PCI_PARITY_INT */

           if( ( asc_dvc->bus_type & ASC_IS_PCI_ULTRA ) == ASC_IS_PCI_ULTRA )
           {

           }
           else
           {
               if( ( pci_device_id == ASC_PCI_DEVICE_ID_REV_A ) ||
                   ( pci_device_id == ASC_PCI_DEVICE_ID_REV_B ) )
               {
                   asc_dvc->bug_fix_cntl |= ASC_BUG_FIX_IF_NOT_DWB ;
                   asc_dvc->bug_fix_cntl |= ASC_BUG_FIX_ASYN_USE_SYN ;

               }/* if */
           }
       }/* if */
       else if( asc_dvc->bus_type == ASC_IS_ISAPNP )
       {
#if !CC_PCI_ADAPTER_ONLY
/*
** fix ISAPNP (0x21) async xfer problem with sync offset one
*/
            if( AscGetChipVersion( iop_base, asc_dvc->bus_type )
                == ASC_CHIP_VER_ASYN_BUG )
            {
                asc_dvc->bug_fix_cntl |= ASC_BUG_FIX_ASYN_USE_SYN ;
                /* asc_dvc->pci_fix_asyn_xfer = ASC_ALL_DEVICE_BIT_SET ; */
            }/* if */
#endif
       }/* else */

       if( AscSetChipScsiID( iop_base, asc_dvc->cfg->chip_scsi_id ) !=
           asc_dvc->cfg->chip_scsi_id )
       {
           asc_dvc->err_code |= ASC_IERR_SET_SCSI_ID ;
       }/* if */

#if !CC_PCI_ADAPTER_ONLY
       if( asc_dvc->bus_type & ASC_IS_ISA )
       {
           AscSetIsaDmaChannel( iop_base, asc_dvc->cfg->isa_dma_channel ) ;
           AscSetIsaDmaSpeed( iop_base, asc_dvc->cfg->isa_dma_speed ) ;
       }/* if */
#endif /* #if !CC_PCI_ADAPTER_ONLY */

       return( warn_code ) ;
}

/* -----------------------------------------------------------------------
**
** return warning code
** -------------------------------------------------------------------- */
ushort AscInitAsc1000Driver(
          ASC_DVC_VAR asc_ptr_type *asc_dvc
       )
{
       ushort   warn_code ;
       PortAddr iop_base ;

extern ushort _mcode_size ;
extern ulong  _mcode_chksum ;
extern uchar  _mcode_buf[] ;

       iop_base = asc_dvc->iop_base ;
       warn_code = 0 ;
/*
**
** we must reset scsi bus, if only reset chip
** next DMA xfer will hang !!!
**
** however after AscResetChipAndScsiBus( ) before you do any data xfer
** you may reset chip as many times as you want
**
*/
       if( ( asc_dvc->dvc_cntl & ASC_CNTL_RESET_SCSI ) &&
           !( asc_dvc->init_state & ASC_INIT_RESET_SCSI_DONE ) )
       {
/*
** if AscGetChipScsiCtrl() is not zero, chip is hanging in certain scsi phase
** in this case, we must reset scsi bus !
*/
           AscResetChipAndScsiBus( asc_dvc ) ;
           DvcSleepMilliSecond( ( ulong )( ( ushort )asc_dvc->scsi_reset_wait*1000 ) ) ;
       }/* if */

       asc_dvc->init_state |= ASC_INIT_STATE_BEG_LOAD_MC ;
       if( asc_dvc->err_code != 0 ) return( UW_ERR ) ;
       if( !AscFindSignature( asc_dvc->iop_base ) )
       {
           asc_dvc->err_code = ASC_IERR_BAD_SIGNATURE ;
           return( warn_code ) ;
       }/* if */

       AscDisableInterrupt( iop_base ) ;

#if CC_SCAM
       if( !( asc_dvc->dvc_cntl & ASC_CNTL_NO_SCAM ) )
       {
           AscSCAM( asc_dvc ) ;
       }/* if */
#endif
/*
**     always setup memory after reset !!!
*/
       warn_code |= AscInitLram( asc_dvc ) ;
       if( asc_dvc->err_code != 0 ) return( UW_ERR ) ;
       if( AscLoadMicroCode( iop_base, 0, ( ushort dosfar *)_mcode_buf,
                             _mcode_size ) != _mcode_chksum )
       {
           asc_dvc->err_code |= ASC_IERR_MCODE_CHKSUM ;
           return( warn_code ) ;
       }/* if */
       warn_code |= AscInitMicroCodeVar( asc_dvc ) ;
       asc_dvc->init_state |= ASC_INIT_STATE_END_LOAD_MC ;
       AscEnableInterrupt( iop_base ) ;
       return( warn_code ) ;
}

/* -----------------------------------------------------------------------
**
** return warning code
** -------------------------------------------------------------------- */
ushort AscInitAscDvcVar(
          ASC_DVC_VAR asc_ptr_type *asc_dvc
       )
{
       int      i ;
       PortAddr iop_base ;
       ushort   warn_code ;
       uchar    chip_version ;

/*       asc_dvc->dvc_type = OS_TYPE ; */
       iop_base = asc_dvc->iop_base ;
       warn_code = 0 ;
       asc_dvc->err_code = 0 ;


       if(
           ( asc_dvc->bus_type &
           ( ASC_IS_ISA | ASC_IS_PCI | ASC_IS_EISA | ASC_IS_VL ) ) == 0
         )
       {
           asc_dvc->err_code |= ASC_IERR_NO_BUS_TYPE ;
       }/* if */
/*
**
** set chip halt ( idle )
** this also clear chip reset bit
**
*/
       AscSetChipControl( iop_base, CC_HALT ) ;
/*
**
** 6/28/96, since S87
** if chip status bit 12 is set, you cannot R/W EEP and Local RAM in VL/EISA chip
**
*/
       AscSetChipStatus( iop_base, 0 ) ;

#if CC_LINK_BUSY_Q
       for( i = 0 ; i <= ASC_MAX_TID ; i++ )
       {
            asc_dvc->scsiq_busy_head[ i ] = ( ASC_SCSI_Q dosfar *)0L ;
            asc_dvc->scsiq_busy_tail[ i ] = ( ASC_SCSI_Q dosfar *)0L ;
       }/* for */
#endif /* CC_LINK_BUSY_Q */

#if CC_INIT_CLEAR_ASC_DVC_VAR
       asc_dvc->bug_fix_cntl = 0 ;
       asc_dvc->pci_fix_asyn_xfer = 0 ;
       asc_dvc->pci_fix_asyn_xfer_always = 0 ;
       asc_dvc->init_state = 0 ;
       asc_dvc->sdtr_done = 0 ;
       asc_dvc->cur_total_qng = 0 ;
       asc_dvc->is_in_int = 0 ;
       asc_dvc->in_critical_cnt = 0 ;
/*       asc_dvc->dvc_reset = 0 ; */
       asc_dvc->last_q_shortage = 0 ;
       asc_dvc->use_tagged_qng = 0 ;
       asc_dvc->no_scam = 0 ;
       asc_dvc->unit_not_ready = 0 ;
       asc_dvc->queue_full_or_busy = 0 ;
       /* asc_dvc->req_count = 0L ; */
       /* asc_dvc->int_count = 0L ; */
       /* asc_dvc->busy_count = 0L ; */
       asc_dvc->redo_scam = 0 ;
       asc_dvc->res2 = 0 ;
       /* asc_dvc->res3 = 0 ; */
       asc_dvc->host_init_sdtr_index = 0 ;
       /* asc_dvc->res6 = 0 ; */
       asc_dvc->res7 = 0 ;
       asc_dvc->res8 = 0 ;

       asc_dvc->cfg->can_tagged_qng = 0 ;
       asc_dvc->cfg->cmd_qng_enabled = 0;
#endif /* CC_INIT_CLEAR_ASC_DVC_VAR */

       asc_dvc->dvc_cntl = ASC_DEF_DVC_CNTL ;
#if CC_INIT_SCSI_TARGET
       /*
        * Only if CC_INIT_SCSI_TARGET is set TRUE, then initialize
        * ASC_DVC_VAR 'init_sdtr' to all 1's.
        *
        * If CC_INIT_SCSI_TARGET is set FALSE, then the ASC_DVC_VAR
        * 'init_sdtr' bits are set in AscInquiryHandling().
        */
       asc_dvc->init_sdtr = ASC_SCSI_WIDTH_BIT_SET ;
#else /* CC_INIT_SCSI_TARGET */
       asc_dvc->init_sdtr = 0;
#endif /* CC_INIT_SCSI_TARGET */
       asc_dvc->max_total_qng = ASC_DEF_MAX_TOTAL_QNG ;
       asc_dvc->scsi_reset_wait = 3 ; /* delay after scsi bus reset */
       /* asc_dvc->irq_no = 10 ; */
       asc_dvc->start_motor = ASC_SCSI_WIDTH_BIT_SET ;
       asc_dvc->max_dma_count = AscGetMaxDmaCount( asc_dvc->bus_type ) ;

       asc_dvc->cfg->disc_enable = ASC_SCSI_WIDTH_BIT_SET ;
       asc_dvc->cfg->sdtr_enable = ASC_SCSI_WIDTH_BIT_SET ;
       asc_dvc->cfg->chip_scsi_id = ASC_DEF_CHIP_SCSI_ID ;
       asc_dvc->cfg->lib_serial_no = ASC_LIB_SERIAL_NUMBER ;
       asc_dvc->cfg->lib_version = ( ASC_LIB_VERSION_MAJOR << 8 ) |
                                     ASC_LIB_VERSION_MINOR ;

       chip_version = AscGetChipVersion( iop_base, asc_dvc->bus_type ) ;
       asc_dvc->cfg->chip_version = chip_version ;

       asc_dvc->sdtr_period_tbl[ 0 ] = SYN_XFER_NS_0 ;
       asc_dvc->sdtr_period_tbl[ 1 ] = SYN_XFER_NS_1 ;
       asc_dvc->sdtr_period_tbl[ 2 ] = SYN_XFER_NS_2 ;
       asc_dvc->sdtr_period_tbl[ 3 ] = SYN_XFER_NS_3 ;
       asc_dvc->sdtr_period_tbl[ 4 ] = SYN_XFER_NS_4 ;
       asc_dvc->sdtr_period_tbl[ 5 ] = SYN_XFER_NS_5 ;
       asc_dvc->sdtr_period_tbl[ 6 ] = SYN_XFER_NS_6 ;
       asc_dvc->sdtr_period_tbl[ 7 ] = SYN_XFER_NS_7 ;
       asc_dvc->max_sdtr_index = 7 ;

#if CC_PCI_ULTRA
       /*
        * PCI Ultra Initialization
        *
        * Because ASC_CHIP_VER_PCI_ULTRA_3050 is numerically greater
        * than ASC_CHIP_VER_PCI_ULTRA_3150, the following block will
        * be entered by ASC_CHIP_VER_PCI_ULTRA_3050.
        */
       if(
           ( asc_dvc->bus_type & ASC_IS_PCI )
           && ( chip_version >= ASC_CHIP_VER_PCI_ULTRA_3150 )
         )
       {
           asc_dvc->bus_type = ASC_IS_PCI_ULTRA ;

           asc_dvc->sdtr_period_tbl[ 0 ] = SYN_ULTRA_XFER_NS_0 ;
           asc_dvc->sdtr_period_tbl[ 1 ] = SYN_ULTRA_XFER_NS_1 ;
           asc_dvc->sdtr_period_tbl[ 2 ] = SYN_ULTRA_XFER_NS_2 ;
           asc_dvc->sdtr_period_tbl[ 3 ] = SYN_ULTRA_XFER_NS_3 ;
           asc_dvc->sdtr_period_tbl[ 4 ] = SYN_ULTRA_XFER_NS_4 ;
           asc_dvc->sdtr_period_tbl[ 5 ] = SYN_ULTRA_XFER_NS_5 ;
           asc_dvc->sdtr_period_tbl[ 6 ] = SYN_ULTRA_XFER_NS_6 ;
           asc_dvc->sdtr_period_tbl[ 7 ] = SYN_ULTRA_XFER_NS_7 ;
           asc_dvc->sdtr_period_tbl[ 8 ] = SYN_ULTRA_XFER_NS_8 ;
           asc_dvc->sdtr_period_tbl[ 9 ] = SYN_ULTRA_XFER_NS_9 ;
           asc_dvc->sdtr_period_tbl[ 10 ] = SYN_ULTRA_XFER_NS_10 ;
           asc_dvc->sdtr_period_tbl[ 11 ] = SYN_ULTRA_XFER_NS_11 ;
           asc_dvc->sdtr_period_tbl[ 12 ] = SYN_ULTRA_XFER_NS_12 ;
           asc_dvc->sdtr_period_tbl[ 13 ] = SYN_ULTRA_XFER_NS_13 ;
           asc_dvc->sdtr_period_tbl[ 14 ] = SYN_ULTRA_XFER_NS_14 ;
           asc_dvc->sdtr_period_tbl[ 15 ] = SYN_ULTRA_XFER_NS_15 ;
           asc_dvc->max_sdtr_index = 15 ;

           if (chip_version == ASC_CHIP_VER_PCI_ULTRA_3150)
           {
               AscSetExtraControl(iop_base,
                   (SEC_ACTIVE_NEGATE | SEC_SLEW_RATE));
           } else if (chip_version >= ASC_CHIP_VER_PCI_ULTRA_3050)
           {
               AscSetExtraControl(iop_base,
                   (SEC_ACTIVE_NEGATE | SEC_ENABLE_FILTER));
           }
       }/* if PCI ULTRA */
#endif /* #if CC_PCI_ULTRA */

       /*
        * Set the Extra Control Register for PCI FAST.  'bus_type' is
        * set to ASC_IS_PCI_ULTRA above for PCI ULTRA.
        */
       if (asc_dvc->bus_type == ASC_IS_PCI)
       {
           /* Only for PCI FAST */
           AscSetExtraControl(iop_base, (SEC_ACTIVE_NEGATE | SEC_SLEW_RATE));
       }

       asc_dvc->cfg->isa_dma_speed = ASC_DEF_ISA_DMA_SPEED ;
       if( AscGetChipBusType( iop_base ) == ASC_IS_ISAPNP )
       {
/*
** turn on active neagtion for better wave form
*/
           AscSetChipIFC( iop_base, IFC_INIT_DEFAULT ) ;
           asc_dvc->bus_type = ASC_IS_ISAPNP ;
       }

#if !CC_PCI_ADAPTER_ONLY
       if( ( asc_dvc->bus_type & ASC_IS_ISA ) != 0 )
       {
           asc_dvc->cfg->isa_dma_channel = ( uchar )AscGetIsaDmaChannel( iop_base ) ;
       }/* if */
#endif /* #if !CC_PCI_ADAPTER_ONLY */

       for( i = 0 ; i <= ASC_MAX_TID ; i++ )
       {
            asc_dvc->cur_dvc_qng[ i ] = 0 ;
            asc_dvc->max_dvc_qng[ i ] = ASC_MAX_SCSI1_QNG ;
            asc_dvc->scsiq_busy_head[ i ] = ( ASC_SCSI_Q dosfar * )0L ;
            asc_dvc->scsiq_busy_tail[ i ] = ( ASC_SCSI_Q dosfar * )0L ;
            asc_dvc->cfg->max_tag_qng[ i ] = ASC_MAX_INRAM_TAG_QNG ;
       }/* for */
       return( warn_code ) ;
}

#if CC_INCLUDE_EEP_CONFIG

/* -----------------------------------------------------------------------
**
** return warning code
** -------------------------------------------------------------------- */
ushort AscInitFromEEP(
          ASC_DVC_VAR asc_ptr_type *asc_dvc
       )
{
       ASCEEP_CONFIG eep_config_buf ;
       ASCEEP_CONFIG dosfar *eep_config ;
       PortAddr iop_base ;
       ushort   chksum ;
       ushort   warn_code ;
       ushort   cfg_msw, cfg_lsw ;
       int      i ;
       int      write_eep = 0;
/*     uchar    iop_byte ;  */
/*     uchar    irq_no ;    */

       iop_base = asc_dvc->iop_base ;
       warn_code = 0 ;
/*
** write to ucode var "halt_code"
** for old( BIOS ) micro code, chip is not idle but looping forever
** we may be able to stop it in this loop
*/
       AscWriteLramWord( iop_base, ASCV_HALTCODE_W, 0x00FE ) ;
/*
** request microcode to stop chip itself
*/
       AscStopQueueExe( iop_base ) ;
       if( ( AscStopChip( iop_base ) == FALSE ) ||
           ( AscGetChipScsiCtrl( iop_base ) != 0 ) )
       {
           asc_dvc->init_state |= ASC_INIT_RESET_SCSI_DONE ;
           AscResetChipAndScsiBus( asc_dvc ) ;
           DvcSleepMilliSecond( ( ulong )( ( ushort )asc_dvc->scsi_reset_wait*1000 ) ) ;
       }/* if */
       if( AscIsChipHalted( iop_base ) == FALSE )
       {
           asc_dvc->err_code |= ASC_IERR_START_STOP_CHIP ;
           return( warn_code ) ;
       }/* if */

/*
** we set PC to 0x80 to prevent EEPROM read error
** ( hardware will generate one extra clock to cause data to shife one bit )
*/
       AscSetPCAddr( iop_base, ASC_MCODE_START_ADDR ) ;
       if( AscGetPCAddr( iop_base ) != ASC_MCODE_START_ADDR )
       {
           asc_dvc->err_code |= ASC_IERR_SET_PC_ADDR ;
           return( warn_code ) ;
       }/* if */

       eep_config = ( ASCEEP_CONFIG dosfar *)&eep_config_buf ;
/*
** first thing before access anything !!!
** we must disable the target mode and local ram 8 bits
*/
       cfg_msw = AscGetChipCfgMsw( iop_base ) ;
       cfg_lsw = AscGetChipCfgLsw( iop_base ) ;

       if( ( cfg_msw & ASC_CFG_MSW_CLR_MASK ) != 0 )
       {
           cfg_msw &= ( ~( ASC_CFG_MSW_CLR_MASK ) ) ;
           warn_code |= ASC_WARN_CFG_MSW_RECOVER ;
           AscSetChipCfgMsw( iop_base, cfg_msw ) ;
       }/* if */
       chksum = AscGetEEPConfig( iop_base, eep_config, asc_dvc->bus_type ) ;
       if (chksum == 0) chksum = 0xaa55 ;     /* ensure not blank */

       if( AscGetChipStatus( iop_base ) & CSW_AUTO_CONFIG )
       {
           warn_code |= ASC_WARN_AUTO_CONFIG ;
/*
** when auto configuration is on, BIOS will be disabled
**
*/
           if( asc_dvc->cfg->chip_version == 3 )
           {
/*
** VERSION 3 ONLY, EEPROM BUG
*/
               if( eep_config->cfg_lsw != cfg_lsw )
               {
                   warn_code |= ASC_WARN_EEPROM_RECOVER ;
                   eep_config->cfg_lsw = AscGetChipCfgLsw( iop_base ) ;
               }/* if */
               if( eep_config->cfg_msw != cfg_msw )
               {
                   warn_code |= ASC_WARN_EEPROM_RECOVER ;
                   eep_config->cfg_msw = AscGetChipCfgMsw( iop_base ) ;
               }/* if */
           }/* if */
       }/* if */
/*
** always enable EEPROM host interrupt
*/
       eep_config->cfg_msw &= ( ~( ASC_CFG_MSW_CLR_MASK ) ) ;
       eep_config->cfg_lsw |= ASC_CFG0_HOST_INT_ON ;


       /*
        * Check the calculated EEPROM checksum against the checksum
        * stored in the EEPROM.
        */
       if( chksum != eep_config->chksum )
       {
           /*
            * Ignore checksum errors for cards with the ASC-3050
            * chip revision. This will include the ASC-3030 which
            * does not have EEPROM.
            *
            * For all other cards that have a bad checksu, set
            * 'write_eep' so that the EEPROM will be written
            * back out to try to correct the error.
            */
           if (AscGetChipVersion(iop_base, asc_dvc->bus_type) ==
                   ASC_CHIP_VER_PCI_ULTRA_3050 )
           {
               eep_config->init_sdtr = 0xFF;     /* Allow SDTR. */
               eep_config->disc_enable = 0xFF;   /* Allow Disconnect. */
               eep_config->start_motor = 0xFF;   /* Allow start motor. */
               eep_config->use_cmd_qng = 0;      /* No tag queuing. */
               eep_config->max_total_qng = 0xF0; /* 250 */
               eep_config->max_tag_qng = 0x20;   /* 32 */
               eep_config->cntl = 0xBFFF;
               eep_config->chip_scsi_id = 7;
               eep_config->no_scam = 0;          /* No SCAM. */
           }
           else
           {
               write_eep = 1 ;
               warn_code |= ASC_WARN_EEPROM_CHKSUM ;
           }
       }/* if */
#if CC_INIT_SCSI_TARGET
       /*
        * Only if CC_INIT_SCSI_TARGET is set TRUE, then initialize
        * ASC_DVC_VAR 'init_sdtr' to the EEPROM 'init_sdtr' value.
        *
        * If CC_INIT_SCSI_TARGET is set FALSE, then the ASC_DVC_VAR
        * 'init_sdtr' bits are set in AscInquiryHandling().
        */
       asc_dvc->init_sdtr = eep_config->init_sdtr ;
#endif /* CC_INIT_SCSI_TARGET */
       asc_dvc->cfg->sdtr_enable = eep_config->init_sdtr ;
       asc_dvc->cfg->disc_enable = eep_config->disc_enable ;

       /* Set the target id that should enable command queuing. */
       asc_dvc->cfg->cmd_qng_enabled = eep_config->use_cmd_qng ;
       asc_dvc->cfg->isa_dma_speed = eep_config->isa_dma_speed ;
       asc_dvc->start_motor = eep_config->start_motor ;
       asc_dvc->dvc_cntl = eep_config->cntl ;
       asc_dvc->no_scam = eep_config->no_scam ;

       if( !AscTestExternalLram( asc_dvc ) )
       {
           if(
               ( ( asc_dvc->bus_type & ASC_IS_PCI_ULTRA ) == ASC_IS_PCI_ULTRA )
             )
           {
               eep_config->max_total_qng = ASC_MAX_PCI_ULTRA_INRAM_TOTAL_QNG ;
               eep_config->max_tag_qng = ASC_MAX_PCI_ULTRA_INRAM_TAG_QNG ;
           }/* if */
           else
           {
               eep_config->cfg_msw |= 0x0800 ;
               cfg_msw |= 0x0800 ;  /* set ucode size to 2.5 KB */
               AscSetChipCfgMsw( iop_base, cfg_msw ) ;
/*
**
** we ignore EEP setting in PCI
**
*/
               eep_config->max_total_qng = ASC_MAX_PCI_INRAM_TOTAL_QNG ;
               eep_config->max_tag_qng = ASC_MAX_INRAM_TAG_QNG ;
           }/* if */
       }/* if there is no external RAM */
       else
       {
#if CC_TEST_RW_LRAM
           asc_dvc->err_code |= AscTestLramEndian( iop_base ) ;
#endif
       }
       if( eep_config->max_total_qng < ASC_MIN_TOTAL_QNG )
       {
           eep_config->max_total_qng = ASC_MIN_TOTAL_QNG ;
       }/* if */
       if( eep_config->max_total_qng > ASC_MAX_TOTAL_QNG )
       {
           eep_config->max_total_qng = ASC_MAX_TOTAL_QNG ;
       }/* if */
       if( eep_config->max_tag_qng > eep_config->max_total_qng )
       {
           eep_config->max_tag_qng = eep_config->max_total_qng ;
       }/* if */
       if( eep_config->max_tag_qng < ASC_MIN_TAG_Q_PER_DVC )
       {
           eep_config->max_tag_qng = ASC_MIN_TAG_Q_PER_DVC ;
       }/* if */

       asc_dvc->max_total_qng = eep_config->max_total_qng ;

       if( ( eep_config->use_cmd_qng & eep_config->disc_enable ) !=
           eep_config->use_cmd_qng )
       {
           eep_config->disc_enable = eep_config->use_cmd_qng ;
           warn_code |= ASC_WARN_CMD_QNG_CONFLICT ;
       }/* if */
/*
** we will now get irq number from CFG register instead of from EEPROM
*/
#if !CC_PCI_ADAPTER_ONLY
       if( asc_dvc->bus_type & ( ASC_IS_ISA | ASC_IS_VL) )
       {
           asc_dvc->irq_no = AscGetChipIRQ( iop_base, asc_dvc->bus_type ) ;
       }
#endif /* not PCI ONLY */

       eep_config->chip_scsi_id &= ASC_MAX_TID ;
       asc_dvc->cfg->chip_scsi_id = eep_config->chip_scsi_id ;

/*
**
** check do we need disable ultra sdtr ( from both host/target inited sdtr )
**
**
*/
       if(
           ( ( asc_dvc->bus_type & ASC_IS_PCI_ULTRA ) == ASC_IS_PCI_ULTRA )
           && !( asc_dvc->dvc_cntl & ASC_CNTL_SDTR_ENABLE_ULTRA )
         )
       {
/*
**
** some combination of cable/terminator ( for example with Iomega ZIP drive )
** we cannot work with ultra( fast-20 ) and fast-10 scsi device together
** the EEPROM device control bit 14 is used to turn off host inited ultra sdtr
**
** ultra PCI, but host inited SDTR use 10MB/sec speed, that is index two instead of zero
**
** - be very careful that asc_dvc->bus_type is already equals ASC_IS_PCI_ULTRA
**   which is verified and modified in function AscInitAscDvcVar()
**
*/
           asc_dvc->host_init_sdtr_index = ASC_SDTR_ULTRA_PCI_10MB_INDEX ;
       }
       for( i = 0 ; i <= ASC_MAX_TID ; i++ )
       {
#if CC_TMP_USE_EEP_SDTR
            asc_dvc->cfg->sdtr_period_offset[ i ] = eep_config->dos_int13_table[ i ] ;
#endif
            asc_dvc->dos_int13_table[ i ] = eep_config->dos_int13_table[ i ] ;
            asc_dvc->cfg->max_tag_qng[ i ] = eep_config->max_tag_qng ;
            asc_dvc->cfg->sdtr_period_offset[ i ] = ( uchar )( ASC_DEF_SDTR_OFFSET
                                                    | ( asc_dvc->host_init_sdtr_index << 4 ) ) ;
       }/* for */
/*
** wait motor spin up
**
**     asc_dvc->sleep_msec( ( ulong )( eep_config->spin_up_wait * 50 ) ) ;
**     asc_dvc->sleep_msec( 1000L ) ;
*/

/*
**
** this will write IRQ number back to EEPROM word 0
*/
       eep_config->cfg_msw = AscGetChipCfgMsw( iop_base ) ;

       /*
        * For boards with a bad EEPROM checksum, other than ASC-3050/3030
        * which might not have an EEPROM, try to re-write the EEPROM.
        *
        */
       if (write_eep)
       {
            /*
             * Ingore EEPROM write errors. A bad EEPROM will not prevent
             * the board from initializing.
             */
           (void) AscSetEEPConfig( iop_base, eep_config, asc_dvc->bus_type ) ;
       }
       return( warn_code ) ;
}

#endif /* CC_INCLUDE_EEP_CONFIG */

/* -----------------------------------------------------------------------
**
**
** PowerMac don't use EEP
**
** return warning code
** -------------------------------------------------------------------- */
ushort AscInitWithoutEEP(
          ASC_DVC_VAR asc_ptr_type *asc_dvc
       )
{
       PortAddr iop_base ;
       ushort   warn_code ;
       ushort   cfg_msw ;
       int      i ;
       int      max_tag_qng = ASC_MAX_INRAM_TAG_QNG ;

       iop_base = asc_dvc->iop_base ;
       warn_code = 0 ;

       cfg_msw = AscGetChipCfgMsw( iop_base ) ;

       if( ( cfg_msw & ASC_CFG_MSW_CLR_MASK ) != 0 )
       {
           cfg_msw &= ( ~( ASC_CFG_MSW_CLR_MASK ) ) ;
           warn_code |= ASC_WARN_CFG_MSW_RECOVER ;
           AscSetChipCfgMsw( iop_base, cfg_msw ) ;
       }/* if */

       if( !AscTestExternalLram( asc_dvc ) )
       {
           if(
               ( ( asc_dvc->bus_type & ASC_IS_PCI_ULTRA ) == ASC_IS_PCI_ULTRA )
             )
           {
               asc_dvc->max_total_qng = ASC_MAX_PCI_ULTRA_INRAM_TOTAL_QNG ;
               max_tag_qng = ASC_MAX_PCI_ULTRA_INRAM_TAG_QNG ;
           }/* if */
           else
           {
               cfg_msw |= 0x0800 ;  /* set ucode size to 2.5 KB */
               AscSetChipCfgMsw( iop_base, cfg_msw ) ;
               asc_dvc->max_total_qng = ASC_MAX_PCI_INRAM_TOTAL_QNG ;
               max_tag_qng = ASC_MAX_INRAM_TAG_QNG ;
           }/* if */
       }/* if there is no external RAM */
       else
       {
#if CC_TEST_RW_LRAM
           asc_dvc->err_code |= AscTestLramEndian( iop_base ) ;
#endif
       }

#if !CC_PCI_ADAPTER_ONLY

       if( asc_dvc->bus_type & ( ASC_IS_ISA | ASC_IS_VL ) )
       {
           asc_dvc->irq_no = AscGetChipIRQ( iop_base, asc_dvc->bus_type ) ;
       }
#endif
       for( i = 0 ; i <= ASC_MAX_TID ; i++ )
       {
            asc_dvc->dos_int13_table[ i ] = 0 ;
            asc_dvc->cfg->sdtr_period_offset[ i ] = ( uchar )( ASC_DEF_SDTR_OFFSET
                                                    | ( asc_dvc->host_init_sdtr_index << 4 ) ) ;
            asc_dvc->cfg->max_tag_qng[ i ] = ( uchar )max_tag_qng ;
       }/* for */
       return( warn_code ) ;
}

/* -----------------------------------------------------------------------
**
** this routine
** 1. set up micro code initialize micro code variable
** 2. run micro code at pc = 0x80
**
** return warning code
** -------------------------------------------------------------------- */
ushort AscInitMicroCodeVar(
          ASC_DVC_VAR asc_ptr_type *asc_dvc
       )
{
       int      i ;
       ushort   warn_code ;
       PortAddr iop_base ;
       ulong    phy_addr ;
/*
** set microcode variables
*/
       iop_base = asc_dvc->iop_base ;
       warn_code = 0 ;
       for( i = 0 ; i <= ASC_MAX_TID ; i++ )
       {
            AscPutMCodeInitSDTRAtID( iop_base, i,
                                     asc_dvc->cfg->sdtr_period_offset[ i ]
                                   ) ;
       }/* for */

       AscInitQLinkVar( asc_dvc ) ;

       AscWriteLramByte( iop_base, ASCV_DISC_ENABLE_B,
                         asc_dvc->cfg->disc_enable ) ;
       AscWriteLramByte( iop_base, ASCV_HOSTSCSI_ID_B,
                         ASC_TID_TO_TARGET_ID( asc_dvc->cfg->chip_scsi_id ) ) ;
       if( ( phy_addr = AscGetOnePhyAddr( asc_dvc,
            ( uchar dosfar *)asc_dvc->cfg->overrun_buf,
            ASC_OVERRUN_BSIZE ) ) == 0L )
       {
            asc_dvc->err_code |= ASC_IERR_GET_PHY_ADDR ;
       }/* if */
       else
       {
/*
** adjust address to double word boundary
** that is why we need 0x48 byte to create 0x40 size buffer
*/
            phy_addr = ( phy_addr & 0xFFFFFFF8UL ) + 8 ;
            AscWriteLramDWord( iop_base, ASCV_OVERRUN_PADDR_D, phy_addr );
            AscWriteLramDWord( iop_base, ASCV_OVERRUN_BSIZE_D,
                               ASC_OVERRUN_BSIZE-8 );
       }/* else */
/*
**     AscWriteLramByte( iop_base, ASCV_MCODE_CNTL_B,
**                       ( uchar )asc_dvc->cfg->mcode_cntl ) ;
*/

       asc_dvc->cfg->mcode_date = AscReadLramWord( iop_base,
                                              ( ushort )ASCV_MC_DATE_W ) ;
       asc_dvc->cfg->mcode_version = AscReadLramWord( iop_base,
                                                 ( ushort )ASCV_MC_VER_W ) ;
       AscSetPCAddr( iop_base, ASC_MCODE_START_ADDR ) ;
       if( AscGetPCAddr( iop_base ) != ASC_MCODE_START_ADDR )
       {
           asc_dvc->err_code |= ASC_IERR_SET_PC_ADDR ;
           return( warn_code ) ;
       }/* if */
       if( AscStartChip( iop_base ) != 1 )
       {
           asc_dvc->err_code |= ASC_IERR_START_STOP_CHIP ;
           return( warn_code ) ;
       }/* if */
       return( warn_code ) ;
}

/* ---------------------------------------------------------------------
** ISR call back function for initialization
**
** ------------------------------------------------------------------ */
void dosfar AscInitPollIsrCallBack(
          ASC_DVC_VAR asc_ptr_type *asc_dvc,
          ASC_QDONE_INFO dosfar *scsi_done_q
       )
{
       ASC_SCSI_REQ_Q dosfar *scsiq_req ;
       ASC_ISR_CALLBACK asc_isr_callback ;
       uchar  cp_sen_len ;
       uchar  i ;

       if( ( scsi_done_q->d2.flag & ASC_FLAG_SCSIQ_REQ ) != 0 )
       {
           scsiq_req = ( ASC_SCSI_REQ_Q dosfar *)scsi_done_q->d2.srb_ptr ;
           scsiq_req->r3.done_stat = scsi_done_q->d3.done_stat ;
           scsiq_req->r3.host_stat = scsi_done_q->d3.host_stat ;
           scsiq_req->r3.scsi_stat = scsi_done_q->d3.scsi_stat ;
           scsiq_req->r3.scsi_msg = scsi_done_q->d3.scsi_msg ;
           if( ( scsi_done_q->d3.scsi_stat == SS_CHK_CONDITION ) &&
               ( scsi_done_q->d3.host_stat == 0 ) )
           {
               cp_sen_len = ( uchar )ASC_MIN_SENSE_LEN ;
               if( scsiq_req->r1.sense_len < ASC_MIN_SENSE_LEN )
               {
                   cp_sen_len = ( uchar )scsiq_req->r1.sense_len ;
               }/* if */
               for( i = 0 ; i < cp_sen_len ; i++ )
               {
                    scsiq_req->sense[ i ] = scsiq_req->sense_ptr[ i ] ;
               }/* for */
           }/* if */
#if 0
           if( AscISR_CheckQDone( asc_dvc, scsi_done_q, scsiq_req->sense_ptr ) == 1 )
           {

           }/* if */
#endif
       }/* if */
       else
       {
           if( asc_dvc->isr_callback != 0 )
           {
               asc_isr_callback = ( ASC_ISR_CALLBACK )asc_dvc->isr_callback ;
               ( * asc_isr_callback )( asc_dvc, scsi_done_q ) ;
           }/* if */
       }/* else */
       return ;
}

/* ----------------------------------------------------------------------
**
** return 1 if there is external RAM
** return 0 if there is no external RAM
** ------------------------------------------------------------------- */
int    AscTestExternalLram(
          ASC_DVC_VAR asc_ptr_type *asc_dvc
       )
{
       PortAddr iop_base ;
       ushort   q_addr ;
       ushort   saved_word ;
       int      sta ;

       iop_base = asc_dvc->iop_base ;
       sta = 0 ;
/*
** if ucode size 2.0 KB, maximum queue = 30
** if ucode size 2.5 KB, maximum queue = 24
*/
       q_addr = ASC_QNO_TO_QADDR( 241 ) ; /* queue 241 doesn't exist if no external RAM */
       saved_word = AscReadLramWord( iop_base, q_addr ) ;

       AscSetChipLramAddr( iop_base, q_addr ) ;
       AscSetChipLramData( iop_base, 0x55AA ) ;

       DvcSleepMilliSecond(10);

       AscSetChipLramAddr( iop_base, q_addr ) ;
       if( AscGetChipLramData( iop_base ) == 0x55AA )
       {
           sta = 1 ; /* yes, has external RAM */
           AscWriteLramWord( iop_base, q_addr, saved_word ) ;
       }/* if */
       return( sta ) ;
}

#if CC_TEST_LRAM_ENDIAN

/* ----------------------------------------------------------------------
**
** Requirements:
** adapter must have external local RAM
** ( local RAM address 0 to 0x7fff must exist )
**
** return 0 if no error
** ------------------------------------------------------------------- */
ushort AscTestLramEndian(
          PortAddr iop_base
       )
{

#define TEST_LRAM_DWORD_ADDR  0x7FF0
#define TEST_LRAM_DWORD_VAL   0x12345678UL
#define TEST_LRAM_WORD_ADDR   0x7FFE
#define TEST_LRAM_WORD_VAL    0xAA55

       ulong   dword_val ;
       ushort  word_val ;
       uchar   byte_val ;

/*
**
*/
       AscWriteLramDWord( iop_base,
          TEST_LRAM_DWORD_ADDR,
          TEST_LRAM_DWORD_VAL ) ;

       dword_val = AscReadLramDWord( iop_base,
          TEST_LRAM_DWORD_ADDR ) ;
       if( dword_val != TEST_LRAM_DWORD_VAL )
       {
           return( ASC_IERR_RW_LRAM ) ;
       }
/*
**
*/
       AscWriteLramWord( iop_base,
          TEST_LRAM_WORD_ADDR,
          TEST_LRAM_WORD_VAL ) ;
       word_val = AscReadLramWord( iop_base, TEST_LRAM_WORD_ADDR ) ;
       if( word_val != TEST_LRAM_WORD_VAL )
       {
           return( ASC_IERR_RW_LRAM ) ;
       }
/*
**
*/
       byte_val = AscReadLramByte( iop_base, TEST_LRAM_WORD_ADDR ) ;
       if( byte_val != ( uchar )( TEST_LRAM_WORD_VAL & 0xFF ) )
       {
           return( ASC_IERR_RW_LRAM ) ;
       }
       byte_val = AscReadLramByte( iop_base, TEST_LRAM_WORD_ADDR+1 ) ;
       if( byte_val != ( TEST_LRAM_WORD_VAL >> 8 ) )
       {
           return( ASC_IERR_RW_LRAM ) ;
       }
       return( 0 ) ;
}

#endif /* CC_TEST_LRAM_ENDIAN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc\asclib.h ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** Filename: asclib.h
**
*/

#ifndef __ASCLIB_H_
#define __ASCLIB_H_

/* *******************************************************************
** asc_eep.c
** ***************************************************************** */
int    AscWriteEEPCmdReg( PortAddr iop_base, uchar cmd_reg ) ;
int    AscWriteEEPDataReg( PortAddr iop_base, ushort data_reg ) ;
void   AscWaitEEPRead( void ) ;
void   AscWaitEEPWrite( void ) ;
ushort AscReadEEPWord( PortAddr, uchar ) ;
ushort AscWriteEEPWord( PortAddr, uchar, ushort ) ;
ushort AscGetEEPConfig( PortAddr, ASCEEP_CONFIG dosfar *, ushort ) ;
int    AscSetEEPConfigOnce( PortAddr, ASCEEP_CONFIG dosfar *, ushort ) ;
int    AscSetEEPConfig( PortAddr, ASCEEP_CONFIG dosfar *, ushort ) ;
ushort AscEEPSum( PortAddr, uchar, uchar ) ;

/* *******************************************************************
** asc_chip.c
** ***************************************************************** */
int    AscStartChip( PortAddr ) ;
int    AscStopChip( PortAddr ) ;
void   AscSetChipIH( PortAddr, ushort ) ;

int    AscIsChipHalted( PortAddr ) ;

void   AscResetScsiBus( ASC_DVC_VAR asc_ptr_type * ) ;
int    AscResetChip( PortAddr ) ;
void   AscSetChipCfgDword( PortAddr, ulong ) ;
ulong  AscGetChipCfgDword( PortAddr ) ;

void   AscAckInterrupt( PortAddr ) ;
void   AscDisableInterrupt( PortAddr ) ;
void   AscEnableInterrupt( PortAddr ) ;
void   AscSetBank( PortAddr, uchar ) ;
uchar  AscGetBank( PortAddr ) ;
int    AscResetChipAndScsiBus( ASC_DVC_VAR asc_ptr_type * ) ;
ushort AscGetIsaDmaChannel( PortAddr ) ;
ushort AscSetIsaDmaChannel( PortAddr, ushort ) ;
uchar  AscSetIsaDmaSpeed( PortAddr, uchar ) ;
uchar  AscGetIsaDmaSpeed( PortAddr ) ;

/* ******************************************************************
** asc_lram.c
** **************************************************************** */
uchar  AscReadLramByte( PortAddr, ushort) ;
ushort AscReadLramWord( PortAddr, ushort ) ;
ulong  AscReadLramDWord( PortAddr, ushort ) ;
void   AscWriteLramWord( PortAddr, ushort, ushort ) ;
void   AscWriteLramDWord( PortAddr, ushort, ulong );
void   AscWriteLramByte( PortAddr, ushort, uchar ) ;

ulong  AscMemSumLramWord( PortAddr, ushort, int ) ;
void   AscMemWordSetLram( PortAddr, ushort, ushort, int ) ;
void   AscMemWordCopyToLram( PortAddr, ushort, ushort dosfar *, int ) ;
void   AscMemDWordCopyToLram( PortAddr, ushort, ulong dosfar *, int ) ;
void   AscMemWordCopyFromLram( PortAddr, ushort, ushort dosfar *, int ) ;
int    AscMemWordCmpToLram( PortAddr, ushort, ushort dosfar *, int ) ;

/* *******************************************************************
** asc_dvc.c
** ***************************************************************** */
ushort AscInitAscDvcVar( ASC_DVC_VAR asc_ptr_type * ) ;
ushort AscInitFromEEP( ASC_DVC_VAR asc_ptr_type * ) ;
ushort AscInitWithoutEEP( ASC_DVC_VAR asc_ptr_type * ) ;
ushort AscInitFromAscDvcVar( ASC_DVC_VAR asc_ptr_type * ) ;
ushort AscInitMicroCodeVar( ASC_DVC_VAR asc_ptr_type *asc_dvc ) ;
/* ushort AscGetSetConfig( ASC_DVC_VAR asc_ptr_type * ) ; */
/* ushort AscInitCfgRegister( ASC_DVC_VAR asc_ptr_type * ) ; */
/* ushort AscInitGetConfig( ASC_DVC_VAR asc_ptr_type * ) ; */
/* ushort AscInitAsc1000Driver( ASC_DVC_VAR asc_ptr_type * ) ; */
void dosfar AscInitPollIsrCallBack( ASC_DVC_VAR asc_ptr_type *,
                                    ASC_QDONE_INFO dosfar * ) ;
int    AscTestExternalLram( ASC_DVC_VAR asc_ptr_type * ) ;
ushort AscTestLramEndian( PortAddr ) ;


/* *******************************************************************
** a_qop.c
** int    AscHostReqRiscHalt( PortAddr )        ; 6-16-95
** ***************************************************************** */
uchar  AscMsgOutSDTR( ASC_DVC_VAR asc_ptr_type *, uchar, uchar ) ;

uchar  AscCalSDTRData( ASC_DVC_VAR asc_ptr_type *, uchar, uchar ) ;
void   AscSetChipSDTR( PortAddr, uchar, uchar ) ;
int    AscInitChipAllSynReg( ASC_DVC_VAR asc_ptr_type *, uchar ) ;
uchar  AscGetSynPeriodIndex( ASC_DVC_VAR asc_ptr_type *, ruchar ) ;
uchar  AscAllocFreeQueue( PortAddr, uchar ) ;
uchar  AscAllocMultipleFreeQueue( PortAddr, uchar, uchar ) ;
int    AscRiscHaltedAbortSRB( ASC_DVC_VAR asc_ptr_type *, ulong ) ;
int    AscRiscHaltedAbortTIX( ASC_DVC_VAR asc_ptr_type *, uchar ) ;
int    AscRiscHaltedAbortALL( ASC_DVC_VAR asc_ptr_type * ) ;
int    AscHostReqRiscHalt( PortAddr ) ;
int    AscStopQueueExe( PortAddr ) ;
int    AscStartQueueExe( PortAddr ) ;
int    AscCleanUpDiscQueue( PortAddr ) ;
int    AscCleanUpBusyQueue( PortAddr ) ;
int    _AscAbortTidBusyQueue( ASC_DVC_VAR asc_ptr_type *,
                              ASC_QDONE_INFO dosfar *, uchar ) ;
int    _AscAbortSrbBusyQueue( ASC_DVC_VAR asc_ptr_type *,
                              ASC_QDONE_INFO dosfar *, ulong ) ;
int    AscWaitTixISRDone( ASC_DVC_VAR asc_ptr_type *, uchar ) ;
int    AscWaitISRDone( ASC_DVC_VAR asc_ptr_type * ) ;
ulong  AscGetOnePhyAddr( ASC_DVC_VAR asc_ptr_type *, uchar dosfar *, ulong ) ;

/* *******************************************************************
** a_q.c
** ***************************************************************** */
int    AscSendScsiQueue( ASC_DVC_VAR asc_ptr_type *asc_dvc,
                         ASC_SCSI_Q dosfar *scsiq,
                         uchar n_q_required ) ;
int    AscPutReadyQueue( ASC_DVC_VAR asc_ptr_type *, ASC_SCSI_Q dosfar *, uchar ) ;
int    AscPutReadySgListQueue( ASC_DVC_VAR asc_ptr_type *,
                               ASC_SCSI_Q dosfar *, uchar ) ;
int    AscAbortScsiIO( ASC_DVC_VAR asc_ptr_type *, ASC_SCSI_Q dosfar * ) ;
void   AscExeScsiIO( ASC_DVC_VAR asc_ptr_type *, ASC_SCSI_Q dosfar * ) ;
int    AscSetChipSynRegAtID( PortAddr, uchar, uchar ) ;
int    AscSetRunChipSynRegAtID( PortAddr, uchar, uchar ) ;
ushort AscInitLram( ASC_DVC_VAR asc_ptr_type * ) ;
int    AscReInitLram( ASC_DVC_VAR asc_ptr_type * ) ;
ushort AscInitQLinkVar( ASC_DVC_VAR asc_ptr_type * ) ;
int    AscSetLibErrorCode( ASC_DVC_VAR asc_ptr_type *, ushort ) ;
int    _AscWaitQDone( PortAddr, ASC_SCSI_Q dosfar * ) ;

/* *******************************************************************
** a_osdep.c
** ***************************************************************** */
int    AscEnterCritical( void ) ;
void   AscLeaveCritical( int ) ;

/* *******************************************************************
** a_isr.c
** ***************************************************************** */
int    AscIsrChipHalted( ASC_DVC_VAR asc_ptr_type * ) ;
uchar  _AscCopyLramScsiDoneQ( PortAddr, ushort,
                              ASC_QDONE_INFO dosfar *, ulong ) ;
int    AscIsrQDone( ASC_DVC_VAR asc_ptr_type * ) ;
ushort AscIsrExeBusyQueue( ASC_DVC_VAR asc_ptr_type *, uchar ) ;
int    AscScsiSetupCmdQ( ASC_DVC_VAR asc_ptr_type *, ASC_SCSI_REQ_Q dosfar *,
                         uchar dosfar *, ulong ) ;

/* ******************************************************************
** asc_scsi.c
** **************************************************************** */
int    AscScsiInquiry( ASC_DVC_VAR asc_ptr_type *, ASC_SCSI_REQ_Q dosfar *,
                       uchar dosfar *, int ) ;
int    AscScsiTestUnitReady( ASC_DVC_VAR asc_ptr_type *, ASC_SCSI_REQ_Q dosfar * ) ;
int    AscScsiStartStopUnit( ASC_DVC_VAR asc_ptr_type *,
                             ASC_SCSI_REQ_Q dosfar *, uchar ) ;
int    AscScsiReadCapacity( ASC_DVC_VAR asc_ptr_type *,
                            ASC_SCSI_REQ_Q dosfar *,
                            uchar dosfar * ) ;

/* *******************************************************************
** asc_inq.c
** ***************************************************************** */
ulong  dosfar *swapfarbuf4( uchar dosfar * ) ;
int    PollQueueDone( ASC_DVC_VAR asc_ptr_type *,
                      ASC_SCSI_REQ_Q dosfar *,
                      int ) ;
int    PollScsiReadCapacity( ASC_DVC_VAR asc_ptr_type *,
                             ASC_SCSI_REQ_Q dosfar *,
                             ASC_CAP_INFO dosfar * ) ;
int    PollScsiInquiry( ASC_DVC_VAR asc_ptr_type *, ASC_SCSI_REQ_Q dosfar *,
                        uchar dosfar *, int ) ;
int    PollScsiTestUnitReady( ASC_DVC_VAR asc_ptr_type *,
                              ASC_SCSI_REQ_Q dosfar * ) ;
int    PollScsiStartUnit( ASC_DVC_VAR asc_ptr_type *,
                          ASC_SCSI_REQ_Q dosfar * ) ;
int    InitTestUnitReady( ASC_DVC_VAR asc_ptr_type *,
                          ASC_SCSI_REQ_Q dosfar * ) ;
void   AscDispInquiry( uchar, uchar, ASC_SCSI_INQUIRY dosfar * ) ;
int    AscPollQDone( ASC_DVC_VAR asc_ptr_type *,
                     ASC_SCSI_REQ_Q dosfar *, int ) ;
int    AscCompareString( uchar *, uchar *, int ) ;

/* ------------------------------------------------------------------
** asc_bios.c
** ---------------------------------------------------------------- */
int    AscSetBIOSBank( PortAddr, int, ushort ) ;
int    AscSetVlBIOSBank( PortAddr, int ) ;
int    AscSetEisaBIOSBank( PortAddr, int ) ;
int    AscSetIsaBIOSBank( PortAddr, int ) ;


/* *******************************************************************
** a_eisa.c
** ***************************************************************** */
ushort AscGetEisaChipCfg( PortAddr ) ;
ushort AscGetEisaChipGpReg( PortAddr ) ;
ushort AscSetEisaChipCfg( PortAddr, ushort ) ;
ushort AscSetEisaChipGpReg( PortAddr, ushort ) ;


/* *******************************************************************
** ae_init1.c
** ***************************************************************** */
ulong  AscGetEisaProductID( PortAddr ) ;
PortAddr AscSearchIOPortAddrEISA( PortAddr ) ;


/* *******************************************************************
** a_init1.c
** **************************************************************** */
void   AscClrResetScsiBus( PortAddr ) ;
uchar  AscGetChipScsiCtrl( PortAddr ) ;
uchar  AscSetChipScsiID( PortAddr, uchar ) ;
uchar  AscGetChipVersion( PortAddr, ushort ) ;
ushort AscGetChipBusType( PortAddr ) ;
ulong  AscLoadMicroCode( PortAddr, ushort,
                         ushort dosfar *, ushort );
int    AscFindSignature( PortAddr ) ;

/* ******************************************************************
** a_init2.c
** ******************************************************************/
PortAddr AscSearchIOPortAddr11( PortAddr ) ;
PortAddr AscSearchIOPortAddr100( PortAddr ) ;
void   AscToggleIRQAct( PortAddr ) ;
void   AscClrResetChip( PortAddr ) ;

short  itos( ushort, uchar dosfar *, short, short ) ;
int    insnchar( uchar dosfar *, short , short, ruchar, short ) ;
void   itoh( ushort, ruchar dosfar * ) ;
void   btoh( uchar, ruchar dosfar * ) ;
void   ltoh( ulong, ruchar dosfar * ) ;
uchar dosfar *todstr( ushort, uchar dosfar * ) ;
uchar dosfar *tohstr( ushort, uchar dosfar * ) ;
uchar dosfar *tobhstr( uchar, uchar dosfar * ) ;
uchar dosfar *tolhstr( ulong, uchar dosfar * ) ;


/* ******************************************************************
** a_init3.c
** ******************************************************************/
void   AscSetISAPNPWaitForKey( void ) ;
uchar  AscGetChipIRQ( PortAddr, ushort ) ;
uchar  AscSetChipIRQ( PortAddr, uchar, ushort ) ;

/* ******************************************************************
** a_bios.c
** ******************************************************************/
int    AscIsBiosEnabled( PortAddr, ushort ) ;
int    AscEnableBios( PortAddr, ushort ) ;
ushort AscGetChipBiosAddress( PortAddr, ushort ) ;
ushort AscSetChipBiosAddress( PortAddr, ushort, ushort ) ;
/* ulong  AscGetMaxDmaCount( ushort ) ; */ /* the function prototype in a_ddlib.h */

/* *******************************************************************
** asc_diag.c
** ***************************************************************** */
void   AscSingleStepChip( PortAddr ) ;


/* *******************************************************************
** asc_res.c
** ***************************************************************** */
int    AscPollQTailSync( PortAddr ) ;
int    AscPollQHeadSync( PortAddr ) ;
int    AscWaitQTailSync( PortAddr ) ;

/* *******************************************************************
** a_novell.c
** ***************************************************************** */
int    _AscRestoreMicroCode( PortAddr, ASC_MC_SAVED dosfar * ) ;


/* *******************************************************************
** a_scam.c
******************************************************************* */
int   AscSCAM( ASC_DVC_VAR asc_ptr_type * ) ;

/* *******************************************************************
** a_mmio.c
** added # S47
**
******************************************************************* */
ushort  SwapByteOfWord( ushort word_val ) ;
ulong   SwapWordOfDWord( ulong dword_val ) ;
ulong   AdjEndianDword( ulong dword_val ) ;

/* *******************************************************************
** a_endian c
** added # S47
**
******************************************************************* */
int     AscAdjEndianScsiQ( ASC_SCSI_Q dosfar * ) ;
int     AscAdjEndianQDoneInfo( ASC_QDONE_INFO dosfar * ) ;


/* *******************************************************************
** a_sg c
** added # S62
**
******************************************************************* */
int    AscCoalesceSgList( ASC_SCSI_Q dosfar  * );

/* *******************************************************************
** a_debug.c
** added since # S89
**
******************************************************************* */
int    AscVerWriteLramDWord( PortAddr, ushort, ulong ) ;
int    AscVerWriteLramWord( PortAddr, ushort, ushort ) ;
int    AscVerWriteLramByte( PortAddr, ushort, uchar ) ;


#endif /* __ASCLIB_H_  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc\asc_eep.c ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** asc_eep.c
**
*/

#include "ascinc.h"

#if CC_INCLUDE_EEP_CONFIG

#if 0

/*
**  how "ABP" is compress to 0x0450
**                      byte 0 bit 7 is 0
**  'A' equal 0b00001 - is byte 0 bit[6:2]
**  'B' equal 0b00010 - is byte 0 bit[1:0] and byte 1 bit[7:5]
**  'P' equal 0b10000 - is byte 1 bit[4:0]
**
**              A     B     P
**  binrary 0,00001,00010,10000  = 0x0450
*/


#define ISA_VID_LSW  0x5004 /* ABP compressed */
#define ISA_VID_MSW  0x0154 /* 0x54 plus revision number 0x01 */

/*
**  serial number byte 0 is unique device number, set to 0xZZ
**  means SCSI HOST ADAPTER
**
**  byte 1 to byte 3 is product serial number
**
**  currently only support one per system, thus 0xffffffff
*/

#define ISA_SERIAL_LSW  0xFF01
#define ISA_SERIAL_MSW  0xFFFF

ushort _isa_pnp_resource[ ] = {
        ISA_VID_MSW, ISA_VID_LSW, ISA_SERIAL_MSW, ISA_SERIAL_LSW, 0x0A3E,
        0x0129, 0x0015, 0x0000, 0x0100, 0x702A,
        0x220C, 0x9C00, 0x0147, 0x0100, 0x03F0,
        0x1010, 0xFD79 } ;

#endif /* if PNP */

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
int    AscWriteEEPCmdReg(
          PortAddr iop_base,
          uchar cmd_reg
       )
{
       uchar  read_back ;
       int    retry ;
#if 0
       uchar  numstr[ 12 ] ;
#endif
       retry = 0 ;
       while( TRUE )
       {
           AscSetChipEEPCmd( iop_base, cmd_reg ) ;
           DvcSleepMilliSecond( 1 ) ;
           read_back = AscGetChipEEPCmd( iop_base ) ;
           if( read_back == cmd_reg )
           {
               return( 1 ) ;
           }/* if */
           if( retry++ > ASC_EEP_MAX_RETRY )
           {
               return( 0 ) ;
           }/* if */
#if 0
           else
           {
               DvcDisplayString( "Write eep_cmd 0x" ) ;
               DvcDisplayString( tohstr( cmd_reg, numstr ) ) ;
               DvcDisplayString( ", read back 0x" ) ;
               DvcDisplayString( tohstr( read_back, numstr ) ) ;
               DvcDisplayString( "\r\n" ) ;

/*             printf( "write eeprom cmd reg 0x%04X, read back 0x%04X\n", cmd_reg, read_back ) ; */

           }/* else */
#endif
       }/* while */
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
int    AscWriteEEPDataReg(
          PortAddr iop_base,
          ushort data_reg
       )
{
       ushort  read_back ;
       int     retry ;

       retry = 0 ;
       while( TRUE )
       {
           AscSetChipEEPData( iop_base, data_reg ) ;
           DvcSleepMilliSecond( 1 ) ;
           read_back = AscGetChipEEPData( iop_base ) ;
           if( read_back == data_reg )
           {
               return( 1 ) ;
           }/* if */
           if( retry++ > ASC_EEP_MAX_RETRY )
           {
               return( 0 ) ;
           }/* if */
#if 0
           else
           {

               printf( "write eeprom data reg 0x%04X, read back 0x%04X\n", data_reg, read_back ) ;

           }/* else */
#endif
       }/* while */
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
void   AscWaitEEPRead(
          void
       )
{
#if 0
/*
** h/w support of EEPROM done status
** this is not working properly
*/
       while( ( AscGetChipStatus( iop_base ) & CSW_EEP_READ_DONE ) == 0 ) ;
       while( ( AscGetChipStatus( iop_base ) & CSW_EEP_READ_DONE ) != 0 ) ;
#endif
       DvcSleepMilliSecond( 1 ) ;  /* data will be ready in 24 micro second */
       return ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
void   AscWaitEEPWrite(
          void
       )
{
       DvcSleepMilliSecond( 20 ) ;  /* data will be ready in 24 micro second */
       return ;
}

/* ----------------------------------------------------------------------
** ushort AscReadEEPWord( ushort iop_base, ushort addr )
**
** description:
**
** return: return the word read from EEPROM
**
** Note: you must halt chip to access eeprom
** ------------------------------------------------------------------- */
ushort AscReadEEPWord(
          PortAddr iop_base,
          uchar  addr
       )
{
       ushort  read_wval ;
       uchar   cmd_reg ;

       AscWriteEEPCmdReg( iop_base, ASC_EEP_CMD_WRITE_DISABLE ) ;
       AscWaitEEPRead( ) ;
       cmd_reg = addr | ASC_EEP_CMD_READ ;
       AscWriteEEPCmdReg( iop_base, cmd_reg ) ;
       AscWaitEEPRead( ) ;
       read_wval = AscGetChipEEPData( iop_base ) ;
       AscWaitEEPRead( ) ;
       return( read_wval ) ;
}

/* ---------------------------------------------------------------------
** ushort AscWriteEEPWord( ushort iop_base, ushort addr, ushort word_value )
**
** description:
**
** return: return the word read back from EEPROM after written
**
** ------------------------------------------------------------------- */
ushort AscWriteEEPWord(
          PortAddr iop_base,
          uchar  addr,
          ushort word_val
       )
{
       ushort  read_wval ;

       read_wval = AscReadEEPWord( iop_base, addr ) ;
       if( read_wval != word_val )
       {
           AscWriteEEPCmdReg( iop_base, ASC_EEP_CMD_WRITE_ABLE ) ;
           AscWaitEEPRead( ) ;

           AscWriteEEPDataReg( iop_base, word_val ) ;
           AscWaitEEPRead( ) ;

           AscWriteEEPCmdReg( iop_base,
                       ( uchar )( ( uchar )ASC_EEP_CMD_WRITE | addr ) ) ;
           AscWaitEEPWrite( ) ;
/*
** we disable write EEP
** DATE: 5-6-94, we found this will cause it write to another location !
*/
           AscWriteEEPCmdReg( iop_base, ASC_EEP_CMD_WRITE_DISABLE ) ;
           AscWaitEEPRead( ) ;
           return( AscReadEEPWord( iop_base, addr ) ) ;
       }/* if */
       return( read_wval ) ;
}

/* ----------------------------------------------------------------------
** ushort AscGetEEPConfig( PortAddr iop_base, ushort *wbuf )
**
** description: read entire EEPROM configuration to buffer
**
** return: return the word read from EEPROM
**
** ------------------------------------------------------------------- */
ushort AscGetEEPConfig(
          PortAddr iop_base,
          ASCEEP_CONFIG dosfar *cfg_buf, ushort bus_type
       )
{
       ushort  wval ;
       ushort  sum ;
       ushort  dosfar *wbuf ;
       int     cfg_beg ;
       int     cfg_end ;
       int     s_addr ;
       int     isa_pnp_wsize ;

       wbuf = ( ushort dosfar *)cfg_buf ;
       sum = 0 ;
/*
** get chip configuration word
*/

       isa_pnp_wsize = 0 ;
#if 0
       if( ( bus_type & ASC_IS_ISA ) != 0 )
       {
           isa_pnp_wsize = ASC_EEP_ISA_PNP_WSIZE ;
       }/* if */
#endif
       for( s_addr = 0 ; s_addr < ( 2 + isa_pnp_wsize ) ; s_addr++, wbuf++ )
       {
            wval = AscReadEEPWord( iop_base, ( uchar )s_addr ) ;
            sum += wval ;
            *wbuf = wval ;
       }/* for */

       if( bus_type & ASC_IS_VL )
       {
           cfg_beg = ASC_EEP_DVC_CFG_BEG_VL ;
           cfg_end = ASC_EEP_MAX_DVC_ADDR_VL ;
       }/* if */
       else
       {
           cfg_beg = ASC_EEP_DVC_CFG_BEG ;
           cfg_end = ASC_EEP_MAX_DVC_ADDR ;
       }/* else */

       for( s_addr = cfg_beg ; s_addr <= ( cfg_end - 1 ) ;
            s_addr++, wbuf++ )
       {
            wval = AscReadEEPWord( iop_base, ( uchar )s_addr ) ;
            sum += wval ;
            *wbuf = wval ;
       }/* for */
       *wbuf = AscReadEEPWord( iop_base, ( uchar )s_addr ) ;
       return( sum ) ;
}


#if CC_CHK_FIX_EEP_CONTENT

/* ----------------------------------------------------------------------
** ushort AscSetEEPConfig( ushort iop_base, ushort *wbuf )
**
** description: write entire configuration buffer
**              ( struct ASCEEP_CONFIG ) to EEPROM
**
** return: return the word read from EEPROM
**
** Note: you must halt chip to access eeprom
** ------------------------------------------------------------------- */
int    AscSetEEPConfigOnce(
          PortAddr iop_base,
          ASCEEP_CONFIG dosfar *cfg_buf, ushort bus_type
       )
{
       int     n_error ;
       ushort  dosfar *wbuf ;
       ushort  sum ;
       int     s_addr ;
       int     cfg_beg ;
       int     cfg_end ;

       wbuf = ( ushort dosfar *)cfg_buf ;
       n_error = 0 ;
       sum = 0 ;
       for( s_addr = 0 ; s_addr < 2 ; s_addr++, wbuf++ )
       {
            sum += *wbuf ;
            if( *wbuf != AscWriteEEPWord( iop_base, ( uchar )s_addr, *wbuf ) )
            {
                n_error++ ;
            }/* if */
       }/* for */
#if 0
       if( ( bus_type & ASC_IS_ISAPNP ) ) == ASC_IS_ISAPNP )
       {
           for( i = 0 ; i < ASC_EEP_ISA_PNP_WSIZE ; s_addr++, wbuf++, i++ )
           {
                wval = _isa_pnp_resource[ i ] ;
                sum += wval ;
                if( wval != AscWriteEEPWord( iop_base, s_addr, wval ) )
                {
                    n_error++ ;
                }/* if */
           }/* for */
       }/* if */
#endif
       if( bus_type & ASC_IS_VL )
       {
           cfg_beg = ASC_EEP_DVC_CFG_BEG_VL ;
           cfg_end = ASC_EEP_MAX_DVC_ADDR_VL ;
       }/* if */
       else
       {
           cfg_beg = ASC_EEP_DVC_CFG_BEG ;
           cfg_end = ASC_EEP_MAX_DVC_ADDR ;
       }/* else */
       for( s_addr = cfg_beg ; s_addr <= ( cfg_end - 1 ) ;
            s_addr++, wbuf++ )
       {
            sum += *wbuf ;
            if( *wbuf != AscWriteEEPWord( iop_base, ( uchar )s_addr, *wbuf ) )
            {
                n_error++ ;
            }/* if */
       }/* for */
       *wbuf = sum ;
       if( sum != AscWriteEEPWord( iop_base, ( uchar )s_addr, sum ) )
       {
           n_error++ ;
       }/* if */
/*
**  for version 3 chip, we read back the whole block again
*/
       wbuf = ( ushort dosfar *)cfg_buf ;
       for( s_addr = 0 ; s_addr < 2 ; s_addr++, wbuf++ )
       {
            if( *wbuf != AscReadEEPWord( iop_base, ( uchar )s_addr ) )
            {
                n_error++ ;
            }/* if */
       }/* for */
       for( s_addr = cfg_beg ; s_addr <= cfg_end ;
            s_addr++, wbuf++ )
       {
            if( *wbuf != AscReadEEPWord( iop_base, ( uchar )s_addr ) )
            {
                n_error++ ;
            }/* if */
       }/* for */
       return( n_error ) ;
}

/* ----------------------------------------------------------------------
** ushort AscSetEEPConfig( ushort iop_base, ushort *wbuf )
**
** description: write entire configuration buffer
**              ( struct ASCEEP_CONFIG ) to EEPROM
**
** return: return the word read from EEPROM
**
** Note: you must halt chip to access eeprom
** ------------------------------------------------------------------- */
int    AscSetEEPConfig(
          PortAddr iop_base,
          ASCEEP_CONFIG dosfar *cfg_buf, ushort bus_type
       )
{
       int   retry ;
       int   n_error ;

       retry = 0 ;
       while( TRUE )
       {
           if( ( n_error = AscSetEEPConfigOnce( iop_base, cfg_buf,
               bus_type ) ) == 0 )
           {
               break ;
           }/* if */
           if( ++retry > ASC_EEP_MAX_RETRY )
           {
               break ;
           }/* if */
       }/* while */
       return( n_error ) ;
}
#endif /* CC_CHK_FIX_EEP_CONTENT */

/* ---------------------------------------------------------------------
** ushort AscEEPSum( ushort iop_base, ushort s_addr, ushort words )
**
** description:
**
** return: return the word read from EEPROM
**
** ------------------------------------------------------------------ */
ushort AscEEPSum(
          PortAddr iop_base,
          uchar s_addr,
          uchar words
       )
{
       ushort  sum ;
       uchar   e_addr ;
       uchar   addr ;

       e_addr = s_addr + words ;
       sum = 0 ;
       if( s_addr > ASC_EEP_MAX_ADDR ) return( sum ) ;
       if( e_addr > ASC_EEP_MAX_ADDR ) e_addr = ASC_EEP_MAX_ADDR ;
       for( addr = s_addr ; addr < e_addr ; addr++ )
       {
            sum += AscReadEEPWord( iop_base, addr ) ;
       }/* for */
       return( sum ) ;
}

#endif /* CC_INCLUDE_EEP_CONFIG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc\asc_chip.c ===
/*
** Copyright (c) 1994-1997 Advanced System Products, Inc.
** All Rights Reserved.
**
** asc_chip.c
**
*/

#include "ascinc.h"

/* --------------------------------------------------------------------
**
** ----------------------------------------------------------------- */
int    AscStartChip(
          PortAddr iop_base
       )
{
       AscSetChipControl( iop_base, 0 ) ;
       if( ( AscGetChipStatus( iop_base ) & CSW_HALTED ) != 0 )
       {
           return( 0 ) ; /* cannot start chip */
       }/* if */
       return( 1 ) ;
}

/* --------------------------------------------------------------------
**
** ----------------------------------------------------------------- */
int    AscStopChip(
          PortAddr iop_base
       )
{
       uchar  cc_val ;

       cc_val = AscGetChipControl( iop_base ) & ( ~( CC_SINGLE_STEP | CC_TEST | CC_DIAG ) ) ;
       AscSetChipControl( iop_base, ( uchar )( cc_val | CC_HALT ) ) ;
       AscSetChipIH( iop_base, INS_HALT ) ;
       AscSetChipIH( iop_base, INS_RFLAG_WTM ) ;
       if( ( AscGetChipStatus( iop_base ) & CSW_HALTED ) == 0 )
       {
           return( 0 ) ;
       }/* if */
       return( 1 ) ;
}

/* --------------------------------------------------------------------
**
** ----------------------------------------------------------------- */
int    AscIsChipHalted(
          PortAddr iop_base
       )
{

       if( ( AscGetChipStatus( iop_base ) & CSW_HALTED ) != 0 )
       {
           if( ( AscGetChipControl( iop_base ) & CC_HALT ) != 0 )
           {
               return( 1 ) ;
           }/* if */
       }/* if */
       return( 0 ) ;
}

/* --------------------------------------------------------------------
**
** ----------------------------------------------------------------- */
void   AscSetChipIH(
          PortAddr iop_base,
          ushort ins_code
       )
{
       AscSetBank( iop_base, 1 ) ;
       AscWriteChipIH( iop_base, ins_code ) ;
       AscSetBank( iop_base, 0 ) ;
       return ;
}

/* --------------------------------------------------------------------
**
** ----------------------------------------------------------------- */
void   AscAckInterrupt(
          PortAddr iop_base
       )
{
       /*  ushort  cfg ;  */
       uchar   host_flag ;
       uchar   risc_flag ;
       ushort  loop ;

/*
**       cfg = inpw( IOP0W_CONFIG_LOW ) ;
**       cfg &= CIW_SEL_33MHZ ;
**       cfg |= CIW_INT_ACK ;
**       outpw( IOP0W_INT_ACK, cfg ) ;
*/

#if 0
       /* disable interrupt at CFG  */
       cfg = AscGetChipCfgLsw( iop_base ) ;
       AscSetChipCfgLsw( iop_base, cfg & ~ASC_CFG0_HOST_INT_ON ) ;
#endif
       loop = 0 ;
       do {
           risc_flag = AscReadLramByte( iop_base, ASCV_RISC_FLAG_B ) ;
           if( loop++ > 0x7FFF ) {
               break ;
           }/* if */
       }while( ( risc_flag & ASC_RISC_FLAG_GEN_INT ) != 0 ) ;
/*
** ACK interrupt
*/
       host_flag = AscReadLramByte( iop_base, ASCV_HOST_FLAG_B ) & (~ASC_HOST_FLAG_ACK_INT) ;
       AscWriteLramByte( iop_base, ASCV_HOST_FLAG_B,
                         ( uchar )( host_flag | ASC_HOST_FLAG_ACK_INT ) ) ;

       AscSetChipStatus( iop_base, CIW_INT_ACK ) ;
       loop = 0 ;
       while( AscGetChipStatus( iop_base ) & CSW_INT_PENDING )
       {
           /* AscDelay( 1000L ) ; */
           AscSetChipStatus( iop_base, CIW_INT_ACK ) ;
           if( loop++ > 3 )
           {
               break ;
           }/* if */
       }/* if */
#if 0
       /* restore CFG */
       AscSetChipCfgLsw( iop_base, cfg | ASC_CFG0_HOST_INT_ON ) ;
#endif
       /* restore host_flag */
       AscWriteLramByte( iop_base, ASCV_HOST_FLAG_B, host_flag ) ;
       return ;
}

/* --------------------------------------------------------------------
**
** ----------------------------------------------------------------- */
void   AscDisableInterrupt(
          PortAddr iop_base
       )
{
       ushort  cfg ;

       cfg = AscGetChipCfgLsw( iop_base ) ;
       AscSetChipCfgLsw( iop_base, cfg & (~ASC_CFG0_HOST_INT_ON) ) ;
       return ;
}

/* --------------------------------------------------------------------
**
** ----------------------------------------------------------------- */
void   AscEnableInterrupt(
          PortAddr iop_base
       )
{
       ushort  cfg ;

       cfg = AscGetChipCfgLsw( iop_base ) ;
       AscSetChipCfgLsw( iop_base, cfg | ASC_CFG0_HOST_INT_ON ) ;
       return ;
}

/* --------------------------------------------------------------------
**
** ----------------------------------------------------------------- */
ulong  AscGetChipCfgDword(
          PortAddr iop_base
       )
{
       ushort  cfg_msw, cfg_lsw ;

       cfg_lsw = AscGetChipCfgLsw( iop_base ) ;
       cfg_msw = AscGetChipCfgMsw( iop_base ) ;
       return( ( ( ulong )cfg_msw << 16  ) | cfg_lsw ) ;
}

/* --------------------------------------------------------------------
**
** ----------------------------------------------------------------- */
void   AscSetChipCfgDword(
          PortAddr iop_base,
          ulong cfg_reg
       )
{
       AscSetChipCfgLsw( iop_base, ( ushort )cfg_reg ) ;
       AscSetChipCfgMsw( iop_base, ( ushort )( cfg_reg >> 16 ) ) ;
       return ;
}

/* --------------------------------------------------------------------
** set bank 0 or 1
**
** ----------------------------------------------------------------- */
void   AscSetBank(
          PortAddr iop_base,
          uchar bank
       )
{
       uchar  val ;

       val = AscGetChipControl( iop_base ) &
             ( ~( CC_SINGLE_STEP | CC_TEST | CC_DIAG | CC_SCSI_RESET | CC_CHIP_RESET ) ) ;
       if( bank == 1 )
       {
           val |= CC_BANK_ONE ;
       }/* if */
       else if( bank == 2 )
       {
           val |= CC_DIAG | CC_BANK_ONE ;
       }/* else */
       else
       {
           val &= ~CC_BANK_ONE ;
       }/* if */
       AscSetChipControl( iop_base, val ) ;
       return ;
}

/* --------------------------------------------------------------------
**
** ----------------------------------------------------------------- */
uchar  AscGetBank(
          PortAddr iop_base
       )
{
       if( ( AscGetChipControl( iop_base ) & CC_BANK_ONE ) == 0 )
       {
           return( 0 ) ;
       }/* if */
       else
       {
           return( 1 ) ;
       }/* else */
}

/* --------------------------------------------------------------------
**
** Note:
**   1. this function will reset SCSI bus
**
** ----------------------------------------------------------------- */
void   AscResetScsiBus( ASC_DVC_VAR asc_ptr_type *asc_dvc )   
         
{
       uchar  val ;
       PortAddr  iop_base;

       iop_base = asc_dvc->iop_base;



       val = AscGetChipControl( iop_base ) & ( ~( CC_SINGLE_STEP | CC_DIAG | CC_TEST ) ) ;
/*
** this is a temporary fix, to make sure the chip will halt
*/
       AscStopChip( iop_base ) ;
       AscSetChipControl( iop_base, ( uchar )( val | CC_SCSI_RESET | CC_HALT ) ) ;

       DvcDelayNanoSecond(asc_dvc, 60000);    /* 60 uSec.  Fix  Panasonic problem */
       val &= ~( CC_SCSI_RESET | CC_SINGLE_STEP | CC_DIAG | CC_TEST ) ;

       AscSetChipControl( iop_base, val | CC_HALT ) ;
       DvcSleepMilliSecond( 300 ) ;
       AscSetChipStatus( iop_base, CIW_CLR_SCSI_RESET_INT ) ;
       AscSetChipStatus( iop_base, 0 ) ;
       return ;
}

/* ---------------------------------------------------------------------
**
** Note:
**   1. this function will reset chip and SCSI bus, then place the chip
**      in halt state
**
** return TRUE if chip is halted
** return FALSE if not halted
** ------------------------------------------------------------------ */
int    AscResetChipAndScsiBus( ASC_DVC_VAR asc_ptr_type *asc_dvc )     
      
{
       PortAddr  iop_base;

       iop_base = asc_dvc->iop_base;

       while( AscGetChipStatus( iop_base ) & CSW_SCSI_RESET_ACTIVE ) ;
       AscStopChip( iop_base ) ;

       AscSetChipControl( iop_base, CC_CHIP_RESET | CC_SCSI_RESET | CC_HALT ) ;
       DvcDelayNanoSecond(asc_dvc,60000);    /* 60 uSec.  Fix  Panasonic problem */
/*
** this is a fix, to make sure the chip will halt
*/
       AscSetChipIH( iop_base, INS_RFLAG_WTM ) ;
       AscSetChipIH( iop_base, INS_HALT ) ;

       AscSetChipControl( iop_base, CC_CHIP_RESET | CC_HALT ) ;
       AscSetChipControl( iop_base, CC_HALT ) ;
       DvcSleepMilliSecond( 200 ) ;
       AscSetChipStatus( iop_base, CIW_CLR_SCSI_RESET_INT ) ;
       AscSetChipStatus( iop_base, 0 ) ;
       return( AscIsChipHalted( iop_base ) ) ;
}

/* ---------------------------------------------------------------------
**
** Note:
**   1. this function will reset chip, then place the chip
**      in halt state
** ------------------------------------------------------------------ */
int    AscResetChip(
          PortAddr iop_base
       )
{
       int i = 10;

       while ((AscGetChipStatus( iop_base ) & CSW_SCSI_RESET_ACTIVE) &&
              (i-- > 0)) 
       {
             DvcSleepMilliSecond(100); // Wait up to 1 second.
       }

       AscSetChipStatus( iop_base, 0 ) ;
       AscStopChip( iop_base ) ;
       AscSetChipControl( iop_base, CC_CHIP_RESET | CC_HALT ) ;
/*
** this is a fix, to make sure the chip will halt
*/
       AscSetChipIH( iop_base, INS_RFLAG_WTM ) ;
       AscSetChipIH( iop_base, INS_HALT ) ;

       DvcSleepMilliSecond( 60 ) ;
       AscSetChipControl( iop_base, CC_HALT ) ;

       return( AscIsChipHalted( iop_base ) ) ;
}

/* --------------------------------------------------------------
** Get maximum permisable DMA transfer address
** ----------------------------------------------------------- */
ulong  AscGetMaxDmaAddress(
          ushort bus_type
       )
{
#if !CC_PCI_ADAPTER_ONLY
       if( bus_type & ASC_IS_VL ) return( ASC_MAX_VL_DMA_ADDR ) ;
       if( bus_type & ASC_IS_ISA ) return( ASC_MAX_ISA_DMA_ADDR ) ;
       if( bus_type & ASC_IS_EISA ) return( ASC_MAX_EISA_DMA_ADDR ) ;
#endif
       if( bus_type & ASC_IS_PCI ) return( ASC_MAX_PCI_DMA_ADDR ) ;
       return( 0L ) ;
}


/* ----------------------------------------------------------------------
** Description: return maximum number of dam counter ( dword )
**
** ------------------------------------------------------------------- */
ulong  AscGetMaxDmaCount(
          ushort bus_type
       )
{
#if !CC_PCI_ADAPTER_ONLY
       if( bus_type & ASC_IS_ISA ) return( ASC_MAX_ISA_DMA_COUNT ) ;
       else if( bus_type & ( ASC_IS_EISA | ASC_IS_VL ) ) return( ASC_MAX_VL_DMA_COUNT ) ;
#endif
       return( ASC_MAX_PCI_DMA_COUNT ) ;
}

#if !CC_PCI_ADAPTER_ONLY

/* --------------------------------------------------------------
** get ASC ISA DMA channel number 5-7
** 0x00 - DMA 7
** 0x01 - DMA 5
** 0x02 - DMA 6
** ----------------------------------------------------------- */
ushort AscGetIsaDmaChannel(
          PortAddr iop_base
       )
{
       ushort channel ;

       channel = AscGetChipCfgLsw( iop_base ) & 0x0003 ;
       if( channel == 0x03 ) return( 0 ) ;
       else if( channel == 0x00 ) return( 7 ) ;
       return( channel + 4 ) ;
}

/* --------------------------------------------------------------
** Set ISA DMA channel 5-7
** ----------------------------------------------------------- */
ushort AscSetIsaDmaChannel(
          PortAddr iop_base,
          ushort dma_channel
       )
{
       ushort cfg_lsw ;
       uchar  value ;

       if( ( dma_channel >= 5 ) && ( dma_channel <= 7 ) )
       {
           /* AscDisableIsaDma( AscGetIsaDmaChannel( iop_base ) ) ; */
           if( dma_channel == 7 ) value = 0x00 ;
           else value = dma_channel - 4 ;
           cfg_lsw = AscGetChipCfgLsw( iop_base ) & 0xFFFC ; /* clear old value */
           cfg_lsw |= value ;
           AscSetChipCfgLsw( iop_base, cfg_lsw ) ;
           return( AscGetIsaDmaChannel( iop_base ) ) ;
       }/* if */
       return( 0 ) ;
}

/* --------------------------------------------------------------
** Set ISA DMA speed
** ----------------------------------------------------------- */
uchar  AscSetIsaDmaSpeed(
          PortAddr iop_base,
          uchar speed_value
       )
{
       speed_value &= 0x07 ;
       AscSetBank( iop_base, 1 ) ;
       AscWriteChipDmaSpeed( iop_base, speed_value ) ;
       AscSetBank( iop_base, 0 ) ;
       return( AscGetIsaDmaSpeed( iop_base ) ) ;
}

/* --------------------------------------------------------------
** Get ISA DMA speed
** ----------------------------------------------------------- */
uchar  AscGetIsaDmaSpeed(
          PortAddr iop_base
       )
{
       uchar speed_value ;

       AscSetBank( iop_base, 1 ) ;
       speed_value = AscReadChipDmaSpeed( iop_base ) ;
       speed_value &= 0x07 ;
       AscSetBank( iop_base, 0 ) ;
       return( speed_value ) ;
}

#endif /* if !CC_PCI_ADAPTER_ONLY */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc\asc_inq.c ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** asc_inq.c
**
*/

#include "ascinc.h"
#include "ascsidef.h"

#if CC_INIT_SCSI_TARGET
/* ---------------------------------------------------------------------
** Init SCSI devices
**
** NOTE:
**  1. if you don't want the capacity information, let cap_array parameter
**     equals zero
**  2. the work_sp_buf needs at least ASC_LIB_SCSIQ_WK_SP bytes of buffer
**
**     the work space must be a memory buffer that can be translated
**     by following virtural to physical address translation functions:
**     ( which are provided by each driver code )
**
**        ulong  DvcGetPhyAddr( uchar dosfar *buf_addr, ulong buf_len ) ;
**        ulong  DvcGetSGList( ASC_DVC_VAR asc_ptr_type *, uchar dosfar *,
**                             ulong, ASC_SG_HEAD dosfar * ) ;
**
**  3. if you want to write your own AscInitScsiTarget() function
**
**     a. you must first call AscInitPollBegin() to begin
**     b. then you may call AscInitPollTarget() as many time as you want
**     c. afterward use AscInitPollEnd() to end.
**
**     Warning: after using AscInitPollBegin() you must call AscInitPollEnd()
**              to end the polling process ! do not return from the function
**              without calling AscInitPollEnd()
**
** ------------------------------------------------------------------ */
int    AscInitScsiTarget(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          REG ASC_DVC_INQ_INFO dosfar *target,
          ruchar dosfar *work_sp_buf,
          REG ASC_CAP_INFO_ARRAY dosfar *cap_array,
          ushort cntl_flag
       )
{
       int     dvc_found ;
       int     sta ;
       ruchar   tid, lun ;
       ASC_SCSI_REQ_Q dosfar *scsiq ;
       ASC_SCSI_INQUIRY dosfar *inq ;
       /* ASC_MIN_SG_HEAD sg_head ; */
       ASC_CAP_INFO dosfar *cap_info ;
       uchar   max_lun_scan ;

       AscInitPollBegin( asc_dvc ) ;
       scsiq = ( ASC_SCSI_REQ_Q dosfar *)work_sp_buf ;
       inq = ( ASC_SCSI_INQUIRY dosfar *)( work_sp_buf + sizeof( ASC_SCSI_REQ_Q ) + 4 ) ;

#if CC_USE_DvcSetMemory
       DvcSetMemory( ( uchar dosfar *)target->type, sizeof( ASC_DVC_INQ_INFO ), SCSI_TYPE_NO_DVC ) ;
#else
       for( tid = 0 ; tid <= ASC_MAX_TID ; tid++ )
       {
            for( lun = 0 ; lun <= ASC_MAX_LUN ; lun++ )
            {
                 target->type[ lun ][ tid ] = SCSI_TYPE_NO_DVC ;
            }/* for */
       }/* for */
#endif
       dvc_found = 0 ;
       tid = 0 ;
       if( cntl_flag & 0x01 ) max_lun_scan = ASC_MAX_LUN ;
       else max_lun_scan = 0 ;
       for( ; tid <= ASC_MAX_TID ; tid++ )
       {
           for( lun = 0 ; lun <= max_lun_scan ; lun++ )
           {
                scsiq->r1.target_id = ASC_TID_TO_TARGET_ID( tid ) ;
                scsiq->r1.target_lun = lun ;
                scsiq->r2.target_ix = ASC_TIDLUN_TO_IX( tid, lun ) ;

                if( tid != asc_dvc->cfg->chip_scsi_id )
                {
                    if( cap_array != 0L )
                    {
                        cap_info = &cap_array->cap_info[ tid ][ lun ] ;
                    }/* if */
                    else
                    {
                        cap_info = ( ASC_CAP_INFO dosfar *)0L ;
                    }/* else */
                    sta = AscInitPollTarget( asc_dvc, scsiq, inq, cap_info ) ;
                    if( sta == 1 )
                    {
                       /*
                        * If the Peripheral Device Type is SCSI_TYPE_UNKNOWN
                        * (0x1F) and the Peripheral Qualifier is 0x3, then
                        * the LUN does not exist.
                        */
                        if( inq->byte0.peri_dvc_type == SCSI_TYPE_UNKNOWN &&
                            inq->byte0.peri_qualifier == 0x3
                           )
                        {
                            /* Non-existent LUN device - stop LUN scanning. */
                            break;
                        }
                        dvc_found++ ;
                        target->type[ tid ][ lun ] = inq->byte0.peri_dvc_type ;
                    }/* if */
                    else
                    {
                        /* AscInitPollTarget() returned an error. */
                        if( sta == ERR ) break ;
                        if( lun == 0 ) break ;
                    }/* else */
                }/* if */
           }/* for */
       }/* for */
       AscInitPollEnd( asc_dvc ) ;
       return( dvc_found ) ;
}

/* -----------------------------------------------------------------------
**
** ---------------------------------------------------------------------*/
int    AscInitPollBegin(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc
       )
{
       PortAddr  iop_base ;

       iop_base = asc_dvc->iop_base ;

#if CC_INIT_INQ_DISPLAY
       DvcDisplayString( ( uchar dosfar *)"\r\n" ) ;
#endif /* CC_INIT_INQ_DISPLAY */

/*
**  reset chip to prevent chip generate an interrupt
**  when interrupt disabled
**
**  this could be a watch dog timer timeout
*/
       AscDisableInterrupt( iop_base ) ;

       asc_dvc->init_state |= ASC_INIT_STATE_BEG_INQUIRY ;
/*
** it was found disable interrupt generate an interrupt !?
** we need to have everything setup
*/
       AscWriteLramByte( iop_base, ASCV_DISC_ENABLE_B, 0x00 ) ;
       asc_dvc->use_tagged_qng = 0 ;
       asc_dvc->cfg->can_tagged_qng = 0 ;
       asc_dvc->saved_ptr2func = ( ulong )asc_dvc->isr_callback ;
       asc_dvc->isr_callback = ASC_GET_PTR2FUNC( AscInitPollIsrCallBack ) ;
       return( 0 ) ;
}

/* -----------------------------------------------------------------------
**
** ---------------------------------------------------------------------*/
int    AscInitPollEnd(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc
       )
{
       PortAddr  iop_base ;
       rint  i ;

       iop_base = asc_dvc->iop_base ;
       asc_dvc->isr_callback = ( Ptr2Func )asc_dvc->saved_ptr2func ;
       AscWriteLramByte( iop_base, ASCV_DISC_ENABLE_B,
                         asc_dvc->cfg->disc_enable ) ;
       AscWriteLramByte( iop_base, ASCV_USE_TAGGED_QNG_B,
                         asc_dvc->use_tagged_qng ) ;
       AscWriteLramByte( iop_base, ASCV_CAN_TAGGED_QNG_B,
                         asc_dvc->cfg->can_tagged_qng ) ;

       for( i = 0 ; i <= ASC_MAX_TID ; i++ )
       {
            AscWriteLramByte( iop_base,
               ( ushort )( ( ushort )ASCV_MAX_DVC_QNG_BEG+( ushort )i ),
                 asc_dvc->max_dvc_qng[ i ] ) ;
       }/* for */
/*
**  interrupt disabled in AscInitAsc1000Driver()
*/
/*
** if timer is timeout to fast
** there will be interrupt pending left here
*/
       AscAckInterrupt( iop_base ) ;
       AscEnableInterrupt( iop_base ) ;

#if CC_INIT_INQ_DISPLAY
       DvcDisplayString( ( uchar dosfar *)"\r\n" ) ;
#endif /* CC_INIT_INQ_DISPLAY */
       asc_dvc->init_state |= ASC_INIT_STATE_END_INQUIRY ;

       return( 0 ) ;
}
#endif /* CC_INIT_SCSI_TARGET */

void AscAsyncFix(ASC_DVC_VAR asc_ptr_type *, uchar,
    ASC_SCSI_INQUIRY dosfar *);

/*
 * AscAsyncFix()
 *
 * Simlpy set default to no asyn-fix on Processor, Scanner, CDROM,
 * and Tape devices. Selectively apply the fix for Asynchronous
 * Transfer problem which is to run in Synchronous Mode with offset one.
 */
void
AscAsyncFix(ASC_DVC_VAR asc_ptr_type *asc_dvc,
            uchar tid_no,
            ASC_SCSI_INQUIRY dosfar *inq)
{
    uchar  dvc_type;
    ASC_SCSI_BIT_ID_TYPE tid_bits;

    dvc_type = inq->byte0.peri_dvc_type;
    tid_bits = ASC_TIX_TO_TARGET_ID(tid_no);

    if(asc_dvc->bug_fix_cntl & ASC_BUG_FIX_ASYN_USE_SYN)
    {
        if(!( asc_dvc->init_sdtr & tid_bits))
        {
/*
 * set syn xfer register to ASYN_SDTR_DATA_FIX_PCI_REV_AB
 */
            if((dvc_type == SCSI_TYPE_CDROM)
                && (AscCompareString((uchar *)inq->vendor_id,
                    (uchar *)"HP ", 3) == 0))
            {
                asc_dvc->pci_fix_asyn_xfer_always |= tid_bits;
            }
            asc_dvc->pci_fix_asyn_xfer |= tid_bits;
            if((dvc_type == SCSI_TYPE_PROC) ||
                (dvc_type == SCSI_TYPE_SCANNER) ||
                (dvc_type == SCSI_TYPE_CDROM) ||
                (dvc_type == SCSI_TYPE_SASD))
            {
                asc_dvc->pci_fix_asyn_xfer &= ~tid_bits;
            }

            if(asc_dvc->pci_fix_asyn_xfer & tid_bits)
            {
                AscSetRunChipSynRegAtID(asc_dvc->iop_base, tid_no,
                    ASYN_SDTR_DATA_FIX_PCI_REV_AB);
            }
        }/* if */
    }
    return;
}

int AscTagQueuingSafe(ASC_SCSI_INQUIRY dosfar *);

/*
 * Return non-zero if Tag Queuing can be used with the
 * target with the specified Inquiry information.
 */
int
AscTagQueuingSafe(ASC_SCSI_INQUIRY dosfar *inq)
{
#if CC_FIX_QUANTUM_XP34301_1071
    if ((inq->add_len >= 32) &&
        (AscCompareString((uchar *) inq->vendor_id,
            (uchar *) "QUANTUM XP34301", 15) == 0) &&
        (AscCompareString((uchar *) inq->product_rev_level,
            (uchar *) "1071", 4) == 0))
    {
        return 0;
    }
#endif /* #if CC_FIX_QUANTUM_XP34301_1071 */

    return 1;
}

#if CC_INIT_SCSI_TARGET
/* -----------------------------------------------------------------------
**
** ---------------------------------------------------------------------*/
int    AscInitPollTarget(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          REG ASC_SCSI_REQ_Q dosfar *scsiq,
          REG ASC_SCSI_INQUIRY dosfar *inq,
          REG ASC_CAP_INFO dosfar *cap_info
       )
{
       uchar  tid_no, lun ;
       uchar  dvc_type ;
       ASC_SCSI_BIT_ID_TYPE tid_bits ;
       int    dvc_found ;
       int    support_read_cap ;
       int    tmp_disable_init_sdtr ;
       int    sta ;

       dvc_found = 0 ;
       tmp_disable_init_sdtr = FALSE ;
       tid_bits = scsiq->r1.target_id ;
       lun = scsiq->r1.target_lun ;
       tid_no = ASC_TIX_TO_TID( scsiq->r2.target_ix ) ;
       if(
           ( ( asc_dvc->init_sdtr & tid_bits ) != 0 )
           && ( ( asc_dvc->sdtr_done & tid_bits ) == 0 )
         )
       {
/*
**
** if host will init sdtr
** we must disable host init SDTR temporarily, as to prevent sending SDTR message
** before we find out which device support SDTR
**
** NOTE: we can not prevent target from sending SDTR here
**
*/
           asc_dvc->init_sdtr &= ~tid_bits ;
           tmp_disable_init_sdtr = TRUE ;
       }/* if */

       if(
           PollScsiInquiry( asc_dvc, scsiq, ( uchar dosfar *)inq,
                            sizeof( ASC_SCSI_INQUIRY ) ) == 1
         )
       {
           dvc_found = 1 ;
           dvc_type = inq->byte0.peri_dvc_type ;
           /*
            * If the Peripheral Device Type is SCSI_TYPE_UNKNOWN (0x1F)
            * then the Peripheral Qualifier must also be checked. The
            * caller is responsible for this checking.
            */
           if( dvc_type != SCSI_TYPE_UNKNOWN )
           {
               support_read_cap = TRUE ;
               if(
                   ( dvc_type != SCSI_TYPE_DASD )
                   && ( dvc_type != SCSI_TYPE_WORM )
                   && ( dvc_type != SCSI_TYPE_CDROM )
                   && ( dvc_type != SCSI_TYPE_OPTMEM )
                 )
               {
                   asc_dvc->start_motor &= ~tid_bits ;
                   support_read_cap = FALSE ;
               }/* if */

#if CC_INIT_INQ_DISPLAY
               AscDispInquiry( tid_no, lun, inq ) ;
#endif /* CC_INIT_INQ_DISPLAY */

               if( lun == 0 )
               {
/*
** we have to check ANSI approved version
*/
                   if(
                       ( inq->byte3.rsp_data_fmt >= 2 )
                       || ( inq->byte2.ansi_apr_ver >= 2 )
                     )
                   {
/*
** response data format >= 2
*/

                       if( inq->byte7.CmdQue )
                       {
                           asc_dvc->cfg->can_tagged_qng |= tid_bits ;
                           if( asc_dvc->cfg->cmd_qng_enabled & tid_bits )
                           {
                               if (AscTagQueuingSafe(inq))
                               {
                                   asc_dvc->use_tagged_qng |= tid_bits ;
                                   asc_dvc->max_dvc_qng[ tid_no ] =
                                       asc_dvc->cfg->max_tag_qng[ tid_no ] ;
                               }
                           }
                       }/* if */

                       if( !inq->byte7.Sync )
                       {
/*
** target does not support SDTR
*/
                           asc_dvc->init_sdtr &= ~tid_bits ;
                           asc_dvc->sdtr_done &= ~tid_bits ;
                       }/* if */
                       else if( tmp_disable_init_sdtr )
                       {
/*
**
** target do support SDTR
**
** we reenable host-inited SDTR here
**
**  NOTE: it is possible target already finished SDTR ( target inited SDTR )
**
*/
                           asc_dvc->init_sdtr |= tid_bits ;
                       }/* else */
                   }/* if */
                   else
                   {
/*
**
** no tagged queuing if response data format < 2
** no SDTR
**
*/
                       asc_dvc->init_sdtr &= ~tid_bits ;
                       asc_dvc->sdtr_done &= ~tid_bits ;
                       asc_dvc->use_tagged_qng &= ~tid_bits ;
                   }/* else */
               }/* if LUN is zero */
/*
** clear PCI asyn xfer fix when:
** 1. if host-inited bit is set ( it means target can do sync xfer )
*/
               AscAsyncFix(asc_dvc, tid_no, inq);

               sta = 1 ;
#if CC_INIT_TARGET_TEST_UNIT_READY
               sta = InitTestUnitReady( asc_dvc, scsiq ) ;
#endif

#if CC_INIT_TARGET_READ_CAPACITY
               if( sta == 1 )
               {
                   if( ( cap_info != 0L ) && support_read_cap )
                   {
                       if( PollScsiReadCapacity( asc_dvc, scsiq,
                           cap_info ) != 1 )
                       {
                           cap_info->lba = 0L ;
                           cap_info->blk_size = 0x0000 ;
                       }/* if */
                       else
                       {

                       }/* else */
                   }/* if */
               }/* if unit is ready */
#endif /* #if CC_INIT_TARGET_READ_CAPACITY */
           }/* if device type is not unknown */
           else
           {
               asc_dvc->start_motor &= ~tid_bits ;
           }/* else */
       }/* if */
       return( dvc_found ) ;
}
#endif /* CC_INIT_SCSI_TARGET */

/*
 * Set Synchronous Transfer and Tag Queuing target capabilities
 * for the specified target from the specified Inquiry information.
 */
void
AscInquiryHandling(ASC_DVC_VAR asc_ptr_type *asc_dvc,
            uchar tid_no, ASC_SCSI_INQUIRY dosfar *inq)
{
    ASC_SCSI_BIT_ID_TYPE tid_bit = ASC_TIX_TO_TARGET_ID(tid_no);
    ASC_SCSI_BIT_ID_TYPE orig_init_sdtr, orig_use_tagged_qng;

    /*
     * Save original values.
     */
    orig_init_sdtr = asc_dvc->init_sdtr;
    orig_use_tagged_qng = asc_dvc->use_tagged_qng;

    /*
     * Clear values by default.
     */
    asc_dvc->init_sdtr &= ~tid_bit;
    asc_dvc->cfg->can_tagged_qng &= ~tid_bit;
    asc_dvc->use_tagged_qng &= ~tid_bit;

    if (inq->byte3.rsp_data_fmt >= 2 || inq->byte2.ansi_apr_ver >= 2)
    {
        /*
         * Synchronous Transfer Capability
         */
        if ((asc_dvc->cfg->sdtr_enable & tid_bit) && inq->byte7.Sync)
        {
            asc_dvc->init_sdtr |= tid_bit;
        }

        /*
         * Command Tag Queuing Capability
         */
        if ((asc_dvc->cfg->cmd_qng_enabled & tid_bit) && inq->byte7.CmdQue)
        {
            if (AscTagQueuingSafe(inq))
            {
                asc_dvc->use_tagged_qng |= tid_bit;
                asc_dvc->cfg->can_tagged_qng |= tid_bit;
            }
        }
    }

    /*
     * Change other operating variables only if there
     * has been a change.
     */
    if (orig_use_tagged_qng != asc_dvc->use_tagged_qng)
    {
        AscWriteLramByte(asc_dvc->iop_base, ASCV_DISC_ENABLE_B,
            asc_dvc->cfg->disc_enable ) ;
        AscWriteLramByte(asc_dvc->iop_base, ASCV_USE_TAGGED_QNG_B,
            asc_dvc->use_tagged_qng);
        AscWriteLramByte(asc_dvc->iop_base, ASCV_CAN_TAGGED_QNG_B,
            asc_dvc->cfg->can_tagged_qng);

        asc_dvc->max_dvc_qng[tid_no] =
            asc_dvc->cfg->max_tag_qng[tid_no];
        AscWriteLramByte(asc_dvc->iop_base,
            (ushort) (ASCV_MAX_DVC_QNG_BEG + tid_no),
            asc_dvc->max_dvc_qng[tid_no]);
    }

    if (orig_init_sdtr != asc_dvc->init_sdtr)
    {
        /* Asynchronous Transfer Fix */
        AscAsyncFix(asc_dvc, tid_no, inq);
    }
    return;
}

#if CC_INIT_SCSI_TARGET
/* -----------------------------------------------------------------------
**
** -------------------------------------------------------------------- */
int    PollQueueDone(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          REG ASC_SCSI_REQ_Q dosfar *scsiq,
          int  timeout_sec
       )
{
       int  status ;
       int  retry ;

       retry = 0 ;
       do {
           if(
               ( status = AscExeScsiQueue( asc_dvc,
                          ( ASC_SCSI_Q dosfar *)scsiq ) ) == 1
             )
           {
               if( ( status = AscPollQDone( asc_dvc, scsiq,
                   timeout_sec ) ) != 1 )
               {
                   if( status == 0x80 )
                   {
                       if( retry++ > ASC_MAX_INIT_BUSY_RETRY )
                       {
                           break ;
                       }/* if */
                       scsiq->r3.done_stat = 0 ;
                       scsiq->r3.host_stat = 0 ;
                       scsiq->r3.scsi_stat = 0 ;
                       scsiq->r3.scsi_msg = 0 ;
                       DvcSleepMilliSecond( 1000 ) ;
                       continue ;  /* target busy */
                   }/* if */
                   scsiq->r3.done_stat = 0 ;
                   scsiq->r3.host_stat = 0 ;
                   scsiq->r3.scsi_stat = 0 ;
                   scsiq->r3.scsi_msg = 0 ;

#if CC_USE_AscAbortSRB
                   AscAbortSRB( asc_dvc, ( ulong )scsiq ) ;
#endif

               }/* if */
               return( scsiq->r3.done_stat ) ;
           }/* if */
       }while( ( status == 0 ) || ( status == 0x80 ) ) ;
       return( scsiq->r3.done_stat = QD_WITH_ERROR ) ;
}

/* -----------------------------------------------------------------------
**
** -------------------------------------------------------------------- */
int    PollScsiInquiry(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          REG ASC_SCSI_REQ_Q dosfar *scsiq,
          uchar dosfar *buf,
          int buf_len
       )
{
       if( AscScsiInquiry( asc_dvc, scsiq, buf, buf_len ) == ERR )
       {
           return( scsiq->r3.done_stat = QD_WITH_ERROR ) ;
       }/* if */
       return( PollQueueDone( asc_dvc, ( ASC_SCSI_REQ_Q dosfar *)scsiq, 4 ) ) ;
}

#if CC_INIT_TARGET_START_UNIT
/* -----------------------------------------------------------------------
**
** -------------------------------------------------------------------- */
int    PollScsiStartUnit(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          REG ASC_SCSI_REQ_Q dosfar *scsiq
       )
{
       if( AscScsiStartStopUnit( asc_dvc, scsiq, 1 ) == ERR )
       {
           return( scsiq->r3.done_stat = QD_WITH_ERROR ) ;
       }/* if */
/*
** wait 40 second to time out
*/
       return( PollQueueDone( asc_dvc, ( ASC_SCSI_REQ_Q dosfar *)scsiq, 40 ) ) ;
}
#endif
#endif /* CC_INIT_SCSI_TARGET */

#if CC_LITTLE_ENDIAN_HOST
/* -----------------------------------------------------------------------
**
** ----------------------------------------------------------------------- */
ulong dosfar *swapfarbuf4(
          ruchar dosfar *buf
       )
{
       uchar tmp ;

       tmp = buf[ 3 ] ;
       buf[ 3 ] = buf[ 0 ] ;
       buf[ 0 ] = tmp ;

       tmp = buf[ 1 ] ;
       buf[ 1 ] = buf[ 2 ] ;
       buf[ 2 ] = tmp ;

       return( ( ulong dosfar *)buf ) ;
}
#endif /* #if CC_LITTLE_ENDIAN_HOST */

#if CC_INIT_SCSI_TARGET
#if CC_INIT_TARGET_READ_CAPACITY

/* -----------------------------------------------------------------------
**
** -------------------------------------------------------------------- */
int    PollScsiReadCapacity(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          REG ASC_SCSI_REQ_Q dosfar *scsiq,
          REG ASC_CAP_INFO dosfar *cap_info
       )
{
       ASC_CAP_INFO  scsi_cap_info ;
       int  status ;

       if( AscScsiReadCapacity( asc_dvc, scsiq,
                                ( uchar dosfar *)&scsi_cap_info ) == ERR )
       {
           return( scsiq->r3.done_stat = QD_WITH_ERROR ) ;
       }/* if */
       status = PollQueueDone( asc_dvc, ( ASC_SCSI_REQ_Q dosfar *)scsiq, 8 ) ;
       if( status == 1 )
       {

#if CC_LITTLE_ENDIAN_HOST
           cap_info->lba = ( ulong )*swapfarbuf4( ( uchar dosfar *)&scsi_cap_info.lba ) ;
           cap_info->blk_size = ( ulong )*swapfarbuf4( ( uchar dosfar *)&scsi_cap_info.blk_size ) ;
#else
           cap_info->lba = scsi_cap_info.lba ;
           cap_info->blk_size = scsi_cap_info.blk_size ;
#endif /* #if CC_LITTLE_ENDIAN_HOST */

           return( scsiq->r3.done_stat ) ;
       }/* if */
       return( scsiq->r3.done_stat = QD_WITH_ERROR ) ;
}

#endif /* if CC_INIT_TARGET_READ_CAPACITY */

#if CC_INIT_TARGET_TEST_UNIT_READY
/* -----------------------------------------------------------------------
**
** -------------------------------------------------------------------- */
int    PollScsiTestUnitReady(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          REG ASC_SCSI_REQ_Q dosfar *scsiq
       )
{
       if( AscScsiTestUnitReady( asc_dvc, scsiq ) == ERR )
       {
           return( scsiq->r3.done_stat = QD_WITH_ERROR ) ;
       }/* if */
       return( PollQueueDone( asc_dvc, ( ASC_SCSI_REQ_Q dosfar *)scsiq, 12 ) ) ;
}

/* -----------------------------------------------------------------------
**
** --------------------------------------------------------------------- */
int    InitTestUnitReady(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          REG ASC_SCSI_REQ_Q dosfar *scsiq
       )
{
       ASC_SCSI_BIT_ID_TYPE tid_bits ;
       int    retry ;
       ASC_REQ_SENSE dosfar *sen ;

       retry = 0 ;
       tid_bits = scsiq->r1.target_id ;
       while( retry++ < 4 )
       {
           PollScsiTestUnitReady( asc_dvc, scsiq ) ;
           if( scsiq->r3.done_stat == 0x01 )
           {
               return( 1 ) ;
           }/* if */
           else if( scsiq->r3.done_stat == QD_WITH_ERROR )
           {
               sen = ( ASC_REQ_SENSE dosfar *)scsiq->sense_ptr ;

               if(
                   ( scsiq->r3.scsi_stat == SS_CHK_CONDITION )
                   && ( ( sen->err_code & 0x70 ) != 0 )
                 )
               {
                   if( sen->sense_key == SCSI_SENKEY_NOT_READY )
                   {
                       /*
                        * If No Media Is Present don't perform a retry
                        * and don't perform a Start Unit.
                        *
                        * Warning: AscIsrQDone() calls AscStartUnit()
                        * from teh interrupt hanlder. This causes a
                        * stack overrun in ASPI with ADVANCD if the
                        * start_motor bit is not cleared here. Refer
                        * to the log file for more information.
                        */
                       if (sen->asc == SCSI_ASC_NOMEDIA)
                       {
                           asc_dvc->start_motor &= ~tid_bits ;
                           break;
                       }
#if CC_INIT_TARGET_START_UNIT
                       /*
                       ** device is in process of becoming ready
                       */
                       if( asc_dvc->start_motor & tid_bits )
                       {
                           if( PollScsiStartUnit( asc_dvc, scsiq ) == 1 )
                           {
                               /*
                                * Delay for 250 ms after the successful
                                * Start Unit command. A Conner and IBM
                                * disk drive have been found to hang
                                * on commands that come too soon after
                                * a Start Unit.
                                */
                               DvcSleepMilliSecond(250) ;
                               continue ;
                           }/* if */
                           else
                           {
                               asc_dvc->start_motor &= ~tid_bits ;
                               break ;
                           }/* else */
                       }/* if start unit */
                       else
                       {
                           DvcSleepMilliSecond( 250 ) ;
                       }/* else */
#endif /* #if CC_INIT_TARGET_START_UNIT */
                   }/* if is not ready */
                   else if( sen->sense_key == SCSI_SENKEY_ATTENTION )
                   {
                       DvcSleepMilliSecond( 250 ) ;
                   }/* else */
                   else
                   {
                       break ;
                   }/* else if */
               }/* if valid sense key found */
               else
               {
                   break ;
               }/* else */
           }/* else */
           else if( scsiq->r3.done_stat == QD_ABORTED_BY_HOST )
           {
               break ;
           }/* else */
           else
           {
               break ;
           }/* else */
       }/* while */
       return( 0 ) ;
}
#endif /* #if CC_INIT_TARGET_TEST_UNIT_READY */


#if CC_INIT_INQ_DISPLAY
/* ------------------------------------------------------------------
**
** ---------------------------------------------------------------- */
void   AscDispInquiry(
          uchar tid,
          uchar lun,
          REG ASC_SCSI_INQUIRY dosfar *inq
       )
{

       int    i ;
       uchar  strbuf[ 18 ] ;
       uchar dosfar *strptr ;
       uchar  numstr[ 12 ] ;

       strptr = ( uchar dosfar *)strbuf ;
       DvcDisplayString( ( uchar dosfar *)" SCSI ID #" ) ;
       DvcDisplayString( todstr( tid, numstr ) ) ;
       if( lun != 0 )
       {
           DvcDisplayString( ( uchar dosfar *)" LUN #" ) ;
           DvcDisplayString( todstr( lun, numstr ) ) ;
       }/* if */
       DvcDisplayString( ( uchar dosfar *)"  Type: " ) ;
       DvcDisplayString( todstr( inq->byte0.peri_dvc_type, numstr ) ) ;
       DvcDisplayString( ( uchar dosfar *)"  " ) ;

       for( i = 0 ; i < 8 ; i++ ) strptr[ i ] = inq->vendor_id[ i ] ;
       strptr[ i ] = EOS ;
       DvcDisplayString( strptr ) ;

       DvcDisplayString( ( uchar dosfar *)" " ) ;
       for( i = 0 ; i < 16 ; i++ ) strptr[ i ] = inq->product_id[ i ] ;
       strptr[ i ] = EOS ;
       DvcDisplayString( strptr ) ;

       DvcDisplayString( ( uchar dosfar *)" " ) ;
       for( i = 0 ; i < 4 ; i++ ) strptr[ i ] = inq->product_rev_level[ i ] ;
       strptr[ i ] = EOS ;
       DvcDisplayString( strptr ) ;
       DvcDisplayString( ( uchar dosfar *)"\r\n" ) ;
       return ;
}
#endif /* CC_INIT_INQ_DISPLAY */

/* ---------------------------------------------------------------------
**
** return values:
**
** FALSE(0): if timed out
** ERR(-1):  if fatla error !
** TRUE(1):  if command completed
** 0x80:     if target is busy
**
** ------------------------------------------------------------------- */
int    AscPollQDone(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          REG ASC_SCSI_REQ_Q dosfar *scsiq,
          int timeout_sec
       )
{
       int      loop, loop_end ;
       int      sta ;
       PortAddr iop_base ;

       iop_base = asc_dvc->iop_base ;
       loop = 0 ;
       loop_end = timeout_sec * 100 ;
       sta = 1 ;

       while( TRUE )
       {
           if( asc_dvc->err_code != 0 )
           {
               scsiq->r3.done_stat = QD_WITH_ERROR ;
               sta = ERR ;
               break ;
           }/* if */
           if( scsiq->r3.done_stat != QD_IN_PROGRESS )
           {
               if( ( scsiq->r3.done_stat == QD_WITH_ERROR ) &&
                   ( scsiq->r3.scsi_stat == SS_TARGET_BUSY ) )
               {
                   sta = 0x80 ;
               }/* if */
               break ;
           }/* if */
           DvcSleepMilliSecond( 10 ) ; /* for dos 55 millisec is one unit */
           if( loop++ > loop_end )
           {
               sta = 0 ;
               break ;
           }/* if */
           if( AscIsChipHalted( iop_base ) )
           {
#if !CC_ASCISR_CHECK_INT_PENDING
               AscAckInterrupt( iop_base ) ;
#endif
               AscISR( asc_dvc ) ;
               loop = 0 ;
           }/* if */
           else
           {
               if( AscIsIntPending( iop_base ) )
               {
#if !CC_ASCISR_CHECK_INT_PENDING
                   AscAckInterrupt( iop_base ) ;
#endif
                   AscISR( asc_dvc ) ;
               }/* if */
           }/* else */
       }/* while */
/*
** should not break to here
*/
       return( sta ) ;
}

#endif /* CC_INIT_SCSI_TARGET */

/* ---------------------------------------------------------------------
**
**
**
** ------------------------------------------------------------------- */
int    AscCompareString(
          ruchar *str1,
          ruchar *str2,
          int    len
       )
{
       int  i ;
       int  diff ;

       for( i = 0 ; i < len ; i++ )
       {
            diff = ( int )( str1[ i ] - str2[ i ]  ) ;
            if( diff != 0 ) return( diff ) ;
       }
       return( 0 ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc\asc_mis.c ===
/*
** Copyright (c) 1994-1997 Advanced System Products, Inc.
** All Rights Reserved.
**
** asc_mis.c
*/

#include "ascinc.h"

/* -----------------------------------------------------------------------
** Description: convert ASC1000 target id number ( bit 0 set to bit 7 set )
** to target id number ( 0 to 7 )
**
** return 0xFF if input is invalid
** -------------------------------------------------------------------- */
uchar  AscScsiIDtoTID(
          uchar tid
       )
{
       uchar  i ;

       for( i = 0 ; i <= ASC_MAX_TID ; i++ )
       {
            if( ( ( tid >> i ) & 0x01 ) != 0 ) return( i ) ;
       }/* for */
       return( 0xFF ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc\asc_lram.c ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** asc_lram.c
*/

#include "ascinc.h"


/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
uchar  AscReadLramByte(
          PortAddr iop_base,
          ushort addr
       )
{
       uchar   byte_data ;
       ushort  word_data ;

       if( isodd_word( addr ) )
       {
           AscSetChipLramAddr( iop_base, addr-1 ) ;
           word_data = AscGetChipLramData( iop_base ) ;
           byte_data = ( uchar )( ( word_data >> 8 ) & 0xFF ) ;
       }/* if */
       else
       {
           AscSetChipLramAddr( iop_base, addr ) ;
           word_data = AscGetChipLramData( iop_base ) ;
           byte_data = ( uchar )( word_data & 0xFF ) ;
       }/* else */
       return( byte_data ) ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
ushort AscReadLramWord(
          PortAddr iop_base,
          ushort addr
       )
{
       ushort  word_data ;

       AscSetChipLramAddr( iop_base, addr ) ;
       word_data = AscGetChipLramData( iop_base ) ;
       return( word_data ) ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
ulong  AscReadLramDWord(
          PortAddr iop_base,
          ushort addr
       )
{
       ushort   val_low, val_high ;
       ulong    dword_data ;

       AscSetChipLramAddr( iop_base, addr ) ;

       val_low = AscGetChipLramData( iop_base ) ;
/*       outpw( IOP0W_RAM_ADDR, addr+2 ) ;  */
       val_high = AscGetChipLramData( iop_base ) ;

       dword_data = ( ( ulong )val_high << 16 ) | ( ulong )val_low ;
       return( dword_data ) ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
void   AscWriteLramWord(
          PortAddr iop_base,
          ushort addr,
          ushort word_val
       )
{
       AscSetChipLramAddr( iop_base, addr ) ;
       AscSetChipLramData( iop_base, word_val ) ;
       return ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
void   AscWriteLramDWord(
          PortAddr iop_base,
          ushort addr,
          ulong dword_val
       )
{
       ushort  word_val ;

       AscSetChipLramAddr( iop_base, addr ) ;

       word_val = ( ushort )dword_val ;
       AscSetChipLramData( iop_base, word_val ) ;
       word_val = ( ushort )( dword_val >> 16 ) ;
       AscSetChipLramData( iop_base, word_val ) ;
       return ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
void   AscWriteLramByte(
          PortAddr iop_base,
          ushort addr,
          uchar byte_val
       )
{
       ushort  word_data ;

       if( isodd_word( addr ) )
       {
           addr-- ;
           word_data = AscReadLramWord( iop_base, addr ) ;
           word_data &= 0x00FF ;
           word_data |= ( ( ( ushort )byte_val << 8 ) & 0xFF00 ) ;
       }/* if */
       else
       {
           word_data = AscReadLramWord( iop_base, addr ) ;
           word_data &= 0xFF00 ;
           word_data |= ( ( ushort )byte_val & 0x00FF ) ;
       }/* else */
       AscWriteLramWord( iop_base, addr, word_data ) ;
       return ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
void   AscMemWordCopyToLram(
          PortAddr iop_base,
          ushort s_addr,
          ushort dosfar *s_buffer,
          int    words
       )
{
       AscSetChipLramAddr( iop_base, s_addr ) ;
       DvcOutPortWords( (PortAddr) (iop_base+IOP_RAM_DATA), s_buffer, words ) ;
       return ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
void   AscMemDWordCopyToLram(
          PortAddr iop_base,
          ushort s_addr,
          ulong  dosfar *s_buffer,
          int    dwords
       )
{
       AscSetChipLramAddr( iop_base, s_addr ) ;
       DvcOutPortDWords( (PortAddr) (iop_base+IOP_RAM_DATA), s_buffer, dwords );
       return ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
void   AscMemWordCopyFromLram(
          PortAddr iop_base,
          ushort   s_addr,
          ushort   dosfar *d_buffer,
          int      words
       )
{
       AscSetChipLramAddr( iop_base, s_addr ) ;
       DvcInPortWords( (PortAddr) (iop_base+IOP_RAM_DATA), d_buffer, words ) ;
       return ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
ulong  AscMemSumLramWord(
          PortAddr iop_base,
          ushort   s_addr,
          rint     words
       )
{
       ulong   sum ;
       int     i ;

       sum = 0L ;
       for( i = 0 ; i < words ; i++, s_addr += 2 )
       {
            sum += AscReadLramWord( iop_base, s_addr ) ;
       }/* for */
       return( sum ) ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
void   AscMemWordSetLram(
          PortAddr iop_base,
          ushort   s_addr,
          ushort   set_wval,
          rint     words
       )
{
       rint  i ;

       AscSetChipLramAddr( iop_base, s_addr ) ;
       for( i = 0 ; i < words ; i++ )
       {
            AscSetChipLramData( iop_base, set_wval ) ;
       }/* for */
       return ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
int    AscMemWordCmpToLram(
          PortAddr iop_base,
          ushort   s_addr,
          ushort   dosfar *buffer,
          rint     words
       )
{
       rint     i ;
       ushort  word_val ;
       int     mismatch ;

       AscSetChipLramAddr( iop_base, s_addr ) ;
       mismatch = 0 ;
       for( i = 0 ; i < words ; i++ )
       {
            word_val = AscGetChipLramData( iop_base ) ;
            if( word_val != *buffer++ )
            {
                mismatch++ ;
            }/* if */
       }/* for */
       return( mismatch ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc\asc_scsi.c ===
/*
** Copyright (c) 1994-1997 Advanced System Products, Inc.
** All Rights Reserved.
**
** asc_scsi.c
**
*/

#include "ascinc.h"
#include "ascsidef.h"

/* -----------------------------------------------------------------------
**
** -------------------------------------------------------------------- */
int    AscScsiInquiry(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          REG ASC_SCSI_REQ_Q dosfar *scsiq,
          uchar dosfar *buf,
          int buf_len
       )
{
       if( AscScsiSetupCmdQ( asc_dvc, scsiq, buf,
           ( ulong )buf_len ) == ERR )
       {
           return( scsiq->r3.done_stat = QD_WITH_ERROR ) ;
       }/* if */
       scsiq->cdb[ 0 ] = ( uchar )SCSICMD_Inquiry ;
       scsiq->cdb[ 1 ] = scsiq->r1.target_lun << 5 ;  /* LUN */
       scsiq->cdb[ 2 ] = 0 ;
       scsiq->cdb[ 3 ] = 0 ;
       scsiq->cdb[ 4 ] = buf_len ;
       scsiq->cdb[ 5 ] = 0 ;
       scsiq->r2.cdb_len = 6 ;
       return( 0 ) ;
}

#if CC_INIT_TARGET_READ_CAPACITY

/* -----------------------------------------------------------------------
**
** -------------------------------------------------------------------- */
int    AscScsiReadCapacity(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          REG ASC_SCSI_REQ_Q dosfar *scsiq,
          uchar dosfar *info
       )
{
       if( AscScsiSetupCmdQ( asc_dvc, scsiq, info, 8L ) == ERR )
       {
           return( scsiq->r3.done_stat = QD_WITH_ERROR ) ;
       }/* if */
       scsiq->cdb[ 0 ] = ( uchar )SCSICMD_ReadCapacity ;
       scsiq->cdb[ 1 ] = scsiq->r1.target_lun << 5 ;  /* LUN */
       scsiq->cdb[ 2 ] = 0 ;
       scsiq->cdb[ 3 ] = 0 ;
       scsiq->cdb[ 4 ] = 0 ;
       scsiq->cdb[ 5 ] = 0 ;
       scsiq->cdb[ 6 ] = 0 ;
       scsiq->cdb[ 7 ] = 0 ;
       scsiq->cdb[ 8 ] = 0 ;
       scsiq->cdb[ 9 ] = 0 ;
       scsiq->r2.cdb_len = 10 ;
       return( 0 ) ;
}

#endif /*  #if CC_INIT_TARGET_READ_CAPACITY */

#if CC_INIT_TARGET_TEST_UNIT_READY
/* -----------------------------------------------------------------------
**
**
** --------------------------------------------------------------------- */
int    AscScsiTestUnitReady(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          REG ASC_SCSI_REQ_Q dosfar *scsiq
       )
{
       if( AscScsiSetupCmdQ( asc_dvc, scsiq, FNULLPTR,
           ( ulong )0L ) == ERR )
       {
           return( scsiq->r3.done_stat = QD_WITH_ERROR ) ;
       }/* if */
       scsiq->r1.cntl = ( uchar )ASC_SCSIDIR_NODATA ;
       scsiq->cdb[ 0 ] = ( uchar )SCSICMD_TestUnitReady ;
       scsiq->cdb[ 1 ] = scsiq->r1.target_lun << 5 ;  /* LUN */
       scsiq->cdb[ 2 ] = 0 ;
       scsiq->cdb[ 3 ] = 0 ;
       scsiq->cdb[ 4 ] = 0 ;
       scsiq->cdb[ 5 ] = 0 ;
       scsiq->r2.cdb_len = 6 ;
       return( 0 ) ;
}
#endif /* #if CC_INIT_TARGET_TEST_UNIT_READY */

#if CC_INIT_TARGET_START_UNIT
/* -----------------------------------------------------------------------
**
**
** --------------------------------------------------------------------- */
int    AscScsiStartStopUnit(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          REG ASC_SCSI_REQ_Q dosfar *scsiq,
          uchar op_mode
       )
{
       if( AscScsiSetupCmdQ( asc_dvc, scsiq, FNULLPTR, ( ulong )0L ) == ERR )
       {
           return( scsiq->r3.done_stat = QD_WITH_ERROR ) ;
       }/* if */
       scsiq->r1.cntl = ( uchar )ASC_SCSIDIR_NODATA ;
       scsiq->cdb[ 0 ] = ( uchar )SCSICMD_StartStopUnit ;
       scsiq->cdb[ 1 ] = scsiq->r1.target_lun << 5 ;  /* LUN */
       scsiq->cdb[ 2 ] = 0 ;
       scsiq->cdb[ 3 ] = 0 ;
       scsiq->cdb[ 4 ] = op_mode ; /* to start/stop unit set bit 0 */
                                   /* to eject/load unit set bit 1 */
       scsiq->cdb[ 5 ] = 0 ;
       scsiq->r2.cdb_len = 6 ;
       return( 0 ) ;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc\asc_res.c ===
/*
** Copyright (c) 1994-1997 Advanced System Products, Inc.
** All Rights Reserved.
**
** ASC_RES.C
**
*/

#include "ascinc.h"

/* -----------------------------------------------------------------------
** NOT FOR GENERAL PUBLIC !!!
**
** Description: poll queue head syncronization status
**
** returns:
** 0 - pointer not sycronized
** 1 - queue pointer syncronized
** else - unrecoverable error
**
** -------------------------------------------------------------------- */
int    AscPollQTailSync(
          PortAddr iop_base
       )
{
       uchar  risc_done_q_tail ;

       risc_done_q_tail = AscReadLramByte( iop_base, ASCV_DONENEXT_B ) ;
       if( AscGetVarDoneQTail( iop_base ) != risc_done_q_tail ) {
           return( 0 ) ;
       }/* if */
       return( 1 ) ;
}

/* -----------------------------------------------------------------------
** NOT FOR GENERAL PUBLIC !!!
**
** Description: syncronize queue pointers
**
** returns:
** 0 - no fault found,
** 1 - queue pointer syncronized, error corrected
** else - unrecoverable error
**
** NOTE:
** 1. if RISC is not in idle state, result can be catastrophic !!!
**
** -------------------------------------------------------------------- */
int    AscPollQHeadSync(
          PortAddr iop_base
       )
{
       uchar  risc_free_q_head ;

       risc_free_q_head = AscReadLramByte( iop_base, ASCV_NEXTRDY_B ) ;
       if( AscGetVarFreeQHead( iop_base ) != risc_free_q_head ) {
           return( 0 ) ;
       }/* if */
       return( 1 ) ;
}

/* ---------------------------------------------------------------------
**
** ------------------------------------------------------------------ */
int    AscWaitQTailSync(
          PortAddr iop_base
       )
{
       uint loop ;

       loop = 0 ;
       while( AscPollQTailSync( iop_base ) != 1 ) {
/*
** wait 15 seconds for all queues to be done
*/
              DvcSleepMilliSecond( 100L ) ;
              if( loop++ > 150 ) {
                  return( 0 ) ;
              }/* if */
       }/* while */
       return( 1 ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc\a_ddinc.h ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** Filename: a_ddinc.h
*/

#ifndef __ASCINC_H_
#define __ASCINC_H_

#include "ascdef.h"
#include "a_osdep.h"
#include "a_cc.h"
#include "ascdep.h"    /* chip dependent include file */
#include "ascsidef.h"  /* ASC SCSI definition         */
#include "aspiq.h"     /* ASC QUEUE                   */
#include "asc1000.h"
#include "a_ddlib.h"

#endif /* #ifndef __ASCINC_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc\aspiq.h ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** Filename: aspiq.h
**
*/

#ifndef __ASPIQ_H_
#define __ASPIQ_H_

/* #define ASCQ_ASPI_COPY_WORDS  13  number of queue words to copy for ASPI */
/* #define ASC_TID_WITH_SCSIQ  0x80  the tid of queue is not a aspi done queue */

#define ASC_SG_LIST_PER_Q   7  /*  */

/*
** q_status
*/
#define QS_FREE        0x00 /* queue is free ( not used )      */
#define QS_READY       0x01 /* queue is ready to be executed   */
#define QS_DISC1       0x02 /* queue is disconnected no tagged queuing */
#define QS_DISC2       0x04 /* queue is disconnected tagged queuing */
#define QS_BUSY        0x08 /* queue is waiting to be executed        */
/* #define QS_ACTIVE      0x08  queue is being executed                */
/* #define QS_DATA_XFER   0x10  queue is doing data transfer           */
#define QS_ABORTED     0x40    /* queue is aborted by host               */
#define QS_DONE        0x80    /* queue is done ( execution completed )  */

/*
** q_cntl
*/
/* conform with ASPI SCSI request flags */
/* #define QC_POST          0x01 */ /* posting fuction need to be called */
/* #define QC_LINK          0x02 */ /* link command */
#define QC_NO_CALLBACK   0x01 /* the queue should not call OS callback in ISR */
                              /* currently use the queue to send out message only */
#define QC_SG_SWAP_QUEUE 0x02 /* more sg list queue in host memory */
#define QC_SG_HEAD       0x04 /* is a sg list head                                 */
#define QC_DATA_IN       0x08 /* check data in transfer byte count match           */
#define QC_DATA_OUT      0x10 /* check data out transfer byte count match          */
/* #define QC_MSG_IN        0x20 */ /* message in from target                        */
#define QC_URGENT        0x20 /* high priority queue, must be executed first */
#define QC_MSG_OUT       0x40 /* send message out to target                        */
#define QC_REQ_SENSE     0x80 /* check condition, automatically do request sense   */
    /* if no data transfer if both data_in and data_out set */
/* #define   QC_DO_TAG_MSG            0x10  set by host */

/*
** following control bit is used on sg list queue only
** doesn't used on sg list queue head
*/
#define QCSG_SG_XFER_LIST  0x02 /* is a sg list queue                      */
#define QCSG_SG_XFER_MORE  0x04 /* there are more sg list in host memory   */
#define QCSG_SG_XFER_END   0x08 /* is end of sg list queue                 */

/*
** completion status, q[ done_stat ]
*/
#define QD_IN_PROGRESS       0x00 /* SCSI request in progress             */
#define QD_NO_ERROR          0x01 /* SCSI request completed without error */
#define QD_ABORTED_BY_HOST   0x02 /* SCSI request aborted by host         */
#define QD_WITH_ERROR        0x04 /* SCSI request completed with error    */
#define QD_INVALID_REQUEST   0x80 /* invalid SCSI request                 */
#define QD_INVALID_HOST_NUM  0x81 /* invalid HOST Aadpter Number          */
#define QD_INVALID_DEVICE    0x82 /* SCSI device not installed            */
#define QD_ERR_INTERNAL      0xFF /* internal error                       */

/*
** host adaptor status
** a fatal error will turn the bit 7 on ( 0x80 )
*/

/*
** ASPI DEFINED error codes
*/
#define QHSTA_NO_ERROR               0x00 /*                              */
#define QHSTA_M_SEL_TIMEOUT          0x11 /* selection time out           */
#define QHSTA_M_DATA_OVER_RUN        0x12 /* data over run                */
#define QHSTA_M_DATA_UNDER_RUN       0x12 /* data under run               */
#define QHSTA_M_UNEXPECTED_BUS_FREE  0x13 /* unexpected bus free          */
#define QHSTA_M_BAD_BUS_PHASE_SEQ    0x14 /* bus phase sequence failure   */

/*
** reported by device driver
*/
#define QHSTA_D_QDONE_SG_LIST_CORRUPTED 0x21 /*                                      */
#define QHSTA_D_ASC_DVC_ERROR_CODE_SET  0x22 /* host adapter internal error          */
#define QHSTA_D_HOST_ABORT_FAILED       0x23 /* abort scsi q failed                  */
#define QHSTA_D_EXE_SCSI_Q_FAILED       0x24 /* call AscExeScsiQueue() failed        */
#define QHSTA_D_EXE_SCSI_Q_BUSY_TIMEOUT 0x25 /* AscExeScsiQueue() busy time out      */
/* #define QHSTA_D_ASPI_RE_ENTERED      0x26  ASPI EXE SCSI IO is being re entered */
#define QHSTA_D_ASPI_NO_BUF_POOL        0x26 /* ASPI out of buffer pool              */

/*
** reported by micro code to device driver
*/
#define QHSTA_M_WTM_TIMEOUT         0x41 /* watch dog timer timeout  */
#define QHSTA_M_BAD_CMPL_STATUS_IN  0x42 /* bad completion status in */
#define QHSTA_M_NO_AUTO_REQ_SENSE   0x43 /* no sense buffer to get sense data */
#define QHSTA_M_AUTO_REQ_SENSE_FAIL 0x44 /* automatic request sense failed  */
#define QHSTA_M_TARGET_STATUS_BUSY  0x45 /* device return status busy ( SS_TARGET_BUSY = 0x08 ), tagged queuing disabled */
#define QHSTA_M_BAD_TAG_CODE        0x46 /* bad tag code of tagged queueing device */
                                         /* a tagged queueing device should always have a correct tag code */
                                         /* either 0x20, 0x21, 0x22, please see "ascsidef.h" of M2_QTAG_xxx */
                                         /* it is dangeous to mix tagged and untagged cmd in a device */
#define QHSTA_M_BAD_QUEUE_FULL_OR_BUSY  0x47 /* bad queue full ( 0x28 ) or busy ( 0x08 ) return */
                                             /* there is actually no queued cmd inside */

#define QHSTA_M_HUNG_REQ_SCSI_BUS_RESET 0x48 /* require reset scsi bus to free from hung condition */

/*
** fatal error
*/
#define QHSTA_D_LRAM_CMP_ERROR        0x81 /* comparison of local ram copying failed */
#define QHSTA_M_MICRO_CODE_ERROR_HALT 0xA1 /* fatal error, micro code halt           */
                                           /*                                        */
/* #define QHSTA_BUSY_TIMEOUT         0x16    host adapter busy time out             */
/* #define QHSTA_HOST_ABORT_TIMEOUT   0x21    abort scsi q timeout                   */
/* #define QHSTA_ERR_Q_CNTL           0x23    error queue control                    */
/* #define QHSTA_DRV_FATAL_ERROR      0x82    host driver fatal                      */
                                           /* asc_dvc->err_code not equal zero       */

/*
**
*/
/* #define SG_LIST_BEG_INDEX    0x08 */
/* #define SG_ENTRY_PER_Q       15    maximum size of CDB in bytes */

/*
** ASC_SCSIQ_2
** flag defintion
*/
#define ASC_FLAG_SCSIQ_REQ        0x01
#define ASC_FLAG_BIOS_SCSIQ_REQ   0x02
#define ASC_FLAG_BIOS_ASYNC_IO    0x04
#define ASC_FLAG_SRB_LINEAR_ADDR  0x08

#define ASC_FLAG_WIN16            0x10
#define ASC_FLAG_WIN32            0x20
#define ASC_FLAG_ISA_OVER_16MB    0x40
#define ASC_FLAG_DOS_VM_CALLBACK  0x80
/* #define ASC_FLAG_ASPI_SRB     0x01  */
/* #define ASC_FLAG_DATA_LOCKED  0x02  */
/* #define ASC_FLAG_SENSE_LOCKED 0x04  */

/*
** tag_code is normally 0x20
*/
/* #define ASC_TAG_FLAG_ADD_ONE_BYTE     0x10 */ /* for PCI fix, we add one byte to data transfer */
/* #define ASC_TAG_FLAG_ISAPNP_ADD_BYTES 0x40 */ /* for ISAPNP (ver 0x21 ) fix, we add three byte to data transfer */
#define ASC_TAG_FLAG_EXTRA_BYTES               0x10
#define ASC_TAG_FLAG_DISABLE_DISCONNECT        0x04
#define ASC_TAG_FLAG_DISABLE_ASYN_USE_SYN_FIX  0x08
#define ASC_TAG_FLAG_DISABLE_CHK_COND_INT_HOST 0x40

/*
**
*/
#define ASC_SCSIQ_CPY_BEG              4
#define ASC_SCSIQ_SGHD_CPY_BEG         2

#define ASC_SCSIQ_B_FWD                0
#define ASC_SCSIQ_B_BWD                1

#define ASC_SCSIQ_B_STATUS             2
#define ASC_SCSIQ_B_QNO                3

#define ASC_SCSIQ_B_CNTL               4
#define ASC_SCSIQ_B_SG_QUEUE_CNT       5
/*
**
*/
#define ASC_SCSIQ_D_DATA_ADDR          8
#define ASC_SCSIQ_D_DATA_CNT          12
#define ASC_SCSIQ_B_SENSE_LEN         20 /* sense data length */
#define ASC_SCSIQ_DONE_INFO_BEG       22
#define ASC_SCSIQ_D_SRBPTR            22
#define ASC_SCSIQ_B_TARGET_IX         26
#define ASC_SCSIQ_B_CDB_LEN           28
#define ASC_SCSIQ_B_TAG_CODE          29
#define ASC_SCSIQ_W_VM_ID             30
#define ASC_SCSIQ_DONE_STATUS         32
#define ASC_SCSIQ_HOST_STATUS         33
#define ASC_SCSIQ_SCSI_STATUS         34
#define ASC_SCSIQ_CDB_BEG             36
#define ASC_SCSIQ_DW_REMAIN_XFER_ADDR 56
#define ASC_SCSIQ_DW_REMAIN_XFER_CNT  60
#define ASC_SCSIQ_B_SG_WK_QP          49
#define ASC_SCSIQ_B_SG_WK_IX          50
#define ASC_SCSIQ_W_REQ_COUNT         52 /* command execution sequence number */
#define ASC_SCSIQ_B_LIST_CNT          6
#define ASC_SCSIQ_B_CUR_LIST_CNT      7

/*
** local address of SG_LIST_Q field
*/
#define ASC_SGQ_B_SG_CNTL             4
#define ASC_SGQ_B_SG_HEAD_QP          5
#define ASC_SGQ_B_SG_LIST_CNT         6
#define ASC_SGQ_B_SG_CUR_LIST_CNT     7
#define ASC_SGQ_LIST_BEG              8

/*
**
*/
#define ASC_DEF_SCSI1_QNG    4
#define ASC_MAX_SCSI1_QNG    4 /* queued commands for non-tagged queuing device */
#define ASC_DEF_SCSI2_QNG    16
#define ASC_MAX_SCSI2_QNG    32

#define ASC_TAG_CODE_MASK    0x23

/*
** stop code definition
*/
#define ASC_STOP_REQ_RISC_STOP      0x01 /* Host set this value to stop RISC  */
                                         /* in fact any value other than zero */
                                         /* will stop the RISC                */
#define ASC_STOP_ACK_RISC_STOP      0x03 /* RISC set this value to confirm    */
                                         /* it has stopped                    */
#define ASC_STOP_CLEAN_UP_BUSY_Q    0x10 /* host request risc clean up busy q */
#define ASC_STOP_CLEAN_UP_DISC_Q    0x20 /* host request risc clean up disc q */
#define ASC_STOP_HOST_REQ_RISC_HALT 0x40 /* host request risc halt, no interrupt generated */
/* #define ASC_STOP_SEND_INT_TO_HOST   0x80 */ /* host request risc generate an interrupt */

/* from tid and lun to taregt_ix */
#define ASC_TIDLUN_TO_IX( tid, lun )  ( ASC_SCSI_TIX_TYPE )( (tid) + ((lun)<<ASC_SCSI_ID_BITS) )
/* from tid to target_id */
#define ASC_TID_TO_TARGET_ID( tid )   ( ASC_SCSI_BIT_ID_TYPE )( 0x01 << (tid) )
#define ASC_TIX_TO_TARGET_ID( tix )   ( 0x01 << ( (tix) & ASC_MAX_TID ) )
#define ASC_TIX_TO_TID( tix )         ( (tix) & ASC_MAX_TID )
#define ASC_TID_TO_TIX( tid )         ( (tid) & ASC_MAX_TID )
#define ASC_TIX_TO_LUN( tix )         ( ( (tix) >> ASC_SCSI_ID_BITS ) & ASC_MAX_LUN )

#define ASC_QNO_TO_QADDR( q_no )      ( (ASC_QADR_BEG)+( ( int )(q_no) << 6 ) )

#pragma pack(1)
typedef struct asc_scisq_1 {
  uchar  status ;        /* 2  q current execution status               */
  uchar  q_no ;          /* 3                                           */
  uchar  cntl ;          /* 4  queue control byte                       */
  uchar  sg_queue_cnt ;  /* 5  number of sg_list queue(s), from 1 to n  */
                         /*    equal zero if is not a sg list queue     */
  uchar  target_id ;     /* 6  Target SCSI ID                           */
  uchar  target_lun ;    /* 7  Target SCSI logical unit number          */
                         /*                                             */
  ulong  data_addr ;     /* 8 -11 dma transfer physical address         */
  ulong  data_cnt ;      /* 12-15 dma transfer byte count               */
  ulong  sense_addr ;    /* 16-19 request sense message buffer          */
  uchar  sense_len ;     /* 20 SCSI request sense data length           */
/* uchar user_def ;  */
  uchar  extra_bytes ;   /* 21 number of extra bytes to send ( for bug fix ) */
                         /*    from cutting last transfer length to dword boundary */
} ASC_SCSIQ_1 ;

typedef struct asc_scisq_2 {
  ulong  srb_ptr ;     /* 22-25 the SCSI SRB from device driver         */
  uchar  target_ix ;   /* 26 target index ( 0 to 63 )                   */
                       /*    calculated by host                         */
  uchar  flag ;        /* 27 left to user implemenation                 */
  uchar  cdb_len ;     /* 28 SCSI command length                        */
  uchar  tag_code ;    /* 29 first byte of tagged queuing messasge      */
                       /*    either 0x20, 0x21, 0x22                    */
  ushort vm_id ;       /* 30-31 Virtual machine ID for DOS and Windows  */
} ASC_SCSIQ_2 ;

typedef struct asc_scsiq_3 {
  uchar  done_stat ;   /* 32 queue completion status        */
  uchar  host_stat ;   /* 33 host adapter error status      */
  uchar  scsi_stat ;   /* 34 SCSI command completion status */
  uchar  scsi_msg ;    /* 35 SCSI command done message      */
} ASC_SCSIQ_3 ;

typedef struct asc_scsiq_4 {
  uchar  cdb[ ASC_MAX_CDB_LEN ] ; /* 36-47 SCSI CDB block, 12 bytes maximum */
  uchar  y_first_sg_list_qp ;     /* 48 B                                   */
  uchar  y_working_sg_qp ;        /* 49 B                                   */
  uchar  y_working_sg_ix ;        /* 50 B                                   */
  uchar  y_res ;                  /* 51 B                                   */
  ushort x_req_count ;            /* 52 W                                   */
  ushort x_reconnect_rtn ;        /* 54 W                                   */
  ulong  x_saved_data_addr ;      /* 56 DW next data transfer address       */
  ulong  x_saved_data_cnt ;       /* 60 DW remaining data transfer count    */
} ASC_SCSIQ_4 ;

typedef struct asc_q_done_info {
  ASC_SCSIQ_2  d2 ;      /*                                 */
  ASC_SCSIQ_3  d3 ;      /*                                 */
  uchar  q_status ;      /* queue status                    */
  uchar  q_no ;          /* queue number                    */
  uchar  cntl ;          /* queue control byte */
  uchar  sense_len ;     /* sense buffer length */
  uchar  extra_bytes ;   /* use  */
  uchar  res ;           /* reserved, for alignment */
  ulong  remain_bytes ;  /* data transfer remaining bytes   */
} ASC_QDONE_INFO ;       /* total 16 bytes                  */
#pragma pack()

/*
** SCSI SG LIST
*/
typedef struct asc_sg_list {
  ulong   addr ;  /* far pointer to physical address */
  ulong   bytes ; /* number of bytes for the entry   */
} ASC_SG_LIST ;

/*
** SCSI SG LIST QUEUE HEAD
*/
typedef struct asc_sg_head {
  ushort entry_cnt ;       /* number of sg entry ( list )                    */
                           /* entered by driver                              */
                           /* when passed to DvcGetSGList() it holds number  */
                           /* of available entry                             */
                           /* when returned DvcGetSGList() return number of  */
                           /* filled entry                                   */
  ushort queue_cnt ;       /* total number of queues not including sg head   */
                           /* from 1 to n                                    */
                           /* entered by library function call               */
  ushort entry_to_copy ;
  ushort res ;
  ASC_SG_LIST sg_list[ ASC_MAX_SG_LIST ] ; /* sg list array */
} ASC_SG_HEAD ;

/*
**
*/
#define ASC_MIN_SG_LIST   2

typedef struct asc_min_sg_head {
  ushort entry_cnt ;         /* number of sg entry ( list )                                */
                             /* when passed to DvcGetSGList() it holds number              */
                             /* of available entry                                         */
                             /* when returned DvcGetSGList() return number of filled entry */
  ushort queue_cnt ;         /* total number of queues not including sg head               */
                             /* from 1 to n                                                */
  ushort entry_to_copy ;     /* should equal entry_cnt when done */
  ushort res ;
  ASC_SG_LIST sg_list[ ASC_MIN_SG_LIST ] ; /* sg list array                                              */
} ASC_MIN_SG_HEAD ;

/*
**
** extended queue control word
**
*/
#define QCX_SORT        (0x0001)  /* insert queue in order */
#define QCX_COALEASE    (0x0002)  /* coalease queue into single command */
                                  /* if possible */
                                  /* in order to provide coalease */
                                  /* "sg_head" must point to a SG LIST buffer */
                                  /* with number of entry available at entry_cnt */

#if CC_LINK_BUSY_Q
typedef struct asc_ext_scsi_q {
  ulong  lba ;                     /* logical block address of i/o */
  ushort lba_len ;                 /* logical block length in sector */
  struct asc_scsi_q dosfar *next ; /* NULL if no more queue */
  struct asc_scsi_q dosfar *join ; /* NULL if not coaleased */
  ushort cntl ;                    /* control word */
  ushort buffer_id ;               /* used for allocation/deallocation */
  uchar  q_required ;              /* number of queues required */
  uchar  res ;
} ASC_EXT_SCSI_Q ;
#endif /* CC_LINK_BUSY_Q */

/*
** ========================================================
** the asc-1000 queue struct on host side for device driver
**
** ======================================================
*/
typedef struct asc_scsi_q {
  ASC_SCSIQ_1  q1 ;
  ASC_SCSIQ_2  q2 ;
  uchar dosfar *cdbptr ;         /* pointer to SCSI CDB block         */
                                 /* CDB length is in q2.cdb_len       */
  ASC_SG_HEAD dosfar *sg_head ;  /* pointer to sg list                */
                                 /* if you have sg list you must set  */
                                 /* QC_SG_HEAD bit of q1.cntl         */
#if CC_LINK_BUSY_Q
  ASC_EXT_SCSI_Q  ext ;
#endif /* CC_LINK_BUSY_Q */

#if CC_ASC_SCSI_Q_USRDEF
  ASC_SCSI_Q_USR  usr ;
#endif

} ASC_SCSI_Q ;

/*
** ----------------------------------------------------------------------
** NOTE:
** 1. the first four fields of ASC_SCSI_REQ_Q must be the same as ASC_SCSI_Q
** -------------------------------------------------------------------
*/
typedef struct asc_scsi_req_q {
  ASC_SCSIQ_1  r1 ;
  ASC_SCSIQ_2  r2 ;
  uchar dosfar *cdbptr ;         /* pointer to SCSI CDB block, 12 bytes maximum */
  ASC_SG_HEAD dosfar *sg_head ;  /* pointer to sg list */

#if CC_LINK_BUSY_Q
  ASC_EXT_SCSI_Q  ext ;
#endif /* CC_LINK_BUSY_Q */
/*
** we must maintain the struct the same as ASC_SCSI_Q before here
*/
  uchar dosfar *sense_ptr ;  /* the pointer to sense buffer address      */
                             /* this is useful when sense buffer is not  */
                             /* in the sense[ ] array                    */
                             /*                                          */
  ASC_SCSIQ_3  r3 ;
  uchar  cdb[ ASC_MAX_CDB_LEN ] ;
  uchar  sense[ ASC_MIN_SENSE_LEN ] ;

#if CC_ASC_SCSI_REQ_Q_USRDEF
  ASC_SCSI_REQ_Q_USR  usr ;
#endif

} ASC_SCSI_REQ_Q ;

typedef struct asc_scsi_bios_req_q {
  ASC_SCSIQ_1  r1 ;
  ASC_SCSIQ_2  r2 ;
  uchar dosfar *cdbptr ;         /* pointer to SCSI CDB block, 12 bytes maximum */
  ASC_SG_HEAD dosfar *sg_head ;  /* pointer to sg list */

/*
** we must maintain the struct the same as ASC_SCSI_Q before here
*/
  uchar dosfar *sense_ptr ;  /* the pointer to sense buffer address      */
                             /* this is useful when sense buffer is not  */
                             /* in the sense[ ] array                    */
                             /*                                          */
  ASC_SCSIQ_3  r3 ;
  uchar  cdb[ ASC_MAX_CDB_LEN ] ;
  uchar  sense[ ASC_MIN_SENSE_LEN ] ;
} ASC_SCSI_BIOS_REQ_Q ;

/*
**
*/
typedef struct asc_risc_q {
  uchar  fwd ;
  uchar  bwd ;
  ASC_SCSIQ_1  i1 ;
  ASC_SCSIQ_2  i2 ;
  ASC_SCSIQ_3  i3 ;
  ASC_SCSIQ_4  i4 ;
} ASC_RISC_Q ;

/*
** sg list queue, exclude the fwd and bwd links
** should not exceed 6 bytes !
*/
typedef struct asc_sg_list_q {
/*  uchar fwd ;                   0  forward pointer, does not exist on host side   */
/*  uchar bwd ;                   1  backward pointer, does not exist on host side  */
  uchar  seq_no ;              /* 2  will be set to zero when the queue is done     */
  uchar  q_no ;                /* 3  queue number                                   */
  uchar  cntl ;                /* 4  queue control byte                             */
  uchar  sg_head_qp ;          /* 5  queue number of sg head queue                  */
  uchar  sg_list_cnt ;         /* 6  number of sg list entries in this queue        */
  uchar  sg_cur_list_cnt ;     /* 7  initially same as sg list_cnt */
                               /* 7  will reach zero when list done */
} ASC_SG_LIST_Q ;

typedef struct asc_risc_sg_list_q {
  uchar  fwd ;                 /* 0  forward pointer, does not exist on host side  */
  uchar  bwd ;                 /* 1  backward pointer, does not exist on host side */
  ASC_SG_LIST_Q  sg ;          /*                                                  */
  ASC_SG_LIST sg_list[ 7 ] ;   /* 8-63 the sg list of address and bytes            */
} ASC_RISC_SG_LIST_Q ;

#endif /* #ifndef _ASPIQ_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc\a_ddlib.h ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** Filename: a_ddlib.h
**
** include file for device driver writer
**
*/

#ifndef __A_DDLIB_H_
#define __A_DDLIB_H_

#include "ascdef.h"
#include "a_osdep.h"   /* os dependent */
#include "a_cc.h"      /* code generation control */
#include "ascdep.h"    /* chip dependent include file  */
#include "ascsidef.h"  /* ASC SCSI definition          */
#include "aspiq.h"     /* ASC QUEUE                    */

#include "asc1000.h"

/*
** for device driver writer
** you need to support the following routines
*/

extern int    DvcEnterCritical( void ) ;
extern void   DvcLeaveCritical( int ) ;
extern void   DvcSetMemory( uchar dosfar *, uint, uchar ) ;
extern void   DvcCopyMemory( uchar dosfar *, uchar dosfar *, uint ) ;

extern void   DvcInPortWords( PortAddr, ushort dosfar *, int ) ;
extern void   DvcOutPortWords( PortAddr, ushort dosfar *, int ) ;
extern void   DvcOutPortDWords( PortAddr, ulong dosfar *, int ) ;

extern uchar  DvcReadPCIConfigByte( ASC_DVC_VAR asc_ptr_type *, ushort ) ;
extern void   DvcWritePCIConfigByte( ASC_DVC_VAR asc_ptr_type *, ushort, uchar ) ;
/* extern ushort DvcReadPCIConfigWord( ASC_DVC_VAR asc_ptr_type *, ushort ) ; */
/* extern void   DvcWritePCIConfigWord( ASC_DVC_VAR asc_ptr_type *, ushort, ushort ) ; */
/* extern ulong  DvcReadPCIConfigDWord( ASC_DVC_VAR asc_ptr_type *, ushort ) ; */
/* extern void   DvcWritePCIConfigDWord( ASC_DVC_VAR asc_ptr_type *, ushort, ulong ) ; */

extern void   DvcSleepMilliSecond( ulong ) ;
extern void   DvcDelayNanoSecond( ASC_DVC_VAR asc_ptr_type *, ulong ) ;

extern void   DvcDisplayString( uchar dosfar * ) ;
extern ulong  DvcGetPhyAddr( uchar dosfar *buf_addr, ulong buf_len ) ;
extern ulong  DvcGetSGList( ASC_DVC_VAR asc_ptr_type *, uchar dosfar *, ulong,
                            ASC_SG_HEAD dosfar * ) ;

/*
** for SCAM only, define CC_SCAM as TRUE in "a_cc.h" to enable SCAM
*/
extern void   DvcSCAMDelayMS( ulong ) ;
extern int    DvcDisableCPUInterrupt( void ) ;
extern void   DvcRestoreCPUInterrupt( int ) ;

/*
**
** extern int    DvcNotifyUcBreak( ASC_DVC_VAR asc_ptr_type *asc_dvc, ushort break_addr ) ;
**
*/
extern int    DvcNotifyUcBreak( ASC_DVC_VAR asc_ptr_type *, ushort ) ;
/* extern int    DvcDebugDisplayString( uchar * ) ; */


/*
**
** special put/get Q struct routine
** for compiler aligned struct ( no packing ) use file "a_align.c"
**
*/
void  DvcPutScsiQ( PortAddr, ushort, ushort dosfar *, int ) ;
void  DvcGetQinfo( PortAddr, ushort, ushort dosfar *, int ) ;

/*
** if you use AscInitScsiTarget(), you need to provide the following
** two functions, and also two source files of asc_inq.c and asc_scsi.c
*/

/*
** you only need the following routines to write a device driver
*/

/*
** initialization functions
*/
PortAddr AscSearchIOPortAddr( PortAddr, ushort ) ;
ushort AscInitGetConfig( ASC_DVC_VAR asc_ptr_type * ) ;
ushort AscInitSetConfig( ASC_DVC_VAR asc_ptr_type * ) ;
ushort AscInitAsc1000Driver( ASC_DVC_VAR asc_ptr_type * ) ;
int    AscInitScsiTarget( ASC_DVC_VAR asc_ptr_type *,
                          ASC_DVC_INQ_INFO dosfar *,
                          uchar dosfar *,
                          ASC_CAP_INFO_ARRAY dosfar *,
                          ushort ) ;
int    AscInitPollBegin( ASC_DVC_VAR asc_ptr_type * ) ;
int    AscInitPollEnd( ASC_DVC_VAR asc_ptr_type * ) ;
int    AscInitPollTarget( ASC_DVC_VAR asc_ptr_type *,
                          ASC_SCSI_REQ_Q dosfar *,
                          ASC_SCSI_INQUIRY dosfar *,
                          ASC_CAP_INFO dosfar * ) ;
void   AscInquiryHandling(ASC_DVC_VAR asc_ptr_type *,
                          uchar,
                          ASC_SCSI_INQUIRY dosfar *);
int    AscExeScsiQueue( ASC_DVC_VAR asc_ptr_type *, ASC_SCSI_Q dosfar * ) ;

/*
** handle interrupt functions
*/
int    AscISR( ASC_DVC_VAR asc_ptr_type * ) ;
void   AscISR_AckInterrupt( ASC_DVC_VAR asc_ptr_type * ) ;
int    AscISR_CheckQDone( ASC_DVC_VAR asc_ptr_type *,
                          ASC_QDONE_INFO dosfar *,
                          uchar dosfar * ) ;
/*
** Macro
**
**     AscIsIntPending( port )
**
*/

/*
** for Power Saver
*/
int    AscStartUnit( ASC_DVC_VAR asc_ptr_type *, ASC_SCSI_TIX_TYPE ) ;

int    AscStopUnit(
          ASC_DVC_VAR asc_ptr_type *asc_dvc,
          ASC_SCSI_TIX_TYPE target_ix
       ) ;

/*
** queue resource inquiry functions
*/
uint   AscGetNumOfFreeQueue( ASC_DVC_VAR asc_ptr_type *, uchar, uchar ) ;
int    AscSgListToQueue( int ) ;
int    AscQueueToSgList( int ) ;
int    AscSetDvcErrorCode( ASC_DVC_VAR asc_ptr_type *, uchar ) ;

/*
**  handle unexpected event
*/
int    AscAbortSRB( ASC_DVC_VAR asc_ptr_type *, ulong ) ;
int    AscResetDevice( ASC_DVC_VAR asc_ptr_type *, uchar ) ;
int    AscResetSB( ASC_DVC_VAR asc_ptr_type * ) ;

/*
** for ISA only
*/
void   AscEnableIsaDma( uchar ) ;
void   AscDisableIsaDma( uchar ) ;

/*
**
**  for DMA limitation
**
*/
ulong  AscGetMaxDmaAddress( ushort ) ;
ulong  AscGetMaxDmaCount( ushort ) ;


/*
**
** set micro code break point
** file "a_debug.c"
**
*/
int               AscSetUcBreakPoint( ASC_DVC_VAR asc_ptr_type *, ushort, int, ushort ) ;
int               AscClearUcBreakPoint( ASC_DVC_VAR asc_ptr_type *, ushort ) ;

/*
** for Novell only
*/
int    AscSaveMicroCode( ASC_DVC_VAR asc_ptr_type *, ASC_MC_SAVED dosfar * ) ;
int    AscRestoreOldMicroCode( ASC_DVC_VAR asc_ptr_type *, ASC_MC_SAVED dosfar * ) ;
int    AscRestoreNewMicroCode( ASC_DVC_VAR asc_ptr_type *, ASC_MC_SAVED dosfar * ) ;

#endif /* __A_DDLIB_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc\a_eisa.c ===
/*
** Copyright (c) 1994-1997 Advanced System Products, Inc.
** All Rights Reserved.
**
** a_eisa.c
**
** for EISA only, functions may be called at run time
**
*/

#include "ascinc.h"

#if CC_INCLUDE_EISA

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------ */
ushort AscGetEisaChipCfg(
          PortAddr iop_base
       )
{
       PortAddr  eisa_cfg_iop ;

       eisa_cfg_iop = ( PortAddr )ASC_GET_EISA_SLOT( iop_base ) |
                                  ( PortAddr )( ASC_EISA_CFG_IOP_MASK ) ;
       return( inpw( eisa_cfg_iop ) ) ;
}

/* ----------------------------------------------------------------------
**  read EISA general purpose register
**  Note: currently unused
** ------------------------------------------------------------------ */
ushort AscGetEisaChipGpReg( PortAddr iop_base )
{
       PortAddr  eisa_cfg_iop ;

       eisa_cfg_iop = ( PortAddr )ASC_GET_EISA_SLOT( iop_base ) |
                                 ( PortAddr )( ASC_EISA_CFG_IOP_MASK - 2 ) ;
       return( inpw( eisa_cfg_iop ) ) ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------ */
ushort AscSetEisaChipCfg(
          PortAddr iop_base,
          ushort cfg_lsw
       )
{
       PortAddr  eisa_cfg_iop ;

       eisa_cfg_iop = ( PortAddr )ASC_GET_EISA_SLOT( iop_base ) |
                                 ( PortAddr )( ASC_EISA_CFG_IOP_MASK ) ;
       outpw( eisa_cfg_iop, cfg_lsw ) ;
       return( 0 ) ;
}

/* ----------------------------------------------------------------------
**
** write EISA general purpose register
** Note:
**  currently unused
** ------------------------------------------------------------------ */
ushort AscSetEisaChipGpReg(
          PortAddr iop_base,
          ushort gp_reg
       )
{
       PortAddr  eisa_cfg_iop ;

       eisa_cfg_iop = ( PortAddr )ASC_GET_EISA_SLOT( iop_base ) |
                                 ( PortAddr )( ASC_EISA_CFG_IOP_MASK - 2 ) ;
       outpw( eisa_cfg_iop, gp_reg ) ;
       return( 0 ) ;
}

#endif /* CC_INCLUDE_EISA */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc\a_cc.h ===
/*
** Copyright (c) 1994-1997 Advanced System Products, Inc.
** All Rights Reserved.
**
** Filename: a_cc.h
**
** compiling code generation control file
**
** This is a MS-DOS template file
*/

#ifndef __A_CC_H_
#define __A_CC_H_

/*
** for debugging
** turn off for released code
*/
#ifdef  OS_MS_DOS

#define CC_INIT_INQ_DISPLAY     TRUE   /* init inquiry display target info */

#else

#define CC_INIT_INQ_DISPLAY     FALSE   /* init inquiry display target info */

#endif

#define CC_CLEAR_LRAM_SRB_PTR   FALSE  /* set srb pointer in local to zero when queue done */
#define CC_VERIFY_LRAM_COPY     FALSE  /* set to TRUE to enable local RAM copy checking capability */
                                       /* performing verification depend on asc_dvc->cntl ASC_CNTL_NO_VERIFY_COPY  bit set/clear */
#define CC_DEBUG_SG_LIST        FALSE  /* set to TRUE to debug sg list odd address problem */
#define CC_FAST_STRING_IO       FALSE  /* use intel string instruction */
                                       /* do not set TRUE, it's not working ! */

#define CC_WRITE_IO_COUNT       FALSE  /* added S47, write scsiq->req_count */


/*
** for fixing bugs
*/

#define CC_DISABLE_PCI_PARITY_INT TRUE /* set to 1 to disable PCI bus parity interrupt */
                                       /* this is necessary for PCI REV A chip ( device code 0x1100 ) */
/*
**
** following control depends on driver
**
*/
#define CC_LINK_BUSY_Q         FALSE  /* AscExeScsiQueue() no busy return status */

#define CC_TARGET_MODE         FALSE  /* enable target mode ( processor device ) */

#define CC_SCAM                TRUE   /* include SCAM code */


/* DATE: 11/28/95 */
#define CC_LITTLE_ENDIAN_HOST  TRUE   /* host is little-endian machine, Example: IBM PC with Intel CPUs */
                                      /* big-endian machine, example: Motorola CPUs */

#if CC_LITTLE_ENDIAN_HOST
#define CC_TEST_LRAM_ENDIAN     FALSE
#else
#define CC_TEST_LRAM_ENDIAN     TRUE
#endif

/* DATE: 11/28/95 */
#define CC_STRUCT_ALIGNED      FALSE  /* default is packing ( not aligned ) */
                                      /* word variable to word boundary address */
                                      /* dword variable to dword boundary address */

/* DATE: 11/28/95 */
#define CC_MEMORY_MAPPED_IO    FALSE  /* define TRUE in memory-mapped host */

#define CC_FIX_QUANTUM_XP34301_1071  TRUE

#define CC_INIT_SCSI_TARGET FALSE

#endif /* #ifndef __A_CC_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc\a_init3.c ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** a_init3.c
**
** non PCI init modules
**
*/

#include "ascinc.h"

#if !CC_PCI_ADAPTER_ONLY

/* -----------------------------------------------------------------
**
** -------------------------------------------------------------- */
void   AscSetISAPNPWaitForKey( void )
{
/*
**  write 0x02 to address 0x02
*/
       outp( ASC_ISA_PNP_PORT_ADDR, 0x02 ) ;
       outp( ASC_ISA_PNP_PORT_WRITE, 0x02 ) ;
       return ;
}

/* ----------------------------------------------------------------------
**
** returns:
** 0 :   no irq
** 10 - xx : either 10, 11, 12, 14, 15
**
** ------------------------------------------------------------------- */
uchar  AscGetChipIRQ(
          PortAddr iop_base,
          ushort bus_type
       )
{
       ushort  cfg_lsw ;
       uchar   chip_irq ;

/*
** else VL, ISA, PCI
*/
#if CC_INCLUDE_VL
       if( ( bus_type & ASC_IS_VL ) != 0 )
       {
/*
** VL VERSION
*/
           cfg_lsw = AscGetChipCfgLsw( iop_base ) ;
           chip_irq = ( uchar )( ( ( cfg_lsw >> 2 ) & 0x07 ) ) ;
           if( ( chip_irq == 0 ) ||
               ( chip_irq == 4 ) ||
               ( chip_irq == 7 ) )
           {
               return( 0 ) ;
           }/* if */
#if CC_PLEXTOR_VL
/*
**
** special plextor version VL adapter
** IRQ 14 is routed to IRQ 9
**
*/
           if( chip_irq == 5 )
           {
               return( 9 ) ;
           }
#endif /* CC_PLEXTOR_VL */
           return( ( uchar )( chip_irq + ( ASC_MIN_IRQ_NO - 1 ) ) ) ;
       }/* if VL */
#endif /* CC_INCLUDE_VL */
/*
** ISA VERSION
** PCI VERSION
*/
       cfg_lsw = AscGetChipCfgLsw( iop_base ) ;
       chip_irq = ( uchar )( ( ( cfg_lsw >> 2 ) & 0x03 ) ) ;
       if( chip_irq == 3 ) chip_irq += ( uchar )2 ;
       return( ( uchar )( chip_irq + ASC_MIN_IRQ_NO ) ) ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
void   AscToggleIRQAct(
          PortAddr iop_base
       )
{
       AscSetChipStatus( iop_base, CIW_IRQ_ACT ) ;
       AscSetChipStatus( iop_base, 0 ) ;
       return ;
}

/* ----------------------------------------------------------------------
** input:
** IRQ should be : 0, 10 - 15
** use IRQ = 0 to disable it
**
** returns:
** same as AscGetChipIRQ
**
** Note:
**  1. you should also change the EEPROM IRQ setting after this
**  2. this should be done only during chip initialization
**
** ------------------------------------------------------------------- */
uchar  AscSetChipIRQ(
          PortAddr iop_base,
          uchar irq_no,
          ushort bus_type
       )
{
       ushort  cfg_lsw ;

#if CC_INCLUDE_VL
       if( ( bus_type & ASC_IS_VL ) != 0 )
       {
/*
** VL VERSION
*/
           if( irq_no != 0 )
           {
#if CC_PLEXTOR_VL
               if( irq_no == 9 )
               {
                   irq_no = 14 ;
               }
#endif /* CC_PLEXTOR_VL */
               if( ( irq_no < ASC_MIN_IRQ_NO ) || ( irq_no > ASC_MAX_IRQ_NO ) )
               {
                   irq_no = 0 ;
               }/* if */
               else
               {
                   irq_no -= ( uchar )( ( ASC_MIN_IRQ_NO - 1 ) ) ;
               }/* else */
           }/* if */
/*
** first reset IRQ
*/
           cfg_lsw = ( ushort )( AscGetChipCfgLsw( iop_base ) & 0xFFE3 ) ;
           cfg_lsw |= ( ushort )0x0010 ;
           AscSetChipCfgLsw( iop_base, cfg_lsw ) ;
           AscToggleIRQAct( iop_base ) ;
/*
** set new IRQ
*/
           cfg_lsw = ( ushort )( AscGetChipCfgLsw( iop_base ) & 0xFFE0 ) ;
           cfg_lsw |= ( ushort )( ( irq_no & 0x07 ) << 2 ) ;
           AscSetChipCfgLsw( iop_base, cfg_lsw ) ;
           AscToggleIRQAct( iop_base ) ;
/*
** now we must toggle write IRQ bit
*/
           return( AscGetChipIRQ( iop_base, bus_type ) ) ;

      }/* if VL */

#endif /* CC_INCLUDE_VL */

      if( ( bus_type & ( ASC_IS_ISA ) ) != 0 )
      {
/*
** ISA VERSION
*/
           if( irq_no == 15 ) irq_no -= ( uchar )2 ;
           irq_no -= ( uchar )ASC_MIN_IRQ_NO ;
           cfg_lsw = ( ushort )( AscGetChipCfgLsw( iop_base ) & 0xFFF3 ) ;
           cfg_lsw |= ( ushort )( ( irq_no & 0x03 ) << 2 ) ;
           AscSetChipCfgLsw( iop_base, cfg_lsw ) ;
           return( AscGetChipIRQ( iop_base, bus_type ) ) ;
      }/* else if ISA */
/*
** PCI, EISA VERSION
*/
      return( 0 ) ;
}

/* --------------------------------------------------------------
** enable ISA DMA channel 0-7
**
**
** ----------------------------------------------------------- */
void   AscEnableIsaDma(
          uchar dma_channel
       )
{
       if( dma_channel < 4 )
       {
           outp( 0x000B, ( ushort )( 0xC0 | dma_channel ) ) ;
           outp( 0x000A, dma_channel ) ;
       }/* if */
       else if( dma_channel < 8 )
       {
/*
** 0xC0 set CASCADE MODE
*/
           outp( 0x00D6, ( ushort )( 0xC0 | ( dma_channel - 4 ) ) ) ;
           outp( 0x00D4, ( ushort )( dma_channel - 4 ) ) ;
       }/* else */
       return ;
}

/* --------------------------------------------------------------
**
** ----------------------------------------------------------- */
void   AscDisableIsaDma(
          uchar dma_channel
       )
{
       if( dma_channel < 4 )
       {
           outp( 0x000A, ( ushort )( 0x04 | dma_channel ) ) ;
       }/* if */
       else if( dma_channel < 8 )
       {
           outp( 0x00D4, ( ushort )( 0x04 | ( dma_channel - 4 ) ) ) ;
       }/* else */
       return ;
}

#endif /* !CC_PCI_ADAPTER_ONLY */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc\a_irq.h ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** Filename: A_IRQ.H
**
*/

#ifndef  __A_IRQ_H
#define  __A_IRQ_H

/* ----------------------------------------------------------------- */
#define IRQ0_VECT   0x08 /* Timer tick, 18.2 times per second            */
#define IRQ1_VECT   0x09 /* keyboard service request                     */
#define IRQ2_VECT   0x0A /* INT form slave 8259A:                        */
#define IRQ3_VECT   0x0B /* COM2, COM4, network adapter, CD-ROM adapter, */
                         /* and sound board                              */
#define IRQ4_VECT   0x0C /* COM1 and COM3                                */
#define IRQ5_VECT   0x0D /* LPT2 parallel port                           */
#define IRQ6_VECT   0x0E /* floppy disk controller                       */
#define IRQ7_VECT   0x0F /* LPT1, but rarely used                        */

#define IRQ8_VECT   0x70 /*     real time clock service                  */
#define IRQ9_VECT   0x71 /*     software redirected to IRQ 2             */
#define IRQ10_VECT  0x72 /*     reserved                                 */
#define IRQ11_VECT  0x73 /*     reserved                                 */
#define IRQ12_VECT  0x74 /*     reserved                                 */
#define IRQ13_VECT  0x75 /*     numeric( math ) coprocessor              */
#define IRQ14_VECT  0x76 /*     fixed disk controller                    */
#define IRQ15_VECT  0x77 /*     reserved                                 */

/*
** progamable interrupt controller (PIC) 8259A
*/
#define PIC1_OCR  0x20 /* location of first 8259A operational control register   */
#define PIC1_IMR  0x21 /* location of first 8259A interrupt mask register        */
#define PIC2_OCR  0xA0 /* location of second 8259A operational control register  */
#define PIC2_IMR  0xA1 /* location of second 8259A interrupt mask register       */

#define NONSPEC_EOI 0x20  /* Non-specific EOI     */
#define SPEC_EOI7   0x67  /* specific EOI for int level 7 */

#define REARM3   0x2F3 /* global REARM location for interrupt level 3   */
#define REARM4   0x2F4 /* global REARM location for interrupt level 4   */
#define REARM5   0x2F5 /* global REARM location for interrupt level 5   */
#define REARM6   0x2F6 /* global REARM location for interrupt level 6   */
#define REARM7   0x2F7 /* global REARM location for interrupt level 7   */
#define REARM9   0x2F2 /* global REARM location for interrupt level 9   */
#define REARM10  0x6F2 /* global REARM location for interrupt level 10  */
#define REARM11  0x6F3 /* global REARM location for interrupt level 11  */
#define REARM12  0x6F4 /* global REARM location for interrupt level 12  */
#define REARM13  0x6F5 /* global REARM location for interrupt level 13  */
#define REARM14  0x6F6 /* global REARM location for interrupt level 14  */
#define REARM15  0x6F7 /* global REARM location for interrupt level 15  */

#endif /* __A_IRQ_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc\a_init1.c ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** a_init1.c
**
*/

#include "ascinc.h"

/* ---------------------------------------------------------------------
**
** ------------------------------------------------------------------ */
void   AscClrResetScsiBus(
          PortAddr iop_base
       )
{
       uchar  cc ;

       cc = AscGetChipControl( iop_base ) ;
       cc &= ~( CC_SCSI_RESET | CC_SINGLE_STEP | CC_DIAG | CC_TEST ) ;
       AscSetChipControl( iop_base, cc ) ;
       return ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------ */
uchar  AscSetChipScsiID(
          PortAddr iop_base,
          uchar new_host_id
       )
{
       ushort cfg_lsw ;

       if( AscGetChipScsiID( iop_base ) == new_host_id ) {
           return( new_host_id ) ;
       }/* if */
       cfg_lsw = AscGetChipCfgLsw( iop_base ) ;
       cfg_lsw &= 0xF8FF ;
       cfg_lsw |= ( ushort )( ( new_host_id & ASC_MAX_TID ) << 8 ) ;
       AscSetChipCfgLsw( iop_base, cfg_lsw ) ;
       return( AscGetChipScsiID( iop_base ) ) ;
}

/* ----------------------------------------------------------------------
** return chip scsi contrl
**
** see asc1000.h definition SC_?? for details
** ------------------------------------------------------------------- */
uchar  AscGetChipScsiCtrl(
          PortAddr iop_base
       )
{
       uchar  sc ;

       AscSetBank( iop_base, 1 ) ;
       sc = inp( iop_base+IOP_REG_SC ) ;
       AscSetBank( iop_base, 0 ) ;
       return( sc ) ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------ */
uchar  AscGetChipVersion(
          PortAddr iop_base,
          ushort bus_type
       )
{

#if !CC_PCI_ADAPTER_ONLY
#if CC_INCLUDE_EISA
       if( ( bus_type & ASC_IS_EISA ) != 0 ) {
/*
** EISA
**
** Only version 1 of the EISA chip was ever and will ever be released.
*/
           return( 1 );
       }/* if */
#endif
#endif
       return( AscGetChipVerNo( iop_base ) ) ;
}

/* ----------------------------------------------------------------------
**
** return following bus type
** ASC_IS_VL
** ASC_IS_ISA
** ASC_IS_PCI
** ASC_IS_EISA
**
** Note:
**   the function cannot get PCI device ID, which was needed
**   in PCI driver init time ( for bug fix of certain version )
**
** ------------------------------------------------------------------ */
ushort AscGetChipBusType(
          PortAddr iop_base
       )
{
       ushort chip_ver ;

#if !CC_PCI_ADAPTER_ONLY
       chip_ver = AscGetChipVerNo( iop_base ) ;

#if CC_INCLUDE_VL
       if(
           ( chip_ver >= ASC_CHIP_MIN_VER_VL )
           && ( chip_ver <= ASC_CHIP_MAX_VER_VL )
         )
       {
           if(
               ( ( iop_base & 0x0C30 ) == 0x0C30 )
               || ( ( iop_base & 0x0C50 ) == 0x0C50 )
             )
           {
               return( ASC_IS_EISA ) ;
           }/* if */
           return( ASC_IS_VL ) ;
       }
#endif /* CC_INCLUDE_VL */

       if( ( chip_ver >= ASC_CHIP_MIN_VER_ISA ) &&
              ( chip_ver <= ASC_CHIP_MAX_VER_ISA ) )
       {
           if( chip_ver >= ASC_CHIP_MIN_VER_ISA_PNP )
           {
               return( ASC_IS_ISAPNP ) ;
           }
           return( ASC_IS_ISA ) ;
       }else if( ( chip_ver >= ASC_CHIP_MIN_VER_PCI ) &&
              ( chip_ver <= ASC_CHIP_MAX_VER_PCI ) )
       {
#endif /* !CC_PCI_ADAPTER_ONLY  */
           return( ASC_IS_PCI ) ;
#if !CC_PCI_ADAPTER_ONLY
       }
       return( 0 ) ; /* error cannot identify bus type */
#endif /* !CC_PCI_ADAPTER_ONLY  */
}

/* -----------------------------------------------------------------------
**
** -------------------------------------------------------------------- */
ulong  AscLoadMicroCode(
          PortAddr iop_base,
          ushort s_addr,
          ushort dosfar *mcode_buf,
          ushort mcode_size
       )
{
       ulong   chksum ;
       ushort  mcode_word_size ;
       ushort  mcode_chksum ;

       mcode_word_size = ( ushort )( mcode_size >> 1 ) ;
       AscMemWordSetLram( iop_base, s_addr, 0, mcode_word_size ) ;
       AscMemWordCopyToLram( iop_base, s_addr, mcode_buf, mcode_word_size ) ;

#if 0
/*
**  use busy queue head as the auto request sense command queue
**  when a check condition occured
**  we put request sense command ( 6 bytes ) into its cdb buffer
*/
       q_no = AscReadLramByte( iop_base, ASCV_BUSY_QHEAD_B ) ;
       q_addr = ASC_QNO_TO_QADDR( q_no ) ;
       AscWriteLramByte( iop_base,
                       ( ushort )( q_addr + ASC_SCSIQ_B_CDB_LEN ), 0x06 ) ;
       AscWriteLramWord( iop_base,
                       ( ushort )( q_addr + ASC_SCSIQ_CDB_BEG ), 0x0003 ) ;
       AscWriteLramWord( iop_base,
                       ( ushort )( q_addr + ASC_SCSIQ_CDB_BEG+2 ), 0x0000 ) ;
       AscWriteLramWord( iop_base,
                       ( ushort )( q_addr + ASC_SCSIQ_CDB_BEG+4 ), 0x0000 ) ;
#endif
/*
** we need to set entire queue buffer data to 0xFF
** it means no queue is disconnected
*/
#if 0
       q_no = AscReadLramByte( iop_base, ASCV_DISC1_QHEAD_B ) ;
       q_addr = ASC_QNO_TO_QADDR( q_no ) ;
       AscMemWordSetLram( iop_base, q_addr,
                          0xFFFF, ( ushort )( ASC_QBLK_SIZE >> 1 ) ) ;
#endif
       chksum = AscMemSumLramWord( iop_base, s_addr, mcode_word_size ) ;
       mcode_chksum = ( ushort )AscMemSumLramWord( iop_base,
                                                 ( ushort )ASC_CODE_SEC_BEG,
       ( ushort )( ( mcode_size - s_addr - ( ushort )ASC_CODE_SEC_BEG )/2 ) ) ;
       AscWriteLramWord( iop_base, ASCV_MCODE_CHKSUM_W, mcode_chksum ) ;
       AscWriteLramWord( iop_base, ASCV_MCODE_SIZE_W, mcode_size ) ;
       return( chksum ) ;
}

/* -----------------------------------------------------------------
** return 0 if not found
** -------------------------------------------------------------- */
int    AscFindSignature(
          PortAddr iop_base
       )
{
       ushort  sig_word ;

       if( AscGetChipSignatureByte( iop_base ) == ( uchar )ASC_1000_ID1B ) {
           sig_word = AscGetChipSignatureWord( iop_base ) ;
           if( ( sig_word == ( ushort )ASC_1000_ID0W ) ||
               ( sig_word == ( ushort )ASC_1000_ID0W_FIX ) ) {
               return( 1 ) ;
           }/* if */
       }/* if */
       return( 0 ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc\a_mcode3.c ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** a_mcode3.c
**
*/

#include "ascinc.h"
#include "a_uc.h"

#if CC_CHECK_MCODE_SIZE_AT_COMPILE

#if sizeof( _mcode_buf ) > 0x900

/* #error micro code size too big ! */

yes, I intentionally made a syntax error here !

#endif /* if uc size too big */

#endif /* CC_CHECK_MCODE_SIZE_AT_COMPILE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc\a_init2.c ===
/*
** Copyright (c) 1994-1997 Advanced System Products, Inc.
** All Rights Reserved.
**
** a_init2.c
**
*/


#include "ascinc.h"

#if !CC_PCI_ADAPTER_ONLY
/*
** for VL, ISA
*/

uchar _isa_pnp_inited = 0 ;

PortAddr _asc_def_iop_base[ ASC_IOADR_TABLE_MAX_IX ] = {
  0x100, ASC_IOADR_1, 0x120, ASC_IOADR_2, 0x140, ASC_IOADR_3, ASC_IOADR_4,
  ASC_IOADR_5, ASC_IOADR_6, ASC_IOADR_7, ASC_IOADR_8
} ;


/* -----------------------------------------------------------------
** return 0 if not found
**
** -------------------------------------------------------------- */
PortAddr AscSearchIOPortAddr(
            PortAddr iop_beg,
            ushort bus_type
         )
{

#if CC_INCLUDE_VL
       if( bus_type & ASC_IS_VL )
       {
           while( ( iop_beg = AscSearchIOPortAddr11( iop_beg ) ) != 0 )
           {
               if( AscGetChipVersion( iop_beg, bus_type ) <= ASC_CHIP_MAX_VER_VL )
               {
                   return( iop_beg ) ;
               }/* if */
           }/* if */
           return( 0 ) ;
       }/* if */
#endif /* CC_INCLUDE_VL */

       if( bus_type & ASC_IS_ISA )
       {
           if( _isa_pnp_inited == 0 )
           {
               AscSetISAPNPWaitForKey( ) ;
               _isa_pnp_inited++ ;
           }/* if */
           while( ( iop_beg = AscSearchIOPortAddr11( iop_beg ) ) != 0 )
           {
               if( ( AscGetChipVersion( iop_beg, bus_type ) & ASC_CHIP_VER_ISA_BIT ) != 0 )
               {
                   return( iop_beg ) ;
               }/* if */
           }/* if */
           return( 0 ) ;
       }/* if */

#if CC_INCLUDE_EISA
       if( bus_type & ASC_IS_EISA )
       {
           if( ( iop_beg = AscSearchIOPortAddrEISA( iop_beg ) ) != 0 )
           {
               return( iop_beg ) ;
           }/* if */
           return( 0 ) ;
       }/* if */
#endif
       return( 0 ) ;
}

/* -----------------------------------------------------------------
** Description: search VL and ISA host adapter ( on 8 default address )
**
** return 0 if not found
** -------------------------------------------------------------- */
PortAddr AscSearchIOPortAddr11(
            PortAddr s_addr
         )
{
/*
** VL, ISA
*/
       int      i ;
       PortAddr iop_base ;

       for( i = 0 ; i < ASC_IOADR_TABLE_MAX_IX ; i++ )
       {
            if( _asc_def_iop_base[ i ] > s_addr )
            {
                break ;
            }/* if */
       }/* for */
       for( ; i < ASC_IOADR_TABLE_MAX_IX ; i++ )
       {
            iop_base = _asc_def_iop_base[ i ] ;
            if( AscFindSignature( iop_base ) )
            {
                return( iop_base ) ;
            }/* if */
       }/* for */
       return( 0 ) ;
}

/* -----------------------------------------------------------------
** Description: search VL and ISA host adapter
**
** search starts with iop_base equals 0
** return i/o port address found
** return 0 if not found
** -------------------------------------------------------------- */
PortAddr AscSearchIOPortAddr100(
            PortAddr iop_base
         )
{
/*
** VL, ISA
*/
       if( iop_base > ASC_MAX_IOP_ADDR ) return( 0 ) ;
       if( iop_base == 0 ) iop_base = ASC_MIN_IOP_ADDR ;
       else
       {
           iop_base += ( PortAddr )( ASC_SEARCH_IOP_GAP ) ;
       }/* else */
       while( iop_base <= ASC_MAX_IOP_ADDR )
       {
           if( AscFindSignature( iop_base ) )
           {
               return( iop_base ) ;
           }/* if */
           iop_base += ( PortAddr )( ASC_SEARCH_IOP_GAP ) ;
       }/* while */
       return( 0 ) ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
void   AscToggleIRQAct(
          PortAddr iop_base
       )
{
       AscSetChipStatus( iop_base, CIW_IRQ_ACT ) ;
       AscSetChipStatus( iop_base, 0 ) ;
       return ;
}

/* ---------------------------------------------------------------------
**
** ------------------------------------------------------------------ */
void   AscClrResetChip(
          PortAddr iop_base
       )
{
       uchar  cc ;

       while( AscGetChipStatus( iop_base ) & CSW_SCSI_RESET_ACTIVE ) ;
       cc = AscGetChipControl( iop_base ) ;
       cc &= ( uchar )( ~( CC_CHIP_RESET | CC_SINGLE_STEP | CC_DIAG | CC_TEST ) ) ;
       AscSetChipControl( iop_base, cc ) ;
       return ;
}

#endif /* #if !CC_PCI_ADAPTER_ONLY */

#if CC_INIT_INQ_DISPLAY

uchar  _hextbl_[ 16 ] = { '0','1','2','3','4','5','6','7','8','9',
                          'A','B','C','D','E','F' } ;

/* -----------------------------------------------------------------------
** Usage  :  void  itos( num, nstr, ndigit, f_blank )
**                 short  num, ndigit, f_blank ;
**                 U_CHAR  *nstr ;
**
**           num  :   the integer to be converted
**           nstr :   the converted ascii string
**           ndigit : minimum number of digits
**           f_blank : if TRUE,  fill string under ndigit with blanks
**                     else fill with '0'
**
** Description : convert an integer to ascii string
**
** -------------------------------------------------------------------- */
short  itos(
             ushort num,
             ruchar dosfar *nstr,
             short ndigit,
             short f_blank
       )
{
       short    len, div ;
       short    fill ;
       ushort   divisor ;
       uchar    f_ch ;

       len = 0 ;
       if( num == 0 )
       {
           *nstr = '0' ;
           len++ ;
       }/* if */
       else
       {
           if( num < 10 ) divisor = 1 ;
           else if( num < 100 ) divisor = 10 ;
           else if( num < 1000 ) divisor = 100 ;
           else if( num < 10000 ) divisor = 1000 ;
           else divisor = 10000 ;
           while( divisor != 0 )
           {
               if( num >= divisor )
               {
                   div = ( num / divisor ) ;
                   num -= divisor * div ;
                   nstr[ len ] = div + '0' ;
               }/* if */
               else nstr[ len ] = '0' ;
               len++ ;
               divisor /= 10 ;
           }/* while */
       }/* else */
       nstr[ len ] = EOS ;
       if( ( fill = ndigit - len ) > 0 )
       {
           if( f_blank == 0 ) f_ch = '0' ;
           else  f_ch = ' ' ;
           return( insnchar( nstr, len, 0, f_ch, fill ) ) ;
       }/* if string length under ndigit specified */
       return( len ) ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
int    insnchar(
           uchar dosfar *str,
           short len,
           short beg_po,
           ruchar ch,
           short n_ch
       )
{
       ruchar dosfar *strbeg ;
       ruchar dosfar *str2 ;

       strbeg = str + beg_po ;
       str += len ;
       str2 = str + n_ch ;
       while( str >= strbeg ) *str2-- = *str-- ;
       str2 = strbeg + n_ch ; /* end of insertion */
       while( strbeg < str2 ) *strbeg++ = ch ;
       /* move string content fill position */
       return( len + n_ch ) ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
void   itoh(
             ushort word_val,
             ruchar dosfar *hstr
       )
{
       short     shf ;
       ruchar dosfar *strend ;
       ruchar dosfar *htbl = ( uchar dosfar *)_hextbl_ ;

       strend = hstr + 4 ;
       *strend-- = EOS ;
       for( shf = 0 ; strend >= hstr ; shf += 4 )
       {
            *strend-- = htbl[ ( word_val >> shf ) & 0x000F ] ;
       }/* for */
       return ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
void   btoh(
             uchar byte_val,
             ruchar dosfar *hstr
       )
{
       short     shf ;
       ruchar dosfar *strend ;
       ruchar dosfar *htbl = ( uchar dosfar *)_hextbl_ ;

       strend = hstr + 2 ;
       *strend-- = EOS ;
       for( shf = 0 ; strend >= hstr ; shf += 4 )
       {
            *strend-- = htbl[ ( byte_val >> shf ) & 0x0F ] ;
       }/* for */
       return ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
void   ltoh(
             ulong lval,
             ruchar dosfar *hstr
       )
{
       ushort dosfar *val ;

       val = ( ushort *)&lval ;
       val++ ;
       itoh( *val--, hstr ) ;
       hstr += 4 ;
       *hstr++ = ':' ;
       itoh( *val, hstr ) ;
       return ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
uchar dosfar *todstr(
           ushort val,
           uchar dosfar *strhex
       )
{
       itos( val, strhex, 0, 0 ) ;
       return( strhex ) ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
uchar dosfar *tohstr(
           ushort val,
           uchar dosfar *hstr
        )
{
        itoh( val, hstr ) ;
        return( hstr ) ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
uchar dosfar *tobhstr(
         uchar val,
         uchar dosfar *hstr
      )
{
        btoh( val, hstr ) ;
        return( hstr ) ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
uchar dosfar *tolhstr(
          ulong val,
          uchar dosfar *hstr
      )
{
        ltoh( val, hstr ) ;
        return( hstr ) ;
}


#endif /* CC_INIT_INQ_DISPLAY */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc\a_isr.c ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** a_isr.c
**
*/

#include "ascinc.h"

/* ---------------------------------------------------------------------
**
** ------------------------------------------------------------------ */
int    AscIsrChipHalted(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc
       )
{
       EXT_MSG  ext_msg ;
       EXT_MSG  out_msg ;
       ushort  halt_q_addr ;
       int     sdtr_accept ;
       ushort  int_halt_code ;
       ASC_SCSI_BIT_ID_TYPE scsi_busy ;
       ASC_SCSI_BIT_ID_TYPE target_id ;
       PortAddr iop_base ;
       uchar   tag_code ;
       uchar   q_status ;
       uchar   halt_qp ;
       uchar   sdtr_data ;
       uchar   target_ix ;
       uchar   q_cntl, tid_no ;
       uchar   cur_dvc_qng ;
       uchar   asyn_sdtr ;
       uchar   scsi_status ;

       iop_base = asc_dvc->iop_base ;
       int_halt_code = AscReadLramWord( iop_base, ASCV_HALTCODE_W ) ;
       /* _err_halt_code = int_halt_code ; */
       halt_qp = AscReadLramByte( iop_base, ASCV_CURCDB_B ) ;
       halt_q_addr = ASC_QNO_TO_QADDR( halt_qp ) ;
       target_ix = AscReadLramByte( iop_base,
                ( ushort )( halt_q_addr+( ushort )ASC_SCSIQ_B_TARGET_IX ) ) ;
       q_cntl = AscReadLramByte( iop_base,
                ( ushort )( halt_q_addr+( ushort )ASC_SCSIQ_B_CNTL ) ) ;
       tid_no = ASC_TIX_TO_TID( target_ix ) ;
       target_id = ( uchar )ASC_TID_TO_TARGET_ID( tid_no ) ;
       if( asc_dvc->pci_fix_asyn_xfer & target_id )
       {
/*
** PCI REV A/B BUG FIX, Let ASYN as SYN 5MB( speed index 4 ) and offset 1
*/
           asyn_sdtr = ASYN_SDTR_DATA_FIX_PCI_REV_AB ;
       }/* if */
       else
       {
           asyn_sdtr = 0 ;
       }/* else */
       if( int_halt_code == ASC_HALT_DISABLE_ASYN_USE_SYN_FIX )
       {
           if( asc_dvc->pci_fix_asyn_xfer & target_id )
           {
               AscSetChipSDTR( iop_base, 0, tid_no ) ;
           }
           AscWriteLramWord( iop_base, ASCV_HALTCODE_W, 0 ) ;
           return( 0 ) ;
       }
       else if( int_halt_code == ASC_HALT_ENABLE_ASYN_USE_SYN_FIX )
       {
           if( asc_dvc->pci_fix_asyn_xfer & target_id )
           {
               AscSetChipSDTR( iop_base, asyn_sdtr, tid_no ) ;
           }
           AscWriteLramWord( iop_base, ASCV_HALTCODE_W, 0 ) ;
           return( 0 ) ;
       }
       else if( int_halt_code == ASC_HALT_EXTMSG_IN )
       {
/* ------------------------------------------------------------ */
           /*
           ** Copy the message saved by the microcode at ASCV_MSGIN_BEG
           ** to the local variable ext_msg.
           */
           AscMemWordCopyFromLram( iop_base,
                                   ASCV_MSGIN_BEG,
                                   ( ushort dosfar *)&ext_msg,
                                   ( ushort )( sizeof( EXT_MSG ) >> 1 ) ) ;

           if (ext_msg.msg_type == MS_EXTEND &&
               ext_msg.msg_req == MS_SDTR_CODE &&
               ext_msg.msg_len == MS_SDTR_LEN) {
               sdtr_accept = TRUE ;
               if(
                   ( ext_msg.req_ack_offset > ASC_SYN_MAX_OFFSET )
                 )
               {
                   /*
                   **
                   ** we set the offset to less than 0x0F
                   ** and re do sdtr
                   **
                   ** if speed is faster than we can handle
                   ** we need to re do sdtr also
                   **
                   **
                   */
                   sdtr_accept = FALSE ;
                   ext_msg.req_ack_offset = ASC_SYN_MAX_OFFSET ;
               }/* if */
               if(
                   ( ext_msg.xfer_period < asc_dvc->sdtr_period_tbl[ asc_dvc->host_init_sdtr_index ] )
                   || ( ext_msg.xfer_period > asc_dvc->sdtr_period_tbl[ asc_dvc->max_sdtr_index ] )
                 )
               {
                   sdtr_accept = FALSE ;
                   ext_msg.xfer_period = asc_dvc->sdtr_period_tbl[ asc_dvc->host_init_sdtr_index ] ;
               }
               if( sdtr_accept )
               {
                   sdtr_data = AscCalSDTRData( asc_dvc, ext_msg.xfer_period,
                                               ext_msg.req_ack_offset ) ;
                   if( ( sdtr_data == 0xFF ) )
                   {
/*
** we should reject the SDTR, because our chip cannot support it
** the period value is out of our range
*/
                       q_cntl |= QC_MSG_OUT ;
                       asc_dvc->init_sdtr &= ~target_id ;
                       asc_dvc->sdtr_done &= ~target_id ;
                       AscSetChipSDTR( iop_base, asyn_sdtr, tid_no ) ;
                   }/* if */
               }
               if( ext_msg.req_ack_offset == 0 )
               {
                   /*
                   ** an offset zero is the same as async transfer
                   */
                   q_cntl &= ~QC_MSG_OUT ;
                   asc_dvc->init_sdtr &= ~target_id ;
                   asc_dvc->sdtr_done &= ~target_id ;
                   AscSetChipSDTR( iop_base, asyn_sdtr, tid_no ) ;
               }/* if */
               else
               {
                   if(
                       sdtr_accept
                       && ( q_cntl & QC_MSG_OUT )
                     )
                   {
/*
** we agreed and will not send message out again
**
**
** turn off ISAPNP( chip ver 0x21 ) fix if use sync xfer
*/
                       q_cntl &= ~QC_MSG_OUT ;
                       asc_dvc->sdtr_done |= target_id ;
                       asc_dvc->init_sdtr |= target_id ;
                       asc_dvc->pci_fix_asyn_xfer &= ~target_id ;
                       sdtr_data = AscCalSDTRData( asc_dvc, ext_msg.xfer_period,
                                                   ext_msg.req_ack_offset ) ;
                       AscSetChipSDTR( iop_base, sdtr_data, tid_no ) ;
                   }/* if */
                   else
                   {
/*
** DATE: 12/7/94
** if SDTR is target inited
** we must answer the target even if we agreed
** because according to SCSI specs.
** if we does not answer back right away
** the SDTR will take effect after bus free which is next command
** we want it take effect now
*/
                   /* ext_msg.req_ack_offset = ASC_SYN_MAX_OFFSET ; */
/*
** it is assumed that if target doesn't reject this message
** we will use the SDTR values we send
*/
              /*
              ** we assume drive will not send the message again
              ** so we set the chip's SDTR data here
              */
                       q_cntl |= QC_MSG_OUT ;
                       AscMsgOutSDTR( asc_dvc,
                                      ext_msg.xfer_period,
                                      ext_msg.req_ack_offset ) ;
                       asc_dvc->pci_fix_asyn_xfer &= ~target_id ;
                       sdtr_data = AscCalSDTRData( asc_dvc, ext_msg.xfer_period,
                                                   ext_msg.req_ack_offset ) ;
                       AscSetChipSDTR( iop_base, sdtr_data, tid_no ) ;
                       asc_dvc->sdtr_done |= target_id ;
                       asc_dvc->init_sdtr |= target_id ;
                   }/* else */
               }/* else */
               /*
               ** AscWriteLramByte( iop_base,
               **                   ASCV_SDTR_DONE_B,
               **                   asc_dvc->sdtr_done ) ;
               */
               AscWriteLramByte( iop_base,
                   ( ushort )( halt_q_addr+( ushort )ASC_SCSIQ_B_CNTL ),
                     q_cntl ) ;
               AscWriteLramWord( iop_base, ASCV_HALTCODE_W, 0 ) ;
               return( 0 ) ;
           } else if (ext_msg.msg_type == MS_EXTEND &&
                      ext_msg.msg_req == MS_WDTR_CODE &&
                      ext_msg.msg_len == MS_WDTR_LEN) {
               /*
               ** Respond to a WDTR message with a WDTR message that
               ** specifies narrow transfers.
               */
               ext_msg.wdtr_width = 0;
               AscMemWordCopyToLram(iop_base,
                                    ASCV_MSGOUT_BEG,
                                    ( ushort dosfar *)&ext_msg,
                                    ( ushort )( sizeof( EXT_MSG ) >> 1 )) ;
               q_cntl |= QC_MSG_OUT ;
               AscWriteLramByte( iop_base,
                   ( ushort )( halt_q_addr+( ushort )ASC_SCSIQ_B_CNTL ),
                     q_cntl ) ;
               AscWriteLramWord( iop_base, ASCV_HALTCODE_W, 0 ) ;
               return( 0 ) ;
           } else {
               /*
               ** Reject messages not handled.
               */
               ext_msg.msg_type = M1_MSG_REJECT;
               AscMemWordCopyToLram(iop_base,
                                    ASCV_MSGOUT_BEG,
                                    ( ushort dosfar *)&ext_msg,
                                    ( ushort )( sizeof( EXT_MSG ) >> 1 )) ;
               q_cntl |= QC_MSG_OUT ;
               AscWriteLramByte( iop_base,
                   ( ushort )( halt_q_addr+( ushort )ASC_SCSIQ_B_CNTL ),
                     q_cntl ) ;
               AscWriteLramWord( iop_base, ASCV_HALTCODE_W, 0 ) ;
               return( 0 ) ;
           }
       }/* if is extended message halt code */
       else if( int_halt_code == ASC_HALT_CHK_CONDITION )
       {

#if CC_CHK_COND_REDO_SDTR
           /*
            * XXX - should setting this flag really be within
            * CC_CHK_COND_REDO_SDTR?
            */
           q_cntl |= QC_REQ_SENSE ;

          /*
           * After a CHECK CONDITION if the 'init_stdr' bit is set,
           * redo SDTR. SDTR is redone regardless of 'sdtr_done'.
           */
           if ((asc_dvc->init_sdtr & target_id) != 0)
           {
              /*
               * get sync xfer data
               */
               asc_dvc->sdtr_done &= ~target_id ;
               sdtr_data = AscGetMCodeInitSDTRAtID( iop_base, tid_no ) ;
               q_cntl |= QC_MSG_OUT ;
               AscMsgOutSDTR( asc_dvc,
                              asc_dvc->sdtr_period_tbl[ ( sdtr_data >> 4 ) & ( uchar )(asc_dvc->max_sdtr_index-1) ],
                              ( uchar )( sdtr_data & ( uchar )ASC_SYN_MAX_OFFSET ) ) ;
           }/* if */
#endif /* CC_CHK_COND_REDO_SDTR */

           AscWriteLramByte( iop_base,
               ( ushort )( halt_q_addr+( ushort )ASC_SCSIQ_B_CNTL ),
                 q_cntl ) ;

/*
** clear bit 5
** DO NOT USE tagged queueing for request sense at all
** if there is no queued cmd in target
** Note: non-tagged queueing device this
**
*/
/*
**
** one HP fix disk apprantly get confused by same tag id again
** and return check cond when we send request sense again
** use the same queue ( and same tag id )
** it report a overlapped command error !
** although if we clear the tag_code field, the cmd
** will be sent using untagged method, but it's not allowed !
**
** we cannot mix a tagged and untagged cmd in a device !
**
*/
           tag_code = AscReadLramByte( iop_base,
               ( ushort )( halt_q_addr+( ushort )ASC_SCSIQ_B_TAG_CODE ) ) ;
           tag_code &= 0xDC ; /* clear bit 5 */
           if(
                ( asc_dvc->pci_fix_asyn_xfer & target_id )
                && !( asc_dvc->pci_fix_asyn_xfer_always & target_id )
             )
           {
/*
** disable use sync. offset one fix for auto request sense
**
*/
                tag_code |= ( ASC_TAG_FLAG_DISABLE_DISCONNECT
                            | ASC_TAG_FLAG_DISABLE_ASYN_USE_SYN_FIX );

           }
           AscWriteLramByte( iop_base,
                ( ushort )( halt_q_addr+( ushort )ASC_SCSIQ_B_TAG_CODE ),
                  tag_code ) ;
/*
**
** change queue status to QS_READY and QS_BUSY
** QS_BUSY will make sure the queue if busy again will link to head of queue in busy list
**
*/
           q_status = AscReadLramByte( iop_base,
                        ( ushort )( halt_q_addr+( ushort )ASC_SCSIQ_B_STATUS  ) ) ;
           q_status |= ( QS_READY | QS_BUSY ) ;
           AscWriteLramByte( iop_base,
                ( ushort )( halt_q_addr+( ushort )ASC_SCSIQ_B_STATUS  ),
                  q_status ) ;

           scsi_busy = AscReadLramByte( iop_base,
                                        ( ushort )ASCV_SCSIBUSY_B ) ;
           scsi_busy &= ~target_id ;
           AscWriteLramByte( iop_base, ( ushort )ASCV_SCSIBUSY_B, scsi_busy ) ;

           AscWriteLramWord( iop_base, ASCV_HALTCODE_W, 0 ) ;
           return( 0 ) ;
       }/* else if */
       else if( int_halt_code == ASC_HALT_SDTR_REJECTED )
       {
/* ------------------------------------------------------------ */
     /*
     ** first check what message it is rejecting
     **
     */
           AscMemWordCopyFromLram( iop_base,
                                   ASCV_MSGOUT_BEG,
                                   ( ushort dosfar *)&out_msg,
                                   ( ushort )( sizeof( EXT_MSG ) >> 1 ) ) ;

           if( ( out_msg.msg_type == MS_EXTEND ) &&
               ( out_msg.msg_len == MS_SDTR_LEN ) &&
               ( out_msg.msg_req == MS_SDTR_CODE ) )
           {
               /*
               ** we should handle target that rejects SDTR
               */
               asc_dvc->init_sdtr &= ~target_id ;
               asc_dvc->sdtr_done &= ~target_id ;
               AscSetChipSDTR( iop_base, asyn_sdtr, tid_no ) ;
               /*
               ** AscWriteLramByte( iop_base, ASCV_SDTR_DONE_B,
               **                   asc_dvc->sdtr_done ) ;
               */
           }/* if a SDTR rejected */
           else
           {
               /*
               ** probably following message rejected:
               ** 1. a bus device reset message
               **
               ** continue with the command
               */

           }/* else */

           q_cntl &= ~QC_MSG_OUT ;
           AscWriteLramByte( iop_base,
               ( ushort )( halt_q_addr+( ushort )ASC_SCSIQ_B_CNTL ),
                 q_cntl ) ;
           AscWriteLramWord( iop_base, ASCV_HALTCODE_W, 0 ) ;
           return( 0 ) ;
       }/* else if */
       else if( int_halt_code == ASC_HALT_SS_QUEUE_FULL )
       {
/* ------------------------------------------------------------ */
/*
** either a queue full ( 0x28 ) or status busy ( 0x08 )
**
*/
           scsi_status = AscReadLramByte( iop_base,
                  ( ushort )( ( ushort )halt_q_addr+( ushort )ASC_SCSIQ_SCSI_STATUS ) ) ;
           cur_dvc_qng = AscReadLramByte( iop_base,
                  ( ushort )( ( ushort )ASC_QADR_BEG+( ushort )target_ix ) ) ;
           if( ( cur_dvc_qng > 0 ) &&
               ( asc_dvc->cur_dvc_qng[ tid_no ] > 0 ) )
           {
/*
** cur_dvc_qng is already decremented, so is the correct number of cmds
** in the target
**
** only set busy of tagged queueing device
** a non-tagged queueing device should not send intterrupt
** also a non-tagged queueing device cannot have cur_dvc_qng > 0
*/
              scsi_busy = AscReadLramByte( iop_base,
                                           ( ushort )ASCV_SCSIBUSY_B ) ;
              scsi_busy |= target_id ;
              AscWriteLramByte( iop_base,
                      ( ushort )ASCV_SCSIBUSY_B, scsi_busy ) ;
              asc_dvc->queue_full_or_busy |= target_id ;

              if( scsi_status == SS_QUEUE_FULL ) {
                  if( cur_dvc_qng > ASC_MIN_TAGGED_CMD )
                  {
                      cur_dvc_qng -= 1 ;
                      asc_dvc->max_dvc_qng[ tid_no ] = cur_dvc_qng ;
       /*
       ** write it down for reference only
       */
                      AscWriteLramByte( iop_base,
                         ( ushort )( ( ushort )ASCV_MAX_DVC_QNG_BEG+( ushort )tid_no ),
                           cur_dvc_qng ) ;
                  }/* if */
              }/* if queue full */
           }/* if over */
           AscWriteLramWord( iop_base, ASCV_HALTCODE_W, 0 ) ;
           return( 0 ) ;
       }/* else if queue full */
/* ------------------------------------------------------------ */
  /*
  ** fatal error !
  ** chip halted
  **
  **     scsiq = ( ASC_QDONE_INFO )
  **     scsiq->d2.done_stat = QD_WITH_ERROR ;
  **     scsiq->d2.host_stat = QHSTA_MICRO_CODE_HALT ;
  */
       /* AscSetLibErrorCode( asc_dvc, ASCQ_ERR_MICRO_CODE_HALT ) ; */
       /* return( ERR ) ; */
       return( 0 ) ;
}

/* ---------------------------------------------------------------------
**
** ------------------------------------------------------------------ */
uchar  _AscCopyLramScsiDoneQ(
           PortAddr iop_base,
           ushort  q_addr,
           REG ASC_QDONE_INFO dosfar *scsiq,
           ulong max_dma_count
       )
{
       ushort  _val ;
       uchar   sg_queue_cnt ;

       DvcGetQinfo( iop_base,
            ( ushort )( q_addr+( ushort )ASC_SCSIQ_DONE_INFO_BEG ),
            ( ushort dosfar *)scsiq,
            ( ushort )( (sizeof(ASC_SCSIQ_2)+sizeof(ASC_SCSIQ_3))/2 )) ;

#if !CC_LITTLE_ENDIAN_HOST
       AscAdjEndianQDoneInfo( scsiq ) ;
#endif

       _val = AscReadLramWord( iop_base,
                    ( ushort )( q_addr+( ushort )ASC_SCSIQ_B_STATUS ) ) ;
       scsiq->q_status = ( uchar )_val ;
       scsiq->q_no = ( uchar )( _val >> 8 ) ;

       _val = AscReadLramWord( iop_base,
                     ( ushort )( q_addr+( ushort )ASC_SCSIQ_B_CNTL ) ) ;
       scsiq->cntl = ( uchar )_val ;
       sg_queue_cnt = ( uchar )( _val >> 8 ) ;

       _val = AscReadLramWord( iop_base,
                     ( ushort )( q_addr+( ushort )ASC_SCSIQ_B_SENSE_LEN ) ) ;
       scsiq->sense_len = ( uchar )_val ;
       scsiq->extra_bytes = ( uchar )( _val >> 8 ) ;

       /*
        * XXX - Read only the first word of 'remain_bytes' from the RISC
        * queue. With the ASC-3050 (Finch) with External LRAM, reading the
        * last word of the last queue before External LRAM (queue 0x13)
        * appears to cause the RISC to read a corrupted byte from status
        * field of the first queue in External LRAM (queue 0x14).
        */
#define FINCH_WORKAROUND 1
#if FINCH_WORKAROUND
       scsiq->remain_bytes = AscReadLramWord( iop_base,
           ( ushort )( q_addr+( ushort )ASC_SCSIQ_DW_REMAIN_XFER_CNT ) ) ;
#else /* FINCH_WORKAROUND */
       scsiq->remain_bytes = AscReadLramDWord( iop_base,
           ( ushort )( q_addr+( ushort )ASC_SCSIQ_DW_REMAIN_XFER_CNT ) ) ;
#endif /* FINCH_WORKAROUND */

       scsiq->remain_bytes &= max_dma_count ;

       return( sg_queue_cnt ) ;
}

/* ---------------------------------------------------------------------
** return number of Qs processed
**
** returns:
**
** Note: should call this routine repeatly until bit 0 is clear
**
** 0 - no queue processed
** 1 - one done queue process
** 0x11 - one aborted queue processed
** 0x80 - fatal error encountered
**
** ------------------------------------------------------------------ */
int    AscIsrQDone(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc
       )
{
       uchar   next_qp ;
       uchar   n_q_used ;
       uchar   sg_list_qp ;
       uchar   sg_queue_cnt ;
       uchar   q_cnt ;
       uchar   done_q_tail ;
       uchar   tid_no ;

#if CC_LINK_BUSY_Q
       uchar   exe_tid_no ;
#endif
       ASC_SCSI_BIT_ID_TYPE scsi_busy ;
       ASC_SCSI_BIT_ID_TYPE target_id ;
       PortAddr iop_base ;
       ushort  q_addr ;
       ushort  sg_q_addr ;
       uchar   cur_target_qng ;
       ASC_QDONE_INFO scsiq_buf ;
       REG ASC_QDONE_INFO dosfar *scsiq ;
       int     false_overrun ; /* for PCI fix */
       ASC_ISR_CALLBACK asc_isr_callback ;

#if CC_LINK_BUSY_Q
       ushort   n_busy_q_done ;
#endif /* CC_LINK_BUSY_Q */

/*
**
** function code begin
**
*/
       iop_base = asc_dvc->iop_base ;
       asc_isr_callback = ( ASC_ISR_CALLBACK )asc_dvc->isr_callback ;

       n_q_used = 1 ;
       scsiq = ( ASC_QDONE_INFO dosfar *)&scsiq_buf ;
       done_q_tail = ( uchar )AscGetVarDoneQTail( iop_base ) ;
       q_addr = ASC_QNO_TO_QADDR( done_q_tail ) ;
       next_qp = AscReadLramByte( iop_base,
                 ( ushort )( q_addr+( ushort )ASC_SCSIQ_B_FWD ) ) ;
       if( next_qp != ASC_QLINK_END )
       {
           /* _err_qp = next_qp ; */
           AscPutVarDoneQTail( iop_base, next_qp ) ;
           q_addr = ASC_QNO_TO_QADDR( next_qp ) ;
/*
** copy ASC_SCSIQ_2 and ASC_SCSIQ_3 to scsiq in word size
*/
           sg_queue_cnt = _AscCopyLramScsiDoneQ( iop_base, q_addr, scsiq, asc_dvc->max_dma_count ) ;

           AscWriteLramByte( iop_base,
                             ( ushort )( q_addr+( ushort )ASC_SCSIQ_B_STATUS ),
                             ( uchar )( scsiq->q_status & ( uchar )~( QS_READY | QS_ABORTED ) ) ) ;
           tid_no = ASC_TIX_TO_TID( scsiq->d2.target_ix ) ;
           target_id = ASC_TIX_TO_TARGET_ID( scsiq->d2.target_ix ) ;
           if( ( scsiq->cntl & QC_SG_HEAD ) != 0 )
           {
               sg_q_addr = q_addr ;
               sg_list_qp = next_qp ;
               for( q_cnt = 0 ; q_cnt < sg_queue_cnt ; q_cnt++ )
               {
                    sg_list_qp = AscReadLramByte( iop_base,
                         ( ushort )( sg_q_addr+( ushort )ASC_SCSIQ_B_FWD ) ) ;
                    sg_q_addr = ASC_QNO_TO_QADDR( sg_list_qp ) ;
                    if( sg_list_qp == ASC_QLINK_END )
                    {
                        AscSetLibErrorCode( asc_dvc, ASCQ_ERR_SG_Q_LINKS ) ;
                        scsiq->d3.done_stat = QD_WITH_ERROR ;
                        scsiq->d3.host_stat = QHSTA_D_QDONE_SG_LIST_CORRUPTED ;
                        goto FATAL_ERR_QDONE ;
                    }/* if */
                    AscWriteLramByte( iop_base,
                         ( ushort )( sg_q_addr+( ushort )ASC_SCSIQ_B_STATUS ),
                                   QS_FREE ) ;
               }/* for */
#if 0
/*
** calculate remaining bytes of sg list
*/
               sg_wk_qp = AscReadLramByte( iop_base,
                                           q_addr+ASC_SCSIQ_B_SG_WK_QP ) ;
               sg_wk_ix = AscReadLramByte( iop_base,
                                           q_addr+ASC_SCSIQ_B_SG_WK_IX ) ;
/*
** skip until you found the
**
*/
               if( sg_wk_qp != done_q_tail )
               {
                   while( TRUE ) {

                   }/* while */
               }/* if */
#endif
               n_q_used = sg_queue_cnt + 1 ;
               AscPutVarDoneQTail( iop_base, sg_list_qp ) ;
           }/* if */

           if( asc_dvc->queue_full_or_busy & target_id )
           {
/*
** clear tagged queue busy device
** when number of queue fall below maximum value
*/
               cur_target_qng = AscReadLramByte( iop_base,
                  ( ushort )( ( ushort )ASC_QADR_BEG+( ushort )scsiq->d2.target_ix ) ) ;
               if( cur_target_qng < asc_dvc->max_dvc_qng[ tid_no ] )
               {
                   scsi_busy = AscReadLramByte( iop_base,
                            ( ushort )ASCV_SCSIBUSY_B ) ;
                   scsi_busy &= ~target_id ;
                   AscWriteLramByte( iop_base,
                      ( ushort )ASCV_SCSIBUSY_B, scsi_busy ) ;
                   asc_dvc->queue_full_or_busy &= ~target_id ;
               }/* if */
           }/* if */

           if( asc_dvc->cur_total_qng >= n_q_used )
           {
               asc_dvc->cur_total_qng -= n_q_used ;
               if( asc_dvc->cur_dvc_qng[ tid_no ] != 0 )
               {
                   asc_dvc->cur_dvc_qng[ tid_no ]-- ;
               }/* if */
           }/* if */
           else
           {
               AscSetLibErrorCode( asc_dvc, ASCQ_ERR_CUR_QNG ) ;
               scsiq->d3.done_stat = QD_WITH_ERROR ;
               goto FATAL_ERR_QDONE ;
           }/* else */

           if( ( scsiq->d2.srb_ptr == 0UL ) ||
               ( ( scsiq->q_status & QS_ABORTED ) != 0 ) )
               {
/*
** do not write information to an aborted queue
** the caller probably has terminated !
*/
               /*
               ** _err_qp = scsiq->q_no ;
               ** _err_q_done_stat = scsiq->d3.done_stat ;
               ** _err_q_status = scsiq->q_status ;
               */
               return( 0x11 ) ;
           }/* else */
           else if( scsiq->q_status == QS_DONE )
           {
/*
** this will clear overrun/underrun error
** if QC_DATA_IN and QC_DATA_OUT is not set
**
*/
               false_overrun = FALSE ;

               if( scsiq->extra_bytes != 0 )
               {
                   scsiq->remain_bytes += ( ulong )scsiq->extra_bytes ;
               }/* if */

               if( scsiq->d3.done_stat == QD_WITH_ERROR )
               {
                   if( scsiq->d3.host_stat == QHSTA_M_DATA_OVER_RUN )
                   {
                       if( ( scsiq->cntl & ( QC_DATA_IN | QC_DATA_OUT ) ) == 0 )
                       {
                           scsiq->d3.done_stat = QD_NO_ERROR ;
                           scsiq->d3.host_stat = QHSTA_NO_ERROR ;
                       }/* if */
                       else if( false_overrun )
                       {
                           scsiq->d3.done_stat = QD_NO_ERROR ;
                           scsiq->d3.host_stat = QHSTA_NO_ERROR ;
                       }/* else */
                   }/* if */
                   else if( scsiq->d3.host_stat == QHSTA_M_HUNG_REQ_SCSI_BUS_RESET )
                   {
                       AscStopChip( iop_base ) ;
                       AscSetChipControl( iop_base, ( uchar )( CC_SCSI_RESET | CC_HALT ) ) ;
                       DvcDelayNanoSecond( asc_dvc, 60000 ) ; /* 60 uSec.  Fix  Panasonic problem */
                       AscSetChipControl( iop_base, CC_HALT ) ;
                       AscSetChipStatus( iop_base, CIW_CLR_SCSI_RESET_INT ) ;
                       AscSetChipStatus( iop_base, 0 ) ;
                       AscSetChipControl( iop_base, 0 ) ;
#if CC_SCAM
                       if( !( asc_dvc->dvc_cntl & ASC_CNTL_NO_SCAM ) )
                       {
                           asc_dvc->redo_scam = TRUE ;
                       }/* if */
#endif
                   }
               }/* if */
#if CC_CLEAR_LRAM_SRB_PTR
               AscWriteLramDWord( iop_base,
                           ( ushort )( q_addr+( ushort )ASC_SCSIQ_D_SRBPTR ),
                             asc_dvc->int_count ) ;
#endif /* #if CC_CLEAR_LRAM_SRB_PTR */
/*
** normal completion
*/
               if( ( scsiq->cntl & QC_NO_CALLBACK ) == 0 )
               {
                   ( *asc_isr_callback )( asc_dvc, scsiq ) ;
               }/* if */
               else
               {
                   if( ( AscReadLramByte( iop_base,
                       ( ushort )( q_addr+( ushort )ASC_SCSIQ_CDB_BEG ) ) ==
                       SCSICMD_StartStopUnit ) )
                   {
/*
** reset target as unit ready now
*/
                       asc_dvc->unit_not_ready &= ~target_id ;
                       if( scsiq->d3.done_stat != QD_NO_ERROR )
                       {
                           asc_dvc->start_motor &= ~target_id ;
                       }/* if */
                   }/* if */
               }/* else */

#if CC_LINK_BUSY_Q
               n_busy_q_done = AscIsrExeBusyQueue( asc_dvc, tid_no ) ;
               if( n_busy_q_done == 0 )
               {
/*
** no busy queue found on the device
**
** in order to be fair
** we do not search queue in a specific order
** search start from current scsi id plus one
*/
                   exe_tid_no = ( uint )tid_no + 1 ;
                   while( TRUE )
                   {
                        if( exe_tid_no > ASC_MAX_TID ) exe_tid_no = 0 ;
                        if( exe_tid_no == ( uint )tid_no ) break ;
                        n_busy_q_done = AscIsrExeBusyQueue( asc_dvc, exe_tid_no ) ;
                        if( n_busy_q_done != 0 ) break ;
                        exe_tid_no++ ;
                   }/* for */
               }/* if */
               if( n_busy_q_done == 0xFFFF ) return( 0x80 ) ;
#endif /* CC_LINK_BUSY_Q */

               return( 1 ) ;
           }/* if */
           else
           {
/*
** fatal error ! incorrect queue done status
**
**               _err_int_count = asc_dvc->int_count ;
**               _err_q_done_stat = scsiq->q_status ;
**               _err_qp = next_qp ;
*/
               AscSetLibErrorCode( asc_dvc, ASCQ_ERR_Q_STATUS ) ;

FATAL_ERR_QDONE:
               if( ( scsiq->cntl & QC_NO_CALLBACK ) == 0 )
               {
                   ( *asc_isr_callback )( asc_dvc, scsiq ) ;
               }/* if */
               return( 0x80 ) ;
           }/* else */
       }/* if */
       return( 0 ) ;
}

#if CC_LINK_BUSY_Q

/* ----------------------------------------------------------------------
** return 0 if RISC queue is still full
** return 0 if no busy queue found at tid_no list
** return 0xFFFF if fatal error occured
** return number of queue sent to RISC
** ------------------------------------------------------------------- */
ushort AscIsrExeBusyQueue(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          uchar tid_no
       )
{
       ASC_SCSI_Q dosfar *scsiq_busy ;
       int  n_q_done ;
       int  sta ;
       ASC_EXE_CALLBACK asc_exe_callback ;

       n_q_done = 0 ;
       scsiq_busy = asc_dvc->scsiq_busy_head[ tid_no ] ;
       while( scsiq_busy != ( ASC_SCSI_Q dosfar *)0UL )
       {
           if( AscGetNumOfFreeQueue( asc_dvc, scsiq_busy->q2.target_ix,
               scsiq_busy->ext.q_required ) >= scsiq_busy->ext.q_required )
           {
               if( ( sta = AscSendScsiQueue( asc_dvc, scsiq_busy,
                   scsiq_busy->ext.q_required ) ) != 1 )
               {
/*
** something is wrong !!!
*/
                   if( sta == 0 )
                   {
                       AscSetLibErrorCode( asc_dvc, ASCQ_ERR_GET_NUM_OF_FREE_Q ) ;
                       return( 0xFFFF ) ;
                   }/* if */
                   else
                   {
                       AscSetLibErrorCode( asc_dvc, ASCQ_ERR_SEND_SCSI_Q ) ;
                       return( 0xFFFF ) ;
                   }/* else */
               }/* if */
               n_q_done++ ;
               if( asc_dvc->exe_callback != 0 )
               {
                   asc_exe_callback = ( ASC_EXE_CALLBACK )asc_dvc->exe_callback ;
                   ( *asc_exe_callback )( asc_dvc, scsiq_busy ) ;
               }/* if */
           }/* if */
           else
           {
               if( n_q_done == 0 ) return( 0 ) ;
               break ;
           }/* else */
           scsiq_busy = scsiq_busy->ext.next ;
           asc_dvc->scsiq_busy_head[ tid_no ] = scsiq_busy ;
           if( scsiq_busy == ( ASC_SCSI_Q dosfar *)0UL )
           {
               asc_dvc->scsiq_busy_tail[ tid_no ] = ( ASC_SCSI_Q dosfar *)0UL ;
               break ;
           }/* if */

           break ; /* now we force it only do one queue */
       }/* while */
       return( n_q_done ) ;
}
#endif /* CC_LINK_BUSY_Q */

/* ----------------------------------------------------------------------
** return TRUE ( 1 )  if interrupt pending bit set
** return FALSE ( 0 ) if interrupt pendinf bit is not set
** return ERR if error occured
** ------------------------------------------------------------------- */
int    AscISR(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc
       )
{
       ASC_CS_TYPE chipstat ;
       PortAddr iop_base ;
       ushort   saved_ram_addr ;
       uchar    ctrl_reg ;
       uchar    saved_ctrl_reg ;
       int      int_pending ;
       int      status ;
       uchar    host_flag ;

/*
** BC compiler cannot take the address of buffer in stack
**
** static SCSI_Q  dosfar *scsiq ;
*/

       iop_base = asc_dvc->iop_base ;
       int_pending = FALSE ;

       /* asc_dvc->int_count++ ; */

       if( ( ( asc_dvc->init_state & ASC_INIT_STATE_END_LOAD_MC ) == 0 )
           || ( asc_dvc->isr_callback == 0 )
           )
       {
/*
**
** if pointer to asc_isr_call_back function is NULL,
** the init process is not completed yet !
** a spurious interrupt may have occured.
** this will be ignored but not treated as a fatal error.
** however, interrupt count is increased
** you may look at interrupt count to check spurious interrupt
**
*/
           return( ERR ) ;
       }/* if */
       if( asc_dvc->in_critical_cnt != 0 )
       {
           AscSetLibErrorCode( asc_dvc, ASCQ_ERR_ISR_ON_CRITICAL ) ;
           return( ERR ) ;
       }/* if */

       if( asc_dvc->is_in_int )
       {
           AscSetLibErrorCode( asc_dvc, ASCQ_ERR_ISR_RE_ENTRY ) ;
           return( ERR ) ;
       }/* if */
       asc_dvc->is_in_int = TRUE ;
       ctrl_reg = AscGetChipControl( iop_base ) ;

       saved_ctrl_reg = ctrl_reg & ( ~( CC_SCSI_RESET | CC_CHIP_RESET |
                        CC_SINGLE_STEP | CC_DIAG | CC_TEST ) ) ;
       chipstat = AscGetChipStatus( iop_base ) ;
       if( chipstat & CSW_SCSI_RESET_LATCH )
       {
           if(
               !( asc_dvc->bus_type & ( ASC_IS_VL | ASC_IS_EISA ) )
             )
           {
               int_pending = TRUE ;
               asc_dvc->sdtr_done = 0 ;
               saved_ctrl_reg &= ( uchar )( ~CC_HALT ) ;
               while( AscGetChipStatus( iop_base ) & CSW_SCSI_RESET_ACTIVE ) ;
    /*
    **
    **
    ** SCSI bus reset occured not by initiator
    ** 1. clear scsi reset interrupt, different from normal intrrupt
    ** 2. reset chip to clear CSW_SCSI_RESET_LATCH
    ** 3. redo all SDTR to every device, presume every device also receive scsi reset
    ** 4. let chip stay in halt( idle ) state, the code later will take care of everything
    **
    ** must clear chip reset state
    ** if chip is in reset state, local RAM cannot be accessed
    **
    */
               AscSetChipControl( iop_base, ( CC_CHIP_RESET | CC_HALT ) ) ;
               AscSetChipControl( iop_base, CC_HALT ) ;

               AscSetChipStatus( iop_base, CIW_CLR_SCSI_RESET_INT ) ;
               AscSetChipStatus( iop_base, 0 ) ;
               chipstat = AscGetChipStatus( iop_base ) ;
           }
       }/* if */
/*
** Save local RAM address register
** must be done before any local RAM access
*/
       saved_ram_addr = AscGetChipLramAddr( iop_base ) ; /* save local ram register */

       host_flag = AscReadLramByte( iop_base, ASCV_HOST_FLAG_B ) & ( uchar )( ~ASC_HOST_FLAG_IN_ISR ) ;
       AscWriteLramByte( iop_base, ASCV_HOST_FLAG_B,
                         ( uchar )( host_flag | ( uchar )ASC_HOST_FLAG_IN_ISR ) ) ;

/*       AscSetChipControl( iop_base, saved_ctrl_reg & (~CC_BANK_ONE) ) ; switch to bank 0 */

#if CC_ASCISR_CHECK_INT_PENDING
       if( ( chipstat & CSW_INT_PENDING )
           || ( int_pending )
         )
       {
            AscAckInterrupt( iop_base ) ;
#endif
            int_pending = TRUE ;

     /*
     ** do not access local RAM before saving saving its address
     **
     */
     /*
     **       chip_status = chipstat ;
     **
     ** this is to prevent more than one level depth interrupt
     ** but you should never call this function with interrupt enabled anyway
     **
     */
            if( ( chipstat & CSW_HALTED ) &&
                ( ctrl_reg & CC_SINGLE_STEP ) )
            {
                if( AscIsrChipHalted( asc_dvc ) == ERR )
                {
     /*
     ** the global error variable should be set in AscIsrChipHalted
     */
                    goto ISR_REPORT_QDONE_FATAL_ERROR ;

                }/* if */
                else
                {
                    saved_ctrl_reg &= ( uchar )(~CC_HALT) ;
                }/* else */
            }/* if */
            else
            {
ISR_REPORT_QDONE_FATAL_ERROR:

                if( ( asc_dvc->dvc_cntl & ASC_CNTL_INT_MULTI_Q ) != 0 )
                {
                    while( ( ( status = AscIsrQDone( asc_dvc ) ) & 0x01 ) != 0 )
                    {
                        /*  n_q_done++ ; */
                    }/* while */
                }/* if */
                else
                {
                    do
                    {
                       if( ( status = AscIsrQDone( asc_dvc ) ) == 1 )
                       {
                           /* n_q_done = 1 ; */
                           break ;
                       }/* if */
                    }while( status == 0x11 ) ;
                }/* else */
                if( ( status & 0x80 ) != 0 ) int_pending = ERR ;
          }/* else */

#if CC_ASCISR_CHECK_INT_PENDING

       }/* if interrupt pending */

#endif

       AscWriteLramByte( iop_base, ASCV_HOST_FLAG_B, host_flag ) ;
/*
** no more local RAM access from here
** address register restored
*/
       AscSetChipLramAddr( iop_base, saved_ram_addr ) ;

#if CC_CHECK_RESTORE_LRAM_ADDR
       if( AscGetChipLramAddr( iop_base ) != saved_ram_addr )
       {
           AscSetLibErrorCode( asc_dvc, ASCQ_ERR_SET_LRAM_ADDR ) ;
       }/* if */
#endif

       AscSetChipControl( iop_base, saved_ctrl_reg ) ;
       asc_dvc->is_in_int = FALSE ;
       return( int_pending ) ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
void   AscISR_AckInterrupt(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc
       )
{
       int      int_level ;
       ushort   saved_ram_addr ;
       PortAddr iop_base ;

       iop_base = asc_dvc->iop_base ;
       int_level = DvcEnterCritical( ) ;
       saved_ram_addr = AscGetChipLramAddr( iop_base ) ;
            /* save local ram register */
       AscAckInterrupt( iop_base ) ;
       AscSetChipLramAddr( iop_base, saved_ram_addr ) ;
       DvcLeaveCritical( int_level ) ;
       return ;
}


#if CC_USE_AscISR_CheckQDone

/* --------------------------------------------------------------------
** Description:
**   this function will take care of following thing
**    1. send start unit command if device is not ready
**
** Notes:
**
**  make calling AscISR_CheckQDone( ) the very first thing
**  inside DvcISRCallBack()
**
**  "sense_data" should be virtual address of physical address
**  "scsiq->q1.sense_addr" that pass to AscExeScsiQueue()
**
**  "scsiq->q1.sense_len" should be at least ASC_MIN_SENSE_LEN bytes
**  when AscExeScsiQueue() was called, otherwise the "sense_data"
**  will not have correct information
**
** ------------------------------------------------------------------ */
int    AscISR_CheckQDone(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          REG ASC_QDONE_INFO dosfar *scsiq,
          uchar dosfar *sense_data
       )
{
       ASC_REQ_SENSE  dosfar *sense ;
       ASC_SCSI_BIT_ID_TYPE target_id ;

       if( ( scsiq->d3.done_stat == QD_WITH_ERROR ) &&
           ( scsiq->d3.scsi_stat == SS_CHK_CONDITION ) )
       {
           sense = ( ASC_REQ_SENSE dosfar *)sense_data ;
           if( ( sense->err_code == 0x70 ) || ( sense->err_code == 0x71 ) )
           {
               if( sense->sense_key == SCSI_SENKEY_NOT_READY )
               {
                   target_id = ASC_TIX_TO_TARGET_ID( scsiq->d2.target_ix ) ;
                   if( ( asc_dvc->unit_not_ready & target_id ) == 0 )
                   {
                       if( ( asc_dvc->start_motor & target_id ) != 0 )
                       {
                           if( AscStartUnit( asc_dvc, scsiq->d2.target_ix ) != 1 )
                           {
                               asc_dvc->start_motor &= ~target_id ;
                               asc_dvc->unit_not_ready &= ~target_id ;
                               return( ERR ) ;
                           }/* if */
                       }/* if */
                   }/* if */
               }/* if */
           }/* if */
           return( 1 ) ;
       }/* if */
       return( 0 ) ;
}

#if CC_INIT_SCSI_TARGET
/* --------------------------------------------------------------------
** Description:
**   The function issue a start unit command to the specified device
**
** Parameter:
**   asc_dvc:    pointer to adapter struct ASC_DVC_VAR
**   taregt_ix : a combination of target id and lun
**               use ASC_TIDLUN_TO_IX( tid, lun ) to get target_ix value
**               that is:
**                  target_ix = ASC_TIDLUN_TO_IX( tid, lun ) ;
**
** Note:
**  asc_dvc->unit_not_ready will be cleared when the command completed
**
** return values are the same as AscExeScsiQueue()
** TRUE(1):  command issued without error
** FALSE(0): adapter busy
** ERR(-1):  command not issued, error cooured
**
** ------------------------------------------------------------------ */
int    AscStartUnit(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          ASC_SCSI_TIX_TYPE target_ix
       )
{
       ASC_SCSI_REQ_Q scsiq_buf ;
       ASC_SCSI_REQ_Q dosfar *scsiq ;
       uchar   target_id ;
       int     status = 0 ;

       target_id = ASC_TIX_TO_TARGET_ID( target_ix ) ;
       if( !( asc_dvc->unit_not_ready & target_id ) )
       {
           scsiq = ( ASC_SCSI_REQ_Q dosfar *)&scsiq_buf ;
           scsiq->r2.target_ix = target_ix ;
           scsiq->r1.target_id = target_id ;
           scsiq->r1.target_lun = ASC_TIX_TO_LUN( target_ix ) ;
           if( AscScsiSetupCmdQ( asc_dvc, scsiq, FNULLPTR,
               ( ulong )0L ) == ERR )
           {
               scsiq->r3.done_stat = QD_WITH_ERROR ;
               return( ERR ) ;
           }/* if */
           scsiq->r1.cntl = ( uchar )( ASC_SCSIDIR_NODATA | QC_URGENT |
                                       QC_NO_CALLBACK ) ;
           scsiq->cdb[ 0 ] = ( uchar )SCSICMD_StartStopUnit ;
           scsiq->cdb[ 1 ] = scsiq->r1.target_lun << 5 ;  /* LUN */
           scsiq->cdb[ 2 ] = 0 ;
           scsiq->cdb[ 3 ] = 0 ;
           scsiq->cdb[ 4 ] = 0x01 ; /* to start/stop unit set bit 0 */
                                 /* to eject/load unit set bit 1 */
           scsiq->cdb[ 5 ] = 0 ;
           scsiq->r2.cdb_len = 6 ;
           scsiq->r1.sense_len = 0 ;
           status = AscExeScsiQueue( asc_dvc, ( ASC_SCSI_Q dosfar *)scsiq ) ;
           asc_dvc->unit_not_ready |= target_id ;
       }
       return( status ) ;

}
#endif /* CC_INIT_SCSI_TARGET */

#endif /* CC_USE_AscISR_CheckQDone */

#if CC_INIT_SCSI_TARGET
#if CC_POWER_SAVER

/* --------------------------------------------------------------------
** Description:
**   The function issue a stop unit command to the specified device
**
** Parameter:
**   asc_dvc:    pointer to adapter struct ASC_DVC_VAR
**   taregt_ix : a combination of target id and lun
**               use ASC_TIDLUN_TO_IX( tid, lun ) to get target_ix value
**               that is:
**                  target_ix = ASC_TIDLUN_TO_IX( tid, lun ) ;
**
** Note:
**  asc_dvc->unit_not_ready will be cleared when the command completed
**
** return values are the same as AscExeScsiQueue()
** TRUE(1):  command issued without error
** FALSE(0): adapter busy
** ERR(-1):  command not issued, error cooured
**
** ------------------------------------------------------------------ */
int    AscStopUnit(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          ASC_SCSI_TIX_TYPE target_ix
       )
{
       ASC_SCSI_REQ_Q scsiq_buf ;
       ASC_SCSI_REQ_Q dosfar *scsiq ;
       uchar   target_id ;
       int     status = 0 ;

       target_id = ASC_TIX_TO_TARGET_ID( target_ix ) ;
       if( !( asc_dvc->unit_not_ready & target_ix ) )
       {
           scsiq = ( ASC_SCSI_REQ_Q dosfar *)&scsiq_buf ;
           scsiq->r2.target_ix = target_ix ;
           scsiq->r1.target_id = target_id ;
           scsiq->r1.target_lun = ASC_TIX_TO_LUN( target_ix ) ;
           if( AscScsiSetupCmdQ( asc_dvc, scsiq, FNULLPTR,
               ( ulong )0L ) == ERR )
           {
               scsiq->r3.done_stat = QD_WITH_ERROR ;
               return( ERR ) ;
           }/* if */
           scsiq->r1.cntl = ( uchar )( ASC_SCSIDIR_NODATA | QC_URGENT |
                                       QC_NO_CALLBACK ) ;
           scsiq->cdb[ 0 ] = ( uchar )SCSICMD_StartStopUnit ;
           scsiq->cdb[ 1 ] = ( scsiq->r1.target_lun << 5 ) | 0x01 ;  /* LUN */
           scsiq->cdb[ 2 ] = 0 ;
           scsiq->cdb[ 3 ] = 0 ;
           scsiq->cdb[ 4 ] = 0x00 ; /* to start/stop unit set bit 0 */
           scsiq->cdb[ 5 ] = 0 ;
           scsiq->r2.cdb_len = 6 ;
           scsiq->r1.sense_len = 0 ;
           status = AscExeScsiQueue( asc_dvc, ( ASC_SCSI_Q dosfar *)scsiq ) ;
           asc_dvc->unit_not_ready |= target_id ;
       }
       return( status ) ;
}

#endif /* CC_POWER_SAVER */

/* ------------------------------------------------------------------------
** ASPI command code 0x02
** SCSI Request Flag:
** bit 0: posting
** bit 1: linking
** bit 3 & 4:  direction bits
**             00: Direction determined by SCSI command, length not checked
**             01: Transfer from SCSI to host, length checked
**             10: Transfer from Host to SCSI, length checked
**             11: No data transfer.
** --------------------------------------------------------------------- */
int    AscScsiSetupCmdQ(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          REG ASC_SCSI_REQ_Q dosfar *scsiq,
          uchar dosfar *buf_addr,
          ulong buf_len
       )
{
       ulong  phy_addr ;

/*
**
** Note: clear entire scsiq wouldn't work
**
*/
       scsiq->r1.cntl = 0 ;
       scsiq->r1.sg_queue_cnt = 0 ;
       scsiq->r1.q_no = 0 ;
       scsiq->r1.extra_bytes = 0 ;
       scsiq->r3.scsi_stat = 0 ;
       scsiq->r3.scsi_msg = 0 ;
       scsiq->r3.host_stat = 0 ;
       scsiq->r3.done_stat = 0 ;
       scsiq->r2.vm_id = 0 ;
       scsiq->r1.data_cnt = buf_len ;
       scsiq->cdbptr = ( uchar dosfar *)scsiq->cdb ;
       scsiq->sense_ptr = ( uchar dosfar *)scsiq->sense ;
       scsiq->r1.sense_len = ASC_MIN_SENSE_LEN ;
/*
**
** will be set to use work space provided
**
*/
       scsiq->r2.tag_code = ( uchar )M2_QTAG_MSG_SIMPLE ;
       scsiq->r2.flag = ( uchar )ASC_FLAG_SCSIQ_REQ ;
       scsiq->r2.srb_ptr = ( ulong )scsiq ;
       scsiq->r1.status = ( uchar )QS_READY ;
       scsiq->r1.data_addr = 0L ;
       /* scsiq->sg_head = &sg_head ; */
       if( buf_len != 0L )
       {
           if( ( phy_addr = AscGetOnePhyAddr( asc_dvc,
               ( uchar dosfar *)buf_addr, scsiq->r1.data_cnt ) ) == 0L )
           {
               return( ERR ) ;
           }/* if */
           scsiq->r1.data_addr = phy_addr ;
       }/* if */
       if(
           ( phy_addr = AscGetOnePhyAddr( asc_dvc,
                       ( uchar dosfar *)scsiq->sense_ptr,
                       ( ulong )scsiq->r1.sense_len ) ) == 0L
         )
       {
           return( ERR ) ;
       }/* if */
       scsiq->r1.sense_addr = phy_addr ;
       return( 0 ) ;
}
#endif /* CC_INIT_SCSI_TARGET */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc\a_osdef.h ===
//
// a_osdef.h
//

//
// if your compiler does not support a command line constant definition
// you may put your platform definition here
//

#ifndef OS_WINNT
#define OS_WINNT
#endif  // OS_WINNT

//#define ASC_CHIP_VERSION 17

#ifndef __A_OSDEF_H_
#define __A_OSDEF_H_


#endif // __A_OSDEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc\a_osdep.h ===
/*
** Copyright (c) 1994-1997 Advanced System Products, Inc.
** All Rights Reserved.
**
** Filename: a_osdep.h
**
*/

#ifndef __A_OSDEP_H_
#define __A_OSDEP_H_

#include "a_winnt.h"
#include "miniport.h"
#include "scsi.h"

#endif /* #ifndef __A_OSDEP_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc\a_q.c ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** a_q.c
**
*/

#include "ascinc.h"

#define ASC_SYN_OFFSET_ONE_DISABLE_LIST  16

uchar   _syn_offset_one_disable_cmd[ ASC_SYN_OFFSET_ONE_DISABLE_LIST ] =
        {
           SCSICMD_Inquiry,
           SCSICMD_RequestSense,
           SCSICMD_ReadCapacity,
           SCSICMD_ReadTOC,
           SCSICMD_ModeSelect6,
           SCSICMD_ModeSense6,
           SCSICMD_ModeSelect10,
           SCSICMD_ModeSense10,
           0xFF,
           0xFF,
           0xFF,
           0xFF,
           0xFF,
           0xFF,
           0xFF,
           0xFF
        };

/* --------------------------------------------------------------------
** you should call the function with scsiq->q1.status set to QS_READY
**
** if this function return code is other than 0 or 1
** user must regard the request as error !
**
** if queue is copied to local RAM, scsiq->q1.status = QS_FREE
** if queue is link into busy list, scsiq->q1.status = QS_BUSY
** ----------------------------------------------------------------- */
int    AscExeScsiQueue(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          REG ASC_SCSI_Q dosfar *scsiq
       )
{
       PortAddr iop_base ;
       int    last_int_level ;
       int    sta ;
       int    n_q_required ;
       int    disable_syn_offset_one_fix ;
       int    i;
       ulong  addr ;
       ASC_EXE_CALLBACK  asc_exe_callback ;
       ushort sg_entry_cnt ;
       ushort sg_entry_cnt_minus_one ;
       uchar  target_ix ;
       uchar  tid_no ;
       uchar  sdtr_data ;
       uchar  extra_bytes ;
       uchar  scsi_cmd ;
       uchar  disable_cmd;
       ASC_SG_HEAD dosfar *sg_head ;
       ulong  data_cnt ;

#if CC_LINK_BUSY_Q
       ASC_SCSI_Q dosfar *scsiq_tail ;
       ASC_SCSI_Q dosfar *scsiq_next ;
       ASC_SCSI_Q dosfar *scsiq_prev ;
#endif /* CC_LINK_BUSY_Q */

       iop_base = asc_dvc->iop_base ;

#if CC_SCAM
       if( asc_dvc->redo_scam )
       {
           if( !( asc_dvc->dvc_cntl & ASC_CNTL_NO_SCAM ) )
           {
               AscSCAM( asc_dvc ) ;
           }/* if */
       }
#endif
       sg_head = scsiq->sg_head ;
       asc_exe_callback = ( ASC_EXE_CALLBACK )asc_dvc->exe_callback ;
       if( asc_dvc->err_code != 0 ) return( ERR ) ;
       if( scsiq == ( ASC_SCSI_Q dosfar *)0L )
       {
           AscSetLibErrorCode( asc_dvc, ASCQ_ERR_SCSIQ_NULL_PTR ) ;
           return( ERR ) ;
       }/* if */

       scsiq->q1.q_no = 0 ;
       if(
           ( scsiq->q2.tag_code & ASC_TAG_FLAG_EXTRA_BYTES ) == 0
         )
       {
           scsiq->q1.extra_bytes = 0 ;
       }
       sta = 0 ;
       target_ix = scsiq->q2.target_ix ;
       tid_no = ASC_TIX_TO_TID( target_ix ) ;

       n_q_required = 1 ; /* needed for CC_LINK_BUSY */

       if( scsiq->cdbptr[ 0 ] == SCSICMD_RequestSense )
       {
           /*
            * Always redo SDTR before issuing a Request Sense command.
            * SDTR is redone regardless of 'sdtr_done'.
            *
            * The request sense queue is always an urgent queue.
            */
           if ((asc_dvc->init_sdtr & scsiq->q1.target_id) != 0)
           {
               asc_dvc->sdtr_done &= ~scsiq->q1.target_id ;
               sdtr_data = AscGetMCodeInitSDTRAtID( iop_base, tid_no ) ;
               AscMsgOutSDTR( asc_dvc,
                              asc_dvc->sdtr_period_tbl[ ( sdtr_data >> 4 ) & ( uchar )(asc_dvc->max_sdtr_index-1) ],
                              ( uchar )( sdtr_data & ( uchar )ASC_SYN_MAX_OFFSET ) ) ;
               scsiq->q1.cntl |= ( QC_MSG_OUT | QC_URGENT ) ;
           }/* if */
       }/* if */
/*
** enter critical section
*/
       last_int_level = DvcEnterCritical( ) ;
       if( asc_dvc->in_critical_cnt != 0 )
       {
           DvcLeaveCritical( last_int_level ) ;
           AscSetLibErrorCode( asc_dvc, ASCQ_ERR_CRITICAL_RE_ENTRY ) ;
           return( ERR ) ;
       }/* if */

       asc_dvc->in_critical_cnt++ ;
       if( ( scsiq->q1.cntl & QC_SG_HEAD ) != 0 )
       {
/*
** SG_LIST QUEUE
*/
           if( ( sg_entry_cnt = sg_head->entry_cnt ) == 0 )
           {
               asc_dvc->in_critical_cnt-- ;
               DvcLeaveCritical( last_int_level ) ;
               return( ERR ) ;
           }/* if */
           if( sg_entry_cnt > ASC_MAX_SG_LIST )
           {
/*
** A too big SG list !
*/
               return( ERR ) ;
           }/* if */
           if( sg_entry_cnt == 1 )
           {
               scsiq->q1.data_addr = sg_head->sg_list[ 0 ].addr ;
               scsiq->q1.data_cnt = sg_head->sg_list[ 0 ].bytes ;
               scsiq->q1.cntl &= ~( QC_SG_HEAD | QC_SG_SWAP_QUEUE ) ;
           }/* if */
           else
           {
#if CC_CHK_AND_COALESCE_SG_LIST
               AscCoalesceSgList( scsiq );
               sg_entry_cnt = sg_head->entry_cnt ;
#endif
           }/* else */


           sg_entry_cnt_minus_one = sg_entry_cnt - 1 ;

#if CC_DEBUG_SG_LIST
           if( asc_dvc->bus_type & ( ASC_IS_ISA | ASC_IS_VL | ASC_IS_EISA ) )
           {
               for( i = 0 ; i < sg_entry_cnt_minus_one ; i++ )
               {
                    /* _asc_sg_entry = i ; */
                    /* _asc_xfer_addr = sg_head->sg_list[ i ].addr ; */
                    /* _asc_xfer_cnt = sg_head->sg_list[ i ].bytes ; */
                    addr = sg_head->sg_list[ i ].addr + sg_head->sg_list[ i ].bytes ;

                    if( ( ( ushort )addr & 0x0003 ) != 0 )
                    {
                        asc_dvc->in_critical_cnt-- ;
                        DvcLeaveCritical( last_int_level ) ;
                        AscSetLibErrorCode( asc_dvc, ASCQ_ERR_SG_LIST_ODD_ADDRESS ) ;
                        return( ERR ) ;
                    }/* if */
               }/* for */
           }/* if check SG list validity */
#endif /* #if CC_DEBUG_SG_LIST */
       }

       scsi_cmd = scsiq->cdbptr[ 0 ] ;
       disable_syn_offset_one_fix = FALSE ;
       if(
            ( asc_dvc->pci_fix_asyn_xfer & scsiq->q1.target_id )
            && !( asc_dvc->pci_fix_asyn_xfer_always & scsiq->q1.target_id )
         )
       {
/*
**
** calculate transfer data length
**
*/
           if( scsiq->q1.cntl & QC_SG_HEAD )
           {
               data_cnt = 0 ;
               for( i = 0 ; i < sg_entry_cnt ; i++ )
               {
                    data_cnt += sg_head->sg_list[i].bytes ;
               }
           }
           else
           {
               data_cnt = scsiq->q1.data_cnt ;
           }
           if( data_cnt != 0UL )
           {
               if( data_cnt < 512UL )
               {
                   disable_syn_offset_one_fix = TRUE;
               }
               else
               {
                   for( i = 0 ; i < ASC_SYN_OFFSET_ONE_DISABLE_LIST ; i++ )
                   {
                        disable_cmd = _syn_offset_one_disable_cmd[ i ] ;
                        if( disable_cmd == 0xFF )
                        {
                            break;
                        }
                        if( scsi_cmd == disable_cmd )
                        {
                            disable_syn_offset_one_fix = TRUE;
                            break;
                        }
                   }
               }/* else */
           }
       }

       if( disable_syn_offset_one_fix )
       {
           scsiq->q2.tag_code &= ~M2_QTAG_MSG_SIMPLE ;
           scsiq->q2.tag_code |= ( ASC_TAG_FLAG_DISABLE_ASYN_USE_SYN_FIX |
                                   ASC_TAG_FLAG_DISABLE_DISCONNECT ) ;
       }
       else
       {
           scsiq->q2.tag_code &= 0x23 ;
       }

       if( ( scsiq->q1.cntl & QC_SG_HEAD ) != 0 )
       {
           if( asc_dvc->bug_fix_cntl )
           {
               if( asc_dvc->bug_fix_cntl & ASC_BUG_FIX_IF_NOT_DWB )
               {
                   if(
                       ( scsi_cmd == SCSICMD_Read6 )
                       || ( scsi_cmd == SCSICMD_Read10 )
                     )
                   {
                        addr = sg_head->sg_list[ sg_entry_cnt_minus_one ].addr +
                               sg_head->sg_list[ sg_entry_cnt_minus_one ].bytes ;
                        extra_bytes = ( uchar )( ( ushort )addr & 0x0003 ) ;
                        if(
                            ( extra_bytes != 0 )
                            && ( ( scsiq->q2.tag_code & ASC_TAG_FLAG_EXTRA_BYTES ) == 0 )
                          )
                        {
                            scsiq->q2.tag_code |= ASC_TAG_FLAG_EXTRA_BYTES ;
                            scsiq->q1.extra_bytes = extra_bytes ;
                            sg_head->sg_list[ sg_entry_cnt_minus_one ].bytes -= ( ulong )extra_bytes ;
                        }/* if */
                   }/* if */
               }/* if */
           }/* if bug fix */


           sg_head->entry_to_copy = sg_head->entry_cnt ;
           n_q_required = AscSgListToQueue( sg_entry_cnt ) ;

#if CC_LINK_BUSY_Q
           scsiq_next = ( ASC_SCSI_Q dosfar *)asc_dvc->scsiq_busy_head[ tid_no ] ;
           if( scsiq_next != ( ASC_SCSI_Q dosfar *)0L )
           {
               goto link_scisq_to_busy_list ;
           }/* if */
#endif /* CC_LINK_BUSY_Q */

           if(
               ( AscGetNumOfFreeQueue( asc_dvc, target_ix, (uchar) n_q_required)
                 >= ( uint )n_q_required ) ||
               ( ( scsiq->q1.cntl & QC_URGENT ) != 0 )
             )
           {
               if( ( sta = AscSendScsiQueue( asc_dvc, scsiq,
                   (uchar) n_q_required ) ) == 1 )
               {
/*
** leave critical section
*/
                   asc_dvc->in_critical_cnt-- ;
                   if( asc_exe_callback != 0 )
                   {
                       ( *asc_exe_callback )( asc_dvc, scsiq ) ;
                   }/* if */
                   DvcLeaveCritical( last_int_level ) ;
                   return( sta ) ;
               }/* if */
           }/* if */
       }/* if */
       else
       {
/*
** NON SG_LIST QUEUE
*/
           if( asc_dvc->bug_fix_cntl )
           {
               if( asc_dvc->bug_fix_cntl & ASC_BUG_FIX_IF_NOT_DWB )
               {
               /*
               ** SG LIST
               ** fix PCI data in address not dword boundary
               **
               */
                  if(
                      ( scsi_cmd == SCSICMD_Read6 )
                      || ( scsi_cmd == SCSICMD_Read10 )
                    )
                  {
                       addr = scsiq->q1.data_addr + scsiq->q1.data_cnt ;
                       extra_bytes = ( uchar )( ( ushort )addr & 0x0003 ) ;
                       if(
                           ( extra_bytes != 0 )
                           && ( ( scsiq->q2.tag_code & ASC_TAG_FLAG_EXTRA_BYTES ) == 0 )
                         )
                       {
                           if( ( ( ushort )scsiq->q1.data_cnt & 0x01FF ) == 0 )
                           {
    /*
    ** if required addr fix
    ** we only add one byte when dma size is a multiple of 512 byte
    */
                               /*  scsiq->q1.data_cnt += ( 4 - ( addr & 0x0003 ) ) ; */
                               scsiq->q2.tag_code |= ASC_TAG_FLAG_EXTRA_BYTES ;
                               scsiq->q1.data_cnt -= ( ulong )extra_bytes ;
                               scsiq->q1.extra_bytes = extra_bytes ;
                           }/* if */
                       }/* if */
                  }/* if */
               }/* if */
           }/* if bug fix */

/*
**  A single queue allocation must satisfy (last_q_shortage+1)
**  to enabled a failed SG_LIST request
**
**  the last_q_shortage will be clear to zero when last
**  failed QG_LIST request finally go through
**
**  the initial value of last_q_shortage should be zero
*/
           n_q_required = 1 ;

#if CC_LINK_BUSY_Q
           scsiq_next = ( ASC_SCSI_Q dosfar *)asc_dvc->scsiq_busy_head[ tid_no ] ;
           if( scsiq_next != ( ASC_SCSI_Q dosfar *)0L )
           {
               goto link_scisq_to_busy_list ;
           }/* if */
#endif /* CC_LINK_BUSY_Q */
           if( ( AscGetNumOfFreeQueue( asc_dvc, target_ix, 1 ) >= 1 ) ||
               ( ( scsiq->q1.cntl & QC_URGENT ) != 0 ) )
           {
               if( ( sta = AscSendScsiQueue( asc_dvc, scsiq,
                   (uchar) n_q_required ) ) == 1 )
               {
/*
** sta returned, could be 1, -1, 0
*/
                   asc_dvc->in_critical_cnt-- ;
                   if( asc_exe_callback != 0 )
                   {
                       ( *asc_exe_callback )( asc_dvc, scsiq ) ;
                   }/* if */
                   DvcLeaveCritical( last_int_level ) ;
                   return( sta ) ;
               }/* if */
           }/* if */
       }/* else */

#if CC_LINK_BUSY_Q
       if( sta == 0 )
       {
/*
**  we must put queue into busy list
*/
link_scisq_to_busy_list:
           scsiq->ext.q_required = n_q_required ;
           if( scsiq_next == ( ASC_SCSI_Q dosfar *)0L )
           {
               asc_dvc->scsiq_busy_head[ tid_no ] = ( ASC_SCSI_Q dosfar *)scsiq ;
               asc_dvc->scsiq_busy_tail[ tid_no ] = ( ASC_SCSI_Q dosfar *)scsiq ;
               scsiq->ext.next = ( ASC_SCSI_Q dosfar *)0L ;
               scsiq->ext.join = ( ASC_SCSI_Q dosfar *)0L ;
               scsiq->q1.status = QS_BUSY ;
               sta = 1 ;
           }/* if */
           else
           {
               scsiq_tail = ( ASC_SCSI_Q dosfar *)asc_dvc->scsiq_busy_tail[ tid_no ] ;
               if( scsiq_tail->ext.next == ( ASC_SCSI_Q dosfar *)0L )
               {
                   if( ( scsiq->q1.cntl & QC_URGENT ) != 0 )
                   {
/*
** link urgent queue into head of queue
*/
                       asc_dvc->scsiq_busy_head[ tid_no ] = ( ASC_SCSI_Q dosfar *)scsiq ;
                       scsiq->ext.next = scsiq_next ;
                       scsiq->ext.join = ( ASC_SCSI_Q dosfar *)0L ;
                   }/* if */
                   else
                   {
                       if( scsiq->ext.cntl & QCX_SORT )
                       {
                           do
                           {
                               scsiq_prev = scsiq_next ;
                               scsiq_next = scsiq_next->ext.next ;
                               if( scsiq->ext.lba < scsiq_prev->ext.lba ) break ;
                           }while( scsiq_next != ( ASC_SCSI_Q dosfar *)0L ) ;
/*
** link queue between "scsiq_prev" and "scsiq_next"
**
*/
                           scsiq_prev->ext.next = scsiq ;
                           scsiq->ext.next = scsiq_next ;
                           if( scsiq_next == ( ASC_SCSI_Q dosfar *)0L )
                           {
                               asc_dvc->scsiq_busy_tail[ tid_no ] = ( ASC_SCSI_Q dosfar *)scsiq ;
                           }/* if */
                           scsiq->ext.join = ( ASC_SCSI_Q dosfar *)0L ;
                       }/* if */
                       else
                       {
/*
** link non-urgent queue into tail of queue
*/
                           scsiq_tail->ext.next = ( ASC_SCSI_Q dosfar *)scsiq ;
                           asc_dvc->scsiq_busy_tail[ tid_no ] = ( ASC_SCSI_Q dosfar *)scsiq ;
                           scsiq->ext.next = ( ASC_SCSI_Q dosfar *)0L ;
                           scsiq->ext.join = ( ASC_SCSI_Q dosfar *)0L ;
                       }/* else */
                   }/* else */
                   scsiq->q1.status = QS_BUSY ;
                   sta = 1 ;
               }/* if */
               else
               {
/*
** fatal error !
*/
                   AscSetLibErrorCode( asc_dvc, ASCQ_ERR_SCSIQ_BAD_NEXT_PTR ) ;
                   sta = ERR ;
               }/* else */
           }/* else */
       }/* if */
#endif /* CC_LINK_BUSY_Q */
       asc_dvc->in_critical_cnt-- ;
       DvcLeaveCritical( last_int_level ) ;
       return( sta ) ;
}

/* --------------------------------------------------------------------
** return 1 if command issued
** return 0 if command not issued
** ----------------------------------------------------------------- */
int    AscSendScsiQueue(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          REG ASC_SCSI_Q dosfar *scsiq,
          uchar n_q_required
       )
{
       PortAddr iop_base ;
       uchar  free_q_head ;
       uchar  next_qp ;
       uchar  tid_no ;
       uchar  target_ix ;
       int    sta ;

       iop_base = asc_dvc->iop_base ;
       target_ix = scsiq->q2.target_ix ;
       tid_no = ASC_TIX_TO_TID( target_ix ) ;
       sta = 0 ;
       free_q_head = ( uchar )AscGetVarFreeQHead( iop_base ) ;
       if( n_q_required > 1 )
       {
           if( ( next_qp = AscAllocMultipleFreeQueue( iop_base,
               free_q_head, ( uchar )( n_q_required ) ) )
               != ( uchar )ASC_QLINK_END )
           {
               asc_dvc->last_q_shortage = 0 ; /* clear the need to reserve queue for SG list */
               scsiq->sg_head->queue_cnt = n_q_required - 1 ;
               scsiq->q1.q_no = free_q_head ;

               if( ( sta = AscPutReadySgListQueue( asc_dvc, scsiq,
                   free_q_head ) ) == 1 )
               {
/*
** sta returned, could be 1, -1, 0
*/

#if CC_WRITE_IO_COUNT
                   asc_dvc->req_count++ ;
#endif /* CC_WRITE_IO_COUNT */

                   AscPutVarFreeQHead( iop_base, next_qp ) ;
                   asc_dvc->cur_total_qng += ( uchar )( n_q_required ) ;
                   asc_dvc->cur_dvc_qng[ tid_no ]++ ;
               }/* if */
               return( sta ) ;
           }/* if */
       }/* if */
       else if( n_q_required == 1 )
       {
/*
**
** DO NOT use "scsiq->sg_head", it may not have buffer at all
**
** set scsiq->sg_heah->queue_cnt = 0 ;
** is not necessary
**
*/
           if( ( next_qp = AscAllocFreeQueue( iop_base,
               free_q_head ) ) != ASC_QLINK_END )
           {
        /*
        ** leave critical section
        */
               scsiq->q1.q_no = free_q_head ;
               if( ( sta = AscPutReadyQueue( asc_dvc, scsiq,
                              free_q_head ) ) == 1 )
               {

#if CC_WRITE_IO_COUNT
                   asc_dvc->req_count++ ;
#endif /* CC_WRITE_IO_COUNT */

                   AscPutVarFreeQHead( iop_base, next_qp ) ;
                   asc_dvc->cur_total_qng++ ;
                   asc_dvc->cur_dvc_qng[ tid_no ]++ ;
               }/* if */
               return( sta ) ;
           }/* if */
       }/* else */
       return( sta ) ;
}

/* -----------------------------------------------------------
** sg_list: number of SG list entry
**
** return number of queue required from number of sg list
**
** -------------------------------------------------------- */
int    AscSgListToQueue(
          int sg_list
       )
{
       int  n_sg_list_qs ;

       n_sg_list_qs = ( ( sg_list - 1 ) / ASC_SG_LIST_PER_Q ) ;
       if( ( ( sg_list - 1 ) % ASC_SG_LIST_PER_Q ) != 0 ) n_sg_list_qs++ ;
       return( n_sg_list_qs + 1 ) ;
}

/* -----------------------------------------------------------
**
** n_queue: number of queue used
**
** return number of sg list available from number of queue(s)
** n_queue should equal 1 to n
**
** -------------------------------------------------------- */
int    AscQueueToSgList(
          int n_queue
       )
{
       if( n_queue == 1 ) return( 1 ) ;
       return( ( ASC_SG_LIST_PER_Q * ( n_queue - 1 ) ) + 1 ) ;
}

/* -----------------------------------------------------------
** Description:
** this routine will return number free queues that is available
** to next AscExeScsiQueue() command
**
**  parameters
**
**  asc_dvc: ASC_DVC_VAR struct
**  target_ix: a combination of target id and LUN
**  n_qs: number of queue required
**
** return number of queue available
** return 0 if no queue is available
** -------------------------------------------------------- */
uint   AscGetNumOfFreeQueue(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          uchar target_ix,
          uchar n_qs
       )
{
       uint  cur_used_qs ;
       uint  cur_free_qs ;
       ASC_SCSI_BIT_ID_TYPE target_id ;
       uchar tid_no ;

       target_id = ASC_TIX_TO_TARGET_ID( target_ix ) ;
       tid_no = ASC_TIX_TO_TID( target_ix ) ;
       if( ( asc_dvc->unit_not_ready & target_id ) ||
           ( asc_dvc->queue_full_or_busy & target_id ) )
       {
           return( 0 ) ;
       }/* if */
       if( n_qs == 1 )
       {
           cur_used_qs = ( uint )asc_dvc->cur_total_qng +
                          ( uint )asc_dvc->last_q_shortage +
                          ( uint )ASC_MIN_FREE_Q ;
       }/* if */
       else
       {
           cur_used_qs = ( uint )asc_dvc->cur_total_qng +
                         ( uint )ASC_MIN_FREE_Q ;
       }/* else */

       if( ( uint )( cur_used_qs + n_qs ) <= ( uint )asc_dvc->max_total_qng )
       {
           cur_free_qs = ( uint )asc_dvc->max_total_qng - cur_used_qs ;
           if( asc_dvc->cur_dvc_qng[ tid_no ] >=
               asc_dvc->max_dvc_qng[ tid_no ] )
           {
               return( 0 ) ;
           }/* if */
           return( cur_free_qs ) ;
       }/* if */
/*
**
** allocating queue failed
** we must not let single queue request from using up the resource
**
*/
       if( n_qs > 1 )
       {
          if(
              ( n_qs > asc_dvc->last_q_shortage )
              && ( n_qs <= ( asc_dvc->max_total_qng - ASC_MIN_FREE_Q ) )
/*
**
** 8/16/96
** Do not set last_q_shortage to more than maximum possible queues
**
*/
            )
          {
              asc_dvc->last_q_shortage = n_qs ;
          }/* if */
       }/* if */
       return( 0 ) ;
}

/* ---------------------------------------------------------------------
**
** Description: copy a queue into ASC-1000 ready queue list
**
** Parameters:
**
**   asc_dvc - the driver's global variable
**   scsiq   - the pointer to ASC-1000 queue
**
** Return values:
**   1 - successful
**   0 - busy
**   else - failed, possibly fatal error
**
** See Also:
**   AscAspiPutReadySgListQueue( )
**
** ------------------------------------------------------------------ */
int    AscPutReadyQueue(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          REG ASC_SCSI_Q dosfar *scsiq,
          uchar q_no
       )
{
       ushort  q_addr ;
       uchar   tid_no ;
       uchar   sdtr_data ;
       uchar   syn_period_ix ;
       uchar   syn_offset ;
       PortAddr  iop_base ;

       iop_base = asc_dvc->iop_base ;

       /*
        * If we need to send extended message and bus device reset
        * at the same time, the bus device reset message will be sent
        * first.
        *
        * This is the only case where 'sdtr_done' is used to prevent SDTR
        * from being redone. If the target's 'sdtr_done' bit is set here
        * SDTR is not done.
        */
       if( ( ( asc_dvc->init_sdtr & scsiq->q1.target_id ) != 0 ) &&
           ( ( asc_dvc->sdtr_done & scsiq->q1.target_id ) == 0 ) )
       {
/*
** If host adapter initiate syn data xfer request
*/
           tid_no = ASC_TIX_TO_TID( scsiq->q2.target_ix ) ;
/*
** Get sync xfer information
*/

           sdtr_data = AscGetMCodeInitSDTRAtID( iop_base, tid_no ) ;
           syn_period_ix = ( sdtr_data >> 4 ) & ( asc_dvc->max_sdtr_index - 1 ) ;
           syn_offset = sdtr_data & ASC_SYN_MAX_OFFSET ;
           AscMsgOutSDTR( asc_dvc,
                          asc_dvc->sdtr_period_tbl[ syn_period_ix ],
                          syn_offset ) ;
           scsiq->q1.cntl |= QC_MSG_OUT ;
           /*
           ** BUG, DATE: 3-11-94, if the device selection timeout
           ** we will have set the bit as done
           **
           ** asc_dvc->sdtr_done |= scsiq->q1.target_id ;
           */
       }/* if */

       q_addr = ASC_QNO_TO_QADDR( q_no ) ;
/*
** DATE: 12/21/94
** the new microcode depends entirely on tag_code bit 5 set
** to do tagged queuing or not.
**
** we must make sure that bit 5 is cleared for non-tagged queuing device !
*/
       if( ( scsiq->q1.target_id & asc_dvc->use_tagged_qng ) == 0 )
       {
           scsiq->q2.tag_code &= ~M2_QTAG_MSG_SIMPLE ;
       }/* if */
/*
** DATE: 12/19/94
** always set status as free, to indicate that queue is send to RISC
** also means the scsiq can be reused
*/
       scsiq->q1.status = QS_FREE ;

/*
** copy from PC to RISC local RAM
**
** copy queue to RISC local ram
*/
       AscMemWordCopyToLram( iop_base,
                           ( ushort )( q_addr+( ushort )ASC_SCSIQ_CDB_BEG ),
                           ( ushort dosfar *)scsiq->cdbptr,
                           ( ushort )( ( ushort )scsiq->q2.cdb_len >> 1 ) ) ;

#if !CC_LITTLE_ENDIAN_HOST
       AscAdjEndianScsiQ( scsiq ) ;
#endif

       DvcPutScsiQ( iop_base,
                  ( ushort )( q_addr+( ushort )ASC_SCSIQ_CPY_BEG ),
                  ( ushort dosfar *)&scsiq->q1.cntl,
          ( ushort )( ((( sizeof(ASC_SCSIQ_1)+sizeof(ASC_SCSIQ_2))/2)-1) ) ) ;
/*
**  write req_count number as reference
*/
#if CC_WRITE_IO_COUNT
       AscWriteLramWord( iop_base,
                         ( ushort )( q_addr+( ushort )ASC_SCSIQ_W_REQ_COUNT ),
                         ( ushort )asc_dvc->req_count ) ;

#endif /* CC_WRITE_IO_COUNT */

/*
** verify local ram copy if the bit is zero
*/
#if CC_VERIFY_LRAM_COPY
       if( ( asc_dvc->dvc_cntl & ASC_CNTL_NO_VERIFY_COPY ) == 0 )
       {
        /*
        ** verify SCSI CDB
        */
           if( AscMemWordCmpToLram( iop_base,
                            ( ushort )( q_addr+( ushort )ASC_SCSIQ_CDB_BEG ),
                            ( ushort dosfar *)scsiq->cdbptr,
                            ( ushort )( scsiq->q2.cdb_len >> 1 ) ) != 0 )
           {
               AscSetLibErrorCode( asc_dvc, ASCQ_ERR_LOCAL_MEM ) ;
               return( ERR ) ;
           }/* if */
/*
** verify queue data
*/
           if( AscMemWordCmpToLram( iop_base,
                           ( ushort )( q_addr+( ushort )ASC_SCSIQ_CPY_BEG ),
                           ( ushort dosfar *)&scsiq->q1.cntl,
               ( ushort )((( sizeof(ASC_SCSIQ_1)+sizeof(ASC_SCSIQ_2) )/2)-1) )
                                   != 0 )
           {
               AscSetLibErrorCode( asc_dvc, ASCQ_ERR_LOCAL_MEM ) ;
               return( ERR ) ;
           }/* if */
       }/* if */
#endif /* #if CC_VERIFY_LRAM_COPY */

#if CC_CLEAR_DMA_REMAIN

       AscWriteLramDWord( iop_base,
           ( ushort )( q_addr+( ushort )ASC_SCSIQ_DW_REMAIN_XFER_ADDR ), 0UL ) ;
       AscWriteLramDWord( iop_base,
           ( ushort )( q_addr+( ushort )ASC_SCSIQ_DW_REMAIN_XFER_CNT ), 0UL ) ;

#endif /* CC_CLEAR_DMA_REMAIN */

    /*
    ** write queue status as ready
    */
       AscWriteLramWord( iop_base,
                 ( ushort )( q_addr+( ushort )ASC_SCSIQ_B_STATUS ),
       ( ushort )( ( ( ushort )scsiq->q1.q_no << 8 ) | ( ushort )QS_READY ) ) ;
       return( 1 ) ;
}

/* ---------------------------------------------------------------------
** Description: copy a queue into ASC-1000 ready queue list
**
** Parameters:
**
**   asc_dvc - the driver's global variable
**   scsiq   - the pointer to ASC-1000 queue
**   cdb_blk - the pointer to SCSI CDB
**
**   note: the scsiq->cdb field is not used in the function call
**
** Return values:
**   1 - successful
**   0 - failed
**
** See Also:
**   AscPutReadyQueue( )
**
** ------------------------------------------------------------------ */
int    AscPutReadySgListQueue(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          REG ASC_SCSI_Q dosfar *scsiq,
          uchar q_no
       )
{
       int     sta ;
       int     i ;
       ASC_SG_HEAD dosfar *sg_head ;
       ASC_SG_LIST_Q scsi_sg_q ;
       ulong  saved_data_addr ;
       ulong  saved_data_cnt ;
       PortAddr  iop_base ;
       ushort  sg_list_dwords ;
       ushort  sg_index ;
       ushort  sg_entry_cnt ;
       ushort  q_addr ;
       uchar   next_qp ;

       iop_base = asc_dvc->iop_base ;
/*
** we put the first SG_LIST in sg head !
*/
       sg_head = scsiq->sg_head ;
/*
**  we will destroy: scsiq->q1.data_addr
**                   scsiq->q1.data_cnt in putting SG list
**
**  we should restore them
*/
       saved_data_addr = scsiq->q1.data_addr ;
       saved_data_cnt = scsiq->q1.data_cnt ;
       scsiq->q1.data_addr = sg_head->sg_list[ 0 ].addr ;
       scsiq->q1.data_cnt = sg_head->sg_list[ 0 ].bytes ;
       sg_entry_cnt = sg_head->entry_cnt - 1 ;
       if( sg_entry_cnt != 0 )
       {
           scsiq->q1.cntl |= QC_SG_HEAD ;
           q_addr = ASC_QNO_TO_QADDR( q_no ) ;
           sg_index = 1 ;
           scsiq->q1.sg_queue_cnt = (uchar) sg_head->queue_cnt ;
           scsi_sg_q.sg_head_qp = q_no ;
           scsi_sg_q.cntl = QCSG_SG_XFER_LIST ;
           for( i = 0 ; i < sg_head->queue_cnt ; i++ )
           {
                scsi_sg_q.seq_no = i + 1 ;
                if( sg_entry_cnt > ASC_SG_LIST_PER_Q )
                {
                    sg_list_dwords = ( uchar )( ASC_SG_LIST_PER_Q * 2 ) ;
                    sg_entry_cnt -= ASC_SG_LIST_PER_Q ;
                    if( i == 0 )
                    {
                        scsi_sg_q.sg_list_cnt = ASC_SG_LIST_PER_Q ;
                        scsi_sg_q.sg_cur_list_cnt = ASC_SG_LIST_PER_Q ;
                    }/* if */
                    else
                    {
                        scsi_sg_q.sg_list_cnt = ASC_SG_LIST_PER_Q - 1 ;
                        scsi_sg_q.sg_cur_list_cnt = ASC_SG_LIST_PER_Q - 1 ;
                    }/* else */
                }/* if */
                else
                {
/*
** is last of SG LIST queue
** we no longer rely on
*/
                    scsi_sg_q.cntl |= QCSG_SG_XFER_END ;
                    sg_list_dwords = sg_entry_cnt << 1 ; /* equals sg_entry_cnt * 2 */
                    if( i == 0 )
                    {
                        scsi_sg_q.sg_list_cnt = (uchar) sg_entry_cnt ;
                        scsi_sg_q.sg_cur_list_cnt = (uchar) sg_entry_cnt ;
                    }/* if */
                    else
                    {
                        scsi_sg_q.sg_list_cnt = sg_entry_cnt - 1 ;
                        scsi_sg_q.sg_cur_list_cnt = sg_entry_cnt - 1 ;
                    }/* else */
                    sg_entry_cnt = 0 ;
                }/* else */
                next_qp = AscReadLramByte( iop_base,
                             ( ushort )( q_addr+ASC_SCSIQ_B_FWD ) ) ;
                scsi_sg_q.q_no = next_qp ;
                q_addr = ASC_QNO_TO_QADDR( next_qp ) ;

                AscMemWordCopyToLram( iop_base,
                             ( ushort )( q_addr+ASC_SCSIQ_SGHD_CPY_BEG ),
                             ( ushort dosfar *)&scsi_sg_q,
                             ( ushort )( sizeof( ASC_SG_LIST_Q ) >> 1 ) ) ;

                AscMemDWordCopyToLram( iop_base,
                             ( ushort )( q_addr+ASC_SGQ_LIST_BEG ),
                             ( ulong dosfar *)&sg_head->sg_list[ sg_index ],
                             ( ushort )sg_list_dwords ) ;

                sg_index += ASC_SG_LIST_PER_Q ;
           }/* for */
       }/* if */
       else
       {
/*
** this should be a fatal error !
*/
           scsiq->q1.cntl &= ~QC_SG_HEAD ;
       }/* else */
       sta = AscPutReadyQueue( asc_dvc, scsiq, q_no ) ;
/*
** restore the modified field that used as first sg list
**
** we restore them just in case these fields are used for other purposes
**
*/
       scsiq->q1.data_addr = saved_data_addr ;
       scsiq->q1.data_cnt = saved_data_cnt ;
       return( sta ) ;
}

#if CC_USE_AscAbortSRB

/* -----------------------------------------------------------
** Description: abort a SRB in ready ( active ) queue list
**
**              the srb_ptr should hold scsiq->q2.srb_ptr that
**              is past to AscExeScsiQueue()
**
** return value:
** TRUE(1): the queue is successfully aborted
**          you should receive a callback later
**
** FALSE(0): the srb_ptr cannot be found in active queue list
**           most likely the queue is done
**
** ERR(-1): the RISC has encountered a fatal error
**          RISC does not response to halt command from host
**
** -------------------------------------------------------- */
int    AscAbortSRB(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          ulong srb_ptr
       )
{
       int  sta ;
       ASC_SCSI_BIT_ID_TYPE saved_unit_not_ready ;
       PortAddr iop_base ;

       iop_base = asc_dvc->iop_base ;
       sta = ERR ;
       saved_unit_not_ready = asc_dvc->unit_not_ready ;
       asc_dvc->unit_not_ready = 0xFF ;
       AscWaitISRDone( asc_dvc ) ;
       if( AscStopQueueExe( iop_base ) == 1 )
       {
           if( AscRiscHaltedAbortSRB( asc_dvc, srb_ptr ) == 1 )
           {
               sta = 1 ;
               AscCleanUpBusyQueue( iop_base ) ;
               AscStartQueueExe( iop_base ) ;
/*
** wait until ISR all come back
*/
#if 0
               if( AscWaitQTailSync( iop_base ) != 1 )
               {
                   if( AscStopQueueExe( iop_base ) == 1 )
                   {
                       AscCleanUpDiscQueue( iop_base ) ;
                       AscStartQueueExe( iop_base ) ;
                   }/* if */
               }/* if */
#endif
           }/* if */
           else
           {
               sta = 0 ;
               AscStartQueueExe( iop_base ) ;
           }/* else */
       }/* if */
       asc_dvc->unit_not_ready = saved_unit_not_ready ;
       return( sta ) ;
}
#endif /* CC_USE_AscAbortSRB */

#if CC_USE_AscResetDevice

/* -----------------------------------------------------------
** Description: abort all ready ( active ) queue list
**              of a specific target_ix ( id and lun )
**
**              after abort completed
**              send a bus device reset message to device.
**              this will result to a selection timeout if
**              device power is turn off
**
** Note:
**    h/w interrupt should be enabled when calling the function
**
** return values:
** ERR (-1): a fatal error occured
** TRUE: abort and reset device successfully
** FALSE: reset device failed
** -------------------------------------------------------- */
int    AscResetDevice(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          uchar target_ix
       )
{
       PortAddr iop_base ;
       int    sta ;
       uchar  tid_no ;
       ASC_SCSI_BIT_ID_TYPE target_id ;
       int    i ;
       ASC_SCSI_REQ_Q scsiq_buf ;
       ASC_SCSI_REQ_Q dosfar *scsiq ;
       uchar dosfar *buf ;
       ASC_SCSI_BIT_ID_TYPE  saved_unit_not_ready ;
/*
**
*/
       iop_base = asc_dvc->iop_base ;
       tid_no = ASC_TIX_TO_TID( target_ix ) ;
       target_id = ASC_TID_TO_TARGET_ID( tid_no ) ;
       saved_unit_not_ready = asc_dvc->unit_not_ready ;
       asc_dvc->unit_not_ready = target_id ;
       sta = ERR ;
       AscWaitTixISRDone( asc_dvc, target_ix ) ;
       if( AscStopQueueExe( iop_base ) == 1 )
       {
           if( AscRiscHaltedAbortTIX( asc_dvc, target_ix ) == 1 )
           {

               AscCleanUpBusyQueue( iop_base ) ;
               AscStartQueueExe( iop_base ) ;
/*
** wait cow come home
** it's OK if they don't, we can..., you know.
*/
               AscWaitTixISRDone( asc_dvc, target_ix ) ;
/*
** build a command to send bus device reset message to the target
*/
               sta = TRUE ;
               scsiq = ( ASC_SCSI_REQ_Q dosfar *)&scsiq_buf ;
               buf = ( uchar dosfar *)&scsiq_buf ;
               for( i = 0 ; i < sizeof( ASC_SCSI_REQ_Q ) ; i++ )
               {
                    *buf++ = 0x00 ;
               }/* for */
               /* scsiq->r2.flag = ( uchar )ASC_FLAG_SCSIQ_REQ ;  */
               /* scsiq->r2.srb_ptr = ( ulong )scsiq ;  */
               scsiq->r1.status = ( uchar )QS_READY ;
               scsiq->r2.cdb_len = 6 ;
               scsiq->r2.tag_code = M2_QTAG_MSG_SIMPLE ;
               scsiq->r1.target_id = target_id ;
/*
** NOTE: we do not reset the lun device
*/
               scsiq->r2.target_ix = ASC_TIDLUN_TO_IX( tid_no, 0 ) ;
               scsiq->cdbptr = ( uchar dosfar *)scsiq->cdb ;
/*
** we send a scsi q which will send a bus device reset message
** to device, and return,
** SCSI command in cdb will not be executed
**
** in case we are reset an active device, the queue has to be QC_URGENT
** in order to go thru
**
*/
               scsiq->r1.cntl = QC_NO_CALLBACK | QC_MSG_OUT | QC_URGENT ;
               AscWriteLramByte( asc_dvc->iop_base, ASCV_MSGOUT_BEG,
                                 M1_BUS_DVC_RESET ) ;
/*
** let next device reset go thru, clear not ready bit of the target
*/
               asc_dvc->unit_not_ready &= ~target_id ;
/*
** if sdtr_done is cleared, the reset device message cannot go through
*/
               asc_dvc->sdtr_done |= target_id ;
/*
** make this target ready, so we may send the command
*/
               if( AscExeScsiQueue( asc_dvc, ( ASC_SCSI_Q dosfar *)scsiq )
                   == 1 )
               {
                   asc_dvc->unit_not_ready = target_id ;
                   DvcSleepMilliSecond( 1000 ) ;
                   _AscWaitQDone( iop_base, ( ASC_SCSI_Q dosfar *)scsiq ) ;
                   if( AscStopQueueExe( iop_base ) == 1 )
                   {
/*
** since we send a reset message, every queue inside the drive
** will not coming back, we must clean up all disc queues
*/
                       AscCleanUpDiscQueue( iop_base ) ;
                       AscStartQueueExe( iop_base ) ;
                       if( asc_dvc->pci_fix_asyn_xfer & target_id )
                       {
/*
**
** PCI BUG FIX, Let ASYN as SYN 5MB( speed index 4 ) and offset 1
**
*/
                           AscSetRunChipSynRegAtID( iop_base, tid_no,
                                                    ASYN_SDTR_DATA_FIX_PCI_REV_AB ) ;
                       }/* if */

                       AscWaitTixISRDone( asc_dvc, target_ix ) ;
                   }/* if */
               }/* if */
               else
               {
/*
** command cannot go through !
*/

                   sta = 0 ;
               }/* else */
/*
** redo SDTR
*/
               asc_dvc->sdtr_done &= ~target_id ;
           }/* if */
           else
           {
               sta = ERR ;
               AscStartQueueExe( iop_base ) ;
           }/* else */
       }/* if */
       asc_dvc->unit_not_ready = saved_unit_not_ready ;
       return( sta ) ;
}

#endif /* CC_USE_AscResetDevice */

#if CC_USE_AscResetSB

/* -----------------------------------------------------------
** Descriptoion:
**   reset scsi bus and restart
**   this is a fatal error recovery function
**
** Function:
** 1. reset scsi bus and chip
**    - chip syn registers automatically cleared ( asyn xfer )
**    - the scsi device also reset to asyn xfer ( because of scsi bus reset )
** 2. reinit all variables, clear all error codes
** 3. reinit chip register(s)
**    - set syn register with pci_fix_asyn_xfer
** 4. restart chip
**
** Return Value:
** return TRUE(1) if successful
** return ERR if error occured
** -------------------------------------------------------- */
int    AscResetSB(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc
       )
{
       int  sta ;
       int  i ;
       PortAddr iop_base ;

       iop_base = asc_dvc->iop_base ;
       asc_dvc->unit_not_ready = 0xFF ;
       sta = TRUE ;
       AscWaitISRDone( asc_dvc ) ;
       AscStopQueueExe( iop_base ) ;
/*
** always redo SDTN
*/
       asc_dvc->sdtr_done = 0 ;
       AscResetChipAndScsiBus( asc_dvc);
/*
** wait xx seconds after reset SCSI BUS
*/
       DvcSleepMilliSecond( ( ulong )( ( ushort )asc_dvc->scsi_reset_wait*1000 ) ) ;

#if CC_SCAM
       if( !( asc_dvc->dvc_cntl & ASC_CNTL_NO_SCAM ) )
       {
           AscSCAM( asc_dvc ) ;
       }/* if */
#endif
       AscReInitLram( asc_dvc ) ;

       for( i = 0 ; i <= ASC_MAX_TID ; i++ )
       {
            asc_dvc->cur_dvc_qng[ i ] = 0 ;
            if( asc_dvc->pci_fix_asyn_xfer & ( ASC_SCSI_BIT_ID_TYPE )( 0x01 << i ) )
            {
/*
** CHIP MUST be halted to set syn register
*/
                AscSetChipSynRegAtID( iop_base, (uchar) i,
                    ASYN_SDTR_DATA_FIX_PCI_REV_AB ) ;
            }/* if */
       }/* for */

       asc_dvc->err_code = 0 ;

       AscSetPCAddr( iop_base, ASC_MCODE_START_ADDR ) ;
       if( AscGetPCAddr( iop_base ) != ASC_MCODE_START_ADDR )
       {
           sta = ERR ;
       }/* if */
       if( AscStartChip( iop_base ) == 0 )
       {
           sta = ERR ;
       }/* if */
       AscStartQueueExe( iop_base ) ;
       asc_dvc->unit_not_ready = 0 ;
       asc_dvc->queue_full_or_busy = 0 ;
       return( sta ) ;
}

#endif /* CC_USE_AscResetSB */

/* -----------------------------------------------------------
** write running chip syn register
** we must stop chip to perform the operation
**
** return TRUE  if successful
** return FALSE if error occured
** -------------------------------------------------------- */
int    AscSetRunChipSynRegAtID(
          PortAddr iop_base,
          uchar tid_no,
          uchar sdtr_data
       )
{
       int sta = FALSE ;

       if( AscHostReqRiscHalt( iop_base ) )
       {
           sta = AscSetChipSynRegAtID( iop_base, tid_no, sdtr_data ) ;
/*
** ucode var "stop_code" should be zero
** all we need is restart the chip
*/
           AscStartChip( iop_base ) ;
           return( sta ) ;
       }/* if */
       return( sta ) ;
}

/* --------------------------------------------------------------------
** valid ID is 0 - 7
** chip must in idle state
**
** but when read back ID
**  0 become 0x01
**  1 become 0x02
**  2 become 0x04, etc...
** ----------------------------------------------------------------- */
int    AscSetChipSynRegAtID(
          PortAddr iop_base,
          uchar    id,
          uchar    sdtr_data
       )
{

       ASC_SCSI_BIT_ID_TYPE  org_id ;
       int  i ;
       int  sta ;

       sta = TRUE ;
       AscSetBank( iop_base, 1 ) ;
       org_id = AscReadChipDvcID( iop_base ) ;
       for( i = 0 ; i <= ASC_MAX_TID ; i++ )
       {
            if( org_id == ( 0x01 << i ) ) break ;
       }
       org_id = (ASC_SCSI_BIT_ID_TYPE)i ;
       AscWriteChipDvcID( iop_base, id ) ;
       if( AscReadChipDvcID( iop_base ) == ( 0x01 << id ) )
       {
          AscSetBank( iop_base, 0 ) ;
          AscSetChipSyn( iop_base, sdtr_data ) ;
          if( AscGetChipSyn( iop_base ) != sdtr_data )
          {
              sta = FALSE ;
          }/* if */
       }/* if */
       else
       {
          sta = FALSE ;
       }
/*
** now restore the original id
*/
       AscSetBank( iop_base, 1 ) ;
       AscWriteChipDvcID( iop_base, org_id ) ;
       AscSetBank( iop_base, 0 ) ;
       return( sta ) ;
}

/* -----------------------------------------------------------
**
** -------------------------------------------------------- */
int    AscReInitLram(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc
       )
{
       AscInitLram( asc_dvc ) ;
       AscInitQLinkVar( asc_dvc ) ;
       return( 0 ) ;
}

/* -----------------------------------------------------------------------
**
** return warning code
** -------------------------------------------------------------------- */
ushort AscInitLram(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc
       )
{
       uchar    i ;
       ushort   s_addr ;
       PortAddr iop_base ;
       ushort   warn_code ;

       iop_base = asc_dvc->iop_base ;
       warn_code = 0 ;
/*
**
** do not clear BIOS data area which is last queue
** we clear two more queues ( busy and disc queue head
**
*/
       AscMemWordSetLram( iop_base, ASC_QADR_BEG, 0,
           ( ushort )( ( ( int )( asc_dvc->max_total_qng+2+1 ) * 64 ) >> 1 )
           ) ;
/*
** init queue buffer
*/

/*
** queue number zero is reserved
*/
       i = ASC_MIN_ACTIVE_QNO ;
       s_addr = ASC_QADR_BEG + ASC_QBLK_SIZE ;
/*
** init first queue link
*/
       AscWriteLramByte( iop_base, ( ushort )( s_addr+ASC_SCSIQ_B_FWD ),
                        ( uchar )( i+1 ) ) ;
       AscWriteLramByte( iop_base, ( ushort )( s_addr+ASC_SCSIQ_B_BWD ),
                         ( uchar )( asc_dvc->max_total_qng ) ) ;
       AscWriteLramByte( iop_base, ( ushort )( s_addr+ASC_SCSIQ_B_QNO ),
                         ( uchar )i ) ;
       i++ ;
       s_addr += ASC_QBLK_SIZE ;
       for( ; i < asc_dvc->max_total_qng ; i++, s_addr += ASC_QBLK_SIZE )
       {
            AscWriteLramByte( iop_base, ( ushort )( s_addr+ASC_SCSIQ_B_FWD ),
                              ( uchar )( i+1 ) ) ;
            AscWriteLramByte( iop_base, ( ushort )( s_addr+ASC_SCSIQ_B_BWD ),
                              ( uchar )( i-1 ) ) ;
            AscWriteLramByte( iop_base, ( ushort )( s_addr+ASC_SCSIQ_B_QNO ),
                              ( uchar )i ) ;
       }/* for */
/*
** init last queue link
*/
       AscWriteLramByte( iop_base, ( ushort )( s_addr+ASC_SCSIQ_B_FWD ),
                         ( uchar )ASC_QLINK_END ) ;
       AscWriteLramByte( iop_base, ( ushort )( s_addr+ASC_SCSIQ_B_BWD ),
                         ( uchar )( asc_dvc->max_total_qng - 1 ) ) ;
       AscWriteLramByte( iop_base, ( ushort )( s_addr+ASC_SCSIQ_B_QNO ),
                         ( uchar )asc_dvc->max_total_qng ) ;
       i++ ;
       s_addr += ASC_QBLK_SIZE ;
/*
** init two more queues, one for busy queue head, one for disc queue head
** all point to themself
*/
       for( ; i <= ( uchar )( asc_dvc->max_total_qng+3 ) ;
              i++, s_addr += ASC_QBLK_SIZE )
       {
/*
** init the rest of queues, all point to themselves
*/
            AscWriteLramByte( iop_base,
                      ( ushort )( s_addr+( ushort )ASC_SCSIQ_B_FWD ), i ) ;
            AscWriteLramByte( iop_base,
                      ( ushort )( s_addr+( ushort )ASC_SCSIQ_B_BWD ), i ) ;
            AscWriteLramByte( iop_base,
                      ( ushort )( s_addr+( ushort )ASC_SCSIQ_B_QNO ), i ) ;
       }/* for */
/*
** Warning: DO NOT initialize BIOS data section !!!
*/
       return( warn_code ) ;
}

/* -----------------------------------------------------------------------
**
** -------------------------------------------------------------------- */
ushort AscInitQLinkVar(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc
       )
{
       PortAddr iop_base ;
       int  i ;
       ushort lram_addr ;

       iop_base = asc_dvc->iop_base ;
       AscPutRiscVarFreeQHead( iop_base, 1 ) ;
       AscPutRiscVarDoneQTail( iop_base, asc_dvc->max_total_qng ) ;

       AscPutVarFreeQHead( iop_base, 1 ) ;
       AscPutVarDoneQTail( iop_base, asc_dvc->max_total_qng ) ;

       AscWriteLramByte( iop_base, ASCV_BUSY_QHEAD_B,
                         ( uchar )( ( int )asc_dvc->max_total_qng+1 ) ) ;
       AscWriteLramByte( iop_base, ASCV_DISC1_QHEAD_B,
                         ( uchar )( ( int )asc_dvc->max_total_qng+2 ) ) ;

       AscWriteLramByte( iop_base, ( ushort )ASCV_TOTAL_READY_Q_B,
                         asc_dvc->max_total_qng ) ;

       AscWriteLramWord( iop_base, ASCV_ASCDVC_ERR_CODE_W, 0 ) ;
       AscWriteLramWord( iop_base, ASCV_HALTCODE_W, 0 ) ;
       AscWriteLramByte( iop_base, ASCV_STOP_CODE_B, 0 ) ;
       AscWriteLramByte( iop_base, ASCV_SCSIBUSY_B, 0 ) ;
       AscWriteLramByte( iop_base, ASCV_WTM_FLAG_B, 0 ) ;

       AscPutQDoneInProgress( iop_base, 0 ) ;

       lram_addr = ASC_QADR_BEG ;
       for( i = 0 ; i < 32 ; i++, lram_addr += 2 )
       {
            AscWriteLramWord( iop_base, lram_addr, 0 ) ;
       }/* for */

       return( 0 ) ;
}

/* -----------------------------------------------------------
** for library internal use
** -------------------------------------------------------- */
int    AscSetLibErrorCode(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          ushort err_code
       )
{
       if( asc_dvc->err_code == 0 )
       {
/*
** error code will be set, if and only if no prior error code exist
**
*/
           asc_dvc->err_code = err_code ;
           AscWriteLramWord( asc_dvc->iop_base, ASCV_ASCDVC_ERR_CODE_W,
                             err_code ) ;
       }/* if */
       return( err_code ) ;
}

/* -----------------------------------------------------------
** write a error code to local RAM for debugging purpose
**
** for device driver use
** -------------------------------------------------------- */
int    AscSetDvcErrorCode(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          uchar err_code
       )
{
       if( asc_dvc->err_code == 0 )
       {
/*
** error code will be set, if and only if no prior error code exist
**
*/
           asc_dvc->err_code = err_code ;
           AscWriteLramByte( asc_dvc->iop_base, ASCV_DVC_ERR_CODE_B,
                             err_code ) ;
       }/* if */
       return( err_code ) ;
}

/* -----------------------------------------------------------
** loop until the queue is
** wait until QS_READY bit is cleared
**
** return 1 if queue is done
** return 0 if timeout
** -------------------------------------------------------- */
int    _AscWaitQDone(
           PortAddr iop_base,
           REG ASC_SCSI_Q dosfar *scsiq
       )
{
       ushort q_addr ;
       uchar  q_status ;
       int    count = 0 ;

       while( scsiq->q1.q_no == 0 ) ;
       q_addr = ASC_QNO_TO_QADDR( scsiq->q1.q_no ) ;

       do
       {
           q_status = AscReadLramByte( iop_base,
               (uchar) (q_addr + ASC_SCSIQ_B_STATUS) ) ;
           DvcSleepMilliSecond( 100L ) ;
           if( count++ > 30 )
           {
               return( 0 ) ;
           }/* if */
       }while( ( q_status & QS_READY ) != 0 ) ;
       return( 1 ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc\a_qop.c ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** a_qop.c
**
*/

#include "ascinc.h"

/* -------------------------------------------------------------------------
** update history
** 1: 12/16/93
**
** version 101: 12/20/93 released
**
** csf 9/13/95 - Change synchronous negotiation code to always use the lower
**               proposed by initiator or target.
**
**     SYN_XFER_NS_0 = 10 MB/sec
**     SYN_XFER_NS_4 = 5 MB/sec
**
** ---------------------------------------------------------------------- */


/* -------------------------------------------------------------------------
**
** return value that should write to chip sdtr register
** but usually not set to chip immediately
** set was done later when target come back with agreed speed
**
** return 0 - means we should use the asyn transfer
**
** ---------------------------------------------------------------------- */
uchar  AscMsgOutSDTR(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          uchar sdtr_period,
          uchar sdtr_offset
       )
{
       EXT_MSG  sdtr_buf ;
       uchar  sdtr_period_index ;
       PortAddr iop_base ;

       iop_base = asc_dvc->iop_base ;
       sdtr_buf.msg_type = MS_EXTEND ;
       sdtr_buf.msg_len = MS_SDTR_LEN ;
       sdtr_buf.msg_req = MS_SDTR_CODE ;
       sdtr_buf.xfer_period = sdtr_period ;
       sdtr_offset &= ASC_SYN_MAX_OFFSET ;
       sdtr_buf.req_ack_offset = sdtr_offset ;
       if( ( sdtr_period_index =
           AscGetSynPeriodIndex( asc_dvc, sdtr_period ) ) <=
           asc_dvc->max_sdtr_index )
       {
           AscMemWordCopyToLram( iop_base,
                                 ASCV_MSGOUT_BEG,
                                 ( ushort dosfar *)&sdtr_buf,
                                 ( ushort )( sizeof( EXT_MSG ) >> 1 )) ;
           return( ( sdtr_period_index << 4 ) | sdtr_offset ) ;
       }/* if */
       else
       {
/*
**
** the speed is too slow
**
**
*/
           sdtr_buf.req_ack_offset = 0 ;
           AscMemWordCopyToLram( iop_base,
                                 ASCV_MSGOUT_BEG,
                                 ( ushort dosfar *)&sdtr_buf,
                                 ( ushort )( sizeof( EXT_MSG ) >> 1 )) ;
           return( 0 ) ;
       }/* else */
}

/* ---------------------------------------------------------------------
**
** return the value that should be written to sdtr register
** return 0xff if value is not acceptable ( either out of range or too low )
** ------------------------------------------------------------------ */
uchar  AscCalSDTRData(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          uchar sdtr_period,
          uchar syn_offset
       )
{
       uchar  byte ;
       uchar  sdtr_period_ix ;

       sdtr_period_ix = AscGetSynPeriodIndex( asc_dvc, sdtr_period ) ;
       if(
           ( sdtr_period_ix > asc_dvc->max_sdtr_index )
           /* || ( sdtr_period_ix > ASC_SDTR_PERIOD_IX_MIN ) */
           )
       {
           return( 0xFF ) ;
       }/* if */
       byte = ( sdtr_period_ix << 4 ) | ( syn_offset & ASC_SYN_MAX_OFFSET );
       return( byte ) ;
}

/* ---------------------------------------------------------------------
**
** ------------------------------------------------------------------ */
void   AscSetChipSDTR(
          PortAddr iop_base,
          uchar sdtr_data,
          uchar tid_no
       )
{
/*
**
** if we write zero to ASCV_SDTR_DONE_BEG table
** we have disable the sdtr also
**
*/
       /* AscSetChipSyn( iop_base, sdtr_data ) ; */

       AscSetChipSynRegAtID( iop_base, tid_no, sdtr_data ) ;
       AscPutMCodeSDTRDoneAtID( iop_base, tid_no, sdtr_data ) ;
       return ;
}

/* --------------------------------------------------------------------
**
** return speed
** return 0 if if speed is faster than we can handle
**
** if return value > 7, it speed is too slow, use asyn transfer
**
** ----------------------------------------------------------------- */
uchar  AscGetSynPeriodIndex(
          ASC_DVC_VAR asc_ptr_type *asc_dvc,
          ruchar syn_time
       )
{
       ruchar *period_table ;
       int    max_index ;
       int    min_index ;
       int    i ;

       period_table = asc_dvc->sdtr_period_tbl ;
       max_index = ( int )asc_dvc->max_sdtr_index ;
       min_index = ( int )asc_dvc->host_init_sdtr_index ;
       if(
           ( syn_time <= period_table[ max_index ] )
         )
       {
           for( i = min_index ; i < (max_index-1) ; i++ )
           {
                if( syn_time <= period_table[ i ] )
                {
                    return( ( uchar )i ) ;
                }
           }
           return( ( uchar )max_index ) ;
       }/* if */
       else
       {
/*
** out of range !
*/
           return( ( uchar )( max_index+1 ) ) ;
       }/* else */
}

/* -------------------------------------------------------------------
**
** returns:
** 0 - busy
** 1 - queue allocated
** other value: error
** ---------------------------------------------------------------- */
uchar  AscAllocFreeQueue(
          PortAddr iop_base,
          uchar free_q_head
       )
{
       ushort  q_addr ;
       uchar   next_qp ;
       uchar   q_status ;

/*
** this is critical section until user update the asc_dvc->free_q_head
*/
       q_addr = ASC_QNO_TO_QADDR( free_q_head ) ;
       q_status = ( uchar )AscReadLramByte( iop_base,
                  ( ushort )( q_addr+ASC_SCSIQ_B_STATUS ) ) ;
       next_qp = AscReadLramByte( iop_base,
                  ( ushort )( q_addr+ASC_SCSIQ_B_FWD ) ) ;
       if(
           ( ( q_status & QS_READY ) == 0 )
           && ( next_qp != ASC_QLINK_END )
         )
       {
           return( next_qp ) ;
       }/* if */
       return( ASC_QLINK_END ) ;
}

/* -------------------------------------------------------------------
**
** returns:
** 0xFF - busy
** 1 - queue allocated
** other value: error
** ---------------------------------------------------------------- */
uchar  AscAllocMultipleFreeQueue(
          PortAddr iop_base,
          uchar free_q_head,
          uchar n_free_q
       )
{
       uchar  i ;
/*
** this is critical section until user update the asc_dvc->free_q_head
*/
       for( i = 0 ; i < n_free_q ; i++ )
       {
            if( ( free_q_head = AscAllocFreeQueue( iop_base, free_q_head ) )
                == ASC_QLINK_END )
            {
                return( ASC_QLINK_END ) ;
            }/* if */
       }/* for */
       return( free_q_head ) ;
}

#if CC_USE_AscAbortSRB

/* -----------------------------------------------------------------------
**
** srb_ptr is "scsiq->q2.srb_ptr" when you call AscExeScsiQueue()
** return value:
** TRUE(1) : the srb_ptr has been successfully aborted,
**           you should receive a callback later
**
** FALSE(0):
** - the srb_ptr cannot be found
**   most likely the queue is done
**
** - the queue is in a state that cannot be aborted
**
** -------------------------------------------------------------------- */
int    AscRiscHaltedAbortSRB(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          ulong srb_ptr
       )
{
       PortAddr  iop_base ;
       ushort  q_addr ;
       uchar   q_no ;
       ASC_QDONE_INFO scsiq_buf ;
       ASC_QDONE_INFO dosfar *scsiq ;
       ASC_ISR_CALLBACK asc_isr_callback ;
       int    last_int_level ;

       iop_base = asc_dvc->iop_base ;
       asc_isr_callback = ( ASC_ISR_CALLBACK )asc_dvc->isr_callback ;
       last_int_level = DvcEnterCritical( ) ;
       scsiq = ( ASC_QDONE_INFO dosfar *)&scsiq_buf ;

#if CC_LINK_BUSY_Q
       _AscAbortSrbBusyQueue( asc_dvc, scsiq, srb_ptr ) ;
#endif /* CC_LINK_BUSY_Q */

       for( q_no = ASC_MIN_ACTIVE_QNO ; q_no <= asc_dvc->max_total_qng ;
            q_no++ )
       {
            q_addr = ASC_QNO_TO_QADDR( q_no ) ;
            scsiq->d2.srb_ptr = AscReadLramDWord( iop_base,
                        ( ushort )( q_addr+( ushort )ASC_SCSIQ_D_SRBPTR ) ) ;
            if( scsiq->d2.srb_ptr == srb_ptr )
            {
                _AscCopyLramScsiDoneQ( iop_base, q_addr, scsiq, asc_dvc->max_dma_count ) ;
                if(
                    ( ( scsiq->q_status & QS_READY ) != 0 )
                    && ( ( scsiq->q_status & QS_ABORTED ) == 0 )
                    && ( ( scsiq->cntl & QCSG_SG_XFER_LIST ) == 0 )
                  )
                {
/*
** abort the queue only if QS_READY bit is set
*/
                    scsiq->q_status |= QS_ABORTED ;
                    scsiq->d3.done_stat = QD_ABORTED_BY_HOST ;
                    AscWriteLramDWord( iop_base,
                          ( ushort )( q_addr+( ushort )ASC_SCSIQ_D_SRBPTR ),
                            0L ) ;
                    AscWriteLramByte( iop_base,
                          ( ushort )( q_addr+( ushort )ASC_SCSIQ_B_STATUS ),
                            scsiq->q_status ) ;
                    ( *asc_isr_callback )( asc_dvc, scsiq ) ;
                    return( 1 ) ;
                }/* if */
            }/* if */
       }/* for */
       DvcLeaveCritical( last_int_level ) ;
       return( 0 ) ;
}
#endif /* CC_USE_AscAbortSRB */

#if CC_USE_AscResetDevice

/* -----------------------------------------------------------------------
**
**
** return value:
** TRUE(1): target successfully reset and abort all queued command
** -------------------------------------------------------------------- */
int    AscRiscHaltedAbortTIX(
           REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
           uchar target_ix
       )
{
       PortAddr  iop_base ;
       ushort  q_addr ;
       uchar   q_no ;
       ASC_QDONE_INFO scsiq_buf ;
       ASC_QDONE_INFO dosfar *scsiq ;
       ASC_ISR_CALLBACK asc_isr_callback ;
       int    last_int_level ;
#if CC_LINK_BUSY_Q
       uchar  tid_no ;
#endif /* CC_LINK_BUSY_Q */

       iop_base = asc_dvc->iop_base ;
       asc_isr_callback = ( ASC_ISR_CALLBACK )asc_dvc->isr_callback ;
       last_int_level = DvcEnterCritical( ) ;
       scsiq = ( ASC_QDONE_INFO dosfar *)&scsiq_buf ;

#if CC_LINK_BUSY_Q
/*
**
** abort all busy queue of the target_ix
**
*/
       tid_no = ASC_TIX_TO_TID( target_ix ) ;
       _AscAbortTidBusyQueue( asc_dvc, scsiq, tid_no ) ;

#endif /* CC_LINK_BUSY_Q */

       for( q_no = ASC_MIN_ACTIVE_QNO ; q_no <= asc_dvc->max_total_qng ;
            q_no++ )
       {
            q_addr = ASC_QNO_TO_QADDR( q_no ) ;
            _AscCopyLramScsiDoneQ( iop_base, q_addr, scsiq, asc_dvc->max_dma_count ) ;
            if(
                ( ( scsiq->q_status & QS_READY ) != 0 )
                && ( ( scsiq->q_status & QS_ABORTED ) == 0 )
                && ( ( scsiq->cntl & QCSG_SG_XFER_LIST ) == 0 )
              )
            {
                if( scsiq->d2.target_ix == target_ix )
                {
                    scsiq->q_status |= QS_ABORTED ;
                    scsiq->d3.done_stat = QD_ABORTED_BY_HOST ;

                    AscWriteLramDWord( iop_base,
                           ( ushort )( q_addr+( ushort )ASC_SCSIQ_D_SRBPTR ),
                             0L ) ;

                    AscWriteLramByte( iop_base,
                           ( ushort )( q_addr+( ushort )ASC_SCSIQ_B_STATUS ),
                             scsiq->q_status ) ;
                    ( *asc_isr_callback )( asc_dvc, scsiq ) ;
                }/* if */
            }/* if */
       }/* for */
       DvcLeaveCritical( last_int_level ) ;
       return( 1 ) ;
}

#endif /* CC_USE_AscResetDevice */

#if 0
/* -----------------------------------------------------------------------
**
** -------------------------------------------------------------------- */
int    AscRiscHaltedAbortALL(
           REG ASC_DVC_VAR asc_ptr_type *asc_dvc
       )
{
       PortAddr  iop_base ;
       ushort  q_addr ;
       uchar   q_no ;
       ASC_QDONE_INFO scsiq_buf ;
       ASC_QDONE_INFO dosfar *scsiq ;
       ASC_ISR_CALLBACK asc_isr_callback ;
       int    last_int_level ;
#if CC_LINK_BUSY_Q
       uchar  tid ;
#endif /* CC_LINK_BUSY_Q */

       iop_base = asc_dvc->iop_base ;
       asc_isr_callback = ( ASC_ISR_CALLBACK )asc_dvc->isr_callback ;
       last_int_level = DvcEnterCritical( ) ;
       scsiq = ( ASC_QDONE_INFO dosfar *)&scsiq_buf ;

#if CC_LINK_BUSY_Q
       for( tid = 0 ; tid <= ASC_MAX_TID ; tid++ )
       {
            _AscAbortTidBusyQueue( asc_dvc, scsiq, tid ) ;
       }/* for */
#endif /* CC_LINK_BUSY_Q */

       for( q_no = ASC_MIN_ACTIVE_QNO ;
            q_no <= asc_dvc->max_total_qng ;
            q_no++ )
       {
            q_addr = ASC_QNO_TO_QADDR( q_no ) ;
            _AscCopyLramScsiDoneQ( iop_base, q_addr, scsiq, asc_dvc->max_dma_count ) ;
            if(
                ( ( scsiq->q_status & QS_READY ) != 0 )
                && ( ( scsiq->q_status & QS_ABORTED ) == 0 )
                && ( ( scsiq->cntl & QCSG_SG_XFER_LIST ) == 0 )
              )
            {
                scsiq->q_status |= QS_ABORTED ;
                scsiq->d3.done_stat = QD_ABORTED_BY_HOST ;
                AscWriteLramDWord( iop_base,
                                   ( ushort )( q_addr+( ushort )ASC_SCSIQ_D_SRBPTR ),
                                   0L ) ;
                AscWriteLramByte( iop_base,
                                  ( ushort )( q_addr+( ushort )ASC_SCSIQ_B_STATUS ),
                                  scsiq->q_status ) ;
                ( *asc_isr_callback )( asc_dvc, scsiq ) ;
            }/* if */
       }/* for */
       DvcLeaveCritical( last_int_level ) ;
       /* asc_dvc->cur_total_qng = 0 ; */
       return( 1 ) ;
}
#endif

#if CC_LINK_BUSY_Q

/* ---------------------------------------------------------------------
** this function will abort busy queue list of specified target id
** and all its lun as well
**
** ------------------------------------------------------------------ */
int    _AscAbortTidBusyQueue(
           REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
           REG ASC_QDONE_INFO dosfar *scsiq,
           uchar tid_no
       )
{
       ASC_SCSI_Q dosfar *scsiq_busy ;
       ASC_ISR_CALLBACK asc_isr_callback ;
       ASC_EXE_CALLBACK asc_exe_callback ;

       asc_isr_callback = ( ASC_ISR_CALLBACK )asc_dvc->isr_callback ;
       asc_exe_callback = ( ASC_EXE_CALLBACK )asc_dvc->exe_callback ;
       scsiq_busy = asc_dvc->scsiq_busy_head[ tid_no ] ;
       while( scsiq_busy != 0L )
       {
           scsiq_busy->q1.status = QS_FREE ;
           ( *asc_exe_callback )( asc_dvc, scsiq_busy ) ;

           scsiq->q_status = QS_ABORTED ;
           scsiq->d3.done_stat = QD_ABORTED_BY_HOST ;
           scsiq->d3.host_stat = 0 ;
           scsiq->d3.scsi_msg = 0 ;

           scsiq->d2.srb_ptr = scsiq_busy->q2.srb_ptr ;
           scsiq->d2.target_ix = scsiq_busy->q2.target_ix ;
           scsiq->d2.flag = scsiq_busy->q2.flag ;
           scsiq->d2.cdb_len = scsiq_busy->q2.cdb_len ;
           scsiq->d2.tag_code = scsiq_busy->q2.tag_code ;
           scsiq->d2.vm_id = scsiq_busy->q2.vm_id ;

           scsiq->q_no = scsiq_busy->q1.q_no ;
           scsiq->cntl = scsiq_busy->q1.cntl ;
           scsiq->sense_len = scsiq_busy->q1.sense_len ;
           /* scsiq->user_def = scsiq_busy->q1.user_def ; */
           scsiq->remain_bytes = scsiq_busy->q1.data_cnt ;

           ( *asc_isr_callback )( asc_dvc, scsiq ) ;

           scsiq_busy = scsiq_busy->ext.next ;
       }/* while */
       asc_dvc->scsiq_busy_head[ tid_no ] = ( ASC_SCSI_Q dosfar *)0L ;
       asc_dvc->scsiq_busy_tail[ tid_no ] = ( ASC_SCSI_Q dosfar *)0L ;
       return( 1 ) ;
}

/* ---------------------------------------------------------------------
** this function will abort busy queue list of specified target id
** and all its lun as well
**
** ------------------------------------------------------------------ */
int    _AscAbortSrbBusyQueue(
           REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
           REG ASC_QDONE_INFO dosfar *scsiq,
           ulong srb_ptr
       )
{
       ASC_SCSI_Q dosfar *scsiq_busy ;
       ASC_ISR_CALLBACK  asc_isr_callback ;
       ASC_EXE_CALLBACK  asc_exe_callback ;
       int  i ;

       asc_isr_callback = ( ASC_ISR_CALLBACK )asc_dvc->isr_callback ;
       asc_exe_callback = ( ASC_EXE_CALLBACK )asc_dvc->exe_callback ;
       for( i = 0 ; i <= ASC_MAX_TID ; i++ )
       {
           scsiq_busy = asc_dvc->scsiq_busy_head[ i ] ;
           while( scsiq_busy != 0L )
           {
               if( scsiq_busy->q2.srb_ptr == srb_ptr )
               {
                   scsiq_busy->q1.status = QS_FREE ;
                   ( *asc_exe_callback )( asc_dvc, scsiq_busy ) ;

                   scsiq->q_status = QS_ABORTED ;
                   scsiq->d3.done_stat = QD_ABORTED_BY_HOST ;
                   scsiq->d3.host_stat = 0 ;
                   scsiq->d3.scsi_msg = 0 ;

                   scsiq->d2.srb_ptr = scsiq_busy->q2.srb_ptr ;
                   scsiq->d2.target_ix = scsiq_busy->q2.target_ix ;
                   scsiq->d2.flag = scsiq_busy->q2.flag ;
                   scsiq->d2.cdb_len = scsiq_busy->q2.cdb_len ;
                   scsiq->d2.tag_code = scsiq_busy->q2.tag_code ;
                   scsiq->d2.vm_id = scsiq_busy->q2.vm_id ;

                   scsiq->q_no = scsiq_busy->q1.q_no ;
                   scsiq->cntl = scsiq_busy->q1.cntl ;
                   scsiq->sense_len = scsiq_busy->q1.sense_len ;
                   /* scsiq->user_def = scsiq_busy->q1.user_def ; */
                   scsiq->remain_bytes = scsiq_busy->q1.data_cnt ;

                   ( *asc_isr_callback )( asc_dvc, scsiq ) ;

                   break ;

               }/* if */
               scsiq_busy = scsiq_busy->ext.next ;
           }/* while */
       }/* for */
       return( 1 ) ;
}
#endif /* CC_LINK_BUSY_Q */

/* -----------------------------------------------------------------------
** Host request risc halt
** no interrupt will be generated
**
** return
** 1 - risc is halted
** 0 - risc fail to reponse, ( but may already halt )
** -------------------------------------------------------------------- */
int    AscHostReqRiscHalt(
          PortAddr iop_base
       )
{
       int  count = 0 ;
       int  sta = 0 ;
       uchar saved_stop_code ;

       if( AscIsChipHalted( iop_base ) ) return( 1 ) ;
       saved_stop_code = AscReadLramByte( iop_base, ASCV_STOP_CODE_B ) ;
/*
** we ask RISC to stop and then halt itself
** this is two commands given in one stop_code
** only work with micro code date: serial number 13, ver 4.5 greater ( 6-20-95 )
*/
       AscWriteLramByte( iop_base, ASCV_STOP_CODE_B,
                         ASC_STOP_HOST_REQ_RISC_HALT | ASC_STOP_REQ_RISC_STOP
                       ) ;
       do
       {
           if( AscIsChipHalted( iop_base ) )
           {
               sta = 1 ;
               break;
           }/* if */
           DvcSleepMilliSecond( 100 ) ;
       }while( count++ < 20 )  ;
/*
** if successful, RISC will halt
** so it is safe to write stop_code as zero
**
** we will always restore the stop_code to old value
*/
       AscWriteLramByte( iop_base, ASCV_STOP_CODE_B, saved_stop_code ) ;
       return( sta ) ;
}

/* -----------------------------------------------------------------------
**
** -------------------------------------------------------------------- */
int    AscStopQueueExe(
          PortAddr iop_base
       )
{
       int  count ;

       count = 0 ;
       if( AscReadLramByte( iop_base, ASCV_STOP_CODE_B ) == 0 )
       {
           AscWriteLramByte( iop_base, ASCV_STOP_CODE_B,
                             ASC_STOP_REQ_RISC_STOP ) ;
           do
           {
              if(
                  AscReadLramByte( iop_base, ASCV_STOP_CODE_B ) &
                  ASC_STOP_ACK_RISC_STOP )
              {
                  return( 1 ) ;
              }/* if */
              DvcSleepMilliSecond( 100 ) ;
           }while( count++ < 20 )  ;
       }/* if */
       return( 0 ) ;
}

/* -----------------------------------------------------------------------
**
** -------------------------------------------------------------------- */
int    AscStartQueueExe(
          PortAddr iop_base
       )
{
       if( AscReadLramByte( iop_base, ASCV_STOP_CODE_B ) != 0 )
       {
           AscWriteLramByte( iop_base, ASCV_STOP_CODE_B, 0 ) ;
       }/* if */
       return( 1 ) ;
}

/* -----------------------------------------------------------------------
**
** -------------------------------------------------------------------- */
int    AscCleanUpBusyQueue(
          PortAddr iop_base
       )
{
       int  count ;
       uchar stop_code ;

       count = 0 ;
       if( AscReadLramByte( iop_base, ASCV_STOP_CODE_B ) != 0 )
       {
           AscWriteLramByte( iop_base, ASCV_STOP_CODE_B,
                             ASC_STOP_CLEAN_UP_BUSY_Q ) ;
           do
           {
               stop_code = AscReadLramByte( iop_base, ASCV_STOP_CODE_B ) ;
               if( ( stop_code & ASC_STOP_CLEAN_UP_BUSY_Q ) == 0 ) break ;
               DvcSleepMilliSecond( 100 ) ;
           }while( count++ < 20 )  ;
       }/* if */
       return( 1 ) ;
}

/* -----------------------------------------------------------------------
**
** -------------------------------------------------------------------- */
int    AscCleanUpDiscQueue(
          PortAddr iop_base
       )
{
       int  count ;
       uchar stop_code ;

       count = 0 ;
       if( AscReadLramByte( iop_base, ASCV_STOP_CODE_B ) != 0 )
       {
           AscWriteLramByte( iop_base, ASCV_STOP_CODE_B,
                             ASC_STOP_CLEAN_UP_DISC_Q ) ;
           do
           {
               stop_code = AscReadLramByte( iop_base, ASCV_STOP_CODE_B ) ;
               if( ( stop_code & ASC_STOP_CLEAN_UP_DISC_Q ) == 0 ) break ;
               DvcSleepMilliSecond( 100 ) ;
           }while( count++ < 20 )  ;
       }/* if */
       return( 1 ) ;
}

/* ---------------------------------------------------------------------
**
** Note: interrupt should not be disabled
** ------------------------------------------------------------------ */
int    AscWaitTixISRDone(
          ASC_DVC_VAR asc_ptr_type *asc_dvc,
          uchar target_ix
       )
{
       uchar  cur_req ;
       uchar  tid_no ;

       tid_no = ASC_TIX_TO_TID( target_ix ) ;
       while( TRUE )
       {
           if( ( cur_req = asc_dvc->cur_dvc_qng[ tid_no ] ) == 0 )
           {
               break ;
           }/* if */
/*
** if no interrupt coming back within xx second
** done queues are probably all processed ?
*/
           DvcSleepMilliSecond( 100L ) ;
           if( asc_dvc->cur_dvc_qng[ tid_no ] == cur_req )
           {
               break ;
           }/* if */
       }/* while */
       return( 1 ) ;
}

/* ---------------------------------------------------------------------
**
** Note: interrupt should not be disabled
** ------------------------------------------------------------------ */
int    AscWaitISRDone(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc
       )
{
       int  tid ;

       for( tid = 0 ; tid <= ASC_MAX_TID ; tid++ )
       {
            AscWaitTixISRDone( asc_dvc, (uchar) ASC_TID_TO_TIX( tid ) ) ;
       }/* for */
       return( 1 ) ;
}

/* -----------------------------------------------------------------------
**
** return warning code
** -------------------------------------------------------------------- */
ulong  AscGetOnePhyAddr(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          uchar dosfar *buf_addr,
          ulong buf_size
       )
{
       ASC_MIN_SG_HEAD sg_head ;

       sg_head.entry_cnt = ASC_MIN_SG_LIST ;
       if( DvcGetSGList( asc_dvc, ( uchar dosfar *)buf_addr,
           buf_size, ( ASC_SG_HEAD dosfar *)&sg_head ) != buf_size )
       {
           return( 0L ) ;
       }/* if */
       if( sg_head.entry_cnt > 1 )
       {
           return( 0L ) ;
       }/* if */
       return( sg_head.sg_list[ 0 ].addr ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc\a_ver.h ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** Filename: a_ver.h
**
*/

#ifndef __A_VER_H_
#define __A_VER_H_

#define ASC_LIB_VERSION_MAJOR  1   /* for major change  */
#define ASC_LIB_VERSION_MINOR  23  /* for minor bug fix */
#define ASC_LIB_SERIAL_NUMBER  115 /* internal serial number */

#endif /* #ifndef __A_VER_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc\a_scam.h ===
//**************************************************************************
//
// Copyright (c) 1994-1998 Advanced System Products, Inc.
// All Rights Reserved.
//
//  SCAM Header
//
//**************************************************************************

//
// Set to 1 to enable debug messages:
//
#define DEBUG_PRINT   0

#define UINT    unsigned int
#define BOOL    unsigned int
#define VOID    void

#ifndef UCHAR
#define UCHAR   unsigned char
#endif

//#define FALSE   (0)
//#define TRUE    (!FALSE)

//
// SCSI Control Signals:
//
#define SEL     (0x80)
#define BSY     (0x40)
#define REQO    (0x20)
#define ACKO    (0x10)
#define ATN     (0x08)
#define IO      (0x04)
#define CD      (0x02)
#define MSG     (0x01)

//
// REQ/ACK defs weird due to hardware differences
//
#define REQI    (reqI[IFType])
#define ACKI    (ackI[IFType])

//
// SCSI Data Signals:
//
#define DB7     (0x80)
#define DB6     (0x40)
#define DB5     (0x20)
#define DB4     (0x10)
#define DB3     (0x08)
#define DB2     (0x04)
#define DB1     (0x02)
#define DB0     (0x01)

//
// SCSI Message Codes
//
#define SCSI_ID     (0x80)

//
// SCAM Function Codes:
//
#define SCAMF_ISO   (0x00)
#define SCAMF_ISPF  (0x01)
#define SCAMF_CPC   (0x03)
#define SCAMF_DIC   (0x0F)
#define SCAMF_SYNC  (0x1F)

//
// SCAM transfer cycle command:
//
#define SCAM_TERM   (0x10)

//
// SCAM Action Codes, first quintet:
//
#define SCAMQ1_ID00 (0x18)
#define SCAMQ1_ID01 (0x11)
#define SCAMQ1_ID10 (0x12)
#define SCAMQ1_ID11 (0x0B)
#define SCAMQ1_CPF  (0x14)
#define SCAMQ1_LON  (0x14)
#define SCAMQ1_LOFF (0x14)

//
// SCAM Action Codes, second quintet:
//
#define SCAMQ2_CPF  (0x18)
#define SCAMQ2_LON  (0x12)
#define SCAMQ2_LOFF (0x0B)

//
// Debugging aids:
//
#if DEBUG_PRINT
#define DebugPrintf(x)  Dbg x
#else
#define DebugPrintf(x)
#endif

//
// Macros
//
#define DelayNS(x)  DelayLoop(x[IFType])

//
// Global data:
//
extern  UINT        IFType;                 // Interface type index
extern  PortAddr    ChipBase;               // Base IO address of chip
extern  PortAddr    ScsiCtrl;               // IO address of SCSI Control Reg
extern  PortAddr    ScsiData;               // IO address of SCSI Data Reg
extern  UCHAR       MyID;                   // Our ID
extern  UCHAR       reqI[];                 // Array of REQ bits by board
extern  UCHAR       ackI[];                 // Array of REQ bits by board

//
// Constants :
//
extern  UCHAR   IDBits[8];
extern  UCHAR   IDQuint[8];                 // Quintets for setting ID's
extern  UINT    ns1200[];                   // loop counts for 1.2us
extern  UINT    ns2000[];                   // loop counts for 2.0us
extern  UINT    ns2400[];                   // loop counts for 2.4us
extern  UINT    us1000[];                   // loop counts for 1.0ms
extern  UINT    dgl[];                      // DeGlitch counts

//
//  Functions defined in SCAM.C:
//
UINT DeGlitch(                      // Deglitch one or more signals
    PortAddr iop,                   // IO port to read
    UCHAR msk,                      // Mask of signals to test
    UINT loops);                    // Number of itterations signals must be low

int DeSerialize(VOID);              // Deserialize one byte of scam data
BOOL Arbitrate( VOID );             // Arbitrate for bus control
VOID DelayLoop( UINT ns );          // Delay a short time

//
// Functions Defined in SELECT.C
//
int ScamSel(                        // Check for SCAM tolerance.
    UCHAR ID);                      // ID to select
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc\a_uc.h ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** This software contains the valuable trade secrets of AdvanSys, Inc.
** The software is protected under copyright laws as unpublished
** work of Advanced System Products, Inc.
**
** micro mode object file converted to C file
** Original object file: MCODE3.OAS
** Converted C file: A_UC.H
** Date: 04-21-1998
** Time: 17:30:47.65
**
*/


#include "ascinc.h"

uchar _mcode_buf[ ] = {
  0x01,  0x03,  0x01,  0x19,  0x0F,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x0F,  0x0F,  0x0F,  0x0F,  0x0F,  0x0F,  0x0F,  0x0F,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x91,  0x10,  0x0A,  0x05,  0x01,  0x00,  0x00,  0x00,  0x00,  0xFF,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0xFF,  0x80,  0xFF,  0xFF,  0x01,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x23,  0x00,  0x24,  0x00,  0x00,  0x00,  0x07,  0x00,  0xFF,  0x00,  0x00,  0x00,  0x00,
  0xFF,  0xFF,  0xFF,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0xE2,  0x88,  0x00,  0x00,  0x00,  0x00,
  0x80,  0x73,  0x48,  0x04,  0x36,  0x00,  0x00,  0xA2,  0xC2,  0x00,  0x80,  0x73,  0x03,  0x23,  0x36,  0x40,
  0xB6,  0x00,  0x36,  0x00,  0x05,  0xD6,  0x0C,  0xD2,  0x12,  0xDA,  0x00,  0xA2,  0xC2,  0x00,  0x92,  0x80,
  0x1E,  0x98,  0x50,  0x00,  0xF5,  0x00,  0x48,  0x98,  0xDF,  0x23,  0x36,  0x60,  0xB6,  0x00,  0x92,  0x80,
  0x4F,  0x00,  0xF5,  0x00,  0x48,  0x98,  0xEF,  0x23,  0x36,  0x60,  0xB6,  0x00,  0x92,  0x80,  0x80,  0x62,
  0x92,  0x80,  0x00,  0x46,  0x17,  0xEE,  0x13,  0xEA,  0x02,  0x01,  0x09,  0xD8,  0xCD,  0x04,  0x4D,  0x00,
  0x00,  0xA3,  0xD6,  0x00,  0xA6,  0x97,  0x7F,  0x23,  0x04,  0x61,  0x84,  0x01,  0xE6,  0x84,  0xD2,  0xC1,
  0x80,  0x73,  0xCD,  0x04,  0x4D,  0x00,  0x00,  0xA3,  0xE2,  0x01,  0xA6,  0x97,  0xCE,  0x81,  0x00,  0x33,
  0x02,  0x00,  0xC0,  0x88,  0x80,  0x73,  0x80,  0x77,  0x00,  0x01,  0x01,  0xA1,  0x02,  0x01,  0x4F,  0x00,
  0x84,  0x97,  0x07,  0xA6,  0x0C,  0x01,  0x00,  0x33,  0x03,  0x00,  0xC0,  0x88,  0x03,  0x03,  0x03,  0xDE,
  0x00,  0x33,  0x05,  0x00,  0xC0,  0x88,  0xCE,  0x00,  0x69,  0x60,  0xCE,  0x00,  0x02,  0x03,  0x4A,  0x60,
  0x00,  0xA2,  0x80,  0x01,  0x80,  0x63,  0x07,  0xA6,  0x2C,  0x01,  0x80,  0x81,  0x03,  0x03,  0x80,  0x63,
  0xE2,  0x00,  0x07,  0xA6,  0x3C,  0x01,  0x00,  0x33,  0x04,  0x00,  0xC0,  0x88,  0x03,  0x07,  0x02,  0x01,
  0x04,  0xCA,  0x0D,  0x23,  0x68,  0x98,  0x4D,  0x04,  0x04,  0x85,  0x05,  0xD8,  0x0D,  0x23,  0x68,  0x98,
  0xCD,  0x04,  0x15,  0x23,  0xF6,  0x88,  0xFB,  0x23,  0x02,  0x61,  0x82,  0x01,  0x80,  0x63,  0x02,  0x03,
  0x06,  0xA3,  0x6A,  0x01,  0x00,  0x33,  0x0A,  0x00,  0xC0,  0x88,  0x4E,  0x00,  0x07,  0xA3,  0x76,  0x01,
  0x00,  0x33,  0x0B,  0x00,  0xC0,  0x88,  0xCD,  0x04,  0x36,  0x2D,  0x00,  0x33,  0x1A,  0x00,  0xC0,  0x88,
  0x50,  0x04,  0x90,  0x81,  0x06,  0xAB,  0x8A,  0x01,  0x90,  0x81,  0x4E,  0x00,  0x07,  0xA3,  0x9A,  0x01,
  0x50,  0x00,  0x00,  0xA3,  0x44,  0x01,  0x00,  0x05,  0x84,  0x81,  0x46,  0x97,  0x02,  0x01,  0x05,  0xC6,
  0x04,  0x23,  0xA0,  0x01,  0x15,  0x23,  0xA1,  0x01,  0xC6,  0x81,  0xFD,  0x23,  0x02,  0x61,  0x82,  0x01,
  0x0A,  0xDA,  0x4A,  0x00,  0x06,  0x61,  0x00,  0xA0,  0xBC,  0x01,  0x80,  0x63,  0xCD,  0x04,  0x36,  0x2D,
  0x00,  0x33,  0x1B,  0x00,  0xC0,  0x88,  0x06,  0x23,  0x68,  0x98,  0xCD,  0x04,  0xE6,  0x84,  0x06,  0x01,
  0x00,  0xA2,  0xDC,  0x01,  0x57,  0x60,  0x00,  0xA0,  0xE2,  0x01,  0xE6,  0x84,  0x80,  0x23,  0xA0,  0x01,
  0xE6,  0x84,  0x80,  0x73,  0x4B,  0x00,  0x06,  0x61,  0x00,  0xA2,  0x08,  0x02,  0x04,  0x01,  0x0C,  0xDE,
  0x02,  0x01,  0x03,  0xCC,  0x4F,  0x00,  0x84,  0x97,  0x04,  0x82,  0x08,  0x23,  0x02,  0x41,  0x82,  0x01,
  0x4F,  0x00,  0x62,  0x97,  0x48,  0x04,  0x84,  0x80,  0xF0,  0x97,  0x00,  0x46,  0x56,  0x00,  0x03,  0xC0,
  0x01,  0x23,  0xE8,  0x00,  0x81,  0x73,  0x06,  0x29,  0x03,  0x42,  0x06,  0xE2,  0x03,  0xEE,  0x67,  0xEB,
  0x11,  0x23,  0xF6,  0x88,  0x04,  0x98,  0xF4,  0x80,  0x80,  0x73,  0x80,  0x77,  0x07,  0xA4,  0x32,  0x02,
  0x7C,  0x95,  0x06,  0xA6,  0x3C,  0x02,  0x03,  0xA6,  0x4C,  0x04,  0xC0,  0x88,  0x04,  0x01,  0x03,  0xD8,
  0xB2,  0x98,  0x6A,  0x96,  0x4E,  0x82,  0xFE,  0x95,  0x80,  0x67,  0x83,  0x03,  0x80,  0x63,  0xB6,  0x2D,
  0x02,  0xA6,  0x78,  0x02,  0x07,  0xA6,  0x66,  0x02,  0x06,  0xA6,  0x6A,  0x02,  0x03,  0xA6,  0x6E,  0x02,
  0x00,  0x33,  0x10,  0x00,  0xC0,  0x88,  0x7C,  0x95,  0x50,  0x82,  0x60,  0x96,  0x50,  0x82,  0x04,  0x23,
  0xA0,  0x01,  0x14,  0x23,  0xA1,  0x01,  0x3C,  0x84,  0x04,  0x01,  0x0C,  0xDC,  0xE0,  0x23,  0x25,  0x61,
  0xEF,  0x00,  0x14,  0x01,  0x4F,  0x04,  0xA8,  0x01,  0x6F,  0x00,  0xA5,  0x01,  0x03,  0x23,  0xA4,  0x01,
  0x06,  0x23,  0x9C,  0x01,  0x24,  0x2B,  0x1C,  0x01,  0x02,  0xA6,  0xB6,  0x02,  0x07,  0xA6,  0x66,  0x02,
  0x06,  0xA6,  0x6A,  0x02,  0x03,  0xA6,  0x20,  0x04,  0x01,  0xA6,  0xC0,  0x02,  0x00,  0xA6,  0xC0,  0x02,
  0x00,  0x33,  0x12,  0x00,  0xC0,  0x88,  0x00,  0x0E,  0x80,  0x63,  0x00,  0x43,  0x00,  0xA0,  0x98,  0x02,
  0x4D,  0x04,  0x04,  0x01,  0x0B,  0xDC,  0xE7,  0x23,  0x04,  0x61,  0x84,  0x01,  0x10,  0x31,  0x12,  0x35,
  0x14,  0x01,  0xEC,  0x00,  0x6C,  0x38,  0x00,  0x3F,  0x00,  0x00,  0xF6,  0x82,  0x18,  0x23,  0x04,  0x61,
  0x18,  0xA0,  0xEE,  0x02,  0x04,  0x01,  0x9C,  0xC8,  0x00,  0x33,  0x1F,  0x00,  0xC0,  0x88,  0x08,  0x31,
  0x0A,  0x35,  0x0C,  0x39,  0x0E,  0x3D,  0x7E,  0x98,  0xB6,  0x2D,  0x01,  0xA6,  0x20,  0x03,  0x00,  0xA6,
  0x20,  0x03,  0x07,  0xA6,  0x18,  0x03,  0x06,  0xA6,  0x1C,  0x03,  0x03,  0xA6,  0x20,  0x04,  0x02,  0xA6,
  0x78,  0x02,  0x00,  0x33,  0x33,  0x00,  0xC0,  0x88,  0x7C,  0x95,  0xFA,  0x82,  0x60,  0x96,  0xFA,  0x82,
  0x82,  0x98,  0x80,  0x42,  0x7E,  0x98,  0x60,  0xE4,  0x04,  0x01,  0x29,  0xC8,  0x31,  0x05,  0x07,  0x01,
  0x00,  0xA2,  0x60,  0x03,  0x00,  0x43,  0x87,  0x01,  0x05,  0x05,  0x86,  0x98,  0x7E,  0x98,  0x00,  0xA6,
  0x22,  0x03,  0x07,  0xA6,  0x58,  0x03,  0x03,  0xA6,  0x3C,  0x04,  0x06,  0xA6,  0x5C,  0x03,  0x01,  0xA6,
  0x22,  0x03,  0x00,  0x33,  0x25,  0x00,  0xC0,  0x88,  0x7C,  0x95,  0x3E,  0x83,  0x60,  0x96,  0x3E,  0x83,
  0x04,  0x01,  0x0C,  0xCE,  0x03,  0xC8,  0x00,  0x33,  0x42,  0x00,  0xC0,  0x88,  0x00,  0x01,  0x05,  0x05,
  0xFF,  0xA2,  0x7E,  0x03,  0xB1,  0x01,  0x08,  0x23,  0xB2,  0x01,  0x3A,  0x83,  0x05,  0x05,  0x15,  0x01,
  0x00,  0xA2,  0x9E,  0x03,  0xEC,  0x00,  0x6E,  0x00,  0x95,  0x01,  0x6C,  0x38,  0x00,  0x3F,  0x00,  0x00,
  0x01,  0xA6,  0x9A,  0x03,  0x00,  0xA6,  0x9A,  0x03,  0x12,  0x84,  0x80,  0x42,  0x7E,  0x98,  0x01,  0xA6,
  0xA8,  0x03,  0x00,  0xA6,  0xC0,  0x03,  0x12,  0x84,  0xA6,  0x98,  0x80,  0x42,  0x01,  0xA6,  0xA8,  0x03,
  0x07,  0xA6,  0xB6,  0x03,  0xD8,  0x83,  0x7C,  0x95,  0xAC,  0x83,  0x00,  0x33,  0x2F,  0x00,  0xC0,  0x88,
  0xA6,  0x98,  0x80,  0x42,  0x00,  0xA6,  0xC0,  0x03,  0x07,  0xA6,  0xCE,  0x03,  0xD8,  0x83,  0x7C,  0x95,
  0xC4,  0x83,  0x00,  0x33,  0x26,  0x00,  0xC0,  0x88,  0x38,  0x2B,  0x80,  0x32,  0x80,  0x36,  0x04,  0x23,
  0xA0,  0x01,  0x12,  0x23,  0xA1,  0x01,  0x12,  0x84,  0x06,  0xF0,  0x06,  0xA4,  0xF6,  0x03,  0x80,  0x6B,
  0x05,  0x23,  0x83,  0x03,  0x80,  0x63,  0x03,  0xA6,  0x10,  0x04,  0x07,  0xA6,  0x08,  0x04,  0x06,  0xA6,
  0x0C,  0x04,  0x00,  0x33,  0x17,  0x00,  0xC0,  0x88,  0x7C,  0x95,  0xF6,  0x83,  0x60,  0x96,  0xF6,  0x83,
  0x20,  0x84,  0x06,  0xF0,  0x06,  0xA4,  0x20,  0x04,  0x80,  0x6B,  0x05,  0x23,  0x83,  0x03,  0x80,  0x63,
  0xB6,  0x2D,  0x03,  0xA6,  0x3C,  0x04,  0x07,  0xA6,  0x34,  0x04,  0x06,  0xA6,  0x38,  0x04,  0x00,  0x33,
  0x30,  0x00,  0xC0,  0x88,  0x7C,  0x95,  0x20,  0x84,  0x60,  0x96,  0x20,  0x84,  0x1D,  0x01,  0x06,  0xCC,
  0x00,  0x33,  0x00,  0x84,  0xC0,  0x20,  0x00,  0x23,  0xEA,  0x00,  0x81,  0x62,  0xA2,  0x0D,  0x80,  0x63,
  0x07,  0xA6,  0x5A,  0x04,  0x00,  0x33,  0x18,  0x00,  0xC0,  0x88,  0x03,  0x03,  0x80,  0x63,  0xA3,  0x01,
  0x07,  0xA4,  0x64,  0x04,  0x23,  0x01,  0x00,  0xA2,  0x86,  0x04,  0x0A,  0xA0,  0x76,  0x04,  0xE0,  0x00,
  0x00,  0x33,  0x1D,  0x00,  0xC0,  0x88,  0x0B,  0xA0,  0x82,  0x04,  0xE0,  0x00,  0x00,  0x33,  0x1E,  0x00,
  0xC0,  0x88,  0x42,  0x23,  0xF6,  0x88,  0x00,  0x23,  0x22,  0xA3,  0xE6,  0x04,  0x08,  0x23,  0x22,  0xA3,
  0xA2,  0x04,  0x28,  0x23,  0x22,  0xA3,  0xAE,  0x04,  0x02,  0x23,  0x22,  0xA3,  0xC4,  0x04,  0x42,  0x23,
  0xF6,  0x88,  0x4A,  0x00,  0x06,  0x61,  0x00,  0xA0,  0xAE,  0x04,  0x45,  0x23,  0xF6,  0x88,  0x04,  0x98,
  0x00,  0xA2,  0xC0,  0x04,  0xB2,  0x98,  0x00,  0x33,  0x00,  0x82,  0xC0,  0x20,  0x81,  0x62,  0xF0,  0x81,
  0x47,  0x23,  0xF6,  0x88,  0x04,  0x01,  0x0B,  0xDE,  0x04,  0x98,  0xB2,  0x98,  0x00,  0x33,  0x00,  0x81,
  0xC0,  0x20,  0x81,  0x62,  0x14,  0x01,  0x00,  0xA0,  0x08,  0x02,  0x43,  0x23,  0xF6,  0x88,  0x04,  0x23,
  0xA0,  0x01,  0x44,  0x23,  0xA1,  0x01,  0x80,  0x73,  0x4D,  0x00,  0x03,  0xA3,  0xF4,  0x04,  0x00,  0x33,
  0x27,  0x00,  0xC0,  0x88,  0x04,  0x01,  0x04,  0xDC,  0x02,  0x23,  0xA2,  0x01,  0x04,  0x23,  0xA0,  0x01,
  0x04,  0x98,  0x26,  0x95,  0x4B,  0x00,  0xF6,  0x00,  0x4F,  0x04,  0x4F,  0x00,  0x00,  0xA3,  0x22,  0x05,
  0x00,  0x05,  0x76,  0x00,  0x06,  0x61,  0x00,  0xA2,  0x1C,  0x05,  0x0A,  0x85,  0x46,  0x97,  0xCD,  0x04,
  0x24,  0x85,  0x48,  0x04,  0x84,  0x80,  0x02,  0x01,  0x03,  0xDA,  0x80,  0x23,  0x82,  0x01,  0x34,  0x85,
  0x02,  0x23,  0xA0,  0x01,  0x4A,  0x00,  0x06,  0x61,  0x00,  0xA2,  0x40,  0x05,  0x1D,  0x01,  0x04,  0xD6,
  0xFF,  0x23,  0x86,  0x41,  0x4B,  0x60,  0xCB,  0x00,  0xFF,  0x23,  0x80,  0x01,  0x49,  0x00,  0x81,  0x01,
  0x04,  0x01,  0x02,  0xC8,  0x30,  0x01,  0x80,  0x01,  0xF7,  0x04,  0x03,  0x01,  0x49,  0x04,  0x80,  0x01,
  0xC9,  0x00,  0x00,  0x05,  0x00,  0x01,  0xFF,  0xA0,  0x60,  0x05,  0x77,  0x04,  0x01,  0x23,  0xEA,  0x00,
  0x5D,  0x00,  0xFE,  0xC7,  0x00,  0x62,  0x00,  0x23,  0xEA,  0x00,  0x00,  0x63,  0x07,  0xA4,  0xF8,  0x05,
  0x03,  0x03,  0x02,  0xA0,  0x8E,  0x05,  0xF4,  0x85,  0x00,  0x33,  0x2D,  0x00,  0xC0,  0x88,  0x04,  0xA0,
  0xB8,  0x05,  0x80,  0x63,  0x00,  0x23,  0xDF,  0x00,  0x4A,  0x00,  0x06,  0x61,  0x00,  0xA2,  0xA4,  0x05,
  0x1D,  0x01,  0x06,  0xD6,  0x02,  0x23,  0x02,  0x41,  0x82,  0x01,  0x50,  0x00,  0x62,  0x97,  0x04,  0x85,
  0x04,  0x23,  0x02,  0x41,  0x82,  0x01,  0x04,  0x85,  0x08,  0xA0,  0xBE,  0x05,  0xF4,  0x85,  0x03,  0xA0,
  0xC4,  0x05,  0xF4,  0x85,  0x01,  0xA0,  0xCE,  0x05,  0x88,  0x00,  0x80,  0x63,  0xCC,  0x86,  0x07,  0xA0,
  0xEE,  0x05,  0x5F,  0x00,  0x00,  0x2B,  0xDF,  0x08,  0x00,  0xA2,  0xE6,  0x05,  0x80,  0x67,  0x80,  0x63,
  0x01,  0xA2,  0x7A,  0x06,  0x7C,  0x85,  0x06,  0x23,  0x68,  0x98,  0x48,  0x23,  0xF6,  0x88,  0x07,  0x23,
  0x80,  0x00,  0x06,  0x87,  0x80,  0x63,  0x7C,  0x85,  0x00,  0x23,  0xDF,  0x00,  0x00,  0x63,  0x4A,  0x00,
  0x06,  0x61,  0x00,  0xA2,  0x36,  0x06,  0x1D,  0x01,  0x16,  0xD4,  0xC0,  0x23,  0x07,  0x41,  0x83,  0x03,
  0x80,  0x63,  0x06,  0xA6,  0x1C,  0x06,  0x00,  0x33,  0x37,  0x00,  0xC0,  0x88,  0x1D,  0x01,  0x01,  0xD6,
  0x20,  0x23,  0x63,  0x60,  0x83,  0x03,  0x80,  0x63,  0x02,  0x23,  0xDF,  0x00,  0x07,  0xA6,  0x7C,  0x05,
  0xEF,  0x04,  0x6F,  0x00,  0x00,  0x63,  0x4B,  0x00,  0x06,  0x41,  0xCB,  0x00,  0x52,  0x00,  0x06,  0x61,
  0x00,  0xA2,  0x4E,  0x06,  0x1D,  0x01,  0x03,  0xCA,  0xC0,  0x23,  0x07,  0x41,  0x00,  0x63,  0x1D,  0x01,
  0x04,  0xCC,  0x00,  0x33,  0x00,  0x83,  0xC0,  0x20,  0x81,  0x62,  0x80,  0x23,  0x07,  0x41,  0x00,  0x63,
  0x80,  0x67,  0x08,  0x23,  0x83,  0x03,  0x80,  0x63,  0x00,  0x63,  0x01,  0x23,  0xDF,  0x00,  0x06,  0xA6,
  0x84,  0x06,  0x07,  0xA6,  0x7C,  0x05,  0x80,  0x67,  0x80,  0x63,  0x00,  0x33,  0x00,  0x40,  0xC0,  0x20,
  0x81,  0x62,  0x00,  0x63,  0x00,  0x00,  0xFE,  0x95,  0x83,  0x03,  0x80,  0x63,  0x06,  0xA6,  0x94,  0x06,
  0x07,  0xA6,  0x7C,  0x05,  0x00,  0x00,  0x01,  0xA0,  0x14,  0x07,  0x00,  0x2B,  0x40,  0x0E,  0x80,  0x63,
  0x01,  0x00,  0x06,  0xA6,  0xAA,  0x06,  0x07,  0xA6,  0x7C,  0x05,  0x40,  0x0E,  0x80,  0x63,  0x00,  0x43,
  0x00,  0xA0,  0xA2,  0x06,  0x06,  0xA6,  0xBC,  0x06,  0x07,  0xA6,  0x7C,  0x05,  0x80,  0x67,  0x40,  0x0E,
  0x80,  0x63,  0x07,  0xA6,  0x7C,  0x05,  0x00,  0x23,  0xDF,  0x00,  0x00,  0x63,  0x07,  0xA6,  0xD6,  0x06,
  0x00,  0x33,  0x2A,  0x00,  0xC0,  0x88,  0x03,  0x03,  0x80,  0x63,  0x89,  0x00,  0x0A,  0x2B,  0x07,  0xA6,
  0xE8,  0x06,  0x00,  0x33,  0x29,  0x00,  0xC0,  0x88,  0x00,  0x43,  0x00,  0xA2,  0xF4,  0x06,  0xC0,  0x0E,
  0x80,  0x63,  0xDE,  0x86,  0xC0,  0x0E,  0x00,  0x33,  0x00,  0x80,  0xC0,  0x20,  0x81,  0x62,  0x04,  0x01,
  0x02,  0xDA,  0x80,  0x63,  0x7C,  0x85,  0x80,  0x7B,  0x80,  0x63,  0x06,  0xA6,  0x8C,  0x06,  0x00,  0x33,
  0x2C,  0x00,  0xC0,  0x88,  0x0C,  0xA2,  0x2E,  0x07,  0xFE,  0x95,  0x83,  0x03,  0x80,  0x63,  0x06,  0xA6,
  0x2C,  0x07,  0x07,  0xA6,  0x7C,  0x05,  0x00,  0x33,  0x3D,  0x00,  0xC0,  0x88,  0x00,  0x00,  0x80,  0x67,
  0x83,  0x03,  0x80,  0x63,  0x0C,  0xA0,  0x44,  0x07,  0x07,  0xA6,  0x7C,  0x05,  0xBF,  0x23,  0x04,  0x61,
  0x84,  0x01,  0xE6,  0x84,  0x00,  0x63,  0xF0,  0x04,  0x01,  0x01,  0xF1,  0x00,  0x00,  0x01,  0xF2,  0x00,
  0x01,  0x05,  0x80,  0x01,  0x72,  0x04,  0x71,  0x00,  0x81,  0x01,  0x70,  0x04,  0x80,  0x05,  0x81,  0x05,
  0x00,  0x63,  0xF0,  0x04,  0xF2,  0x00,  0x72,  0x04,  0x01,  0x01,  0xF1,  0x00,  0x70,  0x00,  0x81,  0x01,
  0x70,  0x04,  0x71,  0x00,  0x81,  0x01,  0x72,  0x00,  0x80,  0x01,  0x71,  0x04,  0x70,  0x00,  0x80,  0x01,
  0x70,  0x04,  0x00,  0x63,  0xF0,  0x04,  0xF2,  0x00,  0x72,  0x04,  0x00,  0x01,  0xF1,  0x00,  0x70,  0x00,
  0x80,  0x01,  0x70,  0x04,  0x71,  0x00,  0x80,  0x01,  0x72,  0x00,  0x81,  0x01,  0x71,  0x04,  0x70,  0x00,
  0x81,  0x01,  0x70,  0x04,  0x00,  0x63,  0x00,  0x23,  0xB3,  0x01,  0x83,  0x05,  0xA3,  0x01,  0xA2,  0x01,
  0xA1,  0x01,  0x01,  0x23,  0xA0,  0x01,  0x00,  0x01,  0xC8,  0x00,  0x03,  0xA1,  0xC4,  0x07,  0x00,  0x33,
  0x07,  0x00,  0xC0,  0x88,  0x80,  0x05,  0x81,  0x05,  0x04,  0x01,  0x11,  0xC8,  0x48,  0x00,  0xB0,  0x01,
  0xB1,  0x01,  0x08,  0x23,  0xB2,  0x01,  0x05,  0x01,  0x48,  0x04,  0x00,  0x43,  0x00,  0xA2,  0xE4,  0x07,
  0x00,  0x05,  0xDA,  0x87,  0x00,  0x01,  0xC8,  0x00,  0xFF,  0x23,  0x80,  0x01,  0x05,  0x05,  0x00,  0x63,
  0xF7,  0x04,  0x1A,  0x09,  0xF6,  0x08,  0x6E,  0x04,  0x00,  0x02,  0x80,  0x43,  0x76,  0x08,  0x80,  0x02,
  0x77,  0x04,  0x00,  0x63,  0xF7,  0x04,  0x1A,  0x09,  0xF6,  0x08,  0x6E,  0x04,  0x00,  0x02,  0x00,  0xA0,
  0x14,  0x08,  0x16,  0x88,  0x00,  0x43,  0x76,  0x08,  0x80,  0x02,  0x77,  0x04,  0x00,  0x63,  0xF3,  0x04,
  0x00,  0x23,  0xF4,  0x00,  0x74,  0x00,  0x80,  0x43,  0xF4,  0x00,  0xCF,  0x40,  0x00,  0xA2,  0x44,  0x08,
  0x74,  0x04,  0x02,  0x01,  0xF7,  0xC9,  0xF6,  0xD9,  0x00,  0x01,  0x01,  0xA1,  0x24,  0x08,  0x04,  0x98,
  0x26,  0x95,  0x24,  0x88,  0x73,  0x04,  0x00,  0x63,  0xF3,  0x04,  0x75,  0x04,  0x5A,  0x88,  0x02,  0x01,
  0x04,  0xD8,  0x46,  0x97,  0x04,  0x98,  0x26,  0x95,  0x4A,  0x88,  0x75,  0x00,  0x00,  0xA3,  0x64,  0x08,
  0x00,  0x05,  0x4E,  0x88,  0x73,  0x04,  0x00,  0x63,  0x80,  0x7B,  0x80,  0x63,  0x06,  0xA6,  0x76,  0x08,
  0x00,  0x33,  0x3E,  0x00,  0xC0,  0x88,  0x80,  0x67,  0x83,  0x03,  0x80,  0x63,  0x00,  0x63,  0x38,  0x2B,
  0x9C,  0x88,  0x38,  0x2B,  0x92,  0x88,  0x32,  0x09,  0x31,  0x05,  0x92,  0x98,  0x05,  0x05,  0xB2,  0x09,
  0x00,  0x63,  0x00,  0x32,  0x00,  0x36,  0x00,  0x3A,  0x00,  0x3E,  0x00,  0x63,  0x80,  0x32,  0x80,  0x36,
  0x80,  0x3A,  0x80,  0x3E,  0x00,  0x63,  0x38,  0x2B,  0x40,  0x32,  0x40,  0x36,  0x40,  0x3A,  0x40,  0x3E,
  0x00,  0x63,  0x5A,  0x20,  0xC9,  0x40,  0x00,  0xA0,  0xB2,  0x08,  0x5D,  0x00,  0xFE,  0xC3,  0x00,  0x63,
  0x80,  0x73,  0xE6,  0x20,  0x02,  0x23,  0xE8,  0x00,  0x82,  0x73,  0xFF,  0xFD,  0x80,  0x73,  0x13,  0x23,
  0xF6,  0x88,  0x66,  0x20,  0xC0,  0x20,  0x04,  0x23,  0xA0,  0x01,  0xA1,  0x23,  0xA1,  0x01,  0x81,  0x62,
  0xE0,  0x88,  0x80,  0x73,  0x80,  0x77,  0x68,  0x00,  0x00,  0xA2,  0x80,  0x00,  0x03,  0xC2,  0xF1,  0xC7,
  0x41,  0x23,  0xF6,  0x88,  0x11,  0x23,  0xA1,  0x01,  0x04,  0x23,  0xA0,  0x01,  0xE6,  0x84,
} ;

ushort _mcode_size = sizeof( _mcode_buf ) ; /* 0x08FE */ 
ulong  _mcode_chksum = 0x012B5442UL ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc\a_scam.c ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** a_scam.c
**
*/

#include "ascinc.h"

#if CC_SCAM

#include "a_scam.h"
#include "a_scam2.c"

/*
** Global data:
*/
UINT        IFType;                     // Interface type index
PortAddr    ChipBase;                   // Base IO address of chip
PortAddr    ScsiCtrl;                   // IO address of SCSI Control Reg
PortAddr    ScsiData;                   // IO address of SCSI Data Reg
UCHAR       MyID;                       // Our ID

/*
** Conversion table, library card type to our type:
*/
int   CardTypes[4] =
{
   ASC_IS_ISA,
   ASC_IS_EISA,
   ASC_IS_VL,
   ASC_IS_PCI
};

/*
** These idiotic tables are necessary because some genius decided to correct
** a mistake in the way REQ and ACK are presented.  The order is:
**                  ISA     EISA    VESA    PCI
*/
UCHAR   reqI[] = {  0x10,   0x10,   0x10,   0x20};
UCHAR   ackI[] = {  0x20,   0x20,   0x20,   0x10};

/*
** Constants :
*/
UCHAR   IDBits[8] =
{
    0x01,   0x02,   0x04,   0x08,   0x10,   0x20,   0x40,   0x80
};

UCHAR   IDQuint[8] =                    /* Quintets for setting ID's */
{
    0x18,   0x11,   0x12,   0x0B,   0x14,   0x0D,   0x0E,   0x07
};

UINT  ns1200[] =                      /* loop counts for 1.2us */
{
    4,                                  // ISA
    5,                                  // EISA
    10,                                 // VESA
    14                                  // PCI
};

UINT  ns2000[] =                      // loop counts for 2.0us
{
    6,                                  // ISA
    9,                                  // EISA
    17,                                 // VESA
    23                                  // PCI
};

UINT  ns2400[] =                      // loop counts for 2.4us
{
    7,                                  // ISA
    10,                                 // EISA
    20,                                 // VESA
    27                                  // PCI
};

UINT  us1000[] =                      // loop counts for 1.0ms
{
    2778,                               // ISA
    4167,                               // EISA
    8334,                               // VESA
    11111                               // PCI
};

UINT  dgl[] =                         // DeGlitch counts
{
    64,                                 // ISA
    64,                                 // EISA
    128,                                // VESA
    150                                 // PCI
};

//**************************************************************************
//
//  DelayLoop() -- Wait the specified number of loops.
//
//**************************************************************************
VOID DelayLoop( UINT ns )
{
    while (ns--)
    {
        inp(ScsiCtrl);
    }
}

//**************************************************************************
//
//  Arbitrate() -- Arbitrate for bus master
//
//  Parms:  None
//
//  Return: TRUE if successful.
//
//  NOTE:   On exit, BSY and SEL are asserter
//
//**************************************************************************
BOOL Arbitrate( VOID )
{
    UCHAR       IDBit;
    UCHAR       arbMask;

    //
    // Pre-calculate a mask of ID's ours and greater for arbitration:
    //
    arbMask = ~((IDBit = IDBits[MyID]) - 1);

    //
    // Wait for bus free
    //
    if (DeGlitch(ScsiCtrl, BSY | SEL, ns1200[IFType]) != 0)
    {
        DebugPrintf(("Arbitrate: Timeout waiting for bus free.\n"));
        outp(ScsiData, 0x00);               // Release bus
        outp(ScsiCtrl, 0x00);               // Release bus
        return(FALSE);
    }

    //
    // Assert BSY and our ID bit, then wait 2.4 us:
    //
    outp(ScsiData, IDBit);
    outp(ScsiCtrl, BSY);
    DelayNS(ns2400);

    //
    // See if we won arbitration:
    //
    if (((UCHAR)inp(ScsiData) & arbMask) > IDBit)
    {
        //
        // Lost arbitration.
        //
        DebugPrintf(("Arbitrate: Lost arbitration.\n"));
        outp(ScsiData, 0x00);               // Release bus
        outp(ScsiCtrl, 0x00);               // Release bus
        return(FALSE);
    }

    //
    // Won arbitration!
    //
    outp(ScsiCtrl, BSY | SEL);              // Assert SEL and BSY

    return(TRUE);
}

//**************************************************************************
//
//  StartSCAM() -- Initiate SCAM protocol.
//
//  Parms:  None
//
//  Return: TRUE if successful.
//
//  NOTE:   On exit, BSY, SEL, I/O, C/D and DB(7) are asserted.
//
//**************************************************************************
BOOL StartSCAM( VOID )
{
    //
    // Arbitrate for bus master
    //
    if (!Arbitrate())
    {
        DebugPrintf(("StartSCAM: Failed arbitration.\n"));
        return(FALSE);
    }

    outp(ScsiData, 0x00);                   // Release Data bus
    outp(ScsiCtrl, BSY | SEL | MSG);        // Assert MSG

//  inp(ScsiCtrl);                          // Wait 90 ns (2 deskews)
//
//  5/7/97, YPC, an NEC drive responded to select despite MSG = 1
//  We will keep BSY a little longer to ensure, the drive is not confused
//
    DelayNS(ns2400);
    outp(ScsiCtrl, SEL | MSG);              // then release BSY

    DvcSCAMDelayMS(250);                    // Wait SCAM selection response
    outp(ScsiCtrl, SEL);                    // then release MSG

    //
    // Deglitch MSG:
    //
    if (DeGlitch(ScsiCtrl, MSG, dgl[IFType]) != 0)
    {
        DebugPrintf(("StartSCAM: Timeout waiting for MSG FALSE.\n"));
        outp(ScsiData, 0x00);               // Release bus
        outp(ScsiCtrl, 0x00);               // Release bus
        return(FALSE);
    }

    outp(ScsiCtrl, BSY | SEL);              // Assert BSY,
    inp(ScsiCtrl);                          // Wait 2 deskew delays,
    outp(ScsiData, 0xC0);                   // assert DB(6), DB(7),
    outp(ScsiCtrl, BSY | SEL | IO | CD);    // and I/O and C/D
    inp(ScsiCtrl);                          // Wait 2 more deskew delays.
    outp(ScsiCtrl, BSY | IO | CD);          // Release SEL

    //
    // Deglitch SEL:
    //
    if (DeGlitch(ScsiCtrl, SEL, dgl[IFType]) != 0)
    {
        DebugPrintf(("StartSCAM: Timeout waiting for SEL FALSE.\n"));
        outp(ScsiData, 0x00);               // Release bus
        outp(ScsiCtrl, 0x00);               // Release bus
        return(FALSE);
    }

    outp(ScsiData, 0x80);                   // Release DB(6)

    //
    // Deglitch DB(6):
    //
    if (DeGlitch(ScsiData, 0x40, dgl[IFType]) != 0)
    {
        DebugPrintf(("StartSCAM: Timeout waiting for DB(6) FALSE.\n"));
        outp(ScsiData, 0x00);               // Release bus
        outp(ScsiCtrl, 0x00);               // Release bus
        return(FALSE);
    }

    outp(ScsiCtrl, BSY | SEL | IO | CD);    // Finally, assert SEL.

    return(TRUE);
}

//**************************************************************************
//
//  Tranceive() -- send/receive one quintet
//
//  This function both transmits and receives one quintet since the SCAM
//  transfer protocol allows transfer in either direction in each transfer
//  cycle.
//
//  Parms:      data -- quintet to output
//
//  Return:     data input -- less than 0 if error
//
//  NOTE:   DB(7) is expected to be asserted prior to entry, and is left
//          asserted on exit.
//**************************************************************************
int Tranceive( UCHAR data )
{
    UCHAR      indata;

    data &= 0x1F;                       // Protect caller from himself

    outp(ScsiData, data | DB7 | DB5);   // Output data, assert DB(5)
    outp(ScsiData, data | DB5);         // Release DB(7)

    //
    // Deglitch DB(7):
    //
    if (DeGlitch(ScsiData, DB7, dgl[IFType]) != 0)
    {
        DebugPrintf(("Tranceive: Timeout waiting for DB7 FALSE.\n"));
        outp(ScsiData, 0x00);           // Release bus
        outp(ScsiCtrl, 0x00);           // Release bus
        return(-1);
    }

    indata = inp(ScsiData);             // Read input data
    outp(ScsiData, data | DB5 | DB6);   // Assert DB(6)
    outp(ScsiData, data | DB6);         // Release DB(5)

    //
    // Deglitch DB(5):
    //
    if (DeGlitch(ScsiData, DB5, dgl[IFType]) != 0)
    {
        DebugPrintf(("Tranceive: Timeout waiting for DB5 FALSE.\n"));
        outp(ScsiData, 0x00);           // Release bus
        outp(ScsiCtrl, 0x00);           // Release bus
        return(-1);
    }

    outp(ScsiData, DB7 | DB6);          // Release data, assert DB7
    outp(ScsiData, DB7);                // Release DB(6)

    //
    // Deglitch DB(6):
    //
    if (DeGlitch(ScsiData, DB6, dgl[IFType]) != 0)
    {
        DebugPrintf(("Tranceive: Timeout waiting for DB6 FALSE.\n"));
        outp(ScsiData, 0x00);           // Release bus
        outp(ScsiCtrl, 0x00);           // Release bus
        return(-1);
    }

    return(indata);                     // Success
}

//**************************************************************************
//
//  AssignID() -- Isolate and assign ID
//
//  This function isolates one device and assigns the specified ID to it.
//
//  Parms:  pBits = pointer to "used" bits.
//
//  Return: TRUE if successful
//
//  Note:  This routine attempts to assign the device's default ID if it
//          is available, cycling to successively lower ID's if not.
//
//**************************************************************************
BOOL AssignID( UCHAR dosfar *pBits )
{
    UCHAR       IDString[40];
    int         temp;
    UCHAR       quint;
    int         i;
    UINT        ID;
    UCHAR       IDBit;

    //
    // Send Sync and Isolate
    //
    if ( Tranceive(SCAMF_SYNC) < 0
        || (temp = Tranceive(SCAMF_ISO)) < 0 )
    {
        DebugPrintf(("AssignID: Unable to send SYNC / ISO!\n"));
        return(FALSE);
    }// End if

    if ((temp & 0x1F) != SCAMF_ISO)
    {
        DebugPrintf(("AssignID: Collision on SCAMF_ISO!\n"));
        return(FALSE);
    }// End if

    //
    // Deserialize one byte of ID string:
    //
    if ((temp = DeSerialize()) < 0)
    {
        // AssignID: No data.
        return(FALSE);
    }

    //
    // Bit 0 (SNA) of first byte means the serial number is not
    // available, we have to stop and retry at a later time.
    //
    if ((temp & 0x0001) == 0)
    {
        DebugPrintf(("AssignID: SNA set on device!\n"));
        if ( Tranceive(SCAM_TERM) < 0)
        {
            DebugPrintf(("AssignID: Failed to transmit TERM!\n"));
        }
        return(FALSE);
    }

    IDString[0] = (UCHAR)temp;              // Save the first byte
    IDString[1] = '\0';                     // Terminate the string

    //
    // Loop getting the rest of the string:
    //
    for (i = 1; i < 32; i++)
    {
        if ((temp = DeSerialize()) < 0)
        {
            break;
        }
        IDString[i] = (UCHAR)temp;
        IDString[i + 1] = '\0';             // Terminate the string
    }

    //
    // Issue the assign ID action code:
    //
    if ( (temp = Tranceive(SCAMQ1_ID00)) < 0)
    {
        DebugPrintf(("AssignID: Unable to send SCAMQ1_ID00!\n"));
        return(FALSE);
    }// End if

    if ((temp & 0x1F) != SCAMQ1_ID00)
    {
        DebugPrintf(("AssignID: Collision on SCAMQ1_ID00!\n"));
        return(FALSE);
    }// End if

    //
    // Determine new ID:
    //
    ID = IDString[1] & 0x07;
    for (i = 0; i < 8; i++)
    {
        IDBit = IDBits[ID];
        if ((*pBits & IDBit) == 0)
            break;
        //
        // Cycle to next ID
        //
        ID = (--ID) & 7;                // Next lower ID modulo 8
    }
    *pBits |= IDBit;
    quint = IDQuint[ID];

    //
    // Send the new ID:
    //
    if ( (temp = Tranceive(quint)) < 0)
    {
        DebugPrintf(("AssignID: Unable to send ID!\n"));
        return(FALSE);
    }// End if

    if ((temp & 0x1F) != quint)
    {
        DebugPrintf(("AssignID: Collision on ID!\n"));
        return(FALSE);
    }// End if

    DebugPrintf(("ID #%x: ", ID));
    DebugPrintf(("Type: %x,%x ", IDString[0], IDString[1]));
    DebugPrintf((&IDString[2]));
    DebugPrintf(("\n"));

    return(TRUE);
}

//***************************************************************************
//
//  Routine to glitch filter a given signal
//
//  ENTRY:       iop = I/O PORT TO CHECK
//               msk = MASK OF BITS WE'RE INTERESTED IN
//               loops = NUMBER OF ITTERATIONS THAT SIGNALS MUST MATCH
//
//  RETURNS:     ZERO IF SUCCESS, ELSE NON-ZERO
//
//  Note: loops must be calculated by caller based on time of an IN
//        as follows:
//                90 -- PCI
//               120 -- VESA
//               480 -- EISA
//               360 -- ISA
//
//***************************************************************************
UINT DeGlitch(PortAddr iop, UCHAR msk, UINT loops)
{
    int     i;
    UINT    esc;

    //
    // Outer loop to ensure we don't lock up forever.
    //
    for (esc = 65535; esc; esc--)
    {
        //
        // Expect the signal(s) to be 0 for the specified loop time:
        //
        for (i = loops; i; i--)
        {
            if (inp(iop) & msk)
                break;                  // Non-zero, restart timer
        }

        if (i == 0)
            return(0);                  // Success.
    }
    return(1);                          // Timeout.
}

//***************************************************************************
//
//  Routine to DeSerialize a byte of ID string
//
//  ENTRY:       NONE
//
//  RETURNS:     AL = BYTE READ
//               AH = 0 IF OK, -1 IF ERROR
//
//***************************************************************************
int DeSerialize(VOID)
{
    UCHAR   accum;
    int     temp;
    int     count;

    for (count = 0, accum = 0; count < 8; count++)
    {
        //
        //  GET A BIT OF THE BYTE:
        //
        if (((temp = Tranceive(0)) < 0) // Check for error
            || (temp & 0x10)            // Check for initiator termination
            || ((temp & 0x03) == 0))    // Check for target termination
        {
            //
            // Premature termination
            //
            return(-1);
        }
        accum = (accum << 1) | ((temp & 0x02)? 1:0);
    }
    return(accum);
}

//**************************************************************************
//
//  Cleanup() -- Clean up the bus prior to exit.
//
//**************************************************************************
VOID Cleanup(UCHAR CCReg)
{
    outp(ChipBase + 0x0F, 0x22);            // Halt chip, bank 1
    outp(ScsiData, 0x00);                   // Release bus
    outp(ScsiCtrl, 0x00);                   // Release bus
    outp(ChipBase + 0x0F, 0x20);            // Bank 0
    outpw(ChipBase + 0x0E, 0x0000);         // Disable SCAM
    outp(ChipBase + 0x0F, CCReg & 0xEF);    // Start chip
    DvcSCAMDelayMS(60);                     // Wait 60ms
}

//**************************************************************************
//
//  Scam() -- Run SCAM
//
// Returns bit map of devices SCAMed, else -1 if error.
//
//**************************************************************************
int AscSCAM(ASC_DVC_VAR asc_ptr_type *asc_dvc)
{
    UCHAR       ID;
    UCHAR       SCAMTolerant;
    UCHAR       SCAMUsed;
    UCHAR       IDBit;
    int         status;
    UCHAR       CCReg;

    DebugPrintf(("\n%ff%b1SCAM 1.0E brought to you by Dave The ScamMan! :D "));
    DebugPrintf((__DATE__ " " __TIME__ "\n"));

    //
    // Look up interface type:
    //
    for (IFType = 0; IFType < 3; IFType++)
    {
        if (CardTypes[IFType] == asc_dvc->bus_type)
        {
            break;                      // Found it.
        }
    }

    //
    // Init globals based on card type and parms:
    //
    ChipBase = asc_dvc->iop_base;
    ScsiCtrl = ChipBase + 0x09;
    ScsiData = ChipBase + 0x0B;

    CCReg = inp(ChipBase + 0x0F);           // Save original Chip Control Reg
    outp(ChipBase + 0x0F, 0x22);            // Halt, Bank 1
    outp(ScsiData, 0x00);                   // Release bus
    outp(ScsiCtrl, 0x00);                   // Release bus
    DvcSCAMDelayMS(1);                      // Wait 1ms
    outp(ChipBase + 0x0F, 0x20);            // Bank 0
    outpw(ChipBase + 0x0E, 0x2000);         // Enable SCAM

    /*
    ** Get our SCSI ID from EEPROM and set into config reg.
    */

    /* Karl 4/24/96, replaced by getting from asc_dvc
    **
    ** MyID = (AscReadEEPWord(ChipBase, (UCHAR)(6+((IFType == 2)? 0:30))) >> 8) & 0x07;
    **
    */

    MyID = asc_dvc->cfg->chip_scsi_id ;
    AscSetChipScsiID(ChipBase, MyID);
    outp(ChipBase + 0x0F, 0x22);            // Bank 1

    /*
    ** Get SCAM intolerants:
    */
    SCAMTolerant = asc_dvc->no_scam;

    /*
    ** Identify SCAM tolerant devices on bus
    */
    DebugPrintf(("\nSearching for scam tolerant devices------------\n", ID));
    for (ID = 0, IDBit = 1; IDBit; ID++, IDBit <<= 1)
    {
        if (SCAMTolerant & IDBit)
        {
            continue;
        }
        if (ID == MyID)
        {
            DebugPrintf(("ID #%d in use by host...\n", ID));
            SCAMTolerant |= IDBit;
            continue;
        }
        if ((status = ScamSel(ID)) < 0)
        {
            DebugPrintf(("Error searching for SCAM tolerants!\n"));
            Cleanup(CCReg);
            return(-1);
        }
        if (status == 1)
        {
            DebugPrintf(("ID #%d in use...\n", ID));
            SCAMTolerant |= IDBit;
        }
    }

//  DvcSCAMDelayMS(1);
    DelayNS(ns2400);  // we must have enough delay here because
    DelayNS(ns2400);  // without delay a NEC driver will respond
    DelayNS(ns2400);  // to the following SCAM select as a normal
    DelayNS(ns2400);  // select, i.e. drive busy in 4 msec.   YPC 5/7/97
    DelayNS(ns2400);

    //
    // Snatch a copy of the devices we're ignoring so we can compute
    // our return value:
    //
    SCAMUsed = SCAMTolerant;

    //
    // Attempt to initiate SCAM protocol:
    //
    if (!StartSCAM())
    {
        DebugPrintf(("Unable to initiate SCAM protocol!\n"));
        Cleanup(CCReg);
        return(-1);
    }

    //
    // Loop isolating and assigning ID's
    //
    DebugPrintf(("\nIsolation phase, assigning ID's----------------\n", ID));
    for (ID = 0; ID < 8; ID++)
    {
        //
        // Assign an ID
        //
        if (!AssignID(&SCAMTolerant))
        {
            DebugPrintf(("End of isolation, %d bits read\n", BCount));
            break;
        }// End if
    }// End for

    //
    // Exit SCAM protocol:
    //
    if ( Tranceive(SCAMF_SYNC) < 0
        || Tranceive(SCAMF_CPC) < 0 )
    {
        DebugPrintf(("Unable to send SYNC / CPC!\n"));
        Cleanup(CCReg);
        return(-1);
    }// End if

    DebugPrintf(("Configuration complete!\n\n"));

    Cleanup(CCReg);
    return(SCAMTolerant ^ SCAMUsed);
}

#endif /* CC_SCAM */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc\a_time.c ===
/*
** Copyright (c) 1994-1997 Advanced System Products, Inc.
** All Rights Reserved.
**
** a_time.c
**
*/

#include "ascinc.h"

/* -------------------------------------------------------------------------
**
** "delay" means the entire procedure should not be interrupted
**  also means the function can be called inside an h/w interrupt
**
**
**  1 second = 1,000,000,000 nano second
**
**  Note: minimum time needed for read i/o byte from our adapter
**
**                90 ns -- PCI
**               120 ns -- VESA
**               480 ns -- EISA
**               360 ns -- ISA
**
** ---------------------------------------------------------------------- */
void   DvcDelayNanoSecond(
          ASC_DVC_VAR asc_ptr_type *asc_dvc,
          ulong nano_sec
          )
{
       ulong    loop ;
       PortAddr iop_base ;

       iop_base = asc_dvc->iop_base ;
       loop = nano_sec / 90 ;
       loop++ ;
       while( loop-- != 0 )
       {
            inp( iop_base ) ;
       }
       return ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc\a_scam2.c ===
//**************************************************************************
//
// Copyright (c) 1994-1998 Advanced System Products, Inc.
// All Rights Reserved.
//
//  SCAM Selection protocol
//
//**************************************************************************

//
// CDB's
//
UCHAR CDB_TUR[] =
{
    0,  0,  0,  0,  0,  0
};

//**************************************************************************
//
//  WaitPhase()
//
//  This function waits the specified time (in ms) for the specified
//  bus condition.
//
//  Parms:  phase = Bits to check
//          result = Bits expected
//          timeout = Time in ms to wait
//
//  Return: TRUE if timeout, otherwise FALSE
//
//**************************************************************************
BOOL WaitPhase( UCHAR phase, UCHAR result, UINT timeout)
{
    while (timeout--)
    {
        if ((inp(ScsiCtrl) & phase) == result)
            return(FALSE);

        DvcSCAMDelayMS(1);
    }
    return(TRUE);
}

//**************************************************************************
//
//  ScsiXmit()
//
//  This function transmits the specified byte with REQ/ACK protocol.
//
//  Parms:  data = byte to transmit
//
//  Return: TRUE if timeout, otherwise FALSE
//
//**************************************************************************
BOOL ScsiXmit(UCHAR data)
{
    //
    // Wait for REQ
    //
    if (WaitPhase(REQI, REQI, 1000))
    {
        DebugPrintf(("ScsiXmit: Failed to receive REQ.\n"));
        outp(ScsiData, 0x00);               // Release bus
        outp(ScsiCtrl, 0x00);               // Release bus
        return(TRUE);
    }

    outp(ScsiData, data);                   // Assert the data
    inp(ScsiCtrl);                          // Delay 55ns
    outp(ScsiCtrl, ACKO);                   // Assert ACK

    //
    // Wait for Target to release REQ
    //
    if (WaitPhase(REQI, 0, 1000))
    {
        DebugPrintf(("ScsiXmit: Target failed to release REQ.\n"));
        outp(ScsiCtrl, 0);                  // Release Bus
        outp(ScsiData, 0);                  // Release Bus
        return(TRUE);
    }

    outp(ScsiCtrl, 0);                      // Release Bus
    outp(ScsiData, 0);                      // Release Bus
    return(FALSE);
}

//**************************************************************************
//
//  ScsiRcv()
//
//  This function receives one byte with REQ/ACK protocol.
//
//  Parms:  None
//
//  Return: <0 if error, else byte input
//
//**************************************************************************
int ScsiRcv( VOID )
{
    UCHAR data;

    data = inp(ScsiData);               // Read the data
    outp(ScsiCtrl, ACKO);               // Assert ACK

    //
    // Wait for Target to release REQ
    //
    if (WaitPhase(REQI, 0, 1000))
    {
        DebugPrintf(("ScsiRcv: Target failed to release REQ.\n"));
        outp(ScsiCtrl, 0);                  // Release Bus
        return(-1);
    }

    outp(ScsiCtrl, 0);                      // Release Bus
    return(data);
}

//**************************************************************************
//
//  XmitCDB() -- Send a CDB to device.
//
//  This function attempts to send the specified CDB to the device.
//
//  Parms:  len = size of CDB
//          pCDB = pointer to CDB
//
//  Return: TRUE if timeout, otherwise FALSE
//
//**************************************************************************
BOOL XmitCDB(int len, UCHAR *pCDB)
{
    while (len--)
    {
        if (ScsiXmit(*(pCDB++)))
        {
            DebugPrintf(("XmitCDB: Target failed to release REQ.\n"));
            return(TRUE);
        }
    }
    return(FALSE);
}

//**************************************************************************
//
//  Select() -- Attempt to select SCAM tolerant device
//
//  This function attempts to select the specified device, if the device
//  responds to selection within 1ms, it is considered SCAM tolerant.
//
//  Parms:  ID =  ID to be tested
//
//  Return: 1 if SCAM tolerant, 0 if not, < 0 if error.
//
//  NOTE: It is assumed on entry that the SEL and BSY are asserted as
//      result of winning arbitration.
//
//**************************************************************************
int Select( UCHAR ID )
{
    UCHAR       IDBit;
    int         state;

    IDBit = IDBits[ID];

    DelayNS(ns1200);                        // Delay 1.2us
    outp(ScsiData, IDBit | IDBits[MyID]);   // Output My ID and target's
    outp(ScsiCtrl, BSY | SEL | ATN);        // Assert attention
    inp(ScsiCtrl);                          // Wait 90 ns (2 deskews)
    outp(ScsiCtrl, SEL | ATN);              // Release BSY

    state = DvcDisableCPUInterrupt();
    DvcSCAMDelayMS(2);                      // Wait 2ms
    DvcRestoreCPUInterrupt(state);

    //
    // If target fails to respond in 1 ms, abort the select.
    //
    if ((inp(ScsiCtrl) & BSY) == 0)
    {
        outp(ScsiData, 0x00);               // Release bus
        outp(ScsiCtrl, 0x00);               // Release bus
        return(0);
    }

    //
    // Have a valid SCAM tolerant device, complete the protocol
    //
    inp(ScsiCtrl);                          // Wait 90 ns (2 deskews)
    outp(ScsiCtrl, ATN);                    // Release SEL

    return(1);
}

//**************************************************************************
//
//  ScamSel() -- Check ID for SCAM tolerance
//
//  This function attempts to select the specified device, if the device
//  responds to selection within 1ms, it is considered SCAM tolerant.
//
//  Parms:  ID =  ID to be tested
//
//  Return: 1 if SCAM tolerant, 0 if not, < 0 if error.
//
//**************************************************************************
int ScamSel( UCHAR ID )
{
    UINT      status;

    //
    // Arbitrate for bus master
    //
    if (!Arbitrate())
    {
        DebugPrintf(("SamSel: Failed arbitration.\n"));
        return(-1);
    }

    //
    // Select device
    //
    if ((status = Select(ID)) <= 0)
    {
        return(status);
    }

    //
    // Now, device is selected, we have to do something with it...
    // first, wait for REQ, and see if we've gone into Message out phase:
    //
    if (WaitPhase((UCHAR)(BSY | MSG | CD | IO | REQI), (UCHAR)(BSY | MSG | CD | REQI), 1000))
    {
        DebugPrintf(("ScamSel: Failed to achieve MESSAGE OUT phase.\n"));
        outp(ScsiData, 0x00);               // Release bus
        outp(ScsiCtrl, 0x00);               // Release bus
        return(-1);
    }

    //
    // Drop ATN
    //
    outp(ScsiCtrl, 0x00);

    //
    // Send an Identity message:
    //
    if (ScsiXmit(SCSI_ID))
    {
        DebugPrintf(("ScamSel: Failed to send SCSI_ID.\n"));
        outp(ScsiData, 0x00);               // Release bus
        outp(ScsiCtrl, 0x00);               // Release bus
        return(-1);
    }

    //
    // Wait for CMD phase
    //
    if (WaitPhase((UCHAR)(BSY | MSG | CD | IO | REQI), (UCHAR)(BSY | CD | REQI), 1000))
    {
        DebugPrintf(("ScamSel: Failed to achieve COMMAND phase.\n"));
        outp(ScsiData, 0x00);               // Release bus
        outp(ScsiCtrl, 0x00);               // Release bus
        return(-1);
    }

    //
    // Send TUR CDB
    //
    if (XmitCDB(sizeof(CDB_TUR), CDB_TUR))
    {
        DebugPrintf(("ScamSel: Failed to transmit CDB_TUR.\n"));
        outp(ScsiData, 0x00);               // Release bus
        outp(ScsiCtrl, 0x00);               // Release bus
        return(-1);
    }

    //
    // Wait for status phase
    //
    if (WaitPhase((UCHAR)(BSY | MSG | CD | IO | REQI), (UCHAR)(BSY | CD | IO | REQI), 1000))
    {
        DebugPrintf(("ScamSel: Failed to achieve STATUS phase.\n"));
        outp(ScsiData, 0x00);               // Release bus
        outp(ScsiCtrl, 0x00);               // Release bus
        return(-1);
    }

    //
    // Read and ignore the status
    //
    if (ScsiRcv() < 0)
    {
        DebugPrintf(("ScamSel: Failed to receive STATUS.\n"));
        outp(ScsiData, 0x00);               // Release bus
        outp(ScsiCtrl, 0x00);               // Release bus
        return(-1);
    }

    //
    // Wait for Message In phase
    //
    if (WaitPhase((UCHAR)(BSY | MSG | CD | IO | REQI), (UCHAR)(BSY | MSG | CD | IO | REQI), 1000))
    {
        DebugPrintf(("ScamSel: Failed to achieve MESSAGE IN phase.\n"));
        outp(ScsiData, 0x00);               // Release bus
        outp(ScsiCtrl, 0x00);               // Release bus
        return(-1);
    }

    //
    // Read message
    //
    if (ScsiRcv() < 0)
    {
        DebugPrintf(("ScamSel: Failed to receive MESSAGE IN.\n"));
        outp(ScsiData, 0x00);               // Release bus
        outp(ScsiCtrl, 0x00);               // Release bus
        return(-1);
    }

    //
    // Wait for Bus Free
    //
    if (WaitPhase(BSY | SEL, 0, 1000))
    {
        DebugPrintf(("ScamSel: Failed to achieve BUS FREE phase.\n"));
        outp(ScsiData, 0x00);               // Release bus
        outp(ScsiCtrl, 0x00);               // Release bus
        return(-1);
    }

    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc\a_winnt.h ===
//
// Copyright (c) 1994-1997 Advanced System Products, Inc.
// All Rights Reserved.
//
// a_winnt.h
//
//

#include "ascdef.h"

#define UBYTE  uchar
#define ULONG  ulong

//
// PortAddr must be an unsigned long to support Alpha and x86
// in the same driver.
//
#define PortAddr  unsigned long       // port address size
#define PORT_ADDR       PortAddr
#define AscFunPtr ulong               // pointer to function for call back

#define PBASE_REGISTER PORT_ADDR

#define far
#define Lptr
#define dosfar

/*
 * Define Asc Library required I/O port macros.
 */
#define inp(addr) \
    ScsiPortReadPortUchar((uchar *) (addr))
#define inpw(addr) \
    ScsiPortReadPortUshort((ushort *) (addr))
#define inpd(addr) \
    ScsiPortReadPortUlong((ulong *) (addr))
#define outp(addr, byte) \
    ScsiPortWritePortUchar((uchar *) (addr) , (uchar) (byte))
#define outpw(addr, word) \
    ScsiPortWritePortUshort((ushort *) (addr), (ushort) (word))
#define outpd(addr, dword) \
    ScsiPortWritePortUlong((ulong *) (addr), (ulong) (dword))

// Size of a function pointer:
#define  Ptr2Func  ULONG

#define NULLPTR  ( void *)0   /* null pointer  */
//#define FNULLPTR ( void far *)0   /* Far null pointer  */
#define EOF      (-1)         /* end of file   */
#define EOS      '\0'         /* end of string */
#define ERR      (-1)         /* boolean error */
#define UB_ERR   (uchar)(0xFF)         /* unsigned byte error */
#define UW_ERR   (uint)(0xFFFF)        /* unsigned word error */
//#define UL_ERR   (ulong)(0xFFFFFFFF)   /* unsigned long error */


#ifndef NULL
#define NULL     0            /* zero          */
#endif

#define isodd_word( val )   ( ( ( ( uint )val) & ( uint )0x0001 ) != 0 )

//
//      Max Scatter Gather List Count. 
//

#define ASC_MAX_SG_QUEUE	7
/*
 * The NT driver returns NumberOfPhysicalBreaks to NT which is 1 less
 * then the maximum scatter-gather count. But NT incorrectly sets
 * MaximumPhysicalPages, the parameter class drivers use, to the value
 * of NumberOfPhsysicalBreaks. Set ASC_MAX_SG_LIST to 257 to allow class
 * drivers to actually send 1MB requests (256 * 4KB) *and* to insure
 * the AdvanSys driver won't be broken if Microsoft decides to fix NT
 * in the future and set MaximumPhysicalPages to NumberOfPhsyicalBreaks + 1.
 */
#define ASC_MAX_SG_LIST		257

// For SCAM:
#define CC_SCAM   TRUE
#define DvcSCAMDelayMS(x)           DvcSleepMilliSecond(x)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc3550\asc3550.h ===
/*
 * AdvanSys 3550 Windows NT SCSI Miniport Driver - asc3550.h
 *
 * Copyright (c) 1994-1998  Advanced System Products, Inc.
 * All Rights Reserved.
 */

/*
 * Generalized request queuing defintions.
 */

/*
 * REQ and REQP are the generic name for a SCSI request block and pointer.
 * REQPNEXT(reqp) returns reqp's next pointer.
 * REQPTID(reqp) returns reqp's target id.
 */
typedef SCSI_REQUEST_BLOCK  REQ, *REQP;
#define REQPNEXT(reqp)      ((REQP) SRB2NEXTSCB((SCSI_REQUEST_BLOCK *) (reqp)))
#define REQPTID(reqp)       ((reqp)->TargetId)

/* asc_enqueue() flags */
#define ASC_FRONT        1
#define ASC_BACK         2

typedef struct asc_queue {
    ADV_SCSI_BIT_ID_TYPE    tidmask;              /* queue mask */
    REQP                    queue[ASC_MAX_TID+1]; /* queue linked list */
} asc_queue_t;

void                asc_enqueue(asc_queue_t *, REQP, int);
REQP                asc_dequeue(asc_queue_t *, int);
int                 asc_rmqueue(asc_queue_t *, REQP);
void                asc_execute_queue(asc_queue_t *);


/*
 * Hardware Device Extenstion Definition
 *
 * One structure is allocated for each adapter.
 */

typedef ASC_DVC_VAR     CHIP_CONFIG, *PCHIP_CONFIG;
typedef ASC_DVC_CFG     CHIP_INFO, *PCHIP_INFO;

/* Forward declarations */
typedef ASC_SCSI_REQ_Q SCB, *PSCB; /* Driver Structure needed per request. */
typedef struct _HW_DEVICE_EXTENSION *PHW_DEVICE_EXTENSION;

typedef struct _HW_DEVICE_EXTENSION {
    CHIP_CONFIG   chipConfig;  /* Aliased ASC_DVC_VAR */
    CHIP_INFO     chipInfo;    /* Aliased ASC_DVC_CFG */
    asc_queue_t   waiting;     /* Waiting command queue */
    PSCB          done;        /* Adapter done list pointer */

    uchar dev_type[ASC_MAX_TID + 1];  /* Hibernation fix (from ver. 3.3E) */

} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;


/* Macros for accessing HW Device Extension structure fields. */
#define HDE2CONFIG(hde)      (((PHW_DEVICE_EXTENSION) (hde))->chipConfig)
#define HDE2INFO(hde)        (((PHW_DEVICE_EXTENSION) (hde))->chipInfo)
#define HDE2WAIT(hde)        (((PHW_DEVICE_EXTENSION) (hde))->waiting)
#define HDE2DONE(hde)        (((PHW_DEVICE_EXTENSION) (hde))->done)
#ifdef ASC_DEBUG
#define HDE2DONECNT(hde)     (((PHW_DEVICE_EXTENSION) (hde))->done_cnt)
#endif /* ASC_DEBUG */

/* 'drv_ptr' is used to point to the adapter's hardware device extension. */
#define CONFIG2HDE(chipConfig)  ((PHW_DEVICE_EXTENSION) ((chipConfig)->drv_ptr))


/*
 * SRB Extension Definition
 *
 * One structure is allocated per request.
 */


/*
 * Scatter-Gather Limit Definitions
 */
#define ASC_PAGE_SIZE           4096 /* XXX - 95/NT definition for this? */
#define MAX_TRANSFER_SIZE       ((ADV_MAX_SG_LIST - NT_FUDGE) * ASC_PAGE_SIZE)

/*
 * Scatter-Gather Definitions per request.
 *
 * Because SG block memory is allocated in virtual memory but is
 * referenced by the microcode as phyical memory, we need to do
 * calculations to insure there will be enough physically contiguous
 * memory to support ADV_MAX_SG_LIST SG entries.
 */

/* Number of SG blocks needed. */
#define ASC_NUM_SG_BLOCK \
     ((ADV_MAX_SG_LIST + (NO_OF_SG_PER_BLOCK - 1))/NO_OF_SG_PER_BLOCK)

/* Total contiguous memory needed for SG blocks. */
#define ASC_SG_TOTAL_MEM_SIZE \
    (sizeof(ASC_SG_BLOCK) *  ASC_NUM_SG_BLOCK)

/*
 * Number of page crossings possible for the total contiguous virtual memory
 * needed for SG blocks.
 *
 * We need to allocate this many additional SG blocks in virtual memory to
 * insure there will be space for ASC_NUM_SG_BLOCK physically contiguous
 * SG blocks.
 */
#define ASC_NUM_PAGE_CROSSING \
    ((ASC_SG_TOTAL_MEM_SIZE + (ASC_PAGE_SIZE - 1))/ASC_PAGE_SIZE)

/* Scatter-gather Descriptor List */
typedef struct _SDL {
    ASC_SG_BLOCK          sg_block[ASC_NUM_SG_BLOCK + ASC_NUM_PAGE_CROSSING];
} SDL, *PSDL;

typedef struct _SRB_EXTENSION {
   PSCB                   scbptr;       /* Pointer to 4-byte aligned scb */
   PSDL                   sdlptr;       /* Pointer to 4-byte aligned sdl */
   SCB                    scb;          /* SCSI command block */
   uchar                  align1[4];    /* scb alignment padding */
   SDL                    sdl;          /* scatter gather descriptor list */
   uchar                  align2[4];    /* sdl alignment padding */
   PSCB                   nextscb;      /* next pointer for scb linked list */
   PHW_DEVICE_EXTENSION   hdep;         /* hardware device extension pointer */
} SRB_EXTENSION, *PSRB_EXTENSION;

/*
 * This macro must be called before using SRB2PSCB() and SRB2PSDL().
 * Both the SCB and SDL structures must be 4 byte aligned for the
 * asc3550 RISC DMA hardware.
 *
 * Under Windows 95 occasionally the SRB and therefore SRB Extension in
 * the SRB are not 4 byte aligned.
 */
#define INITSRBEXT(srb) \
    { \
        ((PSRB_EXTENSION) ((srb)->SrbExtension))->scbptr = \
           (PSCB) ADV_DWALIGN(&((PSRB_EXTENSION) ((srb)->SrbExtension))->scb); \
        ((PSRB_EXTENSION) ((srb)->SrbExtension))->sdlptr = \
           (PSDL) ADV_DWALIGN(&((PSRB_EXTENSION) ((srb)->SrbExtension))->sdl); \
    }

/* Macros for accessing SRB Extension structure fields. */
#define SRB2PSCB(srb)    (((PSRB_EXTENSION) ((srb)->SrbExtension))->scbptr)
#define SRB2PSDL(srb)    (((PSRB_EXTENSION) ((srb)->SrbExtension))->sdlptr)
#define SRB2NEXTSCB(srb) (((PSRB_EXTENSION) ((srb)->SrbExtension))->nextscb)
#define SRB2HDE(srb)     (((PSRB_EXTENSION) ((srb)->SrbExtension))->hdep)
#define PSCB2SRB(scb)    ((PSCSI_REQUEST_BLOCK) ((scb)->srb_ptr))
/* srb_ptr must be valid to use the following macros */
#define SCB2NEXTSCB(scb) (SRB2NEXTSCB(PSCB2SRB(scb)))
#define SCB2HDE(scb)     (SRB2HDE(PSCB2SRB(scb)))

/*
 * Maximum PCI bus number
 */
#define PCI_MAX_BUS                16

/*
 * Port Search structure:
 */
typedef struct _SRCH_CONTEXT              /* Port search context */
{
    PortAddr             lastPort;        /* Last port searched */
    ulong                PCIBusNo;        /* Last PCI Bus searched */
    ulong                PCIDevNo;        /* Last PCI Device searched */
} SRCH_CONTEXT, *PSRCH_CONTEXT;


/*
 * ScsiPortLogError() 'UniqueId' Argument Definitions
 *
 * The 'UniqueID' argument is separated into different parts to
 * report as much information as possible. It is assumed the driver
 * file will never grow beyond 4095 lines. Note: The ADV_ASSERT()
 * format for Bits 27-0 defined in d_os_dep.h differs from the format 
 * defined for all the other Error Types.
 *
 * Bit 31-28: Error Type                (4 bits)
 * Bit 27-16: Line Number               (12 bits)
 * Bit 15-0: Error Type Specific        (16 bits)
 */

/* Error Types - 16 (0x0-0xF) can be defined. */
#define ADV_SPL_BAD_TYPE    0x0  /* Error Type Unused */
#define ADV_SPL_IERR_CODE   0x1  /* Adv Library Init ASC_DVC_VAR 'err_code' */
#define ADV_SPL_IWARN_CODE  0x2  /* Adv Library Init function warning code */
#define ADV_SPL_PCI_CONF    0x3  /* Bad PCI Configuration Information */
#define ADV_SPL_BAD_IRQ     0x4  /* Bad PCI Configuration IRQ */
#define ADV_SPL_ERR_CODE    0x5  /* Adv Library ASC_DVC_VAR 'err_code' */
#define ADV_SPL_UNSUPP_REQ  0x6  /* Unsupported request */
#define ADV_SPL_START_REQ   0x7  /* Error starting a request */
#define ADV_SPL_PROC_INT    0x8  /* Error processing an interrupt */
#define ADV_SPL_REQ_STAT    0x9  /* Request done_status, host_status error */

#define ADV_SPL_ADV_ASSERT  0xF  /* ADV_ASSERT() failure, cf. d_os_dep.h */

/* Macro used to specify the 'UniqueId' argument. */
#define ADV_SPL_UNIQUEID(error_type, error_value) \
    (((ulong) (error_type) << 28) | \
     ((ulong) ((__LINE__) & 0xFFF) << 16) | \
     ((error_value) & 0xFFFF))
    

/*
 * Assertion Macro Definition
 *
 * ADV_ASSERT() is defined in d_os_dep.h, because it is used by both the
 * Windows 95/NT driver and the Adv Library.
 */

/*
 * Debug Macros
 */

#ifndef ASC_DEBUG

#define ASC_DBG(lvl, s)
#define ASC_DBG1(lvl, s, a1)
#define ASC_DBG2(lvl, s, a1, a2)
#define ASC_DBG3(lvl, s, a1, a2, a3)
#define ASC_DBG4(lvl, s, a1, a2, a3, a4)
#define ASC_DASSERT(a)
#define ASC_ASSERT(a)

#else /* ASC_DEBUG */

/*
 * Windows NT Debugging
 *
 * NT Debug Message Levels:
 *  1: Errors Only
 *  2: Information
 *  3: Function Tracing
 *  4: Arcane Information
 */

#define ASC_DBG(lvl, s) \
                    DebugPrint(((lvl), (s)))

#define ASC_DBG1(lvl, s, a1) \
                    DebugPrint(((lvl), (s), (a1)))

#define ASC_DBG2(lvl, s, a1, a2) \
                    DebugPrint(((lvl), (s), (a1), (a2)))

#define ASC_DBG3(lvl, s, a1, a2, a3) \
                    DebugPrint(((lvl), (s), (a1), (a2), (a3)))

#define ASC_DBG4(lvl, s, a1, a2, a3, a4) \
                    DebugPrint(((lvl), (s), (a1), (a2), (a3), (a4)))

#define ASC_ASSERT(a) \
    { \
        if (!(a)) { \
            DebugPrint((1, "ASC_ASSERT() Failure: file %s, line %d\n", \
                __FILE__, __LINE__)); \
        } \
    }

#define ASC_DASSERT(a)  ASC_ASSERT(a)

#endif /* ASC_DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc3550\a_advlib.c ===
/*
 * a_advlib.c - Main Adv Library Source File
 *
 * Copyright (c) 1997-1998 Advanced System Products, Inc.
 * All Rights Reserved.
 */

#include "a_ver.h"       /* Version */
#include "d_os_dep.h"    /* Driver */
#include "a_scsi.h"      /* SCSI */
#include "a_condor.h"    /* AdvanSys Hardware*/
#include "a_advlib.h"    /* Adv Library */

/*
 * Define a 12-bit unique file id which may by used by a driver for
 * debugging or tracing purposes. Each C source file must define a
 * different value.
 */
#define ADV_FILE_UNIQUE_ID           0xAD2   /* Adv Library C Source File #2 */

#ifndef ADV_OS_BIOS
/*
 * Description:
 *      Send a SCSI request to the ASC3550 chip
 *
 * If there is no SG list for the request, set 'sg_entry_cnt' to 0.
 *
 * If 'sg_real_addr' is non-zero on entry, AscGetSGList() will not be
 * called. It is assumed the caller has already initialized 'sg_real_addr'.
 *
 * If 'done_status' is not set to QD_DO_RETRY, then 'error_retry' will be
 * set to SCSI_MAX_RETRY.
 *
 * Return:
 *      ADV_SUCCESS(1) - the request is in the mailbox
 *      ADV_BUSY(0) - total request count > 253, try later
 *      ADV_ERROR(-1) - invalid scsi request Q
 */
int
AdvExeScsiQueue(ASC_DVC_VAR WinBiosFar *asc_dvc,
                ASC_SCSI_REQ_Q dosfar *scsiq)
{
    if (scsiq == (ASC_SCSI_REQ_Q dosfar *) 0L)
    {
        /* 'scsiq' should never be NULL. */
        ADV_ASSERT(0);
        return ADV_ERROR;
    }

#if ADV_GETSGLIST
    if ((scsiq->sg_list_ptr) &&        /* there is a SG list to be done */
        (scsiq->sg_real_addr == 0L) &&
        (scsiq->data_cnt != 0) &&
        (AscGetSGList(asc_dvc, scsiq) == 0))
    {
        /* AscGetSGList() should never fail. */
        ADV_ASSERT(0);
        return ADV_ERROR;
    }
#endif /* ADV_GETSGLIST */

#if ADV_INITSCSITARGET
    if (scsiq->done_status != QD_DO_RETRY)
    {
        scsiq->error_retry = SCSI_MAX_RETRY;        /* set retry count */
    }
#endif /* ADV_INITSCSITARGET */

    return AscSendScsiCmd(asc_dvc, scsiq);
}

/*
 * Reset SCSI Bus and purge all outstanding requests.
 *
 * Return Value:
 *      ADV_TRUE(1) - All requests are purged and SCSI Bus is reset.
 *
 * Note: Should always return ADV_TRUE.
 */
int
AdvResetSB(ASC_DVC_VAR WinBiosFar *asc_dvc)
{
    int         status;

    status = AscSendIdleCmd(asc_dvc, (ushort) IDLE_CMD_SCSI_RESET, 0L, 0);

    AscResetSCSIBus(asc_dvc);

    return status;
}
#endif /* ADV_OS_BIOS */

/*
 * Reset SCSI Bus and delay.
 */
void
AscResetSCSIBus(ASC_DVC_VAR WinBiosFar *asc_dvc)
{
    PortAddr    iop_base;
    ushort      scsi_ctrl;

    iop_base = asc_dvc->iop_base;

    /*
     * The microcode currently sets the SCSI Bus Reset signal while
     * handling the AscSendIdleCmd() IDLE_CMD_SCSI_RESET command above.
     * But the SCSI Bus Reset Hold Time in the microcode is not deterministic
     * (it may in fact be for less than the SCSI Spec. minimum of 25 us).
     * Therefore on return the Adv Library sets the SCSI Bus Reset signal
     * for ASC_SCSI_RESET_HOLD_TIME_US, which is defined to be greater
     * than 25 us.
     */
    scsi_ctrl = AscReadWordRegister(iop_base, IOPW_SCSI_CTRL);
    AscWriteWordRegister(iop_base, IOPW_SCSI_CTRL,
        scsi_ctrl | ADV_SCSI_CTRL_RSTOUT);
    DvcDelayMicroSecond(asc_dvc, (ushort) ASC_SCSI_RESET_HOLD_TIME_US);
    AscWriteWordRegister(iop_base, IOPW_SCSI_CTRL,
        scsi_ctrl & ~ADV_SCSI_CTRL_RSTOUT);

    DvcSleepMilliSecond((ulong) asc_dvc->scsi_reset_wait * 1000);
}

#if ADV_GETSGLIST
/*
 * Set up the SG List for a request
 * Return:
 *      ADV_SUCCESS(1) - SG List successfully created
 *      ADV_ERROR(-1) - SG List creation failed
 */
int
AscGetSGList(ASC_DVC_VAR WinBiosFar *asc_dvc,
             ASC_SCSI_REQ_Q dosfar *scsiq)
{
    ulong               xfer_len, virtual_addr;
    long                sg_list_len;            /* size of the SG list buffer */
    ASC_SG_BLOCK dosfar *sg_block;              /* virtual address of a SG */
    ulong               sg_block_next_addr;     /* block and its next */
    long                sg_count;
    ulong               sg_block_page_boundary; /* page boundary break */
    ulong               sg_block_physical_addr;
    int                 sg_block_index, i;      /* how many SG entries */

    sg_block = scsiq->sg_list_ptr;
    sg_block_next_addr = (ulong) sg_block;    /* allow math operation */
    sg_list_len = ADV_SG_LIST_MAX_BYTE_SIZE;
    sg_block_physical_addr = DvcGetPhyAddr(asc_dvc, scsiq,
        (uchar dosfar *) scsiq->sg_list_ptr, (long dosfar *) &sg_list_len,
        ADV_IS_SGLIST_FLAG);
    ADV_ASSERT(ADV_DWALIGN(sg_block_physical_addr) == sg_block_physical_addr);
    if (sg_list_len < sizeof(ASC_SG_BLOCK))
    {
        /* The caller should always provide enough contiguous memory. */
        ADV_ASSERT(0);
        return ADV_ERROR;
    }
    scsiq->sg_real_addr = sg_block_physical_addr;

    virtual_addr = scsiq->vdata_addr;
    xfer_len = scsiq->data_cnt;
    sg_block_index = 0;
    do
    {
        sg_block_page_boundary = (ulong) sg_block + sg_list_len;
        sg_block->first_entry_no = (UCHAR)sg_block_index;
        for (i = 0; i < NO_OF_SG_PER_BLOCK; i++)
        {
            sg_count = xfer_len; /* Set maximum request length. */
            sg_block->sg_list[i].sg_addr =
              DvcGetPhyAddr(asc_dvc, scsiq,
                  (uchar dosfar *) virtual_addr, &sg_count,
                  ADV_ASCGETSGLIST_VADDR | ADV_IS_DATA_FLAG);
#ifdef ADV_OS_WIN95
            if (sg_block->sg_list[i].sg_addr < 0x1000)
            {
                return ADV_ERROR;
            }
#endif /* ADV_OS_WIN95 */
            if (sg_count > (long) xfer_len)    /* last sg entry */
            {
                sg_count = xfer_len;    /* yes, the last */
            }
            sg_block->sg_list[i].sg_count = sg_count;
            virtual_addr += sg_count;
            xfer_len -= sg_count;
            if (xfer_len <= 0)
            {    /* last entry, get out */
                scsiq->sg_entry_cnt = sg_block_index + i + 1;
                sg_block->last_entry_no = sg_block_index + i;
                sg_block->sg_ptr = 0L;    /* next link = NULL */
                return ADV_SUCCESS;
            }
        }    /* we have go thru 15 entries */
        /* get another SG block */
        sg_list_len -= sizeof(ASC_SG_BLOCK);
        if (sg_list_len >= 0)
        {
            sg_block_next_addr += sizeof(ASC_SG_BLOCK);
            sg_block_physical_addr += sizeof(ASC_SG_BLOCK);
        } else
        {   /* crossing page boundary */
            sg_block_next_addr = sg_block_page_boundary;
            sg_list_len = ADV_SG_LIST_MAX_BYTE_SIZE;
            sg_block_physical_addr = (ulong)
              DvcGetPhyAddr(asc_dvc, scsiq,
                  (uchar dosfar *) sg_block_next_addr, &sg_list_len,
                  ADV_IS_SGLIST_FLAG);
            ADV_ASSERT(ADV_DWALIGN(sg_block_physical_addr) ==
                       sg_block_physical_addr);
            if (sg_list_len < sizeof(ASC_SG_BLOCK))
            {
                /* The caller should always provide enough contiguous memory. */
                ADV_ASSERT(0);
                return ADV_ERROR;
            }
        }
        sg_block_index += NO_OF_SG_PER_BLOCK;
        sg_block->sg_ptr = (ASC_SG_BLOCK dosfar *) sg_block_physical_addr;
        sg_block->last_entry_no = sg_block_index - 1;
        sg_block = (ASC_SG_BLOCK *) sg_block_next_addr; /* virtual addr */
    }
    while (1);
    /* NOTREACHED */
}
#endif /* ADV_GETSGLIST */

#ifndef ADV_OS_BIOS
/*
 * Adv Library Interrupt Service Routine
 *
 *  This function is called by a driver's interrupt service routine.
 *  The function disables and re-enables interrupts.
 *
 *  When a microcode idle command is completed, the ASC_DVC_VAR
 *  'idle_cmd_done' field is set to ADV_TRUE.
 *
 *  Note: AdvISR() can be called when interrupts are disabled or even
 *  when there is no hardware interrupt condition present. It will
 *  always check for completed idle commands and microcode requests.
 *  This is an important feature that shoudln't be changed because it
 *  allows commands to be completed from polling mode loops.
 *
 * Return:
 *   ADV_TRUE(1) - interrupt was pending
 *   ADV_FALSE(0) - no interrupt was pending
 */
int
AdvISR(ASC_DVC_VAR WinBiosFar *asc_dvc)
{
    PortAddr                    iop_base;
    uchar                       int_stat;
    ushort                      next_done_loc, target_bit;
    int                         completed_q;
#if ADV_CRITICAL
    int                         flags;
#endif /* ADV_CRITICAL */
    ASC_SCSI_REQ_Q dosfar       *scsiq;
    ASC_REQ_SENSE dosfar        *sense_data;
    int                         ret;
#if ADV_INITSCSITARGET
    int                         retry;
    uchar                       sense_key, sense_code;
#endif /* ADV_INITSCSITARGET */

#if ADV_CRITICAL
    flags = DvcEnterCritical();
#endif /* ADV_CRITICAL */

    iop_base = asc_dvc->iop_base;

    if (AdvIsIntPending(iop_base))
    {
        ret = ADV_TRUE;
    } else
    {
        ret = ADV_FALSE;
    }

    /* Reading the register clears the interrupt. */
    int_stat = AscReadByteRegister(iop_base, IOPB_INTR_STATUS_REG);

    if (int_stat & ADV_INTR_STATUS_INTRB)
    {
        asc_dvc->idle_cmd_done = ADV_TRUE;
    }

    /*
     * Notify the driver of a hardware detected SCSI Bus Reset.
     */
    if (int_stat & ADV_INTR_STATUS_INTRC)
    {
        if (asc_dvc->sbreset_callback != 0)
        {
            (*(ASC_SBRESET_CALLBACK) asc_dvc->sbreset_callback)(asc_dvc);
        }
    }

    /*
     * ASC_MC_HOST_NEXT_DONE (0x129) is actually the last completed RISC
     * Queue List request. Its forward pointer (RQL_FWD) points to the
     * current completed RISC Queue List request.
     */
    next_done_loc = ASC_MC_RISC_Q_LIST_BASE +
        (AscReadByteLram(iop_base, ASC_MC_HOST_NEXT_DONE) *
            ASC_MC_RISC_Q_LIST_SIZE) + RQL_FWD;

    completed_q = AscReadByteLram(iop_base, next_done_loc);

    /* Loop until all completed Q's are processed. */
    while (completed_q != ASC_MC_NULL_Q)
    {
        AscWriteByteLram(iop_base, ASC_MC_HOST_NEXT_DONE, completed_q);

        next_done_loc = ASC_MC_RISC_Q_LIST_BASE +
            (completed_q * ASC_MC_RISC_Q_LIST_SIZE);

        /*
         * Read the ASC_SCSI_REQ_Q virtual address pointer from
         * the RISC list entry. The microcode has changed the
         * ASC_SCSI_REQ_Q physical address to its virtual address.
         *
         * Refer to comments at the end of AscSendScsiCmd() for
         * more information on the RISC list structure.
         */
        {
            ushort lsw, msw;
            lsw = AscReadWordLram(iop_base, next_done_loc + RQL_PHYADDR);
            msw = AscReadWordLram(iop_base, next_done_loc + RQL_PHYADDR + 2);
#if ADV_BIG_ENDIAN
            scsiq = (ASC_SCSI_REQ_Q dosfar *)
                EndianSwap32Bit((((ulong) msw << 16) | lsw));
#else /* ADV_BIG_ENDIAN */
            scsiq = (ASC_SCSI_REQ_Q dosfar *) (((ulong) msw << 16) | lsw);
#endif /* ADV_BIG_ENDIAN */
        }
#if ADV_BIG_ENDIAN
        AdvAdjEndianScsiQ(scsiq);
        /*
         * Warning: The four fields in the scsiq structure data_addr,
         * data_cnt, sense_addr and srb_ptr have been changed to little
         * endian ordering.
         */
#endif /* ADV_BIG_ENDIAN */

        ADV_ASSERT(scsiq != NULL);
        target_bit = ADV_TID_TO_TIDMASK(scsiq->target_id);

#if ADV_INITSCSITARGET
        retry = ADV_FALSE;
#endif /* ADV_INITSCSITARGET */

        /*
         * Clear request microcode control flag.
         */
        scsiq->cntl = 0;

        /*
         * Check Condition handling
         */
        if ((scsiq->done_status == QD_WITH_ERROR) &&
            (scsiq->scsi_status == SS_CHK_CONDITION) &&
            (sense_data = (ASC_REQ_SENSE dosfar *) scsiq->vsense_addr) != 0 &&
            (scsiq->orig_sense_len - scsiq->sense_len) >= ASC_MIN_SENSE_LEN)
        {
#if ADV_INITSCSITARGET
            sense_key = sense_data->sense_key;
            sense_code = sense_data->asc;
            switch(sense_key)
            {
                case SCSI_SENKEY_ATTENTION:
                    if (sense_code == SCSI_ASC_POWERUP)
                    {
                        retry = ADV_TRUE;
                    }
                    break;

                case SCSI_SENKEY_NOT_READY:
                    if ((sense_code == SCSI_ASC_NOTRDY) &&
                        (sense_data->ascq == SCSI_ASCQ_COMINGRDY))
                    {
                        /*
                         * If the device is "Coming Ready",
                         * then don't decrement 'error_retry'
                         * to try the command indefinitely.
                         */
                        retry = ADV_TRUE;
                    } else
                    {
                        if (sense_code != SCSI_ASC_NOMEDIA)
                        {
                            /*
                             * Perform at most one Start Motor command
                             * by checking whether 'error_retry' is at
                             * SCSI_MAX_RETRY.
                             *
                             * Note: One retry is burned here whether
                             * or not a Start Motor is done.
                             */
                            if ((scsiq->error_retry == SCSI_MAX_RETRY) &&
                                (asc_dvc->start_motor & target_bit))
                            {
                                scsiq->cntl |= ASC_MC_QC_START_MOTOR;
                            }
                            if (scsiq->error_retry > 0)
                            {
                                scsiq->error_retry--;
                                retry = ADV_TRUE;
                            }
                        }
                    }
                    break;

                case SCSI_SENKEY_MEDIUM_ERR:
                case SCSI_SENKEY_HW_ERR:
                    if (scsiq->error_retry > 0)
                    {
                        scsiq->error_retry--;
                        retry = ADV_TRUE;
                    }
                    break;

                case SCSI_SENKEY_NO_SENSE:
                case SCSI_SENKEY_BLANK:
                default:
                    /*
                     * Don't retry if the Sense Data has no Sense Key
                     * and the Sense Key is Blank Check.
                     */
                    break;
            } /* switch */
#endif /* ADV_INITSCSITARGET */
        }
        /*
         * If the command that completed was a SCSI INQUIRY and
         * LUN 0 was sent the command, then process the INQUIRY
         * command information for the device.
         */
        else if (scsiq->done_status == QD_NO_ERROR &&
                 scsiq->cdb[0] == SCSICMD_Inquiry &&
                 scsiq->target_lun == 0)
        {
            AdvInquiryHandling(asc_dvc, scsiq);
        }

        /* Change the RISC Queue List state to free. */
        AscWriteByteLram(iop_base, next_done_loc + RQL_STATE, ASC_MC_QS_FREE);

        /* Get the RISC Queue List forward pointer. */
        completed_q = AscReadByteLram(iop_base, next_done_loc + RQL_FWD);

#if ADV_INITSCSITARGET == 0
        /*
         * Notify the driver of the completed request by passing
         * the ASC_SCSI_REQ_Q pointer to its callback function.
         */
        ADV_ASSERT(asc_dvc->cur_host_qng > 0);
        asc_dvc->cur_host_qng--;
        scsiq->a_flag |= ADV_SCSIQ_DONE;
        (*(ASC_ISR_CALLBACK) asc_dvc->isr_callback)(asc_dvc, scsiq);
        /*
         * Note: After the driver callback function is called, 'scsiq'
         * can no longer be referenced.
         *
         * Fall through and continue processing other completed
         * requests...
         */
#else /* ADV_INITSCSITARGET == 0 */
        /*
         * Don't retry the command if driver sets ADV_DONT_RETRY flag
         * in the ASC_SCSI_REQ_Q 'a_flag' field.
         */
        if ((scsiq->a_flag & ADV_DONT_RETRY) == 0 && retry)
        {
            /*
             * The request needs to be retried.
             *
             * Depending on the ADV_POLL_REQUEST flag either return
             * QD_DO_RETRY status to the caller or retry the request.
             */
            if (scsiq->a_flag & ADV_POLL_REQUEST)
            {
                /*
                 * If ADV_POLL_REQUEST is set, the caller does not have an
                 * interrupt handler installed and is calling AdvISR()
                 * directly when it detects that an interrupt is pending,
                 * cf. AscScsiUrgentCmd().
                 *
                 * The caller is checking for 'scsiq' completion by polling
                 * the 'a_flag' field for the 'ADV_SCSIQ_DONE' flag and is
                 * responsible for retrying commands. After completion the
                 * caller must check scsiq 'done_status' for QD_DO_RETRY to
                 * determine whether the command should be re-issued.
                 */
                ADV_ASSERT(asc_dvc->cur_host_qng > 0);
                asc_dvc->cur_host_qng--;
                scsiq->a_flag |= ADV_SCSIQ_DONE;
                scsiq->done_status = QD_DO_RETRY;

               /*
                * Fall through and continue processing other completed
                * requests...
                */
            } else
            {
                /*
                 * If ADV_POLL_REQUEST is not set, then the caller has set
                 * an interrupt handler and is waiting for the request
                 * to completed via an interrupt. The caller is checking
                 * for the 'scsiq' completion by polling the 'a_flag' field
                 * for the 'ADV_SCSIQ_DONE' flag.
                 */
                ADV_ASSERT(asc_dvc->cur_host_qng > 0);
                asc_dvc->cur_host_qng--;

                /*
                 * Before re-issuing the command, restore the original
                 * data and sense buffer length and reset all status.
                 */
                scsiq->data_cnt = scsiq->orig_data_cnt;
                scsiq->sense_len = scsiq->orig_sense_len;
                scsiq->done_status = QD_DO_RETRY;
                scsiq->host_status = 0;
                scsiq->scsi_status = 0;

                /*
                 * If the command is re-issued successfully, then
                 * don't set 'a_flag' or 'done_status' yet for the 'scsiq'.
                 */
                if (AdvExeScsiQueue(asc_dvc, scsiq) != ADV_SUCCESS)
                {
                    /*
                     * Error re-issuing the command. Complete the 'scsiq'
                     * with an error in 'done_status'.
                     */
                    scsiq->a_flag |= ADV_SCSIQ_DONE;
                    scsiq->done_status = QD_WITH_ERROR;
                    if (asc_dvc->isr_callback != 0)
                    {
                        (*(ASC_ISR_CALLBACK)
                            asc_dvc->isr_callback)(asc_dvc, scsiq);
                    }
                    /*
                     * Note: After the driver callback function is called,
                     * 'scsiq' can no longer be referenced.
                     */
                }

                /*
                 * Fall through and continue processing other completed
                 * requests...
                 */
            }
        } else
        {
            ADV_ASSERT(asc_dvc->cur_host_qng > 0);
            asc_dvc->cur_host_qng--;
            scsiq->a_flag |= ADV_SCSIQ_DONE;
            if ((scsiq->a_flag & ADV_POLL_REQUEST) == 0 &&
                asc_dvc->isr_callback != 0)
            {
                (*(ASC_ISR_CALLBACK) asc_dvc->isr_callback)(asc_dvc, scsiq);
            }
            /*
             * Note: After the driver callback function is called, 'scsiq'
             * can no longer be referenced.
             *
             * Fall through and continue processing other completed
             * requests...
             */
        }
#endif /* ADV_INITSCSITARGET == 0 */
#if ADV_CRITICAL
        /*
         * Disable interrupts again in case the driver inadvertenly
         * enabled interrupts in its callback function.
         *
         * The DvcEnterCritical() return value is ignored, because
         * the 'flags' saved when AdvISR() was first entered will be
         * used to restore the interrupt flag on exit.
         */
        (void) DvcEnterCritical();
#endif /* ADV_CRITICAL */
    }
#if ADV_CRITICAL
    DvcLeaveCritical(flags);
#endif /* ADV_CRITICAL */
    return ret;
}

/*
 * Send an idle command to the chip and wait for completion.
 *
 * Interrupts do not have to be enabled on entry.
 *
 * Return Values:
 *   ADV_TRUE - command completed successfully
 *   ADV_FALSE - command failed
 */
int
AscSendIdleCmd(ASC_DVC_VAR WinBiosFar *asc_dvc,
               ushort idle_cmd,
               ulong idle_cmd_parameter,
               int flags)
{
#if ADV_CRITICAL
    int         last_int_level;
#endif /* ADV_CRITICAL */
    ulong       i;
    PortAddr    iop_base;

    asc_dvc->idle_cmd_done = 0;

#if ADV_CRITICAL
    last_int_level = DvcEnterCritical();
#endif /* ADV_CRITICAL */
    iop_base = asc_dvc->iop_base;

    /*
     * Write the idle command value after the idle command parameter
     * has been written to avoid a race condition. If the order is not
     * followed, the microcode may process the idle command before the
     * parameters have been written to LRAM.
     */
    AscWriteDWordLram(iop_base, ASC_MC_IDLE_PARA_STAT, idle_cmd_parameter);
    AscWriteWordLram(iop_base, ASC_MC_IDLE_CMD, idle_cmd);
#if ADV_CRITICAL
    DvcLeaveCritical(last_int_level);
#endif /* ADV_CRITICAL */

    /*
     * If the 'flags' argument contains the ADV_NOWAIT flag, then
     * return with success.
     */
    if (flags & ADV_NOWAIT)
    {
        return ADV_TRUE;
    }
    for (i = 0; i < SCSI_WAIT_10_SEC * SCSI_MS_PER_SEC; i++)
    {
        /*
         * 'idle_cmd_done' is set by AdvISR().
         */
        if (asc_dvc->idle_cmd_done)
        {
            break;
        }
        DvcSleepMilliSecond(1);

        /*
         * If interrupts were disabled on entry to AscSendIdleCmd(),
         * then they will still be disabled here. Call AdvISR() to
         * check for the idle command completion.
         */
        (void) AdvISR(asc_dvc);
    }

#if ADV_CRITICAL
    last_int_level = DvcEnterCritical();
#endif /* ADV_CRITICAL */

    if (asc_dvc->idle_cmd_done == ADV_FALSE)
    {
        ADV_ASSERT(0); /* The idle command should never timeout. */
        return ADV_FALSE;
    } else
    {
        return AscReadWordLram(iop_base, ASC_MC_IDLE_PARA_STAT);
    }
}

/*
 * Send the SCSI request block to the adapter
 *
 * Each of the 255 Adv Library/Microcode RISC Lists or mailboxes has the
 * following structure:
 *
 * 0: RQL_FWD - RISC list forward pointer (1 byte)
 * 1: RQL_BWD - RISC list backward pointer (1 byte)
 * 2: RQL_STATE - RISC list state byte - free, ready, done, aborted (1 byte)
 * 3: RQL_TID - request target id (1 byte)
 * 4: RQL_PHYADDR - ASC_SCSI_REQ_Q physical pointer (4 bytes)
 *
 * Return:
 *      ADV_SUCCESS(1) - the request is in the mailbox
 *      ADV_BUSY(0) - total request count > 253, try later
 */
int
AscSendScsiCmd(
    ASC_DVC_VAR WinBiosFar *asc_dvc,
    ASC_SCSI_REQ_Q dosfar  *scsiq)
{
    ushort                 next_ready_loc;
    uchar                  next_ready_loc_fwd;
#if ADV_CRITICAL
    int                    last_int_level;
#endif /* ADV_CRITICAL */
    PortAddr               iop_base;
    long                   req_size;
    ulong                  q_phy_addr;

    /*
     * The ASC_SCSI_REQ_Q 'target_id' field should never be equal
     * to the host adapter ID or exceed ASC_MAX_TID.
     */
    if ((scsiq->target_id == asc_dvc->chip_scsi_id)
        ||  scsiq->target_id > ASC_MAX_TID)
    {
        scsiq->host_status = QHSTA_M_INVALID_DEVICE;
        scsiq->done_status = QD_WITH_ERROR;
        return ADV_ERROR;
    }

    iop_base = asc_dvc->iop_base;

#if ADV_CRITICAL
    last_int_level = DvcEnterCritical();
#endif /* ADV_CRITICAL */

    if (asc_dvc->cur_host_qng >= asc_dvc->max_host_qng)
    {
#if ADV_CRITICAL
        DvcLeaveCritical(last_int_level);
#endif /* ADV_CRITICAL */
        return ADV_BUSY;
    } else
    {
        ADV_ASSERT(asc_dvc->cur_host_qng < ASC_MC_RISC_Q_TOTAL_CNT);
        asc_dvc->cur_host_qng++;
    }

    /*
     * Clear the ASC_SCSI_REQ_Q done flag.
     */
    scsiq->a_flag &= ~ADV_SCSIQ_DONE;

#if ADV_INITSCSITARGET
    /*
     * Save the original data buffer length for re-issuing the command
     * in the AdvISR().
     */
    scsiq->orig_data_cnt = scsiq->data_cnt;
#endif /* ADV_INITSCSITARGET */

    /*
     * Save the original sense buffer length.
     *
     * After the request completes 'sense_len' will be set to the residual
     * byte count of the Auto-Request Sense if a command returns CHECK
     * CONDITION and the Sense Data is valid indicated by 'host_status' not
     * being set to QHSTA_M_AUTO_REQ_SENSE_FAIL. To determine the valid
     * Sense Data Length subtract 'sense_len' from 'orig_sense_len'.
     */
    scsiq->orig_sense_len = scsiq->sense_len;

    next_ready_loc = ASC_MC_RISC_Q_LIST_BASE +
        (AscReadByteLram(iop_base, ASC_MC_HOST_NEXT_READY) *
            ASC_MC_RISC_Q_LIST_SIZE);

    /*
     * Write the physical address of the Q to the mailbox.
     * We need to skip the first four bytes, because the microcode
     * uses them internally for linking Q's together.
     */
    req_size = sizeof(ASC_SCSI_REQ_Q);
    q_phy_addr = DvcGetPhyAddr(asc_dvc, scsiq,
        (uchar dosfar *) scsiq, &req_size, ADV_IS_SCSIQ_FLAG);

    ADV_ASSERT(ADV_DWALIGN(q_phy_addr) == q_phy_addr);
    ADV_ASSERT(req_size >= sizeof(ASC_SCSI_REQ_Q));

    scsiq->scsiq_ptr = (ASC_SCSI_REQ_Q dosfar *) scsiq;

#if ADV_BIG_ENDIAN
    AdvAdjEndianScsiQ(scsiq);
    /*
     * Warning: The four fields in the scsiq structure data_addr,
     * data_cnt, sense_addr and srb_ptr have been changed to little
     * endian ordering.
     */
#endif /* ADV_BIG_ENDIAN */

    /*
     * The RISC list structure, which 'next_ready_loc' is a pointer
     * to in microcode LRAM, has the format detailed in the comment
     * header for this function.
     *
     * Write the ASC_SCSI_REQ_Q physical pointer to 'next_ready_loc' request.
     */
    AscWriteDWordLram(iop_base, next_ready_loc + RQL_PHYADDR, q_phy_addr);

    /* Write target_id to 'next_ready_loc' request. */
    AscWriteByteLram(iop_base, next_ready_loc + RQL_TID, scsiq->target_id);

    /*
     * Set the ASC_MC_HOST_NEXT_READY (0x128) microcode variable to
     * the 'next_ready_loc' request forward pointer.
     *
     * Do this *before* changing the 'next_ready_loc' queue to QS_READY.
     * After the state is changed to QS_READY 'RQL_FWD' will be changed
     * by the microcode.
     *
     * NOTE: The temporary variable 'next_ready_loc_fwd' is required to
     * prevent some compilers from optimizing out 'AscReadByteLram()' if
     * it were used as the 3rd argument to 'AscWriteByteLram()'.
     */
    next_ready_loc_fwd = AscReadByteLram(iop_base, next_ready_loc + RQL_FWD);
    AscWriteByteLram(iop_base, ASC_MC_HOST_NEXT_READY, next_ready_loc_fwd);

    /*
     * Change the state of 'next_ready_loc' request from QS_FREE to
     * QS_READY which will cause the microcode to pick it up and
     * execute it.
     *
     * Can't reference 'next_ready_loc' after changing the request
     * state to QS_READY. The microcode now owns the request.
     */
    AscWriteByteLram(iop_base, next_ready_loc + RQL_STATE, ASC_MC_QS_READY);

#if ADV_CRITICAL
    DvcLeaveCritical(last_int_level);
#endif /* ADV_CRITICAL */

    return ADV_SUCCESS;
}
#endif /* ADV_OS_BIOS */

/*
 * Inquiry Information Byte 7 Handling
 *
 * Handle SCSI Inquiry Command information for a device by setting
 * microcode operating variables that affect WDTR, SDTR, and Tag
 * Queuing.
 */
void
AdvInquiryHandling(
    ASC_DVC_VAR WinBiosFar      *asc_dvc,
    ASC_SCSI_REQ_Q dosfar       *scsiq)
{
    PortAddr                    iop_base;
    uchar                       tid;
    ASC_SCSI_INQUIRY dosfar    *inq;
    ushort                      tidmask;
    ushort                      cfg_word;

     /*
     * AdvInquiryHandling() requires up to INQUIRY information Byte 7
     * to be available.
     *
     * If less than 8 bytes of INQUIRY information were requested or less
     * than 8 bytes were transferred, then return. cdb[4] is the request
     * length and the ASC_SCSI_REQ_Q 'data_cnt' field is set by the
     * microcode to the transfer residual count.
     */

    if (scsiq->cdb[4] < 8 || (scsiq->cdb[4] - scsiq->data_cnt) < 8)
    {
        return;
    }

    iop_base = asc_dvc->iop_base;
    tid = scsiq->target_id;

    inq = (ASC_SCSI_INQUIRY dosfar *) scsiq->vdata_addr;

    /*
     * WDTR, SDTR, and Tag Queuing cannot be enabled for old devices.
     */
    if (inq->rsp_data_fmt < 2 && inq->ansi_apr_ver < 2)
    {
        return;
    } else
    {
        /*
         * INQUIRY Byte 7 Handling
         *
         * Use a device's INQUIRY byte 7 to determine whether it
         * supports WDTR, SDTR, and Tag Queuing. If the feature
         * is enabled in the EEPROM and the device supports the
         * feature, then enable it in the microcode.
         */

        tidmask = ADV_TID_TO_TIDMASK(tid);

        /*
         * Wide Transfers
         *
         * If the EEPROM enabled WDTR for the device and the device
         * supports wide bus (16 bit) transfers, then turn on the
         * device's 'wdtr_able' bit and write the new value to the
         * microcode.
         */
        if ((asc_dvc->wdtr_able & tidmask) && inq->WBus16)
        {
            cfg_word = AscReadWordLram(iop_base, ASC_MC_WDTR_ABLE);
            if ((cfg_word & tidmask) == 0)
            {
                cfg_word |= tidmask;
                AscWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, cfg_word);

                /*
                 * Clear the microcode "WDTR negotiation" done indicator
                 * for the target to cause it to negotiate with the new
                 * setting set above.
                 */
                cfg_word = AscReadWordLram(iop_base, ASC_MC_WDTR_DONE);
                cfg_word &= ~tidmask;
                AscWriteWordLram(iop_base, ASC_MC_WDTR_DONE, cfg_word);
            }
        }

        /*
         * Synchronous Transfers
         *
         * If the EEPROM enabled SDTR for the device and the device
         * supports synchronous transfers, then turn on the device's
         * 'sdtr_able' bit. Write the new value to the microcode.
         */
        if ((asc_dvc->sdtr_able & tidmask) && inq->Sync)
        {
            cfg_word = AscReadWordLram(iop_base, ASC_MC_SDTR_ABLE);
            if ((cfg_word & tidmask) == 0)
            {
                cfg_word |= tidmask;
                AscWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, cfg_word);

                /*
                 * Clear the microcode "SDTR negotiation" done indicator
                 * for the target to cause it to negotiate with the new
                 * setting set above.
                 */
                cfg_word = AscReadWordLram(iop_base, ASC_MC_SDTR_DONE);
                cfg_word &= ~tidmask;
                AscWriteWordLram(iop_base, ASC_MC_SDTR_DONE, cfg_word);
            }
        }

#ifndef ADV_OS_BIOS
        /*
         * If the EEPROM enabled Tag Queuing for device and the
         * device supports Tag Queueing, then turn on the device's
         * 'tagqng_enable' bit in the microcode and set the microcode
         * maximum command count to the ASC_DVC_VAR 'max_dvc_qng'
         * value.
         *
         * Tag Queuing is disabled for the BIOS which runs in polled
         * mode and would see no benefit from Tag Queuing. Also by
         * disabling Tag Queuing in the BIOS devices with Tag Queuing
         * bugs will at least work with the BIOS.
         */
        if ((asc_dvc->tagqng_able & tidmask) && inq->CmdQue)
        {
            cfg_word = AscReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE);
            cfg_word |= tidmask;
            AscWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE, cfg_word);

            AscWriteByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,
                asc_dvc->max_dvc_qng);
        }
#endif /* ADV_OS_BIOS */
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc3550\a_advlib.h ===
/*
 * a_advlib.h - Main Adv Library Include File
 *
 * Copyright (c) 1997-1998 Advanced System Products, Inc.
 * All Rights Reserved.
 */

#ifndef __A_ADVLIB_H_
#define __A_ADVLIB_H_

/*
 * Adv Library Compile-Time Options
 *
 * Drivers must explicity define the following options to
 * 1 or 0 in in d_os_dep.h.
 *
 * The Adv Library also contains source code which is conditional
 * on the ADV_OS_* definition in d_os_dep.h.
 */

/* ADV_DISP_INQUIRY - include AscDispInquiry() function */
#if !defined(ADV_DISP_INQUIRY) || \
    (ADV_DISP_INQUIRY != 1 && ADV_DISP_INQUIRY != 0)
Forced Error: Driver must define ADV_DISP_INQUIRY to 1 or 0.
#endif /* ADV_DISP_INQUIRY */

/* ADV_GETSGLIST - include AscGetSGList() function */
#if !defined(ADV_GETSGLIST) || (ADV_GETSGLIST != 1 && ADV_GETSGLIST != 0)
Forced Error: Driver must define ADV_GETSGLIST to 1 or 0.
#endif /* ADV_GETSGLIST */

/* ADV_INITSCSITARGET - include AdvInitScsiTarget() function */
#if !defined(ADV_INITSCSITARGET) || \
    (ADV_INITSCSITARGET != 1 && ADV_INITSCSITARGET != 0)
Forced Error: Driver must define ADV_INITSCSITARGET to 1 or 0.
#endif /* ADV_INITSCSITARGET */

/*
 * ADV_PCI_MEMORY
 *
 * Only use PCI Memory accesses to read/write Condor registers. The
 * driver must set the ASC_DVC_VAR 'mem_base' field during initialization
 * to the mapped virtual address of Condor's registers.
 */
#if !defined(ADV_PCI_MEMORY) || (ADV_PCI_MEMORY != 1 && ADV_PCI_MEMORY != 0)
Forced Error: Driver must define ADV_PCI_MEMORY to 1 or 0.
#endif /* ADV_PCI_MEMORY */

/*
 * ADV_SCAM
 *
 * The SCAM function is not currently utilized and probably won't
 * be in the future. Leave a place holder here for it.
 */
#define ADV_SCAM        0
#if !defined(ADV_SCAM) || (ADV_SCAM != 1 && ADV_SCAM != 0)
Forced Error: Driver must define ADV_SCAM to 1 or 0.
#endif /* ADV_SCAM */

/*
 * ADV_CRITICAL
 *
 * If set to 1, driver supplies DvcEnterCritical() and DvcLeaveCritical()
 * functions. If set to 0, the driver guarantees that whenever it calls
 * Adv Library functions interrupts are disabled.
 */
#if !defined(ADV_CRITICAL) || (ADV_CRITICAL != 1 && ADV_CRITICAL != 0)
Forced Error: Driver must define ADV_CRITICAL to 1 or 0.
#endif /* ADV_CRITICAL */

/*
 * ADV_UCODEDEFAULT
 *
 * If ADV_UCODEDEFAULT is defined to 1 then certain microcode
 * operating variable default values are overridden, cf.
 * a_init.c:AdvInitAsc3550Driver().
 *
 * Only set this to 0 if the driver or BIOS needs to save space.
 */
#if !defined(ADV_UCODEDEFAULT) || (ADV_UCODEDEFAULT != 1 && ADV_UCODEDEFAULT != 0)
Forced Error: Driver must define ADV_UCODEDEFAULT to 1 or 0.
#endif /* ADV_UCODEDEFAULT */

/*
 * ADV_BIG_ENDIAN
 *
 * Choose to use big endian data orientation or little endian
 * data orientation. Currently Mac is the only OS using big
 * endian data orientation.
 */
#if !defined(ADV_BIG_ENDIAN) || (ADV_BIG_ENDIAN != 1 && ADV_BIG_ENDIAN != 0)
Forced Error: Driver must define ADV_BIG_ENDIAN to 1 or 0.
#endif /* ADV_BIG_ENDIAN */

/*
 * Adv Library Status Definitions
 */
#define ADV_TRUE        1
#define ADV_FALSE       0
#define ADV_NOERROR     1
#define ADV_SUCCESS     1
#define ADV_BUSY        0
#define ADV_ERROR       (-1)


/*
 * ASC_DVC_VAR 'warn_code' values
 */
#define ASC_WARN_EEPROM_CHKSUM          0x0002 /* EEP check sum error */
#define ASC_WARN_EEPROM_TERMINATION     0x0004 /* EEP termination bad field */
#define ASC_WARN_SET_PCI_CONFIG_SPACE   0x0080 /* PCI config space set error */
#define ASC_WARN_ERROR                  0xFFFF /* ADV_ERROR return */

#define ASC_MAX_TID                     15 /* max. target identifier */
#define ASC_MAX_LUN                     7  /* max. logical unit number */

#if ADV_INITSCSITARGET
/*
 * AscInitScsiTarget() structure definitions.
 */
typedef struct asc_dvc_inq_info
{
  uchar type[ASC_MAX_TID+1][ASC_MAX_LUN+1];
} ASC_DVC_INQ_INFO;

typedef struct asc_cap_info
{
  ulong lba;       /* the maximum logical block size */
  ulong blk_size;  /* the logical block size in bytes */
} ASC_CAP_INFO;

typedef struct asc_cap_info_array
{
  ASC_CAP_INFO  cap_info[ASC_MAX_TID+1][ASC_MAX_LUN+1];
} ASC_CAP_INFO_ARRAY;
#endif /* ADV_INITSCSITARGET */


/*
 * AscInitGetConfig() and AscInitAsc1000Driver() Definitions
 *
 * Error code values are set in ASC_DVC_VAR 'err_code'.
 */
#define ASC_IERR_WRITE_EEPROM       0x0001 /* write EEPROM error */
#define ASC_IERR_MCODE_CHKSUM       0x0002 /* micro code check sum error */
#define ASC_IERR_START_STOP_CHIP    0x0008 /* start/stop chip failed */
#define ASC_IERR_CHIP_VERSION       0x0040 /* wrong chip version */
#define ASC_IERR_SET_SCSI_ID        0x0080 /* set SCSI ID failed */
#define ASC_IERR_BAD_SIGNATURE      0x0200 /* signature not found */
#define ASC_IERR_ILLEGAL_CONNECTION 0x0400 /* Illegal cable connection */
#define ASC_IERR_SINGLE_END_DEVICE  0x0800 /* Single-end used w/differential */
#define ASC_IERR_REVERSED_CABLE     0x1000 /* Narrow flat cable reversed */
#define ASC_IERR_RW_LRAM            0x8000 /* read/write local RAM error */

/*
 * Fixed locations of microcode operating variables.
 */
#define ASC_MC_CODE_BEGIN_ADDR          0x0028 /* microcode start address */
#define ASC_MC_CODE_END_ADDR            0x002A /* microcode end address */
#define ASC_MC_CODE_CHK_SUM             0x002C /* microcode code checksum */
#define ASC_MC_STACK_BEGIN              0x002E /* microcode stack begin */
#define ASC_MC_STACK_END                0x0030 /* microcode stack end */
#define ASC_MC_VERSION_DATE             0x0038 /* microcode version */
#define ASC_MC_VERSION_NUM              0x003A /* microcode number */
#define ASCV_VER_SERIAL_W               0x003C /* used in dos_init */
#define ASC_MC_BIOSMEM                  0x0040 /* BIOS RISC Memory Start */
#define ASC_MC_BIOSLEN                  0x0050 /* BIOS RISC Memory Length */
#define ASC_MC_HALTCODE                 0x0094 /* microcode halt code */
#define ASC_MC_CALLERPC                 0x0096 /* microcode halt caller PC */
#define ASC_MC_ADAPTER_SCSI_ID          0x0098 /* one ID byte + reserved */
#define ASC_MC_ULTRA_ABLE               0x009C
#define ASC_MC_SDTR_ABLE                0x009E
#define ASC_MC_TAGQNG_ABLE              0x00A0
#define ASC_MC_DISC_ENABLE              0x00A2
#define ASC_MC_IDLE_CMD                 0x00A6
#define ASC_MC_IDLE_PARA_STAT           0x00A8
#define ASC_MC_DEFAULT_SCSI_CFG0        0x00AC
#define ASC_MC_DEFAULT_SCSI_CFG1        0x00AE
#define ASC_MC_DEFAULT_MEM_CFG          0x00B0
#define ASC_MC_DEFAULT_SEL_MASK         0x00B2
#define ASC_MC_RISC_NEXT_READY          0x00B4
#define ASC_MC_RISC_NEXT_DONE           0x00B5
#define ASC_MC_SDTR_DONE                0x00B6
#define ASC_MC_NUMBER_OF_MAX_CMD        0x00D0
#define ASC_MC_DEVICE_HSHK_CFG_TABLE    0x0100
#define ASC_MC_WDTR_ABLE                0x0120 /* Wide Transfer TID bitmask. */
#define ASC_MC_CONTROL_FLAG             0x0122 /* Microcode control flag. */
#define ASC_MC_WDTR_DONE                0x0124
#define ASC_MC_HOST_NEXT_READY          0x0128 /* Host Next Ready RQL Entry. */
#define ASC_MC_HOST_NEXT_DONE           0x0129 /* Host Next Done RQL Entry. */

/*
 * Microcode Control Flags
 *
 * Flags set by the Adv Library in RISC variable 'control_flag' (0x122)
 * and handled by the microcode.
 */
#define CONTROL_FLAG_IGNORE_PERR        0x0001 /* Ignore DMA Parity Errors */

/*
 * ASC_MC_DEVICE_HSHK_CFG_TABLE microcode table or HSHK_CFG register format
 */
#define HSHK_CFG_WIDE_XFR       0x8000
#define HSHK_CFG_RATE           0x0F00
#define HSHK_CFG_OFFSET         0x001F

/*
 * LRAM RISC Queue Lists (LRAM addresses 0x1200 - 0x19FF)
 *
 * Each of the 255 Adv Library/Microcode RISC queue lists or mailboxes
 * starting at LRAM address 0x1200 is 8 bytes and has the following
 * structure. Only 253 of these are actually used for command queues.
 */

#define ASC_MC_RISC_Q_LIST_BASE         0x1200
#define ASC_MC_RISC_Q_LIST_SIZE         0x0008
#define ASC_MC_RISC_Q_TOTAL_CNT         0x00FF /* Num. queue slots in LRAM. */
#define ASC_MC_RISC_Q_FIRST             0x0001
#define ASC_MC_RISC_Q_LAST              0x00FF

#define ASC_DEF_MAX_HOST_QNG    0xFD /* Max. number of host commands (253) */
#define ASC_DEF_MIN_HOST_QNG    0x10 /* Min. number of host commands (16) */
#define ASC_DEF_MAX_DVC_QNG     0x3F /* Max. number commands per device (63) */
#define ASC_DEF_MIN_DVC_QNG     0x04 /* Min. number commands per device (4) */

/* RISC Queue List structure - 8 bytes */
#define RQL_FWD     0     /* forward pointer (1 byte) */
#define RQL_BWD     1     /* backward pointer (1 byte) */
#define RQL_STATE   2     /* state byte - free, ready, done, aborted (1 byte) */
#define RQL_TID     3     /* request target id (1 byte) */
#define RQL_PHYADDR 4     /* request physical pointer (4 bytes) */

/* RISC Queue List state values */
#define ASC_MC_QS_FREE                  0x00
#define ASC_MC_QS_READY                 0x01
#define ASC_MC_QS_DONE                  0x40
#define ASC_MC_QS_ABORTED               0x80

/* RISC Queue List pointer values */
#define ASC_MC_NULL_Q                   0x00            /* NULL_Q == 0   */
#define ASC_MC_BIOS_Q                   0xFF            /* BIOS_Q = 255  */

/* ASC_SCSI_REQ_Q 'cntl' field values */
#define ASC_MC_QC_START_MOTOR           0x02     /* Issue start motor. */
#define ASC_MC_QC_NO_OVERRUN            0x04     /* Don't report overrun. */
#define ASC_MC_QC_FIRST_DMA             0x08     /* Internal microcode flag. */
#define ASC_MC_QC_ABORTED               0x10     /* Request aborted by host. */
#define ASC_MC_QC_REQ_SENSE             0x20     /* Auto-Request Sense. */
#define ASC_MC_QC_DOS_REQ               0x80     /* Request issued by DOS. */


/*
 * ASC_SCSI_REQ_Q 'a_flag' definitions
 *
 * The Adv Library should limit use to the lower nibble (4 bits) of
 * a_flag. Drivers are free to use the upper nibble (4 bits) of a_flag.
 *
 * Note: ASPI uses the 0x04 definition and should change to 0x10.
 * Just check with ASPI before you really want to use 0x04 here.
 */
#define ADV_POLL_REQUEST                0x01   /* poll for request completion */
#define ADV_SCSIQ_DONE                  0x02   /* request done */
#define ADV_DONT_RETRY                  0x08   /* don't do retry */

/*
 * Adapter temporary configuration structure
 *
 * This structure can be discarded after initialization. Don't add
 * fields here needed after initialization.
 *
 * Field naming convention:
 *
 *  *_enable indicates the field enables or disables a feature. The
 *  value of the field is never reset.
 */
typedef struct asc_dvc_cfg {
  ushort disc_enable;       /* enable disconnection */
  uchar  chip_version;      /* chip version */
  uchar  termination;       /* Term. Ctrl. bits 6-5 of SCSI_CFG1 register */
  ushort pci_device_id;     /* PCI device code number */
  ushort lib_version;       /* Adv Library version number */
  ushort control_flag;      /* Microcode Control Flag */
  ushort mcode_date;        /* Microcode date */
  ushort mcode_version;     /* Microcode version */
  ushort pci_slot_info;     /* high byte device/function number */
                            /* bits 7-3 device num., bits 2-0 function num. */
                            /* low byte bus num. */
#ifdef ADV_OS_BIOS
  ushort bios_scan;         /* BIOS device scan bitmask. */
  ushort bios_delay;        /* BIOS boot time initialization delay. */
  uchar  bios_id_lun;       /* BIOS Boot TID and LUN */
#endif /* ADV_OS_BIOS */
} ASC_DVC_CFG;

/*
 * Adatper operation variable structure.
 *
 * One structure is required per host adapter.
 *
 * Field naming convention:
 *
 *  *_able indicates both whether a feature should be enabled or disabled
 *  and whether a device isi capable of the feature. At initialization
 *  this field may be set, but later if a device is found to be incapable
 *  of the feature, the field is cleared.
 */
typedef struct asc_dvc_var {
  PortAddr iop_base;      /* I/O port address */
  ushort err_code;        /* fatal error code */
  ushort bios_ctrl;       /* BIOS control word, EEPROM word 12 */
  Ptr2Func isr_callback;  /* pointer to function, called in AdvISR() */
  Ptr2Func sbreset_callback;  /* pointer to function, called in AdvISR() */
  ushort wdtr_able;       /* try WDTR for a device */
  ushort sdtr_able;       /* try SDTR for a device */
  ushort ultra_able;      /* try SDTR Ultra speed for a device */
  ushort tagqng_able;     /* try tagged queuing with a device */
  uchar  max_dvc_qng;     /* maximum number of tagged commands per device */
  ushort start_motor;     /* start motor command allowed */
  uchar  scsi_reset_wait; /* delay in seconds after scsi bus reset */
  uchar  chip_no;         /* should be assigned by caller */
  uchar  max_host_qng;    /* maximum number of Q'ed command allowed */
  uchar  cur_host_qng;    /* total number of queue command */
  uchar  irq_no;          /* IRQ number */
  ushort no_scam;         /* scam_tolerant of EEPROM */
  ushort idle_cmd_done;   /* microcode idle command done set by AdvISR() */
  ulong  drv_ptr;         /* driver pointer to private structure */
  uchar  chip_scsi_id;    /* chip SCSI target ID */
 /*
  * Note: The following fields will not be used after initialization. The
  * driver may discard the buffer after initialization is done.
  */
  ASC_DVC_CFG WinBiosFar *cfg; /* temporary configuration structure  */
} ASC_DVC_VAR;

#define NO_OF_SG_PER_BLOCK              15

typedef struct asc_sg_block {
#ifdef ADV_OS_DOS
    uchar dos_ix;                     /* index for DOS phy addr array */
#else /* ADV_OS_DOS */
    uchar reserved1;
#endif /* ADV_OS_DOS */
    uchar reserved2;
    uchar first_entry_no;             /* starting entry number */
    uchar last_entry_no;              /* last entry number */
    struct asc_sg_block dosfar *sg_ptr; /* links to the next sg block */
    struct  {
        ulong sg_addr;                /* SG element address */
        ulong sg_count;               /* SG element count */
    } sg_list[NO_OF_SG_PER_BLOCK];
} ASC_SG_BLOCK;

/*
 * ASC_SCSI_REQ_Q - microcode request structure
 *
 * All fields in this structure up to byte 60 are used by the microcode.
 * The microcode makes assumptions about the size and ordering of fields
 * in this structure. Do not change the structure definition here without
 * coordinating the change with the microcode.
 */
typedef struct asc_scsi_req_q {
    uchar       cntl;           /* Ucode flags and state (ASC_MC_QC_*). */
    uchar       sg_entry_cnt;   /* SG element count. Zero for no SG. */
    uchar       target_id;      /* Device target identifier. */
    uchar       target_lun;     /* Device target logical unit number. */
    ulong       data_addr;      /* Data buffer physical address. */
    ulong       data_cnt;       /* Data count. Ucode sets to residual. */
    ulong       sense_addr;     /* Sense buffer physical address. */
    ulong       srb_ptr;        /* Driver request pointer. */
    uchar       a_flag;         /* Adv Library flag field. */
    uchar       sense_len;      /* Auto-sense length. Ucode sets to residual. */
    uchar       cdb_len;        /* SCSI CDB length. */
    uchar       tag_code;       /* SCSI-2 Tag Queue Code: 00, 20-22. */
    uchar       done_status;    /* Completion status. */
    uchar       scsi_status;    /* SCSI status byte. */
    uchar       host_status;    /* Ucode host status. */
    uchar       ux_sg_ix;       /* Ucode working SG variable. */
    uchar       cdb[12];        /* SCSI command block. */
    ulong       sg_real_addr;   /* SG list physical address. */
    struct asc_scsi_req_q dosfar *free_scsiq_link;
    ulong       ux_wk_data_cnt; /* Saved data count at disconnection. */
    struct asc_scsi_req_q dosfar *scsiq_ptr;
    ASC_SG_BLOCK dosfar *sg_list_ptr; /* SG list virtual address. */
    /*
     * End of microcode structure - 60 bytes. The rest of the structure
     * is used by the Adv Library and ignored by the microcode.
     */
    ulong       vsense_addr;    /* Sense buffer virtual address. */
    ulong       vdata_addr;     /* Data buffer virtual address. */
#ifdef ADV_OS_DOS
    ushort      vm_id;          /* Used by DOS to track VM ID. */
    uchar       dos_ix;         /* Index for DOS phy addr array. */
#endif /* ADV_OS_DOS */
#if ADV_INITSCSITARGET
    uchar       error_retry;    /* Retry counter, used by AdvISR(). */
    ulong       orig_data_cnt;  /* Original length of data buffer. */
#endif /* ADV_INITSCSITARGET */
    uchar       orig_sense_len; /* Original length of sense buffer. */
#ifdef ADV_OS_DOS
    /*
     * Pad the structure for DOS to a doubleword (4 byte) boundary.
     * DOS ASPI allocates an array of these structures and only aligns
     * the first structure. To ensure that all following structures in
     * the array are doubleword (4 byte) aligned the structure for DOS
     * must be a multiple of 4 bytes.
     */
    uchar       reserved1;
    uchar       reserved2;
    uchar       reserved3;
#endif /* ADV_OS_DOS */
} ASC_SCSI_REQ_Q; /* BIOS - 74 bytes, DOS - 80 bytes, W95, WNT - 69 bytes */

/*
 * Microcode idle loop commands
 */
#define IDLE_CMD_COMPLETED           0
#define IDLE_CMD_STOP_CHIP           0x0001
#define IDLE_CMD_STOP_CHIP_SEND_INT  0x0002
#define IDLE_CMD_SEND_INT            0x0004
#define IDLE_CMD_ABORT               0x0008
#define IDLE_CMD_DEVICE_RESET        0x0010
#define IDLE_CMD_SCSI_RESET          0x0020

/*
 * AscSendIdleCmd() flag definitions.
 */
#define ADV_NOWAIT     0x01

/*
 * Wait loop time out values.
 */
#define SCSI_WAIT_10_SEC             10         /* 10 seconds */
#define SCSI_MS_PER_SEC              1000       /* milliseconds per second */
#define SCSI_MAX_RETRY               10         /* retry count */

#if ADV_PCI_MEMORY

#ifndef ADV_MEM_READB
Forced Error: Driver must define ADV_MEM_READB macro.
#endif /* ADV_MEM_READB */

#ifndef ADV_MEM_WRITEB
Forced Error: Driver must define ADV_MEM_WRITEB macro.
#endif /* ADV_MEM_WRITEB */

#ifndef ADV_MEM_READW
Forced Error: Driver must define ADV_MEM_READW macro.
#endif /* ADV_MEM_READW */

#ifndef ADV_MEM_WRITEW
Forced Error: Driver must define ADV_MEM_WRITEW macro.
#endif /* ADV_MEM_WRITEW */

#else /* ADV_PCI_MEMORY */

#ifndef ADV_OS_NETWARE
/*
 * Device drivers must define the following macros:
 *   inp, inpw, outp, outpw
 */
#ifndef inp
Forced Error: Driver must define inp macro.
#endif /* inp */

#ifndef inpw
Forced Error: Driver must define inpw macro.
#endif /* inpw */

#ifndef outp
Forced Error: Driver must define outp macro.
#endif /* outp */

#ifndef outpw
Forced Error: Driver must define outpw macro.
#endif /* outpw */
#endif /* ADV_OS_NETWARE */

#endif /* ADV_PCI_MEMORY */


/*
 * Device drivers must define the following functions that
 * are called by the Adv Library.
 */
extern int   DvcEnterCritical(void);
extern void  DvcLeaveCritical(int);
extern uchar DvcReadPCIConfigByte(ASC_DVC_VAR WinBiosFar *, ushort);
extern void  DvcWritePCIConfigByte(ASC_DVC_VAR WinBiosFar *, ushort, uchar);
extern void  DvcSleepMilliSecond(ulong);
extern void  DvcDisplayString(uchar dosfar *);
extern ulong DvcGetPhyAddr(ASC_DVC_VAR WinBiosFar *, ASC_SCSI_REQ_Q dosfar *,
                uchar dosfar *, long dosfar *, int);
extern void  DvcDelayMicroSecond(ASC_DVC_VAR WinBiosFar *, ushort);
#ifdef ADV_OS_BIOS
extern void  BIOSDispInquiry(uchar, ASC_SCSI_INQUIRY dosfar *);
extern void  BIOSCheckControlDrive(ASC_DVC_VAR WinBiosFar*, uchar,
                ASC_SCSI_INQUIRY dosfar *, ASC_CAP_INFO dosfar *, uchar);
#endif /* ADV_OS_BIOS */
#if ADV_BIG_ENDIAN
extern int   AdvAdjEndianScsiQ( ASC_SCSI_REQ_Q * ) ;
#endif /* ADV_BIG_ENDIAN */

/*
 * Adv Library interface functions. These are functions called
 * by device drivers.
 *
 * The convention is that all external interface function
 * names begin with "Adv".
 */

int     AdvExeScsiQueue(ASC_DVC_VAR WinBiosFar *,
                         ASC_SCSI_REQ_Q dosfar *);
int     AdvISR(ASC_DVC_VAR WinBiosFar *);
int     AdvInitGetConfig(ASC_DVC_VAR WinBiosFar *);
int     AdvInitAsc3550Driver(ASC_DVC_VAR WinBiosFar *);
int     AdvResetSB(ASC_DVC_VAR WinBiosFar *);
ushort  AdvGetEEPConfig(PortAddr, ASCEEP_CONFIG dosfar *);
void    AdvSetEEPConfig(PortAddr, ASCEEP_CONFIG dosfar *);
void    AdvResetChip(ASC_DVC_VAR WinBiosFar *);
void    AscResetSCSIBus(ASC_DVC_VAR WinBiosFar *);
#if ADV_GETSGLIST
int     AscGetSGList(ASC_DVC_VAR WinBiosFar *, ASC_SCSI_REQ_Q dosfar *);
#endif /* ADV_SGLIST */
#if ADV_INITSCSITARGET
int     AdvInitScsiTarget(ASC_DVC_VAR WinBiosFar *,
                           ASC_DVC_INQ_INFO dosfar *,
                           uchar dosfar *,
                           ASC_CAP_INFO_ARRAY dosfar *,
                           ushort);
#endif /* ADV_INITSCSITARGET */

/*
 * Internal Adv Library functions. These functions are not
 * supposed to be directly called by device drivers.
 *
 * The convention is these all internal interface function
 * names begin with "Asc".
 */
int     AscSendIdleCmd(ASC_DVC_VAR WinBiosFar *, ushort, ulong, int);
int     AscSendScsiCmd(ASC_DVC_VAR WinBiosFar *, ASC_SCSI_REQ_Q dosfar *);
void    AdvInquiryHandling(ASC_DVC_VAR WinBiosFar *, ASC_SCSI_REQ_Q dosfar *);

#if ADV_INITSCSITARGET
#if (OS_UNIXWARE || OS_SCO_UNIX)
int     AdvInitPollTarget(
#else
int     AscInitPollTarget(
#endif
            ASC_DVC_VAR WinBiosFar *, ASC_SCSI_REQ_Q dosfar *,
            ASC_SCSI_INQUIRY dosfar *, ASC_CAP_INFO dosfar *,
            ASC_REQ_SENSE dosfar *);

int     AscScsiUrgentCmd(ASC_DVC_VAR WinBiosFar *, ASC_SCSI_REQ_Q dosfar *,
            uchar dosfar *, long , uchar dosfar *, long);
void    AscWaitScsiCmd(ASC_DVC_VAR WinBiosFar *, ASC_SCSI_REQ_Q dosfar *);
#endif /* ADV_INITSCSITARGET */
static   int     AscInitFromEEP(ASC_DVC_VAR WinBiosFar *);
static   void    AscWaitEEPCmd(PortAddr);
static   ushort  AscReadEEPWord(PortAddr, int);
#if ADV_DISP_INQUIRY
void    AscDispInquiry(uchar, uchar, ASC_SCSI_INQUIRY dosfar *);
#endif /* ADV_DISP_INQUIRY */

/*
 * PCI Bus Definitions
 */
#define AscPCICmdRegBits_BusMastering     0x0007
#define AscPCICmdRegBits_ParErrRespCtrl   0x0040

#define AscPCIConfigVendorIDRegister      0x0000
#define AscPCIConfigDeviceIDRegister      0x0002
#define AscPCIConfigCommandRegister       0x0004
#define AscPCIConfigStatusRegister        0x0006
#define AscPCIConfigCacheSize             0x000C
#define AscPCIConfigLatencyTimer          0x000D /* BYTE */
#define AscPCIIOBaseRegister              0x0010

#define ASC_PCI_ID2BUS(id)    ((id) & 0xFF)
#define ASC_PCI_ID2DEV(id)    (((id) >> 11) & 0x1F)
#define ASC_PCI_ID2FUNC(id)   (((id) >> 8) & 0x7)

#define ASC_PCI_MKID(bus, dev, func) \
      ((((dev) & 0x1F) << 11) | (((func) & 0x7) << 8) | ((bus) & 0xFF))


/*
 * Define macros for accessing Condor registers.
 *
 * Registers can be accessed using I/O space at the I/O address
 * specified by PCI Configuration Space Base Address Register #0
 * or using memory space at the memory address specified by
 * PCI Configuration Space Base Address Register #1.
 *
 * If a driver defines ADV_PCI_MEMORY to 1, then it will use
 * memory space to access Condor registers. The driver must
 * map the physical Base Address Register #1 to virtual memory
 * and set the ASC_DVC_VAR 'iop_base' field to this address
 * for the Adv Library to use. The 'PortAddr' type will also
 * have to be defined to be the size of the mapped virtual
 * address.
 */

#if ADV_PCI_MEMORY

/* Read byte from a register. */
#define AscReadByteRegister(iop_base, reg_off) \
     (ADV_MEM_READB((iop_base) + (reg_off)))

/* Write byte to a register. */
#define AscWriteByteRegister(iop_base, reg_off, byte) \
     (ADV_MEM_WRITEB((iop_base) + (reg_off), (byte)))

/* Read word (2 bytes) from a register. */
#define AscReadWordRegister(iop_base, reg_off) \
     (ADV_MEM_READW((iop_base) + (reg_off)))

/* Write word (2 bytes) to a register. */
#define AscWriteWordRegister(iop_base, reg_off, word) \
     (ADV_MEM_WRITEW((iop_base) + (reg_off), (word)))

/* Read byte from LRAM. */
#define AscReadByteLram(iop_base, addr) \
    (ADV_MEM_WRITEW((iop_base) + IOPW_RAM_ADDR, (addr)), \
     (ADV_MEM_READB((iop_base) + IOPB_RAM_DATA)))

/* Write byte to LRAM. */
#define AscWriteByteLram(iop_base, addr, byte) \
    (ADV_MEM_WRITEW((iop_base) + IOPW_RAM_ADDR, (addr)), \
     ADV_MEM_WRITEB((iop_base) + IOPB_RAM_DATA, (byte)))

/* Read word (2 bytes) from LRAM. */
#define AscReadWordLram(iop_base, addr) \
    (ADV_MEM_WRITEW((iop_base) + IOPW_RAM_ADDR, (addr)), \
     (ADV_MEM_READW((iop_base) + IOPW_RAM_DATA)))

/* Write word (2 bytes) to LRAM. */
#define AscWriteWordLram(iop_base, addr, word) \
    (ADV_MEM_WRITEW((iop_base) + IOPW_RAM_ADDR, (addr)), \
     ADV_MEM_WRITEW((iop_base) + IOPW_RAM_DATA, (word)))

/* Write double word (4 bytes) to LRAM
 * Because of unspecified C language ordering don't use auto-increment.
 */
#define AscWriteDWordLram(iop_base, addr, dword) \
    ((ADV_MEM_WRITEW((iop_base) + IOPW_RAM_ADDR, (addr)), \
      ADV_MEM_WRITEW((iop_base) + IOPW_RAM_DATA, \
                     (ushort) ((dword) & 0xFFFF))), \
     (ADV_MEM_WRITEW((iop_base) + IOPW_RAM_ADDR, (addr) + 2), \
      ADV_MEM_WRITEW((iop_base) + IOPW_RAM_DATA, \
                     (ushort) ((dword >> 16) & 0xFFFF))))

/* Read word (2 bytes) from LRAM assuming that the address is already set. */
#define AscReadWordAutoIncLram(iop_base) \
     (ADV_MEM_READW((iop_base) + IOPW_RAM_DATA))

/* Write word (2 bytes) to LRAM assuming that the address is already set. */
#define AscWriteWordAutoIncLram(iop_base, word) \
     (ADV_MEM_WRITEW((iop_base) + IOPW_RAM_DATA, (word)))

#else /* ADV_PCI_MEMORY */

/* Read byte from a register. */
#define AscReadByteRegister(iop_base, reg_off) \
     (inp((iop_base) + (reg_off)))

/* Write byte to a register. */
#define AscWriteByteRegister(iop_base, reg_off, byte) \
     (outp((iop_base) + (reg_off), (byte)))

/* Read word (2 bytes) from a register. */
#define AscReadWordRegister(iop_base, reg_off) \
     (inpw((iop_base) + (reg_off)))

/* Write word (2 bytes) to a register. */
#define AscWriteWordRegister(iop_base, reg_off, word) \
     (outpw((iop_base) + (reg_off), (word)))

/* Read byte from LRAM. */
#define AscReadByteLram(iop_base, addr) \
    (outpw((iop_base) + IOPW_RAM_ADDR, (addr)), \
     (inp((iop_base) + IOPB_RAM_DATA)))

/* Write byte to LRAM. */
#define AscWriteByteLram(iop_base, addr, byte) \
    (outpw((iop_base) + IOPW_RAM_ADDR, (addr)), \
     outp((iop_base) + IOPB_RAM_DATA, (byte)))

/* Read word (2 bytes) from LRAM. */
#define AscReadWordLram(iop_base, addr) \
    (outpw((iop_base) + IOPW_RAM_ADDR, (addr)), \
     (inpw((iop_base) + IOPW_RAM_DATA)))

/* Write word (2 bytes) to LRAM. */
#define AscWriteWordLram(iop_base, addr, word) \
    (outpw((iop_base) + IOPW_RAM_ADDR, (addr)), \
     outpw((iop_base) + IOPW_RAM_DATA, (word)))

/* Write double word (4 bytes) to LRAM
 * Because of unspecified C language ordering don't use auto-increment.
 */
#define AscWriteDWordLram(iop_base, addr, dword) \
    ((outpw((iop_base) + IOPW_RAM_ADDR, (addr)), \
      outpw((iop_base) + IOPW_RAM_DATA, (ushort) ((dword) & 0xFFFF))), \
     (outpw((iop_base) + IOPW_RAM_ADDR, (addr) + 2), \
      outpw((iop_base) + IOPW_RAM_DATA, (ushort) ((dword >> 16) & 0xFFFF))))

/* Read word (2 bytes) from LRAM assuming that the address is already set. */
#define AscReadWordAutoIncLram(iop_base) \
     (inpw((iop_base) + IOPW_RAM_DATA))

/* Write word (2 bytes) to LRAM assuming that the address is already set. */
#define AscWriteWordAutoIncLram(iop_base, word) \
     (outpw((iop_base) + IOPW_RAM_DATA, (word)))

#endif /* ADV_PCI_MEMORY */


/*
 * Define macro to check for Condor signature.
 *
 * Evaluate to ADV_TRUE if a Condor chip is found the specified port
 * address 'iop_base'. Otherwise evalue to ADV_FALSE.
 */
#define AdvFindSignature(iop_base) \
    (((AscReadByteRegister((iop_base), IOPB_CHIP_ID_1) == \
        ADV_CHIP_ID_BYTE) && \
     (AscReadWordRegister((iop_base), IOPW_CHIP_ID_0) == \
        ADV_CHIP_ID_WORD)) ?  ADV_TRUE : ADV_FALSE)

/*
 * Define macro to Return the version number of the chip at 'iop_base'.
 *
 * The second parameter 'bus_type' is currently unused.
 */
#define AdvGetChipVersion(iop_base, bus_type) \
    AscReadByteRegister((iop_base), IOPB_CHIP_TYPE_REV)

/*
 * Abort an SRB in the chip's RISC Memory. The 'srb_ptr' argument must
 * match the ASC_SCSI_REQ_Q 'srb_ptr' field.
 *
 * If the request has not yet been sent to the device it will simply be
 * aborted from RISC memory. If the request is disconnected it will be
 * aborted on reselection by sending an Abort Message to the target ID.
 *
 * Return value:
 *      ADV_TRUE(1) - Queue was successfully aborted.
 *      ADV_FALSE(0) - Queue was not found on the active queue list.
 */
#define AdvAbortSRB(asc_dvc, srb_ptr) \
    AscSendIdleCmd((asc_dvc), (ushort) IDLE_CMD_ABORT, \
                (ulong) (srb_ptr), 0)

/*
 * Send a Bus Device Reset Message to the specified target ID.
 *
 * All outstanding commands will be purged if sending the
 * Bus Device Reset Message is successful.
 *
 * Return Value:
 *      ADV_TRUE(1) - All requests on the target are purged.
 *      ADV_FALSE(0) - Couldn't issue Bus Device Reset Message; Requests
 *                     are not purged.
 */
#define AdvResetDevice(asc_dvc, target_id) \
        AscSendIdleCmd((asc_dvc), (ushort) IDLE_CMD_DEVICE_RESET, \
                    (ulong) (target_id), 0)

/*
 * SCSI Wide Type definition.
 */
#define ADV_SCSI_BIT_ID_TYPE   ushort

/*
 * AdvInitScsiTarget() 'cntl_flag' options.
 */
#define ADV_SCAN_LUN           0x01
#define ADV_CAPINFO_NOLUN      0x02

/*
 * Convert target id to target id bit mask.
 */
#define ADV_TID_TO_TIDMASK(tid)   (0x01 << ((tid) & ASC_MAX_TID))

/*
 * ASC_SCSI_REQ_Q 'done_status' and 'host_status' return values.
 *
 * XXX - These constants are also defined in qswap.sas. The microcode
 * and Adv Library should instead share the same definitions. qswap.sas
 * should be changed to be able to use an include file.
 */

#define QD_NO_STATUS         0x00       /* Request not completed yet. */
#define QD_NO_ERROR          0x01
#define QD_ABORTED_BY_HOST   0x02
#define QD_WITH_ERROR        0x04
#if ADV_INITSCSITARGET
#define QD_DO_RETRY          0x08
#endif /* ADV_INITSCSITARGET */

#define QHSTA_NO_ERROR              0x00
#define QHSTA_M_SEL_TIMEOUT         0x11
#define QHSTA_M_DATA_OVER_RUN       0x12
#define QHSTA_M_UNEXPECTED_BUS_FREE 0x13
#define QHSTA_M_QUEUE_ABORTED       0x15
#define QHSTA_M_SXFR_SDMA_ERR       0x16 /* SXFR_STATUS SCSI DMA Error */
#define QHSTA_M_SXFR_SXFR_PERR      0x17 /* SXFR_STATUS SCSI Bus Parity Error */
#define QHSTA_M_RDMA_PERR           0x18 /* RISC PCI DMA parity error */
#define QHSTA_M_SXFR_OFF_UFLW       0x19 /* SXFR_STATUS Offset Underflow */
#define QHSTA_M_SXFR_OFF_OFLW       0x20 /* SXFR_STATUS Offset Overflow */
#define QHSTA_M_SXFR_WD_TMO         0x21 /* SXFR_STATUS Watchdog Timeout */
#define QHSTA_M_SXFR_DESELECTED     0x22 /* SXFR_STATUS Deselected */
/* Note: QHSTA_M_SXFR_XFR_OFLW is identical to QHSTA_M_DATA_OVER_RUN. */
#define QHSTA_M_SXFR_XFR_OFLW       0x12 /* SXFR_STATUS Transfer Overflow */
#define QHSTA_M_SXFR_XFR_PH_ERR     0x24 /* SXFR_STATUS Transfer Phase Error */
#define QHSTA_M_SXFR_UNKNOWN_ERROR  0x25 /* SXFR_STATUS Unknown Error */
#define QHSTA_M_WTM_TIMEOUT         0x41
#define QHSTA_M_BAD_CMPL_STATUS_IN  0x42
#define QHSTA_M_NO_AUTO_REQ_SENSE   0x43
#define QHSTA_M_AUTO_REQ_SENSE_FAIL 0x44
#define QHSTA_M_INVALID_DEVICE      0x45 /* Bad target ID */

typedef int (dosfar * ASC_ISR_CALLBACK)
    (ASC_DVC_VAR WinBiosFar *, ASC_SCSI_REQ_Q dosfar *);

typedef int (dosfar * ASC_SBRESET_CALLBACK)
    (ASC_DVC_VAR WinBiosFar *);

/*
 * Default EEPROM Configuration structure defined in a_init.c.
 */
extern ASCEEP_CONFIG Default_EEPROM_Config;

/*
 * DvcGetPhyAddr() flag arguments
 */
#define ADV_IS_SCSIQ_FLAG       0x01 /* 'addr' is ASC_SCSI_REQ_Q pointer */
#define ADV_ASCGETSGLIST_VADDR  0x02 /* 'addr' is AscGetSGList() virtual addr */
#define ADV_IS_SENSE_FLAG       0x04 /* 'addr' is sense virtual pointer */
#define ADV_IS_DATA_FLAG        0x08 /* 'addr' is data virtual pointer */
#define ADV_IS_SGLIST_FLAG      0x10 /* 'addr' is sglist virtual pointer */

/* 'IS_SCSIQ_FLAG is now obsolete; Instead use ADV_IS_SCSIQ_FLAG. */
#define IS_SCSIQ_FLAG           ADV_IS_SCSIQ_FLAG


/* Return the address that is aligned at the next doubleword >= to 'addr'. */
#define ADV_DWALIGN(addr)       (((ulong) (addr) + 0x3) & ~0x3)

/*
 * Total contiguous memory needed for driver SG blocks.
 *
 * ADV_MAX_SG_LIST must be defined by a driver. It is the maximum
 * number of scatter-gather elements the driver supports in a
 * single request.
 */

#ifndef ADV_MAX_SG_LIST
Forced Error: Driver must define ADV_MAX_SG_LIST.
#endif /* ADV_MAX_SG_LIST */

#define ADV_SG_LIST_MAX_BYTE_SIZE \
         (sizeof(ASC_SG_BLOCK) * \
          ((ADV_MAX_SG_LIST + (NO_OF_SG_PER_BLOCK - 1))/NO_OF_SG_PER_BLOCK))

/*
 * A driver may optionally define the assertion macro ADV_ASSERT() in
 * its d_os_dep.h file. If the macro has not already been defined,
 * then define the macro to a no-op.
 */
#ifndef ADV_ASSERT
#define ADV_ASSERT(a)
#endif /* ADV_ASSERT */



#endif /* __A_ADVLIB_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc3550\a_condor.h ===
/*
 * a_condor.h - Main Hardware Include File
 *
 * Copyright (c) 1997-1998 Advanced System Products, Inc.
 * All Rights Reserved.
 */

#ifndef __A_CONDOR_H_
#define __A_CONDOR_H_

#define ADV_PCI_VENDOR_ID               0x10CD
#define ADV_PCI_DEVICE_ID_REV_A         0x2300

#define ASC_EEP_DVC_CFG_BEGIN           (0x00)
#define ASC_EEP_DVC_CFG_END             (0x15)
#define ASC_EEP_DVC_CTL_BEGIN           (0x16)  /* location of OEM name */
#define ASC_EEP_MAX_WORD_ADDR           (0x1E)

#define ASC_EEP_DELAY_MS                100

/*
 * EEPROM bits reference by the RISC after initialization.
 */
#define ADV_EEPROM_BIG_ENDIAN          0x8000   /* EEPROM Bit 15 */
#define ADV_EEPROM_BIOS_ENABLE         0x4000   /* EEPROM Bit 14 */
#define ADV_EEPROM_TERM_POL            0x2000   /* EEPROM Bit 13 */

/*
 * EEPROM configuration format
 *
 * Field naming convention: 
 *
 *  *_enable indicates the field enables or disables the feature. The
 *  value is never reset.
 *
 *  *_able indicates both whether a feature should be enabled or disabled
 *  and whether a device isi capable of the feature. At initialization
 *  this field may be set, but later if a device is found to be incapable
 *  of the feature, the field is cleared.
 *
 * Default values are maintained in a_init.c in the structure
 * Default_EEPROM_Config.
 */
typedef struct asceep_config
{                              
                                /* Word Offset, Description */

  ushort cfg_lsw;               /* 00 power up initialization */
                                /*  bit 13 set - Term Polarity Control */
                                /*  bit 14 set - BIOS Enable */
                                /*  bit 15 set - Big Endian Mode */
  ushort cfg_msw;               /* 01 unused      */
  ushort disc_enable;           /* 02 disconect enable */         
  ushort wdtr_able;             /* 03 Wide DTR able */
  ushort sdtr_able;             /* 04 Synchronous DTR able */
  ushort start_motor;           /* 05 send start up motor */      
  ushort tagqng_able;           /* 06 tag queuing able */
  ushort bios_scan;             /* 07 BIOS device control */   
  ushort scam_tolerant;         /* 08 no scam */  
 
  uchar  adapter_scsi_id;       /* 09 Host Adapter ID */
  uchar  bios_boot_delay;       /*    power up wait */
 
  uchar  scsi_reset_delay;      /* 10 reset delay */
  uchar  bios_id_lun;           /*    first boot device scsi id & lun */
                                /*    high nibble is lun */  
                                /*    low nibble is scsi id */

  uchar  termination;           /* 11 0 - automatic */
                                /*    1 - low off / high off */
                                /*    2 - low off / high on */
                                /*    3 - low on  / high on */
                                /*    There is no low on  / high off */

  uchar  reserved1;             /*    resevered byte (not used) */                                  

  ushort bios_ctrl;             /* 12 BIOS control bits */
                                /*  bit 0  set: BIOS don't act as initiator. */
                                /*  bit 1  set: BIOS > 1 GB support */
                                /*  bit 2  set: BIOS > 2 Disk Support */
                                /*  bit 3  set: BIOS don't support removables */
                                /*  bit 4  set: BIOS support bootable CD */
                                /*  bit 5  set: BIOS scan enabled */
                                /*  bit 6  set: BIOS support multiple LUNs */
                                /*  bit 7  set: BIOS display of message */
                                /*  bit 8  set: */
                                /*  bit 9  set: Reset SCSI bus during init. */
                                /*  bit 10 set: */
                                /*  bit 11 set: No verbose initialization. */
                                /*  bit 12 set: SCSI parity enabled */
                                /*  bit 13 set: */
                                /*  bit 14 set: */
                                /*  bit 15 set: */
  ushort  ultra_able;           /* 13 ULTRA speed able */ 
  ushort  reserved2;            /* 14 reserved */
  uchar   max_host_qng;         /* 15 maximum host queueing */
  uchar   max_dvc_qng;          /*    maximum per device queuing */
  ushort  dvc_cntl;             /* 16 control bit for driver */
  ushort  bug_fix;              /* 17 control bit for bug fix */
  ushort  serial_number_word1;  /* 18 Board serial number word 1 */  
  ushort  serial_number_word2;  /* 19 Board serial number word 2 */  
  ushort  serial_number_word3;  /* 20 Board serial number word 3 */
  ushort  check_sum;            /* 21 EEP check sum */
  uchar   oem_name[16];         /* 22 OEM name */
  ushort  dvc_err_code;         /* 30 last device driver error code */
  ushort  adv_err_code;         /* 31 last uc and Adv Lib error code */
  ushort  adv_err_addr;         /* 32 last uc error address */
  ushort  saved_dvc_err_code;   /* 33 saved last dev. driver error code   */
  ushort  saved_adv_err_code;   /* 34 saved last uc and Adv Lib error code */
  ushort  saved_adv_err_addr;   /* 35 saved last uc error address         */  
  ushort  num_of_err;           /* 36 number of error */
} ASCEEP_CONFIG; 

/*
 * EEPROM Commands
 */
#define ASC_EEP_CMD_READ             0x0080
#define ASC_EEP_CMD_WRITE            0x0040
#define ASC_EEP_CMD_WRITE_ABLE       0x0030
#define ASC_EEP_CMD_WRITE_DISABLE    0x0000
#define ASC_EEP_CMD_DONE             0x0200
#define ASC_EEP_CMD_DONE_ERR         0x0001

/* cfg_word */
#define EEP_CFG_WORD_BIG_ENDIAN      0x8000

/* bios_ctrl */
#define BIOS_CTRL_BIOS               0x0001
#define BIOS_CTRL_EXTENDED_XLAT      0x0002
#define BIOS_CTRL_GT_2_DISK          0x0004
#define BIOS_CTRL_BIOS_REMOVABLE     0x0008
#define BIOS_CTRL_BOOTABLE_CD        0x0010
#define BIOS_CTRL_SCAN               0x0020
#define BIOS_CTRL_MULTIPLE_LUN       0x0040
#define BIOS_CTRL_DISPLAY_MSG        0x0080
#define BIOS_CTRL_NO_SCAM            0x0100
#define BIOS_CTRL_RESET_SCSI_BUS     0x0200
#define BIOS_CTRL_INIT_VERBOSE       0x0800
#define BIOS_CTRL_SCSI_PARITY        0x1000

/*
 * ASC 3550 Internal Memory Size - 8KB
 */
#define ADV_CONDOR_MEMSIZE   0x2000     /* 8 KB Internal Memory */

/*
 * ASC 3550 I/O Length - 64 bytes
 */
#define ADV_CONDOR_IOLEN     0x40       /* I/O Port Range in bytes */

/*
 * Byte I/O register address from base of 'iop_base'.
 */
#define IOPB_INTR_STATUS_REG    0x00
#define IOPB_CHIP_ID_1          0x01
#define IOPB_INTR_ENABLES       0x02
#define IOPB_CHIP_TYPE_REV      0x03
#define IOPB_RES_ADDR_4         0x04
#define IOPB_RES_ADDR_5         0x05
#define IOPB_RAM_DATA           0x06
#define IOPB_RES_ADDR_7         0x07
#define IOPB_FLAG_REG           0x08
#define IOPB_RES_ADDR_9         0x09
#define IOPB_RISC_CSR           0x0A
#define IOPB_RES_ADDR_B         0x0B
#define IOPB_RES_ADDR_C         0x0C
#define IOPB_RES_ADDR_D         0x0D
#define IOPB_RES_ADDR_E         0x0E
#define IOPB_RES_ADDR_F         0x0F
#define IOPB_MEM_CFG            0x10
#define IOPB_RES_ADDR_11        0x11
#define IOPB_RES_ADDR_12        0x12
#define IOPB_RES_ADDR_13        0x13
#define IOPB_FLASH_PAGE         0x14
#define IOPB_RES_ADDR_15        0x15
#define IOPB_RES_ADDR_16        0x16
#define IOPB_RES_ADDR_17        0x17
#define IOPB_FLASH_DATA         0x18
#define IOPB_RES_ADDR_19        0x19
#define IOPB_RES_ADDR_1A        0x1A
#define IOPB_RES_ADDR_1B        0x1B
#define IOPB_RES_ADDR_1C        0x1C
#define IOPB_RES_ADDR_1D        0x1D
#define IOPB_RES_ADDR_1E        0x1E
#define IOPB_RES_ADDR_1F        0x1F
#define IOPB_DMA_CFG0           0x20
#define IOPB_DMA_CFG1           0x21
#define IOPB_TICKLE             0x22
#define IOPB_DMA_REG_WR         0x23
#define IOPB_SDMA_STATUS        0x24
#define IOPB_SCSI_BYTE_CNT      0x25
#define IOPB_HOST_BYTE_CNT      0x26
#define IOPB_BYTE_LEFT_TO_XFER  0x27
#define IOPB_BYTE_TO_XFER_0     0x28
#define IOPB_BYTE_TO_XFER_1     0x29
#define IOPB_BYTE_TO_XFER_2     0x2A
#define IOPB_BYTE_TO_XFER_3     0x2B
#define IOPB_ACC_GRP            0x2C
#define IOPB_RES_ADDR_2D        0x2D
#define IOPB_DEV_ID             0x2E
#define IOPB_RES_ADDR_2F        0x2F
#define IOPB_SCSI_DATA          0x30
#define IOPB_RES_ADDR_31        0x31
#define IOPB_RES_ADDR_32        0x32
#define IOPB_SCSI_DATA_HSHK     0x33
#define IOPB_SCSI_CTRL          0x34
#define IOPB_RES_ADDR_35        0x35
#define IOPB_RES_ADDR_36        0x36
#define IOPB_RES_ADDR_37        0x37
#define IOPB_RES_ADDR_38        0x38
#define IOPB_RES_ADDR_39        0x39
#define IOPB_RES_ADDR_3A        0x3A
#define IOPB_RES_ADDR_3B        0x3B
#define IOPB_RFIFO_CNT          0x3C
#define IOPB_RES_ADDR_3D        0x3D
#define IOPB_RES_ADDR_3E        0x3E
#define IOPB_RES_ADDR_3F        0x3F

/*
 * Word I/O register address from base of 'iop_base'.
 */
#define IOPW_CHIP_ID_0          0x00  /* CID0  */
#define IOPW_CTRL_REG           0x02  /* CC    */
#define IOPW_RAM_ADDR           0x04  /* LA    */
#define IOPW_RAM_DATA           0x06  /* LD    */
#define IOPW_RES_ADDR_08        0x08
#define IOPW_RISC_CSR           0x0A  /* CSR   */
#define IOPW_SCSI_CFG0          0x0C  /* CFG0  */
#define IOPW_SCSI_CFG1          0x0E  /* CFG1  */
#define IOPW_RES_ADDR_10        0x10
#define IOPW_SEL_MASK           0x12  /* SM    */
#define IOPW_RES_ADDR_14        0x14
#define IOPW_FLASH_ADDR         0x16  /* FA    */
#define IOPW_RES_ADDR_18        0x18
#define IOPW_EE_CMD             0x1A  /* EC    */
#define IOPW_EE_DATA            0x1C  /* ED    */
#define IOPW_SFIFO_CNT          0x1E  /* SFC   */
#define IOPW_RES_ADDR_20        0x20
#define IOPW_Q_BASE             0x22  /* QB    */
#define IOPW_QP                 0x24  /* QP    */
#define IOPW_IX                 0x26  /* IX    */
#define IOPW_SP                 0x28  /* SP    */
#define IOPW_PC                 0x2A  /* PC    */
#define IOPW_RES_ADDR_2C        0x2C
#define IOPW_RES_ADDR_2E        0x2E
#define IOPW_SCSI_DATA          0x30  /* SD    */
#define IOPW_SCSI_DATA_HSHK     0x32  /* SDH   */
#define IOPW_SCSI_CTRL          0x34  /* SC    */
#define IOPW_HSHK_CFG           0x36  /* HCFG  */
#define IOPW_SXFR_STATUS        0x36  /* SXS   */
#define IOPW_SXFR_CNTL          0x38  /* SXL   */
#define IOPW_SXFR_CNTH          0x3A  /* SXH   */
#define IOPW_RES_ADDR_3C        0x3C
#define IOPW_RFIFO_DATA         0x3E  /* RFD   */

/*
 * Doubleword I/O register address from base of 'iop_base'.
 */
#define IOPDW_RES_ADDR_0         0x00
#define IOPDW_RAM_DATA           0x04
#define IOPDW_RES_ADDR_8         0x08
#define IOPDW_RES_ADDR_C         0x0C
#define IOPDW_RES_ADDR_10        0x10
#define IOPDW_RES_ADDR_14        0x14
#define IOPDW_RES_ADDR_18        0x18
#define IOPDW_RES_ADDR_1C        0x1C
#define IOPDW_SDMA_ADDR0         0x20
#define IOPDW_SDMA_ADDR1         0x24
#define IOPDW_SDMA_COUNT         0x28
#define IOPDW_SDMA_ERROR         0x2C
#define IOPDW_RDMA_ADDR0         0x30
#define IOPDW_RDMA_ADDR1         0x34
#define IOPDW_RDMA_COUNT         0x38
#define IOPDW_RDMA_ERROR         0x3C

#define ADV_CHIP_ID_BYTE         0x25
#define ADV_CHIP_ID_WORD         0x04C1

#define ADV_SC_SCSI_BUS_RESET    0x2000

#define ADV_INTR_ENABLE_HOST_INTR                   0x01
#define ADV_INTR_ENABLE_SEL_INTR                    0x02
#define ADV_INTR_ENABLE_DPR_INTR                    0x04
#define ADV_INTR_ENABLE_RTA_INTR                    0x08
#define ADV_INTR_ENABLE_RMA_INTR                    0x10
#define ADV_INTR_ENABLE_RST_INTR                    0x20
#define ADV_INTR_ENABLE_DPE_INTR                    0x40
#define ADV_INTR_ENABLE_GLOBAL_INTR                 0x80

#define ADV_INTR_STATUS_INTRA            0x01
#define ADV_INTR_STATUS_INTRB            0x02
#define ADV_INTR_STATUS_INTRC            0x04

#define ADV_RISC_CSR_STOP           (0x0000)
#define ADV_RISC_TEST_COND          (0x2000)
#define ADV_RISC_CSR_RUN            (0x4000)
#define ADV_RISC_CSR_SINGLE_STEP    (0x8000)

#define ADV_CTRL_REG_HOST_INTR      0x0100
#define ADV_CTRL_REG_SEL_INTR       0x0200
#define ADV_CTRL_REG_DPR_INTR       0x0400
#define ADV_CTRL_REG_RTA_INTR       0x0800
#define ADV_CTRL_REG_RMA_INTR       0x1000
#define ADV_CTRL_REG_RES_BIT14      0x2000
#define ADV_CTRL_REG_DPE_INTR       0x4000
#define ADV_CTRL_REG_POWER_DONE     0x8000
#define ADV_CTRL_REG_ANY_INTR       0xFF00

#define ADV_CTRL_REG_CMD_RESET             0x00C6
#define ADV_CTRL_REG_CMD_WR_IO_REG         0x00C5
#define ADV_CTRL_REG_CMD_RD_IO_REG         0x00C4
#define ADV_CTRL_REG_CMD_WR_PCI_CFG_SPACE  0x00C3
#define ADV_CTRL_REG_CMD_RD_PCI_CFG_SPACE  0x00C2

#define ADV_SCSI_CTRL_RSTOUT        0x2000

#define AdvIsIntPending(port)  \
    (AscReadWordRegister(port, IOPW_CTRL_REG) & ADV_CTRL_REG_HOST_INTR)

/*
 * SCSI_CFG0 Register bit definitions
 */
#define TIMER_MODEAB    0xC000  /* Watchdog, Second, and Select. Timer Ctrl. */
#define PARITY_EN       0x2000  /* Enable SCSI Parity Error detection */
#define EVEN_PARITY     0x1000  /* Select Even Parity */
#define WD_LONG         0x0800  /* Watchdog Interval, 1: 57 min, 0: 13 sec */
#define QUEUE_128       0x0400  /* Queue Size, 1: 128 byte, 0: 64 byte */
#define PRIM_MODE       0x0100  /* Primitive SCSI mode */
#define SCAM_EN         0x0080  /* Enable SCAM selection */
#define SEL_TMO_LONG    0x0040  /* Sel/Resel Timeout, 1: 400 ms, 0: 1.6 ms */
#define CFRM_ID         0x0020  /* SCAM id sel. confirm., 1: fast, 0: 6.4 ms */
#define OUR_ID_EN       0x0010  /* Enable OUR_ID bits */
#define OUR_ID          0x000F  /* SCSI ID */

/*
 * SCSI_CFG1 Register bit definitions
 */
#define BIG_ENDIAN      0x8000  /* Enable Big Endian Mode MIO:15, EEP:15 */
#define TERM_POL        0x2000  /* Terminator Polarity Ctrl. MIO:13, EEP:13 */
#define SLEW_RATE       0x1000  /* SCSI output buffer slew rate */
#define FILTER_SEL      0x0C00  /* Filter Period Selection */
#define  FLTR_DISABLE    0x0000  /* Input Filtering Disabled */
#define  FLTR_11_TO_20NS 0x0800  /* Input Filtering 11ns to 20ns */          
#define  FLTR_21_TO_39NS 0x0C00  /* Input Filtering 21ns to 39ns */          
#define ACTIVE_DBL      0x0200  /* Disable Active Negation */
#define DIFF_MODE       0x0100  /* SCSI differential Mode (Read-Only) */
#define DIFF_SENSE      0x0080  /* 1: No SE cables, 0: SE cable (Read-Only) */
#define TERM_CTL_SEL    0x0040  /* Enable TERM_CTL_H and TERM_CTL_L */
#define TERM_CTL        0x0030  /* External SCSI Termination Bits */
#define  TERM_CTL_H      0x0020  /* Enable External SCSI Upper Termination */
#define  TERM_CTL_L      0x0010  /* Enable External SCSI Lower Termination */
#define CABLE_DETECT    0x000F  /* External SCSI Cable Connection Status */

#define CABLE_ILLEGAL_A 0x7
    /* x 0 0 0  | on  on | Illegal (all 3 connectors are used) */

#define CABLE_ILLEGAL_B 0xB
    /* 0 x 0 0  | on  on | Illegal (all 3 connectors are used) */

/*
   The following table details the SCSI_CFG1 Termination Polarity,
   Termination Control and Cable Detect bits.

   Cable Detect | Termination
   Bit 3 2 1 0  | 5   4  | Notes
   -------------|--------|--------------------
       1 1 1 0  | on  on | Internal wide only
       1 1 0 1  | on  on | Internal narrow only
       1 0 1 1  | on  on | External narrow only
       0 x 1 1  | on  on | External wide only
       1 1 0 0  | on  off| Internal wide and internal narrow
       1 0 1 0  | on  off| Internal wide and external narrow
       0 x 1 0  | off off| Internal wide and external wide
       1 0 0 1  | on  off| Internal narrow and external narrow
       0 x 0 1  | on  off| Internal narrow and external wide
       1 1 1 1  | on  on | No devices are attached
       x 0 0 0  | on  on | Illegal (all 3 connectors are used)
       0 x 0 0  | on  on | Illegal (all 3 connectors are used)
  
       x means don't-care (either '0' or '1')
  
       If term_pol (bit 13) is '0' (active-low terminator enable), then:
           'on' is '0' and 'off' is '1'.
  
       If term_pol bit is '1' (meaning active-hi terminator enable), then:
           'on' is '1' and 'off' is '0'.
 */

/*
 * MEM_CFG Register bit definitions
 */
#define BIOS_EN         0x40    /* BIOS Enable MIO:14,EEP:14 */
#define FAST_EE_CLK     0x20    /* Diagnostic Bit */
#define RAM_SZ          0x1C    /* Specify size of RAM to RISC */
#define  RAM_SZ_2KB      0x00    /* 2 KB */
#define  RAM_SZ_4KB      0x04    /* 4 KB */
#define  RAM_SZ_8KB      0x08    /* 8 KB */
#define  RAM_SZ_16KB     0x0C    /* 16 KB */
#define  RAM_SZ_32KB     0x10    /* 32 KB */
#define  RAM_SZ_64KB     0x14    /* 64 KB */

/*
 * DMA_CFG0 Register bit defintions
 *
 * This register is only accessible to the host.
 */
#define BC_THRESH_ENB   0x80    /* PCI DMA Start Conditions */
#define FIFO_THRESH     0x70    /* PCI DMA FIFO Threshold */
#define  FIFO_THRESH_16B  0x00   /* 16 bytes */
#define  FIFO_THRESH_32B  0x20   /* 32 bytes */
#define  FIFO_THRESH_48B  0x30   /* 48 bytes */
#define  FIFO_THRESH_64B  0x40   /* 64 bytes */
#define  FIFO_THRESH_80B  0x50   /* 80 bytes (default) */
#define  FIFO_THRESH_96B  0x60   /* 96 bytes */
#define  FIFO_THRESH_112B 0x70   /* 112 bytes */
#define START_CTL       0x0C    /* DMA start conditions */
#define  START_CTL_TH    0x00    /* Wait threshold level (default) */
#define  START_CTL_ID    0x04    /* Wait SDMA/SBUS idle */
#define  START_CTL_THID  0x08    /* Wait threshold and SDMA/SBUS idle */
#define  START_CTL_EMFU  0x0C    /* Wait SDMA FIFO empty/full */
#define READ_CMD        0x03    /* Memory Read Method */
#define  READ_CMD_MR     0x00    /* Memory Read */
#define  READ_CMD_MRL    0x02    /* Memory Read Long */
#define  READ_CMD_MRM    0x03    /* Memory Read Multiple (default) */

#endif /* __A_CONDOR_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc3550\asc3550.c ===
/*
 * AdvanSys 3550 Windows NT SCSI Miniport Driver - asc3550.c
 *
 * Copyright (c) 1994-1998  Advanced System Products, Inc.
 * All Rights Reserved.
 *
 * This Windows 95/NT Miniport driver is written and tested
 * to work with Windows 95, Windows NT 3.51, and Windows NT 4.0.
 *
 * The Driver has the following sections. Each section can be found
 * by searching for '---'.
 *
 *  --- Debug Constants
 *  --- Driver Include Files
 *  --- Debug Definitions
 *  --- Driver Global Data
 *  --- Driver Function Prototypes
 *  --- Initial Driver Entrypoint - DriverEntry()
 *  --- DriverEntry() Support Functions
 *  --- Driver Instance Entrypoint Functions
 *  --- Driver Support Functions
 *  --- Adv Library Required Functions
 *  --- Debug Function Definitions
 *
 */


/*
 * --- Debug Constants
 *
 * Compile time debug options are enabled and disabled here. All debug
 * options must be disabled for the retail driver release.
 */

#if DBG != 0
#define ASC_DEBUG            /* Enable tracing messages. */
#endif /* DBG != 0 */

/*
 * --- Driver Include Files
 */


/* Driver and Adv Library include files */
#include "a_ver.h"
#include "d_os_dep.h"           /* Driver Adv Library include file */
#include "a_scsi.h"
#include "a_condor.h"
#include "a_advlib.h"
#include "asc3550.h"            /* Driver specific include file */

/*
 * --- Debug Definitions
 */

/*
 * --- Driver Global Data
 */

/*
 * AdvanSys PCI Vendor and Device IDs
 *
 * XXX - these definitions should be automatically synched with
 * the Adv Library ADV_PCI_VENDOR_ID and ADV_PCI_DEVICE_ID_REV_A
 * definitions.
 */
UCHAR VenID[4] = { '1', '0', 'C', 'D' };
UCHAR DevID[4] = { '2', '3', '0', '0' };

/*
 * --- Driver Function Prototypes
 */

ulong HwFindAdapterPCI(
    IN PVOID HwDeviceExtension,
    IN PVOID Context,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN Again
    );

ulong SearchPCI(
    IN PVOID HwDeviceExtension,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN ulong config_ioport,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo
    );

BOOLEAN HwInitialize(
    IN PVOID HwDeviceExtension
    );

BOOLEAN HwStartIo(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

BOOLEAN HwInterrupt(
    IN PVOID HwDeviceExtension
    );

BOOLEAN HwResetBus(
    IN PVOID HwDeviceExtension,
    IN ulong PathId
    );

SCSI_ADAPTER_CONTROL_STATUS HwAdapterControl(
    IN PVOID HwDeviceExtension,
    IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
        IN PVOID Paramters
    );

int
AscExecuteIO(
    IN PSCSI_REQUEST_BLOCK srb
    );

int BuildScb(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

void
AscCompleteRequest(
    IN PVOID HwDeviceExtension
    );

VOID DvcISRCallBack(
    IN PCHIP_CONFIG chipConfig,
    IN ASC_SCSI_REQ_Q *scb
    );

VOID DvcSBResetCallBack(
    IN PCHIP_CONFIG chipConfig
    );

UCHAR ErrXlate (
    UCHAR host_status
    );

VOID AscZeroMemory(IN UCHAR *cp, IN ULONG length);


/*
 * --- Initial Driver Entrypoint - DriverEntry()
 *
 * DriverEntry()
 *
 * Routine Description:
 *     Installable driver initialization entry point for system.
 * 
 * Arguments:
 *     Driver Object
 *             
 * Return Value:
 *     Status from ScsiPortInitialize()
 */
ulong
DriverEntry(
    IN PVOID DriverObject,
    IN PVOID Argument2
    )
{
    HW_INITIALIZATION_DATA      hwInitializationData;
    SRCH_CONTEXT                Context;
    ulong                       status;

    ASC_DBG(2, "Asc3550: DriverEntry: begin\n");

    /* Display Driver Parameters */
    ASC_DBG2(2, "Asc3550: sizeof(SRB_EXTENSION) %lu, ASC_NUM_SG_BLOCK %lu\n",
        sizeof(SRB_EXTENSION), ASC_NUM_SG_BLOCK);
    ASC_DBG2(2, "Asc3550: ADV_MAX_SG_LIST %lu, ASC_SG_TOTAL_MEM_SIZE %lu\n",
        ADV_MAX_SG_LIST, ASC_SG_TOTAL_MEM_SIZE);
#if ADV_INITSCSITARGET
    ASC_DBG2(2,
        "Asc3550: ADV_SG_LIST_MAX_BYTE_SIZE %lu, ASC_WORKSPACE_SIZE %lu\n",
        ADV_SG_LIST_MAX_BYTE_SIZE, ASC_WORKSPACE_SIZE);
#else /* ADV_INITSCSITARGET */
    ASC_DBG1(2,
        "Asc3550: ADV_SG_LIST_MAX_BYTE_SIZE %lu\n",
        ADV_SG_LIST_MAX_BYTE_SIZE);
#endif /* ADV_INITSCSITARGET */

    /*
     * Set-up hardware initialization structure used to initialize
     * each adapter instance.
     *
     * Zero out structure and set size.
     */
    AscZeroMemory((PUCHAR) &hwInitializationData,
        sizeof(HW_INITIALIZATION_DATA));
    hwInitializationData.HwInitializationDataSize =
        sizeof(HW_INITIALIZATION_DATA);
        
    /*
     * Set driver entry points.
     */
    hwInitializationData.HwInitialize = HwInitialize;
    hwInitializationData.HwResetBus = HwResetBus;
    hwInitializationData.HwStartIo = HwStartIo;
    hwInitializationData.HwInterrupt = HwInterrupt;
    hwInitializationData.HwDmaStarted = NULL;
    // 'HwAdapterControl' is a SCSI miniport interface added with NT 5.0.
    hwInitializationData.HwAdapterControl = HwAdapterControl;
    hwInitializationData.HwAdapterState = NULL;

    /*
     * Need physical addresses.
     */
    hwInitializationData.NeedPhysicalAddresses = TRUE;
    hwInitializationData.AutoRequestSense = TRUE;
    hwInitializationData.MapBuffers = TRUE;

    /*
     * Enable tag queuing
     */
    hwInitializationData.TaggedQueuing = TRUE;
    hwInitializationData.MultipleRequestPerLu = TRUE;
    hwInitializationData.ReceiveEvent = FALSE;

    /*
     * Specify size of adapter and request extensions.
     */
    hwInitializationData.DeviceExtensionSize = sizeof(HW_DEVICE_EXTENSION);
    hwInitializationData.SpecificLuExtensionSize = 0;
    hwInitializationData.SrbExtensionSize = sizeof(SRB_EXTENSION);

    /*
     * If PCI memory is going to be used to access Condor's
     * registers, then set 2 access ranges: I/O Space, PCI Memory
     */
#if ADV_PCI_MEMORY
    hwInitializationData.NumberOfAccessRanges = 2;
#else /* ADV_PCI_MEMORY */
    hwInitializationData.NumberOfAccessRanges = 1;
#endif /* ADV_PCI_MEMORY */

    /*
     * Set-up and run search for PCI Adapters.
     */

    /* XXX - lengths needs to be in sync with 'VenID', 'DevID' definitions. */
    hwInitializationData.VendorIdLength = 4;
    hwInitializationData.VendorId = VenID;
    hwInitializationData.DeviceIdLength = 4;
    hwInitializationData.DeviceId = DevID;

    hwInitializationData.AdapterInterfaceType = PCIBus;
    hwInitializationData.HwFindAdapter = HwFindAdapterPCI;

    /* Before starting the search, zero out the search context. */
    AscZeroMemory((PUCHAR) &Context, sizeof(SRCH_CONTEXT));

    status = ScsiPortInitialize(DriverObject, Argument2,
                (PHW_INITIALIZATION_DATA) &hwInitializationData, &Context);

    ASC_DBG1(2, "Asc3550: DriverEntry: status %ld\n", status);
    return status;
}


/*
 * --- DriverEntry() Support Functions
 */

/*
 * HwFindAdapterPCI()
 *
 * Find an instance of an AdvanSys PCI adapter. Windows 95/NT will either
 * pass a non-zero I/O port where it expects this function to look for an
 * adapter or it will pass a zero I/O port and expect the function to
 * scan the PCI bus for an adapter.
 *
 * If an adapter is found, return SP_RETURN_FOUND with *Again set to TRUE.
 * If an adapter is not found, return SP_RETURN_NOT_FOUND with *Again set
 * to FALSE. If an adapter is found but an error occurred while trying to
 * initialize it, return SP_RETURN_ERROR with *Again set to TRUE.
 */
ulong
HwFindAdapterPCI(
    IN PVOID HwDeviceExtension,
    IN PVOID Context,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN Again
    )
{
    ulong                    config_ioport;

    *Again = FALSE;

#ifdef ASC_DEBUG
    {
        /* 
         * Display the access ranges for the adapter supplied
         * by Windows 95/NT.
         */
        uint i;

        ASC_DBG1(2, "HwFindAdapterPCI: NumberOfAccessRanges %lu\n",
            ConfigInfo->NumberOfAccessRanges);
        for (i = 0; i < ConfigInfo->NumberOfAccessRanges; i++) {
            ASC_DBG1(2,
                "HwFindAdapterPCI: [%lu]:\n", i);
            ASC_DBG3(2,
                "  RangeStart 0x%lx, RangeLength 0x%lx, RangeInMemory %d\n",
                ScsiPortConvertPhysicalAddressToUlong(
                    (*ConfigInfo->AccessRanges)[i].RangeStart),
                    (*ConfigInfo->AccessRanges)[i].RangeLength,
                    (*ConfigInfo->AccessRanges)[i].RangeInMemory);
        }
    }
#endif /* ASC_DEBUG */
   
    /*
     * If Windows 95/NT provided an I/O Port, then try to find an AdvanSys
     * adapter at that I/O Port.
     *
     * Otherwise scan the PCI Configuration Space for AdvanSys adapters.
     */

    /* Adapter I/O Port is the first access range. */
    config_ioport = ScsiPortConvertPhysicalAddressToUlong(
        (*ConfigInfo->AccessRanges)[0].RangeStart);

    if (config_ioport != 0)
    {
        ASC_DBG1(2,
            "HwFindAdapterPCI: Windows 95/NT specified I/O port: 0x%x\n",
            config_ioport);
        switch (SearchPCI(HwDeviceExtension, BusInformation,
                      ArgumentString, config_ioport, ConfigInfo)) {
        case SP_RETURN_FOUND:
            *Again = TRUE;
            return SP_RETURN_FOUND;
        case SP_RETURN_ERROR:
            *Again = TRUE;
            return SP_RETURN_ERROR;
        case SP_RETURN_NOT_FOUND:
            return SP_RETURN_NOT_FOUND;
        }
        /* NOTREACHED */
    }
    return SP_RETURN_NOT_FOUND;
}

/*
 * SearchPCI()
 *
 * Search for an AdvanSys PCI adapter at the location specified
 * by 'ConfigInfo'. The PCI Configuration Slot Number, Device Number, 
 * and Function Number specify where to look for the device. If the
 * I/O Port specified in 'ConfigInfo' is non-zero then check it against
 * the I/O Port found in the PCI Configuration Space. Otherwise if the
 * I/O Port is zero, just use the I/O Port obtained from the PCI
 * Configuration Space. Check the adapter IRQ in the same way.
 *
 * If an adapter is found, return SP_RETURN_FOUND. If an adapter is not
 * found, return SP_RETURN_NOT_FOUND. If an adapter is found but an error
 * occurs with trying to initialize it, return SP_RETURN_ERROR.
 */
ulong
SearchPCI(
    IN PVOID HwDeviceExtension,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN ulong config_ioport,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo
    )
{
    PortAddr                pci_ioport;
#if ADV_PCI_MEMORY
    PortAddr                pci_memaddr;
#endif /* ADV_PCI_MEMORY */
    PHW_DEVICE_EXTENSION    deviceExtension = HwDeviceExtension;
    PCHIP_CONFIG            chipConfig = &HDE2CONFIG(deviceExtension);
    USHORT                  initstat;
    PCI_SLOT_NUMBER         pci_slot;
    PCI_COMMON_CONFIG       pci_config;
    ulong                   size;
    PVOID                   map_ioport;
    int                     i;

    /* Set the 'pci_slot' DeviceNumber . */
    pci_slot.u.AsULONG = 0L;
    pci_slot.u.bits.DeviceNumber = ConfigInfo->SlotNumber;

    ASC_DBG3(2,
        "SearchPCI: SystemIoBusNumber %x, DeviceNumber %x, FunctionNumber %x\n",
        ConfigInfo->SystemIoBusNumber,
        pci_slot.u.bits.DeviceNumber, pci_slot.u.bits.FunctionNumber);

    if ((size = ScsiPortGetBusData(
            HwDeviceExtension,               /* HwDeviceExtension */
            PCIConfiguration,                /* Bus type */
            (ulong) ConfigInfo->SystemIoBusNumber,   /* Bus Number */
            pci_slot.u.AsULONG,              /* Device and Function Number */
            &pci_config,                     /* Buffer */
            sizeof(PCI_COMMON_CONFIG)        /* Length */
            )) != sizeof(PCI_COMMON_CONFIG)) {

        ASC_DBG1(1, "SearchPCI: bad PCI config size: %lu\n", size);

        ScsiPortLogError(HwDeviceExtension, NULL, 0, 0, 0,
            SP_INTERNAL_ADAPTER_ERROR,
            ADV_SPL_UNIQUEID(ADV_SPL_PCI_CONF, size));
        return SP_RETURN_NOT_FOUND;
    }

#ifdef ASC_DEBUG

    /*
     * Display PCI Configuration Information
     */

    ASC_DBG(2, "SearchPCI: Found adapter PCI Configuration information:\n");

    ASC_DBG3(2,
        "SearchPCI: SystemIoBusNumber %x, DeviceNumber %x, FunctionNumber %x\n",
         ConfigInfo->SystemIoBusNumber,
         pci_slot.u.bits.DeviceNumber, pci_slot.u.bits.FunctionNumber);

    ASC_DBG4(2,
        "SearchPCI: VendorID %x, DeviceID %x, Command %x, Status %x\n",
        pci_config.VendorID, pci_config.DeviceID,
        pci_config.Command, pci_config.Status);

    ASC_DBG3(2,
        "SearchPCI: RevisionID %x, CacheLineSize %x, LatencyTimer %x\n",
        pci_config.RevisionID, pci_config.CacheLineSize,
        pci_config.LatencyTimer);

    ASC_DBG2(2,
        "SearchPCI: BaseAddresses[0] %lx, BaseAddresses[1] %lx\n",
        pci_config.u.type0.BaseAddresses[0], 
        pci_config.u.type0.BaseAddresses[1]);

    ASC_DBG2(2,
        "SearchPCI: ROMBaseAddress %lx, InterruptLine %lx\n",
        pci_config.u.type0.ROMBaseAddress,
        pci_config.u.type0.InterruptLine);

#endif /* ASC_DEBUG */


    /*
     * Check returned PCI configuration information.
     */

    if (pci_config.VendorID == PCI_INVALID_VENDORID) {
        ScsiPortLogError(HwDeviceExtension, NULL, 0, 0, 0,
            SP_INTERNAL_ADAPTER_ERROR,
            ADV_SPL_UNIQUEID(ADV_SPL_PCI_CONF, pci_config.VendorID));
        return SP_RETURN_NOT_FOUND;
    }

    if (pci_config.VendorID != ADV_PCI_VENDOR_ID)
    {
        ASC_DBG1(2, "SearchPCI: PCI Vendor ID mismatch: 0x%x\n",
            pci_config.VendorID);
        ScsiPortLogError(HwDeviceExtension, NULL, 0, 0, 0,
            SP_INTERNAL_ADAPTER_ERROR,
            ADV_SPL_UNIQUEID(ADV_SPL_PCI_CONF, pci_config.VendorID));
        return SP_RETURN_NOT_FOUND;
    }

    if (pci_config.DeviceID != ADV_PCI_DEVICE_ID_REV_A) 
    {
        ASC_DBG1(2, "SearchPCI: Device ID mismatch: 0x%x\n",
            pci_config.DeviceID);
        ScsiPortLogError(HwDeviceExtension, NULL, 0, 0, 0,
            SP_INTERNAL_ADAPTER_ERROR,
            ADV_SPL_UNIQUEID(ADV_SPL_PCI_CONF, pci_config.DeviceID));
        return SP_RETURN_NOT_FOUND;
    }

    /*
     * Set ConfigInfo IRQ information 
     */
    if (ConfigInfo->BusInterruptLevel != pci_config.u.type0.InterruptLine) {
        ASC_DBG2(1,
            "SearchPCI: ConfigInfo IRQ 0x%x != PCI IRQ 0x%x\n",
            ConfigInfo->BusInterruptLevel, pci_config.u.type0.InterruptLine);
    }

    ConfigInfo->BusInterruptLevel = pci_config.u.type0.InterruptLine;

    /*
     * Set ConfigInfo I/O Space Access Range Information
     */
    ASC_DBG1(2, "SearchPCI: PCI BaseAddresses[0]: 0x%x\n",
        pci_config.u.type0.BaseAddresses[0] & (~PCI_ADDRESS_IO_SPACE));

    pci_ioport = (PortAddr)
        (pci_config.u.type0.BaseAddresses[0] & (~PCI_ADDRESS_IO_SPACE));

    ASC_DBG1(2, "SearchPCI: pci_ioport 0x%lx\n", pci_ioport);

    /*
     * If the given I/O Port does not match the I/O Port address
     * found for the PCI device, then return not found.
     */
    if (config_ioport != pci_ioport) {
        ASC_DBG2(1,
            "SearchPCI: config_ioport 0x%x != pci_ioport 0x%x\n",
            config_ioport, pci_ioport);
        ScsiPortLogError(HwDeviceExtension, NULL, 0, 0, 0,
            SP_INTERNAL_ADAPTER_ERROR,
            ADV_SPL_UNIQUEID(ADV_SPL_PCI_CONF, pci_ioport));
        return SP_RETURN_NOT_FOUND;
    }


#if ADV_PCI_MEMORY
    /*
     * Set PCI Memory Space access range information
     */

    ASC_DBG1(2, "SearchPCI: PCI BaseAddresses[1]: 0x%lx\n",
        pci_config.u.type0.BaseAddresses[1] & (~PCI_ADDRESS_MEMORY_TYPE_MASK));

    pci_memaddr = (PortAddr)
        (pci_config.u.type0.BaseAddresses[1] &
        (~PCI_ADDRESS_MEMORY_TYPE_MASK));

    ASC_DBG1(2, "SearchPCI: pci_memaddr 0x%lx\n", pci_memaddr);

    /*
     * Set 'ConfigInfo' information for ScsiPortGetDeviceBase().
     */
    (*ConfigInfo->AccessRanges)[1].RangeStart =
        ScsiPortConvertUlongToPhysicalAddress(pci_memaddr);
    (*ConfigInfo->AccessRanges)[1].RangeLength = ADV_CONDOR_IOLEN;
    (*ConfigInfo->AccessRanges)[1].RangeInMemory = TRUE;
#endif /* ADV_PCI_MEMORY */

#if ADV_PCI_MEMORY
    /*
     * If PCI memory access has been set for Condor, then obtain
     * a mapping for 'pci_memaddr' to allow Condor's registers to
     * be accessed through memory references. Otherwise obtain a
     * mapping for 'pci_ioport' and access Condor's registers with
     * PIO instructions.
     */
    ASC_DBG(2, "SearchPCI: Memory Space ScsiPortGetDeviceBase() Mapping.\n");

    map_ioport = ScsiPortGetDeviceBase(
     HwDeviceExtension,                   /* HwDeviceExtension */
     ConfigInfo->AdapterInterfaceType,    /* AdapterInterfaceType */
     ConfigInfo->SystemIoBusNumber,       /* SystemIoBusNumber */
     (*ConfigInfo->AccessRanges)[1].RangeStart,  /* IoAddress */
     (*ConfigInfo->AccessRanges)[1].RangeLength, /* NumberOfBytes */ 
     (BOOLEAN) !(*ConfigInfo->AccessRanges)[1].RangeInMemory); /* InIoSpace */

#else /* ADV_PCI_MEMORY */

    /*
     * Convert 'config_ioport' to a possibly different mapped
     * I/O port address.
     */
    ASC_DBG(2, "SearchPCI: I/O Space ScsiPortGetDeviceBase() Mapping.\n");

    map_ioport = ScsiPortGetDeviceBase(
     HwDeviceExtension,                   /* HwDeviceExtension */
     ConfigInfo->AdapterInterfaceType,    /* AdapterInterfaceType */
     ConfigInfo->SystemIoBusNumber,       /* SystemIoBusNumber */
     (*ConfigInfo->AccessRanges)[0].RangeStart,  /* IoAddress */
     (*ConfigInfo->AccessRanges)[0].RangeLength, /* NumberOfBytes */ 
     (BOOLEAN) !(*ConfigInfo->AccessRanges)[0].RangeInMemory); /* InIoSpace */

#endif /* ADV_PCI_MEMORY */

    /*
     * PCI adapter found
     */
    ASC_DBG3(2, "SearchPCI: config_ioport 0x%x, map_ioport 0x%lx, IRQ 0x%x\n",
            config_ioport, map_ioport, ConfigInfo->BusInterruptLevel);

    /*
     * Fill-in Adv Library adapter information.
     */
    chipConfig->iop_base = (PortAddr) map_ioport;
    chipConfig->cfg = &HDE2INFO(deviceExtension);
    chipConfig->cfg->pci_device_id = pci_config.DeviceID;
    chipConfig->isr_callback = (Ptr2Func) &DvcISRCallBack;
    chipConfig->sbreset_callback = (Ptr2Func) &DvcSBResetCallBack;
    chipConfig->irq_no = (UCHAR) ConfigInfo->BusInterruptLevel;
    chipConfig->cfg->pci_slot_info =
         (USHORT) ASC_PCI_MKID(ConfigInfo->SystemIoBusNumber,
                    pci_slot.u.bits.DeviceNumber,
                    pci_slot.u.bits.FunctionNumber);
    CONFIG2HDE(chipConfig) = HwDeviceExtension;


    /*
     * Execute Adv Library initialization.
     */
    ASC_DBG(2, "SearchPCI: before AdvInitGetConfig\n");
    if ((initstat = (USHORT)AdvInitGetConfig(chipConfig)) != 0) {
        ASC_DBG1(1, "SearchPCI: AdvInitGetConfig warning code 0x%x\n",
            initstat);
        ScsiPortLogError(HwDeviceExtension, NULL, 0, 0, 0,
            SP_INTERNAL_ADAPTER_ERROR,
            ADV_SPL_UNIQUEID(ADV_SPL_IWARN_CODE, initstat));
    }

    if (chipConfig->err_code != 0) {
        ASC_DBG1(1, "AdvInitGetConfig: err_code 0x%x\n",
            chipConfig->err_code);
        ScsiPortLogError(HwDeviceExtension, NULL, 0, 0, 0,
            SP_INTERNAL_ADAPTER_ERROR,
            ADV_SPL_UNIQUEID(ADV_SPL_IERR_CODE, chipConfig->err_code));

        /* Clear the 'iop_base' field to prevent the board from being used. */
        chipConfig->iop_base = (PortAddr) NULL;
        return SP_RETURN_ERROR;
    }
    ASC_DBG(2, "SearchPCI: AscInitGetConfig successful\n");

    /*
     * Fill-in Windows 95/NT ConfigInfo information.
     */
    ConfigInfo->NumberOfBuses = 1;
    ConfigInfo->InitiatorBusId[0] = chipConfig->chip_scsi_id;
    ConfigInfo->MaximumTransferLength = 0xFFFFFFFF;
    ConfigInfo->Master = TRUE;
    ConfigInfo->NeedPhysicalAddresses = TRUE;
    ConfigInfo->Dma32BitAddresses = TRUE;
    ConfigInfo->InterruptMode = LevelSensitive;
    ConfigInfo->AdapterInterfaceType = PCIBus;
    ConfigInfo->AlignmentMask = 0;
    ConfigInfo->BufferAccessScsiPortControlled = FALSE;
    ConfigInfo->MaximumNumberOfTargets = ASC_MAX_TID + 1;
    ConfigInfo->AdapterScansDown = FALSE;
    ConfigInfo->TaggedQueuing = TRUE;
    //
    // 'ResetTargetSupported' is flag added with NT 5.0 that will
    // result in SRB_FUNCTION_RESET_DEVICE SRB requests being sent
    // to the miniport driver.
    //
    ConfigInfo->ResetTargetSupported = TRUE;

    /*
     * Set NumberOfPhysicalBreaks in a single request that the driver
     * is capable of handling.
     *
     * According to the Windows 95/NT DDK miniport drivers are not supposed
     * to change NumberOfPhysicalBreaks if its value on entry is not
     * SP_UNINITIALIZED_VALUE. But AdvanSys has found that performance
     * can be improved by increasing the value to the maximum the
     * adapter can handle.
     *
     * Note: The definition of NumberOfPhysicalBreaks is "maximum
     * scatter-gather elements - 1". Windows 95/NT is broken in that
     * it sets MaximumPhysicalPages, the value class drivers use, to
     * the same value as NumberOfPhysicalBreaks. This bug should be
     * reflected in the value of ADV_MAX_SG_LIST, which should be
     * one greater than it should have to be.
     */
    ConfigInfo->ScatterGather = TRUE;
    ConfigInfo->NumberOfPhysicalBreaks = ADV_MAX_SG_LIST - 1;

    /*
     * Zero out per adapter request wait queue.
     */
    AscZeroMemory((PUCHAR) &HDE2WAIT(deviceExtension), sizeof(asc_queue_t));

    /* Initialize the device type filed to NO_DEVICE_TYPE value */
    for ( i = 0; i <= ASC_MAX_TID; i++ )
    {
        deviceExtension->dev_type[i] =  0x1F;
    }

    ASC_DBG(2, "SearchPCI: SP_RETURN_FOUND\n");
    return SP_RETURN_FOUND;
}


/*
 * --- Driver Instance Entrypoint Functions
 *
 * These entrypoint functions are defined by the initial driver
 * entrypoint 'DriverEntery()' for each driver instance or adapter.
 */

/*
 * HwInitialize()
 *
 * Routine Description:
 * 
 *   This routine is called from ScsiPortInitialize
 *   to set up the adapter so that it is ready to service requests.
 * 
 * Arguments:
 * 
 *   HwDeviceExtension - HBA miniport driver's adapter data storage
 * 
 * Return Value:
 * 
 *   TRUE - if initialization successful.
 *   FALSE - if initialization unsuccessful.
 */
BOOLEAN
HwInitialize(
    IN PVOID HwDeviceExtension
    )
{
    PCHIP_CONFIG            chipConfig = &HDE2CONFIG(HwDeviceExtension);
    USHORT                  initstat;
    
    ASC_DBG1(2, "HwInitialize: chipConfig 0x%lx\n", chipConfig);

    /*
     * If 'iop_base' is NULL, then initialization must have failed.
     */
    if (chipConfig->iop_base == (PortAddr) NULL) {
        ASC_DBG(1, "HwInitialize: iop_base is NULL\n");
        return FALSE;
    }

    if ((initstat = (USHORT)AdvInitAsc3550Driver(chipConfig)) != 0) {
        ASC_DBG1(1, "AdvInitAsc3550Driver: warning code 0x%x\n", initstat);

        /*
         * Log the warning only if the 'err_code' is zero. If the
         * 'err_code' is non-zero it will be logged below.
         */
        if (chipConfig->err_code == 0) {
            ScsiPortLogError(HwDeviceExtension, NULL, 0, 0, 0,
                SP_INTERNAL_ADAPTER_ERROR,
                ADV_SPL_UNIQUEID(ADV_SPL_IWARN_CODE, initstat));
        }
    }

    if (chipConfig->err_code != 0) {
        ASC_DBG1(1, "AdvInitAsc3550Driver: err_code 0x%x\n",
            chipConfig->err_code);
        ScsiPortLogError(HwDeviceExtension, NULL, 0, 0, 0,
            SP_INTERNAL_ADAPTER_ERROR,
            ADV_SPL_UNIQUEID(ADV_SPL_IERR_CODE, chipConfig->err_code));
        return FALSE;
    } else {
        ASC_DBG(2, "AdvInitAsc3550Driver: successful\n");
    }

    ASC_DBG(2, "HwInitialize: TRUE\n");
    return TRUE;
}

/*
 * Routine Description:
 * 
 *     This routine is called from the SCSI port driver to send a
 *     command to controller or target. 
 * 
 * Arguments:
 * 
 *     HwDeviceExtension - HBA miniport driver's adapter data storage
 *     Srb - IO request packet
 * 
 * Return Value:
 * 
 *     TRUE
 * 
 */
BOOLEAN
HwStartIo(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK srb
    )
{
    PCHIP_CONFIG    chipConfig;
    asc_queue_t     *waitq;

    ASC_DBG(4, "HwStartIo: begin\n");

    ASC_DBG2(4, "HwStartIo: srb 0x%lx, SrbExtension 0x%lx\n",
        srb, srb->SrbExtension);

    chipConfig = &HDE2CONFIG(HwDeviceExtension);
    waitq = &HDE2WAIT(HwDeviceExtension);
    
    switch (srb->Function) {

    case SRB_FUNCTION_ABORT_COMMAND:
        ASC_DBG1(1, "HwStartIo: Abort srb 0x%lx \n", srb->NextSrb);
        ASC_DBG1(1, "chipConfig 0x%lx\n", chipConfig);
        if (asc_rmqueue(waitq, srb->NextSrb) == ADV_TRUE) {
            ASC_DBG(2, "Abort success from waitq.\n");
            /* Complete the aborted SRB 'NextSrb'. */
            srb->NextSrb->SrbStatus = SRB_STATUS_ABORTED;
            ScsiPortNotification(RequestComplete, HwDeviceExtension,
                srb->NextSrb);
            srb->SrbStatus = SRB_STATUS_SUCCESS;
        } else if (AdvAbortSRB(chipConfig, (ulong) srb->NextSrb)) {
            ASC_DBG(2, "Abort success.\n");
            srb->SrbStatus = SRB_STATUS_SUCCESS;
        } else {
            ASC_DBG(1, "Abort failure.\n");
            /*
             * The aborted request may already be on the adapter
             * done list and will be completed below. But in case
             * it isn't set an error indicating that the abort
             * failed and continue.
             */
            srb->SrbStatus = SRB_STATUS_ERROR;
        }

        /*
         * Call AdvISR() to process all requests completed by the
         * microcode and then call AscCompleteRequest() to complete
         * these requests to the OS. If AdvAbortSRB() succeeded,
         * then one of the requests completed will include the
         * aborted SRB.
         */
        (void) AdvISR(chipConfig);
        AscCompleteRequest(HwDeviceExtension);

        /* Complete current SRB and ask for the next request. */
        ScsiPortNotification(RequestComplete, HwDeviceExtension, srb);
        ScsiPortNotification(NextRequest, HwDeviceExtension, NULL);
        return TRUE;

    case SRB_FUNCTION_RESET_BUS:
        /*
         * Reset SCSI bus.
         */
        ASC_DBG(1, "HwStartIo: Reset Bus\n");
        HwResetBus (chipConfig, 0L);
        srb->SrbStatus = SRB_STATUS_SUCCESS;
        ScsiPortNotification(RequestComplete, HwDeviceExtension, srb);
        ScsiPortNotification(NextRequest, HwDeviceExtension, NULL);
        return TRUE;

    case SRB_FUNCTION_EXECUTE_SCSI:

        ASC_DBG(4, "HwStartIo: Execute SCSI\n");
        /*
         * Set the srb's Device Extension pointer before attempting to start
         * the IO. It will be needed for any retrys and in DvcISRCallBack().
         */
        SRB2HDE(srb) = HwDeviceExtension;

        /* Execute any queued commands for the host adapter. */
        if (waitq->tidmask) {
            asc_execute_queue(waitq);
        }

        /*
         * If the target for the current command has any queued
         * commands or if trying to execute the command returns
         * BUSY, then enqueue the command.
         */
        if ((waitq->tidmask & ADV_TID_TO_TIDMASK(srb->TargetId)) ||
            (AscExecuteIO(srb) == ADV_BUSY)) {
            ASC_DBG1(2, "HwStartIO: put request to waitq srb 0x%lx\n", srb);
            asc_enqueue(waitq, srb, ASC_BACK);
        }

        return TRUE;

    case SRB_FUNCTION_RESET_DEVICE:
        ASC_DBG1(1, "HwStartIo: Reset device: %u\n", srb->TargetId);
        if (AdvResetDevice(chipConfig, srb->TargetId) == ADV_TRUE) {
            ASC_DBG(2, "Device Reset success.\n");
            srb->SrbStatus = SRB_STATUS_SUCCESS;
        } else {
            ASC_DBG(2, "Device Reset failure.\n");
            srb->SrbStatus = SRB_STATUS_ERROR;
        }

        /*
         * Call AdvISR() to process all requests completed by the
         * microcode and then call AscCompleteRequest() to complete
         * these requests to the OS.
         */
        (void) AdvISR(chipConfig);
        AscCompleteRequest(HwDeviceExtension);

        ScsiPortNotification(RequestComplete, HwDeviceExtension, srb);
        ScsiPortNotification(NextRequest, HwDeviceExtension, NULL);
        return TRUE;

    case SRB_FUNCTION_SHUTDOWN:
        /*
         * Shutdown - HwAdapterControl() ScsiStopAdapter performs
         * all needed shutdown of the adapter.
         */
        ASC_DBG(1, "HwStartIo: SRB_FUNCTION_SHUTDOWN\n");
        ScsiPortNotification(RequestComplete, HwDeviceExtension, srb);
        ScsiPortNotification(NextRequest, HwDeviceExtension, NULL);
        return TRUE;

    default:
        /*
         * Bad Function
         *
         * Set an error, complete the request, and signal ready for
         * next request.
         */
        ASC_DBG1(1, "HwStartIo: Function 0x%x: invalid request\n",
            srb->Function);
        srb->SrbStatus = SRB_STATUS_BAD_FUNCTION;

        ScsiPortLogError(HwDeviceExtension, srb,
            srb->PathId, srb->TargetId, srb->Lun,
            SP_INTERNAL_ADAPTER_ERROR,
            ADV_SPL_UNIQUEID(ADV_SPL_UNSUPP_REQ, srb->Function));

        ScsiPortNotification(RequestComplete, HwDeviceExtension, srb);
        ScsiPortNotification(NextRequest, HwDeviceExtension, NULL);
        return TRUE;

    }
    /* NOTREACHED */
}

/*
 * Routine Description:
 * 
 *     This is the interrupt service routine for the SCSI adapter.
 *     It reads the interrupt register to determine if the adapter is indeed
 *     the source of the interrupt and clears the interrupt at the device.
 * 
 * Arguments:
 * 
 *     HwDeviceExtension - HBA miniport driver's adapter data storage
 * 
 * Return Value:
 *     Indicates where device generated an interrupt. 
 */
BOOLEAN
HwInterrupt(
    IN PVOID HwDeviceExtension
    )
{
    PCHIP_CONFIG        chipConfig;
    int                 retstatus;
    asc_queue_t         *waitq;

    ASC_DBG(3, "HwInterrupt: begin\n");

    chipConfig = &HDE2CONFIG(HwDeviceExtension);

    switch (retstatus = AdvISR(chipConfig)) {
    case ADV_TRUE:
       ASC_DBG(4, "HwInterrupt: AdvISR() TRUE\n");
       break;
    case ADV_FALSE:
       ASC_DBG(4, "HwInterrupt: AdvISR() FALSE\n");
        break;
    case ADV_ERROR:
    default:
        ASC_DBG2(1,
            "HwInterrupt: AdvISR() retsatus 0x%lx, err_code 0x%x\n",
            retstatus, chipConfig->err_code);
        ScsiPortLogError(HwDeviceExtension, NULL, 0, 0, 0,
            SP_INTERNAL_ADAPTER_ERROR,
            ADV_SPL_UNIQUEID(ADV_SPL_ERR_CODE, chipConfig->err_code));
        break;
    }

    /*
     * Execute any waiting requests.
     */
    if ((waitq = &HDE2WAIT(HwDeviceExtension))->tidmask) {
        asc_execute_queue(waitq);
    }

    /*
     * Complete all requests on the adapter done list.
     */
    AscCompleteRequest(HwDeviceExtension);

    ASC_DBG1(3, "HwInterrupt: retstatus 0x%x\n", retstatus);
    return (UCHAR)retstatus;
}

SCSI_ADAPTER_CONTROL_STATUS
HwAdapterControl(
    IN PVOID HwDeviceExtension,
    IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
    IN PVOID Parameters
    )
/*++

Routine Description:

    HwAdapterControl() interface added in NT 5.0 for
        Plug and Play/Power Management.

Arguments:

    DeviceExtension
    ControlType
        Parameters

Return Value:

    SCSI_ADAPTER_CONTROL_STATUS.

--*/
{
    PCHIP_CONFIG                chipConfig = &HDE2CONFIG(HwDeviceExtension);
    PHW_DEVICE_EXTENSION        deviceExtension = HwDeviceExtension;
    PSCSI_SUPPORTED_CONTROL_TYPE_LIST ControlTypeList;
    asc_queue_t                 *waitq;
    REQP                        reqp;
    int                         i;
    USHORT                      initstat;

    switch (ControlType)
    {
    //
    // Query Adapter.
    //
    case ScsiQuerySupportedControlTypes:
        ASC_DBG(2, "HwAdapterControl: ScsiQuerySupportControlTypes\n");

        ControlTypeList =
            (PSCSI_SUPPORTED_CONTROL_TYPE_LIST) Parameters;
        if (ControlTypeList->MaxControlType < ScsiStopAdapter)
        {
            ASC_DBG(1, "HwAdapterControl: Unsuccessful 1\n");
            return ScsiAdapterControlUnsuccessful;
        }
        ControlTypeList->SupportedTypeList[ScsiStopAdapter] = TRUE;

        if (ControlTypeList->MaxControlType < ScsiSetRunningConfig)
        {
            ASC_DBG(1, "HwAdapterControl: Unsuccessful 2\n");
            return ScsiAdapterControlUnsuccessful;
        }
        ControlTypeList->SupportedTypeList[ScsiSetRunningConfig] = TRUE;

        if (ControlTypeList->MaxControlType < ScsiRestartAdapter)
        {
            ASC_DBG(1, "HwAdapterControl: Unsuccessful 3\n");
            return ScsiAdapterControlUnsuccessful;
        }
        ControlTypeList->SupportedTypeList[ScsiRestartAdapter] = TRUE;

        ASC_DBG(1, "HwAdapterControl: ScsiAdapterControlSuccess\n");
        return ScsiAdapterControlSuccess;
        /* NOTREACHED */

    //
    // Stop Adapter.
    //
    case ScsiStopAdapter:
        ASC_DBG(2, "HwAdapterControl: ScsiStopdapter\n");

        /*
         * Complete any waiting requests.
         */
        if ((waitq = &HDE2WAIT(HwDeviceExtension))->tidmask)
        {
            for (i = 0; i <= ASC_MAX_TID; i++)
            {
                while ((reqp = asc_dequeue(waitq, i)) != NULL)
                {
                    reqp->SrbStatus = SRB_STATUS_ABORTED;
                    ScsiPortNotification(RequestComplete, HwDeviceExtension,
                        reqp);
                }
            }
        }

        //
        // Disable interrupts and halt the chip.
        //
        AscWriteByteRegister(chipConfig->iop_base, IOPB_INTR_ENABLES, 0);
        AscWriteWordRegister(chipConfig->iop_base, IOPW_RISC_CSR,
            ADV_RISC_CSR_STOP);


        ASC_DBG(2, "HwAdapterControl: ScsiStopAdapter Success\n");
        return ScsiAdapterControlSuccess;
        /* NOTREACHED */

    //
    // ScsiSetRunningConfig.
    //
    // Called before ScsiRestartAdapter. Can use ScsiPort[Get|Set]BusData.
    //
    case ScsiSetRunningConfig:
        ASC_DBG(2, "HwAdapterControl: ScsiSetRunningConfig\n");

        /*
         * Execute Adv Library initialization.
         */
        ASC_DBG(2, "SearchPCI: before AdvInitGetConfig\n");
        if ((initstat = (USHORT)AdvInitGetConfig(chipConfig)) != 0) {
            ASC_DBG1(1, "AdvInitGetConfig: warning code 0x%x\n",
                initstat);
        }

        if (chipConfig->err_code != 0) {
            ASC_DBG1(1, "AdvInitGetConfig: err_code 0x%x\n",
                chipConfig->err_code);
            ASC_DBG(1, "HwAdapterControl: Unsuccessful 3\n");
            return ScsiAdapterControlUnsuccessful;
        }

        ASC_DBG(2, "HwAdapterControl: ScsiSetRunningConfig successful\n");
        return ScsiAdapterControlSuccess;
        /* NOTREACHED */

    //
    // Restart Adapter.
    //
    // Cannot use ScsiPort[Get|Set]BusData.
    //
    case ScsiRestartAdapter:
        ASC_DBG(2, "HwAdapterControl: ScsiRestartAdapter\n");

        if ((initstat = (USHORT)AdvInitAsc3550Driver(chipConfig)) != 0)
        {
            ASC_DBG1(1,
                "AdvInitAsc3550Driver: warning code %x\n", initstat);
        }

        if (chipConfig->err_code != 0) {
            ASC_DBG1(1, "AdvInitAsc3550Driver: err_code code %x\n",
                chipConfig->err_code);
            return ScsiAdapterControlUnsuccessful;
        } else {
            ASC_DBG(2, "HwAdapterControl: ScsiRestartAdapter success\n");
            return ScsiAdapterControlSuccess;
        }
        /* NOTREACHED */

    //
    // Unsupported Control Operation.
    //
    default:
        return ScsiAdapterControlUnsuccessful;
        /* NOTREACHED */
    }
    /* NOTREACHED */
}

/*
 * Routine Description:
 * 
 *     Reset SCSI bus.
 * 
 * Arguments:
 * 
 *     HwDeviceExtension - HBA miniport driver's adapter data storage
 * 
 * Return Value:
 * 
 *     Nothing.
 * 
 */
BOOLEAN
HwResetBus(
    IN PVOID HwDeviceExtension,
    IN ulong PathId
    )
{
    PCHIP_CONFIG        chipConfig;
    REQP                reqp;
    asc_queue_t         *waitq;
    int                 i;
#ifdef ASC_DEBUG
    int                 j;
#endif /* ASC_DEBUG */
    PSCB                pscb, tpscb;
    PSCSI_REQUEST_BLOCK srb;
    int                 status;
    
    ASC_DBG(1, "HwResetBus: begin\n");

    chipConfig = &HDE2CONFIG(HwDeviceExtension);

    /*
     * Complete all requests that have not been sent to the microcode.
     *
     * Because these requests have not been sent to the microcode, they
     * may be completed prior to the Bus Reset. All of these requests must
     * be removed to clean up the driver queues before returning from
     * HwResetBus().
     */
    if ((waitq = &HDE2WAIT(HwDeviceExtension))->tidmask) {
        for (i = 0; i <= ASC_MAX_TID; i++) {
            while ((reqp = asc_dequeue(waitq, i)) != NULL) {
                ASC_DBG1(1, "HwResetBus: completing waitq reqp 0x%lx\n", reqp);
                reqp->SrbStatus = SRB_STATUS_BUS_RESET;
                ScsiPortNotification(RequestComplete, HwDeviceExtension, reqp);
            }
        }
    }

    /*
     * Perform the bus reset.
     */
    status = AdvResetSB(chipConfig);

    /*
     * Call AdvISR() to process all requests completed by the
     * microcode and then call AscCompleteRequest() to complete
     * these requests to the OS.
     */
    (void) AdvISR(chipConfig);
    AscCompleteRequest(HwDeviceExtension);

    /*
     * Complete all pending requests to the OS.
     *
     * All requests that have been sent to the microcode should have been
     * completed by the call to AdvResetSB(). In case there were requests
     * that were misplaced by the microcode and not completed, use the
     * SRB_STATUS_BUS_RESET function with no TID and LUN to clear all
     * pending requests.
     */
    ScsiPortCompleteRequest(HwDeviceExtension,
            (UCHAR) PathId,
            SP_UNTAGGED,
            SP_UNTAGGED,
            SRB_STATUS_BUS_RESET);

    /*
     * Indicate that the adapter is ready for a new request.
     */
    ScsiPortNotification(NextRequest, HwDeviceExtension, NULL);

    ASC_DBG1(2, "HwResetBus: AdvResetSB() status %ld\n", status);
    return (UCHAR)status;
}


/*
 * --- Driver Support Functions
 */

/*
 * AscExecuteIO()
 *
 * If ADV_BUSY is returned, the request was not executed and it
 * should be enqueued and tried later.
 *
 * For all other return values the request is active or has
 * been completed.
 */
int
AscExecuteIO(IN PSCSI_REQUEST_BLOCK srb)
{
    PVOID            HwDeviceExtension;
    PCHIP_CONFIG     chipConfig;
    PSCB             scb;
    UCHAR            PathId, TargetId, Lun;
    short            status;

    ASC_DBG1(4, "AscExecuteIO: srb 0x%lx\n", srb);
    HwDeviceExtension = SRB2HDE(srb);
    chipConfig = &HDE2CONFIG(HwDeviceExtension);

    /*
     * Build SCB.
     */
    if ((status = (SHORT)BuildScb(HwDeviceExtension, srb)) == ADV_FALSE) {
        ASC_DBG(1, "AscExecuteIO: BuildScb() failure\n");

        ScsiPortLogError(HwDeviceExtension, NULL, 0, 0, 0,
            SP_INTERNAL_ADAPTER_ERROR,
            ADV_SPL_UNIQUEID(ADV_SPL_START_REQ, status));

        srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;

        ASC_DBG1(4, "AscExecuteIO: srb 0x%lx, RequestComplete\n", srb);
        ScsiPortNotification(RequestComplete, HwDeviceExtension, srb);

        ASC_DBG1(4, "AscExecuteIO: srb 0x%lx, NextRequest\n", srb);
        ScsiPortNotification(NextRequest, HwDeviceExtension, NULL);
        return status;
    }
    scb = SRB2PSCB(srb);
    ASC_DBG1(3, "AscExecuteIO: scb 0x%lx\n", scb);

    /*
     * Save information about the request.
     *
     * After a request has been completed it can no longer be accessed.
     */
    PathId = srb->PathId;
    TargetId = srb->TargetId;
    Lun = srb->Lun;

    /*
     * Execute SCSI Command
     */
    status = (SHORT)AdvExeScsiQueue(chipConfig, scb);

    if (status == ADV_NOERROR) {
        /*
         * Request successfully started.
         *
         * If more requests can be sent to the Asc Library then
         * call NextRequest or NextLuRequest.
         *
         * NextRequest indicates that another request may be sent
         * to any non-busy target. Since a request was just issued
         * to the target 'TargetId' that target is now busy and won't
         * be sent another request until a RequestComplete is done.
         *
         * NextLuRequest indicates that another request may be sent
         * to any non-busy target as well as the specified target even
         * if the specified target is busy.
         */
        ASC_DBG1(4, "AdvExeScsiQueue: srb 0x%lx ADV_NOERROR\n", srb);
        ASC_DBG1(4, "AscExecuteIO: srb 0x%lx, NextLuRequest\n", srb);
        ScsiPortNotification(NextLuRequest, HwDeviceExtension,
                        PathId, TargetId, Lun);
    } else if (status == ADV_BUSY) {
        ASC_DBG1(1, "AdvExeScsiQueue: srb 0x%lx ADV_BUSY\n", srb);
        ASC_DBG1(4, "AscExecuteIO: srb 0x%lx, NextRequest\n", srb);
        ScsiPortNotification(NextRequest, HwDeviceExtension, NULL);
    } else {
        /*
         * AdvExeScsiQueue() returned an error...
         */
        ASC_DBG2(1, "AdvExeScsiQueue: srb 0x%lx, error code 0x%x\n",
            srb, status);
        srb->SrbStatus = SRB_STATUS_BAD_FUNCTION;
        ASC_DBG1(4, "AscExecuteIO: srb 0x%lx, RequestComplete\n", srb);
        ScsiPortNotification(RequestComplete, HwDeviceExtension, srb);
        ASC_DBG1(4, "AscExecuteIO: srb 0x%lx, NextRequest\n", srb);
        ScsiPortNotification(NextRequest, HwDeviceExtension, NULL);
    }

    ASC_DBG1(4, "AscExecuteIO: status %ld\n", status);
    return status;
}


/*
 * BuildScb()
 *
 * Routine Description:
 * 
 *     Build SCB for Library routines.
 * 
 * Arguments:
 * 
 *     DeviceExtension
 *     SRB
 * 
 * Return Value:
 * 
 *     ADV_TRUE - sucesss
 *     ADV_FALSE - faliure
 */
int
BuildScb(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK srb
    )
{
    PSCB            scb;
    PCHIP_CONFIG    chipConfig = &HDE2CONFIG(HwDeviceExtension);
    UCHAR           i;
    ulong           contig_len;
    
    // variables used for hibernation fix //
    ushort tidmask;
    ushort cfg_word;
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;

    
    /*
     * Initialize Adv Library reqeust and scatter-gather structures.
     * These structures are pre-allocated as a part of the 'srb'.
     */
    INITSRBEXT(srb);
    scb = SRB2PSCB(srb);
    AscZeroMemory((PUCHAR) scb, sizeof(SCB));
    PSCB2SRB(scb) = srb;

    ASC_ASSERT(SCB2HDE(scb) == HwDeviceExtension);

    /*
     * Set request target id and lun.
     */
    scb->target_id = srb->TargetId;
    scb->target_lun = srb->Lun;

    /*
     * If tag queueing is enabled for the request, set the specified
     * tag code. By default the driver will perform tag queuing.
     */
    if (srb->SrbFlags & SRB_FLAGS_QUEUE_ACTION_ENABLE) {
        scb->tag_code = srb->QueueAction;
    } else {
        scb->tag_code = M2_QTAG_MSG_SIMPLE ;
    }

    ASC_DBG3(4, "BuildSCB: target_id %lu, target_lun %lu, tag_code %lu\n",
          scb->target_id, scb->target_lun, scb->tag_code);

    /*
     * Set CDB length and copy it to the request structure.
     */
    scb->cdb_len = srb->CdbLength;
    for (i = 0; i < srb->CdbLength; i++) {
        scb->cdb[i] = srb->Cdb[i];
    }

    
    ////////////// Apply Hibernation Fix ////////////

    if (srb->CdbLength > 0)
    {
        // Check opcode
        if (srb->Cdb[0] == 0x1B)
        {
            // 0x1B is the SCSI Opcode command for the following
            // Dev_Type
            // 00 Disk drives           Start/Stop
            // 01 Tape drives           Load/Unload
            // 02 Printers              Stop Print
            // 03 Processor devices     n.a.
            // 04 WORM drives           Start/Stop
            // 05 CD-ROM                Start/Stop
            // 06 Scanners              Scan
            // 07 Optical storage       Start/Stop
            // 08 Medium changers       n.a.
            // 09 Communication devices n.a.
            // 1f unknown devices       n.a.
            
            if ( 0x00 == deviceExtension->dev_type[srb->TargetId] )
            {
                /* The assume this is applicable for all LUN for a TargetID.
                 * Q-tag on Start/Stop causes certain Quantum AtlasIII drives to
                 * respond with QueFull when hibernation is initiated under w2k.
                 * This causes the hibernation process to hang.
                 */
                ASC_DBG(1, "BuildScb: setting no tag que for 0x1B command: Start/Stop for disk drives.\n");
                
                tidmask = ADV_TID_TO_TIDMASK(srb->TargetId);
                
                cfg_word = AscReadWordLram( chipConfig->iop_base, ASC_MC_WDTR_DONE );
                cfg_word &= ~tidmask;
                AscWriteWordLram( chipConfig->iop_base, ASC_MC_WDTR_DONE, cfg_word );
            }
        }
    }

    ////////////// END Hibernation Fix ////////////


    /*
     * Set the data count.
     */
    scb->data_cnt = srb->DataTransferLength;
    ASC_DBG1(4, "BuildSCB: data_cnt 0x%lx\n", scb->data_cnt);

    /*
     * If there is a non-zero data transfer to be done, then check
     * if the data buffer is physically contiguous. If it isn't
     * physically contiguous, then a scatter-gather list will be
     * built.
     */
    if (scb->data_cnt > 0) {

        /*
         * Save the buffer virtual address.
         */
        scb->vdata_addr = (ulong) srb->DataBuffer;

        /*
         * Obtain physically contiguous length of 'DataBuffer'.
         */
        scb->data_addr = ScsiPortConvertPhysicalAddressToUlong(
                    ScsiPortGetPhysicalAddress(HwDeviceExtension, srb,
                    srb->DataBuffer, &contig_len));

        /*
         * If the physically contiguous length of 'DataBuffer' is
         * less than the 'DataTransferLength', then a scatter-gather
         * list must be built.
         */
        if (contig_len < srb->DataTransferLength) {
            /*
             * Initialize scatter-gather list area.
             */
            scb->sg_list_ptr = (ASC_SG_BLOCK *) SRB2PSDL(srb);
            AscZeroMemory((PUCHAR) scb->sg_list_ptr, sizeof(SDL));

            /*
             * AscGetSGList() will build the SG blocks and set the
             * ASC_SCSI_REQ_Q 'sg_real_addr' field. It will reference
             * the 'vdata_addr' field.
             *
             * AdvExeScsiQueue() will call AscGetSGList() if 'sg_real_addr'
             * is non-NULL. Call AscGetSGList() prior to AdvExeScsiQueue()
             * for better error checking.
             */
            if (AscGetSGList(chipConfig, scb) == ADV_ERROR) {
                ASC_DBG(1, "BuildScb: AscGetSGList() failed\n");
                return ADV_FALSE;
            }
        }
    }

    /*
     * Convert sense buffer length and buffer into physical address.
     * The sense buffer length may be changed below by
     * ScsiPortGetPhysicalAddress() to reflect the amount of available
     * physically contiguous memory.
     */
    if ((srb->SrbFlags & SRB_FLAGS_DISABLE_AUTOSENSE) == 0) {
        ASC_DBG2(4,
            "BuildScb: SenseInfoBuffer 0x%lx, SenseInfoBufferLength 0x%lx\n",
            srb->SenseInfoBuffer, srb->SenseInfoBufferLength);
        scb->sense_len = srb->SenseInfoBufferLength;
        if (scb->sense_len > 0) {
            scb->vsense_addr = (ulong) srb->SenseInfoBuffer;
            scb->sense_addr = (ulong) ScsiPortConvertPhysicalAddressToUlong(
                        ScsiPortGetPhysicalAddress(HwDeviceExtension, srb,
                            srb->SenseInfoBuffer, &contig_len));
            /*
             * If the contiguous length of the Sense Buffer is less
             * than 'sense_len', then set the Sense Buffer Length
             * to the contiguous length.
             */ 
            if (contig_len < scb->sense_len) {
                ASC_DBG(1, "Asc3550: sense buffer overflow to next page.\n");
                scb->sense_len = (uchar) contig_len;
            }
            ASC_DBG3(4,
              "BuildScb: vsense_addr 0x%lx, sense_addr 0x%lx, sense_len 0x%x\n",
              scb->vsense_addr, scb->sense_addr, scb->sense_len);
        }
    }
    return ADV_TRUE;
}

/*
 * Complete all requests on the adapter done list by
 * DvcISRCallBack().
 */
void
AscCompleteRequest(
    IN PVOID HwDeviceExtension
    )
{
    PSCB                pscb, tpscb;
    PSCSI_REQUEST_BLOCK srb;

    /*
     * Return if the done list is empty.
     */
    if ((pscb = HDE2DONE(HwDeviceExtension)) == NULL) {
        ASC_DBG(4, "AscCompleteRequest: adapter scb_done == NULL\n");
        return;
    }

    HDE2DONE(HwDeviceExtension) = NULL;

    /*
     * Interrupts could now be enabled during the SRB callback
     * without adversely affecting the driver.
     */

    while (pscb) {
        tpscb = SCB2NEXTSCB(pscb);
        SCB2NEXTSCB(pscb) = NULL;
        srb = PSCB2SRB(pscb);
        ASC_DBG2(4,
            "AscCompleteRequest: RequestComplete: srb 0x%lx, scb 0x%lx\n",
            srb, pscb);
        ASC_ASSERT(SRB2HDE(srb) != NULL);
        ScsiPortNotification(RequestComplete, SRB2HDE(srb), srb);
        pscb = tpscb;
    }
}

/*
 * Add a 'REQP' to the end of specified queue. Set 'tidmask'
 * to indicate a command is queued for the device.
 *
 * 'flag' may be either ASC_FRONT or ASC_BACK.
 *
 * 'REQPNEXT(reqp)' returns reqp's next pointer.
 */
void
asc_enqueue(asc_queue_t *ascq, REQP reqp, int flag)
{
    REQP    *reqpp;
    int        tid;

    ASC_DBG3(4, "asc_enqueue: ascq 0x%lx, reqp 0x%lx, flag 0x%lx\n",
        ascq, reqp, flag);
    tid = REQPTID(reqp);
    ASC_DASSERT(flag == ASC_FRONT || flag == ASC_BACK);
    if (flag == ASC_FRONT) {
        REQPNEXT(reqp) = ascq->queue[tid];
        ascq->queue[tid] = reqp;
    } else { /* ASC_BACK */
        for (reqpp = &ascq->queue[tid]; *reqpp; reqpp = &REQPNEXT(*reqpp)) {
            ASC_DASSERT(ascq->tidmask & ADV_TID_TO_TIDMASK(tid));
            ;
        }
        *reqpp = reqp;
        REQPNEXT(reqp) = NULL;
    }
    /* The queue has at least one entry, set its bit. */
    ascq->tidmask |= ADV_TID_TO_TIDMASK(tid);
    ASC_DBG1(4, "asc_enqueue: reqp 0x%lx\n", reqp);
    return;
}

/*
 * Return first queued 'REQP' on the specified queue for
 * the specified target device. Clear the 'tidmask' bit for
 * the device if no more commands are left queued for it.
 *
 * 'REQPNEXT(reqp)' returns reqp's next pointer.
 */
REQP
asc_dequeue(asc_queue_t *ascq, int tid)
{
    REQP    reqp;

    ASC_DBG2(4, "asc_dequeue: ascq 0x%lx, tid %lu\n", ascq, tid);
    if ((reqp = ascq->queue[tid]) != NULL) {
        ASC_DASSERT(ascq->tidmask & ADV_TID_TO_TIDMASK(tid));
        ascq->queue[tid] = REQPNEXT(reqp);
        /* If the queue is empty, clear its bit. */
        if (ascq->queue[tid] == NULL) {
            ascq->tidmask &= ~ADV_TID_TO_TIDMASK(tid);
        }
    }
    ASC_DBG1(4, "asc_dequeue: reqp 0x%lx\n", reqp);
    return reqp;
}

/*
 * Remove the specified 'REQP' from the specified queue for
 * the specified target device. Clear the 'tidmask' bit for the
 * device if no more commands are left queued for it.
 *
 * 'REQPNEXT(reqp)' returns reqp's the next pointer.
 *
 * Return ADV_TRUE if the command was found and removed,
 * otherwise return ADV_FALSE.
 */
int
asc_rmqueue(asc_queue_t *ascq, REQP reqp)
{
    REQP        *reqpp;
    int            tid;
    int            ret;

    ret = ADV_FALSE;
    tid = REQPTID(reqp);
    for (reqpp = &ascq->queue[tid]; *reqpp; reqpp = &REQPNEXT(*reqpp)) {
        ASC_DASSERT(ascq->tidmask & ADV_TID_TO_TIDMASK(tid));
        if (*reqpp == reqp) {
            ret = ADV_TRUE;
            *reqpp = REQPNEXT(reqp);
            REQPNEXT(reqp) = NULL;
            /* If the queue is now empty, clear its bit. */
            if (ascq->queue[tid] == NULL) {
                ascq->tidmask &= ~ADV_TID_TO_TIDMASK(tid);
            }
            break; /* Note: *reqpp may now be NULL; don't iterate. */
        }
    }
    ASC_DBG2(4, "asc_rmqueue: reqp 0x%lx, ret %ld\n", reqp, ret);
    return ret;
}

/*
 * Execute as many queued requests as possible for the specified queue.
 *
 * Calls AscExecuteIO() to execute a REQP.
 */
void
asc_execute_queue(asc_queue_t *ascq)
{
    ADV_SCSI_BIT_ID_TYPE    scan_tidmask;
    REQP                    reqp;
    int                        i;

    ASC_DBG1(4, "asc_execute_queue: ascq 0x%lx\n", ascq);
    /*
     * Execute queued commands for devices attached to
     * the current board in round-robin fashion.
     */
    scan_tidmask = ascq->tidmask;
    do {
        for (i = 0; i <= ASC_MAX_TID; i++) {
            if (scan_tidmask & ADV_TID_TO_TIDMASK(i)) {
                if ((reqp = asc_dequeue(ascq, i)) == NULL) {
                    scan_tidmask &= ~ADV_TID_TO_TIDMASK(i);
                } else if (AscExecuteIO(reqp) == ADV_BUSY) {
                    scan_tidmask &= ~ADV_TID_TO_TIDMASK(i);
                    /* Put the request back at front of the list. */
                    asc_enqueue(ascq, reqp, ASC_FRONT);
                }
            }
        }
    } while (scan_tidmask);
    return;
}

/*
 * ErrXlate()
 *
 * Routine Description:
 * 
 *   This routine translate Library status into 'SrbStatus' which
 *   is requried by Windows 95/NT.
 * 
 * Arguments:
 * 
 *   host_status - ASC_SCSI_REQ_Q 'host_status'
 * 
 * Return Value:
 * 
 *   Error code defined by Windows 95/NT SCSI port driver.
 *   If no appropriate SrbStatus value is found return 0.
 * 
 */
UCHAR
ErrXlate(UCHAR host_status)
{
    switch (host_status) {
    case QHSTA_M_SEL_TIMEOUT:
        return SRB_STATUS_SELECTION_TIMEOUT;

    case QHSTA_M_DATA_OVER_RUN:
        return SRB_STATUS_DATA_OVERRUN;

    case QHSTA_M_UNEXPECTED_BUS_FREE:
        return SRB_STATUS_UNEXPECTED_BUS_FREE;

    case QHSTA_M_SXFR_WD_TMO:
    case QHSTA_M_WTM_TIMEOUT:
        return SRB_STATUS_COMMAND_TIMEOUT;

    case QHSTA_M_QUEUE_ABORTED:
        return SRB_STATUS_ABORTED;

    case QHSTA_M_SXFR_DESELECTED:
    case QHSTA_M_SXFR_XFR_PH_ERR:
        return SRB_STATUS_PHASE_SEQUENCE_FAILURE;

    case QHSTA_M_SXFR_SXFR_PERR:
        return SRB_STATUS_PARITY_ERROR;

    case QHSTA_M_SXFR_OFF_UFLW:
    case QHSTA_M_SXFR_OFF_OFLW:
    case QHSTA_M_BAD_CMPL_STATUS_IN:
    case QHSTA_M_SXFR_SDMA_ERR:
    case QHSTA_M_SXFR_UNKNOWN_ERROR:
        return SRB_STATUS_ERROR;

    case QHSTA_M_INVALID_DEVICE:
        return SRB_STATUS_NO_DEVICE;

    case QHSTA_M_AUTO_REQ_SENSE_FAIL:
    case QHSTA_M_NO_AUTO_REQ_SENSE:
        ASC_DBG1(2,
            "ErrXlate: Unexpected Auto-Request Sense 'host_status' 0x%x.\n",
            host_status);
        return 0;

    default:
        ASC_DBG1(2, "ErrXlate: Unknown 'host_status' 0x%x\n", host_status);
        return 0;
    }
    /* NOTREACHED */
}

/*
 * Zero memory starting at 'cp' for 'length' bytes.
 */
VOID
AscZeroMemory(UCHAR *cp, ULONG length)
{
    ULONG i;

    for (i = 0; i < length; i++)
    {
        *cp++ = 0;
    }

}


/*
 * --- Adv Library Required Functions
 *
 * The following functions are called by the Adv Library.
 */

/*
 * Routine Description:
 * 
 *     Callback routine for interrupt handler.
 * 
 * Arguments:
 * 
 *     chipConfig - Pointer to chip configuration structure
 *     scb - Pointer to completed ASC_SCSI_REQ_Q
 * 
 * Return Value:
 *     void
 */
VOID
DvcISRCallBack(
    IN PCHIP_CONFIG chipConfig,
    IN ASC_SCSI_REQ_Q *scb
    )
{
    PHW_DEVICE_EXTENSION HwDeviceExtension = CONFIG2HDE(chipConfig);
    PSCSI_REQUEST_BLOCK srb = (PSCSI_REQUEST_BLOCK) scb->srb_ptr;
    PSCB *ppscb;
    uchar underrun = FALSE;

    ASC_DBG1(3, "DvcISRCallBack: scb 0x%lx\n", scb);
    ASC_DBG2(4, "DvcISRCallBack: chipConfig 0x%lx, srb 0x%lx\n",
        chipConfig, srb);

    if (srb == NULL) {
        ScsiPortLogError(HwDeviceExtension, NULL, 0, 0, 0,
            SP_INTERNAL_ADAPTER_ERROR,
            ADV_SPL_UNIQUEID(ADV_SPL_PROC_INT, 0));
        ASC_DBG(1, "DvcISRCallBack: srb is NULL\n");
        return;
    }

#ifdef ASC_DEBUG
    if (srb->DataTransferLength > 0) {
        ASC_DBG2(4, "DvcISRCallBack: DataTransferLength %lu, data_cnt %lu\n",
            srb->DataTransferLength, scb->data_cnt);
    }
#endif /* ASC_DEBUG */

    /*
     * Check for a data underrun which is indicated by a non-zero
     * 'data_cnt' value. The microcode sets 'data_cnt' to the transfer
     * residual byte count. In the case of an underrun, the SRB
     * 'DataTransferLength' must indicate the actual number of bytes
     * tranferred.
     *
     * Note: The underrun check and possible adjustment must be made before
     * checking 'done_status', 'host_status', and 'scsi_status'. If the
     * original command returned with a Check Condition, it may have
     * performed a valid partial transfer prior to the Check Condition.
     */
    if (srb->DataTransferLength != 0 && scb->data_cnt != 0) {
        ASC_DBG2(2,
            "DvcISRCallBack: DataTransferLength %lu, data_cnt %lu\n",
            srb->DataTransferLength, scb->data_cnt);
        ASC_DBG1(2,
            "DvcISRCallBack: data underrun of %lu bytes\n",
            scb->data_cnt);

        srb->DataTransferLength -= scb->data_cnt;
        underrun = TRUE;
    }

    if (scb->done_status == QD_NO_ERROR) {
        /*
         * Command sucessfully completed
         */
        if (underrun == TRUE)
        {
            /*
             * If DataTransferlength is returned non-zero and the
             * SRB_STATUS_DATA_OVERRUN flag is set an Underrun condition
             * is indicated. There is no separate SrbStatus flag
             * to indicate an Underrun condition.
             */
            srb->SrbStatus = SRB_STATUS_DATA_OVERRUN;
        } else
        {
            srb->SrbStatus = SRB_STATUS_SUCCESS;
        }
        srb->SrbStatus = SRB_STATUS_SUCCESS;
        srb->ScsiStatus = 0;
        ASC_DBG(4, "DvcISRCallBack: QD_NO_ERROR\n");

        /* Check if this successful command is a SCSI Inquiry.
         * If so, we want to record the dev_type using the
         * inquiry data returned.
         */
        if (srb->Cdb[0] == SCSICMD_Inquiry && srb->Lun == 0)
        {
            HwDeviceExtension->dev_type[srb->TargetId] = 
            *((PCHAR)srb->DataBuffer) & 0x1F ;
            ASC_DBG2(1,
                "DvcISRCallBack: HwDeviceExtension->dev_type[TID=0x%x] set to 0x%x.\n",
                srb->TargetId,
                HwDeviceExtension->dev_type[srb->TargetId]);
        }
    
    } else {

        ASC_DBG3(2,
            "DvcISRCallBack: tid %u, done_status 0x%x, scsi_status 0x%x\n",
            scb->target_id, scb->done_status, scb->scsi_status);
        ASC_DBG1(2,
            "DvcISRCallBack: host_status 0x%x\n",
            scb->host_status);

        if (scb->done_status == QD_ABORTED_BY_HOST) {
            /*
             * Command aborted by host.
             */
            ASC_DBG(2, "DvcISRCallBack: QD_ABORTED_BY_HOST\n");
            srb->SrbStatus = SRB_STATUS_ABORTED;
            srb->ScsiStatus = 0;
        } else if (scb->scsi_status != SS_GOOD) {
            ASC_DBG(1, "DvcISRCallBack: scsi_status != SS_GOOD\n");
            /*
             * Set 'ScsiStatus' for SRB.
             */
            srb->SrbStatus = SRB_STATUS_ERROR;
            srb->ScsiStatus = scb->scsi_status;

            //
            // Treat a SCSI Status Byte of BUSY status as a special case
            // in setting the 'SrbStatus' field. STI (Still Image Capture)
            // drivers need this 'SrbStatus', because the STI interface does
            // not include the 'ScsiStatus' byte. These drivers must rely
            // on the 'SrbStatus' field to determine when the target device
            // returns BUSY.
            //
            if (scb->scsi_status == SS_TARGET_BUSY)
            {
                srb->SrbStatus = SRB_STATUS_BUSY;
            } else if (scb->scsi_status == SS_CHK_CONDITION)
            {
                if (scb->host_status == QHSTA_M_AUTO_REQ_SENSE_FAIL) {
                    ASC_DBG(2, "DvcISRCallBack: QHST_M_AUTO_REQ_SENSE_FAIL\n");
                } else if (scb->host_status == QHSTA_M_NO_AUTO_REQ_SENSE) {
                    ASC_DBG(2, "DvcISRCallBack: QHSTA_M_NO_AUTO_REQ_SENSE\n");
                } else {
                    srb->SrbStatus |= SRB_STATUS_AUTOSENSE_VALID;
#ifdef ASC_DEBUG
                    if (scb->orig_sense_len != scb->sense_len)
                    {
                        ASC_DBG2(2,
                            "DvcISRCallBack: orig_sense_len %u, sense_len %u\n",
                            scb->orig_sense_len, scb->sense_len);
                        ASC_DBG1(2,
                            "DvcISRCallBack: sense underrun of %u bytes\n",
                            scb->orig_sense_len);
                    }
#endif /* ASC_DEBUG */
                }
            }
        } else {
            /*
             * SCSI status byte is OK, but 'host_status' is not.
             */
            if ((srb->SrbStatus = ErrXlate(scb->host_status)) == 0)
            {
                srb->SrbStatus = SRB_STATUS_ERROR;

                /*
                 * Because no appropriate 'SrbStatus' value was returned
                 * by ErrXlate(), log an error that includes the returned
                 * 'done_status' and 'host_status' values.
                 */
                ScsiPortLogError(HwDeviceExtension, NULL, 0, 0, 0,
                    SP_INTERNAL_ADAPTER_ERROR,
                    ADV_SPL_UNIQUEID(ADV_SPL_REQ_STAT,
                      ((scb->done_status << 8) | (scb->host_status & 0xFF))));
            }
        }
    }

#ifdef ASC_DEBUG
    /* Check the integrity of the done list. */
    if (*(ppscb = &HDE2DONE(HwDeviceExtension)) != NULL) {
        if (PSCB2SRB(*ppscb) == NULL) {
            ASC_DBG1(1, "DvcISRCallBack: PSCB2SRB() is NULL 1, *ppscb 0x%lx\n",
                *ppscb);
        }
        for (; *ppscb; ppscb = &SCB2NEXTSCB(*ppscb)) {
            if (PSCB2SRB(*ppscb) == NULL) {
                ASC_DBG1(1,
                    "DvcISRCallBack: PSCB2SRB() is NULL 2, *ppscb 0x%lx\n",
                    *ppscb);
            }
        }
    }
#endif /* ASC_DEBUG */

    /*
     * Add the SCB to end of the completion list. The request will be
     * completed in HwInterrupt().
     */
    for (ppscb = &HDE2DONE(HwDeviceExtension); *ppscb;
         ppscb = &SCB2NEXTSCB(*ppscb)) {
        ;
    }
    *ppscb = SRB2PSCB(srb);
    SRB2NEXTSCB(srb) = NULL;

    return;
}

/*
 * Routine Description:
 * 
 *     Callback routine for hardware detected SCSI Bus Reset.
 * 
 * Arguments:
 * 
 *     chipConfig - Pointer to chip configuration structure
 * 
 * Return Value:
 *     void
 */
VOID
DvcSBResetCallBack(
    IN PCHIP_CONFIG chipConfig
    )
{
    PHW_DEVICE_EXTENSION HwDeviceExtension = CONFIG2HDE(chipConfig);

    ASC_DBG1(2, "DvcSBResetCallBack: chipConfig 0x%lx\n", chipConfig);
    ScsiPortNotification(ResetDetected, HwDeviceExtension);
}

/*
 * This routine delays 'msec' as required by Asc Library.
 */
VOID
DvcSleepMilliSecond(
    ulong msec
    )
{
    ulong i;
    for (i = 0; i < msec; i++) {
        ScsiPortStallExecution(1000L);
    }
}

/*
 * Delay for specificed number of microseconds.
 */
void
DvcDelayMicroSecond(
    ASC_DVC_VAR *asc_dvc,
    ushort micro_sec
          )
{
    ScsiPortStallExecution((long) micro_sec);
}

/*
 * DvcGetPhyAddr()
 *
 * Return the physical address of 'vaddr' and set '*lenp' to the
 * number of physically bytes that follow the physical address.
 *
 * 'flag' indicates whether 'vaddr' points to a ASC_SCSI_REQ_Q
 * structure. It is currently unused.
 */
ulong
DvcGetPhyAddr(PCHIP_CONFIG chipConfig, PSCB scb,
        UCHAR *vaddr, LONG *lenp, int flag)
{
    PHW_DEVICE_EXTENSION HwDeviceExtension = CONFIG2HDE(chipConfig);
    ulong                paddr;
    PSCSI_REQUEST_BLOCK  srb;

    /*
     * 'vaddr' may be 0! There used to be an assert here that 'vaddr' not
     * be NULL. It appears that the 'srb' combined with 'vaddr' produce a
     * valid virtual address space address for a 'vaddr' of 0.
     *
     * ASC_DASSERT(vaddr != NULL);
     */
    ASC_DASSERT(lenp != NULL);

    /*
     * If a non-NULL 'scb' was given as an argument, then it must
     * be converted to an 'srb' and passed to ScsiPortGetPhysicalAddress().
     */
    if (flag & ADV_ASCGETSGLIST_VADDR) {
        srb = PSCB2SRB(scb);
    } else {
        srb = NULL;
    }
    paddr = ScsiPortConvertPhysicalAddressToUlong(
                ScsiPortGetPhysicalAddress(HwDeviceExtension, srb,
                   (PVOID) vaddr, (ulong *) lenp));

    ASC_DBG4(4,
        "DvcGetPhyAddr: vaddr 0x%lx, lenp 0x%lx *lenp %lu, paddr 0x%lx\n", 
        vaddr, lenp, *((ulong *) lenp), paddr);
    return paddr;
}

/*
 * Input a PCI configuration byte.
 */
UCHAR 
DvcReadPCIConfigByte(
    ASC_DVC_VAR         *asc_dvc, 
    USHORT              offset
   )
{
    PCI_COMMON_CONFIG   pci_config;
    PCI_SLOT_NUMBER     pci_slot;
#ifdef ASC_DEBUG
    ulong               size;
#endif /* ASC_DEBUG */

    pci_slot.u.AsULONG = 0;
    pci_slot.u.bits.DeviceNumber =
        ASC_PCI_ID2DEV(asc_dvc->cfg->pci_slot_info);
    pci_slot.u.bits.FunctionNumber =
        ASC_PCI_ID2FUNC(asc_dvc->cfg->pci_slot_info);

#ifdef ASC_DEBUG
    size =
#else /* ASC_DEBUG */
    (VOID)
#endif /* ASC_DEBUG */
    ScsiPortGetBusData(
        (PVOID) asc_dvc,            /* HwDeviceExtension */
        PCIConfiguration,           /* Bus Type */
        (ulong) ASC_PCI_ID2BUS(asc_dvc->cfg->pci_slot_info), /* Bus Number */
        pci_slot.u.AsULONG,         /* Device and Function Number */
        &pci_config,                /* Buffer */
        sizeof(PCI_COMMON_CONFIG)   /* Length */
        );

#ifdef ASC_DEBUG
        if (size != sizeof(PCI_COMMON_CONFIG)) {
            ASC_DBG1(1, "DvcReadPCIConfigByte: Bad PCI Config size: %lu\n",
                size);
        }
#endif /* ASC_DEBUG */

    return(*((PUCHAR)(&pci_config) + offset));
}

/*
 * Output a PCI configuration byte.
 */
void
DvcWritePCIConfigByte(
   ASC_DVC_VAR          *asc_dvc, 
   USHORT               offset, 
   UCHAR                byte_data
   )
{
    PCI_SLOT_NUMBER     pci_slot;

    pci_slot.u.AsULONG = 0;
    pci_slot.u.bits.DeviceNumber =
        ASC_PCI_ID2DEV(asc_dvc->cfg->pci_slot_info);
    pci_slot.u.bits.FunctionNumber =
        ASC_PCI_ID2FUNC(asc_dvc->cfg->pci_slot_info);

    /*
     * Write it out
     */
    (void) ScsiPortSetBusDataByOffset(
        (PVOID)asc_dvc,                      /* HwDeviceExtension */
        PCIConfiguration,                    /* Bus type */
        (ulong) ASC_PCI_ID2BUS(asc_dvc->cfg->pci_slot_info), /* Bus Number */
        pci_slot.u.AsULONG,                  /* Device and Function Number */
        &byte_data,                          /* Buffer */
        offset,                              /* Offset */
        1                                    /* Length */
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc3550\a_mcode.c ===
/*
 * a_mcode.c - Adv Library Microcode C Source File
 *
 * Copyright (c) 1997-1998 Advanced System Products, Inc.
 * All Rights Reserved.
 */

#include "a_qswap.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc3550\a_init.c ===
/*
 * a_init.c - Adv Library Driver Initialization Source File
 *
 * Functions defined in this function are not used after driver
 * initialization.
 *
 * Copyright (c) 1997-1998 Advanced System Products, Inc.
 * All Rights Reserved.
 */

#include "a_ver.h"       /* Version */
#include "d_os_dep.h"    /* Driver */
#include "a_scsi.h"      /* SCSI */
#include "a_condor.h"    /* AdvanSys Hardware */
#include "a_advlib.h"    /* Adv Library */

/*
 * Define a 12-bit unique file id which may by used by a driver for
 * debugging or tracing purposes. Each C source file must define a
 * different value.
 */
#define ADV_FILE_UNIQUE_ID           0xAD1   /* Adv Library C Source File #1 */

extern ulong _adv_mcode_chksum;
extern ushort _adv_mcode_size;
extern uchar _adv_mcode_buf[];

/*
 * Default EEPROM Configuration.
 *
 * All drivers should use this structure to set the default EEPROM
 * configuration. The BIOS now uses this structure when it is built.
 * Additional structure information can be found in a_condor.h where
 * the structure is defined.
 */
ASCEEP_CONFIG
Default_EEPROM_Config = {
    ADV_EEPROM_BIOS_ENABLE,     /* cfg_msw */
    0x0000,                     /* cfg_lsw */
    0xFFFF,                     /* disc_enable */
    0xFFFF,                     /* wdtr_able */
    0xFFFF,                     /* sdtr_able */
    0xFFFF,                     /* start_motor */
    0xFFFF,                     /* tagqng_able */
    0xFFFF,                     /* bios_scan */
    0,                          /* scam_tolerant */
    7,                          /* adapter_scsi_id */
    0,                          /* bios_boot_delay */
    3,                          /* scsi_reset_delay */
    0,                          /* bios_id_lun */
    0,                          /* termination */
    0,                          /* reserved1 */
    0xFFE7,                     /* bios_ctrl */
    0xFFFF,                     /* ultra_able */
    0,                          /* reserved2 */
    ASC_DEF_MAX_HOST_QNG,       /* max_host_qng */
    ASC_DEF_MAX_DVC_QNG,        /* max_dvc_qng */
    0,                          /* dvc_cntl */
    0,                          /* bug_fix */
    0,                          /* serial_number_word1 */
    0,                          /* serial_number_word2 */
    0,                          /* serial_number_word3 */
    0,                          /* check_sum */
    { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, /* oem_name[16] */
    0,                          /* dvc_err_code */
    0,                          /* adv_err_code */
    0,                          /* adv_err_addr */
    0,                          /* saved_dvc_err_code */
    0,                          /* saved_adv_err_code */
    0,                          /* saved_adv_err_addr */
    0                           /* num_of_err */
};

/*
 * Initialize the ASC_DVC_VAR structure.
 *
 * On failure set the ASC_DVC_VAR field 'err_code' and return ADV_ERROR.
 *
 * For a non-fatal error return a warning code. If there are no warnings
 * then 0 is returned.
 */
int
AdvInitGetConfig(ASC_DVC_VAR WinBiosFar *asc_dvc)
{
    ushort      warn_code;
    PortAddr    iop_base;
#ifndef ADV_OS_MAC
    uchar       pci_cmd_reg;
#endif /* ADV_OS_MAC */
    int         status;

    warn_code = 0;
    asc_dvc->err_code = 0;
    iop_base = asc_dvc->iop_base;

    /*
     * PCI Command Register
     */
#ifndef ADV_OS_MAC
    if (((pci_cmd_reg = DvcReadPCIConfigByte(asc_dvc,
                            AscPCIConfigCommandRegister))
         & AscPCICmdRegBits_BusMastering)
        != AscPCICmdRegBits_BusMastering)
    {
        pci_cmd_reg |= AscPCICmdRegBits_BusMastering;

        DvcWritePCIConfigByte(asc_dvc,
                AscPCIConfigCommandRegister, pci_cmd_reg);

        if (((DvcReadPCIConfigByte(asc_dvc, AscPCIConfigCommandRegister))
             & AscPCICmdRegBits_BusMastering)
            != AscPCICmdRegBits_BusMastering)
        {
            warn_code |= ASC_WARN_SET_PCI_CONFIG_SPACE;
        }
    }

    /*
     * PCI Latency Timer
     *
     * If the "latency timer" register is 0x20 or above, then we don't need
     * to change it.  Otherwise, set it to 0x20 (i.e. set it to 0x20 if it
     * comes up less than 0x20).
     */
    if (DvcReadPCIConfigByte(asc_dvc, AscPCIConfigLatencyTimer) < 0x20) {
        DvcWritePCIConfigByte(asc_dvc, AscPCIConfigLatencyTimer, 0x20);
        if (DvcReadPCIConfigByte(asc_dvc, AscPCIConfigLatencyTimer) < 0x20)
        {
            warn_code |= ASC_WARN_SET_PCI_CONFIG_SPACE;
        }
    }
#endif /* ADV_OS_MAC */
    /*
     * Save the state of the PCI Configuration Command Register
     * "Parity Error Response Control" Bit. If the bit is clear (0),
     * in AdvInitAsc3550Driver() tell the microcode to ignore DMA
     * parity errors.
     */
    asc_dvc->cfg->control_flag = 0;
#ifndef ADV_OS_MAC
    if (((DvcReadPCIConfigByte(asc_dvc, AscPCIConfigCommandRegister)
         & AscPCICmdRegBits_ParErrRespCtrl)) == 0)
    {
        asc_dvc->cfg->control_flag |= CONTROL_FLAG_IGNORE_PERR;
    }
#endif /* ADV_OS_MAC */
    asc_dvc->cur_host_qng = 0;

    asc_dvc->cfg->lib_version = (ASC_LIB_VERSION_MAJOR << 8) |
      ASC_LIB_VERSION_MINOR;
    asc_dvc->cfg->chip_version =
      AdvGetChipVersion(iop_base, asc_dvc->bus_type);

    /*
     * Reset the chip to start and allow register writes.
     */
    if (AdvFindSignature(iop_base) == 0)
    {
        asc_dvc->err_code = ASC_IERR_BAD_SIGNATURE;
        return ADV_ERROR;
    }
    else {

        AdvResetChip(asc_dvc);

        if ((status = AscInitFromEEP(asc_dvc)) == ADV_ERROR)
        {
            return ADV_ERROR;
        }
        warn_code |= status;

        /*
         * Reset the SCSI Bus if the EEPROM indicates that SCSI Bus
         * Resets should be performed.
         */
        if (asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS)
        {
            AscResetSCSIBus(asc_dvc);
        }
    }

    return warn_code;
}

/*
 * Initialize the ASC3550.
 *
 * On failure set the ASC_DVC_VAR field 'err_code' and return ADV_ERROR.
 *
 * For a non-fatal error return a warning code. If there are no warnings
 * then 0 is returned.
 */
int
AdvInitAsc3550Driver(ASC_DVC_VAR WinBiosFar *asc_dvc)
{
    PortAddr    iop_base;
    ushort      warn_code;
    ulong       sum;
    int         begin_addr;
    int         end_addr;
    int         code_sum;
    int         word;
    int         rql_addr;                   /* RISC Queue List address */
#if ADV_UCODEDEFAULT
    int         tid;
#endif /* ADV_UCODEDEFAULT */
    int         i;
    ushort      scsi_cfg1;
    uchar       biosmem[ASC_MC_BIOSLEN];    /* BIOS RISC Memory 0x40-0x8F. */

    /* If there is already an error, don't continue. */
    if (asc_dvc->err_code != 0)
    {
        return ADV_ERROR;
    }

    warn_code = 0;
    iop_base = asc_dvc->iop_base;

#if ADV_SCAM
    /*
     * Perform SCAM
     */
    if (!(asc_dvc->bios_ctrl & BIOS_CTRL_NO_SCAM))
    {
        AscSCAM(asc_dvc);
    }
#endif /* ADV_SCAM */

    /*
     * Save the RISC memory BIOS region before writing the microcode.
     * The BIOS may already be loaded and using its RISC LRAM region
     * so its region must be saved and restored.
     *
     * Note: This code makes the assumption, which is currently true,
     * that a chip reset does not clear RISC LRAM.
     */
    for (i = 0; i < ASC_MC_BIOSLEN; i++)
    {
        biosmem[i] = AscReadByteLram(iop_base, ASC_MC_BIOSMEM + i);
    }

    /*
     * Load the Microcode
     *
     * Write the microcode image to RISC memory starting at address 0.
     */
    AscWriteWordRegister(iop_base, IOPW_RAM_ADDR, 0);
    for (word = 0; word < _adv_mcode_size; word += 2)
    {
#if ADV_BIG_ENDIAN
        outpw_noswap(iop_base, *((ushort *) (&_adv_mcode_buf[word])));
#else /* ADV_BIG_ENDIAN */
        AscWriteWordAutoIncLram(iop_base,
            *((ushort *) (&_adv_mcode_buf[word])));
#endif /* ADV_BIG_ENDIAN */
    }

    /*
     * Clear the rest of Condor's Internal RAM (8KB).
     */
    for (; word < ADV_CONDOR_MEMSIZE; word += 2)
    {
        AscWriteWordAutoIncLram(iop_base, 0);
    }

    /*
     * Verify the microcode checksum.
     */
    sum = 0;
    AscWriteWordRegister(iop_base, IOPW_RAM_ADDR, 0);
    for (word = 0; word < _adv_mcode_size; word += 2)
    {
        sum += AscReadWordAutoIncLram(iop_base);
    }

    if (sum != _adv_mcode_chksum)
    {
        asc_dvc->err_code |= ASC_IERR_MCODE_CHKSUM;
        return ADV_ERROR;
    }

    /*
     * Restore the RISC memory BIOS region.
     */
    for (i = 0; i < ASC_MC_BIOSLEN; i++)
    {
        AscWriteByteLram(iop_base, ASC_MC_BIOSMEM + i, biosmem[i]);
    }

    /*
     * Calculate and write the microcode code checksum to the microcode
     * code checksum location ASC_MC_CODE_CHK_SUM (0x2C).
     */
    begin_addr = AscReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR);
    end_addr = AscReadWordLram(iop_base, ASC_MC_CODE_END_ADDR);
    code_sum = 0;
    for (word = begin_addr; word < end_addr; word += 2)
    {
#if ADV_BIG_ENDIAN
        code_sum += EndianSwap16Bit(*((ushort *) (&_adv_mcode_buf[word])));
#else /* ADV_BIG_ENDIAN */
        code_sum += *((ushort *) (&_adv_mcode_buf[word]));
#endif /* ADV_BIG_ENDIAN */
    }
    AscWriteWordLram(iop_base, ASC_MC_CODE_CHK_SUM, code_sum);

    /*
     * Read microcode version and date.
     */
    asc_dvc->cfg->mcode_date =
        AscReadWordLram(iop_base, ASC_MC_VERSION_DATE);

    asc_dvc->cfg->mcode_version =
        AscReadWordLram(iop_base, ASC_MC_VERSION_NUM);

    /*
     * Initialize microcode operating variables
     */
    AscWriteWordLram(iop_base, ASC_MC_ADAPTER_SCSI_ID,
                       asc_dvc->chip_scsi_id);

    /*
     * If the PCI Configuration Command Register "Parity Error Response
     * Control" Bit was clear (0), then set the microcode variable
     * 'control_flag' CONTROL_FLAG_IGNORE_PERR flag to tell the microcode
     * to ignore DMA parity errors.
     */
    if (asc_dvc->cfg->control_flag & CONTROL_FLAG_IGNORE_PERR)
    {
        /*
         * Note: Don't remove the use of a temporary variable in
         * the following code, otherwise the Microsoft C compiler
         * will turn the following lines into a no-op.
         */
        word = AscReadWordLram(iop_base, ASC_MC_CONTROL_FLAG);
        word |= CONTROL_FLAG_IGNORE_PERR;
        AscWriteWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);
    }

    /*
     * Set default microcode operating variables for WDTR, SDTR, and
     * command tag queuing based on the EEPROM configuration values.
     *
     * These ASC_DVC_VAR fields and the microcode variables will be
     * changed in AdvInquiryHandling() if it is found a device is
     * incapable of a particular feature.
     */

#if ADV_UCODEDEFAULT
    /*
     * Set microcode WDTR target mask.
     *
     * Set the mask value initially to zero. If the EEPROM has
     * enabled WDTR for a target, then WDTR for that target may
     * be enabled after an Inquiry command for the target completes.
     *
     * The microcode manages the handshake configuration table
     * ASC_MC_DEVICE_HSHK_CFG_TABLE (0x100) based on the 'wdtr_able'.
     *
     * Note: The microcode image defaults to a value of zero.
     */
     AscWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, 0);
#endif /* ADV_UCODEDEFAULT */

#if ADV_UCODEDEFAULT
    /*
     * Set microcode SDTR target mask.
     *
     * Set the mask value initially to zero. If the EEPROM has
     * enabled SDTR for a target, then SDTR for that target may
     * be enabled after an Inquiry command for the target completes.
     *
     * Note: The microcode image defaults to a value of zero.
     */
    AscWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, 0);
#endif /* ADV_UCODEDEFAULT */

    /*
     * Set the microcode ULTRA target mask from EEPROM value. The
     * SDTR target mask overrides the ULTRA target mask in the
     * microcode so it is safe to set this value without determining
     * whether the device supports SDTR.
     *
     * Note: There is no way to know whether a device supports ULTRA
     * speed without attempting a SDTR ULTRA speed negotiation with
     * the device. The device will reject the speed if it does not
     * support it by responding with an SDTR message containing a
     * slower speed.
     */
    AscWriteWordLram(iop_base, ASC_MC_ULTRA_ABLE, asc_dvc->ultra_able);
#if ADV_UCODEDEFAULT
    /*
     * Set microcode Tag Queuing target mask.
     *
     * Set the mask value initially to zero. If the EEPROM has
     * enabled Tag Queuing for a target, then Tag Queuing for
     * that target may be enabled after an Inquiry command for
     * the target completes.
     *
     * Note: The microcode image defaults to a value of zero.
     */
    AscWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE, 0);
#endif /* ADV_UCODEDEFAULT */

#if ADV_UCODEDEFAULT
    /*
     * Initially set all device command limits to 1. As with the
     * microcode Tag Queuing target mask if the EEPROM has
     * enabled Tag Queuing for a target, then the command limit
     * may be increased an Inquiry command for the target completes.
     * Note: The microcode image defaults to a value of zero.
     */
    for (tid = 0; tid <= ASC_MAX_TID; tid++)
    {
        AscWriteByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid, 1);
    }
#endif /* ADV_UCODEDEFAULT */

    AscWriteWordLram(iop_base, ASC_MC_DISC_ENABLE, asc_dvc->cfg->disc_enable);


    /*
     * Set SCSI_CFG0 Microcode Default Value.
     *
     * The microcode will set the SCSI_CFG0 register using this value
     * after it is started below.
     */
    AscWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG0,
        PARITY_EN | SEL_TMO_LONG | OUR_ID_EN | asc_dvc->chip_scsi_id);

    /*
     * Determine SCSI_CFG1 Microcode Default Value.
     *
     * The microcode will set the SCSI_CFG1 register using this value
     * after it is started below.
     */

    /* Read current SCSI_CFG1 Register value. */
    scsi_cfg1 = AscReadWordRegister(iop_base, IOPW_SCSI_CFG1);

    /*
     * If all three connectors are in use, return an error.
     */
    if ((scsi_cfg1 & CABLE_ILLEGAL_A) == 0 ||
        (scsi_cfg1 & CABLE_ILLEGAL_B) == 0)
    {
#ifdef ADV_OS_DOS
        /*
         * For the Manufacturing Test DOS ASPI ignore illegal use of
         * the three connectors.
         */
        if (!m_opt)
        {
#endif /* ADV_OS_DOS */
        asc_dvc->err_code |= ASC_IERR_ILLEGAL_CONNECTION;
#ifdef ADV_OS_DIAG
        /*
         * If all three connectors are in use, then display
         * error information and exit.
         */
        cprintf("\r\n   All three connectors are in use .......................ILLEGAL\r\n");
        HaltSystem(illegalerr);
#endif /* ADV_OS_DIAG */
        return ADV_ERROR;
#ifdef ADV_OS_DOS
        }
#endif /* ADV_OS_DOS */
    }

#ifdef ADV_OS_DIAG
   /*
    * Display information about connectors.
    */
   cprintf("\r\n      Connector information:\r\n");
   if ((scsi_cfg1 & 0x02) == 0 ) /* 0x0D internal narrow */
   {
       cprintf("      Internal narrow connector is in use\r\n");
   }else
   {
       cprintf("      Internal narrow connector is free\r\n");
   }

   if ((scsi_cfg1 & 0x04 )== 0) /* 0x0B External narrow */
   {
       cprintf("      External narrow connector is in use\r\n");
   } else
   {
       cprintf("      External narrow connector is free\r\n");
   }

   if ((scsi_cfg1 & 0x01 )== 0) /* 0x0E internal wide */
   {
       cprintf("      Internal wide connector is in use\r\n");
   }else
   {
        cprintf("      Internal wide connector is free\r\n");
        wideconnectorfree = 1;
   }
#endif /* ADV_OS_DIAG */
    /*
     * If the internal narrow cable is reversed all of the SCSI_CTRL
     * register signals will be set. Check for and return an error if
     * this condition is found.
     */
    if ((AscReadWordRegister(iop_base, IOPW_SCSI_CTRL) & 0x3F07) == 0x3F07)
    {
        asc_dvc->err_code |= ASC_IERR_REVERSED_CABLE;
        return ADV_ERROR;
    }

    /*
     * If this is a differential board and a single-ended device
     * is attached to one of the connectors, return an error.
     */
    if ((scsi_cfg1 & DIFF_MODE) && (scsi_cfg1 & DIFF_SENSE) == 0)
    {
        asc_dvc->err_code |= ASC_IERR_SINGLE_END_DEVICE;
        return ADV_ERROR;
    }

    /*
     * If automatic termination control is enabled, then set the
     * termination value based on a table listed in a_condor.h.
     *
     * If manual termination was specified with an EEPROM setting
     * then 'termination' was set-up in AscInitFromEEPROM() and
     * is ready to be 'ored' into SCSI_CFG1.
     */
    if (asc_dvc->cfg->termination == 0)
    {
        /*
         * The software always controls termination by setting TERM_CTL_SEL.
         * If TERM_CTL_SEL were set to 0, the hardware would set termination.
         */
        asc_dvc->cfg->termination |= TERM_CTL_SEL;

        switch(scsi_cfg1 & CABLE_DETECT)
        {
            /* TERM_CTL_H: on, TERM_CTL_L: on */
            case 0x3: case 0x7: case 0xB: case 0xD: case 0xE: case 0xF:
                asc_dvc->cfg->termination |= (TERM_CTL_H | TERM_CTL_L);
                break;

            /* TERM_CTL_H: on, TERM_CTL_L: off */
            case 0x1: case 0x5: case 0x9: case 0xA: case 0xC:
                asc_dvc->cfg->termination |= TERM_CTL_H;
                break;

            /* TERM_CTL_H: off, TERM_CTL_L: off */
            case 0x2: case 0x6:
                break;
        }
    }

    /*
     * Clear any set TERM_CTL_H and TERM_CTL_L bits.
     */
    scsi_cfg1 &= ~TERM_CTL;

    /*
     * Invert the TERM_CTL_H and TERM_CTL_L bits and then
     * set 'scsi_cfg1'. The TERM_POL bit does not need to be
     * referenced, because the hardware internally inverts
     * the Termination High and Low bits if TERM_POL is set.
     */
    scsi_cfg1 |= (TERM_CTL_SEL | (~asc_dvc->cfg->termination & TERM_CTL));

    /*
     * Set SCSI_CFG1 Microcode Default Value
     *
     * Set filter value and possibly modified termination control
     * bits in the Microcode SCSI_CFG1 Register Value.
     *
     * The microcode will set the SCSI_CFG1 register using this value
     * after it is started below.
     */
    AscWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG1,
                       FLTR_11_TO_20NS | scsi_cfg1);

#if ADV_UCODEDEFAULT
    /*
     * Set MEM_CFG Microcode Default Value
     *
     * The microcode will set the MEM_CFG register using this value
     * after it is started below.
     *
     * MEM_CFG may be accessed as a word or byte, but only bits 0-7
     * are defined.
     */
    AscWriteWordLram(iop_base, ASC_MC_DEFAULT_MEM_CFG,
                        BIOS_EN | RAM_SZ_8KB);
#endif /* ADV_UCODEDEFAULT */

    /*
     * Set SEL_MASK Microcode Default Value
     *
     * The microcode will set the SEL_MASK register using this value
     * after it is started below.
     */
    AscWriteWordLram(iop_base, ASC_MC_DEFAULT_SEL_MASK,
                        ADV_TID_TO_TIDMASK(asc_dvc->chip_scsi_id));

    /*
     * Link all the RISC Queue Lists together in a doubly-linked
     * NULL terminated list.
     *
     * Skip the NULL (0) queue which is not used.
     */
    for (i = 1, rql_addr = ASC_MC_RISC_Q_LIST_BASE + ASC_MC_RISC_Q_LIST_SIZE;
         i < ASC_MC_RISC_Q_TOTAL_CNT;
         i++, rql_addr += ASC_MC_RISC_Q_LIST_SIZE)
    {
        /*
         * Set the current RISC Queue List's RQL_FWD and RQL_BWD pointers
         * in a one word write and set the state (RQL_STATE) to free.
         */
        AscWriteWordLram(iop_base, rql_addr, ((i + 1) + ((i - 1) << 8)));
        AscWriteByteLram(iop_base, rql_addr + RQL_STATE, ASC_MC_QS_FREE);
    }

    /*
     * Set the Host and RISC Queue List pointers.
     *
     * Both sets of pointers are initialized with the same values:
     * ASC_MC_RISC_Q_FIRST(0x01) and ASC_MC_RISC_Q_LAST (0xFF).
     */
    AscWriteByteLram(iop_base, ASC_MC_HOST_NEXT_READY, ASC_MC_RISC_Q_FIRST);
    AscWriteByteLram(iop_base, ASC_MC_HOST_NEXT_DONE, ASC_MC_RISC_Q_LAST);

    AscWriteByteLram(iop_base, ASC_MC_RISC_NEXT_READY, ASC_MC_RISC_Q_FIRST);
    AscWriteByteLram(iop_base, ASC_MC_RISC_NEXT_DONE, ASC_MC_RISC_Q_LAST);

    /*
     * Finally, set up the last RISC Queue List (255) with
     * a NULL forward pointer.
     */
    AscWriteWordLram(iop_base, rql_addr, (ASC_MC_NULL_Q + ((i - 1) << 8)));
    AscWriteByteLram(iop_base, rql_addr + RQL_STATE, ASC_MC_QS_FREE);
#ifndef ADV_OS_MAC
    AscWriteByteRegister(iop_base, IOPB_INTR_ENABLES,
         (ADV_INTR_ENABLE_HOST_INTR | ADV_INTR_ENABLE_GLOBAL_INTR));
#endif /* ADV_OS_MAC */
    /*
     * Note: Don't remove the use of a temporary variable in
     * the following code, otherwise the Microsoft C compiler
     * will turn the following lines into a no-op.
     */
    word = AscReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR);
    AscWriteWordRegister(iop_base, IOPW_PC, word);

    /* finally, finally, gentlemen, start your engine */
    AscWriteWordRegister(iop_base, IOPW_RISC_CSR, ADV_RISC_CSR_RUN);

    return warn_code;
}

#if ADV_INITSCSITARGET
/*
 * Initialize SCSI target devices
 *
 * Returns two arrays: ASC_DVC_INQ_INFO and ASC_CAP_INFO_ARRAY. The
 * second array is optional.
 *
 * 'work_sp_buf' must point to enough space for a doubleword aligned
 * structure containing a ASC_SCSI_REQ_Q, ASC_SCSI_INQUIRY, and
 * ASC_REQ_SENSE structures.
 * Here's an example of a size definition that will guarantee enough
 * space for AdvInitScsiTarget()
 *
 * #define ADV_INITSCSITARGET_BUFFER_SIZE \
 *      (sizeof(ASC_SCSI_REQ_Q) + \
 *       sizeof(ASC_SCSI_INQUIRY) + \
 *       sizeof(ASC_REQ_SENSE) + \
 *       3 * (sizeof(ulong) - 1))
 *
 * If the ADV_SCAN_LUN flag is set in the 'cntl_flag' argument, LUN
 * scanning will be done.
 */
int
AdvInitScsiTarget(ASC_DVC_VAR WinBiosFar *asc_dvc,
                  ASC_DVC_INQ_INFO dosfar *target,
                  uchar dosfar *work_sp_buf,
                  ASC_CAP_INFO_ARRAY dosfar *cap_array,
                  ushort cntl_flag)
{
    int                         dvc_found;
    int                         sta;
    uchar                       tid, lun;
    uchar                       scan_tid;
#ifdef ADV_OS_BIOS
    uchar                       bios_tid;
#endif /* ADV_OS_BIOS */
    ASC_SCSI_REQ_Q dosfar       *scsiq;
    ASC_SCSI_INQUIRY dosfar     *inq;
    ASC_REQ_SENSE dosfar        *sense;
    ASC_CAP_INFO dosfar         *cap_info;
    uchar                       max_lun_scan;

    /* Align buffers on a double word boundary. */
    scsiq = (ASC_SCSI_REQ_Q dosfar *)
        ADV_DWALIGN(work_sp_buf);

    inq = (ASC_SCSI_INQUIRY dosfar *)
        ADV_DWALIGN((ulong) scsiq + sizeof(ASC_SCSI_REQ_Q));

    sense = (ASC_REQ_SENSE dosfar *)
        ADV_DWALIGN((ulong) inq + sizeof(ASC_SCSI_INQUIRY));

    for (tid = 0; tid <= ASC_MAX_TID; tid++)
    {
        for (lun = 0; lun <= ASC_MAX_LUN; lun++)
        {
            target->type[tid][lun] = SCSI_TYPE_NO_DVC;
        }
    }

    dvc_found = 0;
    if (cntl_flag & ADV_SCAN_LUN)
    {
        max_lun_scan = ASC_MAX_LUN;
    } else
    {
        max_lun_scan = 0;
    }

    for (tid = 0; tid <= ASC_MAX_TID; tid++)
    {
#ifdef ADV_OS_DOS
        /*
         * For the Manufacturing Test DOS ASPI only scan TIDs
         * 0, 1, and 2.
         */
        if (m_opt && tid > 2)
        {
            break;
        }
#endif /* ADV_OS_DOS */
        for (lun = 0; lun <= max_lun_scan; lun++)
        {
#ifdef ADV_OS_BIOS
            //
            // Default boot device is TID 0.
            //
            if ((bios_tid = (asc_dvc->cfg->bios_id_lun & ASC_MAX_TID)) == 0)
            {
                scan_tid = tid;
            } else
            {
                /*
                 * Re-order TID scanning so that the EEPROM
                 * specified bios_id_lun TID is scanned first.
                 * All other TIDs are moved down in the order
                 * by one.
                 */
                if (tid == 0)
                {
                    scan_tid = bios_tid; /* Scan 'bios_id_lun' TID first. */
                } else if (tid <= bios_tid)
                {
                    scan_tid = tid - 1;
                } else
                {
                    scan_tid = tid;
                }
            }
#else /* ADV_OS_BIOS */
            scan_tid = tid;
#endif /* !ADV_OS_BIOS */

            if (scan_tid == asc_dvc->chip_scsi_id)
            {
#ifdef ADV_OS_BIOS
                /*
                 * Indicate the chip SCSI ID to the BIOS scan function
                 * by passing the inquiry pointer as NULL.
                 */
                BIOSDispInquiry(scan_tid, (ASC_SCSI_INQUIRY dosfar *) NULL);
#endif /* ADV_OS_BIOS */
                continue;
            }

            scsiq->target_id = scan_tid;
            scsiq->target_lun = lun;

            if (cap_array != 0L)
            {
                /*
                 * ADV_CAPINFO_NOLUN indicates that 'cap_array'
                 * is not an ASC_CAP_INFO_ARRAY.
                 *
                 * Instead it is an array of ASC_CAP_INFO structures
                 * with ASC_MAX_TID elements which is much smaller
                 * than an ASC_CAP_INFO_ARRAY. The caller can provide
                 * a much smaller 'cap_array' buffer to
                 * AdvInitScsiTarget().
                 */
                if (cntl_flag & ADV_CAPINFO_NOLUN)
                {
                    cap_info = &((ASC_CAP_INFO dosfar *) cap_array)[scan_tid];
                } else
                {
                    cap_info = &cap_array->cap_info[scan_tid][lun];
                }
            } else
            {
                cap_info = (ASC_CAP_INFO dosfar *) 0L;
            }
#if (OS_UNIXWARE || OS_SCO_UNIX)
            sta = AdvInitPollTarget(asc_dvc, scsiq, inq, cap_info, sense);
#else
            sta = AscInitPollTarget(asc_dvc, scsiq, inq, cap_info, sense);
#endif

            if (sta == ADV_SUCCESS)
            {
#ifdef ADV_OS_BIOS
                if ((asc_dvc->cfg->bios_scan & ADV_TID_TO_TIDMASK(scan_tid))
                    == 0)
                {
                    break; /* Ignoring current TID; Try next TID. */
                } else
                {
#endif /* ADV_OS_BIOS */
                    dvc_found++;
                    target->type[scan_tid][lun] = inq->peri_dvc_type;
#ifdef ADV_OS_BIOS
                }
#endif /* ADV_OS_BIOS */
            } else
            {
#ifdef ADV_OS_DOS
                /*
                 * The manufacturing test needs to return immediately
                 * on any error.
                 */
                if (m_opt)
                {
                    return (dvc_found);
                }
#endif /* ADV_OS_DOS */
                break; /* TID/LUN Not Found; Try next TID. */
            }
        }
    }
#ifdef ADV_OS_MAC
    AscWriteByteRegister(asc_dvc->iop_base, IOPB_INTR_ENABLES,
                (ADV_INTR_ENABLE_HOST_INTR | ADV_INTR_ENABLE_GLOBAL_INTR));
#endif /* ADV_OS_MAC */
    return (dvc_found);
}

/*
 * Send initialization command to each target device
 *
 * Return Values:
 *   ADV_FALSE - inquiry failed for target
 *   ADV_SUCCESS - target found
 */
int
#if (OS_UNIXWARE || OS_SCO_UNIX)
AdvInitPollTarget(
#else
AscInitPollTarget(
#endif
                  ASC_DVC_VAR WinBiosFar *asc_dvc,
                  ASC_SCSI_REQ_Q dosfar *scsiq,
                  ASC_SCSI_INQUIRY dosfar *inq,
                  ASC_CAP_INFO dosfar *cap_info,
                  ASC_REQ_SENSE dosfar *sense)
{
    uchar       tid_no;
    uchar       dvc_type;
    int         support_read_cap;
#ifdef ADV_OS_BIOS
    uchar       status = ADV_SUCCESS;
#endif /* ADV_OS_BIOS */

    tid_no = scsiq->target_id;

    /*
     * Send an INQUIRY command to the device.
     */
    scsiq->cdb[0] = (uchar) SCSICMD_Inquiry;
    scsiq->cdb[1] = scsiq->target_lun << 5;        /* LUN */
    scsiq->cdb[2] = 0;
    scsiq->cdb[3] = 0;
    scsiq->cdb[4] = sizeof(ASC_SCSI_INQUIRY);
    scsiq->cdb[5] = 0;
    scsiq->cdb_len = 6;
    scsiq->sg_list_ptr = 0;             /* no sg work area */

    if (AscScsiUrgentCmd(asc_dvc, scsiq,
            (uchar dosfar *) inq, sizeof(ASC_SCSI_INQUIRY),
            (uchar dosfar *) sense, sizeof(ASC_REQ_SENSE)) != ADV_SUCCESS)
    {
        return ADV_FALSE;
    }

    dvc_type = inq->peri_dvc_type;

#ifdef ADV_OS_DIAG
     /*
      * check for narrow cable connected to wide device
      */
    if (wideconnectorfree == 1)
    {
        if (inq->WBus16 == 0x1)
        {
            cprintf("\r\n   Narrow cable connected to Wide device ..................ILLEGAL\r\n");
            return ADV_FALSE;
        }
    }
#endif /* ADV_OS_DIAG */
    if (inq->peri_qualifier == SCSI_QUAL_NODVC &&
        dvc_type == SCSI_TYPE_UNKNOWN)
    {
        return ADV_FALSE; /* TID/LUN not supported. */
    }

#if ADV_DISP_INQUIRY
    AscDispInquiry(tid_no, scsiq->target_lun, inq);
#endif /* ADV_DISP_INQUIRY */
#ifdef ADV_OS_BIOS
    BIOSDispInquiry(tid_no, inq);
#endif /* ADV_OS_BIOS */
#ifdef ADV_OS_DIAG
    DiagDispInquiry(tid_no, scsiq->target_lun, inq);
#endif /* ADV_OS_DIAG */


    /*
     * Only allow Start Motor and Read Capacity commands on certain
     * device types. Turn off the Start Motor bit for all other device
     * types.
     */
    if ((dvc_type != SCSI_TYPE_DASD)
        && (dvc_type != SCSI_TYPE_WORM)
        && (dvc_type != SCSI_TYPE_CDROM)
        && (dvc_type != SCSI_TYPE_OPTMEM))
    {
        asc_dvc->start_motor &= ~ADV_TID_TO_TIDMASK(tid_no);
        support_read_cap = ADV_FALSE;
    } else
    {
        support_read_cap = ADV_TRUE;
    }

    /*
     * Issue a Test Unit Ready.
     *
     * If the Test Unit Ready succeeds and a Read Capacity buffer
     * has been provided and the device supports the Read Capacity
     * command, then issue a Read Capacity.
     */
    scsiq->cdb[0] = (uchar) SCSICMD_TestUnitReady;
    scsiq->cdb[4] = 0;

    if ((AscScsiUrgentCmd(asc_dvc, scsiq,
            (uchar dosfar *) 0, 0,
            (uchar dosfar *) sense, sizeof(ASC_REQ_SENSE)) == ADV_SUCCESS)
        && (cap_info != 0L) && support_read_cap)
    {
        scsiq->cdb[0] = (uchar) SCSICMD_ReadCapacity;
        scsiq->cdb[6] = 0;
        scsiq->cdb[7] = 0;
        scsiq->cdb[8] = 0;
        scsiq->cdb[9] = 0;
        scsiq->cdb_len = 10;
        if (AscScsiUrgentCmd(asc_dvc, scsiq,
                (uchar dosfar *) cap_info, sizeof(ASC_CAP_INFO),
                (uchar dosfar *) sense, sizeof(ASC_REQ_SENSE)) != ADV_SUCCESS)
        {
#ifdef ADV_OS_BIOS
            status = ADV_ERROR; /* Read Capacity Failed. */
#endif /* ADV_OS_BIOS */
            cap_info->lba = 0L;
            cap_info->blk_size = 0x0000;
        }
    }
#ifdef ADV_OS_BIOS
    else
    {
        status = ADV_ERROR;     /* Test Unit Ready Failed. */
    }
    BIOSCheckControlDrive(asc_dvc, tid_no, inq, cap_info, status);
#endif /* ADV_OS_BIOS */
    return ADV_SUCCESS;
}

#ifndef ADV_OS_BIOS
/*
 * Set up an urgent SCSI request block and wait for completion.
 *
 * This routine currently is used during initialization.
 *
 * Return Values: ADV_SUCCESS/ADV_ERROR
 */
int
AscScsiUrgentCmd(ASC_DVC_VAR WinBiosFar *asc_dvc,
                 ASC_SCSI_REQ_Q dosfar *scsiq,
                 uchar dosfar *buf_addr, long buf_len,
                 uchar dosfar *sense_addr, long sense_len)
{
    long        phy_contig_len; /* physically contiguous length */

    scsiq->error_retry = SCSI_MAX_RETRY;

    /*
     * The 'cntl' flag may be modified, so initialize the value outside
     * of the retry loop.
     */
    scsiq->cntl = 0;

   /*
    * Wait for completion of the command.
    *
    * Don't do a driver callback. The caller of AscScsiUrgentCmd()
    * should handle return status not the driver callback function.
    */
    do
    {
        scsiq->a_flag |= ADV_POLL_REQUEST;

#ifdef ADV_OS_DOS
        /*
         * Set dos_ix to 0xFF for DOS ASPI to tell it this is a call
         * made during initialization.
         *
         * XXX - Instead of setting dos_ix DOS ASPI should set a global
         * variable when it is in initialization. The DOS ASPI driver
         * shouldn't depend on the Adv Library to tell it when inititialization
         * is being done.
         */
        scsiq->dos_ix = 0xFF;
#endif /* ADV_OS_DOS */

        scsiq->sg_entry_cnt = 0; /* No SG list. */
        scsiq->scsi_status = 0;
        scsiq->host_status = 0;
        scsiq->done_status = QD_NO_STATUS;
        scsiq->srb_ptr = (ulong) scsiq;

        /*
         * Set-up request data buffer.
         */
        if (buf_len != 0L)
        {
            /*
             * Save data buffer virtual address for possible use in AdvISR().
             */
            scsiq->vdata_addr = (ulong) buf_addr;

            /*
             * Set requested physically contiguous length. The returned
             * physically contiguous length will be set by DvcGetPhyAddr().
             */
            phy_contig_len = buf_len;

            scsiq->data_addr = DvcGetPhyAddr(asc_dvc,
                scsiq, buf_addr, (long WinBiosFar *) &phy_contig_len,
                ADV_IS_DATA_FLAG);
            ADV_ASSERT(phy_contig_len >= 0);

            /*
             * If the physically contiguous memory is greater than 'buf_len'
             * or the user has already built a scatter-gather list pointed
             * to by 'sg_real_addr', then set 'data_cnt' to 'buf_len'. It is
             * assumed the caller has created a valid scatter-gather list.
             */
            if (phy_contig_len >= buf_len || scsiq->sg_real_addr)
            {
                scsiq->data_cnt = buf_len;
            } else
            {
#if ADV_GETSGLIST
                /*
                 * Build a scatter-gather list for the request by calling
                 * AscGetSGList(). If AscGetSGList() fails set 'data_cnt' to
                 * 'phy_contig_len'.
                 *
                 * If the work area 'sg_list_ptr' is non-zero and AscGetSGList()
                 * succeeds set 'data_cnt' to the full buffer length. Otherwise
                 * truncate 'data_cnt' to the amount of physically contiguous
                 * memory.
                 */
                if (scsiq->sg_list_ptr && AscGetSGList(asc_dvc, scsiq))
                {
                    scsiq->data_cnt = buf_len;          /* full length */
                } else
#endif /* ADV_GETSGLIST */
                {
                    scsiq->data_cnt = phy_contig_len; /* truncate length */
                }
            }
        }
        else
        {
            scsiq->data_addr = scsiq->vdata_addr = 0L;
            scsiq->data_cnt = 0L;
        }

        /*
         * Set-up request sense buffer.
         */
        if (sense_len != 0)
        {
            scsiq->vsense_addr = (ulong) sense_addr;

            /*
             * Set requested physically contiguous length. The returned
             * physically contiguous length will be set by DvcGetPhyAddr().
             */
            phy_contig_len = sense_len;

            scsiq->sense_addr = DvcGetPhyAddr(asc_dvc,
                scsiq, sense_addr, (long WinBiosFar *) &phy_contig_len,
                ADV_IS_SENSE_FLAG);

            /*
             * If DvcGetPhyAddr() returned a physically contiguous length
             * less than 'sense_len', then set the data count to
             * 'phy_contig_len'.
             */
            ADV_ASSERT(phy_contig_len >= 0);
            ADV_ASSERT(sense_len <= 255);
            scsiq->sense_len = (uchar)
                ((phy_contig_len < sense_len) ? phy_contig_len : sense_len);
        } else
        {
            scsiq->sense_len = 0;
            scsiq->sense_addr = scsiq->vsense_addr = 0L;
        }

        if (AscSendScsiCmd(asc_dvc, scsiq) != ADV_SUCCESS)
        {
            /*
             * AscSendScsiCmd() should never fail in polled mode.
             * If it does fail, then set an error and break to cause
             * a return to the caller.
             */
            ADV_ASSERT(0);
            scsiq->done_status = QD_WITH_ERROR;
            break;
        }
        else
        {
            AscWaitScsiCmd(asc_dvc, scsiq);
            if (scsiq->done_status == QD_DO_RETRY)
            {
                /* Wait 100 ms before retrying the command. */
                DvcSleepMilliSecond(100);
            }
        }
    } while (scsiq->done_status == QD_DO_RETRY);
    scsiq->a_flag &= ~ADV_POLL_REQUEST;

    if (scsiq->done_status == QD_NO_ERROR)
    {
        return ADV_SUCCESS;
    } else
    {
        return ADV_ERROR;
    }
}

/*
 * Wait for request to complete up to 10 seconds.
 *
 * On return caller should refer to scsiq 'done_status' for
 * request completion status.
 */
void
AscWaitScsiCmd(ASC_DVC_VAR WinBiosFar *asc_dvc,
               ASC_SCSI_REQ_Q dosfar *scsiq)
{
    ulong       i;

    /*
     * Wait up to 60 seconds for the command to complete.
     *
     * A Start Unit command for some disk drives may take over
     * 30 seconds to complete.
     */
    for (i = 0; i < 6 * SCSI_WAIT_10_SEC * SCSI_MS_PER_SEC; i++)
    {
        /*
         * AdvISR() will set the 'scsiq' a_flag ADV_SCSIQ_DONE
         * flag when the request has been completed.
         */
        (void) AdvISR(asc_dvc);

        if (scsiq->a_flag & ADV_SCSIQ_DONE)
        {
            break;
        }
        DvcSleepMilliSecond(1);
    }

    /*
     * If the 'scsiq' a_flag ADV_SCSIQ_DONE is not set indicating
     * that the microcode has completed it, then abort the request
     * in the microcode and return. The abort operation will set
     * a scsiq 'done_status' error. If the abort fails set an error
     * here.
     */
    if ((scsiq->a_flag & ADV_SCSIQ_DONE) == 0)
    {
        ADV_ASSERT(0); /* The request should never timeout. */

        /*
         * Abort the request in the microcode.
         */
        AscSendIdleCmd(asc_dvc, (ushort) IDLE_CMD_ABORT,
                (ulong) scsiq, ADV_NOWAIT);

        /*
         * Wait for the microcode to acknowledge the abort.
         */
        for (i = 0; i < SCSI_WAIT_10_SEC * SCSI_MS_PER_SEC; i++)
        {
            /*
             * The ASC_DVC_VAR 'idle_cmd_done' field is set by AdvISR().
             */
            (void) AdvISR(asc_dvc);
            if (asc_dvc->idle_cmd_done == ADV_TRUE)
            {
                break;
            }
            DvcSleepMilliSecond(1);
        }

        /*
         * If the abort command was not acknowledged by the microcode,
         * then complete the request with an error.
         */
        if (asc_dvc->idle_cmd_done == ADV_FALSE)
        {
            ADV_ASSERT(0); /* Abort should never fail. */
            scsiq->done_status = QD_WITH_ERROR;
        }
    }
    return;
}
#endif /* ADV_OS_BIOS */
#endif /* ADV_INITSCSITARGET */

/*
 * Read the board's EEPROM configuration. Set fields in ASC_DVC_VAR and
 * ASC_DVC_CFG based on the EEPROM settings. The chip is stopped while
 * all of this is done.
 *
 * On failure set the ASC_DVC_VAR field 'err_code' and return ADV_ERROR.
 *
 * For a non-fatal error return a warning code. If there are no warnings
 * then 0 is returned.
 *
 * Note: Chip is stopped on entry.
 */
static int
AscInitFromEEP(ASC_DVC_VAR WinBiosFar *asc_dvc)
{
    PortAddr            iop_base;
    ushort              warn_code;
    ASCEEP_CONFIG       eep_config;
    int                 i;

    iop_base = asc_dvc->iop_base;

    warn_code = 0;

    /*
     * Read the board's EEPROM configuration.
     *
     * Set default values if a bad checksum is found.
     */
    if (AdvGetEEPConfig(iop_base, &eep_config) != eep_config.check_sum)
    {
#if ADV_BIG_ENDIAN
        /* Need to swap some of the words before writing to the EEPROM. */
        ASCEEP_CONFIG  eep_config_mac;
#endif /* ADV_BIG_ENDIAN */

#ifndef ADV_OS_MAC
        warn_code |= ASC_WARN_EEPROM_CHKSUM;
#endif /* ADV_OS_MAC */

        /*
         * Set EEPROM default values.
         */
        for (i = 0; i < sizeof(ASCEEP_CONFIG); i++)
        {
            *((uchar *) &eep_config + i) =
#if ADV_BIG_ENDIAN
            *((uchar *) &eep_config_mac + i) =
#endif /* ADV_BIG_ENDIAN */
            *((uchar *) &Default_EEPROM_Config + i);
        }

        /*
         * Assume the 6 byte board serial number that was read
         * from EEPROM is correct even if the EEPROM checksum
         * failed.
         */
        eep_config.serial_number_word3 =
#if ADV_BIG_ENDIAN
        eep_config_mac.serial_number_word3 =
#endif /* ADV_BIG_ENDIAN */
            AscReadEEPWord(iop_base, ASC_EEP_DVC_CFG_END - 1);

        eep_config.serial_number_word2 =
#if ADV_BIG_ENDIAN
        eep_config_mac.serial_number_word2 =
#endif /* ADV_BIG_ENDIAN */
            AscReadEEPWord(iop_base, ASC_EEP_DVC_CFG_END - 2);

        eep_config.serial_number_word1 =
#if ADV_BIG_ENDIAN
        eep_config_mac.serial_number_word1 =
#endif /* ADV_BIG_ENDIAN */
            AscReadEEPWord(iop_base, ASC_EEP_DVC_CFG_END - 3);

#if !ADV_BIG_ENDIAN
        AdvSetEEPConfig(iop_base, &eep_config);
#else /* ADV_BIG_ENDIAN */
        /* swap every two bytes from word 9 to 15 before write to eep */
        for ( i = 9 ; i < 16 ; i ++ )
        {
            /* no need to swap word 12, 13 and 14 */
            if ( i == 12 ) { i = 15 ;}
            *((ushort *) &eep_config_mac + i) =
                EndianSwap16Bit(*((ushort *) &eep_config_mac + i));
        }
        AdvSetEEPConfig(iop_base, &eep_config_mac);
#endif /* ADV_BIG_ENDIAN */
    }
#if ADV_BIG_ENDIAN
    else
    {
        /* swap every two bytes from word 9 to 15 before write to eep */
        for ( i = 9 ; i < 16 ; i ++ )
        {
            /* no need to swap word 12, 13 and 14 */
            if ( i == 12 ) { i = 15 ;}
            *((ushort *) &eep_config + i) =
                EndianSwap16Bit(*((ushort *) &eep_config + i));
        }
    }
#endif /* ADV_BIG_ENDIAN */
    /*
     * Set ASC_DVC_VAR and ASC_DVC_CFG variables from the
     * EEPROM configuration that was read.
     *
     * This is the mapping of EEPROM fields to Adv Library fields.
     */
    asc_dvc->wdtr_able = eep_config.wdtr_able;
    asc_dvc->sdtr_able = eep_config.sdtr_able;
    asc_dvc->ultra_able = eep_config.ultra_able;
    asc_dvc->tagqng_able = eep_config.tagqng_able;
    asc_dvc->cfg->disc_enable = eep_config.disc_enable;
    asc_dvc->max_host_qng = eep_config.max_host_qng;
    asc_dvc->max_dvc_qng = eep_config.max_dvc_qng;
    asc_dvc->chip_scsi_id = (eep_config.adapter_scsi_id & ASC_MAX_TID);
    asc_dvc->start_motor = eep_config.start_motor;
    asc_dvc->scsi_reset_wait = eep_config.scsi_reset_delay;
    asc_dvc->bios_ctrl = eep_config.bios_ctrl;
#ifdef ADV_OS_BIOS
    asc_dvc->cfg->bios_scan = eep_config.bios_scan;
    asc_dvc->cfg->bios_delay = eep_config.bios_boot_delay;
    asc_dvc->cfg->bios_id_lun = eep_config.bios_id_lun;
#endif /* ADV_OS_BIOS */
    asc_dvc->no_scam = eep_config.scam_tolerant;

    /*
     * Set the host maximum queuing (max. 253, min. 16) and the per device
     * maximum queuing (max. 63, min. 4).
     */
    if (eep_config.max_host_qng > ASC_DEF_MAX_HOST_QNG)
    {
        eep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;
    } else if (eep_config.max_host_qng < ASC_DEF_MIN_HOST_QNG)
    {
        /* If the value is zero, assume it is uninitialized. */
        if (eep_config.max_host_qng == 0)
        {
            eep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;
        } else
        {
            eep_config.max_host_qng = ASC_DEF_MIN_HOST_QNG;
        }
    }

    if (eep_config.max_dvc_qng > ASC_DEF_MAX_DVC_QNG)
    {
        eep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;
    } else if (eep_config.max_dvc_qng < ASC_DEF_MIN_DVC_QNG)
    {
        /* If the value is zero, assume it is uninitialized. */
        if (eep_config.max_dvc_qng == 0)
        {
            eep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;
        } else
        {
            eep_config.max_dvc_qng = ASC_DEF_MIN_DVC_QNG;
        }
    }

    /*
     * If 'max_dvc_qng' is greater than 'max_host_qng', then
     * set 'max_dvc_qng' to 'max_host_qng'.
     */
    if (eep_config.max_dvc_qng > eep_config.max_host_qng)
    {
        eep_config.max_dvc_qng = eep_config.max_host_qng;
    }

    /*
     * Set ASC_DVC_VAR 'max_host_qng' and ASC_DVC_CFG 'max_dvc_qng'
     * values based on possibly adjusted EEPROM values.
     */
    asc_dvc->max_host_qng = eep_config.max_host_qng;
    asc_dvc->max_dvc_qng = eep_config.max_dvc_qng;


    /*
     * If the EEPROM 'termination' field is set to automatic (0), then set
     * the ASC_DVC_CFG 'termination' field to automatic also.
     *
     * If the termination is specified with a non-zero 'termination'
     * value check that a legal value is set and set the ASC_DVC_CFG
     * 'termination' field appropriately.
     */
    if (eep_config.termination == 0)
    {
        asc_dvc->cfg->termination = 0;    /* auto termination */
    } else
    {
        /* Enable manual control with low off / high off. */
        if (eep_config.termination == 1)
        {
            asc_dvc->cfg->termination = TERM_CTL_SEL;

        /* Enable manual control with low off / high on. */
        } else if (eep_config.termination == 2)
        {
            asc_dvc->cfg->termination = TERM_CTL_SEL | TERM_CTL_H;

        /* Enable manual control with low on / high on. */
        } else if (eep_config.termination == 3)
        {
            asc_dvc->cfg->termination = TERM_CTL_SEL | TERM_CTL_H | TERM_CTL_L;
        } else
        {
            /*
             * The EEPROM 'termination' field contains a bad value. Use
             * automatic termination instead.
             */
            asc_dvc->cfg->termination = 0;
            warn_code |= ASC_WARN_EEPROM_TERMINATION;
        }
    }

    return warn_code;
}

/*
 * Read EEPROM configuration into the specified buffer.
 *
 * Return a checksum based on the EEPROM configuration read.
 */
ushort
AdvGetEEPConfig(PortAddr iop_base,
                ASCEEP_CONFIG dosfar *cfg_buf)
{
    ushort              wval, chksum;
    ushort dosfar       *wbuf;
    int                 eep_addr;

    wbuf = (ushort dosfar *) cfg_buf;
    chksum = 0;

    for (eep_addr = ASC_EEP_DVC_CFG_BEGIN;
         eep_addr < ASC_EEP_DVC_CFG_END;
         eep_addr++, wbuf++)
    {
        wval = AscReadEEPWord(iop_base, eep_addr);
        chksum += wval;
        *wbuf = wval;
    }
    *wbuf = AscReadEEPWord(iop_base, eep_addr);
    wbuf++;
    for (eep_addr = ASC_EEP_DVC_CTL_BEGIN;
         eep_addr < ASC_EEP_MAX_WORD_ADDR;
         eep_addr++, wbuf++)
    {
        *wbuf = AscReadEEPWord(iop_base, eep_addr);
    }
    return chksum;
}

/*
 * Read the EEPROM from specified location
 */
static ushort
AscReadEEPWord(PortAddr iop_base, int eep_word_addr)
{
    AscWriteWordRegister(iop_base, IOPW_EE_CMD,
        ASC_EEP_CMD_READ | eep_word_addr);
    AscWaitEEPCmd(iop_base);
    return AscReadWordRegister(iop_base, IOPW_EE_DATA);
}

/*
 * Wait for EEPROM command to complete
 */
static void
AscWaitEEPCmd(PortAddr iop_base)
{
    int eep_delay_ms;

    for (eep_delay_ms = 0; eep_delay_ms < ASC_EEP_DELAY_MS; eep_delay_ms++)
    {
        if (AscReadWordRegister(iop_base, IOPW_EE_CMD) & ASC_EEP_CMD_DONE)
        {
            break;
        }
        DvcSleepMilliSecond(1);
    }
    if ((AscReadWordRegister(iop_base, IOPW_EE_CMD) & ASC_EEP_CMD_DONE) == 0)
    {
        /* XXX - since the command timed-out an error should be returned. */
        ADV_ASSERT(0);
    }
    return;
}

/*
 * Write the EEPROM from 'cfg_buf'.
 */
void
AdvSetEEPConfig(PortAddr iop_base, ASCEEP_CONFIG dosfar *cfg_buf)
{
    ushort dosfar       *wbuf;
    ushort              addr, chksum;

    wbuf = (ushort dosfar *) cfg_buf;
    chksum = 0;

    AscWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_ABLE);
    AscWaitEEPCmd(iop_base);

    /*
     * Write EEPROM from word 0 to word 15
     */
    for (addr = ASC_EEP_DVC_CFG_BEGIN;
         addr < ASC_EEP_DVC_CFG_END; addr++, wbuf++)
    {
        chksum += *wbuf;
        AscWriteWordRegister(iop_base, IOPW_EE_DATA, *wbuf);
        AscWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE | addr);
        AscWaitEEPCmd(iop_base);
        DvcSleepMilliSecond(ASC_EEP_DELAY_MS);
    }

    /*
     * Write EEPROM checksum at word 18
     */
    AscWriteWordRegister(iop_base, IOPW_EE_DATA, chksum);
    AscWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE | addr);
    AscWaitEEPCmd(iop_base);
    wbuf++;        /* skip over check_sum */

    /*
     * Write EEPROM OEM name at words 19 to 26
     */
    for (addr = ASC_EEP_DVC_CTL_BEGIN;
         addr < ASC_EEP_MAX_WORD_ADDR; addr++, wbuf++)
    {
        AscWriteWordRegister(iop_base, IOPW_EE_DATA, *wbuf);
        AscWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE | addr);
        AscWaitEEPCmd(iop_base);
    }
    AscWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_DISABLE);
    AscWaitEEPCmd(iop_base);
    return;
}

/*
 * This function resets the chip and SCSI bus
 *
 * It is up to the caller to add a delay to let the bus settle after
 * calling this function.
 *
 * The SCSI_CFG0, SCSI_CFG1, and MEM_CFG registers are set-up in
 * AdvInitAsc3550Driver(). Here when doing a write to one of these
 * registers read first and then write.
 *
 * Note: A SCSI Bus Reset can not be done until after the EEPROM
 * configuration is read to determine whether SCSI Bus Resets
 * should be performed.
 */
void
AdvResetChip(ASC_DVC_VAR WinBiosFar *asc_dvc)
{
    PortAddr    iop_base;
    ushort      word;
    uchar       byte;

    iop_base = asc_dvc->iop_base;

    /*
     * Reset Chip.
     */
    AscWriteWordRegister(iop_base, IOPW_CTRL_REG, ADV_CTRL_REG_CMD_RESET);
    DvcSleepMilliSecond(100);
    AscWriteWordRegister(iop_base, IOPW_CTRL_REG, ADV_CTRL_REG_CMD_WR_IO_REG);

    /*
     * Initialize Chip registers.
     *
     * Note: Don't remove the use of a temporary variable in the following
     * code, otherwise the Microsoft C compiler will turn the following lines
     * into a no-op.
     */
    byte = AscReadByteRegister(iop_base, IOPB_MEM_CFG);
    byte |= RAM_SZ_8KB;
    AscWriteByteRegister(iop_base, IOPB_MEM_CFG, byte);

    word = AscReadWordRegister(iop_base, IOPW_SCSI_CFG1);
    word &= ~BIG_ENDIAN;
    AscWriteWordRegister(iop_base, IOPW_SCSI_CFG1, word);

    /*
     * Setting the START_CTL_EMFU 3:2 bits sets a FIFO threshold
     * of 128 bytes. This register is only accessible to the host.
     */
    AscWriteByteRegister(iop_base, IOPB_DMA_CFG0,
        START_CTL_EMFU | READ_CMD_MRM);
}


#if ADV_DISP_INQUIRY
void
AscDispInquiry(uchar tid, uchar lun, ASC_SCSI_INQUIRY dosfar *inq)
{
    int                 i;
    uchar               strbuf[18];
    uchar dosfar        *strptr;
    uchar               numstr[12];

    strptr = (uchar dosfar *) strbuf;
    DvcDisplayString((uchar dosfar *) " SCSI ID #");
    DvcDisplayString(todstr(tid, numstr));

    if (lun != 0)
    {
        DvcDisplayString((uchar dosfar *) " LUN #");
        DvcDisplayString(todstr(lun, numstr));
    }
    DvcDisplayString((uchar dosfar *) "  Type: ");
    DvcDisplayString(todstr(inq->peri_dvc_type, (uchar dosfar *) numstr));
    DvcDisplayString((uchar dosfar *) "  ");

    for (i = 0; i < 8; i++)
    {
        strptr[i] = inq->vendor_id[i];
    }
    strptr[i] = EOS;
    DvcDisplayString(strptr);

    DvcDisplayString((uchar dosfar *) " ");
    for (i = 0; i < 16; i++)
    {
        strptr[i] = inq->product_id[i];
    }
    strptr[i] = EOS;
    DvcDisplayString(strptr);

    DvcDisplayString((uchar dosfar *) " ");
    for (i = 0; i < 4; i++)
    {
        strptr[i] = inq->product_rev_level[i];
    }
    strptr[i] = EOS;
    DvcDisplayString(strptr);
    DvcDisplayString((uchar dosfar *) "\r\n");
    return;
}
#endif /* ADV_DISP_INQUIRY */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc3550\a_qswap.h ===
/*
 * Copyright (c) 1994-1998 Advanced System Products, Inc.
 * All Rights Reserved.
 *
 * Original object file: QSWAP.OAS
 * Converted C file: A_QSWAP.H
 * Date: 08-11-1998
 * Time: 16:14:43.51
 */

unsigned char _adv_mcode_buf[] = {
  0x9C,  0xF0,  0x80,  0x01,  0x00,  0xF0,  0x34,  0x0A,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x72,  0x01,  0xBA,  0x11,  0x00,  0x00,  0x70,  0x01,
  0x30,  0x01,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x0B,  0x11,  0x33,  0x03,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x48,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x01,  0x01,  0x01,  0x01,  0x01,  0x01,  0x01,  0x01,  0x01,  0x01,  0x01,  0x01,  0x01,  0x01,  0x01,  0x01,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x78,  0x56,  0x34,  0x12,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x04,  0xF7,  0x70,  0x01,  0x0C,  0x1C,  0x06,  0xF7,  0x02,  0x00,  0x00,  0xF2,  0xC6,  0x0A,
  0x04,  0xF7,  0x70,  0x01,  0x06,  0xF7,  0x02,  0x00,  0x3E,  0x57,  0x3C,  0x56,  0x0C,  0x1C,  0x00,  0xFC,
  0xA6,  0x00,  0x01,  0x58,  0xAA,  0x13,  0x20,  0xF0,  0xA2,  0x03,  0x06,  0xEC,  0xB9,  0x00,  0x0E,  0x47,
  0x03,  0xE6,  0x10,  0x00,  0xCE,  0x45,  0x02,  0x13,  0x3E,  0x57,  0x06,  0xEA,  0xB9,  0x00,  0x47,  0x4B,
  0x03,  0xF6,  0xE0,  0x00,  0x00,  0xF2,  0x58,  0x0A,  0x01,  0x48,  0x4E,  0x12,  0x03,  0xF6,  0xC0,  0x00,
  0x00,  0xF2,  0x58,  0x0A,  0x41,  0x58,  0x03,  0xF6,  0xD0,  0x00,  0x00,  0xF2,  0x58,  0x0A,  0x49,  0x44,
  0x59,  0xF0,  0x0A,  0x02,  0x03,  0xF6,  0xE0,  0x00,  0x00,  0xF2,  0x58,  0x0A,  0x44,  0x58,  0x00,  0xF2,
  0xB6,  0x0D,  0x02,  0xCC,  0x4A,  0xE4,  0x01,  0x00,  0x55,  0xF0,  0x08,  0x03,  0x45,  0xF4,  0x02,  0x00,
  0x83,  0x5A,  0x04,  0xCC,  0x01,  0x4A,  0x12,  0x12,  0x00,  0xF2,  0xB6,  0x0D,  0x00,  0xCD,  0x48,  0xE4,
  0x01,  0x00,  0xE9,  0x13,  0x00,  0xF2,  0x9A,  0x0F,  0xFA,  0x10,  0x0E,  0x47,  0x03,  0xE6,  0x10,  0x00,
  0xCE,  0x45,  0x02,  0x13,  0x3E,  0x57,  0xCE,  0x47,  0x97,  0x13,  0x04,  0xEC,  0xB4,  0x00,  0x00,  0xF2,
  0xB6,  0x0D,  0x00,  0xCD,  0x48,  0xE4,  0x00,  0x00,  0x12,  0x12,  0x3E,  0x57,  0x06,  0xCC,  0x45,  0xF4,
  0x02,  0x00,  0x83,  0x5A,  0x00,  0xCC,  0x00,  0xEA,  0xB4,  0x00,  0x92,  0x10,  0x00,  0xF0,  0x8C,  0x01,
  0x43,  0xF0,  0x5C,  0x02,  0x44,  0xF0,  0x60,  0x02,  0x45,  0xF0,  0x64,  0x02,  0x46,  0xF0,  0x68,  0x02,
  0x47,  0xF0,  0x6E,  0x02,  0x48,  0xF0,  0x9E,  0x02,  0xB9,  0x54,  0x62,  0x10,  0x00,  0x1C,  0x5A,  0x10,
  0x02,  0x1C,  0x56,  0x10,  0x1E,  0x1C,  0x52,  0x10,  0x00,  0xF2,  0xF4,  0x10,  0x50,  0x10,  0x06,  0xFC,
  0xA8,  0x00,  0x03,  0xF6,  0xBE,  0x00,  0x00,  0xF2,  0x3E,  0x0A,  0x8C,  0x10,  0x01,  0xF6,  0x01,  0x00,
  0x01,  0xFA,  0xA8,  0x00,  0x00,  0xF2,  0x1C,  0x0B,  0x06,  0x10,  0xB9,  0x54,  0x01,  0xFA,  0xA8,  0x00,
  0x03,  0xF6,  0xBE,  0x00,  0x00,  0xF2,  0x48,  0x0A,  0x01,  0xFC,  0xA8,  0x00,  0x20,  0x10,  0x58,  0x1C,
  0x00,  0xF2,  0x0C,  0x0B,  0x5A,  0x1C,  0x01,  0xF6,  0x01,  0x00,  0x38,  0x54,  0x00,  0xFA,  0xA6,  0x00,
  0x01,  0xFA,  0xA8,  0x00,  0x20,  0x1C,  0x00,  0xF0,  0x72,  0x01,  0x01,  0xF6,  0x01,  0x00,  0x38,  0x54,
  0x00,  0xFA,  0xA6,  0x00,  0x01,  0xFA,  0xA8,  0x00,  0x20,  0x1C,  0x00,  0xF0,  0x80,  0x01,  0x03,  0xF6,
  0xE0,  0x00,  0x00,  0xF2,  0x58,  0x0A,  0x01,  0x48,  0x0A,  0x13,  0x00,  0xF2,  0x0C,  0x10,  0x00,  0xF2,
  0x28,  0x0F,  0x24,  0x10,  0x03,  0xF6,  0xC0,  0x00,  0x00,  0xF2,  0x58,  0x0A,  0x02,  0xF6,  0xD0,  0x00,
  0x02,  0x57,  0x03,  0x59,  0x01,  0xCC,  0x49,  0x44,  0x5B,  0xF0,  0x04,  0x03,  0x00,  0xF2,  0x70,  0x0F,
  0x00,  0xF0,  0x80,  0x01,  0x00,  0xF2,  0xE8,  0x0F,  0x0C,  0x1C,  0x02,  0x4B,  0xBF,  0x57,  0x9E,  0x43,
  0x77,  0x57,  0x07,  0x4B,  0x20,  0xF0,  0xA2,  0x03,  0x40,  0x1C,  0x1E,  0xF0,  0x30,  0x03,  0x26,  0xF0,
  0x2C,  0x03,  0xA0,  0xF0,  0x1A,  0x03,  0x11,  0xF0,  0xA2,  0x03,  0x12,  0x10,  0x9F,  0xF0,  0x3E,  0x03,
  0x46,  0x1C,  0x82,  0xE7,  0x05,  0x00,  0x9E,  0xE7,  0x11,  0x00,  0x00,  0xF0,  0xF6,  0x09,  0x0C,  0x1C,
  0x48,  0x1C,  0x46,  0x1C,  0x38,  0x54,  0x00,  0xEC,  0xBA,  0x00,  0x08,  0x44,  0x00,  0xEA,  0xBA,  0x00,
  0x03,  0xF6,  0xC0,  0x00,  0x00,  0xF2,  0x58,  0x0A,  0x08,  0x44,  0x00,  0x4C,  0x82,  0xE7,  0x02,  0x00,
  0x00,  0xF2,  0xAC,  0x11,  0xB1,  0xF0,  0x64,  0x03,  0x85,  0xF0,  0x70,  0x03,  0x00,  0xF2,  0x50,  0x0B,
  0x06,  0xF0,  0x80,  0x03,  0x09,  0xF0,  0x14,  0x09,  0x1E,  0xF0,  0xEC,  0x09,  0x00,  0xF0,  0xF2,  0x09,
  0x00,  0xFC,  0xBE,  0x00,  0x98,  0x57,  0x55,  0xF0,  0xA0,  0x04,  0x01,  0xE6,  0x0C,  0x00,  0x00,  0xF2,
  0x20,  0x0D,  0x00,  0xF2,  0x92,  0x11,  0x00,  0xF2,  0x9E,  0x11,  0x01,  0xF0,  0x7C,  0x02,  0x00,  0xF0,
  0x8A,  0x02,  0x46,  0x1C,  0x0C,  0x1C,  0x67,  0x1B,  0xBF,  0x57,  0x77,  0x57,  0x02,  0x4B,  0x48,  0x1C,
  0x32,  0x1C,  0x00,  0xF2,  0x66,  0x0D,  0x30,  0x1C,  0x96,  0xF0,  0xB8,  0x03,  0xB1,  0xF0,  0xBC,  0x03,
  0x1E,  0xF0,  0xEC,  0x09,  0x85,  0xF0,  0xF2,  0x09,  0x00,  0xFC,  0xBE,  0x00,  0x98,  0x57,  0x10,  0x12,
  0x01,  0xE6,  0x0C,  0x00,  0x00,  0xF2,  0x20,  0x0D,  0x01,  0xF0,  0x7C,  0x02,  0x00,  0xF0,  0x8A,  0x02,
  0x03,  0xF6,  0xE0,  0x00,  0x00,  0xF2,  0x58,  0x0A,  0x01,  0x48,  0x55,  0xF0,  0x8C,  0x04,  0x03,  0x82,
  0x03,  0xFC,  0xA0,  0x00,  0x9B,  0x57,  0x40,  0x12,  0x69,  0x08,  0x00,  0xF2,  0xE6,  0x10,  0x85,  0xF0,
  0x3A,  0x04,  0x69,  0x08,  0x00,  0xF2,  0xE6,  0x10,  0x85,  0xF0,  0xF2,  0x09,  0x68,  0x08,  0x4C,  0x44,
  0x28,  0x12,  0x44,  0x48,  0x03,  0xF6,  0xE0,  0x00,  0x00,  0xF2,  0x58,  0x0A,  0x45,  0x58,  0x00,  0xF2,
  0xCA,  0x0D,  0x00,  0xCC,  0x01,  0x48,  0x55,  0xF0,  0x8C,  0x04,  0x4C,  0x44,  0xEF,  0x13,  0x00,  0xF2,
  0x9A,  0x0F,  0x00,  0xF2,  0xE8,  0x0F,  0x08,  0x10,  0x68,  0x08,  0x45,  0x5A,  0x00,  0xF2,  0xCA,  0x0D,
  0x04,  0x80,  0x18,  0xE4,  0x10,  0x00,  0x24,  0x12,  0x01,  0xE6,  0x06,  0x00,  0x04,  0x80,  0x18,  0xE4,
  0x01,  0x00,  0x04,  0x12,  0x01,  0xE6,  0x0D,  0x00,  0x00,  0xF2,  0x20,  0x0D,  0x04,  0xE6,  0x02,  0x00,
  0x9E,  0xE7,  0x15,  0x00,  0x01,  0xF0,  0x0C,  0x0A,  0x00,  0xF0,  0xF2,  0x09,  0x3E,  0x1C,  0x05,  0x80,
  0x48,  0xE4,  0x00,  0x00,  0x0C,  0x12,  0x00,  0xE6,  0x11,  0x00,  0x00,  0xEA,  0xB8,  0x00,  0x00,  0xF2,
  0x8A,  0x10,  0x82,  0xE7,  0x02,  0x00,  0x1C,  0x90,  0x40,  0x5C,  0x00,  0x16,  0x01,  0xE6,  0x06,  0x00,
  0x00,  0xF2,  0x20,  0x0D,  0x01,  0xF0,  0x80,  0x01,  0x1E,  0xF0,  0x80,  0x01,  0x00,  0xF0,  0x94,  0x04,
  0x42,  0x5B,  0x06,  0xF7,  0x03,  0x00,  0x46,  0x59,  0xBF,  0x57,  0x77,  0x57,  0x01,  0xE6,  0x80,  0x00,
  0x07,  0x80,  0x31,  0x44,  0x04,  0x80,  0x18,  0xE4,  0x20,  0x00,  0x56,  0x13,  0x20,  0x80,  0x48,  0xE4,
  0x03,  0x00,  0x4E,  0x12,  0x00,  0xFC,  0xA2,  0x00,  0x98,  0x57,  0x55,  0xF0,  0x10,  0x05,  0x31,  0xE4,
  0x40,  0x00,  0x00,  0xFC,  0xA0,  0x00,  0x98,  0x57,  0x36,  0x12,  0x4C,  0x1C,  0xB1,  0xF0,  0xDC,  0x04,
  0x89,  0x48,  0x00,  0xF2,  0xE6,  0x10,  0x86,  0xF0,  0x22,  0x05,  0x82,  0xE7,  0x06,  0x00,  0x1B,  0x80,
  0x48,  0xE4,  0x22,  0x00,  0x5B,  0xF0,  0x00,  0x05,  0x48,  0xE4,  0x20,  0x00,  0x59,  0xF0,  0x04,  0x05,
  0x00,  0xE6,  0x20,  0x00,  0x09,  0x48,  0x00,  0xF2,  0xE6,  0x10,  0x86,  0xF0,  0x22,  0x05,  0x83,  0x80,
  0x04,  0x10,  0x00,  0xF2,  0x76,  0x0D,  0x00,  0xE6,  0x01,  0x00,  0x00,  0xEA,  0x26,  0x01,  0x01,  0xEA,
  0x27,  0x01,  0x04,  0x80,  0x18,  0xE4,  0x10,  0x00,  0x32,  0x12,  0xB9,  0x54,  0x00,  0xF2,  0xCA,  0x0E,
  0x01,  0xE6,  0x06,  0x00,  0x04,  0x80,  0x18,  0xE4,  0x01,  0x00,  0x04,  0x12,  0x01,  0xE6,  0x0D,  0x00,
  0x00,  0xF2,  0x20,  0x0D,  0x00,  0xF2,  0x92,  0x11,  0x00,  0xF2,  0x9E,  0x11,  0x04,  0xE6,  0x02,  0x00,
  0x9E,  0xE7,  0x15,  0x00,  0x01,  0xF0,  0x0C,  0x0A,  0x00,  0xF0,  0xF2,  0x09,  0x00,  0xFC,  0x20,  0x01,
  0x98,  0x57,  0x34,  0x12,  0x00,  0xFC,  0x24,  0x01,  0x98,  0x57,  0x2C,  0x13,  0xB9,  0x54,  0x00,  0xF2,
  0xCA,  0x0E,  0x86,  0xF0,  0x98,  0x05,  0x03,  0xF6,  0x01,  0x00,  0x00,  0xF2,  0x60,  0x0E,  0x85,  0xF0,
  0x8E,  0x05,  0x82,  0xE7,  0x03,  0x00,  0x00,  0xF2,  0x50,  0x0B,  0x82,  0xE7,  0x02,  0x00,  0x00,  0xFC,
  0x24,  0x01,  0xB0,  0x57,  0x00,  0xFA,  0x24,  0x01,  0x00,  0xFC,  0x9E,  0x00,  0x98,  0x57,  0x5A,  0x12,
  0x00,  0xFC,  0xB6,  0x00,  0x98,  0x57,  0x52,  0x13,  0x03,  0xE6,  0x0C,  0x00,  0x00,  0xFC,  0x9C,  0x00,
  0x98,  0x57,  0x04,  0x13,  0x03,  0xE6,  0x19,  0x00,  0x05,  0xE6,  0x08,  0x00,  0x00,  0xF6,  0x00,  0x01,
  0x00,  0x57,  0x00,  0x57,  0x03,  0x58,  0x00,  0xDC,  0x18,  0xF4,  0x00,  0x80,  0x04,  0x13,  0x05,  0xE6,
  0x0F,  0x00,  0xB9,  0x54,  0x00,  0xF2,  0xCA,  0x0E,  0x86,  0xF0,  0xFA,  0x05,  0x00,  0xF2,  0x8E,  0x0E,
  0x85,  0xF0,  0xF0,  0x05,  0x82,  0xE7,  0x03,  0x00,  0x00,  0xF2,  0x50,  0x0B,  0x82,  0xE7,  0x02,  0x00,
  0x00,  0xFC,  0xB6,  0x00,  0xB0,  0x57,  0x00,  0xFA,  0xB6,  0x00,  0x01,  0xF6,  0x01,  0x00,  0x00,  0xF2,
  0xCA,  0x0E,  0x9C,  0x32,  0x4E,  0x1C,  0x32,  0x1C,  0x00,  0xF2,  0x66,  0x0D,  0x30,  0x1C,  0x82,  0xE7,
  0x04,  0x00,  0xB1,  0xF0,  0x12,  0x06,  0x0A,  0xF0,  0x2E,  0x06,  0x05,  0xF0,  0xC6,  0x06,  0x06,  0xF0,
  0xCC,  0x06,  0x09,  0xF0,  0x14,  0x09,  0x1E,  0xF0,  0xEC,  0x09,  0x00,  0xF0,  0xF2,  0x09,  0x04,  0x80,
  0x18,  0xE4,  0x20,  0x00,  0x30,  0x12,  0x09,  0xE7,  0x03,  0x00,  0x00,  0xF2,  0xE6,  0x10,  0x21,  0x80,
  0x18,  0xE4,  0xE0,  0x00,  0x09,  0x48,  0x00,  0xF2,  0xE6,  0x10,  0x09,  0xE7,  0x00,  0x00,  0x00,  0xF2,
  0xE6,  0x10,  0x09,  0xE7,  0x00,  0x00,  0x00,  0xF2,  0xE6,  0x10,  0x99,  0xA4,  0x00,  0xF2,  0xE6,  0x10,
  0x09,  0xE7,  0x00,  0x00,  0x9A,  0x10,  0x04,  0x80,  0x18,  0xE4,  0x02,  0x00,  0x34,  0x12,  0x09,  0xE7,
  0x1B,  0x00,  0x00,  0xF2,  0xE6,  0x10,  0x21,  0x80,  0x18,  0xE4,  0xE0,  0x00,  0x09,  0x48,  0x00,  0xF2,
  0xE6,  0x10,  0x09,  0xE7,  0x00,  0x00,  0x00,  0xF2,  0xE6,  0x10,  0x09,  0xE7,  0x00,  0x00,  0x00,  0xF2,
  0xE6,  0x10,  0x09,  0xE7,  0x01,  0x00,  0x00,  0xF2,  0xE6,  0x10,  0x09,  0xE7,  0x00,  0x00,  0x00,  0xF0,
  0xFC,  0x08,  0xBB,  0x55,  0x9A,  0x81,  0x03,  0xF7,  0x20,  0x00,  0x09,  0x6F,  0x93,  0x45,  0x55,  0xF0,
  0xD2,  0x06,  0xB1,  0xF0,  0xB2,  0x06,  0x0A,  0xF0,  0xAA,  0x06,  0x09,  0xF0,  0x14,  0x09,  0x1E,  0xF0,
  0xEC,  0x09,  0x00,  0xF0,  0xF2,  0x09,  0x00,  0xF2,  0x50,  0x0B,  0x47,  0x10,  0x09,  0xE7,  0x08,  0x00,
  0x41,  0x10,  0x05,  0x80,  0x48,  0xE4,  0x00,  0x00,  0x1E,  0x12,  0x00,  0xE6,  0x11,  0x00,  0x00,  0xEA,
  0xB8,  0x00,  0x00,  0xF2,  0x8A,  0x10,  0x2C,  0x90,  0xAE,  0x90,  0x08,  0x50,  0x8A,  0x50,  0x38,  0x54,
  0x1F,  0x40,  0x00,  0xF2,  0x88,  0x0D,  0x08,  0x10,  0x08,  0x90,  0x8A,  0x90,  0x30,  0x50,  0xB2,  0x50,
  0x9C,  0x32,  0x0C,  0x92,  0x8E,  0x92,  0x38,  0x54,  0x04,  0x80,  0x30,  0xE4,  0x08,  0x00,  0x04,  0x40,
  0x0C,  0x1C,  0x00,  0xF6,  0x05,  0x00,  0xB1,  0xF0,  0x16,  0x07,  0x9E,  0xF0,  0x2A,  0x07,  0x01,  0x48,
  0x55,  0xF0,  0xEC,  0x09,  0x0C,  0x1C,  0x10,  0x44,  0xED,  0x10,  0x0B,  0xF0,  0x4E,  0x07,  0x0C,  0xF0,
  0x52,  0x07,  0x05,  0xF0,  0x42,  0x07,  0x06,  0xF0,  0x48,  0x07,  0x09,  0xF0,  0x14,  0x09,  0x00,  0xF0,
  0xF2,  0x09,  0x00,  0xF2,  0x50,  0x0B,  0xCF,  0x10,  0x09,  0xE7,  0x08,  0x00,  0xC9,  0x10,  0x2E,  0x1C,
  0x02,  0x10,  0x2C,  0x1C,  0xAA,  0xF0,  0x54,  0x07,  0xAC,  0xF0,  0x62,  0x07,  0x40,  0x10,  0x34,  0x1C,
  0xF3,  0x10,  0xAD,  0xF0,  0x6C,  0x07,  0xC8,  0x10,  0x36,  0x1C,  0xE9,  0x10,  0x2B,  0xF0,  0x72,  0x08,
  0x6B,  0x18,  0x18,  0xF4,  0x00,  0xFE,  0x20,  0x12,  0x01,  0x58,  0xD2,  0xF0,  0x72,  0x08,  0x76,  0x18,
  0x18,  0xF4,  0x03,  0x00,  0xEC,  0x12,  0x00,  0xFC,  0x22,  0x01,  0x18,  0xF4,  0x01,  0x00,  0xE2,  0x12,
  0x0B,  0xF0,  0x54,  0x07,  0x0C,  0xF0,  0x54,  0x07,  0x36,  0x1C,  0x34,  0x1C,  0xB7,  0x10,  0x38,  0x54,
  0xB9,  0x54,  0x84,  0x80,  0x19,  0xE4,  0x20,  0x00,  0xB2,  0x13,  0x85,  0x80,  0x81,  0x48,  0x66,  0x12,
  0x04,  0x80,  0x18,  0xE4,  0x08,  0x00,  0x58,  0x13,  0x1F,  0x80,  0x08,  0x44,  0xC8,  0x44,  0x9F,  0x12,
  0x1F,  0x40,  0x34,  0x91,  0xB6,  0x91,  0x44,  0x55,  0xE5,  0x55,  0x02,  0xEC,  0xB8,  0x00,  0x02,  0x49,
  0xBB,  0x55,  0x82,  0x81,  0xC0,  0x55,  0x48,  0xF4,  0x0F,  0x00,  0x5A,  0xF0,  0x0A,  0x08,  0x4A,  0xE4,
  0x17,  0x00,  0xD5,  0xF0,  0xEA,  0x07,  0x02,  0xF6,  0x0F,  0x00,  0x02,  0xF4,  0x02,  0x00,  0x02,  0xEA,
  0xB8,  0x00,  0x04,  0x91,  0x86,  0x91,  0x02,  0x4B,  0x2C,  0x90,  0x08,  0x50,  0x2E,  0x90,  0x0A,  0x50,
  0x2C,  0x51,  0xAE,  0x51,  0x00,  0xF2,  0x8A,  0x10,  0x38,  0x54,  0x00,  0xF2,  0x88,  0x0D,  0x56,  0x10,
  0x34,  0x91,  0xB6,  0x91,  0x0C,  0x10,  0x04,  0x80,  0x18,  0xE4,  0x08,  0x00,  0x41,  0x12,  0x0C,  0x91,
  0x8E,  0x91,  0x04,  0x80,  0x18,  0xE4,  0xF7,  0x00,  0x04,  0x40,  0x30,  0x90,  0xB2,  0x90,  0x36,  0x10,
  0x02,  0x80,  0x48,  0xE4,  0x10,  0x00,  0x31,  0x12,  0x82,  0xE7,  0x10,  0x00,  0x84,  0x80,  0x19,  0xE4,
  0x20,  0x00,  0x10,  0x13,  0x0C,  0x90,  0x8E,  0x90,  0x5D,  0xF0,  0x68,  0x07,  0x0C,  0x58,  0x8D,  0x58,
  0x00,  0xF0,  0x54,  0x07,  0x38,  0x54,  0xB9,  0x54,  0x19,  0x80,  0xF1,  0x10,  0x3A,  0x55,  0x19,  0x81,
  0xBB,  0x55,  0x10,  0x90,  0x92,  0x90,  0x10,  0x58,  0x91,  0x58,  0x14,  0x59,  0x95,  0x59,  0x00,  0xF0,
  0x54,  0x07,  0x04,  0x80,  0x18,  0xE4,  0x20,  0x00,  0x06,  0x12,  0x6C,  0x19,  0x19,  0x41,  0x7C,  0x10,
  0x6C,  0x19,  0x0C,  0x51,  0xED,  0x19,  0x8E,  0x51,  0x6B,  0x18,  0x18,  0xF4,  0x00,  0xFF,  0x02,  0x13,
  0x6A,  0x10,  0x01,  0x58,  0xD2,  0xF0,  0xB0,  0x08,  0x76,  0x18,  0x18,  0xF4,  0x03,  0x00,  0x0A,  0x12,
  0x00,  0xFC,  0x22,  0x01,  0x18,  0xF4,  0x01,  0x00,  0x06,  0x13,  0x9E,  0xE7,  0x16,  0x00,  0x4C,  0x10,
  0xD1,  0xF0,  0xBA,  0x08,  0x9E,  0xE7,  0x17,  0x00,  0x42,  0x10,  0xD0,  0xF0,  0xC4,  0x08,  0x9E,  0xE7,
  0x19,  0x00,  0x38,  0x10,  0xCF,  0xF0,  0xCE,  0x08,  0x9E,  0xE7,  0x20,  0x00,  0x2E,  0x10,  0xCE,  0xF0,
  0xD8,  0x08,  0x9E,  0xE7,  0x21,  0x00,  0x24,  0x10,  0xCD,  0xF0,  0xE2,  0x08,  0x9E,  0xE7,  0x22,  0x00,
  0x1A,  0x10,  0xCC,  0xF0,  0xF4,  0x08,  0x84,  0x80,  0x19,  0xE4,  0x04,  0x00,  0x06,  0x12,  0x9E,  0xE7,
  0x12,  0x00,  0x08,  0x10,  0xCB,  0xF0,  0xFC,  0x08,  0x9E,  0xE7,  0x24,  0x00,  0xB1,  0xF0,  0xFC,  0x08,
  0x05,  0xF0,  0x0E,  0x09,  0x09,  0xF0,  0x14,  0x09,  0x1E,  0xF0,  0xEC,  0x09,  0xE4,  0x10,  0x00,  0xF2,
  0x50,  0x0B,  0xE9,  0x10,  0x9C,  0x32,  0x82,  0xE7,  0x20,  0x00,  0x32,  0x1C,  0xE9,  0x09,  0x00,  0xF2,
  0xE6,  0x10,  0x85,  0xF0,  0xF2,  0x09,  0x69,  0x08,  0x01,  0xF0,  0x34,  0x09,  0x1E,  0xF0,  0xEC,  0x09,
  0x00,  0xF0,  0x28,  0x09,  0x30,  0x44,  0x06,  0x12,  0x9E,  0xE7,  0x42,  0x00,  0xB8,  0x10,  0x04,  0xF6,
  0x01,  0x00,  0xB3,  0x45,  0x74,  0x12,  0x04,  0x80,  0x18,  0xE4,  0x20,  0x00,  0x22,  0x13,  0x4B,  0xE4,
  0x02,  0x00,  0x36,  0x12,  0x4B,  0xE4,  0x28,  0x00,  0xAC,  0x13,  0x00,  0xF2,  0x92,  0x11,  0x00,  0xF2,
  0x9E,  0x11,  0x03,  0xF6,  0xD0,  0x00,  0xFA,  0x14,  0x82,  0xE7,  0x01,  0x00,  0x00,  0xF0,  0x80,  0x01,
  0x9E,  0xE7,  0x44,  0x00,  0x4B,  0xE4,  0x02,  0x00,  0x06,  0x12,  0x03,  0xE6,  0x02,  0x00,  0x76,  0x10,
  0x00,  0xF2,  0x76,  0x0D,  0x03,  0xE6,  0x02,  0x00,  0x6C,  0x10,  0x00,  0xF2,  0x76,  0x0D,  0x19,  0x82,
  0x34,  0x46,  0x0A,  0x13,  0x03,  0xE6,  0x02,  0x00,  0x9E,  0xE7,  0x43,  0x00,  0x68,  0x10,  0x04,  0x80,
  0x30,  0xE4,  0x20,  0x00,  0x04,  0x40,  0x00,  0xF2,  0x92,  0x11,  0x00,  0xF2,  0x9E,  0x11,  0x82,  0xE7,
  0x01,  0x00,  0x06,  0xF7,  0x02,  0x00,  0x00,  0xF0,  0x08,  0x03,  0x04,  0x80,  0x18,  0xE4,  0x20,  0x00,
  0x06,  0x12,  0x03,  0xE6,  0x02,  0x00,  0x3E,  0x10,  0x04,  0x80,  0x18,  0xE4,  0x02,  0x00,  0x3A,  0x12,
  0x04,  0x80,  0x18,  0xE4,  0xFD,  0x00,  0x04,  0x40,  0x1C,  0x1C,  0x9D,  0xF0,  0xDA,  0x09,  0x1C,  0x1C,
  0x9D,  0xF0,  0xE0,  0x09,  0xC1,  0x10,  0x9E,  0xE7,  0x13,  0x00,  0x0A,  0x10,  0x9E,  0xE7,  0x41,  0x00,
  0x04,  0x10,  0x9E,  0xE7,  0x24,  0x00,  0x00,  0xFC,  0xBE,  0x00,  0x98,  0x57,  0xD5,  0xF0,  0x8A,  0x02,
  0x04,  0xE6,  0x04,  0x00,  0x06,  0x10,  0x04,  0xE6,  0x04,  0x00,  0x9D,  0x41,  0x1C,  0x42,  0x9F,  0xE7,
  0x00,  0x00,  0x06,  0xF7,  0x02,  0x00,  0x03,  0xF6,  0xE0,  0x00,  0x3C,  0x14,  0x44,  0x58,  0x45,  0x58,
  0x00,  0xF2,  0xCA,  0x0D,  0x00,  0xF2,  0x52,  0x10,  0x00,  0xF2,  0x9A,  0x0F,  0x3C,  0x14,  0x1E,  0x1C,
  0x00,  0xF0,  0x80,  0x01,  0x12,  0x1C,  0x22,  0x1C,  0xD2,  0x14,  0x00,  0xF0,  0x72,  0x01,  0x83,  0x59,
  0x03,  0xDC,  0x73,  0x57,  0x80,  0x5D,  0x00,  0x16,  0x83,  0x59,  0x03,  0xDC,  0x38,  0x54,  0x70,  0x57,
  0x33,  0x54,  0x3B,  0x54,  0x80,  0x5D,  0x00,  0x16,  0x03,  0x57,  0x83,  0x59,  0x38,  0x54,  0x00,  0xCC,
  0x00,  0x16,  0x03,  0x57,  0x83,  0x59,  0x00,  0x4C,  0x00,  0x16,  0x02,  0x80,  0x48,  0xE4,  0x01,  0x00,
  0x0E,  0x12,  0x48,  0xE4,  0x05,  0x00,  0x08,  0x12,  0x00,  0xF2,  0x92,  0x11,  0x00,  0xF2,  0x9E,  0x11,
  0xC1,  0x5A,  0x3A,  0x55,  0x02,  0xEC,  0xB5,  0x00,  0x45,  0x59,  0x00,  0xF2,  0xCA,  0x0D,  0x83,  0x58,
  0x30,  0xE7,  0x00,  0x00,  0x10,  0x4D,  0x30,  0xE7,  0x40,  0x00,  0x10,  0x4F,  0x38,  0x90,  0xBA,  0x90,
  0x10,  0x5C,  0x80,  0x5C,  0x83,  0x5A,  0x10,  0x4E,  0x04,  0xEA,  0xB5,  0x00,  0x43,  0x5B,  0x03,  0xF4,
  0xE0,  0x00,  0x83,  0x59,  0x04,  0xCC,  0x01,  0x4A,  0x0A,  0x12,  0x45,  0x5A,  0x00,  0xF2,  0xCA,  0x0D,
  0x00,  0xF2,  0x0C,  0x10,  0x00,  0x16,  0x08,  0x1C,  0x00,  0xFC,  0xAC,  0x00,  0x06,  0x58,  0x67,  0x18,
  0x18,  0xF4,  0x8F,  0xE1,  0x01,  0xFC,  0xAE,  0x00,  0x19,  0xF4,  0x70,  0x1E,  0xB0,  0x54,  0x07,  0x58,
  0x00,  0xFC,  0xB0,  0x00,  0x08,  0x58,  0x00,  0xFC,  0xB2,  0x00,  0x09,  0x58,  0x0A,  0x1C,  0x00,  0xE6,
  0x0F,  0x00,  0x00,  0xEA,  0xB9,  0x00,  0x38,  0x54,  0x00,  0xFA,  0x24,  0x01,  0x00,  0xFA,  0xB6,  0x00,
  0x18,  0x1C,  0x14,  0x1C,  0x10,  0x1C,  0x32,  0x1C,  0x12,  0x1C,  0x00,  0x16,  0x3E,  0x57,  0x0C,  0x14,
  0x0E,  0x47,  0x07,  0xE6,  0x10,  0x00,  0xCE,  0x47,  0xF5,  0x13,  0x00,  0x16,  0x00,  0xF2,  0x76,  0x0D,
  0x02,  0x4B,  0x03,  0xF6,  0xE0,  0x00,  0x00,  0xF2,  0x58,  0x0A,  0x01,  0x48,  0x20,  0x12,  0x44,  0x58,
  0x45,  0x58,  0x9E,  0xE7,  0x15,  0x00,  0x9C,  0xE7,  0x04,  0x00,  0x00,  0xF2,  0xCA,  0x0D,  0x00,  0xF2,
  0x52,  0x10,  0x00,  0xF2,  0x9A,  0x0F,  0x00,  0xF2,  0x6A,  0x0A,  0x1E,  0x1C,  0xD5,  0x10,  0x00,  0x16,
  0x68,  0x08,  0x48,  0xE4,  0x04,  0x00,  0x3E,  0x12,  0x48,  0xE4,  0x02,  0x00,  0x22,  0x12,  0x48,  0xE4,
  0x03,  0x00,  0x1C,  0x12,  0x48,  0xE4,  0x08,  0x00,  0x16,  0x12,  0x48,  0xE4,  0x01,  0x00,  0xCC,  0x12,
  0x48,  0xE4,  0x07,  0x00,  0x16,  0x12,  0x01,  0xE6,  0x07,  0x00,  0x00,  0xF2,  0x20,  0x0D,  0x02,  0x10,
  0x3E,  0x1C,  0x00,  0xF2,  0xE6,  0x10,  0x05,  0xF0,  0x50,  0x0B,  0x00,  0x16,  0x00,  0xE6,  0x01,  0x00,
  0x00,  0xEA,  0x99,  0x00,  0xEB,  0x10,  0x3E,  0x1C,  0x02,  0x80,  0x48,  0xE4,  0x10,  0x00,  0x1C,  0x12,
  0x82,  0xE7,  0x08,  0x00,  0x3C,  0x56,  0x03,  0x82,  0x00,  0xF2,  0xB6,  0x0D,  0x30,  0xE7,  0x08,  0x00,
  0x04,  0xF7,  0x70,  0x01,  0x06,  0xF7,  0x02,  0x00,  0x00,  0xF0,  0x80,  0x01,  0x6C,  0x19,  0xED,  0x19,
  0x5D,  0xF0,  0xA0,  0x0B,  0x44,  0x55,  0xE5,  0x55,  0x59,  0xF0,  0x1E,  0x0C,  0x04,  0x55,  0xA5,  0x55,
  0x1F,  0x80,  0x01,  0xEC,  0xB8,  0x00,  0x82,  0x48,  0x82,  0x80,  0x49,  0x44,  0x2E,  0x13,  0x01,  0xEC,
  0xB8,  0x00,  0x41,  0xE4,  0x02,  0x00,  0x01,  0xEA,  0xB8,  0x00,  0x49,  0xE4,  0x11,  0x00,  0x59,  0xF0,
  0xFA,  0x0B,  0x01,  0xE6,  0x17,  0x00,  0x01,  0xEA,  0xB8,  0x00,  0x02,  0x4B,  0x88,  0x90,  0xAC,  0x50,
  0x8A,  0x90,  0xAE,  0x50,  0x01,  0xEC,  0xB8,  0x00,  0x82,  0x48,  0x82,  0x80,  0x10,  0x44,  0x02,  0x4B,
  0x1F,  0x40,  0xC0,  0x44,  0x00,  0xF2,  0x88,  0x0D,  0x04,  0x55,  0xA5,  0x55,  0x9F,  0x10,  0x0C,  0x51,
  0x8E,  0x51,  0x30,  0x90,  0xB2,  0x90,  0x00,  0x56,  0xA1,  0x56,  0x30,  0x50,  0xB2,  0x50,  0x34,  0x90,
  0xB6,  0x90,  0x40,  0x56,  0xE1,  0x56,  0x34,  0x50,  0xB6,  0x50,  0x65,  0x10,  0x3E,  0x1C,  0x00,  0xF2,
  0xE6,  0x10,  0x85,  0xF0,  0x8A,  0x0B,  0xE9,  0x09,  0x4B,  0xE4,  0x03,  0x00,  0x7E,  0x12,  0x4B,  0xE4,
  0x02,  0x00,  0x23,  0x13,  0xB1,  0xF0,  0x54,  0x0C,  0x85,  0xF0,  0x8A,  0x0B,  0x69,  0x08,  0x48,  0xE4,
  0x03,  0x00,  0xD5,  0xF0,  0x76,  0x0B,  0x00,  0xF2,  0xE6,  0x10,  0x85,  0xF0,  0x8A,  0x0B,  0xE8,  0x09,
  0x3C,  0x56,  0x00,  0xFC,  0x20,  0x01,  0x98,  0x57,  0x02,  0x13,  0xBB,  0x45,  0x4B,  0xE4,  0x00,  0x00,
  0x08,  0x12,  0x03,  0xE6,  0x01,  0x00,  0x04,  0xF6,  0x00,  0x80,  0xAE,  0x14,  0xD8,  0x14,  0x30,  0x1C,
  0x02,  0x80,  0x48,  0xE4,  0x03,  0x00,  0x16,  0x13,  0x00,  0xFC,  0x9E,  0x00,  0x98,  0x57,  0x0A,  0x12,
  0x00,  0xFC,  0xB6,  0x00,  0x98,  0x57,  0x02,  0x13,  0x4C,  0x1C,  0x00,  0xF0,  0x80,  0x0B,  0x00,  0xFC,
  0x24,  0x01,  0xB0,  0x57,  0x00,  0xFA,  0x24,  0x01,  0x4C,  0x1C,  0x3E,  0x1C,  0x00,  0xF2,  0xE6,  0x10,
  0x86,  0xF0,  0x82,  0x0B,  0x00,  0xF2,  0x60,  0x0E,  0x00,  0xF0,  0x82,  0x0B,  0xB1,  0xF0,  0xCC,  0x0C,
  0x85,  0xF0,  0x76,  0x0B,  0x69,  0x08,  0x48,  0xE4,  0x01,  0x00,  0xD5,  0xF0,  0x76,  0x0B,  0xFC,  0x14,
  0x42,  0x58,  0x6C,  0x14,  0x80,  0x14,  0x30,  0x1C,  0x4A,  0xF4,  0x02,  0x00,  0x55,  0xF0,  0x76,  0x0B,
  0x4A,  0xF4,  0x01,  0x00,  0x0C,  0x12,  0x02,  0x80,  0x48,  0xE4,  0x03,  0x00,  0x04,  0x13,  0x00,  0xF0,
  0x80,  0x0B,  0x00,  0xFC,  0xB6,  0x00,  0xB0,  0x57,  0x00,  0xFA,  0xB6,  0x00,  0x4C,  0x1C,  0x3E,  0x1C,
  0x00,  0xF2,  0xE6,  0x10,  0x86,  0xF0,  0x82,  0x0B,  0x00,  0xF2,  0x8E,  0x0E,  0x00,  0xF0,  0x82,  0x0B,
  0x86,  0xF0,  0x2C,  0x0D,  0x4E,  0x1C,  0x89,  0x48,  0x4E,  0x1C,  0x00,  0x16,  0x85,  0xF0,  0x28,  0x0D,
  0x4C,  0x1C,  0x3E,  0x1C,  0x00,  0xF2,  0xE6,  0x10,  0xE7,  0x10,  0x00,  0xF6,  0x00,  0x01,  0x00,  0x57,
  0x00,  0x57,  0x03,  0x58,  0x00,  0xDC,  0x18,  0xF4,  0xFF,  0x7F,  0x30,  0x56,  0x00,  0x5C,  0x00,  0x16,
  0x00,  0xF6,  0x00,  0x01,  0x00,  0x57,  0x00,  0x57,  0x03,  0x58,  0x00,  0xDC,  0x18,  0xF4,  0x00,  0x80,
  0x30,  0x56,  0x00,  0x5C,  0x00,  0x16,  0x00,  0xF6,  0x00,  0x01,  0x00,  0x57,  0x00,  0x57,  0x03,  0x58,
  0x00,  0xDC,  0x0B,  0x58,  0x00,  0x16,  0x03,  0xF6,  0x24,  0x01,  0x00,  0xF2,  0x48,  0x0A,  0x03,  0xF6,
  0xB6,  0x00,  0x00,  0xF2,  0x48,  0x0A,  0x00,  0x16,  0x02,  0xEC,  0xB8,  0x00,  0x02,  0x49,  0x18,  0xF4,
  0xFF,  0x00,  0x00,  0x54,  0x00,  0x54,  0x00,  0x54,  0x00,  0xF4,  0x08,  0x00,  0xE1,  0x18,  0x80,  0x54,
  0x03,  0x58,  0x00,  0xDD,  0x01,  0xDD,  0x02,  0xDD,  0x03,  0xDC,  0x02,  0x4B,  0x30,  0x50,  0xB2,  0x50,
  0x34,  0x51,  0xB6,  0x51,  0x00,  0x16,  0x45,  0x5A,  0x1D,  0xF4,  0xFF,  0x00,  0x85,  0x56,  0x85,  0x56,
  0x85,  0x56,  0x05,  0xF4,  0x02,  0x12,  0x83,  0x5A,  0x00,  0x16,  0x1D,  0xF4,  0xFF,  0x00,  0x85,  0x56,
  0x85,  0x56,  0x85,  0x56,  0x05,  0xF4,  0x00,  0x12,  0x83,  0x5A,  0x00,  0x16,  0x38,  0x54,  0xBB,  0x55,
  0x3C,  0x56,  0xBD,  0x56,  0x00,  0xF2,  0xE6,  0x10,  0x85,  0xF0,  0x56,  0x0E,  0xE9,  0x09,  0xC1,  0x59,
  0x00,  0xF2,  0xE6,  0x10,  0x85,  0xF0,  0x56,  0x0E,  0xE8,  0x0A,  0x83,  0x55,  0x83,  0x55,  0x4B,  0xF4,
  0x90,  0x01,  0x5C,  0xF0,  0x0A,  0x0E,  0xBD,  0x56,  0x40,  0x10,  0x4B,  0xF4,  0x30,  0x00,  0x59,  0xF0,
  0x1C,  0x0E,  0x01,  0xF6,  0x0C,  0x00,  0x00,  0xF6,  0x01,  0x00,  0x2E,  0x10,  0x02,  0xFC,  0x9C,  0x00,
  0x9A,  0x57,  0x14,  0x13,  0x4B,  0xF4,  0x64,  0x00,  0x59,  0xF0,  0x38,  0x0E,  0x03,  0xF6,  0x64,  0x00,
  0x01,  0xF6,  0x19,  0x00,  0x00,  0xF6,  0x01,  0x00,  0x43,  0xF4,  0x33,  0x00,  0x56,  0xF0,  0x4A,  0x0E,
  0x04,  0xF4,  0x00,  0x01,  0x43,  0xF4,  0x19,  0x00,  0xF3,  0x10,  0xB4,  0x56,  0xC3,  0x58,  0x02,  0xFC,
  0x9E,  0x00,  0x9A,  0x57,  0x08,  0x13,  0x3C,  0x56,  0x00,  0xF6,  0x02,  0x00,  0x00,  0x16,  0x00,  0x16,
  0x09,  0xE7,  0x01,  0x00,  0x00,  0xF2,  0xE6,  0x10,  0x86,  0xF0,  0x8C,  0x0E,  0x09,  0xE7,  0x02,  0x00,
  0x00,  0xF2,  0xE6,  0x10,  0x86,  0xF0,  0x8C,  0x0E,  0x09,  0xE7,  0x03,  0x00,  0x00,  0xF2,  0xE6,  0x10,
  0x86,  0xF0,  0x8C,  0x0E,  0x4E,  0x1C,  0x89,  0x49,  0x00,  0xF2,  0xE6,  0x10,  0x00,  0x16,  0x09,  0xE7,
  0x01,  0x00,  0x00,  0xF2,  0xE6,  0x10,  0x86,  0xF0,  0xC6,  0x0E,  0x09,  0xE7,  0x03,  0x00,  0x00,  0xF2,
  0xE6,  0x10,  0x86,  0xF0,  0xC6,  0x0E,  0x09,  0xE7,  0x01,  0x00,  0x00,  0xF2,  0xE6,  0x10,  0x86,  0xF0,
  0xC6,  0x0E,  0x89,  0x49,  0x00,  0xF2,  0xE6,  0x10,  0x86,  0xF0,  0xC6,  0x0E,  0x4E,  0x1C,  0x89,  0x4A,
  0x00,  0xF2,  0xE6,  0x10,  0x00,  0x16,  0x3C,  0x56,  0x00,  0x16,  0x00,  0xEC,  0x26,  0x01,  0x48,  0xE4,
  0x01,  0x00,  0x1E,  0x13,  0x38,  0x44,  0x00,  0xEA,  0x26,  0x01,  0x49,  0xF4,  0x00,  0x00,  0x04,  0x12,
  0x4E,  0x1C,  0x02,  0x10,  0x4C,  0x1C,  0x01,  0xEC,  0x27,  0x01,  0x89,  0x48,  0x00,  0xF2,  0xE6,  0x10,
  0x02,  0x14,  0x00,  0x16,  0x85,  0xF0,  0x26,  0x0F,  0x38,  0x54,  0x00,  0xEA,  0x99,  0x00,  0x00,  0xF2,
  0x50,  0x0B,  0x02,  0x80,  0x48,  0xE4,  0x06,  0x00,  0x1C,  0x13,  0x00,  0xEC,  0x99,  0x00,  0x48,  0xE4,
  0x01,  0x00,  0x0A,  0x12,  0x04,  0x80,  0x30,  0xE4,  0x01,  0x00,  0x04,  0x40,  0x08,  0x10,  0x04,  0x80,
  0x18,  0xE4,  0xFE,  0x00,  0x04,  0x40,  0x00,  0x16,  0x02,  0xF6,  0xE0,  0x00,  0x02,  0x57,  0x03,  0x59,
  0x01,  0xCC,  0x81,  0x48,  0x22,  0x12,  0x00,  0x4E,  0x83,  0x5A,  0x90,  0x4C,  0x20,  0xE7,  0x00,  0x00,
  0xC3,  0x58,  0x1B,  0xF4,  0xFF,  0x00,  0x83,  0x55,  0x83,  0x55,  0x83,  0x55,  0x03,  0xF4,  0x00,  0x12,
  0x8B,  0x55,  0x83,  0x59,  0x00,  0x4E,  0x00,  0x16,  0x00,  0x4E,  0x02,  0xF6,  0xF0,  0x00,  0x02,  0x57,
  0x03,  0x59,  0x00,  0x4E,  0x83,  0x5A,  0x30,  0xE7,  0x00,  0x00,  0x20,  0xE7,  0x00,  0x00,  0x00,  0x16,
  0x02,  0xF6,  0xF0,  0x00,  0x02,  0x57,  0x03,  0x59,  0x01,  0xCC,  0x00,  0x4E,  0x83,  0x5A,  0x30,  0xE7,
  0x00,  0x00,  0x80,  0x4C,  0xC3,  0x58,  0x1B,  0xF4,  0xFF,  0x00,  0x83,  0x55,  0x83,  0x55,  0x83,  0x55,
  0x03,  0xF4,  0x00,  0x12,  0x83,  0x59,  0x00,  0x4E,  0x00,  0x16,  0x03,  0xF6,  0xE0,  0x00,  0x03,  0x57,
  0x83,  0x59,  0x3A,  0x55,  0x02,  0xCC,  0x45,  0x5A,  0x00,  0xF2,  0xCA,  0x0D,  0xC0,  0x5A,  0x40,  0x5C,
  0x38,  0x54,  0x00,  0xCD,  0x01,  0xCC,  0x4A,  0x46,  0x0A,  0x13,  0x83,  0x59,  0x00,  0x4C,  0x01,  0x48,
  0x16,  0x13,  0x0C,  0x10,  0xC5,  0x58,  0x00,  0xF2,  0xCA,  0x0D,  0x00,  0x4C,  0x01,  0x48,  0x08,  0x13,
  0x05,  0xF6,  0xF0,  0x00,  0x05,  0x57,  0x08,  0x10,  0x45,  0x58,  0x00,  0xF2,  0xCA,  0x0D,  0x8D,  0x56,
  0x83,  0x5A,  0x80,  0x4C,  0x05,  0x17,  0x00,  0x16,  0x02,  0x4B,  0x06,  0xF7,  0x04,  0x00,  0x62,  0x0B,
  0x03,  0x82,  0x00,  0xF2,  0xB6,  0x0D,  0x02,  0x80,  0x00,  0x4C,  0x45,  0xF4,  0x02,  0x00,  0x52,  0x14,
  0x06,  0xF7,  0x02,  0x00,  0x06,  0x14,  0x00,  0xF2,  0x28,  0x0F,  0x00,  0x16,  0x02,  0x4B,  0x01,  0xF6,
  0xFF,  0x00,  0x38,  0x1C,  0x05,  0xF4,  0x04,  0x00,  0x83,  0x5A,  0x18,  0xDF,  0x19,  0xDF,  0x1D,  0xF7,
  0x3C,  0x00,  0xB8,  0xF0,  0x22,  0x10,  0x9C,  0x14,  0x01,  0x48,  0x1C,  0x13,  0x0E,  0xF7,  0x3C,  0x00,
  0x03,  0xF7,  0x04,  0x00,  0xAF,  0x19,  0x03,  0x42,  0x45,  0xF4,  0x02,  0x00,  0x83,  0x5A,  0x02,  0xCC,
  0x02,  0x41,  0x45,  0xF4,  0x02,  0x00,  0x00,  0x16,  0x91,  0x44,  0xD5,  0xF0,  0x12,  0x10,  0x00,  0xF0,
  0x9E,  0x02,  0x01,  0xF6,  0xFF,  0x00,  0x38,  0x1C,  0x05,  0xF4,  0x04,  0x00,  0x83,  0x5A,  0x18,  0xDF,
  0x19,  0xDF,  0x0E,  0xF7,  0x3C,  0x00,  0x03,  0xF7,  0x04,  0x00,  0x0F,  0x79,  0x1C,  0xF7,  0x3C,  0x00,
  0xB8,  0xF0,  0x70,  0x10,  0x4E,  0x14,  0x01,  0x48,  0x06,  0x13,  0x45,  0xF4,  0x04,  0x00,  0x00,  0x16,
  0x91,  0x44,  0xD5,  0xF0,  0x56,  0x10,  0x00,  0xF0,  0x9E,  0x02,  0x02,  0xF6,  0xFF,  0x00,  0x38,  0x1C,
  0x2C,  0xBC,  0xAE,  0xBC,  0xE2,  0x08,  0x00,  0xEC,  0xB8,  0x00,  0x02,  0x48,  0x1D,  0xF7,  0x80,  0x00,
  0xB8,  0xF0,  0xA0,  0x10,  0x1E,  0x14,  0x01,  0x48,  0x0E,  0x13,  0x0E,  0xF7,  0x80,  0x00,  0x38,  0x54,
  0x03,  0x58,  0xAF,  0x19,  0x82,  0x48,  0x00,  0x16,  0x82,  0x48,  0x12,  0x45,  0xD5,  0xF0,  0x8E,  0x10,
  0x00,  0xF0,  0x9E,  0x02,  0x39,  0xF0,  0xCC,  0x10,  0x38,  0x44,  0x00,  0x16,  0x7E,  0x18,  0x18,  0xF4,
  0x03,  0x00,  0x04,  0x13,  0x61,  0x18,  0x00,  0x16,  0x38,  0x1C,  0x00,  0xFC,  0x22,  0x01,  0x18,  0xF4,
  0x01,  0x00,  0xF1,  0x12,  0xE3,  0x10,  0x1E,  0xF0,  0xEE,  0x10,  0x14,  0xF0,  0xE6,  0x10,  0xB1,  0xF0,
  0xEE,  0x10,  0x00,  0x16,  0x3E,  0x57,  0x03,  0xF6,  0xE0,  0x00,  0x03,  0x57,  0x83,  0x59,  0x04,  0xCC,
  0x01,  0x4A,  0x6A,  0x12,  0x45,  0x5A,  0x00,  0xF2,  0xCA,  0x0D,  0x02,  0x4B,  0x70,  0x14,  0x34,  0x13,
  0x02,  0x80,  0x48,  0xE4,  0x08,  0x00,  0x18,  0x12,  0x9C,  0xE7,  0x02,  0x00,  0x9E,  0xE7,  0x15,  0x00,
  0x00,  0xF2,  0x9A,  0x0F,  0x00,  0xF2,  0x6A,  0x0A,  0x1E,  0x1C,  0x01,  0xF6,  0x01,  0x00,  0x00,  0x16,
  0x30,  0xE4,  0x10,  0x00,  0x04,  0x40,  0x00,  0xF2,  0xB6,  0x0D,  0x20,  0xE7,  0x01,  0x00,  0x01,  0xF6,
  0x01,  0x00,  0x00,  0x16,  0x04,  0xDC,  0x01,  0x4A,  0x24,  0x12,  0x45,  0x5A,  0x00,  0xF2,  0xCA,  0x0D,
  0x43,  0x5B,  0x06,  0xEC,  0x98,  0x00,  0x00,  0xF2,  0x0C,  0x10,  0xC6,  0x59,  0x20,  0x14,  0x0A,  0x13,
  0x00,  0xF2,  0x9A,  0x0F,  0x00,  0xF2,  0xE8,  0x0F,  0xA7,  0x10,  0x83,  0x5A,  0xD7,  0x10,  0x0E,  0x47,
  0x07,  0xE6,  0x10,  0x00,  0xCE,  0x47,  0x5A,  0xF0,  0xF6,  0x10,  0xB9,  0x54,  0x00,  0x16,  0x14,  0x90,
  0x96,  0x90,  0x02,  0xFC,  0xA8,  0x00,  0x03,  0xFC,  0xAA,  0x00,  0x48,  0x55,  0x02,  0x13,  0xC9,  0x55,
  0x00,  0x16,  0x00,  0xEC,  0xBA,  0x00,  0x10,  0x44,  0x00,  0xEA,  0xBA,  0x00,  0x00,  0x16,  0x03,  0xF6,
  0xC0,  0x00,  0x00,  0xF2,  0x58,  0x0A,  0x10,  0x44,  0x00,  0x4C,  0x00,  0x16,  0x00,  0xF6,  0x02,  0x00,
  0x00,  0x10,  0x00,  0x10,  0x10,  0x54,  0xF9,  0x13,  0x00,  0x16,};

unsigned short _adv_mcode_size = sizeof(_adv_mcode_buf); /* 0x11BA */
unsigned long  _adv_mcode_chksum = 0x03406FC9UL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc3550\a_scsi.h ===
/*
 * a_scsi.h - Adv Library SCSI Include File
 *
 * Copyright (c) 1997-1998 Advanced System Products, Inc.
 * All Rights Reserved.
 */

#ifndef __A_SCSI_H_
#define __A_SCSI_H_

#define ASC_MAX_SENSE_LEN   32
#define ASC_MIN_SENSE_LEN   14

#define ASC_MAX_CDB_LEN     12 /* maximum command descriptor block */

/*
 * SCSI Bus Reset Hold Time - 60 microseconds.
 *
 * The minimum SCSI Bus Reset Hold Time defined in the SCSI Spec. is
 * 25 microseconds. The spec. does not define a maximum Hold Time. It
 * has been found that some devices will not operate after a SCSI Bus
 * Reset Hold Time of greater than 400 microseconds.
 *
 */
#define ASC_SCSI_RESET_HOLD_TIME_US  60

/*
 * SCSI Command Codes
 */
#define SCSICMD_TestUnitReady     0x00
#define SCSICMD_Rewind            0x01
#define SCSICMD_Rezero            0x01
#define SCSICMD_RequestSense      0x03
#define SCSICMD_Format            0x04
#define SCSICMD_FormatUnit        0x04
#define SCSICMD_Read6             0x08
#define SCSICMD_Write6            0x0A
#define SCSICMD_Seek6             0x0B
#define SCSICMD_Inquiry           0x12
#define SCSICMD_Verify6           0x13
#define SCSICMD_ModeSelect6       0x15
#define SCSICMD_ModeSense6        0x1A

#define SCSICMD_StartStopUnit     0x1B
#define SCSICMD_LoadUnloadTape    0x1B
#define SCSICMD_ReadCapacity      0x25
#define SCSICMD_Read10            0x28
#define SCSICMD_Write10           0x2A
#define SCSICMD_Seek10            0x2B
#define SCSICMD_Erase10           0x2C
#define SCSICMD_WriteAndVerify10  0x2E
#define SCSICMD_Verify10          0x2F

#define SCSICMD_WriteBuffer       0x3B
#define SCSICMD_ReadBuffer        0x3C
#define SCSICMD_ReadLong          0x3E
#define SCSICMD_WriteLong         0x3F

#define SCSICMD_ReadTOC           0x43
#define SCSICMD_ReadHeader        0x44

#define SCSICMD_ModeSelect10      0x55
#define SCSICMD_ModeSense10       0x5A

/*
 * Inquiry Data Peripheral Device Qualifier
 */
#define SCSI_QUAL_NODVC 0x03 /* LUN not supported. Device Type must be 0x1F */


/*
 * Inqury Data Peripheral Device Types
 */
#define SCSI_TYPE_DASD     0x00
#define SCSI_TYPE_SASD     0x01
#define SCSI_TYPE_PRN      0x02
#define SCSI_TYPE_PROC     0x03 /* Processor (some HP scanners) */
#define SCSI_TYPE_WORM     0x04 /* Write Once Read Many (some CD-Rs) */
#define SCSI_TYPE_CDROM    0x05
#define SCSI_TYPE_SCANNER  0x06
#define SCSI_TYPE_OPTMEM   0x07
#define SCSI_TYPE_MED_CHG  0x08
#define SCSI_TYPE_COMM     0x09
#define SCSI_TYPE_UNKNOWN  0x1F

#define SCSI_TYPE_NO_DVC   (SCSI_QUAL_NODVC | SCSI_TYPE_UNKNOWN)


#define ASC_SCSIDIR_NOCHK    0x00
        /* Direction determined by SCSI command, length not check */
#define ASC_SCSIDIR_T2H      0x08
        /* Transfer from SCSI Target to Host adapter, length check */
#define ASC_SCSIDIR_H2T      0x10
        /* Transfer from Host adapter to Target, length check  */
#define ASC_SCSIDIR_NODATA   0x18
        /* No data transfer */

#define ASC_SRB_HOST( x )  ( ( uchar )( ( uchar )( x ) >> 4 ) )
#define ASC_SRB_TID( x )   ( ( uchar )( ( uchar )( x ) & ( uchar )0x0F ) )
#define ASC_SRB_LUN( x )   ( ( uchar )( ( uint )( x ) >> 13 ) )

/* take high byte of unit number put it into CDB block index 1 */
#define PUT_CDB1( x )   ( ( uchar )( ( uint )( x ) >> 8 ) )


/*
 * SCSI Command Status Byte Values
 */
#define SS_GOOD              0x00 /* target successfully completed command  */
#define SS_CHK_CONDITION     0x02 /* contingent allegiance condition        */
#define SS_CONDITION_MET     0x04 /* requested operation is satisfied       */
#define SS_TARGET_BUSY       0x08 /* target is busy                         */
#define SS_INTERMID          0x10 /* intermediate                           */
#define SS_INTERMID_COND_MET 0x14 /* intermediate-condition met - the       */
                                  /* combination of condition-met (0x04)    */
                                  /* and intermediate (0x10) statuses       */
#define SS_RSERV_CONFLICT    0x18 /* reservation conflict                   */
#define SS_CMD_TERMINATED    0x22 /* command terminated                     */
                                  /* by terminated I/O process message or   */
                                  /* contingent allegiance condition        */
#define SS_QUEUE_FULL        0x28 /* queue full                             */


/*
 * Sense Keys
 *
 * Sense keys are returned in the Request Sense Command Data Structure.
 */
#define SCSI_SENKEY_NO_SENSE      0x00
#define SCSI_SENKEY_NOT_READY     0x02
#define SCSI_SENKEY_MEDIUM_ERR    0x03
#define SCSI_SENKEY_HW_ERR        0x04
#define SCSI_SENKEY_ILLEGAL       0x05
#define SCSI_SENKEY_ATTENTION     0x06
#define SCSI_SENKEY_PROTECTED     0x07
#define SCSI_SENKEY_BLANK         0x08
#define SCSI_SENKEY_ABORT         0x0B
#define SCSI_SENKEY_EQUAL         0x0C
#define SCSI_SENKEY_VOL_OVERFLOW  0x0D


/*
 * (ASC) Additional Sense Codes
 */
#define SCSI_ASC_NOTRDY         0x04
#define SCSI_ASC_POWERUP        0x29
#define SCSI_ASC_NOMEDIA        0x3A

/*
 * (ASCQ) Additional Sense Code Qualifiers
 */
#define SCSI_ASCQ_COMINGRDY     0x01

/*
 * SCSI messages
 */
#define MS_CMD_DONE    0x00 /* command completed            */
#define MS_EXTEND      0x01 /* first byte of extend message */
#define MS_SDTR_LEN    0x03 /* SDTR message length          */
#define MS_SDTR_CODE   0x01 /* extended message code of SDTR */

/*
 * One byte messages, 0x02 - 0x1F
 * 0x12 - 0x1F: reserved for one-byte messages
 *                                     I T, I-initiator T-target support
 *                                          O: Optional, M:mandatory
 * One byte Messages
 */
#define M1_SAVE_DATA_PTR        0x02 /*; O O save data pointer               */
#define M1_RESTORE_PTRS         0x03 /*; O O restore pointers                */
#define M1_DISCONNECT           0x04 /*; O O disconnect                      */
#define M1_INIT_DETECTED_ERR    0x05 /*; M M initiator detected error        */
#define M1_ABORT                0x06 /*; O M abort                           */
#define M1_MSG_REJECT           0x07 /*; M M message reject                  */
#define M1_NO_OP                0x08 /*; M M no operation                    */
#define M1_MSG_PARITY_ERR       0x09 /*; M M message parity error            */
#define M1_LINK_CMD_DONE        0x0A /*; O O link command completed          */
#define M1_LINK_CMD_DONE_WFLAG  0x0B /*; O O link command completed with flag*/
#define M1_BUS_DVC_RESET        0x0C /*; O M bus device reset                */
#define M1_ABORT_TAG            0x0D /*; O O abort tag                       */
#define M1_CLR_QUEUE            0x0E /*; O O clear queue                     */
#define M1_INIT_RECOVERY        0x0F /*; O O initiate recovery               */
#define M1_RELEASE_RECOVERY     0x10 /*; O O release recovery                */
#define M1_KILL_IO_PROC         0x11 /*; O O terminate i/o process           */

/*
 * First byte of two-byte queue tag messages, 0x20 - 0x2F
 * queue tag messages, 0x20 - 0x22
 */
#define M2_QTAG_MSG_SIMPLE      0x20 /* O O simple queue tag     */
#define M2_QTAG_MSG_HEAD        0x21 /* O O head of queue tag    */
#define M2_QTAG_MSG_ORDERED     0x22 /* O O ordered queue tag    */

#define M2_IGNORE_WIDE_RESIDUE  0x23 /* O O ignore wide residue  */


/*
 * Inquiry Data Structure
 */
#if !ADV_BIG_ENDIAN
typedef struct {
  uchar peri_dvc_type   : 5;    /* peripheral device type */
  uchar peri_qualifier  : 3;    /* peripheral qualifier */
  uchar dvc_type_modifier : 7;  /* device type modifier (for SCSI I) */
  uchar rmb      : 1;           /* RMB - removable medium bit */
  uchar ansi_apr_ver : 3;       /* ANSI approved version */
  uchar ecma_ver : 3;           /* ECMA version */
  uchar iso_ver  : 2;           /* ISO version */
  uchar rsp_data_fmt : 4;       /* response data format */
                                /* 0 SCSI 1 */
                                /* 1 CCS */
                                /* 2 SCSI-2 */
                                /* 3-F reserved */
  uchar res      : 2;           /* reserved */
  uchar TemIOP   : 1;           /* terminate I/O process bit (see 5.6.22) */
  uchar aenc     : 1;           /* asynch. event notification (processor) */
  uchar  add_len;               /* additional length */
  uchar  res1;                  /* reserved */
  uchar  res2;                  /* reserved */
  uchar StfRe   : 1;            /* soft reset implemented */
  uchar CmdQue  : 1;            /* command queuing */
  uchar Reserved: 1;            /* reserved */
  uchar Linked  : 1;            /* linked command for this logical unit */
  uchar Sync    : 1;            /* synchronous data transfer */
  uchar WBus16  : 1;            /* wide bus 16 bit data transfer */
  uchar WBus32  : 1;            /* wide bus 32 bit data transfer */
  uchar RelAdr  : 1;            /* relative addressing mode */
  uchar vendor_id[8];           /* vendor identification */
  uchar product_id[16];         /* product identification */
  uchar product_rev_level[4];   /* product revision level */
} ASC_SCSI_INQUIRY; /* 36 bytes */
#else /* ADV_BIG_ENDIAN */
typedef struct {
  uchar peri_qualifier  : 3;    /* peripheral qualifier */
  uchar peri_dvc_type   : 5;    /* peripheral device type */
  uchar rmb      : 1;           /* RMB - removable medium bit */
  uchar dvc_type_modifier : 7;  /* device type modifier (for SCSI I) */
  uchar iso_ver  : 2;           /* ISO version */
  uchar ecma_ver : 3;           /* ECMA version */
  uchar ansi_apr_ver : 3;       /* ANSI approved version */
  uchar aenc     : 1;           /* asynch. event notification (processor) */
  uchar TemIOP   : 1;           /* terminate I/O process bit (see 5.6.22) */
  uchar res      : 2;           /* reserved */
  uchar rsp_data_fmt : 4;       /* response data format */
                                /* 0 SCSI 1 */
                                /* 1 CCS */
                                /* 2 SCSI-2 */
                                /* 3-F reserved */
  uchar  add_len;               /* additional length */
  uchar  res1;                  /* reserved */
  uchar  res2;                  /* reserved */
  uchar RelAdr  : 1;            /* relative addressing mode */
  uchar WBus32  : 1;            /* wide bus 32 bit data transfer */
  uchar WBus16  : 1;            /* wide bus 16 bit data transfer */
  uchar Sync    : 1;            /* synchronous data transfer */
  uchar Linked  : 1;            /* linked command for this logical unit */
  uchar Reserved: 1;            /* reserved */
  uchar CmdQue  : 1;            /* command queuing */
  uchar StfRe   : 1;            /* soft reset implemented */
  uchar vendor_id[8];           /* vendor identification */
  uchar product_id[16];         /* product identification */
  uchar product_rev_level[4];   /* product revision level */
} ASC_SCSI_INQUIRY; /* 36 bytes */
#endif /* ADV_BIG_ENDIAN */
/*
 * Request Sense Data Structure
 */
#if !ADV_BIG_ENDIAN
typedef struct adv_req_sense {
  uchar err_code: 7 ;         /* 0  bit 0 to 6, if code 70h or 71h           */
  uchar info_valid: 1 ;       /*    bit 7, info1[] information is valid      */

  uchar segment_no ;          /* 1, segment number                           */

  uchar sense_key: 4 ;        /* 2, bit 3 - 0: sense key                     */
  uchar reserved_bit: 1 ;     /*    bit 4 reserved bit                       */
  uchar sense_ILI: 1 ;        /*    bit 5 EOM( end of medium encountered )   */
  uchar sense_EOM: 1 ;        /*    bit 6 ILI( length error )                */
  uchar file_mark: 1 ;        /*    bit 7 file mark encountered              */

  uchar info1[ 4 ] ;          /* 3-6, information                            */
  uchar add_sense_len ;       /* 7, additional sense length                  */
  uchar cmd_sp_info[ 4 ] ;    /* 8-11, command specific information          */
  uchar asc ;                 /* 12, additional sense code                   */
  uchar ascq ;                /* 13, additional sense code qualifier         */
  /* Minimum request sense length ends here. */

  uchar fruc ;                /* 14, field replaceable unit code             */

  uchar sks_byte0: 7 ;        /* 15,                                         */
  uchar sks_valid : 1 ;       /* 15, SKSV: sense key specific valid          */

  uchar sks_bytes[2] ;        /* 16-17, sense key specific, MSB is SKSV      */
  uchar notused[ 2 ] ;        /* 18-19,                                      */
  uchar ex_sense_code ;       /* 20, extended additional sense code          */
  uchar info2[ 5 ] ;          /* 21-25, additional sense bytes               */
} ASC_REQ_SENSE ;             /* 26 bytes - must be even number of bytes */
#else /* ADV_BIG_ENDIAN */
typedef struct adv_req_sense {
  uchar info_valid: 1 ;       /*    bit 7, info1[] information is valid      */
  uchar err_code: 7 ;         /* 0  bit 0 to 6, if code 70h or 71h           */

  uchar segment_no ;          /* 1, segment number                           */
  uchar file_mark: 1 ;        /*    bit 7 file mark encountered              */
  uchar sense_EOM: 1 ;        /*    bit 6 ILI( length error )                */
  uchar sense_ILI: 1 ;        /*    bit 5 EOM( end of medium encountered )   */
  uchar reserved_bit: 1 ;     /*    bit 4 reserved bit                       */
  uchar sense_key: 4 ;        /* 2, bit 3 - 0: sense key                     */

  uchar info1[ 4 ] ;          /* 3-6, information                            */
  uchar add_sense_len ;       /* 7, additional sense length                  */
  uchar cmd_sp_info[ 4 ] ;    /* 8-11, command specific information          */
  uchar asc ;                 /* 12, additional sense code                   */
  uchar ascq ;                /* 13, additional sense code qualifier         */
  /* Minimum request sense length ends here. */

  uchar fruc ;                /* 14, field replaceable unit code             */

  uchar sks_valid : 1 ;       /* 15, SKSV: sense key specific valid          */
  uchar sks_byte0: 7 ;        /* 15,                                         */

  uchar sks_bytes[2] ;        /* 16-17, sense key specific, MSB is SKSV      */
  uchar notused[ 2 ] ;        /* 18-19,                                      */
  uchar ex_sense_code ;       /* 20, extended additional sense code          */
  uchar info2[ 5 ] ;          /* 21-25, additional sense bytes               */
} ASC_REQ_SENSE ;             /* 26 bytes - must be even number of bytes */
#endif /* ADV_BIG_ENDIAN */

#endif /* #ifndef __A_SCSI_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\buildop.h ===
/*++

Copyright (c) 2000 Agilent Technologies

Module Name:

   buildop.h

Abstract:

Authors:

Environment:

   kernel mode only

Notes:

Version Control Information:

   $Archive: /Drivers/Win2000/MSE/OSLayer/H/buildop.h $


Revision History:

   $Revision: 10 $
   $Date: 3/30/01 11:54a $
   $Modtime:: 3/30/01 11:51a           $

Notes:


--*/

#ifndef __BUILDOP_H_
#define __BUILDOP_H_

#ifndef UNDEF__REGISTERFORSHUTDOWN__
#define __REGISTERFORSHUTDOWN__	
#endif

#ifndef UNDEF_ENABLE_LARGELUN_
#define	 _ENABLE_LARGELUN_		
#endif

#ifdef HP_NT50				          // Compaq Hot Plug support NT4 only
	#undef	HP_PCI_HOT_PLUG		
#else
	#define	HP_PCI_HOT_PLUG		
#endif

#ifndef UNDEF_YAM2_1
#define	YAM2_1
#endif

// #define _DEBUG_READ_REGISTRY_
// #define _DEBUG_EVENTLOG_


#ifndef UNDEF_ENABLE_PSEUDO_DEVICE_
#define _ENABLE_PSEUDO_DEVICE_		     /* reserve Bus 4 TID 0 Lun 0 for IOCTL */
#endif

//#define UNDEF_FCCI_SUPPORT
#ifndef UNDEF_FCCI_SUPPORT
#define _FCCI_SUPPORT				     /* Enable Transoft IOCTL */
#endif


//#define UNDEF_SAN_IOCTL_
#ifndef UNDEF_SAN_IOCTL_
#define	_SAN_IOCTL_					/* Enable Agilent Technologies SNIA Ioctl support */
#endif

/* Add FCLayer switches here */
#ifndef _AGILENT_HBA 
#ifndef _ADAPTEC_HBA 
#define _GENERIC_HBA			/* r35 and up requires this 
								/* or #define _ADAPTEC_HBA
								/* or #define _AGILENT_HBA		
								*/
#endif
#endif


/** DEBUG Options **/

//#define _Partial_Log_Debug_String_	/* enable to print out FCLayer debug messages */

#if DBG > 0
//#define _DEBUG_STALL_ISSUE_             /* Used to debug Stall issue only of I386*/
#endif

#ifdef YAM2_1
#if DBG > 0
#define     DBGPRINT_IO			          // enable to dbgpriunt IOs
#define     _DEBUG_REPORT_LUNS_
#define     _DEBUG_SCSIPORT_NOTIFICATION_		// enable to debug ScsiPortNotification
#endif
#endif

// #define _DEBUG_PERR_				     /* Debug Parity Error Issue */

//#define _DEBUG_LOSE_IOS_				// enable to simulate loosing IOs

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc3550\a_ver.h ===
/*
 * a_ver.h - Adv Library Version and Revision History File
 *
 * Copyright (c) 1997-1998  Advanced System Products, Inc.
 * All Rights Reserved.
 */

/*
 * Adv Library Version Number - Increment the major number for major
 * changes and the minor number for minor changes.
 */
#define ASC_LIB_VERSION_MAJOR  3
#define ASC_LIB_VERSION_MINOR  52
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\adapinit.c ===
/*++

Copyright (c) 2000 Agilent Technologies

Module Name:

    Adapinit.c

Abstract:

    This is the Adapter Initialize entry point for the Agilent
    PCI to Fibre Channel Host Bus Adapter (HBA).

Authors:

    MB - Michael Bessire
    DL - Dennis Lindfors FC Layer support
    IW - Ie Wei Njoo
    LP - Leopold Purwadihardja
    KR - Kanna Rajagopal

Environment:

    kernel mode only

Notes:

Version Control Information:

    $Archive: /Drivers/Win2000/Trunk/OSLayer/C/ADAPINIT.C $


Revision History:

    $Revision: 4 $
    $Date: 10/23/00 5:35p $
    $Modtime:: 10/18/00 6:08p           $

Notes:


--*/


#include "buildop.h"
#include "osflags.h"
#include "TLStruct.H"
#if defined(HP_PCI_HOT_PLUG)
   #include "HotPlug4.h"    // NT 4.0 PCI Hot-Plug header file
#endif

extern ULONG gGlobalIOTimeout;

/*++

Routine Description:

    Initialize HBA.
    HwScsiInitialize
 
    NOTE: Interrupts are available before completion of this routine !
 
Arguments:
 
    pCard - HBA miniport driver's data adapter storage

Return Value:

    TRUE  - if initialization successful.
    FALSE - if initialization unsuccessful.

--*/

BOOLEAN
HPFibreInitialize(
    IN PCARD_EXTENSION pCard
    )
{
    agRoot_t * hpRoot=&pCard->hpRoot;
    ULONG return_value;
    ULONG num_devices=0;
    UCHAR PathId,TargID,Lun,x;
    PLU_EXTENSION plunExtension = NULL;
 
    pCard->State |= CS_DURING_DRV_INIT;
 
    osDEBUGPRINT((ALWAYS_PRINT,"IN HPFibreInitialize %lx @ %x\n", hpRoot, osTimeStamp(0) ));
 
#if DBG > 2
    dump_pCard( pCard);
#endif

    pCard->External_ResetCount=0;
    pCard->Internal_ResetCount=0;
    
    #ifdef _DEBUG_LOSE_IOS_
    pCard->Srb_IO_Count=0;
    pCard->Last_Srb_IO_Count=0;
    #endif

    pCard->Number_interrupts=0;
    
    #ifdef _DEBUG_PERF_DATA_
    pCard->Perf_ptr = &pCard->perf_data[0];
    pCard->usecsPerTick = 1000000;
    #endif
    
    pCard->SingleThreadCount = 0;

    osDEBUGPRINT((ALWAYS_PRINT,"Zero Cache Memory %lx Length %x\n",
        pCard->cachedMemoryPtr, pCard->cachedMemoryNeeded ));

    osZero( pCard->cachedMemoryPtr, pCard->cachedMemoryNeeded );

    osDEBUGPRINT((DMOD,"Zero DMA Memory %lx Length %x\n",
            pCard->dmaMemoryPtr, pCard->dmaMemoryNeeded ));

    osZero( pCard->dmaMemoryPtr, pCard->dmaMemoryNeeded );

    osDEBUGPRINT((ALWAYS_PRINT,"Calling fcInitializeChannel with the following parameters:\n"));
    osDEBUGPRINT((ALWAYS_PRINT,"   cachedMemoryPtr    = %x\n   cachedMemoryNeeded = %x\n",
                               pCard->cachedMemoryPtr,
                               pCard->cachedMemoryNeeded));
    osDEBUGPRINT((ALWAYS_PRINT,"   dmaMemoryUpper32   = %x\n   dmaMemoryLower32   = %x\n",
                               pCard->dmaMemoryUpper32,
                               pCard->dmaMemoryLower32));
    osDEBUGPRINT((ALWAYS_PRINT,"   dmaMemoryPtr       = %x\n   dmaMemoryNeeded    = %x\n",
                               pCard->dmaMemoryPtr,
                               pCard->dmaMemoryNeeded));
    osDEBUGPRINT((ALWAYS_PRINT,"   nvMemoryNeeded     = %x\n   cardRamUpper       = %x\n",
                               pCard->nvMemoryNeeded,
                               pCard->cardRamUpper));
    osDEBUGPRINT((ALWAYS_PRINT,"   cardRamLower       = %x\n   RamLength          = %x\n",
                               pCard->cardRamLower,
                               pCard->RamLength));
    osDEBUGPRINT((ALWAYS_PRINT,"   cardRomUpper       = %x\n   cardRomLower       = %x\n",
                               pCard->cardRomUpper,
                               pCard->cardRomLower));
    osDEBUGPRINT((ALWAYS_PRINT,"   RomLength          = %x\n   usecsPerTick       = %x\n",
                               pCard->RomLength,
                               pCard->usecsPerTick ));
    

    return_value = fcInitializeChannel( hpRoot,
                                       fcSyncInit,
#ifdef OSLayer_Stub
                                       agFALSE, // sysIntsActive
#else
                                       agTRUE, // sysIntsActive
#endif
                                       pCard->cachedMemoryPtr,
                                       pCard->cachedMemoryNeeded,
                                       pCard->dmaMemoryUpper32,
                                       pCard->dmaMemoryLower32,
                                       pCard->dmaMemoryPtr,
                                       pCard->dmaMemoryNeeded,
                                       pCard->nvMemoryNeeded,
                                       pCard->cardRamUpper,
                                       pCard->cardRamLower,
                                       pCard->RamLength ,
                                       pCard->cardRomUpper,
                                       pCard->cardRomLower,
                                       pCard->RomLength,
                                       pCard->usecsPerTick );

    if (return_value != fcInitializeSuccess) 
    {
        osDEBUGPRINT((ALWAYS_PRINT, "HPFibreInitialize: fcInitializeChannel FAILED\n"));
        
        #ifdef _DEBUG_EVENTLOG_
        LogEvent(   pCard, 
                  NULL,
                  HPFC_MSG_INITIALIZECHANNELFAILED,
                  NULL, 
                  0, 
                  "%xx", return_value);
        #endif
        
        pCard->State &= ~CS_DURING_DRV_INIT;
        osLogBit32 (hpRoot, __LINE__);
        return FALSE;
    }

    #ifdef _DEBUG_EVENTLOG_
    {
        LogHBAInformation(pCard);
    }
    #endif
      
    #ifndef YAM2_1
    for(x=0; x < MAX_FC_DEVICES; x++)
    {
    #else
    for(x=0; x < gMaxPaDevices; x++)
    {
    #endif
        pCard->hpFCDev[x]= NULL;
    }

    GetNodeInfo (pCard);

#if DBG > 2
    dump_pCard( pCard);
#endif

    //WIN64 compliant
    #ifndef YAM2_1
    osDEBUGPRINT((ALWAYS_PRINT,"Card Ext %p to %p\n",pCard,
                            (((char*)pCard)+sizeof(CARD_EXTENSION) +
                            pCard->cachedMemoryNeeded +
                            pCard->cachedMemoryAlign)));
    #else
    osDEBUGPRINT((ALWAYS_PRINT,"Card Ext %p to %p\n",pCard,
                            (((char*)pCard)+gDeviceExtensionSize) ));
   
    #endif
    osDEBUGPRINT((ALWAYS_PRINT,"OUT HPFibreInitialize %lx return_value %x\n",hpRoot,  return_value));
    pCard->State &= ~CS_DURING_DRV_INIT;

    // osChipIOUpWriteBit32(hpRoot, ChipIOUp_TachLite_Control, 0x8); // Clear trigger for finsar

    if(pCard->usecsPerTick > 100 )
    {
        HPFibreTimerTick ( pCard );
    }

    //ScsiPortNotification (RequestTimerCall, pCard,
    //                    (PHW_TIMER) HPFibreTimerTick, pCard->usecsPerTick);

#if defined(HP_PCI_HOT_PLUG)

    // Set Hot Plug flag to indicate timer is running.
    pCard->controlFlags |= LCS_HBA_TIMER_ACTIVE;

    // Clear Hot Plug state flag to indicate cache is NOT used.
    pCard->stateFlags &= ~PCS_HBA_CACHE_IN_USE;
   
    // Compute how many iterations should the StartIO() return Busy during 
    // hot plug. The time limit is set to default to 30 seconds.

    pCard->IoHeldRetMaxIter = RET_VAL_MAX_ITER;     // Default, assume 1 second timer.
    if (pCard->usecsPerTick)
    {
        pCard->IoHeldRetMaxIter = (RET_VAL_MAX_ITER * 1000000) / pCard->usecsPerTick;
    }
#endif    

    return TRUE;
} // end HPFibreInitialize()

/*++

Routine Description:

    This routine is a call back from FC layer when we call fcInitializeChannel. 
    NT layer do nothing.

Arguments:

    hpRoot                  - common card structure
    hpInitializeStatus      - status

Return Value:

    void

--*/
osGLOBAL void osInitializeChannelCallback(
                                          agRoot_t *hpRoot,
                                          os_bit32  hpInitializeStatus
                                        )
{
    PCARD_EXTENSION pCard;
    pCard   = (PCARD_EXTENSION)hpRoot->osData;
    osDEBUGPRINT((DLOW,"IN osInitializeChannelCallback %lx status %lx\n",hpRoot,hpInitializeStatus));
}

// extern ULONG  HPDebugFlag;
extern ULONG  Global_Print_Level;

/*++

Routine Description:

    This routine is part of the Qing routine

Arguments:

    pSrbExt        - current Srb extension

Return Value:

    next SrbExt or NULL

--*/
PSRB_EXTENSION  Get_next_Srbext( PSRB_EXTENSION pSrbExt)
{
    if(pSrbExt->pNextSrbExt)
    {
        if(pSrbExt == pSrbExt->pNextSrbExt )
        {
            osDEBUGPRINT((ALWAYS_PRINT,"IN Out standing Q screwed up ! Cur %lx == next %lx\n",pSrbExt, pSrbExt->pNextSrbExt));
        }
    return pSrbExt->pNextSrbExt;
    }
    else
        return NULL;
}

/*++

Routine Description:

    This routine is part of the Qing routine. Debug Purpose only

Arguments:

    pSrbExt        - current Srb extension

Return Value:

    next SrbExt or NULL

--*/
void display_srbext( agIORequest_t *hpIORequest )
{
    PSRB_EXTENSION pSrbExt= hpIORequest->osData;
    PSCSI_REQUEST_BLOCK pSrb;
    agIORequestBody_t * phpReqBody;

    if(IS_VALID_PTR(pSrbExt))
    {
        pSrb = pSrbExt->pSrb;
        if(IS_VALID_PTR(pSrb))
        {
            phpReqBody = &pSrbExt->hpRequestBody;
            osDEBUGPRINT((ALWAYS_PRINT,"phpRoot            %lx\n", pSrbExt->phpRoot        ));
            osDEBUGPRINT((ALWAYS_PRINT,"pCard              %lx\n", pSrbExt->pCard          ));
            osDEBUGPRINT((ALWAYS_PRINT,"AbortSrb           %lx\n", pSrbExt->AbortSrb       ));
            osDEBUGPRINT((ALWAYS_PRINT,"pSrb               %lx\n", pSrbExt->pSrb           ));
            osDEBUGPRINT((ALWAYS_PRINT,"CDB  %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                pSrb->Cdb[0],pSrb->Cdb[1],pSrb->Cdb[2],pSrb->Cdb[3],pSrb->Cdb[4],
                pSrb->Cdb[5],pSrb->Cdb[6],pSrb->Cdb[7],pSrb->Cdb[8],pSrb->Cdb[9] ));
            osDEBUGPRINT((ALWAYS_PRINT,"pNextSrb           %lx\n", pSrbExt->pNextSrb       ));
            osDEBUGPRINT((ALWAYS_PRINT,"SglVirtAddr        %lx\n", pSrbExt->SglVirtAddr    ));
            osDEBUGPRINT((ALWAYS_PRINT,"SglDataLen         %8x\n", pSrbExt->SglDataLen     ));
            osDEBUGPRINT((ALWAYS_PRINT,"SglElements         %x\n", pSrbExt->SglElements    ));
            osDEBUGPRINT((ALWAYS_PRINT,"SRB_State          %08x\n", pSrbExt->SRB_State     ));
            osDEBUGPRINT((ALWAYS_PRINT,"SRB_StartTime      %08x\n", pSrbExt->SRB_StartTime ));
            #ifdef _DEBUG_LOSE_IOS_
            osDEBUGPRINT((ALWAYS_PRINT,"SRB_SRB_IO_COUNT   %8x\n",pSrbExt->SRB_IO_COUNT  ));
            #endif
            osDEBUGPRINT((ALWAYS_PRINT,"pLunExt            %lx\n", pSrbExt->pLunExt        ));
            osDEBUGPRINT((ALWAYS_PRINT,"hpIORequest        %lx\n", &pSrbExt->hpIORequest   ));
            osDEBUGPRINT((ALWAYS_PRINT,"FcpCntl %02x %02x %02x %02x\n",
                phpReqBody->CDBRequest.FcpCmnd.FcpCntl[0],phpReqBody->CDBRequest.FcpCmnd.FcpCntl[1],
                phpReqBody->CDBRequest.FcpCmnd.FcpCntl[2],phpReqBody->CDBRequest.FcpCmnd.FcpCntl[3] ));

            osDEBUGPRINT((ALWAYS_PRINT,"hpRequestBody      %lx\n", &pSrbExt->hpRequestBody ));
        }
        else
            osDEBUGPRINT((ALWAYS_PRINT,"Bad SRB     %lx\n",pSrbExt->pSrb ));
    }
    else
        osDEBUGPRINT((ALWAYS_PRINT,"Bad SRBext  %lx hpIORequest %lx\n",pSrbExt,hpIORequest ));
}

/*++

Routine Description:

    *** HwScsiTimer entry point for the OS layer. ***
    NT kernel mode drivers design guide specifies that
    ScsiPortNotification synchronizes calls to the HwScsiTimer
    routine with those to the HwScsiInterrupt routine so that
    it can not execute concurrently while the HwScsiTimer
    routine is running. But it does not specify any thing
    about port driver synchronizing calls to other miniport
    driver entry points like HwScsiStartIo with the HwScsiTimer
    routine.
    Excluding the initialization specific entry points and the interrupt
    specific entry points the only entry points that we use are
    HwScsiStartIo and HwScsiResetBus. In order to synchronize calls
    to HwScsiTimer with these routines we make use of
    pCard->inDriver and pCard->inTimer variables.

Arguments:

    pCard          - Device Extension specifying a specific card instance
   
Return Value:

    none

--*/
void
HPFibreTimerTick (
    IN PCARD_EXTENSION pCard
    )
{
    agRoot_t *hpRoot = &pCard->hpRoot;

    pCard->inTimer = TRUE;

    // Sequencialize entry
    if (pCard->inDriver == TRUE) 
    {
        ScsiPortNotification (RequestTimerCall, pCard,
                          (PHW_TIMER) HPFibreTimerTick, pCard->usecsPerTick);
        pCard->inTimer = FALSE;
        return;
    }

//----------------------------------------------------------------------------
#if defined(HP_PCI_HOT_PLUG)
    //
    // If there is any PCI Hot Plug related task need to be done, do it here
    // and skip normal timer task.
    //
    if ( HotPlugTimer(pCard) == TRUE)
    {
        ScsiPortNotification (RequestTimerCall, pCard,
                          (PHW_TIMER) HPFibreTimerTick, pCard->usecsPerTick);
        pCard->inTimer = FALSE;
        return;
    }

#endif
//----------------------------------------------------------------------------

    // notify FClayer
    fcTimerTick (hpRoot);

    // process our own reset command
    if (pCard->flags & OS_DO_SOFT_RESET) 
    {
        pCard->LostDevTickCount--;
        if (pCard->LostDevTickCount == 0) 
        {
            pCard->flags &= ~OS_DO_SOFT_RESET;
            pCard->OldNumDevices = 0;
            osDEBUGPRINT((ALWAYS_PRINT, ".............................................\n"));
            osDEBUGPRINT((ALWAYS_PRINT, "HPFibreTimerTick: Resetting channel\n"));

            fcResetChannel (hpRoot, fcSyncReset);

            if (pCard->LinkState != LS_LINK_UP) 
            {
                GetNodeInfo (pCard);
                if (pCard->Num_Devices != 0) 
                {
                    FixDevHandlesForLinkUp (pCard);
                    pCard->LinkState = LS_LINK_UP;
                } 
                else
                    pCard->LinkState = LS_LINK_DOWN;
                ScsiPortNotification (NextRequest, pCard, NULL, NULL, NULL);
            }
        }
    }

    // move all IOs from RetryQ to AdapterQ
    RetryQToAdapterQ (pCard);

    // if Link is UP, rethread all pending IOs
    if (pCard->LinkState == LS_LINK_UP && pCard->AdapterQ.Head)
        Startio (pCard);

    // if link is DOWN, retries any Inquiry commands by reporting ResetDetected so that 
    // we don't get ID 9 events during ScsiPort scanning phase
    if (pCard->LinkState == LS_LINK_DOWN) 
    {
        pCard->TicksSinceLinkDown++;
        /* Issue a resetdetected, so that the port driver
        * re-issues all its IOs, and there will be no timeouts
        */
        if((pCard->SrbStatusFlag) && (pCard->TicksSinceLinkDown <= gGlobalIOTimeout))
        {
            ScsiPortNotification (ResetDetected, pCard, NULL);
        }
        
        if (pCard->TicksSinceLinkDown >= TICKS_FOR_LINK_DEAD) 
        {
            pCard->LinkState = LS_LINK_DEAD;
            pCard->TicksSinceLinkDown = 0;
        }
    } 
    else
        pCard->TicksSinceLinkDown = 0;

    // Restart Timer
    ScsiPortNotification (RequestTimerCall, pCard,
                          (PHW_TIMER) HPFibreTimerTick, pCard->usecsPerTick);

    pCard->inTimer = FALSE;
}

/*++

Routine Description:

   This routine filled up the FC device array and Node Info.

Arguments:

   pCard        - card instance

Return Value:

   none

--*/
void
GetNodeInfo (PCARD_EXTENSION pCard)
{
    agRoot_t       *hpRoot = &pCard->hpRoot;
    agFCDevInfo_t  devinfo;
    ULONG          x;

    // clear existing array
    ClearDevHandleArray (pCard);

    // call FC layer to get all the FC handles
    #ifndef YAM2_1
    pCard->Num_Devices = fcGetDeviceHandles (hpRoot, &pCard->hpFCDev[0], MAX_FC_DEVICES);
    #else
    pCard->Num_Devices = fcGetDeviceHandles (hpRoot, &pCard->hpFCDev[0], gMaxPaDevices);
    #endif

    osDEBUGPRINT((ALWAYS_PRINT,"GetNodeInfo: fcGetDeviceHandles returned %d\n", pCard->Num_Devices));
    pCard->Num_Devices = 0;

    // fill the Device Info array
    #ifndef YAM2_1
    for (x=0; x < MAX_FC_DEVICES; x++) 
    {
    #else
    for (x=0; x < gMaxPaDevices; x++) 
    {
    #endif
        if (pCard->hpFCDev[x]) 
        {
            fcGetDeviceInfo (hpRoot, pCard->hpFCDev[x], &devinfo );

            pCard->nodeInfo[x].DeviceType = devinfo.DeviceType;

            if (devinfo.DeviceType & agDevSelf) 
            {
                pCard->cardHandleIndex = x;
            }

            // count the number of 'scsi' devices
            if (devinfo.DeviceType & agDevSCSITarget)
                pCard->Num_Devices++;

            osDEBUGPRINT((ALWAYS_PRINT,"GetNodeInfo: Slot = %d handle = 0x%lx\n", x, pCard->hpFCDev[x]));
            osDEBUGPRINT((ALWAYS_PRINT,"GetNodeInfo: WWN 0x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                                 devinfo.NodeWWN[0],devinfo.NodeWWN[1],
                                 devinfo.NodeWWN[2],devinfo.NodeWWN[3],
                                 devinfo.NodeWWN[4],devinfo.NodeWWN[5],
                                 devinfo.NodeWWN[6],devinfo.NodeWWN[7] ));
            osDEBUGPRINT((ALWAYS_PRINT,"GetNodeInfo: PortWWN 0x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                                 devinfo.PortWWN[0],devinfo.PortWWN[1],
                                 devinfo.PortWWN[2],devinfo.PortWWN[3],
                                 devinfo.PortWWN[4],devinfo.PortWWN[5],
                                 devinfo.PortWWN[6],devinfo.PortWWN[7] ));
            osDEBUGPRINT((ALWAYS_PRINT,"GetNodeInfo: Alpa = 0x%02x\n",devinfo.CurrentAddress.AL_PA));
            
            #ifndef YAM2_1          
            #ifdef _DEBUG_EVENTLOG_
            if (!pCard->Old_hpFCDev[x]) 
            {
                LogEvent(pCard, NULL, HPFC_MSG_FOUND_DEVICE, NULL, 0,
                     "%02x%02x%02x%02x %02x%02x%02x%02x",
                     devinfo.NodeWWN[0],devinfo.NodeWWN[1],
                     devinfo.NodeWWN[2],devinfo.NodeWWN[3],
                     devinfo.NodeWWN[4],devinfo.NodeWWN[5],
                     devinfo.NodeWWN[6],devinfo.NodeWWN[7] );
            }
            #endif
            #endif               

        } 
        else 
        {
            pCard->nodeInfo[x].DeviceType = agDevUnknown;
        }
    }

    #ifndef YAM2_1
    #ifdef _DEBUG_EVENTLOG_
    for (x=0; x < MAX_FC_DEVICES; x++) 
        pCard->Old_hpFCDev[x] = pCard->hpFCDev[x];
    #endif
    #endif
    osDEBUGPRINT((ALWAYS_PRINT,"GetNodeInfo: Number of SCSI target ports = %d\n", pCard->Num_Devices));
    
    // update YAM Peripheral mode (PA) device table
    #ifdef YAM2_1
    FillPaDeviceTable(pCard);
    #endif            
}

/*++

Routine Description:

    Move all pending IOs in the retryQ to the adapterQ. 
    Note: Any retries MUST not be added to the AdapterQ directly. It must be added to the RetryQ and 
    processed by this routine (for synch purpose).
   
Arguments:

    pCard        - card instance

Return Value:

    none

--*/
void
RetryQToAdapterQ (PCARD_EXTENSION pCard)
{
    PSCSI_REQUEST_BLOCK pSrb;

    while ((pSrb = SrbDequeueHead (&pCard->RetryQ)) != NULL)
      SrbEnqueueTail (&pCard->AdapterQ, pSrb);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\advansys\asc3550\d_os_dep.h ===
/*
 * AdvanSys 3550 Windows NT SCSI Miniport Driver - d_os_dep.h
 *
 * Copyright (c) 1994-1997  Advanced System Products, Inc.
 * All Rights Reserved.
 */

#ifndef _D_OS_DEP_H
#define _D_OS_DEP_H

#define ADV_OS_WINNT

/*
 * Include driver required files.
 */
/* Windows NT Include Files */
#include "miniport.h"
#include "scsi.h"

/*
 * Define Adv Library compile-time options. Refer to a_advlib.h for
 * more information about Adv Library compile-time options.
 */

#define ADV_GETSGLIST           1     /* Use AscGetSGList() */
#define ADV_NEW_BOARD           1     /* Use new Condor board */
#define ADV_PCI_MEMORY          1     /* Use registers mapped to PCI memory */
#define ADV_DISP_INQUIRY        0     /* Don't use AscDispInquiry() */
#define ADV_INITSCSITARGET      0     /* Don't use AdvInitScsiTarget() */
#define ADV_RETRY               0     /* Don't let Adv Library do retries */
#define ADV_SCAM                0     /* Don't use AscScam() */
#define ADV_CRITICAL            0     /* Don't have critical sections. */
#define ADV_UCODEDEFAULT        1     /* Use default microcode variables. */
#define ADV_BIG_ENDIAN          0     /* Use Little Endian ordering. */


/*
 * Define Adv Library required general types.
 */
typedef unsigned char   uchar;
typedef unsigned short  ushort;
typedef unsigned int    uint;
typedef unsigned long   ulong;

/*
 * Define Adv Library required special types.
 */
#if ADV_PCI_MEMORY
#define PortAddr  unsigned long         /* virtual memory address size */
#else /* ADV_PCI_MEMORY */
#define PortAddr  unsigned short        /* port address size */
#endif /* ADV_PCI_MEMORY */
#define Ptr2Func  ulong                 /* size of a function pointer */
#define dosfar
#define WinBiosFar

/*
 * Define Adv Library required I/O port macros.
 */
#define inp(addr) \
    ScsiPortReadPortUchar((uchar *) (addr))
#define inpw(addr) \
    ScsiPortReadPortUshort((ushort *) (addr))
#define outp(addr, byte) \
    ScsiPortWritePortUchar((uchar *) (addr) , (uchar) (byte))
#define outpw(addr, word) \
    ScsiPortWritePortUshort((ushort *) (addr), (ushort) (word))

#if ADV_PCI_MEMORY
/*
 * Define Adv Library required memory access macros.
 */
#define ADV_MEM_READB(addr) \
    ScsiPortReadRegisterUchar((uchar *) (addr))
#define ADV_MEM_READW(addr) \
    ScsiPortReadRegisterUshort((ushort *) (addr))
#define ADV_MEM_WRITEB(addr, byte) \
    ScsiPortWriteRegisterUchar((uchar *) (addr) , (uchar) (byte))
#define ADV_MEM_WRITEW(addr, word) \
    ScsiPortWriteRegisterUshort((ushort *) (addr), (ushort) (word))
#endif /* ADV_PCI_MEMORY */

/*
 * Define Adv Library required scatter-gather limit definition.
 *
 * The driver returns NumberOfPhysicalBreaks to Windows NT which is 1
 * less then the maximum scatter-gather count. But Windows NT incorrectly
 * set MaximumPhysicalPages, the parameter class drivers use, to the value
 * of NumberOfPhsysicalBreaks.
 *
 * For Windows NT set ADV_MAX_SG_LIST to 64 for 256 KB requests (64 * 4KB).
 * This value shouldn't be set too high otherwise under heavy load NT will
 * be unable to allocate non-paged memory and blue-screen.
 *
 * WINNT_SGADD is added to insure the driver won't be broken if Microsoft
 * decides to fix NT in the future and set MaximumPhysicalPages to
 * NumberOfPhsyicalBreaks + 1. The driver sets the limit 1 higher than
 * it has to be to support a certain number of scatter-gather elements.
 * If NT is ever changed to use 1 more, the driver will have already
 * reserved space for it.
 */
#define WINNT_SGADD           1

#define ADV_MAX_SG_LIST         (64 + WINNT_SGADD)

#define ADV_ASSERT(a) \
    { \
        if (!(a)) { \
            DebugPrint((1, "ADv_ASSERT() Failure: file %s, line %d\n", \
                __FILE__, __LINE__)); \
        } \
    }

#endif /* _D_OS_DEP_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\cdbsetup.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/CDBSetup.C $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 9/20/00 5:02p   $ (Last Modified)

Purpose:

  This file implements CDB Support Functions for the FC Layer.

--*/

#ifndef _New_Header_file_Layout_

#include "../h/globals.h"
#include "../h/state.h"
#include "../h/memmap.h"
#include "../h/tlstruct.h"
#include "../h/fcmain.h"
#include "../h/cdbsetup.h"

#else /* _New_Header_file_Layout_ */

#include "globals.h"
#include "state.h"
#include "memmap.h"
#include "tlstruct.h"
#include "fcmain.h"
#include "cdbsetup.h"

#endif  /* _New_Header_file_Layout_ */

/*+
  Function: fiFillInFCP_CMND

   Purpose: Generic inCardRam or inDmaMemory version to fill in FCP command payload
 Called By: none
     Calls: fiFillInFCP_CMND_OnCard 
            fiFillInFCP_CMND_OffCard
-*/
void fiFillInFCP_CMND(
                       CDBThread_t *CDBThread
                     )
{
    if (CThread_ptr(CDBThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.FCP_CMND.memLoc == inCardRam)
    {
        fiFillInFCP_CMND_OnCard(
                                 CDBThread
                               );
    }
    else /* CThread_ptr(CDBThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.FCP_CMND.memLoc == inDmaMemory */
    {
        fiFillInFCP_CMND_OffCard(
                                  CDBThread
                                );
    }
}

/*+
  Function: fiFillInFCP_CMND_OnCard

   Purpose: inCardRam  version to fill in FCP command payload, copies 
            from precalculated image of FCP header.
 Called By: CThread->FuncPtrs.fiFillInFCP_CMND
     Calls: osCardRamWriteBlock
            osCardRamWriteBit32
-*/
void fiFillInFCP_CMND_OnCard(
                              CDBThread_t *CDBThread
                            )
{
#ifndef __MemMap_Force_Off_Card__
    agRoot_t    *hpRoot          = CDBThread->thread_hdr.hpRoot;
    DevThread_t *DevThread       = CDBThread->Device;
    X_ID_t       Masked_OX_ID;
    os_bit32     FCP_CMND_Offset = CDBThread->FCP_CMND_Offset;

    if (CDBThread->ReadWrite == CDBThread_Read)
    {
        Masked_OX_ID = (X_ID_t)(CDBThread->X_ID | X_ID_Read);
    }
    else /* CDBThread->ReadWrite == CDBThread_Write */
    {
        Masked_OX_ID = (X_ID_t)(CDBThread->X_ID | X_ID_Write);
    }

    osCardRamWriteBlock(
                         hpRoot,
                         FCP_CMND_Offset,
                         (os_bit8 *)&(DevThread->Template_FCHS),
                         sizeof(FCHS_t)
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FCP_CMND_Offset + hpFieldOffset(
                                                          FCHS_t,
                                                          OX_ID__RX_ID
                                                        ),
                         (  (Masked_OX_ID << FCHS_OX_ID_SHIFT)
                          | (0xFFFF << FCHS_RX_ID_SHIFT)      )
                       );

    osCardRamWriteBlock(
                         hpRoot,
                         FCP_CMND_Offset + sizeof(FCHS_t),
                         (os_bit8 *)&(CDBThread->CDBRequest->FcpCmnd),
                         sizeof(agFcpCmnd_t)
                       );

#ifndef Performance_Debug
    fiLogDebugString(hpRoot,
                    CStateLogConsoleShowSEST,
                    "FCP_CMND_Offset %08X",
                    (char *)agNULL,(char *)agNULL,
                    agNULL, agNULL,
                    FCP_CMND_Offset,
                    0,0,0,0,0,0,0);

    fiLogDebugString(hpRoot,
                    CStateLogConsoleShowSEST,
                    "FCP_CMND_Offset DWORD 0 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                    (char *)agNULL,(char *)agNULL,
                    agNULL, agNULL,
                    osCardRamReadBit32(hpRoot,FCP_CMND_Offset + 0),
                    osCardRamReadBit32(hpRoot,FCP_CMND_Offset + 4),
                    osCardRamReadBit32(hpRoot,FCP_CMND_Offset + 8),
                    osCardRamReadBit32(hpRoot,FCP_CMND_Offset + 12),
                    osCardRamReadBit32(hpRoot,FCP_CMND_Offset + 16),
                    osCardRamReadBit32(hpRoot,FCP_CMND_Offset + 20),
                    osCardRamReadBit32(hpRoot,FCP_CMND_Offset + 24),
                    osCardRamReadBit32(hpRoot,FCP_CMND_Offset + 28));

#endif /* Performance_Debug */

#endif /* __MemMap_Force_Off_Card__ was not defined */
}

/*+
  Function: fiFillInFCP_CMND_OffCard

   Purpose: inDmaMemory  version to fill in FCP command payload, copies 
            from precalculated image of FCP header.
 Called By: CThread->FuncPtrs.fiFillInFCP_CMND
     Calls: none
-*/
void fiFillInFCP_CMND_OffCard(
                               CDBThread_t *CDBThread
                             )
{
#ifndef __MemMap_Force_On_Card__
    DevThread_t * DevThread    = CDBThread->Device;
    X_ID_t        Masked_OX_ID;
    FCHS_t      * FCHS         = CDBThread->FCP_CMND_Ptr;
#ifndef Performance_Debug
    agRoot_t    *hpRoot        = CDBThread->thread_hdr.hpRoot;
    os_bit32    *FCHSbit_32    = (os_bit32 * )FCHS;
#endif /* Performance_Debug */
    agFcpCmnd_t * hpFcpCmnd    = (agFcpCmnd_t *)((os_bit8 *)FCHS + sizeof(FCHS_t));
    if (CDBThread->ReadWrite == CDBThread_Read)
    {
        Masked_OX_ID = (X_ID_t)(CDBThread->X_ID | X_ID_Read);
    }
    else /* CDBThread->ReadWrite == CDBThread_Write */
    {
        Masked_OX_ID = (X_ID_t)(CDBThread->X_ID | X_ID_Write);
    }

    *FCHS              = DevThread->Template_FCHS;

    FCHS->OX_ID__RX_ID =   (Masked_OX_ID << FCHS_OX_ID_SHIFT)
                         | (0xFFFF << FCHS_RX_ID_SHIFT);

    *hpFcpCmnd         = CDBThread->CDBRequest->FcpCmnd;

#ifndef Performance_Debug
    fiLogDebugString(hpRoot,
                    CStateLogConsoleShowSEST,
                    "FCP_CMND_ptr %p",
                    (char *)agNULL,(char *)agNULL,
                    FCHSbit_32, agNULL,
                    0,0,0,0,0,0,0,0);
 
    fiLogDebugString(hpRoot,
                    CStateLogConsoleShowSEST,
                    "FCP_CMND_ptr DWORD 0 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                    (char *)agNULL,(char *)agNULL,
                    agNULL, agNULL,
                    * (FCHSbit_32 + 0),
                    * (FCHSbit_32 + 4),
                    * (FCHSbit_32 + 8),
                    * (FCHSbit_32 + 12),
                    * (FCHSbit_32 + 16),
                    * (FCHSbit_32 + 20),
                    * (FCHSbit_32 + 24),
                    * (FCHSbit_32 + 28));

#endif /* Performance_Debug */

#endif /* __MemMap_Force_On_Card__ was not defined */
}

/*+
   Function: fiFillInFCP_RESP

    Purpose: Generic inCardRam or inDmaMemory version to zero FCP response buffer
  Called By: none
      Calls: fiFillInFCP_RESP_OnCard 
             fiFillInFCP_RESP_OffCard
-*/
void fiFillInFCP_RESP(
                       CDBThread_t *CDBThread
                     )
{
    if (CThread_ptr(CDBThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.FCP_RESP.memLoc == inCardRam)
    {
        fiFillInFCP_RESP_OnCard(
                                 CDBThread
                               );
    }
    else /* CThread_ptr(CDBThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.FCP_RESP.memLoc == inDmaMemory */
    {
        fiFillInFCP_RESP_OffCard(
                                  CDBThread
                                );
    }
}

/*+
  Function: fiFillInFCP_RESP_OnCard

   Purpose: inCardRam version to zero FCP response buffer,
 Called By: CThread->FuncPtrs.fiFillInFCP_RESP
     Calls: osCardRamWriteBit32
-*/
void fiFillInFCP_RESP_OnCard(
                              CDBThread_t *CDBThread
                            )
{
#ifndef __MemMap_Force_Off_Card__
    agRoot_t *hpRoot                  = CDBThread->thread_hdr.hpRoot;
    os_bit32     FCP_RESP_Payload_Offset = CDBThread->FCP_RESP_Offset + sizeof(FC_Frame_Header_t);

    osCardRamWriteBit32(
                         hpRoot,
                         FCP_RESP_Payload_Offset + hpFieldOffset(
                                                                  FC_FCP_RSP_Payload_t,
                                                                  FCP_STATUS
                                                                ),
                         0
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FCP_RESP_Payload_Offset + hpFieldOffset(
                                                                  FC_FCP_RSP_Payload_t,
                                                                  FCP_RESID
                                                                ),
                         0
                       );
    
    osCardRamWriteBit32(
                         hpRoot,
                         FCP_RESP_Payload_Offset + hpFieldOffset(
                                                                  FC_FCP_RSP_Payload_t,
                                                                  FCP_SNS_LEN
                                                                ),
                         0
                       );

#endif /* __MemMap_Force_Off_Card__ was not defined */
}

/*+
  Function: fiFillInFCP_RESP_OffCard

   Purpose: inDmaMemory version to zero FCP response buffer,
 Called By: CThread->FuncPtrs.fiFillInFCP_RESP
     Calls: none
-*/
void fiFillInFCP_RESP_OffCard(
                               CDBThread_t *CDBThread
                             )
{
#ifndef __MemMap_Force_On_Card__
    FC_FCP_RSP_Payload_t *FCP_RESP_Payload = (FC_FCP_RSP_Payload_t *)((os_bit8 *)CDBThread->FCP_RESP_Ptr + sizeof(FC_Frame_Header_t));

    *(os_bit32 *)(&(FCP_RESP_Payload->FCP_STATUS)) = 0;
    FCP_RESP_Payload->FCP_RESID                 = 0;
    FCP_RESP_Payload->FCP_SNS_LEN               = 0;
#endif /* __MemMap_Force_On_Card__ was not defined */
}

/*+
  Function: fiFillInFCP_SEST

   Purpose: Generic inCardRam or inDmaMemory version to fill in SEST entry for FCP commands
 Called By: none
     Calls: fiFillInFCP_SEST_OnCard 
            fiFillInFCP_SEST_OffCard
-*/
void fiFillInFCP_SEST(
                       CDBThread_t *CDBThread
                     )
{
    if (CThread_ptr(CDBThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SEST.memLoc == inCardRam)
    {
        fiFillInFCP_SEST_OnCard(
                                 CDBThread
                               );
    }
    else /* CThread_ptr(CDBThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SEST.memLoc == inDmaMemory */
    {
        fiFillInFCP_SEST_OffCard(
                                  CDBThread
                                );
    }
}

/*+
  Function: fiFillInFCP_SEST_OnCard

   Purpose: inCardRam version to fill in SEST entry for FCP commands, copies 
            from precalculated image of SEST entry.
 Called By: CThread->FuncPtrs.fiFillInFCP_SEST
     Calls: osCardRamWriteBlock
            osCardRamWriteBit32
-*/
void fiFillInFCP_SEST_OnCard(
                              CDBThread_t *CDBThread
                            )
{
#ifndef __MemMap_Force_Off_Card__
    agRoot_t    *hpRoot      = CDBThread->thread_hdr.hpRoot;
     DevThread_t *DevThread   = CDBThread->Device;
    os_bit32        SEST_Offset = CDBThread->SEST_Offset;

    if (CDBThread->ReadWrite == CDBThread_Read)
    {
        osCardRamWriteBlock(
                             hpRoot,
                             SEST_Offset,
                             (os_bit8 *)&(DevThread->Template_SEST_IRE), /* NW BUG */
                             sizeof(IRE_t)
                           );

        osCardRamWriteBit32(
                             hpRoot,
                             SEST_Offset + hpFieldOffset(
                                                          SEST_t,
                                                          IRE.RSP_Addr
                                                        ),
                             CDBThread->FCP_RESP_Lower32
                           );

        osCardRamWriteBit32(
                             hpRoot,
                             SEST_Offset + hpFieldOffset(
                                                          SEST_t,
                                                          IRE.Exp_Byte_Cnt
                                                        ),
                             CDBThread->DataLength
                           );
    }
    else /* CDBThread->ReadWrite == CDBThread_Write */
    {
        osCardRamWriteBlock(
                             hpRoot,
                             SEST_Offset,
                             (os_bit8 *)&(DevThread->Template_SEST_IWE),/* NW BUG */
                             sizeof(IWE_t)
                           );

        osCardRamWriteBit32(
                             hpRoot,
                             SEST_Offset + hpFieldOffset(
                                                          SEST_t,
                                                          IWE.Hdr_Addr
                                                        ),
                             CDBThread->FCP_CMND_Lower32
                           );

        osCardRamWriteBit32(
                             hpRoot,
                             SEST_Offset + hpFieldOffset(
                                                          SEST_t,
                                                          IWE.RSP_Addr
                                                        ),
                             CDBThread->FCP_RESP_Lower32
                           );

        osCardRamWriteBit32(
                             hpRoot,
                             SEST_Offset + hpFieldOffset(
                                                          SEST_t,
                                                          IWE.Data_Len
                                                        ),
                             CDBThread->DataLength
                           );

        osCardRamWriteBit32(
                             hpRoot,
                             SEST_Offset + hpFieldOffset(
                                                          SEST_t,
                                                          IWE.Exp_Byte_Cnt
                                                        ),
                             CDBThread->DataLength
                           );
    }
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

/*+
  Function: fiFillInFCP_SEST_OffCard

   Purpose: inDmaMemory version to fill in SEST entry for FCP commands, copies 
            from precalculated image of SEST entry.
 Called By: CThread->FuncPtrs.fiFillInFCP_SEST
     Calls: none
-*/
void fiFillInFCP_SEST_OffCard(
                               CDBThread_t *CDBThread
                             )
{
#ifndef __MemMap_Force_On_Card__
    DevThread_t *DevThread = CDBThread->Device;
    SEST_t      *SEST      = CDBThread->SEST_Ptr;

    if (CDBThread->ReadWrite == CDBThread_Read)
    {
        *((IRE_t *)SEST)       = DevThread->Template_SEST_IRE;
        SEST->IRE.RSP_Addr     = CDBThread->FCP_RESP_Lower32;
        SEST->IRE.Exp_Byte_Cnt = CDBThread->DataLength;
    }
    else /* CDBThread->ReadWrite == CDBThread_Write */
    {
        *((IWE_t *)SEST)       = DevThread->Template_SEST_IWE;
        SEST->IWE.Hdr_Addr     = CDBThread->FCP_CMND_Lower32;
        SEST->IWE.RSP_Addr     = CDBThread->FCP_RESP_Lower32;
        SEST->IWE.Data_Len     = CDBThread->DataLength;
        SEST->IWE.Exp_Byte_Cnt = CDBThread->DataLength;
    }
#endif /* __MemMap_Force_On_Card__ was not defined */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\cdbsetup.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/CDBSetup.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 7/20/00 2:33p   $ (Last Modified)

Purpose:

  This file defines the macros, types, and data structures used by ../C/CDBSetup.C

--*/

#ifndef __CDBSetup_H__
#define __CDBSetup_H__

osGLOBAL void fiFillInFCP_CMND(
                              CDBThread_t *CDBThread
                            );

osGLOBAL void fiFillInFCP_CMND_OnCard(
                                     CDBThread_t *CDBThread
                                   );

osGLOBAL void fiFillInFCP_CMND_OffCard(
                                      CDBThread_t *CDBThread
                                    );

osGLOBAL void fiFillInFCP_RESP(
                              CDBThread_t *CDBThread
                            );

osGLOBAL void fiFillInFCP_RESP_OnCard(
                                     CDBThread_t *CDBThread
                                   );

osGLOBAL void fiFillInFCP_RESP_OffCard(
                                      CDBThread_t *CDBThread
                                    );

osGLOBAL void fiFillInFCP_SEST(
                              CDBThread_t *CDBThread
                            );

osGLOBAL void fiFillInFCP_SEST_OnCard(
                                     CDBThread_t *CDBThread
                                   );

osGLOBAL void fiFillInFCP_SEST_OffCard(
                                      CDBThread_t *CDBThread
                                    );

#endif /* __CDBSetup_H__ was not defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\cdbstate.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/CDBSTATE.C $

  $Revision:: 3               $
      $Date:: 7/13/01 4:44p   $
   $Modtime:: 7/13/01 4:43p   $

Purpose:

  This file implements the FC Layer State Machine.

--*/

#ifndef _New_Header_file_Layout_

#include "../h/globals.h"
#include "../h/state.h"
#include "../h/tlstruct.h"
#include "../h/memmap.h"
#include "../h/fcmain.h"
#include "../h/cdbstate.h"
#include "../h/devstate.h"
#include "../h/cdbsetup.h"
#include "../h/queue.h"
#include "../h/cstate.h"
#include "../h/sfstate.h"
#include "../h/timersvc.h"
#include "../h/cfunc.h"
#else /* _New_Header_file_Layout_ */
#include "globals.h"
#include "state.h"
#include "tlstruct.h"
#include "memmap.h"
#include "fcmain.h"
#include "cdbstate.h"
#include "devstate.h"
#include "cdbsetup.h"
#include "queue.h"
#include "cstate.h"
#include "sfstate.h"
#include "timersvc.h"
#include "cfunc.h"
#endif  /* _New_Header_file_Layout_ */


stateTransitionMatrix_t CDBStateTransitionMatrix = {
    /* Event/State 0        State 1          State 2...             */
    CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
      CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
        CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
          CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
            CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
              CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
                CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
                  CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
                    CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
                      CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
                        CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
                          CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
                            CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
    CDBStateThreadFree,
      CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
        CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
          CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
            CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
              CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
                CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventInitialize 1                      */
    CDBStateInitialize,CDBStateInitialize,0,0,0,
      0,CDBStateReSend_IO,0,0,0,
        0,CDBStateInitialize,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,CDBStateInitialize,0,
                0,CDBStatePending_Abort,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,CDBStateInitialize,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventLocalSGL 2                                                      */
    0,0,CDBStateFillLocalSGL,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventNeedESGL 3                                                      */
    0,0,CDBStateAllocESGL,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventGotESGL 4                                                      */
    0,0,0,0,CDBStateFillESGL, 
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                CDBStateAllocESGL_Abort,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventESGLSendIo 5                                                      */
    0,0,0,0,0, CDBStateSendIo,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventLocalSGLSendIo 6                                                      */
    0,0,0,CDBStateSendIo,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventIoSuccess 7                                                      */
    0,CDBStateInitialize_DR,0,0,0,
      0,CDBStateFcpCompleteSuccess,0,0,0,
        0,0,0,0,0,
          CDBStateFcpCompleteSuccess,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                CDBStatePending_Abort,CDBStatePending_Abort,CDBStatePending_Abort,CDBStateFcpCompleteAbort,0,
                  CDBEvent_CCC_IO_Success,0,0,CDBStateFcpCompleteSuccess,CDBStateFcpCompleteSuccess,
                    CDBStateFcpCompleteSuccess,CDBStateFcpCompleteSuccess,CDBStateFcpCompleteSuccess,CDBStateFcpCompleteSuccess,CDBStateFcpCompleteSuccess,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventIoFailed 8                                                      */
    0,CDBStateInitialize_DR,0,0,0,
      0,CDBStateFcpCompleteFail,0,0,0,
        0,0,0,0,0,
          CDBStateFcpCompleteFail,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                CDBStatePending_Abort,CDBStatePending_Abort,CDBStatePending_Abort,0,0,
                  CDBState_CCC_IO_Fail,0,0,0,CDBStateFcpCompleteFail,
                    CDBStateFcpCompleteFail,CDBStateFcpCompleteFail,CDBStateFcpCompleteFail,CDBStateFcpCompleteFail,CDBStateFcpCompleteFail,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventIoAbort 9                                                      */
    0,CDBStateInitialize_DR,CDBStateInitialize_Abort,CDBStateFillLocalSGL_Abort,CDBStateAllocESGL_Abort,
      CDBStateFillESGL_Abort,CDBStateFcpCompleteAbort,0,0,0,
        0,0,0,CDBStateOOOReceived_Abort,CDBStateOOOFixup_Abort,
          CDBStateFcpCompleteAbort,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                CDBStateFcpCompleteAbort,CDBStateFcpCompleteAbort,CDBStateFcpCompleteAbort,0,0,
                  CDBState_CCC_IO_Fail,0,0,0,CDBStateFcpCompleteAbort,
                    CDBStateFcpCompleteAbort,CDBStateFcpCompleteAbort,CDBStateFcpCompleteAbort,CDBStateFcpCompleteAbort,CDBStateFcpCompleteAbort,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventIoOver 10 A                                                   */
    0,CDBStateInitialize_DR,0,0,0,
      0,CDBStateFcpCompleteOver,0,0,0,
        0,0,0,0,0,
          CDBStateFcpCompleteOver,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                CDBStatePending_Abort,CDBStatePending_Abort,CDBStatePending_Abort,0,0,
                  CDBState_CCC_IO_Fail,0,0,CDBStateFcpCompleteOver,CDBStateFcpCompleteOver,
                    CDBStateFcpCompleteOver,CDBStateFcpCompleteOver,CDBStateFcpCompleteOver,CDBStateFcpCompleteOver,CDBStateFcpCompleteOver,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
     0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventThreadFree 11 B                                                   */
    0,0,0,0,0,
      0,0,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
        CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,0,0,
          0,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
            CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
              CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,0,CDBStateThreadFree,
                CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
                  CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
                    CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
     0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventIODeviceReset 12 c                                                    */
    0,CDBStateInitialize_DR,CDBStateInitialize_DR,CDBStateFillLocalSGL_DR,CDBStateAllocESGL_DR,
      CDBStateFillESGL_DR,CDBStateFcpCompleteDeviceReset,0,0,0,
        0,0,0,CDBStateOOOReceived_DR,CDBStateOOOFixup_DR,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                CDBStatePending_Abort,CDBStatePending_Abort,CDBStatePending_Abort,CDBStateFcpCompleteAbort,0,
                  CDBState_CCC_IO_Fail,0,0,CDBStateFcpCompleteDeviceReset,CDBStateFcpCompleteDeviceReset,
                    CDBStateFcpCompleteDeviceReset,CDBStateFcpCompleteDeviceReset,CDBStateFcpCompleteDeviceReset,CDBStateFcpCompleteDeviceReset,CDBStateFcpCompleteDeviceReset,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
     0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventOOOReceived 13 d                                                    */
    0,0,0,0,0, 0,CDBStateOOOReceived,0,0,0, 0,0,0,0,0, CDBStateOOOReceived,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventOOOFixup 14 e                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,CDBStateOOOFixup,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventOOOSend 15 f                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,CDBStateOOOSend, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventIoSuccessRSP 16  10                                                  */
    0,CDBStateInitialize_DR,0,0,0,
      0,CDBStateFcpCompleteSuccessRSP,0,0,0,
        0,0,0,0,0,
          CDBStateFcpCompleteSuccessRSP,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                CDBStatePending_Abort,CDBStatePending_Abort,CDBStatePending_Abort,CDBStateFcpCompleteAbort,0,
                  CDBState_CCC_IO_Fail,0,0,0,CDBStateFcpCompleteSuccessRSP,
                    CDBStateFcpCompleteSuccessRSP,CDBStateFcpCompleteSuccessRSP,CDBStateFcpCompleteSuccessRSP,CDBStateFcpCompleteSuccessRSP,CDBStateFcpCompleteSuccessRSP,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
     0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventOutBoundError 17  11                                                  */
    0,CDBStateInitialize_DR,0,0,0,
      0,CDBStateOutBoundError,0,0,0,
        0,0,0,0,0,
          CDBStateOutBoundError,0,0,0,0,
            0,0,0,0,0,
              0,0,0,CDBStateOutBoundError,0,
                CDBStatePending_Abort,CDBStatePending_Abort,CDBStatePending_Abort,0,0,
                  CDBStateOutBoundError,CDBState_CCC_IO_Fail,0,0,CDBStateOutBoundError,
                    CDBStateOutBoundError,CDBStateOutBoundError,CDBStateOutBoundError,CDBStateOutBoundError,CDBStateOutBoundError,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
     0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventFailNoRSP 18  12                                                  */
    CDBStateInitialize_DR,CDBStateInitialize_DR,0,0,0,
      0,CDBStateFailure_NO_RSP,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,CDBStateInitialize_DR,
                CDBStatePending_Abort,CDBStatePending_Abort,CDBStatePending_Abort,0,0,
                  CDBState_CCC_IO_Fail,0,0,0,CDBStateFailure_NO_RSP,
                    CDBStateFailure_NO_RSP,CDBStateFailure_NO_RSP,CDBStateFailure_NO_RSP,CDBStateFailure_NO_RSP,CDBStateFailure_NO_RSP,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
     0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 19 CDBEventAlloc_Abort */
    CDBStateFcpCompleteAbort,CDBStateFcpCompleteAbort,CDBStateFcpCompleteAbort,CDBStateFcpCompleteAbort,CDBStateFcpCompleteAbort,
      CDBStateFcpCompleteAbort,CDBStateAlloc_Abort,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,CDBStateAlloc_Abort,0,
                  CDBStateAlloc_Abort,CDBStateAlloc_Abort,CDBStateAlloc_Abort,CDBStateAlloc_Abort,CDBStateAlloc_Abort,
                    CDBStateAlloc_Abort,CDBStateAlloc_Abort,CDBStateAlloc_Abort,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
     0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 20 CDBEventDo_Abort */
    0,0,0,0,0, 
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                CDBStateDo_Abort,CDBStatePending_Abort,CDBStateFcpCompleteAbort,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 21 CDBEvent_Abort_Rejected */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,CDBStatePending_Abort,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 22 CDBEvent_PrepareforAbort */
    0,CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,CDBStateAllocESGL_Abort,
      CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,0,0,0,
        0,0,0,CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,
          CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,
            CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,
              CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,0,CDBStatePrepare_For_Abort,
                CDBStatePending_Abort,CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,
                  CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,
                    CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
     0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventDo_CCC_IO       23  */
    CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,
      CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,
        CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,
          CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,
            CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,
              CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,
                CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
     0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEvent_CCC_IO_Build   24  */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,CDBStateSend_CCC_IO,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
     0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEvent_CCC_IO_Success 25  */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  CDBState_CCC_IO_Success,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
     0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEvent_CCC_IO_Fail    26  */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  CDBState_CCC_IO_Fail,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
     0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventREC_TOV 27  */
    0,0,0,0,0,
      0,CDBState_Alloc_REC,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,CDBStateSend_REC,
                    CDBStateSend_SRR,CDBStateSend_REC,CDBStateSend_REC,CDBStateSend_REC,CDBStateSend_REC,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventSendREC_Success 28  */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,CDBStatePending_Abort,0,0,
                  0,0,0,CDBState_REC_Success,CDBState_REC_Success,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventSendREC_Fail 29  */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,CDBStateSend_REC_Second,CDBStateSend_REC_Second,
                    0,0,0,CDBStateSend_REC_Second,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventSendSRR 30  */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,CDBStateSend_SRR,
                    0,0,CDBStateSend_SRR,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventSendSRR_Success 31  */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    CDBState_SRR_Success,CDBState_SRR_Success,0,0,CDBState_SRR_Success,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventSendSRR_Again 32  */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    CDBState_SRR_Fail,0,0,0,CDBStateSend_SRR_Second,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 33 CDBEvent_Got_REC */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      CDBStateSend_REC,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* CDBEvent_ResendIO          34  */
    0,0,0,0,0,
      0,CDBStateSendIo,0,0,0,
        CDBStateReSend_IO,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,CDBStateReSend_IO,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* CDBEventSendSRR_Fail 35  */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    CDBState_SRR_Fail,CDBState_SRR_Fail,0,0,CDBStateSend_SRR_Second,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 36                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 37                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 38                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 39                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 40                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 41                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 42                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 43                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 44                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 45                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 46                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 47                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 48                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 49                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 50                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 51                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 52                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 53                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 54                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 55                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 56                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 57                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 58                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 59                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 60                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 61                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 62                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 63                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 64                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 65                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 66                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 67                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 68                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 69                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 70                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 71                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 72                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 73                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 74                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 75                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 76                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 77                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 78                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 79                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 80                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 81                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 82                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 83                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 84                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 85                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 86                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 87                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 88                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 89                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 90                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 91                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 92                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 93                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 94                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 95                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 96                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 97                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 98                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 99                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 100                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 101                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 102                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 103                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 104                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 105                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 106                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 107                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 108                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 109                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 110                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 111                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 112                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 113                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 114                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 115                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 116                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 117                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 118                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 119                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 120                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 121                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 122                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 123                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 124                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 125                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 126                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 127                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    };
/*
stateTransitionMatrix_t copiedCDBStateTransitionMatrix;
*/
stateActionScalar_t CDBStateActionScalar = {
    &CDBActionConfused,                /* 0  */
    &CDBActionThreadFree,              /* 1  */
    &CDBActionInitialize,              /* 2  */
    &CDBActionFillLocalSGL,            /* 3  */
    &CDBActionAllocESGL,               /* 4  */
    &CDBActionFillESGL,                /* 5  */
    &CDBActionSendIo,                  /* 6  */
    &CDBActionFcpCompleteSuccess,      /* 7  */
    &CDBActionFcpCompleteSuccessRSP,   /* 8  */
    &CDBActionFcpCompleteFail,         /* 9  */
    &CDBActionFcpCompleteAbort,        /* 10 */
    &CDBActionFcpCompleteDeviceReset,  /* 11 */
    &CDBActionFcpCompleteOver,         /* 12 */
    &CDBActionOOOReceived,             /* 13 */
    &CDBActionOOOFixup,                /* 14 */
    &CDBActionOOOSend,                 /* 15 */
    &CDBActionInitialize_DR,           /* 16 */
    &CDBActionFillLocalSGL_DR,         /* 17 */
    &CDBActionAllocESGL_DR,            /* 18 */
    &CDBActionFillESGL_DR,             /* 19 */
    &CDBActionInitialize_Abort,        /* 20 */
    &CDBActionFillLocalSGL_Abort,      /* 21 */
    &CDBActionAllocESGL_Abort,         /* 22 */
    &CDBActionFillESGL_Abort,          /* 23 */
    &CDBActionOOOReceived_Abort,       /* 24 */
    &CDBActionOOOReceived_DR,          /* 25 */
    &CDBActionOOOFixup_Abort,          /* 26 */
    &CDBActionOOOFixup_DR,             /* 27 */
    &CDBActionOutBoundError,           /* 28 */
    &CDBActionFailure_NO_RSP,          /* 29 */
    &CDBActionAlloc_Abort,
    &CDBActionDo_Abort,
    &CDBActionPending_Abort,
    &CDBActionPrepare_For_Abort,
    &CDBActionBuild_CCC_IO,
    &CDBActionSend_CCC_IO,
    &CDBAction_CCC_IO_Success,
    &CDBAction_CCC_IO_Fail,
    &CDBActionSend_REC,
    &CDBActionSend_REC_Second,
    &CDBActionSend_SRR,
    &CDBActionSend_SRR_Second,
    &CDBAction_REC_Success,
    &CDBAction_SRR_Success,
    &CDBAction_SRR_Fail,
    &CDBAction_Alloc_REC,
    &CDBActionDO_Nothing,
    &CDBActionReSend_IO,
    &CDBActionConfused,
    &CDBActionConfused,
    &CDBActionConfused
    };

/*
stateActionScalar_t copiedCDBStateActionScalar;
*/

#define testCDBCompareBase 0x00000110

#ifndef __State_Force_Static_State_Tables__
actionUpdate_t CDBTestActionUpdate[] = {
                              {0,          0,      agNULL,                 agNULL}
                     };
#endif /* __State_Force_Static_State_Tables__ was not defined */

#define TIMEOUT_VALUE 6250
/*
#define TEST_REC
*/
#ifndef USESTATEMACROS

/*+

   Function: CDBActionConfused

    Purpose: Terminating State for error detection
  Called By: Any State/Event pair that does not have a assign action.
             This function is called only in programming error condtions.
      Calls: <none>

-*/
/* CDBStateConfused           0 */
extern void CDBActionConfused(fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t *   pCDBThread =    (CDBThread_t * )thread;
    DevThread_t *   pDevThread =    pCDBThread->Device;

    /* pCThread->CDBpollingCount--; */

    fiLogString(thread->hpRoot,
                    "CDBActionConfused",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "In %s - State = %d ALPA %X X_ID %X",
                    "CDBActionConfused",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);

    if(! fiListElementOnList(  &(pCDBThread->CDBLink),
                               &(CThread_ptr(thread->hpRoot)->Free_CDBLink)))
    {
        pCDBThread->ExchActive = agFALSE;
        CDBThreadFree( thread->hpRoot,pCDBThread);
    }
}

/*+

   Function: CDBActionThreadFree

    Purpose: Terminating State releases CDBThread for reuse.
  Called By: Any State/Event pair that has finished using a CDBThread.
      Calls: CDBThreadFree

-*/
/* CDBStateThreadFree         1 */
extern void CDBActionThreadFree(fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t *   pCDBThread =    (CDBThread_t * )thread;
    DevThread_t *   pDevThread =    pCDBThread->Device;

#ifndef Performance_Debug
    fiLogDebugString(thread->hpRoot,
                    CDBStateLogConsoleLevel,
                    "In %s - State = %d ALPA %X",
                    "CDBActionThreadFree",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0);
#endif /* Performance_Debug */

    fiSetEventRecordNull(eventRecord);

    CDBThreadFree( thread->hpRoot,pCDBThread);
}

/*+

   Function: CDBActionInitialize

    Purpose: Initial State of CDBThread. Calculates number of memory segments
             needed by IO request.
  Called By: DevAction_IO_Ready
      Calls: Number memory segments 
                error           CDBEventConfused
                Need ESGL       CDBEventNeedESGL
                Use Local SGL   CDBEventLocalSGL
-*/
/* CDBStateInitialize         2 */
extern void CDBActionInitialize( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;
    event_t event_to_send    = CDBEventLocalSGL;

    os_bit32 Chunks=0;
    os_bit32 GetSGLStatus =0;
    os_bit32     hpChunkOffset=0;
    os_bit32     hpChunkUpper32=0;
    os_bit32     hpChunkLower32=0;
    os_bit32     hpChunkLen = 0;
    os_bit32     DataLength;

    os_bit32         SG_Cache_Offset = 0;
    os_bit32         SG_Cache_Used   = 0;
    os_bit32         SG_Cache_MAX    = CThread_ptr(thread->hpRoot)->Calculation.Parameters.SizeCachedSGLs;
    SG_Element_t *SG_Cache_Ptr       = &(pCDBThread->SG_Cache[0]);
    os_bit32         hpIOStatus;
    os_bit32         hpIOInfoLen = 0;

    os_bit32 ChunksPerESGL = CThread_ptr(thread->hpRoot)->Calculation.MemoryLayout.ESGL.elementSize/sizeof(SG_Element_t) - 1;

/*
    if( pCDBThread->ReSentIO )
    {
        fiLogDebugString(thread->hpRoot,
                        CStateLogConsoleERROR,
                        "In %s - State = %d ALPA %X ReSentIO",
                        "CDBActionInitialize",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        fiComputeDevThread_D_ID(pDevThread),
                        0,0,0,0,0,0);
    }

*/
    if (pCDBThread->CDBRequest->FcpCmnd.FcpCntl[3] & agFcpCntlReadData)
    {
        pCDBThread->ReadWrite  =  CDBThread_Read;
    }
    else /* !(pCDBThread->CDBRequest->FcpCmnd.FcpCntl[3] & agFcpCntlReadData) */
    {
        pCDBThread->ReadWrite  =  CDBThread_Write;
    }

    DataLength = pCDBThread->DataLength;

    CThread_ptr(thread->hpRoot)->FuncPtrs.fiFillInFCP_CMND(pCDBThread);
    CThread_ptr(thread->hpRoot)->FuncPtrs.fiFillInFCP_RESP(pCDBThread);
    CThread_ptr(thread->hpRoot)->FuncPtrs.fiFillInFCP_SEST(pCDBThread);

    while( hpChunkOffset < DataLength ){
        GetSGLStatus = osGetSGLChunk( thread->hpRoot,
                         pCDBThread->hpIORequest,
                         hpChunkOffset,
                         &hpChunkUpper32,
                         &hpChunkLower32,
                         &hpChunkLen
                         );

        if (hpChunkLen > SG_Element_Len_MAX)
        {
            fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "%s hpChunkLen %X hpChunkOffset %X hpChunkUpper32 %X hpChunkLower32 %X",
                    "CDBActionInitialize",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    hpChunkLen,
                    hpChunkOffset,
                    hpChunkUpper32,
                    hpChunkLower32,
                    0,0,0,0);

            hpChunkLen = SG_Element_Len_MAX;

        }

        if (hpChunkLen == 0)
        {
            fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "%s hpChunkLen %X hpChunkOffset %X hpChunkUpper32 %X hpChunkLower32 %X",
                    "CDBActionInitialize",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    hpChunkLen,
                    hpChunkOffset,
                    hpChunkUpper32,
                    hpChunkLower32,
                    0,0,0,0);
        }

        if (SG_Cache_Used < SG_Cache_MAX)
        {
            SG_Cache_Ptr->U32_Len = (hpChunkUpper32 << SG_Element_U32_SHIFT) | hpChunkLen;
            SG_Cache_Ptr->L32     = hpChunkLower32;

            SG_Cache_Offset += hpChunkLen;
            SG_Cache_Used   += 1;
            SG_Cache_Ptr    += 1;
        }

        if(GetSGLStatus)
        {
            hpIOStatus = osIOInfoBad;
            osIOCompleted( thread->hpRoot,
               pCDBThread->hpIORequest,
               hpIOStatus,
               hpIOInfoLen);

            Device_IO_Throttle_Decrement
            event_to_send=CDBEventConfused;
            break;
        }
        hpChunkOffset+=hpChunkLen;
        Chunks++;

    }

    pCDBThread->SG_Cache_Offset = SG_Cache_Offset;
    pCDBThread->SG_Cache_Used   = SG_Cache_Used;

    if(event_to_send != CDBEventConfused )
    {
        if(Chunks > 3)
        {
            event_to_send=CDBEventNeedESGL;
            pCDBThread->ESGL_Request.num_ESGL = (Chunks + ChunksPerESGL - 1) / ChunksPerESGL;
        }
        else pCDBThread->ESGL_Request.num_ESGL = 0;

    }

#ifndef Performance_Debug
    fiLogDebugString(thread->hpRoot,
                    CDBStateLogConsoleLevel,
                    "In %s - State = %d ALPA %X ESGL req %x",
                    "CDBActionInitialize",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->ESGL_Request.num_ESGL,0,0,0,0,0);

#endif /* Performance_Debug */

    fiSetEventRecord(eventRecord,thread,event_to_send);
}

/*+

   Function: CDBActionFillLocalSGL

    Purpose: Copies result of SGL calculation to SEST entry. 
  Called By: CDBActionInitialize
      Calls: CDBEventLocalSGLSendIo
-*/
/* CDBStateFillLocalSGL       3 */
extern void CDBActionFillLocalSGL( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;

    CThread_ptr(thread->hpRoot)->FuncPtrs.fillLocalSGL(pCDBThread);

#ifndef Performance_Debug

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogConsoleLevel,
                    "In %s - State = %d ALPA %X",
                    "CDBActionFillLocalSGL",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0);

#endif /* Performance_Debug */

    fiSetEventRecord(eventRecord,thread,CDBEventLocalSGLSendIo);
}

/*+

   Function: CDBActionAllocESGL

    Purpose: Requests ESGL pages calculated in CDBActionInitialize.
  Called By: CDBActionInitialize
      Calls: ESGLAlloc sends event CDBEventGotESGL when all resources are available
-*/
/* CDBStateAllocESGL          4 */
extern void CDBActionAllocESGL( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;

    ESGL_Request_t *pESGL_Request = &pCDBThread->ESGL_Request;

    pESGL_Request->eventRecord_to_send.thread= thread;
    pESGL_Request->eventRecord_to_send.event= CDBEventGotESGL;

#ifndef Performance_Debug
    fiLogDebugString(thread->hpRoot,
                    CDBStateLogConsoleLevel,
                    "In %s - State = %d ALPA %X",
                    "CDBActionAllocESGL",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0);

#endif /* Performance_Debug */

    CThread_ptr(thread->hpRoot)->FuncPtrs.ESGLAlloc( thread->hpRoot,pESGL_Request );

    fiSetEventRecordNull(eventRecord);

}

/*+

   Function: CDBActionFillESGL

    Purpose: Fills Requested ESGL pages calculated in CDBActionInitialize.
  Called By: CDBActionAllocESGL
      Calls: CDBEventESGLSendIo

-*/
/* CDBStateFillESGL           5 */
extern void CDBActionFillESGL( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;

    CThread_ptr(thread->hpRoot)->FuncPtrs.upSEST(pCDBThread);
    CThread_ptr(thread->hpRoot)->FuncPtrs.fillESGL(pCDBThread);
#ifndef Performance_Debug

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogConsoleLevel,
                    "In %s - State = %d ALPA %X",
                    "CDBActionFillESGL",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0);
#endif /* Performance_Debug */

    fiSetEventRecord(eventRecord,thread,CDBEventESGLSendIo);
}

/*+

   Function: CDBActionSendIo

    Purpose: Fills all remaining information to send IO.
  Called By: CDBActionFillESGL or CDBActionFillLocalSGL
      Calls: WaitForERQ
             CDBFuncIRB_Init
             SENDIO
-*/
/* CDBStateSendIo             6 */
extern void CDBActionSendIo(fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t        * hpRoot        = thread->hpRoot;
    CThread_t       * pCThread      = CThread_ptr(hpRoot);
    CDBThread_t     * pCDBThread    = (CDBThread_t * )thread;
    DevThread_t     * pDevThread    = pCDBThread->Device;

    pCThread->FuncPtrs.WaitForERQ( hpRoot );

    pCThread->FuncPtrs.CDBFuncIRB_Init(pCDBThread);

    pCDBThread->SentERQ   =  pCThread->HostCopy_ERQProdIndex;

    if( pCDBThread->CDB_CMND_Type != SFThread_SF_CMND_Type_CDB_FC_Tape)
    {
/*
        fiLogString(hpRoot,
                    "Startio X_ID %X  CDB Class %2X Type %2X State %2X Status %2X Time %X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)pCDBThread->X_ID,
                    (os_bit32)pCDBThread->CDB_CMND_Class,
                    (os_bit32)pCDBThread->CDB_CMND_Type,
                    (os_bit32)pCDBThread->CDB_CMND_State,
                    (os_bit32)pCDBThread->CDB_CMND_Status,
                    pCDBThread->TimeStamp,
                    0,0);
*/
        pCDBThread->TimeStamp =  osTimeStamp(hpRoot);

    }
    else
    {
/****************** FC Tape ******************************************/


       if( pCDBThread->CDB_CMND_Type == SFThread_SF_CMND_Type_CDB_FC_Tape)
        {

             fiLogString(hpRoot,
                    "Startio Dev %02X Cl %2X Ty %2X St %2X Stat %2X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                    (os_bit32)pCDBThread->CDB_CMND_Class,
                    (os_bit32)pCDBThread->CDB_CMND_Type,
                    (os_bit32)pCDBThread->CDB_CMND_State,
                    (os_bit32)pCDBThread->CDB_CMND_Status,
                    0,0,0);

            if( pCDBThread->CDB_CMND_State == SFThread_SF_CMND_State_CDB_FC_Tape_ReSend)
            {/* ReSend command */ 

                if (pCDBThread->ReadWrite == CDBThread_Read)
                {
                }
                else /* CDBThread->ReadWrite == CDBThread_Write */
                {
                    USE_t           * SEST          = &( pCDBThread->SEST_Ptr->USE);
                    FCHS_t          * FCHS          = pCDBThread->FCP_CMND_Ptr;
                    fiMemMapMemoryDescriptor_t *ERQ = &(pCThread->Calculation.MemoryLayout.ERQ);
                    IRB_t                      *pIrb;

 
                    pIrb = (IRB_t *)ERQ->addr.DmaMemory.dmaMemoryPtr;
                    pIrb += pCThread->HostCopy_ERQProdIndex;

                    SEST->Bits &= 0x00FFFFFF;
                    SEST->Bits |=  (IWE_VAL | IWE_INI | IWE_DAT | IWE_RSP);
                    SEST->Unused_DWord_6 = pCDBThread->FC_Tape_RXID;


                    pIrb->Req_A.Bits__SFS_Len   &= ~IRB_SFA;

                    fiLogDebugString(hpRoot,
                                    SFStateLogErrorLevel,
                                    "Sest DWORD 0 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    SEST->Bits,
                                    SEST->Unused_DWord_1,
                                    SEST->Unused_DWord_2,
                                    SEST->Unused_DWord_3,
                                    SEST->LOC,
                                    SEST->Unused_DWord_5,
                                    SEST->Unused_DWord_6,
                                    SEST->Unused_DWord_7);

                    fiLogDebugString(hpRoot,
                                    SFStateLogErrorLevel,
                                    "FCHS DWORD 0 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                                    (char *)agNULL,(char *)agNULL,
                                     (void *)agNULL,(void *)agNULL,
                                    FCHS->MBZ1,
                                    FCHS->SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp,
                                    FCHS->R_CTL__D_ID,
                                    FCHS->CS_CTL__S_ID,
                                    FCHS->TYPE__F_CTL,
                                    FCHS->SEQ_ID__DF_CTL__SEQ_CNT,
                                    FCHS->OX_ID__RX_ID,
                                    FCHS->RO );

                    fiLogDebugString(hpRoot,
                                    SFStateLogErrorLevel,
                                    "IRB  DWORD 0 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    pIrb->Req_A.Bits__SFS_Len,
                                    pIrb->Req_A.SFS_Addr,
                                    pIrb->Req_A.D_ID,
                                    pIrb->Req_A.MBZ__SEST_Index__Trans_ID,
                                    0,0,0,0);

                    fiListDequeueThis(&(pCDBThread->CDBLink));

                    fiListEnqueueAtTail( &(pCDBThread->CDBLink),&(pDevThread->Active_CDBLink_1) );


                }
            }/* End if( pCDBThread->CDB_CMND_State == SFThread_SF_CMND_State_CDB_FC_Tape_ReSend)*/
            else
            {
                if( pCDBThread->CDB_CMND_State == SFThread_SF_CMND_State_CDB_FC_Tape_GotXRDY)
                {/* Re send data  */ 
                    USE_t           * SEST          = &( pCDBThread->SEST_Ptr->USE);
                    FCHS_t          * FCHS          = pCDBThread->FCP_CMND_Ptr;
                    fiMemMapMemoryDescriptor_t *ERQ = &(pCThread->Calculation.MemoryLayout.ERQ);
                    IRB_t                      *pIrb;

                    fiLogString(hpRoot,
                                    "SFThread_SF_CMND_State_CDB_FC_Tape_GotXRDY",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    0,0,0,0,0,0,0,0 );


                    pIrb = (IRB_t *)ERQ->addr.DmaMemory.dmaMemoryPtr;
                    pIrb += pCThread->HostCopy_ERQProdIndex;

                    SEST->Bits &= 0x00FFFFFF;
                    SEST->Bits |=  (IWE_VAL | IWE_INI | IWE_DAT | IWE_RSP);
                    SEST->Unused_DWord_6 = pCDBThread->FC_Tape_RXID;


                    pIrb->Req_A.Bits__SFS_Len   &= ~IRB_SFA;

                    fiLogDebugString(hpRoot,
                                    SFStateLogErrorLevel,
                                    "Sest DWORD 0 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    SEST->Bits,
                                    SEST->Unused_DWord_1,
                                    SEST->Unused_DWord_2,
                                    SEST->Unused_DWord_3,
                                    SEST->LOC,
                                    SEST->Unused_DWord_5,
                                    SEST->Unused_DWord_6,
                                    SEST->Unused_DWord_7);

                    fiLogDebugString(hpRoot,
                                    SFStateLogErrorLevel,
                                    "FCHS DWORD 0 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                                    (char *)agNULL,(char *)agNULL,
                                     (void *)agNULL,(void *)agNULL,
                                    FCHS->MBZ1,
                                    FCHS->SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp,
                                    FCHS->R_CTL__D_ID,
                                    FCHS->CS_CTL__S_ID,
                                    FCHS->TYPE__F_CTL,
                                    FCHS->SEQ_ID__DF_CTL__SEQ_CNT,
                                    FCHS->OX_ID__RX_ID,
                                    FCHS->RO );

                    fiLogDebugString(hpRoot,
                                    SFStateLogErrorLevel,
                                    "IRB  DWORD 0 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    pIrb->Req_A.Bits__SFS_Len,
                                    pIrb->Req_A.SFS_Addr,
                                    pIrb->Req_A.D_ID,
                                    pIrb->Req_A.MBZ__SEST_Index__Trans_ID,
                                    0,0,0,0);

                    fiListDequeueThis(&(pCDBThread->CDBLink));

                    fiListEnqueueAtTail( &(pCDBThread->CDBLink),&(pDevThread->Active_CDBLink_1) );

                }
            }
        } /****************** FC Tape ******************************************/
    }

    pCDBThread->CDBStartTimeBase = pCThread->TimeBase;

    ROLL(pCThread->HostCopy_ERQProdIndex,
        pCThread->Calculation.MemoryLayout.ERQ.elements);

    SENDIO(hpRoot,pCThread,thread,DoFuncCdbCmnd);

#ifndef Performance_Debug

    fiLogDebugString(hpRoot,
                    CDBStateLogConsoleLevel,
                    "In %s - State = %d ALPA %X CCnt %x X_ID %X ERQ %X",
                    "CDBActionSendIo",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCThread->CDBpollingCount,
                    pCDBThread->X_ID,
                    pCThread->HostCopy_ERQProdIndex,
                    0,0,0);
#endif /* Performance_Debug */

    fiSetEventRecordNull(eventRecord);

}

/*+
  Function: CDBActionFcpCompleteSuccess

   Purpose: Successful IO completion hpIOInfoLen set to zero indicating oslayer does not
            need to access response buffer information.
 Called By: CFuncProcessFcpRsp CFuncSEST_ off / on Card_FCPCompletion
     Calls: osIOCompleted 
            CDBEventThreadFree
-*/
/* CDBStateFcpCompleteSuccess 7 */
extern void CDBActionFcpCompleteSuccess( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;
    os_bit32 hpIOStatus     = osIOSuccess;
    os_bit32 hpIOInfoLen = 0;

    /* CThread_ptr(thread->hpRoot)->CDBpollingCount--; */
#ifndef Performance_Debug

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogConsoleLevel,
                    "In %s - State = %d ALPA %X",
                    "CDBActionFcpCompleteSuccess",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0);
    if( osTimeStamp(thread->hpRoot)- pCDBThread->TimeStamp > TIMEOUT_VALUE ) /*1.6 ms per */
    {
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s IO timeout ALPA %X  X_ID %3X Time %d",
                    "Good",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    osTimeStamp(thread->hpRoot)-pCDBThread->TimeStamp,
                    0,0,0,0,0);

        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s Bytes %d TimeBase %d",
                    pCDBThread->ReadWrite ? "Write": "Read" ,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCDBThread->DataLength,
                    CThread_ptr(thread->hpRoot)->TimeBase.Lo -  pCDBThread->CDBStartTimeBase.Lo,
                    0,0,0,0,0,0);
    }
#endif /* Performance_Debug */

#ifdef FULL_FC_TAPE_DBG

    if (pCDBThread->FC_Tape_Active)
    {
        fiLogDebugString(thread->hpRoot,
                    CFuncLogConsoleERROR,
                    "%d Found a FC_Tape_Active cbdthread %p X_ID %X",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread,agNULL,
                    (os_bit32)thread->currentState,
                    pCDBThread->X_ID,                    
                    0,0,0,0,0,0);

         fiLogDebugString(thread->hpRoot,
                    CFuncLogConsoleERROR,
                    "Device %02X  CDB Class %2X Type %2X State %2X Status %2X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                    (os_bit32)pCDBThread->CDB_CMND_Class,
                    (os_bit32)pCDBThread->CDB_CMND_Type,
                    (os_bit32)pCDBThread->CDB_CMND_State,
                    (os_bit32)pCDBThread->CDB_CMND_Status,
                    0,0,0);
        

        if (pCDBThread->ReadWrite == CDBThread_Read)
        {

            if(pCDBThread->DataLength - pCDBThread->SEST_Ptr->IRE.Exp_Byte_Cnt != pCDBThread->SEST_Ptr->IRE.Byte_Count)
            {
                fiLogDebugString(thread->hpRoot,
                            CFuncLogConsoleERROR,
                            "Byte Count %08X Exp %08X %s DataLength %X",
                            "Read",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            pCDBThread->SEST_Ptr->IRE.Byte_Count,
                            pCDBThread->SEST_Ptr->IRE.Exp_Byte_Cnt,
                            pCDBThread->DataLength,
                            0,0,0,0,0);
            }
        }
        else
        {
            if(pCDBThread->DataLength - pCDBThread->SEST_Ptr->IWE.Exp_Byte_Cnt != pCDBThread->SEST_Ptr->IWE.Data_Len)
            {
                fiLogDebugString(thread->hpRoot,
                        CFuncLogConsoleERROR,
                        "Byte Count %08X Exp %08X %s DataLength %X",
                        "Write",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        pCDBThread->SEST_Ptr->IWE.Data_Len,
                        pCDBThread->SEST_Ptr->IWE.Exp_Byte_Cnt,
                        pCDBThread->DataLength,
                        0,0,0,0,0);
            }
        }
    }

#endif /* FULL_FC_TAPE_DBG */

    osIOCompleted( thread->hpRoot,
                   pCDBThread->hpIORequest,
                   hpIOStatus,
                   hpIOInfoLen
                  );

    Device_IO_Throttle_Decrement
    pCDBThread->ExchActive = agFALSE;
    fiSetEventRecord(eventRecord,thread,CDBEventThreadFree);
}

/*+
   Function: CDBActionFcpCompleteSuccessRSP

    Purpose: Does completion on Succesful IO that have response buffer 
             information to return.
  Called By: CFuncProcessFcpRsp CFuncSEST_ off / on Card_FCPCompletion
      Calls: osIOCompleted 
             CDBEventThreadFree
-*/
/* CDBStateFcpCompleteSuccessRSP 8 */
extern void CDBActionFcpCompleteSuccessRSP( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;
    os_bit32 hpIOStatus = osIOSuccess;
    os_bit32 hpIOInfoLen = CThread_ptr(thread->hpRoot)->Calculation.MemoryLayout.FCP_RESP.elementSize;
    os_bit32 ERQ_Entry = 0;

    /* CThread_ptr(thread->hpRoot)->CDBpollingCount--; */

    ERQ_Entry = CFunc_Get_ERQ_Entry( thread->hpRoot, pCDBThread->X_ID );

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "(%p)In %s - State = %d ALPA %X X_ID %X ERQ %X SERQ %X",
                    "CDBActionFcpCompleteSuccessRSP",(char *)agNULL,
                    thread,agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    ERQ_Entry,
                    pCDBThread->SentERQ,
                    0,0,0);

    if( osTimeStamp(thread->hpRoot)- pCDBThread->TimeStamp > TIMEOUT_VALUE ) /*1.6 ms per */
    {
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s IO timeout ALPA %X  X_ID %3X Time %d",
                    "Good RSP",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    osTimeStamp(thread->hpRoot)-pCDBThread->TimeStamp,
                    0,0,0,0,0);
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s Bytes %d TimeBase %d",
                    pCDBThread->ReadWrite ? "Write": "Read" ,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCDBThread->DataLength,
                    CThread_ptr(thread->hpRoot)->TimeBase.Lo -  pCDBThread->CDBStartTimeBase.Lo,
                    0,0,0,0,0,0);
    }

    if (pCDBThread->FC_Tape_Active)
    {
        fiLogDebugString(thread->hpRoot,
                    CFuncLogConsoleERROR,
                    "%d Found a FC_Tape_Active cbdthread %p X_ID %X",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread,agNULL,
                    (os_bit32)thread->currentState,
                    pCDBThread->X_ID,                    
                    0,0,0,0,0,0);

         fiLogDebugString(thread->hpRoot,
                    CFuncLogConsoleERROR,
                    "Device %02X  CDB Class %2X Type %2X State %2X Status %2X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                    (os_bit32)pCDBThread->CDB_CMND_Class,
                    (os_bit32)pCDBThread->CDB_CMND_Type,
                    (os_bit32)pCDBThread->CDB_CMND_State,
                    (os_bit32)pCDBThread->CDB_CMND_Status,
                    0,0,0);
        

        if (pCDBThread->ReadWrite == CDBThread_Read)
        {

            if(pCDBThread->DataLength - pCDBThread->SEST_Ptr->IRE.Exp_Byte_Cnt != pCDBThread->SEST_Ptr->IRE.Byte_Count)
            {
                fiLogDebugString(thread->hpRoot,
                            CFuncLogConsoleERROR,
                            "Byte Count %08X Exp %08X %s DataLength %X",
                            "Read",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            pCDBThread->SEST_Ptr->IRE.Byte_Count,
                            pCDBThread->SEST_Ptr->IRE.Exp_Byte_Cnt,
                            pCDBThread->DataLength,
                            0,0,0,0,0);
            }
        }
        else
        {
            if(pCDBThread->DataLength - pCDBThread->SEST_Ptr->IWE.Exp_Byte_Cnt != pCDBThread->SEST_Ptr->IWE.Data_Len)
            {
                fiLogDebugString(thread->hpRoot,
                        CFuncLogConsoleERROR,
                        "Byte Count %08X Exp %08X %s DataLength %X",
                        "Write",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        pCDBThread->SEST_Ptr->IWE.Data_Len,
                        pCDBThread->SEST_Ptr->IWE.Exp_Byte_Cnt,
                        pCDBThread->DataLength,
                        0,0,0,0,0);
            }
        }
    }

    osIOCompleted( thread->hpRoot,
                   pCDBThread->hpIORequest,
                   hpIOStatus,
                   hpIOInfoLen
                  );
    Device_IO_Throttle_Decrement
    pCDBThread->ExchActive = agFALSE;
    fiSetEventRecord(eventRecord,thread,CDBEventThreadFree);
}

/*+
   Function: CDBActionFcpCompleteFail

    Purpose: Does completion on failed IO that have response buffer 
             information to return.
  Called By: CFuncProcessFcpRsp CFuncSEST_ off / on Card_FCPCompletion
             CFuncOutBoundCompletion
             CFunc_LOGO_Completion

      Calls: osIOCompleted 
             CDBEventThreadFree
-*/
/* CDBStateFcpCompleteFail    9 */
extern void CDBActionFcpCompleteFail( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;
    os_bit32 hpIOStatus = osIOFailed;
    os_bit32 hpIOInfoLen = CThread_ptr(thread->hpRoot)->Calculation.MemoryLayout.FCP_RESP.elementSize;

    /* CThread_ptr(thread->hpRoot)->CDBpollingCount--; */

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "(%p)In %s - State = %d ALPA %X X_ID %X ExchActive %X",
                    "CDBActionFcpCompleteFail",(char *)agNULL,
                    thread,agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    pCDBThread->ExchActive,
                    0,0,0,0);

    if( osTimeStamp(thread->hpRoot)- pCDBThread->TimeStamp > TIMEOUT_VALUE ) /*1.6 ms per */
    {
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s IO timeout ALPA %X  X_ID %3X Time %d",
                    "Fail",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    osTimeStamp(thread->hpRoot)-pCDBThread->TimeStamp,
                    0,0,0,0,0);
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s Bytes %d TimeBase %d",
                    pCDBThread->ReadWrite ? "Write": "Read" ,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCDBThread->DataLength,
                    CThread_ptr(thread->hpRoot)->TimeBase.Lo -  pCDBThread->CDBStartTimeBase.Lo,
                    0,0,0,0,0,0);

    }

    if (pCDBThread->FC_Tape_Active)
    {
        fiLogDebugString(thread->hpRoot,
                    CFuncLogConsoleERROR,
                    "%d Found a FC_Tape_Active cbdthread %p X_ID %X",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread,agNULL,
                    (os_bit32)thread->currentState,
                    pCDBThread->X_ID,                    
                    0,0,0,0,0,0);

         fiLogDebugString(thread->hpRoot,
                    CFuncLogConsoleERROR,
                    "Device %02X  CDB Class %2X Type %2X State %2X Status %2X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                    (os_bit32)pCDBThread->CDB_CMND_Class,
                    (os_bit32)pCDBThread->CDB_CMND_Type,
                    (os_bit32)pCDBThread->CDB_CMND_State,
                    (os_bit32)pCDBThread->CDB_CMND_Status,
                    0,0,0);
        

        if (pCDBThread->ReadWrite == CDBThread_Read)
        {

            if(pCDBThread->DataLength - pCDBThread->SEST_Ptr->IRE.Exp_Byte_Cnt != pCDBThread->SEST_Ptr->IRE.Byte_Count)
            {
                fiLogDebugString(thread->hpRoot,
                            CFuncLogConsoleERROR,
                            "Byte Count %08X Exp %08X %s DataLength %X",
                            "Read",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            pCDBThread->SEST_Ptr->IRE.Byte_Count,
                            pCDBThread->SEST_Ptr->IRE.Exp_Byte_Cnt,
                            pCDBThread->DataLength,
                            0,0,0,0,0);
            }
        }
        else
        {
            if(pCDBThread->DataLength - pCDBThread->SEST_Ptr->IWE.Exp_Byte_Cnt != pCDBThread->SEST_Ptr->IWE.Data_Len)
            {
                fiLogDebugString(thread->hpRoot,
                        CFuncLogConsoleERROR,
                        "Byte Count %08X Exp %08X %s DataLength %X",
                        "Write",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        pCDBThread->SEST_Ptr->IWE.Data_Len,
                        pCDBThread->SEST_Ptr->IWE.Exp_Byte_Cnt,
                        pCDBThread->DataLength,
                        0,0,0,0,0);
            }
        }
    }


    osIOCompleted( thread->hpRoot,
                   pCDBThread->hpIORequest,
                   hpIOStatus,
                   hpIOInfoLen
                  );
    Device_IO_Throttle_Decrement
    pCDBThread->ExchActive = agFALSE;
    fiSetEventRecord(eventRecord,thread,CDBEventThreadFree);
}

/*+
   Function: CDBActionFcpCompleteAbort

    Purpose: Does completion on IO that have  been aborted.
  Called By: SFActionAbortAccept
             SFActionAbortRej
             SFActionAbortBadALPA
             SFActionAbortTimedOut
      Calls: osIOCompleted 
             CDBEventThreadFree
-*/
/* CDBStateFcpCompleteAbort   10 */
extern void CDBActionFcpCompleteAbort( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;
    os_bit32 hpIOStatus         = pCDBThread->CompletionStatus;
    os_bit32 hpIOInfoLen = 0;

    /* CThread_ptr(thread->hpRoot)->CDBpollingCount--; */

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "(%p)In %s - State = %d ALPA %X X_ID %X @ %d Status %x",
                    "CDBActionFcpCompleteAbort",(char *)agNULL,
                    thread,agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    pCDBThread->TimeStamp,
                    pCDBThread->CompletionStatus,
                    0,0,0);

    if( osTimeStamp(thread->hpRoot)- pCDBThread->TimeStamp > TIMEOUT_VALUE ) /*1.6 ms per */
    {
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s IO timeout ALPA %X  X_ID %3X Time %d",
                    "Abort",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    osTimeStamp(thread->hpRoot)-pCDBThread->TimeStamp,
                    0,0,0,0,0);
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s Bytes %d TimeBase %d",
                    pCDBThread->ReadWrite ? "Write": "Read" ,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCDBThread->DataLength,
                    CThread_ptr(thread->hpRoot)->TimeBase.Lo -  pCDBThread->CDBStartTimeBase.Lo,
                    0,0,0,0,0,0);

    }

    if(pCDBThread->FC_Tape_CompletionStatus == CdbCompetionStatusReSendIO)
    {
        fiSetEventRecord(eventRecord,thread,CDBEvent_ResendIO);
    }
    else
    {

        osIOCompleted( thread->hpRoot,
                       pCDBThread->hpIORequest,
                       hpIOStatus,
                       hpIOInfoLen
                      );
        Device_IO_Throttle_Decrement
        pCDBThread->ExchActive = agFALSE;
        fiSetEventRecord(eventRecord,thread,CDBEventThreadFree);
    }
}

/*+
   Function: CDBActionFcpCompleteDeviceReset

    Purpose: Does completion on IO that have  been reset.
  Called By: CFuncOutBoundCompletion
             CFuncCompleteAllActiveCDBThreads with CDBEventIODeviceReset
             CFuncCompleteActiveCDBThreadsOnDevice with CDBEventIODeviceReset
      Calls: osIOCompleted 
             CDBEventThreadFree
-*/
/* CDBStateFcpCompleteDeviceReset  11 */
extern void CDBActionFcpCompleteDeviceReset( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;
    os_bit32 hpIOStatus = osIODevReset;
    os_bit32 hpIOInfoLen = 0;

    /* CThread_ptr(thread->hpRoot)->CDBpollingCount--; */

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "(%p)In %s State = %d CCnt %x ALPA %X X_ID %X @ %d",
                    "CDBActionFcpCompleteDeviceReset",(char *)agNULL,
                    thread,agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->CDBpollingCount,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    pCDBThread->TimeStamp,
                    0,0,0);

    if( osTimeStamp(thread->hpRoot)- pCDBThread->TimeStamp > TIMEOUT_VALUE ) /*1.6 ms per */
    {
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s IO timeout ALPA %X  X_ID %3X Time %d",
                    "Reset",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    osTimeStamp(thread->hpRoot)-pCDBThread->TimeStamp,
                    0,0,0,0,0);
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s Bytes %d TimeBase %d",
                    pCDBThread->ReadWrite ? "Write": "Read" ,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCDBThread->DataLength,
                    CThread_ptr(thread->hpRoot)->TimeBase.Lo -  pCDBThread->CDBStartTimeBase.Lo,
                    0,0,0,0,0,0);
    }

    osIOCompleted( thread->hpRoot,
                   pCDBThread->hpIORequest,
                   hpIOStatus,
                   hpIOInfoLen
                  );
    Device_IO_Throttle_Decrement
    pCDBThread->ExchActive = agFALSE;
    fiSetEventRecord(eventRecord,thread,CDBEventThreadFree);
}

/*+
   Function: CDBActionFcpCompleteOver

    Purpose: Does completion on IO that have mismatch with request data length 
             and actual data length.
  Called By: CFuncProcessFcpRsp CFuncSEST_ off / on Card_FCPCompletion
      Calls: osIOCompleted 
             CDBEventThreadFree
-*/
/* CDBStateFcpCompleteOver   12 */
extern void CDBActionFcpCompleteOver( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;
/*
    os_bit32    *  fcprsp= ( os_bit32 * )pCDBThread->FCP_RESP_Ptr;
*/
    os_bit32 hpIOStatus = osIOOverUnder;
    os_bit32 hpIOInfoLen = CThread_ptr(thread->hpRoot)->Calculation.MemoryLayout.FCP_RESP.elementSize;

    /* CThread_ptr(thread->hpRoot)->CDBpollingCount--; */
    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleErrorOverRun,
                    "(%p)In %s - State = %d ALPA %X X_ID %X",
                    "CDBActionFcpCompleteOver",(char *)agNULL,
                    thread,agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    0,0,0,0,0);

    if (pCDBThread->FC_Tape_Active)
    {
        fiLogDebugString(thread->hpRoot,
                    CFuncLogConsoleERROR,
                    "%d Found a FC_Tape_Active cbdthread %p X_ID %X",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread,agNULL,
                    (os_bit32)thread->currentState,
                    pCDBThread->X_ID,                    
                    0,0,0,0,0,0);

         fiLogDebugString(thread->hpRoot,
                    CFuncLogConsoleERROR,
                    "Device %02X  CDB Class %2X Type %2X State %2X Status %2X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                    (os_bit32)pCDBThread->CDB_CMND_Class,
                    (os_bit32)pCDBThread->CDB_CMND_Type,
                    (os_bit32)pCDBThread->CDB_CMND_State,
                    (os_bit32)pCDBThread->CDB_CMND_Status,
                    0,0,0);
        

        if (pCDBThread->ReadWrite == CDBThread_Read)
        {

            if(pCDBThread->DataLength - pCDBThread->SEST_Ptr->IRE.Exp_Byte_Cnt != pCDBThread->SEST_Ptr->IRE.Byte_Count)
            {
                fiLogDebugString(thread->hpRoot,
                            CFuncLogConsoleERROR,
                            "Byte Count %08X Exp %08X %s DataLength %X",
                            "Read",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            pCDBThread->SEST_Ptr->IRE.Byte_Count,
                            pCDBThread->SEST_Ptr->IRE.Exp_Byte_Cnt,
                            pCDBThread->DataLength,
                            0,0,0,0,0);
            }
        }
        else
        {
            if(pCDBThread->DataLength - pCDBThread->SEST_Ptr->IWE.Exp_Byte_Cnt != pCDBThread->SEST_Ptr->IWE.Data_Len)
            {
                fiLogDebugString(thread->hpRoot,
                        CFuncLogConsoleERROR,
                        "Byte Count %08X Exp %08X %s DataLength %X",
                        "Write",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        pCDBThread->SEST_Ptr->IWE.Data_Len,
                        pCDBThread->SEST_Ptr->IWE.Exp_Byte_Cnt,
                        pCDBThread->DataLength,
                        0,0,0,0,0);
            }
        }
    }



/*
    fiLogString(thread->hpRoot,
                    "FCHS  0 %08X %08X %08X %08X %08X %08X %08X %08X",
                    (char *)NULL,(char *)NULL,
                    (void *)agNULL,(void *)agNULL,
                    hpSwapBit32(*(fcprsp+0)),
                    hpSwapBit32(*(fcprsp+1)),
                    hpSwapBit32(*(fcprsp+2)),
                    hpSwapBit32(*(fcprsp+3)),
                    hpSwapBit32(*(fcprsp+4)),
                    hpSwapBit32(*(fcprsp+5)),
                    hpSwapBit32(*(fcprsp+6)),
                    hpSwapBit32(*(fcprsp+7))
                    );
    fiLogString(thread->hpRoot,
                    "RSP   0 %08X %08X  %08X %08X %08X %08X %08X %08X",
                    (char *)NULL,(char *)NULL,
                    (void *)agNULL,(void *)agNULL,
                    hpSwapBit32(*(fcprsp+8)),
                    hpSwapBit32(*(fcprsp+9)),
                    hpSwapBit32(*(fcprsp+10)),
                    hpSwapBit32(*(fcprsp+11)),
                    hpSwapBit32(*(fcprsp+12)),
                    hpSwapBit32(*(fcprsp+13)),
                    hpSwapBit32(*(fcprsp+14)),
                    hpSwapBit32(*(fcprsp+15))
                    );
    fiLogString(thread->hpRoot,
                    "RSP  9 %08X %08X %08X %08X %08X %08X %08X %08X",
                    (char *)NULL,(char *)NULL,
                    (void *)agNULL,(void *)agNULL,
                    hpSwapBit32(*(fcprsp+16)),
                    hpSwapBit32(*(fcprsp+17)),
                    hpSwapBit32(*(fcprsp+18)),
                    hpSwapBit32(*(fcprsp+19)),
                    hpSwapBit32(*(fcprsp+20)),
                    hpSwapBit32(*(fcprsp+21)),
                    hpSwapBit32(*(fcprsp+22)),
                    hpSwapBit32(*(fcprsp+23))
                    );

    *(fcprsp+10) = FC_FCP_RSP_FCP_STATUS_ValidityStatusIndicators_FCP_RESID_OVER << 16;
                    
    *(fcprsp+11) = ~*(fcprsp+11);

    fiLogString(thread->hpRoot,
                    "Status   %08X Resid %X", 
                    (char *)NULL,(char *)NULL,
                    (void *)agNULL,(void *)agNULL,
                    hpSwapBit32(*(fcprsp+10)),
                    hpSwapBit32(*(fcprsp+11)),
                    0,0,0,0,0,0);

*/
    if( osTimeStamp(thread->hpRoot)- pCDBThread->TimeStamp > TIMEOUT_VALUE ) /*1.6 ms per */
    {
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s IO timeout ALPA %X  X_ID %3X Time %d",
                    "Over",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    osTimeStamp(thread->hpRoot)-pCDBThread->TimeStamp,
                    0,0,0,0,0);
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s Bytes %d TimeBase %d",
                    pCDBThread->ReadWrite ? "Write": "Read" ,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCDBThread->DataLength,
                    CThread_ptr(thread->hpRoot)->TimeBase.Lo -  pCDBThread->CDBStartTimeBase.Lo,
                    0,0,0,0,0,0);
    }

    osIOCompleted( thread->hpRoot,
                   pCDBThread->hpIORequest,
                   hpIOStatus,
                   hpIOInfoLen
                  );
    Device_IO_Throttle_Decrement
    pCDBThread->ExchActive = agFALSE;
    fiSetEventRecord(eventRecord,thread,CDBEventThreadFree);
}

/*+
   Function: CDBActionOOOReceived

    Purpose: Place holder state for Out Of Order Data reception.
  Called By: None
      Calls: CDBEventOOOFixup
             
-*/
/*  CDBStateOOOReceived  13 */
extern void CDBActionOOOReceived( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "In %s - State = %d ALPA %X",
                    "CDBActionOOOReceived",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0);


    fiSetEventRecord(eventRecord,thread,CDBEventOOOFixup);
}

/*+
   Function: CDBActionOOOReceived

    Purpose: Place holder state for Out Of Order Data reception.
  Called By: None
      Calls: CDBEventOOOSend
             
-*/
/* CDBStateOOOFixup   14 */
extern void CDBActionOOOFixup( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "In %s - State = %d ALPA %X",
                    "CDBActionOOOFixup",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0);

    fiSetEventRecord(eventRecord,thread,CDBEventOOOSend);
}

/*+
   Function: CDBActionOOOSend

    Purpose: Place holder state for Out Of Order Data reception.
  Called By: None
      Calls: Terminating
             
-*/
/* CDBStateOOOSend   15 */
extern void CDBActionOOOSend( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "In %s - State = %d ALPA %X",
                    "CDBActionOOOSend",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);
}

/*+
   Function: CDBActionInitialize_DR

    Purpose: Place holder state for receiving  Device Reset Event .while in CDBActionInitialize
  Called By: None Not possible to be in this state at Device Reset time.
      Calls: osIOCompleted CDBEventThreadFree
            
             
-*/
/* CDBStateInitialize_DR   16 */
extern void CDBActionInitialize_DR( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;
    os_bit32 hpIOStatus      = pCDBThread->CompletionStatus;
    os_bit32 hpIOInfoLen = 0;

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "In %s - State = %d ALPA %X",
                    "CDBActionInitialize_DR",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0);

    if( osTimeStamp(thread->hpRoot)- pCDBThread->TimeStamp > TIMEOUT_VALUE ) /*1.6 ms per */
    {
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s IO timeout ALPA %X  X_ID %3X Time %d",
                    "DR I",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    osTimeStamp(thread->hpRoot)-pCDBThread->TimeStamp,
                    0,0,0,0,0);
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s Bytes %d TimeBase %d",
                    pCDBThread->ReadWrite ? "Write": "Read" ,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCDBThread->DataLength,
                    CThread_ptr(thread->hpRoot)->TimeBase.Lo -  pCDBThread->CDBStartTimeBase.Lo,
                    0,0,0,0,0,0);
    }

    osIOCompleted( thread->hpRoot,
                   pCDBThread->hpIORequest,
                   hpIOStatus,
                   hpIOInfoLen
                  );
    Device_IO_Throttle_Decrement
    pCDBThread->ExchActive = agFALSE;
    fiSetEventRecord(eventRecord,thread,CDBEventThreadFree);
}

/*+
   Function: CDBActionFillLocalSGL_DR

    Purpose: Place holder state for receiving Device Reset Event while in CDBActionFillLocalSGL_DR
  Called By: None Not possible to be in this state at Device Reset time.
      Calls: osIOCompleted CDBEventThreadFree
-*/
/* CDBStateFillLocalSGL_DR   17 */
extern void CDBActionFillLocalSGL_DR( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;
    os_bit32 hpIOStatus = osIODevReset;
    os_bit32 hpIOInfoLen = 0;

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "In %s - State = %d ALPA %X",
                    "CDBActionFillLocalSGL_DR",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0);

    if( osTimeStamp(thread->hpRoot)- pCDBThread->TimeStamp > TIMEOUT_VALUE ) /*1.6 ms per */
    {
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s IO timeout ALPA %X  X_ID %3X Time %d",
                    "DR LSGL",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    osTimeStamp(thread->hpRoot)-pCDBThread->TimeStamp,
                    0,0,0,0,0);
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s Bytes %d TimeBase %d",
                    pCDBThread->ReadWrite ? "Write": "Read" ,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCDBThread->DataLength,
                    CThread_ptr(thread->hpRoot)->TimeBase.Lo -  pCDBThread->CDBStartTimeBase.Lo,
                    0,0,0,0,0,0);
    }

    osIOCompleted( thread->hpRoot,
                   pCDBThread->hpIORequest,
                   hpIOStatus,
                   hpIOInfoLen
                  );
    Device_IO_Throttle_Decrement
    pCDBThread->ExchActive = agFALSE;
    fiSetEventRecord(eventRecord,thread,CDBEventThreadFree);
}

/*+
   Function: CDBActionAllocESGL_DR 

    Purpose: Place holder state for receiving Device Reset Event while in CDBActionAllocESGL
  Called By: None Not possible to be in this state at Device Reset time.
      Calls: osIOCompleted CDBEventThreadFree
-*/
/* CDBStateAllocESGL_DR   18 */
extern void CDBActionAllocESGL_DR( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;
    os_bit32 hpIOStatus = osIODevReset;
    os_bit32 hpIOInfoLen = 0;

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "In %s - State = %d ALPA %X",
                    "CDBActionAllocESGL_DR",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0);
/*
    ESGLAllocCancel(thread->hpRoot,&pCDBThread->ESGL_Request);
*/
    if( osTimeStamp(thread->hpRoot)- pCDBThread->TimeStamp > TIMEOUT_VALUE ) /*1.6 ms per */
    {
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s IO timeout ALPA %X  X_ID %3X Time %d",
                    "DR ESGL",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    osTimeStamp(thread->hpRoot)-pCDBThread->TimeStamp,
                    0,0,0,0,0);
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s Bytes %d TimeBase %d",
                    pCDBThread->ReadWrite ? "Write": "Read" ,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCDBThread->DataLength,
                    CThread_ptr(thread->hpRoot)->TimeBase.Lo -  pCDBThread->CDBStartTimeBase.Lo,
                    0,0,0,0,0,0);

    }

    osIOCompleted( thread->hpRoot,
                   pCDBThread->hpIORequest,
                   hpIOStatus,
                   hpIOInfoLen
                  );
    Device_IO_Throttle_Decrement
    pCDBThread->ExchActive = agFALSE;
    fiSetEventRecord(eventRecord,thread,CDBEventThreadFree);
}

/*+
   Function: CDBActionFillESGL_DR 

    Purpose: Place holder state for receiving Device Reset Event while in CDBActionFillESGL
  Called By: None Not possible to be in this state at Device Reset time.
      Calls: osIOCompleted CDBEventThreadFree
-*/
/*  CDBStateFillESGL_DR  19 */
extern void CDBActionFillESGL_DR( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;
    os_bit32 hpIOStatus = osIODevReset;
    os_bit32 hpIOInfoLen = 0;

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "In %s - State = %d ALPA %X",
                    "CDBActionFillESGL_DR",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0);

    if( osTimeStamp(thread->hpRoot)- pCDBThread->TimeStamp > TIMEOUT_VALUE ) /*1.6 ms per */
    {
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s IO timeout ALPA %X  X_ID %3X Time %d",
                    "DR F ESGL",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    osTimeStamp(thread->hpRoot)-pCDBThread->TimeStamp,
                    0,0,0,0,0);
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s Bytes %d TimeBase %d",
                    pCDBThread->ReadWrite ? "Write": "Read" ,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCDBThread->DataLength,
                    CThread_ptr(thread->hpRoot)->TimeBase.Lo -  pCDBThread->CDBStartTimeBase.Lo,
                    0,0,0,0,0,0);

    }

    osIOCompleted( thread->hpRoot,
                   pCDBThread->hpIORequest,
                   hpIOStatus,
                   hpIOInfoLen
                  );
    Device_IO_Throttle_Decrement
    pCDBThread->ExchActive = agFALSE;
    fiSetEventRecord(eventRecord,thread,CDBEventThreadFree);
}

/*+
   Function: CDBActionInitialize_Abort 

    Purpose: Place holder state for receiving abort Event while in CDBActionInitialize
  Called By: None Not possible to be in this state at Device Reset time.
      Calls: osIOCompleted CDBEventThreadFree
-*/
/* CDBStateInitialize_Abort   20 */
extern void CDBActionInitialize_Abort( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;
    os_bit32 hpIOStatus = osIOAborted;
    os_bit32 hpIOInfoLen = 0;

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "In %s - State = %d ALPA %X",
                    "CDBActionInitialize_Abort",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0);


    if( osTimeStamp(thread->hpRoot)- pCDBThread->TimeStamp > TIMEOUT_VALUE ) /*1.6 ms per */
    {
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s IO timeout ALPA %X  X_ID %3X Time %d",
                    "A I",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    osTimeStamp(thread->hpRoot)-pCDBThread->TimeStamp,
                    0,0,0,0,0);
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s Bytes %d TimeBase %d",
                    pCDBThread->ReadWrite ? "Write": "Read" ,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCDBThread->DataLength,
                    CThread_ptr(thread->hpRoot)->TimeBase.Lo -  pCDBThread->CDBStartTimeBase.Lo,
                    0,0,0,0,0,0);
    }

    osIOCompleted( thread->hpRoot,
                   pCDBThread->hpIORequest,
                   hpIOStatus,
                   hpIOInfoLen
                  );
    Device_IO_Throttle_Decrement
    pCDBThread->ExchActive = agFALSE;
    fiSetEventRecord(eventRecord,thread,CDBEventThreadFree);
}

/*+
   Function: CDBActionFillLocalSGL_Abort 

    Purpose: Place holder state for receiving abort Event while in CDBActionFillLocalSGL
  Called By: None Not possible to be in this state at Device Reset time.
      Calls: osIOCompleted CDBEventThreadFree
-*/
/* CDBStateFillLocalSGL_Abort  21 */
extern void CDBActionFillLocalSGL_Abort( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;
    os_bit32 hpIOStatus = osIOAborted;
    os_bit32 hpIOInfoLen = 0;

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "In %s - State = %d ALPA %X",
                    "CDBActionFillLocalSGL_Abort",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0);


    if( osTimeStamp(thread->hpRoot)- pCDBThread->TimeStamp > TIMEOUT_VALUE ) /*1.6 ms per */
    {
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s IO timeout ALPA %X  X_ID %3X Time %d",
                    "A FLSGL",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    osTimeStamp(thread->hpRoot)-pCDBThread->TimeStamp,
                    0,0,0,0,0);
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s Bytes %d TimeBase %d",
                    pCDBThread->ReadWrite ? "Write": "Read" ,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCDBThread->DataLength,
                    CThread_ptr(thread->hpRoot)->TimeBase.Lo -  pCDBThread->CDBStartTimeBase.Lo,
                    0,0,0,0,0,0);
    }

    osIOCompleted( thread->hpRoot,
                   pCDBThread->hpIORequest,
                   hpIOStatus,
                   hpIOInfoLen
                  );
    Device_IO_Throttle_Decrement
    pCDBThread->ExchActive = agFALSE;
    fiSetEventRecord(eventRecord,thread,CDBEventThreadFree);
}

/*+
   Function: CDBActionAllocESGL_Abort 

    Purpose: Place holder state for receiving abort Event while in CDBActionAllocESGL
  Called By: None Not possible to be in this state at Device Reset time.
      Calls: osIOCompleted CDBEventThreadFree
-*/
/* CDBStateAllocESGL_Abort   22 */
extern void CDBActionAllocESGL_Abort( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;
    os_bit32 hpIOStatus = osIOAborted;
    os_bit32 hpIOInfoLen = 0;

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "In %s - State = %d ALPA %X",
                    "CDBActionAllocESGL_Abort",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0);
    if( osTimeStamp(thread->hpRoot)- pCDBThread->TimeStamp > TIMEOUT_VALUE ) /*1.6 ms per */
    {
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s IO timeout ALPA %X  X_ID %3X Time %d",
                    "A ESGL",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    osTimeStamp(thread->hpRoot)-pCDBThread->TimeStamp,
                    0,0,0,0,0);
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s Bytes %d TimeBase %d",
                    pCDBThread->ReadWrite ? "Write": "Read" ,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCDBThread->DataLength,
                    CThread_ptr(thread->hpRoot)->TimeBase.Lo -  pCDBThread->CDBStartTimeBase.Lo,
                    0,0,0,0,0,0);
    }

    osIOCompleted( thread->hpRoot,
                   pCDBThread->hpIORequest,
                   hpIOStatus,
                   hpIOInfoLen
                  );
    Device_IO_Throttle_Decrement
    pCDBThread->ExchActive = agFALSE;
    fiSetEventRecord(eventRecord,thread,CDBEventThreadFree);
}

/*+
   Function: CDBActionFillESGL_Abort 

    Purpose: Place holder state for receiving abort Event while in CDBActionFillESGL
  Called By: None Not possible to be in this state at Device Reset time.
      Calls: osIOCompleted CDBEventThreadFree
-*/
/*  CDBStateFillESGL_Abort  23 */
extern void CDBActionFillESGL_Abort( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;
    os_bit32 hpIOStatus = osIOAborted;
    os_bit32 hpIOInfoLen = 0;

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "In %s - State = %d ALPA %X",
                    "CDBActionFillESGL_Abort",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0);


    if( osTimeStamp(thread->hpRoot)- pCDBThread->TimeStamp > TIMEOUT_VALUE ) /*1.6 ms per */
    {
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s IO timeout ALPA %X  X_ID %3X Time %d",
                    "A F ESGL",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    osTimeStamp(thread->hpRoot)-pCDBThread->TimeStamp,
                    0,0,0,0,0);
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s Bytes %d TimeBase %d",
                    pCDBThread->ReadWrite ? "Write": "Read" ,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCDBThread->DataLength,
                    CThread_ptr(thread->hpRoot)->TimeBase.Lo -  pCDBThread->CDBStartTimeBase.Lo,
                    0,0,0,0,0,0);
    }


    osIOCompleted( thread->hpRoot,
                   pCDBThread->hpIORequest,
                   hpIOStatus,
                   hpIOInfoLen
                  );
    Device_IO_Throttle_Decrement
    pCDBThread->ExchActive = agFALSE;
    fiSetEventRecord(eventRecord,thread,CDBEventThreadFree);
}

/*+
   Function: CDBActionOOOReceived_Abort 

    Purpose: Place holder state for receiving abort Event while in CDBActionOOOReceived
  Called By: None Not possible to be in this state at Device Reset time.
      Calls: osIOCompleted CDBEventThreadFree
-*/
/* CDBStateOOOReceived_Abort   24 */
extern void CDBActionOOOReceived_Abort( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;
    os_bit32 hpIOStatus = osIOAborted;
    os_bit32 hpIOInfoLen = 0;

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "In %s - State = %d ALPA %X",
                    "CDBActionOOOReceived_Abort",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0);

    if( osTimeStamp(thread->hpRoot)- pCDBThread->TimeStamp > TIMEOUT_VALUE ) /*1.6 ms per */
    {
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s IO timeout ALPA %X  X_ID %3X Time %d",
                    "A OOO",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    osTimeStamp(thread->hpRoot)-pCDBThread->TimeStamp,
                    0,0,0,0,0);
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s Bytes %d TimeBase %d",
                    pCDBThread->ReadWrite ? "Write": "Read" ,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCDBThread->DataLength,
                    CThread_ptr(thread->hpRoot)->TimeBase.Lo -  pCDBThread->CDBStartTimeBase.Lo,
                    0,0,0,0,0,0);
    }

    osIOCompleted( thread->hpRoot,
                   pCDBThread->hpIORequest,
                   hpIOStatus,
                   hpIOInfoLen
                  );
    Device_IO_Throttle_Decrement
    pCDBThread->ExchActive = agFALSE;
    fiSetEventRecord(eventRecord,thread,CDBEventThreadFree);
}

/*+
   Function: CDBActionOOOReceived_DR 

    Purpose: Place holder state for receiving Device Reset Event while in CDBActionOOOReceived
  Called By: None Not possible to be in this state at Device Reset time.
      Calls: osIOCompleted CDBEventThreadFree
-*/
/*  CDBStateOOOReceived_DR  25 */
extern void CDBActionOOOReceived_DR( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;
    os_bit32 hpIOStatus = osIODevReset;
    os_bit32 hpIOInfoLen = 0;

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "In %s - State = %d ALPA %X",
                    "CDBActionOOOReceived_DR",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0);

    if( osTimeStamp(thread->hpRoot)- pCDBThread->TimeStamp > TIMEOUT_VALUE ) /*1.6 ms per */
    {
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s IO timeout ALPA %X  X_ID %3X Time %d",
                    "DR OOO",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    osTimeStamp(thread->hpRoot)-pCDBThread->TimeStamp,
                    0,0,0,0,0);
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s Bytes %d TimeBase %d",
                    pCDBThread->ReadWrite ? "Write": "Read" ,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCDBThread->DataLength,
                    CThread_ptr(thread->hpRoot)->TimeBase.Lo -  pCDBThread->CDBStartTimeBase.Lo,
                    0,0,0,0,0,0);
    }

    osIOCompleted( thread->hpRoot,
                   pCDBThread->hpIORequest,
                   hpIOStatus,
                   hpIOInfoLen
                  );
    Device_IO_Throttle_Decrement
    pCDBThread->ExchActive = agFALSE;
    fiSetEventRecord(eventRecord,thread,CDBEventThreadFree);
}

/*+
   Function: CDBActionOOOFixup_Abort 

    Purpose: Place holder state for receiving abort Event while in CDBActionOOOFixup
  Called By: None Not possible to be in this state at Device Reset time.
      Calls: osIOCompleted CDBEventThreadFree
-*/
/* CDBStateOOOFixup_Abort   26 */
extern void CDBActionOOOFixup_Abort( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;
    os_bit32 hpIOStatus = osIOAborted;
    os_bit32 hpIOInfoLen = 0;

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "In %s - State = %d ALPA %X",
                    "CDBActionOOOFixup_Abort",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0);

    if( osTimeStamp(thread->hpRoot)- pCDBThread->TimeStamp > TIMEOUT_VALUE ) /*1.6 ms per */
    {
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s IO timeout ALPA %X  X_ID %3X Time %d",
                    "A F OOO",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    osTimeStamp(thread->hpRoot)-pCDBThread->TimeStamp,
                    0,0,0,0,0);
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s Bytes %d TimeBase %d",
                    pCDBThread->ReadWrite ? "Write": "Read" ,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCDBThread->DataLength,
                    CThread_ptr(thread->hpRoot)->TimeBase.Lo -  pCDBThread->CDBStartTimeBase.Lo,
                    0,0,0,0,0,0);
    }


    osIOCompleted( thread->hpRoot,
                   pCDBThread->hpIORequest,
                   hpIOStatus,
                   hpIOInfoLen
                  );
    Device_IO_Throttle_Decrement
    pCDBThread->ExchActive = agFALSE;
    fiSetEventRecord(eventRecord,thread,CDBEventThreadFree);
}

/*+
   Function: CDBActionOOOFixup_DR 

    Purpose: Place holder state for receiving Device Reset Event while in CDBActionOOOFixup
  Called By: None Not possible to be in this state at Device Reset time.
      Calls: osIOCompleted CDBEventThreadFree
-*/
/*  CDBStateOOOFixup_DR  27 */
extern void CDBActionOOOFixup_DR( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;
    os_bit32 hpIOStatus = osIODevReset;
    os_bit32 hpIOInfoLen = 0;

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "(%p)In %s - State = %d ALPA %X X_ID %X",
                    "CDBActionOOOFixup_DR",(char *)agNULL,
                    thread,agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    0,0,0,0,0);
    if( osTimeStamp(thread->hpRoot)- pCDBThread->TimeStamp > TIMEOUT_VALUE ) /*1.6 ms per */
    {
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s IO timeout ALPA %X  X_ID %3X Time %d",
                    "DR F OOO",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    osTimeStamp(thread->hpRoot)-pCDBThread->TimeStamp,
                    0,0,0,0,0);
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s Bytes %d TimeBase %d",
                    pCDBThread->ReadWrite ? "Write": "Read" ,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCDBThread->DataLength,
                    CThread_ptr(thread->hpRoot)->TimeBase.Lo -  pCDBThread->CDBStartTimeBase.Lo,
                    0,0,0,0,0,0);
    }

    osIOCompleted( thread->hpRoot,
                   pCDBThread->hpIORequest,
                   hpIOStatus,
                   hpIOInfoLen
                  );
    Device_IO_Throttle_Decrement
    pCDBThread->ExchActive = agFALSE;
    fiSetEventRecord(eventRecord,thread,CDBEventThreadFree);
}

/*+
   Function: CDBActionOutBoundError

    Purpose: Does completion on IO that have mismatch with request data length and actual data length.
  Called By: CFuncProcessFcpRsp CFuncSEST_ off / on Card_FCPCompletion
CFuncOutBoundCompletion
             CFuncCompleteAllActiveCDBThreads with CDBEventIODeviceReset
             CFuncCompleteActiveCDBThreadsOnDevice with CDBEventIODeviceReset
SFActionAbortAccept
             SFActionAbortRej
             SFActionAbortBadALPA
             SFActionAbortTimedOut
      Calls: osIOCompleted 
             CDBEventThreadFree
-*/
/*  CDBStateOutBoundError  28 */
extern void CDBActionOutBoundError( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;

    /* CThread_ptr(thread->hpRoot)->CDBpollingCount--; */

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "(%p)In %s - State = %d ALPA %X X_ID %X",
                    "CDBActionOutBoundError",(char *)agNULL,
                    thread,agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    0,0,0,0,0);
    if( osTimeStamp(thread->hpRoot)- pCDBThread->TimeStamp > TIMEOUT_VALUE ) /*1.6 ms per */
    {
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s IO timeout ALPA %X  X_ID %3X Time %d",
                    "Outbound",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    osTimeStamp(thread->hpRoot)-pCDBThread->TimeStamp,
                    0,0,0,0,0);
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s Bytes %d TimeBase %d",
                    pCDBThread->ReadWrite ? "Write": "Read" ,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCDBThread->DataLength,
                    CThread_ptr(thread->hpRoot)->TimeBase.Lo -  pCDBThread->CDBStartTimeBase.Lo,
                    0,0,0,0,0,0);
    }

    if (pCDBThread->ESGL_Request.State != ESGL_Request_InActive)
    {
        if (pCDBThread->ESGL_Request.State == ESGL_Request_Pending)
        {
            CThread_ptr(thread->hpRoot)->FuncPtrs.ESGLAllocCancel(
                                                thread->hpRoot,
                                                &(pCDBThread->ESGL_Request)
                                              );
        }
        else /* pCDBThread->ESGL_Request.State == ESGL_Request_Granted */
        {
            CThread_ptr(thread->hpRoot)->FuncPtrs.ESGLFree(
                                         thread->hpRoot,
                                         &(pCDBThread->ESGL_Request)
                                       );
        }
    }
    /* Resend OutboundError CDB's */
    fiSetEventRecord(eventRecord,thread,CDBEventInitialize);
}

/*+
   Function: CDBActionFailure_NO_RSP

    Purpose: Does completion on IO that have failed but do not have a response buffer.
  Called By: CFuncProcessFcpRsp CFuncSEST_ off / on Card_FCPCompletion
             CFuncOutBoundCompletion
      Calls: osIOCompleted 
             CDBEventThreadFree
-*/
/* CDBStateFailure_NO_RSP    29 */
extern void CDBActionFailure_NO_RSP( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;
    os_bit32 hpIOStatus = osIOFailed;
    os_bit32 hpIOInfoLen = 0;

    /* CThread_ptr(thread->hpRoot)->CDBpollingCount--; */
    fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "(%p)In %s - State = %d ALPA %X X_ID %X",
                    "CDBActionFailure_NO_RSP",(char *)agNULL,
                    thread,agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    0,0,0,0,0);

    if( osTimeStamp(thread->hpRoot)- pCDBThread->TimeStamp > TIMEOUT_VALUE ) /*1.6 ms per */
    {
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s IO timeout ALPA %X  X_ID %3X Time %d",
                    "F NR",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    osTimeStamp(thread->hpRoot)-pCDBThread->TimeStamp,
                    0,0,0,0,0);
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s Bytes %d TimeBase %d",
                    pCDBThread->ReadWrite ? "Write": "Read" ,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCDBThread->DataLength,
                    CThread_ptr(thread->hpRoot)->TimeBase.Lo -  pCDBThread->CDBStartTimeBase.Lo,
                    0,0,0,0,0,0);
    }

    osIOCompleted( thread->hpRoot,
                   pCDBThread->hpIORequest,
                   hpIOStatus,
                   hpIOInfoLen
                  );
    Device_IO_Throttle_Decrement
    pCDBThread->ExchActive = agFALSE;
    fiSetEventRecord(eventRecord,thread,CDBEventThreadFree);
}

/*+
   Function: CDBActionAlloc_Abort

    Purpose: Gets resources for aborting current CDBThread.
  Called By: CDBActionSend_REC_Second
             CFuncReadSFQ
             CFuncCheckActiveDuringLinkEvent
             DevActionExternalDeviceReset
             fcAbortIO
      Calls: SFThreadAlloc
-*/
/* CDBStateAlloc_Abort 30 */
extern void CDBActionAlloc_Abort( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread    = (CDBThread_t * )thread;
    DevThread_t * pDevThread    = pCDBThread->Device;

    fiLogDebugString(thread->hpRoot,
                    CDBStateAbortPathLevel,
                    "(%p)In %s - State = %d ALPA %X X_ID %X",
                    "CDBActionAlloc_Abort",(char *)agNULL,
                    thread,agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    0,0,0,0,0);


#ifdef ESGLCancelAllocAbortRequests
    if (pCDBThread->ESGL_Request.State != ESGL_Request_InActive)
    {
        if (pCDBThread->ESGL_Request.State == ESGL_Request_Pending)
        {
            CThread_ptr(thread->hpRoot)->FuncPtrs.ESGLAllocCancel(
                                                thread->hpRoot,
                                                &(pCDBThread->ESGL_Request)
                                              );
        }
        else /* pCDBThread->ESGL_Request.State == ESGL_Request_Granted */
        {
            CThread_ptr(thread->hpRoot)->FuncPtrs.ESGLFree(
                                         thread->hpRoot,
                                         &(pCDBThread->ESGL_Request)
                                       );
        }
    }

#endif /* ESGLCancelAllocAbortRequests */
    if( pCDBThread->SFThread_Request.State  != SFThread_Request_InActive )
    {
        fiLogDebugString(thread->hpRoot,
                        0,
                        "(%p)In %s - State = %d ALPA %X X_ID %X SF(%p) SFrS %x Ev %d!",
                        "CDBActionAlloc_Abort",(char *)agNULL,
                        thread,pCDBThread->SFThread_Request.SFThread,
                        (os_bit32)thread->currentState,
                        fiComputeDevThread_D_ID(pDevThread),
                        pCDBThread->X_ID,
                        (os_bit32)pCDBThread->SFThread_Request.State,
                        (os_bit32)pCDBThread->SFThread_Request.eventRecord_to_send.event,
                        0,0,0);

        fiSetEventRecord(eventRecord,thread,CDBEvent_PrepareforAbort);
        return;
    }
    pCDBThread->SFThread_Request.eventRecord_to_send.event = CDBEventDo_Abort;
    pCDBThread->SFThread_Request.eventRecord_to_send.thread = thread;

    fiSetEventRecordNull(eventRecord);
    SFThreadAlloc( thread->hpRoot, & pCDBThread->SFThread_Request );

}

/*+
   Function: CDBActionAlloc_Abort

    Purpose: Sends event to SFThread to aborting current CDBThread.
  Called By: SFThreadAlloc
      Calls: SFActionDoAbort
-*/
/* CDBStateDo_Abort        31  */
extern void CDBActionDo_Abort( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t     * pCDBThread    = (CDBThread_t * )thread;
    DevThread_t     * pDevThread    = pCDBThread->Device;
    SFThread_t      * pSFThread     = pCDBThread->SFThread_Request.SFThread;

    pSFThread->parent.CDB = pCDBThread;

    fiLogDebugString(thread->hpRoot,
                    CDBStateAbortPathLevel,
                    "(%p)In %s - State = %d ALPA %X X_ID %X",
                    "CDBActionDo_Abort",(char *)agNULL,
                    thread,agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);
    fiSetEventRecord(eventRecord,&pSFThread->thread_hdr,SFEventDoAbort);
}

/*+
   Function: CDBActionPending_Abort

    Purpose: Changes CDBThread execution so aborted IO only complete with aborted status .
  Called By: Many
      Calls: Terminating State
-*/
/* CDBStatePending_Abort        32  */
extern void CDBActionPending_Abort( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t     * pCDBThread    = (CDBThread_t * )thread;
    DevThread_t     * pDevThread    = pCDBThread->Device;

    fiLogDebugString(thread->hpRoot,
                    CDBStateAbortPathLevel,
                    "(%p)In %s - State = %d ALPA %X X_ID %X",
                    "CDBActionPending_Abort",(char *)agNULL,
                    thread,agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);

}

/*+
   Function: CDBActionPrepare_For_Abort

    Purpose: Changes CDBThread execution when waiting for alloc abort.
  Called By: Many
      Calls: Terminating State
-*/
/* CDBStatePrepare_For_Abort        33  */
extern void CDBActionPrepare_For_Abort( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t     * pCDBThread    = (CDBThread_t * )thread;
    DevThread_t     * pDevThread    = pCDBThread->Device;


    fiLogDebugString(thread->hpRoot,
                    CDBStateAbortPathLevel,
                    "(%p)In %s - State = %d ALPA %X X_ID %X",
                    "CDBActionPrepare_For_Abort",(char *)agNULL,
                    thread,agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    0,0,0,0,0);


    fiSetEventRecordNull(eventRecord);

}

/*+
   Function: CDBActionBuild_CCC_IO

    Purpose: Builds private CDB to Clear Check Condition.
  Called By: Not Used
      Calls: Not Used
-*/
/*  CDBStateBuild_CCC_IO              34           */
extern void CDBActionBuild_CCC_IO( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t        * hpRoot        = thread->hpRoot;
    CThread_t       * pCThread      = CThread_ptr(hpRoot);
    CDBThread_t     * pCDBThread    = (CDBThread_t * )thread;
    DevThread_t     * pDevThread    = pCDBThread->Device;
    os_bit8 x;
    X_ID_t       Masked_OX_ID;
    os_bit32        FCP_CMND_Offset = pCDBThread->FCP_CMND_Offset;
    FCHS_t      *FCHS            = pCDBThread->FCP_CMND_Ptr;
    os_bit8 * tmp8                 = (os_bit8 *)FCHS + sizeof(FCHS_t);
    os_bit32 * FCHSbit_32 = (os_bit32 * )FCHS; /* NW BUG */


    pCDBThread->CCC_pollingCount++;

    pCDBThread->ReadWrite  =  CDBThread_Write;
    pCDBThread->SG_Cache_Offset = 0;
    pCDBThread->SG_Cache_Used   = 0;

    if (pCThread->Calculation.MemoryLayout.FCP_CMND.memLoc == inCardRam)
    {
#ifndef __MemMap_Force_Off_Card__

        Masked_OX_ID = pCDBThread->X_ID;

        osCardRamWriteBlock(
                             hpRoot,
                             FCP_CMND_Offset,
                             (os_bit8 *)&(pDevThread->Template_FCHS),
                             sizeof(FCHS_t)
                           );

        osCardRamWriteBit32(
                             hpRoot,
                             FCP_CMND_Offset + hpFieldOffset(
                                                              FCHS_t,
                                                              OX_ID__RX_ID
                                                            ),
                             (  (Masked_OX_ID << FCHS_OX_ID_SHIFT)
                              | (0xFFFF << FCHS_RX_ID_SHIFT)      )
                           );
        /* Fill in CDB 0 for TUR */
        for(x=0; x < sizeof(agFcpCmnd_t); x++)
        {
            osCardRamWriteBit8(
                             hpRoot,
                             FCP_CMND_Offset + sizeof(FCHS_t)+x,
                             0 );
        }

        osCardRamWriteBit8(
                         hpRoot,
                         FCP_CMND_Offset + sizeof(FCHS_t)+1,
                         (os_bit8)pCDBThread->Lun );

        fiLogDebugString(hpRoot,
                        CStateLogConsoleShowSEST,
                        "FCP_CMND_Offset %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        FCP_CMND_Offset,
                        0,0,0,0,0,0,0);

        fiLogDebugString(hpRoot,
                        CStateLogConsoleShowSEST,
                        "FCP_CMND_Offset DWORD 0 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        osCardRamReadBit32(hpRoot,FCP_CMND_Offset + 0),
                        osCardRamReadBit32(hpRoot,FCP_CMND_Offset + 4),
                        osCardRamReadBit32(hpRoot,FCP_CMND_Offset + 8),
                        osCardRamReadBit32(hpRoot,FCP_CMND_Offset + 12),
                        osCardRamReadBit32(hpRoot,FCP_CMND_Offset + 16),
                        osCardRamReadBit32(hpRoot,FCP_CMND_Offset + 20),
                        osCardRamReadBit32(hpRoot,FCP_CMND_Offset + 24),
                        osCardRamReadBit32(hpRoot,FCP_CMND_Offset + 28));

#endif /* __MemMap_Force_Off_Card__ was not defined */
    }
    else /* CThread_ptr(CDBThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.FCP_CMND.memLoc == inDmaMemory */
    {
#ifndef __MemMap_Force_On_Card__

        Masked_OX_ID = (X_ID_t)(pCDBThread->X_ID | X_ID_Write);

        *FCHS              = pDevThread->Template_FCHS;

        FCHS->OX_ID__RX_ID =   (Masked_OX_ID << FCHS_OX_ID_SHIFT)
                             | (0xFFFF << FCHS_RX_ID_SHIFT);

        /* Fill in CDB 0 for TUR */
        for(x=0; x < sizeof(agFcpCmnd_t); x++)
        {
            *(tmp8+x) = 0;
        }
        *(tmp8 + 1) = (os_bit8) pCDBThread->Lun;

        fiLogDebugString(hpRoot,
                        CStateLogConsoleShowSEST,
                        "FCP_CMND_ptr %p",
                        (char *)agNULL,(char *)agNULL,
                        FCHSbit_32,agNULL,
                        0,0,0,0,0,0,0,0);

        fiLogDebugString(hpRoot,
                        CStateLogConsoleShowSEST,
                        "FCP_CMND_ptr DWORD 0 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        * (FCHSbit_32 + 0),
                        * (FCHSbit_32 + 4),
                        * (FCHSbit_32 + 8),
                        * (FCHSbit_32 + 12),
                        * (FCHSbit_32 + 16),
                        * (FCHSbit_32 + 20),
                        * (FCHSbit_32 + 24),
                        * (FCHSbit_32 + 28));


#endif /* __MemMap_Force_On_Card__ was not defined */

    }

    pCThread->FuncPtrs.fiFillInFCP_RESP(pCDBThread);
    pCThread->FuncPtrs.fiFillInFCP_SEST(pCDBThread);

#ifndef Performance_Debug

    fiLogDebugString(hpRoot,
                    CDBStateCCC_IOPathLevel,
                    "In %s - State = %d ALPA %X X_ID %X Lun %x",
                    "CDBActionBuild_CCC_IO",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    pCDBThread->Lun,
                    0,0,0,0);

#endif /* Performance_Debug */

    fiSetEventRecord(eventRecord,thread,CDBEvent_CCC_IO_Built);

}

/*+
   Function: CDBActionSend_CCC_IO

    Purpose: Sends private CDB to Clear Check Condition.
  Called By: Not Used but functional
      Calls: Not Used
-*/
/*  CDBStateSend_CCC_IO               35          */
extern void CDBActionSend_CCC_IO( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t        * hpRoot        = thread->hpRoot;
    CDBThread_t     * pCDBThread    = (CDBThread_t * )thread;
    DevThread_t     * pDevThread    = pCDBThread->Device;
    USE_t           * SEST          = &( pCDBThread->SEST_Ptr->USE);
    os_bit32             SEST_Offset   = pCDBThread->SEST_Offset;

    CThread_ptr(hpRoot)->FuncPtrs.WaitForERQ( hpRoot );

    CThread_ptr(hpRoot)->FuncPtrs.CDBFuncIRB_Init(pCDBThread);

    pCDBThread->TimeStamp =  osTimeStamp(hpRoot);

    ROLL(CThread_ptr(hpRoot)->HostCopy_ERQProdIndex,
        CThread_ptr(hpRoot)->Calculation.MemoryLayout.ERQ.elements);

    /* Big_Endian_code */
    SENDIO(hpRoot,CThread_ptr(hpRoot),thread,DoFuncCdbCmnd);

    fiSetEventRecordNull(eventRecord);

    if(SEST)
    {
        fiLogDebugString(hpRoot,
                        CStateLogConsoleShowSEST,
                        "SEST_Offset %08X X_ID %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        SEST_Offset,
                        pCDBThread->X_ID,
                        0,0,0,0,0,0);

        fiLogDebugString(hpRoot,
                        CStateLogConsoleShowSEST,
                        "Sest DWORD 0 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        SEST->Bits,
                        SEST->Unused_DWord_1,
                        SEST->Unused_DWord_2,
                        SEST->Unused_DWord_3,
                        SEST->LOC,
                        SEST->Unused_DWord_5,
                        SEST->Unused_DWord_6,
                        SEST->Unused_DWord_7);

        fiLogDebugString(hpRoot,
                        CStateLogConsoleShowSEST,
                        "Sest DWORD 8 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        SEST->Unused_DWord_8,
                        SEST->Unused_DWord_9,
                        SEST->First_SG.U32_Len,
                        SEST->First_SG.L32,
                        SEST->Second_SG.U32_Len,
                        SEST->Second_SG.L32,
                        SEST->Third_SG.U32_Len,
                        SEST->Third_SG.L32);
    }
    else
    {
        fiLogDebugString(hpRoot,
                        CStateLogConsoleShowSEST,
                        "SEST_Offset %08X X_ID %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        SEST_Offset,
                        pCDBThread->X_ID,
                        0,0,0,0,0,0);

        fiLogDebugString(hpRoot,
                        CStateLogConsoleShowSEST,
                        "Sest DWORD 0 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Bits))),
                        osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Unused_DWord_1))),
                        osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Unused_DWord_2))),
                        osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Unused_DWord_3))),
                        osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,LOC))),
                        osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Unused_DWord_5))),
                        osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Unused_DWord_6))),
                        osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Unused_DWord_7))));


        fiLogDebugString(hpRoot,
                        CStateLogConsoleShowSEST,
                        "Sest DWORD 8 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Unused_DWord_8))),
                        osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Unused_DWord_9))),
                        osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,First_SG))),
                        osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,First_SG))+4),
                        osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Second_SG))),
                        osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Second_SG))+4),
                        osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Third_SG))),
                        osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Third_SG))+4));

    }

    fiLogDebugString(hpRoot,
                    CDBStateCCC_IOPathLevel,
                    "In %s - State = %d ALPA %X X_ID %X BitMask %X",
                    "CDBActionSend_CCC_IO",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    pDevThread->Lun_Active_Bitmask,
                    0,0,0,0);
}

/*+
   Function: CDBAction_CCC_IO_Success

    Purpose: Completion on private CDB to Clear Check Condition.
  Called By: Not Used but functional
      Calls: Not Used
-*/
/*   CDBState_CCC_IO_Success           36         */
extern void CDBAction_CCC_IO_Success( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t     * pCDBThread    = (CDBThread_t * )thread;
    DevThread_t     * pDevThread    = pCDBThread->Device;

    pCDBThread->CCC_pollingCount--;

    fiLogDebugString(thread->hpRoot,
                    CDBStateCCC_IOPathLevel,
                    "In %s - State = %d ALPA %X X_ID %X BitMask %X Lun %x",
                    "CDBAction_CCC_IO_Success",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    pDevThread->Lun_Active_Bitmask,
                    pCDBThread->Lun,
                    0,0,0);
    pCDBThread->ExchActive = agFALSE;
    fiSetEventRecord(eventRecord,thread,CDBEventThreadFree);

}

/*+
   Function: CDBAction_CCC_IO_Fail

    Purpose: Completion on private CDB to Clear Check Condition.
  Called By: Not Used but functional
      Calls: Not Used
-*/
/* CDBState_CCC_IO_Fail              37           */
extern void CDBAction_CCC_IO_Fail( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t     * pCDBThread    = (CDBThread_t * )thread;
    DevThread_t     * pDevThread    = pCDBThread->Device;

    pCDBThread->CCC_pollingCount--;

    pDevThread->Lun_Active_Bitmask &=  ~ (1 <<  pCDBThread->Lun);

    fiLogDebugString(thread->hpRoot,
                    CDBStateCCC_IOPathLevel,
                    "In %s - State = %d ALPA %X X_ID %X BitMask %X Lun %x",
                    "CDBAction_CCC_IO_Fail",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    pDevThread->Lun_Active_Bitmask,
                    pCDBThread->Lun,
                    0,0,0);
    pCDBThread->ExchActive = agFALSE;
    fiSetEventRecord(eventRecord,thread,CDBEventThreadFree);

}

/****************** FC Tape ******************************************/

/*+
   Function: CDBAction_Alloc_REC

    Purpose: Allocates REC ELS for FCTape recovery.
  Called By: CFuncReadSFQ
             CFuncFC_Tape
      Calls: SFThreadAlloc
-*/

/* CDBState_Alloc_REC                45            */
extern void CDBAction_Alloc_REC(fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t *   pCDBThread =    (CDBThread_t * )thread;
    DevThread_t *   pDevThread =    pCDBThread->Device;

    fiLogString(thread->hpRoot,
                    "(%p) %s St %d %s ALPA %X X_ID %X",
                    "CDBAction_Alloc_REC",pCDBThread->ReadWrite ? "Write": "Read",
                    thread,agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    0,0,0,0,0);

    fiLogString(thread->hpRoot,
                    "CDB Cl %2X Ty %2X St %2X Stat %2X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)pCDBThread->CDB_CMND_Class,
                    (os_bit32)pCDBThread->CDB_CMND_Type,
                    (os_bit32)pCDBThread->CDB_CMND_State,
                    (os_bit32)pCDBThread->CDB_CMND_Status,
                    0,0,0,0);

    pCDBThread->FC_Tape_Active  = agTRUE;
    pCDBThread->CDB_CMND_Class  = SFThread_SF_CMND_Class_FC_Tape;
    pCDBThread->CDB_CMND_Type   = SFThread_SF_CMND_Type_CDB_FC_Tape;
    pCDBThread->CDB_CMND_State  = SFThread_SF_CMND_State_CDB_FC_Tape_AllocREC;
    pCDBThread->CDB_CMND_Status = SFThread_SF_CMND_Status_NULL;


    pCDBThread->FC_Tape_REC_Reject_Count = 0;
    pCDBThread->FC_Tape_ExchangeStatusBlock= 0,
    pCDBThread->FC_Tape_Active = agTRUE;
    pCDBThread->FC_Tape_HBA_Has_SequenceInitiative = 0;
    pCDBThread->FC_Tape_CompletionStatus = 0;

    pCDBThread->SFThread_Request.eventRecord_to_send.event = CDBEvent_Got_REC;
    pCDBThread->SFThread_Request.eventRecord_to_send.thread = thread;

    fiSetEventRecordNull(eventRecord);
    SFThreadAlloc( thread->hpRoot, &pCDBThread->SFThread_Request );
}

/*+
   Function: CDBActionSend_REC

    Purpose: Send REC ELS for FCTape recovery.
  Called By: SFThreadAlloc / CDBAction_Alloc_REC
             
      Calls: SFActionDoREC
-*/
/*  CDBStateSend_REC                  38            */
extern void CDBActionSend_REC(fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t    * hpRoot     =   thread->hpRoot;
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread =  pCDBThread->Device;
    SFThread_t  * pSFThread  =  pCDBThread->SFThread_Request.SFThread;
    FCHS_t      * FCHS       =  pCDBThread->FCP_CMND_Ptr;
    USE_t       * SEST       = &( pCDBThread->SEST_Ptr->USE);

    fiLogString(hpRoot,
                    "(%p) %s St %d ALPA %X X_ID %X SF %p R_CT %08X RX %08X",
                    "CDBActionSend_REC",(char *)agNULL,
                    thread,pSFThread,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    FCHS->R_CTL__D_ID,
                    SEST->Unused_DWord_6,
                    0,0,0);


    if( pCDBThread->SFThread_Request.SFThread->thread_hdr.currentState == SFStateDoREC )
    {
        fiLogString(hpRoot,
                        "%s - Currently Active !!!",
                        "CDBActionSend_REC",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);
        fiSetEventRecordNull(eventRecord);
        return;
    }

/*  Last resort.......
    CFuncFreezeFCP( hpRoot );
    CFuncWaitForFCP( hpRoot );
*/
    pSFThread->parent.CDB = pCDBThread; 

    fiSetEventRecord(eventRecord,&pSFThread->thread_hdr,SFEventDoREC);
}

/*+
   Function: CDBActionSend_REC_Second

    Purpose: Sends REC ELS multiple REC could be sent, the CDBThead bounce back a forth  
             between this function and CDBActionSend_REC.
  Called By: SFThreadAlloc / CDBAction_Alloc_REC
             
      Calls: SFActionDoREC
-*/
/*  CDBStateSend_REC_Second           39              */
extern void CDBActionSend_REC_Second(fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t    * hpRoot     =   thread->hpRoot;
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;
    SFThread_t  * pSFThread  = pCDBThread->SFThread_Request.SFThread;
    FCHS_t      * FCHS       = pCDBThread->FCP_CMND_Ptr;
    USE_t       * SEST       = &( pCDBThread->SEST_Ptr->USE);

    pCDBThread->FC_Tape_RXID  = SEST->Unused_DWord_6;

    pCDBThread->CDB_CMND_State = SFThread_SF_CMND_State_CDB_FC_Tape_REC2;

    fiLogString(hpRoot,
                    "In %s St %d ALPA %X X_ID %X R_CTL %08X",
                    "CDBASR_S",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    FCHS->R_CTL__D_ID,
                    0,0,0,0);

    if( pCDBThread->SFThread_Request.SFThread->thread_hdr.currentState == SFStateRECRej )
    {
        /* If the REC is rejected the target did not get the command */
        pCDBThread->FC_Tape_REC_Reject_Count ++;
        if( pCDBThread->FC_Tape_REC_Reject_Count > 2 )
        {
                fiLogString(hpRoot,
                            "%s %s %d R_CTL %08X",
                            "CDBASRS","FC_TRRC",
                            (void *)agNULL,(void *)agNULL,
                            pCDBThread->FC_Tape_REC_Reject_Count,
                            FCHS->R_CTL__D_ID,
                            0,0,0,0,0,0);
            pCDBThread->FC_Tape_CompletionStatus =  CdbCompetionStatusReSendIO;
            SFThreadFree(thread->hpRoot, &pCDBThread->SFThread_Request );
            fiSetEventRecord(eventRecord,thread,CDBEventAlloc_Abort);
            return;
        }
    }
    fiSetEventRecord(eventRecord,&pSFThread->thread_hdr,SFEventDoREC);

/*
    fiSetEventRecord(eventRecord,thread,CDBEventSendREC_Success);
  
    fiSetEventRecordNull(eventRecord);
*/
}

/*+
   Function: CDBAction_REC_Success

    Purpose: Detrimines next action in fctape recovery.
  Called By: SFActionRECAccept 
             
      Calls: CDBStateSend_SRR or terminates
-*/
/* CDBState_REC_Success              42             */
extern void CDBAction_REC_Success(fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t    * hpRoot        = thread->hpRoot;
    CDBThread_t *   pCDBThread  = (CDBThread_t * )thread;
    DevThread_t *   pDevThread  = pCDBThread->Device;
    USE_t       *   SEST        = &( pCDBThread->SEST_Ptr->USE);
    os_bit32        SEST_Offset = pCDBThread->SEST_Offset;
    FCHS_t      * FCHS          = pCDBThread->FCP_CMND_Ptr;

    pCDBThread->FC_Tape_RXID    = SEST->Unused_DWord_6;

    fiLogString(hpRoot,
                    "%s S %d ALPA %X X_ID %X ESB %08X R_CTL %08X",
                    "CDBAction_REC_Success",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    pCDBThread->FC_Tape_ExchangeStatusBlock,
                    FCHS->R_CTL__D_ID,
                    0,0,0);

    fiLogString(hpRoot,
                    "Dev %02X Cl %2X Ty %2X St %2X Stat %2X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                    (os_bit32)pCDBThread->CDB_CMND_Class,
                    (os_bit32)pCDBThread->CDB_CMND_Type,
                    (os_bit32)pCDBThread->CDB_CMND_State,
                    (os_bit32)pCDBThread->CDB_CMND_Status,
                    0,0,0);

    if( pCDBThread->FC_Tape_ExchangeStatusBlock )
    {

       fiLogString(hpRoot,
                        "pCDBThread Direction  %s ",
                        pCDBThread->ReadWrite & CDBThread_Write ? "CDBThread_Write": "CDBThread_Read" ,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);

        fiLogString(hpRoot,
                        "FC_Tape_ExchangeStatusBlock %s Owner %s",
                        pCDBThread->FC_Tape_ExchangeStatusBlock & FC_REC_ESTAT_ESB_OWNER_Responder          ? "Responder": "Originator" ,
                        pCDBThread->FC_Tape_ExchangeStatusBlock & FC_REC_ESTAT_SequenceInitiativeThisPort ? "This Port": "Other Port" ,
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);
        fiLogString(hpRoot,
                        "FC_Tape_ExchangeStatusBlock Exchange %s Ending %s",
                        pCDBThread->FC_Tape_ExchangeStatusBlock & FC_REC_ESTAT_ExchangeCompletion      ? "Complete" : "Open" ,
                        pCDBThread->FC_Tape_ExchangeStatusBlock & FC_REC_ESTAT_EndingConditionAbnormal ? "Abnormal": "Normal" ,
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);
        fiLogString(hpRoot,
                        "FC_Tape_ExchangeStatusBlock Error  %s  RQ %s",
                        pCDBThread->FC_Tape_ExchangeStatusBlock & FC_REC_ESTAT_ErrorTypeAbnormal       ? "Abnormal Termination" : "ABTX" ,
                        pCDBThread->FC_Tape_ExchangeStatusBlock & FC_REC_ESTAT_RecoveryQualiferActive   ? "Recovery Qualifer Active" : "None" ,
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);

        fiLogString(hpRoot,
                        "FC_Tape_ExchangeStatusBlock Policy %s  ( %08X) ",
                        pCDBThread->FC_Tape_ExchangeStatusBlock & FC_REC_ESTAT_ExchangePolicy_DiscardMultipleRetry ? "Retransmit"  : "Discard " ,
                        (char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        pCDBThread->FC_Tape_ExchangeStatusBlock & FC_REC_ESTAT_ExchangePolicy_MASK,
                        0,0,0,0,0,0,0);

    }
    if( pCDBThread->FC_Tape_ExchangeStatusBlock )
    {
        if(pCDBThread->ReadWrite & CDBThread_Write )
        {
            if( pCDBThread->FC_Tape_ExchangeStatusBlock & FC_REC_ESTAT_ESB_OWNER_Responder )
            {
                if( FC_REC_ESTAT_SequenceInitiativeThisPort & ~pCDBThread->FC_Tape_ExchangeStatusBlock)
                {
                    pCDBThread->FC_Tape_HBA_Has_SequenceInitiative++;
                }
            }
        }
    }

    if(SEST)
    {
        fiLogString(hpRoot,
                        "SEST_Offset %08X X_ID %08X",
                        (char *)NULL,(char *)NULL,
                        (void *)agNULL,(void *)agNULL,
                        SEST_Offset,
                        pCDBThread->X_ID,
                        0,0,0,0,0,0);

        fiLogString(hpRoot,
                        "Sest0 %08X %08X %08X %08X %08X %08X %08X %08X",
                        (char *)NULL,(char *)NULL,
                        (void *)agNULL,(void *)agNULL,
                        SEST->Bits,
                        SEST->Unused_DWord_1,
                        SEST->Unused_DWord_2,
                        SEST->Unused_DWord_3,
                        SEST->LOC,
                        SEST->Unused_DWord_5,
                        SEST->Unused_DWord_6,
                        SEST->Unused_DWord_7);

        fiLogString(hpRoot,
                        "Sest8 %08X %08X %08X %08X %08X %08X %08X %08X",
                        (char *)NULL,(char *)NULL,
                        (void *)agNULL,(void *)agNULL,
                        SEST->Unused_DWord_8,
                        SEST->Unused_DWord_9,
                        SEST->First_SG.U32_Len,
                        SEST->First_SG.L32,
                        SEST->Second_SG.U32_Len,
                        SEST->Second_SG.L32,
                        SEST->Third_SG.U32_Len,
                        SEST->Third_SG.L32);
    }

    if( pCDBThread->FC_Tape_HBA_Has_SequenceInitiative < 1 )
    {
        fiSetEventRecordNull(eventRecord);
    }
    else
    {
        fiLogString(hpRoot,
                        "%s - %s %d",
                        "CDBARS","FC_Tape_HBA_Has_SequenceInitiative",
                        (void *)agNULL,(void *)agNULL,
                        pCDBThread->FC_Tape_HBA_Has_SequenceInitiative,
                        0,0,0,0,0,0,0);
        /*

        pCDBThread->FC_Tape_CompletionStatus =  CdbCompetionStatusReSendIO;
        SFThreadFree(thread->hpRoot, &pCDBThread->SFThread_Request );
        fiSetEventRecord(eventRecord,thread,CDBEventAlloc_Abort);
        */
        fiSetEventRecord(eventRecord,thread,CDBEventSendSRR);

    }
}

/*+
   Function: CDBActionSend_SRR

    Purpose: Detrimines next action in fctape recovery.
  Called By: CDBAction_REC_Success 
             
      Calls: SFActionDoSRR or terminates if SRR is active
-*/
/*  CDBStateSend_SRR                  40            */
extern void CDBActionSend_SRR(fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t    * hpRoot     =   thread->hpRoot;
    CDBThread_t * pCDBThread =  (CDBThread_t * )thread;
    DevThread_t * pDevThread =  pCDBThread->Device;
    SFThread_t  * pSFThread  =  pCDBThread->SFThread_Request.SFThread;
    FCHS_t      * FCHS       =  pCDBThread->FCP_CMND_Ptr;
    USE_t       * SEST       = &( pCDBThread->SEST_Ptr->USE);

    pCDBThread->CDB_CMND_State = SFThread_SF_CMND_State_CDB_FC_Tape_SRR;

    fiLogString(hpRoot,
                    "%s St %d ALPA %X X_ID %X R_CTL %08X",
                    "CDBASSRR",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    FCHS->R_CTL__D_ID,
                    0,0,0,0);

    if(SEST)
    {

        fiLogString(hpRoot,
                        "Sest0 %08X %08X %08X %08X %08X %08X %08X %08X",
                        (char *)NULL,(char *)NULL,
                        (void *)agNULL,(void *)agNULL,
                        SEST->Bits,
                        SEST->Unused_DWord_1,
                        SEST->Unused_DWord_2,
                        SEST->Unused_DWord_3,
                        SEST->LOC,
                        SEST->Unused_DWord_5,
                        SEST->Unused_DWord_6,
                        SEST->Unused_DWord_7);

        fiLogString(hpRoot,
                        "Sest8 %08X %08X %08X %08X %08X %08X  %08X  %08X",
                        (char *)NULL,(char *)NULL,
                        (void *)agNULL,(void *)agNULL,
                        SEST->Unused_DWord_8,
                        SEST->Unused_DWord_9,
                        SEST->First_SG.U32_Len,
                        SEST->First_SG.L32,
                        SEST->Second_SG.U32_Len,
                        SEST->Second_SG.L32,
                        SEST->Third_SG.U32_Len,
                        SEST->Third_SG.L32);
    }


    if( pCDBThread->SFThread_Request.SFThread->thread_hdr.currentState == SFStateDoSRR )
    {
        fiLogString(hpRoot,
                        "%s - Currently Active !!!",
                        "CDBActionSend_SRR",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);
        fiSetEventRecordNull(eventRecord);
        return;
    }

    fiSetEventRecord(eventRecord,&pSFThread->thread_hdr,SFEventDoSRR);
  
/*
    fiSetEventRecord(eventRecord,thread,CDBEventSendSRR_Success);
    fiSetEventRecordNull(eventRecord);
*/
}

/*+
   Function: CDBActionSend_SRR_Second

    Purpose: If first SRR Fails try again.
  Called By: CDBState_SRR_Fail 
             
      Calls: SFActionDoSRR 
-*/
/*  CDBStateSend_SRR_Second           41           */
extern void CDBActionSend_SRR_Second(fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t    * hpRoot     =   thread->hpRoot;
    CDBThread_t *   pCDBThread =    (CDBThread_t * )thread;
    DevThread_t *   pDevThread =    pCDBThread->Device;
    SFThread_t  *   pSFThread  =    pCDBThread->SFThread_Request.SFThread;
    FCHS_t      * FCHS       =  pCDBThread->FCP_CMND_Ptr;


    pCDBThread->CDB_CMND_State = SFThread_SF_CMND_State_CDB_FC_Tape_SRR2;

        fiLogString(hpRoot,
                    "%s St %d ALPA %X X_ID %X R_CTL %08X",
                    "CDBASSRS",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    FCHS->R_CTL__D_ID,
                    0,0,0,0);

    fiSetEventRecord(eventRecord,&pSFThread->thread_hdr,SFEventDoSRR);

  
/*
    fiSetEventRecordNull(eventRecord);
*/
}

/*+
   Function: CDBAction_SRR_Success

    Purpose: If SRR succedes wait for next action.
  Called By: SFActionSRRAccept 
             
      Calls: Terminates 
-*/
/*  CDBState_SRR_Success              43            */
extern void CDBAction_SRR_Success(fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t    * hpRoot     =   thread->hpRoot;
    CDBThread_t *   pCDBThread =    (CDBThread_t * )thread;
    DevThread_t *   pDevThread =    pCDBThread->Device;

    fiLogString(hpRoot,
                    "%s St %d ALPA %X X_ID %X",
                    "CDBASRR_S",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    0,0,0,0,0);


    if( (pCDBThread->FC_Tape_ExchangeStatusBlock )  == FC_REC_ESTAT_ESB_OWNER_Responder)
    {
        if(pCDBThread->CDB_CMND_State != SFThread_SF_CMND_State_CDB_FC_Tape_ReSend)
        {
            /* pCDBThread->CDB_CMND_State = SFThread_SF_CMND_State_CDB_FC_Tape_ReSend; */
            fiSetEventRecordNull(eventRecord);

        }
        else
        {
            /* pCDBThread->CDB_CMND_Status  = SFThread_SF_CMND_Status_CDB_FC_TapeTargetReSendData;
               fiSetEventRecord(eventRecord,thread,CDBEvent_ResendIO);
            */
            fiSetEventRecordNull(eventRecord);
        }
    }
    else
    {
        /* pCDBThread->CDB_CMND_Status  = SFThread_SF_CMND_Status_CDB_FC_TapeGet_RSP;
        */        
        fiSetEventRecordNull(eventRecord);
    }
}

/*+
   Function: CDBAction_SRR_Fail

    Purpose: If SRR failed try it again.
  Called By: SFActionSRRRej
             SFActionSRRTimedOut
             SFActionSRRBadALPA
          
      Calls: SFActionDoSRR 
-*/
/* CDBState_SRR_Fail                 44            */
extern void CDBAction_SRR_Fail(fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t    * hpRoot     =   thread->hpRoot;
    CDBThread_t *   pCDBThread =    (CDBThread_t * )thread;
    DevThread_t *   pDevThread =    pCDBThread->Device;
    SFThread_t  *   pSFThread  =    pCDBThread->SFThread_Request.SFThread;

    fiLogString(hpRoot,
                    "%s St %d ALPA %X X_ID %X",
                    "CDBA_SRR_F",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pSFThread->thread_hdr,SFEventDoSRR);

}

/*+
   Function: CDBActionDO_Nothing

    Purpose: Unused state
  Called By: None
          
      Calls: Terminates
-*/
/*   CDBStateDO_Nothing           46      */
extern void CDBActionDO_Nothing( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t    * hpRoot     =   thread->hpRoot;
    CDBThread_t     * pCDBThread    = (CDBThread_t * )thread;
    DevThread_t     * pDevThread    = pCDBThread->Device;

        fiLogString(hpRoot,
                    "%s St %d ALPA %X X_ID %X",
                    "CDBADO_N",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);
}

/*+
   Function: CDBActionReSend_IO

    Purpose: Frees resources from CDBThread for resend
  Called By: CFuncReadSFQ
             CDBActionFcpCompleteAbort          

      Calls: CDBActionInitialize
-*/
/*   CDBStateReSend_IO   47      */
extern void CDBActionReSend_IO( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t     * pCDBThread    = (CDBThread_t * )thread;
    DevThread_t     * pDevThread    = pCDBThread->Device;

    fiLogString(thread->hpRoot,
                    "%s St %d ALPA %X X_ID %X",
                    "CDBARS_IO",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    0,0,0,0,0);

    fiLogString(thread->hpRoot,
                    "Dev %02X  Cl %2X Ty %2X St %2X Stat %2X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                    (os_bit32)pCDBThread->CDB_CMND_Class,
                    (os_bit32)pCDBThread->CDB_CMND_Type,
                    (os_bit32)pCDBThread->CDB_CMND_State,
                    (os_bit32)pCDBThread->CDB_CMND_Status,
                    0,0,0);


    pCDBThread->ReSentIO = agTRUE;

    if (pCDBThread->ESGL_Request.State != ESGL_Request_InActive)
    {
        if (pCDBThread->ESGL_Request.State == ESGL_Request_Pending)
        {
            CThread_ptr(thread->hpRoot)->FuncPtrs.ESGLAllocCancel(
                                               thread->hpRoot,
                                               &(pCDBThread->ESGL_Request)
                                             );
        }
        else /* CDBThread->ESGL_Request.State == ESGL_Request_Granted */
        {
            CThread_ptr(thread->hpRoot)->FuncPtrs.ESGLFree(
                                        thread->hpRoot,
                                        &(pCDBThread->ESGL_Request)
                                      );
        }
    }

    if (pCDBThread->SFThread_Request.State != SFThread_Request_InActive)
    {
        if (pCDBThread->SFThread_Request.State == SFThread_Request_Pending)
        {
            SFThreadAllocCancel(
                                 thread->hpRoot,
                                 &(pCDBThread->SFThread_Request)
                               );
        }
        else /* CDBThread->SFThread_Request.State == SFThread_Request_Granted */
        {
            fiLogString(thread->hpRoot,
                            "In %s - SF %p SFState = %d CCnt %x",
                            "CDBAReSend_IO",(char *)agNULL,
                            pCDBThread->SFThread_Request.SFThread,agNULL,
                            (os_bit32)pCDBThread->SFThread_Request.SFThread->thread_hdr.currentState,
                            CThread_ptr(thread->hpRoot)->CDBpollingCount,
                            0,0,0,0,0,0);

            SFThreadFree( thread->hpRoot,&(pCDBThread->SFThread_Request) );
        }
    }

    if (pCDBThread->Timer_Request.Active == agTRUE)
    {
        fiTimerStop(
                     &(pCDBThread->Timer_Request)
                   );
    }

    /* CThread_ptr(thread->hpRoot)->CDBpollingCount--; */

    fiListDequeueThis( &(pCDBThread->CDBLink) );

    fiListEnqueueAtTail( &(pCDBThread->CDBLink),  &(pDevThread->Active_CDBLink_0) );

    fiSetEventRecord(eventRecord,thread,CDBEventInitialize);

}

/******************End FC Tape ******************************************/

/*+
   Function: CDBFuncIRB_onCardInit

    Purpose: On card memory version of Initialize IRB (IO request Block) in 
             the ERQ (Exchange Request Queue)
  Called By: CDBActionSendIo

      Calls: None
-*/
void CDBFuncIRB_onCardInit(CDBThread_t  * CDBThread )
{
#ifndef __MemMap_Force_Off_Card__
    agRoot_t                   * hpRoot    = CDBThread->thread_hdr.hpRoot;
    CThread_t                  * CThread   = CThread_ptr(hpRoot);
    DevThread_t                * DevThread = CDBThread->Device;
    fiMemMapMemoryDescriptor_t * ERQ       = &(CThread->Calculation.MemoryLayout.ERQ);
    os_bit32                     Irb_offset;
    os_bit32                     D_ID;

    D_ID = DevThread->DevInfo.CurrentAddress.Domain << 16
            | DevThread->DevInfo.CurrentAddress.Area   <<  8
            | DevThread->DevInfo.CurrentAddress.AL_PA;

    Irb_offset = ERQ->addr.CardRam.cardRamOffset;

    Irb_offset += ERQ->elementSize * CThread->HostCopy_ERQProdIndex;

    osCardRamWriteBit32(hpRoot,
                    Irb_offset, /*Req_A.Bits__SFS_Len */
                    (sizeof(agCDBRequest_t)+32) | IRB_SFA | IRB_DCM);

    osCardRamWriteBit32(hpRoot,
                    Irb_offset+4, /*Req_A.SFS_Addr */
                    CDBThread->FCP_CMND_Lower32);

    osCardRamWriteBit32(hpRoot,
                    Irb_offset+8, /* Req_A.D_ID  */
                    D_ID << IRB_D_ID_SHIFT);
    osCardRamWriteBit32(hpRoot,
                    Irb_offset+12, /* Req_A.MBZ__SEST_Index__Trans_ID */
                    CDBThread->X_ID);
    osCardRamWriteBit32(hpRoot,
                    Irb_offset+16, /*     pIrb->Req_B.Bits__SFS_Len */
                    0);
#endif /* __MemMap_Force_Off_Card__ was not defined */
    }

/*+
   Function: CDBFuncIRB_offCardInit

    Purpose: Off card (system )memory version of Initialize IRB (IO request Block) in 
             the ERQ (Exchange Request Queue)
  Called By: CDBActionSendIo

      Calls: None
-*/
void CDBFuncIRB_offCardInit(CDBThread_t  * CDBThread )
{
#ifndef __MemMap_Force_On_Card__
    CThread_t                  *CThread = CThread_ptr(CDBThread->thread_hdr.hpRoot);
    DevThread_t               *DevThread= CDBThread->Device;
    fiMemMapMemoryDescriptor_t *ERQ     = &(CThread->Calculation.MemoryLayout.ERQ);
    IRB_t                      *pIrb;
    os_bit32                    D_ID;

    D_ID = DevThread->DevInfo.CurrentAddress.Domain << 16
            | DevThread->DevInfo.CurrentAddress.Area   <<  8
            | DevThread->DevInfo.CurrentAddress.AL_PA;

    pIrb = (IRB_t *)ERQ->addr.DmaMemory.dmaMemoryPtr;
    pIrb += CThread->HostCopy_ERQProdIndex;


    pIrb->Req_A.Bits__SFS_Len   = (sizeof(agCDBRequest_t)+32) | IRB_SFA | IRB_DCM;

    pIrb->Req_A.SFS_Addr                 = CDBThread->FCP_CMND_Lower32;
    pIrb->Req_A.D_ID                      = D_ID << IRB_D_ID_SHIFT;
    pIrb->Req_A.MBZ__SEST_Index__Trans_ID = CDBThread->X_ID;
    pIrb->Req_B.Bits__SFS_Len = 0;
#endif /* __MemMap_Force_On_Card__ was not defined */
}

/*+
   Function: fill_Loc_SGL_offCard

    Purpose: Off card (system )memory version to set IO buffers using only 
             local Scatter Gather
             
  Called By: CDBActionFillLocalSGL

      Calls: None
-*/
void fill_Loc_SGL_offCard(CDBThread_t * pCDBThread)
{
#ifndef __MemMap_Force_On_Card__
    SG_Element_t *LSGL_Ptr      = &(pCDBThread->SEST_Ptr->USE.First_SG);
    os_bit32         SG_Cache_Used = pCDBThread->SG_Cache_Used;
    SG_Element_t *SG_Cache_Ptr  = &(pCDBThread->SG_Cache[0]);

#ifndef Performance_Debug
    fiLogDebugString(
                      pCDBThread->thread_hdr.hpRoot,
                      CDBStateLogConsoleLevel,
                      "%s  Length %d",
                      "fill_Loc_SGL_offCard",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      pCDBThread->DataLength,
                      0,0,0,0,0,0,0
                    );
#endif /* Performance_Debug */

    while (SG_Cache_Used--)
    {
        *LSGL_Ptr++ = *SG_Cache_Ptr++;
    }
#endif /* __MemMap_Force_On_Card__ was not defined */
}

/*+
   Function: fill_Loc_SGL_onCard

    Purpose: On card memory version to set IO buffers using only 
             local Scatter Gather
             
  Called By: CDBActionFillLocalSGL

      Calls: None
-*/
void fill_Loc_SGL_onCard(CDBThread_t * pCDBThread)
{
#ifndef __MemMap_Force_Off_Card__
    agRoot_t     *hpRoot       = pCDBThread->thread_hdr.hpRoot; /* NW BUG */
    os_bit32         LSGL_Offset  = pCDBThread->SEST_Offset + hpFieldOffset(USE_t,First_SG);/* NW BUG */
    SG_Element_t *SG_Cache_Ptr = &(pCDBThread->SG_Cache[0]);/* NW BUG */

#ifndef Performance_Debug
    fiLogDebugString(
                      hpRoot,
                      CDBStateLogConsoleLevel,
                      "%s  Length %d",
                      "fill_Loc_SGL_onCard",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      pCDBThread->DataLength,
                      0,0,0,0,0,0,0
                    );
#endif /* Performance_Debug */

    osCardRamWriteBlock(
                         hpRoot,
                         LSGL_Offset,
                         (void *)SG_Cache_Ptr,
                         (os_bit32)(pCDBThread->SG_Cache_Used * sizeof(SG_Element_t))
                       );
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

/*+
   Function: fillptr_SEST_offCard_ESGL_offCard

    Purpose: Off card (system )memory version to set SEST to point to initial ESGL Page. 
             
  Called By: CDBActionFillESGL

      Calls: None
-*/
void fillptr_SEST_offCard_ESGL_offCard(CDBThread_t * pCDBThread)
{
#ifndef __MemMap_Force_On_Card__
    agRoot_t        * hpRoot        = pCDBThread->thread_hdr.hpRoot;
    CThread_t       * pCThread      = CThread_ptr(hpRoot);
    ESGL_Request_t  * pESGL_Request = &pCDBThread->ESGL_Request;
    os_bit32        * Clear_LOC     = (os_bit32 * )((os_bit8 *)(pCDBThread->SEST_Ptr) + hpFieldOffset(USE_t,LOC) );

    SG_Element_t * pLSGL  = &pCDBThread->SEST_Ptr->USE.First_SG;

    *Clear_LOC &= ~USE_LOC;

    pLSGL->U32_Len = 0;
    pLSGL->L32 = pCThread->Calculation.Input.dmaMemoryLower32+pESGL_Request->offsetToFirst;
#endif /* __MemMap_Force_On_Card__ was not defined */
}

/*+
   Function: fillptr_SEST_offCard_ESGL_onCard

    Purpose: On card memory version to set SEST to point to initial ESGL Page
             local Scatter Gather
             
  Called By: CDBActionFillESGL

      Calls: None
-*/
void fillptr_SEST_offCard_ESGL_onCard(CDBThread_t * pCDBThread)
{
#ifndef __MemMap_Force_Off_Card__
    agRoot_t        * hpRoot            = pCDBThread->thread_hdr.hpRoot;
    CThread_t       * pCThread          = CThread_ptr(hpRoot);
    SG_Element_t * pLSGL  = &pCDBThread->SEST_Ptr->USE.First_SG;

    os_bit32           * Clear_LOC     = (os_bit32 * )((os_bit8 *)(pCDBThread->SEST_Ptr) + hpFieldOffset(USE_t,LOC) );

    ESGL_Request_t *pESGL_Request = &pCDBThread->ESGL_Request;

    *Clear_LOC &= ~USE_LOC;

    pLSGL->U32_Len = 0;
    pLSGL->L32 = pCThread->Calculation.Input.cardRamLower32+pESGL_Request->offsetToFirst;

#endif /* __MemMap_Force_Off_Card__ was not defined */
}

/*+
   Function: fillptr_SEST_onCard_ESGL_offCard

    Purpose: On card memory version to set fill memory locations and data length in 
             allocated  ESGL Pages when SEST in off card
             
  Called By: CDBActionFillESGL

      Calls: None
-*/
void fillptr_SEST_onCard_ESGL_offCard(CDBThread_t * pCDBThread)
{
#ifndef __MemMap_Force_On_Card__
    agRoot_t        * hpRoot        = pCDBThread->thread_hdr.hpRoot;
    CThread_t       * pCThread      = CThread_ptr(hpRoot);
    ESGL_Request_t  * pESGL_Request = &pCDBThread->ESGL_Request;

    os_bit32             Clear_LOC_Offset  = pCDBThread->SEST_Offset + hpFieldOffset(USE_t,LOC);
    os_bit32             LSGL_Offset       = pCDBThread->SEST_Offset + hpFieldOffset(USE_t,First_SG);

    osCardRamWriteBit32(hpRoot,
                        Clear_LOC_Offset,
                        osCardRamReadBit32(hpRoot,
                                Clear_LOC_Offset) & ~USE_LOC );

    osCardRamWriteBit32(hpRoot,
                        LSGL_Offset,
                        0);

    osCardRamWriteBit32(hpRoot,
                        LSGL_Offset + 4,
                        pCThread->Calculation.Input.dmaMemoryLower32+pESGL_Request->offsetToFirst
                        );

#endif /* __MemMap_Force_On_Card__ was not defined */
}

/*+
   Function: fillptr_SEST_onCard_ESGL_onCard

    Purpose: On card memory version to set fill memory locations and data length in 
             allocated  ESGL Pages when SEST in on card
             
  Called By: CDBActionFillESGL

      Calls: None
-*/
void fillptr_SEST_onCard_ESGL_onCard(CDBThread_t * pCDBThread)
{
#ifndef __MemMap_Force_Off_Card__
    agRoot_t        * hpRoot            = pCDBThread->thread_hdr.hpRoot;
    CThread_t       * pCThread          = CThread_ptr(hpRoot);
    os_bit32             Clear_LOC_Offset  = pCDBThread->SEST_Offset + hpFieldOffset(USE_t,LOC);
    os_bit32             LSGL_Offset       = pCDBThread->SEST_Offset + hpFieldOffset(USE_t,First_SG);
    ESGL_Request_t *pESGL_Request = &pCDBThread->ESGL_Request;

    osCardRamWriteBit32(hpRoot,
                        Clear_LOC_Offset,
                        osCardRamReadBit32(hpRoot,
                                Clear_LOC_Offset) & ~USE_LOC );

    osCardRamWriteBit32(hpRoot,
                        LSGL_Offset,
                        0);

    osCardRamWriteBit32(hpRoot,
                        LSGL_Offset + 4,
                        pCThread->Calculation.Input.cardRamLower32+pESGL_Request->offsetToFirst
                        );

#endif /* __MemMap_Force_Off_Card__ was not defined */
}

/*+
   Function: fill_ESGL_offCard

    Purpose: System memory version to set fill memory locations and data length in 
             allocated  ESGL Pages when ESGL is off card.
             
  Called By: CDBActionFillESGL

      Calls: None
-*/
void fill_ESGL_offCard(CDBThread_t * pCDBThread)
{
#ifndef __MemMap_Force_On_Card__
    agRoot_t        * hpRoot        = pCDBThread->thread_hdr.hpRoot;
    CThread_t       * pCThread      = CThread_ptr(hpRoot);
    ESGL_Request_t  * pESGL_Request = &pCDBThread->ESGL_Request;

    SG_Element_t * pESGL  = (SG_Element_t * )((os_bit8 *)(pCThread->Calculation.Input.dmaMemoryPtr)
                                                                + pESGL_Request->offsetToFirst );

    os_bit32 DataLength = pCDBThread->DataLength;

    os_bit32 ChunksPerESGL;
    os_bit32 TotalChunks;
    os_bit32 Chunk          = 0;
    os_bit32 hpChunkOffset  = pCDBThread->SG_Cache_Offset;
    os_bit32 hpChunkUpper32;
    os_bit32 hpChunkLower32;
    os_bit32 hpChunkLen;

    os_bit32       SG_Cache_Used = pCDBThread->SG_Cache_Used;
    SG_Element_t * SG_Cache_Ptr  = &(pCDBThread->SG_Cache[0]);

    ChunksPerESGL = pCThread->Calculation.MemoryLayout.ESGL.elementSize / sizeof(SG_Element_t);
    TotalChunks   = ChunksPerESGL * pESGL_Request->num_ESGL;

#ifndef Performance_Debug

    fiLogDebugString(
                      hpRoot,
                      CDBStateLogConsoleLevel,
                      " %s Length %d",
                      "fill_ESGL_offCard",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      pCDBThread->DataLength,
                      0,0,0,0,0,0,0
                    );
#endif /* Performance_Debug */

    while (SG_Cache_Used--)
    {
        *pESGL++ = *SG_Cache_Ptr++;

        Chunk++;
        TotalChunks--;

        if (Chunk == (ChunksPerESGL-1))
        {
           /*
            Chain ESGL here
            */

            pESGL = (SG_Element_t * )((os_bit8 *)(pCThread->Calculation.Input.dmaMemoryPtr)
                                      + (pESGL->L32 - pCThread->Calculation.Input.dmaMemoryLower32) );

            Chunk = 0;
            TotalChunks--;
        }
    }

    while (hpChunkOffset < DataLength)
    {
        osGetSGLChunk( hpRoot,
                         pCDBThread->hpIORequest,
                         hpChunkOffset,
                         &hpChunkUpper32,
                         &hpChunkLower32,
                         &hpChunkLen
                         );

        if (hpChunkLen > SG_Element_Len_MAX)
            hpChunkLen = SG_Element_Len_MAX;

        pESGL->U32_Len = (hpChunkUpper32 << SG_Element_U32_SHIFT) | hpChunkLen;
        pESGL->L32     = hpChunkLower32;

        hpChunkOffset += hpChunkLen;
        pESGL++;

        Chunk++;
        TotalChunks--;

        if (Chunk == (ChunksPerESGL-1))
        {
           /*
            Chain ESGL here
            */

            pESGL = (SG_Element_t * )((os_bit8 *)(pCThread->Calculation.Input.dmaMemoryPtr)
                                      + (pESGL->L32 - pCThread->Calculation.Input.dmaMemoryLower32) );

            Chunk = 0;
            TotalChunks--;
        }
    }

    while (TotalChunks--)
    {
        pESGL->U32_Len = 0;
        pESGL->L32     = 0;

        pESGL++;
    }
#endif /* __MemMap_Force_On_Card__ was not defined */
}

/*+
   Function: fill_ESGL_onCard

    Purpose: On card version to set fill memory locations and data length in 
             allocated  ESGL Pages when ESGL is on card.
             
  Called By: CDBActionFillESGL

      Calls: None
-*/
void fill_ESGL_onCard(CDBThread_t * pCDBThread)
{
#ifndef __MemMap_Force_Off_Card__
    agRoot_t        * hpRoot        = pCDBThread->thread_hdr.hpRoot;
    CThread_t       * pCThread      = CThread_ptr(hpRoot);
    ESGL_Request_t  * pESGL_Request = &pCDBThread->ESGL_Request;

    os_bit32 ESGL_offset  = pESGL_Request->offsetToFirst;

    os_bit32     DataLength = pCDBThread->DataLength;

    os_bit32 ChunksPerESGL;
    os_bit32 TotalChunks;
    os_bit32     Chunk  = 0;
    os_bit32     hpChunkOffset  = pCDBThread->SG_Cache_Offset;
    os_bit32     hpChunkUpper32;
    os_bit32     hpChunkLower32;
    os_bit32     hpChunkLen;

    os_bit32         SG_Cache_Used = pCDBThread->SG_Cache_Used;
    SG_Element_t *SG_Cache_Ptr  = &(pCDBThread->SG_Cache[0]);

    ChunksPerESGL = pCThread->Calculation.MemoryLayout.ESGL.elementSize / sizeof(SG_Element_t);
    TotalChunks = ChunksPerESGL * pESGL_Request->num_ESGL;

#ifndef Performance_Debug
    fiLogDebugString(
                      hpRoot,
                      CDBStateLogConsoleLevel,
                      "%s  Length %d",
                      "fill_ESGL_onCard",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      pCDBThread->DataLength,
                      0,0,0,0,0,0,0
                    );

#endif /* Performance_Debug */
    while (SG_Cache_Used--)
    {
        osCardRamWriteBlock(
                             hpRoot,
                             ESGL_offset,
                             (void *)SG_Cache_Ptr,
                             (os_bit32)sizeof(SG_Element_t)
                           );

        ESGL_offset  += sizeof(SG_Element_t);
        SG_Cache_Ptr += 1;

        Chunk++;
        TotalChunks--;

        if (Chunk == (ChunksPerESGL-1))
        {
           /*
            Chain ESGL here
            */

            ESGL_offset = osCardRamReadBit32(hpRoot,ESGL_offset + 4 );

            Chunk = 0;
            TotalChunks--;
        }
    }

    while (hpChunkOffset < DataLength)
    {
        osGetSGLChunk( hpRoot,
                         pCDBThread->hpIORequest,
                         hpChunkOffset,
                         &hpChunkUpper32,
                         &hpChunkLower32,
                         &hpChunkLen
                         );

        if (hpChunkLen > SG_Element_Len_MAX)
            hpChunkLen = SG_Element_Len_MAX;

        osCardRamWriteBit32(hpRoot,
                            ESGL_offset,
                            (hpChunkUpper32 << SG_Element_U32_SHIFT) | hpChunkLen);
        osCardRamWriteBit32(hpRoot,
                            ESGL_offset + 4,
                            hpChunkLower32);

        hpChunkOffset += hpChunkLen;
        ESGL_offset += sizeof(SG_Element_t);

        Chunk++;
        TotalChunks--;

        if (Chunk == (ChunksPerESGL-1))
        {
           /*
            Chain ESGL here
            */

            ESGL_offset = osCardRamReadBit32(hpRoot,ESGL_offset + 4 );

            Chunk = 0;
            TotalChunks--;
        }
    }

    while (TotalChunks--)
    {
        osCardRamWriteBit32(hpRoot,
                            ESGL_offset,
                            0);
        osCardRamWriteBit32(hpRoot,
                            ESGL_offset+4,
                            0);

        ESGL_offset += sizeof(SG_Element_t);
    }
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

/*+
   Function: CCC_CdbThreadAlloc

    Purpose: Allocates private Test Unit ready CDB to Clear Check Condition.
  Called By: Not Used but functional
      Calls: Not Used
-*/
CDBThread_t *CCC_CdbThreadAlloc(
                             agRoot_t          *hpRoot,
                             DevThread_t       *DevThread,
                             os_bit32 Lun
                           )
{
    agIORequest_t      hpIORequest;
    agIORequestBody_t  hpIORequestBody;
    CDBThread_t       *CDBThread_to_return;
    os_bit32              i;

    for (i = 0;i <  8;i++) hpIORequestBody.CDBRequest.FcpCmnd.FcpLun[i]  = 0;
    for (i = 0;i <  4;i++) hpIORequestBody.CDBRequest.FcpCmnd.FcpCntl[i] = 0;
    for (i = 0;i < 16;i++) hpIORequestBody.CDBRequest.FcpCmnd.FcpCdb[i]  = 0;
    for (i = 0;i <  4;i++) hpIORequestBody.CDBRequest.FcpCmnd.FcpDL[i]   = 0;

    CDBThread_to_return = CDBThreadAlloc(hpRoot,&hpIORequest,(agFCDev_t)DevThread,&hpIORequestBody);

    if (CDBThread_to_return != (CDBThread_t *)agNULL)
    {
        CDBThread_to_return->Lun = Lun;
    }

    return CDBThread_to_return;
}

#endif /* Not USESTATEMACROS  */


/*+
  Function: CDBState_c
   Purpose: When compiled updates browser info file for VC 5.0 / 6.0
   Returns: none
 Called By: none
     Calls: none
-*/
/* void CDBState_c(void){} */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\cfinit.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/CFINIT.C $

  $Revision:: 3               $
      $Date:: 7/16/01 2:08p   $
   $Modtime:: 7/16/01 2:05p   $

Purpose:

  This file implements Initialize functions called by the FC Layer Card
  State Machine.

--*/

#ifndef _New_Header_file_Layout_
#include "../h/globals.h"
#include "../h/state.h"

#include "../h/tlstruct.h"
#include "../h/memmap.h"
#include "../h/fcmain.h"
#include "../h/fcstruct.h"
#include "../h/linksvc.h"
#include "../h/cmntrans.h"
#include "../h/sf_fcp.h"
#include "../h/flashsvc.h"
#include "../h/timersvc.h"

#include "../h/cstate.h"
#include "../h/cfunc.h"
#include "../h/devstate.h"
#include "../h/cdbstate.h"
#include "../h/sfstate.h"
#include "../h/tgtstate.h"

#ifdef _DvrArch_1_30_
#include "../h/ipstate.h"
#include "../h/pktstate.h"
#endif /* _DvrArch_1_30_ was defined */

#include "../h/queue.h"
#include "../h/cdbsetup.h"
#else /* _New_Header_file_Layout_ */
#include "globals.h"
#include "state.h"

#include "tlstruct.h"
#include "memmap.h"
#include "fcmain.h"
#include "fcstruct.h"
#include "linksvc.h"
#include "cmntrans.h"
#include "sf_fcp.h"
#include "flashsvc.h"
#include "timersvc.h"

#include "cstate.h"
#include "cfunc.h"
#include "devstate.h"
#include "cdbstate.h"
#include "sfstate.h"
#include "tgtstate.h"

#ifdef _DvrArch_1_30_
#include "ipstate.h"
#include "pktstate.h"
#endif /* _DvrArch_1_30_ was defined */

#include "queue.h"
#include "cdbsetup.h"
#endif  /* _New_Header_file_Layout_ */


#ifndef __State_Force_Static_State_Tables__
extern actionUpdate_t noActionUpdate;
#endif /* __State_Force_Static_State_Tables__ was not defined */

extern os_bit8 Alpa_Index[256];


void CFuncInitERQ_Registers( agRoot_t *hpRoot )
{
    CThread_t  * pCThread= CThread_ptr(hpRoot);
    os_bit32        reg_value = 0;

    switch (pCThread->Calculation.MemoryLayout.ERQ.memLoc)
    {
        case inDmaMemory:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "ERQ.memLoc OffCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
            reg_value = pCThread->Calculation.MemoryLayout.ERQ.addr.DmaMemory.dmaMemoryLower32;
            break;

        case inCardRam:
             fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "ERQ.memLoc OnCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
            reg_value = pCThread->Calculation.MemoryLayout.ERQ.addr.CardRam.cardRamLower32;
            break;

        default: Fc_ERROR(hpRoot);
    }

    osChipIOLoWriteBit32(hpRoot, ChipIOLo_ERQ_Base, reg_value);
    osChipIOLoWriteBit32(hpRoot, ChipIOLo_ERQ_Length,
        pCThread->Calculation.MemoryLayout.ERQ.elements - 1 );

    pCThread->HostCopy_ERQProdIndex=0;

    switch (pCThread->Calculation.MemoryLayout.ERQConsIndex.memLoc)
    {
        case inDmaMemory:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "ERQ.ERQConsIndex OffCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);


            reg_value                          = pCThread->Calculation.MemoryLayout.ERQConsIndex.addr.DmaMemory.dmaMemoryLower32;
            *(ERQConsIndex_t *)(pCThread->Calculation.MemoryLayout.ERQConsIndex.addr.DmaMemory.dmaMemoryPtr) = 0;
            break;

        case inCardRam:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "ERQ.ERQConsIndex OnCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

            reg_value                          = pCThread->Calculation.MemoryLayout.ERQConsIndex.addr.CardRam.cardRamLower32;
            osCardRamWriteBit32(hpRoot,
                    pCThread->Calculation.MemoryLayout.ERQConsIndex.addr.CardRam.cardRamOffset,
                    0
                    );

            break;

        default: Fc_ERROR(hpRoot);
    }

    osChipIOLoWriteBit32(hpRoot, ChipIOLo_ERQ_Consumer_Index_Address, reg_value);

}

os_bit32 CFuncInitChip( agRoot_t *hpRoot )
{

    CThread_t  * pCThread= CThread_ptr(hpRoot);
    os_bit32        reg_value = 0;
    os_bit32 * pInitIMQ,x;
    /* ERQ Entries */

    switch (pCThread->Calculation.MemoryLayout.ERQ.memLoc)
    {
        case inDmaMemory:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "ERQ.memLoc OffCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
#ifdef _DvrArch_1_30_
            pCThread->FuncPtrs.Pkt_IRB_Init = &PktFuncIRB_OffCardInit;
#endif /* _DvrArch_1_30_ was defined */
            pCThread->FuncPtrs.SF_IRB_Init = &SFFuncIRB_OffCardInit;
            pCThread->FuncPtrs.CDBFuncIRB_Init = &CDBFuncIRB_offCardInit;
            reg_value = pCThread->Calculation.MemoryLayout.ERQ.addr.DmaMemory.dmaMemoryLower32;
            break;

        case inCardRam:
             fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "ERQ.memLoc OnCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
            pCThread->FuncPtrs.SF_IRB_Init = &SFFuncIRB_OnCardInit;
            pCThread->FuncPtrs.CDBFuncIRB_Init = &CDBFuncIRB_onCardInit;
            reg_value = pCThread->Calculation.MemoryLayout.ERQ.addr.CardRam.cardRamLower32;
            break;

        default: Fc_ERROR(hpRoot);
    }

    osChipIOLoWriteBit32(hpRoot, ChipIOLo_ERQ_Base, reg_value);
    osChipIOLoWriteBit32(hpRoot, ChipIOLo_ERQ_Length,
        pCThread->Calculation.MemoryLayout.ERQ.elements - 1 );

    pCThread->HostCopy_ERQProdIndex=0;

    switch (pCThread->Calculation.MemoryLayout.ERQConsIndex.memLoc)
    {
        case inDmaMemory:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "ERQ.ERQConsIndex OffCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);


            reg_value                          = pCThread->Calculation.MemoryLayout.ERQConsIndex.addr.DmaMemory.dmaMemoryLower32;
            pCThread->FuncPtrs.GetERQConsIndex = &CFuncGetDmaMemERQConsIndex;
            pCThread->FuncPtrs.WaitForERQ      = &WaitForERQ_ConsIndexOffCard;
            pCThread->FuncPtrs.WaitForERQEmpty = &WaitForERQEmpty_ConsIndexOffCard;
            *(ERQConsIndex_t *)(pCThread->Calculation.MemoryLayout.ERQConsIndex.addr.DmaMemory.dmaMemoryPtr) = 0;
            break;

        case inCardRam:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "ERQ.ERQConsIndex OnCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

            reg_value                          = pCThread->Calculation.MemoryLayout.ERQConsIndex.addr.CardRam.cardRamLower32;
            pCThread->FuncPtrs.GetERQConsIndex = &CFuncGetCardRamERQConsIndex;
            pCThread->FuncPtrs.WaitForERQ      = &WaitForERQ_ConsIndexOnCard;
            pCThread->FuncPtrs.WaitForERQEmpty = &WaitForERQEmpty_ConsIndexOnCard;
            osCardRamWriteBit32(hpRoot,
                    pCThread->Calculation.MemoryLayout.ERQConsIndex.addr.CardRam.cardRamOffset,
                    0
                    );

            break;

        default: Fc_ERROR(hpRoot);
    }

    osChipIOLoWriteBit32(hpRoot, ChipIOLo_ERQ_Consumer_Index_Address, reg_value);

    /* SFQ Entries */

    switch (pCThread->Calculation.MemoryLayout.SFQ.memLoc)
    {
        case inDmaMemory:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "SFQ.memLoc OffCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

             reg_value                              = pCThread->Calculation.MemoryLayout.SFQ.addr.DmaMemory.dmaMemoryLower32;
             pCThread->FuncPtrs.fiLinkSvcProcessSFQ = &fiLinkSvcProcessSFQ_OffCard;
             pCThread->FuncPtrs.fiCTProcessSFQ      = &fiCTProcessSFQ_OffCard;
             pCThread->FuncPtrs.fiSF_FCP_ProcessSFQ = &fiSF_FCP_ProcessSFQ_OffCard;
             break;

        case inCardRam:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "SFQ.memLoc OnCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
             reg_value                              = pCThread->Calculation.MemoryLayout.SFQ.addr.CardRam.cardRamLower32;
             pCThread->FuncPtrs.fiLinkSvcProcessSFQ = &fiLinkSvcProcessSFQ_OnCard;
             pCThread->FuncPtrs.fiCTProcessSFQ      = &fiCTProcessSFQ_OnCard;
             pCThread->FuncPtrs.fiSF_FCP_ProcessSFQ = &fiSF_FCP_ProcessSFQ_OnCard;
             break;

        default: Fc_ERROR(hpRoot);
    }

    osChipIOLoWriteBit32(hpRoot,ChipIOLo_SFQ_Base , reg_value);
    osChipIOLoWriteBit32(hpRoot, ChipIOLo_SFQ_Length,
        pCThread->Calculation.MemoryLayout.SFQ.elements - 1 );


    /* IMQ Entries */
    pCThread->HostCopy_IMQConsIndex=0;

    switch( pCThread->Calculation.MemoryLayout.IMQ.memLoc)
    {
        case inDmaMemory:

            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "IMQ.memLoc OffCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

            reg_value = pCThread->Calculation.MemoryLayout.IMQ.addr.DmaMemory.dmaMemoryLower32;
            pCThread->FuncPtrs.Proccess_IMQ    =&CFuncOffCardProcessIMQ;

            pInitIMQ = pCThread->Calculation.MemoryLayout.IMQ.addr.DmaMemory.dmaMemoryPtr;
            for(x=0; x < pCThread->Calculation.MemoryLayout.IMQ.elements - 1; x++)
            {
               * pInitIMQ = CM_Unknown_CM_Type_InvalidType;
                 pInitIMQ += 8;
            }
            break;

        case inCardRam:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "IMQ.memLoc OnCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
            reg_value = pCThread->Calculation.MemoryLayout.IMQ.addr.CardRam.cardRamLower32;
            pCThread->FuncPtrs.Proccess_IMQ    = &CFuncOnCardProcessIMQ;
            break;

        default: Fc_ERROR(hpRoot);
    }

    osChipIOLoWriteBit32(hpRoot,ChipIOLo_IMQ_Base, reg_value);

    osChipIOLoWriteBit32(hpRoot, ChipIOLo_IMQ_Length,
        pCThread->Calculation.MemoryLayout.IMQ.elements - 1 );

    switch (pCThread->Calculation.MemoryLayout.IMQProdIndex.memLoc)
    {
        case inDmaMemory:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "IMQProdIndex.memLoc OffCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

             reg_value                          = pCThread->Calculation.MemoryLayout.IMQProdIndex.addr.DmaMemory.dmaMemoryLower32;
             pCThread->FuncPtrs.GetIMQProdIndex = &CFuncGetDmaMemIMQProdIndex;
             break;

        case inCardRam:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "IMQProdIndex.memLoc OnCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
             reg_value                          = pCThread->Calculation.MemoryLayout.IMQProdIndex.addr.CardRam.cardRamLower32;
             pCThread->FuncPtrs.GetIMQProdIndex = &CFuncGetCardRamIMQProdIndex;
             osCardRamWriteBit32(hpRoot,
                    pCThread->Calculation.MemoryLayout.IMQProdIndex.addr.CardRam.cardRamOffset,
                    0
                    );
             break;

        default: Fc_ERROR(hpRoot);
    }

    osChipIOLoWriteBit32(hpRoot,ChipIOLo_IMQ_Producer_Index_Address, reg_value);


    /* SEST Entries */

    switch (pCThread->Calculation.MemoryLayout.SEST.memLoc)
    {
        case inDmaMemory:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "SEST.memLoc OffCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

            reg_value                           = pCThread->Calculation.MemoryLayout.SEST.addr.DmaMemory.dmaMemoryLower32;
            pCThread->FuncPtrs.fiFillInFCP_SEST = &fiFillInFCP_SEST_OffCard;
            pCThread->FuncPtrs.fillLocalSGL     = &fill_Loc_SGL_offCard;

            pCThread->FuncPtrs.FCP_Completion = &CFuncSEST_offCard_FCPCompletion;
            if(pCThread->Calculation.MemoryLayout.ESGL.memLoc == inDmaMemory)
            {
                pCThread->FuncPtrs.upSEST           = &fillptr_SEST_offCard_ESGL_offCard;

            }
            else
            {
                pCThread->FuncPtrs.upSEST           = &fillptr_SEST_offCard_ESGL_onCard;
            }

            break;

        case inCardRam:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "SEST.memLoc OnCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
             pCThread->FuncPtrs.FCP_Completion = &CFuncSEST_onCard_FCPCompletion;

             reg_value                           = pCThread->Calculation.MemoryLayout.SEST.addr.CardRam.cardRamLower32;
             pCThread->FuncPtrs.fiFillInFCP_SEST = &fiFillInFCP_SEST_OnCard;
             pCThread->FuncPtrs.fillLocalSGL     = &fill_Loc_SGL_onCard;
            if(pCThread->Calculation.MemoryLayout.ESGL.memLoc == inDmaMemory)
            {
                 pCThread->FuncPtrs.upSEST           = &fillptr_SEST_onCard_ESGL_offCard;

            }
            else
            {
                 pCThread->FuncPtrs.upSEST           = &fillptr_SEST_onCard_ESGL_onCard;
            }
            break;

        default: Fc_ERROR(hpRoot);
    }

    osChipIOUpWriteBit32( hpRoot, ChipIOUp_SEST_Base, reg_value);

    osChipIOUpWriteBit32( hpRoot, ChipIOUp_SEST_Length, pCThread->Calculation.MemoryLayout.SEST.elements );

    osChipIOUpWriteBit32( hpRoot, ChipIOUp_SEST_Linked_List_Head_Tail, 0xffffffff  );


    /* ESGL */
    osChipIOUpWriteBit32( hpRoot, ChipIOUp_ScatterGather_List_Page_Length, pCThread->Calculation.MemoryLayout.ESGL.elementSize/sizeof(SG_Element_t) - 1 );

    /*TL Config Register */

#ifdef __Implement_The_Advise_About_OB_Thresh_In_The_Users_Manual__
    reg_value = osChipIOUpReadBit32(hpRoot,
                ChipIOUp_PCIMCTR__ROMCTR__Reserved_8__Reserved_9);

    if(reg_value &  ChipIOUp_PCIMCTL_P64 )
    {
        osChipIOUpWriteBit32( hpRoot, ChipIOUp_TachLite_Configuration,
                        ChipIOUp_TachLite_Configuration_M66EN |
                        ChipIOUp_TachLite_Configuration_OB_Thresh_264);
    }
    else
    {
        osChipIOUpWriteBit32( hpRoot, ChipIOUp_TachLite_Configuration,
                        ChipIOUp_TachLite_Configuration_M66EN |
                        ChipIOUp_TachLite_Configuration_OB_Thresh_132);

    }
#endif /* __Implement_The_Advise_About_OB_Thresh_In_The_Users_Manual__ was not defined */

    /* This will break the Gadzoox  Gibraltar GS  Hub 
        pCThread->TimeOutValues.LP_Tov = 1000;
    */
/* Now set from osAdjustParm.....
    pCThread->TimeOutValues.ED_Tov = 2000;
    pCThread->TimeOutValues.LP_Tov = pCThread->TimeOutValues.ED_Tov;
*/
    CFuncWriteTimeoutValues( hpRoot, &pCThread->TimeOutValues  );

    return agTRUE;
}

void CFuncInitFM_Registers( agRoot_t *hpRoot,agBOOLEAN SendInit )
{
    CThread_t  * pCThread = CThread_ptr(hpRoot);
    agFCChanInfo_t *Self_info = &(pCThread->ChanInfo);
    os_bit32 Init_FM_Value = 0;


    if(! pCThread->PreviouslyAquiredALPA)
    {
        CFuncGetHaInfoFromNVR(hpRoot);
    }
    fiLinkSvcInit(hpRoot);

    fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "%s FM Status %08X FM Cfg %08x Self ALPA %x",
                    "CFuncInitFM_Registers",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration),
                    Self_info->CurrentAddress.AL_PA,
                    0,0,0,0,0);

    fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "F  %s HA %x CA %x FA %x",
                    "CFuncInitFM_Registers",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)(Self_info->HardAddress.AL_PA),
                    (os_bit32)(Self_info->CurrentAddress.AL_PA),
                    fiFlash_Card_Unassigned_Loop_Address,0,0,0,0,0);


#ifdef NPORT_STUFF
    if (!(pCThread->InitAsNport))
    {
#endif /* NPORT_STUFF */

    if (Self_info->CurrentAddress.AL_PA == fiFlash_Card_Unassigned_Loop_Address)
    {

#ifdef _BYPASSLOOPMAP
        if(pCThread->PreviouslyAquiredALPA)
        {
            Init_FM_Value = (  ChipIOUp_Frame_Manager_Configuration_AQ  |
                               ChipIOUp_Frame_Manager_Configuration_BLM |
                               ( ((os_bit32)(Self_info->HardAddress.AL_PA))
                                  << ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT ) ); 

        }
        else
        {
            Init_FM_Value = (  ChipIOUp_Frame_Manager_Configuration_SA  |
                               ChipIOUp_Frame_Manager_Configuration_BLM |
                               ( ((os_bit32)(Self_info->HardAddress.AL_PA))
                                  << ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT ) ); 
        }
#else /* NOT _BYPASSLOOPMAP */
        if(pCThread->PreviouslyAquiredALPA)
        {

        Init_FM_Value  = ( ChipIOUp_Frame_Manager_Configuration_AQ    |
                           ( ((os_bit32)(Self_info->HardAddress.AL_PA))
                              << ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT ) ); 

        }
        else
        {
        Init_FM_Value  = ( ChipIOUp_Frame_Manager_Configuration_SA    |
                           ( ((os_bit32)(Self_info->HardAddress.AL_PA))
                              << ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT ) ); 

        }
#endif /* _BYPASSLOOPMAP */

        osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Configuration,  Init_FM_Value );

        fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "A %s Frame Manager Configuration %08X",
                    "CFuncInitFM_Registers",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration),
                    0,0,0,0,0,0,0);

        fiLogDebugString(hpRoot,
                        CFuncLogConsoleERROR,
                        "G %s HA %x CA %x FA %x",
                        "CFuncInitFM_Registers",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        (os_bit32)(Self_info->HardAddress.AL_PA),
                        (os_bit32)(Self_info->CurrentAddress.AL_PA),
                        fiFlash_Card_Unassigned_Loop_Address,0,0,0,0,0);

    }
    else /* Self_info->CurrentAddress.AL_PA != fiFlash_Card_Unassigned_Loop_Address */
    {

#ifdef _BYPASSLOOPMAP
        Init_FM_Value = (  ChipIOUp_Frame_Manager_Configuration_HA  |
                           ChipIOUp_Frame_Manager_Configuration_BLM |
                           ( ((os_bit32)(Self_info->CurrentAddress.AL_PA))
                              << ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT ) ); 
#else /* _BYPASSLOOPMAP */
        Init_FM_Value  = ( ChipIOUp_Frame_Manager_Configuration_HA|
                           ( ((os_bit32)(Self_info->CurrentAddress.AL_PA))
                              << ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT ) ); 
#endif /* _BYPASSLOOPMAP */

        fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "B %s Frame Manager Configuration %08X",
                    "CFuncInitFM_Registers",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration),
                    0,0,0,0,0,0,0);

        fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "H %s HA %x CA %x FA %x",
                    "CFuncInitFM_Registers",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)(Self_info->HardAddress.AL_PA),
                    (os_bit32)(Self_info->CurrentAddress.AL_PA),
                    fiFlash_Card_Unassigned_Loop_Address,
                    0,0,0,0,0);

        osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Configuration, Init_FM_Value );

    }
#ifdef NPORT_STUFF
    }
    else /* NPORT_STUFF */
    {
         /* TachyonTL Errata 3.21 - Need to set the
          * ENP bit first and then set the rest of the
          * bits needed to initialize as NPORT. Infact,
          * it does not work if we do not set the ENP
          * bit AGAIN.
          */

         osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Configuration, ChipIOUp_Frame_Manager_Configuration_ENP);

         osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Configuration,
                              ChipIOUp_Frame_Manager_Configuration_NPI |
                              ChipIOUp_Frame_Manager_Configuration_ENP |
                              /* BB Credit of 1 for NPORT */
                              pCThread->AquiredCredit_Shifted);


        fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "C %s Frame Manager Configuration %08X",
                    "CFuncInitFM_Registers",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration),
                    0,0,0,0,0,0,0);

    }
#endif /* NPORT_STUFF */


    CFuncDisable_Interrupts(hpRoot,ChipIOUp_INTEN_INT);

    fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Writing High WWN %08X to %X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    hpSwapBit32(*(os_bit32*) &(Self_info->PortWWN[0])),
                    ChipIOUp_Frame_Manager_World_Wide_Name_High,
                    0,0,0,0,0,0);


    osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_World_Wide_Name_High, hpSwapBit32(*(os_bit32*) &(Self_info->PortWWN[0])));

    fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Writing Low  WWN %08X to %X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    hpSwapBit32(*(os_bit32*)&(Self_info->PortWWN[4])),
                    ChipIOUp_Frame_Manager_World_Wide_Name_Low,
                    0,0,0,0,0,0);


    osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_World_Wide_Name_Low, hpSwapBit32(*(os_bit32*) &(Self_info->PortWWN[4])));

    fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Frame Manager Initialize FM Cfg %08X FM Stat %08X  TL Stat %08X Self ALPA %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Configuration),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    (os_bit32)Self_info->CurrentAddress.AL_PA,
                    0,0,0,0);
    osChipIOUpWriteBit32( hpRoot,ChipIOUp_Frame_Manager_Status, osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ));

    if( SendInit )
    {
        osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Control, ChipIOUp_Frame_Manager_Control_CMD_Initialize );

    }

}

/*****************************************************************************************************/

void CFuncInit_DevThread(agRoot_t * hpRoot, DevThread_t * pDevThread   )
{
    CThread_t  *                pCThread        = CThread_ptr(hpRoot);

    fiInitializeThread(&pDevThread->thread_hdr,
            hpRoot,
            threadType_DevThread,
            DevStateHandleEmpty,
#ifdef __State_Force_Static_State_Tables__
            &DevStateTransitionMatrix,
            &DevStateActionScalar
#else /* __State_Force_Static_State_Tables__ was not defined */
            pCThread->Calculation.MemoryLayout.DevTransitions.addr.CachedMemory.cachedMemoryPtr,
            pCThread->Calculation.MemoryLayout.DevActions.addr.CachedMemory.cachedMemoryPtr
#endif /* __State_Force_Static_State_Tables__ was not defined */
            );

    Device_IO_Throttle_Initialize

    pDevThread->pollingCount                    = 0;
    pDevThread->Failed_Reset_Count              = 0;

    pDevThread->In_Verify_ALPA_FLAG = agFALSE;
    pDevThread->Prev_Active_Device_FLAG = agFALSE;

    pDevThread->Lun_Active_Bitmask = 0x000000FF;

    fiListInitHdr(&(pDevThread->Active_CDBLink_0));
    fiListInitHdr(&(pDevThread->Active_CDBLink_1));
    fiListInitHdr(&(pDevThread->Active_CDBLink_2));
    fiListInitHdr(&(pDevThread->Active_CDBLink_3));
    fiListInitHdr(&(pDevThread->TimedOut_CDBLink));
    fiListInitHdr(&(pDevThread->Send_IO_CDBLink));
    fiListInitHdr(&(pDevThread->Awaiting_Login_CDBLink));

    fiListInitElement(&(pDevThread->DevLink));

    fiListEnqueueAtTail(&pDevThread->DevLink,&pCThread->Prev_Unknown_Slot_DevLink);


    /*
    Not during  CStateReInitFM or CStateInitDataStructs CStateInitFM
    */


}

void CFuncInit_DirectoryDevThread(agRoot_t   *    hpRoot )
{
    CThread_t  *                pCThread        = CThread_ptr(hpRoot);
    DevThread_t                *pDevThread      = &(pCThread->DirDevThread);



    fiInitializeThread(&pDevThread->thread_hdr,
            hpRoot,
            threadType_DevThread,
            DevStateHandleEmpty,
#ifdef __State_Force_Static_State_Tables__
            &DevStateTransitionMatrix,
            &DevStateActionScalar
#else /* __State_Force_Static_State_Tables__ was not defined */
            pCThread->Calculation.MemoryLayout.DevTransitions.addr.CachedMemory.cachedMemoryPtr,
            pCThread->Calculation.MemoryLayout.DevActions.addr.CachedMemory.cachedMemoryPtr
#endif /* __State_Force_Static_State_Tables__ was not defined */
            );

    fiListInitHdr(&(pDevThread->Active_CDBLink_0));
    fiListInitHdr(&(pDevThread->Active_CDBLink_1));
    fiListInitHdr(&(pDevThread->Active_CDBLink_2));
    fiListInitHdr(&(pDevThread->Active_CDBLink_3));
    fiListInitHdr(&(pDevThread->TimedOut_CDBLink));
    fiListInitHdr(&(pDevThread->Send_IO_CDBLink));
    fiListInitHdr(&(pDevThread->Awaiting_Login_CDBLink));

    fiListInitElement(&(pDevThread->DevLink));

    Device_IO_Throttle_Initialize
    pDevThread->pollingCount                    = 0;
    pDevThread->Failed_Reset_Count              = 0;
#ifdef BROCADE_BUG
    pDevThread->DevInfo.CurrentAddress.Domain   = 0xff;
    pDevThread->DevInfo.CurrentAddress.Area     = 0xfc;

    pDevThread->DevInfo.CurrentAddress.AL_PA    = 0x41;
#else /* BROCADE_BUG */
    pDevThread->DevInfo.CurrentAddress.Domain   = 0xff;
    pDevThread->DevInfo.CurrentAddress.Area     = 0xff;

    pDevThread->DevInfo.CurrentAddress.AL_PA    = 0xfc;
#endif /* BROCADE_BUG */


    pDevThread->In_Verify_ALPA_FLAG = agFALSE;


    if( pCThread->thread_hdr.currentState ==  CStateInitialize )
    {
       /*
         Not during  CStateReInitFM or CStateInitDataStructs CStateInitFM
        */
        pDevThread->Prev_Active_Device_FLAG = agFALSE;

     }
     pDevThread->Lun_Active_Bitmask = 0x000000FF;


}
/*****************************************************************************************************/

void CFuncInit_CDBThreads(agRoot_t   *    hpRoot )
{
    CThread_t                  *pCThread                   = CThread_ptr(hpRoot);
    os_bit32                       CDBThread_cnt              = 0;
    fiMemMapMemoryDescriptor_t *CDBThread_MemoryDescriptor = &(pCThread->Calculation.MemoryLayout.CDBThread);
    os_bit32                       CDBThread_size             = CDBThread_MemoryDescriptor->elementSize;
    CDBThread_t                *pCDBThread                 = CDBThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr;

#ifndef __State_Force_Static_State_Tables__
    fiInstallStateMachine(
        &CDBStateTransitionMatrix,
        &CDBStateActionScalar,
        pCThread->Calculation.MemoryLayout.CDBTransitions.addr.CachedMemory.cachedMemoryPtr,
        pCThread->Calculation.MemoryLayout.CDBActions.addr.CachedMemory.cachedMemoryPtr,
        pCThread->Calculation.MemoryLayout.On_Card_MASK,
        &noActionUpdate
        );
#endif /* __State_Force_Static_State_Tables__ was not defined */

    CDBThread_cnt = pCThread->Calculation.MemoryLayout.CDBThread.elements;

    while(CDBThread_cnt-- > 0)
    {
        fiInitializeThread(&pCDBThread->thread_hdr,
            hpRoot,
            threadType_CDBThread,
            CDBStateThreadFree,
#ifdef __State_Force_Static_State_Tables__
            &CDBStateTransitionMatrix,
            &CDBStateActionScalar
#else /* __State_Force_Static_State_Tables__ was not defined */
            pCThread->Calculation.MemoryLayout.CDBTransitions.addr.CachedMemory.cachedMemoryPtr,
            pCThread->Calculation.MemoryLayout.CDBActions.addr.CachedMemory.cachedMemoryPtr
#endif /* __State_Force_Static_State_Tables__ was not defined */
            );
        pCDBThread = (CDBThread_t *)((os_bit8 *)pCDBThread + CDBThread_size);
        }
}

void CFuncInit_TgtThreads(  agRoot_t *  hpRoot )
{
    CThread_t               *   pCThread                    = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t *TgtThread_MemoryDescriptor = &(pCThread->Calculation.MemoryLayout.TgtThread);
    TgtThread_t                *pTgtThread                  = TgtThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr;
    os_bit32                       TgtThread_cnt   = TgtThread_MemoryDescriptor->elements;
    os_bit32                       TgtThread_size  = TgtThread_MemoryDescriptor->elementSize;

#ifndef __State_Force_Static_State_Tables__
    fiInstallStateMachine(&SFStateTransitionMatrix,
        &TgtStateActionScalar,
        pCThread->Calculation.MemoryLayout.TgtTransitions.addr.CachedMemory.cachedMemoryPtr,
        pCThread->Calculation.MemoryLayout.TgtActions.addr.CachedMemory.cachedMemoryPtr,
        pCThread->Calculation.MemoryLayout.On_Card_MASK,
        &noActionUpdate
        );
#endif /* __State_Force_Static_State_Tables__ was not defined */

    while(TgtThread_cnt-- > 0)
    {

        fiInitializeThread(&pTgtThread->thread_hdr,
            hpRoot,
            threadType_TgtThread,
            TgtStateIdle,
#ifdef __State_Force_Static_State_Tables__
            &TgtStateTransitionMatrix,
            &TgtStateActionScalar
#else /* __State_Force_Static_State_Tables__ was not defined */
            pCThread->Calculation.MemoryLayout.TgtTransitions.addr.CachedMemory.cachedMemoryPtr,
            pCThread->Calculation.MemoryLayout.TgtActions.addr.CachedMemory.cachedMemoryPtr
#endif /* __State_Force_Static_State_Tables__ was not defined */
            );

        pTgtThread = (TgtThread_t *)((os_bit8 *)pTgtThread + TgtThread_size);

    }

}


void CFuncInit_SFThreads(agRoot_t   *    hpRoot )
{
    CThread_t  *    pCThread        = CThread_ptr(hpRoot);
    SFThread_t            *pSFThread;
    os_bit32                  SFThread_cnt          = 0;
    pSFThread = pCThread->Calculation.MemoryLayout.SFThread.addr.CachedMemory.cachedMemoryPtr;

#ifndef __State_Force_Static_State_Tables__
    fiInstallStateMachine(&SFStateTransitionMatrix,
        &SFStateActionScalar,
        pCThread->Calculation.MemoryLayout.SFTransitions.addr.CachedMemory.cachedMemoryPtr,
        pCThread->Calculation.MemoryLayout.SFActions.addr.CachedMemory.cachedMemoryPtr,
        pCThread->Calculation.MemoryLayout.On_Card_MASK,
        &noActionUpdate
        );
#endif /* __State_Force_Static_State_Tables__ was not defined */

    SFThread_cnt = pCThread->Calculation.MemoryLayout.SFThread.elements;
    while(SFThread_cnt-- > 0)
    {
        fiInitializeThread(&pSFThread->thread_hdr,
            hpRoot,
            threadType_SFThread,
            SFStateFree,
#ifdef __State_Force_Static_State_Tables__
            &SFStateTransitionMatrix,
            &SFStateActionScalar
#else /* __State_Force_Static_State_Tables__ was not defined */
            pCThread->Calculation.MemoryLayout.SFTransitions.addr.CachedMemory.cachedMemoryPtr,
            pCThread->Calculation.MemoryLayout.SFActions.addr.CachedMemory.cachedMemoryPtr
#endif /* __State_Force_Static_State_Tables__ was not defined */
            );

        pSFThread->QueuedEvent = 0;

        pSFThread++;
        }

}

#ifdef _DvrArch_1_30_
void CFuncInit_IPThread(agRoot_t   *    hpRoot )
{
    CThread_t             *pCThread              = CThread_ptr(hpRoot);
    IPThread_t            *pIPThread;
    os_bit32               IPThread_cnt          = 0;

    pIPThread = pCThread->Calculation.MemoryLayout.IPThread.addr.CachedMemory.cachedMemoryPtr;

    pCThread->IP = pIPThread;

#ifndef __State_Force_Static_State_Tables__
    fiInstallStateMachine(&IPStateTransitionMatrix,
        &IPStateActionScalar,
        pCThread->Calculation.MemoryLayout.IPTransitions.addr.CachedMemory.cachedMemoryPtr,
        pCThread->Calculation.MemoryLayout.IPActions.addr.CachedMemory.cachedMemoryPtr,
        pCThread->Calculation.MemoryLayout.On_Card_MASK,
        &noActionUpdate
        );
#endif /* __State_Force_Static_State_Tables__ was not defined */

    IPThread_cnt = pCThread->Calculation.MemoryLayout.IPThread.elements;

    fiInitializeThread(&pIPThread->thread_hdr,
        hpRoot,
        threadType_IPThread,
        IPStateIdle,
#ifdef __State_Force_Static_State_Tables__
        &IPStateTransitionMatrix,
        &IPStateActionScalar
#else /* __State_Force_Static_State_Tables__ was not defined */
        pCThread->Calculation.MemoryLayout.IPTransitions.addr.CachedMemory.cachedMemoryPtr,
        pCThread->Calculation.MemoryLayout.IPActions.addr.CachedMemory.cachedMemoryPtr
#endif /* __State_Force_Static_State_Tables__ was not defined */
    );

    pIPThread->BroadcastDevice = (DevThread_t *)agNULL;
    pIPThread->LinkStatus.osData = (void *)agNULL;
    pIPThread->LinkStatus.LastReported = pIPThread->LinkStatus.MostRecent = 0;

    fiListInitHdr(&(pIPThread->OutgoingLink));
    fiListInitHdr(&(pIPThread->IncomingBufferLink));

    pIPThread->CompletedPkt = (PktThread_t *)agNULL;
}

void CFuncInit_PktThreads(agRoot_t   *    hpRoot )
{
    CThread_t  *    pCThread        = CThread_ptr(hpRoot);
    PktThread_t            *pPktThread;
    os_bit32                  PktThread_cnt          = 0;
    pPktThread = pCThread->Calculation.MemoryLayout.PktThread.addr.CachedMemory.cachedMemoryPtr;

#ifndef __State_Force_Static_State_Tables__
    fiInstallStateMachine(&PktStateTransitionMatrix,
        &PktStateActionScalar,
        pCThread->Calculation.MemoryLayout.PktTransitions.addr.CachedMemory.cachedMemoryPtr,
        pCThread->Calculation.MemoryLayout.PktActions.addr.CachedMemory.cachedMemoryPtr,
        pCThread->Calculation.MemoryLayout.On_Card_MASK,
        &noActionUpdate
        );
#endif /* __State_Force_Static_State_Tables__ was not defined */

    PktThread_cnt = pCThread->Calculation.MemoryLayout.PktThread.elements;
    while(PktThread_cnt-- > 0)
    {
        fiInitializeThread(&pPktThread->thread_hdr,
            hpRoot,
            threadType_PktThread,
            PktStateReady,
#ifdef __State_Force_Static_State_Tables__
            &PktStateTransitionMatrix,
            &PktStateActionScalar
#else /* __State_Force_Static_State_Tables__ was not defined */
            pCThread->Calculation.MemoryLayout.PktTransitions.addr.CachedMemory.cachedMemoryPtr,
            pCThread->Calculation.MemoryLayout.PktActions.addr.CachedMemory.cachedMemoryPtr
#endif /* __State_Force_Static_State_Tables__ was not defined */
            );

        pPktThread++;
    }
}
#endif /* _DvrArch_1_30_ was defined */

void CFuncInit_Threads(agRoot_t   *    hpRoot )
{
    CFuncInit_TgtThreads(  hpRoot );

    CFuncInit_CDBThreads(  hpRoot );

    CFuncInit_DirectoryDevThread( hpRoot);

    CFuncInit_SFThreads(  hpRoot );
#ifdef _DvrArch_1_30_
    CFuncInit_IPThread( hpRoot );
    CFuncInit_PktThreads( hpRoot );
#endif /* _DvrArch_1_30_ was defined */
}

void CFuncInit_DevLists(agRoot_t   *    hpRoot )
{
    CThread_t  *    pCThread        = CThread_ptr(hpRoot);

    fiListInitHdr(&(pCThread->Active_DevLink));
    fiListInitHdr(&(pCThread->Unknown_Slot_DevLink));
    fiListInitHdr(&(pCThread->Slot_Searching_DevLink));
    fiListInitHdr(&(pCThread->Prev_Active_DevLink));
    fiListInitHdr(&(pCThread->Prev_Unknown_Slot_DevLink));
    fiListInitHdr(&(pCThread->DevSelf_NameServer_DevLink));
    fiListInitHdr(&(pCThread->AWaiting_Login_DevLink));
    fiListInitHdr(&(pCThread->AWaiting_ADISC_DevLink));

    fiListInitHdr(&(pCThread->QueueFrozenWaitingSFLink));
    fiListInitHdr(&(pCThread->RSCN_Recieved_NameServer_DevLink));
  
  /* "Special list only reinit at initialize and reinitialize
    ** fiListInitHdr(&(pCThread->TimedOut_Slot_DevLink));
    */

}

void CFuncInit_FunctionPointers(agRoot_t   *    hpRoot )
{
    CThread_t  *    pCThread        = CThread_ptr(hpRoot);

    if (pCThread->Calculation.MemoryLayout.FCP_CMND.memLoc == inCardRam)
    {
        fiLogDebugString(pCThread->thread_hdr.hpRoot,
                                CFuncLogConsoleERROR,
                                "FCP_CMND.memLoc OnCard",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                0,0,0,0,0,0,0,0);

        pCThread->FuncPtrs.fiFillInFCP_CMND = &fiFillInFCP_CMND_OnCard;
    }
    else /* pCThread->Calculation.MemoryLayout.FCP_CMND.memLoc == inDmaMemory */
    {
        fiLogDebugString(pCThread->thread_hdr.hpRoot,
                                CFuncLogConsoleERROR,
                                "FCP_CMND.memLoc OffCard",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                0,0,0,0,0,0,0,0);
        pCThread->FuncPtrs.fiFillInFCP_CMND = &fiFillInFCP_CMND_OffCard;
    }

    if (pCThread->Calculation.MemoryLayout.FCP_RESP.memLoc == inCardRam)
    {
        fiLogDebugString(pCThread->thread_hdr.hpRoot,
                                CFuncLogConsoleERROR,
                                "FCP_RESP.memLoc OnCard",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                0,0,0,0,0,0,0,0);
        pCThread->FuncPtrs.fiFillInFCP_RESP = &fiFillInFCP_RESP_OnCard;
    }
    else /* pCThread->Calculation.MemoryLayout.FCP_RESP.memLoc == inDmaMemory */
    {
        fiLogDebugString(pCThread->thread_hdr.hpRoot,
                                CFuncLogConsoleERROR,
                                "FCP_RESP.memLoc OffCard",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                0,0,0,0,0,0,0,0);
        pCThread->FuncPtrs.fiFillInFCP_RESP = &fiFillInFCP_RESP_OffCard;
    }

    if (pCThread->Calculation.MemoryLayout.ESGL.memLoc == inCardRam)
    {
        fiLogDebugString(pCThread->thread_hdr.hpRoot,
                                CFuncLogConsoleERROR,
                                "ESGL.memLoc OnCard",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                0,0,0,0,0,0,0,0);

        pCThread->FuncPtrs.ESGLAlloc       = &ESGLAlloc_OnCard;
        pCThread->FuncPtrs.ESGLAllocCancel = &ESGLAllocCancel_OnCard;
        pCThread->FuncPtrs.ESGLFree        = &ESGLFree_OnCard;
        pCThread->FuncPtrs.fillESGL        = &fill_ESGL_onCard;
    }
    else /* pCThread->Calculation.MemoryLayout.ESGL.memLoc == inDmaMemory */
    {
        fiLogDebugString(pCThread->thread_hdr.hpRoot,
                                CFuncLogConsoleERROR,
                                "ESGL.memLoc OffCard",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                0,0,0,0,0,0,0,0);

        pCThread->FuncPtrs.ESGLAlloc       = &ESGLAlloc_OffCard;
        pCThread->FuncPtrs.ESGLAllocCancel = &ESGLAllocCancel_OffCard;
        pCThread->FuncPtrs.ESGLFree        = &ESGLFree_OffCard;
        pCThread->FuncPtrs.fillESGL        = &fill_ESGL_offCard;
    }

    if (pCThread->Calculation.MemoryLayout.SF_CMND.memLoc == inCardRam)
    {
        fiLogDebugString(pCThread->thread_hdr.hpRoot,
                                CFuncLogConsoleERROR,
                                "SF_CMND.memLoc OnCard",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                0,0,0,0,0,0,0,0);

        pCThread->FuncPtrs.fiFillInPLOGI = &fiFillInPLOGI_OnCard;
        pCThread->FuncPtrs.fiFillInFLOGI = &fiFillInFLOGI_OnCard;
        pCThread->FuncPtrs.fiFillInLOGO  = &fiFillInLOGO_OnCard;
        pCThread->FuncPtrs.fiFillInPRLI  = &fiFillInPRLI_OnCard;
        pCThread->FuncPtrs.fiFillInPRLO  = &fiFillInPRLO_OnCard;
        pCThread->FuncPtrs.fiFillInADISC = &fiFillInADISC_OnCard;
        pCThread->FuncPtrs.fiFillInSCR   = &fiFillInSCR_OnCard;
        pCThread->FuncPtrs.fiFillInSRR   = &fiFillInSRR_OnCard;
        pCThread->FuncPtrs.fiFillInREC   = &fiFillInREC_OnCard;
    }
    else /* pCThread->Calculation.MemoryLayout.SF_CMND.memLoc == inDmaMemory */
    {
        fiLogDebugString(pCThread->thread_hdr.hpRoot,
                                CFuncLogConsoleERROR,
                                "SF_CMND.memLoc OffCard",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                0,0,0,0,0,0,0,0);
        pCThread->FuncPtrs.fiFillInPLOGI = &fiFillInPLOGI_OffCard;
        pCThread->FuncPtrs.fiFillInFLOGI = &fiFillInFLOGI_OffCard;
        pCThread->FuncPtrs.fiFillInLOGO  = &fiFillInLOGO_OffCard;
        pCThread->FuncPtrs.fiFillInPRLI  = &fiFillInPRLI_OffCard;
        pCThread->FuncPtrs.fiFillInPRLO  = &fiFillInPRLO_OffCard;
        pCThread->FuncPtrs.fiFillInADISC = &fiFillInADISC_OffCard;
        pCThread->FuncPtrs.fiFillInSCR   = &fiFillInSCR_OffCard;
        pCThread->FuncPtrs.fiFillInSRR   = &fiFillInSRR_OffCard;
        pCThread->FuncPtrs.fiFillInREC   = &fiFillInREC_OffCard;
    }


    /* ERQ Entries */

    switch (pCThread->Calculation.MemoryLayout.ERQ.memLoc)
    {
        case inDmaMemory:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "ERQ.memLoc OffCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
#ifdef _DvrArch_1_30_
            pCThread->FuncPtrs.Pkt_IRB_Init = &PktFuncIRB_OffCardInit;
#endif /* _DvrArch_1_30_ was defined */
            pCThread->FuncPtrs.SF_IRB_Init = &SFFuncIRB_OffCardInit;
            pCThread->FuncPtrs.CDBFuncIRB_Init = &CDBFuncIRB_offCardInit;
            break;

        case inCardRam:
             fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "ERQ.memLoc OnCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
            pCThread->FuncPtrs.SF_IRB_Init = &SFFuncIRB_OnCardInit;
            pCThread->FuncPtrs.CDBFuncIRB_Init = &CDBFuncIRB_onCardInit;
            break;

        default: Fc_ERROR(hpRoot);
    }


    switch (pCThread->Calculation.MemoryLayout.ERQConsIndex.memLoc)
    {
        case inDmaMemory:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "ERQ.ERQConsIndex OffCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);


            pCThread->FuncPtrs.GetERQConsIndex = &CFuncGetDmaMemERQConsIndex;
            pCThread->FuncPtrs.WaitForERQ      = &WaitForERQ_ConsIndexOffCard;
            pCThread->FuncPtrs.WaitForERQEmpty = &WaitForERQEmpty_ConsIndexOffCard;
            *(ERQConsIndex_t *)(pCThread->Calculation.MemoryLayout.ERQConsIndex.addr.DmaMemory.dmaMemoryPtr) = 0;
            break;

        case inCardRam:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "ERQ.ERQConsIndex OnCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

            pCThread->FuncPtrs.GetERQConsIndex = &CFuncGetCardRamERQConsIndex;
            pCThread->FuncPtrs.WaitForERQ      = &WaitForERQ_ConsIndexOnCard;
            pCThread->FuncPtrs.WaitForERQEmpty = &WaitForERQEmpty_ConsIndexOnCard;
            osCardRamWriteBit32(hpRoot,
                    pCThread->Calculation.MemoryLayout.ERQConsIndex.addr.CardRam.cardRamOffset,
                    0
                    );

            break;

        default: Fc_ERROR(hpRoot);
    }


    /* SFQ Entries */

    switch (pCThread->Calculation.MemoryLayout.SFQ.memLoc)
    {
        case inDmaMemory:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "SFQ.memLoc OffCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

             pCThread->FuncPtrs.fiLinkSvcProcessSFQ = &fiLinkSvcProcessSFQ_OffCard;
             pCThread->FuncPtrs.fiCTProcessSFQ      = &fiCTProcessSFQ_OffCard;
             pCThread->FuncPtrs.fiSF_FCP_ProcessSFQ = &fiSF_FCP_ProcessSFQ_OffCard;
             break;

        case inCardRam:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "SFQ.memLoc OnCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
             pCThread->FuncPtrs.fiLinkSvcProcessSFQ = &fiLinkSvcProcessSFQ_OnCard;
             pCThread->FuncPtrs.fiCTProcessSFQ      = &fiCTProcessSFQ_OnCard;
             pCThread->FuncPtrs.fiSF_FCP_ProcessSFQ = &fiSF_FCP_ProcessSFQ_OnCard;
             break;

        default: Fc_ERROR(hpRoot);
    }

    /* IMQ Entries */
    pCThread->HostCopy_IMQConsIndex=0;

    switch( pCThread->Calculation.MemoryLayout.IMQ.memLoc)
    {
        case inDmaMemory:

            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "IMQ.memLoc OffCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

            pCThread->FuncPtrs.Proccess_IMQ    =&CFuncOffCardProcessIMQ;

            break;

        case inCardRam:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "IMQ.memLoc OnCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
            pCThread->FuncPtrs.Proccess_IMQ    = &CFuncOnCardProcessIMQ;
            break;

        default: Fc_ERROR(hpRoot);
    }

    switch (pCThread->Calculation.MemoryLayout.IMQProdIndex.memLoc)
    {
        case inDmaMemory:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "IMQProdIndex.memLoc OffCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

             pCThread->FuncPtrs.GetIMQProdIndex = &CFuncGetDmaMemIMQProdIndex;
             break;

        case inCardRam:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "IMQProdIndex.memLoc OnCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
             pCThread->FuncPtrs.GetIMQProdIndex = &CFuncGetCardRamIMQProdIndex;
             osCardRamWriteBit32(hpRoot,
                    pCThread->Calculation.MemoryLayout.IMQProdIndex.addr.CardRam.cardRamOffset,
                    0
                    );
             break;

        default: Fc_ERROR(hpRoot);
    }

    /* SEST Entries */

    switch (pCThread->Calculation.MemoryLayout.SEST.memLoc)
    {
        case inDmaMemory:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "SEST.memLoc OffCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

            pCThread->FuncPtrs.fiFillInFCP_SEST = &fiFillInFCP_SEST_OffCard;
            pCThread->FuncPtrs.fillLocalSGL     = &fill_Loc_SGL_offCard;

            pCThread->FuncPtrs.FCP_Completion = &CFuncSEST_offCard_FCPCompletion;
            if(pCThread->Calculation.MemoryLayout.ESGL.memLoc == inDmaMemory)
            {
                pCThread->FuncPtrs.upSEST           = &fillptr_SEST_offCard_ESGL_offCard;

            }
            else
            {
                pCThread->FuncPtrs.upSEST           = &fillptr_SEST_offCard_ESGL_onCard;
            }

            break;

        case inCardRam:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "SEST.memLoc OnCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
             pCThread->FuncPtrs.FCP_Completion = &CFuncSEST_onCard_FCPCompletion;

             pCThread->FuncPtrs.fiFillInFCP_SEST = &fiFillInFCP_SEST_OnCard;
             pCThread->FuncPtrs.fillLocalSGL     = &fill_Loc_SGL_onCard;
            if(pCThread->Calculation.MemoryLayout.ESGL.memLoc == inDmaMemory)
            {
                 pCThread->FuncPtrs.upSEST           = &fillptr_SEST_onCard_ESGL_offCard;

            }
            else
            {
                 pCThread->FuncPtrs.upSEST           = &fillptr_SEST_onCard_ESGL_onCard;
            }
            break;

        default: Fc_ERROR(hpRoot);
    }


}

void CFuncCoreReset(agRoot_t   *    hpRoot ){
    os_bit32 Reset_Reg;

    fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "CFuncCoreReset (%p)",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    0,0,0,0,0,0,0,0);

    osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Control, ChipIOUp_Frame_Manager_Control_CMD_Exit_Loop);

    osStallThread(hpRoot,1009);

    Reset_Reg = osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Control);

    Reset_Reg |=  ChipIOUp_TachLite_Control_CRS;
    Reset_Reg &= ~ ChipIOUp_TachLite_Control_GP4; /* GP04 Always Low for Janus */

    CFuncWriteTL_ControlReg( hpRoot, Reset_Reg);

    osStallThread(hpRoot,1008);

    Reset_Reg &=  ~ ChipIOUp_TachLite_Control_CRS;
    Reset_Reg &= ~ ChipIOUp_TachLite_Control_GP4; /* GP04 Always Low for Janus */

    CFuncWriteTL_ControlReg( hpRoot, Reset_Reg);

}


agBOOLEAN CFuncNewInitFM(agRoot_t   *    hpRoot )
{
    CThread_t         *pCThread = CThread_ptr(hpRoot);
    os_bit32 AL_PA_Register = 0;
    os_bit32 FM_Status = 0;
    FC_Port_ID_t    Port_ID;
    agFCChanInfo_t *Self_info = &(pCThread->ChanInfo);

    AL_PA_Register =  (osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ) & 0xFF000000 )
                                    >>  ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT;

    if (pCThread->InitAsNport)
    {
        FM_Status = osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status );
        

        if( (FM_Status & ChipIOUp_Frame_Manager_Status_PSM_MASK) ==
                                 ChipIOUp_Frame_Manager_Status_PSM_ACTIVE )
        {
            pCThread->ChanInfo.CurrentAddress.AL_PA = 0;

            Port_ID.Struct_Form.reserved = 0;
            Port_ID.Struct_Form.Domain = pCThread->ChanInfo.CurrentAddress.Domain;
            Port_ID.Struct_Form.Area   = pCThread->ChanInfo.CurrentAddress.Area;
            Port_ID.Struct_Form.AL_PA  = pCThread->ChanInfo.CurrentAddress.AL_PA;

            if (FM_Status & ChipIOUp_Frame_Manager_Status_LF ||
                    FM_Status & ChipIOUp_Frame_Manager_Status_OLS)
            {
                    fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "Detected NOS/OLS or Link Failure %08X FM Config %08X ALPA %08X",
                            (char *)agNULL,(char *)agNULL,
                            agNULL,agNULL,
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                            osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                            0,0,0,0,0);

                    /* Since we are not going to be polling and reading the IMQ, we better
                       clear the FM status register so that when we do read the frame manager
                       as a result of the interrupt, we do not process this LF or OLS again.
                     */

                    osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status, (ChipIOUp_Frame_Manager_Status_LF | ChipIOUp_Frame_Manager_Status_OLS));
                    
           }


            pCThread->DeviceSelf =  DevThreadAlloc( hpRoot,Port_ID );
            fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Clear FM DevSelf %x FM_Status %x",
                    (char *)agNULL,(char *)agNULL,
                    agNULL,agNULL,
                    (os_bit32)Self_info->CurrentAddress.AL_PA,
                    FM_Status,
                    0,
                    0,0,0,0,0);

			if (pCThread->DeviceSelf)
			{
				pCThread->DeviceSelf->DevSlot = DevThreadFindSlot(hpRoot,
                                                      Self_info->CurrentAddress.Domain,
                                                      Self_info->CurrentAddress.Area,
                                                      Self_info->CurrentAddress.AL_PA,
                                                      (FC_Port_Name_t *)(&Self_info->PortWWN));

				fiListDequeueThis(&(pCThread->DeviceSelf->DevLink));
				fiListEnqueueAtTail(&(pCThread->DeviceSelf->DevLink),&pCThread->DevSelf_NameServer_DevLink);
			}
			else
			{
				fiLogString(hpRoot,
								"%s pCThread->DeviceSelf = 0",
								"CFuncNewInitFM",(char *)agNULL,
								(void *)agNULL,(void *)agNULL,
								0,0,0,0,0,0,0,0);
				return (agFALSE);
			}

            return (agTRUE);
        }

        return (agFALSE);
    }
    else /* NOT InitAsNport */
    {
        if( pCThread->DeviceSelf == agNULL)
        {
            return agFALSE;
        }

        if (AL_PA_Register != 0x00 &&  AL_PA_Register != 0xFF)
        {
            fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "%s FM Status %08X FM Config %08X",
                        "CFuncNewInitFM",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                        0,0,0,0,0,0);

            fiLogDebugString(hpRoot,
                        CFuncLogConsoleERROR,
                        "F  %s HA %x CA %x FA %x AL_PA_Register %x",
                        "CFuncNewInitFM",(char *)NULL,
                        (void *)agNULL,(void *)agNULL,
                        (os_bit32)(pCThread->ChanInfo.HardAddress.AL_PA),
                        (os_bit32)(pCThread->ChanInfo.CurrentAddress.AL_PA),
                        AL_PA_Register,0,0,0,0,0);
            return agTRUE;

        }
        else
        {
            fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "%s FAILED  FM Status %08X FM Config %08X",
                        "CFuncNewInitFM",(char *)NULL,
                        (void *)agNULL,(void *)agNULL,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                        0,0,0,0,0,0);
           fiLogDebugString(hpRoot,
                        CFuncLogConsoleERROR,
                        "F  %s HA %x CA %x FA %x AL_PA_Register %x",
                        "CFuncNewInitFM",(char *)NULL,
                        (void *)agNULL,(void *)agNULL,
                        (os_bit32)(pCThread->ChanInfo.HardAddress.AL_PA),
                        (os_bit32)(pCThread->ChanInfo.CurrentAddress.AL_PA),
                        AL_PA_Register,0,0,0,0,0);

            return agFALSE;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\cfunc.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/CFUNC.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $
   $Modtime:: 10/14/00 12:59p $

Purpose:

  This file defines the macros, types, and data structures
  used by ../C/Cfunc.C

--*/

#ifndef __CFunc_H__
#define __CFunc_H__

#define POWER_ON_RESET_OR_BUS_DEVICE_RESET_OCCURRED     0x29
#define Interrupt_Polling_osStallThread_Parameter 21

#define SENSE_KEY_OFFSET 2
#define SENSE_ASC_OFFSET 12
#define SENSE_ASQ_OFFSET 13

#define ShowActive 1
#define ShowERQ    0


agBOOLEAN CFuncInitFM( agRoot_t *hpRoot );
os_bit32 CFuncInitChip( agRoot_t *hpRoot );

void CFuncInitFM_Registers( agRoot_t *hpRoot ,agBOOLEAN SendInit);
void CFuncInitFM_Initialize( agRoot_t *hpRoot );
agBOOLEAN CFuncInitFM_Clear_FM( agRoot_t *hpRoot );
event_t CFuncProcessFcpRsp(agRoot_t * hpRoot, CDBThread_t * pCDBThread, event_t event_to_send);

DevThread_t * CFuncMatchALPAtoThread( agRoot_t * hpRoot, FC_Port_ID_t  Port_ID);
DevThread_t * CFuncMatchPortWWNtoThread(agRoot_t * hpRoot, os_bit8 *PortWWN );
ERQConsIndex_t CFuncGetDmaMemERQConsIndex(  agRoot_t *hpRoot);
ERQConsIndex_t CFuncGetCardRamERQConsIndex( agRoot_t *hpRoot);
IMQProdIndex_t CFuncGetDmaMemIMQProdIndex(  agRoot_t *hpRoot);
IMQProdIndex_t CFuncGetCardRamIMQProdIndex( agRoot_t *hpRoot);

/* Big_Endian_Code */
void CFuncSwapDmaMemBeforeIoSent(fi_thread__t *thread, os_bit32 DoFunc);
void CFuncSwapDmaMemAfterIoDone(agRoot_t *hpRoot);

void CFuncGetHaInfoFromNVR(agRoot_t *hpRoot);

void CFuncSEST_offCard_FCPCompletion(agRoot_t * hpRoot,os_bit32 status);
void CFuncSEST_onCard_FCPCompletion(agRoot_t * hpRoot,os_bit32 status);

void CFuncFMCompletion(agRoot_t * hpRoot);
agBOOLEAN CFuncProcessNportFMCompletion(agRoot_t * hpRoot, os_bit32 fmStatus);

agBOOLEAN CFuncOffCardProcessIMQ( agRoot_t *hpRoot );
agBOOLEAN CFuncOnCardProcessIMQ(agRoot_t *hpRoot );

agBOOLEAN CFuncInterruptPoll(
                         agRoot_t *hpRoot,
                         os_bit32 * pollingCount
                       );


agBOOLEAN CFuncEnable_Queues(agRoot_t * hpRoot );


void CFuncSoftResetAdapter(agRoot_t * hpRoot);
void CFuncSoftResetAdapterNoStall(agRoot_t * hpRoot);

void CFuncDisable_Interrupts(agRoot_t * hpRoot, os_bit32 Mask);
void CFuncEnable_Interrupts(agRoot_t * hpRoot, os_bit32 Mask);

void CFuncInBoundCompletion(agRoot_t * hpRoot,os_bit32 SFQ_Index,os_bit32 Frame_len, os_bit32 Type);

void CFuncReadSFQ(agRoot_t * hpRoot, os_bit32 Frame_len,  os_bit32 SFQ_Index);
void Fc_ERROR(agRoot_t *hpRoot);

os_bit32 CFuncRead_Interrupts(agRoot_t * hpRoot);

void CFuncGreenLed(agRoot_t * hpRoot, agBOOLEAN On_or_Off);
void CFuncYellowLed(agRoot_t * hpRoot, agBOOLEAN On_or_Off);

agBOOLEAN CFuncIMQ_Interrupt_Pending(agRoot_t * hpRoot);

agBOOLEAN CFuncLoopNeedsInitializing(agRoot_t * hpRoot);

void CFuncInitializeSEST(agRoot_t * hpRoot);
void CFuncInitializeERQ(agRoot_t * hpRoot);

agBOOLEAN CFuncReInitFM( agRoot_t *hpRoot );
agBOOLEAN  CFuncClearFrameManager( agRoot_t *hpRoot, os_bit32 * Acquired_Alpa );

void CFuncInit_Lists(agRoot_t *hpRoot );

void CFuncInit_Threads(agRoot_t *hpRoot );

void  CFuncInit_DevLists( agRoot_t *hpRoot );

void  CFuncInit_TgtThreads( agRoot_t * hpRoot );

void  CFuncInit_DevThreads( agRoot_t *hpRoot );
void  CFuncInit_DirectoryDevThread(agRoot_t *hpRoot );
void CFuncInit_DevThread(agRoot_t * hpRoot, DevThread_t * pDevThread );

void  CFuncInit_CDBThreads( agRoot_t *hpRoot  );

void  CFuncInit_SFThreads( agRoot_t *hpRoot  );

void  CFuncInit_FunctionPointers(  agRoot_t *hpRoot);

void CFuncReInitializeSEST(agRoot_t * hpRoot);

void CFuncCoreReset(agRoot_t   *    hpRoot );

void CFuncOutBoundCompletion(agRoot_t * hpRoot,
         os_bit32 Bits__SEST_Index__Trans_ID,
         os_bit32 More_Bits
);

agBOOLEAN CFunc_Queues_Frozen(agRoot_t * hpRoot );

void CFuncErrorIdle(agRoot_t * hpRoot);
void CFuncErrorERQFrozen(agRoot_t * hpRoot);
void CFuncErrorFCP_Frozen(agRoot_t * hpRoot);

os_bit32 fiResetAllDevices( agRoot_t *hpRoot,  os_bit32     hpResetType );

os_bit32 fiResetDevice(
                     agRoot_t  *hpRoot,
                     agFCDev_t  hpFCDev,
                     os_bit32      hpResetType,
                     agBOOLEAN    retry,
                     agBOOLEAN  resetotherhost
                   );


os_bit32     Find_SF_Thread(  agRoot_t        *hpRoot,
                           SFQConsIndex_t   SFQConsIndex,
                           os_bit32            Frame_Length,
                           SFThread_t     **SFThread_to_return
                         );

DevSlot_t CFuncALPA_To_Slot( os_bit8 AL_PA);

agBOOLEAN CFuncLoopDownPoll( agRoot_t *hpRoot );

agBOOLEAN CFunc_Always_Enable_Queues(agRoot_t * hpRoot );

agBOOLEAN CFuncFreezeQueuesPoll( agRoot_t *hpRoot );

void CFuncInitERQ_Registers( agRoot_t *hpRoot );

agBOOLEAN CFuncAll_clear( agRoot_t *hpRoot );
agBOOLEAN CFuncTakeOffline( agRoot_t *hpRoot );
agBOOLEAN CFuncToReinit( os_bit32 FM_Status);
event_t CFuncCheckCstate(agRoot_t * hpRoot);

agBOOLEAN CFuncReadGBICSerEprom(agRoot_t * hpRoot);

agBOOLEAN CFuncShowWhereDevThreadsAre( agRoot_t * hpRoot);
agBOOLEAN CFuncShowWhereTgtThreadsAre( agRoot_t * hpRoot);
agBOOLEAN CFuncShowWhereCDBThreadsAre( agRoot_t * hpRoot);
void CFuncWhatStateAreDevThreads(agRoot_t   *    hpRoot );

void CFuncInteruptDelay(agRoot_t * hpRoot, agBOOLEAN On_or_Off);

void CFuncCompleteAllActiveCDBThreads( agRoot_t * hpRoot,os_bit32 CompletionStatus, event_t event_to_send );

agBOOLEAN CFuncCheckForTimeouts(agRoot_t *hpRoot, fiList_t * pCheckDevList);

void CFuncCompleteActiveCDBThreadsOnDevice(DevThread_t   * pDevThread ,os_bit32 CompletionStatus, event_t event_to_send );

void CFuncCompleteAwaitingLoginCDBThreadsOnDevice(DevThread_t   * pDevThread ,os_bit32 CompletionStatus, event_t event_to_send );

agBOOLEAN CFuncCheckIfPortActive( agRoot_t     *hpRoot, FC_Port_ID_t  Port_ID);
agBOOLEAN CFuncCheckIfPortPrev_Active( agRoot_t     *hpRoot, FC_Port_ID_t  Port_ID);
void CFunc_LOGO_Completion(agRoot_t * hpRoot, os_bit32 X_ID);
agBOOLEAN CFuncQuietShowWhereDevThreadsAre( agRoot_t * hpRoot);
void CFunc_Check_SEST(agRoot_t * hpRoot);
void CFunc_Check_ERQ_Registers( agRoot_t *hpRoot );
os_bit32 CFunc_Get_ERQ_Entry( agRoot_t *hpRoot, os_bit32 Search_X_ID );

void CFuncWhatStateAreCDBThreads(agRoot_t   *    hpRoot );

os_bit32 CFuncShowActiveCDBThreads( agRoot_t * hpRoot, os_bit32 Mode);
os_bit32 CFuncShowActiveCDBThreadsOnQ( agRoot_t * hpRoot, fiList_t * pShowList, os_bit32 ERQ, os_bit32 Mode );

void CFuncWriteTL_ControlReg( agRoot_t *hpRoot, os_bit32 Value_To_Write );
os_bit32 CFuncCountFC4_Devices( agRoot_t * hpRoot );

agBOOLEAN CFuncNewInitFM(agRoot_t   *    hpRoot );

void CFuncWriteTimeoutValues( agRoot_t *hpRoot, agTimeOutValue_t * TOV );

void CFuncFC_Tape( agRoot_t * hpRoot, fiList_t * pShowList , DevThread_t * DevThread );
agBOOLEAN CFuncCheckActiveDuringLinkEvent( agRoot_t * hpRoot, fiList_t * pShowList, agBOOLEAN * Sent_Abort , DevThread_t * DevThread);

void CFuncFreezeFCP( agRoot_t *hpRoot );
void CFuncWaitForFCP( agRoot_t *hpRoot );

void internSingleThreadedEnter(agRoot_t   *    hproot,os_bit32  Caller );
void internSingleThreadedLeave(agRoot_t   *    hpRoot,os_bit32  Caller );

void internAsyncSingleThreadedEnter(agRoot_t   *    hproot,os_bit32  Caller );
void internAsyncSingleThreadedLeave(agRoot_t   *    hpRoot,os_bit32  Caller );

void CFuncShowDevThreadActive( agRoot_t     *hpRoot);

agBOOLEAN CFuncCheckForDuplicateDevThread( agRoot_t     *hpRoot);

agBOOLEAN CFuncShowWhereSFThreadsAre( agRoot_t * hpRoot);
void CFuncWhatStateAreSFThreads(agRoot_t   *    hpRoot );
agBOOLEAN CFuncDoLinkSpeedNegotiation(agRoot_t * hpRoot);

void CFuncDoADISC(agRoot_t * hpRoot);
void CFuncShowNonEmptyLists(agRoot_t *hpRoot, fiList_t * pCheckDevList);

os_bit32 CFuncCheckFabricMap(agRoot_t * hpRoot, agBOOLEAN Check_Active );
os_bit32 CFuncLoopMapRecieved(agRoot_t * hpRoot, agBOOLEAN Check_Active );
os_bit32 CFunc_MAX_XL2_Payload( agRoot_t *hpRoot );

void CFuncTEST_GPIO(agRoot_t * hpRoot);
void CFuncReadBiosParms(agRoot_t * hpRoot);

#endif /*  __CFunc_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\agilent\afc\cfunc.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/CFUNC.C $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $
   $Modtime:: 10/29/00 1:06p  $

Purpose:

  This file implements functions called by the FC Layer Card State Machine.

--*/

#ifndef _New_Header_file_Layout_
#include "../h/globals.h"
#include "../h/fcstruct.h"
#include "../h/state.h"

#include "../h/tlstruct.h"
#include "../h/memmap.h"
#include "../h/fcmain.h"
#include "../h/linksvc.h"
#include "../h/cmntrans.h"
#include "../h/flashsvc.h"
#include "../h/timersvc.h"

#include "../h/cstate.h"
#include "../h/cfunc.h"
#include "../h/devstate.h"
#include "../h/cdbstate.h"
#include "../h/sfstate.h"

#include "../h/queue.h"
#include "../h/cdbsetup.h"
#else /* _New_Header_file_Layout_ */
#include "globals.h"
#include "fcstruct.h"
#include "state.h"

#include "tlstruct.h"
#include "memmap.h"
#include "fcmain.h"
#include "linksvc.h"
#include "cmntrans.h"
#include "flashsvc.h"
#include "timersvc.h"

#include "cstate.h"
#include "cfunc.h"
#include "devstate.h"
#include "cdbstate.h"
#include "sfstate.h"

#include "queue.h"
#include "cdbsetup.h"
#endif  /* _New_Header_file_Layout_ */


#ifndef __State_Force_Static_State_Tables__
extern actionUpdate_t noActionUpdate;
#endif /* __State_Force_Static_State_Tables__ was not defined */

extern os_bit8 Alpa_Index[256];

extern void Fc_ERROR(agRoot_t *hpRoot){
static int tmp=0;
    tmp++;
    fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "%s (%p) Error count %d FM Status %08X TL Status %08X",
                    "Fc_ERROR",(char *)agNULL,
                    hpRoot,agNULL,
                    tmp,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    0,0,0,0,0);

        }

#ifdef _DvrArch_1_30_
DevThread_t * CFuncMatchPortWWNtoThread(agRoot_t * hpRoot, os_bit8 *PortWWN)
{
    CThread_t     * pCThread    = CThread_ptr(hpRoot);
    DevThread_t   * pDevThread  = (DevThread_t *)agNULL;
    fiList_t      * pList;
    FC_Port_ID_t    Port_ID;

    os_bit32 i;

    for (i = 0; i < sizeof(FC_N_Port_Name_t); i++)
    {
        if (PortWWN[i] != 0xff)
             break;
    }
    if (i == 8)
    {
        fiLogDebugString(hpRoot,
                    PktStateLogConsoleLevel,
                    "WWN matched broadcast device D_ID",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

        pDevThread = pCThread->IP->BroadcastDevice;
        if (pDevThread == (DevThread_t *)agNULL)
    {
        if (pCThread->ChanInfo.CurrentAddress.Domain || pCThread->ChanInfo.CurrentAddress.Area)
        {
                Port_ID.Struct_Form.Domain = 0xff;
                Port_ID.Struct_Form.Area   = 0xff;
        }
        else
        {
                Port_ID.Struct_Form.Domain = 0;
                Port_ID.Struct_Form.Area   = 0;
        }

            Port_ID.Struct_Form.AL_PA  = 0xff;

            pCThread->IP->BroadcastDevice = pDevThread = DevThreadAlloc( hpRoot, Port_ID );

            for (i = 0; i < sizeof(FC_N_Port_Name_t); i++)
            {
                pDevThread->DevInfo.NodeWWN[i] = 0xff;
                pDevThread->DevInfo.PortWWN[i] = 0xff;
            }
    }
        pDevThread->NewIPExchange = agTRUE;

        return(pDevThread);
    }

    pList = &pCThread->Prev_Unknown_Slot_DevLink;
    pList = pList->flink;
    while((&pCThread->Prev_Unknown_Slot_DevLink) != pList)
    {
        pDevThread = hpObjectBase(DevThread_t,
                                    DevLink,pList );
        if( pDevThread )
        {
            for (i = 0; i < sizeof(FC_N_Port_Name_t); i++)
            {
                if(pDevThread->DevInfo.PortWWN[i] != PortWWN[i])
                     break;
            }
        if (i == 8)
            break;
        }
        else
        {
            fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "pDevThread agNULL",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

        }
        pList = pList->flink;
        pDevThread = (DevThread_t *)agNULL;
    }

    if( pDevThread )
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "Prev_Unknown_Slot_DevLink pDevThread Match %p - AL_PA = %X",
                    (char *)agNULL,(char *)agNULL,
                    pDevThread,agNULL,
                    pDevThread->DevInfo.CurrentAddress.AL_PA,
                    0,0,0,0,0,0,0);
         return(pDevThread);
    }

    pList = &pCThread->Slot_Searching_DevLink;
    pList = pList->flink;
    while((&pCThread->Slot_Searching_DevLink) != pList)
    {
        pDevThread = hpObjectBase(DevThread_t,
                                      DevLink,pList );
        for (i = 0; i < sizeof(FC_N_Port_Name_t); i++)
        {
           if(pDevThread->DevInfo.PortWWN[i] != PortWWN[i])
               break;
        }
        if (i == 8)
            break;

        pList = pList->flink;
        pDevThread = (DevThread_t *)agNULL;
    }

    if( pDevThread )
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "Slot_Searching_DevLink pDevThread Match %p - AL_PA = %X",
                    (char *)agNULL,(char *)agNULL,
                    pDevThread,agNULL,
                    pDevThread->DevInfo.CurrentAddress.AL_PA,
                    0,0,0,0,0,0,0);
         return(pDevThread);
    }

    pList = &pCThread->Active_DevLink;
    pList = pList->flink;
    while((&pCThread->Active_DevLink) != pList)
    {
        pDevThread = hpObjectBase(DevThread_t,
                                        DevLink,pList );

        for (i = 0; i < sizeof(FC_N_Port_Name_t); i++)
        {
           if(pDevThread->DevInfo.PortWWN[i] != PortWWN[i])
               break;
        }
        if (i == 8)
            break;

        pList = pList->flink;
        pDevThread = (DevThread_t *)agNULL;
    }

    if( pDevThread )
    {
        fiLogDebugString(hpRoot,
                    /* CStateLogConsoleLevel, */ FCMainLogErrorLevel,
                    "Active_DevLink pDevThread Match %p - AL_PA = %X",
                    (char *)agNULL,(char *)agNULL,
                    pDevThread,agNULL,
                    pDevThread->DevInfo.CurrentAddress.AL_PA,
                    0,0,0,0,0,0,0);
        return(pDevThread);
    }

    fiLogDebugString(hpRoot,
               CStateLogConsoleLevel,
               "NO Match 0n thread ALL Queues searched agNULL returned !",
               (char *)agNULL,(char *)agNULL,
               (void *)agNULL,(void *)agNULL,
               0,0,0,0,0,0,0,0);

    return(pDevThread);
}
#endif /* _DvrArch_1_30_ was defined */


DevThread_t * CFuncMatchALPAtoThread( agRoot_t * hpRoot, FC_Port_ID_t  Port_ID)
{
    CThread_t     * pCThread    = CThread_ptr(hpRoot);
    DevThread_t   * pDevThread  = (DevThread_t *)agNULL;
    fiList_t      * pList;
    os_bit8         Domain = Port_ID.Struct_Form.Domain;
    os_bit8         Area   = Port_ID.Struct_Form.Area;
    os_bit8         AL_PA  = Port_ID.Struct_Form.AL_PA;

   agBOOLEAN        UseDomainArea = (Domain || Area) ? agTRUE : agFALSE;

    pList = &pCThread->Prev_Unknown_Slot_DevLink;
    pList = pList->flink;
    while((&pCThread->Prev_Unknown_Slot_DevLink) != pList)
    {
        pDevThread = hpObjectBase(DevThread_t,
                                    DevLink,pList );
        if( pDevThread )
        {
            if (UseDomainArea)
            {
                if((pDevThread->DevInfo.CurrentAddress.Domain) &&
                  (pDevThread->DevInfo.CurrentAddress.Area == Area) &&
                  (pDevThread->DevInfo.CurrentAddress.AL_PA == AL_PA))
                     break;
            }
            else
            {
                if (pDevThread->DevInfo.CurrentAddress.AL_PA == AL_PA)
                break;
            }
        }
        else
        {
            fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "pDevThread agNULL",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

        }
        pList = pList->flink;
        pDevThread = (DevThread_t *)agNULL;
    }

    if( pDevThread )
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "Prev_Unknown_Slot_DevLink pDevThread Match %p - AL_PA = %X",
                    (char *)agNULL,(char *)agNULL,
                    pDevThread,agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0,0);
         return(pDevThread);
    }

    pList = &pCThread->Slot_Searching_DevLink;
    pList = pList->flink;
    while((&pCThread->Slot_Searching_DevLink) != pList)
    {
        pDevThread = hpObjectBase(DevThread_t,
                                      DevLink,pList );
        if (UseDomainArea)
        {
            if((pDevThread->DevInfo.CurrentAddress.Domain) &&
              (pDevThread->DevInfo.CurrentAddress.Area == Area) &&
              (pDevThread->DevInfo.CurrentAddress.AL_PA == AL_PA))
                 break;
        }
        else
        {
            if (pDevThread->DevInfo.CurrentAddress.AL_PA == AL_PA)
            break;
        }

        pList = pList->flink;
        pDevThread = (DevThread_t *)agNULL;
    }

    if( pDevThread )
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "Slot_Searching_DevLink pDevThread Match %p - AL_PA = %X",
                    (char *)agNULL,(char *)agNULL,
                    pDevThread,agNULL,
                    pDevThread->DevInfo.CurrentAddress.AL_PA,
                    0,0,0,0,0,0,0);
         return(pDevThread);
    }

    pList = &pCThread->Active_DevLink;
    pList = pList->flink;
    while((&pCThread->Active_DevLink) != pList)
    {
        pDevThread = hpObjectBase(DevThread_t,
                                        DevLink,pList );

        if (UseDomainArea)
        {
            if((pDevThread->DevInfo.CurrentAddress.Domain) &&
              (pDevThread->DevInfo.CurrentAddress.Area == Area) &&
              (pDevThread->DevInfo.CurrentAddress.AL_PA == AL_PA))
                 break;
        }
        else
        {
            if (pDevThread->DevInfo.CurrentAddress.AL_PA == AL_PA)
            break;
        }
        pList = pList->flink;
        pDevThread = (DevThread_t *)agNULL;
    }

    if( pDevThread )
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "Active_DevLink pDevThread Match %p - AL_PA = %X",
                    (char *)agNULL,(char *)agNULL,
                    pDevThread,agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0,0);
        return(pDevThread);
    }


    pList = &pCThread->Prev_Active_DevLink;
    pList = pList->flink;
    while((&pCThread->Prev_Active_DevLink) != pList)
    {
        pDevThread = hpObjectBase(DevThread_t,
                                        DevLink,pList );

        if (UseDomainArea)
        {
            if((pDevThread->DevInfo.CurrentAddress.Domain) &&
              (pDevThread->DevInfo.CurrentAddress.Area == Area) &&
              (pDevThread->DevInfo.CurrentAddress.AL_PA == AL_PA))
                 break;
        }
        else
        {
            if (pDevThread->DevInfo.CurrentAddress.AL_PA == AL_PA)
            break;
        }
        pList = pList->flink;
        pDevThread = (DevThread_t *)agNULL;
    }

    if( pDevThread )
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "Prev_Active_DevLink pDevThread Match %p - AL_PA = %X",
                    (char *)agNULL,(char *)agNULL,
                    pDevThread,agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0,0);
        return(pDevThread);
    }

    fiLogDebugString(hpRoot,
               CStateLogConsoleLevel,
               "NO Match 0n thread ALL Queues searched agNULL returned !",
               (char *)agNULL,(char *)agNULL,
               (void *)agNULL,(void *)agNULL,
               0,0,0,0,0,0,0,0);


    return(pDevThread);
}


void CFuncGetHaInfoFromNVR(agRoot_t *hpRoot)
{
    os_bit8                 Hard_Domain_Address;
    os_bit8                 Hard_Area_Address;
    os_bit8                 Hard_Loop_Address;
    fiFlash_Card_WWN_t   Card_WWN;
    agFCChanInfo_t     * Self_info = &(CThread_ptr(hpRoot)->ChanInfo);

    fiFlashGet_Hard_Address(hpRoot,
                            &Hard_Domain_Address,
                            &Hard_Area_Address,
                            &Hard_Loop_Address);

    Self_info->CurrentAddress.Domain = (os_bit8)(Hard_Domain_Address == fiFlash_Card_Unassigned_Domain_Address
                                        ? 0x00
                                        : Hard_Domain_Address);
    Self_info->CurrentAddress.Area   = (os_bit8)(Hard_Area_Address == fiFlash_Card_Unassigned_Area_Address
                                        ? 0x00
                                        : Hard_Area_Address);

    if( CThread_ptr(hpRoot)->InitAsNport)
    {
        Self_info->CurrentAddress.AL_PA  = 0;
    }
    else
    {
        Self_info->CurrentAddress.AL_PA  = Hard_Loop_Address;
    }

    Self_info->HardAddress.Domain    = (os_bit8)(Hard_Domain_Address == fiFlash_Card_Unassigned_Domain_Address
                                        ? 0x00
                                        : Hard_Domain_Address);
    Self_info->HardAddress.Area      = (os_bit8)(Hard_Area_Address == fiFlash_Card_Unassigned_Area_Address
                                        ? 0x00
                                        : Hard_Area_Address);
    Self_info->HardAddress.AL_PA     = (os_bit8)(Hard_Loop_Address == fiFlash_Card_Unassigned_Loop_Address
                                        ? 0xBA
                                        : Hard_Loop_Address);

    fiFlashGet_Card_WWN(hpRoot,
                        &Card_WWN);

    }

ERQConsIndex_t CFuncGetDmaMemERQConsIndex(
                                             agRoot_t *hpRoot
                                             )
{
    CThread_t  * pCThread = CThread_ptr(hpRoot);

    /* Big_Endian_Code */
    return osSwapBit32TachLiteToSystemEndian(
        * ((ERQConsIndex_t * )pCThread->Calculation.MemoryLayout.ERQConsIndex.addr.DmaMemory.dmaMemoryPtr)
                                            );
    }


ERQConsIndex_t CFuncGetCardRamERQConsIndex(
                                             agRoot_t *hpRoot
                                             )
{

    CThread_t  * pCThread = CThread_ptr(hpRoot);

    return( osCardRamReadBit32(hpRoot,
        pCThread->Calculation.MemoryLayout.ERQConsIndex.addr.CardRam.cardRamOffset  )
        );
    }


IMQProdIndex_t CFuncGetDmaMemIMQProdIndex(
                                             agRoot_t *hpRoot
                                           ){
    CThread_t  * pCThread = CThread_ptr(hpRoot);

    /* Big_Endian_Code */
    return osSwapBit32TachLiteToSystemEndian(
        * ((IMQProdIndex_t * )pCThread->Calculation.MemoryLayout.IMQProdIndex.addr.DmaMemory.dmaMemoryPtr)
                                            );
}


IMQProdIndex_t CFuncGetCardRamIMQProdIndex(
                                             agRoot_t *hpRoot
                                             ){
    CThread_t  * pCThread;
    pCThread = CThread_ptr(hpRoot);

    return( osCardRamReadBit32(hpRoot,
    pCThread->Calculation.MemoryLayout.IMQProdIndex.addr.CardRam.cardRamOffset ));
}



void CFuncSoftResetAdapter(agRoot_t * hpRoot)
{
    os_bit32 Reset_Reg,x;
    CThread_t *CThread                 = CThread_ptr(hpRoot);
    if(CThread) CThread->InterruptsDelayed = agFALSE;

    Reset_Reg = osChipIOUpReadBit32(hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST );
    Reset_Reg &= ~ChipIOUp_SOFTRST_MASK;
    Reset_Reg |=  ChipIOUp_SOFTRST_RST;

    osChipIOUpWriteBit32( hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST, Reset_Reg );

    osStallThread(hpRoot,100);
    for(x=0; x < 8; x++)
    {
         Reset_Reg = osChipIOUpReadBit32(hpRoot,
             ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST );
    }

    osChipIOUpWriteBit32( hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST, 0);

    for(x=0; x < 2000; x++)
    {
        osStallThread(hpRoot,200);
    }

/*
     osStallThread(hpRoot,200 * 2000);

     fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "CFuncSoftResetAdapter LARGE TIME DELAY !!!",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
*/
}

void CFuncSoftResetAdapterNoStall(agRoot_t * hpRoot)
{
    os_bit32 Reset_Reg,x;
    CThread_t *CThread                 = CThread_ptr(hpRoot);

    if(CThread) CThread->InterruptsDelayed = agFALSE;

    Reset_Reg = osChipIOUpReadBit32(hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST );
    Reset_Reg &= ~ChipIOUp_SOFTRST_MASK;
    Reset_Reg |=  ChipIOUp_SOFTRST_RST;


    osChipIOUpWriteBit32( hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST, Reset_Reg );

    osStallThread(hpRoot,100);
    for(x=0; x < 8; x++)
    {
         Reset_Reg = osChipIOUpReadBit32(hpRoot,
             ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST );
    }

    osChipIOUpWriteBit32( hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST, 0);

    fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "%s",
                    "CFuncSoftResetAdapterNoStall",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

}


void CFuncDisable_Interrupts(agRoot_t * hpRoot, os_bit32 Mask)
{
    CThread_t *CThread                 = CThread_ptr(hpRoot);
    os_bit32      sysIntsLogicallyEnabled = CThread->sysIntsLogicallyEnabled & ~Mask;
    os_bit32      INTEN_Reg;

    if (CThread->sysIntsActive == agTRUE)
    {
        INTEN_Reg = ((  osChipIOUpReadBit32(hpRoot,ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST)
                      & ~ChipIOUp_INTEN_MASK                                              )
                     | sysIntsLogicallyEnabled                                             );
    }
    else /* CThread->sysIntsActive == agFALSE */
    {
        INTEN_Reg = (  osChipIOUpReadBit32(hpRoot,ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST)
                     & ~ChipIOUp_INTEN_MASK                                              );
    }

    osChipIOUpWriteBit32( hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST, INTEN_Reg );

    CThread->sysIntsLogicallyEnabled = sysIntsLogicallyEnabled;
/* Called during interrupt
    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "In - %s Interrupts %08X sysInts - Active %x LogicallyEnabled %x",
                    "CFuncDisable_Interrupts",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST ),
                    CThread_ptr(hpRoot)->sysIntsActive,
                    CThread_ptr(hpRoot)->sysIntsLogicallyEnabled,
                    0,0,0,0,0);
*/
    }

os_bit32 CFuncRead_Interrupts(agRoot_t * hpRoot)
{

    return (osChipIOUpReadBit32(hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST ));
    }


agBOOLEAN CFuncIMQ_Interrupt_Pending(agRoot_t * hpRoot)
{

    return (
    osChipIOUpReadBit32(hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST )
        &       ChipIOUp_INTSTAT_INT      ? agTRUE : agFALSE);
}



void CFuncEnable_Interrupts(agRoot_t * hpRoot, os_bit32 Mask)
{
    CThread_t *CThread                 = CThread_ptr(hpRoot);
    os_bit32      sysIntsLogicallyEnabled = CThread->sysIntsLogicallyEnabled | Mask;
    os_bit32      INTEN_Reg;

    if (CThread->sysIntsActive ) /* CThread->sysIntsActive == agTRUE */
    {
        INTEN_Reg = ((  osChipIOUpReadBit32(hpRoot,ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST)
                      & ~ChipIOUp_INTEN_MASK                                              )
                     | sysIntsLogicallyEnabled                                             );
    }
    else /* CThread->sysIntsActive == agFALSE */
    {
        INTEN_Reg = (  osChipIOUpReadBit32(hpRoot,ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST)
                     & ~ChipIOUp_INTEN_MASK                                              );
    }

    osChipIOUpWriteBit32( hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST, INTEN_Reg );

    CThread->sysIntsLogicallyEnabled = sysIntsLogicallyEnabled;
/*  Called during interrupt
    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "In - %s Interrupts %08X sysInts - Active %x LogicallyEnabled %x",
                    "CFuncEnable_Interrupts",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST ),
                    CThread_ptr(hpRoot)->sysIntsActive,
                    CThread_ptr(hpRoot)->sysIntsLogicallyEnabled,
                    0,0,0,0,0);
*/
    }

agBOOLEAN CFuncEnable_Queues(agRoot_t * hpRoot )
{
#ifdef OSLayer_Stub
    return agFALSE;
#else /* OSLayer_Stub was not defined */
    os_bit32 Status = 0;
    Status = osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status );
    /* Micron 64 bit slot..... */
    if(Status == ChipIOUp_TachLite_Status )
    {
        Status = osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status );
        if(Status == ChipIOUp_TachLite_Status )
        {
            fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "CFuncEnable_Queues Chip BAD !!!! TL Status %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    Status,
                    0,0,0,0,0,0,0);
            return(agFALSE);
        }

      }


    if(CFunc_Queues_Frozen(hpRoot ))
    {


        if(Status & ChipIOUp_TachLite_Status_OFF )
        {
            CFuncWriteTL_ControlReg( hpRoot,
                                   (ChipIOUp_TachLite_Control_ROF |
                                    ((osChipIOUpReadBit32(hpRoot,
                                        ChipIOUp_TachLite_Control) &
                                        ChipIOUp_TachLite_Control_GPIO_0_3_MASK) &
                                        ~ ChipIOUp_TachLite_Control_GP4)));
        }

        if(Status & ChipIOUp_TachLite_Status_IFF )
        {
            CFuncWriteTL_ControlReg( hpRoot,
                                    (ChipIOUp_TachLite_Control_RIF  |
                                    ((osChipIOUpReadBit32(hpRoot,
                                        ChipIOUp_TachLite_Control) &
                                        ChipIOUp_TachLite_Control_GPIO_0_3_MASK) &
                                        ~ ChipIOUp_TachLite_Control_GP4)));
        }

        if(Status & ChipIOUp_TachLite_Status_EQF )
        {
            CFuncWriteTL_ControlReg( hpRoot,
                                   ( ChipIOUp_TachLite_Control_REQ  |
                                    ((osChipIOUpReadBit32(hpRoot,
                                        ChipIOUp_TachLite_Control) &
                                        ChipIOUp_TachLite_Control_GPIO_0_3_MASK) &
                                        ~ ChipIOUp_TachLite_Control_GP4)));
        }


        if(CFunc_Queues_Frozen(hpRoot ))
        {
/*
            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "CFuncEnable_Queues Frozen ! Return Status %08X TL Status %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    Status,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    0,0,0,0,0,0);
*/
            return agTRUE;
        }
        else
        {
            fiLogDebugString(hpRoot,
                    CSTATE_NOISE(hpRoot,CStateFindDevice),
                    "CFuncEnable_Queues Cleared Return Status %08X TL Status %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    Status,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    0,0,0,0,0,0);
         return agFALSE;
        }
    }
    return agFALSE;
#endif  /* OSLayer_Stub */

}

agBOOLEAN CFunc_Always_Enable_Queues(agRoot_t * hpRoot )
{
#ifdef OSLayer_Stub
    return agFALSE;
#else /* OSLayer_Stub was not defined */
    os_bit32 Status = 0;

    Status = osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status );

    if(CFunc_Queues_Frozen(hpRoot ))
    {
        CFuncWriteTL_ControlReg( hpRoot,
                                    (ChipIOUp_TachLite_Control_ROF |
                                    Status &  ChipIOUp_TachLite_Control_GPIO_0_3_MASK &
                                            ~ ChipIOUp_TachLite_Control_GP4));

        CFuncWriteTL_ControlReg( hpRoot,
                                    (ChipIOUp_TachLite_Control_RIF  |
                                    Status &  ChipIOUp_TachLite_Control_GPIO_0_3_MASK &
                                            ~ ChipIOUp_TachLite_Control_GP4));

        CFuncWriteTL_ControlReg( hpRoot,
                                    (ChipIOUp_TachLite_Control_REQ  |
                                    Status &  ChipIOUp_TachLite_Control_GPIO_0_3_MASK &
                                            ~ ChipIOUp_TachLite_Control_GP4));

    }
    CThread_ptr(hpRoot)->ERQ_FROZEN = agFALSE;
    CThread_ptr(hpRoot)->FCP_FROZEN = agFALSE;
    CThread_ptr(hpRoot)->IDLE_RECEIVED = agFALSE;

    if(CFunc_Queues_Frozen(hpRoot ))
    {
/*
         fiLogDebugString(hpRoot,
                    CSTATE_NOISE(hpRoot,CStateFindDevice),
                    "CFunc_Always_Enable_Queues Frozen ! Return Status %08X TL Status %08X FM %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    Status,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    0,0,0,0,0);
*/
            return agTRUE;
    }
    else
    {

/*
        fiLogDebugString(hpRoot,
                    CStateLogConsoleLevelLip,
                    "CFunc_Always_Enable_Queues Cleared Return Status %08X TL Status %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    Status,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    0,0,0,0,0,0);
*/
         return agFALSE;
    }

#endif  /* OSLayer_Stub */

}

agBOOLEAN CFunc_Queues_Frozen(agRoot_t * hpRoot )
{
#ifndef OSLayer_Stub
    os_bit32 Status = 0;
    Status = osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status );

    if(Status & (   ChipIOUp_TachLite_Status_OFF |
                    ChipIOUp_TachLite_Status_IFF |
                    ChipIOUp_TachLite_Status_EQF ))

    {
        return(agTRUE);
    }
#endif /* OSLayer_Stub was not defined */
    return(agFALSE);
}

void CFuncGreenLed(agRoot_t * hpRoot, agBOOLEAN On_or_Off)
{   /* Green Led - Is one by default at power up */
    os_bit32 Reg_Mask;
    Reg_Mask = osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Control );

    if( CThread_ptr(hpRoot)->JANUS)
    {
        if( On_or_Off) Reg_Mask &= ~ ChipIOUp_TachLite_Control_GP3;
        else Reg_Mask |= ChipIOUp_TachLite_Control_GP3; /* Link LED */
    }
    else
    {
        if( On_or_Off) Reg_Mask &= ~ ChipIOUp_TachLite_Control_GP2;
        else Reg_Mask |= ChipIOUp_TachLite_Control_GP2; /* Green LED */
    }
    /* GP04 Always Low for Leds */
    CFuncWriteTL_ControlReg( hpRoot, Reg_Mask & ~ ChipIOUp_TachLite_Control_GP4);

}


void CFuncYellowLed(agRoot_t * hpRoot, agBOOLEAN On_or_Off)
{
    os_bit32 Reg_Mask;
    Reg_Mask = osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Control );

    if( CThread_ptr(hpRoot)->JANUS)
    {
        if( On_or_Off) Reg_Mask |= ChipIOUp_TachLite_Control_GP2;
        else Reg_Mask &= ~ ChipIOUp_TachLite_Control_GP2; /* Active LED */
    }
    else
    {
        if( On_or_Off)
        {
            CThread_ptr(hpRoot)->Yellow_LED_State = agTRUE;
            Reg_Mask |= ChipIOUp_TachLite_Control_GP3;
        }
        else
        {
            CThread_ptr(hpRoot)->Yellow_LED_State = agFALSE;
            Reg_Mask &= ~ ChipIOUp_TachLite_Control_GP3; /* Yellow LED */
        }
    }
    /* GP04 Always Low for Leds */
    CFuncWriteTL_ControlReg( hpRoot, Reg_Mask & ~ ChipIOUp_TachLite_Control_GP4);

}

void CFuncWriteTL_ControlReg( agRoot_t *hpRoot, os_bit32 Value_To_Write )
{
    CThread_t * pCThread= CThread_ptr(hpRoot);
    /* Set GP4 High Always */
    if(pCThread->LaserEnable)
    {
        Value_To_Write |= ChipIOUp_TachLite_Control_GP4;
    }
    else
    {
        Value_To_Write &= ~ChipIOUp_TachLite_Control_GP4;

    }
    if( Value_To_Write & ChipIOUp_TachLite_Control_GP3 )
    {
        if( !CThread_ptr(hpRoot)->Yellow_LED_State)
        {
            Value_To_Write &= ~ ChipIOUp_TachLite_Control_GP3; /* Yellow LED */
        }
    }
    osChipIOUpWriteBit32(hpRoot, ChipIOUp_TachLite_Control, Value_To_Write);
}



/**/

void CFuncInteruptDelay(agRoot_t * hpRoot, agBOOLEAN On_or_Off)
{
    os_bit32    Reg_Mask = 0;
    os_bit32    GPIO_REG = 0;
    CThread_t * CThread = CThread_ptr(hpRoot);

#ifdef USE_XL_Delay_Register
    os_bit32    Delay_val = ChipIOUp_Interrupt_Delay_Timer_1ms;

    Delay_val = ChipIOUp_Interrupt_Delay_Timer_250;
    if (CThread->DEVID == ChipConfig_DEVID_TachyonXL2)
    {
/*         fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "CFuncInteruptDelay %s (%x) %s Addr %p %x",
                    "ChipConfig_DEVID_TachyonXL2",On_or_Off ? "On " : "Off",
                    &Delay_val,(void *)agNULL,
                    ChipIOLo_Interrupt_Delay_Timer,
                    Delay_val,0,0,0,0,0,0);
*/
        if( On_or_Off)
        {
            CThread_ptr(hpRoot)->XL2DelayActive = agTRUE;
            osChipIOLoWriteBit32( hpRoot, ChipIOLo_Interrupt_Delay_Timer, Delay_val  );
        }
        else
        {
            CThread_ptr(hpRoot)->XL2DelayActive = agFALSE;
            osChipIOLoWriteBit32( hpRoot, ChipIOLo_Interrupt_Delay_Timer, ChipIOUp_Interrupt_Delay_Timer_Immediate );
            CThread->FuncPtrs.Proccess_IMQ(hpRoot);
        }
        return;
    }
#endif /* USE_XL_Delay_Register */
    if( CThread_ptr(hpRoot)->JANUS)
    {   /* 1 millisecond delay */
        Reg_Mask = osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Control );
        if( On_or_Off)
        {
            CFuncWriteTL_ControlReg( hpRoot,
                        ChipIOUp_TachLite_Control_GP3 |
                        ChipIOUp_TachLite_Control_GP4);

            CFuncWriteTL_ControlReg( hpRoot,
                        ChipIOUp_TachLite_Control_GP3 |
                        ChipIOUp_TachLite_Control_GP4);

            CFuncWriteTL_ControlReg( hpRoot,
                        ChipIOUp_TachLite_Control_GP3 );
        }
        else
        {
            /*Delay off */
            CFuncWriteTL_ControlReg( hpRoot,
                                ChipIOUp_TachLite_Control_GP4   );

            CFuncWriteTL_ControlReg( hpRoot,
                                ChipIOUp_TachLite_Control_GP4   );

            CFuncWriteTL_ControlReg( hpRoot,
                                0   );
        }
        /* Restore Leds */
        CFuncWriteTL_ControlReg( hpRoot, Reg_Mask & ~ ChipIOUp_TachLite_Control_GP4);

    }
    else
    {
        if( On_or_Off)
        {/* 1 millisecond delay */

            GPIO_REG = osChipIOUpReadBit32( hpRoot, ChipIOUp_TachLite_Control);

            GPIO_REG = (GPIO_REG & ~MemMap_GPIO_BITS_MASK) | CThread->Calculation.Parameters.IntDelayAmount;
/*
            GPIO_REG = (GPIO_REG & ~MemMap_GPIO_BITS_MASK) | (ChipIOUp_TachLite_Control_GP0    );
*/
            CFuncWriteTL_ControlReg( hpRoot, GPIO_REG );
        }
        else
        {
            GPIO_REG = osChipIOUpReadBit32( hpRoot, ChipIOUp_TachLite_Control );

            GPIO_REG = (GPIO_REG & ~MemMap_GPIO_BITS_MASK) | MemMap_GPIO_BITS_PAL_Delay_0_00_ms;

            CFuncWriteTL_ControlReg( hpRoot, GPIO_REG );
        }
    }

/*
     fiLogString(hpRoot,
                    "%s %s %08X",
                    "CFuncInteruptDelay",On_or_Off ? "On " : "Off",
                    (void *)agNULL,(void *)agNULL,
                    GPIO_REG,
                    0,0,0,0,0,0,0);
*/

}

void CFuncReInitializeSEST(agRoot_t * hpRoot){
    CThread_t  * pCThread = CThread_ptr(hpRoot);
    os_bit32 num_sest_entry = pCThread->Calculation.MemoryLayout.SEST.elements - 1;
    os_bit32 x;
    os_bit32 sest_offset;
    USE_t                     *SEST;


    if(pCThread->Calculation.MemoryLayout.SEST.memLoc ==  inDmaMemory)
    {

        fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "SEST.memLoc OffCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

        SEST = (USE_t *)pCThread->Calculation.MemoryLayout.SEST.addr.DmaMemory.dmaMemoryPtr;
        for(x= 0; x < num_sest_entry; x++, SEST++)
        {
            SEST->Bits =0;
        }

    }
    else
    {   /* inCardRam */
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "SEST.memLoc OnCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

             sest_offset  = pCThread->Calculation.MemoryLayout.SEST.addr.CardRam.cardRamOffset;

        for(x= 0; x < num_sest_entry; x++ )
        {

            osCardRamWriteBit32(
                                 hpRoot,
                                 sest_offset + (sizeof(USE_t) * x),
                                 0);

        }

    }

}

os_bit32 fiResetDevice(
                     agRoot_t  *hpRoot,
                     agFCDev_t  hpFCDev,
                     os_bit32   hpResetType,
                     agBOOLEAN  retry,
                     agBOOLEAN  resetotherhost
                   )
{
    CThread_t *pCThread= CThread_ptr(hpRoot);
    DevThread_t * pDevThread = (DevThread_t *)hpFCDev;

    fiLogDebugString(hpRoot,
                    FCMainLogErrorLevel,
                    "In fiResetDevice %p Alpa %X CCnt %x DCnt %x",
                    (char *)agNULL,(char *)agNULL,
                    hpFCDev,agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCThread->CDBpollingCount,
                    pDevThread->pollingCount,
                    resetotherhost,0,0,0,0);

    if ( hpFCDev == agNULL )
    {
        return fcResetFailure;
    }

    pCThread->thread_hdr.subState = CSubStateResettingDevices;

    if ((hpResetType & fcHardSoftResetMask) == fcSoftReset)
    {
        fiSendEvent(&pDevThread->thread_hdr,DevEventLogin);
    }
    else
    {
        Retry_Reset:
        if( pCThread->thread_hdr.currentState != CStateNormal )
        {
            return fcResetFailure;
        }

       fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "Device current state %d DEVReset_pollingCount %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pDevThread->thread_hdr.currentState,
                    pCThread->DEVReset_pollingCount,
                    0,0,0,0,0,0);

        fiSendEvent(&pDevThread->thread_hdr, DevEventAllocDeviceResetHard);
        if(CFuncInterruptPoll( hpRoot,&pCThread->DEVReset_pollingCount ))
        {
            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "Reset Dev Fail Poll (%x )Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->DEVReset_pollingCount,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Received_ALPA),
                    0,0,0);
        }

       fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "Device current state %d",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pDevThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);

        if(  (pDevThread->thread_hdr.currentState == DevStateHandleAvailable ) &&
             (pDevThread->Failed_Reset_Count))
        {
            pDevThread->Failed_Reset_Count              = 0;
            goto Retry_Reset;
        }


        if(  pDevThread->thread_hdr.currentState != DevStateHandleAvailable )
        {
            if(retry)
            {
                Login_Retry:
                fiSendEvent(&pDevThread->thread_hdr,DevEventLogin);
                if(CFuncInterruptPoll( hpRoot,&pCThread->FindDEV_pollingCount ))
                {
                    fiLogDebugString(hpRoot,
                                    CStateLogConsoleERROR,
                                    "Reset Dev Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                                    0,0,0,0);
                }

                pDevThread->Failed_Reset_Count += 1;

                if(pDevThread->thread_hdr.currentState == DevStateHandleAvailable )
                {
                    if( pDevThread->Failed_Reset_Count < FC_MAX_RESET_RETRYS )
                    {
                        goto Retry_Reset;
                    }
                }
                else
                {
                    if( pDevThread->Failed_Reset_Count < FC_MAX_RESET_RETRYS )
                    {
                        goto Login_Retry;
                    }
                }
            }
        }
    }

    pCThread->thread_hdr.subState = CSubStateInitialized;

    return fcResetSuccess;
}


os_bit32 fiResetAllDevices( agRoot_t *hpRoot,  os_bit32     hpResetType )
{
    CThread_t *pCThread = CThread_ptr(hpRoot);

    DevThread_t   * pDevThread;
    fiList_t      * pList;

    agFCDev_t  hpFCDev[127];
    os_bit32 numDevs,x,ResetStatus;

    pList = &pCThread->Active_DevLink;
    pList = pList->flink;
    numDevs=0;

    CFuncCompleteAllActiveCDBThreads( hpRoot, osIODevReset,CDBEventIODeviceReset );

    while((&pCThread->Active_DevLink) != pList)
    {
        hpFCDev[numDevs] = hpObjectBase(DevThread_t, DevLink,pList );
        numDevs ++;
        pList = pList->flink;
        pDevThread = (DevThread_t *)agNULL;  /*What ?*/
    }
    fiLogDebugString(hpRoot,
                    FCMainLogErrorLevel,
                    "num Devs %d TO reset",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    numDevs,
                    0,0,0,0,0,0,0);

    if(numDevs)
    {
        for(x= 0; x < numDevs; x++)
        {
            if( pCThread->thread_hdr.currentState != CStateNormal )
            {
                return fcResetFailure;
            }

            if( ((DevThread_t *)hpFCDev[x])->DevInfo.DeviceType & agDevSCSITarget)
            {
                pDevThread = (DevThread_t *)hpFCDev[x];
                fiLogDebugString(hpRoot,
                                FCMainLogErrorLevel,
                                "agDevSCSITarget ID %X",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                fiComputeDevThread_D_ID(pDevThread),
                                0,0,0,0,0,0,0);

                ResetStatus = fiResetDevice( hpRoot, hpFCDev[x],hpResetType, agTRUE, agFALSE );
            }
        }
    }
    else
    {
/*
        fiLogDebugString(hpRoot,
                        FCMainLogErrorLevel,
                        "%s Sending Shutdown !",
                        "fiResetAllDevices",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);
        fiSendEvent(&(pCThread->thread_hdr),CEventShutdown);
        fiSendEvent(&(pCThread->thread_hdr),CEventDoInitalize);
*/

        /* Maybe send Device resets ????
        if( pCThread->thread_hdr.currentState == CStateNormal )
        */


    }

    return fcResetSuccess;

}


/* Returns true if Loop stays down */
agBOOLEAN CFuncLoopDownPoll( agRoot_t *hpRoot )
{
    CThread_t       *   CThread      = CThread_ptr(hpRoot);
    os_bit32               PollingCalls = 0;

    fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "CFuncLoopDownPoll LD %x IR %x InIMQ %x",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        CThread->LOOP_DOWN,
                        CThread->IDLE_RECEIVED,
                        CThread->ProcessingIMQ,
                        0,0,0,0,0);
    if (CThread->InitAsNport)
    {/* Does not make sense to wait for this when Nport */
        return(agTRUE);
    }



    while( CThread->LOOP_DOWN )
    {
        PollingCalls++;

        if( CThread->thread_hdr.currentState == CStateLIPEventStorm         ||
            CThread->thread_hdr.currentState == CStateElasticStoreEventStorm   ) return(agTRUE);

        if( (osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ) &
                                        ChipIOUp_Frame_Manager_Status_LSM_MASK) ==
                                        ChipIOUp_Frame_Manager_Status_LSM_Loop_Fail )
        {
            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "LSM Loop Fail FM Status %08X FM Config %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    0,0,0,0,0,0);

            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "Loop Fail TL Status %08X TL Control %08X Alpa %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Control),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                    0,0,0,0,0);
            return(agTRUE);
        }


        if(PollingCalls > 2 * ( SF_EDTOV / Interrupt_Polling_osStallThread_Parameter))
        {
               fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "CFuncLoopDownPoll  TIMEOUT FM %08X InIMQ %x TL status %08X Qf %d",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    CThread->ProcessingIMQ,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    CFunc_Queues_Frozen( hpRoot ),
                    0,0,0,0);


            return(agTRUE);
        }
        if( ! CThread->FuncPtrs.Proccess_IMQ( hpRoot ))
        {
            if(osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ) &
                   (~ ( ChipIOUp_Frame_Manager_Status_LP      |
                        ChipIOUp_Frame_Manager_Status_LSM_MASK   )) )
            {
                if (CThread->HostCopy_IMQConsIndex == CThread->FuncPtrs.GetIMQProdIndex(hpRoot))
                {
                    CFuncFMCompletion(hpRoot);
                }
                else
                {
                    continue;
                }
            }
        }
        osStallThread(
                       hpRoot,
                       Interrupt_Polling_osStallThread_Parameter
                     );

        fiTimerTick(
                       hpRoot,
                       Interrupt_Polling_osStallThread_Parameter
                     );

    }
    return(agFALSE);
}

/* Returns true if Queues Don't Freeze */
agBOOLEAN CFuncFreezeQueuesPoll( agRoot_t *hpRoot )
{
    CThread_t       *   CThread      = CThread_ptr(hpRoot);
    os_bit32            PollingCalls = 0;

    os_bit32 Status = 0;

    Status = osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status );
    fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "CFuncFreezeQueuesPoll LD %x IR %x  IMQ %x Queues %x TL Status %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        CThread->LOOP_DOWN,
                        CThread->IDLE_RECEIVED,
                        CThread->ProcessingIMQ,
                        CFunc_Queues_Frozen( hpRoot ),
                        Status,
                        0,0,0);


    if(CFunc_Queues_Frozen( hpRoot ))
    {

        fiLogString(hpRoot,
                        "%s FROZEN Already FM %08X TL %08X",
                        "CFFQPoll",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                        0,0,0,0,0,0);
/*
        CFuncWriteTL_ControlReg( hpRoot,
                                    ChipIOUp_TachLite_Control_FFA |
                                    Status &  ChipIOUp_TachLite_Control_GPIO_0_3_MASK &
                                            ~ ChipIOUp_TachLite_Control_GP4);

        CFuncWriteTL_ControlReg( hpRoot,
                                    ChipIOUp_TachLite_Control_FEQ |
                                    Status &  ChipIOUp_TachLite_Control_GPIO_0_3_MASK &
                                            ~ ChipIOUp_TachLite_Control_GP4);

        return(agTRUE);
*/
    }

    fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "TL Setting %s %08X",
                        "ChipIOUp_TachLite_Control_FEQ",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        (ChipIOUp_TachLite_Control_FEQ |
                                (Status & ( ChipIOUp_TachLite_Control_GPIO_0_3_MASK &
                                        ~ ChipIOUp_TachLite_Control_GP4))),
                        0,0,0,0,0,0,0);

    CFuncWriteTL_ControlReg( hpRoot,
                               ( ChipIOUp_TachLite_Control_FEQ |
                               (( Status &  ChipIOUp_TachLite_Control_GPIO_0_3_MASK )&
                                        ~ ChipIOUp_TachLite_Control_GP4)));

    while( ! CThread_ptr(hpRoot)->ERQ_FROZEN  )
    {
        if( CThread->thread_hdr.currentState == CStateLIPEventStorm         ||
            CThread->thread_hdr.currentState == CStateElasticStoreEventStorm   ) return(agTRUE);

        PollingCalls++;

        if(PollingCalls > 2 * ( SF_EDTOV / Interrupt_Polling_osStallThread_Parameter))
        {
            fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "ERQ CFuncFreezeQueuesPoll  TIMEOUT FM %08X InIMQ %x TL status %08X Qf %d",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                        CThread->ProcessingIMQ,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                        CFunc_Queues_Frozen( hpRoot ),
                        0,0,0,0);

            fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "LD %x IR %x OR %x ERQ %x FCP %x Queues %x",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        CThread_ptr(hpRoot)->LOOP_DOWN,
                        CThread_ptr(hpRoot)->IDLE_RECEIVED,
                        CThread_ptr(hpRoot)->OUTBOUND_RECEIVED,
                        CThread_ptr(hpRoot)->ERQ_FROZEN,
                        CThread_ptr(hpRoot)->FCP_FROZEN,
                        CFunc_Queues_Frozen( hpRoot ),
                        0,0);

            return(agTRUE);
        }
        if( ! CThread->FuncPtrs.Proccess_IMQ( hpRoot ))
        {
            if(osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ) &
                   (~ ( ChipIOUp_Frame_Manager_Status_LP      |
                        ChipIOUp_Frame_Manager_Status_LSM_MASK   )) )
            {
                if (CThread->HostCopy_IMQConsIndex == CThread->FuncPtrs.GetIMQProdIndex(hpRoot))
                {
                    CFuncFMCompletion(hpRoot);
                }
                else
                {
                    continue;
                }
            }
        }

        CFuncWriteTL_ControlReg( hpRoot,
                                   (ChipIOUp_TachLite_Control_FFA |
                                   (( Status &  ChipIOUp_TachLite_Control_GPIO_0_3_MASK) &
                  