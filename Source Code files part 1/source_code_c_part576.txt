ing message", lpd->dwParentID);
		return DPERR_INVALIDGROUP;
	}

	// Take the dplay lock
	ENTER_DPLAY();

	// First see if the group is in our map table.  If it is,
	// we just want to return.  If it's not, we want to add
	// them and send the appropriate message
	if(IsLobbyIDInMapTable(this, lpd->dwGroupID))
	{
		DPF(2, "Received a CreateGroupInGroup message for a group we already know about");
		hr = DP_OK;
		goto ERROR_DPLP_CREATEGROUPINGROUP;
	}
	else
	{
		// Setup the internal flags
		if(lpd->dwFlags & DPGROUP_STAGINGAREA)
			dwInternalFlags = DPLAYI_GROUP_STAGINGAREA;
		if(lpd->dwFlags & DPGROUP_HIDDEN)
			dwInternalFlags |= DPLAYI_GROUP_HIDDEN;
		
		// Make the owner default to the server player if we have a problem
		dwOwnerID = DPID_SERVERPLAYER;

		// If we are talking to at least a DX6 lobby provider, we should
		// be able to use the GroupOwnerID element
		if(this->dwLPVersion > DPLSP_DX5VERSION)
			dwOwnerID = lpd->dwGroupOwnerID;
		
		// It doesn't show up in our map table, so create a new
		// nametable entry for them and put them in our map table.
		hr = PRV_CreateAndMapNewGroup(this, &dpidGroup, lpd->lpName,
				NULL, 0, dwInternalFlags,
				lpd->dwGroupID, lpd->dwParentID, dwOwnerID);
		if(FAILED(hr))
		{
			DPF(8, "Unable to add group to nametable or map table, hr = 0x%08x", hr);
			goto ERROR_DPLP_CREATEGROUPINGROUP;
		}

		bCreated = TRUE;
	}

	// So now we should have a valid group and valid player in both
	// the map table and the nametable, so call dplay with the add message
	hr = InternalAddGroupToGroup((LPDIRECTPLAY)this->lpDPlayObject->pInterfaces,
				lpd->dwParentID, lpd->dwGroupID, lpd->dwFlags, FALSE);
	if(FAILED(hr))
	{
		// If we created the player and mapped it, then destroy the
		// player and unmap it.
		if(bCreated)
		{
			// Get a pointer to dplay's group struct
			lpGroup = GroupFromID(this->lpDPlayObject, lpd->dwGroupID);

			// Remove the group from the nametable
			if(lpGroup){
				InternalDestroyGroup(this->lpDPlayObject, lpGroup, FALSE);
			}	
		}

		// If we failed, don't send the system message
		DPF_ERRVAL("Failed creating remote group in group from the lobby, hr = 0x%08x", hr);
		goto ERROR_DPLP_CREATEGROUPINGROUP;
	}


	// Now build the system message (at least the parts we need)
	memset(&msg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
	SET_MESSAGE_HDR(&msg);
	SET_MESSAGE_COMMAND(&msg, DPSP_MSG_CREATEGROUP);
	msg.dwPlayerID = lpd->dwGroupID;

	// Find dplay's internal group struct for the To group
	lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
	if(!lpGroupTo)
	{
		DPF_ERRVAL("Unable to find group in nametable, hr = 0x%08x", hr);
		hr = DPERR_INVALIDGROUP;
		goto ERROR_DPLP_CREATEGROUPINGROUP;
	}

	// Call dplay's DistributeGroupMessage function to put the message
	// in the queues of all the appropriate players
	hr = DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
			(LPBYTE)&msg, sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
	if(FAILED(hr))
	{
		DPF(8, "Failed adding CreateGroupInGroup message to player's receive queue from lobby, hr = 0x%08x", hr);
	}


ERROR_DPLP_CREATEGROUPINGROUP:

	// Drop the lock
	LEAVE_LOBBY_ALL();
	return hr;

} // DPLP_CreateGroupInGroup



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DeleteRemoteGroupFromGroup"
HRESULT PRV_DeleteRemoteGroupFromGroup(LPDPLOBBYI_DPLOBJECT this,
			LPSPDATA_DELETEREMOTEGROUPFROMGROUP lpd, BOOL fPropagate,
			LPDPLAYI_GROUP lpStopParent)
{
	LPDPLAYI_GROUP			lpGroupTo = NULL;
	LPDPLAYI_GROUP			lpGroup = NULL, lpParentGroup = NULL;
	MSG_PLAYERMGMTMESSAGE	msg;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering PRV_DeleteRemoteGroupFromGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x, %lu, 0x%08x",
			this, lpd, fPropagate, lpStopParent);


	// First see if the group is in our map table.  If it's not,
	// we should just ignore this message because it's for a
	// group we are not currently in.
	if(!IsLobbyIDInMapTable(this, lpd->dwParentID))
	{
		DPF(8, "Recieved DeleteGroupFromGroup message for unknown parent group, dwGroupID = %lu, discarding message", lpd->dwParentID);
		return DPERR_INVALIDGROUP;
	}

	// Now make sure the group is in our map table.  If it's not,
	// we should just ignore this message because it's for a
	// group we don't know about.
	if(!IsLobbyIDInMapTable(this, lpd->dwGroupID))
	{
		DPF(8, "Recieved DeleteGroupFromGroup message for unknown group, dwGroupID = %lu, discarding message", lpd->dwGroupID);
		return DPERR_INVALIDGROUP;
	}

	// Take the lock
	ENTER_DPLAY();

	// Get dplay's internal group structures
	lpParentGroup = GroupFromID(this->lpDPlayObject, lpd->dwParentID);
	if(!lpParentGroup)
	{
		LEAVE_DPLAY();
		DPF(8, "Unable to find parent group in nametable");
		return DPERR_INVALIDGROUP;
	}

	lpGroup = GroupFromID(this->lpDPlayObject, lpd->dwGroupID);
	if(!lpGroup)
	{
		LEAVE_DPLAY();
		DPF(8, "Unable to find group in nametable");
		return DPERR_INVALIDGROUP;
	}

	// Call dplay's internal removegroupfromgroup to remove the attachment
	// in the nametable
	hr = RemoveGroupFromGroup(lpParentGroup, lpGroup);
	if(FAILED(hr))
	{
		DPF(8, "Failed removing group from group, hr = 0x%08x", hr);
		goto EXIT_DPLP_DELETEREMOTEGROUPFROMGROUP;
	}

	// If the fPropagate flag is not set, we don't want to send this message
	if(fPropagate)
	{
		// Now build the system message (at least the parts we need)
		memset(&msg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
		SET_MESSAGE_HDR(&msg);
		SET_MESSAGE_COMMAND(&msg, DPSP_MSG_DELETEGROUPFROMGROUP);
		msg.dwPlayerID = lpd->dwGroupID;
		msg.dwGroupID = lpd->dwParentID;

		lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
		if(!lpGroupTo)
		{
			DPF(8, "Unable to find system group in nametable");
			goto EXIT_DPLP_DELETEREMOTEGROUPFROMGROUP;
		}

		// Call dplay's DistributeGroupMessage function to put the message
		// in the queues of all the appropriate players
		DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
				(LPBYTE)&msg, sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
		if(FAILED(hr))
		{
			DPF(8, "Failed adding DeleteGroupFromGroup message to player's receive queue from lobby, hr = 0x%08x", hr);
		}
	}

	// Even if we couldn't send the message above, destroy the group anyway

EXIT_DPLP_DELETEREMOTEGROUPFROMGROUP:

	// Destroy the group and any of it's parents if there are no more local
	// references to it or any of it's heirarchy
	PRV_DestroyGroupAndParents(this, lpGroup, lpStopParent);

	// Drop the lock
	LEAVE_DPLAY();

	return hr;

} // PRV_DeleteRemoteGroupFromGroup



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_DeleteGroupFromGroup"
HRESULT DPLAPI DPLP_DeleteGroupFromGroup(LPDPLOBBYSP lpILP,
					LPSPDATA_DELETEREMOTEGROUPFROMGROUP lpd)
{
	LPDPLOBBYI_DPLOBJECT	this;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering DPLP_DeleteGroupFromGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpILP, lpd);

	ENTER_DPLOBBY();

	//	Make sure the LP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpILP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLOBBY();
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

		// Validate the struct pointer
		if(!lpd)
		{
			LEAVE_DPLOBBY();
			DPF_ERR("SPDATA_DELETEREMOTEGROUPFROMGROUP structure pointer cannot be NULL");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// Call our internal routine, setting the propagate flag to TRUE so that
	// we post the appropriate message in the player's receive queue
	hr = PRV_DeleteRemoteGroupFromGroup(this, lpd, TRUE, NULL);

	LEAVE_DPLOBBY();
	return hr;

} // DPLP_DeleteGroupFromGroup



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DeleteRemotePlayerFromGroup"
HRESULT PRV_DeleteRemotePlayerFromGroup(LPDPLOBBYI_DPLOBJECT this,
			LPSPDATA_DELETEREMOTEPLAYERFROMGROUP lpd, BOOL fPropagate)
{
	LPDPLAYI_PLAYER			lpPlayer = NULL;
	LPDPLAYI_GROUP			lpGroupTo = NULL;
	MSG_PLAYERMGMTMESSAGE	msg, dpmsg;
	HRESULT					hr;


	DPF(7, "Entering PRV_DeleteRemotePlayerFromGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x, %lu", this, lpd, fPropagate);


	// First see if the group is in our map table.  If it's not,
	// we should just ignore this message because it's for a
	// group we are not currently in.
	if(!IsLobbyIDInMapTable(this, lpd->dwGroupID))
	{
		DPF(8, "Recieved DeletePlayerFromGroup message for unknown group, dwGroupID = %lu, discarding message", lpd->dwGroupID);
		return DPERR_INVALIDGROUP;
	}

	// Now make sure the player is in our map table.  If it's not,
	// we should just ignore this message because it's for a
	// player we don't know about.
	if(!IsLobbyIDInMapTable(this, lpd->dwPlayerID))
	{
		DPF(8, "Recieved DeletePlayerFromGroup message for unknown player, dwPlayerID = %lu, discarding message", lpd->dwGroupID);
		return DPERR_INVALIDPLAYER;
	}

	// Take the lock
	ENTER_DPLAY();

	// Call dplay's internal removeplayerfromgroup to remove the attachment
	// in the nametable
	hr = InternalDeletePlayerFromGroup((LPDIRECTPLAY)this->lpDPlayObject->pInterfaces,
			lpd->dwGroupID, lpd->dwPlayerID, FALSE);
	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed removing player from group, hr = 0x%08x", hr);
		goto ERROR_DPLP_DELETEPLAYERFROMGROUP;
	}

	// If the fPropagate flag is not set, we don't want to send this message
	if(fPropagate)
	{
		// Now build the system message (at least the parts we need)
		memset(&msg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
		SET_MESSAGE_HDR(&msg);
		SET_MESSAGE_COMMAND(&msg, DPSP_MSG_DELETEPLAYERFROMGROUP);
		msg.dwPlayerID = lpd->dwPlayerID;
		msg.dwGroupID = lpd->dwGroupID;

		// Find dplay's internal group struct for the To group
		lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
		if(!lpGroupTo)
		{
			DPF_ERRVAL("Unable to find group in nametable, hr = 0x%08x", hr);
			hr = DPERR_INVALIDGROUP;
			goto ERROR_DPLP_DELETEPLAYERFROMGROUP;
		}

		// Call dplay's DistributeGroupMessage function to put the message
		// in the queues of all the appropriate players
		DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
				(LPBYTE)&msg, sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
		if(FAILED(hr))
		{
			DPF(8, "Failed adding DeletePlayerFromGroup message to player's receive queue from lobby, hr = 0x%08x", hr);
		}
	}

	// Get dplay's internal group & player structures
	lpPlayer = PlayerFromID(this->lpDPlayObject, lpd->dwPlayerID);
	if(!lpPlayer)
	{
		// So if this fails, the above call to InternalDeletePlayerFromGroup
		// shouldn't have succeeded either
		DPF_ERR("Unable to find player in nametable");
		ASSERT(FALSE);
		goto ERROR_DPLP_DELETEPLAYERFROMGROUP;
	}

	// Now we need to decide if this is the last group this player was in.  If
	// it is, then we need to destroy the player as well, and remove them from
	// our map table.  Of course, only destroy the player if it is a remote player.
	if((!(lpPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)) &&
		(!(lpPlayer->dwFlags & DPLAYI_PLAYER_PLAYERINGROUP)))
	{
		// However, before we do this, we need to send a DestroyPlayer
		// message to all the people who got the DeletePlayerFromGroup
		if(lpGroupTo && fPropagate)
		{
			// Now build the system message (at least the parts we need)
			memset(&dpmsg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
			SET_MESSAGE_HDR(&dpmsg);
			SET_MESSAGE_COMMAND(&dpmsg, DPSP_MSG_DELETEPLAYER);
			dpmsg.dwPlayerID = lpd->dwPlayerID;

			// Call dplay's DistributeGroupMessage function to put the message
			// in the queues of all the appropriate players
			DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
					(LPBYTE)&dpmsg, sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
			if(FAILED(hr))
			{
				DPF(8, "Failed adding DestroyPlayer message to player's receive queue from lobby, hr = 0x%08x", hr);
			}
		}

		// Destroy the player and remove it from the nametable
		InternalDestroyPlayer(this->lpDPlayObject, lpPlayer, FALSE, FALSE);
	}


ERROR_DPLP_DELETEPLAYERFROMGROUP:

	// Drop the lock
	LEAVE_DPLAY();

	return hr;

} // PRV_DeleteRemotePlayerFromGroup



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_DeletePlayerFromGroup"
HRESULT DPLAPI DPLP_DeletePlayerFromGroup(LPDPLOBBYSP lpILP,
						LPSPDATA_DELETEREMOTEPLAYERFROMGROUP lpd)
{
	LPDPLOBBYI_DPLOBJECT	this;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering DPLP_DeletePlayerFromGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpILP, lpd);

	ENTER_DPLOBBY();

	//	Make sure the LP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpILP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLOBBY();
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

		// Validate the struct pointer
		if(!lpd)
		{
			LEAVE_DPLOBBY();
			DPF_ERR("SPDATA_DELETEREMOTEPLAYERFROMGROUP structure pointer cannot be NULL");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// Call our internal routine, setting the propagate flag to TRUE so that
	// we post the appropriate message in the player's receive queue
	hr = PRV_DeleteRemotePlayerFromGroup(this, lpd, TRUE);

	LEAVE_DPLOBBY();
	return hr;

} // DPLP_DeletePlayerFromGroup



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_BroadcastDestroyGroupMessage"
HRESULT DPLAPI PRV_BroadcastDestroyGroupMessage(LPDPLOBBYI_DPLOBJECT this,
					DWORD dwGroupID)
{
	MSG_PLAYERMGMTMESSAGE	msg;
	LPDPLAYI_GROUP			lpGroupTo = NULL;
	HRESULT					hr;


	// Now build the system message (at least the parts we need)
	memset(&msg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
	SET_MESSAGE_HDR(&msg);
	SET_MESSAGE_COMMAND(&msg, DPSP_MSG_DELETEGROUP);
	msg.dwGroupID = dwGroupID;

	// Find dplay's internal group struct for the To group
	lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
	if(!lpGroupTo)
	{
		DPF_ERR("Unable to find system group in nametable");
		hr = DPERR_INVALIDGROUP;
	}
	else
	{
		// Call dplay's DistributeGroupMessage function to put the message in the queue
		hr = DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
				(LPBYTE)&msg, sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
		if(FAILED(hr))
		{
			DPF(8, "Failed adding DestroyGroup message to player's receive queue from lobby, hr = 0x%08x", hr);
		}
	}

	return hr;

} // PRV_BroadcastDestroyGroupMessage



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_RemoveSubgroupsAndPlayersFromGroup"
void PRV_RemoveSubgroupsAndPlayersFromGroup(LPDPLOBBYI_DPLOBJECT this,
		LPDPLAYI_GROUP lpGroup, DWORD dwGroupID, BOOL bRemoteOnly)
{
	SPDATA_DELETEREMOTEPLAYERFROMGROUP	dpd;
	LPDPLAYI_GROUPNODE					lpGroupnode = NULL;
	LPDPLAYI_GROUPNODE					lpNextGroupnode = NULL;
	HRESULT								hr = DP_OK;


	DPF(7, "Entering PRV_RemoveSubgroupsAndPlayersFromGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x", this, lpGroup);

	ASSERT(lpGroup);

	// Destroy any subgroups hanging off of this group
	PRV_DestroySubgroups(this, lpGroup, bRemoteOnly);

	// Walk the list of nodes, removing each player from the group manually.
	// The reason for doing this manually is so that the lobby gets a chance
	// to remove every remote player out of the nametable whose only existence
	// was inside this room.  It also allows the lobby to remove the player's
	// ID from the map table.  Do this by calling the lobby's
	// DPLP_DeletePlayerFromGroup function which responds to that message.

	// Setup the DeletePlayerFromGroup data structure
	memset(&dpd, 0, sizeof(SPDATA_DELETEREMOTEPLAYERFROMGROUP));
	dpd.dwSize = sizeof(SPDATA_DELETEREMOTEPLAYERFROMGROUP);
	dpd.dwGroupID = dwGroupID;

	// Walk the list of groupnodes, deleting all of the remote players
	lpGroupnode = lpGroup->pGroupnodes;
	while(lpGroupnode)
	{
		// Save the next groupnode
		lpNextGroupnode = lpGroupnode->pNextGroupnode;
		
		// If the player is local, skip them
		if(lpGroupnode->pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)
		{
			lpGroupnode = lpNextGroupnode;
			continue;
		}

		// Get the lobby ID for the player
		dpd.dwPlayerID = lpGroup->pGroupnodes->pPlayer->dwID;

		// Now call the lobby's delete function, setting the fPropagate flag
		// to true so we put a delete message in the player's queue
		hr = PRV_DeleteRemotePlayerFromGroup(this, &dpd, TRUE);
		if(FAILED(hr))
		{
			// Same here, if this fails, something is tragically wrong
			// with the map table, so just continue;
			ASSERT(FALSE);
			break;
		}

		// Move to the next node
		lpGroupnode = lpNextGroupnode;
	}

} // PRV_RemoveSubgroupsAndPlayersFromGroup



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SendDeleteShortcutMessageForExitingGroup"
void PRV_SendDeleteShortcutMessageForExitingGroup(LPDPLOBBYI_DPLOBJECT this,
			LPDPLAYI_GROUP lpGroup)
{
	MSG_PLAYERMGMTMESSAGE	msg;
	LPDPLAYI_GROUP			lpGroupTo = NULL;
	LPDPLAYI_GROUP			lpGroupTemp = NULL;
	LPDPLAYI_SUBGROUP		lpSubgroupTemp = NULL;
	UINT					nGroupsIn;
	HRESULT					hr;


	DPF(7, "Entering PRV_SendDeleteShortcutMessageForExitingGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x", this, lpGroup);

	// Take the dplay lock since we will be walking dplay's group list
	ENTER_DPLAY();

	// Get the number of subgroups this group is in
	nGroupsIn = lpGroup->nGroups;

	// Setup the static parts of the message, and get a pointer to the system group
	if(nGroupsIn)
	{
		// Build the message struct
		memset(&msg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
		SET_MESSAGE_HDR(&msg);
		SET_MESSAGE_COMMAND(&msg, DPSP_MSG_DELETEGROUPFROMGROUP);
		msg.dwPlayerID = lpGroup->dwID;

		// Get a pointer to the system group
		lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
		if(!lpGroupTo)
		{
			LEAVE_DPLAY();
			DPF_ERR("Unable to get a pointer to the system group - not sending deletegroupfromgroup messages");
			return;
		}
	}

	// Walk the list of groups, and send a DeleteGroupFromGroup message
	// for each shortcut
	lpGroupTemp = this->lpDPlayObject->pGroups;
	while(nGroupsIn && lpGroupTemp)
	{
		// Walk the list of subgroups for the group
		lpSubgroupTemp = lpGroupTemp->pSubgroups;
		while(nGroupsIn && lpSubgroupTemp)
		{
			// If the group is our group, send a message, but only if
			// it is not the parent group (since we will never do a
			// DeleteGroupFromGroup on a parent-child)
			if(lpSubgroupTemp->pGroup == lpGroup)
			{
				// Make sure it's not the group's parent
				if(lpGroup->dwIDParent != lpGroupTemp->dwID)
				{
					// Send the message
					msg.dwGroupID = lpGroupTemp->dwID;

					// Call dplay's DistributeGroupMessage function to put the message
					// in the queues of all the appropriate players
					hr = DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
							(LPBYTE)&msg, sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
					if(FAILED(hr))
					{
						DPF(8, "Failed adding DeleteGroupFromGroup message to player's receive queue from lobby, hr = 0x%08x", hr);
					}
				}

				// Decrement the count of subgroups
				nGroupsIn--;
			}
			
			// Move to the next subgroup
			lpSubgroupTemp = lpSubgroupTemp->pNextSubgroup;
		}

		// Move to the next group
		lpGroupTemp = lpGroupTemp->pNextGroup;
	}

	ASSERT(!nGroupsIn);

	// Drop the dplay lock since we're done
	LEAVE_DPLAY();

} // PRV_SendDeleteShortcutMessageForExitingGroup



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_DestroyGroup"
HRESULT DPLAPI DPLP_DestroyGroup(LPDPLOBBYSP lpILP,
					LPSPDATA_DESTROYREMOTEGROUP lpd)
{
	LPDPLOBBYI_DPLOBJECT				this;
	HRESULT								hr = DP_OK;
	LPDPLAYI_GROUP						lpGroup = NULL;
	LPDPLAYI_GROUPNODE					lpGroupNode = NULL;


	DPF(7, "Entering DPLP_DestroyGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpILP, lpd);

	ENTER_DPLOBBY();

	//	Make sure the LP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpILP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLOBBY();
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

		// Validate the struct pointer
		if(!lpd)
		{
			LEAVE_DPLOBBY();
			DPF_ERR("SPDATA_DESTROYGROUP structure pointer cannot be NULL");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// First see if the group is in our map table.  If it's not,
	// we should just ignore this message because it's for a
	// group we are not currently in.
	if(!IsLobbyIDInMapTable(this, lpd->dwGroupID))
	{
		LEAVE_DPLOBBY();
		DPF(8, "Recieved DestroyGroup message for unknown group, dwGroupID = %lu, discarding message", lpd->dwGroupID);
		return DPERR_INVALIDGROUP;
	}

	// This is either a group we are in, or it is a root group.  If it has
	// any players, it's a group we are in, so we need to delete all remote
	// players from the nametable and map table (if this is the only group
	// they are in).

	// Take the lock
	ENTER_DPLAY();

	// So, get dplay's internal group structure
	lpGroup = GroupFromID(this->lpDPlayObject, lpd->dwGroupID);
	if(!lpGroup)
	{
		// If we don't have an lpGroup, we need to fail because some of
		// the functions below will crash if lpGroup is invalid.
		DPF(8, "Unable to find group in nametable, dpidGroup = %lu", lpd->dwGroupID);
		LEAVE_LOBBY_ALL();
		return DPERR_INVALIDGROUP;
	}

	// Send messages to remove shortcuts to this group (since dplay won't
	// do it for us)
	PRV_SendDeleteShortcutMessageForExitingGroup(this, lpGroup);

	// Destroy all the remote subgroups and players
	PRV_RemoveSubgroupsAndPlayersFromGroup(this, lpGroup, lpd->dwGroupID, FALSE);

	// Now send a DestroyGroup system message to all the local players
	hr = PRV_BroadcastDestroyGroupMessage(this, lpd->dwGroupID);

	// Now call dplay's destroy group
	hr = InternalDestroyGroup(this->lpDPlayObject, lpGroup, FALSE); 
	if(FAILED(hr))
	{
		DPF(8, "Failed destroying group from nametable, hr = 0x%08x", hr);
	}

	// Drop the locks
	LEAVE_LOBBY_ALL();

	return hr;

} // DPLP_DestroyGroup



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_GetSPDataPointer"
HRESULT DPLAPI DPLP_GetSPDataPointer(LPDPLOBBYSP lpDPLSP, LPVOID * lplpData)
{
	LPDPLOBBYI_DPLOBJECT this;


	//	Make sure the SP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpDPLSP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }
	
	// Go ahead and save the pointer
	*lplpData = this->lpSPData;

	return DP_OK;

} // DPLP_GetSPDataPointer



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_HandleLobbySystemMessage"
HRESULT PRV_HandleLobbySystemMessage(LPDPLOBBYI_DPLOBJECT this,
						LPSPDATA_HANDLEMESSAGE lpd)
{
	LPDPLMSG_GENERIC				lpmsg = lpd->lpBuffer;
	LPDPLMSG_GETPROPERTYRESPONSE	lpgpr = NULL;
	LPDPLOBBYI_REQUESTNODE			lprn = NULL;
	HRESULT							hr = DP_OK;

	
	// If it's a property message, we need to deal with the request
	switch(lpmsg->dwType)
	{
		case DPLSYS_GETPROPERTYRESPONSE:
		case DPLSYS_SETPROPERTYRESPONSE:
		{
			// Cast it to a GetPropertyResponse message
			lpgpr = (LPDPLMSG_GETPROPERTYRESPONSE)lpmsg;
			
			// Find the request ID in our list of pending requests
			lprn = this->lprnHead;
			while(lprn)
			{
				if(lprn->dwRequestID == lpgpr->dwRequestID)
					break;
				else
					lprn = lprn->lpNext;
			}

			// Print some debug spew if we didn't find it, but return DP_OK since
			// we "handled" the message
			if(!lprn)
			{
				DPF(5, "Unable to find request ID in pending request list");
				return DP_OK;
			}

			// See if we slammed the guid, and replace it with GUID_NULL if we did
			if(lprn->dwFlags & GN_SLAMMED_GUID)
				lpgpr->guidPlayer = GUID_NULL;
			
			// If we found it, swap out the request ID, and send it to the
			// appropriate place
			lpgpr->dwRequestID = lprn->dwAppRequestID;
			if(lprn->dwFlags & GN_SELF_LOBBIED)
			{
				// Put the message in the lobby message receive queue
				hr = PRV_InjectMessageInQueue(lprn->lpgn, DPLMSG_STANDARD,
						lpgpr, lpd->dwBufSize, FALSE);
				if(FAILED(hr))
				{
					DPF_ERRVAL("Failed to put message in lobby receive queue, hr = 0x%08x", hr);
					goto EXIT_HANDLELOBBYSYSTEMMESSAGE;
				}
			}
			else
			{
				// Call SendLobbyMessage to send the message to the game
				hr = PRV_WriteClientData(lprn->lpgn, DPLMSG_STANDARD,
						lpgpr, lpd->dwBufSize);
				if(FAILED(hr))
				{
					DPF_ERRVAL("Failed to forward message to game, hr = 0x%08x", hr);
					goto EXIT_HANDLELOBBYSYSTEMMESSAGE;
				}
			}

			break;
		}
		default:
			break;
	}

EXIT_HANDLELOBBYSYSTEMMESSAGE:
	
	// Remove the pending request node if we serviced it (which would have
	// happened if we have a valid pointer to it)
	if(lprn)
		PRV_RemoveRequestNode(this, lprn);	
	
	return hr;

} // PRV_HandleLobbySystemMessage



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_HandleMessage"
HRESULT DPLAPI DPLP_HandleMessage(LPDPLOBBYSP lpILP,
						LPSPDATA_HANDLEMESSAGE lpd)
{
	LPDPLOBBYI_DPLOBJECT	this;
	HRESULT					hr = DP_OK;
	LPMSG_PLAYERMESSAGE		lpmsg = NULL;
	LPBYTE					lpByte = NULL;
	DWORD					dwSize;
	BOOL					bAllocBuffer = FALSE;
	LPDPLAYI_PLAYER			lpPlayer = NULL;


	DPF(7, "Entering DPLP_HandleMessage");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpILP, lpd);

	ENTER_DPLOBBY();
	
	//	Make sure the LP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpILP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLOBBY();
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

		// Validate the struct pointer
		if(!lpd)
		{
			LEAVE_DPLOBBY();
			DPF_ERR("SPDATA_HANDLEMESSAGE structure pointer cannot be NULL");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	// If the message is a lobby system message, process it
	// NOTE: Make sure the size of the SPDATA_HANDLEMESSAGE is big enough
	// to contain a flags field (the shipping 5.0 bits did not have
	// this field, but the 5.1 bits did).
	if((lpd->dwSize > DPLOBBYPR_SIZE_HANDLEMESSAGE_DX50) &&
		(lpd->dwFlags & DPSEND_LOBBYSYSTEMMESSAGE))
	{
		hr = PRV_HandleLobbySystemMessage(this, lpd);
		if(FAILED(hr))
		{
			DPF_ERRVAL("Unable to handle lobby system message, hr = 0x%08x", hr);
		}

		LEAVE_DPLOBBY();
		return hr;
	}

	// REVIEW!!!! -- We should be able to handle a generic send to a group
	// as well as a player.  Currently, I don't think we do.

	// If this session is using naked messages, we can just send the buffer.
	// Otherwise, we need to allocate a MSG_PLAYERMESSAGE struct and fill
	// in the header.
	if(this->lpDPlayObject->lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID)
	{
		lpmsg = lpd->lpBuffer;
		dwSize = lpd->dwBufSize;
	}
	else
	{
		// Calculate the size of the message
		dwSize = sizeof(MSG_PLAYERMESSAGE) + lpd->dwBufSize;

		// Allocate memory for a message buffer
		lpmsg = DPMEM_ALLOC(dwSize);
		if(!lpmsg)
		{
			DPF_ERR("Unable to allocate temporary message buffer");
			hr = DPERR_OUTOFMEMORY;
			goto ERROR_DPLP_HANDLEMESSAGE;
		}

		// Copy in the message header
		lpmsg->idFrom = lpd->dwFromID;
		lpmsg->idTo = lpd->dwToID;

		// Copy in the message
		lpByte = (LPBYTE)lpmsg + sizeof(MSG_PLAYERMESSAGE);
		memcpy(lpByte, lpd->lpBuffer, lpd->dwBufSize);

		// Set our flag indicating that we allocated a buffer
		bAllocBuffer = TRUE;
	}

	// Take the lock
	ENTER_DPLAY();

	// Find dplay's internal player struct for the To player
	lpPlayer = PlayerFromID(this->lpDPlayObject, lpd->dwToID);
	if(!lpPlayer)
	{
		LEAVE_DPLAY();
		DPF_ERRVAL("Unable to find player in nametable, hr = 0x%08x", hr);
		hr = DPERR_INVALIDPLAYER;
		goto ERROR_DPLP_HANDLEMESSAGE;
	}

	// Call dplay's handleplayermessage function to put the message in the queue
	hr = HandlePlayerMessage(lpPlayer, (LPBYTE)lpmsg, dwSize, TRUE, 0);
	if(FAILED(hr))
	{
		DPF(8, "Failed adding message to player's receive queue from lobby, hr = 0x%08x", hr);
	}

	// Drop the lock
	LEAVE_DPLAY();
			

ERROR_DPLP_HANDLEMESSAGE:
	if(bAllocBuffer && lpmsg)
		DPMEM_FREE(lpmsg);

	LEAVE_DPLOBBY();
	return hr;

} // DPLP_HandleMessage



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_SendChatMessage"
HRESULT DPLAPI DPLP_SendChatMessage(LPDPLOBBYSP lpILP,
						LPSPDATA_CHATMESSAGE lpd)
{
	LPDPLOBBYI_DPLOBJECT	this;
	HRESULT					hr = DP_OK;
	LPMSG_CHAT				lpmsg = NULL;
	LPBYTE					lpByte = NULL;
	DWORD					dwSize;
	LPDPLAYI_PLAYER			lpPlayer = NULL;
	LPDPLAYI_GROUP			lpGroup = NULL;
	DWORD					dwStringSize;
	BOOL					bToGroup = FALSE;
		


	DPF(7, "Entering DPLP_SendChatMessage");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpILP, lpd);

	ENTER_DPLOBBY();
	
	//	Make sure the LP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpILP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLOBBY();
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

		// Validate the struct pointer
		if(!lpd)
		{
			LEAVE_DPLOBBY();
			DPF_ERR("SPDATA_HANDLEMESSAGE structure pointer cannot be NULL");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	// Calculate the size of the message
	dwStringSize = WSTRLEN_BYTES(lpd->lpChat->lpszMessage);
	dwSize = sizeof(MSG_CHAT) + dwStringSize;

	// Allocate memory for a message buffer
	lpmsg = DPMEM_ALLOC(dwSize);
	if(!lpmsg)
	{
		DPF_ERR("Unable to allocate temporary message buffer");
		hr = DPERR_OUTOFMEMORY;
		goto ERROR_DPLP_SENDCHATMESSAGE;
	}

	// Copy in the message header
	SET_MESSAGE_HDR(lpmsg);
	SET_MESSAGE_COMMAND(lpmsg,DPSP_MSG_CHAT);
	lpmsg->dwIDFrom = lpd->dwFromID;
	lpmsg->dwIDTo = lpd->dwToID;
	lpmsg->dwFlags = lpd->lpChat->dwFlags;
	lpmsg->dwMessageOffset = sizeof(MSG_CHAT);

	// Copy in the message
	lpByte = (LPBYTE)lpmsg + sizeof(MSG_CHAT);
	memcpy(lpByte, lpd->lpChat->lpszMessage, dwStringSize);


	// Take the lock
	ENTER_DPLAY();

	// Make sure it's from a valid player or the server player
	if(lpd->dwFromID != DPID_SERVERPLAYER)
	{
		lpPlayer = PlayerFromID(this->lpDPlayObject, lpd->dwFromID);
		if(!VALID_DPLAY_PLAYER(lpPlayer)) 
		{
			LEAVE_DPLAY();
			DPF_ERR("Received chat message FROM invalid player id!!");
			hr = DPERR_INVALIDPLAYER;
			goto ERROR_DPLP_SENDCHATMESSAGE;
		}
	}

	// See who the message is for
	lpPlayer = PlayerFromID(this->lpDPlayObject, lpd->dwToID);
	if(!VALID_DPLAY_PLAYER(lpPlayer)) 
	{
		// See if it's to a group
		lpGroup = GroupFromID(this->lpDPlayObject, lpd->dwToID);
		if(!VALID_DPLAY_GROUP(lpGroup))
		{
			LEAVE_DPLAY();
			DPF_ERR("Received chat message for invalid player / group");
			hr = DPERR_INVALIDPLAYER;
			goto ERROR_DPLP_SENDCHATMESSAGE;
		}
		bToGroup = TRUE;
	}

	// Send it out
	if(bToGroup)
	{
		// Send the message
		hr = DistributeGroupMessage(this->lpDPlayObject, lpGroup,
				(LPBYTE)lpmsg, dwSize, FALSE, 0);						
	} 
	else 
	{
		// Send the message
		hr = HandlePlayerMessage(lpPlayer, (LPBYTE)lpmsg, dwSize, FALSE, 0);
	}

	// Drop the lock
	LEAVE_DPLAY();
			

ERROR_DPLP_SENDCHATMESSAGE:
	if(lpmsg)
		DPMEM_FREE(lpmsg);

	LEAVE_DPLOBBY();
	return hr;

} // DPLP_SendChatMessage



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SendDataChangedMessageLocally"
HRESULT PRV_SendDataChangedMessageLocally(LPDPLOBBYI_DPLOBJECT this,
		DPID dpidPlayer, LPVOID lpData, DWORD dwDataSize)
{
	LPDPLAYI_GROUP			lpGroupTo = NULL;
	HRESULT					hr = DP_OK;
	LPMSG_PLAYERDATA		lpmsg = NULL;
	LPBYTE					lpByte = NULL;
	DWORD					dwSize;


	DPF(7, "Entering PRV_SendDataChangedMessageLocally");
	DPF(9, "Parameters: 0x%08x, %lu, 0x%08x, %lu",
			this, dpidPlayer, lpData, dwDataSize);


	// Take the lock
	ENTER_DPLAY();
	
	// Setup the message to put in the player's queue
	// Calculate the size of the message
	dwSize = sizeof(MSG_PLAYERDATA) + dwDataSize;

	// Allocate memory for the message
	lpmsg = DPMEM_ALLOC(dwSize);
	if(!lpmsg)
	{
		DPF_ERR("Unable to allocate memory for temporary message structure");
		// Since the name has been changed, we'll just return success here
		hr = DP_OK;
		goto EXIT_SENDDATACHANGED;
	}

	// Now build the system message
	SET_MESSAGE_HDR(lpmsg);
	SET_MESSAGE_COMMAND(lpmsg, DPSP_MSG_PLAYERDATACHANGED);
	lpmsg->dwPlayerID = dpidPlayer;
	lpmsg->dwDataSize = dwDataSize;
	lpmsg->dwDataOffset = sizeof(MSG_PLAYERDATA);

	// Copy in the data
	lpByte = (LPBYTE)lpmsg + sizeof(MSG_PLAYERDATA);
	memcpy(lpByte, lpData, dwDataSize);

	// Find dplay's internal group struct for the To group
	lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
	if(!lpGroupTo)
	{
		DPF_ERRVAL("Unable to find group in nametable, hr = 0x%08x", hr);
		hr = DPERR_INVALIDGROUP;
		goto EXIT_SENDDATACHANGED;
	}

	// Call dplay's DistributeGroupMessage function to put the message
	// in the queues of all the appropriate players
	hr = DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
			(LPBYTE)lpmsg, dwSize, FALSE, 0);
	if(FAILED(hr))
	{
		DPF(8, "Failed adding SetGroupData message to player's receive queue from lobby, hr = 0x%08x", hr);
	}

EXIT_SENDDATACHANGED:

	// Free our message
	if(lpmsg)
		DPMEM_FREE(lpmsg);
	
	// Drop the lock
	LEAVE_DPLAY();

	return hr;

} // PRV_SendDataChangedMessageLocally



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SendNameChangedMessageLocally"
HRESULT PRV_SendNameChangedMessageLocally(LPDPLOBBYI_DPLOBJECT this,
		DPID dpidPlayer, LPDPNAME lpName, BOOL bPlayer)
{
	LPDPLAYI_GROUP			lpGroupTo = NULL;
	HRESULT					hr = DP_OK;
	LPMSG_PLAYERNAME		lpmsg = NULL;
	DWORD					dwSize, dwShortSize = 0, dwLongSize = 0;
	LPBYTE					lpByte = NULL;

	DPF(7, "Entering PRV_SendNameChangedMessageLocally");
	DPF(9, "Parameters: 0x%08x, %lu, 0x%08x, 0x%08x",
			this, dpidPlayer, lpName, bPlayer);


	// Take the lock
	ENTER_DPLAY();
	
	// Setup the message to put in the player's queue
	// Calculate the size of the message
	if(lpName->lpszShortName)
		dwShortSize = WSTRLEN_BYTES(lpName->lpszShortName);
	if(lpName->lpszLongName)
		dwLongSize = WSTRLEN_BYTES(lpName->lpszLongName);
	dwSize = sizeof(MSG_PLAYERNAME) + dwShortSize + dwLongSize;

	// Allocate memory for the message
	lpmsg = DPMEM_ALLOC(dwSize);
	if(!lpmsg)
	{
		DPF_ERR("Unable to allocate memory for temporary message structure");
		// Since the name has been changed, we'll just return success here
		hr = DP_OK;
		goto EXIT_SENDNAMECHANGED;
	}

	// Now build the system message
	SET_MESSAGE_HDR(lpmsg);
	if(bPlayer)
		SET_MESSAGE_COMMAND(lpmsg, DPSP_MSG_PLAYERNAMECHANGED);
	else
		SET_MESSAGE_COMMAND(lpmsg, DPSP_MSG_GROUPNAMECHANGED);
	lpmsg->dwPlayerID = dpidPlayer;
	lpmsg->dwShortOffset = sizeof(MSG_PLAYERNAME);
	lpmsg->dwLongOffset = sizeof(MSG_PLAYERNAME) + dwShortSize;

	// Copy in the names
	lpByte = (LPBYTE)lpmsg + sizeof(MSG_PLAYERNAME);
	memcpy(lpByte, lpName->lpszShortName, dwShortSize);
	lpByte += dwShortSize;
	memcpy(lpByte, lpName->lpszLongName, dwLongSize);

	// Find dplay's internal group struct for the To group
	lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
	if(!lpGroupTo)
	{
		DPF_ERRVAL("Unable to find group in nametable, hr = 0x%08x", hr);
		hr = DPERR_INVALIDGROUP;
		goto EXIT_SENDNAMECHANGED;
	}

	// Call dplay's DistributeGroupMessage function to put the message
	// in the queues of all the appropriate players
	hr = DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
			(LPBYTE)lpmsg, dwSize, FALSE, 0);
	if(FAILED(hr))
	{
		DPF(8, "Failed adding SetGroupName message to player's receive queue from lobby, hr = 0x%08x", hr);
	}


EXIT_SENDNAMECHANGED:

	// Free our message
	if(lpmsg)
		DPMEM_FREE(lpmsg);
	
	// Drop the lock
	LEAVE_DPLAY();

	return hr;

} // PRV_SendNameChangedMessageLocally



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_SetGroupName"
HRESULT DPLAPI DPLP_SetGroupName(LPDPLOBBYSP lpILP,
					LPSPDATA_SETREMOTEGROUPNAME lpd)
{
	LPDPLOBBYI_DPLOBJECT	this;
	LPDPLAYI_GROUP			lpGroup = NULL;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering DPLP_SetGroupName");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpILP, lpd);

	ENTER_DPLOBBY();
	
	//	Make sure the LP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpILP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLOBBY();
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

		// Validate the struct pointer
		if(!lpd)
		{
			LEAVE_DPLOBBY();
			DPF_ERR("SPDATA_SETGROUPNAME structure pointer cannot be NULL");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	
	// First see if the group is in our map table.  If it is not,
	// we should just ignore this message because it's for a
	// group we don't know about.
	if(!IsLobbyIDInMapTable(this, lpd->dwGroupID))
	{
		LEAVE_DPLOBBY();
		DPF(8, "Recieved SetGroupName message for unknown group, dwGroupID = %lu, discarding message", lpd->dwGroupID);
		return DPERR_INVALIDGROUP;
	}

	// Take the lock
	ENTER_DPLAY();

	// See if the group is local or remote.  If it's local, ignore this message
	// and just return DP_OK becuase we've already sent this message locally.
	lpGroup = GroupFromID(this->lpDPlayObject, lpd->dwGroupID);
	if((!lpGroup) || (lpGroup->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
	{
		hr = DP_OK;
		goto ERROR_DPLP_SETGROUPNAME;
	}

	// Call dplay's internalsetname function to update the name in the cache
	hr = InternalSetName((LPDIRECTPLAY)this->lpDPlayObject->pInterfaces,
			lpd->dwGroupID, lpd->lpName, FALSE, lpd->dwFlags, FALSE);
	if(FAILED(hr))
	{
		DPF(8, "Failed to SetGroupName internally for remote group, hr = 0x%08x", hr);
		goto ERROR_DPLP_SETGROUPNAME;
	}

	// Send the message to all the local players
	hr = PRV_SendNameChangedMessageLocally(this, lpd->dwGroupID, lpd->lpName, FALSE);

ERROR_DPLP_SETGROUPNAME:

	// Drop the locks
	LEAVE_LOBBY_ALL();

	return hr;

} // DPLP_SetGroupName



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SendGroupOwnerMessageLocally"
HRESULT PRV_SendGroupOwnerMessageLocally(LPDPLOBBYI_DPLOBJECT this,
		DPID dpidGroup, DPID dpidNewOwner, DPID dpidOldOwner)
{
	LPDPLAYI_GROUP			lpGroupTo = NULL;
	HRESULT					hr = DP_OK;
	MSG_GROUPOWNERCHANGED	msg;


	DPF(7, "Entering PRV_SendGroupOwnerMessageLocally");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			this, dpidGroup, dpidNewOwner, dpidOldOwner);


	// Take the lock
	ENTER_DPLAY();
	
	// Now build the system message
	memset(&msg, 0, sizeof(MSG_GROUPOWNERCHANGED));
	SET_MESSAGE_HDR(&msg);
	SET_MESSAGE_COMMAND(&msg, DPSP_MSG_GROUPOWNERCHANGED);
	msg.dwIDGroup = dpidGroup;
	msg.dwIDNewOwner = dpidNewOwner;
	msg.dwIDOldOwner = dpidOldOwner;

	// Find dplay's internal group struct for the To group
	lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
	if(!lpGroupTo)
	{
		DPF_ERRVAL("Unable to find group in nametable, hr = 0x%08x", hr);
		hr = DPERR_INVALIDGROUP;
		goto EXIT_SENDGROUPOWNER;
	}

	// Call dplay's DistributeGroupMessage function to put the message
	// in the queues of all the appropriate players
	hr = DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
			(LPBYTE)&msg, sizeof(MSG_GROUPOWNERCHANGED), FALSE, 0);
	if(FAILED(hr))
	{
		DPF(8, "Failed adding SetGroupOwner message to player's receive queue from lobby, hr = 0x%08x", hr);
	}


EXIT_SENDGROUPOWNER:

	// Drop the lock
	LEAVE_DPLAY();

	return hr;

} // PRV_SendGroupOwnerMessageLocally



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_SetGroupOwner"
HRESULT DPLAPI DPLP_SetGroupOwner(LPDPLOBBYSP lpILP,
					LPSPDATA_SETREMOTEGROUPOWNER lpd)
{
	LPDPLOBBYI_DPLOBJECT	this;
	LPDPLAYI_GROUP			lpGroup = NULL;
	HRESULT					hr = DP_OK;
	DWORD					dwOldOwnerID;


	DPF(7, "Entering DPLP_SetGroupOwner");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpILP, lpd);

	ENTER_DPLOBBY();
	
	//	Make sure the LP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpILP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLOBBY();
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

		// Validate the struct pointer
		if(!lpd)
		{
			LEAVE_DPLOBBY();
			DPF_ERR("SPDATA_SETGROUPNAME structure pointer cannot be NULL");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	
	// First see if the group is in our map table.  If it is not,
	// we should just ignore this message because it's for a
	// group we don't know about.
	if(!IsLobbyIDInMapTable(this, lpd->dwGroupID))
	{
		LEAVE_DPLOBBY();
		DPF(8, "Recieved SetGroupOwner message for unknown group, dwGroupID = %lu, discarding message", lpd->dwGroupID);
		return DPERR_INVALIDGROUP;
	}

	// Take the lock
	ENTER_DPLAY();

	// See if the group is local or remote.  If it's local, ignore this message
	// and just return DP_OK becuase we've already sent this message locally.
	lpGroup = GroupFromID(this->lpDPlayObject, lpd->dwGroupID);
	if(!lpGroup)
	{
		hr = DP_OK;
		goto ERROR_DPLP_SETGROUPOWNER;
	}

	// If the player is already the owner of the group, we don't need
	// to do any processing (this is the buffer in case the server
	// sends us duplicate messages for stuff we've already sent locally)
	if(lpGroup->dwOwnerID == lpd->dwOwnerID)
	{
		hr = DP_OK;
		goto ERROR_DPLP_SETGROUPOWNER;
	}
	
	// Make sure the old owner is in our map table, otherwise just set
	// it to zero (the default)
	dwOldOwnerID = lpGroup->dwOwnerID;

	// Change the owner locally
	lpGroup->dwOwnerID = lpd->dwOwnerID;

	// Send a SetGroupOwner message locally
	PRV_SendGroupOwnerMessageLocally(this, lpd->dwGroupID,
		lpd->dwOwnerID, dwOldOwnerID);

ERROR_DPLP_SETGROUPOWNER:

	// Drop the locks
	LEAVE_LOBBY_ALL();

	return hr;

} // DPLP_SetGroupOwner



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_SetPlayerName"
HRESULT DPLAPI DPLP_SetPlayerName(LPDPLOBBYSP lpILP,
					LPSPDATA_SETREMOTEPLAYERNAME lpd)
{
	LPDPLOBBYI_DPLOBJECT	this;
	HRESULT					hr = DP_OK;
	LPDPLAYI_PLAYER			lpPlayer = NULL;


	DPF(7, "Entering DPLP_SetPlayerName");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpILP, lpd);

	ENTER_DPLOBBY();
	
	//	Make sure the LP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpILP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLOBBY();
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

		// Validate the struct pointer
		if(!lpd)
		{
			LEAVE_DPLOBBY();
			DPF_ERR("SPDATA_SETPLAYERNAME structure pointer cannot be NULL");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	// First see if the player is in our map table.  If it is not,
	// we should just ignore this message because it's for a
	// player we don't know about.
	if(!IsLobbyIDInMapTable(this, lpd->dwPlayerID))
	{
		LEAVE_DPLOBBY();
		DPF(8, "Recieved SetPlayerName message for unknown player, dwPlayerID = %lu, discarding message", lpd->dwPlayerID);
		return DPERR_INVALIDPLAYER;
	}

	// Take the lock
	ENTER_DPLAY();

	// See if the player is local or remote.  If it's local, ignore this message
	// and just return DP_OK becuase we've already sent this message locally.
	lpPlayer = PlayerFromID(this->lpDPlayObject, lpd->dwPlayerID);
	if((!lpPlayer) || (lpPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
	{
		hr = DP_OK;
		goto ERROR_DPLP_SETPLAYERNAME;
	}

	// Call dplay's internalsetname function to update the name in the cache
	hr = InternalSetName((LPDIRECTPLAY)this->lpDPlayObject->pInterfaces,
			lpd->dwPlayerID, lpd->lpName, TRUE, lpd->dwFlags, FALSE);
	if(FAILED(hr))
	{
		DPF(8, "Failed to SetPlayerName internally for remote group, hr = 0x%08x", hr);
		goto ERROR_DPLP_SETPLAYERNAME;
	}

	// Send the message to all the local players
	hr = PRV_SendNameChangedMessageLocally(this, lpd->dwPlayerID, lpd->lpName, TRUE);


ERROR_DPLP_SETPLAYERNAME:

	// Drop the lock
	LEAVE_LOBBY_ALL();

	return hr;

} // DPLP_SetPlayerName



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_SetSessionDesc"
HRESULT DPLAPI DPLP_SetSessionDesc(LPDPLOBBYSP lpILP,
						LPSPDATA_SETSESSIONDESC lpd)
{
	LPDPLOBBYI_DPLOBJECT	this;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering DPLP_SetSessionDesc");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpILP, lpd);

	ENTER_DPLOBBY();

	//	Make sure the LP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpILP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLOBBY();
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

		// Validate the struct pointer
		if(!lpd)
		{
			LEAVE_DPLOBBY();
			DPF_ERR("SPDATA_SETSESSIONDESC structure pointer cannot be NULL");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	LEAVE_DPLOBBY();
	return hr;

} // DPLP_SetSessionDesc



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_SetSPDataPointer"
HRESULT DPLAPI DPLP_SetSPDataPointer(LPDPLOBBYSP lpDPLSP, LPVOID lpData)
{
	LPDPLOBBYI_DPLOBJECT this;

	
	//	Make sure the SP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpDPLSP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }
	
	// Go ahead and save the pointer
	this->lpSPData = lpData;

	return DP_OK;

} // DPLP_SetSPDataPointer



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_BuildStartSessionMessage"
HRESULT PRV_BuildStartSessionMessage(LPVOID * lplpmsg, LPDWORD lpdwSize,
				LPDPLCONNECTION	lpConn, LPDPLAYI_PLAYER lpPlayer)
{
	LPMSG_STARTSESSION		lpmsg = NULL;
	DWORD					dwPackageSize;
	DWORD					dwSize;
	LPBYTE					lpTemp = NULL;
	DPNAME					dpn;
	HRESULT					hr;


	// Setup a local DPNAME struct for the player if the names exist
	if((lpPlayer->lpszShortName) || (lpPlayer->lpszLongName))
	{
		// Setup the struct
		memset(&dpn, 0, sizeof(DPNAME));
		dpn.dwSize = sizeof(DPNAME);
		dpn.lpszShortName = lpPlayer->lpszShortName;
		dpn.lpszLongName = lpPlayer->lpszLongName;
		lpConn->lpPlayerName = &dpn;
	}
	else
	{
		// Make sure the PlayerName pointer is NULL
		lpConn->lpPlayerName = NULL;
	}

	// Calculate the size of our message in Unicode
	PRV_GetDPLCONNECTIONPackageSize(lpConn, &dwPackageSize, NULL);
	dwSize = sizeof(MSG_STARTSESSION) + dwPackageSize -
				sizeof(DPLOBBYI_PACKEDCONNHEADER);

	// Allocate memory for the message
	lpmsg = DPMEM_ALLOC(dwSize);
	if(!lpmsg)
	{
		DPF_ERR("Unable to allocate memory for temporary message structure");
		return DPERR_OUTOFMEMORY;
	}

	// Now build the system message
	SET_MESSAGE_HDR(lpmsg);
	SET_MESSAGE_COMMAND(lpmsg, DPSP_MSG_STARTSESSION);
	
	// Set the DPLCONNECTION pointer
	lpmsg->dwConnOffset = sizeof(MSG_STARTSESSION);
	lpTemp = (LPBYTE)lpmsg + lpmsg->dwConnOffset;

	// Copy in the package
	hr = PRV_PackageDPLCONNECTION(lpConn, lpTemp, FALSE);
	if(FAILED(hr))
	{
		DPF_ERRVAL("Unable to pack DPLCONNECTION struct, hr = 0x%08x", hr);
		DPMEM_FREE(lpmsg);
		return hr;
	}

	// Set the output pointers
	*lpdwSize = dwSize;
	*lplpmsg = lpmsg;

	return DP_OK;

} // PRV_BuildStartSessionMessage



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_StartSession"
HRESULT DPLAPI DPLP_StartSession(LPDPLOBBYSP lpILP,
				LPSPDATA_STARTSESSIONCOMMAND lpd)
{
	LPDPLOBBYI_DPLOBJECT	this = NULL;
	LPDPLAYI_DPLAY			lpDP = NULL;
	DPLCONNECTION			conn;
	LPBYTE					lpmsg = NULL;
	HRESULT					hr = DP_OK;
	LPDPLAYI_PLAYER			lpPlayer = NULL;
	LPDPLAYI_GROUP			lpGroup = NULL;
	DWORD					dwMessageSize;
	LPDPLAYI_GROUPNODE		lpGroupnode = NULL;
	UINT					nPlayers;


	DPF(7, "Entering DPLP_StartSession");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpILP, lpd);

	ENTER_DPLOBBY();

	//	Make sure the LP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpILP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLOBBY();
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

		// Validate the struct pointer
		if(!lpd)
		{
			LEAVE_DPLOBBY();
			DPF_ERR("SPDATA_STARTSESSIONCOMMAND structure pointer cannot be NULL");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// Make a local copy of the DPLCONNECTION structure since we will
	// be modifying some elements of it.  We are currently only modifying
	// elements in the DPLCONNECTION structure itself, so we can get
	// away with using it's pointers to SessionDesc and PlayerName structs,
	// but if we modify those in the future, we need to copy them as well
	memcpy(&conn, lpd->lpConn, sizeof(DPLCONNECTION));

	// Make a local variable pointer to the dplay object
	lpDP = this->lpDPlayObject;

	// Make sure we know about this group
	if(!IsLobbyIDInMapTable(this, lpd->dwGroupID))
	{
		DPF(8, "Received StartSessionCommand message for an unknown group, dwGroupID = %lu, discarding message", lpd->dwGroupID);
		LEAVE_DPLOBBY();
		return DPERR_INVALIDGROUP;
	}

	// Take the dplay lock since we'll be looking at it's structures
	ENTER_DPLAY();	

	// See if the host is even in our nametable, if it isn't, we'll assume
	// we're not the host
	// See if the host is a local player, if it is, send separate messages
	if(IsLobbyIDInMapTable(this, lpd->dwHostID))
	{
		// Get dplay's player struct for the host player
		lpPlayer = PlayerFromID(lpDP, lpd->dwHostID);

		// If we know the host player (we should) and he's local, we
		// want to send the host message first
		if((lpPlayer) && (lpPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
		{
			// So set the host bit
			conn.dwFlags |= DPLCONNECTION_CREATESESSION;

			// Build the StartSession message for the host
			hr = PRV_BuildStartSessionMessage(&lpmsg, &dwMessageSize,
						&conn, lpPlayer);
			if(FAILED(hr))
			{
				DPF_ERRVAL("Failed building StartSessionCommand message, hr = 0x%08x", hr);
				goto EXIT_DPLP_STARTSESSION;
			}

			// Now send the message to the host player alone
			hr = HandlePlayerMessage(lpPlayer, (LPBYTE)lpmsg,
							dwMessageSize, FALSE, 0);
			if(FAILED(hr))
			{
				DPF(8, "Failed adding message to player's receive queue from lobby, hr = 0x%08x", hr);
			}

			// Free our message since we're done with it
			DPMEM_FREE(lpmsg);
			lpmsg = NULL;
			
			// Now fall through and send the join message to everyone else
			// in the group
		}
	}

	// We must be joining, so set the join bit, and make sure the host
	// bit isn't still set from above
	conn.dwFlags &= ~DPLCONNECTION_CREATESESSION;
	conn.dwFlags |= DPLCONNECTION_JOINSESSION;

	// Get a pointer to dplay's internal group structure
	lpGroup = GroupFromID(lpDP, lpd->dwGroupID);
	if(!lpGroup)
	{
		DPF(5, "Unable to find group in nametable, idGroup = %lu", lpd->dwGroupID);
		goto EXIT_DPLP_STARTSESSION;
	}


	// Figure out how many players we are looking for
	lpGroupnode = FindPlayerInGroupList(lpGroup->pSysPlayerGroupnodes,lpDP->pSysPlayer->dwID);
	if (!lpGroupnode)
	{
		ASSERT(FALSE);
		return E_UNEXPECTED;
	}
	nPlayers = lpGroupnode->nPlayers;

	// Walk the list of groupnodes, looking for nPlayers local players to give
	// the message to, excluding the host
	lpGroupnode = lpGroup->pGroupnodes;
	while ((nPlayers > 0) && (lpGroupnode))
	{
		if ((lpGroupnode->pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) &&
			(lpGroupnode->pPlayer->dwID != lpd->dwHostID))
		{
			// Build the StartSession (join) message for this player
			hr = PRV_BuildStartSessionMessage(&lpmsg, &dwMessageSize,
						&conn, lpGroupnode->pPlayer);
			if(FAILED(hr))
			{
				DPF(5, "Failed building StartSessionCommand message, hr = 0x%08x", hr);
				goto EXIT_DPLP_STARTSESSION;
			}

			// Send the message to this player
			hr = HandlePlayerMessage(lpGroupnode->pPlayer, lpmsg,
					dwMessageSize, FALSE, 0);

			// Free our message
			if(lpmsg)
				DPMEM_FREE(lpmsg);
			lpmsg = NULL;

			nPlayers--;
		} // local & !host

		lpGroupnode = lpGroupnode->pNextGroupnode;

	} // while
	

EXIT_DPLP_STARTSESSION:

	if(lpmsg)
		DPMEM_FREE(lpmsg);

	LEAVE_LOBBY_ALL();
	return hr;

} // DPLP_StartSession
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplobby\lobbysp.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       lobbysp.h
 *  Content:    DirectPlayLobby data structures for Service Providers
 *@@BEGIN_MSINTERNAL
 *  History:
 *	Date		By		Reason
 *	====		==		======
 *	7/23/96		myronth	Created it
 *	10/23/96	myronth	Added IDPLobbySP interface stuff
 *	10/28/96	myronth	Changed to DX5 methods
 *	11/20/96	myronth	Added DPLOGONINFO to LogonServer data
 *	2/12/97		myronth	Mass DX5 changes
 *	2/18/97		myronth	Implemented GetObjectCaps
 *	3/12/97		myronth	Implemented EnumSessions, Removed Open & Close Responses
 *	3/13/97		myronth	Added link to global DPlay SP count (imported)
 *	3/17/97		myronth	Create/DestroyGroup/Player, Removed unnecessary
 *						Enum functions & structures
 *	3/21/97		myronth	SetGroup/PlayerName, Get/SetGroup/PlayerData, Removed
 *						more unnecessary response functions
 *	3/31/97		myronth	Removed dead code, Added new IDPLobbySP method structs
 *	4/4/97		myronth	Added new IDPLobbySP method structures
 *	4/9/97		myronth	Cleaned up SPINIT structure elements, Added
 *						GetCaps and GetPlayerCaps
 *	5/8/97		myronth	Subgroup methods, GroupConnSettings, StartSession
 *	5/13/97		myronth	Added Credentials to Open data struct
 *	5/17/97		myronth	SendChatMessage callback functions, structs, etc.
 *	5/23/97		myronth	Removed dwPlayerToID from the SPDATA structs
 *	6/3/97		myronth	Added dwPlayerFlags to SPDATA_ADDREMOTEPLAYERTOGROUP
 *	6/5/97		myronth	Added parent to SPDATA_ADDREMOTEPLAYERTOGROUP and
 *						added SPDATA_BUILDPARENTALHEIRARCHY message & structs
 *	7/30/97		myronth	Added dwFlags member to SPDATA_HANDLEMESSAGE
 *	10/3/97		myronth	Added dwDPlayVersion to DPLSPInit data struct
 *						Added player & group data to several remote structs
 *						Bumped version to DX6 (#12667)
 *	10/8/97		myronth	Rolled back the fix to #10961 which added lpData and
 *						dwDataSize to all remote structs -- It's not needed
 *	10/29/97	myronth	Added support for group owner and it's methods
 *	11/6/97		myronth	Added version existence flag and dwReserved values
 *						to SPDATA_INIT (#12916, #12917)
 *	12/29/97	myronth	Fixed DX6 macros (#15739)
 *@@END_MSINTERNAL
 ***************************************************************************/
#ifndef __LOBBYSP_INCLUDED__
#define __LOBBYSP_INCLUDED__

#include "dplobby.h"

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


/*
 * gdwDPlaySPRefCount
 *
 * To ensure that the DPLAYX.DLL will not be unloaded before the lobby
 * provider, the lobby provider should statically link to DPLAYX.LIB and
 * increment this global during the DPLSPInit call and decrement this global
 * during Shutdown.
 */
extern __declspec(dllimport) DWORD gdwDPlaySPRefCount;


// A few forward declarations
typedef struct SPDATA_ADDGROUPTOGROUP * LPSPDATA_ADDGROUPTOGROUP;
typedef struct SPDATA_ADDPLAYERTOGROUP *LPSPDATA_ADDPLAYERTOGROUP;
typedef struct SPDATA_ADDREMOTEGROUPTOGROUP *LPSPDATA_ADDREMOTEGROUPTOGROUP;
typedef struct SPDATA_ADDREMOTEPLAYERTOGROUP *LPSPDATA_ADDREMOTEPLAYERTOGROUP;
typedef struct SPDATA_BUILDPARENTALHEIRARCHY *LPSPDATA_BUILDPARENTALHEIRARCHY;
typedef struct SPDATA_CHATMESSAGE *LPSPDATA_CHATMESSAGE;
typedef struct SPDATA_CLOSE *LPSPDATA_CLOSE;
typedef struct SPDATA_CREATEGROUP *LPSPDATA_CREATEGROUP;
typedef struct SPDATA_CREATEGROUPINGROUP *LPSPDATA_CREATEGROUPINGROUP;
typedef struct SPDATA_CREATEREMOTEGROUP *LPSPDATA_CREATEREMOTEGROUP;
typedef struct SPDATA_CREATEREMOTEGROUPINGROUP *LPSPDATA_CREATEREMOTEGROUPINGROUP;
typedef struct SPDATA_CREATEPLAYER *LPSPDATA_CREATEPLAYER;
typedef struct SPDATA_DELETEGROUPFROMGROUP * LPSPDATA_DELETEGROUPFROMGROUP;
typedef struct SPDATA_DELETEPLAYERFROMGROUP *LPSPDATA_DELETEPLAYERFROMGROUP;
typedef struct SPDATA_DELETEREMOTEGROUPFROMGROUP *LPSPDATA_DELETEREMOTEGROUPFROMGROUP;
typedef struct SPDATA_DELETEREMOTEPLAYERFROMGROUP *LPSPDATA_DELETEREMOTEPLAYERFROMGROUP;
typedef struct SPDATA_DESTROYGROUP *LPSPDATA_DESTROYGROUP;
typedef struct SPDATA_DESTROYREMOTEGROUP *LPSPDATA_DESTROYREMOTEGROUP;
typedef struct SPDATA_DESTROYPLAYER *LPSPDATA_DESTROYPLAYER;
typedef struct SPDATA_ENUMSESSIONS *LPSPDATA_ENUMSESSIONS;
typedef struct SPDATA_ENUMSESSIONSRESPONSE * LPSPDATA_ENUMSESSIONSRESPONSE;
typedef struct SPDATA_GETCAPS *LPSPDATA_GETCAPS;
typedef struct SPDATA_GETGROUPCONNECTIONSETTINGS *LPSPDATA_GETGROUPCONNECTIONSETTINGS;
typedef struct SPDATA_GETGROUPDATA *LPSPDATA_GETGROUPDATA;
typedef struct SPDATA_GETPLAYERCAPS *LPSPDATA_GETPLAYERCAPS;
typedef struct SPDATA_GETPLAYERDATA *LPSPDATA_GETPLAYERDATA;
typedef struct SPDATA_HANDLEMESSAGE *LPSPDATA_HANDLEMESSAGE;
typedef struct SPDATA_OPEN *LPSPDATA_OPEN;
typedef struct SPDATA_SEND *LPSPDATA_SEND;
typedef struct SPDATA_SETGROUPDATA *LPSPDATA_SETGROUPDATA;
typedef struct SPDATA_SETGROUPNAME *LPSPDATA_SETGROUPNAME;
typedef struct SPDATA_SETGROUPOWNER *LPSPDATA_SETGROUPOWNER;
typedef struct SPDATA_SETREMOTEGROUPNAME *LPSPDATA_SETREMOTEGROUPNAME;
typedef struct SPDATA_SETREMOTEGROUPOWNER *LPSPDATA_SETREMOTEGROUPOWNER;
typedef struct SPDATA_SETGROUPCONNECTIONSETTINGS *LPSPDATA_SETGROUPCONNECTIONSETTINGS;
typedef struct SPDATA_SETPLAYERDATA *LPSPDATA_SETPLAYERDATA;
typedef struct SPDATA_SETPLAYERNAME *LPSPDATA_SETPLAYERNAME;
typedef struct SPDATA_SETREMOTEPLAYERNAME *LPSPDATA_SETREMOTEPLAYERNAME;
typedef struct SPDATA_SETSESSIONDESC *LPSPDATA_SETSESSIONDESC;
typedef struct SPDATA_SHUTDOWN *LPSPDATA_SHUTDOWN;
typedef struct SPDATA_STARTSESSION *LPSPDATA_STARTSESSION;
typedef struct SPDATA_STARTSESSIONCOMMAND *LPSPDATA_STARTSESSIONCOMMAND;


/*
 *	IDPLobbySP
 *
 *	Lobby Service Providers are passed an IDPLobbySP interface
 *	in the LobbySPInit method. This interface is used to call
 *	back into DirectPlayLobby.
 */
struct IDPLobbySP;
typedef struct IDPLobbySP FAR* LPDPLOBBYSP;

#undef INTERFACE
#define INTERFACE IDPLobbySP
DECLARE_INTERFACE_( IDPLobbySP, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)               (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)                (THIS) PURE;
    STDMETHOD_(ULONG,Release)               (THIS) PURE;
    /*** IDPLobbySP methods ***/
	STDMETHOD(AddGroupToGroup)              (THIS_ LPSPDATA_ADDREMOTEGROUPTOGROUP) PURE;
	STDMETHOD(AddPlayerToGroup)             (THIS_ LPSPDATA_ADDREMOTEPLAYERTOGROUP) PURE;
	STDMETHOD(CreateGroup)                  (THIS_ LPSPDATA_CREATEREMOTEGROUP) PURE;
	STDMETHOD(CreateGroupInGroup)           (THIS_ LPSPDATA_CREATEREMOTEGROUPINGROUP) PURE;
	STDMETHOD(DeleteGroupFromGroup)         (THIS_ LPSPDATA_DELETEREMOTEGROUPFROMGROUP) PURE;
	STDMETHOD(DeletePlayerFromGroup)        (THIS_ LPSPDATA_DELETEREMOTEPLAYERFROMGROUP) PURE;
	STDMETHOD(DestroyGroup)                 (THIS_ LPSPDATA_DESTROYREMOTEGROUP) PURE;
	STDMETHOD(EnumSessionsResponse)	        (THIS_ LPSPDATA_ENUMSESSIONSRESPONSE) PURE;
	STDMETHOD(GetSPDataPointer)		        (THIS_ LPVOID *) PURE;
	STDMETHOD(HandleMessage)				(THIS_ LPSPDATA_HANDLEMESSAGE) PURE;
	STDMETHOD(SendChatMessage)              (THIS_ LPSPDATA_CHATMESSAGE) PURE;
	STDMETHOD(SetGroupName)                 (THIS_ LPSPDATA_SETREMOTEGROUPNAME) PURE;
	STDMETHOD(SetPlayerName)                (THIS_ LPSPDATA_SETREMOTEPLAYERNAME) PURE;
	STDMETHOD(SetSessionDesc)               (THIS_ LPSPDATA_SETSESSIONDESC) PURE;
	STDMETHOD(SetSPDataPointer)		        (THIS_ LPVOID) PURE;
	STDMETHOD(StartSession)                 (THIS_ LPSPDATA_STARTSESSIONCOMMAND) PURE;
    /*** Methods added for DX6 ***/
    STDMETHOD(CreateCompoundAddress)        (THIS_ LPCDPCOMPOUNDADDRESSELEMENT,DWORD,LPVOID,LPDWORD) PURE;
    STDMETHOD(EnumAddress)                  (THIS_ LPDPENUMADDRESSCALLBACK, LPCVOID, DWORD, LPVOID) PURE;
	STDMETHOD(SetGroupOwner)				(THIS_ LPSPDATA_SETREMOTEGROUPOWNER) PURE;
};

/*
 * GUID for IDPLobbySP
 */
// IID_IDPLobbySP	{5A4E5A20-2CED-11d0-A889-00A0C905433C}
DEFINE_GUID(IID_IDPLobbySP, 0x5a4e5a20, 0x2ced, 0x11d0, 0xa8, 0x89, 0x0, 0xa0, 0xc9, 0x5, 0x43, 0x3c);

/*
 * Major version number for service provider.
 *
 * The most-significant 16 bits are reserved for the DirectPlay
 * major version number. The least-significant 16 bits are for
 * use by the service provider.
 */
#define DPLSP_MAJORVERSION               0x00060000

// Major version used by DX5
#define DPLSP_DX5VERSION                 0x00050000

// Size of the SPDATA_INIT structure in DX5
#define DPLSP_SIZE_DX5_INIT_STRUCT       (16)

//--------------------------------------------------------------------------
//
//	Service Provider Callback Stuff
//
//--------------------------------------------------------------------------

// Callback prototypes
typedef HRESULT (WINAPI *LPSP_ADDGROUPTOGROUP)(LPSPDATA_ADDGROUPTOGROUP);
typedef HRESULT	(WINAPI *LPSP_ADDPLAYERTOGROUP)(LPSPDATA_ADDPLAYERTOGROUP);
typedef HRESULT	(WINAPI *LPSP_BUILDPARENTALHEIRARCHY)(LPSPDATA_BUILDPARENTALHEIRARCHY);
typedef HRESULT	(WINAPI *LPSP_CLOSE)(LPSPDATA_CLOSE);
typedef HRESULT	(WINAPI *LPSP_CREATEGROUP)(LPSPDATA_CREATEGROUP);
typedef HRESULT (WINAPI *LPSP_CREATEGROUPINGROUP)(LPSPDATA_CREATEGROUPINGROUP);
typedef HRESULT	(WINAPI *LPSP_CREATEPLAYER)(LPSPDATA_CREATEPLAYER);
typedef HRESULT (WINAPI *LPSP_DELETEGROUPFROMGROUP)(LPSPDATA_DELETEGROUPFROMGROUP);
typedef HRESULT	(WINAPI *LPSP_DELETEPLAYERFROMGROUP)(LPSPDATA_DELETEPLAYERFROMGROUP);
typedef HRESULT	(WINAPI *LPSP_DESTROYGROUP)(LPSPDATA_DESTROYGROUP);
typedef HRESULT	(WINAPI *LPSP_DESTROYPLAYER)(LPSPDATA_DESTROYPLAYER);
typedef HRESULT	(WINAPI *LPSP_ENUMSESSIONS)(LPSPDATA_ENUMSESSIONS);
typedef HRESULT (WINAPI *LPSP_GETCAPS)(LPSPDATA_GETCAPS);
typedef HRESULT (WINAPI *LPSP_GETGROUPCONNECTIONSETTINGS)(LPSPDATA_GETGROUPCONNECTIONSETTINGS);
typedef HRESULT	(WINAPI *LPSP_GETGROUPDATA)(LPSPDATA_GETGROUPDATA);
typedef HRESULT (WINAPI *LPSP_GETPLAYERCAPS)(LPSPDATA_GETPLAYERCAPS);
typedef HRESULT	(WINAPI *LPSP_GETPLAYERDATA)(LPSPDATA_GETPLAYERDATA);
typedef HRESULT	(WINAPI *LPSP_HANDLEMESSAGE)(LPSPDATA_HANDLEMESSAGE);
typedef HRESULT	(WINAPI *LPSP_OPEN)(LPSPDATA_OPEN);
typedef HRESULT	(WINAPI *LPSP_SEND)(LPSPDATA_SEND);
typedef HRESULT	(WINAPI *LPSP_SENDCHATMESSAGE)(LPSPDATA_CHATMESSAGE);
typedef HRESULT (WINAPI *LPSP_SETGROUPCONNECTIONSETTINGS)(LPSPDATA_SETGROUPCONNECTIONSETTINGS);
typedef HRESULT	(WINAPI *LPSP_SETGROUPDATA)(LPSPDATA_SETGROUPDATA);
typedef HRESULT	(WINAPI *LPSP_SETGROUPNAME)(LPSPDATA_SETGROUPNAME);
typedef HRESULT	(WINAPI *LPSP_SETGROUPOWNER)(LPSPDATA_SETGROUPOWNER);
typedef HRESULT	(WINAPI *LPSP_SETPLAYERDATA)(LPSPDATA_SETPLAYERDATA);
typedef HRESULT	(WINAPI *LPSP_SETPLAYERNAME)(LPSPDATA_SETPLAYERNAME);
typedef HRESULT	(WINAPI *LPSP_SHUTDOWN)(LPSPDATA_SHUTDOWN);
typedef HRESULT (WINAPI *LPSP_STARTSESSION)(LPSPDATA_STARTSESSION);

// Callback table for dplay to call into service provider
typedef struct SP_CALLBACKS
{
    DWORD								dwSize;
    DWORD								dwDPlayVersion;
    LPSP_ADDGROUPTOGROUP				AddGroupToGroup;
	LPSP_ADDPLAYERTOGROUP				AddPlayerToGroup;
	LPSP_BUILDPARENTALHEIRARCHY			BuildParentalHeirarchy;
	LPSP_CLOSE							Close;
    LPSP_CREATEGROUP					CreateGroup;
	LPSP_CREATEGROUPINGROUP				CreateGroupInGroup;
	LPSP_CREATEPLAYER					CreatePlayer;
    LPSP_DELETEGROUPFROMGROUP			DeleteGroupFromGroup;
	LPSP_DELETEPLAYERFROMGROUP			DeletePlayerFromGroup;
    LPSP_DESTROYGROUP					DestroyGroup;
	LPSP_DESTROYPLAYER					DestroyPlayer;
	LPSP_ENUMSESSIONS					EnumSessions;
	LPSP_GETCAPS						GetCaps;
	LPSP_GETGROUPCONNECTIONSETTINGS		GetGroupConnectionSettings;
	LPSP_GETGROUPDATA					GetGroupData;
	LPSP_GETPLAYERCAPS					GetPlayerCaps;
	LPSP_GETPLAYERDATA					GetPlayerData;
	LPSP_OPEN							Open;
	LPSP_SEND							Send;
	LPSP_SENDCHATMESSAGE				SendChatMessage;
	LPSP_SETGROUPCONNECTIONSETTINGS		SetGroupConnectionSettings;
	LPSP_SETGROUPDATA					SetGroupData;
	LPSP_SETGROUPNAME					SetGroupName;
	LPSP_SETPLAYERDATA					SetPlayerData;
	LPSP_SETPLAYERNAME					SetPlayerName;
	LPSP_SHUTDOWN						Shutdown;
	LPSP_STARTSESSION					StartSession;
	LPSP_SETGROUPOWNER					SetGroupOwner;
} SP_CALLBACKS, * LPSP_CALLBACKS;             


// CALLBACK DATA STRUCTURES. These are passed by DPLAY to the sp when
// the callback is invoked
typedef struct SPDATA_ADDGROUPTOGROUP
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwParentID;		// ID of the parent group
	DWORD			dwGroupID;		// ID of the new group to be created (output param)
} SPDATA_ADDGROUPTOGROUP;

typedef struct SPDATA_ADDPLAYERTOGROUP
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the group
	DWORD			dwPlayerID;		// ID of the player
} SPDATA_ADDPLAYERTOGROUP;

typedef struct SPDATA_ADDREMOTEGROUPTOGROUP
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwAnchorID;		// ID of the anchor group (group the shortcut is added to)
	DWORD			dwGroupID;		// ID of the group the shortcut references
	DWORD			dwParentID;		// ID of the group's parent (not the group being added to)
	LPDPNAME		lpName;			// Pointer to DPNAME struct for group name
	DWORD			dwGroupFlags;	// Group flags for the group the shortcut references
	DWORD			dwGroupOwnerID;	// ID of the owner of the group the shortcut references
} SPDATA_ADDREMOTEGROUPTOGROUP;

typedef struct SPDATA_ADDREMOTEPLAYERTOGROUP
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the group
	DWORD			dwPlayerID;		// ID of the player
	DWORD			dwPlayerFlags;	// Player flags
	LPDPNAME		lpName;			// Name of the player
} SPDATA_ADDREMOTEPLAYERTOGROUP;

typedef struct SPDATA_BUILDPARENTALHEIRARCHY
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the group to build the heirarchy for
	DWORD			dwMessage;		// Message type the lobby errored on
	DWORD			dwParentID;		// ID of the parent (for an AddGroupToGroup call)
} SPDATA_BUILDPARENTALHEIRARCHY;

typedef struct SPDATA_CLOSE
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
} SPDATA_CLOSE;

typedef struct SPDATA_CREATEGROUP
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the group (output parameter)
	LPDPNAME		lpName;			// Pointer to DPNAME struct for group name
	LPVOID			lpData;			// Pointer to group data
	DWORD			dwDataSize;		// Size of the group data
	DWORD			dwFlags;		// CreateGroup flags
	DWORD			dwGroupOwnerID;	// ID of the group's owner
} SPDATA_CREATEGROUP;

typedef struct SPDATA_CREATEGROUPINGROUP
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwParentID;		// ID of the parent group
	DWORD			dwGroupID;		// ID of the new group to be created (output param)
	LPDPNAME		lpName;			// Pointer to DPNAME struct for group name
	LPVOID			lpData;			// Pointer to group data
	DWORD			dwDataSize;		// Size of the group data
	DWORD			dwFlags;		// CreateGroup flags
	DWORD			dwGroupOwnerID;	// ID of the group's owner
} SPDATA_CREATEGROUPINGROUP;

typedef struct SPDATA_CREATEREMOTEGROUP
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the group (output parameter)
	LPDPNAME		lpName;			// Pointer to DPNAME struct for group name
	LPVOID			lpData;			// Pointer to group data
	DWORD			dwDataSize;		// Size of the group data
	DWORD			dwFlags;		// CreateGroup flags
	DWORD			dwGroupOwnerID;	// ID of the group's owner
} SPDATA_CREATEREMOTEGROUP;

typedef struct SPDATA_CREATEREMOTEGROUPINGROUP
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwParentID;		// ID of the parent group
	DWORD			dwGroupID;		// ID of the new group to be created (output param)
	LPDPNAME		lpName;			// Pointer to DPNAME struct for group name
	DWORD			dwFlags;		// CreateGroupInGroup flags
	DWORD			dwGroupOwnerID;	// ID of the group's owner
} SPDATA_CREATEREMOTEGROUPINGROUP;

typedef struct SPDATA_CREATEPLAYER
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwPlayerID;		// ID of the group (output parameter)
	LPDPNAME		lpName;			// Pointer to DPNAME struct for group name
	LPVOID			lpData;			// Pointer to group data
	DWORD			dwDataSize;		// Size of the group data
	DWORD			dwFlags;		// CreatePlayer flags
} SPDATA_CREATEPLAYER;

typedef struct SPDATA_DELETEGROUPFROMGROUP
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwParentID;		// ID of the Parent Group
	DWORD			dwGroupID;		// ID of the Group to be deleted
} SPDATA_DELETEGROUPFROMGROUP;

typedef struct SPDATA_DELETEPLAYERFROMGROUP
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the Group
	DWORD			dwPlayerID;		// ID of the Player
} SPDATA_DELETEPLAYERFROMGROUP;

typedef struct SPDATA_DELETEREMOTEGROUPFROMGROUP
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwParentID;		// ID of the Parent Group
	DWORD			dwGroupID;		// ID of the Group to be deleted
} SPDATA_DELETEREMOTEGROUPFROMGROUP;

typedef struct SPDATA_DELETEREMOTEPLAYERFROMGROUP
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the Group
	DWORD			dwPlayerID;		// ID of the Player
} SPDATA_DELETEREMOTEPLAYERFROMGROUP;

typedef struct SPDATA_DESTROYGROUP
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the player on the lobby
} SPDATA_DESTROYGROUP;

typedef struct SPDATA_DESTROYREMOTEGROUP
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the player on the lobby
} SPDATA_DESTROYREMOTEGROUP;

typedef struct SPDATA_DESTROYPLAYER
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwPlayerID;		// ID of the player on the lobby
} SPDATA_DESTROYPLAYER;

typedef struct SPDATA_ENUMSESSIONS
{
	DWORD				dwSize;		// Size of this structure
	LPDPLOBBYSP			lpISP;		// Pointer to an IDPLobbySP interface
	LPDPSESSIONDESC2	lpsd;		// SessionDesc to enumerate on
	DWORD               dwTimeout;	// Timeout value
	DWORD               dwFlags;	// Flags
} SPDATA_ENUMSESSIONS;

typedef struct SPDATA_ENUMSESSIONSRESPONSE
{
	DWORD				dwSize;		// Size of this structure
	LPDPSESSIONDESC2	lpsd;		// SessionDesc returned by server
} SPDATA_ENUMSESSIONSRESPONSE;

typedef struct SPDATA_GETCAPS
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwFlags;		// Flags
	LPDPCAPS		lpcaps;			// Pointer to DPCAPS structure
} SPDATA_GETCAPS;

typedef struct SPDATA_GETGROUPCONNECTIONSETTINGS
{
	DWORD			dwSize;			// Size of this structure
	DWORD			dwFlags;		// Flags
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the Group
	LPDWORD			lpdwBufferSize;	// Pointer to the size of the buffer
	LPVOID			lpBuffer;		// Pointer to a buffer
} SPDATA_GETGROUPCONNECTIONSETTINGS;

typedef struct SPDATA_GETGROUPDATA
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the Group
	LPDWORD			lpdwDataSize;	// Pointer to the size of the lpData buffer
	LPVOID			lpData;			// Pointer to a data buffer
} SPDATA_GETGROUPDATA;

typedef struct SPDATA_GETPLAYERCAPS
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwFlags;		// Flags
	DWORD			dwPlayerID;		// ID of the Player
	LPDPCAPS		lpcaps;			// Pointer to DPCAPS structure
} SPDATA_GETPLAYERCAPS;

typedef struct SPDATA_GETPLAYERDATA
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwPlayerID;		// ID of the Player
	LPDWORD			lpdwDataSize;	// Pointer to the size of the lpData buffer
	LPVOID			lpData;			// Pointer to a data buffer
} SPDATA_GETPLAYERDATA;

typedef struct SPDATA_HANDLEMESSAGE
{
	DWORD			dwSize;			// Size of this structure
	DWORD			dwFromID;		// ID of the player from
	DWORD			dwToID;			// ID of the player to
	LPVOID			lpBuffer;		// Message buffer
	DWORD			dwBufSize;		// Size of the message buffer
	DWORD			dwFlags;		// Message flags
} SPDATA_HANDLEMESSAGE;

typedef struct SPDATA_OPEN
{
	DWORD				dwSize;		// Size of this structure (including data)
	LPDPLOBBYSP			lpISP;	    // Pointer to an IDPLobbySP interface
	LPDPSESSIONDESC2	lpsd;		// Pointer to SessionDesc of the Lobby to open
	DWORD				dwFlags;	// Flags
	LPCDPCREDENTIALS	lpCredentials;	// Pointer to a Credentials structure
} SPDATA_OPEN;

typedef struct SPDATA_SEND
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwFromID;		// ID of the player from
	DWORD			dwToID;			// ID of the player to
	DWORD			dwFlags;		// Flags
	LPVOID			lpBuffer;		// Message buffer
	DWORD			dwBufSize;		// Size of the message buffer
} SPDATA_SEND;

typedef struct SPDATA_CHATMESSAGE
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwFromID;		// ID of the player from
	DWORD			dwToID;			// ID of the player to
	DWORD			dwFlags;		// Send Flags
	LPDPCHAT		lpChat;			// Pointer to a DPCHAT structure
} SPDATA_CHATMESSAGE;

typedef struct SPDATA_SETGROUPCONNECTIONSETTINGS
{
	DWORD			dwSize;			// Size of this structure
	DWORD			dwFlags;		// Flags
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the group
	LPDPLCONNECTION	lpConn;			// Pointer to a DPLCONNECTION structure
} SPDATA_SETGROUPCONNECTIONSETTINGS;

typedef struct SPDATA_SETGROUPDATA
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the group
	LPVOID			lpData;			// Pointer to the new group data
	DWORD			dwDataSize;		// Size of lpData
	DWORD			dwFlags;		// Flags
} SPDATA_SETGROUPDATA;

typedef struct SPDATA_SETGROUPNAME
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the group
	LPDPNAME		lpName;			// Pointer to the new DPNAME struct
	DWORD			dwFlags;		// Flags
} SPDATA_SETGROUPNAME;

typedef struct SPDATA_SETREMOTEGROUPNAME
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the group
	LPDPNAME		lpName;			// Pointer to the new DPNAME struct
	DWORD			dwFlags;		// Flags
} SPDATA_SETREMOTEGROUPNAME;

typedef struct SPDATA_SETGROUPOWNER
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwGroupID;		// ID of the group
	DWORD			dwOwnerID;		// ID of the group's owner
} SPDATA_SETGROUPOWNER;

typedef struct SPDATA_SETREMOTEGROUPOWNER
{
	DWORD			dwSize;			// Size of this structure
	DWORD			dwGroupID;		// ID of the group
	DWORD			dwOwnerID;		// ID of the group's owner
} SPDATA_SETREMOTEGROUPOWNER;

typedef struct SPDATA_SETPLAYERDATA
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwPlayerID;		// ID of the player
	LPVOID			lpData;			// Pointer to the new player data
	DWORD			dwDataSize;		// Size of lpData
	DWORD			dwFlags;		// Flags
} SPDATA_SETPLAYERDATA;

typedef struct SPDATA_SETPLAYERNAME
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwPlayerID;		// ID of the player
	LPDPNAME		lpName;			// Pointer to the new DPNAME struct
	DWORD			dwFlags;		// Flags
} SPDATA_SETPLAYERNAME;

typedef struct SPDATA_SETREMOTEPLAYERNAME
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwPlayerID;		// ID of the player
	LPDPNAME		lpName;			// Pointer to the new DPNAME struct
	DWORD			dwFlags;		// Flags
} SPDATA_SETREMOTEPLAYERNAME;

typedef struct SPDATA_SETSESSIONDESC
{
	DWORD				dwSize;		// Size of this structure
	LPDPSESSIONDESC2	lpsd;		// Pointer to a SessionDesc struct
	LPDPLOBBYSP			lpISP;		// Pointer to an IDPLobbySP interface
} SPDATA_SETSESSIONDESC;

typedef struct SPDATA_SHUTDOWN
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
} SPDATA_SHUTDOWN;

typedef struct SPDATA_STARTSESSION
{
	DWORD			dwSize;			// Size of this structure
	LPDPLOBBYSP		lpISP;			// Pointer to an IDPLobbySP interface
	DWORD			dwFlags;		// Flags
	DWORD			dwGroupID;		// ID of the group who's session to start
} SPDATA_STARTSESSION;

typedef struct SPDATA_STARTSESSIONCOMMAND
{
	DWORD			dwFlags;		// Flags
	DWORD			dwGroupID;		// Group ID of the group to start the session on
	DWORD			dwHostID;		// ID of the host player for the session
	LPDPLCONNECTION	lpConn;			// Pointer to a DPLCONNECTION struct for the session information
} SPDATA_STARTSESSIONCOMMAND;

// Data structure passed to the service provider at DPLSPInit
typedef struct SPDATA_INIT 
{
	LPSP_CALLBACKS      lpCB;			// Lobby Provider fills in entry points
    DWORD               dwSPVersion;	// Lobby provider fills in version number 16 | 16 , major | minor version 
	LPDPLOBBYSP         lpISP;			// DPLobbySP interface pointer
	LPDPADDRESS			lpAddress;		// DPADDRESS of the Lobby (partial or complete)
	DWORD				dwReserved1;	// Reserved DWORD from the registry entry for the LP
	DWORD				dwReserved2;	// Reserved DWORD from the registry entry for the LP
} SPDATA_INIT, * LPSPDATA_INIT;

// This is the function that DPLobby calls to
// get the SP to fill in callbacks
typedef HRESULT (WINAPI *LPSP_INIT)(LPSPDATA_INIT);
HRESULT WINAPI DPLSPInit(LPSPDATA_INIT);


/****************************************************************************
 *
 * IDirectPlayLobby interface macros
 *
 ****************************************************************************/


#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDPLobbySP_QueryInterface(p,a,b)         (p)->lpVtbl->QueryInterface(p,a,b)
#define IDPLobbySP_AddRef(p)                     (p)->lpVtbl->AddRef(p)
#define IDPLobbySP_Release(p)                    (p)->lpVtbl->Release(p)
#define IDPLobbySP_AddGroupToGroup(p,a)          (p)->lpVtbl->AddGroupToGroup(p,a)
#define IDPLobbySP_AddPlayerToGroup(p,a)         (p)->lpVtbl->AddPlayerToGroup(p,a)
#define IDPLobbySP_CreateCompoundAddress(p,a,b,c,d) (p)->lpVtbl->CreateCompoundAddress(p,a,b,c,d)
#define IDPLobbySP_CreateGroup(p,a)              (p)->lpVtbl->CreateGroup(p,a)
#define IDPLobbySP_CreateGroupInGroup(p,a)       (p)->lpVtbl->CreateGroupInGroup(p,a)
#define IDPLobbySP_DeleteGroupFromGroup(p,a)     (p)->lpVtbl->DeleteGroupFromGroup(p,a)
#define IDPLobbySP_DeletePlayerFromGroup(p,a)    (p)->lpVtbl->DeletePlayerFromGroup(p,a)
#define IDPLobbySP_DestroyGroup(p,a)             (p)->lpVtbl->DestroyGroup(p,a)
#define IDPLobbySP_EnumAddress(p,a,b,c,d)        (p)->lpVtbl->EnumAddress(p,a,b,c,d)
#define IDPLobbySP_EnumSessionsResponse(p,a)     (p)->lpVtbl->EnumSessionsResponse(p,a)
#define IDPLobbySP_GetSPDataPointer(p,a)         (p)->lpVtbl->GetSPDataPointer(p,a)
#define IDPLobbySP_HandleMessage(p,a)            (p)->lpVtbl->HandleMessage(p,a)
#define IDPLobbySP_SetGroupName(p,a)             (p)->lpVtbl->SetGroupName(p,a)
#define IDPLobbySP_SetPlayerName(p,a)            (p)->lpVtbl->SetPlayerName(p,a)
#define IDPLobbySP_SetSessionDesc(p,a)           (p)->lpVtbl->SetSessionDesc(p,a)
#define IDPLobbySP_StartSession(p,a)             (p)->lpVtbl->StartSession(p,a)
#define IDPLobbySP_SetGroupOwner(p,a)            (p)->lpVtbl->SetGroupOwner(p,a)
#define IDPLobbySP_SetSPDataPointer(p,a)         (p)->lpVtbl->SetSPDataPointer(p,a)

#else /* C++ */

#define IDPLobbySP_QueryInterface(p,a,b)         (p)->QueryInterface(a,b)
#define IDPLobbySP_AddRef(p)                     (p)->AddRef()
#define IDPLobbySP_Release(p)                    (p)->Release()
#define IDPLobbySP_AddGroupToGroup(p,a)          (p)->AddGroupToGroup(a)
#define IDPLobbySP_AddPlayerToGroup(p,a)         (p)->AddPlayerToGroup(a)
#define IDPLobbySP_CreateCompoundAddress(p,a,b,c,d) (p)->CreateCompoundAddress(a,b,c,d)
#define IDPLobbySP_CreateGroup(p,a)              (p)->CreateGroup(a)
#define IDPLobbySP_CreateGroupInGroup(p,a)       (p)->CreateGroupInGroup(a)
#define IDPLobbySP_DeleteGroupFromGroup(p,a)     (p)->DeleteGroupFromGroup(a)
#define IDPLobbySP_DeletePlayerFromGroup(p,a)    (p)->DeletePlayerFromGroup(a)
#define IDPLobbySP_DestroyGroup(p,a)             (p)->DestroyGroup(a)
#define IDPLobbySP_EnumAddress(p,a,b,c,d)        (p)->EnumAddress(a,b,c,d)
#define IDPLobbySP_EnumSessionsResponse(p,a)     (p)->EnumSessionsResponse(a)
#define IDPLobbySP_GetSPDataPointer(p,a)         (p)->GetSPDataPointer(a)
#define IDPLobbySP_HandleMessage(p,a)            (p)->HandleMessage(a)
#define IDPLobbySP_SetGroupName(p,a)             (p)->SetGroupName(a)
#define IDPLobbySP_SetPlayerName(p,a)            (p)->SetPlayerName(a)
#define IDPLobbySP_SetSessionDesc(p,a)           (p)->SetSessionDesc(a)
#define IDPLobbySP_StartSession(p,a)             (p)->StartSession(a)
#define IDPLobbySP_SetGroupOwner(p,a)            (p)->SetGroupOwner(a)
#define IDPLobbySP_SetSPDataPointer(p,a)         (p)->SetSPDataPointer(a)

#endif /* C or C++ */


#ifdef __cplusplus
};
#endif // __cplusplus

#endif // __LOBBYSP_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplobby\player.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       player.c
 *  Content:	Methods for player management
 *
 *  History:
 *	Date		By		Reason
 *	=======		=======	======
 *	2/27/97		myronth	Created it
 *	3/17/97		myronth	Create/DestroyPlayer, Removed unnecessary Enum fn's
 *	3/21/97		myronth	SetPlayerName, Get/SetPlayerData, Removed more
 *						unnecessary functions
 *	3/25/97		myronth	Fixed GetPlayer prototype (1 new parameter)
 *	3/31/97		myronth	Removed dead code, Implemented Send, Added
 *						CreateAndMapNewPlayer function
 *	4/3/97		myronth	Changed CALLSP macro to CALL_LP
 *	4/10/97		myronth	Added support for GetPlayerCaps
 *	5/8/97		myronth	Drop lobby lock when calling LP, Propagate player's
 *						receive event on CreatePlayer call
 *	5/12/97		myronth	Handle remote players properly, create a lobby
 *						system player for all remote players & groups
 *	5/17/97		myronth	SendChatMessage
 *	5/20/97		myronth	Made AddPlayerToGroup & DeletePlayerFromGroup return
 *						DPERR_ACCESSDENIED on remote players (#8679),
 *						Fixed a bunch of other lock bugs, Changed debug levels
 *	6/3/97		myronth	Added support for player flags in CreatePlayer
 *	9/29/97		myronth	Send local SetPlayerName/Data msgs after call to
 *						lobby server succeeds (#12554)
 *	11/5/97		myronth	Expose lobby ID's as DPID's in lobby sessions
 ***************************************************************************/
#include "dplobpr.h"


//--------------------------------------------------------------------------
//
//	Functions
//
//--------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "PRV_CreatePlayer"
HRESULT DPLAPI PRV_CreatePlayer(LPDPLOBBYI_DPLOBJECT this, LPDPID lpidPlayer,
						LPDPNAME lpName, HANDLE hEvent, LPVOID lpData,
						DWORD dwDataSize, DWORD dwFlags)
{
	SPDATA_CREATEPLAYER		cp;
	HRESULT					hr = DP_OK;
	DWORD					dwPlayerFlags;


	DPF(7, "Entering PRV_CreatePlayer");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, %lu, 0x%08x",
			this, lpidPlayer, lpName, hEvent, lpData, dwDataSize, dwFlags);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// Setup our SPDATA struct
	memset(&cp, 0, sizeof(SPDATA_CREATEPLAYER));
	cp.dwSize = sizeof(SPDATA_CREATEPLAYER);
	cp.lpName = lpName;
	cp.lpData = lpData;
	cp.dwDataSize = dwDataSize;
	cp.dwFlags = dwFlags;

	// Call the CreatePlayer method in the SP
	if(CALLBACK_EXISTS(CreatePlayer))
	{
		cp.lpISP = PRV_GetDPLobbySPInterface(this);
	    
		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
		hr = CALL_LP(this, CreatePlayer, &cp);
		ENTER_DPLOBBY();
	}
	else 
	{
		// CreatePlayer is required
		DPF_ERR("The Lobby Provider callback for CreatePlayer doesn't exist -- it's required");
		ASSERT(FALSE);
		LEAVE_DPLOBBY();
		return DPERR_UNAVAILABLE;
	}

	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed calling CreatePlayer in the Lobby Provider, hr = 0x%08x", hr);
		LEAVE_DPLOBBY();
		return hr;
	}

	// Fix up the player flags
	dwPlayerFlags = DPLAYI_PLAYER_PLAYERLOCAL;
	if(dwFlags & DPPLAYER_SPECTATOR)
		dwPlayerFlags |= DPLAYI_PLAYER_SPECTATOR;

	// Add the player to dplay's nametable and put it in our map table
	hr = PRV_CreateAndMapNewPlayer(this, lpidPlayer, lpName, hEvent, lpData,
			dwDataSize, dwPlayerFlags, cp.dwPlayerID, FALSE);
	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed creating a new local player, hr = 0x%08x", hr);
		// REVIEW!!!! -- We need to send a message back to the server saying
		// we couldn't complete the deal on our end.
	}

	LEAVE_DPLOBBY();
	return hr;

} // PRV_CreatePlayer



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DestroyPlayer"
HRESULT DPLAPI PRV_DestroyPlayer(LPDPLOBBYI_DPLOBJECT this, DWORD dwLobbyID)
{
	SPDATA_DESTROYPLAYER	dp;
	LPDPLAYI_PLAYER			lpPlayer = NULL;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering PRV_DestroyPlayer");
	DPF(9, "Parameters: 0x%08x, 0x%08x", this, dwLobbyID);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLAY();
			return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
    }


	// Take the dplay lock since we'll be looking at a dplay internal struct
	ENTER_DPLAY();

	// Make sure the player is a local player, otherwise return AccessDenied
	lpPlayer = PlayerFromID(this->lpDPlayObject, dwLobbyID);
	if(!lpPlayer)
	{
		LEAVE_DPLAY();
		DPF_ERR("Unable to find player in nametable");
		hr = DPERR_INVALIDPLAYER;
		goto EXIT_DESTROYPLAYER;
	}

	if(!(lpPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
	{
		LEAVE_DPLAY();
		DPF_ERR("Cannot add a remote player to a group");
		hr = DPERR_ACCESSDENIED;
		goto EXIT_DESTROYPLAYER;
	}
	
	// Drop the dplay lock since we're done
	LEAVE_DPLAY();

	// Setup our SPDATA struct
	memset(&dp, 0, sizeof(SPDATA_DESTROYPLAYER));
	dp.dwSize = sizeof(SPDATA_DESTROYPLAYER);
	dp.dwPlayerID = dwLobbyID;

	// Call the DestroyPlayer method in the SP
	if(CALLBACK_EXISTS(DestroyPlayer))
	{
		dp.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, DestroyPlayer, &dp);
		ENTER_DPLOBBY();
	}
	else 
	{
		// DestroyPlayer is required
		DPF_ERR("The Lobby Provider callback for DestroyPlayer doesn't exist -- it's required");
		ASSERT(FALSE);
		hr = DPERR_UNAVAILABLE;
		goto EXIT_DESTROYPLAYER;
	}

	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed calling DestroyPlayer in the Lobby Provider, hr = 0x%08x", hr);
		goto EXIT_DESTROYPLAYER;
	}

	// The dplay InternalDestroyPlayer code will take care of the rest of
	// the internal cleanup (nametable, groups, etc.), so we can just return
	// from here.

EXIT_DESTROYPLAYER:

	LEAVE_DPLOBBY();
	return hr;

} // PRV_DestroyPlayer



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetPlayerCaps"
HRESULT DPLAPI PRV_GetPlayerCaps(LPDPLOBBYI_DPLOBJECT this, DWORD dwFlags,
				DWORD dwPlayerID, LPDPCAPS lpcaps)
{
	SPDATA_GETPLAYERCAPS	gcd;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering PRV_GetPlayerCaps");
	DPF(9, "Parameters: 0x%08x, 0x%08x, %lu, 0x%08x",
			this, dwFlags, dwPlayerID, lpcaps);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLAY();
			return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
    }

	
	// Setup our SPDATA struct
	memset(&gcd, 0, sizeof(SPDATA_GETCAPS));
	gcd.dwSize = sizeof(SPDATA_GETCAPS);
	gcd.dwFlags = dwFlags;
	gcd.dwPlayerID = dwPlayerID;
	gcd.lpcaps = lpcaps;

	// Call the GetPlayerCaps method in the LP
	if(CALLBACK_EXISTS(GetPlayerCaps))
	{
		gcd.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, GetPlayerCaps, &gcd);
		ENTER_DPLOBBY();
	}
	else 
	{
		// GetPlayerCaps is required
		DPF_ERR("The Lobby Provider callback for GetPlayerCaps doesn't exist -- it's required");
		ASSERT(FALSE);
		hr = DPERR_UNAVAILABLE;
		goto EXIT_GETPLAYERCAPS;
	}

	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed calling GetPlayerCaps in the Lobby Provider, hr = 0x%08x", hr);
	}

EXIT_GETPLAYERCAPS:

	LEAVE_DPLOBBY();
	return hr;

} // PRV_GetPlayerCaps



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetPlayerData"
HRESULT DPLAPI PRV_GetPlayerData(LPDPLOBBYI_DPLOBJECT this, DWORD dwPlayerID,
					LPVOID lpData, LPDWORD lpdwDataSize)
{
	SPDATA_GETPLAYERDATA	gpd;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering DPL_GetPlayerData");
	DPF(9, "Parameters: 0x%08x, %lu, 0x%08x, 0x%08x",
			this, dwPlayerID, lpData, lpdwDataSize);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLAY();
			return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
    }


	// Setup our SPDATA struct
	memset(&gpd, 0, sizeof(SPDATA_GETPLAYERDATA));
	gpd.dwSize = sizeof(SPDATA_GETPLAYERDATA);
	gpd.dwPlayerID = dwPlayerID;
	gpd.lpdwDataSize = lpdwDataSize;
	gpd.lpData = lpData;

	// Call the GetPlayerData method in the SP
	if(CALLBACK_EXISTS(GetPlayerData))
	{
		gpd.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, GetPlayerData, &gpd);
		ENTER_DPLOBBY();
	}
	else 
	{
		// GetPlayerData is required
		DPF_ERR("The Lobby Provider callback for GetPlayerData doesn't exist -- it's required");
		ASSERT(FALSE);
		hr = DPERR_UNAVAILABLE;
		goto EXIT_GETPLAYERDATA;
	}

	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed calling GetPlayerData in the Lobby Provider, hr = 0x%08x", hr);
	}

EXIT_GETPLAYERDATA:

	LEAVE_DPLOBBY();
	return hr;

} // PRV_GetPlayerData



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_Send"
HRESULT DPLAPI PRV_Send(LPDPLOBBYI_DPLOBJECT this, DWORD dwFromID, DWORD dwToID,
					DWORD dwFlags, LPVOID lpBuffer, DWORD dwBufSize)
{
	SPDATA_SEND		sd;
	HRESULT			hr = DP_OK;


	DPF(7, "Entering PRV_Send");
	DPF(9, "Parameters: 0x%08x, %lu, %lu, 0x%08x, 0x%08x, %lu",
			this, dwFromID, dwToID, dwFlags, lpBuffer, dwBufSize);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLAY();
			return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
    }


	// Setup our SPDATA structure
	memset(&sd, 0, sizeof(SPDATA_SEND));
	sd.dwSize = sizeof(SPDATA_SEND);
	sd.dwFromID = dwFromID;
	sd.dwToID = dwToID;
	sd.dwFlags = dwFlags;
	sd.lpBuffer = lpBuffer;
	sd.dwBufSize = dwBufSize;

	// Call the Send method in the SP
	if(CALLBACK_EXISTS(Send))
	{
		sd.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, Send, &sd);
		ENTER_DPLOBBY();
	}
	else 
	{
		// Send is required
		DPF_ERR("The Lobby Provider callback for Send doesn't exist -- it's required");
		ASSERT(FALSE);
		LEAVE_DPLOBBY();
		return DPERR_UNAVAILABLE;
	}

	LEAVE_DPLOBBY();
	return hr;

} // PRV_Send



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SendChatMessage"
HRESULT DPLAPI PRV_SendChatMessage(LPDPLOBBYI_DPLOBJECT this, DWORD dwFromID,
			DWORD dwToID, DWORD dwFlags, LPDPCHAT lpChat)
{
	SPDATA_CHATMESSAGE		sd;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering PRV_SendChatMessage");
	DPF(9, "Parameters: 0x%08x, %lu, %lu, 0x%08x, 0x%08x",
			this, dwFromID, dwToID, dwFlags, lpChat);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLAY();
			return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
    }


	// Setup our SPDATA structure
	memset(&sd, 0, sizeof(SPDATA_CHATMESSAGE));
	sd.dwSize = sizeof(SPDATA_CHATMESSAGE);
	sd.dwFromID = dwFromID;
	sd.dwToID = dwToID;
	sd.dwFlags = dwFlags;
	sd.lpChat = lpChat;

	// Call the SendChatMessage method in the SP
	if(CALLBACK_EXISTS(SendChatMessage))
	{
		sd.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, SendChatMessage, &sd);
		ENTER_DPLOBBY();
	}
	else 
	{
		// SendChatMessage is required
		DPF_ERR("The Lobby Provider callback for SendChatMessage doesn't exist -- it's required");
		ASSERT(FALSE);
		hr = DPERR_UNAVAILABLE;
		goto EXIT_SENDCHATMESSAGE;
	}

EXIT_SENDCHATMESSAGE:

	LEAVE_DPLOBBY();
	return hr;

} // PRV_SendChatMessage



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SetPlayerData"
HRESULT DPLAPI PRV_SetPlayerData(LPDPLOBBYI_DPLOBJECT this, DWORD dwPlayerID,
					LPVOID lpData, DWORD dwDataSize, DWORD dwFlags)
{
	SPDATA_SETPLAYERDATA	spd;
	LPDPLAYI_PLAYER			lpPlayer = NULL;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering PRV_SetPlayerData");
	DPF(9, "Parameters: 0x%08x, %lu, 0x%08x, %lu, 0x%08x",
			this, dwPlayerID, lpData, dwDataSize, dwFlags);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLAY();
			return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
    }


	// Take the dplay lock since we'll be looking at a dplay internal struct
	ENTER_DPLAY();

	// Make sure the player is a local player, otherwise return AccessDenied
	lpPlayer = PlayerFromID(this->lpDPlayObject, dwPlayerID);
	if(!lpPlayer)
	{
		LEAVE_DPLAY();
		DPF_ERR("Unable to find player in nametable");
		hr = DPERR_INVALIDPLAYER;
		goto EXIT_SETPLAYERDATA;
	}

	if(!(lpPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
	{
		LEAVE_DPLAY();
		DPF_ERR("Cannot add a remote player to a group");
		hr = DPERR_ACCESSDENIED;
		goto EXIT_SETPLAYERDATA;
	}
	
	// Drop the dplay lock since we're finished
	LEAVE_DPLAY();

	// Setup our SPDATA struct
	memset(&spd, 0, sizeof(SPDATA_SETPLAYERDATA));
	spd.dwSize = sizeof(SPDATA_SETPLAYERDATA);
	spd.dwPlayerID = dwPlayerID;
	spd.dwDataSize = dwDataSize;
	spd.lpData = lpData;
	spd.dwFlags = dwFlags;

	// Call the SetPlayerData method in the SP
	if(CALLBACK_EXISTS(SetPlayerData))
	{
		spd.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, SetPlayerData, &spd);
		ENTER_DPLOBBY();
	}
	else 
	{
		// SetPlayerData is required
		DPF_ERR("The Lobby Provider callback for SetPlayerData doesn't exist -- it's required");
		ASSERT(FALSE);
		hr = DPERR_UNAVAILABLE;
		goto EXIT_SETPLAYERDATA;
	}

	// If it succeeded, send the SetPlayerData message to our local players
	if(SUCCEEDED(hr))
	{
		hr = PRV_SendDataChangedMessageLocally(this, dwPlayerID, lpData, dwDataSize);
	}
	else
	{
		DPF_ERRVAL("Failed calling SetPlayerData in the Lobby Provider, hr = 0x%08x", hr);
	}

EXIT_SETPLAYERDATA:

	LEAVE_DPLOBBY();
	return hr;

} // PRV_SetPlayerData



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SetPlayerName"
HRESULT DPLAPI PRV_SetPlayerName(LPDPLOBBYI_DPLOBJECT this, DWORD dwPlayerID,
					LPDPNAME lpName, DWORD dwFlags)
{
	SPDATA_SETPLAYERNAME	spn;
	LPDPLAYI_PLAYER			lpPlayer = NULL;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering DPL_SetPlayerName");
	DPF(9, "Parameters: 0x%08x, %lu, 0x%08x, 0x%08x",
			this, dwPlayerID, lpName, dwFlags);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLAY();
			return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
    }


	// Take the dplay lock since we'll be looking at a dplay internal struct
	ENTER_DPLAY();

	// Make sure the player is a local player, otherwise return AccessDenied
	lpPlayer = PlayerFromID(this->lpDPlayObject, dwPlayerID);
	if(!lpPlayer)
	{
		LEAVE_DPLAY();
		DPF_ERR("Unable to find player in nametable");
		hr = DPERR_INVALIDPLAYER;
		goto EXIT_SETPLAYERNAME;
	}

	if(!(lpPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
	{
		LEAVE_DPLAY();
		DPF_ERR("Cannot add a remote player to a group");
		hr = DPERR_ACCESSDENIED;
		goto EXIT_SETPLAYERNAME;
	}
	
	// Drop the dplay lock since we're finished
	LEAVE_DPLAY();

	// Setup our SPDATA struct
	memset(&spn, 0, sizeof(SPDATA_SETPLAYERNAME));
	spn.dwSize = sizeof(SPDATA_SETPLAYERNAME);
	spn.dwPlayerID = dwPlayerID;
	spn.lpName = lpName;
	spn.dwFlags = dwFlags;

	// Call the SetPlayerName method in the SP
	if(CALLBACK_EXISTS(SetPlayerName))
	{
		spn.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, SetPlayerName, &spn);
		ENTER_DPLOBBY();
	}
	else 
	{
		// SetPlayerName is required
		DPF_ERR("The Lobby Provider callback for SetPlayerName doesn't exist -- it's required");
		ASSERT(FALSE);
		hr = DPERR_UNAVAILABLE;
		goto EXIT_SETPLAYERNAME;
	}

	// If it succeeded, send the SetPlayerName message to our local players
	if(SUCCEEDED(hr))
	{
		hr = PRV_SendNameChangedMessageLocally(this, dwPlayerID, lpName, TRUE);
	}
	else
	{
		DPF_ERRVAL("Failed calling SetPlayerName in the Lobby Provider, hr = 0x%08x", hr);
	}

EXIT_SETPLAYERNAME:

	LEAVE_DPLOBBY();
	return hr;

} // PRV_SetPlayerName



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GrowMapTable"
HRESULT PRV_GrowMapTable(LPDPLOBBYI_DPLOBJECT this)
{
	LPDPLOBBYI_MAPIDNODE	lpTempMap = NULL;


	// If we haven't already allocated a buffer, allocate one with
	// DPLOBBYPR_DEFAULTMAPENTRIES entries in it
	if(!this->lpMap)
	{
		this->lpMap = DPMEM_ALLOC(DPLOBBYPR_DEFAULTMAPENTRIES *
							sizeof(DPLOBBYI_MAPIDNODE));
		if(!this->lpMap)
		{
			DPF(2, "Unable to allocate memory for ID map table");
			return DPERR_OUTOFMEMORY;
		}

		this->dwTotalMapEntries = DPLOBBYPR_DEFAULTMAPENTRIES;
		return DP_OK;
	}

	// Otherwise, grow the table by the default number of entries
	lpTempMap = DPMEM_REALLOC(this->lpMap, (this->dwTotalMapEntries +
				DPLOBBYPR_DEFAULTMAPENTRIES * sizeof(DPLOBBYI_MAPIDNODE)));
	if(!lpTempMap)
	{
		DPF(2, "Unable to grow map table");
		return DPERR_OUTOFMEMORY;
	}

	this->lpMap = lpTempMap;
	this->dwTotalMapEntries += DPLOBBYPR_DEFAULTMAPENTRIES *
								sizeof(DPLOBBYI_MAPIDNODE);

	return DP_OK;

} // PRV_GrowMapTable



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DoesLobbyIDExist"
BOOL PRV_DoesLobbyIDExist(LPDPLOBBYI_DPLOBJECT this, DWORD dwLobbyID,
		LPDWORD lpdwIndex)
{
	DWORD	dwIndex = 0;


	if(this->lpMap && this->dwMapEntries)
	{
		// REVIEW!!!! -- We need to make this faster -- use a sorted array
		while(dwIndex < this->dwMapEntries)
		{
			if(this->lpMap[dwIndex++].dwLobbyID == dwLobbyID)
			{
				*lpdwIndex = --dwIndex;
				return TRUE;
			}
		}
	}

	return FALSE;

} // PRV_DoesLobbyIDExist



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_AddMapIDNode"
HRESULT PRV_AddMapIDNode(LPDPLOBBYI_DPLOBJECT this, DWORD dwLobbyID, DPID dpid)
{
	HRESULT		hr = DP_OK;
	DWORD		dwIndex = 0;


	// Make sure we have room for a new entry
	if(this->dwMapEntries == this->dwTotalMapEntries)
	{
		hr = PRV_GrowMapTable(this);
		if(FAILED(hr))
			return hr;
	}

	// Verify that this LobbyID doesn't already exist in the table
	if(PRV_DoesLobbyIDExist(this, dwLobbyID, &dwIndex))
	{
		DPF(2, "Tried to add Lobby ID to map table which already existed, overwriting data");
		ASSERT(FALSE);
		this->lpMap[dwIndex].dwLobbyID = dwLobbyID;
		this->lpMap[dwIndex].dpid = dpid;
		return hr;
	}	

	// REVIEW!!!! -- We need to add this in and keep the array sorted to
	// make lookups faster, but for now, don't worry about it.
	// Fill in a new node at the end of the array
	this->lpMap[this->dwMapEntries].dwLobbyID = dwLobbyID;
	this->lpMap[this->dwMapEntries].dpid = dpid;
	this->dwMapEntries++;

	return hr;

} // PRV_AddMapIDNode



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DeleteMapIDNode"
BOOL PRV_DeleteMapIDNode(LPDPLOBBYI_DPLOBJECT this, DWORD dwLobbyID)
{
	DWORD	dwIndex = 0;


	// Make sure we have entries
	if((this->lpMap) && (this->dwMapEntries))
	{
		// REVIEW!!!! -- We need to make this faster by using a sorted array
		while(dwIndex < this->dwMapEntries)
		{
			if(this->lpMap[dwIndex].dwLobbyID == dwLobbyID)
			{
				// Check for the boundary case (last entry)
				if((++dwIndex) == this->dwMapEntries)
				{
					// This is the last entry, so don't do anything but
					// decrement the number of entries
					this->dwMapEntries--;
					return TRUE;
				}
				else
				{
					// Move all entries from here to the end of the list
					// up one array entry
					MoveMemory((LPDPLOBBYI_MAPIDNODE)(&this->lpMap[dwIndex-1]),
						(LPDPLOBBYI_MAPIDNODE)(&this->lpMap[dwIndex]),
						((this->dwMapEntries - dwIndex) *
						sizeof(DPLOBBYI_MAPIDNODE)));

					// Decrement the count of entries
					this->dwMapEntries--;
					
					return TRUE;
				}
			}
			else
				dwIndex++;
		}
	}

	// We weren't able to delete the entry in the map table
	DPF(2, "Trying to delete an entry in the map ID table which doesn't exist");
	ASSERT(FALSE);
	return FALSE;

} // PRV_DeleteMapIDNode



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetDPIDByLobbyID"
BOOL PRV_GetDPIDByLobbyID(LPDPLOBBYI_DPLOBJECT this, DWORD dwLobbyID,
									DPID * lpdpid)
{
	DWORD	dwIndex = 0;

	
	// Take care of the known cases or else look in the map table
	switch(dwLobbyID)
	{
		case DPID_ALLPLAYERS:
		case DPID_SERVERPLAYER:
			*lpdpid = dwLobbyID;
			return TRUE;

		default:
			// Walk the list look for the ID
			while(dwIndex < this->dwMapEntries)
			{
				if(this->lpMap[dwIndex].dwLobbyID == dwLobbyID)
				{
					*lpdpid = this->lpMap[dwIndex].dpid;
					return TRUE;
				}
				else
					dwIndex++;
			}
	}

	return FALSE;

} // PRV_GetDPIDByLobbyID



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetLobbyIDByDPID"
BOOL PRV_GetLobbyIDByDPID(LPDPLOBBYI_DPLOBJECT this, DPID dpid,
									LPDWORD lpdwLobbyID)
{
	DWORD	dwIndex = 0;

	
	// Take care of the known cases or else look in the map table
	switch(dpid)
	{
		case DPID_ALLPLAYERS:
		case DPID_SERVERPLAYER:
			*lpdwLobbyID = dpid;
			return TRUE;

		default:
			// Walk the list look for the ID
			while(dwIndex < this->dwMapEntries)
			{
				if(this->lpMap[dwIndex].dpid == dpid)
				{
					*lpdwLobbyID = this->lpMap[dwIndex].dwLobbyID;
					return TRUE;
				}
				else
					dwIndex++;
			}
			break;
	}

	return FALSE;

} // PRV_GetLobbyIDByDPID



#undef DPF_MODNAME
#define DPF_MODNAME "IsLobbyIDInMapTable"
BOOL IsLobbyIDInMapTable(LPDPLOBBYI_DPLOBJECT this, DWORD dwID)
{
	DPID	dpidTemp;

	// If we can get it, then it's in there
	if(PRV_GetDPIDByLobbyID(this, dwID, &dpidTemp))
		return TRUE;

	// Otherwise, return FALSE
	return FALSE;

} // IsLobbyIDInMapTable



#undef DPF_MODNAME
#define DPF_MODNAME "IsValidLobbyID"
BOOL IsValidLobbyID(DWORD dwID)
{
	// If it's in our reserved range, it's invalid.  Otherwise, it's valid
	if(dwID <= DPID_RESERVEDRANGE)
		return FALSE;
	else
		return TRUE;

} // IsValidLobbyID



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_CreateAndMapNewPlayer"
HRESULT PRV_CreateAndMapNewPlayer(LPDPLOBBYI_DPLOBJECT this,
			DPID * lpdpid, LPDPNAME lpName, HANDLE hEvent, LPVOID lpData,
			DWORD dwDataSize, DWORD dwFlags, DWORD dwLobbyID,
			BOOL bSystemPlayer)
{
	LPDPLAYI_PLAYER		lpPlayer = NULL, lpSysPlayer = NULL;
	HRESULT				hr = DP_OK;
	DPID				dpidPlayer = 0, dpidSysPlayer = 0;


	// Take the dplay lock
	ENTER_DPLAY();

	// Make sure the lobby ID is valid, but only if it's not a system player
	if((!bSystemPlayer) && (!IsValidLobbyID(dwLobbyID)))
	{
		DPF_ERRVAL("ID %lu is reserved, cannot create new player", dwLobbyID);
	    hr = DPERR_INVALIDPLAYER;
		goto EXIT_CREATEANDMAPNEWPLAYER;
	}

	// If this is a remote player, we need allocate a new nametable entry
	// for them and set the correct system player ID
	if(!(dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
	{
		// Allocate a new ID for the player
		hr = NS_AllocNameTableEntry(this->lpDPlayObject, &dpidPlayer);
		if(FAILED(hr))
		{
			DPF_ERRVAL("Unable to allocate new nametable id, hr = 0x%08x", hr);
			goto EXIT_CREATEANDMAPNEWPLAYER;
		}

		// Make sure we have a lobby system player (for all remote players)
		// If we don't then allocate a new one, unless we are creating
		// the system player currently
		if((!(this->dpidSysPlayer)) && (!(dwFlags & DPLAYI_PLAYER_SYSPLAYER)))
		{
			hr = PRV_CreateAndMapNewPlayer(this, &dpidSysPlayer, NULL, NULL, NULL,
					0, DPLAYI_PLAYER_SYSPLAYER,
					DPID_LOBBYREMOTESYSTEMPLAYER, TRUE);
			if(FAILED(hr))
			{
				DPF_ERRVAL("Unable to create lobby system player, hr = 0x%08x", hr);
				ASSERT(FALSE);
				goto EXIT_CREATEANDMAPNEWPLAYER;
			}

			// Set the lobby system player ID pointer to the new ID
			this->dpidSysPlayer = dpidSysPlayer;
		}
	}

	// Get a player struct for the player (if it's local, this will add it
	// to the nametable.  If it's remote, we need to add it below)
	hr = GetPlayer(this->lpDPlayObject, &lpPlayer, lpName, hEvent, lpData,
					dwDataSize, dwFlags, NULL, dwLobbyID);
	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed trying to add player to the nametable, hr = 0x%08x", hr);
		goto EXIT_CREATEANDMAPNEWPLAYER;
	}

	// If the player is remote, set the player's ID to the new one we
	// allocated and then set the system player ID to the lobby system player
	if(!(dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
	{
		// Set the player's system player
		lpPlayer->dwIDSysPlayer = this->dpidSysPlayer;

		// Add the player to the nametable
		hr = AddItemToNameTable(this->lpDPlayObject, (DWORD_PTR)lpPlayer,
				&dpidPlayer, TRUE, dwLobbyID);
	    if (FAILED(hr)) 
	    {
			DPF_ERRVAL("Unable to add new player to the nametable, hr = 0x%08x", hr);
			ASSERT(FALSE);
			goto EXIT_CREATEANDMAPNEWPLAYER;
	    }

		// Set the player's ID
		lpPlayer->dwID = dpidPlayer;
	}

	// Set the output dpid pointer
	*lpdpid = lpPlayer->dwID;

EXIT_CREATEANDMAPNEWPLAYER:

	LEAVE_DPLAY();
	return hr;

} // PRV_CreateAndMapNewPlayer
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplobby\psapi.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1994-1996  Microsoft Corporation

Module Name:

    psapi.h

Abstract:

    Include file for APIs provided by PSAPI.DLL

Author:

    Richard Shupak   [richards]  06-Jan-1994

Revision History:

--*/

#ifndef _PSAPI_H_
#define _PSAPI_H_

#ifdef __cplusplus
extern "C" {
#endif

BOOL
WINAPI
EnumProcesses(
    DWORD * lpidProcess,
    DWORD   cb,
    DWORD * cbNeeded
    );

BOOL
WINAPI
EnumProcessModules(
    HANDLE hProcess,
    HMODULE *lphModule,
    DWORD cb,
    LPDWORD lpcbNeeded
    );

DWORD
WINAPI
GetModuleBaseNameA(
    HANDLE hProcess,
    HMODULE hModule,
    LPSTR lpBaseName,
    DWORD nSize
    );

DWORD
WINAPI
GetModuleBaseNameW(
    HANDLE hProcess,
    HMODULE hModule,
    LPWSTR lpBaseName,
    DWORD nSize
    );

#ifdef UNICODE
#define GetModuleBaseName  GetModuleBaseNameW
#else
#define GetModuleBaseName  GetModuleBaseNameA
#endif // !UNICODE


DWORD
WINAPI
GetModuleFileNameExA(
    HANDLE hProcess,
    HMODULE hModule,
    LPSTR lpFilename,
    DWORD nSize
    );

DWORD
WINAPI
GetModuleFileNameExW(
    HANDLE hProcess,
    HMODULE hModule,
    LPWSTR lpFilename,
    DWORD nSize
    );

#ifdef UNICODE
#define GetModuleFileNameEx  GetModuleFileNameExW
#else
#define GetModuleFileNameEx  GetModuleFileNameExA
#endif // !UNICODE


typedef struct _MODULEINFO {
    LPVOID lpBaseOfDll;
    DWORD SizeOfImage;
    LPVOID EntryPoint;
} MODULEINFO, *LPMODULEINFO;


BOOL
WINAPI
GetModuleInformation(
    HANDLE hProcess,
    HMODULE hModule,
    LPMODULEINFO lpmodinfo,
    DWORD cb
    );


BOOL
WINAPI
EmptyWorkingSet(
    HANDLE hProcess
    );


BOOL
WINAPI
QueryWorkingSet(
    HANDLE hProcess,
    PVOID pv,
    DWORD cb
    );

BOOL
WINAPI
InitializeProcessForWsWatch(
    HANDLE hProcess
    );


typedef struct _PSAPI_WS_WATCH_INFORMATION {
    LPVOID FaultingPc;
    LPVOID FaultingVa;
} PSAPI_WS_WATCH_INFORMATION, *PPSAPI_WS_WATCH_INFORMATION;

BOOL
WINAPI
GetWsChanges(
    HANDLE hProcess,
    PPSAPI_WS_WATCH_INFORMATION lpWatchInfo,
    DWORD cb
    );

DWORD
WINAPI
GetMappedFileNameW(
    HANDLE hProcess,
    LPVOID lpv,
    LPWSTR lpFilename,
    DWORD nSize
    );

DWORD
WINAPI
GetMappedFileNameA(
    HANDLE hProcess,
    LPVOID lpv,
    LPSTR lpFilename,
    DWORD nSize
    );

#ifdef UNICODE
#define GetMappedFilenameEx  GetMappedFilenameExW
#else
#define GetMappedFilenameEx  GetMappedFilenameExA
#endif // !UNICODE

BOOL
WINAPI
EnumDeviceDrivers(
    LPVOID *lpImageBase,
    DWORD cb,
    LPDWORD lpcbNeeded
    );


DWORD
WINAPI
GetDeviceDriverBaseNameA(
    LPVOID ImageBase,
    LPSTR lpBaseName,
    DWORD nSize
    );

DWORD
WINAPI
GetDeviceDriverBaseNameW(
    LPVOID ImageBase,
    LPWSTR lpBaseName,
    DWORD nSize
    );

#ifdef UNICODE
#define GetDeviceDriverBaseName  GetDeviceDriverBaseNameW
#else
#define GetDeviceDriverBaseName  GetDeviceDriverBaseNameA
#endif // !UNICODE


DWORD
WINAPI
GetDeviceDriverFileNameA(
    LPVOID ImageBase,
    LPSTR lpFilename,
    DWORD nSize
    );

DWORD
WINAPI
GetDeviceDriverFileNameW(
    LPVOID ImageBase,
    LPWSTR lpFilename,
    DWORD nSize
    );

#ifdef UNICODE
#define GetDeviceDriverFileName  GetDeviceDriverFileNameW
#else
#define GetDeviceDriverFileName  GetDeviceDriverFileNameA
#endif // !UNICODE

// Structure for GetProcessMemoryInfo()

typedef struct _PROCESS_MEMORY_COUNTERS {
    DWORD cb;
    DWORD PageFaultCount;
    DWORD PeakWorkingSetSize;
    DWORD WorkingSetSize;
    DWORD QuotaPeakPagedPoolUsage;
    DWORD QuotaPagedPoolUsage;
    DWORD QuotaPeakNonPagedPoolUsage;
    DWORD QuotaNonPagedPoolUsage;
    DWORD PagefileUsage;
    DWORD PeakPagefileUsage;
} PROCESS_MEMORY_COUNTERS;
typedef PROCESS_MEMORY_COUNTERS *PPROCESS_MEMORY_COUNTERS;

BOOL
WINAPI
GetProcessMemoryInfo(
    HANDLE Process,
    PPROCESS_MEMORY_COUNTERS ppsmemCounters,
    DWORD cb
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplobby\sources.inc ===
TARGETNAME=dplobby
TARGETPATH=.\obj$(BUILD_ALT_DIR)
TARGETTYPE=LIBRARY

USE_MAPSYM=1

INCLUDES= \
	$(DXROOT)\inc;\
	..\;\
	..\..\dplay;\
	..\..\common;\
	..\..\misc; \
	..\..\..\dvoice\inc;

C_DEFINES=$(C_DEFINES) -DWINVER=0x0400

!IFDEF PENTIUMCOUNTER
C_DEFINES=$(C_DEFINES) -DPENTIUMCOUNTER
ASM_DEFINES=$(ASM_DEFINES) -DPENTIUMCOUNTER
!endif

C_DEFINES=$(C_DEFINES)	-DUNICODE -D_UNICODE -DNEW_DPF -DSECURITY_WIN32


NTPROFILEINPUT=yes


SOURCES= \
        ..\create.c \
        ..\dplenum.c \
        ..\dplgame.c \
        ..\dplobby.c \
        ..\dplobbya.c \
        ..\dplpack.c \
        ..\dplshare.c \
        ..\dplsp.c \
        ..\dplunk.c \
        ..\group.c \
        ..\player.c \
        ..\server.c \
        ..\session.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplobby\win9x\makefile.inc ===
misc :
	copy ..\..\common\newdpf.h .
	copy ..\..\common\newdpf.c .
	copy ..\..\common\dputils.c .
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplobby\server.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       server.c
 *  Content:	Methods for connecting and interrogating a lobby server
 *
 *  History:
 *	Date		By		Reason
 *	=======		=======	======
 *	10/25/96	myronth	Created it
 *	11/20/96	myronth	Implemented Logon/LogoffServer
 *	2/12/97		myronth	Mass DX5 changes
 *	2/26/97		myronth	#ifdef'd out DPASYNCDATA stuff (removed dependency)
 *	3/12/97		myronth	Fixed LoadSP code for DPlay3, reg & DPF bug fixes
 *	3/13/97		myronth	Save hInstance handle for LP DLL
 *	4/3/97		myronth	Changed CALLSP macro to CALL_LP
 *	4/9/97		myronth	Fixed structure passed to LP at DPLSPInit
 *	5/8/97		myronth	Purged dead code
 *	6/19/97		myronth	Moved setting of DPLOBBYPR_SPINTERFACE flag (#10118)
 *  7/28/97		sohailm	PRV_FindLPGUIDInAddressCallback was assuming pointers 
 *						were valid after duration of call.
 *	10/3/97		myronth	Bumped version to DX6, added it to DPLSPInit struct (#12667)
 *	10/7/97		myronth	Save the LP version in the lobby struct for later use
 *	11/6/97		myronth	Added version existence flag and dwReserved values
 *						to SPDATA_INIT (#12916, #12917)
 ***************************************************************************/
#include "dplobpr.h"


//--------------------------------------------------------------------------
//
//	Definitions
//
//--------------------------------------------------------------------------
#define NUM_CALLBACKS( ptr ) ((ptr->dwSize-2*sizeof( DWORD ))/ sizeof( LPVOID ))

typedef struct LOOKFORSP
{
	LPGUID	lpguid;
	LPBOOL	lpbSuccess;
} LOOKFORSP, FAR * LPLOOKFORSP;

//--------------------------------------------------------------------------
//
//	Functions
//
//--------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "PRV_VerifySPCallbacks"
HRESULT PRV_VerifySPCallbacks(LPDPLOBBYI_DPLOBJECT this)
{
	LPDWORD	lpCallback;
	int		nCallbacks = NUM_CALLBACKS(((LPSP_CALLBACKS)this->pcbSPCallbacks));
	int		i;


	DPF(2,"Verifying %d callbacks\n",nCallbacks);
	DPF(7, "Entering PRV_VerifySPCallbacks");
	DPF(9, "Parameters: 0x%08x", this);

	lpCallback = (LPDWORD)this->pcbSPCallbacks + 2; // + 1 for dwSize, + 1 for dwFlags

	for (i=0;i<nCallbacks ;i++ )
	{
		if ((lpCallback) && !VALIDEX_CODE_PTR(lpCallback)) 
		{
			DPF_ERR("SP provided bad callback pointer!");
			return E_FAIL;
		}
		lpCallback++;
	}

	return DP_OK;	

} // PRV_VerifySPCallbacks



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_LookForSPCallback"
BOOL FAR PASCAL PRV_LookForSPCallback(LPGUID lpguidSP, LPWSTR lpSPName,
				DWORD dwMajorVersion, DWORD dwMinorVersion, LPVOID lpContext)
{
	LPLOOKFORSP		lplook = (LPLOOKFORSP)lpContext;


	ASSERT(lpguidSP);
	ASSERT(lplook);

	// Check the guid and see if they match
	if(IsEqualGUID(lpguidSP, lplook->lpguid))
	{
		// Set the flag to true and stop enumerating
		*(lplook->lpbSuccess) = TRUE;
		return FALSE;
	}

	return TRUE;

} // PRV_LookForSPCallback



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_FindSPName"
HRESULT PRV_FindSPName(LPGUID lpguidSP, LPWSTR * lplpName,
		LPDWORD lpdwReserved1, LPDWORD lpdwReserved2)
{
	HKEY		hkeyLobbySP=NULL, hkeySP;
	WCHAR		wszSPName[DPLOBBY_REGISTRY_NAMELEN];
	DWORD		dwIndex = 0, dwSPNameSize;
	WCHAR		wszGuidStr[GUID_STRING_SIZE];
	DWORD		dwGuidStrSize = sizeof(wszGuidStr)/sizeof(WCHAR);
	DWORD		dwFileStrSize = 0;
	DWORD		dwType = REG_SZ;
	LPWSTR		lpwszFile = NULL;
	GUID		guidSP;
	LOOKFORSP	look;
	LONG		lReturn;
	BOOL		bFound = FALSE;
	DWORD		dwError;
	HRESULT		hr;
	DWORD		dwSize;



	DPF(7, "Entering PRV_FindSPName");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpguidSP, lplpName);

	ASSERT(lpguidSP);
	ASSERT(lplpName);


	// First see if it is a Lobby SP
	// Open the DPLobby SP key
	lReturn = OS_RegOpenKeyEx(HKEY_LOCAL_MACHINE, SZ_DPLOBBY_SP_KEY, 0,
								KEY_READ, &hkeyLobbySP);
	// If this fails, it just means that the DPLobby SP key doesn't exist (most
	// likely), so in that case, there are no Lobby SP's to enumerate.
	if(lReturn == ERROR_SUCCESS)
	{
		// Walk the list of Lobby SP's in the registry, enumerating them
		while(!bFound)
		{
		
			// Get the next key's name
			dwSPNameSize = DPLOBBY_REGISTRY_NAMELEN;
			lReturn = OS_RegEnumKeyEx(hkeyLobbySP, dwIndex++, (LPWSTR)wszSPName,
							&dwSPNameSize, NULL, NULL, NULL, NULL);
			if(ERROR_NO_MORE_ITEMS == lReturn)
				break;
			else if(lReturn != ERROR_SUCCESS)
			{
				dwError = GetLastError();
				DPF(2, "Unable to get Lobby Provider name -- skipping provider -- dwError = %u", dwError);
				continue;
			}
			

			// Open the key
			lReturn = OS_RegOpenKeyEx(hkeyLobbySP, (LPWSTR)wszSPName, 0,
										KEY_READ, &hkeySP);
			if(lReturn != ERROR_SUCCESS)
			{
				DPF_ERR("Unable to open Lobby Service Provider key in the registry!");
				continue;
			}

			// Get the GUID of the SP
			dwGuidStrSize = GUID_STRING_SIZE;
			lReturn = OS_RegQueryValueEx(hkeySP, SZ_GUID, NULL, &dwType,
										(LPBYTE)wszGuidStr, &dwGuidStrSize);
			if(lReturn != ERROR_SUCCESS)
			{
				RegCloseKey(hkeySP);
				DPF_ERR("Unable to query GUID key value!");
				continue;
			}

			// Convert the string to a real GUID
			GUIDFromString(wszGuidStr, &guidSP);

			// Check to see if the guid is the one we are looking for
			if(IsEqualGUID(&guidSP, lpguidSP))
			{
				// Allocate memory for the filename string
				lReturn = OS_RegQueryValueEx(hkeySP, SZ_PATH, NULL, &dwType,
											NULL, &dwFileStrSize);
				if(lReturn != ERROR_SUCCESS)
				{
					RegCloseKey(hkeySP);
					DPF_ERR("Unable to get the size of the SP Path string");
					continue;
				}
				
				// Allocate memory for the string
				lpwszFile = DPMEM_ALLOC(dwFileStrSize);
				if(!lpwszFile)
				{
					RegCloseKey(hkeySP);
					DPF_ERR("Unable to allocate memory for temporary file string");
					continue;
				}

				// Get the filename string
				lReturn = OS_RegQueryValueEx(hkeySP, SZ_PATH, NULL, &dwType,
											(LPBYTE)lpwszFile, &dwFileStrSize);
				if(lReturn != ERROR_SUCCESS)
				{
					RegCloseKey(hkeySP);
					DPF_ERR("Unable to get filename string from registry");
					continue;
				}

				// Get the Reserved1 value
				dwSize = sizeof(DWORD);
				lReturn = OS_RegQueryValueEx(hkeySP, SZ_DWRESERVED1, NULL,
							&dwType, (LPBYTE)lpdwReserved1, &dwSize);
				if (lReturn != ERROR_SUCCESS) 
				{
					DPF(0,"Could not read dwReserved1 lReturn = %d\n", lReturn);
					// It's ok if LP doesn't have one of these...
				}

				// Get the Reserved2 value
				dwSize = sizeof(DWORD);
				lReturn = OS_RegQueryValueEx(hkeySP, SZ_DWRESERVED2, NULL,
							&dwType, (LPBYTE)lpdwReserved2, &dwSize);
				if (lReturn != ERROR_SUCCESS) 
				{
					DPF(0,"Could not read dwReserved2 lReturn = %d\n", lReturn);
					// It's ok if LP doesn't have one of these...
				}

				// We've got our information, so set the flag and bail
				bFound = TRUE;
				RegCloseKey(hkeySP);
				break;
			}

			// Close the SP key
			RegCloseKey(hkeySP);
		}
	}

	// Close the Lobby SP key
	if(hkeyLobbySP)
	{
		RegCloseKey(hkeyLobbySP);
	}	

	// If we haven't found the SP, start checking the DPlay SP's for it
	if(!bFound)
	{
		// Set up a struct containing the guid and a success flag
		look.lpguid = lpguidSP;
		look.lpbSuccess = &bFound;
		
		// Call DirectPlayEnumerate and look for our SP
		hr = DirectPlayEnumerate(PRV_LookForSPCallback, &look);
		if(FAILED(hr))
		{
			DPF_ERR("Unable to enumerate DirectPlay Service Providers");
		}

		// If the flag is TRUE, that means we found it, so set the output
		// pointer to a string containing our LobbySP for DPlay
		if(bFound)
		{
			hr = GetString(&lpwszFile, SZ_SP_FOR_DPLAY);
			if(FAILED(hr))
			{
				DPF_ERR("Unable to allocate temporary string for filename");
			}
		}
	}	

	// If we haven't found the filename, return an error
	if(!bFound)
		return DPERR_GENERIC;

	// Set the output parameter
	*lplpName = lpwszFile;

	return DP_OK;

} // PRV_FindSPName



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_LoadSP"
HRESULT PRV_LoadSP(LPDPLOBBYI_DPLOBJECT this, LPGUID lpguidSP,
						LPVOID lpAddress, DWORD dwAddressSize)
{
	SPDATA_INIT				sd;
	SPDATA_SHUTDOWN			sdd;
	LPDPLOBBYSP				lpISP = NULL;
	LPWSTR					lpwszSP = NULL;
	HANDLE					hModule = NULL;
	HRESULT					hr;
	HRESULT					(WINAPI *SPInit)(LPSPDATA_INIT pSD);
	DWORD					dwError;
	DWORD					dwReserved1 = 0;
	DWORD					dwReserved2 = 0;


	DPF(7, "Entering PRV_LoadSP");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			this, lpguidSP, lpAddress);

	ASSERT(this);
	ASSERT(lpguidSP);


	// Find the requested Service Provider
	hr = PRV_FindSPName(lpguidSP, &lpwszSP, &dwReserved1, &dwReserved2);
	if(FAILED(hr))
	{
		DPF_ERR("Unabled to find requested LobbyProvider");
		hr = DPERR_GENERIC;
		goto ERROR_EXIT_LOADSP;
	}

 	// Try to load the specified sp
    hModule = OS_LoadLibrary(lpwszSP);
	if (!hModule) 
	{
		dwError = GetLastError();
		DPF_ERR("Could not load service provider\n");
		DPF(0, "GetLastError returned dwError = %d\n", dwError);
		hr = DPERR_GENERIC;
		goto ERROR_EXIT_LOADSP;
	}

	// Free the name string
	DPMEM_FREE(lpwszSP);
	lpwszSP = NULL;

	// Get our DPLSPInit entry point
    (FARPROC)SPInit = OS_GetProcAddress(hModule, "DPLSPInit");
	if (!SPInit) 
	{
		DPF(0,"Could not find service provider entry point");
		hr = DPERR_GENERIC;
		goto ERROR_EXIT_LOADSP;
	}

	// Get an IDPLobbySP to pass it
	hr = PRV_GetInterface(this, (LPDPLOBBYI_INTERFACE *)&lpISP, &dplCallbacksSP);
	if (FAILED(hr)) 
	{
		DPF(0,"Unable to get an IDPLobbySP interface. hr = 0x%08lx\n",hr);
		hr = DPERR_GENERIC;
		goto ERROR_EXIT_LOADSP;
	}
	
	// Alloc the callbacks
	this->pcbSPCallbacks = DPMEM_ALLOC(sizeof(SP_CALLBACKS));
	if (!this->pcbSPCallbacks) 
	{
		DPF_ERR("Unable to allocate memory for SPCallback structure");
		LEAVE_DPLOBBY();
		hr = DPERR_OUTOFMEMORY;
		goto ERROR_EXIT_LOADSP;
	}

	// Set up the init data struct
	memset(&sd,0,sizeof(sd));
	sd.lpCB = this->pcbSPCallbacks;
    sd.lpCB->dwSize = sizeof(SP_CALLBACKS);
	sd.lpCB->dwDPlayVersion = DPLSP_MAJORVERSION;
	sd.lpISP = lpISP;
	sd.lpAddress = lpAddress;
	sd.dwReserved1 = dwReserved1;
	sd.dwReserved2 = dwReserved2;

	hr = SPInit(&sd);
    if (FAILED(hr))
    {
    	DPF_ERR("Could not start up service provider!");
		goto ERROR_EXIT_LOADSP;
    }

	// Verify the callbacks are valid
	hr = PRV_VerifySPCallbacks(this);
    if (FAILED(hr))
    {
    	DPF_ERR("Invalid callbacks from service provider!");
		goto ERROR_EXIT_LOADSP;
    }

	// Make sure the SP version is valid
	if (sd.dwSPVersion < DPLSP_DX5VERSION)
	{
    	DPF_ERR("Incompatible version returned from lobby provider!");
		// Since the init succeeded, try to call shutdown
		memset(&sdd, 0, sizeof(SPDATA_SHUTDOWN));
		// REVIEW!!!! -- Should we pass a valid interface pointer
		// to the shutdown callback?  If so, which one?
		if (CALLBACK_EXISTS(Shutdown))
		{
			sdd.lpISP = PRV_GetDPLobbySPInterface(this);
			hr = CALL_LP(this, Shutdown, &sdd);
			if (FAILED(hr)) 
			{
				DPF_ERR("Could not invoke shutdown on the Lobby Provider");
			}
		}
		else 
		{
			ASSERT(FALSE);
		}

		hr = DPERR_UNAVAILABLE;
		goto ERROR_EXIT_LOADSP;
	}
	else
	{
		// Save the version of the lobby provider
		this->dwLPVersion = sd.dwSPVersion;
	}

	// Set the flag which tells us we have an IDPLobbySP interface
	this->dwFlags |= DPLOBBYPR_SPINTERFACE;

	// Save the hInstance for the LP's DLL
	this->hInstanceLP = hModule;

	return DP_OK;

ERROR_EXIT_LOADSP:
	
	// If the LP DLL was loaded, unload it
    if(hModule)
    {
        if(!FreeLibrary(hModule))
        {
			dwError = GetLastError();
			DPF_ERRVAL("Unable to free Lobby Provider DLL, dwError = %lu", dwError);
            ASSERT(FALSE);
        }
    }

	// Free our allocated callback table
	if(this->pcbSPCallbacks)
	{
		DPMEM_FREE(this->pcbSPCallbacks);
		this->pcbSPCallbacks = NULL;
	}

    return hr;

} // PRV_LoadSP



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_FindLPGUIDInAddressCallback"
BOOL FAR PASCAL PRV_FindLPGUIDInAddressCallback(REFGUID lpguidDataType, DWORD dwDataSize,
							LPCVOID lpData, LPVOID lpContext)
{	
	// See if this chunk is our LobbyProvider GUID
	if (IsEqualGUID(lpguidDataType, &DPAID_LobbyProvider))
	{
		// We found it, so we can stop enumerating chunks
		*((LPGUID)lpContext) = *((LPGUID)lpData);
		return FALSE;
	}
	
	// Try the next chunk
	return TRUE;

} // PRV_FindLPGUIDInAddressCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplog\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	DPLOG.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplog\dplog.cpp ===
// DPLOG.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "..\common\memlog.h"

int main(int argc, char* argv[])
{
	HANDLE hFile=0;
	HANDLE hMutex=0;
	LPVOID lpMemory=NULL;
	UINT timebase=0;
	UINT i=0;
	
	PSHARED_LOG_FILE pLogFile	=NULL;
	PLOG_ENTRY 		 pLog		=NULL;
    PLOG_ENTRY       pReadEntry =NULL;

	hFile=CreateFileMappingA(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, DPLOG_SIZE, BASE_LOG_FILENAME);
	hMutex=CreateMutexA(NULL, FALSE, BASE_LOG_MUTEXNAME); 
	lpMemory=MapViewOfFile(hFile, FILE_MAP_ALL_ACCESS, 0, 0, 0);

	if(!hFile || !hMutex || !lpMemory){
		goto exit;
	}

	pLogFile=(PSHARED_LOG_FILE)lpMemory;
	pLog=(PLOG_ENTRY)(pLogFile+1);

	WaitForSingleObject(hMutex,INFINITE);

	if(pLogFile->cInUse == pLogFile->nEntries){
		// dump last half of buffer
		for(i=pLogFile->iWrite; i < pLogFile->nEntries; i++){
			pReadEntry=(PLOG_ENTRY)(((CHAR *)pLog)+(i*(pLogFile->cbLine+sizeof(LOG_ENTRY))));
			printf("%4d: %8x %6d %2x %s\n",i,pReadEntry->hThread,pReadEntry->tLogged-timebase,pReadEntry->DebugLevel, pReadEntry->str);
			timebase=pReadEntry->tLogged;
		}
	}

	// dump firt part of buffer

	for(i=0;i<pLogFile->iWrite;i++){
		pReadEntry=(PLOG_ENTRY)(((CHAR *)pLog)+(i*(pLogFile->cbLine+sizeof(LOG_ENTRY))));
		printf("%4d: %8x %6d %2x %s\n",i,pReadEntry->hThread,pReadEntry->tLogged-timebase,pReadEntry->DebugLevel, pReadEntry->str);
		timebase=pReadEntry->tLogged;
	}

	ReleaseMutex(hMutex);
	UnmapViewOfFile(lpMemory);

exit:
	if(hFile){
		CloseHandle(hFile);
	}
	if(hMutex){
		CloseHandle(hMutex);
	}
	
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplobby\session.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       session.c
 *  Content:	Methods for session management
 *
 *  History:
 *	Date		By		Reason
 *	=======		=======	======
 *	2/27/97		myronth	Created it
 *	3/12/97		myronth	Implemented EnumSessions, Open, & Close
 *	3/31/97		myronth	Removed dead code, Fixed EnumSessionReponse fn name
 *	4/3/97		myronth	Changed CALLSP macro to CALL_LP
 *	5/8/97		myronth	Drop lobby lock when calling the LP
 *	5/13/97		myronth	Handle Credentials in Open, pass them to LP
 *	6/4/97		myronth	Fixed PRV_Open to fail on DPOPEN_CREATE (#9491)
 ***************************************************************************/
#include "dplobpr.h"


//--------------------------------------------------------------------------
//
//	Functions
//
//--------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "PRV_Close"
HRESULT DPLAPI PRV_Close(LPDPLOBBYI_DPLOBJECT this)
{
	SPDATA_CLOSE	cd;
	HRESULT			hr = DP_OK;


	DPF(7, "Entering PRV_Close");
	DPF(9, "Parameters: 0x%08x", this);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// Setup our SPDATA structure
	memset(&cd, 0, sizeof(SPDATA_CLOSE));
	cd.dwSize = sizeof(SPDATA_CLOSE);

	// Call the Close method in the SP
	if(CALLBACK_EXISTS(Close))
	{
		cd.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, Close, &cd);
		ENTER_DPLOBBY();
	}
	else 
	{
		// Close is required
		DPF_ERR("The Lobby Provider callback for Close doesn't exist -- it's required");
		ASSERT(FALSE);
		LEAVE_DPLOBBY();
		return DPERR_UNAVAILABLE;
	}

	LEAVE_DPLOBBY();
	return hr;

} // PRV_Close



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_EnumSessions"
HRESULT DPLAPI PRV_EnumSessions(LPDPLOBBYI_DPLOBJECT this,
		LPDPSESSIONDESC2 lpsd, DWORD dwTimeout, DWORD dwFlags)
{
	HRESULT					hr = DP_OK;
	SPDATA_ENUMSESSIONS		esd;


	DPF(7, "Entering PRV_EnumSessions");
	DPF(9, "Parameters: 0x%08x, 0x%08x, %lu, 0x%08x",
			this, lpsd, dwTimeout, dwFlags);

	ASSERT(this);
	ASSERT(lpsd);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	// Call the EnumSessions method in the SP
	if(CALLBACK_EXISTS(EnumSessions))
	{
		// Clear our stack-based structure
		memset(&esd, 0, sizeof(SPDATA_ENUMSESSIONS));

		// Set up the structure and call the callback
		esd.dwSize = sizeof(SPDATA_ENUMSESSIONS);
		esd.lpISP = PRV_GetDPLobbySPInterface(this);
		esd.lpsd = lpsd;
		esd.dwTimeout = dwTimeout;
		esd.dwFlags = dwFlags;

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, EnumSessions, &esd);
		ENTER_DPLOBBY();
	}
	else 
	{
		// EnumSessions is required
		// REVIEW!!!! -- What error should we return here????
		DPF_ERR("The Lobby Provider callback for EnumSessions doesn't exist -- it's required");
		ASSERT(FALSE);
		hr = DPERR_UNAVAILABLE;
	}

	if(FAILED(hr)) 
	{
		DPF_ERR("Could not invoke EnumSessions in the Service Provider");
	}

	LEAVE_DPLOBBY();
	return hr;

} // PRV_EnumSessions



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_EnumSessionsResponse"
HRESULT DPLAPI DPLP_EnumSessionsResponse(LPDPLOBBYSP lpDPLSP,
						LPSPDATA_ENUMSESSIONSRESPONSE lpr)
{
	LPDPLOBBYI_DPLOBJECT	this;
	LPMSG_ENUMSESSIONSREPLY	lpBuffer = NULL;
	LPBYTE					lpIndex = NULL;
	DWORD					dwNameLength, dwMessageSize;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering DPLP_EnumSessionsResponse");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpDPLSP, lpr);

	//	Make sure the SP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpDPLSP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			DPF_ERR("SP passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

		// Validate the struct pointer
		if(!lpr)
		{
			DPF_ERR("SPDATA_ENUMSESSIONSRESPONSE structure pointer cannot be NULL");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	// REVIEW!!!! -- Can we put this packing code that's duplicated
	// from dplay into a single function???
	dwNameLength =  WSTRLEN_BYTES(lpr->lpsd->lpszSessionName);

	// Calculate the size of the message to send back to dplay
	dwMessageSize = sizeof(MSG_ENUMSESSIONSREPLY);
	dwMessageSize +=  dwNameLength;

	lpBuffer = DPMEM_ALLOC(dwMessageSize);
	if (!lpBuffer) 
	{
		DPF(2, "Unable to allocate memory for EnumSessions request");
		return DPERR_OUTOFMEMORY;
	}

	// Set up the message
	SET_MESSAGE_HDR(lpBuffer);
    SET_MESSAGE_COMMAND(lpBuffer, DPSP_MSG_ENUMSESSIONSREPLY);
    lpBuffer->dpDesc =  *(lpr->lpsd);

	// Pack strings on end
	lpIndex = (LPBYTE)lpBuffer+sizeof(MSG_ENUMSESSIONSREPLY);
	if(dwNameLength) 
	{
		memcpy(lpIndex, lpr->lpsd->lpszSessionName, dwNameLength);
		lpBuffer->dwNameOffset = sizeof(MSG_ENUMSESSIONSREPLY);
	}

	// set string pointers to NULL - they must be set at client
	lpBuffer->dpDesc.lpszPassword = NULL;
	lpBuffer->dpDesc.lpszSessionName = NULL;

	// Now send it to dplay
	ENTER_DPLAY();
	hr = HandleEnumSessionsReply(this->lpDPlayObject, (LPBYTE)lpBuffer, dwMessageSize, NULL);
	LEAVE_DPLAY();

	// Free our buffer
	DPMEM_FREE(lpBuffer);

	return hr;

} // DPLP_EnumSessionsResponse



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_Open"
HRESULT DPLAPI PRV_Open(LPDPLOBBYI_DPLOBJECT this, LPDPSESSIONDESC2 lpsd,
				DWORD dwFlags, LPCDPCREDENTIALS lpCredentials)
{
	SPDATA_OPEN		od;
	HRESULT			hr = DP_OK;


	DPF(7, "Entering PRV_Open");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			this, lpsd, dwFlags, lpCredentials);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }

		// We cannot host a lobby session
		if(dwFlags & DPOPEN_CREATE)
		{
			DPF_ERR("Cannot host a lobby session");
			LEAVE_DPLOBBY();
			return DPERR_INVALIDFLAGS;
		}
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// Setup our SPDATA structure
	memset(&od, 0, sizeof(SPDATA_OPEN));
	od.dwSize = sizeof(SPDATA_OPEN);
	od.lpsd = lpsd;
	od.dwFlags = dwFlags;
	od.lpCredentials = lpCredentials;

	// Call the ConnectServer method in the SP
	if(CALLBACK_EXISTS(Open))
	{
		od.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, Open, &od);
		ENTER_DPLOBBY();
	}
	else 
	{
		// Open is required
		DPF_ERR("The Lobby Provider callback for Open doesn't exist -- it's required");
		ASSERT(FALSE);
		LEAVE_DPLOBBY();
		return DPERR_UNAVAILABLE;
	}

	LEAVE_DPLOBBY();
	return hr;

} // PRV_Open
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplog\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__2AC80E07_F918_11D2_872F_00C04F6BC8E3__INCLUDED_)
#define AFX_STDAFX_H__2AC80E07_F918_11D2_872F_00C04F6BC8E3__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <stdio.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__2AC80E07_F918_11D2_872F_00C04F6BC8E3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplobby\tlhelp32.h ===
/*****************************************************************************\
*                                                                             *
* tlhelp32.h -	WIN32 tool help functions, types, and definitions	      *
*                                                                             *
* Version 1.0								      *
*                                                                             *
* NOTE: windows.h/winbase.h must be #included first			      *
*                                                                             *
* Copyright (c) 1994-1995, Microsoft Corp.   All rights reserved. 	      *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_TOOLHELP32
#define _INC_TOOLHELP32


#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#define MAX_MODULE_NAME32 255

/****** Shapshot function **********************************************/

HANDLE WINAPI CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID);
//
// The th32ProcessID argument is only used if TH32CS_SNAPHEAPLIST or
// TH32CS_SNAPMODULE is specified. th32ProcessID == 0 means the current
// process.
//
// NOTE that all of the snapshots are global except for the heap and module
//	lists which are process specific. To enumerate the heap or module
//	state for all WIN32 processes call with TH32CS_SNAPALL and the
//	current process. Then for each process in the TH32CS_SNAPPROCESS
//	list that isn't the current process, do a call with just
//	TH32CS_SNAPHEAPLIST and/or TH32CS_SNAPMODULE.
//
// dwFlags
//
#define TH32CS_SNAPHEAPLIST 0x00000001
#define TH32CS_SNAPPROCESS  0x00000002
#define TH32CS_SNAPTHREAD   0x00000004
#define TH32CS_SNAPMODULE   0x00000008
#define TH32CS_SNAPALL	    (TH32CS_SNAPHEAPLIST | TH32CS_SNAPPROCESS | TH32CS_SNAPTHREAD | TH32CS_SNAPMODULE)
#define TH32CS_INHERIT	    0x80000000
//
// Use CloseHandle to destroy the snapshot
//

/****** heap walking ***************************************************/

typedef struct tagHEAPLIST32
{
    DWORD  dwSize;
    DWORD  th32ProcessID;   // owning process
    DWORD  th32HeapID;	    // heap (in owning process's context!)
    DWORD  dwFlags;
} HEAPLIST32;
typedef HEAPLIST32 *  PHEAPLIST32;
typedef HEAPLIST32 *  LPHEAPLIST32;
//
// dwFlags
//
#define HF32_DEFAULT	  1  // process's default heap
#define HF32_SHARED	  2  // is shared heap

BOOL WINAPI Heap32ListFirst(HANDLE hSnapshot, LPHEAPLIST32 lphl);
BOOL WINAPI Heap32ListNext(HANDLE hSnapshot, LPHEAPLIST32 lphl);

typedef struct tagHEAPENTRY32
{
    DWORD  dwSize;
    HANDLE hHandle;	// Handle of this heap block
    DWORD  dwAddress;	// Linear address of start of block
    DWORD  dwBlockSize; // Size of block in bytes
    DWORD  dwFlags;
    DWORD  dwLockCount;
    DWORD  dwResvd;
    DWORD  th32ProcessID;   // owning process
    DWORD  th32HeapID;	    // heap block is in
} HEAPENTRY32;
typedef HEAPENTRY32 *  PHEAPENTRY32;
typedef HEAPENTRY32 *  LPHEAPENTRY32;
//
// dwFlags
//
#define LF32_FIXED    0x00000001
#define LF32_FREE     0x00000002
#define LF32_MOVEABLE 0x00000004

BOOL WINAPI Heap32First(LPHEAPENTRY32 lphe, DWORD th32ProcessID,
			DWORD th32HeapID);
BOOL WINAPI Heap32Next(LPHEAPENTRY32 lphe);
BOOL WINAPI Toolhelp32ReadProcessMemory(DWORD	th32ProcessID,
					LPCVOID lpBaseAddress,
					LPVOID	lpBuffer,
					DWORD	cbRead,
					LPDWORD lpNumberOfBytesRead);

/***** Process walking *************************************************/

typedef struct tagPROCESSENTRY32
{
    DWORD   dwSize;
    DWORD   cntUsage;
    DWORD   th32ProcessID;	    // this process
    DWORD   th32DefaultHeapID;
    DWORD   th32ModuleID;	    // associated exe
    DWORD   cntThreads;
    DWORD   th32ParentProcessID;    // this process's parent process
    LONG    pcPriClassBase;	    // Base priority of process's threads
    DWORD   dwFlags;
    char    szExeFile[MAX_PATH];    // Path
} PROCESSENTRY32;
typedef PROCESSENTRY32 *  PPROCESSENTRY32;
typedef PROCESSENTRY32 *  LPPROCESSENTRY32;

BOOL WINAPI Process32First(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
BOOL WINAPI Process32Next(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);

/***** Thread walking **************************************************/

typedef struct tagTHREADENTRY32
{
    DWORD   dwSize;
    DWORD   cntUsage;
    DWORD   th32ThreadID;	// this thread
    DWORD   th32OwnerProcessID; // Process this thread is associated with
    LONG    tpBasePri;
    LONG    tpDeltaPri;
    DWORD   dwFlags;
} THREADENTRY32;
typedef THREADENTRY32 *  PTHREADENTRY32;
typedef THREADENTRY32 *  LPTHREADENTRY32;

BOOL WINAPI Thread32First(HANDLE hSnapshot, LPTHREADENTRY32 lpte);
BOOL WINAPI Thread32Next(HANDLE hSnapshot, LPTHREADENTRY32 lpte);

/***** Module walking *************************************************/

typedef struct tagMODULEENTRY32
{
    DWORD   dwSize;
    DWORD   th32ModuleID;	// This module
    DWORD   th32ProcessID;	// owning process
    DWORD   GlblcntUsage;	// Global usage count on the module
    DWORD   ProccntUsage;	// Module usage count in th32ProcessID's context
    BYTE  * modBaseAddr;	// Base address of module in th32ProcessID's context
    DWORD   modBaseSize;	// Size in bytes of module starting at modBaseAddr
    HMODULE hModule;		// The hModule of this module in th32ProcessID's context
    char    szModule[MAX_MODULE_NAME32 + 1];
    char    szExePath[MAX_PATH];
} MODULEENTRY32;
typedef MODULEENTRY32 *  PMODULEENTRY32;
typedef MODULEENTRY32 *  LPMODULEENTRY32;

//
// NOTE CAREFULLY that the modBaseAddr and hModule fields are valid ONLY
// in th32ProcessID's process context.
//

BOOL WINAPI Module32First(HANDLE hSnapshot, LPMODULEENTRY32 lpme);
BOOL WINAPI Module32Next(HANDLE hSnapshot, LPMODULEENTRY32 lpme);

#ifdef __cplusplus
}
#endif

#endif // _INC_TOOLHELP32
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\misc\memalloc.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       memalloc.h
 *  Content:	header file for memory allocation
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   06-apr-95	craige	initial implementation
 *   22-may-95	craige	added MemAlloc16
 *   12-jun-95	craige	added MemReAlloc
 *   26-jun-95  craige  added GetPtr16
 *   26-jul-95  toddla  added MemSize and fixed MemReAlloc
 *
 ***************************************************************************/
#ifndef __MEMALLOC_INCLUDED__
#define __MEMALLOC_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif
extern void MemFini( void );
extern void MemState( void );
extern BOOL MemInit( void );
extern void MemFree( LPVOID lptr );
extern UINT_PTR __cdecl MemSize( LPVOID lptr );
extern LPVOID __cdecl MemAlloc( UINT size );
extern LPVOID __cdecl MemReAlloc( LPVOID ptr, UINT size );
extern LPVOID __cdecl MemAlloc16( UINT size, DWORD FAR *p16 );
extern LPVOID GetPtr16( LPVOID ptr );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\misc\dpf.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpf.c
 *  Content:	debugging printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   06-jan-95	craige	initial implementation
 *   03-mar-95	craige	added dprintf2
 *   31-mar-95	craige	add DPFInit to read WIN.INI for [DirectDraw] section;
 *			added dprintf3
 *   01-apr-95	craige	happy fun joy updated header file
 *   06-apr-95	craige	made stand-alone
 *   18-jun-95	craige	use negative dpf level to display ONLY that level
 *   06-dec-95  jeffno  Changed dprintf to use c-standard variable argument
 *                      list techniques. Also added abs for NT
 *   06-feb-96  colinmc added simple assertion mechanism for DirectDraw
 *   15-apr-96	kipo	added msinternal
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#ifdef NEW_DPF
    #include "newdpf.c"
#else   //use old debug:

    #undef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN
    #include <windows.h>
    #include "dpf.h"
    #include <stdarg.h>

    //#ifdef WINNT
    //int abs(int x)
    //{
    //    return x>=0?x:-x;
    //}
    //#endif

    #ifdef DEBUG

    #define USE_DDASSERT

    #ifndef START_STR
        #define START_STR	"DDRAW: "
    #endif
    #ifndef PROF_SECT
        #define PROF_SECT	"DirectDraw"
    #endif

    #define END_STR		"\r\n"

    HWND		hWndListBox;
    LONG		lDebugLevel = 0;

    /*
     * dumpStr
     */
    static void dumpStr( LPSTR str )
    {
        OutputDebugString( str );

        #ifdef DPF_HWND
	    if( hWndListBox != NULL )
	    {
	        if( !IsWindow( hWndListBox ) )
	        {
		    hWndListBox = NULL;
	        }
	    }
	    if( hWndListBox != NULL )
	    {
	        UINT	sel;
	        int	len;
	        len = strlen( str );
	        if( len > 0 )
	        {
		    if( str[len-1] == '\r' || str[len-1] == '\n' )
		    {
		        str[len-1] = 0;
		    }
		    if( len > 1 )
		    {
		        if( str[len-2] == '\r' || str[len-2] == '\n' )
		        {
			    str[len-2] = 0;
		        }
		    }
	        }
	        SendMessage( hWndListBox, LB_ADDSTRING, 0, (LONG) (LPSTR) str );
	        sel = (UINT) SendMessage( hWndListBox, LB_GETCOUNT, 0, 0L );
	        if( sel != LB_ERR )
	        {
		    SendMessage( hWndListBox, LB_SETCURSEL, sel-1, 0L );
	        }
	    }
        #endif

    } /* dumpStr */

    /*
     * dprintf
     */
    void cdecl dprintf( UINT lvl, LPSTR szFormat, ...)
    {
        char 	str[256];
        //char 	str2[256];

        BOOL	allow = FALSE;
        va_list ap;
        va_start(ap,szFormat);


        if( lDebugLevel < 0 )
        {
	    if(  (UINT) -lDebugLevel == lvl )
	    {
	        allow = TRUE;
	    }
        }
        else if( (UINT) lDebugLevel >= lvl )
        {
	    allow = TRUE;
        }

        if( allow )
        {
	    wsprintf( (LPSTR) str, START_STR );
            //GetModuleFileName(NULL,str2,256);
            //if (strrchr(str2,'\\'))
            //    wsprintf(str+strlen(str),"%12s",strrchr(str2,'\\')+1);
            //strcat(str,":");
	    wvsprintf( str+lstrlen( str ), szFormat, ap);   //(LPVOID)(&szFormat+1) );

	    lstrcat( (LPSTR) str, END_STR );
	    dumpStr( str );
        }

        va_end(ap);
    } /* dprintf */

    /*
     * DPFInit
     */
    void DPFInit( void )
    {
        lDebugLevel = GetProfileInt( PROF_SECT, "debug", 0 );

    } /* DPFInit */

    #ifdef USE_DDASSERT

    /*
     * NOTE: I don't want to get into error checking for buffer overflows when
     * trying to issue an assertion failure message. So instead I just allocate
     * a buffer that is "bug enough" (I know, I know...)
     */
    #define ASSERT_BUFFER_SIZE   512
    #define ASSERT_BANNER_STRING "************************************************************"
    #define ASSERT_BREAK_SECTION "BreakOnAssert"
    #define ASSERT_BREAK_DEFAULT FALSE
    #define ASSERT_MESSAGE_LEVEL 0

    void _DDAssert( LPCSTR szFile, int nLine, LPCSTR szCondition )
    {
        char buffer[ASSERT_BUFFER_SIZE];

        /*
         * Build the debug stream message.
         */
        wsprintf( buffer, "ASSERTION FAILED! File %s Line %d: %s", szFile, nLine, szCondition );

        /*
         * Actually issue the message. These messages are considered error level
         * so they all go out at error level priority.
         */
        dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );
        dprintf( ASSERT_MESSAGE_LEVEL, buffer );
        dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );

        /*
         * Should we drop into the debugger?
         */
        if( GetProfileInt( PROF_SECT, ASSERT_BREAK_SECTION, ASSERT_BREAK_DEFAULT ) )
        {
	    /*
	     * Into the debugger we go...
	     */
	    DEBUG_BREAK();
        }
    }

    #endif /* USE_DDASSERT */

    #endif
#endif //use new dpf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\misc\dxvalid.h ===
//--------------------------------------------------------------------------;
//
//  File: dxvalid.h
//
//  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
//
//  Abstract:
//      This header contains common parameter validate macros for DirectX.
//
//  History:
//      02/14/96    angusm    Initial version
//      03/05/96    angusm    added VALIDEX_GUID_PTR
//
//--------------------------------------------------------------------------;


// _________________________________________________________________________
// VALIDEX_xxx 
//     macros are the same for debug and retail


#define VALIDEX_PTR( ptr, size ) \
	(!IsBadReadPtr( ptr, size) )

#define VALIDEX_GUID_PTR( ptr ) \
	(!IsBadReadPtr( ptr, sizeof( GUID ) ) )

#define VALIDEX_IID_PTR( ptr ) \
	(!IsBadReadPtr( ptr, sizeof( IID )) )

#define VALIDEX_PTR_PTR( ptr ) \
	(!IsBadWritePtr( ptr, sizeof( LPVOID )) )

#define VALIDEX_CODE_PTR( ptr ) \
	(!IsBadCodePtr( (LPVOID) ptr ) )


// _________________________________________________________________________
// VALID_xxx 
//     macros that check memory allocated and sent as API parameters


#ifndef DEBUG
#define FAST_CHECKING
#endif

#ifndef FAST_CHECKING

#define VALID_BOOL_PTR( ptr ) \
	(!IsBadWritePtr( ptr, sizeof( BOOL ) ))
#define VALID_DDCOLORKEY_PTR( ptr ) \
	(!IsBadWritePtr( ptr, sizeof( DDCOLORKEY ) ) )
#define VALID_RGNDATA_PTR( ptr ) \
	(!IsBadWritePtr( ptr, sizeof( RGNDATA ) ) )
#define VALID_RECT_PTR( ptr ) \
	(!IsBadWritePtr( ptr, sizeof( RECT ) ) )
#define VALID_PTR_PTR( ptr ) \
	(!IsBadWritePtr( ptr, sizeof( LPVOID )) )
#define VALID_IID_PTR( ptr ) \
	(!IsBadReadPtr( ptr, sizeof( IID )) )
#define VALID_HWND_PTR( ptr ) \
	(!IsBadWritePtr( (LPVOID) ptr, sizeof( HWND )) )
#define VALID_VMEM_PTR( ptr ) \
	(!IsBadWritePtr( (LPVOID) ptr, sizeof( VMEM )) )
#define VALID_POINTER_ARRAY( ptr, cnt ) \
	(!IsBadWritePtr( ptr, sizeof( LPVOID ) * cnt ) )
#define VALID_HANDLE_PTR( ptr ) \
	(!IsBadWritePtr( ptr, sizeof( HANDLE )) )
#define VALID_DWORD_ARRAY( ptr, cnt ) \
	(!IsBadWritePtr( ptr, sizeof( DWORD ) * cnt ) )
#define VALID_GUID_PTR( ptr ) \
	(!IsBadReadPtr( ptr, sizeof( GUID ) ) )
#define VALID_BYTE_ARRAY( ptr, cnt ) \
        (!IsBadWritePtr( ptr, sizeof( BYTE ) * cnt ) )
#define VALID_PTR( ptr, size ) \
	(!IsBadReadPtr( ptr, size) )

#else
#define VALID_PTR( ptr, size ) 		1
#define VALID_DIRECTDRAW_PTR( ptr )	1
#define VALID_DIRECTDRAWSURFACE_PTR( ptr )	1
#define VALID_DIRECTDRAWPALETTE_PTR( ptr )	1
#define VALID_DIRECTDRAWCLIPPER_PTR( ptr )	1
#define VALID_DDSURFACEDESC_PTR( ptr ) (ptr->dwSize == sizeof( DDSURFACEDESC ))
#define VALID_BOOL_PTR( ptr )	1
#define VALID_HDC_PTR( ptr )	1
#define VALID_DDPIXELFORMAT_PTR( ptr ) (ptr->dwSize == sizeof( DDPIXELFORMAT ))
#define VALID_DDCOLORKEY_PTR( ptr )	1
#define VALID_RGNDATA_PTR( ptr )	1
#define VALID_RECT_PTR( ptr )	1
#define VALID_DDOVERLAYFX_PTR( ptr ) (ptr->dwSize == sizeof( DDOVERLAYFX ))
#define VALID_DDBLTFX_PTR( ptr ) (ptr->dwSize == sizeof( DDBLTFX ))
#define VALID_DDBLTBATCH_PTR( ptr )	1
#define VALID_DDMASK_PTR( ptr )	1
#define VALID_DDSCAPS_PTR( ptr )	1
#define VALID_PTR_PTR( ptr )	1
#define VALID_IID_PTR( ptr )	1
#define VALID_HWND_PTR( ptr )	1
#define VALID_VMEM_PTR( ptr )	1
#define VALID_POINTER_ARRAY( ptr, cnt ) 1
#define VALID_PALETTEENTRY_ARRAY( ptr, cnt )	1
#define VALID_HANDLE_PTR( ptr )	1
#define VALID_DDCAPS_PTR( ptr ) (ptr->dwSize == sizeof( DDCAPS ))
#define VALID_READ_DDSURFACEDESC_ARRAY( ptr, cnt )	1
#define VALID_DWORD_ARRAY( ptr, cnt )	1
#define VALID_GUID_PTR( ptr )	1
#define VALID_BYTE_ARRAY( ptr, cnt ) 1

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\misc\lists.h ===
/* Copyright (c) 1997  Microsoft Corporation */
/* See the .C test code at the end of this file for examples of how to use
   this stuff.
*/
#ifndef	_LISTS_H
#define	_LISTS_H

#if __cplusplus
extern "C" {
#endif

#define LIST_ROOT(name, type) struct name {struct type *Root;}

#define LIST_MEMBER(type) struct { struct type **Prev; struct type *Next;}
/* Note!  Prev is the ADDRESS of the previous next element ptr */

#define LIST_INSERT_ROOT(root,element,field)\
{   if(((element)->field.Next = (root)->Root) != 0)\
	(root)->Root->field.Prev = &(element)->field.Next;\
    (root)->Root = (element);\
    (element)->field.Prev = &(root)->Root;\
}

#define LIST_DELETE(element,field)\
{\
    if((element)->field.Next)\
	(element)->field.Next->field.Prev = (element)->field.Prev;\
    *(element)->field.Prev = (element)->field.Next;\
    (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define	LIST_INITIALIZE(root)\
{\
    (root)->Root = 0;\
}

#define LIST_INITIALIZE_MEMBER(element,field)\
{   (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define LIST_ORPHAN_MEMBER(element,field) (!((element)->field.Prev))

#define LIST_FIRST(root) (root)->Root
#define LIST_NEXT(element,field) (element)->field.Next



#define	TAIL_QUEUE_INITIALIZE(root)\
{\
    (root)->First = NULL;\
    (root)->Last = &(root)->First;\
}

#define TAIL_QUEUE_ROOT(name,type)\
struct name\
{   struct type *First;\
    struct type **Last;\
}/* NOTE!  This is the address of the last Next pointer. */


#define TAIL_QUEUE_MEMBER(type)\
struct\
{   struct type *Next;\
    struct type **Prev;	/* NOTE!  Address of previous Next element ptr */\
}

#define TAIL_QUEUE_INSERT_END(root,element,field)\
{   (element)->field.Prev = (root)->Last;\
    (element)->field.Next = 0;\
    *(root)->Last = (element);\
    (root)->Last = &(element)->field.Next;\
}

#define TAIL_QUEUE_DELETE(root,element,field)\
{\
    if (((element)->field.Next) != NULL)\
	(element)->field.Next->field.Prev = (element)->field.Prev;\
    else\
	(root)->Last = (element)->field.Prev;\
    *(element)->field.Prev = (element)->field.Next;\
    (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define TAIL_QUEUE_FIRST(root) (root)->First
#define TAIL_QUEUE_NEXT(element,field) (element)->field.Next



#define CIRCLE_QUEUE_ROOT(name,type)\
struct name\
{   struct type *Last;\
    struct type *First;\
}

#define CIRCLE_QUEUE_MEMBER(type)\
struct\
{   struct type *Prev;\
    struct type *Next;\
}

#define	CIRCLE_QUEUE_INITIALIZE(root,type)\
{   (root)->Last = (type *)(root);\
    (root)->First = (type *)(root);\
}

#define CIRCLE_QUEUE_INITIALIZE_MEMBER(element,field)\
{ (element)->field.Next = (element)->field.Prev = 0;\
}

#define CIRCLE_QUEUE_INSERT_END(root,type,element,field)\
{   (element)->field.Prev = (root)->Last;\
    (element)->field.Next = (type *)(root);\
    if((root)->First != (type *)(root))\
	(root)->Last->field.Next = (element);\
    else\
	(root)->First = (element);\
    (root)->Last = (element);\
}

#define CIRCLE_QUEUE_INSERT_ROOT(root,type,element,field)\
{   (element)->field.Prev = (type *)(root);\
    (element)->field.Next = (root)->First;\
    if ((root)->Last != (void *)(root))\
	(root)->First->field.Prev = (element);\
    else\
	(root)->Last = (element);\
    (root)->First = (element);\
}

#define CIRCLE_QUEUE_INSERT_PREVIOUS(root,current_element,element,field)\
{   (element)->field.Prev = (current_element)->field.Prev;\
    (element)->field.Next = (current_element);\
    if ((current_element)->field.Prev != (void *)(root))\
	(current_element)->field.Prev->field.Next = (element);\
    else\
	(root)->First = (element);\
    (current_element)->field.Prev = (element);\
}

#define	CIRCLE_QUEUE_DELETE(root,element,field)\
{   if((element)->field.Next != (void *)(root))\
	(element)->field.Next->field.Prev = (element)->field.Prev;\
    else\
	(root)->Last = (element)->field.Prev;\
    if((element)->field.Prev != (void *)(root))\
	(element)->field.Prev->field.Next = (element)->field.Next;\
    else\
	(root)->First = (element)->field.Next;\
    (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define CIRCLE_QUEUE_FIRST(root)\
((root)->First == (void *) (root)? 0: (root)->First)

#define CIRCLE_QUEUE_LAST(root)\
((root)->Last == (void *) (root)? 0: (root)->Last)

#define CIRCLE_QUEUE_NEXT(root,element,field)\
((void *) (element)->field.Next == (void *) (root)? 0: (element)->field.Next)

#define CIRCLE_QUEUE_PREVIOUS(root,element,field)\
((element)->field.Prev == (void *) (root)? 0: (element)->field.Prev)

#if 0
/*
Test code.  Strip it out, put it in a .C (or .CPP) file and compile it as a
console app to test this stuff. It should run without any assertion failures.

Also, use this as example code.
*/

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#include "lists.h"

void TestList(void)
{
    struct Foo
    {
	int a;
	LIST_MEMBER(Foo) ListStuff;
	int b;
    };
    struct Foo MyFoo1, MyFoo2, MyFoo3, *pFoo = 0;
    LIST_ROOT(sRoot, Foo) MyListRoot;

    fputs("Testing LIST.\n",stdout);

    LIST_INITIALIZE(&MyListRoot);

    LIST_INITIALIZE_MEMBER(&MyFoo1,ListStuff);
    MyFoo1.a = 0x1A; MyFoo1.b = 0x1B;

    LIST_INITIALIZE_MEMBER(&MyFoo2,ListStuff);
    MyFoo2.a = 0x2A; MyFoo2.b = 0x2B;

    LIST_INITIALIZE_MEMBER(&MyFoo3,ListStuff);
    MyFoo3.a = 0x3A; MyFoo3.b = 0x3B;
    assert(LIST_ORPHAN_MEMBER(&MyFoo3,ListStuff));

    LIST_INSERT_ROOT(&MyListRoot,&MyFoo3,ListStuff);
    assert(!LIST_ORPHAN_MEMBER(&MyFoo3,ListStuff));
    LIST_INSERT_ROOT(&MyListRoot,&MyFoo2,ListStuff);
    LIST_INSERT_ROOT(&MyListRoot,&MyFoo1,ListStuff);

    assert(!LIST_ORPHAN_MEMBER(&MyFoo1,ListStuff));
    assert(!LIST_ORPHAN_MEMBER(&MyFoo2,ListStuff));
    assert(!LIST_ORPHAN_MEMBER(&MyFoo3,ListStuff));

    pFoo = LIST_FIRST(&MyListRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);

    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo);
    assert(pFoo->a == 0x2A);
    assert(pFoo->b == 0x2B);

    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);

    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo == 0);

    /* Delete member 2. */
    pFoo = LIST_FIRST(&MyListRoot);
    pFoo = LIST_NEXT(pFoo,ListStuff);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x2A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x2B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);

    /* Make sure that there are only members 1 and 3 in the list now. */
    pFoo = LIST_FIRST(&MyListRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);
    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);
    assert(LIST_NEXT(pFoo,ListStuff) == 0);

    /* Delete member 3. */
    pFoo = LIST_FIRST(&MyListRoot);
    pFoo = LIST_NEXT(pFoo,ListStuff);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x3A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x3B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);

    /* Delete member 1. */
    pFoo = LIST_FIRST(&MyListRoot);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);
    assert(LIST_FIRST(&MyListRoot) == 0);

    LIST_INSERT_ROOT(&MyListRoot,&MyFoo2,ListStuff);
    LIST_INSERT_ROOT(&MyListRoot,&MyFoo1,ListStuff);
    
    /* Delete member 1 while there are other members in the list. */
    pFoo = LIST_FIRST(&MyListRoot);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);
    assert(LIST_FIRST(&MyListRoot) == &MyFoo2);

    assert(MyFoo1.a == 0x1A); assert(MyFoo1.b == 0x1B);
    assert(MyFoo2.a == 0x2A); assert(MyFoo2.b == 0x2B);
    assert(MyFoo3.a == 0x3A); assert(MyFoo3.b == 0x3B);

    fputs("List passed.\n", stdout);
}

void TestTailQueue(void)
{
    struct Foo
    {
	int a;
	TAIL_QUEUE_MEMBER(Foo) TQStuff;
	int b;
    };
    struct Foo MyFoo1, MyFoo2, MyFoo3, *pFoo = 0;
    TAIL_QUEUE_ROOT(sRoot, Foo) MyTQRoot;

    fputs("Testing TAIL_QUEUE.\n",stdout);

    TAIL_QUEUE_INITIALIZE(&MyTQRoot);
    MyFoo1.a = 0x1A; MyFoo1.b = 0x1B;
    MyFoo2.a = 0x2A; MyFoo2.b = 0x2B;
    MyFoo3.a = 0x3A; MyFoo3.b = 0x3B;

    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo1,TQStuff);
    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo2,TQStuff);
    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo3,TQStuff);

    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);

    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo);
    assert(pFoo->a == 0x2A);
    assert(pFoo->b == 0x2B);

    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);

    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo == 0);

    /* Delete member 2. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x2A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x2B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);

    /* Make sure that there are only members 1 and 3 in the list now. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);
    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);

    /* Delete member 3. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x3A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x3B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);

    /* Delete member 1. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);
    assert(TAIL_QUEUE_FIRST(&MyTQRoot) == 0);

    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo1,TQStuff);
    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo2,TQStuff);
    
    /* Delete member 1 while there are other members in the list. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);
    assert(TAIL_QUEUE_FIRST(&MyTQRoot) == &MyFoo2);

    assert(MyFoo1.a == 0x1A); assert(MyFoo1.b == 0x1B);
    assert(MyFoo2.a == 0x2A); assert(MyFoo2.b == 0x2B);
    assert(MyFoo3.a == 0x3A); assert(MyFoo3.b == 0x3B);

    fputs("Tail Queue passed.\n", stdout);
}
void TestCircleQueue(void)
{
    enum {END,ROOT,PREVIOUS,DONE} WhichInsert = END;
    int i;
    struct Foo
    {
	int a;
	CIRCLE_QUEUE_MEMBER(Foo) CQStuff;
	int b;
    };
    struct Foo MyFoo1, MyFoo2, MyFoo3, *pFoo = 0;
    CIRCLE_QUEUE_ROOT(sRoot, Foo) MyCQRoot;

    fputs("Testing CIRCLE_QUEUE.\n",stdout);

    while(WhichInsert != DONE)
    {
	CIRCLE_QUEUE_INITIALIZE(&MyCQRoot,Foo);
	MyFoo1.a = 0x1A; MyFoo1.b = 0x1B;
	MyFoo2.a = 0x2A; MyFoo2.b = 0x2B;
	MyFoo3.a = 0x3A; MyFoo3.b = 0x3B;
    
	switch(WhichInsert)
	{
	case END:
	    CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo1,CQStuff);
	    CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo2,CQStuff);
	    CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo3,CQStuff);
	    WhichInsert = ROOT;
	    break;
	case ROOT:
	    CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo3,CQStuff);
	    CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo2,CQStuff);
	    CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo1,CQStuff);
	    WhichInsert = PREVIOUS;
	    break;
	case PREVIOUS:
	    CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo3,CQStuff);
	    CIRCLE_QUEUE_INSERT_PREVIOUS(&MyCQRoot,&MyFoo3,&MyFoo2,CQStuff);
	    CIRCLE_QUEUE_INSERT_PREVIOUS(&MyCQRoot,&MyFoo2,&MyFoo1,CQStuff);
	    WhichInsert = DONE;
	    break;
	default:
	    assert(0);
	}

        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        assert(pFoo);
        assert(pFoo->a == 0x1A);
        assert(pFoo->b == 0x1B);
    
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo);
        assert(pFoo->a == 0x2A);
        assert(pFoo->b == 0x2B);
    
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo);
        assert(pFoo->a == 0x3A);
        assert(pFoo->b == 0x3B);
    
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo == 0);

	pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
	assert(CIRCLE_QUEUE_PREVIOUS(&MyCQRoot,pFoo,CQStuff) == 0);
	pFoo = CIRCLE_QUEUE_LAST(&MyCQRoot);
	assert(pFoo == &MyFoo3);
	assert(CIRCLE_QUEUE_PREVIOUS(&MyCQRoot,pFoo,CQStuff) == &MyFoo2);
	assert(CIRCLE_QUEUE_PREVIOUS(&MyCQRoot,&MyFoo2,CQStuff) == &MyFoo1);
    
        /* Delete member 2. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x2A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x2B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
    
        /* Make sure that there are only members 1 and 3 in the list now. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        assert(pFoo);
        assert(pFoo->a == 0x1A);
        assert(pFoo->b == 0x1B);
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo);
        assert(pFoo->a == 0x3A);
        assert(pFoo->b == 0x3B);
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
    
        /* Delete member 3. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x3A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x3B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
    
        /* Delete member 1. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x1B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
        assert(CIRCLE_QUEUE_FIRST(&MyCQRoot) == 0);
    
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo1,CQStuff);
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo2,CQStuff);
        
        /* Delete member 1 while there are other members in the list. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x1B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
        assert(CIRCLE_QUEUE_FIRST(&MyCQRoot) == &MyFoo2);
    
        assert(MyFoo1.a == 0x1A); assert(MyFoo1.b == 0x1B);
        assert(MyFoo2.a == 0x2A); assert(MyFoo2.b == 0x2B);
        assert(MyFoo3.a == 0x3A); assert(MyFoo3.b == 0x3B);
    }

    fputs("Circle Queue passed.\n", stdout);
}

int main()
{
    TestList();
    TestTailQueue();
    TestCircleQueue();
    fputs("All tests passed.", stdout);
    return EXIT_SUCCESS;
}
#endif /* End of test code. */

#if __cplusplus
}
#endif

#endif // !_LISTS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\misc\logger.h ===
/*
	logger.h

	Use to write log info to a file.

	Multiple-instance aware. If one instance already owns the output
        file, another will sleep (up to 20s) until the first is done.
	Nicely outputs a header containing user, computer, and driver names,
	date/time and starting display resolution.


        You use it like this:

                CLogfile Log("test.log","your comment here");

                // or CLogfile Log("test.log");
                // for no comment, and overwriting the file.

                // or CLogfile Log("test.log","your comment here",TRUE);
                // to make it append to the file. Default is overwrite.
                
                Log << "\n\n42 decimal is " << 42ul <<" in hex\n";
                Log << "Hi"<<'!'<<'\n' ;
                Log << "The value of 0x2a is " << 0x2al << " in decimal\n";

				CLogfile Faults("faults.log","my test's faults",TRUE);	//append new faults
				Faults << "Encountered a booboo, here's what i did:\n";
				Faults << Log;		//copies contents of test.log to Fault
				Faults << "so now you can diagnose\n";

        The class will then write stuff like this to test.log:


                ----------------------------------------------------------
                EnumSurface test
                Beginning test at 10:38 on 1995/8/14
                User Name:jeffno
                Computer Name:JEFFNO2
                Display driver:S3 Vision864 PCI
                Starting resolution: 640x480x8
                - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
                42 decimal is 0000002a in hex
                Hi!
                The value of 0x2a is 42 in decimal
                ----------- Test ends at 10:38 on 1995/8/14 -------------
                
		And faults.log will get:
				< a header like above>
				Encountered a booboo, here's what i did:
				< a copy of the test.log contents surrounded by
					notes that say this is a snapshot of test.log >
				so now you can diagnose
				< a trailer like above (test ends at etc...)>



        The class can output DWORDS, which it does as an 8-digit hex number,
        LONGs which are output as decimal, chars and strings. As shown
		above you can output one log object to another, which copies 
		everything in the source file from the pos at which the source
		file was opened (if appending to a pre-existing file) up to
		the end.


        But wait! you also get...
                A routine called char * ErrorName(HRESULT) which takes
                a ddraw return value and returns a string describing it.
                Very handy.
                BTW: this header file includes a statically declared array
                full of names, at file level scope. This means you get a 2k
                array in your source wether you want ErrorName or not.
                Go ahead and edit this file if you don't want this array.

        NOTE: this uses WNetGetUser API, so you'll need to add mpr.lib
        to you LIBS line in your makefile.
*/

//#include <stdio.h>
#include <windows.h>
#include <windowsx.h> 


struct {
	char name[100];
	HRESULT errcode;
} ErrorLookup[] = {
				{"DD_OK",DD_OK},
				{"DDERR_ALREADYINITIALIZED",DDERR_ALREADYINITIALIZED},
				{"DDERR_CANNOTATTACHSURFACE",DDERR_CANNOTATTACHSURFACE},
				{"DDERR_CANNOTDETACHSURFACE",DDERR_CANNOTDETACHSURFACE},
				{"DDERR_CURRENTLYNOTAVAIL",DDERR_CURRENTLYNOTAVAIL},
				{"DDERR_EXCEPTION",DDERR_EXCEPTION},
				{"DDERR_GENERIC",DDERR_GENERIC},
				{"DDERR_HEIGHTALIGN",DDERR_HEIGHTALIGN},
				{"DDERR_INCOMPATIBLEPRIMARY",DDERR_INCOMPATIBLEPRIMARY},
				{"DDERR_INVALIDCAPS",DDERR_INVALIDCAPS},
				{"DDERR_INVALIDCLIPLIST",DDERR_INVALIDCLIPLIST},
				{"DDERR_INVALIDMODE",DDERR_INVALIDMODE},
				{"DDERR_INVALIDOBJECT",DDERR_INVALIDOBJECT},
				{"DDERR_INVALIDPARAMS",DDERR_INVALIDPARAMS},
				{"DDERR_INVALIDPIXELFORMAT",DDERR_INVALIDPIXELFORMAT},
				{"DDERR_INVALIDRECT",DDERR_INVALIDRECT},
				{"DDERR_LOCKEDSURFACES",DDERR_LOCKEDSURFACES},
				{"DDERR_NO3D",DDERR_NO3D},
				{"DDERR_NOALPHAHW",DDERR_NOALPHAHW},
				{"DDERR_NOANTITEARHW",DDERR_NOANTITEARHW},
				{"DDERR_NOBLTQUEUEHW",DDERR_NOBLTQUEUEHW},
				{"DDERR_NOCLIPLIST",DDERR_NOCLIPLIST},
				{"DDERR_NOCOLORCONVHW",DDERR_NOCOLORCONVHW},
				{"DDERR_NOCOOPERATIVELEVELSET",DDERR_NOCOOPERATIVELEVELSET},
				{"DDERR_NOCOLORKEY",DDERR_NOCOLORKEY},
				{"DDERR_NOCOLORKEYHW",DDERR_NOCOLORKEYHW},
				{"DDERR_NOEXCLUSIVEMODE",DDERR_NOEXCLUSIVEMODE},
				{"DDERR_NOFLIPHW",DDERR_NOFLIPHW},
				{"DDERR_NOGDI",DDERR_NOGDI},
				{"DDERR_NOMIRRORHW",DDERR_NOMIRRORHW},
				{"DDERR_NOTFOUND",DDERR_NOTFOUND},
				{"DDERR_NOOVERLAYHW",DDERR_NOOVERLAYHW},
				{"DDERR_NORASTEROPHW",DDERR_NORASTEROPHW},
				{"DDERR_NOROTATIONHW",DDERR_NOROTATIONHW},
				{"DDERR_NOSTRETCHHW",DDERR_NOSTRETCHHW},
				{"DDERR_NOT4BITCOLOR",DDERR_NOT4BITCOLOR},
				{"DDERR_NOT4BITCOLORINDEX",DDERR_NOT4BITCOLORINDEX},
				{"DDERR_NOT8BITCOLOR",DDERR_NOT8BITCOLOR},
				{"DDERR_NOTEXTUREHW",DDERR_NOTEXTUREHW},
				{"DDERR_NOVSYNCHW",DDERR_NOVSYNCHW},
				{"DDERR_NOZBUFFERHW",DDERR_NOZBUFFERHW},
				{"DDERR_NOZOVERLAYHW",DDERR_NOZOVERLAYHW},
				{"DDERR_OUTOFCAPS",DDERR_OUTOFCAPS},
				{"DDERR_OUTOFMEMORY",DDERR_OUTOFMEMORY},
				{"DDERR_OUTOFVIDEOMEMORY",DDERR_OUTOFVIDEOMEMORY},
				{"DDERR_OVERLAYCANTCLIP",DDERR_OVERLAYCANTCLIP},
				{"DDERR_OVERLAYCOLORKEYONLYONEACTIVE",DDERR_OVERLAYCOLORKEYONLYONEACTIVE},
				{"DDERR_PALETTEBUSY",DDERR_PALETTEBUSY},
				{"DDERR_COLORKEYNOTSET",DDERR_COLORKEYNOTSET},
				{"DDERR_SURFACEALREADYATTACHED",DDERR_SURFACEALREADYATTACHED},
				{"DDERR_SURFACEALREADYDEPENDENT",DDERR_SURFACEALREADYDEPENDENT},
				{"DDERR_SURFACEBUSY",DDERR_SURFACEBUSY},
				{"DDERR_SURFACEISOBSCURED",DDERR_SURFACEISOBSCURED},
				{"DDERR_SURFACELOST",DDERR_SURFACELOST},
				{"DDERR_SURFACENOTATTACHED",DDERR_SURFACENOTATTACHED},
				{"DDERR_TOOBIGHEIGHT",DDERR_TOOBIGHEIGHT},
				{"DDERR_TOOBIGSIZE",DDERR_TOOBIGSIZE},
				{"DDERR_TOOBIGWIDTH",DDERR_TOOBIGWIDTH},
				{"DDERR_UNSUPPORTED",DDERR_UNSUPPORTED},
				{"DDERR_UNSUPPORTEDFORMAT",DDERR_UNSUPPORTEDFORMAT},
				{"DDERR_UNSUPPORTEDMASK",DDERR_UNSUPPORTEDMASK},
				{"DDERR_VERTICALBLANKINPROGRESS",DDERR_VERTICALBLANKINPROGRESS},
				{"DDERR_WASSTILLDRAWING",DDERR_WASSTILLDRAWING},
				{"DDERR_XALIGN",DDERR_XALIGN},
				{"DDERR_INVALIDDIRECTDRAWGUID",DDERR_INVALIDDIRECTDRAWGUID},
				{"DDERR_DIRECTDRAWALREADYCREATED",DDERR_DIRECTDRAWALREADYCREATED},
				{"DDERR_NODIRECTDRAWHW",DDERR_NODIRECTDRAWHW},
				{"DDERR_PRIMARYSURFACEALREADYEXISTS",DDERR_PRIMARYSURFACEALREADYEXISTS},
				{"DDERR_NOEMULATION",DDERR_NOEMULATION},
				{"DDERR_REGIONTOOSMALL",DDERR_REGIONTOOSMALL},
				{"DDERR_CLIPPERISUSINGHWND",DDERR_CLIPPERISUSINGHWND},
				{"DDERR_NOCLIPPERATTACHED",DDERR_NOCLIPPERATTACHED},
				{"DDERR_NOHWND",DDERR_NOHWND},
				{"DDERR_HWNDSUBCLASSED",DDERR_HWNDSUBCLASSED},
				{"DDERR_HWNDALREADYSET",DDERR_HWNDALREADYSET},
				{"DDERR_NOPALETTEATTACHED",DDERR_NOPALETTEATTACHED},
				{"DDERR_NOPALETTEHW",DDERR_NOPALETTEHW},
				{"DDERR_BLTFASTCANTCLIP",DDERR_BLTFASTCANTCLIP},
				{"DDERR_NOBLTHW",DDERR_NOBLTHW},
				{"DDERR_NODDROPSHW",DDERR_NODDROPSHW},
				{"DDERR_OVERLAYNOTVISIBLE",DDERR_OVERLAYNOTVISIBLE},
				{"DDERR_NOOVERLAYDEST",DDERR_NOOVERLAYDEST},
				{"DDERR_INVALIDPOSITION",DDERR_INVALIDPOSITION},
				{"DDERR_NOTAOVERLAYSURFACE",DDERR_NOTAOVERLAYSURFACE},
				{"DDERR_EXCLUSIVEMODEALREADYSET",DDERR_EXCLUSIVEMODEALREADYSET},
				{"DDERR_NOTFLIPPABLE",DDERR_NOTFLIPPABLE},
				{"DDERR_CANTDUPLICATE",DDERR_CANTDUPLICATE},
				{"DDERR_NOTLOCKED",DDERR_NOTLOCKED},
				{"DDERR_CANTCREATEDC",DDERR_CANTCREATEDC},
				{"DDERR_NODC",DDERR_NODC},
				{"DDERR_WRONGMODE",DDERR_WRONGMODE},
				{"DDERR_IMPLICITLYCREATED",DDERR_IMPLICITLYCREATED},
				{"DDERR_NOTPALETTIZED",DDERR_NOTPALETTIZED},
				{"DDERR_UNSUPPORTEDMODE",DDERR_UNSUPPORTEDMODE},
				{"END",0}
};

inline char * ErrorName(HRESULT err)
{
	int e=0;
	while (strcmp(ErrorLookup[e].name,"END"))
	{
		if (err == ErrorLookup[e].errcode)
			return ErrorLookup[e].name;
		e++;
	};
	return "Unknown Error code";
}	


class CLogfile
{	
	private:
		char smalltemp[10];
		HFILE 	fh;
		OFSTRUCT of;
		BOOL bHeaderWritten;
		char *cComment;
		char line[1000];
		LONG lStartPos;
		char Path[200];
	public:
		CLogfile(char * path, char * comment = 0,BOOL bAppend=FALSE)
		{
			if (path)
				strncpy(Path,path,199);

			fh = HFILE_ERROR;
			bHeaderWritten = FALSE;
			lStartPos = 0;

			//if the file does not exist, create it:
			if (GetFileAttributes(path) == 0xffffffff)
				fh = OpenFile(path,&of,OF_CREATE|OF_READWRITE|OF_SHARE_DENY_WRITE);
			else
				//first attempt to get a lock on the file...
				for (int i=0;i<20 && fh==HFILE_ERROR;i++)
				{
					if (bAppend)
						fh = OpenFile(path,&of, OF_READWRITE|OF_SHARE_DENY_WRITE);
					else
						fh = OpenFile(path,&of, OF_CREATE|OF_READWRITE|OF_SHARE_DENY_WRITE);
					if (fh==HFILE_ERROR)
						Sleep(1000);
				}

			if (fh==HFILE_ERROR)
				return;

			lStartPos = _llseek(fh,0,SEEK_END);

			cComment = comment;
		}

		void OutputHeader(void)
		{
			//now we have the file, write user/computer info:

			//write separator, comment if necessary and date and time:
			SYSTEMTIME st;
			GetLocalTime(&st);
			wsprintf(line,"----------------------------------------------------------\r\n");
			_lwrite(fh,line,strlen(line));
			if (cComment && strlen(cComment))
			{
				wsprintf(line,"%s\r\n",cComment);
				_lwrite(fh,line,strlen(line));
			}
			wsprintf(line,"Beginning test at %d:%02d on %d/%d/%d\r\n",st.wHour,st.wMinute,st.wYear,st.wMonth,st.wDay);
			_lwrite(fh,line,strlen(line));


			//write user's name:
			DWORD length = 100;
			wsprintf(line,"User Name:");

			WNetGetUser(NULL,line+strlen(line),&length);
			_lwrite(fh,line,strlen(line));

			//write computer's name:
			wsprintf(line,"\r\nComputer Name:");
			GetComputerName(line+strlen(line),&length);
			_lwrite(fh,line,strlen(line));

			//write display driver's name:
			wsprintf(line,"\r\nDisplay driver:");
			GetPrivateProfileString("boot.description","display.drv","(Unknown)",line+strlen(line),100,"system.ini");
			_lwrite(fh,line,strlen(line));

			_lwrite(fh,"\r\n",2);

			HDC hdc = GetDC(NULL);
			if (hdc)
			{
				wsprintf(line,"Starting resolution: %dx%dx%d\r\n",
							GetDeviceCaps(hdc,HORZRES)
							,GetDeviceCaps(hdc,VERTRES)
							,GetDeviceCaps(hdc,BITSPIXEL) );
				_lwrite(fh,line,strlen(line));
				ReleaseDC(NULL,hdc);
			}
			wsprintf(line,"- - - - - - - - - - - - - - - - - - - - - - - - - - - - - \r\n");
			_lwrite(fh,line,strlen(line));

			bHeaderWritten = TRUE;
		}
		~CLogfile()
		{
			SYSTEMTIME st;
			if(fh != HFILE_ERROR)
			{
				if (bHeaderWritten)
				{
					GetLocalTime(&st);
					wsprintf(line,"----------- Test ends at %d:%02d on %d/%d/%d -------------\r\n",st.wHour,st.wMinute,st.wYear,st.wMonth,st.wDay);
					_lwrite(fh,line,strlen(line));
				}
				_lclose(fh);
			}
		}
		CLogfile & operator << (DWORD dw)
		{
			if(fh == HFILE_ERROR)
				return *this;
			if(!bHeaderWritten)
				OutputHeader();
			wsprintf(smalltemp,"%08x",dw);
			_lwrite(fh,smalltemp,strlen(smalltemp));
			return *this;
		}
		CLogfile & operator << (LONG dw)
		{
			if(fh == HFILE_ERROR)
				return *this;
			if(!bHeaderWritten)
				OutputHeader();
			wsprintf(smalltemp,"%d",dw);
			_lwrite(fh,smalltemp,strlen(smalltemp));
			return *this;
		}
                CLogfile & operator << (void * p)
		{
			if(fh == HFILE_ERROR)
				return *this;
			if(!bHeaderWritten)
				OutputHeader();
            // 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers and handles.
			wsprintf(smalltemp,"%p",p);
			_lwrite(fh,smalltemp,strlen(smalltemp));
			return *this;
		}
		CLogfile & operator << (char * cp)
		{
			if(fh == HFILE_ERROR)
				return *this;
			if(!bHeaderWritten)
				OutputHeader();
			while( *cp)
				*this << *cp++;
			return *this;
		}
		CLogfile & operator << (char  c)
		{
			if(fh == HFILE_ERROR)
				return *this;
			if(!bHeaderWritten)
				OutputHeader();
			if (c=='\n')
			{
				wsprintf(smalltemp,"\r");
				_lwrite(fh,smalltemp,strlen(smalltemp));
			}
			wsprintf(smalltemp,"%c",c);
			_lwrite(fh,smalltemp,strlen(smalltemp));
			return *this;
		}
		CLogfile & operator << (CLogfile & log)
		{
			if(fh == HFILE_ERROR)
				return *this;
			if(!bHeaderWritten)
				OutputHeader();

			LONG pos = _llseek(log.fh,0,FILE_CURRENT);
			LONG from = _llseek(log.fh,log.lStartPos,FILE_BEGIN);

			char ch;
			*this << "= = = = = = = Snapshot of ";
			if (log.Path)
				*this << log.Path;
			else
				*this << "Unknown file";
			*this << " = = = = = = =\n";

			for (LONG j=0;j<pos-from;j++)
			{
				_lread(log.fh,&ch,1);
				*this << ch;
			}

			*this << "= = = = = = = = = Snapshot ends = = = = = = = = = = =\n";
			return *this;
		}
			
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\misc\dpfa.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpf.c
 *  Content:	debugging printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   06-jan-95	craige	initial implementation
 *   03-mar-95	craige	added dprintf2
 *   31-mar-95	craige	add DPFInit to read WIN.INI for [DirectDraw] section;
 *			added dprintf3
 *   01-apr-95	craige	happy fun joy updated header file
 *   06-apr-95	craige	made stand-alone
 *   18-jun-95	craige	use negative dpf level to display ONLY that level
 *   06-dec-95  jeffno  Changed dprintf to use c-standard variable argument
 *                      list techniques. Also added abs for NT
 *   06-feb-96  colinmc added simple assertion mechanism for DirectDraw
 *   15-apr-96	kipo	added msinternal
 *	 20-may-96	andyco	forced ansi entry points on all functions
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#undef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include "dpf.h"
#include <stdarg.h>

//#ifdef WINNT
//int abs(int x)
//{
//    return x>=0?x:-x;
//}
//#endif

#ifdef DEBUG

#define USE_DDASSERT

#ifndef START_STR
    #define START_STR	"DDRAW: "
#endif
#ifndef PROF_SECT
    #define PROF_SECT	"DirectDraw"
#endif

#define END_STR		"\r\n"

HWND		hWndListBox;
LONG		lDebugLevel = 0;

/*
 * dumpStr
 */
static void dumpStr( LPSTR str )
{
    OutputDebugStringA( str );

    #ifdef DPF_HWND
	if( hWndListBox != NULL )
	{
	    if( !IsWindow( hWndListBox ) )
	    {
		hWndListBox = NULL;
	    }
	}
	if( hWndListBox != NULL )
	{
	    UINT	sel;
	    int	len;
	    len = strlen( str );
	    if( len > 0 )
	    {
		if( str[len-1] == '\r' || str[len-1] == '\n' )
		{
		    str[len-1] = 0;
		}
		if( len > 1 )
		{
		    if( str[len-2] == '\r' || str[len-2] == '\n' )
		    {
			str[len-2] = 0;
		    }
		}
	    }
	    SendMessage( hWndListBox, LB_ADDSTRING, 0, (LONG) (LPSTR) str );
	    sel = (UINT) SendMessage( hWndListBox, LB_GETCOUNT, 0, 0L );
	    if( sel != LB_ERR )
	    {
		SendMessage( hWndListBox, LB_SETCURSEL, sel-1, 0L );
	    }
	}
    #endif

} /* dumpStr */

/*
 * dprintf
 */
void cdecl dprintf( UINT lvl, LPSTR szFormat, ...)
{
    char 	str[256];
    BOOL	allow = FALSE;
    va_list ap;
    va_start(ap,szFormat);


    if( lDebugLevel < 0 )
    {
#ifdef WINNT
	if( (UINT) abs( lDebugLevel ) == lvl )
#else
	if( (UINT) labs( lDebugLevel ) == lvl )
#endif
	{
	    allow = TRUE;
	}
    }
    else if( (UINT) lDebugLevel >= lvl )
    {
	allow = TRUE;
    }

    if( allow )
    {
	wsprintfA( (LPSTR) str, START_STR );
	wvsprintfA( str+lstrlenA( str ), szFormat, ap);   //(LPVOID)(&szFormat+1) );

	lstrcatA( (LPSTR) str, END_STR );
	dumpStr( str );
    }

    va_end(ap);
} /* dprintf */

/*
 * DPFInit
 */
void DPFInit( void )
{
    lDebugLevel = GetProfileIntA( PROF_SECT, "debug", 0 );

} /* DPFInit */

#ifdef USE_DDASSERT

/*
 * NOTE: I don't want to get into error checking for buffer overflows when
 * trying to issue an assertion failure message. So instead I just allocate
 * a buffer that is "bug enough" (I know, I know...)
 */
#define ASSERT_BUFFER_SIZE   512
#define ASSERT_BANNER_STRING "************************************************************"
#define ASSERT_BREAK_SECTION "BreakOnAssert"
#define ASSERT_BREAK_DEFAULT FALSE
#define ASSERT_MESSAGE_LEVEL 0

void _DDAssert( LPCSTR szFile, int nLine, LPCSTR szCondition )
{
    char buffer[ASSERT_BUFFER_SIZE];

    /*
     * Build the debug stream message.
     */
    wsprintfA( buffer, "ASSERTION FAILED! File %s Line %d: %s", szFile, nLine, szCondition );

    /*
     * Actually issue the message. These messages are considered error level
     * so they all go out at error level priority.
     */
    dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );
    dprintf( ASSERT_MESSAGE_LEVEL, buffer );
    dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );

    /*
     * Should we drop into the debugger?
     */
    if( GetProfileIntA( PROF_SECT, ASSERT_BREAK_SECTION, ASSERT_BREAK_DEFAULT ) )
    {
	/*
	 * Into the debugger we go...
	 */
	DEBUG_BREAK();
    }
}

#endif /* USE_DDASSERT */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\misc\dpf.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpf.h
 *  Content:    header file for debug printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   06-apr-95  craige  initial implementation
 *   06-feb-96  colinmc added simple assertion mechanism for DirectDraw
 *   15-apr-96	kipo	added msinternal
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#ifdef NEW_DPF
#include "newdpf.h"
#else

    #ifndef __DPF_INCLUDED__
    #define __DPF_INCLUDED__

    #ifdef __cplusplus
    extern "C" {
    #endif

    #ifdef WINNT
        #undef DEBUG
        #ifdef DBG
	    #define DEBUG
        #endif
    #endif

    extern void cdecl dprintf( UINT lvl, LPSTR szFormat, ...);
    extern void DPFInit( void );
    #ifdef DEBUG
        #define DPFINIT()   DPFInit()
        #define DPF         dprintf
        #define DPF_ERR(a)  dprintf( 0, DPF_MODNAME ": " a );
        extern HWND hWndListBox;
        #if defined( _WIN32 ) && !defined(WINNT)
	    #define DEBUG_BREAK()       _try { _asm { int 3 } } _except (EXCEPTION_EXECUTE_HANDLER) {;}
        #else
	    #define DEBUG_BREAK()       DebugBreak()
        #endif
        #define USE_DDASSERT
    #else
        #pragma warning(disable:4002)
        #define DPFINIT()
        #define DPF()
        #define DPF_ERR(a)
        #define DEBUG_BREAK()
    #endif

    #if defined(DEBUG) && defined(USE_DDASSERT)

    extern void _DDAssert(LPCSTR szFile, int nLine, LPCSTR szCondition);

    #define DDASSERT(condition) if (!(condition)) _DDAssert(__FILE__, __LINE__, #condition)

    #else  /* DEBUG && USE_DDASSERT */

    #define DDASSERT(condition)

    #endif /* DEBUG && USE_DDASSERT */

    #ifdef _WIN32

    #ifdef DEBUG
        __inline DWORD clockrate() {LARGE_INTEGER li; QueryPerformanceFrequency(&li); return li.LowPart;}
        __inline DWORD clock()     {LARGE_INTEGER li; QueryPerformanceCounter(&li);   return li.LowPart;}

        #define TIMEVAR(t)    DWORD t ## T; DWORD t ## N
        #define TIMEZERO(t)   t ## T = 0, t ## N = 0
        #define TIMESTART(t)  t ## T -= clock(), t ## N ++
        #define TIMESTOP(t)   t ## T += clock()
        #define TIMEFMT(t)    ((DWORD)(t) / clockrate()), (((DWORD)(t) * 1000 / clockrate())%1000)
        #define TIMEOUT(t)    if (t ## N) DPF(1, #t ": %ld calls, %ld.%03ld sec (%ld.%03ld)", t ## N, TIMEFMT(t ## T), TIMEFMT(t ## T / t ## N))
    #else
        #define TIMEVAR(t)
        #define TIMEZERO(t)
        #define TIMESTART(t)
        #define TIMESTOP(t)
        #define TIMEFMT(t)
        #define TIMEOUT(t)
    #endif

    #endif
    #ifdef __cplusplus
    }
    #endif

    #endif
#endif //use new dpf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\misc\memalloc.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       memalloc.c
 *  Content:    allocates memory
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   20-jan-95  craige  initial implementation
 *   27-feb-95  craige  don't call HeapFree with NULL, it is a huge time sink
 *   29-mar-95  craige  memory tracker
 *   01-apr-95  craige  happy fun joy updated header file
 *   06-apr-95  craige  made stand-alone
 *   22-may-95  craige  added MemAlloc16
 *   12-jun-95  craige  added MemReAlloc
 *   18-jun-95  craige  deadlock joy: don't take DLL csect here
 *   26-jul-95  toddla  added MemSize and fixed MemReAlloc
 *   29-feb-96  colinmc added optional debugging code to blat a a specific
 *                      bit pattern over freed memory
 *   08-oct-96	ketand	change debug message to give a total for the terminating
 *			process
 *
 ***************************************************************************/
#undef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include "memalloc.h"
#include "dpf.h"

#define FREE_MEMORY_PATTERN 0xDEADBEEFUL

#ifdef WIN95
    #ifdef NOSHARED
	#define HEAP_SHARED     0
    #else
	#define HEAP_SHARED     0x04000000      // put heap in shared memory
    #endif
#else
    #define HEAP_SHARED         0
#endif

static HANDLE   hHeap = NULL;           // handle to shared heap for this DLL

/*
 * memory track struct and list
 */
#ifdef DEBUG
#define MCOOKIE 0xbaaabaaa
#define MCOOKIE_FREE    0xbabababa
typedef struct _MEMTRACK
{
    DWORD               dwCookie;
    struct _MEMTRACK    FAR *lpNext;
    struct _MEMTRACK    FAR *lpPrev;
    DWORD               dwSize;
    LPVOID              lpAddr;
    DWORD               dwPid;
} MEMTRACK, FAR *LPMEMTRACK;

static LPMEMTRACK       lpHead;
static LPMEMTRACK       lpTail;
static LONG             lAllocCount;

#define DEBUG_TRACK( lptr, first ) \
    if( lptr == NULL ) \
    { \
	DPF( 1, "Alloc of size %u FAILED!", size ); \
    } \
    else \
    { \
	LPMEMTRACK      pmt; \
	pmt = (LPMEMTRACK) lptr; \
	pmt->dwSize = size - sizeof( MEMTRACK ); \
	pmt->dwCookie = MCOOKIE; \
	pmt->lpAddr = _ReturnAddress(); \
	pmt->dwPid = GetCurrentProcessId(); \
	if( lpHead == NULL ) \
	{ \
	    lpHead = lpTail = pmt; \
	} \
	else \
	{ \
	    lpTail->lpNext = pmt; \
	    pmt->lpPrev = lpTail; \
	    lpTail = pmt; \
	} \
	lptr = (LPVOID) (((LPBYTE) lptr) + sizeof( MEMTRACK )); \
	lAllocCount++; \
    }

#define DEBUG_TRACK_UPDATE_SIZE( s ) s += sizeof( MEMTRACK );

#else

#define DEBUG_TRACK( lptr, first )
#define DEBUG_TRACK_UPDATE_SIZE( size )

#endif


#if defined( WIN95 ) && defined( WANT_MEM16 )

extern DWORD _stdcall MapLS( LPVOID ); // flat -> 16:16
extern void _stdcall UnMapLS( DWORD ); // unmap 16:16

typedef struct SELLIST {
    struct SELLIST      *link;
    LPBYTE              base;
    WORD                sel;
} SELLIST, *LPSELLIST;

static LPSELLIST        lpSelList;

/*
 * MemAlloc16
 *
 * Allocate some memory, and return a 16:16 pointer to that memory
 *
 * NOTE: ASSUMES WE ARE IN THE DLL CRITICAL SECTION!
 */
LPVOID __cdecl MemAlloc16( UINT size, LPDWORD p16 )
{
    LPBYTE              lptr;
    LPSELLIST           psel;
    DWORD               diff;

    DEBUG_TRACK_UPDATE_SIZE( size );
    lptr = HeapAlloc( hHeap, HEAP_ZERO_MEMORY, size );
    DEBUG_TRACK( lptr, size );
    if( lptr == NULL )
    {
	return NULL;
    }

    /*
     * try to find an existing selector that maps this area
     */
    psel = lpSelList;
    while( psel != NULL )
    {
	if( psel->base <= lptr )
	{
	    diff = lptr - psel->base;
	    if( diff+size < 0xf000 )
	    {
		*p16 = ((DWORD)psel->sel << 16l) + diff;
		return lptr;
	    }
	}
	psel = psel->link;
    }

    /*
     * no selector found, create a new one
     */
    psel = HeapAlloc( hHeap, HEAP_ZERO_MEMORY, sizeof( SELLIST ));
    if( psel == NULL )
    {
	return NULL;
    }
    psel->sel = HIWORD( MapLS( lptr ) );
    DPF( 2, "$$$$$$ New selector allocated: %04x", psel->sel );
    psel->base = lptr;
    psel->link = lpSelList;
    lpSelList = psel;
    *p16 = ((DWORD) psel->sel) << 16l;

    return lptr;

} /* MemAlloc16 */

/*
 * GetPtr16
 */
LPVOID GetPtr16( LPVOID ptr )
{
    DWORD       diff;
    DWORD       p16;
    LPSELLIST   psel;
    LPBYTE      lptr;

    lptr = ptr;

    psel = lpSelList;
    while( psel != NULL )
    {
	if( psel->base <= lptr )
	{
	    diff = lptr - psel->base;
	    if( diff <= 0xf000 )
	    {
		p16 = ((DWORD)psel->sel << 16l) + diff;
		return (LPVOID) p16;
	    }
	}
	psel = psel->link;
    }
    DPF( 1, "ERROR: NO 16:16 PTR for %08lx", lptr );
    return NULL;

} /* GetPtr16 */

/*
 * freeSelectors
 */
static void freeSelectors( void )
{
    LPSELLIST           psel;
    LPSELLIST           link;

    psel = lpSelList;
    while( psel != NULL )
    {
	link = psel->link;
	DPF( 2, "$$$$$$ Freeing selector %04x", psel->sel );
	UnMapLS( ((DWORD)psel->sel) << 16l );
	HeapFree( hHeap, 0, psel );
	psel = link;
    }
    lpSelList = NULL;

} /* freeSelectors */
#endif

/*
 * MemAlloc - allocate memory from our global pool
 */
LPVOID __cdecl MemAlloc( UINT size )
{
    LPBYTE lptr;

    DEBUG_TRACK_UPDATE_SIZE( size );
    lptr = HeapAlloc( hHeap, HEAP_ZERO_MEMORY, size );
    DEBUG_TRACK( lptr, size );

    return lptr;

} /* MemAlloc */

/*
 * MemSize - return size of object
 */
UINT_PTR __cdecl MemSize( LPVOID lptr )
{
#ifdef DEBUG
    if (lptr)
    {
	LPMEMTRACK  pmt;
	lptr = (LPVOID) (((LPBYTE)lptr) - sizeof( MEMTRACK ));
	pmt = lptr;
	return pmt->dwSize;
    }
#endif
    return HeapSize(hHeap, 0, lptr);

} /* MemSize */

/*
 * MemFree - free memory from our global pool
 */
void MemFree( LPVOID lptr )
{
    if( lptr != NULL )
    {
	#ifdef DEBUG
	{
	    /*
	     * get real pointer and unlink from chain
	     */
	    LPMEMTRACK  pmt;
	    lptr = (LPVOID) (((LPBYTE)lptr) - sizeof( MEMTRACK ));
	    pmt = lptr;

	    if( pmt->dwCookie == MCOOKIE_FREE )
	    {
		DPF( 1, "FREE OF FREED MEMORY! ptr=%08lx", pmt );
		DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx", pmt, pmt->dwSize, pmt->lpAddr );
	    }
	    else if( pmt->dwCookie != MCOOKIE )
	    {
		DPF( 1, "INVALID FREE! cookie=%08lx, ptr = %08lx", pmt->dwCookie, lptr );
		DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx", pmt, pmt->dwSize, pmt->lpAddr );
	    }
	    else
	    {
		pmt->dwCookie = MCOOKIE_FREE;
		if( pmt == lpHead && pmt == lpTail )
		{
		    lpHead = NULL;
		    lpTail = NULL;
		}
		else if( pmt == lpHead )
		{
		    lpHead = pmt->lpNext;
		    lpHead->lpPrev = NULL;
		}
		else if( pmt == lpTail )
		{
		    lpTail = pmt->lpPrev;
		    lpTail->lpNext = NULL;
		}
		else
		{
		    pmt->lpPrev->lpNext = pmt->lpNext;
		    pmt->lpNext->lpPrev = pmt->lpPrev;
		}

		#ifdef FILL_ON_MEMFREE
		{
		    LPDWORD lpMem;
		    DWORD   dwPat;
		    DWORD   dwSize;

		    dwSize = pmt->dwSize;
		    lpMem = (LPDWORD)( (LPBYTE)lptr + sizeof( MEMTRACK ) );
		    while (dwSize >= sizeof(DWORD))
		    {
			*lpMem++ = FREE_MEMORY_PATTERN;
			dwSize -= sizeof(DWORD);
		    }
		    if (dwSize != 0UL)
		    {
			dwPat = FREE_MEMORY_PATTERN;
			memcpy(lpMem, &dwPat, dwSize);
		    }
		}
		#endif
	    }
	    lAllocCount--;
	    if( lAllocCount < 0 )
	    {
		DPF( 1, "Too Many Frees!\n" );
	    }
	}
	#endif

	HeapFree( hHeap, 0, lptr );

    }

} /* MemFree */

/*
 * MemReAlloc
 */
LPVOID __cdecl MemReAlloc( LPVOID lptr, UINT size )
{
    LPVOID new;

    DEBUG_TRACK_UPDATE_SIZE( size );
    #ifdef DEBUG
	if( lptr != NULL )
	{
	    LPMEMTRACK  pmt;
	    lptr = (LPVOID) (((LPBYTE)lptr) - sizeof( MEMTRACK ));
	    pmt = lptr;
	    if( pmt->dwCookie != MCOOKIE )
	    {
		DPF( 1, "INVALID REALLOC! cookie=%08lx, ptr = %08lx", pmt->dwCookie, lptr );
		DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx", pmt, pmt->dwSize, pmt->lpAddr );
	    }
	}
    #endif

    new = HeapReAlloc( hHeap, HEAP_ZERO_MEMORY, lptr, size );

    #ifdef DEBUG
    if (new != NULL)
    {
	LPMEMTRACK pmt = new;

	pmt->dwSize = size - sizeof( MEMTRACK );

	if( lptr == (LPVOID)lpHead )
	    lpHead = pmt;
	else
	    pmt->lpPrev->lpNext = pmt;

	if( lptr == (LPVOID)lpTail )
	    lpTail = pmt;
	else
	    pmt->lpNext->lpPrev = pmt;

	new = (LPVOID) (((LPBYTE)new) + sizeof(MEMTRACK));
    }
    #endif
    return new;

} /* MemReAlloc */

/*
 * MemInit - initialize the heap manager
 */
BOOL MemInit( void )
{
    if( hHeap == NULL )
    {
	hHeap = HeapCreate( HEAP_SHARED, 0x2000, 0 );
	if( hHeap == NULL )
	{
	    return FALSE;
	}
    }
    #ifdef DEBUG
	lAllocCount = 0;
	lpHead = NULL;
	lpTail = NULL;
    #endif
    return TRUE;

} /* MemInit */

#ifdef DEBUG
/*
 * MemState - finished with our heap manager
 */
void MemState( void )
{
    DPF( 2, "MemState" );
    if( lAllocCount != 0 )
    {
	DPF( 1, "Memory still allocated!  Alloc count = %ld", lAllocCount );
	DPF( 1, "Current Process (pid) = %08lx", GetCurrentProcessId() );
    }
    if( lpHead != NULL )
    {
	LPMEMTRACK      pmt;
	DWORD		dwTotal = 0;
	DWORD		pidCurrent = GetCurrentProcessId();
	pmt = lpHead;
	while( pmt != NULL )
	{
	    if( pidCurrent == pmt->dwPid )
		dwTotal += pmt->dwSize;
	    DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx (pid=%08lx)", pmt, pmt->dwSize, pmt->lpAddr, pmt->dwPid );
	    pmt = pmt->lpNext;
	}
	DPF ( 1, "Total Memory Unfreed From Current Process = %ld bytes", dwTotal );
    }
} /* MemState */
#endif

/*
 * MemFini - finished with our heap manager
 */
void MemFini( void )
{
    DPF( 2, "MemFini!" );
    #ifdef DEBUG
	MemState();
    #endif
    #if defined( WIN95 ) && defined( WANT_MEM16 )
	freeSelectors();
    #endif
    if( hHeap )
    {
	HeapDestroy( hHeap );
	hHeap = NULL;
    }
} /* MemFini */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\protocol\bilink.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    BILINK.H

Abstract:

    Management for doubly linked lists

Author:

    George Joy

Environment:

    32-bit 'C'

Revision History:

--*/// BILINK.H

#ifndef _BILINK_

#define _BILINK_

#if !defined(offsetof)
	#define offsetof(type, field) ((int)(&((type *)0)->field))
#endif	

typedef struct BILINK {
    struct BILINK *next;
    struct BILINK *prev;
} BILINK;

/* XLATOFF */

#define EMPTY_BILINK(_pBilink) ((_pBilink)->next==(_pBilink))

#ifdef DEBUG
    #define ASSERT_EMPTY_BILINK(_b) ASSERT((_b)->next==(_b))
#else
    #define ASSERT_EMPTY_BILINK(_b)
#endif

// This only works for BILINKS that are the first item in a structure.
#define BilinkToList( _pBilink ) \
	(_pBilink)->prev->next=NULL;

#define InitBilink( _pBilink ) \
    (_pBilink)->prev=(_pBilink)->next=(_pBilink);

#ifdef DEBUG

int FindObject(
    BILINK *link,
    BILINK *list
    );
#endif

void InsertAfter(
    BILINK *in,
    BILINK *after
    );

void InsertBefore(
     BILINK *in,
     BILINK *before
    );

void Delete(
     BILINK *p
);

/* XLATON */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\misc\newdpf.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       newdpf.c
 *  Content:    new debug printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   10-oct-95  jeffno  initial implementation
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#if defined(DEBUG) || defined(DBG)

#ifdef IS_16
    #define OUTPUTDEBUGSTRING OutputDebugString
    #define GETPROFILESTRING GetProfileString
    #define GETPROFILEINT GetProfileInt
    #define WSPRINTF wsprintf
    #define WVSPRINTF wvsprintf
    #define LSTRLEN lstrlen
#else
    #define OUTPUTDEBUGSTRING OutputDebugStringA
    #define GETPROFILESTRING GetProfileStringA
    #define GETPROFILEINT GetProfileIntA
    #define WSPRINTF wsprintfA
    #define WVSPRINTF wvsprintfA
    #define LSTRLEN lstrlenA
#endif

#include "dpf.h"

#undef DEBUG_TOPIC
#define DEBUG_TOPIC(flag,name) {#flag,name,TRUE},

static 
    struct {
        char cFlag[4];
        char cName[64];
        BOOL bOn;
} DebugTopics[] = {
    {"","Filler",FALSE},
    {"A","API Usage",TRUE},
#include "DBGTOPIC.H"
    {"","End",FALSE}
};

#ifndef DPF_MODULE_NAME
    #define DPF_MODULE_NAME ""
#endif

static DWORD bDetailOn = 1;

static BOOL bInited=FALSE;
static BOOL bAllowMisc=TRUE;
static bBreakOnAsserts=FALSE;
static bPrintLineNumbers=FALSE;
static bPrintFileNames=FALSE;
static bPrintExecutableName=FALSE;
static bPrintTID=FALSE;
static bPrintPID=FALSE;
static bIndentOnMessageLevel=FALSE;
static bPrintTopicsAndLevels=FALSE;
static bPrintModuleName=TRUE;
static bPrintFunctionName=FALSE;
static bRespectColumns=FALSE;
static bPrintAPIStats=FALSE;
static bPrintAllTopics=TRUE;

static DWORD dwFileLineTID=0;
static char cFile[100];
static char cFnName[100];
static DWORD dwLineNo;
static bMute=FALSE;

static BOOL bLogging=FALSE; // whether to use the logging VxD instead of dumping.


DPF_PROC_STATS ProcStats[MAX_PROC_ORDINAL];
#ifdef cplusplus
	extern "C" {
#endif

void mystrncpy(char * to,char * from,int n)
{
    for(;n;n--)
        *(to++)=*(from++);
}

char * mystrrchr(char * in,char c)
{
    char * last=0;
    while (*in)
    {
        if (*in == c)
            last = in;
        in++;
    }
    return last;
}

char Junk[]="DPF_MODNAME undef'd";
char * DPF_MODNAME = Junk;
 
int DebugSetFileLineEtc(LPSTR szFile, DWORD dwLineNumber, LPSTR szFnName)
{
    if (!(bPrintFileNames||bPrintLineNumbers||bPrintFunctionName))
    {
        return 1;
    }
#ifdef WIN32
    dwFileLineTID = GetCurrentThreadId();
#endif
    mystrncpy (cFile,szFile,sizeof(cFile));
    mystrncpy (cFnName,szFnName,sizeof(cFnName));
    dwLineNo = dwLineNumber;
    return 1;
}

/*
BOOL DeviceIoControl( 
HANDLE hDevice, 			// handle to device of interest 
DWORD dwIoControlCode, 		// control code of operation to perform 
LPVOID lpInBuffer, 			// pointer to buffer to supply input data 
DWORD nInBufferSize, 		// size of input buffer 
LPVOID lpOutBuffer, 		// pointer to buffer to receive output data 
DWORD nOutBufferSize, 		// size of output buffer 
LPDWORD lpBytesReturned, 	// pointer to variable to receive output byte count 
LPOVERLAPPED lpOverlapped 	// pointer to overlapped structure for asynchronous operation 
); 
*/

#define MAX_STRING       240
#define LOG_SIZE         2000
#define FIRST_DEBUG_PROC 100

#define OPEN_DEBUGLOG 	(FIRST_DEBUG_PROC)
#define WRITE_DEBUGLOG 	(FIRST_DEBUG_PROC+1)

HANDLE hDPLAY_VxD=0;

typedef struct _LOGENTRY {
	CHAR	debuglevel;
	CHAR    str[1];
} LOGENTRY, *PLOGENTRY;

typedef struct {
	UINT	nLogEntries;
	UINT    nCharsPerLine;
} IN_LOGINIT, *PIN_LOGINIT;

typedef struct {
	UINT    hr;
} OUT_LOGINIT, *POUT_LOGINIT;

typedef struct {
	CHAR	debuglevel;
	CHAR    str[1];
} IN_LOGWRITE, *PIN_LOGWRITE;

typedef struct {
	UINT	hr;
} OUT_LOGWRITE, *POUT_LOGWRITE;


static void LogString( LPSTR str )
{
	char logstring[MAX_STRING+sizeof(LOGENTRY)];
	int  i=0;
	PLOGENTRY pLogEntry=(PLOGENTRY)logstring;
	UINT rc;
	UINT cbRet;

	if(hDPLAY_VxD && str){
		while(str[i])i++;
		pLogEntry->debuglevel=0;
		memcpy(pLogEntry->str,str,i+1);
		DeviceIoControl(hDPLAY_VxD,WRITE_DEBUGLOG,pLogEntry,i+sizeof(LOGENTRY), &rc, sizeof(rc), &cbRet, NULL);
	}
}

static void dumpStr( LPSTR str )
{
    /*
     * Have to warm the string, since OutputDebugString is buried
     * deep enough that it won't page the string in before reading it.
     */
    int i=0;
    if (str)
        while(str[i])
            i++;
	if(bLogging!=2)
	{            
	    OUTPUTDEBUGSTRING( str );
	    OUTPUTDEBUGSTRING("\n");
    }
    if(bLogging)
    {
	    LogString(str);
	}    
    
}
    
void DebugPrintfInit(void)
{
    signed int lDebugLevel;
    int i;
    char cTopics[100];

#ifndef PROF_SECT
    #define PROF_SECT	"DirectDraw"
#endif
    bDetailOn=1;

    for (i=0;i<LAST_TOPIC;i++)
        DebugTopics[i].bOn=FALSE;

    //ZeroMemory(ProcStats,sizeof(ProcStats));

    GETPROFILESTRING( "DirectX", DPF_CONTROL_LINE, "DefaultTopics", cTopics, sizeof(cTopics) );
    if (!strcmp(cTopics,"DefaultTopics"))
    {
        DebugSetTopicsAndLevels("");
        bAllowMisc=TRUE;
        bPrintAllTopics=TRUE;
        lDebugLevel = (signed int) GETPROFILEINT( PROF_SECT, "debug", 0 );
        bLogging    = (signed int) GETPROFILEINT( PROF_SECT, "log" , 0);

        if (lDebugLevel <0)
        {
            if (lDebugLevel < -9)
                lDebugLevel=-9;

            bDetailOn |= (1<<(-lDebugLevel));
        }
        else
        {
            for (i=0;i<= (lDebugLevel<10?lDebugLevel:10);i++)
                bDetailOn |= 1<<i;
        }

        if(bLogging){
        	hDPLAY_VxD = CreateFileA("\\\\.\\DPLAY",0,0,0,0,0,0);
        	if(hDPLAY_VxD){
        		IN_LOGINIT In;
        		OUT_LOGINIT Out;
        		UINT cbRet;
        		In.nCharsPerLine=MAX_STRING;
        		In.nLogEntries=5000;
				DeviceIoControl(hDPLAY_VxD,OPEN_DEBUGLOG,&In,sizeof(In), &Out, sizeof(Out), &cbRet, NULL);
        	}
        }
    }
    else
    {
        DebugSetTopicsAndLevels(cTopics);
        if (!strcmp(cTopics,"?") && !bInited)
        {
            dumpStr("--------------" DPF_MODULE_NAME " Debug Output Control -------------");
            dumpStr("Each character on the control line controls a topic, a detail");
            dumpStr("level or an extra info. E.g. 0-36A@ means print detail levels 0");
            dumpStr("through 3 and 6 for topic A with source file name and line numbers.");
            dumpStr("The extra info control characters are:");
            dumpStr("   !: Break on asserts");
            dumpStr("   ^: Print TID of calling thread");
            dumpStr("   #: Print PID of calling process");
            dumpStr("   >: Indent on message detail levels");
            dumpStr("   &: Print the topic and detail level of each message");
            dumpStr("   =: Print function name");
            dumpStr("   +: Print all topics, including topic-less");
            dumpStr("   / or -: do not allow topic-less messages");
            dumpStr("   @ or $: Print source filename and line number of DPF");
            dumpStr("Topics for this module are:");
            for(i=0;strcmp(DebugTopics[i].cName,"End");i++)
            {
                OUTPUTDEBUGSTRING("   ");
                OUTPUTDEBUGSTRING(DebugTopics[i].cFlag);
                OUTPUTDEBUGSTRING(": ");
                dumpStr(DebugTopics[i].cName);
            }
            dumpStr("Tip: Use 0-3A to get debug info about API calls");
        }
    }
    bInited=TRUE;
}


/*
 *
 * The full output can be:
 * Module:(Executable,TxNNNN,PxNN):FunctionName:"file.c",#nnn(AAnn) Messagemessagemessage
 * or, if indentation turned on:
 * Module:(Executable,TxNNNN,PxNN):FunctionName:"file.c",#nnn(AAnn)        Messagemessagemessage
 */
int DebugPrintf(DWORD dwDetail, ...)
{
#define MSGBUFFERSIZE 1000
    char cMsg[MSGBUFFERSIZE];
    char cTopics[20];
    DWORD arg;
    LPSTR szFormat;
    BOOL bAllowed=FALSE;
    BOOL bMiscMessage=TRUE;
    int i;

    va_list ap;


    if (!bInited)
        DebugPrintfInit();

	if(bLogging != 2){
	    //error checking:
	    if (dwDetail >= 10)
	        return 1;

	    if ( (bDetailOn & (1<<dwDetail)) == 0 )
	        return 1;

	    if (bMute)
	        return 1;
	}        
    va_start(ap,dwDetail);
    WSPRINTF(cTopics,"%d",dwDetail);

    while ( (arg = va_arg(ap,DWORD)) <256 )
    {
        if (arg>0 && arg < LAST_TOPIC)
        {
            bMiscMessage=FALSE;
            if (DebugTopics[arg].bOn)
                bAllowed = TRUE;
        }
    }
    if (bMiscMessage)
        if (bAllowMisc || dwDetail == 0)
            bAllowed=TRUE;

    if ( bPrintAllTopics )
        bAllowed=TRUE;

    if (!bAllowed)
        return FALSE;

    szFormat = (LPSTR) arg;

    cMsg[0]=0;
    
    /*
     * Add the module name first
     */

    if (bPrintModuleName)
    {
        WSPRINTF( cMsg+strlen(cMsg),DPF_MODULE_NAME ":" );
    }

    if (bPrintExecutableName || bPrintTID || bPrintPID)
        WSPRINTF( cMsg+strlen(cMsg),"(");

#ifdef WIN32
#if 0
    /*
     * deleted due to RIP in GetModuleFilename on debug windows when win16 lock held
     */
    if (bPrintExecutableName)
    {
        GetModuleFileName(NULL,str,256);
        if (mystrrchr(str,'\\'))
            WSPRINTF(cMsg+strlen(cMsg),"%12s",mystrrchr(str,'\\')+1);
    }
#endif
    if (bPrintPID)
    {
        if (bPrintExecutableName)
            strcat(cMsg,",");
        WSPRINTF( cMsg+strlen(cMsg),"Px%02x",GetCurrentProcessId());
    }

    if (bPrintTID)
    {
        if (bPrintExecutableName || bPrintPID)
            strcat(cMsg,",");
        WSPRINTF( cMsg+strlen(cMsg),"Tx%04x",GetCurrentThreadId());
    }

    if (bPrintExecutableName || bPrintTID || bPrintPID)
        WSPRINTF( cMsg+strlen(cMsg),"):");
#endif

    if (bPrintFunctionName)
    {
        WSPRINTF( cMsg+strlen(cMsg),cFnName);
    }

    if (bPrintFileNames || bPrintLineNumbers)
    {
        if (mystrrchr(cFile,'\\'))
            WSPRINTF( cMsg+strlen(cMsg),":%12s",mystrrchr(cFile,'\\')+1 );
        else
            WSPRINTF( cMsg+strlen(cMsg),":%12s",cFile);
        WSPRINTF( cMsg+strlen(cMsg),"@%d",dwLineNo);
    }

    if (bPrintTopicsAndLevels)
    {
        WSPRINTF( cMsg+strlen(cMsg),"(%3s)",cTopics);
    }

    if (cMsg[strlen(cMsg)-1] != ':')
        WSPRINTF( cMsg+strlen(cMsg),":");

    if (bIndentOnMessageLevel)
    {
        for(i=0;(DWORD)i<dwDetail;i++)
            strcat(cMsg," ");
    }

    WVSPRINTF( cMsg+LSTRLEN( cMsg ), szFormat, ap);

    if (bAllowed)
        dumpStr( cMsg );

    va_end(ap);
    return 1;
    
}

void DebugSetMute(BOOL bMuteFlag)
{
    bMute=bMuteFlag;
}

void DebugEnterAPI(char *pFunctionName , LPDWORD pIface)
{
    // 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers and handles.
	DebugPrintf(2,A,"%p->%s",pIface,pFunctionName);
}

void DebugSetTopicsAndLevels(char * cTopics)
{
    int i;
    int j;
    bAllowMisc=TRUE;
    bBreakOnAsserts=FALSE;
    bPrintLineNumbers=FALSE;
    bPrintFileNames=FALSE;
    bPrintExecutableName=FALSE;
    bPrintTID=FALSE;
    bPrintPID=FALSE;
    bIndentOnMessageLevel=FALSE;
    bPrintTopicsAndLevels=FALSE;
    bPrintFunctionName=FALSE;
    bPrintAPIStats=FALSE;
    bPrintAllTopics=FALSE;
    bDetailOn=1;    /* always print detail level 0*/


    for (i=0;(DWORD)i<strlen(cTopics);i++)
    {
        switch (cTopics[i])
        {
        case '/':
        case '-':
            bAllowMisc=FALSE;
            break;
        case '!':
            bBreakOnAsserts=TRUE;
            break;
        case '@':
            bPrintLineNumbers=TRUE;
            break;
        case '$':
            bPrintFileNames=TRUE;
            break;
#if 0
            /*
             * Currently deleted because GetModuleFilename causes a RIP on debug windows when the win16
             * lock is held.
             */
        case '?':
            bPrintExecutableName=TRUE;
            break;
#endif
        case '^':
            bPrintTID=TRUE;
            break;
        case '#':
            bPrintPID=TRUE;
            break;
        case '>':
            bIndentOnMessageLevel=TRUE;
            break;
        case '&':
            bPrintTopicsAndLevels=TRUE;
            break;
        case '=':
            bPrintFunctionName=TRUE;
            break;
        case '%':
            bPrintAPIStats=TRUE;
            break;
        case '+':
            bPrintAllTopics=TRUE;
            break;
        default:
            if (cTopics[i]>='0' && cTopics[i]<='9')
            {
                if (cTopics[i+1]=='-')
                {
                    if (cTopics[i+2]>='0' && cTopics[i+2]<='9')
                    {
                        for(j=cTopics[i]-'0';j<=cTopics[i+2]-'0';j++)
                            bDetailOn |= 1<<j;
                        i+=2;
                    }
                }
                else
                    bDetailOn |= 1<<(cTopics[i]-'0');
            }
            else
            {
                for(j=0;j<LAST_TOPIC;j++)
                    if (cTopics[i]==DebugTopics[j].cFlag[0])
                        DebugTopics[j].bOn=TRUE;
            }
        } //end switch
    }
}


/*
 * NOTE: I don't want to get into error checking for buffer overflows when
 * trying to issue an assertion failure message. So instead I just allocate
 * a buffer that is "bug enough" (I know, I know...)
 */
#define ASSERT_BUFFER_SIZE   512
#define ASSERT_BANNER_STRING "************************************************************"
#define ASSERT_BREAK_SECTION "BreakOnAssert"
#define ASSERT_BREAK_DEFAULT FALSE
#define ASSERT_MESSAGE_LEVEL 0

void _DDAssert( LPCSTR szFile, int nLine, LPCSTR szCondition )
{
    char buffer[ASSERT_BUFFER_SIZE];

    /*
     * Build the debug stream message.
     */
    WSPRINTF( buffer, "ASSERTION FAILED! File %s Line %d: %s", szFile, nLine, szCondition );

    /*
     * Actually issue the message. These messages are considered error level
     * so they all go out at error level priority.
     */
    dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );
    dprintf( ASSERT_MESSAGE_LEVEL, buffer );
    dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );

    /*
     * Should we drop into the debugger?
     */
    if( bBreakOnAsserts || GETPROFILEINT( PROF_SECT, ASSERT_BREAK_SECTION, ASSERT_BREAK_DEFAULT ) )
    {
	/*
	 * Into the debugger we go...
	 */
	DEBUG_BREAK();
    }
}


#ifdef cplusplus
}
#endif

#endif //defined debug
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\misc\newdpf.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       newdpf.h
 *  Content:    new debug printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   10-oct-95  jeffno  initial implementation
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DEBUGPF_H
#define __DEBUGPF_H

#include <stdarg.h>
#include <windows.h>

#ifdef __cplusplus
	extern "C" {
#endif
#ifndef DPF_MODNAME
    extern char * DPF_MODNAME;
#endif

#if defined(DEBUG) || defined(DBG)

    #undef DEBUG_TOPIC
    #define DEBUG_TOPIC(flag,name) flag,
    typedef enum DEBUG_TOPICS {
        A=1,    /* For API Usage */
    #include "DBGTOPIC.H"
        LAST_TOPIC
    };

    #line 21
/*
    #undef DBG
    #define DBG 1
    */
    #undef DEBUG
    #define DEBUG
    #if defined( _WIN32 ) && !defined(WINNT)
	#define DEBUG_BREAK()       _try { _asm { int 3 } } _except (EXCEPTION_EXECUTE_HANDLER) {;}
    #else
	#define DEBUG_BREAK()       DebugBreak()
    #endif


    /*
     * DEBUG_TOPIC
     * This structure describes a debugging topic and associates a single-letter key to it.
     */

    #define DEBUG_TOPIC_NAME_LENGTH 59
    typedef struct
    {
        DWORD   dwSize; //for versioning
        char    cKey;
        char    cName[DEBUG_TOPIC_NAME_LENGTH];
    } DPF_DEBUG_TOPIC;

    /*
     * PROC_STATS
     * This struct saves statistics about each proc as maintained by DebugEnterProc
     */
    typedef struct
    {
        char            cName[DEBUG_TOPIC_NAME_LENGTH];
        DWORD           dwCalls;
#ifdef WIN32
        LARGE_INTEGER   liTotalTime;
        LARGE_INTEGER   liLastEnteredAt;
#else
        DWORD           dwFiller[8];
#endif
    } DPF_PROC_STATS;

    #define MAX_PROC_ORDINAL 100

    /*
     * Debugging output/flow-control calls
     */
   extern void DebugSetTopicsAndLevels(char * pcTopicsAndLevelsToDisplay);
   extern void DebugHalt(void);       //Break if control level allows
   extern int  DebugSetFileLineEtc(LPSTR szFile, DWORD dwLineNumber,LPSTR szFnName);
   extern int  DebugPrintf(DWORD dwDetail, ...);
   extern void DebugSetMute(BOOL bMuteFlag);
   extern void DebugPrintfInit(void);
   extern void DebugEnterAPI(char *,LPDWORD);
   extern void _DDAssert(LPCSTR szFile, int nLine, LPCSTR szCondition);
 
    #define dprintf(a,b)                            DebugPrintf(a,b);
    #define DPFINIT()                               DebugPrintfInit();
    #define DPF                                     DebugSetFileLineEtc(__FILE__,__LINE__,DPF_MODNAME),DebugPrintf
    #define DPF_ERR(a)                              DebugSetFileLineEtc(__FILE__,__LINE__,DPF_MODNAME),DebugPrintf( 0, a )
    #define DPF_ENTERAPI(pIface)                    DebugEnterAPI(DPF_MODNAME,(LPDWORD)pIface)
    #define DPF_APIRETURNS(hr)                      DPF(3,"   %s returns %08x (%d)",DPF_MODNAME,hr,hr&0xfff)
    #define DDASSERT(condition)                     if (!(condition)) _DDAssert(__FILE__, __LINE__, #condition)
    #define DPF_MUTEWHEN(c)                         {DebugSetMute((BOOL) (c) );}
    #define DPF_SPEWWHEN(c)                         {DebugSetMute((BOOL) (!(c)) );}
    #define DPF_SETTOPICS(t)
    #define DPF_STRUCT(level,topic,struct_identifier,struct_ptr)    {extern void DUMP_##struct_identifier(DWORD,DWORD,LP##struct_identifier);\
                                                    DUMP_##struct_identifier(level,topic,struct_ptr);}


#else
    #pragma warning(disable:4002)
    #define dprintf()
    #define DPFINIT()
    #define DPFFINI()
    #define DPF()
    #define DPF_ENTERAPI()
    #define DPF_APIRETURNS()
    #define DPF_DUMP()
    #define DPF_DUMPHEX()
    #define DPF_DUMPGUID()
    #define DDASSERT()
    #define DPF_ERR()
    #define DEBUG_BREAK()
    #define DPF_MUTEWHEN()
    #define DPF_SPEWWHEN()
    #define DPF_SETTOPICS()
    #define DPF_DUMPGUID()
    #define DPF_STRUCT()

#endif


#ifdef _WIN32

#ifdef DEBUG
    __inline DWORD myclockrate() {LARGE_INTEGER li; QueryPerformanceFrequency(&li); return li.LowPart;}
    __inline DWORD myclock()	 {LARGE_INTEGER li; QueryPerformanceCounter(&li);   return li.LowPart;}

    #define TIMEVAR(t)    DWORD t ## T; DWORD t ## N
    #define TIMEZERO(t)   t ## T = 0, t ## N = 0
    #define TIMESTART(t)  t ## T -= myclock(), t ## N ++
    #define TIMESTOP(t)   t ## T += myclock()
    #define TIMEFMT(t)	  ((DWORD)(t) / myclockrate()), (((DWORD)(t) * 1000 / myclockrate())%1000)
    #define TIMEOUT(t)    if (t ## N) DPF(1, #t ": %ld calls, %ld.%03ld sec (%ld.%03ld)", t ## N, TIMEFMT(t ## T), TIMEFMT(t ## T / t ## N))
#else
    #define TIMEVAR(t)
    #define TIMEZERO(t)
    #define TIMESTART(t)
    #define TIMESTOP(t)
    #define TIMEFMT(t)
    #define TIMEOUT(t)
#endif

#endif


#ifdef __cplusplus
}
#endif

#endif //__DEBUG_PF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\misc\w95help.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       w95help.h
 *  Content:	header file for Win95 helper interface
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   06-apr-95	craige	initial implementation
 *   29-nov-95  angusm  added HelperCreateDSFocusThread
 *   18-jul-96	andyco	added Helper(Add/)DeleteDPlayServer
 *   12-oct-96  colinmc added new service to get DDHELP to get its own handle
 *                      for communicating with the DirectSound VXD
 *   22-jan-97  kipo	return an HRESULT from HelperAddDPlayServer()
 *
 ***************************************************************************/
#ifndef __W95HELP_INCLUDED__
#define __W95HELP_INCLUDED__
#include "ddhelp.h"

#ifdef __cplusplus
extern "C" {
#endif

extern void SignalNewProcess( DWORD pid, LPHELPNOTIFYPROC proc );

extern void SignalNewDriver( LPSTR fname, BOOL isdisp );

extern BOOL CreateHelperProcess( LPDWORD ppid );

extern void DoneWithHelperProcess( void );

extern BOOL WaitForHelperStartup( void );

extern DWORD HelperLoadDLL( LPSTR dllname, LPSTR fnname, DWORD context );

extern void HelperCreateThread( void );

extern DWORD HelperWaveOpen( LPVOID lphwo, DWORD dwDeviceID, LPVOID pwfx );

extern DWORD HelperWaveClose( DWORD hwo );

extern DWORD HelperCreateTimer( DWORD dwResolution,LPVOID pTimerProc,DWORD dwInstanceData );

extern DWORD HelperKillTimer( DWORD dwTimerID );

#ifdef _WIN32
extern HANDLE HelperCreateDSMixerThread( LPTHREAD_START_ROUTINE pfnThreadFunc,
					 LPVOID pThreadParam,
					 DWORD dwFlags,
					 LPDWORD pThreadId );

extern HANDLE HelperCreateDSFocusThread( LPTHREAD_START_ROUTINE pfnThreadFunc,
					 LPVOID pThreadParam,
					 DWORD dwFlags,
					 LPDWORD pThreadId );

extern void HelperCallDSEmulatorCleanup( LPVOID pCleanupFunc,
                                         LPVOID pDirectSound );

#endif

extern BOOL HelperCreateModeSetThread( LPVOID callback, HANDLE *ph, LPVOID lpdd, DWORD hInstance );

extern BOOL HelperCreateDOSBoxThread( LPVOID callback, HANDLE *ph, LPVOID lpdd, DWORD hInstance );

extern void HelperKillModeSetThread( DWORD hInstance );

extern void HelperKillDOSBoxThread( DWORD hInstance );

extern DWORD HelperAddDPlayServer(DWORD port);
extern BOOL HelperDeleteDPlayServer();

#ifdef WIN95
extern HANDLE HelperGetDSVxd( void );
#endif

extern void HelperSetOnDisplayChangeNotify( void *pfn );

#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\protocol\arpd.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ARPD.H

Abstract:

	Include file for Another Reliable Protocol internal, CPP version

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
  12/10/96 aarono  Original

--*/

#ifndef _ARPD_H_
#define _ARPD_H_

typedef VOID (*PSEND_CALLBACK)(PVOID Context,UINT Status);

typedef struct _ASYNCSENDINFO {
	UINT            Reserved[4];
	HANDLE 			hEvent;			// Event to signal on send complete.
	PSEND_CALLBACK	SendCallBack;   // Callback to call on send complete.
	PVOID           CallBackContext;// Context for callback.
	PUINT			pStatus;        // place to put status on completion.
} ASYNCSENDINFO, *PASYNCSENDINFO;

#define SEND_STATUS_QUEUED			0x00000001
#define SEND_STATUS_TRANSMITTING	0x00000002
#define SEND_STATUS_FAILURE  		0x80000003
#define SEND_STATUS_SUCCESS			0x80000004

#endif //_ARPD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\protocol\arpdint.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ARPDINT.H

Abstract:

	Include file for Another Reliable Protocol internal.

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
  12/10/96 aarono  Original
   2/16/98 aarono  Don't patch for Protocol, DPLAY now calls direct.
   6/6/98  aarono  Turn on throttling and windowing
   2/12/00 aarono  Concurrency issues, fix VOL usage and Refcount

--*/

#ifndef _ARPDINT_H_

#define _ARPDINT_H_

#include <dplay.h>
#include "arpd.h"
#include "bilink.h"
#include "arpstruc.h"
#include "protocol.h"
#include "bufmgr.h"
#include "handles.h"

// Macros for converting too and from 24.8 fixed point.
#define Fp(_x) ((_x)<<8)
#define unFp(_x)((_x)>>8)

typedef enum _PROTOCOL_State {
	Initializing=1,
	Running,
	ShuttingDown,
	ShutDown
} PROTOCOL_State;

#define MAX_THREADS 16

typedef struct PROTOCOL {
		//
		// Service Provider info - at top so DPLAY can access easily through protocol ptr.
		//
		IDirectPlaySP   * m_lpISP;      	       	 	//  used by SP to call back into DirectPlay 

		DWORD             m_dwSPMaxFrame;
		DWORD             m_dwSPMaxGuaranteed;
		DWORD             m_dwSPHeaderSize;
		CRITICAL_SECTION  m_SPLock;						// lock calls to SP on our own, avoids deadlocks.

		//
		// Protocol Info
		//
		
VOL		UINT 	  	  	  m_cRef;		// Refcount.
		CRITICAL_SECTION  m_ObjLock;	// lock for this object.
VOL		PROTOCOL_State    m_eState;		// State of object

VOL		LPDPLAYI_DPLAY    m_lpDPlay;	// backpointer to DPLAY object.

		// Handle Table
		VOLLPMYHANDLETABLE lpHandleTable;
		CRITICAL_SECTION   csHandleTable;

		// Cached DPLAY info.
		DWORD             m_dwIDKey;    // to unlock DPID's
		
		//
		// Threads
		//
		HANDLE            m_hSendThread[MAX_THREADS];	// send thread handles (0->nSendThreads)
		DWORD             m_dwSendThreadId[MAX_THREADS];// send thread ids (0->nSendThreads)
VOL		UINT              m_nSendThreads;				// number of send threads.
VOL		HANDLE            m_hSendEvent;                 // kick send until nothing to send.

		//
		// Multi-media timer capabilities
		//
		TIMECAPS          m_timecaps;					// {.wPeriodMin .wPeriodMax (ms)}

		//
	    // SESSIONion Handles
	    //
		CRITICAL_SECTION  m_SessionLock;
VOL		UINT              m_nSessions;
VOL		UINT              m_SessionListSize;
VOL		PSESSION          (*m_pSessions)[];
VOL		PSESSION          m_pServerPlayerSession;		// Short circuit to index 0xFFFE
		
		//
		// Priority Queue
		//
VOL		DWORD             m_dwBytesPending;
VOL		DWORD             m_dwMessagesPending;
		CRITICAL_SECTION  m_SendQLock;         			// Locks the Priority Queue.
		BILINK            m_GSendQ;						// Packet Queue in priority order.
VOL		BOOL              m_bRescanQueue;               // Used for force GetNextMessageToSend to restart

		
		CRITICAL_SECTION  m_RcvQLock;           		// All completed receives lock. (locks on SESSION too).
		BILINK            m_GlobalRcvQ;					// All receives queued here, (also on each session).


		//
		// Receive Descriptor Management - per instance because of SPHeader length.
		//
		
VOL		PRECEIVE 		 pRcvDescPool;
VOL		UINT             nRcvDescsAllocated;	// Number Allocated
VOL		UINT             nRcvDescsInUse;		// Number currently in use
VOL		UINT             nMaxRcvDescsInUse;     // Maximum number in use since last TICK.

		CRITICAL_SECTION RcvDescLock;
		
VOL		LONG fInRcvDescTick;					

} PROTOCOL, *PPROTOCOL;

// PROTOCOL.C
HRESULT WINAPI ProtocolSend(LPDPSP_SENDDATA pSendData);
HRESULT WINAPI ProtocolCreatePlayer(LPDPSP_CREATEPLAYERDATA pCreatePlayerData);
HRESULT WINAPI ProtocolDeletePlayer(LPDPSP_DELETEPLAYERDATA pDeletePlayerData);
HRESULT WINAPI ProtocolGetCaps(LPDPSP_GETCAPSDATA pGetCapsData);
HRESULT WINAPI ProtocolShutdown(void);
HRESULT WINAPI ProtocolShutdownEx(LPDPSP_SHUTDOWNDATA pShutdownData);

//
// SENDPOOL.CPP
//
VOID  InitSendDescs(VOID);
VOID  FiniSendDescs(VOID);
PSEND GetSendDesc(VOID);
VOID  ReleaseSendDesc(PSEND pSend);

//
// STATPOOL.CPP
//
VOID InitSendStats(VOID);
VOID FiniSendStats(VOID);
PSENDSTAT GetSendStat(VOID);
VOID ReleaseSendStat(PSENDSTAT pSendStat);

//
// RCVPOOL.CPP
//
VOID InitRcvDescs(PPROTOCOL pProtocol);
VOID FiniRcvDescs(PPROTOCOL pProtocol);
PRECEIVE GetRcvDesc(PPROTOCOL pProtocol);
VOID ReleaseRcvDesc(PPROTOCOL pProtocol, PRECEIVE pReceive);

// FRAMEBUF.CPP 
VOID InitFrameBuffers(VOID);
VOID FiniFrameBuffers(VOID);
VOID FreeFrameBuffer(PBUFFER pBuffer);
PBUFFER GetFrameBuffer(UINT MaxFrame);
VOID ReleaseFrameBufferMemory(PUCHAR pFrame);

// SEND.C
VOID UpdateSendTime(PSESSION pSession, DWORD Len, DWORD tm, BOOL fAbsolute);
HRESULT SendHandler(PPROTOCOL pProt);
VOID BuildHeader(PSEND pSend, pPacket1 pFrame, UINT shift, DWORD tm);
ULONG WINAPI SendThread(LPVOID pProt);
INT IncSendRef(PSEND pSend);
INT DecSendRef(PPROTOCOL pProt, PSEND pSend);
BOOL AdvanceSend(PSEND pSend, UINT FrameDataLen);
VOID CancelRetryTimer(PSEND pSend);
VOID DoSendCompletion(PSEND pSend, INT Status);

HRESULT Send(
	PPROTOCOL      pProtocol,
	DPID           idFrom, 
	DPID           idTo, 
	DWORD          dwSendFlags, 
	LPVOID         pBuffers,
	DWORD          dwBufferCount, 
	DWORD          dwSendPri,
	DWORD          dwTimeOut,
	LPVOID         lpvUserID,
	LPDWORD        lpdwMsgID,
	BOOL           bSendEx,		// called from SendEx.
	PASYNCSENDINFO pAsyncInfo
	);
	
HRESULT ISend(
	PPROTOCOL pProtocol,
	PSESSION pSession, 
	PSEND    pSend
	);

HRESULT QueueSendOnSession(
	PPROTOCOL pProtocol, PSESSION pSession, PSEND pSend
);

UINT CopyDataToFrame(
	PUCHAR  pFrameData, 
	UINT    FrameDataLen,
	PSEND   pSend,
	UINT    nAhead);

ULONG WINAPI SendThread(LPVOID pProt);
HRESULT ReliableSend(PPROTOCOL pProtocol, PSEND pSend);
BOOL AdvanceSend(PSEND pSend, UINT AckedLen);
HRESULT DGSend(PPROTOCOL pProtocol, PSEND  pSend);
BOOL DGCompleteSend(PSEND pSend);
HRESULT SystemSend(PPROTOCOL pProtocol, PSEND  pSend);
PSEND GetNextMessageToSend(PPROTOCOL pProtocol);
VOID TimeOutSession(PSESSION pSession);
INT AddSendRef(PSEND pSend, UINT count);

extern CRITICAL_SECTION g_SendTimeoutListLock;
extern BILINK g_BilinkSendTimeoutList;

//RECEIVE.C
UINT CommandReceive(PPROTOCOL pProt, CMDINFO *pCmdInfo, PBUFFER pBuffer);
VOID ProtocolReceive(PPROTOCOL pProtocol, WORD idFrom, WORD idTo, PBUFFER pRcvBuffer, LPVOID pvSPHeader);
VOID FreeReceive(PPROTOCOL pProtocol, PRECEIVE pReceive);
VOID InternalSendComplete(PVOID Context, UINT Status);

//SESSION.C
LPDPLAYI_PLAYER pPlayerFromId(PPROTOCOL pProtocol, DPID idPlayer);
HRESULT	CreateNewSession(PPROTOCOL pProtocol, DPID idPlayer);
PSESSION GetSession(PPROTOCOL pProtocol, DPID idPlayer);
PSESSION GetSysSession(PPROTOCOL pProtocol, DPID idPlayer);
PSESSION GetSysSessionByIndex(PPROTOCOL pProtocol, DWORD index);
DPID GetDPIDByIndex(PPROTOCOL pProtocol, DWORD index);
WORD GetIndexByDPID(PPROTOCOL pProtocol, DPID dpid);
INT DecSessionRef(PSESSION pSession);

//BUFGMGR.C
VOID InitBufferManager(VOID);
VOID FiniBufferManager(VOID);
UINT MemDescTotalSize(PMEMDESC pMemDesc, UINT nDesc);
PDOUBLEBUFFER GetDoubleBuffer(UINT nBytes);
PBUFFER GetDoubleBufferAndCopy(PMEMDESC pMemDesc, UINT nDesc);
VOID FreeDoubleBuffer(PBUFFER pBuffer);
PBUFFER BuildBufferChain(PMEMDESC pMemDesc, UINT nDesc);
VOID FreeBufferChain(PBUFFER pBuffer);
VOID FreeBufferChainAndMemory(PBUFFER pBuffer);
UINT BufferChainTotalSize(PBUFFER pBuffer);

//STATS.C
VOID InitSessionStats(PSESSION pSession);
VOID UpdateSessionStats(PSESSION pSession, PSENDSTAT pStat, PCMDINFO pCmdInfo, BOOL fBadDrop);
VOID UpdateSessionSendStats(PSESSION pSession, PSEND pSend, PCMDINFO pCmdInfo, BOOL fBadDrop);


#define SAR_FAIL 0
#define SAR_ACK  1
#define SAR_NACK 2
UINT SendAppropriateResponse(PPROTOCOL pProt, PSESSION pSession, CMDINFO *pCmdInfo, PRECEIVE pReceive);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\protocol\arpstruc.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ARPSTRUC.H

Abstract:

	Structure definitions for the ARP protocol implementation

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date    Author  Description
   =======  ======  ============================================================
   1/27/97  aarono  Original
   2/18/98  aarono  Added more fields to SEND for SendEx support
   6/6/98   aarono  Turn on throttling and windowing
   2/12/00  aarono  Concurrency issues, fix VOL usage and Refcount

--*/

#ifndef _ARPSTRUC_H_
#define _ARPSTRUC_H_

#include <windows.h>
#include <mmsystem.h>
#include <dplay.h>
#include "arpd.h"
#include "bufpool.h"
#include "bilink.h"
#include "mydebug.h"
//#include "threads.h"

//#pragma warning( disable : 4090)

#define VOL volatile
//
// Information about sent packets, tracked for operational statistics.
//

#define SENDSTAT_SIGN SIGNATURE('S','T','A','T')

typedef struct PROTOCOL *PPROTOCOL;

typedef struct _SENDSTAT {
#ifdef SIGN
	UINT				Signature;		// Signature for SIGN
#endif
	union {
		BILINK	StatList;		// linked on Send and later SESSION.
		struct _SENDSTAT *pNext;
	};	
	UINT    messageid;   
	UINT    sequence;		// sequence number
	UINT    serial;			// serial number
	UINT    tSent;			// tick time when this packet instance sent.
	UINT    LocalBytesSent;     // number of bytes sent on session at send time.
	UINT    RemoteBytesReceived;// last remote byte report at send time.
	UINT    tRemoteBytesReceived; // remote timestamp when received.
	UINT    bResetBias;
} SENDSTAT, *PSENDSTAT;

#define SEND_SIGN SIGNATURE('S','E','N','D')

typedef enum _TRANSMITSTATE {
	Start=0,			// Never sent a packet.
	Sending=1,			// Thread to send is running and xmitting.
	Throttled=2,		// Waiting for send bandwidth.
	WaitingForAck=3,	// Timer running, listening for ACKs.
	WaitingForId=4,   	// Waiting for a Send Id.
	ReadyToSend=5,		// Have stuff to xmit, waiting for thread.
	TimedOut=6,       	// Retry timed out.
	Cancelled=7,        // User cancelled send.
	UserTimeOut=8,		// Didn't try to send until too late.
	Done=9				// Finished sending, singalled sender.
	
} TRANSMITSTATE;

struct _SESSION;

// this Send is an ACK or NACK (OR'ed into SEND.dwFlags)
#define 	ASEND_PROTOCOL 	0x80000000

#pragma pack(push,1)

typedef struct _SEND{

#ifdef SIGN
	UINT		     Signature;		    // Signature for SIGN
#endif
	CRITICAL_SECTION SendLock;          // Lock for Send Structure
	UINT             RefCount;          // @#$%! - not marked volatile since accessed only with Interlocked fns.
	
VOL	TRANSMITSTATE    SendState;			// State of this message's transmission.

	// Lists and Links...
	
	union {
		struct _SEND *pNext;			// linking on free pool
		BILINK		   SendQ;			// linking on session send queue
	};
	BILINK         m_GSendQ;			// Global Priority Queue
	BILINK         TimeoutList;			// List of sends waiting for timeout (workaround MMTIMER cancel bug).
	struct _SESSION *pSession;          // pointer to SESSIONion(gets a ref)

	PPROTOCOL      pProtocol;           // pointer to Protocol instance that created us.

	// Send Information
	
	DPID           idFrom;
	DPID           idTo;
	WORD           wIdTo;				// index in table
	WORD           wIdFrom;             // index in table
	UINT		   dwFlags;             // Send Flags (include reliable)
	PBUFFER		   pMessage;			// Buffer chain describing message.
	UINT           MessageSize;			// Total size of the message.
	UINT           FrameDataLen;        // Data area of each frame.
	UINT           nFrames;			    // Number of frames for this message.

	UINT           Priority;            // Send Priority.

	// User cancel and complete info
	DWORD          dwMsgID;             // message id given to user, for use in cancel.
	LPVOID         lpvUserMsgID;		// user's own identifier for this send.
	BOOL           bSendEx;             // called through SendEx.

	// Vars for reliability
	BOOL           fSendSmall;
VOL BOOL       	   fUpdate;             // update to NS,NR NACKMask made by receive.
	UINT		   messageid;			// Message ID number.
	UINT           serial;              // serial number.
VOL	UINT		   OpenWindow;          // Number of sends we are trying to get outstanding
VOL	UINT           NS;		        	// Sequence Sent.
VOL	UINT           NR;					// Sequence ACKED.
	UINT           SendSEQMSK; 			// Mask to use. 
VOL	UINT           NACKMask;            // Bit pattern of NACKed frames.
	

	// These are the values at NR - updated by ACKs
VOL	UINT		   SendOffset;			// Current offset we are sending.
VOL	PBUFFER        pCurrentBuffer;  	// Current buffer being sent.
VOL	UINT           CurrentBufferOffset; // Offset in the current buffer of next packet.

	// info to update link characteristics when ACKs come in.
	
	BILINK         StatList;			// Info for packets already sent.
	DWORD          BytesThisSend;		// number of bytes being sent in the current packet.

	// Operational Characteristics

VOL	UINT_PTR       uRetryTimer;         
    UINT           TimerUnique;

	UINT           RetryCount;          // Number of times we retransmitted.
	UINT           WindowSize;          // Maximum Window Size.
	UINT           SAKInterval;         // interval (frames) at which a SAK is required.
	UINT           SAKCountDown;		// countdown to 0 from interval.
	UINT           tLastACK;            // Time we last got an ACK.

	UINT           dwSendTime;			// time we were called in send.
	UINT           dwTimeOut;			// timeout time.

	UINT           PacketSize;          // Size of packets to send.
	UINT           FrameSize;           // Size of Frames for this send.

	// Completion Vars
	HANDLE         hEvent;              // Event to wait on for internal send.
	UINT           Status;              // Send Completion Status.

	PASYNCSENDINFO pAsyncInfo;          // ptr to Info for completing Async send(NULL=>internal send)
	ASYNCSENDINFO  AsyncInfo;           // actual info (copied at send call).

	DWORD		   tScheduled;			// the time we scheduled the retry;
	DWORD          tRetryScheduled;     // expected retry timer run time.
VOL	BOOL           bCleaningUp;			// we are on the queue but don't take a ref pls.
} SEND, *PSEND;

#pragma pack(pop)

#define RECEIVE_SIGN SIGNATURE('R','C','V','_')


// Receive buffers are in reverse receive order.  When they have all
// been received, they are then put in proper order.
typedef struct _RECEIVE {
#ifdef SIGN
	UINT		    Signature;		// Signature for SIGN
#endif
	union {
		BILINK          pReceiveQ;
		struct _RECEIVE *      pNext;
	};	
	BILINK		    RcvBuffList;     // List of receive buffers that make up the message.

	CRITICAL_SECTION ReceiveLock;

	struct _SESSION *pSession;

VOL	BOOL            fBusy;		// Someone is moving this receive.
	BOOL            fReliable;		// Whether this is a reliable receive.
VOL	BOOL            fEOM;           // Whether we received the EOM bit.

	UINT            command;      
	
	UINT			messageid;
VOL	UINT			MessageSize;

VOL	UINT            iNR;			// Absolute index of first receiving packet (reliable only).
VOL	UINT            NR;				// Last in sequence packet received.
VOL	UINT            NS;				// Highest packet number received.
VOL	UINT            RCVMask;		// bitmask of received packets (NR relative)

	PUCHAR          pSPHeader;
	UCHAR           SPHeader[0];

} RECEIVE, *PRECEIVE;

#pragma pack(push,1)

typedef struct _CMDINFO {
	WORD        wIdTo;		// index
	WORD        wIdFrom;	// index
	DPID        idTo;		// actual DPID
	DPID        idFrom;		// actual DPID
	
	UINT        bytes;      // read from ACK.
	DWORD       tRemoteACK; // remote time remote ACKed/NACKed
	
	UINT        tReceived;  // timeGetTime() when received.
	UINT        command;
	UINT        IDMSK;
	USHORT      SEQMSK;
	USHORT      messageid;
	USHORT      sequence;
	UCHAR       serial;
	UCHAR		flags;
	PVOID       pSPHeader;  // used to issue a reply.
} CMDINFO, *PCMDINFO;

#pragma pack(pop)


#define SESSION_SIGN SIGNATURE('S','E','S','S')

// since we now have a full byte for messagid and sequenne in the small headers, 
// we no longer have an advantage for full headers until we apply the new
// bitmask package, then we must transit to large frame for windows > 127 messages.

#define MAX_SMALL_CSENDS 	 29UL			// Maximum Concurrent Sends when using small frame headers
#define MAX_LARGE_CSENDS	 29UL			// Maxinum Concurrent Sends when using large frame headers (could make larger except for mask bits)
#define MAX_SMALL_DG_CSENDS  16UL			// Maximum concurrent datagrams when using small frame     
#define MAX_LARGE_DG_CSENDS  16UL           // Maximum Concurrent datagrams when using large frames.
#define MAX_SMALL_WINDOW     24UL
#define MAX_LARGE_WINDOW     24UL

typedef enum _SESSION_STATE {
	Open,				// When created and Inited.
	Closing,			// Don't accept new receives/sends.
	Closed				// gone.
} SESSION_STATE;

#define SERVERPLAYER_INDEX 0xFFFE

#define SESSION_THROTTLED			0x00000001		// session throttle is on.
#define SESSION_UNTHROTTLED         0x00000002		// unthrottle is deffered to avoid confusing GetMessageQueue.

/////////////////////////////////////////////////////////////////
//
//	Transition Matrix for Throttle Adjust
// 
//  Initial State	Event:
//					No Drops	1 Drop		>1 Drop
//
//  Start			+ Start		- Meta      -- Start
//								
//  Meta			+ Meta      - Stable    -- Meta
//
//  Stable          + Stable    - Stable    -- Meta
//
//
//  Engagement of Backlog Throttle goes to MetaStable State.
///////////////////////////////////////////////////////////////////

#define METASTABLE_GROWTH_RATE      4
#define METASTABLE_ADJUST_SMALL_ERR	12
#define METASTABLE_ADJUST_LARGE_ERR 25

#define START_GROWTH_RATE      50
#define START_ADJUST_SMALL_ERR 25
#define START_ADJUST_LARGE_ERR 50

#define STABLE_GROWTH_RATE      2
#define STABLE_ADJUST_SMALL_ERR 12
#define STABLE_ADJUST_LARGE_ERR 25

typedef enum _ThrottleAdjustState
{
	Begin=0,		// At start, double until drop or backlog
	MetaStable=1,	// Meta stable, large deltas for drops
	Stable=2		// Stable, small deltas for drops
} eThrottleAdjust;

typedef struct _SESSION {
	PPROTOCOL        pProtocol;			    // back ptr to object.

#ifdef SIGN
	UINT		  	 Signature;			    // Signature for SIGN
#endif

	// Identification

	CRITICAL_SECTION SessionLock;           // Lock for the SESSIONion.
	UINT             RefCount;			    // RefCount for the SESSION. - not vol, only accessed with Interlocked
VOL	SESSION_STATE    eState;
	HANDLE           hClosingEvent;         // Delete waits on this during close.
	
	DPID			 dpid;					// The remote direct play id for this session.
	UINT             iSession;              // index in the session table
	UINT             iSysPlayer;            // index in session table of sys player.
											// NOTE: if iSysPlayer != iSession, then rest of struct not req'd.

	BILINK			 SendQ;					// Priority order sendQ;
	BOOL             fFastLink;				// set True when link > 50K/sec, set False when less than 10K/sec.
	BOOL             fSendSmall;            // Whether we are sending small reliable frames.
	BOOL             fSendSmallDG;          // Whether we are sending small datagram frames.

	BOOL             fReceiveSmall;
	BOOL             fReceiveSmallDG;
											
	UINT			 MaxPacketSize;			// Largest packet allowed on the media.

	// Operating parameters -- Send

	// Common
	
	UINT             MaxCSends;				// maximum number of concurrent sends
	UINT             MaxCDGSends;           // maximum number of concurrent datagram sends

	// Reliable

VOL	UINT			 FirstMsg;				// First message number being transmitted
VOL	UINT			 LastMsg;				// Last message number being transmitted
VOL	UINT             OutMsgMask;            // relative to FirstMsg, unacked messages

	UINT             nWaitingForMessageid;  // number of sends on queue that can't start sending because they don't have an id.

	// DataGram


VOL	UINT             DGFirstMsg;             // First message number being transmitted
VOL	UINT             DGLastMsg;              // Last message number being transmitted
VOL	UINT             DGOutMsgMask;           // relative to FirstMsg, not-fully sent messages.

	UINT             nWaitingForDGMessageid; // number of sends on queue that can't start sending because they don't have an id.

	// Send stats are tracked seperately since sends may
	// no longer be around when completions come in.
	
	//BILINK           OldStatList;		
	

	// Operating parameters -- Receive

	// DataGram Receive.
	BILINK           pDGReceiveQ;            // queue of ongoing datagram receives

	// Reliable Receive.
	BILINK	         pRlyReceiveQ;			 // queue of ongoing reliable receives
	BILINK           pRlyWaitingQ;           // Queue of out of order reliable receives waiting.
											 // only used when PROTOCOL_NO_ORDER not set.
VOL	UINT             FirstRlyReceive;
VOL	UINT             LastRlyReceive;
VOL	UINT             InMsgMask;              // mask of fully received receives, relative to FirstRlyReceive
 

	// Operational characteristics - MUST BE DWORD ALIGNED!!! - this is because we read and write them
	//                               without a lock and assume the reads and writes are atomic (not in combination)

	UINT             WindowSize;            // Max outstanding packets on a send - reliable
	UINT             DGWindowSize;          // Max outstanding packets on a send - datagram
	
	UINT             MaxRetry;				// Usual max retries before dropping.
	UINT             MinDropTime;			// Min time to retry before dropping.
	UINT             MaxDropTime;			// After this time always drop.

VOL	UINT             LocalBytesReceived;    // Total Data Bytes received (including retries).
VOL	UINT             RemoteBytesReceived;   // Last value from remote.
VOL	DWORD            tRemoteBytesReceived;  // Remote time last value received.

	UINT			 LongestLatency;		// longest observed latency (msec)
	UINT             ShortestLatency;		// shortest observed latency(msec)
	UINT             LastLatency;           // last observed latency (msec)
	
	UINT             FpAverageLatency;		// average latency          (msec 24.8) (128 samples)
	UINT             FpLocalAverageLatency;	// Local average latency    (msec 24.8) (16 samples)

	UINT             FpAvgDeviation;        // average deviation of latency. (msec 24.8) (128 samples)
	UINT             FpLocalAvgDeviation;   // average deviation of latency. (msec 24.8) (16 samples)

	UINT             Bandwidth;				// latest observed bandwidth (bps)
	UINT			 HighestBandwidth;      // highest observed bandwidth (bps)

	// we will use changes in the remote ACK delta to isolate latency in the send direction.
	UINT             RemAvgACKDelta;		// average clock delta between our send time (local time) and remote ACK time (remote time).
	UINT             RemAvgACKDeltaResidue;
	UINT             RemAvgACKBias;			// This value is used to pull the clock delta into a safe range (not near 0 or -1)
											// that won't risk hitting the wraparound when doing calculations

	// Throttle statistics
	DWORD			 dwFlags;               // Session Flags - currently just "throttle on/off"(MUST STAY THIS WAY)
	UINT			 SendRateThrottle;	    // current rate (bps) at which we are throttling.
	DWORD            bhitThrottle;          // we hit a throttle
	DWORD            tNextSend;				// when we are allowed to send again.
	DWORD            tNextSendResidue;		// residual from calculating next send time
	DWORD_PTR		 uUnThrottle;
	DWORD            UnThrottleUnique;
	DWORD            FpAvgUnThrottleTime;   // (24.8) how late Unthrottle usually called. (throttle when send is this far ahead)
											// last 16 samples, start at 5 ms.

	DWORD            tLastSAK;				// last time we asked for an ACK

	CRITICAL_SECTION SessionStatLock;        // [locks this section ------------------------------------------- ]
	BILINK           DGStatList;             // [Send Statistics for Datagrams (for reliable they are on Sends) ]
	DWORD            BytesSent;				 // [Total Bytes Sent to this target                                ]
	DWORD			 BytesLost;				 // [Total Bytes Lost on the link.							 		]
	DWORD            bResetBias;             // [Counts down to reset latency bias								]
											 // [---------------------------------------------------------------]

	eThrottleAdjust  ThrottleState;			// ZEROINIT puts in Start
	DWORD            GrowCount;				// number of times we grew in this state
	DWORD            ShrinkCount;			// number of times we shrank in this state
	DWORD            tLastThrottleAdjust;   // remember when we last throttled to avoid overthrottling.
} SESSION, *PSESSION;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\protocol\bilink.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    BILINK.C

Abstract:

    Management for doubly linked lists

Author:

    George Joy

Environment:

    32-bit 'C'

Revision History:

--*/
#include <windows.h>
#include "newdpf.h"
#include <dplaypr.h>
#include "bilink.h"
#include "mydebug.h"

// Note: serialization of access to BILINK structures must 
//       take place in the calling code.  Operations are
//       not intrinsically atomic.

#ifdef DEBUG
int FindObject(
    BILINK *link,
    BILINK *list
    )
{
    BILINK *p = list->next;
    while(p != link && p != list)
        p= p->next;
    return (p==link);
}
#endif

void InsertAfter(
    BILINK *in,
    BILINK *after
    )
/*=========================================================================
 *  Description:
 *      Insert an object after a specified object in the doubly linked list.
 *      The after object could be the Head BILINK for adding to the head of a
 *      queue.
 *  Returns:
 *
 */
{
    #ifdef DEBUG
    if(FindObject(in,after)) {
        DPF(0,"Attempt to re-insert object in BILINK queue\n");
        DEBUG_BREAK();
    }
    #endif
    in->next = after->next;
    in->prev = after;
    after->next->prev = in;
    after->next = in;
}

void InsertBefore(
     BILINK *in,
     BILINK *before
    )
/*=========================================================================
 *  Description:
 * Inserts an  object before a specified object in the doubly linked list.
 * The before object could be the Head BILINK for adding to the end
 * of the queue
 * CALLED WITH INTERRUPTS_OFF
 *
 *  Returns:
 *
 */
{
    #ifdef DEBUG
    if(FindObject(in,before)) {
        DPF(0,"Attempt to re-insert object in BILINK queue\n");
        DEBUG_BREAK();
    }
    #endif
    in->next = before;
    in->prev = before->prev;
    before->prev->next = in;
    before->prev = in;
}

void Delete(
     BILINK *p
)
/*=========================================================================
 *  Description:
 *
 * Delete a  object from a doubly linked list. Make sure it IS on a list!
 * CALLED WITH INTERRUPTS OFF (must be atomic).
 *
 *  Returns:
 *
 */
{
    ASSERT(p && p->prev && p->next);
    if(!p && p->prev && p->next){
    	DEBUG_BREAK();
    }
    ASSERT(p->prev->next == p && p->next->prev == p);
    if(!(p->prev->next == p && p->next->prev == p)){
    	DEBUG_BREAK();
    }
    p->next->prev = p->prev;
    p->prev->next = p->next;
    // p->next = p->prev = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\protocol\bufmgr.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    BUFMGR.C

Abstract:

	Buffer Descriptor and Memory Manager

Author:

	Aaron Ogus (aarono)

Environment:
	Win32/COM

Revision History:

	Date    Author  Description
   =======  ======  ============================================================
   1/13/97  aarono  Original

--*/

#include <windows.h>
#include "newdpf.h"
#include <dplay.h>
#include <dplaysp.h>
#include <dplaypr.h>
#include "arpdint.h"
#include "bufmgr.h"
#include "mydebug.h"
#include "macros.h"
		
CRITICAL_SECTION DoubleBufferListLock;
PDOUBLEBUFFER	 pDoubleBufferList;
UINT   			 nDoubleBuffers;
UINT			 cbDoubleBuffers;

VOID InitBufferManager(VOID)
{
	pDoubleBufferList=NULL;
	nDoubleBuffers=0;
	cbDoubleBuffers=0;
	InitializeCriticalSection(&DoubleBufferListLock);
}

VOID FiniBufferManager(VOID)
{
	PDOUBLEBUFFER pDoubleBuffer = pDoubleBufferList;
	
	while(pDoubleBuffer){
		pDoubleBufferList=pDoubleBuffer->pNext;
		My_GlobalFree(pDoubleBuffer);
		pDoubleBuffer=pDoubleBufferList;
	}

	DeleteCriticalSection(&DoubleBufferListLock);
}

UINT MemDescTotalSize(PMEMDESC pMemDesc, UINT nDesc)
{
	UINT i;
	UINT cbTotalSize=0;

	for(i=0 ; i < nDesc ; i++){
		cbTotalSize+=pMemDesc->len;
		pMemDesc++;
	}
	
	return cbTotalSize;
}

// Actually get the memory block or allocate it.
PDOUBLEBUFFER GetDoubleBuffer(UINT TotalMessageSize)
{
	PDOUBLEBUFFER pDoubleBuffer=NULL;
	// First Check the FreeList for a buffer of the appropriate size.

	if(nDoubleBuffers && (cbDoubleBuffers >= TotalMessageSize)){
	
		PDOUBLEBUFFER pPrevBuffer, pCurrentBuffer;
		UINT nAllowedWaste=TotalMessageSize >> 2;
		
		Lock(&DoubleBufferListLock);

			// Search for best fit packet.  Cannot be more than 25% larger
			// than the actual required size.
			pPrevBuffer = (PDOUBLEBUFFER)&pDoubleBufferList;
			pCurrentBuffer = pPrevBuffer->pNext;
			
			while(pCurrentBuffer){
			
				if(pCurrentBuffer->totlen >= TotalMessageSize){
				
					if(pCurrentBuffer->totlen-TotalMessageSize < nAllowedWaste){
						// We have a winner, relink list over this buffer.
						pPrevBuffer->pNext = pCurrentBuffer->pNext;
						pDoubleBuffer = pCurrentBuffer;
						nDoubleBuffers--;
						cbDoubleBuffers-=pCurrentBuffer->totlen;
						break;
					}
					
				}
				pPrevBuffer = pCurrentBuffer;
				pCurrentBuffer = pCurrentBuffer->pNext; 
			}
		
		Unlock(&DoubleBufferListLock);
	}

	if(!pDoubleBuffer){
		// No Buffer Found on the FreeList, so allocate one.
		pDoubleBuffer=(PDOUBLEBUFFER)My_GlobalAlloc(GMEM_FIXED,TotalMessageSize+sizeof(DOUBLEBUFFER));
		
 		if(!pDoubleBuffer){
 			// couldn't allocate... out of memory.
 			DPF(0,"COULDN'T ALLOCATE DOUBLE BUFFER TO INDICATE RECEIVE, SIZE: %x\n",TotalMessageSize+sizeof(DOUBLEBUFFER));
 			ASSERT(0);
 			goto exit;
 		}
 		pDoubleBuffer->totlen = TotalMessageSize;
		pDoubleBuffer->dwFlags=BFLAG_DOUBLE; // double buffer buffer.
//	pDoubleBuffer->tLastUsed=GetTickCount(); only relevant when put back on list... throw this out??
	}
	
	pDoubleBuffer->pNext =  NULL;
	pDoubleBuffer->pData  = (PCHAR)&pDoubleBuffer->data;
	pDoubleBuffer->len	  = TotalMessageSize;
	
exit:
	return pDoubleBuffer;
}
/*++

	Double Buffer Management strategy.

	When the system needs to allocate buffers locally, it does it on a per
	channel basis.  A buffer of exactly the requested size is allocated and
	used to buffer the data.   When the buffer is done with, it is put on 
	the DoubleBufferList which caches the last few allocations.  Since
	most clients tend to use the same size packet over and over, this saves
	the time it takes to call GlobalAlloc and My_GlobalFree for every send.

	Aging out entries:  Every 15 seconds, a timer goes off and the system
	checks the age of each buffer on the DoubleBufferList.  Any entry 
	that has not been used in the last 15 seconds is actually freed.

	There is also a cap on the size of allocations allowed for the entire
	free list.  It never exceeds 64K.  If it does, oldest entries are 
	thrown out until the free list is less than 64K.

--*/

PBUFFER GetDoubleBufferAndCopy(PMEMDESC pMemDesc, UINT nDesc)
{
	
	UINT i;
	UINT TotalMessageSize;
	UINT WriteOffset;
	PDOUBLEBUFFER pDoubleBuffer=NULL;

	// Calculate the total size of the buffer
	TotalMessageSize=MemDescTotalSize(pMemDesc, nDesc);

	pDoubleBuffer=GetDoubleBuffer(TotalMessageSize);

	if(!pDoubleBuffer){
		goto exit;
	}

	// Scatter Gather Copy to Contiguous Local Buffer
	WriteOffset=0;
	
	for(i=0 ; i < nDesc ; i++){
		memcpy(&pDoubleBuffer->data[WriteOffset], pMemDesc->pData, pMemDesc->len);
		WriteOffset+=pMemDesc->len;
		pMemDesc++;
	}

exit:
	return (PBUFFER)pDoubleBuffer;
	
}

VOID FreeDoubleBuffer(PBUFFER pBuffer)
{
	PDOUBLEBUFFER pDoubleBuffer=(PDOUBLEBUFFER) pBuffer;
	PDOUBLEBUFFER pBufferWalker, pLargestBuffer;

	//
	// Put the local buffer on the free list.
	//
	
	pDoubleBuffer->tLastUsed = GetTickCount();
	
	Lock(&DoubleBufferListLock);

	pDoubleBuffer->pNext  = pDoubleBufferList;
	pDoubleBufferList 	  = pDoubleBuffer;
	cbDoubleBuffers      += pDoubleBuffer->totlen;
	nDoubleBuffers++;

	Unlock(&DoubleBufferListLock);


	//
	// If the free list is too large, trim it
	//

	while(cbDoubleBuffers > MAX_CHANNEL_DATA || nDoubleBuffers > MAX_CHANNEL_BUFFERS){

		Lock(&DoubleBufferListLock);

		if(cbDoubleBuffers > MAX_CHANNEL_DATA || nDoubleBuffers > MAX_CHANNEL_BUFFERS){

			//
			// Free the largest buffer.
			//

			pLargestBuffer=pDoubleBufferList;
			pBufferWalker=pLargestBuffer->pNext;

			// Find the largest buffer.
			while(pBufferWalker){
				if(pBufferWalker->totlen > pLargestBuffer->totlen){
					pLargestBuffer=pBufferWalker;
				}
				pBufferWalker=pBufferWalker->pNext;
			}

			//
			// Remove the largest buffer from the list
			//

			// Find previous element - sneaky, since ptr first in struct, 
			// take addr of list head.

			pBufferWalker=(PDOUBLEBUFFER)&pDoubleBufferList;
			while(pBufferWalker->pNext != pLargestBuffer){
				pBufferWalker=pBufferWalker->pNext;
			}

			// link over the largest buffer
			pBufferWalker->pNext=pLargestBuffer->pNext;

			// update object buffer information
			cbDoubleBuffers -= pLargestBuffer->totlen;
			nDoubleBuffers--;
			
			DPF(9,"Freeing Double Buffer Memory %x\n",pLargestBuffer->totlen);
			
			Unlock(&DoubleBufferListLock);

			My_GlobalFree(pLargestBuffer);

		}	else {
		
			Unlock(&DoubleBufferListLock);

		}
			
	}

	DPF(9,"Total Free Double Buffer Memory %x\n",cbDoubleBuffers);

}

PBUFFER BuildBufferChain(PMEMDESC pMemDesc, UINT nDesc)
{
	UINT i;
	PBUFFER pBuffer=NULL,pLastBuffer=NULL;

	ASSERT(nDesc);

	if(!nDesc){
		goto exit;
	}
	
	// walk backward through the array, allocating and linking
	// the buffers.

	i=nDesc;

	while(i){
		i--;
		
		// skip 0 length buffers 
		//if(pMemDesc[i].len){
			
			pBuffer=GetBuffer();
			
			if(!pBuffer){
				goto err_exit;
			}
			
			pBuffer->pNext   = pLastBuffer;
			pBuffer->pData   = pMemDesc[i].pData;
			pBuffer->len     = pMemDesc[i].len;
			pBuffer->dwFlags = 0;
			pLastBuffer      = pBuffer;
		//} 
	}


	// return the head of the chain to the caller

exit:
	return pBuffer;

err_exit: 
	// Couldn't allocate enough buffers, free the ones we did alloc
	// and then fail.
	while(pLastBuffer){
		pBuffer=pLastBuffer->pNext;
		FreeBuffer(pLastBuffer);
		pLastBuffer=pBuffer;
	}
	ASSERT(pBuffer==NULL);
	goto exit;
}


VOID FreeBufferChainAndMemory(PBUFFER pBuffer)
{
	PBUFFER pNext;
	while(pBuffer){
		pNext=pBuffer->pNext;
		if(pBuffer->dwFlags & BFLAG_DOUBLE){
			FreeDoubleBuffer(pBuffer);
		} else if(pBuffer->dwFlags & BFLAG_FRAME){	
			FreeFrameBuffer(pBuffer);
		} else {
			FreeBuffer(pBuffer);
		}	
		pBuffer=pNext;
	}	
}

UINT BufferChainTotalSize(PBUFFER pBuffer)
{

	UINT nTotalLen;
	
	ASSERT(pBuffer);
	
	if(!pBuffer){
		return 0;
	}
	
	nTotalLen=0;
	
	do{
		nTotalLen+=pBuffer->len;
		pBuffer=pBuffer->pNext;
	} while (pBuffer);

	return nTotalLen;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\protocol\bufpool.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    BUFPOOL.H

Abstract:

	Header for buffer pool manager

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date    Author  Description
   =======  ======  ============================================================
   1/30/97  aarono  Original

--*/

#ifndef _BUFPOOL_H_
#define _BUFPOOL_H_

#include <windows.h>
#include "buffer.h"

#define BUFFER_POOL_SIZE 16

//
// Buffer pools are allocated but only freed when the object is destroyed.
//

typedef struct _BUFFER_POOL {
	struct _BUFFER_POOL *pNext;
	BUFFER              Buffers[BUFFER_POOL_SIZE];
} BUFFER_POOL, *PBUFFER_POOL;


PBUFFER GetBuffer(VOID);
VOID FreeBuffer(PBUFFER);

VOID InitBufferPool(VOID);
VOID FiniBufferPool(VOID);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\protocol\bufpool.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    BUFPOOL.C

Abstract:

	Manages a pool of BUFFER descriptors (BUFFERS)
	16 at a time are allocated.  They are not freed until
	shutdown.

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date    Author  Description
   =======  ======  ============================================================
   1/27/97  aarono  Original

--*/

#include <windows.h>
#include "newdpf.h"
#include <dplay.h>
#include <dplaysp.h>
#include <dplaypr.h>
#include "bufpool.h"
#include "macros.h"
#include "mydebug.h"

CRITICAL_SECTION BufferPoolLock;
PBUFFER_POOL pBufferPoolList;
PBUFFER      pBufferFreeList;

VOID InitBufferPool(VOID)
{
	pBufferPoolList=NULL;
	pBufferFreeList=NULL;
	InitializeCriticalSection(&BufferPoolLock);
}

VOID FiniBufferPool(VOID)
{
	PBUFFER_POOL pNextBufPool;
	while(pBufferPoolList){
		pNextBufPool=pBufferPoolList->pNext;
		My_GlobalFree(pBufferPoolList);
		pBufferPoolList=pNextBufPool;
	}
	DeleteCriticalSection(&BufferPoolLock);
}

PBUFFER GetBuffer(VOID)
{
	PBUFFER 	 pBuffer=NULL;
	PBUFFER_POOL pBufferPool;
	UINT i;

Top:
	if(pBufferPoolList){
	
		Lock(&BufferPoolLock);
		
		if(pBufferFreeList){
			pBuffer=pBufferFreeList;
			pBufferFreeList=pBuffer->pNext;
		} 
		
		Unlock(&BufferPoolLock);
		
		if(pBuffer){
			return pBuffer;
		}	
	} 
	
	pBufferPool=(PBUFFER_POOL)My_GlobalAlloc(GMEM_FIXED, sizeof(BUFFER_POOL));
	
	if(pBufferPool){

		// link the buffers into a chain.
		for(i=0;i<BUFFER_POOL_SIZE-1;i++){
			pBufferPool->Buffers[i].pNext=&pBufferPool->Buffers[i+1];
		}
		
		Lock(&BufferPoolLock);

		// link the pool on the pool list.
		pBufferPool->pNext=pBufferPoolList;
		pBufferPoolList=pBufferPool;

		// link the buffers on the buffer list.
		pBufferPool->Buffers[BUFFER_POOL_SIZE-1].pNext=pBufferFreeList;
		pBufferFreeList=&pBufferPool->Buffers[0];
		
		Unlock(&BufferPoolLock);
		
		goto Top;
		
	} else {
		ASSERT(0); //TRACE ALL PATHS
	
		return NULL;
		
	}
}

VOID FreeBuffer(PBUFFER pBuffer)
{
	Lock(&BufferPoolLock);
	pBuffer->pNext=pBufferFreeList;
	pBufferFreeList=pBuffer;
	Unlock(&BufferPoolLock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\protocol\bufmgr.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    BUFMGR.H

Abstract:

	Buffer Descriptor and Memory Manager for ARPD

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date    Author  Description
   =======  ======  ============================================================
   1/13/97  aarono  Original

--*/

#ifndef _BUFMGR_H_
#define _BUFMGR_H_

#include "buffer.h"
#include "bufpool.h"

typedef struct _DoubleBuffer{
	union {
		BUFFER Buffer;
		struct {
			struct _DoubleBuffer *pNext;
			PVOID PAD;
			PCHAR pData;
			UINT  len;		    // length of data area used
			DWORD dwFlags;      // Packet flags, ownership and type of packet.
		};	
	};
	UINT  totlen;       // total length of data area
	UINT  tLastUsed;	// last tick count this was used
	CHAR  data[1];		// variable length data
} DOUBLEBUFFER, *PDOUBLEBUFFER;

	
VOID InitBufferManager(VOID);
VOID FiniBuffermanager(VOID);

PBUFFER GetDoubleBufferAndCopy(PMEMDESC, UINT);
VOID    FreeDoubleBuffer(PBUFFER);
PBUFFER BuildBufferChain(PMEMDESC, UINT);

VOID    FreeBufferChainAndMemory(PBUFFER); //works for either type
UINT    BufferChainTotalSize(PBUFFER);

#define GBF_ALLOC_MEM 0x00000001

// Don't pool more than 64K per channel.
#define MAX_CHANNEL_DATA 	65536
// Don't hold more than 3 free buffers per channel.
#define MAX_CHANNEL_BUFFERS 3

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\protocol\dbgtopic.h ===
DEBUG_TOPIC(B,"&Blting")
DEBUG_TOPIC(C,"&Clipping")
DEBUG_TOPIC(D,"&DDraw Object")
DEBUG_TOPIC(F,"&Focus Changes")
DEBUG_TOPIC(H,"&HAL/HEL Calls")
DEBUG_TOPIC(I,"Internal Fn Entered")
DEBUG_TOPIC(K,"NT Kernel Calls")
DEBUG_TOPIC(L,"&Locking/Ownership")
DEBUG_TOPIC(O,"M&odes")
DEBUG_TOPIC(M,"&Memory")
DEBUG_TOPIC(P,"API &Parameters")
DEBUG_TOPIC(R,"&Reference Counting")
DEBUG_TOPIC(S,"&Surface Objects")
DEBUG_TOPIC(T,"Fil&ters")
DEBUG_TOPIC(V,"&Video Memory allocation")
DEBUG_TOPIC(W,"&Windows and Handles")
DEBUG_TOPIC(X,"Ad-Hoc Message &X")

#undef PROF_SECT
#define PROF_SECT "DirectPlay"

#undef DPF_MODULE_NAME
#ifdef START_STR
	#define DPF_MODULE_NAME START_STR
#else
	#define DPF_MODULE_NAME "DPlayProtocol"
#endif


/*
 * Use this identifier to define which line in WIN.INI [DirectX] denotes the
 * debug control string
 */
#undef DPF_CONTROL_LINE
#define DPF_CONTROL_LINE "DPlayDebug"

/*
 * It is important that the first DEBUG_TOPIC appear at the top line of this
 * file, and that no other lines are interspersed between DEBUG_TOPIC lines.
 * (The debug system uses the __LINE__ pseudo-variable to identify topics)
 */

/*
 * Definitions for DPF detail levels:
 *
 * 0: Error useful for application developers.
 * 1: Warning useful for application developers.
 * 2: API Entered
 * 3: API parameters, API return values
 * 4: Driver conversation
 *
 * 5: Deeper program flow notifications
 * 6: Dump structures 
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\protocol\command.h ===
/*++

Copyright (c) 1996,1997  Microsoft Corporation

Module Name:

	COMMAND.H

Abstract:


Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
   3/14/97 aarono  Original

--*/

#ifndef _COMMAND_H_

#define _COMMAND_H_

#define REQUEST_PARAMS PPROTOCOL pProtocol, DPID idFrom, DPID idTo, PCMDINFO pCmdInfo, PBUFFER pSrcBuffer
#define MAX_COMMAND 0x06

typedef UINT (*COMMAND_HANDLER)(REQUEST_PARAMS);

UINT AssertMe(REQUEST_PARAMS);
UINT Ping(REQUEST_PARAMS);
UINT PingResp(REQUEST_PARAMS);
UINT GetTime(REQUEST_PARAMS);
UINT GetTimeResp(REQUEST_PARAMS);
UINT SetTime(REQUEST_PARAMS);
UINT SetTimeResp(REQUEST_PARAMS);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\protocol\framebuf.c ===
/*++

Copyright (c) 1996,1997  Microsoft Corporation

Module Name:

    FRAMEBUF.CPP

Abstract:

	Manages Memory for Send/Receive Frames.
	ISSUE: when you have time do an intelligent implementation,
	for now this is just a frame cache.
	    - not likely now, DP4 is being put to bed AO 04/03/2001

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
  12/10/96 aarono  Original
   6/6/98  aarono  More debug checks, shrink pool.

--*/

#include <windows.h>
#include "newdpf.h"
#include <dplay.h>
#include <dplaysp.h>
#include <dplaypr.h>
#include "mydebug.h"
#include "bufmgr.h"
#include "macros.h"

#define MAX_FRAMES_ON_LIST 16
#define MIN_FRAMES_ON_LIST 8

typedef struct _frame 
{
	BILINK Bilink;
	UINT len;
	UCHAR data[0];
} FRAME, *PFRAME;	

BILINK FrameList;
UINT   nFramesOnList=0;
UINT   TotalFrameMemory=0;
CRITICAL_SECTION FrameLock;

#ifdef DEBUG
void DebugChkFrameList()
{
	BILINK *pBilink;
	PFRAME  pFrameWalker;

	DWORD	count=0;
	DWORD	totalsize=0;
	DWORD   fBreak=FALSE;

	Lock(&FrameLock);

	pBilink=FrameList.next;
	while(pBilink != &FrameList){
		pFrameWalker=CONTAINING_RECORD(pBilink,FRAME,Bilink);
		pBilink=pBilink->next;
		count++;
		totalsize+=pFrameWalker->len;
	}

	if(totalsize != TotalFrameMemory){
		DPF(0, "Total Frame Memory says %d but I count %d\n",TotalFrameMemory, totalsize);
		fBreak=TRUE;
	}

	if(count != nFramesOnList){
		DPF(0, "nFramesOnList %d but I count %d\n",nFramesOnList, count);
		fBreak=TRUE;
	}
	if(fBreak){
		DEBUG_BREAK();
	}
	
	Unlock(&FrameLock);
}
#else
#define DebugChkFrameList()
#endif

VOID InitFrameBuffers(VOID)
{
	InitBilink(&FrameList);
	InitializeCriticalSection(&FrameLock);
	nFramesOnList=0;
	TotalFrameMemory=0;
}

VOID FiniFrameBuffers(VOID)
{
	BILINK *pBilink;
	PFRAME  pFrame;
	
	Lock(&FrameLock);

	while(!EMPTY_BILINK(&FrameList)){
		pBilink=FrameList.next;
		pFrame=CONTAINING_RECORD(pBilink,FRAME,Bilink);
		Delete(pBilink);
		My_GlobalFree(pFrame);
	}

	nFramesOnList=0;
	TotalFrameMemory=0;
	
	Unlock(&FrameLock);
	DeleteCriticalSection(&FrameLock);
}

VOID ReleaseFrameBufferMemory(PUCHAR pFrameData)
{
	PFRAME  pFrame;
	BILINK  FramesToFree;
	BILINK *pBilink;
	
	Lock(&FrameLock);

	DebugChkFrameList();

	InitBilink(&FramesToFree);

	pFrame=CONTAINING_RECORD(pFrameData,FRAME,data);

	InsertAfter(&pFrame->Bilink, &FrameList);
	nFramesOnList++;
	TotalFrameMemory+=pFrame->len;

	if(nFramesOnList > MAX_FRAMES_ON_LIST){
		while(nFramesOnList > MIN_FRAMES_ON_LIST){
			pBilink=FrameList.next;
			pFrame=CONTAINING_RECORD(pBilink,FRAME,Bilink);
			nFramesOnList--;
			TotalFrameMemory-=pFrame->len;
			Delete(pBilink);
			DebugChkFrameList();
			InsertAfter(pBilink, &FramesToFree);
		}
	}
	
	DebugChkFrameList();
	ASSERT(nFramesOnList);

	Unlock(&FrameLock);

	// Drop lock before freeing, to make more effecient.

	while(!EMPTY_BILINK(&FramesToFree)){
		pBilink=FramesToFree.next;
		pFrame=CONTAINING_RECORD(pBilink,FRAME,Bilink);
		Delete(pBilink);
		My_GlobalFree(pFrame);
	}

	DebugChkFrameList();

}

PBUFFER GetFrameBuffer(UINT FrameLen)
{
	PBUFFER pBuffer;
	PFRAME  pFrame;
	MEMDESC memdesc;

	BILINK  *pBilinkWalker;
	PFRAME  pFrameBest=NULL, pFrameWalker;
	UINT    difference=FrameLen;

	DPF(9,"==>GetFrameBuffer Len %d\n",FrameLen);

	Lock(&FrameLock);
	
	if(!EMPTY_BILINK(&FrameList)){
		ASSERT(nFramesOnList);

		pBilinkWalker=FrameList.next;
		
		while(pBilinkWalker != &FrameList){
			pFrameWalker=CONTAINING_RECORD(pBilinkWalker, FRAME, Bilink);
			if(pFrameWalker->len >= FrameLen){
				if(FrameLen-pFrameWalker->len < difference){
					difference=FrameLen-pFrameWalker->len;
					pFrameBest=pFrameWalker;
					if(!difference){
						break;
					}
				}
			}
			pBilinkWalker=pBilinkWalker->next;
		}

		if(!pFrameBest){
			goto alloc_new_frame;
		} else {
			pFrame=pFrameBest;
		}

		DebugChkFrameList();

		Delete(&pFrame->Bilink);
		nFramesOnList--;
		TotalFrameMemory-=pFrame->len;

		DebugChkFrameList();

		Unlock(&FrameLock);
		
	} else {
	
alloc_new_frame:	
		Unlock(&FrameLock);
		pFrame=(PFRAME)My_GlobalAlloc(GMEM_FIXED,FrameLen+sizeof(FRAME));
		if(!pFrame){
			return NULL;
		}
		pFrame->len=FrameLen;
	}

	memdesc.pData=&pFrame->data[0];
	memdesc.len=pFrame->len;
	
	pBuffer=BuildBufferChain((&memdesc),1);

	if(!pBuffer){
		ReleaseFrameBufferMemory(pFrame->data);
		DPF(9,"<==GetFrameBuffer FAILED returning %x\n",pBuffer);
	} else {
		pBuffer->dwFlags |= BFLAG_FRAME;
		DPF(9,"<==GetFrameBuffer %x, len %d\n",pBuffer, pFrame->len);
	}	

	DebugChkFrameList();
	
	return pBuffer;
}

// Release the buffer, put the memory back on the frame buffer list.
VOID FreeFrameBuffer(PBUFFER pBuffer)
{
	ASSERT(pBuffer->dwFlags & BFLAG_FRAME);
	ReleaseFrameBufferMemory(pBuffer->pData);
	FreeBuffer(pBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\protocol\buffer.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    BUFFER.H

Abstract:

	HEADER for buffers.

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date    Author  Description
   =======  ======  ============================================================
   1/30/97  aarono  Original
   2/17/98  aarono  changed memdesc to be len,ptr from ptr,len to align with sendex data.

--*/

#ifndef _BUFFER_H_
#define _BUFFER_H_
//
// Buffer is a descriptor for a chunk of data.
//

#include "bilink.h"

typedef struct _BUFFER {
	union {
		struct _BUFFER *pNext;		// Next buffer in chain
		BILINK BuffList;
	};	
	PUCHAR 		   pData;		// Data area of buffer
	UINT   		   len;         // length of data area
	DWORD          dwFlags;     // info about the data area
	PUCHAR         pCmdData;    // pointer past header to command data - used in receive path.
	DWORD          sequence;    // absolute sequence number
} BUFFER, *PBUFFER;

#define BFLAG_PROTOCOL		0x00000001	/* This buffer is for protocol information */
#define BFLAG_DOUBLE    	0x00000002	/* This buffer is a double buffer buffer   */
#define BFLAG_PROTHEADER	0x00000004  /* Room for the protocol header is at the head of the packet */
#define BFLAG_FRAME         0x00000008  /* From Frame allocator */

// PROTHEADER flag will only occur with packets that have the DOUBLE flag set 
// and only when the provider does not support multi-buffer sends and the 
// entire message and protocol header will fit in one media frame. - actually pretty often.

typedef struct _MEMDESC {
	UINT 	len;
	PUCHAR 	pData;
} MEMDESC, *PMEMDESC;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\protocol\macros.h ===
#define Lock(_a) EnterCriticalSection(_a)
#define Unlock(_a) LeaveCriticalSection(_a)
#define CreateSem(_Initial)	CreateSemaphoreA(NULL,(_Initial),-1,NULL) 
#define DestroySem(_hSem)   CloseHandle((_hSem))
#define Wait(_A) 			WaitForSingleObject((_A),0xFFFFFFFF)
#define Signal(_A) 			ReleaseSemaphore((_A), 1, NULL)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\protocol\mydebug.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mydebug.h
 ***************************************************************************/
#ifndef __MYDEBUG_H__
#define __MYDEBUG_H__


#ifdef DEBUG
HGLOBAL
My_GlobalAlloc(
    UINT uFlags,
    DWORD dwBytes
    );

HGLOBAL
My_GlobalFree(
    HGLOBAL hMem
    );
#else 
#define My_GlobalAlloc(_a,_b) GlobalAlloc(_a,_b)
#define My_GlobalFree(_a) GlobalFree(_a)
#endif


#define SIGNATURE(a,b,c,d) (UINT)(a+(b<<8)+(c<<16)+(d<<24))

#ifdef DEBUG
	#define SIGN 1
	#define ASSERT_NACKMask(_a) \
	if(pSend->OpenWindow && ((_a)->NACKMask & (0xFFFFFFFF-((1<<(((_a)->OpenWindow)))-1)) ) ){ \
		DPF(0,"pSend %x OpenWindow %d NACKMask %x",pSend,pSend->OpenWindow, pSend->NACKMask);\
		DEBUG_BREAK(); \
	} else if (!(_a)->OpenWindow && (_a)->NACKMask){ \
		DPF(0,"pSend %x OpenWindow %d NACKMask %x",pSend,pSend->OpenWindow, pSend->NACKMask);\
		DEBUG_BREAK(); \
	} 
#else
	#define ASSERT_NACKMask(_a)
#endif

#ifdef SIGN
	#define SET_SIGN(a,b) ((a)->Signature=(b))
	#define UNSIGN(a) ((a)|=0x20202020);
//	#define ASSERT_SIGN(a,b) ASSERT((((UINT)(a)->Signature))==((UINT)(b)))
	#define ASSERT_SIGN(a,b) if(!((((UINT)(a)->Signature))==((UINT)(b))))DEBUG_BREAK();


#else
	#define UNSIGN(a)
	#define SET_SIGN(a,b)
	#define ASSERT_SIGN(a,b)
#endif

#ifdef DEBUG
	#if !defined(ASSERT)
		#define ASSERT DDASSERT
	#endif
#endif

#endif /* __MYDEBUG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\protocol\mydebug.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mydebug.c
 *  Content:	debugging printf - stolen from direct draw.
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	  Reason
 *   ====	==	  ======
 *         aarono splurp.
 *  6/6/98 aarono Debug support for link statistics
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#undef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include "newdpf.h"
#include "mydebug.h"
#include "bilink.h"
#include <stdarg.h>

#ifdef DEBUG

typedef struct _MEM_BLOCK {
	union {
		BILINK Bilink;
		struct _FB {
			struct _MEM_BLOCK *pNext;
			struct _MEM_BLOCK *pPrev;
		} FB;
	};	
	UINT len;
	UINT tmAlloc;
	CHAR data[4];
} MEM_BLOCK, *PMEM_BLOCK;

LONG TotalMem = 0;

struct _MEMLIST {
	union{
		BILINK Bilink;
		struct _FB FB;
	};
} MemList={(BILINK *)&MemList,(BILINK *)&MemList};

UINT nInit=0xFFFFFFFF;
CRITICAL_SECTION MEM_CS;

VOID My_GlobalAllocInit()
{
	if(!InterlockedIncrement(&nInit)){
		InitializeCriticalSection(&MEM_CS);
	}
}

VOID My_GlobalAllocDeInit()
{
	if(InterlockedDecrement(&nInit)&0x80000000){
		DeleteCriticalSection(&MEM_CS);
	}
}

HGLOBAL
My_GlobalAlloc(
    UINT uFlags,
    DWORD dwBytes
    )
{
	PMEM_BLOCK pMem;

	UINT lTotalMem;

	pMem=(PMEM_BLOCK)GlobalAlloc(uFlags,dwBytes+sizeof(MEM_BLOCK)-4);
	pMem->len=dwBytes;
	pMem->tmAlloc=GetTickCount();
	
	EnterCriticalSection(&MEM_CS);
	InsertAfter(&pMem->Bilink, &MemList.Bilink);
	TotalMem+=dwBytes;
	lTotalMem=TotalMem;
	LeaveCriticalSection(&MEM_CS);

	DPF(9,"GlobalAlloc: Allocated %d TotalMem %d\n",dwBytes, lTotalMem);
	{
		IN_WRITESTATS InWS;
		memset((PVOID)&InWS,0xFF,sizeof(IN_WRITESTATS));
	 	InWS.stat_USER2=lTotalMem;
		DbgWriteStats(&InWS);
	}

	return((HGLOBAL)&pMem->data[0]);
}

HGLOBAL
My_GlobalFree(
    HGLOBAL hMem
    )
{
	PUCHAR pData=(PUCHAR)(hMem);
	PMEM_BLOCK pMem;
	UINT lTotalMem;
	UINT dwBytes;

	pMem=CONTAINING_RECORD(pData, MEM_BLOCK, data);
	EnterCriticalSection(&MEM_CS);
	Delete(&pMem->Bilink);
	TotalMem-=pMem->len;
	dwBytes=pMem->len;
	lTotalMem=TotalMem;
	LeaveCriticalSection(&MEM_CS);
	DPF(9,"GlobalFree: Freed %d TotalMem %d\n",dwBytes,lTotalMem);
	{
		IN_WRITESTATS InWS;
		memset((PVOID)&InWS,0xFF,sizeof(IN_WRITESTATS));
	 	InWS.stat_USER2=lTotalMem;
		DbgWriteStats(&InWS);
	}
	return GlobalFree(pMem);
}

#endif /* DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\protocol\mytimer.h ===
/*++

Copyright (c) 1996,1997  Microsoft Corporation

Module Name:

    MYTIMER.H

Abstract:

	Include For
	Handle adjusting timer resolution for throttling and do thread pool

Author:

	Aaron Ogus (aarono)

Environment:

	Win32

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
   6/04/98 aarono  Original

--*/

typedef void CALLBACK MYTIMERCALLBACK (UINT_PTR uID, UINT uMsg, DWORD_PTR dwUser, DWORD dw1, DWORD dw2);

typedef enum _TimerState {
	NotInUse,
	WaitingForTimeout,
	QueuedForThread,
	InCallBack,
	End
} eTimerState;

typedef struct _MyTimer {
	BILINK	Bilink;
	eTimerState TimerState;
	DWORD	TimeOut;
	DWORD_PTR Context;
	MYTIMERCALLBACK *CallBack;
	DWORD   Unique;
} MYTIMER, *PMYTIMER;

DWORD_PTR SetMyTimer(DWORD dwTimeOut, DWORD TimerRes, MYTIMERCALLBACK TimerCallBack, DWORD_PTR UserContext, PUINT pUnique);
HRESULT InitTimerWorkaround();
VOID FiniTimerWorkaround();
HRESULT CancelMyTimer(DWORD_PTR pTimer, DWORD Unique);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\protocol\handles.c ===
/*++

Copyright (c) 1996,1997  Microsoft Corporation

Module Name:

    HANDLES.C

Abstract:

	Handle Manager

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
   2/16/98 aarono  Original
   6/6/98  aarono  debug support, use My_GlobalAlloc
   7/23/00 aarono  B#40279: fix consistency in InitHandle table, implicit assumption was nSize==GrowSize


--*/

#include <windows.h>
#include <mmsystem.h>
#include <dplay.h>
#include <dplaysp.h>
#include <dplaypr.h>
#include "mydebug.h"
#include "arpd.h"
#include "arpdint.h"
#include "macros.h"
#include "handles.h"

VOLLPMYHANDLETABLE InitHandleTable(UINT nSize, CRITICAL_SECTION *pcs, UINT nUserGrowSize)
{
	LPMYHANDLETABLE lpTable;
	UINT nGrowSize;
	UINT i;

	if(nUserGrowSize){
		nGrowSize=nUserGrowSize;
	} else {
		nGrowSize=MYHANDLE_DEFAULT_GROWSIZE;
	}

	lpTable=(LPMYHANDLETABLE)My_GlobalAlloc(GPTR, sizeof(MYHANDLETABLE)+(sizeof(MYHANDLE)*nSize));

	if(lpTable){
		if(pcs){
			InitializeCriticalSection(pcs);
		}
	
		lpTable->nUnique=UNIQUE_ADD;
		lpTable->nTableSize=nSize;
		lpTable->nTableGrowSize=nGrowSize;

		lpTable->iNext=0;
		for(i=0;i < nSize-1; i++){
			lpTable->Table[i].iNext=i+1;
		}
		lpTable->Table[nSize-1].iNext = LIST_END;
	}

	return lpTable;
}

VOID FiniHandleTable(LPMYHANDLETABLE lpTable, CRITICAL_SECTION *pcs)
{
	My_GlobalFree(lpTable);
	if(pcs){
		DeleteCriticalSection(pcs);
	}	
}

DWORD AllocHandleTableEntry(LPVOLLPMYHANDLETABLE lplpTable, CRITICAL_SECTION *pcs, LPVOID lpv)
{
	#define lpTable (*lplpTable)

	UINT i;
	LPMYHANDLETABLE lpNewTable;

	if(pcs){
		EnterCriticalSection(pcs);
	}

	if(lpTable->iNext==LIST_END){
		// grow the table.
		lpNewTable=(LPMYHANDLETABLE)My_GlobalAlloc(GPTR, sizeof(MYHANDLETABLE)+
					((lpTable->nTableGrowSize+lpTable->nTableSize)*sizeof(MYHANDLE)));

		if(!lpNewTable){
			return 0;
		}
		memcpy(lpNewTable, lpTable, (lpTable->nTableSize*sizeof(MYHANDLE))+sizeof(MYHANDLETABLE));

		lpNewTable->iNext=lpNewTable->nTableSize;
		lpNewTable->nTableSize=lpNewTable->nTableSize+lpNewTable->nTableGrowSize;

		for(i=lpNewTable->iNext ; i < lpNewTable->nTableSize-1 ; i++){
			lpNewTable->Table[i].iNext=i+1;
		}
		lpNewTable->Table[lpNewTable->nTableSize-1].iNext = LIST_END;

		My_GlobalFree(lpTable);
		
		*lplpTable=lpNewTable;
	}

	i=lpTable->iNext;
	lpTable->iNext=lpTable->Table[i].iNext;

	// increment uniqueness, never zero.
	do {
		lpTable->nUnique += UNIQUE_ADD;
	} while (!lpTable->nUnique);

	lpTable->Table[i].nUnique=lpTable->nUnique;
	lpTable->Table[i].lpv=lpv;

	if(pcs) {
		LeaveCriticalSection(pcs);
	}

	ASSERT((i+lpTable->Table[i].nUnique & CONTEXT_INDEX_MASK) == i);

	return i+lpTable->Table[i].nUnique;	

	#undef lpTable
}

LPVOID ReadHandleTableEntry( LPVOLLPMYHANDLETABLE lplpTable, CRITICAL_SECTION *pcs, UINT handle)
{
	#define lpTable (*lplpTable)

	UINT i;
	UINT nUnique;
	LPVOID lpv;

	if(handle){

		if(pcs){
			EnterCriticalSection(pcs);
		}	

		i = handle & CONTEXT_INDEX_MASK;
		nUnique = handle - i;

		if(i < lpTable->nTableSize && nUnique == lpTable->Table[i].nUnique){
			lpv = lpTable->Table[i].lpv;
		} else {
			lpv = NULL;
		}
		
		if(pcs){
			LeaveCriticalSection(pcs);
		}	
		
	} else {
	
		lpv=NULL;

	}

	return lpv;

	#undef lpTable
}

HRESULT FreeHandleTableEntry(LPVOLLPMYHANDLETABLE lplpTable, CRITICAL_SECTION *pcs, UINT handle)
{
	#define lpTable (*lplpTable)

	HRESULT hr=DP_OK;
	UINT i;
	UINT nUnique;

	if(handle){

		if(pcs){
			EnterCriticalSection(pcs);
		}	

		i = handle & CONTEXT_INDEX_MASK;
		nUnique = handle - i;

		if(i < lpTable->nTableSize && nUnique == lpTable->Table[i].nUnique){
			lpTable->Table[i].iNext = lpTable->iNext;
			lpTable->iNext=i;
		} else {
			hr = DPERR_GENERIC;
			DPF(0,"FreeHandleTableEntry, ERROR, TRIED TO FREE INVALID HANDLE %x",handle);
			ASSERT(0);
		}

		if(pcs){
			LeaveCriticalSection(pcs);
		}	

	} else {
		hr=DPERR_GENERIC;
	}
	return hr;

	#undef lpTable
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\protocol\protocol.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    Protocol.c

Abstract:

	Another Reliable Protocol (on DirectPlay)

Author:

	Aaron Ogus (aarono)

Environment:

	Win32

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
  12/10/96 aarono  Original
  05/11/97 aarono  convert from C++ COM object to 'C' library
   2/03/98 aarono  fixed ProtocolGetCaps for RAW
   2/18/98 aarono  changed InitProtocol to work later in connect process
                   added new API handlers SendEx, GetMessageQueue, stub Cancel
   2/18/98 aarono  added Cancel support
   2/19/98 aarono  don't hook Shutdown anymore, dplay calls us
   				   explicitly on DP_OPEN (InitProtocol) DP_CLOSE (FiniProtocol)
   2/20/98 aarono  B#18827 not pulling cancelled sends from Q properly
   3/5/98  aarono  B#18962 allow non-reliable enumsessions reply when using protocol
		   this avoids a bug where a remote on an invalid IPX net enums us
		   and we get bogged down with RIPing in the response path.  Actually hangs
		   the machine and sometimes crashes IPX.
   6/6/98  aarono  Turn on throttling and windowing
   10/8/99 aarono  Improve shutdown handling, avoid 1min hang with pending sends.

Notes:
	All direct calls from DPLAY to the PROTOCOL occur in this file.

--*/

#include <windows.h>
#include <mmsystem.h>
#include <dplay.h>
#include <dplaysp.h>
#include <dplaypr.h>
#include "mydebug.h"
#include "handles.h"
#include "arpd.h"
#include "arpdint.h"
#include "macros.h"
#include "mytimer.h"

/*
	Protocol Object Life:
	=====================

	The protocol object is allocated on the DPLAY interface immediately after
	the call to SPInit. The protocol block is allocated and tacked onto the
	DPLAY interface.  If the object is not allocated, the protocol pointer
	will be NULL.

	When the SP shutdown handler is called, the protocol object is released,
	first making sure that all other structures off of the protocol have
	been freed and all memory pools have been freed.

	SESSION Life:
	=============
	Sessions are the structures that support the connection of a pair of
	PLAYERS.  For each target playerid there is a SESSION structure.
	SESSIONS are accessed by converting playerids into indices into a
	session array, valid sessions are filled in, invalid or not yet seen
	ones are NULL.  A session is allocated for every call to the SP
	CreatePlayer routine.  When a DeletePlayer is received, the session
	is freed.  There are races to create players and delete players so
	the session state is tracked.  If the session is not in the OPEN
	state, mesages for the session are ABORTED/IGNORED(?).  When the
	player is being removed, there may be stragling receives, these
	are rejected.  Any packet received for a non-existent session is
	dropped.  When a session is being closed, all pending sends are
	first completed.

	SEND Life:
	==========

		STATISTICS Life:
		================

	RECEIVE Life:
	=============


	How we hook in:
	===============

	Receive:
	--------
	HandlePacket in the ISP table has been replaced by the protocol's
	ProtocolHandlePacket routine.  Each call to HandlePacket comes along
	with a pISP, from which we derive the pProtocol.  If no pProtocol exits
	on the object, then we just call the old HandlePacket routine, otherwise
	we examine the packet and do our thing depending on what type of message
	it is and/or negotiated session parameters.

	Send/CreatePlayer/DeletePlayer/Shutdown:
	----------------------------------------
	If we install:
	We replace the interface pointers to these SP callbacks with our own and
	remember the existing ones.  When we are called we do our processing and
	then call the handler in the SP.  In the case of Send, we may not even
	call because we need to packetize the message.

	We also replace the packet size information in the SPData structure so that
	directplay's packetize and send code won't try to break up messages before
	we get them.  System messages that we don't handle hopefully don't exceed
	the actual maximum frame size, else they will fail on a non-reliable
	transport.
	
*/

#ifdef DEBUG
extern VOID My_GlobalAllocInit();
extern VOID My_GlobalAllocDeInit();
#endif

//
// Global pools should only be inited once, this counts opens.
// No lock req'd since calls to spinit serialized in DirectPlay itself.
//
UINT nInitCount = 0;

/*=============================================================================

	InitProtocol - initialize the protocol block and hook into the send path.

    Description:

    	After each SP is initialized (in SPInit) this routine is called to
    	hook the SP callbacks for the protocol.  Also the protocol information
    	for this instance of the protocol is allocated and initialized.

    Parameters:

		LPSPINITDATA pInitData - initialization block that was passed to the
			 					 SP.  We use it to hook in.

    Return Values:

		DP_OK         - successfully hooked in.
		                pProtocol on DIRECTPLAY object points to protocol obj.
		DPERR_GENERIC - didn't hook in.  Also pProtocol in the DIRECTPLAY
		                object will be NULL.

-----------------------------------------------------------------------------*/

HRESULT WINAPI InitProtocol(DPLAYI_DPLAY *lpDPlay)
{
	PPROTOCOL    pProtocol;
	HRESULT      hr;

	#define TABLE_INIT_SIZE 16
	#define TABLE_GROW_SIZE 16

	#ifdef DEBUG
	My_GlobalAllocInit();
	#endif

	// Allocate the protocol block;
	pProtocol=My_GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT,sizeof(PROTOCOL));

	if(!pProtocol){
		hr=DPERR_NOMEMORY;
		goto exit;
	}

	//
	// Initialize protocol variables.
	//

	pProtocol->m_lpDPlay=lpDPlay;

	pProtocol->m_lpISP=lpDPlay->pISP;
	
	pProtocol->m_dwSPHeaderSize=lpDPlay->dwSPHeaderSize;
	
	pProtocol->m_nSendThreads=0;						// we support any number of send threads!
	pProtocol->m_eState=Initializing;                   // we are initing
	
	InitializeCriticalSection(&pProtocol->m_ObjLock);
	InitializeCriticalSection(&pProtocol->m_SPLock);

	// Session lookup by ID list.
	InitializeCriticalSection(&pProtocol->m_SessionLock);
	pProtocol->m_SessionListSize=0;
	pProtocol->m_pSessions=NULL;

	// GLOBAL SENDQ
	InitializeCriticalSection(&pProtocol->m_SendQLock);
	InitBilink(&pProtocol->m_GSendQ);

	//
	// Get Multi-Media Timer Information.
    //
	
	if( timeGetDevCaps(&pProtocol->m_timecaps,sizeof(TIMECAPS)) != TIMERR_NOERROR ){
		// make em up
		ASSERT(0);
		pProtocol->m_timecaps.wPeriodMin=5;
		pProtocol->m_timecaps.wPeriodMax=10000000;
	}

	// Send Thread Triggers - waits for Sends, DataGram IDs or Reliable IDs.
	
	pProtocol->m_hSendEvent=CreateEventA(NULL, FALSE, FALSE, NULL);
	
	if(!pProtocol->m_hSendEvent){
		ASSERT(0); //TRACE all paths.
		hr=DPERR_NOMEMORY;
		goto exit1;
	}


	// Various descriptor pools.
	// These can't fail.
	if(!nInitCount){
		InitializeCriticalSection(&g_SendTimeoutListLock);
		InitBilink(&g_BilinkSendTimeoutList);
		// only allocated once per process.
		InitSendDescs();
		InitSendStats();
		InitFrameBuffers();
		InitBufferManager();
		InitBufferPool();
	}

	InitRcvDescs(pProtocol);

	nInitCount++;

	//
	// Get the datagram frame size from the SP
	//

	{
	        DPCAPS    	     Caps;
		    DPSP_GETCAPSDATA GetCapsData;

			memset(&Caps,0,sizeof(DPCAPS));

			Caps.dwMaxBufferSize = 0;
			Caps.dwSize          = sizeof(DPCAPS);
			GetCapsData.dwFlags  = 0;
			GetCapsData.lpCaps   = &Caps;
			GetCapsData.idPlayer = 0;
			GetCapsData.lpISP    = lpDPlay->pISP;
			CALLSP(lpDPlay->pcbSPCallbacks->GetCaps, &GetCapsData);
			pProtocol->m_dwSPMaxFrame=GetCapsData.lpCaps->dwMaxBufferSize;

			if(pProtocol->m_dwSPMaxFrame > 1400){
				// Necessary since UDP reports huge capacity even though no receiver can
				// successfully receive a datagram of that size without throttle.
				pProtocol->m_dwSPMaxFrame = 1400;
			}

			GetCapsData.dwFlags = DPCAPS_GUARANTEED;
			
			hr=CALLSP(lpDPlay->pcbSPCallbacks->GetCaps, &GetCapsData);

			if(hr==DP_OK){
				pProtocol->m_dwSPMaxGuaranteed=GetCapsData.lpCaps->dwMaxBufferSize;
			}	
			if(!pProtocol->m_dwSPMaxGuaranteed){
				pProtocol->m_dwSPMaxGuaranteed=pProtocol->m_dwSPMaxFrame;
			}
	}

	Lock(&pProtocol->m_ObjLock);

	//
	// Spin up the send thread
	//
	pProtocol->m_nSendThreads++;
	
	// Need for serialization starts here...
	pProtocol->m_hSendThread[0]=CreateThread( NULL,
									      4000,
									      SendThread,
							              (LPVOID)pProtocol,
							              0,
							              &pProtocol->m_dwSendThreadId[0]);
	if(!pProtocol->m_hSendThread[0]){
		ASSERT(0); //TRACE all paths.
		hr=DPERR_NOMEMORY;
		goto exit4;
	}


	pProtocol->lpHandleTable=InitHandleTable(TABLE_INIT_SIZE,&pProtocol->csHandleTable,TABLE_GROW_SIZE);

	if(!pProtocol->lpHandleTable){
		goto exit5;
	}

	pProtocol->m_eState=Running;

	Unlock(&pProtocol->m_ObjLock);
	hr=DP_OK;
	
exit:
	if(hr==DP_OK){
		lpDPlay->pProtocol=(LPPROTOCOL_PART)pProtocol;
	} else {
		lpDPlay->pProtocol=NULL;
	}
	return hr;

//exit6: if more init written, may need this.
//	FiniHandleTable(pProtocol->lpHandleTable, &pProtocol->csHandleTable);
	

exit5:
	pProtocol->m_eState=ShuttingDown;
	SetEvent(pProtocol->m_hSendEvent);
	Unlock(&pProtocol->m_ObjLock);
	
	while(pProtocol->m_nSendThreads){
		// wait for the send thread to shut off.
		Sleep(0);
	}
	CloseHandle(pProtocol->m_hSendThread[0]);
	
	Lock(&pProtocol->m_ObjLock);
	
exit4:
	Unlock(&pProtocol->m_ObjLock);

//exit3:
	FiniRcvDescs(pProtocol);

	nInitCount--;
	if(!nInitCount){
		DeleteCriticalSection(&g_SendTimeoutListLock);
		FiniBufferPool();
		FiniBufferManager();
		FiniFrameBuffers();
		FiniSendStats();
		FiniSendDescs();
	}	
	
//exit2:
	CloseHandle(pProtocol->m_hSendEvent);
exit1:	
	DeleteCriticalSection(&pProtocol->m_SPLock);
	DeleteCriticalSection(&pProtocol->m_ObjLock);
	DeleteCriticalSection(&pProtocol->m_SessionLock);
	DeleteCriticalSection(&pProtocol->m_SendQLock);
	My_GlobalFree(pProtocol);
	goto exit;

	#undef TABLE_INIT_SIZE
	#undef TABLE_GROW_SIZE

	
}

/*=============================================================================

	FiniProtocol -
	
    Description:

    Parameters:


    Return Values:

-----------------------------------------------------------------------------*/

VOID WINAPI FiniProtocol(PPROTOCOL pProtocol)
{
	DWORD tmKill;
	//
	// Kill the send thread.
	//

	DPF(1,"==>ProtShutdown\n");

	Lock(&pProtocol->m_ObjLock);
	pProtocol->m_eState=ShuttingDown;
	SetEvent(pProtocol->m_hSendEvent);
	while(pProtocol->m_nSendThreads){
		// wait for the send thread to shut off.
		Unlock(&pProtocol->m_ObjLock);
		Sleep(0);
		Lock(&pProtocol->m_ObjLock);
	}
	Unlock(&pProtocol->m_ObjLock);
	
	CloseHandle(pProtocol->m_hSendThread[0]);

	DPF(1,"SHUTDOWN: Protocol Send Thread ShutDown, waiting for sessions\n");

	tmKill=timeGetTime()+60000;

	Lock(&pProtocol->m_SessionLock);
	while(pProtocol->m_nSessions && (((INT)(tmKill-timeGetTime())) > 0)){
		UINT SendRc;
		
		Unlock(&pProtocol->m_SessionLock);
		//NOTE: race.  when m_nSessions dereffed, there
		//        is a race for the protocol to be freed.
		Sleep(55);
		do {
			SendRc=SendHandler(pProtocol);
		} while (SendRc!=DPERR_NOMESSAGES);

		Lock(&pProtocol->m_SessionLock);
	}
	DPF(1,"SHUTDOWN: Sessions All Gone Freeing other objects.\n");
	
	//
	// Free the SESSION table
	//
	if(pProtocol->m_pSessions){
		My_GlobalFree(pProtocol->m_pSessions);
		pProtocol->m_pSessions=0;
	}	
	Unlock(&pProtocol->m_SessionLock);

	DeleteCriticalSection(&pProtocol->m_SendQLock);
	DeleteCriticalSection(&pProtocol->m_SessionLock);
	DeleteCriticalSection(&pProtocol->m_SPLock);
	DeleteCriticalSection(&pProtocol->m_ObjLock);

	CloseHandle(pProtocol->m_hSendEvent);

	FiniRcvDescs(pProtocol);
	
	nInitCount--;
	if(!nInitCount){
		// Last one out, turn off the lights...
		DeleteCriticalSection(&g_SendTimeoutListLock);
		FiniBufferPool();
		FiniBufferManager();
		FiniFrameBuffers();
		FiniSendStats();
		FiniSendDescs();
	}

	FiniHandleTable(pProtocol->lpHandleTable, &pProtocol->csHandleTable);
	
	My_GlobalFree(pProtocol);
	
	#ifdef DEBUG
		My_GlobalAllocDeInit();
	#endif
}


/*=============================================================================

	ProtocolCreatePlayer - Called by DPlay when SP needs to be notified of new
		                   player creation.

    Description:

		Creates a session for the id.  OPTIMIZATION: if local, don't need this?
		Also notifies the SP.

    Parameters:


    Return Values:

-----------------------------------------------------------------------------*/

HRESULT WINAPI ProtocolCreatePlayer(LPDPSP_CREATEPLAYERDATA pCreatePlayerData)
{
	DPLAYI_DPLAY *lpDPlay;
	PPROTOCOL    pProtocol;
	HRESULT      hr=DP_OK;


	lpDPlay=((DPLAYI_DPLAY_INT *)pCreatePlayerData->lpISP)->lpDPlay;
	ASSERT(lpDPlay);
	pProtocol=(PPROTOCOL)lpDPlay->pProtocol;
	ASSERT(pProtocol);
	pProtocol->m_dwIDKey=(DWORD)lpDPlay->lpsdDesc->dwReserved1;

	// Creates the session and gets one refcount.
	hr=CreateNewSession(pProtocol, pCreatePlayerData->idPlayer);

	if(hr==DP_OK){
		
		// Chain the call to the real provider.
		Lock(&pProtocol->m_SPLock);
		if(lpDPlay->pcbSPCallbacks->CreatePlayer){
			hr=CALLSP(lpDPlay->pcbSPCallbacks->CreatePlayer,pCreatePlayerData);
		}
		Unlock(&pProtocol->m_SPLock);

		if(hr!=DP_OK){
			PSESSION pSession;
			pSession=GetSession(pProtocol,pCreatePlayerData->idPlayer); //adds a ref
			if(pSession){
				DecSessionRef(pSession); // unGetSession
				DecSessionRef(pSession); // blow it away, noone could access yet.
			}	
		}

	}
	return hr;

}

/*=============================================================================

	ProtocolPreNotifyDeletePlayer

	Called to tell us a DELETEPLAYER message was enqueued for a particular
	player.  We need to drop the player NOW!

	We don't notify the SP, that will happen when we are called in
	ProtocolDeletePlayer later when the pending queue is processed.
	
    Description:

		Dereference the session for the player.

    Parameters:


    Return Values:

-----------------------------------------------------------------------------*/

HRESULT WINAPI ProtocolPreNotifyDeletePlayer(LPDPLAYI_DPLAY this, DPID idPlayer)
{
	PPROTOCOL    pProtocol;
	PSESSION     pSession;
	HRESULT      hr=DP_OK;

	pProtocol=(PPROTOCOL)this->pProtocol;
	ASSERT(pProtocol);

	pSession=GetSession(pProtocol,idPlayer);

	DPF(9,"==>Protocol Prenotify Delete Player %x, pSession %x\n",idPlayer, pSession);

	if(pSession){

		pSession->hClosingEvent=0;
#if 0	
		//NOTE: if you even think about putting this back, also do it in ProtocolDeletePlayer
		hClosingEvent=pSession->hClosingEvent=CreateEventA(NULL,FALSE,FALSE,NULL);

		if(hClosingEvent){
			ResetEvent(hClosingEvent);
		}
#endif		

		Lock(&pProtocol->m_SendQLock);
		Lock(&pSession->SessionLock);

		switch(pSession->eState)
		{	
			case Open:
				TimeOutSession(pSession);
				Unlock(&pSession->SessionLock);
				Unlock(&pProtocol->m_SendQLock);
				DecSessionRef(pSession); // balance GetSession
				DecSessionRef(pSession); // balance Creation - may destroy session, and signal event
				break;
				
			case Closing:
			case Closed:
				Unlock(&pSession->SessionLock);
				Unlock(&pProtocol->m_SendQLock);
				DecSessionRef(pSession); // balance GetSession
				break;
		}

#if 0
		if(hClosingEvent){
		//	Wait(hClosingEvent);
			CloseHandle(hClosingEvent);
		} else {
			DPF(0,"ProtocolPreNotifyDeletePlayer: couldn't get close event handle--not waiting...\n");
			ASSERT(0);			
		}
#endif		

	} else {
		DPF(0,"ProtocolPreNotifyDeletePlayer: couldn't find session for playerid %x\n",idPlayer);
		ASSERT(0);
	}

	DPF(9,"<==Protocol Prenotify DeletePlayer, hr=%x\n",hr);

	return hr;
}

/*=============================================================================

	ProtocolDeletePlayer - Called by DPlay when SP needs to be notified of
		                   player deletion.

    Description:

		Dereference the session for the player.  Then notifies the SP.

    Parameters:


    Return Values:

-----------------------------------------------------------------------------*/

HRESULT WINAPI ProtocolDeletePlayer(LPDPSP_DELETEPLAYERDATA pDeletePlayerData)
{

	DPLAYI_DPLAY *lpDPlay;
	PPROTOCOL    pProtocol;
	PSESSION     pSession;
	HRESULT      hr=DP_OK;
	//HANDLE       hClosingEvent;

	lpDPlay=((DPLAYI_DPLAY_INT *)pDeletePlayerData->lpISP)->lpDPlay;
	ASSERT(lpDPlay);
	pProtocol=(PPROTOCOL)lpDPlay->pProtocol;
	ASSERT(pProtocol);

	pSession=GetSession(pProtocol,pDeletePlayerData->idPlayer);

	DPF(9,"==>Protocol Delete Player %x, pSession %x\n",pDeletePlayerData->idPlayer, pSession);

	if(pSession){

		pSession->hClosingEvent=0;
		
	#if 0	
		//NOTE: if you even think about putting this back, also do it in ProtocolPreNotifyDeletePlayer

		hClosingEvent=pSession->hClosingEvent=CreateEventA(NULL,FALSE,FALSE,NULL);

		if(hClosingEvent){
			ResetEvent(hClosingEvent);
		}
	#endif	

		Lock(&pProtocol->m_SendQLock);
		Lock(&pSession->SessionLock);
		
		switch(pSession->eState)
		{	
			case Open:
				TimeOutSession(pSession);
			case Closing:
				Unlock(&pSession->SessionLock);
				Unlock(&pProtocol->m_SendQLock);
				DecSessionRef(pSession); // balance GetSession
				DecSessionRef(pSession); // balance Creation - may destroy session, and signal event
				break;
				
			case Closed:
				Unlock(&pSession->SessionLock);
				Unlock(&pProtocol->m_SendQLock);
				DecSessionRef(pSession); // balance GetSession
				break;
		}

	#if 0
		if(hClosingEvent){
		//	Wait(hClosingEvent);
			CloseHandle(hClosingEvent);
		} else {
			DPF(0,"ProtocolDeletePlayer: couldn't get close event handle--not waiting...\n");
			ASSERT(0);			
		}
	#endif	

	} else {
		DPF(0,"ProtocolDeletePlayer: couldn't find session for playerid %x, ok if ProtocolPreNotifyDeletPlayer ran.\n",pDeletePlayerData->idPlayer);
	}

	DPF(9,"Protocol, deleted player id %x\n",pDeletePlayerData->idPlayer);

	DPF(9,"<==ProtocolDeletePlayer, hr=%x\n",hr);

	return hr;
}

/*=============================================================================

	ProtocolSendEx -
	
    Description:


    Parameters:


    Return Values:

-----------------------------------------------------------------------------*/

HRESULT WINAPI ProtocolSendEx(LPDPSP_SENDEXDATA pSendData)
{
	DPSP_SENDDATA sd;
	DPLAYI_DPLAY *lpDPlay;
	PPROTOCOL    pProtocol;
	HRESULT      hr=DP_OK;
	DWORD        dwCommand;
	
	PUCHAR pBuffer;

	lpDPlay=((DPLAYI_DPLAY_INT *)pSendData->lpISP)->lpDPlay;
	ASSERT(lpDPlay);

	pProtocol=(PPROTOCOL)lpDPlay->pProtocol;
	ASSERT(pProtocol);

	ASSERT(lpDPlay->dwFlags & DPLAYI_PROTOCOL);

	if(pSendData->lpSendBuffers->len >= 8){
		pBuffer=pSendData->lpSendBuffers->pData;

		if((*((DWORD *)pBuffer)) == SIGNATURE('p','l','a','y')){
		
			dwCommand=GET_MESSAGE_COMMAND((LPMSG_SYSMESSAGE)pBuffer);

			switch(dwCommand){
				case DPSP_MSG_PACKET2_DATA:
				case DPSP_MSG_PACKET2_ACK:
				case DPSP_MSG_PACKET:
					goto send_non_protocol_message;
					break;
		
				default:
					break;
			}
		}
		
	}


	// OPTIMIZATION:, make Send take the SENDEXDATA struct only.
	hr=Send(pProtocol,
			pSendData->idPlayerFrom,
			pSendData->idPlayerTo,
		 	pSendData->dwFlags,
			pSendData->lpSendBuffers,
		 	pSendData->cBuffers,
		 	pSendData->dwPriority,
		 	pSendData->dwTimeout,
		 	pSendData->lpDPContext,
		 	pSendData->lpdwSPMsgID,
		 	TRUE,
			NULL);  // forces us to be called back in InternalSendComplete, if Send is ASYNC.

	return hr;
	
send_non_protocol_message:

	ENTER_DPLAY();
	
	Lock(&pProtocol->m_SPLock);
	
	if(lpDPlay->pcbSPCallbacks->SendEx){
		hr=CALLSP(lpDPlay->pcbSPCallbacks->SendEx,pSendData);	
	} else {
		hr=ConvertSendExDataToSendData(lpDPlay, pSendData, &sd);
		if(hr==DP_OK){
			hr=CALLSP(lpDPlay->pcbSPCallbacks->Send, &sd);
			MsgFree(NULL, sd.lpMessage);
		}
	}
	
	Unlock(&pProtocol->m_SPLock);
	
	LEAVE_DPLAY();

	return hr;

}

/*=============================================================================

	ProtocolGetMessageQueue -
	
    Description:


    Parameters:


    Return Values:

-----------------------------------------------------------------------------*/

HRESULT WINAPI ProtocolGetMessageQueue(LPDPSP_GETMESSAGEQUEUEDATA pGetMessageQueueData)
{
	#define pData pGetMessageQueueData
	
	DPLAYI_DPLAY *lpDPlay;
	PPROTOCOL    pProtocol;
	PSESSION     pSession;
	HRESULT      hr=DP_OK;

	BILINK *pBilink;
	PSEND pSend;

	DWORD dwNumMsgs;
	DWORD dwNumBytes;

	lpDPlay=((DPLAYI_DPLAY_INT *)pData->lpISP)->lpDPlay;
	ASSERT(lpDPlay);

	pProtocol=(PPROTOCOL)lpDPlay->pProtocol;
	ASSERT(pProtocol);

	dwNumMsgs=0;
	dwNumBytes=0;

	if(!pData->idTo && !pData->idFrom){
		// just wants totals, I know that!
		EnterCriticalSection(&pProtocol->m_SendQLock);
		dwNumMsgs  = pProtocol->m_dwMessagesPending;
		dwNumBytes = pProtocol->m_dwBytesPending;
		LeaveCriticalSection(&pProtocol->m_SendQLock);

	} else if(pData->idTo){

		// Given idTo, walk that target's sendQ

		pSession=GetSysSession(pProtocol,pData->idTo);

		if(!pSession) {
			DPF(0,"GetMessageQueue: NO SESSION for idTo %x, returning INVALIDPLAYER\n",pData->idTo);
			hr=DPERR_INVALIDPLAYER;
			goto exit;
		}
		
		EnterCriticalSection(&pSession->SessionLock);

		pBilink=pSession->SendQ.next;

		while(pBilink != &pSession->SendQ){
			pSend=CONTAINING_RECORD(pBilink, SEND, SendQ);
			pBilink=pBilink->next;

			if((pSend->idTo==pData->idTo) && (!pData->idFrom || (pSend->idFrom == pData->idFrom))){
				dwNumBytes += pSend->MessageSize;
				dwNumMsgs += 1;
			}

		}

		LeaveCriticalSection(&pSession->SessionLock);
		
		DecSessionRef(pSession);

	} else {
		ASSERT(pData->idFrom);
		// Geting Queue for a from id, this is most costly
		EnterCriticalSection(&pProtocol->m_SendQLock);
		
		pBilink=pProtocol->m_GSendQ.next;

		while(pBilink != &pProtocol->m_GSendQ){
			pSend=CONTAINING_RECORD(pBilink, SEND, m_GSendQ);
			pBilink=pBilink->next;

			if(pData->idFrom == pSend->idFrom){
				if(!pData->idTo || pData->idTo==pSend->idTo){
					dwNumBytes += pSend->MessageSize;
					dwNumMsgs += 1;
				}
			}
		}
			
		LeaveCriticalSection(&pProtocol->m_SendQLock);
	}

	if(pData->lpdwNumMsgs){
		*pData->lpdwNumMsgs=dwNumMsgs;
	}

	if(pData->lpdwNumBytes){
		*pData->lpdwNumBytes=dwNumBytes;
	}
	
exit:
	return hr;
	
	#undef pData
}


/*=============================================================================

	ProtocolCancel -
	
    Description:


    Parameters:


    Return Values:

-----------------------------------------------------------------------------*/

HRESULT WINAPI ProtocolCancel(LPDPSP_CANCELDATA pCancelData)
{
	#define pData pCancelData
	
	DPLAYI_DPLAY *lpDPlay;
	PPROTOCOL    pProtocol;
	HRESULT      hr=DP_OK;
	DWORD        nCancelled=0;
	BILINK       *pBilink;
	BOOL         bCancel;
	UINT         i;
	UINT         j;
	DWORD        dwContext;
	PSEND        pSend;

	lpDPlay=((DPLAYI_DPLAY_INT *)pData->lpISP)->lpDPlay;
	ASSERT(lpDPlay);

	pProtocol=(PPROTOCOL)lpDPlay->pProtocol;
	ASSERT(pProtocol);

	EnterCriticalSection(&pProtocol->m_SendQLock);

	if(pData->dwFlags) {

		// either cancelpriority or cancel all, either way we
		// need to scan...
	
		pBilink=pProtocol->m_GSendQ.next;

		while(pBilink!=&pProtocol->m_GSendQ){

			pSend=CONTAINING_RECORD(pBilink, SEND, m_GSendQ);
			pBilink=pBilink->next;

			bCancel=FALSE;

			Lock(&pSend->SendLock);

			switch(pSend->SendState){
			
				case Start:
				case WaitingForId:
					if(pData->dwFlags & DPCANCELSEND_PRIORITY) {
						// Cancel sends in priority range.
						if((pSend->Priority <= pData->dwMaxPriority) &&
						   (pSend->Priority >= pData->dwMinPriority)){
						   	bCancel=TRUE;
						}
					} else if(pData->dwFlags & DPCANCELSEND_ALL) {
						// Cancel all sends that can be.
						bCancel=TRUE;
					} else {
						ASSERT(0); // Invalid flags, should never happen
					}

					if(bCancel){
						if(pSend->SendState == WaitingForId){
							if(pSend->dwFlags & DPSEND_GUARANTEED){
								InterlockedDecrement(&pSend->pSession->nWaitingForMessageid);
							} else {
								InterlockedDecrement(&pSend->pSession->nWaitingForDGMessageid);
							}
						}
						nCancelled+=1;
						pSend->SendState=Cancelled;
					}
				break;	
				
				default:
					DPF(5,"Couldn't cancel send %x in State %d, already sending...\n",pSend,pSend->SendState);
			}

			Unlock(&pSend->SendLock);
		}	

	} else {
		// No flags, therefore we have a list to cancel so lookup
		// each send and cancel rather than scanning as above.

		// Run through the list, find the sends and lock em 1st, if we find one that doesn't lookup,
		// or one not in the start state, then we bail.  We then unlock them all.

		for(i=0;i<pData->cSPMsgID;i++){

			dwContext=(DWORD)((DWORD_PTR)((*pData->lprglpvSPMsgID)[i]));
			
			pSend=(PSEND)ReadHandleTableEntry(&pProtocol->lpHandleTable, &pProtocol->csHandleTable, dwContext);
			
			if(pSend){
				Lock(&pSend->SendLock);
				if(pSend->SendState != Start && pSend->SendState != WaitingForId){
					Unlock(&pSend->SendLock);
					hr=DPERR_CANCELFAILED;
					break;
				}
			} else {
				hr=DPERR_CANCELFAILED;
				break;
			}

		}

		if(hr==DPERR_CANCELFAILED) {
			// release all the locks.
			for(j=0;j<i;j++){
				dwContext=(DWORD)((DWORD_PTR)((*pData->lprglpvSPMsgID)[j]));
				pSend=(PSEND)ReadHandleTableEntry(&pProtocol->lpHandleTable, &pProtocol->csHandleTable, dwContext);
				ASSERT(pSend);
				Unlock(&pSend->SendLock);
			}
		} else {
			// mark the sends cancelled and release all the locks.
			for(i=0;i<pData->cSPMsgID;i++){
				dwContext=(DWORD)((DWORD_PTR)((*pData->lprglpvSPMsgID)[i]));
				pSend=(PSEND)ReadHandleTableEntry(&pProtocol->lpHandleTable, &pProtocol->csHandleTable, dwContext);
				ASSERT(pSend);
				if(pSend->SendState == WaitingForId){
					if(pSend->dwFlags & DPSEND_GUARANTEED){
						InterlockedDecrement(&pSend->pSession->nWaitingForMessageid);
					} else {
						InterlockedDecrement(&pSend->pSession->nWaitingForDGMessageid);
					}
				}
				pSend->SendState=Cancelled;
				nCancelled+=1;
				Unlock(&pSend->SendLock);
			}
		}
	}
	
	LeaveCriticalSection(&pProtocol->m_SendQLock);
	
	SetEvent(pProtocol->m_hSendEvent);
	return hr;
	
	#undef pData
}

/*=============================================================================

	ProtocolSend - Send A message synchronously.
	
    Description:


    Parameters:


    Return Values:

-----------------------------------------------------------------------------*/
DWORD bForceDGAsync=FALSE;

HRESULT WINAPI ProtocolSend(LPDPSP_SENDDATA pSendData)
{

	DPLAYI_DPLAY *lpDPlay;
	PPROTOCOL    pProtocol;
	HRESULT      hr=DP_OK;
	DWORD        dwCommand;
	DWORD		 dwPriority;
	DWORD		 dwFlags;
	
	PUCHAR pBuffer;

	MEMDESC memdesc;

	lpDPlay=((DPLAYI_DPLAY_INT *)pSendData->lpISP)->lpDPlay;
	ASSERT(lpDPlay);

	pProtocol=(PPROTOCOL)lpDPlay->pProtocol;
	ASSERT(pProtocol);
	pBuffer=&(((PUCHAR)(pSendData->lpMessage))[pProtocol->m_dwSPHeaderSize]);

	if((*((DWORD *)pBuffer)) == SIGNATURE('p','l','a','y')){
	
		dwCommand=GET_MESSAGE_COMMAND((LPMSG_SYSMESSAGE)pBuffer);

		switch(dwCommand){
			case DPSP_MSG_PACKET2_DATA:
			case DPSP_MSG_PACKET2_ACK:
			case DPSP_MSG_ENUMSESSIONSREPLY:
			case DPSP_MSG_PACKET:
				goto send_non_protocol_message;
				break;
				
			default:
				break;
		}
	}

	memdesc.pData=((PUCHAR)pSendData->lpMessage)+pProtocol->m_dwSPHeaderSize;
	memdesc.len  =pSendData->dwMessageSize-pProtocol->m_dwSPHeaderSize;

	if(pSendData->dwFlags & DPSEND_HIGHPRIORITY){
		pSendData->dwFlags &= ~(DPSEND_HIGHPRIORITY);
		dwPriority=0xFFFFFFFE;
	} else {
		dwPriority=1000;
	}

	dwFlags = pSendData->dwFlags;
	if(bForceDGAsync && !(dwFlags&DPSEND_GUARANTEE)){
		// for testing old apps with protocol make datagram sends
		// async so that the application doesn't block.
		dwFlags |= DPSEND_ASYNC;
	}


	hr=Send(pProtocol,
			pSendData->idPlayerFrom,
			pSendData->idPlayerTo,
		 	dwFlags,
			&memdesc,
		 	1,
		 	dwPriority,
		 	0,
		 	NULL,
		 	NULL,
		 	FALSE,
			NULL);

	return hr;
	
send_non_protocol_message:
	if((*((DWORD *)pBuffer)) == SIGNATURE('p','l','a','y')){
		DPF(9,"Send Message %d Ver %d\n", pBuffer[4]+(pBuffer[5]<<8),pBuffer[6]+(pBuffer[7]<<8));
	}

	ENTER_DPLAY();
	Lock(&pProtocol->m_SPLock);
	hr=CALLSP(lpDPlay->pcbSPCallbacks->Send,pSendData);	
	Unlock(&pProtocol->m_SPLock);
	LEAVE_DPLAY();

	return hr;

}

/*=============================================================================

	GetPlayerLatency - Get Latency for a player
	
    Description:


    Parameters:


    Return Values:

-----------------------------------------------------------------------------*/

DWORD GetPlayerLatency(LPDPLAYI_DPLAY lpDPlay, DPID idPlayer)
{
	PPROTOCOL    pProtocol;
	PSESSION     pSession;
	DWORD        dwLatency=0;	// default, means I don't know latency

	pProtocol=(PPROTOCOL)lpDPlay->pProtocol;
	ASSERT(pProtocol);

	pSession=GetSession(pProtocol,idPlayer);

	DPF(9,"==>Protocol GetPlayer Latency %x, pSession %x\n",idPlayer, pSession);

	if(pSession){

		Lock(&pSession->SessionLock);

		// Protocol Latency is round trip in 24.8 fixed point,
		// we net round trip latency divided by 2, so shift right 9.
		dwLatency=(pSession->FpLocalAverageLatency)>>(9);

		Unlock(&pSession->SessionLock);
	
		DecSessionRef(pSession); // balance GetSession

	}
	DPF(9,"<==Protocol GetPlayerLatency, returning dwLat=%x\n",dwLatency);

	return dwLatency;
}

/*=============================================================================

	ProtocolGetCaps - Get Service Provider Capabilities
	
    Description:


    Parameters:


    Return Values:

-----------------------------------------------------------------------------*/

HRESULT WINAPI ProtocolGetCaps(LPDPSP_GETCAPSDATA pGetCapsData)
{
	#define ALL_PROTOCOLCAPS	(DPCAPS_SENDPRIORITYSUPPORTED | \
								 DPCAPS_ASYNCSUPPORTED        | \
								 DPCAPS_SENDTIMEOUTSUPPORTED  | \
								 DPCAPS_ASYNCCANCELSUPPORTED  )

	DPLAYI_DPLAY *lpDPlay;
	PPROTOCOL    pProtocol;
	HRESULT      hr=DP_OK;

	lpDPlay=((DPLAYI_DPLAY_INT *)pGetCapsData->lpISP)->lpDPlay;
	ASSERT(lpDPlay);
	pProtocol=(PPROTOCOL)lpDPlay->pProtocol;
	ASSERT(pProtocol);

	// Chain the call to the real provider.
	Lock(&pProtocol->m_SPLock);
	if(lpDPlay->pcbSPCallbacks->GetCaps){
		hr=CALLSP(lpDPlay->pcbSPCallbacks->GetCaps,pGetCapsData);
	}
	Unlock(&pProtocol->m_SPLock);

	// if it fails, this doesn't hurt
	if(lpDPlay->dwFlags & DPLAYI_DPLAY_PROTOCOL)
	{
	    // 1 megabyte is lots (says Jamie Osborne)
		pGetCapsData->lpCaps->dwMaxBufferSize=0x100000;
		pGetCapsData->lpCaps->dwFlags |= ALL_PROTOCOLCAPS;
	}
	
	if(pGetCapsData->idPlayer && !pGetCapsData->lpCaps->dwLatency){
		// SP refused to guess at latency, so use ours.
		pGetCapsData->lpCaps->dwLatency=GetPlayerLatency(lpDPlay, pGetCapsData->idPlayer);
	}
	
	return hr;
	
	#undef ALL_PROTOCOLCAPS
}

DWORD ExtractProtocolIds(PUCHAR pInBuffer, DWORD cbBuffer, PUINT pdwIdFrom, PUINT pdwIdTo)
{
	PCHAR pBuffer=pInBuffer;
	DWORD dwIdFrom=0;
	DWORD dwIdTo=0;
	DWORD cbLeft=cbBuffer;

	dwIdFrom=*pBuffer&0x7F;
	if(*pBuffer&0x80){
		pBuffer++;
		cbLeft--;
		if(0==cbLeft)goto error_exit;
		dwIdFrom=dwIdFrom+((*pBuffer&0x7F)<<7);
		if(*pBuffer&0x80){
			pBuffer++;
			cbLeft--;
			if(0==cbLeft)goto error_exit;
			dwIdFrom=dwIdFrom+((*pBuffer&0x7F)<<14);
			if(dwIdFrom > 0xFFFF || *pBuffer&0x80){
				DPF(0,"INVALID FROM ID  %x IN MESSAGE, REJECTING PACKET\n",dwIdFrom);
				return 0;
			}
		}
	}

	if(dwIdFrom==0xFFFF){
		dwIdFrom=0x70;
	}
	
	pBuffer++;
	cbLeft--;
	if(0==cbLeft)goto error_exit;

	dwIdTo=*pBuffer&0x7F;
	if(*pBuffer&0x80){
		pBuffer++;
		cbLeft--;
		if(0==cbLeft)goto error_exit;
		dwIdTo=dwIdTo+((*pBuffer&0x7F)<<7);
		if(*pBuffer&0x80){
			pBuffer++;
			cbLeft--;
			if(0==cbLeft)goto error_exit;
			dwIdTo=dwIdTo+((*pBuffer&0x7F)<<14);
			if(dwIdTo > 0xFFFF || *pBuffer&0x80){
				DPF(0,"INVALID TO ID  %x IN MESSAGE, REJECTING PACKET\n",dwIdTo);
				return 0;
			}
		}
	}

	*pdwIdFrom=dwIdFrom;
	*pdwIdTo=dwIdTo;

	pBuffer++;
	cbLeft--;
	if(0==cbLeft)goto error_exit;
	
//	DPF(9, "In ExtractProtocolIds: from %x became %x\n", *(DWORD *)pInBuffer, dwIdFrom);
	return (DWORD)(pBuffer-pInBuffer);

error_exit:
	DPF(1,"SECURITY WARN: Invalid To/From in Protoocl ID fields");
	return 0;
}

/*=============================================================================

	DP_SP_ProtocolHandleMessage - Packet handler for Dplay protocol
	
	
    Description:

		All messages go through here when the protocol is active.  If the
		message is not a protocol message, this routine doesn't process
		it and returns DPERR_NOTHANDLED to let other layers (probably
		PacketizeAndSend) process it.
	

    Parameters:

		IDirectPlaySP * pISP  - pointer to pISP interface
		LPBYTE pReceiveBuffer - a single buffer of data
		DWORD dwMessageSize   - length of the buffer
		LPVOID pvSPHeader     - pointer to SP's header used in Reply

    Return Values:

	Notes:

		We don't worry about re-entering DP_SP_HandleMessage since
		we are calling only when a receive has completed and we are in the
		callback from the SP to directplay, so effectively the SP is
		serializing receives for us.

		The receive code is actually written to be re-entrant, so if we
		ever decide to allow concurrent receive processing the protocol
		can handle it.

		Protocol messages start with 'P','L','A','Y','0xFF' when not RAW.


		DPLAY gets handleMessage first, and hands off to protocol if active.
-----------------------------------------------------------------------------*/


HRESULT DPAPI DP_SP_ProtocolHandleMessage(
	IDirectPlaySP * pISP,
	LPBYTE pReceiveBuffer,
	DWORD dwMessageSize,
	LPVOID pvSPHeader)
{
	DPLAYI_DPLAY *lpDPlay;
	DWORD dwIdFrom, dwIdTo;
	PBUFFER pRcvBuffer;
	PPROTOCOL pProtocol;
	
	lpDPlay=DPLAY_FROM_INT(pISP);
	pProtocol=(PPROTOCOL)lpDPlay->pProtocol;

	if(!pProtocol){
		goto handle_non_protocol_message;
	}

	if(pProtocol->m_lpDPlay->dwFlags & DPLAYI_DPLAY_PROTOCOL){

		// Running in RAW mode there is no dplay header on protocol
		// messages.  If we see one with a header or we don't receive
		// a message large enough to be a protocol message we punt it.
	
		if(dwMessageSize >= 4 &&
		  (*((DWORD *)pReceiveBuffer)) == SIGNATURE('p','l','a','y'))
		{
			// Got a system message.
		  	goto handle_non_protocol_message;
		}
		
		if( dwMessageSize < 6 ){
			goto handle_non_protocol_message;
		}

	} else {
		// this can happen when shutting down.
		DPF(0,"Protocol still up, but no bits set, not handling receive (must be shutting down?)");
		goto handle_non_protocol_message;
	}
	
	// Hey, this must be ours...

	Lock(&pProtocol->m_ObjLock);
	if(pProtocol->m_eState==Running){	// just a sanity check, we don't depend on it after dropping lock.

		DWORD idLen;
	
		Unlock(&pProtocol->m_ObjLock);

		idLen = ExtractProtocolIds(pReceiveBuffer,dwMessageSize,&dwIdFrom,&dwIdTo);

		if(!idLen){
			goto handle_non_protocol_message;
		}

		if(dwMessageSize <= idLen){
			DPF(1,"SECURITY WARN: protocol header contains Ids but no content, illegal");
			return DP_OK;
		}
		pRcvBuffer=GetFrameBuffer(dwMessageSize-idLen);
		if(!pRcvBuffer){
			// couldn't allocate a buffer, but we are allowed to drop frames, so drop it.
			return DP_OK;
		}
		pRcvBuffer->len=dwMessageSize-idLen;
		memcpy(pRcvBuffer->pData, pReceiveBuffer+idLen,pRcvBuffer->len);

		DPF(9,"DP_SP_ProtocolHandleMessage	From %x	To %x\n",dwIdFrom,dwIdTo);

		ENTER_DPLAY();

		ProtocolReceive((PPROTOCOL)lpDPlay->pProtocol, (WORD)dwIdFrom, (WORD)dwIdTo, pRcvBuffer,pvSPHeader);

		LEAVE_DPLAY();
	} else {
		Unlock(&pProtocol->m_ObjLock);
	}

	return DP_OK;
	
handle_non_protocol_message:
	return DPERR_NOTHANDLED;
}

// DP_SP_ProtocolSendComplete is the callback handler for all completions since there is no other
// way to wrap the completion. When the protocol is not present, this just calls the DPLAY handler
// immediately.

VOID DPAPI DP_SP_ProtocolSendComplete(
	IDirectPlaySP * pISP,
	LPVOID          lpvContext,
	HRESULT         CompletionStatus)
{
	DPLAYI_DPLAY *lpDPlay;
	PPROTOCOL pProtocol;

	lpDPlay=DPLAY_FROM_INT(pISP);

	if(lpDPlay->pProtocol){

		// NOTE: when SP SendEx is used, we have to patch and xlate here.
		// for now, this should never happen.

		DEBUG_BREAK(); // Shouldn't get here yet.
		
		pProtocol=(PPROTOCOL)lpDPlay->pProtocol;

		DP_SP_SendComplete(pISP, lpvContext, CompletionStatus);

	} else {

		DP_SP_SendComplete(pISP, lpvContext, CompletionStatus);
	
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\protocol\handles.h ===
/*++

Copyright (c) 1996,1997  Microsoft Corporation

Module Name:

    HANDLES.H

Abstract:

	Handle Table

Author:

	Aaron Ogus (aarono)

Environment:

	Win32

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
   2/16/98 aarono  Original

--*/

#ifndef _MYHANDLE_H_
#define _MYHANDLE_H_

#define LIST_END 0xFFFFFFFF

#define MYHANDLE_DEFAULT_GROWSIZE 16

#define N_UNIQUE_BITS 16
#define UNIQUE_ADD (1<<(32-N_UNIQUE_BITS))
#define CONTEXT_INDEX_MASK (UNIQUE_ADD-1)
#define CONTEXT_UNIQUE_MASK (0xFFFFFFFF-CONTEXT_INDEX_MASK)

typedef struct _myhandle {
	LPVOID lpv;
	union {
		UINT nUnique;
		UINT iNext;
	};	
} MYHANDLE, *LPMYHANDLE;

typedef struct _myhandletable {
	UINT	nUnique;
	UINT    nTableSize;
	UINT    nTableGrowSize;
	UINT    iNext;
	MYHANDLE Table[0];
} MYHANDLETABLE, *LPMYHANDLETABLE;

typedef volatile LPMYHANDLETABLE VOLLPMYHANDLETABLE, *LPVOLLPMYHANDLETABLE;

extern VOLLPMYHANDLETABLE InitHandleTable(UINT nSize, CRITICAL_SECTION *pcs, UINT nGrowSize);
extern VOID FiniHandleTable(LPMYHANDLETABLE lpTable, CRITICAL_SECTION *pcs);

extern DWORD AllocHandleTableEntry(LPVOLLPMYHANDLETABLE lplpTable, CRITICAL_SECTION *pcs, LPVOID lpv);
extern LPVOID ReadHandleTableEntry(LPVOLLPMYHANDLETABLE lplpTable, CRITICAL_SECTION *pcs, UINT handle);
extern HRESULT FreeHandleTableEntry(LPVOLLPMYHANDLETABLE lplpTable, CRITICAL_SECTION *pcs, UINT handle);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\protocol\protocol.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    PROTOCOL.H

Abstract:

	Another Reliable Protocol - CPP implementation

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
  12/10/96 aarono  Original
   2/11/97 aarono  Removed channel from header, now rides in body of 1st packet.
   					 								along with the length field.
   3/12/97 aarono  channel is gone, not relevant to transport protocol, can be
                   prepended to messages that want it.  Length field is gone,
                   not required.
   6/6/98  aarono  Turn on throttling and windowing - fix some definitions
--*/

#ifndef _PROTOCOL_H_
#define _PROTOCOL_H_

#pragma pack(push,1)

typedef unsigned char  byte;
typedef unsigned short word;
typedef unsigned int   dword;

//
// ARP - Another Reliable Protocol - Packet Definitions
//

// Terminology
//
// message - an arbitrary sized chunk of data
// to be sent from one computer to a another over
// the available media.
//
// packet - a piece of a message broken down
// for the media, including protocol information
// to allow the message to be reconstructed at
// the other end.
//
// frame - an instance of a packet.
//
// Assumptions:
//
// All values on the wire are little endian.
//
// This protocol allows packets to arrive out of
// order but is optimized for the in-order case.
//

#define EXT 0x80    /* EXTENSION BIT            */
#define BIG 0x40    /* BIG HEADERS (FAST MEDIA) */
#define CMD 0x20    /* COMMAND FRAME            */
#define STA 0x10
#define EOM	0x08	/* END OF MESSAGE           */
#define SAK 0x04    /* SEND ME AN ACK           */
#define ACK 0x02    /* ACKNOWLEDGE FRAME        */
#define RLY 0x01    /* RELIABLE FRAME           */

// Shifts used in small extended fields.

#define nNACK_MSK   0x60
#define nNACK_SHIFT 5
#define CMD_MSK     0x1F

#define IDMSK  (pCmdInfo->IDMSK)
#define SEQMSK (pCmdInfo->SEQMSK)

// Note: abort packets contain serial numbers but no sequence numbers.
//       the nACK field can be used to abort many messages at the same
//       time. (using ABORT2 or ABORT3).  Also just the messageid is 
//       provided in the abort case.

typedef struct _Packet1 {	// simple small -I- frame
	byte	flags;
	byte    messageid;
	byte	sequence;
	byte    serial;
	byte    data[0];
} Packet1, *pPacket1;

typedef struct _Packet2 {   // simple large -I- frame
	byte	flags;
	word    messageid;
	word 	sequence;
	byte	serial;
	byte    data[0];
} Packet2, *pPacket2;	

typedef	struct {
	byte     flag1;     // header flags
	byte     flag2;     // extended flags for small hdr/command for lrg
	byte     flag3;     // nNACK for large hdr.
	byte     pad;		// make it a dword.
} FLAGS, *pFLAGS;

// different frame components that may be part of any
// frame.  type 1 - small frames, type 2 - large frames

//
// ACKNOWLEDGE information
//

typedef struct _ACK1 {
	byte    messageid;
	byte	sequence;
	byte 	serial;
	dword   bytes;		// bytes received from remote
	dword   time;		// time when bytes received was this value
} ACK1, *pACK1;

typedef struct _ACK2 {
	word    messageid;
	word    sequence;
	byte    serial;
	dword   bytes;		// bytes received from remote
	dword   time;		// remote time when bytes receive was this value
} ACK2, *pACK2;	

//
// ABORT
//

typedef struct _ABT1 {
	byte    messageid;
	byte	sequence;
} ABT1, *pABT1;	

typedef struct _ABT2 {
	word	messageid;
	word	sequence;
} ABT2, *pABT2;

//
// MISSING packet information
//

typedef struct _NACK1 {
	byte    messageid;
	byte	sequence;
	dword	bytes;		// bytes received from remote
	dword   time;		// remote time when bytes received was this value
	byte    mask[0];
} NACK1, *pNACK1;

typedef struct _NACK2 {
	word	messageid;
	word	sequence;
	dword   bytes;		// bytes received from remote
	dword   time;		// remote time when bytes received was this value
	byte    mask[0];
} NACK2, *pNACK2;

//
// COMMAND information (including -I- frames)
//

typedef struct _CMD1 {
	byte    messageid;
	byte	sequence;
	byte	serial;
	byte	data[0];
} CMD1, *pCMD1;

typedef struct _CMD2 {
	word	messageid;
	word	sequence;
	byte    serial;
	byte	data[0];
} CMD2, *pCMD2;

#pragma pack(pop)

#endif

/*==============================================================================
                       Protocol Operational description
                       ================================

    Characteristics:
    ----------------
    
	The ARP protocol provides for reliable and non-reliable packet delivery
	over an existing non-reliable (datagram) protocol.  It is assumed that
	packet length information and addressing information is carried by the
	datagram protocol and these fields are therefore ambiguous and excluded
	from ARP.

	ARP is optimized to provide a minimum of overhead in the case of low
	bandwidth links. The overhead per-packet is 3 bytes.

	ARP's default command is the delivery of I frames.  This avoids the need
	for a command field in the protocol header for the most common frame type.

	ARP does segmentation and reassembly on large datagram messages.  This
	allows for datagram delivery of messages larger than 1 packet.

	ARP does a hybrid of windowing with selective NACK of missing packets,
	allowing optimal operation on both good and weak links, regardless
	of latency.

	ARP assigns each frame a serial number that is used in the ACK responses.
	This allows the protocol to keep up to date latency information as well
	as recognize which packet is being responded to in a retry situation. 
	The serial number allows the protocol to adjust timeouts reliably.

	ARP allows multiple messages to be sent concurrently.  Having multiple 
	messages prevents the system from blocking on retry from a single packet 
	transmission failure.  It also allows better use of available bandwidth
	since the protocol does not wait for the ACK from one message before 
	sending the next.

	{FUTURE: What about packet sub-allocation?  Bandwidth allocation?}
	

	Header Description:
	-------------------

	Flags:

	+-----+-----+-----+-----+-----+-----+-----+-----+
	| EXT | BIG | CMD | STA | EOM | SAK | ACK | RLY |  
	+-----+-----+-----+-----+-----+-----+-----+-----+

	Extended Flags:

	Small:

	+-----+-----+-----+-----+-----+-----+-----+-----+
	| EXT |   nNACK   |         COMMAND             |
	+-----+-----+-----+-----+-----+-----+-----+-----+


	Big:

	+-----+-----------------------------------------+
	| EXT |              COMMAND                    | (only if CMD & BIG set)
	+-----+-----------------------------------------+
	| EXT |               nNACK                     |
	+-----+-----------------------------------------+

	Flags:

	STA   - start of a message.
	EOM   - this bit is set when the packet is the last packet of a message
	ACK   - used to signify that this is an ACK packet, otherwise a COMMAND
		    - if nACK != 0, the ACK is informative only. i.e - tells client
		      last ACKed frame that instigated the nACK to update latency
		      information.  An ACK without nACK indicates all frames up
		      to the ACK frame were successfully received.  Any bit set
		      in the nACK mask indicates a missing frame, any 0 bit indicates
		      a frame that was successfully received.
	SAK   - when this bit is set, the receiver must send an ACK packet
	        for this packet.
	RLY   - indicates that this message is being delivered reliably.
	BIG   - when this bit is set, the packets are in large format TYPE 3.
	CMD   - command frame.  When this bit is set, the packet contains a 
	        command.  If there is no COMMAND field it is an I frame.
	EXT   - when the BIG bit is not set, indicates extended flags are present.

	Extended Flags:

	nNACK - if non-zero indicates presence of nNACK byte masks.  The NACK 
			field consists of a sequence number followed by nNACK byte masks.  
			Each bit in the mask represents a packet after the packet specified
			in the sequence number.  The packet in the sequence number is also
			being NACKed.
	
	Command:

	The command field is used to specify protocol subcommands.  The following
	are defined.  Commands larger than 15 require BIG packets.  Commands that
	require responses include the response in the ACK packet.  All protocol
	commands are unreliable.  Each command has its own messageid sequence and
	serial.  This means commands can be of arbitrary length.  The Response
	to a command is also a command.

	0000  0 - Default           - I Frame or ACK/NACK (nACK != 0)
	0001  1 - ABORT
	0010  2 - Ping              - send packet back to sender.
	0011  3 - Ping Response     - a message being returned.
	0100  4 - GetTime           - Get the tick count.
	0101  5 - Get Time Response - Response to the Get Time request.
	0110  6 - SetTime           - Set the tick count.
	0111  7 - Set Time Response - Response to the Set Time request.

	Rule for processing EXT bits.  If a byte in the flags has the high
	bit set, there is one more byte.  Ignore any bits beyond what you know
	how to process.

	Sample Packets:
	===============

	Time setting algorithm?

	Bandwidth Calculations?

	Scheduling?

	Window Size?

	Interpacket wait?

	Send Queue Management?

	Command for selective NACK.

	RLY bit separates 2 streams - reliable/datagram.  For piggyback
	ACK this means reliable piggyback ACKs are only on reliable streams
	and datagram piggyback ACKs are only on non-reliable streams.

==============================================================================*/
#ifdef __DPMESS_INCLUDED__
#define MAX_SEND_HEADER (sizeof(Packet2)+sizeof(MSG_PROTOCOL))
// leave space for a 128 bit NACK message, this is the maximum window we ever allow
#define MAX_SYS_HEADER (sizeof(NACK2)+(128/8)+sizeof(MSG_PROTOCOL))
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\protocol\sendpool.c ===
/*++

Copyright (c) 1996,1997  Microsoft Corporation

Module Name:

    SENDPOOL.C

Abstract:

	Manages pool of send descriptors.

Author:

	Aaron Ogus (aarono)

Environment:

	Win32

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
  12/10/96 aarono  Original

--*/

#include <windows.h>
#include <mmsystem.h>
#include <dplay.h>
#include <dplaysp.h>
#include <dplaypr.h>
#include "mydebug.h"
#include "arpd.h"
#include "arpdint.h"
#include "macros.h"

//
// Send Descriptor Management.
//

PSEND 			 pSendDescPool=NULL;
UINT             nSendDescsAllocated=0;	// Number Allocated
UINT             nSendDescsInUse=0;		// Number currently in use
UINT             nMaxSendDescsInUse=0;  // Maximum number in use since last TICK.

CRITICAL_SECTION SendDescLock;

VOID InitSendDescs(VOID)
{
	InitializeCriticalSection(&SendDescLock);
}

VOID FiniSendDescs(VOID)
{
	PSEND pSend;
	
	ASSERT(nSendDescsInUse==0);
	
	while(pSendDescPool){
		pSend=pSendDescPool;
		ASSERT_SIGN(pSend, SEND_SIGN);
		pSendDescPool=pSendDescPool->pNext;
		CloseHandle(pSend->hEvent);
		DeleteCriticalSection(&pSend->SendLock);
		My_GlobalFree(pSend);
		nSendDescsAllocated--;
	}
	
	ASSERT(nSendDescsAllocated==0);
	
	DeleteCriticalSection(&SendDescLock);
}

PSEND GetSendDesc(VOID)
{
	PSEND pSend;

	Lock(&SendDescLock);
	
	if(!pSendDescPool){
	
		Unlock(&SendDescLock);
		pSend=(PSEND)My_GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, sizeof(SEND));
		if(pSend){
			if(!(pSend->hEvent=CreateEventA(NULL, FALSE, FALSE, NULL))){
				My_GlobalFree(pSend);
				goto exit;
			}
			InitBilink(&pSend->StatList);
			InitializeCriticalSection(&pSend->SendLock);
		}
		Lock(&SendDescLock);
		if(pSend){
			SET_SIGN(pSend,SEND_SIGN);			
			nSendDescsAllocated++;
		}
	} else {
	
		pSend=pSendDescPool;
		ASSERT_SIGN(pSend, SEND_SIGN);
		pSendDescPool=pSendDescPool->pNext;
		
	}

	if(pSend){
		InitBilink(&pSend->TimeoutList);
		InitBilink(&pSend->m_GSendQ);
		InitBilink(&pSend->SendQ);
		nSendDescsInUse++;
		if( nSendDescsInUse > nMaxSendDescsInUse ){
			nMaxSendDescsInUse = nSendDescsInUse;
		}
	}

	ASSERT(nSendDescsAllocated >= nSendDescsInUse);

	Unlock(&SendDescLock);
	if(pSend){
		pSend->NACKMask=0;
		pSend->bCleaningUp=FALSE;
	}	

exit:	
	return pSend;
}

VOID ReleaseSendDesc(PSEND pSend)
{
	PSENDSTAT pStat;
	BILINK *pBilink;

	// Dump extra statistics.
	while(!EMPTY_BILINK(&pSend->StatList)){
		pBilink=pSend->StatList.next;
		pStat=CONTAINING_RECORD(pBilink, SENDSTAT, StatList);
		Delete(pBilink);
		ReleaseSendStat(pStat);
	}

	Lock(&SendDescLock);
	nSendDescsInUse--;
	ASSERT(!(nSendDescsInUse&0x80000000));
	pSend->pNext=pSendDescPool;
	pSendDescPool=pSend;
	Unlock(&SendDescLock);

}


#if 0
// let virtual memory handle this. - switched out.
LONG fInSendDescTick=0;

VOID SendDescTick(VOID)
{
	PSEND pSend;
#ifdef DEBUG
	LONG fLast; 
#endif
	// Adjusts Number of allocated buffers to 
	// highwater mark over the last ticks.
	// Call once per delta t (around a minute).
	DEBUG_BREAK(); //TRACE all paths.

	if(!InterlockedExchange(&fInSendDescTick, 1)){
	
		Lock(&SendDescLock);
		
		while((nSendDescsAllocated > nMaxSendDescsInUse) && pSendDescPool){
		
			pSend=pSendDescPool;
			ASSERT_SIGN(pSend,SEND_SIGN);
			pSendDescPool=pSendDescPool->pNext;
			
			Unlock(&SendDescLock);
			CloseHandle(pSend->hEvent);
			DeleteCriticalSection(&pSend->SendLock);
			My_GlobalFree(pSend);
			Lock(&SendDescLock);
			nSendDescsAllocated--;
			
		}
		nMaxSendDescsInUse=nSendDescsInUse;

		ASSERT(nMaxSendDescsInUse <= nSendDescsAllocated);
		
		Unlock(&SendDescLock);
#ifdef DEBUG
		fLast=
#endif
		InterlockedExchange(&fInSendDescTick, 0);
#ifdef DEBUG
		ASSERT(fLast==1);
#endif
	}	
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\protocol\statpool.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    STATPOOL.CPP

Abstract:

	Maintains pool of Stat structures.

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date    Author  Description
   =======  ======  ============================================================
   1/30/97  aarono  Original

--*/

#include <windows.h>
#include <mmsystem.h>
#include <dplay.h>
#include <dplaysp.h>
#include <dplaypr.h>
#include "mydebug.h"
#include "arpd.h"
#include "arpdint.h"
#include "macros.h"


PSENDSTAT		 pSendStatPool=NULL;
UINT             nSendStatsAllocated=0;	// Number Allocated
UINT             nSendStatsInUse=0;		    // Number currently in use
UINT             nMaxSendStatsInUse=0;      // Maximum number in use since last TICK.

CRITICAL_SECTION SendStatLock;

VOID InitSendStats(VOID)
{
	InitializeCriticalSection(&SendStatLock);
}

VOID FiniSendStats(VOID)
{
	PSENDSTAT pSendStat;
	
	ASSERT(nSendStatsInUse==0);
	
	while(pSendStatPool){
		pSendStat=pSendStatPool;
		ASSERT_SIGN(pSendStat, SENDSTAT_SIGN);
		pSendStatPool=pSendStatPool->pNext;
		My_GlobalFree(pSendStat);
		nSendStatsAllocated--;
	}
	
	ASSERT(nSendStatsAllocated==0);
	
	DeleteCriticalSection(&SendStatLock);
}

PSENDSTAT GetSendStat(VOID)
{
	PSENDSTAT pSendStat;

	Lock(&SendStatLock);
	
	if(!pSendStatPool){
	
		Unlock(&SendStatLock);
		pSendStat=(PSENDSTAT)My_GlobalAlloc(GMEM_FIXED, sizeof(SENDSTAT));
		Lock(&SendStatLock);
		if(pSendStat){
			SET_SIGN(pSendStat,SENDSTAT_SIGN);			
			nSendStatsAllocated++;
		}
	} else {
		pSendStat=pSendStatPool;
		ASSERT_SIGN(pSendStat, SENDSTAT_SIGN);
		pSendStatPool=pSendStatPool->pNext;
		
	}

	if(pSendStat){
		nSendStatsInUse++;
		if( nSendStatsInUse > nMaxSendStatsInUse ){
			nMaxSendStatsInUse = nSendStatsInUse;
		}
	}

	ASSERT(nSendStatsAllocated >= nSendStatsInUse);

	Unlock(&SendStatLock);

	return pSendStat;
}

VOID ReleaseSendStat(PSENDSTAT pSendStat)
{
	Lock(&SendStatLock);
	nSendStatsInUse--;
	ASSERT(!(nSendStatsInUse&0x80000000));
	pSendStat->pNext=pSendStatPool;
	pSendStatPool=pSendStat;
	Unlock(&SendStatLock);

}

#if 0
// let virtual memory handle this.
LONG fInSendStatTick=0;

VOID SendStatTick(VOID)
{
	PSENDSTAT pSendStat;
#ifdef DEBUG
	LONG fLast; 
#endif
	// Adjusts Number of allocated buffers to 
	// highwater mark over the last ticks.
	// Call once per delta t (around a minute).
	DEBUG_BREAK(); //TRACE all paths.

	if(!InterlockedExchange(&fInSendStatTick, 1)){
	
		Lock(&SendStatLock);
		
		while((nSendStatsAllocated > nMaxSendStatsInUse) && pSendStatPool){
		
			pSendStat=pSendStatPool;
			ASSERT_SIGN(pSendStat,SENDSTAT_SIGN);
			pSendStatPool=pSendStatPool->pNext;
			
			Unlock(&SendStatLock);
			My_GlobalFree(pSendStat);
			Lock(&SendStatLock);
			nSendStatsAllocated--;
			
		}
		nMaxSendStatsInUse=nSendStatsInUse;

		ASSERT(nMaxSendStatsInUse <= nSendStatsAllocated);
		
		Unlock(&SendStatLock);
#ifdef DEBUG
		fLast=
#endif
		InterlockedExchange(&fInSendStatTick, 0);
#ifdef DEBUG
		ASSERT(fLast==1);
#endif
	}	
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\protocol\stats.c ===
/*++

Copyright (c) 1996,1997  Microsoft Corporation

Module Name:

	STATS.C

Abstract:

	Session Statistics routines

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
   7/30/97 aarono  Original
   6/6/98  aarono  Turn on throttling and windowing

--*/

#include <windows.h>
#include "newdpf.h"
#include <dplay.h>
#include <dplaysp.h>
#include <dplaypr.h>
#include "mydebug.h"
#include "arpd.h"
#include "arpdint.h"
#include "protocol.h"
#include "macros.h"
#include "command.h"

#define STARTING_LONG_LATENCY 			1  /*  1  ms (intentionally low so first sample fills)      */
#define STARTING_SHORT_LATENCY 		15000  /* 15 seconds (intentionally high so first sample fills) */
#define STARTING_AVERAGE_LATENCY 	 2000  /*  2 seconds (good start for internet) */
#define STARTING_AVERAGE_DEVIATION      0  

#define STARTING_MAXRETRY                16  /* Maximum number of retries */
#define STARTING_MINDROPTIME          15000  /* Minimum time to retry before dropping connection (ms) */
#define STARTING_MAXDROPTIME          60000  /* Maximum time to retry before dropping connection (ms) */

#define STARTING_BANDWIDTH          (28800/10) /* 28 kbps modem */

#define LATENCY_SHORT_BITS				4
#define LATENCY_LONG_BITS               7

#define STAT_LOCAL_LATENCY_SAMPLES 		2^(LATENCY_SHORT_BITS) /* 2^4 */
#define STAT_LONG_LATENCY_SAMPLES       2^(LATENCY_LONG_BITS)  /* 2^7 */

#define TARGET_CLOCK_OFFSET 		10000000


#define Fp(_x) ((_x)<<8)
#define unFp(_x)((_x)>>8)

// Latency Averages and deviation averages are stored as fixed point 24.8

VOID InitSessionStats(PSESSION pSession)
{
	pSession->ShortestLatency     = STARTING_SHORT_LATENCY;
	pSession->LongestLatency      = STARTING_LONG_LATENCY;
	
	pSession->FpAverageLatency      = 1000;
	pSession->FpLocalAverageLatency = 1000;

	pSession->FpLocalAvgDeviation   = 300;
	pSession->FpAvgDeviation        = 300;

	pSession->Bandwidth = 28800/10;
	pSession->HighestBandwidth=28800/10;
	
	pSession->MaxRetry    = STARTING_MAXRETRY;
	pSession->MinDropTime = STARTING_MINDROPTIME;
	pSession->MaxDropTime = STARTING_MAXDROPTIME;
}


// called with SESSIONLOCK.
VOID UpdateSessionStats(PSESSION pSession, PSENDSTAT pStat, PCMDINFO pCmdInfo, BOOL fBadDrop)
{
	DWORD tLatency;
	DWORD nBytesReceived;
	DWORD tDeviation;
	DWORD BytesLost=0;
	DWORD BackLog=0;

	DWORD fThrottleAdjusted=FALSE;

	DWORD tRemoteDelta; // change in time on remote from last received ACK until this was ACKed.
	
	DWORD tBiasedDelta; // a biased difference in local and remote clocks.
	INT   tDelta; // the unbiased difference (signed)
	static DWORD cBiasReset;

	
	// Get the statistics information we need.
	tLatency = pCmdInfo->tReceived-pStat->tSent;

	ASSERT((int)tLatency >= 0);
	if(!tLatency){
		DPF(8,"0ms observed latency, using 1ms\n");
		tLatency=1;
	}	

	Lock(&pSession->SessionStatLock);
	
		// Calculates the number of bytes received at remote since this send was done.
		pSession->RemoteBytesReceived = pCmdInfo->bytes;
		pSession->tRemoteBytesReceived = pCmdInfo->tRemoteACK;
		nBytesReceived = pSession->RemoteBytesReceived - pStat->RemoteBytesReceived;

		BytesLost = pStat->LocalBytesSent-(pSession->RemoteBytesReceived+pSession->BytesLost);

		if((int)BytesLost >= 0){
		
			pSession->BytesLost += BytesLost;

			// Note, Backlog may be as little as 1/2 this value.
			BackLog = pSession->BytesSent -( pSession->RemoteBytesReceived + pSession->BytesLost );

			if((int)BackLog < 0){
				DPF(8,"Hmmm, upside down backlog?\n");
				DPF(8,"pSession->BytesSent             %d\n",pSession->BytesSent);
				DPF(8,"pSession->RemoteBytesReceived   %d\n",pSession->RemoteBytesReceived); 
				DPF(8,"pSession->BytesLost             %d\n",pSession->BytesLost);
				DPF(8,"Calculated BackLog              %d\n",BackLog);
				BackLog=0;
			}
			
		} else if((int)BytesLost < 0){
			// Can be caused by out of order receives
			DPF(1,"Out of order remote receive lots of these may affect throttling...\n");
			DPF(8,"Hmmm, upside down byte counting?\n"); 
			DPF(8,"pStat->LocalBytesSent           %d\n",pStat->LocalBytesSent);
			DPF(8,"pSession->RemoteBytesReceived   %d\n",pSession->RemoteBytesReceived); 
			DPF(8,"pSession->BytesLost             %d\n",pSession->BytesLost);
			DPF(8,"Calculated Bytes Lost           %d\n",BytesLost);
			BytesLost=0;
			// fixup lost count.
			pSession->BytesLost=pSession->RemoteBytesReceived-pStat->LocalBytesSent;
		}

	Unlock(&pSession->SessionStatLock);

	if(pSession->MaxCSends==1){
	
		DWORD Bias;
		
		// 1st ACK, adjust windows to normal operation.
		pSession->MaxCSends     = MAX_SMALL_CSENDS;	 
		pSession->MaxCDGSends   = MAX_SMALL_DG_CSENDS;
		pSession->WindowSize	= MAX_SMALL_WINDOW;
		pSession->DGWindowSize  = MAX_SMALL_WINDOW;

		pSession->FpAverageLatency      = 2*tLatency; // start high to avoid overthrottle
		pSession->FpLocalAverageLatency = 2*tLatency;

		pSession->FpLocalAvgDeviation   = 1+tLatency/3;
		pSession->FpAvgDeviation        = 1+tLatency/3;



		Bias = pCmdInfo->tRemoteACK - pStat->tSent;

		if(Bias > TARGET_CLOCK_OFFSET){
			Bias = -1*(Bias-TARGET_CLOCK_OFFSET);
		} else {
			Bias = TARGET_CLOCK_OFFSET - Bias;
		}

		pSession->RemAvgACKBias = Bias;
		
		pSession->RemAvgACKDelta = (pCmdInfo->tRemoteACK - pStat->tSent)+pSession->RemAvgACKBias;

		ASSERT(pSession->RemAvgACKDelta == TARGET_CLOCK_OFFSET);
	}

	//
	// Calculate shift in outbound latency.
	//
	tBiasedDelta = (pCmdInfo->tRemoteACK - pStat->tSent)+pSession->RemAvgACKBias;
	tDelta = tBiasedDelta-TARGET_CLOCK_OFFSET;

	if(tDelta < 0 || pStat->bResetBias || tDelta > (int)tLatency){
		DWORD Bias;

		// Either clock drift or lower server load shows latency down, so reset baseline.
		
		Bias = pCmdInfo->tRemoteACK - pStat->tSent;

		if(Bias > TARGET_CLOCK_OFFSET){
			Bias = -1*(Bias-TARGET_CLOCK_OFFSET);
		} else {
			Bias = TARGET_CLOCK_OFFSET - Bias;
		}
		cBiasReset++;

		pSession->RemAvgACKBias = Bias;
		tBiasedDelta = (pCmdInfo->tRemoteACK - pStat->tSent)+pSession->RemAvgACKBias;
		tDelta = tBiasedDelta-TARGET_CLOCK_OFFSET;
	}

	pSession->RemAvgACKDelta -= pSession->RemAvgACKDelta >> 7; // -1/128th
	pSession->RemAvgACKDelta += tBiasedDelta >> 7;			   // +1/128th of new value 

	// keep the residue so we don't creep down due to rounding error.
	pSession->RemAvgACKDeltaResidue += tBiasedDelta & 0x7f;
	if(pSession->RemAvgACKDeltaResidue>>7){
		pSession->RemAvgACKDelta += pSession->RemAvgACKDeltaResidue>>7;
		pSession->RemAvgACKDeltaResidue &= 0x7f;
	}


	DPF(8,"tRemoteACK %d tSent %d Bias %d tBiasedDelta %d tDelta %d\n", pCmdInfo->tRemoteACK, pStat->tSent, 
		pSession->RemAvgACKBias, tBiasedDelta, tDelta);
	
	
	//
	// Update latency statistics
	//
	
	ASSERT(!(nBytesReceived & 0x80000000)); // received in interval +ve
	ASSERT(!(tLatency & 0x80000000));       // latency is +ve

	if(tLatency < pSession->ShortestLatency){
		pSession->ShortestLatency=tLatency;
		DPF(8,"Shortest Latency %d ms\n",tLatency);
	}

	if(tLatency > pSession->LongestLatency){
		pSession->LongestLatency=tLatency;
		DPF(8,"Longest Latency %d ms\n", tLatency);
	}

	pSession->LastLatency=tLatency;

	// Throw out 1/16 of local latency and add in the new statistic.
	// Note we only use local latency for retry calculations.

	if(pSession->FpLocalAverageLatency){
		if(Fp(tLatency) > pSession->FpAverageLatency){
			pSession->FpLocalAverageLatency -= (pSession->FpLocalAverageLatency >> LATENCY_SHORT_BITS);
			pSession->FpLocalAverageLatency += (tLatency << (8-LATENCY_SHORT_BITS));
		} else {
			// Ratched down when we get a latency that is below average, so we can better
			// detect backlog due to latency.
			pSession->FpLocalAverageLatency = Fp(tLatency);
		}
	} else {
		// this only happens once at startup.
		pSession->FpLocalAverageLatency = Fp(tLatency);
		pSession->FpAverageLatency = Fp(tLatency);
	}

	if(Fp(tLatency) > pSession->FpAverageLatency){

		// Thow out 1/128 of average latency and add in the new statistic.
		pSession->FpAverageLatency -= (pSession->FpAverageLatency >> LATENCY_LONG_BITS);
		pSession->FpAverageLatency += (tLatency << (8-LATENCY_LONG_BITS));

	} else {
		// Ratched down when we get a latency that is below average, so we can better
		// detect backlog due to latency.
		pSession->FpAverageLatency = Fp(tLatency);
	}
	
	tDeviation=unFp(pSession->FpLocalAverageLatency)-tLatency;
	if((int)tDeviation < 0){
		tDeviation = 0-tDeviation;
	}

	pSession->FpLocalAvgDeviation -= (pSession->FpLocalAvgDeviation >> LATENCY_SHORT_BITS);
	pSession->FpLocalAvgDeviation += (tDeviation << (8-LATENCY_SHORT_BITS));

	pSession->FpAvgDeviation -= (pSession->FpAvgDeviation >> LATENCY_LONG_BITS);
	pSession->FpAvgDeviation += (tDeviation << (8-LATENCY_LONG_BITS));


	DPF(8,"Got ACK, tLat: %d Avg: %d.%d Dev:  %d AvgDev: %d.%d \n",
			tLatency, pSession->FpLocalAverageLatency >> 8, ((pSession->FpLocalAverageLatency&0xFF)*100)/256,
			tDeviation, pSession->FpLocalAvgDeviation >> 8, ((pSession->FpLocalAvgDeviation&0xFF)*100)/256);


	//
	// Do Bandwidth calculations
	//
	
   	tRemoteDelta= pCmdInfo->tRemoteACK - pStat->tRemoteBytesReceived;
   	if(!tRemoteDelta){
   		tRemoteDelta=1;
   	}

	if(pStat->tRemoteBytesReceived){
		pSession->Bandwidth = (1000*nBytesReceived)/(tRemoteDelta);
		// could adjust throttle here if Bandwidth is higher, but this
		// might pimp high speed links. OPTIMIZATION.
	} else {
		// backup calculation, not as good.  Only used early in the link
		// before we have received an ACK from the remote prior to issuing
		// a send.
		pSession->Bandwidth = (2000*nBytesReceived)/tLatency;	// 2000, not 1000 since tLatency is round trip.
	}	
	if(pSession->Bandwidth > pSession->HighestBandwidth){
		pSession->HighestBandwidth = pSession->Bandwidth;
	}


	DPF(8,"tRemoteDelta %d Remote bytes Received %d\n",tRemoteDelta,nBytesReceived);

	// Adjust sending...
	
	if ( BackLog && pSession->Bandwidth)
	{

		DWORD tAvgLat;
		DWORD tBackLog;
		DWORD ExcessBackLog; // amount of backlog (bytes) we need to clear before hitting avg latency again.
		DWORD tLatCheck;
		DWORD AvgLat133; // 133% of local average latency (tolerance for slow links)
		DWORD AvgLat200; // 200% of local average latency (tolerance for fast links)


		if(pSession->fFastLink){
			tAvgLat=unFp(pSession->FpAverageLatency);
			tLatCheck = (tAvgLat*3)/2;
			AvgLat133 = max(100,3*unFp(pSession->FpAvgDeviation)+(unFp(pSession->FpAverageLatency)*4)/3); // don't throttle <100ms lat
			AvgLat200 = max(100,3*unFp(pSession->FpAvgDeviation)+unFp(pSession->FpAverageLatency)*2);
		} else {
			tAvgLat=unFp(pSession->FpLocalAverageLatency);
			tLatCheck = (tAvgLat*3)/2;
			AvgLat133 = max(100,3*unFp(pSession->FpLocalAvgDeviation)+(unFp(pSession->FpLocalAverageLatency)*4)/3); // don't throttle <100ms lat
			AvgLat200 = max(100,3*unFp(pSession->FpLocalAvgDeviation)+unFp(pSession->FpLocalAverageLatency)*2);
		}
		
		if(tLatCheck < AvgLat133){
			tLatCheck = AvgLat133; 
		}

		if(tLatency > tLatCheck){
			// check link speed
			if(pSession->fFastLink){
				if(pSession->Bandwidth <= 10000){
					pSession->fFastLink=FALSE;
				}
			} else {
				if(pSession->Bandwidth >= 25000){
					pSession->fFastLink=TRUE;
				}
			}
		}

		if(pSession->fFastLink && tLatCheck < AvgLat200){
			tLatCheck=AvgLat200;
		}

		DPF(8,"tLat %d, tLatCheck %d, tDelta %d, tLat/3 %d\n",tLatency,tLatCheck,tDelta,tLatency/3); 
		DPF(8,"pSession->ShortestLatency %d, Shortest+MaxPacketTime %d\n",pSession->ShortestLatency,
			pSession->ShortestLatency+(pSession->MaxPacketSize*1000)/pSession->Bandwidth);

		
		if((tLatency > tLatCheck && tDelta > (int)(tLatency/3)) ||
		    ((!pSession->fFastLink)&&
		     (tLatency > pSession->ShortestLatency+((pSession->MaxPacketSize*2000)/pSession->Bandwidth))
		    )
		  )
		{
				
			#ifdef DEBUG
			if(pSession->SendRateThrottle){
				DPF(8,"BackLog %d, SendRate %d BackLog ms %d, tLatency %d tAvgLat %d Used Bandwidth %d tBacklog %d \n",
						BackLog,
						pSession->SendRateThrottle, 
						(BackLog*1000 / pSession->SendRateThrottle),
						tLatency, 
						tAvgLat, 
						pSession->Bandwidth,
						((BackLog*1000) / pSession->Bandwidth)
						);
			}	
			#endif

			tBackLog = (BackLog * 1000)/pSession->Bandwidth;
			
			if(tBackLog > 4*tLatency){
				DPF(8,"1: tBackLog %d was >> tLatency %d, using 4*tLatency instead\n",tBackLog,tLatency);
				tBackLog=4*tLatency; //never wait more than 4 latency periods
			}
			if(tBackLog > 8000){
				DPF(8,"Disalowing backlog > 8 seconds, using 8 instead\n");
				tBackLog=8000;
			}

			// if the backlog is greater than the bandwidth*latency, then we need to slow down our sending.
			// don't slow down due to backlog until we are over 100ms on way latency (200 round trip)
		
			if((tBackLog > 200) && (tBackLog > tAvgLat)){
			
				BOOL fWait=TRUE;

				// at max we cut send rate in 1/2.

				if(pSession->SendRateThrottle/2 > pSession->Bandwidth){
					DPF(8,"Asked for too aggresive throttle adjust %d, going from %d to %d\n",pSession->Bandwidth,pSession->SendRateThrottle,pSession->SendRateThrottle/2);
					pSession->SendRateThrottle /= 2;
					// Recheck if we are really backlogged at the new rate
					tBackLog = (BackLog * 1000)/pSession->SendRateThrottle;
					if(tBackLog > tLatency){
						DPF(8,"2: tBackLog %d was > tLatency %d, using tLatency instead\n",tBackLog,tLatency);
						tBackLog=tLatency;// never wait more than last latency period
					}
				} else {
					// set new throttle rate and current observed bandwidth (+5% to avoid overthrottle)
					pSession->SendRateThrottle=pSession->Bandwidth+pSession->Bandwidth/16;
				}

				// don't adjust for a while.
				pSession->bhitThrottle=FALSE;
				pSession->tLastThrottleAdjust = pCmdInfo->tReceived;

				if(fWait && (tBackLog > tAvgLat)){
				
					ExcessBackLog = ((tBackLog-tAvgLat)*pSession->Bandwidth)/1000;
					
					DPF(8,"Throttling back due to BACKLOG, excess = %d\n",ExcessBackLog);

					#ifdef DEBUG
					if(tBackLog-tAvgLat > 30000){
						DPF(5,"WARNING: BACKLOG THROTTLE %d ms seems kinda large\n",tBackLog-tAvgLat);
					}
					#endif

					// wait until backlog is down to avg latency before sending again
					Lock(&pSession->SessionStatLock);
					pSession->bResetBias = 2; // could be in the middle of a send, so count down from 2.
					Unlock(&pSession->SessionStatLock);
					UpdateSendTime(pSession,ExcessBackLog,timeGetTime(),TRUE);
				} else {
					DPF(8,"Not throttling due to BACKLOG because of smaller adjustment\n");
				}
				
			} else {
				DPF(8,"NOT Throttling back due to BACKLOG\n");
				
			}
		}		

	} else if(tDelta > (int)tLatency) {
		// tDelta is bogus due to clock drift, force throttle so we can correct.
		Lock(&pSession->SessionStatLock);
		pSession->bResetBias=2;
		Unlock(&pSession->SessionStatLock);
		pSession->tNextSend=timeGetTime()+2*tLatency;
		DPF(8,"tDelta %d > tLatency %d, need to correct for clock drift, time %d set next send time to %d\n", tDelta, tLatency,timeGetTime(),pSession->tNextSend);
	}	



	//
	// Adjust Throttle if not already adjusted.
	//
	
	if((pSession->ThrottleState==Begin) || 
	   (pCmdInfo->tReceived-pSession->tLastThrottleAdjust) > (1+1*pSession->fFastLink)*unFp(pSession->FpLocalAverageLatency) )
	{
		if(!fThrottleAdjusted){
			DPF(8,"Current Send Rate %d\n", pSession->SendRateThrottle);
			if(!BytesLost && pSession->bhitThrottle){
				pSession->bhitThrottle=FALSE;
				pSession->tLastThrottleAdjust = pCmdInfo->tReceived;
				// Good Send, push up send rate if we hit throttle.
				switch(pSession->ThrottleState){
					case Begin:
						pSession->SendRateThrottle = (pSession->SendRateThrottle*(100+START_GROWTH_RATE))/100;
						pSession->GrowCount++;
						pSession->ShrinkCount=0;
						break;
						
					case MetaStable:
						pSession->SendRateThrottle = (pSession->SendRateThrottle*(100+METASTABLE_GROWTH_RATE))/100;
						pSession->GrowCount++;
						pSession->ShrinkCount=0;
						break;
						
					case Stable:
						pSession->SendRateThrottle = (pSession->SendRateThrottle*(100+STABLE_GROWTH_RATE))/100;
						pSession->GrowCount++;
						pSession->ShrinkCount=0;
						if(pSession->GrowCount > (UINT)(20+60*pSession->fFastLink)){
							pSession->ThrottleState = MetaStable;
							pSession->GrowCount=0;
						}
						break;
					default:	
						DPF(0,"Session in wierd ThrottleState %d\n",pSession->ThrottleState);
						break;
				}	
				DPF(8,"Successful Send Adjusted Throttle, SendRate %d\n",pSession->SendRateThrottle);
			} else if(BytesLost){
				// Figure out how much we dropped
				if(fBadDrop || (BytesLost > pSession->pProtocol->m_dwSPMaxFrame)){
					// Very bad send, back off
					pSession->tLastThrottleAdjust = pCmdInfo->tReceived;
					switch(pSession->ThrottleState){
						case Begin:
							pSession->SendRateThrottle = (pSession->SendRateThrottle*(100-START_ADJUST_LARGE_ERR))/100;
							pSession->GrowCount=0;
							pSession->ShrinkCount++;
							break;
						case MetaStable:
							pSession->SendRateThrottle = (pSession->SendRateThrottle*(100-METASTABLE_ADJUST_LARGE_ERR))/100;
							pSession->GrowCount=0;
							pSession->ShrinkCount++;
							break;
						case Stable:
							pSession->SendRateThrottle = (pSession->SendRateThrottle*(100-STABLE_ADJUST_LARGE_ERR))/100;
							pSession->ShrinkCount++;
							if(pSession->ShrinkCount > 1){
								pSession->ShrinkCount=0;
								pSession->GrowCount=0;
								pSession->ThrottleState=MetaStable;
							}
							break;
						default:
							DPF(0,"Session in wierd ThrottleState %d\n",pSession->ThrottleState);
							break;
					}	
					DPF(8,"VERY BAD SEND Adjusted Throttle, SendRate %d\n",pSession->SendRateThrottle);
				} else {
					// Bad send, back off a bit
					pSession->tLastThrottleAdjust = pCmdInfo->tReceived;
					switch(pSession->ThrottleState){
						case Begin:
							pSession->SendRateThrottle = (pSession->SendRateThrottle*(100-START_ADJUST_SMALL_ERR))/100;
							pSession->GrowCount=0;
							pSession->ShrinkCount=0;
							pSession->ThrottleState = MetaStable;
							break;
						case MetaStable:
							pSession->SendRateThrottle = (pSession->SendRateThrottle*(100-METASTABLE_ADJUST_SMALL_ERR))/100;
							pSession->ShrinkCount++;
							pSession->GrowCount=0;
							break;
						case Stable:
							pSession->SendRateThrottle = (pSession->SendRateThrottle*(100-STABLE_ADJUST_SMALL_ERR))/100;
							pSession->ShrinkCount++;
							pSession->GrowCount=0;
							if(pSession->ShrinkCount > 2){
								pSession->ShrinkCount=0;
								pSession->ThrottleState = MetaStable;
							}	
							break;
						default:
							DPF(0,"Session in wierd ThrottleState %d\n",pSession->ThrottleState);
							break;
					}
					DPF(8,"BAD SEND Adjusted Throttle, SendRate %d\n",pSession->SendRateThrottle);
				} /* if (BadDrop... ) */
				
			} /* if (BytesLost ...) */
			
		}/*if (ThrottleAdjusted) */

	}

	if(!BytesLost && pSession->Bandwidth && pSession->SendRateThrottle < pSession->Bandwidth){
		DPF(8,"Avoid goofyness, throttle was %d, setting to observed bandwidth %d\n",pSession->SendRateThrottle,pSession->Bandwidth);
		pSession->SendRateThrottle=pSession->Bandwidth;
	}
	if(pSession->SendRateThrottle < 100){
		DPF(8,"WARNING: SendRateThrottle %d below 100, keeping at 100 to avoid starvation\n",pSession->SendRateThrottle);
		pSession->SendRateThrottle=100;
	}

#ifdef DEBUG
	{
		IN_WRITESTATS InWS;
		memset((PVOID)&InWS,0xFF,sizeof(IN_WRITESTATS));

	   	InWS.stat_ThrottleRate = pSession->SendRateThrottle;
		InWS.stat_BytesSent	   = pSession->BytesSent;
		InWS.stat_BackLog      = BackLog;      
	 	InWS.stat_BytesLost    = pSession->BytesLost;
	 	//InWS.stat_RemBytesReceived;
		InWS.stat_Latency = tLatency;
		InWS.stat_MinLatency=pSession->ShortestLatency;
		InWS.stat_AvgLatency=unFp(pSession->FpLocalAverageLatency);
		InWS.stat_AvgDevLatency=unFp(pSession->FpLocalAvgDeviation);
		//InWS.stat_USER1=
		//InWS.stat_USER2=
		//InWS.stat_USER3=
		InWS.stat_USER5 = tDelta;
		InWS.stat_USER6 = cBiasReset;
	
		DbgWriteStats(&InWS);
	}
#endif
	
	DPF(8,"Bandwidth %d, Highest %d\n",pSession->Bandwidth, pSession->HighestBandwidth);
	
}

// Called with SessionLock and SendLock
// Statistics are stored on the send in send order on a BILINK.
// most recent sends are at the end of the list.  We scan from
// the end of the list to the beginning until we find the SENDSTAT
// that records the sequence and serial we got ACKED.  We then 
// update our statistics and throw out all SENDSTATs
// before this entry.
VOID UpdateSessionSendStats(PSESSION pSession, PSEND pSend, PCMDINFO pCmdInfo, BOOL fBadDrop)
{
	PSENDSTAT pStatWalker,pStat=NULL;
	BILINK    *pStatBilink;

	pSend->tLastACK=pCmdInfo->tReceived;
	pSend->RetryCount=0;
	// Find the last STAT for this ACK.
	pStatBilink=pSend->StatList.prev;

	while(pStatBilink != &pSend->StatList){
		pStatWalker=CONTAINING_RECORD(pStatBilink, SENDSTAT, StatList);
		if(pStatWalker->serial==pCmdInfo->serial &&
			pStatWalker->sequence==pCmdInfo->sequence)
		{
			ASSERT(pStatWalker->messageid==pSend->messageid);
			ASSERT(pSend->messageid==pCmdInfo->messageid);
			pStat=pStatWalker;
			break;
		}
		pStatBilink=pStatBilink->prev;
	}

	if(pStat){
		UpdateSessionStats(pSession,pStat,pCmdInfo,fBadDrop);

		// Unlink All Previous SENDSTATS;
		pStat->StatList.next->prev=&pSend->StatList;
		pSend->StatList.next=pStat->StatList.next;

		// Put the SENDSTATS back in the pool.
		while(pStatBilink != &pSend->StatList){
			pStatWalker=CONTAINING_RECORD(pStatBilink, SENDSTAT, StatList);
			pStatBilink=pStatBilink->prev;
			ReleaseSendStat(pStatWalker);
		}

	}	

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\protocol\win9x\makefile.inc ===
misc :
	copy ..\..\common\newdpf.h .
	copy ..\..\common\newdpf.c .
	copy ..\..\common\dputils.c .
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\protocol\rcvpool.c ===
/*++

Copyright (c) 1996,1997  Microsoft Corporation

Module Name:

    RCVPOOL.CPP

Abstract:

	Manages pool of send descriptors.

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
  12/10/96 aarono  Original

--*/

#include <windows.h>
#include <mmsystem.h>
#include <dplay.h>
#include <dplaysp.h>
#include <dplaypr.h>
#include "mydebug.h"
#include "arpd.h"
#include "arpdint.h"
#include "macros.h"

//
// Receive Descriptor Management.
//

VOID InitRcvDescs(PPROTOCOL this)
{
	this->pRcvDescPool=NULL;
	this->nRcvDescsAllocated=0;
	this->nRcvDescsInUse=0;
	this->nMaxRcvDescsInUse=0;
	this->fInRcvDescTick=FALSE;
	InitializeCriticalSection(&this->RcvDescLock);
}

VOID FiniRcvDescs(PPROTOCOL this)
{
	PRECEIVE pReceive;
	
	ASSERT(this->nRcvDescsInUse==0);
	
	while(this->pRcvDescPool){
		pReceive=this->pRcvDescPool;
		ASSERT_SIGN(pReceive, RECEIVE_SIGN);
		this->pRcvDescPool=this->pRcvDescPool->pNext;
		DeleteCriticalSection(&pReceive->ReceiveLock);
		My_GlobalFree(pReceive);
		this->nRcvDescsAllocated--;
	}
	
	ASSERT(this->nRcvDescsAllocated==0);
	
	DeleteCriticalSection(&this->RcvDescLock);
}

PRECEIVE GetRcvDesc(PPROTOCOL this)
{
	PRECEIVE pReceive;

	Lock(&this->RcvDescLock);

	if(!this->pRcvDescPool){
	
		Unlock(&this->RcvDescLock);
		pReceive=(PRECEIVE)My_GlobalAlloc(GMEM_FIXED, sizeof(RECEIVE)+this->m_dwSPHeaderSize);
		if(pReceive){
			SET_SIGN(pReceive,RECEIVE_SIGN);			
			InitializeCriticalSection(&pReceive->ReceiveLock);
			InitBilink(&pReceive->RcvBuffList);
		}
		Lock(&this->RcvDescLock);
		if(pReceive){
			this->nRcvDescsAllocated++;
		}
	} else {
		pReceive=this->pRcvDescPool;
		ASSERT_SIGN(pReceive, RECEIVE_SIGN);
		this->pRcvDescPool=this->pRcvDescPool->pNext;
		
	}

	if(pReceive){
		this->nRcvDescsInUse++;
		if( this->nRcvDescsInUse > this->nMaxRcvDescsInUse ){
			this->nMaxRcvDescsInUse = this->nRcvDescsInUse;
		}
	}

	ASSERT(this->nRcvDescsAllocated >= this->nRcvDescsInUse);

	Unlock(&this->RcvDescLock);

	return pReceive;
}

VOID ReleaseRcvDesc(PPROTOCOL this, PRECEIVE pReceive)
{
	Lock(&this->RcvDescLock);
	this->nRcvDescsInUse--;
	ASSERT(!(this->nRcvDescsInUse&0x80000000));
	pReceive->pNext=this->pRcvDescPool;
	this->pRcvDescPool=pReceive;
	Unlock(&this->RcvDescLock);

}


#if 0
// few enough of these, that we can just let virtual memory handle it. - switched off
VOID RcvDescTick(PPROTOCOL this)
{
	PRECEIVE pReceive;
#ifdef DEBUG
	LONG fLast; 
#endif
	// Adjusts Number of allocated buffers to 
	// highwater mark over the last ticks.
	// Call once per delta t (around a minute).
	DEBUG_BREAK(); //TRACE all paths.

	if(!InterlockedExchange(&this->fInRcvDescTick, 1)){
	
		Lock(&this->RcvDescLock);
		
		while((this->nRcvDescsAllocated > this->nMaxRcvDescsInUse) && this->pRcvDescPool){
		
			pReceive=this->pRcvDescPool;
			ASSERT_SIGN(pReceive,RECEIVE_SIGN);
			this->pRcvDescPool=this->pRcvDescPool->pNext;
			Unlock(&this->RcvDescLock);
			DeleteCriticalSection(&pReceive->ReceiveLock);
			My_GlobalFree(pReceive);
			Lock(&this->RcvDescLock);
			this->nRcvDescsAllocated--;
			
		}
		this->nMaxRcvDescsInUse=this->nRcvDescsInUse;

		ASSERT(this->nMaxRcvDescsInUse <= this->nRcvDescsAllocated);
		
		Unlock(&this->RcvDescLock);
#ifdef DEBUG
		fLast=
#endif
		InterlockedExchange(&this->fInRcvDescTick, 0);
#ifdef DEBUG
		ASSERT(fLast==1);
#endif
	}	
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\protocol\sources.inc ===
MAJORCOMP=ntos
MINORCOMP=w32
USE_MAPSYM=1

#SYNCHRONIZE_BLOCK=1

TARGETNAME=protocol
TARGETPATH=.\obj$(BUILD_ALT_DIR)
#$(BASEDIR)\public\sdk\lib\$(ALT_PROJECT_TARGET)
TARGETTYPE=LIBRARY

INCLUDES= \
    $(DXROOT)\inc; \
    ..\;\
    ..\..\dplay;\
    ..\..\common;\
    ..\..\misc; \
    ..\..\dplobby; \
    ..\..\..\dvoice\inc;

#SYNCHRONIZE_DRAIN=1

C_DEFINES=$(C_DEFINES) -DWINVER=0x0400

MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

!IFDEF PENTIUMCOUNTER
C_DEFINES=$(C_DEFINES) -DPENTIUMCOUNTER
ASM_DEFINES=$(ASM_DEFINES) -DPENTIUMCOUNTER
!endif

C_DEFINES=$(C_DEFINES)	-DUNICODE -D_UNICODE -DNEW_DPF -DSECURITY_WIN32


NTPROFILEINPUT=yes


SOURCES= \
		..\HANDLES.C     \
        ..\PROTOCOL.C    \
        ..\PSESSION.C    \
        ..\SEND.C        \
        ..\RECEIVE.C     \
        ..\STATS.C       \
        ..\BUFMGR.C      \
        ..\FRAMEBUF.C    \
        ..\SENDPOOL.C    \
        ..\BUFPOOL.C     \
        ..\RCVPOOL.C     \
        ..\STATPOOL.C    \
        ..\BILINK.C      \
		..\TIMER.C       \
        ..\MYDEBUG.C     


#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\protocol\receive.c ===
/*++

Copyright (c) 1996,1997  Microsoft Corporation

Module Name:

	RECEIVE.C

Abstract:

	Receive Handler and Receive Thread.

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
  12/10/96 aarono  Original
  02/18/98 aarono  Added support for SendEx
   6/6/98  aarono  Turn on throttling and windowing
   6/10/98 aarono  Allow out of order receives when requested by application
   4/15/99 aarono  Take a Send reference in NACK and ACK handlers
--*/

#include <windows.h>
#include "newdpf.h"
#include <dplay.h>
#include <dplaysp.h>
#include <dplaypr.h>
#include "mydebug.h"
#include "arpd.h"
#include "arpdint.h"
#include "protocol.h"
#include "macros.h"
#include "command.h"

// Note: WaitForMultipleObjects has a bug where it restarts the wait in
//       the middle of the list and can run off the end.  We put an extra
//       entry at the end of the object list to deal with this and when
//       we get an invalid_handle error, we just re-wait.

// First object is an event that is signalled when 
// the wait list needs to be changed.


// Receive List Semantics.  The Receive thread 

VOID ProcessACK(PPROTOCOL pProtocol, PCMDINFO pCmdInfo);
VOID ProcessNACK(PPROTOCOL pProtocol, PCMDINFO pCmdInfo, PUCHAR pNACKmask, UINT nNACK);
VOID ProcessAbort(PPROTOCOL pProtocol, DPID idFrom, DPID idTo, pABT1 pABT, BOOL fBig);
VOID SendACK(PPROTOCOL pProtocol, PSESSION pSession, PCMDINFO pCmdInfo);


// Function table for received commands.
UINT (*ProtocolFn[MAX_COMMAND+1])(REQUEST_PARAMS)={
	AssertMe,                                       // 0x00  
	Ping,                               // 0x01  
	PingResp,                                                       // 0x02
	GetTime,                            // 0x03  
	GetTimeResp,                                            // 0x04
	SetTime,                            // 0x05 
	SetTimeResp                                                     // 0x06
};


VOID FreeReceiveBuffers(PRECEIVE pReceive)
{
	BILINK *pBilink;
	PBUFFER pBuffer;
	pBilink=pReceive->RcvBuffList.next;
	while(pBilink != &pReceive->RcvBuffList){
		pBuffer=CONTAINING_RECORD(pBilink, BUFFER, BuffList);
		pBilink=pBilink->next;
		FreeFrameBuffer(pBuffer);
	}
}

VOID CopyReceiveBuffers(PRECEIVE pReceive,PVOID pBuffers,UINT nBuffers)
{
	#define MemDesc(_i) (*(((PMEMDESC)pBuffers)+(_i)))

	PBUFFER  pBuffer;

	UINT    BytesToCopy;
	
	UINT    BuffLen;
	UINT    BuffOffset;

	UINT    mdlen;
	UINT    mdoffset;

	UINT    i=0;

	PUCHAR  src;
	PUCHAR  dest;
	UINT    len;

	BytesToCopy=pReceive->MessageSize;

	pBuffer=(PBUFFER)pReceive->RcvBuffList.next;
	BuffLen=(UINT)(pBuffer->len-(pBuffer->pCmdData-pBuffer->pData));
	BuffOffset=0;
	
	mdlen=MemDesc(0).len;
	mdoffset=0;

	while(BytesToCopy){
		if(!mdlen){
			i++;
			mdlen=MemDesc(i).len;
			mdoffset=0;
			ASSERT(i<nBuffers);
		}
		if(!BuffLen){
			pBuffer=pBuffer->pNext;
			ASSERT(pBuffer);
			BuffLen=(UINT)(pBuffer->len-(pBuffer->pCmdData-pBuffer->pData));
			BuffOffset=0;
		}
		
		src=&pBuffer->pCmdData[BuffOffset];
		dest=&(MemDesc(i).pData[mdoffset]);

		if(BuffLen > mdlen){
			len=mdlen;
			BuffOffset+=len;
		} else {
			len=BuffLen;
			mdoffset+=len;
		}

		DPF(9,"CopyReceiveBuffers src,dest,len: %x %x %x\n",dest,src,len);

		memcpy(dest,src,len);

		BuffLen-=len;
		mdlen-=len;
		BytesToCopy-=len;
	}
	
	#undef MemDesc  
}

HRESULT _inline ParseHeader(
	FLAGS *pflags, 
	PUCHAR pData,
	DWORD  cbData,
	UINT * pCommand, 
	UINT *piEOF, 
	UINT *piEOA, 
	UINT *piEON, 
	UINT *pnNACK)
{

	if(pflags->flag1 & BIG){
		// big frame
		if(pflags->flag1 & CMD){
			// big command frame 
			if(pflags->flag1 & EXT){
				// big command frame with explicit command
				*pCommand=pflags->flag2 & ~EXT;
				if(pflags->flag2 & EXT){
					// big command frame with explicit command and NACK
					*pnNACK=pflags->flag3 & ~EXT;
					*piEOF=3;
				} else {
					// big command frame with explicit command, no NACK
					*pnNACK=0;
					*piEOF=2;
				}
			} else {
				// big -I- frame, no NACK
				*pCommand=0;
				*pnNACK=0;
				*piEOF=1;
			}
			
		} else {
			// big supervisory (non-command) frame
			if(pflags->flag1 & EXT){
				// big supervisory frame with nNACK
				*pnNACK=pflags->flag2 & ~EXT;
				ASSERT(*pnNACK);
				*piEOF=2;
			} else {
				// big supervisory frame with no-nNACK
				*pnNACK=0;
				*piEOF=1;
			}
		}
	} else {
		// small frame
		if(pflags->flag1 & CMD){
			// small command frame
			if(pflags->flag1 & EXT){
				// small command frame (with NACK?) and explicit command
				DPF(0,"ERROR PARSING FRAME, NOT RECOGNIZED, ABORTING DECODE\n");
				return DPERR_ABORTED;
				
				*pCommand = pflags->flag2 & CMD_MSK;
				*pnNACK   = (pflags->flag2 & nNACK_MSK) >> nNACK_SHIFT;
				*piEOF = 2;
			} else {
				// small -I- frame, no NACK
				*pCommand = 0;
				*pnNACK = 0;
				*piEOF = 1;
			}
		} else {
			// small supervisory (non-command) frame
			if(pflags->flag1 & EXT){
				*pnNACK   = (pflags->flag2 & nNACK_MSK) >> nNACK_SHIFT;
				*piEOF = 2;
			} else {
				*pnNACK=0;
				*piEOF=1;
			}
		}
	}

	while(pData[(*piEOF)-1]&EXT){
		// Skip past any flags extensions we don't understand.
		// small command frame (with NACK?) and explicit command
		DPF(0,"ERROR PARSING FRAME, NOT RECOGNIZED, ABORTING DECODE\n");
		return DPERR_ABORTED;
		
		(*piEOF)++;
	}
	
	*piEOA=*piEOF;

	// Update any ACK information.
	if((pflags->flag1 & ACK)){ 
		if((pflags->flag1 & BIG)){
			// LARGE ACK
			*piEOA+=sizeof(ACK2);
		} else {
			// SMALL ACK
			*piEOA+=sizeof(ACK1);
		}
	} 

	*piEON = *piEOA;
	
	// Update any NACK information.
	
	if(*pnNACK){
		if((pflags->flag1 & BIG)){
			*piEON+=sizeof(NACK2);
		}else{
			*piEON+=sizeof(NACK1);
		}
		*piEON+=*pnNACK;
	}

	// SECURITY
	if(*piEON > cbData)
	{
		DPF(1,"SECURITY WARN: invalid protocol header");
		return DPERR_ABORTED;
	}

	return DP_OK;
}

/*=============================================================================

	ProtocolReceive - Receive handler for protocol, called when we've
					  verified the message is a protocol message and
					  we've been able to allocate receive space for the
					  message
	
    Description:

		Cracks the protocol header on the message and fills in a CMDINFO
		structure to describe the protocol information in the frame.  Then
		dispatches the message along with the CMDINFO to the appropriate
		handler.

		A packet may have ACK or NACK information in the header and still
		be a command packet.  We do ACK/NACK processing first, then we
		do command processing.

		This routine will dispatch to

		ProcessACK
		ProcessNACK
		CommandReceive

    Parameters:     

		idFrom	  - index in player table of sending player
		idTo      - "                      " receiving player
		pBuffer   - a buffer we own with a copy of the message
		pSPHeader - if present can be used to issue a reply without an id.

    Return Values:

		None.

	Notes:
-----------------------------------------------------------------------------*/

VOID ProtocolReceive(PPROTOCOL pProtocol, WORD idFrom, WORD idTo, PBUFFER pBuffer, PVOID pSPHeader)
{
	#define pFrame      ((pPacket1)(pBuffer->pData))
	#define pBigFrame   ((pPacket2)(pBuffer->pData))

	#define pACK        ((pACK1)(&pData[iEOF]))
	#define pBigACK     ((pACK2)(&pData[iEOF]))

	#define pABT        ((pABT1)(&pData[iEOF]))
	#define pBigABT     ((pABT2)(&pData[iEOF]))

	#define pNACK       ((pNACK1)(&pData[iEOA]))
	#define pBigNACK    ((pNACK2)(&pData[iEOA]))

	#define pCMD        ((pCMD1)(&pData[iEON]))
	#define pBigCMD     ((pCMD2)(&pData[iEON]))

	#define cbBuf       (pBuffer->len)
	// pFrameEnd points to the byte after the last frame byte, the first invalid byte.
	#define pFrameEnd   (&pBuffer->pData[cbBuf])

	PUCHAR   pData;

	FLAGS    flags;
	
	UINT     command;   // the command if a command frame.
	UINT     nNACK;     // if this is a NACK frame, sizeof bitfield
	UINT     iEOF;      // index past end of flags
	UINT     iEOA;      // index past end of any ACK or ABT information
	UINT     iEON;      // index past end of any NACK information
	UINT     rc=0;

	PUCHAR   pNACKmask;

	HRESULT  hr;

	CMDINFO  CmdInfo;
	PCMDINFO pCmdInfo=&CmdInfo;

	CmdInfo.tReceived=timeGetTime();

	if(cbBuf < sizeof(flags)){
		DPF(1,"SECURITY WARN: received protocol frame too short");
		return; //ignore frame
	}

	pData=pBuffer->pData;
	memcpy(&flags,pData,sizeof(flags));

	hr=ParseHeader(&flags, pData, cbBuf, &command, &iEOF, &iEOA, &iEON, &nNACK);

	if(FAILED(hr)){
		goto exit;
	}

	// Get the DPLAY id's for the indicies

	CmdInfo.idFrom  = GetDPIDByIndex(pProtocol, idFrom);
	if(CmdInfo.idFrom == 0xFFFFFFFF){
		DPF(1,"Rejecting packet with invalid From Id\n",idFrom);
		goto exit;
	}
	CmdInfo.idTo    = GetDPIDByIndex(pProtocol, idTo);
	if(CmdInfo.idTo == 0xFFFFFFFF){
		DPF(1,"Rejecting packet with invalid To Id\n");
		goto exit;
	}

	DPF(9,"Protocol Receive idFrom %x idTo %x\n",CmdInfo.idFrom,CmdInfo.idTo);

	
	CmdInfo.wIdFrom = idFrom;
	CmdInfo.wIdTo   = idTo;
	CmdInfo.flags   = flags.flag1;
	CmdInfo.pSPHeader = pSPHeader;

	// determine masks to use for this size frame
	if(flags.flag1 & BIG){
		IDMSK     = 0xFFFF;
		SEQMSK    = 0xFFFF;
	} else {
		IDMSK     = 0xFF;
		SEQMSK    = 0xFF;
	}

	if((flags.flag1 & ACK))
	{
		// Process the ACK field (could be piggyback).
		if(flags.flag1 & BIG){
			pCmdInfo->messageid = pBigACK->messageid;
			pCmdInfo->sequence  = pBigACK->sequence;
			pCmdInfo->serial    = pBigACK->serial;
			pCmdInfo->bytes     = pBigACK->bytes;
			pCmdInfo->tRemoteACK= pBigACK->time;
		} else {
			pCmdInfo->messageid = pACK->messageid;
			pCmdInfo->sequence  = pACK->sequence;
			pCmdInfo->serial    = pACK->serial;
			pCmdInfo->bytes     = pACK->bytes;
			pCmdInfo->tRemoteACK= pACK->time;
		}       
		DPF(9,"ACK: msgid: %d seq %d serial %d\n",CmdInfo.messageid, CmdInfo.sequence, CmdInfo.serial);
		if(CmdInfo.serial==150){
			// this is a little excessive for retries, break out so we can debug this.
			DPF(0,"ProtocolReceive: WHOOPS, 150 retries is a little excessive\n");
			ASSERT(0);
		}	
		ProcessACK(pProtocol, &CmdInfo);
	}

	if(nNACK){
		if(flags.flag1 & BIG){
			CmdInfo.messageid = pBigNACK->messageid;
			CmdInfo.sequence  = pBigNACK->sequence;
			CmdInfo.bytes     = pBigNACK->bytes;
			CmdInfo.tRemoteACK= pBigNACK->time;
			pNACKmask         = pBigNACK->mask;
		} else {
			CmdInfo.messageid = pNACK->messageid;
			CmdInfo.sequence  = pNACK->sequence;
			CmdInfo.bytes     = pNACK->bytes;
			CmdInfo.tRemoteACK= pNACK->time;
			pNACKmask         = pNACK->mask;
		}
		DPF(9,"NACK: msgid: %d seq %d\n",CmdInfo.messageid, CmdInfo.sequence);
		ProcessNACK(pProtocol, &CmdInfo, pNACKmask, nNACK);
	}

#ifdef DEBUG
	if((flags.flag1 & ACK) || nNACK)
	{
		IN_WRITESTATS InWS;
		memset((PVOID)&InWS,0xFF,sizeof(IN_WRITESTATS));
	 	InWS.stat_RemBytesReceived=CmdInfo.bytes;
		DbgWriteStats(&InWS);
	}
#endif

	if((flags.flag1 & CMD)){

		CmdInfo.command = command;
		
		if((flags.flag1 & BIG)){
			// SECURITY
			if(iEON+5 > cbBuf)
			{
				DPF(1,"SECURITY WARN: illegally formated BIG protocol message");
				goto exit;
			}
			CmdInfo.messageid= pBigCMD->messageid;
			CmdInfo.sequence = pBigCMD->sequence;
			CmdInfo.serial   = pBigCMD->serial;
			pBuffer->pCmdData = pData+iEON+5;//(+5 for messageid(2), sequence(2), serial(1))
		} else {
			// SECURITY
			if(iEON+3 > cbBuf)
			{
				DPF(1,"SECURITY WARN: illegally formated NORMAL protocol message");
				goto exit;
			}
			CmdInfo.messageid= pCMD->messageid;
			CmdInfo.sequence = pCMD->sequence;
			CmdInfo.serial   = pCMD->serial;
			pBuffer->pCmdData = pData+iEON+3;//(+3 for byte messageid,seq,serial)
		}

		if(pBuffer->pData + pBuffer->len <= pBuffer->pCmdData){
			DPF(1,"SECURITY WARN: illegally fromated message, data message w/no data");
			goto exit;
		}

		rc=CommandReceive(pProtocol, &CmdInfo, pBuffer);
	}

	if(!rc){
exit:
		FreeFrameBuffer(pBuffer);
	}
	return;
	
	#undef pNACK   
	#undef pBigNACK

	#undef pCMD   
	#undef pBigCMD

	#undef pABT
	#undef pBigABT

	#undef pACK
	#undef pBigACK

	#undef pBigFrame
	#undef pFrame

	#undef cbBuf    
}

VOID FreeReceive(PPROTOCOL pProtocol, PRECEIVE pReceive)
{
	DPF(9,"Freeing Receive %x\n",pReceive);
	FreeReceiveBuffers(pReceive);
	ReleaseRcvDesc(pProtocol, pReceive);
}

#ifdef DEBUG
VOID DebugScanForMessageId(BILINK *pBilink, UINT messageid)
{
	BILINK *pBilinkWalker;
	PRECEIVE pReceive;
	
	pBilinkWalker=pBilink->next;
	while(pBilinkWalker!=pBilink){
		pReceive=CONTAINING_RECORD(pBilinkWalker,RECEIVE,pReceiveQ);
		if(pReceive->messageid==messageid){
			DPF(0,"ERROR: MESSAGEID x%x already exists in pReceive %x\n",pReceive);
			DEBUG_BREAK();
		}
		pBilinkWalker=pBilinkWalker->next;
	}
}
#else
#define DebugScanForMessageId(_a,_b)
#endif

#ifdef DEBUG
VOID DbgCheckReceiveStart(PSESSION pSession,PRECEIVE pReceive,PBUFFER pBuffer)
{
	BILINK *pBilink;
	PBUFFER pBuffWalker;
	
	pBilink=pReceive->RcvBuffList.next;
	if (pBilink == &pReceive->RcvBuffList)
	{
		DPF(0,"No items in list, pSession %x, pReceive %x, pBuffer %x\n",pSession,pReceive,pBuffer);
		DEBUG_BREAK();
	}

	while(pBilink != &pReceive->RcvBuffList){
		pBuffWalker=CONTAINING_RECORD(pBilink, BUFFER, BuffList);
		pBilink=pBilink->next;
		
			if(pBuffWalker->sequence==1){
				break;
			}
	}

	if( ((pBuffer->len-(pBuffer->pCmdData-pBuffer->pData)) != (pBuffWalker->len-(pBuffWalker->pCmdData-pBuffWalker->pData))) ||

	   (memcmp(pBuffWalker->pCmdData, 
	   		   pBuffer->pCmdData, 
	   		   (UINT32)(pBuffer->len-(pBuffer->pCmdData-pBuffer->pData)))) )
	{
		DPF(0,"Different retry start buffer, pSession %x, pReceive %x, pBufferOnList %x, pBuffer %x\n",pSession,pReceive,pBuffWalker,pBuffer);
		DEBUG_BREAK();
	}
	// compare the buffers
}

#else
#define DbgCheckReceiveStart
#endif

// If a receive is returned, it is locked on behalf of the caller.
/*=============================================================================

	GetReceive - for a received data message find the receive structure
	             or create one.  If this message is a retry of a completed
	             message, send an extra ACK.

    Description:

    Parameters:     
    	pProtocol
    	pSession
    	pCmdInfo

    Return Values:
    	PRECEIVE - pointer to receive for this frame

	
	Notes:
-----------------------------------------------------------------------------*/
PRECEIVE GetReceive(PPROTOCOL pProtocol, PSESSION pSession, PCMDINFO pCmdInfo, PBUFFER pBuffer)
{
	#define flags pCmdInfo->flags

	BOOL fFoundReceive=FALSE;

	BILINK *pBiHead, *pBilink;
	PRECEIVE pReceive=NULL,pReceiveWalker;

	DPF(9,"==>GetReceive pSession %x\n",pSession);

	Lock(&pSession->SessionLock);

	// Scan the queue on the SESSION for a RECEIVE with this messageid.

	if(flags & RLY){
		pBiHead = &pSession->pRlyReceiveQ;
		if(!pSession->fReceiveSmall){
			IDMSK = 0xFFFF;
		}
	} else {
		pBiHead = &pSession->pDGReceiveQ;
		if(!pSession->fReceiveSmallDG){
			IDMSK = 0xFFFF;
		}
	}
	
	pBilink = pBiHead->next;

	while(pBilink != pBiHead){

		pReceive=CONTAINING_RECORD(pBilink, RECEIVE, pReceiveQ);
		ASSERT_SIGN(pReceive, RECEIVE_SIGN);
		pBilink=pBilink->next;

		if(pReceive->messageid==pCmdInfo->messageid){

			Lock(&pReceive->ReceiveLock);
		
			if(!pReceive->fBusy){
			
				ASSERT(pReceive->command   == pCmdInfo->command);
				ASSERT(pReceive->fReliable == (flags & RLY));
				
				fFoundReceive=TRUE;
				break;
				
			} else {

				Unlock(&pReceive->ReceiveLock);
				// its moving, so its done.  Ignore.
				// there is probably a racing ACK already so ignore is fine.
				DPF(9,"GetReceive: Receive %x for messageid x%x is completing already, so ignoring receive\n",pReceive,pReceive->messageid);
				ASSERT(0);
				pReceive=NULL;
				goto exit;
			}
		}
	}

	if(!fFoundReceive){
		DPF(9,"GetReceive: Didn't find a receive for messageid x%x\n",pCmdInfo->messageid);
		pReceive=NULL;
	} else {
		DPF(9,"GetReceive: Found receive %x for messageid x%x\n",pReceive, pCmdInfo->messageid);
	}

	if(pReceive && ( flags & STA )){
		// Should get blown away below - this is the start frame, but we already got it
		DPF(9,"GetReceive: Got start for receive %x messageid x%x we already have going\n",pReceive, pCmdInfo->messageid);
		DbgCheckReceiveStart(pSession,pReceive,pBuffer);
		Unlock(&pReceive->ReceiveLock);
		pReceive=NULL;
		goto ACK_EXIT;
	}
	
	if(!pReceive){
		if(flags & RLY){
			UINT MsgIdDelta;
			DWORD bit;
			
			MsgIdDelta=(pCmdInfo->messageid - pSession->FirstRlyReceive)&IDMSK;
			bit=MsgIdDelta-1;

			if((bit > MAX_LARGE_CSENDS) || (pSession->InMsgMask & (1<<bit))){
				DPF(9,"GetReceive: dropping extraneous rexmit data\n");
				if(flags & (EOM|SAK)) {
					// RE-ACK the message.
					DPF(9,"GetReceive: Sending extra ACK anyway\n");
					goto ACK_EXIT;
				}
				goto exit; // Drop it, this is for an old message.
			} else {

//			if( (MsgIdDelta==0) || 
//				((pSession->fReceiveSmall)?(MsgIdDelta > MAX_SMALL_CSENDS):(MsgIdDelta > MAX_LARGE_CSENDS))){
//				DPF(5,"GetReceive: dropping extraneous rexmit data\n");
//				if(flags & EOM|SAK) {
//					// RE-ACK the message.
//					DPF(5,"GetReceive: Sending extra ACK anyway\n");
//					goto ACK_EXIT;
//				}
//				goto exit; // Drop it, this is for an old message.
//			} else {
				if(flags & STA){
					if(pSession->LastRlyReceive==pCmdInfo->messageid){
						DPF(9,"RECEIVE: dropping resend for messageid x%x, but ACKING\n",pCmdInfo->messageid);
						// RE-ACK the message.
						goto ACK_EXIT;
					}      

					if(((pSession->LastRlyReceive-pSession->FirstRlyReceive)&IDMSK)<MsgIdDelta){
						pSession->LastRlyReceive=pCmdInfo->messageid;
						DPF(9,"GetReceive: New messageid x%x FirstRcv %x LastRcv %x\n",pCmdInfo->messageid,pSession->FirstRlyReceive,pSession->LastRlyReceive);
						#ifdef DEBUG
						if(!pSession->fReceiveSmall){
							if(((pSession->LastRlyReceive-pSession->FirstRlyReceive) & 0xFFFF) > MAX_LARGE_CSENDS){
								ASSERT(0);
							}
						} else {
							if(((pSession->LastRlyReceive-pSession->FirstRlyReceive) & 0x0FF) > MAX_SMALL_CSENDS){
								ASSERT(0);
							}
						}
						#endif

					}
				}
			}
		} else {
		
			// Nonreliable, blow away any messages outside the window.
			// also blow away any residual messages with same number if we are a START.
			pBiHead = &pSession->pDGReceiveQ;
			pBilink = pBiHead->next;
			while( pBilink != pBiHead ){
			
				pReceiveWalker=CONTAINING_RECORD(pBilink, RECEIVE, pReceiveQ);
				ASSERT_SIGN(pReceiveWalker, RECEIVE_SIGN);
				pBilink=pBilink->next;

				if(!pReceiveWalker->fBusy && 
						( (((pCmdInfo->messageid - pReceiveWalker->messageid) & IDMSK ) > ((pSession->fReceiveSmallDG)?(MAX_SMALL_DG_CSENDS):(MAX_LARGE_DG_CSENDS))) ||
						  ((flags&STA) && pCmdInfo->messageid==pReceiveWalker->messageid) 
						)
					){

					Lock(&pReceiveWalker->ReceiveLock);
					if(!pReceiveWalker->fBusy){
						DPF(9,"GetReceive: Got Id %d Throwing Out old Datagram Receive id %d\n",pCmdInfo->messageid,pReceiveWalker->messageid);
						Delete(&pReceiveWalker->pReceiveQ);
						Unlock(&pReceiveWalker->ReceiveLock);
						FreeReceive(pProtocol,pReceiveWalker);
					} else {
						ASSERT(0);
						DPF(0,"GetReceive: Got Id %d Couldn't throw out DG id %d\n",pCmdInfo->messageid,pReceiveWalker->messageid);
						Unlock(&pReceiveWalker->ReceiveLock);
					}
				}       
			}       
		}
		
		// Allocate a receive structure
		if(flags & STA){
			pReceive=GetRcvDesc(pProtocol);
			DPF(9,"allocated new receive %x messageid x%x\n",pReceive,pCmdInfo->messageid);
			if(!pReceive){
				// no memory, drop it.
				ASSERT(0);
				DPF(0,"RECEIVE: no memory! dropping packet\n");
				goto exit;
			}

			pReceive->pSession    = pSession;
			pReceive->fBusy       = FALSE;
			pReceive->fReliable   = flags&RLY;
			pReceive->fEOM        = FALSE;
			pReceive->command     = pCmdInfo->command;
			pReceive->messageid   = pCmdInfo->messageid;
			pReceive->iNR         = 0;
			pReceive->NR          = 0; 
			pReceive->NS          = 0;
			pReceive->RCVMask     = 0;
			pReceive->MessageSize = 0;
			InitBilink(&pReceive->RcvBuffList);
			Lock(&pReceive->ReceiveLock);
			
		
			if(flags & RLY){
				// Set bit in incoming receive mask;
				DebugScanForMessageId(&pSession->pRlyReceiveQ, pCmdInfo->messageid);
				InsertAfter(&pReceive->pReceiveQ,&pSession->pRlyReceiveQ);
			} else {
				DebugScanForMessageId(&pSession->pDGReceiveQ, pCmdInfo->messageid);
				InsertAfter(&pReceive->pReceiveQ,&pSession->pDGReceiveQ);
			}       
			// Save the SP header for indications
			if(pCmdInfo->pSPHeader){
				pReceive->pSPHeader=&pReceive->SPHeader[0];
				memcpy(pReceive->pSPHeader, pCmdInfo->pSPHeader, pProtocol->m_dwSPHeaderSize);
			} else {
				pReceive->pSPHeader=NULL;
			}
		}       
	}

exit:   
	Unlock(&pSession->SessionLock);

unlocked_exit:  
	DPF(9,"<==GetReceive pSession %x pReceive %x\n",pSession, pReceive);

	return pReceive;

	#undef flags

ACK_EXIT:
	Unlock(&pSession->SessionLock);
	SendACK(pProtocol,pSession,pCmdInfo);
	goto unlocked_exit;
}

VOID PutBufferOnReceive(PRECEIVE pReceive, PBUFFER pBuffer)
{
	BILINK *pBilink;
	PBUFFER pBuffWalker;
	
	pBilink=pReceive->RcvBuffList.prev;

	while(pBilink != &pReceive->RcvBuffList){
		pBuffWalker=CONTAINING_RECORD(pBilink, BUFFER, BuffList);
		#ifdef DEBUG
			if(pBuffWalker->sequence==pBuffer->sequence){
				DPF(0,"already have sequence queued?\n");
				DEBUG_BREAK();
				break;
			}
		#endif
		if(pBuffWalker->sequence < pBuffer->sequence){
			break;
		}
		pBilink=pBilink->prev;
	}
	
	InsertAfter(&pBuffer->BuffList, pBilink);
}

// Chains receives that must be also be completed on this Receive
VOID ChainReceiveFromQueue(PSESSION pSession, PRECEIVE pReceive, UINT messageid)
{
	BOOL bFound=FALSE;
	BILINK *pBilink;
	PRECEIVE pReceiveWalker;

	DPF(9,"==>ChainReceiveFromQueue on pReceive %x, chain messageid x%x\n",pReceive,messageid);

	ASSERT(messageid!=pReceive->messageid);
	ASSERT(!EMPTY_BILINK(&pSession->pRlyWaitingQ));

	pBilink=pSession->pRlyWaitingQ.next;

	while(pBilink != &pSession->pRlyWaitingQ){
		pReceiveWalker=CONTAINING_RECORD(pBilink, RECEIVE, pReceiveQ);
		if(pReceiveWalker->messageid==messageid){
			bFound=TRUE;
			break;
		}
		pBilink=pBilink->next;
	}

	if(bFound){
		// store in order on pReceive->pReceiveQ
		Delete(&pReceiveWalker->pReceiveQ);
		InsertBefore(&pReceiveWalker->pReceiveQ,&pReceive->pReceiveQ);
		DPF(9,"<==ChainReceiveFromQueue: Chained pReceiveWalker %x messageid x%x on pReceive %x\n",pReceiveWalker, pReceiveWalker->messageid, pReceive);
	} else {
#ifdef DEBUG
		DPF(9,"<==ChainReceiveFromQueue, messageid x%x NOT FOUND!!!, Maybe out of order receive\n",messageid);
		if(!(pSession->pProtocol->m_lpDPlay->dwFlags & DPLAYI_DPLAY_PROTOCOLNOORDER)){
			DPF(0,"<==ChainReceiveFromQueue, messageid x%x NOT FOUND!!!, NOT ALLOWED with PRESERVE ORDER\n",messageid);
			DEBUG_BREAK();
		}
#endif	
	}

}

VOID BlowAwayOldReceives(PSESSION pSession, DWORD messageid, DWORD MASK)
{
	BOOL fFoundReceive=FALSE;

	BILINK *pBiHead, *pBilink;
	PRECEIVE pReceive=NULL;

	pBiHead = &pSession->pRlyReceiveQ;
	pBilink = pBiHead->next;

	while(pBilink != pBiHead){

		pReceive=CONTAINING_RECORD(pBilink, RECEIVE, pReceiveQ);
		ASSERT_SIGN(pReceive, RECEIVE_SIGN);
		pBilink=pBilink->next;

		if((int)((pReceive->messageid-messageid)&MASK) <= 0){

			Lock(&pReceive->ReceiveLock);

			if(!pReceive->fBusy){

				DPF(8,"Blowing away duplicate receive %x id\n",pReceive, pReceive->messageid);
			
				Delete(&pReceive->pReceiveQ);
				Unlock(&pReceive->ReceiveLock);
				FreeReceive(pSession->pProtocol, pReceive);
				
			} else {
				DPF(0,"Huston, we have a problem pSession %x, pReceive %x, messageid %d\n",pSession,pReceive,messageid);
				DEBUG_BREAK();
				Unlock(&pReceive->ReceiveLock);
			}
		}
	}
}


// called with receive lock held, SESSIONion lock unheld, 
// returns with receivelock unheld, but receive not on any lists.
// 0xFFFFFFFF means receive was bogus and blown away
UINT DeQueueReceive(PSESSION pSession, PRECEIVE pReceive, PCMDINFO pCmdInfo)
{
	UINT bit;
	UINT nComplete=0;

	DPF(9,"==>DQReceive pReceive %x, messageid x%x\n",pReceive, pReceive->messageid);

		pReceive->fBusy=TRUE;
		Unlock(&pReceive->ReceiveLock);
		
	Lock(&pSession->SessionLock);
		Lock(&pReceive->ReceiveLock);

			// Pull off of receive Q
			Delete(&pReceive->pReceiveQ);
			InitBilink(&pReceive->pReceiveQ); // so we can chain on here.
			pReceive->fBusy=FALSE;

			bit=((pReceive->messageid-pSession->FirstRlyReceive)&IDMSK)-1;

			if(bit >= MAX_LARGE_CSENDS){
				// Duplicate receive, blow it away
				Unlock(&pReceive->ReceiveLock);
				FreeReceive(pSession->pProtocol,pReceive);
				Unlock(&pSession->SessionLock);
				return 0xFFFFFFFF;
			}

			#ifdef DEBUG
				if(pSession->InMsgMask > (UINT)((1<<((pSession->LastRlyReceive-pSession->FirstRlyReceive)&IDMSK))-1)){
					DPF(0,"Bad InMsgMask %x pSession %x\n", pSession->InMsgMask, pSession);
					DEBUG_BREAK();
				}
			#endif	

			pSession->InMsgMask |= 1<<bit;

			while(pSession->InMsgMask&1){
				nComplete++;
				pSession->FirstRlyReceive=(pSession->FirstRlyReceive+1)&IDMSK;
				BlowAwayOldReceives(pSession, pSession->FirstRlyReceive,IDMSK);
				if(nComplete > 1){
					// Chain extra receives to be indicated on this receive.
					ChainReceiveFromQueue(pSession, pReceive,pSession->FirstRlyReceive);
				}
				pSession->InMsgMask>>=1;
			}

			#ifdef DEBUG
				DPF(9,"DQ: FirstRcv %x LastRcv %x\n",pSession->FirstRlyReceive,pSession->LastRlyReceive);
				if((pSession->LastRlyReceive-pSession->FirstRlyReceive & IDMSK) > MAX_LARGE_CSENDS){
					DEBUG_BREAK();
				}
			#endif	
			
		Unlock(&pReceive->ReceiveLock);
	Unlock(&pSession->SessionLock);

	DPF(9,"<==DQReceive pReceive %x nComplete %d\n",pReceive,nComplete);
	
	return nComplete;
}

// called with receive lock held, SESSIONion lock unheld, 
// returns with receivelock unheld, but receive not on any lists.
VOID DGDeQueueReceive(PSESSION pSession, PRECEIVE pReceive)
{
		pReceive->fBusy=TRUE;
		Unlock(&pReceive->ReceiveLock);
	Lock(&pSession->SessionLock);
		Lock(&pReceive->ReceiveLock);
			// Pull off of receive Q
			Delete(&pReceive->pReceiveQ);
			InitBilink(&pReceive->pReceiveQ);
			pReceive->fBusy=FALSE;
		Unlock(&pReceive->ReceiveLock);
	Unlock(&pSession->SessionLock);
}

#ifdef DEBUG
VOID CheckWaitingQ(PSESSION pSession, PRECEIVE pReceive, PCMDINFO pCmdInfo)
{
	BILINK *pBilink;
	PRECEIVE pReceiveWalker;
	UINT     iReceiveWalker; 
	UINT     iReceive;  // our index based on FirstRlyReceive 

	DPF(9,"==>Check WaitingQ\n");

	Lock(&pSession->SessionLock);

	iReceive=(pReceive->messageid-pSession->FirstRlyReceive)&IDMSK;
	
	pBilink=pSession->pRlyWaitingQ.next;

	while(pBilink != &pSession->pRlyWaitingQ){
		pReceiveWalker=CONTAINING_RECORD(pBilink, RECEIVE, pReceiveQ);
		iReceiveWalker=(pReceiveWalker->messageid-pSession->FirstRlyReceive)&IDMSK;
		
		if((int)iReceiveWalker < 0){
			DEBUG_BREAK();
		}
		
		if(iReceiveWalker == iReceive){
			DPF(9,"Found Duplicate Receive index %d on WaitingQ %x pSession %x\n",iReceiveWalker, &pSession->pRlyWaitingQ, pSession);
			// found our insert point.
			break;
		}
		pBilink=pBilink->next;
	}
	
	Unlock(&pSession->SessionLock);
	DPF(9,"<==CheckWaitingQ\n");
	
}
#else
#define CheckWaitingQ
#endif

#ifdef DEBUG
VOID DUMPBYTES(PCHAR pBytes, DWORD nBytes)
{
	UCHAR Target[16];
	INT i;

	i=0;
	while(nBytes){
	
		memset(Target,0,16);

		if(nBytes > 16){
			memcpy(Target,pBytes+i*16,16);
			nBytes-=16;
		} else {
			memcpy(Target,pBytes+i*16,nBytes);
			nBytes=0;
		}

		DPF(9,"%04x:  %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n", i*16,
		Target[0],Target[1],Target[2],Target[3],Target[4],Target[5],Target[6],Target[7],
		Target[8],Target[9],Target[10],Target[11],Target[12],Target[13],Target[14],Target[15]); 
		
		i++;
	}	

}
#else
#define DUMPBYTES(a,b)
#endif

// Out of order reliable message, queue it up on the session.
VOID QueueReceive(PPROTOCOL pProtocol, PSESSION pSession, PRECEIVE pReceive, PCMDINFO pCmdInfo)
{
	BILINK *pBilink;
	PRECEIVE pReceiveWalker;
	UINT     iReceiveWalker; 
	UINT     iReceive;  // our index based on FirstRlyReceive 

	DPF(9,"==>QueueReceive Out of order pReceive %x messageid x%x\n",pReceive,pReceive->messageid);

	Lock(&pSession->SessionLock);
	// Don't need the receive lock since receive already dequeued.

	// insert the receive into the pRlyWaitingQ, in order - 
	// based pSession->FirstRlyReceive IDMSK
	// list is ordered left to right, scan from end for our slot.

	CheckWaitingQ(pSession, pReceive, pCmdInfo);

	iReceive=(pReceive->messageid-pSession->FirstRlyReceive)&IDMSK;
	
	pBilink=pSession->pRlyWaitingQ.prev;

	while(pBilink != &pSession->pRlyWaitingQ){
		pReceiveWalker=CONTAINING_RECORD(pBilink, RECEIVE, pReceiveQ);
		iReceiveWalker=(pReceiveWalker->messageid-pSession->FirstRlyReceive)&IDMSK;
		
		if((int)iReceiveWalker < 0){
			DEBUG_BREAK();
		}
		
		if(iReceiveWalker < iReceive){
			// found our insert point.
			break;
		}
		pBilink=pBilink->prev;
	}
	
	// insert in the list.

	InsertAfter(&pReceive->pReceiveQ,pBilink);
	
	Unlock(&pSession->SessionLock);
	DPF(9,"<==QueueReceive Out of order pReceive\n");
}

VOID IndicateReceive(PPROTOCOL pProtocol, PSESSION pSession, PRECEIVE pReceive, UINT nToIndicate)
{
	PDOUBLEBUFFER pDoubleBuffer;
	MEMDESC memdesc;

	BILINK *pBilink, *pBilinkAnchor;
	PRECEIVE pReceiveWalker;

	DPF(9,"==>IndicateReceive pReceive %x nToIndicate %d\n",pReceive,nToIndicate);

	pBilink=pBilinkAnchor=&pReceive->pReceiveQ;
	
	do{
		pReceiveWalker=CONTAINING_RECORD(pBilink, RECEIVE, pReceiveQ);

		// Assemble the message into one frame (if it isn't already)

		if(pReceiveWalker->iNR==1){
			// one frame.
			PBUFFER pBuffer;
			
			
			pBuffer=CONTAINING_RECORD(pReceiveWalker->RcvBuffList.next, BUFFER, BuffList);
			LEAVE_DPLAY();
			DPF(9,"Single Indicating pReceive %x messageid x%x\n",pReceiveWalker, pReceiveWalker->messageid);
			DUMPBYTES(pBuffer->pCmdData, min((UINT32)(pBuffer->len-(pBuffer->pCmdData-pBuffer->pData)),48));
			InternalHandleMessage(pProtocol->m_lpISP,
								pBuffer->pCmdData,
								(ULONG32)(pBuffer->len-(pBuffer->pCmdData-pBuffer->pData)),
								pReceiveWalker->pSPHeader,0);
			ENTER_DPLAY();                                  
								
		} else {

			// multiple frames, copy to a contiguous chunk.
			
			pDoubleBuffer=GetDoubleBuffer(pReceiveWalker->MessageSize);
			if(pDoubleBuffer){

				memdesc.pData=pDoubleBuffer->pData;
				memdesc.len=pDoubleBuffer->len;

				CopyReceiveBuffers(pReceiveWalker,&memdesc,1);

				LEAVE_DPLAY();
				DPF(9,"Multi Indicating pReceive %x messageid x%x\n",pReceiveWalker, pReceiveWalker->messageid);
				
				DUMPBYTES(memdesc.pData, min(memdesc.len,48));
				
				InternalHandleMessage(pProtocol->m_lpISP,
									memdesc.pData,
									memdesc.len,
									pReceiveWalker->pSPHeader,0);
				ENTER_DPLAY();

				FreeDoubleBuffer((PBUFFER)pDoubleBuffer);
			} else {
				DPF(0,"NO MEMORY, MESSAGE DROPPED!\n");
				ASSERT(0);
			}
		}

		pBilink=pBilink->next;
		FreeReceive(pProtocol, pReceiveWalker);
		
	} while (pBilink != pBilinkAnchor);
	
	DPF(9,"<==IndicateReceive\n");
}

// called with receive lock held, must release
int ReliableAccept(PPROTOCOL pProtocol, PSESSION pSession, PRECEIVE pReceive, PCMDINFO pCmdInfo, PBUFFER pBuffer)
{
	int rc=0,rc2;

	UINT sequence;
	UINT bit;
	UINT bitmask;
	UINT nToIndicate;
	
	// if its moving, we already have all the data, so drop this.(OPTIMIZATION: maybe ACK again?)
	if(!pReceive->fBusy){
		
		bit=(pCmdInfo->sequence-pReceive->NR-1 ) & SEQMSK;

		if(bit < 32){

			// Calculate absolute sequence number of this packet.
			pBuffer->sequence = sequence = (bit+1) + pReceive->iNR;
			
			bitmask=1<<bit;

			if((pReceive->RCVMask & bitmask)){
			
				rc=FALSE; // already got this one - reject.
				
			} else {

				// Accept it.

				PutBufferOnReceive(pReceive,pBuffer);
				pReceive->MessageSize+=(UINT)((pBuffer->pData+pBuffer->len)-pBuffer->pCmdData);

				pReceive->RCVMask |= bitmask;

				if( ((pReceive->NS-pReceive->NR)&SEQMSK) <= bit){
					pReceive->NS=(pReceive->NR+bit+1)&SEQMSK;
				}
				
				// update NR based on set received bits.
				while(pReceive->RCVMask & 1){
					pReceive->RCVMask >>= 1;
					pReceive->iNR++;
					pReceive->NR=(pReceive->NR+1)&SEQMSK;
				}

				DPF(9,"Reliable ACCEPT: pReceive %x messageid %x iNR %8x NR %2x, NS %2x RCVMask %8x, SEQMSK %2x\n",pReceive, pReceive->messageid, pReceive->iNR, pReceive->NR,pReceive->NS,pReceive->RCVMask,SEQMSK);

				rc=TRUE; // packet accepted.
			}       
			
		} else {
			DPF(9,"Reliable ACCEPT: Rejecting Packet Seq %x, NR %x, SEQMSK %x\n",pCmdInfo->sequence, pReceive->NR, SEQMSK);
		}

		if(pCmdInfo->flags & (SAK|EOM)) {
			//ACKrc=SendAppropriateResponse, check code, if ACK on EOM, then POST receive.
			rc2=SendAppropriateResponse(pProtocol, pSession, pCmdInfo, pReceive); 
			
			if(pCmdInfo->flags & EOM){
				if(rc2==SAR_ACK){
					goto ReceiveDone;
				} else {
					pReceive->fEOM=TRUE;    
				}
			} else if(pReceive->fEOM){
				if(!pReceive->RCVMask){
					goto ReceiveDone;
				}
			}
		}
	} else  {
		ASSERT(0);
	}

	Unlock(&pReceive->ReceiveLock);
	return rc;


ReceiveDone:
	DPF(9,"++>ReceiveDone\n");
	if(nToIndicate=DeQueueReceive(pSession, pReceive, pCmdInfo)){   // unlocks pReceive->ReceiveLock
		if(nToIndicate != 0xFFFFFFFF){
			IndicateReceive(pProtocol, pSession, pReceive, nToIndicate);                    
		}	
	} else if(pProtocol->m_lpDPlay->dwFlags & DPLAYI_DPLAY_PROTOCOLNOORDER){
		// Out of order receives are OK
		IndicateReceive(pProtocol, pSession, pReceive, 1);
	} else {
		QueueReceive(pProtocol,pSession,pReceive, pCmdInfo);
	}
	DPF(9,"<--ReceiveDone\n");
	return rc;
}

// Returns highest order byte in n with set bits.
UINT SetBytes(UINT n)
{
	UINT nr;
	if(n==(n&0xFFFF)){
		if(n==(n&0xFF)){
			 nr=1;
		} else {
			 nr=2;
		}
	} else {
		if(n==(n&0xFFFFFF)){
			nr=3;
		} else {
			nr=4;
		}
	}
	return nr;
}

VOID InternalSendComplete(PVOID Context, UINT Status)
{
	PSEND pSend=(PSEND)Context;

	if(pSend->dwFlags & ASEND_PROTOCOL){
		// nothing to do?
	} else if(pSend->bSendEx){
		// send completion if required
		if(pSend->dwFlags & DPSEND_ASYNC){
			DP_SP_SendComplete(pSend->pProtocol->m_lpISP, pSend->lpvUserMsgID, Status);
		}
	}
}

// Used by internal routines for sending.
VOID FillInAndSendBuffer(
	PPROTOCOL pProtocol, 
	PSESSION pSession,
	PSEND pSend,
	PBUFFER pBuffer,
	PCMDINFO pCmdInfo)
{
	pSend->pMessage                 = pBuffer;
	pSend->MessageSize              = pBuffer->len;
	
	pSend->pSession                 = pSession;
	pSend->SendOffset               = 0;
	pSend->pCurrentBuffer           = pBuffer;
	pSend->CurrentBufferOffset      = 0;

	pSend->RefCount             	= 0;
	pSend->pProtocol                = pProtocol;
	pSend->dwMsgID                  = 0;
	pSend->bSendEx                  = FALSE;

//	pSend->BytesThisSend            = 0;

	// Internal sends MUST be highest pri - else can deadlock head to head.
	pSend->Priority                         = 0xFFFFFFFF; 
	pSend->dwFlags                          = ASEND_PROTOCOL;
	pSend->dwTimeOut                        = 0;
	pSend->pAsyncInfo                       = 0;
	pSend->AsyncInfo.hEvent     			= 0;
	pSend->AsyncInfo.SendCallBack			= InternalSendComplete;
	pSend->AsyncInfo.CallBackContext		= pSend;
	pSend->AsyncInfo.pStatus   				= &pSend->Status;
	pSend->SendState                        = Start;
	pSend->RetryCount                       = 0;
	pSend->PacketSize                       = pSession->MaxPacketSize; 

	pSend->NR                               = 0;
	pSend->NS                   			= 0;

	pSend->idFrom                           = pCmdInfo->idTo;
	pSend->idTo                             = pCmdInfo->idFrom;
	pSend->wIdTo							= pCmdInfo->wIdFrom;

	pSend->serial               			= 0;

	ISend(pProtocol,pSession,pSend);
}       


UINT WrapBuffer(PPROTOCOL pProtocol, PCMDINFO pCmdInfo, PBUFFER pBuffer)
{
	PUCHAR pMessage,pMessageStart;
	DWORD dwWrapSize=0;
	DWORD dwIdTo=0;
	DWORD dwIdFrom=0;

	pMessageStart = &pBuffer->pData[pProtocol->m_dwSPHeaderSize];
	pMessage      = pMessageStart;
	dwIdFrom      = pCmdInfo->wIdTo;
	dwIdTo        = pCmdInfo->wIdFrom;
	
	if(dwIdFrom==0x70){ // avoid looking like a system message 'play'
		dwIdFrom=0xFFFF;
	}

	if(dwIdFrom){
		while(dwIdFrom){
			*pMessage=(UCHAR)(dwIdFrom & 0x7F);
			dwIdFrom >>= 7;
			if(dwIdFrom){
				*pMessage|=0x80;
			}
			pMessage++;
		}
	} else {
		*(pMessage++)=0;
	}

	if(dwIdTo){
		
		while(dwIdTo){
			*pMessage=(UCHAR)(dwIdTo & 0x7F);
			dwIdTo >>= 7;
			if(dwIdTo){
				*pMessage|=0x80;
			}
			pMessage++;
		}
	} else {
		*(pMessage++)=0;
	}
	
	return (UINT)(pMessage-pMessageStart);
}       

UINT SendAppropriateResponse(PPROTOCOL pProtocol, PSESSION pSession, PCMDINFO pCmdInfo, PRECEIVE pReceive)
{
	#define pBigACK ((pACK2)pACK)
	#define pBigNACK ((pNACK2)pNACK)

	UINT rc=SAR_FAIL;

	PSEND pSend;

	PBUFFER pBuffer;

	pFLAGS pFlags;
	pACK1  pACK;
	pNACK1 pNACK;

	UINT   RCVMask;

	UINT   WrapSize;

	// OPTIMIZATION: piggyback ACK on pending send if available.

	pSend=GetSendDesc();

	if(!pSend){
		goto exit1;
	}
	
	pBuffer = GetFrameBuffer(pProtocol->m_dwSPHeaderSize+MAX_SYS_HEADER);
	
	if(!pBuffer){
		goto exit2;     // out of memory, bail
	}       

	WrapSize  = pProtocol->m_dwSPHeaderSize;
	WrapSize += WrapBuffer(pProtocol, pCmdInfo, pBuffer);

	pFlags=(pFLAGS)&pBuffer->pData[WrapSize];

	// See if we need to ACK or NACK.
	if(pReceive->RCVMask){
		UINT nNACK=SetBytes(pReceive->RCVMask);
		rc=SAR_NACK;
		// Send a NACK  
		if(pCmdInfo->flags & BIG){
			// BIG HEADER FORMAT NACK
			pNACK=(pNACK1)(&pFlags->flag3);
			pFlags->flag1 = EXT|BIG|RLY;
			pFlags->flag2 = (byte)nNACK;
			pBigNACK->sequence = (word)pReceive->NR;
			pBigNACK->messageid = (word)pReceive->messageid;
			pBigNACK->time = pCmdInfo->tReceived;
			pBigNACK->bytes = pSession->LocalBytesReceived;
			RCVMask=pReceive->RCVMask;
			memcpy(&pBigNACK->mask, &RCVMask, nNACK);
			pBuffer->len=WrapSize+2+sizeof(NACK2)+nNACK; // 2 for flags
		} else {
			// SMALL HEADER FORMAT NACK
			pNACK=(pNACK1)(&pFlags->flag3);
			pFlags->flag1 = EXT|RLY;
			ASSERT(nNACK < 4);
			ASSERT(pReceive->NR < 32);
			pFlags->flag2 = nNACK << nNACK_SHIFT;
			pNACK->messageid=(byte)pReceive->messageid;
			pNACK->sequence=(byte)pReceive->NR;
			pNACK->time = pCmdInfo->tReceived;
			pNACK->bytes = pSession->LocalBytesReceived;
			RCVMask=pReceive->RCVMask;
			memcpy(&pNACK->mask, &RCVMask, nNACK);
			pBuffer->len=WrapSize+2+sizeof(NACK1)+nNACK; // 2 for flags
			DPF(9,"RcvMask %x Send Appropriate response nNACK=%d\n",pReceive->RCVMask,nNACK);
		}
	} else {
		// Send an ACK
		rc=SAR_ACK;
		pACK    = (pACK1)(&pFlags->flag2);

		if(pCmdInfo->flags & BIG){
			// Big packet
			pFlags->flag1     = ACK|BIG;
			pBigACK->messageid= (word)pReceive->messageid;
			pBigACK->sequence = pCmdInfo->sequence;
			pBigACK->serial   = pCmdInfo->serial;
			pBigACK->time     = pCmdInfo->tReceived;
			pBigACK->bytes    = pSession->LocalBytesReceived;
			pBuffer->len      = sizeof(ACK2)+1+WrapSize;
		} else {
			// Small packet
			pFlags->flag1   = ACK;
			pACK->messageid = (byte)pReceive->messageid;
			pACK->sequence  = (UCHAR)pCmdInfo->sequence;
			pACK->serial    = pCmdInfo->serial;
			pACK->time      = pCmdInfo->tReceived;
			pACK->bytes     = pSession->LocalBytesReceived;
			pBuffer->len    = sizeof(ACK1)+1+WrapSize;
			DPF(9,"RcvMask %x Send Appropriate response ACK seq=%x\n",pReceive->RCVMask,pACK->sequence);
		}
	}
	
	pFlags->flag1 |= (pCmdInfo->flags & RLY);

	FillInAndSendBuffer(pProtocol,pSession,pSend,pBuffer,pCmdInfo);

exit1:
	return rc;

exit2:
	ReleaseSendDesc(pSend);
	return rc;

#undef pBigACK
#undef pBigNACK
}

// ACKs CmdInfo packet.
VOID SendACK(PPROTOCOL pProtocol, PSESSION pSession, PCMDINFO pCmdInfo)
{
	#define pBigACK ((pACK2)pACK)

	PSEND pSend;

	PBUFFER pBuffer;

	pFLAGS pFlags;
	pACK1 pACK;

	UINT WrapSize;

	// OPTIMIZATION: piggyback ACK on pending send if available.

	pSend=GetSendDesc();

	if(!pSend){
		goto exit1;
	}
	
	// allocation here is bigger than necessary but should 
	// recyle ACK/NACK buffers.
	pBuffer = GetFrameBuffer(pProtocol->m_dwSPHeaderSize+MAX_SYS_HEADER);
	
	if(!pBuffer){
		goto exit2;     // out of memory, bail
	}       

	WrapSize  = pProtocol->m_dwSPHeaderSize;
	WrapSize += WrapBuffer(pProtocol, pCmdInfo, pBuffer);

	pFlags=(pFLAGS)&pBuffer->pData[WrapSize];

	pACK    = (pACK1)(&pFlags->flag2);

	if(pCmdInfo->flags & BIG){
		// Big packet
		pFlags->flag1     = ACK|BIG;
		pBigACK->sequence = pCmdInfo->sequence;
		pBigACK->serial   = pCmdInfo->serial;
		pBigACK->messageid= pCmdInfo->messageid;
		pBigACK->bytes    = pSession->LocalBytesReceived;
		pBigACK->time     = pCmdInfo->tReceived;
		pBuffer->len    = sizeof(ACK2)+1+WrapSize;
	} else {
		// Small packet
		pFlags->flag1   = ACK;
		pACK->messageid = (UCHAR)pCmdInfo->messageid;
		pACK->sequence  = (UCHAR)pCmdInfo->sequence;
		pACK->serial    = pCmdInfo->serial;
		pACK->bytes     = pSession->LocalBytesReceived;
		pACK->time      = pCmdInfo->tReceived;
		pBuffer->len    = sizeof(ACK1)+1+WrapSize;
		DPF(9,"Send Extra ACK seq=%x, serial=%x\n",pACK->sequence,pACK->serial);
	}

	pFlags->flag1 |= (pCmdInfo->flags & RLY);
	
	FillInAndSendBuffer(pProtocol,pSession,pSend,pBuffer,pCmdInfo);
	
exit1:
	return;

exit2:
	ReleaseSendDesc(pSend);
	return;
}

// Called with receive lock.  Returns without lock.
UINT DGAccept(PPROTOCOL pProtocol, PSESSION pSession, PRECEIVE pReceive, PCMDINFO pCmdInfo, PBUFFER pBuffer)
{
	
	ASSERT(!pReceive->fBusy);
	//if(!pReceive->fBusy){

		// Allows datagram receive to start on any serial.
		if(pCmdInfo->flags & STA){
			pReceive->NR=pCmdInfo->serial;
		}
	
		if(pReceive->NR == pCmdInfo->serial){

			pReceive->iNR++;        //really unnecessary, but interesting.

			pReceive->NR = (pReceive->NR+1) & SEQMSK;

			// Add the buffer to the receive buffer list.
			InsertBefore(&pBuffer->BuffList, &pReceive->RcvBuffList);
			pReceive->MessageSize+=(UINT)((pBuffer->pData+pBuffer->len)-pBuffer->pCmdData);

			if(pCmdInfo->flags & EOM){
				DGDeQueueReceive(pSession, pReceive); //unlock's receive.
				IndicateReceive(pProtocol, pSession, pReceive,1);                       
			} else {
				Unlock(&pReceive->ReceiveLock);
			}

			return TRUE; // ate the buffer.
			
		} else {
			// Throw this puppy out.
			ASSERT(!pReceive->fBusy);
			DGDeQueueReceive(pSession, pReceive);
			FreeReceive(pProtocol, pReceive);
		}

	//}
	return FALSE;
}

UINT CommandReceive(PPROTOCOL pProtocol, PCMDINFO pCmdInfo, PBUFFER pBuffer)
{
	#define flags pCmdInfo->flags
	PSESSION      pSession;
	UINT          rc=0;             // by default, buffer not accepted.
	PRECEIVE      pReceive;

	pSession=GetSysSessionByIndex(pProtocol, pCmdInfo->wIdFrom);

	if(!pSession) {
		DPF(9,"CommandReceive: Throwing out receive for gone session\n");
		goto drop_exit;
	}
	
	if(flags & BIG){
		if(flags & RLY) {
			pSession->fReceiveSmall=FALSE;
		} else {
			pSession->fReceiveSmallDG=FALSE;
		}
	}

	// See if this receive is already ongoing - if found, it is locked.
	pReceive=GetReceive(pProtocol, pSession, pCmdInfo, pBuffer);

	if(pCmdInfo->command==0){
		pSession->LocalBytesReceived+=pBuffer->len;
	}

	if(!(flags & RLY)){
		if(flags & (SAK|EOM)) {
			SendACK(pProtocol, pSession, pCmdInfo);
		}
	}

	if(pReceive){
		if(flags & RLY){
			// unlocks receive when done.
			rc=ReliableAccept(pProtocol, pSession, pReceive, pCmdInfo, pBuffer);
		} else {
			rc=DGAccept(pProtocol, pSession, pReceive, pCmdInfo, pBuffer);
		}
	}


	DecSessionRef(pSession);
	
drop_exit:
	return rc;

	#undef flags
}


BOOL CompleteSend(PSESSION pSession, PSEND pSend, PCMDINFO pCmdInfo)
{
	UINT bit;
	UINT MsgMask;

	pSend->SendState=Done;

	if(pCmdInfo->flags & BIG){
		MsgMask = 0xFFFF;
	} else {
		MsgMask = 0xFF;
	}       

	DPF(9,"CompleteSend, pSession %x pSend %x\n",pSession,pSend);

	//
	// Update Session information for completion of this send.
	//
	
	bit = ((pCmdInfo->messageid-pSession->FirstMsg) & MsgMask)-1;

	// clear the message mask bit for the completed send.
	if(pSession->OutMsgMask & 1<<bit){
		pSession->OutMsgMask &= ~(1<<bit);
	} else {
		Unlock(&pSession->SessionLock);
		return TRUE;
	}

	// slide the first message count forward for each low
	// bit clear in Message mask.
	while(pSession->LastMsg-pSession->FirstMsg){
		if(!(pSession->OutMsgMask & 1)){
			pSession->FirstMsg=(pSession->FirstMsg+1)&MsgMask;
			pSession->OutMsgMask >>= 1;
			if(pSession->nWaitingForMessageid){
				pSession->pProtocol->m_bRescanQueue=TRUE;
				DPF(9,"Signalling reliable ID Sem, nWaitingForMessageid was %d\n",pSession->nWaitingForMessageid);
				SetEvent(pSession->pProtocol->m_hSendEvent);
			}       
		} else {
			break;
		}
	}
	
	//
	// Return the Send to the pool and complete the waiting client.
	//

	Unlock(&pSession->SessionLock);
	
	ASSERT(pSend->RefCount);

	// Send completed, do completion
	DoSendCompletion(pSend, DP_OK);

	DecSendRef(pSession->pProtocol, pSend); // for completion.

	return TRUE;
}

// called with session lock held
VOID ProcessDGACK(PSESSION pSession, PCMDINFO pCmdInfo)
{
	BILINK *pBilink;
	PSENDSTAT pStatWalker,pStat=NULL;

	Lock(&pSession->SessionStatLock);
	
	pBilink=pSession->DGStatList.next;
	
	while(pBilink != &pSession->DGStatList){
		pStatWalker=CONTAINING_RECORD(pBilink, SENDSTAT, StatList);
		if((pStatWalker->messageid == pCmdInfo->messageid) && 	// correct messageid
		   (pStatWalker->sequence  == pCmdInfo->sequence)       // correct sequence
		   // don't check serial, since datagrams are always serial 0, never retried.
		  )
		{  
			pStat=pStatWalker;
			break;
		}
		pBilink=pBilink->next;
	}


	if(pStat){
	
		UpdateSessionStats(pSession,pStat,pCmdInfo,FALSE);

		// Unlink All Previous SENDSTATS;
		pStat->StatList.next->prev=&pSession->DGStatList;
		pSession->DGStatList.next=pStat->StatList.next;

		// Put the SENDSTATS back in the pool.
		while(pBilink != &pSession->DGStatList){
			pStatWalker=CONTAINING_RECORD(pBilink, SENDSTAT, StatList);
			pBilink=pBilink->prev;
			ReleaseSendStat(pStatWalker);
		}

	}	
	
	Unlock(&pSession->SessionStatLock);

}

// update a send's information for an ACK.
// called with SESSIONion lock held.
// now always drops the sessionlock
BOOL ProcessReliableACK(PSESSION pSession, PCMDINFO pCmdInfo)
{
	PSEND pSend=NULL, pSendWalker;
	BILINK *pBilink;
	UINT nFrame;
	UINT nAdvance;

	Unlock(&pSession->SessionLock);
	Lock(&pSession->pProtocol->m_SendQLock);
	Lock(&pSession->SessionLock);
	
	pBilink=pSession->SendQ.next;
	
	while(pBilink != &pSession->SendQ){
		pSendWalker=CONTAINING_RECORD(pBilink, SEND, SendQ);
		if((pSendWalker->messageid == pCmdInfo->messageid) && 	// correct messageid
		   (!(pSendWalker->dwFlags & ASEND_PROTOCOL)) &&		// not and internal message
		   (pSendWalker->dwFlags & DPSEND_GUARANTEED)){         // guaranteed
			pSend=pSendWalker;
			break;
		}
		pBilink=pBilink->next;
	}

	// need a reference to avoid processing a send as 
	// it is being recycled for another send.
	if(pSend){
		if(!AddSendRef(pSend,1)){
			pSend=NULL;
		}
	}

	Unlock(&pSession->pProtocol->m_SendQLock);
	// SessionLock still held.

	if(pSend){

		Lock(&pSend->SendLock);

		UpdateSessionSendStats(pSession,pSend,pCmdInfo,FALSE);

		// we need to make sure this send isn't already finished.
		switch(pSend->SendState){
		
			case    Sending:
			case 	Throttled:
			case	WaitingForAck:
			case	WaitingForId:
			case 	ReadyToSend:
				break;

			case Start:		// shouldn't be getting an ACK for a send in the start state.
			case TimedOut:
			case Cancelled:
			case UserTimeOut:
			case Done:
				// this send is already done, don't do processing on it.
				DPF(4,"PRACK:Not processing ACK on send in State (B#22359 avoided)%x\n",pSend->SendState);
				Unlock(&pSend->SendLock);
				Unlock(&pSession->SessionLock);
				DecSendRef(pSession->pProtocol,pSend); // balances AddSendRef in this fn
				return TRUE; // SessionLock dropped
				break;
				
			default:
				break;
		}

		pSend->fUpdate=TRUE;

		nFrame=(pCmdInfo->sequence-pSend->NR)&pSend->SendSEQMSK;
		
		if(nFrame > (pSend->NS - pSend->NR)){
			// Out of range.
			DPF(9,"ReliableACK:Got out of range ACK, SQMSK=%x NS=%d NR=%d ACK=%d\n",pSend->SendSEQMSK,pSend->NS&pSend->SendSEQMSK, pSend->NR&pSend->SendSEQMSK, (pSend->NR+nFrame)&pSend->SendSEQMSK);
			Unlock(&pSend->SendLock);
			Unlock(&pSession->SessionLock);
			DecSendRef(pSession->pProtocol,pSend);
			return TRUE; // SessionLock dropped
		}

		CancelRetryTimer(pSend);

		DPF(9,"ProcessReliableACK (before): pSend->NR %x pSend->OpenWindow %x, pSend->NACKMask %x\n",pSend->NR, pSend->OpenWindow, pSend->NACKMask);

		pSend->NR=(pSend->NR+nFrame);
		pSend->OpenWindow -= nFrame;
		pSend->NACKMask >>= nFrame;
		ASSERT_NACKMask(pSend);
		AdvanceSend(pSend,pSend->FrameDataLen*nFrame); // can put us past on the last frame, but that's ok.

		DPF(9,"ProcessReliableACK: Send->nFrames %2x NR %2x NS %2x nFrame %2x NACKMask %x\n",pSend->nFrames,pSend->NR, pSend->NS, nFrame, pSend->NACKMask);

		if(pSend->NR==pSend->nFrames){
			// LAST ACK, we're done!
			pSend->SendState=Done;
			Unlock(&pSend->SendLock);
			// SessionLock still held
			CompleteSend(pSession, pSend, pCmdInfo);// drops SessionLock
			DecSendRef(pSession->pProtocol,pSend);
			return TRUE;
		} else {
			// set new "NACK bits" for extra window opening
			if(pSend->NR+pSend->OpenWindow+nFrame > pSend->nFrames){
				nAdvance=pSend->nFrames-(pSend->NR+pSend->OpenWindow);
				DPF(9,"A nAdvance %d\n",nAdvance);
			} else {
				nAdvance=nFrame;
				DPF(9,"B nAdvance %d\n",nAdvance);
			}
			pSend->NACKMask |= ((1<<nAdvance)-1)<<pSend->OpenWindow;
			pSend->OpenWindow += nAdvance;
			DPF(9,"pSend->NACKMask=%x\n",pSend->NACKMask);
			ASSERT_NACKMask(pSend);
		}

		switch(pSend->SendState){

			case Start:
				DPF(1,"ERROR, ACK ON UNSTARTED SEND!\n");
				ASSERT(0);
				break;

			case Done:
				DPF(1,"ERROR, ACK ON DONE SEND!\n");
				ASSERT(0);
				break;
				
			case WaitingForAck:
				pSend->SendState=ReadyToSend;
				SetEvent(pSession->pProtocol->m_hSendEvent);
				break;

			case ReadyToSend:
			case Sending:
			case Throttled:
			default:
				break;
		}

		Unlock(&pSend->SendLock);
	} else {        
		DPF(9,"ProcessReliableACK: dup ACK ignoring\n");
	}
	Unlock(&pSession->SessionLock);
	
	if(pSend){
		DecSendRef(pSession->pProtocol, pSend);
	}	
	return TRUE; // SessionLock dropped
}

//called with session lock held, always drops lock.
BOOL ProcessReliableNACK(PSESSION pSession, PCMDINFO pCmdInfo,PUCHAR pNACKmask, UINT nNACK)
{
	UINT NACKmask=0;
	UINT NACKshift=0;

	PSEND pSend=NULL, pSendWalker;
	BILINK *pBilink;
	UINT nFrame;
	UINT nAdvance;
	UINT nAdvanceShift;

	DWORD nDropped=0;

	DPF(9,"==>ProcessReliableNACK\n");

	Unlock(&pSession->SessionLock);
	Lock(&pSession->pProtocol->m_SendQLock);
	Lock(&pSession->SessionLock);

	pBilink=pSession->SendQ.next;
	
	while(pBilink != &pSession->SendQ){
		pSendWalker=CONTAINING_RECORD(pBilink, SEND, SendQ);
		if(pSendWalker->dwFlags & DPSEND_GUARANTEE && 
		   pSendWalker->messageid == pCmdInfo->messageid){
			pSend=pSendWalker;
			break;
		}
		pBilink=pBilink->next;
	}

	// need a reference to avoid processing a send as 
	// it is being recycled for another send.
	if(pSend){
		if(!AddSendRef(pSend,1)){
			pSend=NULL;
		}
	}	
	
	Unlock(&pSession->pProtocol->m_SendQLock);
	// SessionLock still held.

	if(pSend){

		Lock(&pSend->SendLock);

		UpdateSessionSendStats(pSession,pSend,pCmdInfo,FALSE);

		// we need to make sure this send isn't already finished.
		switch(pSend->SendState){
		
			case    Sending:
			case 	Throttled:
			case	WaitingForAck:
			case	WaitingForId:
			case 	ReadyToSend:
				break;

			case Start:		// shouldn't be getting an ACK for a send in the start state.
			case TimedOut:
			case Cancelled:
			case UserTimeOut:
			case Done:
				// this send is already done, don't do processing on it.
				DPF(4,"PRNACK:Not processing NACK on send in State (B#22359 avoided)%x\n",pSend->SendState);
				Unlock(&pSend->SendLock);
				Unlock(&pSession->SessionLock);
				DecSendRef(pSession->pProtocol,pSend); // balances AddSendRef in this fn
				return TRUE; // SessionLock dropped
				break;
				
			default:
				break;
		}

		DPF(9,"Reliable NACK for Send %x, pCmdInfo %x\n",pSend, pCmdInfo);
		
		pSend->fUpdate=TRUE;
		// Do regular NR updates (OPTIMIZATION: fold with process reliable ACK)
		nFrame=(pCmdInfo->sequence-pSend->NR) & pSend->SendSEQMSK;
		
		if(nFrame > (pSend->NS - pSend->NR)){
			// Out of range.
			DPF(9,"ReliableNACK:Got out of range NACK, SQMSK=%x NS=%d NR=%d ACK=%d\n",pSend->SendSEQMSK,pSend->NS&pSend->SendSEQMSK, pSend->NR&pSend->SendSEQMSK, (pSend->NR+nFrame)&pSend->SendSEQMSK);
			Unlock(&pSend->SendLock);
			Unlock(&pSession->SessionLock);
			DecSendRef(pSession->pProtocol,pSend);
			return TRUE;
		}

		CancelRetryTimer(pSend);

		DPF(9,"NACK0: pSend->NACKMask %x, OpenWindow %d\n",pSend->NACKMask, pSend->OpenWindow);

		pSend->NR=(pSend->NR+nFrame);
		pSend->OpenWindow -= nFrame;
		pSend->NACKMask >>= nFrame;
		ASSERT_NACKMask(pSend);
		AdvanceSend(pSend,pSend->FrameDataLen*nFrame);

		DPF(9,"ProcessReliableNACK: Send->nFrames %2x NR %2x NS %2x nFrame %2x NACKMask %x\n",pSend->nFrames,pSend->NR, pSend->NS, nFrame, pSend->NACKMask);

		ASSERT(pSend->NR != pSend->nFrames);
		// set new "NACK bits" for extra window opening
		if(pSend->NR+pSend->OpenWindow+nFrame > pSend->nFrames){
			nAdvance=pSend->nFrames-(pSend->NR+pSend->OpenWindow);
			DPF(9, "NACK: 1 nAdvance %d\n",nAdvance);
		} else {
			nAdvance=nFrame;
			DPF(9, "NACK: 2 nAdvance %d\n",nAdvance);
		}
		pSend->NACKMask |= ((1<<nAdvance)-1)<<pSend->OpenWindow;

		DPF(9, "NACK Mask %x\n",pSend->NACKMask);
		pSend->OpenWindow += nAdvance;
		ASSERT_NACKMask(pSend);


		while(nNACK--){
			NACKmask |= (*(pNACKmask++))<<NACKshift;
			NACKshift+=8;
		}

		DPF(9,"NACKmask in NACK %x\n",NACKmask);

		// set the NACK mask.
		nAdvanceShift=0;
		while(NACKmask){
			if(NACKmask&1){
				// set bits are ACKs.
				pSend->NACKMask&=~(1<<nAdvanceShift);
			} else {
				// clear bits are NACKs.
				pSend->NACKMask|=1<<nAdvanceShift;
				nDropped++;
			}
			NACKmask >>= 1;
			nAdvanceShift++;
		}
		DPF(9,"ProcessReliableNACK: pSend->NACKMask=%x\n",pSend->NACKMask);
		ASSERT_NACKMask(pSend);

		UpdateSessionSendStats(pSession,pSend,pCmdInfo, ((nDropped > 1) ? TRUE:FALSE) );
	
		switch(pSend->SendState){

			case Start:
				DPF(5,"ERROR, NACK ON UNSTARTED SEND!\n");
				ASSERT(0);
				break;

			case Done:
				DPF(5,"ERROR, NACK ON DONE SEND!\n");
				ASSERT(0);
				break;
				
			case WaitingForAck:
				pSend->SendState=ReadyToSend;
				SetEvent(pSession->pProtocol->m_hSendEvent);
				break;

			case ReadyToSend:
			case Sending:
			case Throttled:
			default:
				break;
		}
		Unlock(&pSend->SendLock);
	} else {
		// OPTIMIZATION: reliable NACK for send we aren't doing? Ignore or send abort?
		DPF(0,"Reliable NACK for send we aren't doing? Ignore?\n");
	}

	Unlock(&pSession->SessionLock);
	
	if(pSend){
		DecSendRef(pSession->pProtocol,pSend);
	}
	return TRUE;
	
	#undef pBigNACK
}

VOID ProcessACK(PPROTOCOL pProtocol, PCMDINFO pCmdInfo)
{
	PSESSION      pSession;
	UINT          rc=0;             // by default, buffer not accepted.
	BOOL          fUnlockedSession=FALSE;

	// Find the Send for this ACK.

	DPF(9,"ProcessACK\n");

	pSession=GetSysSessionByIndex(pProtocol,pCmdInfo->wIdFrom);

	if(!pSession) {
		goto exit;
	}
	
	Lock(&pSession->SessionLock);

	// Find the message with the id, make sure its the same type of send.
	if(pCmdInfo->flags & RLY){
		if(pCmdInfo->flags & BIG){
			//NOTE: if messageid, FirstMsg and LastMsg are SHORT, no masking req'd
			if((pCmdInfo->messageid==pSession->FirstMsg)||((pCmdInfo->messageid-pSession->FirstMsg)&0xFFFF) > ((pSession->LastMsg-pSession->FirstMsg)&0xFFFF)){
				DPF(9,"Ignoring out of range ACK\n");
				goto exit1;
			}
		} else {
			if((pCmdInfo->messageid==pSession->FirstMsg)||((pCmdInfo->messageid-pSession->FirstMsg)&0xFF) > ((pSession->LastMsg-pSession->FirstMsg)&0xFF)){
				// out of range, ignore
				DPF(9,"Ignoring out of range ACK\n");
				goto exit1;
			} 
		}
		ProcessReliableACK(pSession,pCmdInfo); //now always unlocks session.
		fUnlockedSession=TRUE;
	} else {
		ProcessDGACK(pSession,pCmdInfo);
	}

exit1:  
	if(!fUnlockedSession){  
		Unlock(&pSession->SessionLock);
	}
	
	DecSessionRef(pSession);

exit:
	return;

	#undef pBigACK
}

VOID ProcessNACK(PPROTOCOL pProtocol, PCMDINFO pCmdInfo, PUCHAR pNACKmask, UINT nNACK)
{
	#define pBigNACK ((pNACK2)pNACK)

	PSESSION      pSession;

	pSession=GetSysSessionByIndex(pProtocol, pCmdInfo->wIdFrom);

	if(!pSession) {
		ASSERT(0);
		goto exit;
	}

	Lock(&pSession->SessionLock);

	if(pCmdInfo->flags & RLY){
		ProcessReliableNACK(pSession,pCmdInfo,pNACKmask, nNACK); // drops SessionLock
	} else {
		Unlock(&pSession->SessionLock);
		DPF(0,"FATAL: non-reliable NACK???\n");
		ASSERT(0);
	}

	DecSessionRef(pSession);
	
exit:
	return;
}


UINT AssertMe(REQUEST_PARAMS)
{
	DEBUG_BREAK();
	return TRUE;
}

UINT Ping(REQUEST_PARAMS){return TRUE;}
UINT PingResp(REQUEST_PARAMS){return TRUE;}
UINT GetTime(REQUEST_PARAMS){return TRUE;}
UINT GetTimeResp(REQUEST_PARAMS){return TRUE;}
UINT SetTime(REQUEST_PARAMS){return TRUE;}
UINT SetTimeResp(REQUEST_PARAMS){return TRUE;}

VOID ProcessAbort(PPROTOCOL pProtocol, DPID idFrom, DPID idTo, pABT1 pABT, BOOL fBig){}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\serial\bilink.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    BILINK.H

Abstract:

    Management for doubly linked lists

Author:

    George Joy

Environment:

    32-bit 'C'

Revision History:

--*/// BILINK.H

#ifndef _BILINK_

#define _BILINK_

#if !defined(offsetof)
	#define offsetof(type, field) ((int)(&((type *)0)->field))
#endif	

typedef struct BILINK {
    struct BILINK *next;
    struct BILINK *prev;
} BILINK;

/* XLATOFF */

#define EMPTY_BILINK(_pBilink) ((_pBilink)->next==(_pBilink))

#ifdef DEBUG
    #define ASSERT_EMPTY_BILINK(_b) ASSERT((_b)->next==(_b))
#else
    #define ASSERT_EMPTY_BILINK(_b)
#endif

// This only works for BILINKS that are the first item in a structure.
#define BilinkToList( _pBilink ) \
	(_pBilink)->prev->next=NULL;

#define InitBilink( _pBilink ) \
    (_pBilink)->prev=(_pBilink)->next=(_pBilink);

#ifdef DEBUG

int FindObject(
    BILINK *link,
    BILINK *list
    );
#endif

void InsertAfter(
    BILINK *in,
    BILINK *after
    );

void InsertBefore(
     BILINK *in,
     BILINK *before
    );

void Delete(
     BILINK *p
);

/* XLATON */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\protocol\send.c ===
/*++

Copyright (c) 1996,1997  Microsoft Corporation

Module Name:

    SEND.C

Abstract:

	Send Handler and Send Thread.

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
  12/10/96 aarono  Original
   2/18/98 aarono  added support for SendEx
   2/18/98 aarono  added support for Cancel
   2/20/98 aarono  B#18827 not pulling Cancelled sends off queue
   3/09/98 aarono  documented workaround for mmTimers on Win95, removed dead code.
   3/29/98 aarono  fixed locking for ReliableSend
   3/30/98 aarono  make sure erroring sends moved to Done state to avoid reprocess.
   4/14/98 a-peterz B#18340 DPSEND_NOCOPY subsumes DPSEND_NOBUFFERCOPY
   5/18/98 aarono  fixed SendEx with scatter gather
   6/6/98  aarono  Turn on throttling and windowing
   10/8/99 aarono  Improve shutdown handling, avoid 1min hang with pending sends.
   2/12/00 aarono  Concurrency issues, fix VOL usage and Refcount

--*/

#include <windows.h>
#include "newdpf.h"
#include <mmsystem.h>
#include <dplay.h>
#include <dplaysp.h>
#include <dplaypr.h>
#include "mydebug.h"
#include "arpd.h"
#include "arpdint.h"
#include "macros.h"
#include "mytimer.h"

#ifdef DEBUG
VOID DQProtocolSend(PSEND pS)
{
	DPF(0,"===SEND====pSend %x=====",pS);

#ifdef SIGN
	DPF(0,"Signature           : %08x", pS->Signature);
#endif
//	CRITICAL_SECTION SendLock;          // Lock for Send Structure
	DPF(0,"RefCount            : %d", pS->RefCount);

	DPF(0,"SendState:          %08x", pS->SendState);	// State of this message's transmission.

	// Lists and Links...
	
//	union {
//		struct _SEND *pNext;			// linking on free pool
//		BILINK		   SendQ;			// linking on session send queue
//	};
//	BILINK         m_GSendQ;			// Global Priority Queue
	DPF(0,"pSession:     %08x",pS->pSession); // pointer to SESSIONion(gets a ref)

	// Send Information
	
	DPF(0,"idFrom:       %08x",pS->idFrom);
	DPF(0,"idTo:         %08x",pS->idTo);
	DPF(0,"wIdTo:        %08x",pS->wIdTo);		// index in table
	DPF(0,"wIdFrom:      %08x",pS->wIdFrom);       // index in table
	DPF(0,"dwFlags:      %08x",pS->dwFlags);       // Send Flags (include reliable)
	DPF(0,"pMessage:     %08x",pS->pMessage);	// Buffer chain describing message.
	DPF(0,"MessageSize:  %08x",pS->MessageSize);		// Total size of the message.
	DPF(0,"FrameDataLen: %08x",pS->FrameDataLen);       // Data area of each frame.
	DPF(0,"nFrames:      %08x",pS->nFrames);	    // Number of frames for this message.

	DPF(0,"Priority:     %08x",pS->Priority);       // Send Priority.

	// Vars for reliability
	DPF(0,"fSendSmall:   %08x",pS->fSendSmall);
	DPF(0,"fUpdate:      %08x",pS->fUpdate);       // update to NS,NR NACKMask made by receive.
	DPF(0,"messageid:    %08x",pS->messageid);		// Message ID number.
	DPF(0,"serial:       %08x",pS->serial);       // serial number.
	DPF(0,"OpenWindows   %08x",pS->OpenWindow);
	DPF(0,"NS:           %08x",pS->NS);    	// Sequence Sent.
	DPF(0,"NR:           %08x",pS->NR);		// Sequence ACKED.
	DPF(0,"SendSEQMSK:   %08x",pS->SendSEQMSK);		// Mask to use.
	DPF(0,"NACKMask:     %08x",pS->NACKMask);       // Bit pattern of NACKed frames.
	

	// These are the values at NR - updated by ACKs
	DPF(0,"SendOffset:          %08x",pS->SendOffset);		// Current offset we are sending.
	DPF(0,"pCurrentBuffer:      %08x",pS->pCurrentBuffer);  	// Current buffer being sent.
	DPF(0,"CurrentBufferOffset: %08x",pS->CurrentBufferOffset);// Offset in the current buffer of next packet.

	// info to update link characteristics when ACKs come in.
	
	//BILINK         StatList:			// Info for packets already sent.
	
	// Operational Characteristics

//	DPF(0,"PendedRetryTimer:    %08x\n",pS->PendedRetryTimer);
//	DPF(0,"CancelledRetryTimer: %08x\n",pS->CancelledRetryTimer);
	DPF(0,"uRetryTimer:         %08x",pS->uRetryTimer);
	DPF(0,"RetryCount:          %08x",pS->RetryCount);// Number of times we retransmitted.
	DPF(0,"WindowSize:          %08x",pS->WindowSize);// Maximum Window Size.
	DPF(0,"tLastACK:            %08x",pS->tLastACK);// Time we last got an ACK.

	DPF(0,"PacketSize:          %08x",pS->PacketSize);// Size of packets to send.
	DPF(0,"FrameSize:           %08x",pS->FrameSize);// Size of Frames for this send.

	// Completion Vars
	DPF(0,"hEvent:              %08x",pS->hEvent);// Event to wait on for internal send.
	DPF(0,"Status:              %08x",pS->Status);// Send Completion Status.

	DPF(0,"pAsyncInfo:          %08x",pS->pAsyncInfo);// ptr to Info for completing Async send(NULL=>internal send)
//	DPF(0,"AsyncInfo:           // actual info (copied at send call).
	
} 


VOID DQProtocolSession(PSESSION pS)
{
	DPF(0,"pProtocol           : %08x", pS->pProtocol);

#ifdef SIGN
	DPF(0,"Signature           : %08x", pS->Signature);
#endif

	// Identification

//	DPF(0," SessionLock;           // Lock for the SESSIONion.
	DPF(0,"RefCount            : %d", pS->RefCount);
	DPF(0,"eState              : %d", pS->eState);
	DPF(0,"hClosingEvent       : %d", pS->hClosingEvent);

	DPF(0,"fSendSmall          : %d", pS->fSendSmall);     
	DPF(0,"fSendSmallDG        : %d", pS->fSendSmallDG);
	
	DPF(0,"dpid                : %08x",pS->dpid);
	DPF(0,"iSession;           : %d", pS->iSession);
	
	DPF(0,"MaxPacketSize       : x%08x %d",pS->MaxPacketSize,pS->MaxPacketSize);

	DPF(0,"\n Operating Parameters:SEND \n --------- --------------- \n");

	// Operating parameters -- Send

	// Common

	DPF(0,"Common:\n");
	DPF(0,"MaxCSends           : %d",pS->MaxCSends);

	DPF(0,"Reliable:\n");
	// Reliable

	DPF(0,"FirstMsg    : %08x",pS->FirstMsg);				// First message number being transmitted
	DPF(0,"LastMsg     : %08x",pS->LastMsg);				// Last message number being transmitted
	DPF(0,"OutMsgMask  : %08x",pS->OutMsgMask);           // relative to FirstMsg, unacked messages

	DPF(0,"nWaitingForMessageid: %08x", pS->nWaitingForMessageid);

	// DataGram
	DPF(0,"Datagram:\n");

	DPF(0,"DGFirstMsg    : %08x",pS->DGFirstMsg);
	DPF(0,"DGLastMsg     : %08x",pS->DGLastMsg);
	DPF(0,"DGOutMsgMask  : %08x",pS->DGOutMsgMask);

	DPF(0,"nWaitingForDGMessageid: %08x",pS->nWaitingForDGMessageid);

	// Send stats are tracked seperately since sends may
	// no longer be around when completions come in.
	
	//BILINK           OldStatList;		
	

	// Operating parameters -- Receive
	DPF(0,"\n Operating Parameters:RECEIVE \n --------- ------------------ \n");

	// DataGram Receive.
//	BILINK           pDGReceiveQ;            // queue of ongoing datagram receives

	// Reliable Receive.
//	BILINK	         pRlyReceiveQ;			 // queue of ongoing reliable receives
//	BILINK           pRlyWaitingQ;           // Queue of out of order reliable receives waiting.
											 // only used when PROTOCOL_NO_ORDER not set.
	DPF(0,"FirstRlyReceive : %08x",pS->FirstRlyReceive);
	DPF(0,"LastRlyReceive  : %08x",pS->LastRlyReceive);
	DPF(0,"InMsgMask       : %08x",pS->InMsgMask);

	DPF(0,"\n Operating Parameters:STATS \n --------- ---------------- \n");
 

	// Operational characteristics - MUST BE DWORD ALIGNED!!!

	DPF(0,"WindowSize           :%d",pS->WindowSize);
	DPF(0,"DGWindowSize         :%d",pS->DGWindowSize);

	
	DPF(0,"MaxRetry             :%d",pS->MaxRetry);	// Usualy max retries before dropping.
	DPF(0,"MinDropTime          :%d",pS->MinDropTime);	// Min time to retry before dropping.
	DPF(0,"MaxDropTime          :%d",pS->MaxDropTime);	// After this time always drop.

	DPF(0,"LocalBytesReceived   :%d",pS->LocalBytesReceived);    // Total Data Bytes received (including retries).
	DPF(0,"RemoteBytesReceived  :%d",pS->RemoteBytesReceived);   // Last value from remote.

	DPF(0,"LongestLatency       :%d",pS->LongestLatency);		// longest observed latency (msec)
	DPF(0,"ShortestLatency      :%d",pS->ShortestLatency);		// shortest observed latency(msec)
	
	DPF(0,"FpAverageLatency     :%d",pS->FpAverageLatency/256);
	DPF(0,"FpLocalAverageLatency:%d",pS->FpLocalAverageLatency/256);	// Local average latency    (msec 24.8) (across fewer samples)
	
	DPF(0,"FpLocalAvgDeviation  :%d",pS->FpLocalAvgDeviation/256);   // average deviation of latency. (msec 24.8)

	DPF(0,"Bandwidth            :%d",pS->Bandwidth);				// latest observed bandwidth (bps)
	DPF(0,"HighestBandwidth     :%d",pS->HighestBandwidth);    // highest observed bandwidth (bps)

}

VOID DumpSession(SESSION *pSession)
{
	BILINK *pBilink;
	PSEND pSend;
	DWORD dwMaxDump=99;
	DQProtocolSession(pSession);

	pBilink=pSession->SendQ.next;

	while(pBilink != &pSession->SendQ)
	{
		pSend=CONTAINING_RECORD(pBilink, SEND, SendQ);
		DQProtocolSend(pSend);
		if((dwMaxDump--)==0) break; // only dump 99 sends
		pBilink=pBilink->next;
	}
}


#endif

BOOL DGCompleteSend(PSEND pSend);

// a-josbor: for debuggin purposes only
extern DWORD ExtractProtocolIds(PUCHAR pInBuffer, PUINT pdwIdFrom, PUINT pdwIdTo);

INT AddSendRef(PSEND pSend, UINT count)
{
	INT newcount;

	ASSERT(count > 0);
	
	Lock(&pSend->SendLock);
	Lock(&g_SendTimeoutListLock);
	if(pSend->bCleaningUp){
		DPF(1,"WARNING: ADDSENDREF tried to add reference to cleaning up send %x\n",pSend);
		newcount=0;
		goto exit;
	}
	if(!pSend->RefCount){
		// Anyone calling addsend ref requires a reference on the session
		Unlock(&g_SendTimeoutListLock);
		Unlock(&pSend->SendLock);
		
		Lock(&pSend->pSession->pProtocol->m_SessionLock);
		Lock(&pSend->pSession->SessionLock);
		Lock(&pSend->SendLock);
		Lock(&g_SendTimeoutListLock);
		InterlockedIncrement((PLONG)&pSend->pSession->RefCount);
		Unlock(&pSend->pSession->SessionLock);
		Unlock(&pSend->pSession->pProtocol->m_SessionLock);
		
	} else {
		newcount=pSend->RefCount;
	}
	
	while(count--){
		newcount=InterlockedIncrement(&pSend->RefCount);
	}
	
exit:	
	Unlock(&g_SendTimeoutListLock);
	Unlock(&pSend->SendLock);
	return newcount;
}

#ifdef DEBUG
// Turn off global optimizations when building DEBUG version since the
// compiler over-writes the return address in this code.  NTB#347427
// Should be fixed in compiler post Win2K.
#if _MSC_VER < 0x1100
#pragma optimize("g", off)
#endif
#endif

// Critical Section must not be held when this is called, unless there
// is a reference for holding the critical section (ie. will not hit 0).
INT DecSendRef(PPROTOCOL pProtocol, PSEND pSend)
{
	INT      count;
	PSESSION pSession;
	
	Lock(&pSend->SendLock);
	
	count=InterlockedDecrement((PLONG)&pSend->RefCount);//count is zero if result of dec is zero, otw nonzero but not actual count.

	if(!count){
		pSession=pSend->pSession;
		pSend->bCleaningUp=TRUE;
		
		Unlock(&pSend->SendLock);
		// pull the Send off of the global queue and the session queue
		Lock(&pProtocol->m_SendQLock);
		Lock(&pSession->SessionLock);
		Lock(&pSend->SendLock);
		Lock(&g_SendTimeoutListLock);
		
		if(!pSend->RefCount){
			Delete(&pSend->TimeoutList);
			Delete(&pSend->m_GSendQ);
			Delete(&pSend->SendQ);
		} else {
			count=pSend->RefCount;
		}

		Unlock(&g_SendTimeoutListLock);
		Unlock(&pSend->SendLock);
		Unlock(&pSession->SessionLock);
		Unlock(&pProtocol->m_SendQLock);
		
		if(!count){
			DecSessionRef(pSession);

			DPF(8,"DecSendRef: pSession %x pSend %x Freeing Send, called from %x\n",pSession, pSend, _ReturnAddress());

			FreeHandleTableEntry(&pProtocol->lpHandleTable,&pProtocol->csHandleTable,pSend->dwMsgID);
			// Free the message buffer(s) (including memory if WE allocated it).
			FreeBufferChainAndMemory(pSend->pMessage);
			// OPTIMIZATION:move any Stats we want to keep to the session.
			// free the send.(handles the stats for now).
			ReleaseSendDesc(pSend);
		}       
	} else {
		DPF(8,"DecSendRef: pSession %x pSend %x count %d, called from %x\n",pSend->pSession, pSend, count,_ReturnAddress());
		if(count&0x80000000){
			DEBUG_BREAK();
		}
		Unlock(&pSend->SendLock);
	}
	return count;
}

#ifdef DEBUG
#if _MSC_VER < 1100
#pragma optimize("", on)
#endif 
#endif

// SFLAGS_DOUBLEBUFFER - if the send is ASYNCHRONOUS, make a copy of the data
/*=============================================================================

    Send - Send a message to a client.
    
    Description:

	    Used by the client to send a message to another directplay client
	    or server.  

    Parameters:     

		ARPDID  idFrom        - who is sending this message
		ARPDID  idTo          - target
		DWORD   dwSendFlags   - specifies buffer ownership, priority, reliable
		LPVOID  pBuffers      - Array of buffer and lengths
		DWORD   dwBufferCount - number of entries in array
		PASYNCINFO pAsyncInfo - If specified, call is asynchronous

		typedef struct _ASYNCSENDINFO {
			UINT            Private[4];
			HANDLE          hEvent;
			PSEND_CALLBACK  SendCallBack;
			PVOID           CallBackContext;
			UINT            Status;
		} ASYNCSENDINFO, *PASYNCSENDINFO;

		hEvent              - event to signal when send completes.
		SendCallBack    - routine to call when send completes.
		CallBackContext - context passed to SendCallBack.
		Status          - send completion status.

    Return Values:

		DP_OK - no problem
		DPERR_INVALIDPARAMS


-----------------------------------------------------------------------------*/
HRESULT Send(
	PPROTOCOL      pProtocol,
	DPID           idFrom, 
	DPID           idTo, 
	DWORD          dwSendFlags, 
	LPVOID         pBuffers,
	DWORD          dwBufferCount, 
	DWORD          dwSendPri,
	DWORD          dwTimeOut,
	LPVOID         lpvUserMsgID,
	LPDWORD        lpdwMsgID,
	BOOL           bSendEx,
	PASYNCSENDINFO pAsyncInfo
)
{
	HRESULT hr=DP_OK;

	PSESSION    pSession;
	PBUFFER     pSendBufferChain;
	PSEND       pSend;

	pSession=GetSysSession(pProtocol,idTo);

	if(!pSession) {
		DPF(4,"NO SESSION for idTo %x, returning SESSIONLOST\n",idTo);
		hr=DPERR_CONNECTIONLOST;
		goto exit2;
	}

	pSend=GetSendDesc();
	
	if(!pSend){
		ASSERT(0); //TRACE all paths.
		hr=DPERR_OUTOFMEMORY;
		goto exit;
	}

	pSend->pProtocol=pProtocol;

	// fails by returning 0 in which case cancel won't be available for this send.
	pSend->dwMsgID=AllocHandleTableEntry(&pProtocol->lpHandleTable, &pProtocol->csHandleTable, pSend);

	if(lpdwMsgID){
		*lpdwMsgID=pSend->dwMsgID;
	}

	pSend->lpvUserMsgID = lpvUserMsgID;
	pSend->bSendEx = bSendEx;

	// if pAsyncInfo is provided, the call is asynchronous.
	// if dwFlags DPSEND_ASYNC is set, the call is async.
	// if the call is asynchronous and double buffering is
	// required, we must make a copy of the data.

	if((pAsyncInfo||(dwSendFlags & DPSEND_ASYNC)) && (!(dwSendFlags & DPSEND_NOCOPY))){
		// Need to copy the memory
		pSendBufferChain=GetDoubleBufferAndCopy((PMEMDESC)pBuffers,dwBufferCount);
		// OPTIMIZATION: if the provider requires contiguous buffers, we should
		//         break this down into packet allocations, and chain them
		//         on the send immediately.  Using the packet chain to indicate
		//         to ISend routine that the message is already broken down.
	} else {
		// Build a send buffer chain for the described buffers.
		pSendBufferChain=BuildBufferChain((PMEMDESC)pBuffers,dwBufferCount);            
	}
	
	if(!pSendBufferChain){
		ASSERT(0); //TRACE all paths.
		return DPERR_OUTOFMEMORY;
	}
	
	pSend->pSession            = pSession;     //!!! when this is dropped, deref the connection
	
	pSend->pMessage            = pSendBufferChain;
	pSend->MessageSize         = BufferChainTotalSize(pSendBufferChain);
	pSend->SendOffset          = 0;
	pSend->pCurrentBuffer      = pSend->pMessage;
	pSend->CurrentBufferOffset = 0;
	
	pSend->Priority            = dwSendPri;
	pSend->dwFlags             = dwSendFlags;
	
	if(pAsyncInfo){
		pSend->pAsyncInfo       = &pSend->AsyncInfo;
		pSend->AsyncInfo        = *pAsyncInfo; //copy Async info from client.
	} else {
		pSend->pAsyncInfo               = NULL;
		if(pSend->dwFlags & DPSEND_ASYNC){
			pSend->AsyncInfo.hEvent         = 0;
			pSend->AsyncInfo.SendCallBack   = InternalSendComplete;
			pSend->AsyncInfo.CallBackContext= pSend;
			pSend->AsyncInfo.pStatus        = &pSend->Status;
		}       
	}

	pSend->SendState            = Start;
	pSend->RetryCount           = 0;
	pSend->PacketSize           = pSession->MaxPacketSize;

	pSend->fUpdate              = FALSE;
	pSend->NR                   = 0;
	pSend->NS                   = 0;
	//pSend->SendSEQMSK			= // filled in on the fly.
	pSend->WindowSize           = pSession->WindowSize;
	pSend->SAKInterval			= (pSend->WindowSize+1)/2;
	pSend->SAKCountDown         = pSend->SAKInterval;

	pSend->uRetryTimer          = 0;
	
	pSend->idFrom               = idFrom;
	pSend->idTo                 = idTo;

	pSend->wIdFrom              = GetIndexByDPID(pProtocol, idFrom);
	pSend->wIdTo                = (WORD)pSession->iSession;
	pSend->RefCount             = 0;                        // if provider does async send counts references.

	pSend->serial               = 0;

	pSend->tLastACK             = timeGetTime();
	pSend->dwSendTime           = pSend->tLastACK;
	pSend->dwTimeOut            = dwTimeOut;

	pSend->BytesThisSend        = 0;

	pSend->messageid            = -1;  // avoid matching this send in ACK/NACK handlers
	pSend->bCleaningUp          = FALSE;

	hr=ISend(pProtocol,pSession, pSend);

exit:
	DecSessionRef(pSession);
	
exit2:
	return hr;

}

/*================================================================================
	Send Completion information matrix:
	===================================

											(pSend->dwFlags & ASEND_PROTOCOL)
							                               |
							Sync            Async   Internal (Async)
							--------------  -----   --------------------
	pSend->pAsyncInfo       0               user    0
	pSend->AI.SendCallback  0               user    InternalSendComplete
	pSend->AI.hEvent        pSend->hEvent   user    0
	pSend->AI.pStatus       &pSend->Status  user    &pSend->Status
	
 ---------------------------------------------------------------------------*/

HRESULT ISend(
	PPROTOCOL pProtocol,
	PSESSION pSession, 
	PSEND    pSend
	)
{
	HRESULT hr=DP_OK;

	DWORD_PTR fAsync;
	BOOL    fCallDirect=FALSE;

	fAsync=(DWORD_PTR)(pSend->pAsyncInfo);

	if(!fAsync && !(pSend->dwFlags & (ASEND_PROTOCOL|DPSEND_ASYNC))) {
		//Synchronous call, and not a protocol generated packet
		pSend->AsyncInfo.SendCallBack=NULL;
		//AsyncInfo.CallbackContext=0; //not required.
		pSend->AsyncInfo.hEvent=pSend->hEvent;
		pSend->AsyncInfo.pStatus=&pSend->Status;
		ResetEvent(pSend->hEvent);
	}

	// don't need to check if ref added here since the send isn't on a list yet.
	AddSendRef(pSend,2); // 1 for ISend, 1 for completion.

	DPF(9,"ISend: ==>Q\n");
	hr=QueueSendOnSession(pProtocol,pSession,pSend);
	DPF(9,"ISend: <==Q\n");

	if(hr==DP_OK){

		if(!fAsync && !(pSend->dwFlags & (ASEND_PROTOCOL|DPSEND_ASYNC))){
			// Synchronous call, and not internal, we need 
			// to wait until the send has completed.
			if(!(pSend->dwFlags & DPSEND_GUARANTEED)){
				// Non-guaranteed, need to drop dplay lock, in 
				// guaranteed case, dplay already dropped it for us.
				LEAVE_DPLAY();
			}
			
			DPF(9,"ISend: Wait==> %x\n",pSend->hEvent);
			Wait(pSend->hEvent);
			
			if(!(pSend->dwFlags & DPSEND_GUARANTEED)){
				ENTER_DPLAY();
			}

			DPF(9,"ISend: <== WAIT\n");
			hr=pSend->Status;
		} else {
			hr=DPERR_PENDING;
		}

	} else {
		DecSendRef(pProtocol, pSend); //not going to complete a send that didn't enqueue.
	}
	
	DecSendRef(pProtocol,pSend);

	return hr;
}


HRESULT QueueSendOnSession(
	PPROTOCOL pProtocol, PSESSION pSession, PSEND pSend
)
{
	BILINK *pBilink;                // walks the links scanning priority    
	BILINK *pPriQLink;      // runs links in the global priority queue.
	PSEND   pSendWalker;    // pointer to send structure
	BOOL    fFront;         // if we put this at the front of the CON SendQ
	BOOL    fSignalQ=TRUE;  // whether to signal the sendQ

	// NOTE: locking global and connection queues concurrently,
	//         -> this better be fast!
	ASSERT_SIGN(pSend, SEND_SIGN);
	
	Lock(&pProtocol->m_SendQLock);
	Lock(&pSession->SessionLock);
	Lock(&pSend->SendLock);

	if(pSession->eState != Open){
		Unlock(&pSend->SendLock);
		Unlock(&pSession->SessionLock);
		Unlock(&pProtocol->m_SendQLock);
		return DPERR_CONNECTIONLOST;
	}

	if(!(pSend->dwFlags & ASEND_PROTOCOL)){
		pProtocol->m_dwBytesPending += pSend->MessageSize;
		pProtocol->m_dwMessagesPending += 1;
	}	

	// Put on Connection SendQ

	// First Check if we are highest priority.
	pBilink = pSession->SendQ.next;
	pSendWalker=CONTAINING_RECORD(pBilink, SEND, SendQ);
	if(pBilink == &pSession->SendQ || pSendWalker->Priority < pSend->Priority)
	{
		InsertAfter(&pSend->SendQ,&pSession->SendQ);
		fFront=TRUE;
		
	} else {

		// Scan backwards through the SendQ until we find a Send with a higher
		// or equal priority and insert ourselves afterwards.  This is optimized
		// for the same pri send case.
	
		pBilink = pSession->SendQ.prev;

		while(TRUE /*pBilink != &pSend->SendQ*/){
		
			pSendWalker = CONTAINING_RECORD(pBilink, SEND, SendQ);
			
			ASSERT_SIGN(pSendWalker, SEND_SIGN);

			if(pSend->Priority <= pSendWalker->Priority){
				InsertAfter(&pSend->SendQ, &pSendWalker->SendQ);
				fFront=FALSE;
				break;
			}
			pBilink=pBilink->prev;
		}
		
		ASSERT(pBilink != &pSend->SendQ);
	}

	//
	// Put on Global SendQ
	//

	if(!fFront){
		// We queued it not at the front, therefore there are already
		// entries in the Global Queue and we need to be inserted 
		// after the entry that we are behind, so start scanning the
		// global queue backwards from the packet ahead of us in the
		// Connection Queue until we find a lower priority packet

		// get pointer into previous packet in queue.
		pBilink=pSend->SendQ.prev;
		// get pointer to the PriorityQ record of the previous packet.
		pPriQLink = &(CONTAINING_RECORD(pBilink, SEND, SendQ))->m_GSendQ;

		while(pPriQLink != &pProtocol->m_GSendQ){
			pSendWalker = CONTAINING_RECORD(pPriQLink, SEND, m_GSendQ);
			
			ASSERT_SIGN(pSendWalker, SEND_SIGN);

			if(pSendWalker->Priority < pSend->Priority){
				InsertBefore(&pSend->m_GSendQ, &pSendWalker->m_GSendQ);
				break;
			}
			pPriQLink=pPriQLink->next;
		}
		if(pPriQLink==&pProtocol->m_GSendQ){
			// put at the end of the list.
			InsertBefore(&pSend->m_GSendQ, &pProtocol->m_GSendQ);
		}
		
	} else {
		// There was no-one in front of us on the connection.  So
		// we look at the head of the global queue first and then scan 
		// from the back.

		pBilink = pProtocol->m_GSendQ.next;
		pSendWalker=CONTAINING_RECORD(pBilink, SEND, m_GSendQ);
		
		if(pBilink == &pProtocol->m_GSendQ ||  pSend->Priority > pSendWalker->Priority)
		{
			InsertAfter(&pSend->m_GSendQ,&pProtocol->m_GSendQ);
		} else {
			// Scan backwards through the m_GSendQ until we find a Send with a higher
			// or equal priority and insert ourselves afterwards.  This is optimized
			// for the same pri send case.
			
			pBilink = pProtocol->m_GSendQ.prev;

			while(TRUE){
				pSendWalker = CONTAINING_RECORD(pBilink, SEND, m_GSendQ);
				
				ASSERT_SIGN(pSendWalker, SEND_SIGN);
				
				if(pSend->Priority <= pSendWalker->Priority){
					InsertAfter(&pSend->m_GSendQ, &pSendWalker->m_GSendQ);
					break;
				}
				pBilink=pBilink->prev;
			}
			
			ASSERT(pBilink != &pProtocol->m_GSendQ);
		}
		
	}

	// Fixup send state if we are blocking other sends on the session.

	if(pSend->dwFlags & DPSEND_GUARANTEED){
		if(pSession->nWaitingForMessageid){
			DPF(8,"pSession %x, pSend %x Waiting For Id\n",pSession,pSend);
			pSend->SendState=WaitingForId;
			InterlockedIncrement(&pSession->nWaitingForMessageid);
			#ifdef DEBUG
				if(pSession->nWaitingForMessageid > 300)
				{
					DPF(0,"Session %x nWaitingForMessageid is %d, looks like trouble, continue to dump session\n",pSession, pSession->nWaitingForMessageid);
					//DEBUG_BREAK();
					//DumpSession(pSession);
					//DEBUG_BREAK();
				}		
			#endif
			fSignalQ=FALSE;
		}
	} else {
		if(pSession->nWaitingForDGMessageid){
			DPF(8,"pSession %x, pSend %x Waiting For Id\n",pSession,pSend);
			pSend->SendState=WaitingForId;
			InterlockedIncrement(&pSession->nWaitingForDGMessageid);
			fSignalQ=FALSE;
		}       
	}


#ifdef DEBUG
	DPF(9,"SessionQ:");
	pBilink=pSession->SendQ.next;
	while(pBilink!=&pSession->SendQ){
		pSendWalker=CONTAINING_RECORD(pBilink, SEND, SendQ);
		ASSERT_SIGN(pSendWalker,SEND_SIGN);
		DPF(9,"Send %x pSession %x Pri %x State %d\n",pSendWalker,pSendWalker->pSession,pSendWalker->Priority,pSendWalker->SendState);
		pBilink=pBilink->next;
	}
	DPF(9,"GlobalQ:");
	pBilink=pProtocol->m_GSendQ.next;
	while(pBilink!=&pProtocol->m_GSendQ){
		pSendWalker=CONTAINING_RECORD(pBilink, SEND, m_GSendQ);
		ASSERT_SIGN(pSendWalker,SEND_SIGN);
		DPF(9,"Send %x pSession %x Pri %x State %d\n",pSendWalker,pSendWalker->pSession,pSendWalker->Priority,pSendWalker->SendState);
		pBilink=pBilink->next;
	}
#endif

	Unlock(&pSend->SendLock);
	Unlock(&pSession->SessionLock);
	Unlock(&pProtocol->m_SendQLock);

	if(fSignalQ){
		// tell send thread to process.
		SetEvent(pProtocol->m_hSendEvent);
	}       

	return DP_OK;
}

/*=============================================================================

	CopyDataToFrame
     
    Description:

		Copies data for a frame from the Send to the frame's data area. 

    Parameters:     

		pFrameData              - pointer to data area
		FrameDataSize   - Size of the Frame Data area
		pSend                   - send from which to get data
		nAhead          - number of frames ahead of NR to get data for.
		
    Return Values:

		Number of bytes copied.


	Notes: 

		Send must be locked across this call.
		
-----------------------------------------------------------------------------*/

UINT CopyDataToFrame(
	PUCHAR  pFrameData, 
	UINT    FrameDataLen,
	PSEND   pSend,
	UINT    nAhead)
{
	UINT    BytesToAdvance, BytesToCopy;
	UINT    FrameOffset=0;
	PUCHAR  dest,src;
	UINT    len;
	UINT    totlen=0;

	UINT    SendOffset;
	PBUFFER pSrcBuffer;
	UINT    CurrentBufferOffset;

	BytesToAdvance      = nAhead*FrameDataLen;
	SendOffset          = pSend->SendOffset;
	pSrcBuffer          = pSend->pCurrentBuffer;
	CurrentBufferOffset = pSend->CurrentBufferOffset;

	//
	// Run ahead to the buffer we start getting data from
	//

	while(BytesToAdvance){

		len = pSrcBuffer->len - CurrentBufferOffset;

		if(len > BytesToAdvance){
			CurrentBufferOffset += BytesToAdvance;
			SendOffset+=BytesToAdvance;
			BytesToAdvance=0;
		} else {
			pSrcBuffer=pSrcBuffer->pNext;
			CurrentBufferOffset = 0;
			BytesToAdvance-=len;
			SendOffset+=len;
		}
	}

	//
	// Copy the data for the Send into the frame
	//

	BytesToCopy = pSend->MessageSize - SendOffset;

	if(BytesToCopy > FrameDataLen){
		BytesToCopy=FrameDataLen;
	}

	while(BytesToCopy){

		ASSERT(pSrcBuffer);
		
		dest= pFrameData        + FrameOffset;
		src = pSrcBuffer->pData + CurrentBufferOffset;
		len = pSrcBuffer->len   - CurrentBufferOffset;

		if(len > BytesToCopy){
			len=BytesToCopy;
			CurrentBufferOffset+=len;//OPTIMIZATION?: not used after, don't need.
		} else {
			pSrcBuffer = pSrcBuffer->pNext;
			CurrentBufferOffset = 0;
		}

		BytesToCopy -= len;
		FrameOffset += len;
		totlen+=len;
		
		memcpy(dest,src,len);
	}
	
	return totlen;
}

// NOTE: ONLY 1 SEND THREAD ALLOWED.
ULONG WINAPI SendThread(LPVOID pProt)
{
	PPROTOCOL pProtocol=((PPROTOCOL)pProt);
	UINT  SendRc;

	while(TRUE){

		WaitForSingleObject(pProtocol->m_hSendEvent, INFINITE);

		Lock(&pProtocol->m_ObjLock);
		
		if(pProtocol->m_eState==ShuttingDown){
			Unlock(&pProtocol->m_ObjLock);
			// Make sure nothing is still waiting to timeout on the queue
			do {
				SendRc=SendHandler(pProtocol);
			} while (SendRc!=DPERR_NOMESSAGES);
			Lock(&pProtocol->m_ObjLock);
			pProtocol->m_nSendThreads--;
			Unlock(&pProtocol->m_ObjLock);
			ExitThread(0);
		}

		Unlock(&pProtocol->m_ObjLock);

		do {
			SendRc=SendHandler(pProtocol);
		} while (SendRc!=DPERR_NOMESSAGES);

	}
	return TRUE;
}


// Called with SendLock held.
VOID CancelRetryTimer(PSEND pSend)
{
//	UINT mmError;
	UINT retrycount=0;
	UINT_PTR uRetryTimer;
	UINT Unique;
	
	
	if(pSend->uRetryTimer){
		DPF(9,"Canceling Timer %x\n",pSend->uRetryTimer);

		// Delete it from the list first so we don't deadlock trying to kill it.
		Lock(&g_SendTimeoutListLock);

		uRetryTimer=pSend->uRetryTimer;
		Unique=pSend->TimerUnique;
		pSend->uRetryTimer=0;
	
		if(!EMPTY_BILINK(&pSend->TimeoutList)){
			Delete(&pSend->TimeoutList);
			InitBilink(&pSend->TimeoutList); // avoids DecSendRef having to know state of bilink.
			Unlock(&g_SendTimeoutListLock);

			CancelMyTimer(uRetryTimer, Unique);

		} else {
		
			Unlock(&g_SendTimeoutListLock);
		}
		
	} else {
		DPF(9,"CancelRetryTimer:No timer to cancel.\n");
	}
}

// Workaround for Win95 mmTimers:
// ==============================
//
// We cannot use a reference count for the timeouts as a result of the following Win95 bug:
//
// The cancelling of mmTimers is non-deterministic.  That is, when calling cancel, you cannot
// tell from the return code whether the timer ran, was cancelled or is still going to run.  
// Since we use the Send as the context for timeout, we cannot dereference it until we make 
// sure it is still valid, since code that cancelled the send and timer may have already freed 
// the send memory.  We place the sends being timed out on a list and scan the list for the
// send before we use it.  If we don't find the send on the list, we ignore the timeout.
//
// Also note, this workaround is not very expensive.  The linked list is in the order timeouts
// were scheduled, so generally if the links are approximately the same speed, timeouts will
// be similiar so the context being checked should be near the beginning of the list.


CRITICAL_SECTION g_SendTimeoutListLock;
BILINK g_BilinkSendTimeoutList;

void CALLBACK RetryTimerExpiry( UINT_PTR uID, UINT uMsg, DWORD_PTR dwUser, DWORD dw1, DWORD dw2 )
{
	PSEND pSend=(PSEND)(dwUser), pSendWalker;
	UINT  tWaiting;
	BILINK *pBilink;
	UINT    bFound=FALSE;

	DPF(9,"RetryTimerExpiry: %x, expecting %x, pSend %x\n",uID, pSend->uRetryTimer, pSend);

	tWaiting=timeGetTime();

	// Scan the list of waiting sends to see if this one is still waiting for a timeout.
	Lock(&g_SendTimeoutListLock);

	pBilink=g_BilinkSendTimeoutList.next;

	while(pBilink!=&g_BilinkSendTimeoutList){
	
		pSendWalker=CONTAINING_RECORD(pBilink, SEND, TimeoutList);
		pBilink=pBilink->next;
		
		if(pSendWalker == pSend){
			if(pSend->uRetryTimer==uID){
				Delete(&pSend->TimeoutList);
				InitBilink(&pSend->TimeoutList); // avoids DecSendRef having to know state of bilink.
				Unlock(&g_SendTimeoutListLock);
				// it is ok to call AddSendRef here without the sessionlock because
				// there is no way we could be adding the session reference.  If
				// the refcount is 0, it can only mean the send is already cleaning up
				// and we won't try to take the session locks so there is no lock
				// ordering problem.
				bFound=AddSendRef(pSend,1); // note bFound set to Refcount on send
				goto skip_unlock;
			}       
		}
	}
	
	Unlock(&g_SendTimeoutListLock);

skip_unlock:
	if(bFound){

		if(pSend->tRetryScheduled - pSend->tScheduled > 500){
			DWORD tm=timeGetTime();
			if(tm - pSend->tScheduled < 100 ){
				DPF(9,"RETRY TIMER EXPIRY IS WAY TOO EARLY, EXPECTED AT %x ACTUALLY AT %x\n",pSend->tRetryScheduled, tm);
				DEBUG_BREAK();
			}
		}
	
		DPF(9,"RetryTimerExpiry: Waiting For Send Lock...\n");

		Lock(&pSend->SendLock);

		DPF(9,"RetryTimerExpiry: Got SendLock\n");

		if(pSend->uRetryTimer==uID){ // check again, may be cancelled.
		
			pSend->uRetryTimer=0;

			switch(pSend->SendState)
			{
				case Start:             
				case Sending:   
					ASSERT(0);
				case Done:
					break;
					
				case WaitingForAck:

					pSend->RetryCount++;
					tWaiting-=pSend->tLastACK;

#ifdef DEBUG
					{
						static int retries;
						IN_WRITESTATS InWS;
						memset((PVOID)&InWS,0xFF,sizeof(IN_WRITESTATS));
					 	InWS.stat_USER1=((retries++)%20)+1;
						DbgWriteStats(&InWS);
					}
#endif

					if(tWaiting > pSend->pSession->MaxDropTime ||
					   (pSend->RetryCount > pSend->pSession->MaxRetry && tWaiting > pSend->pSession->MinDropTime)
					  )
					{
						DPF(8,"Send %x Timed Out, tWaiting: %d RetryCount: %d\n",pSend,tWaiting,pSend->RetryCount);
						pSend->SendState=TimedOut;
					} else {
						DPF(9,"Timer expired, retrying send %x RetryCount= %d\n",pSend,pSend->RetryCount);
						//pSend->NACKMask|=(1<<(pSend->NS-pSend->NR))-1;
						pSend->NACKMask |= 1; // just retry 1 frame.
						ASSERT_NACKMask(pSend);
						pSend->SendState=ReadyToSend;
					}       
					SetEvent(pSend->pSession->pProtocol->m_hSendEvent);
					break;
					
				case Throttled: 
					break;
				
				case ReadyToSend:
				default:
					break;

			}
		} 
		
		Unlock(&pSend->SendLock);
		DecSendRef(pSend->pSession->pProtocol, pSend);
	}       
}

VOID StartRetryTimer(PSEND pSend)
{
	UINT FptLatency;
	UINT tLatencyLong;
	UINT FptDev;
	UINT tRetry;

	FptLatency=max(pSend->pSession->FpLocalAverageLatency,pSend->pSession->LastLatency);
	FptDev=pSend->pSession->FpLocalAvgDeviation;
	tRetry=unFp(FptLatency+3*FptDev);//Latency +3 average deviations

	tLatencyLong=unFp(pSend->pSession->FpAverageLatency);

	// Sometimes stddev of latency gets badly skewed by the serial driver
	// taking a long time to complete locally, avoid setting retry time
	// too high by limiting to 2x the long latency average.
	if(tLatencyLong > 100 && tRetry > 2*max(tLatencyLong,unFp(FptLatency))){
		tRetry = 2*tLatencyLong;
	}

	if(pSend->RetryCount > 3){
		if(pSend->pSession->RemoteBytesReceived==0){
			// haven't spoken to remote yet, may be waiting for nametable, so back down hard.
			tRetry=5000;
		} else if (tRetry < 1000){
			// taking a lot of retries to get response, back down.
			tRetry=1000;
		}
	}

	if(tRetry < 50){
		tRetry=50;
	}
	
	ASSERT(tRetry);

	if(tRetry > 30000){
		DPF(0,"RETRY TIMER REQUESTING %d seconds?\n",tRetry);
	}
	
	if(!pSend->uRetryTimer){

		Lock(&g_SendTimeoutListLock);

		DPF(9,"Setting Retry Timer of %d ms\n", tRetry);

		pSend->uRetryTimer=SetMyTimer((tRetry)?(tRetry):1,(tRetry>>2)+1,RetryTimerExpiry,(ULONG_PTR) pSend,&pSend->TimerUnique);
		
		if(pSend->uRetryTimer){
			pSend->tScheduled = timeGetTime();
			pSend->tRetryScheduled = pSend->tScheduled+tRetry;
			InsertBefore(&pSend->TimeoutList, &g_BilinkSendTimeoutList);
		} else {
			DPF(0,"Start Retry Timer failed to schedule a timer with tRetry=%d for pSend %x\n",tRetry,pSend);
			DEBUG_BREAK();
		}
		
		DPF(9,"Started Retry Timer %x\n",pSend->uRetryTimer);                                                            

		Unlock(&g_SendTimeoutListLock);
										 
		if(!pSend->uRetryTimer){
			ASSERT(0);
		}
		
	} else {
		ASSERT(0);
	}

}

// Called with all necessary locks held.
VOID TimeOutSession(PSESSION pSession)
{
	PSEND pSend;
	BILINK *pBilink;
	UINT nSignalsRequired=0;

	// Mark Session Timed out.
	pSession->eState=Closing;
	// Mark all sends Timed out.
	pBilink=pSession->SendQ.next;

	while(pBilink != &pSession->SendQ){
	
		pSend=CONTAINING_RECORD(pBilink, SEND, SendQ);
		pBilink=pBilink->next;

		DPF(9,"TimeOutSession: Force Timing Out Send %x, State %d\n",pSend, pSend->SendState);

		switch(pSend->SendState){
		
			case Start:
			case Throttled:
			case ReadyToSend:
				DPF(9,"TimeOutSession: Moving to TimedOut, should be safe\n");
				pSend->SendState=TimedOut;
				nSignalsRequired += 1;
				break;
				
			case Sending:
				// can we even get here?  If we can this is probably not good
				// since the send will reset the retry count and tLastACK.
				DPF(9,"TimeOutSession: ALLOWING TimeOut to cancel.(could take 15 secs)\n");
				pSend->RetryCount=pSession->MaxRetry;
				pSend->tLastACK=timeGetTime()-pSession->MinDropTime;
				break;

			case WaitingForAck:
				DPF(9,"TimeOutSession: Canceling timer and making TimedOut\n");
				CancelRetryTimer(pSend);
				pSend->SendState = TimedOut;
				nSignalsRequired += 1;
				break;
				
			case WaitingForId:
				// Note, this means we can get signals for ids that aren't used.
				DPF(9,"TimeOutSession: Timing Out Send Waiting for ID, GetNextMessageToSend may fail, this is OK\n");
				pSend->SendState=TimedOut;
				if(pSend->dwFlags & DPSEND_GUARANTEED){
					InterlockedDecrement(&pSession->nWaitingForMessageid);
				} else {
					InterlockedDecrement(&pSession->nWaitingForDGMessageid);
				}
				nSignalsRequired += 1;
				break;
				
			case TimedOut:
			case Done:
				DPF(9,"TimeOutSession: Send already done or timed out, doesn't need our help\n");
				break;
				
			default:
				DPF(0,"TimeOutSession, pSession %x found Send %x in Wierd State %d\n",pSession,pSend,pSend->SendState);
				ASSERT(0);
				break;
		} /* switch */

	} /* while */

	// Create enough signals to process timed out sends.
	DPF(9,"Signalling SendQ %d items to process\n",nSignalsRequired);
	SetEvent(pSession->pProtocol->m_hSendEvent);
}

UINT WrapSend(PPROTOCOL pProtocol, PSEND pSend, PBUFFER pBuffer)
{
	PUCHAR pMessage,pMessageStart;
	DWORD dwWrapSize=0;
	DWORD dwIdTo=0;
	DWORD dwIdFrom=0;

	pMessageStart = &pBuffer->pData[pProtocol->m_dwSPHeaderSize];
	pMessage      = pMessageStart;
	dwIdFrom      = pSend->wIdFrom;
	dwIdTo        = pSend->wIdTo;
	
	if(dwIdFrom==0x70){ // avoid looking like a system message 'play'
		dwIdFrom=0xFFFF;
	}

	if(dwIdFrom){
		while(dwIdFrom){
			*pMessage=(UCHAR)(dwIdFrom & 0x7F);
			dwIdFrom >>= 7;
			if(dwIdFrom){
				*pMessage|=0x80;
			}
			pMessage++;
		}
	} else {
		*(pMessage++)=0;
	}

	if(dwIdTo){
		while(dwIdTo){
			*pMessage=(UCHAR)(dwIdTo & 0x7F);
			dwIdTo >>= 7;
			if(dwIdTo){
				*pMessage|=0x80;
			}
			pMessage++;
		}
	} else {
		*(pMessage++)=0;
	}

#if 0	// a-josbor: for debugging only.  I left it in in case we ever needed it again
	ExtractProtocolIds(pMessageStart, &dwIdFrom, &dwIdTo);
	ASSERT(dwIdFrom == pSend->wIdFrom);
	ASSERT(dwIdTo == pSend->wIdTo);
#endif

	return (UINT)(pMessage-pMessageStart);
}       

#define DROP 0

#if DROP
// 1 for send, 0 for drop.

char droparray[]= {
	1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,0,0};

UINT dropindex=0;
#endif

VOID CALLBACK UnThrottle(UINT_PTR uID, UINT uMsg, DWORD_PTR dwUser, DWORD dw1, DWORD dw2)
{
	PSESSION pSession=(PSESSION)dwUser;
	UINT tMissedBy;		// how long we missed the throttle by.
	DWORD tm;

	Lock(&pSession->SessionLock);

	tm=timeGetTime();
	tMissedBy = tm-pSession->tNextSend;

	if( (int)tMissedBy > 0){
		pSession->FpAvgUnThrottleTime -= pSession->FpAvgUnThrottleTime >> 4;
		pSession->FpAvgUnThrottleTime += (Fp(tMissedBy) >> 4);
		DPF(9,"Missed by: %d ms Avg Unthrottle Miss %d.%d ms\n", tMissedBy, pSession->FpAvgUnThrottleTime >> 8, (((pSession->FpAvgUnThrottleTime&0xFF)*100)/256) );
		
	}
	
	pSession->uUnThrottle=0;
	pSession->dwFlags |= SESSION_UNTHROTTLED; 
	pSession->pProtocol->m_bRescanQueue=TRUE;	// tell send routine to restart scan.
	DPF(9,"Unthrottling Session %x at %d\n",pSession, timeGetTime());
	Unlock(&pSession->SessionLock);
	SetEvent(pSession->pProtocol->m_hSendEvent);
	DecSessionRef(pSession);
}

VOID Throttle( PSESSION pSession, DWORD tm )
{
	DWORD tmDelta;
	Lock(&pSession->SessionLock);
		pSession->bhitThrottle=TRUE;
		pSession->dwFlags |= SESSION_THROTTLED;
		tmDelta = pSession->tNextSend - tm;
		if((INT)tmDelta < 0){
			tmDelta=1;
		}
		DPF(9,"Throttling pSession %x for %d ms (until %d)\n",pSession, tmDelta,pSession->tNextSend);
		InterlockedIncrement(&pSession->RefCount);
		pSession->uUnThrottle = SetMyTimer(tmDelta, (tmDelta>>2)?(tmDelta>>2):1, UnThrottle, (DWORD_PTR)pSession, &pSession->UnThrottleUnique);
		if(!pSession->uUnThrottle){
			DPF(0,"UH OH failed to schedule unthrottle event\n");
			DEBUG_BREAK();
		}
	Unlock(&pSession->SessionLock);
#ifdef DEBUG
	{
		static int throttlecounter;
		IN_WRITESTATS InWS;
		memset((PVOID)&InWS,0xFF,sizeof(IN_WRITESTATS));
	 	InWS.stat_USER4=((throttlecounter++)%20)+1;
		DbgWriteStats(&InWS);
	}
#endif
}	

// Given the current time, the bandwidth we are throttling to and the length of the packet we are sending,
// calculate the next time we are allowed to send.  Also keep a residue from this calculation so that
// we don't wind up using excessive bandwidth due to rounding, the residue from the last calculation is
// used in this calculation.

// Absolute flag means set the next send time relative to tm regardless

VOID UpdateSendTime(PSESSION pSession, DWORD Len, DWORD tm, BOOL fAbsolute)
{
	#define SendRate 		pSession->SendRateThrottle
	#define Residue   		pSession->tNextSendResidue
	#define tNext           pSession->tNextSend
	
	DWORD tFrame;		// amount of time this frame will take on the wire.


	tFrame = (Len+Residue)*1000 / SendRate;	// rate is bps, but want to calc bpms, so (Len+Residue)*1000
	
	Residue = (Len+Residue) - (tFrame * SendRate)/1000 ;	
	
	ASSERT(!(Residue&0x80000000)); 	// residue better be +ve

	if(fAbsolute || (INT)(tNext - tm) < 0){
		// tNext is less than tm, so calc based on tm.
		tNext = tm+tFrame;
	} else {
		// tNext is greater than tm, so add more wait.
		tNext = tNext+tFrame;
	}

	DPF(8,"UpdateSendTime time %d, tFrame %d, Residue %d, tNext %d",tm,tFrame,Residue,tNext);


	#undef SendRate
	#undef Residue
	#undef tNext
}			

//CHAR Drop[]={0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,1,0,0};
//DWORD DropSize = sizeof(Drop);
//DWORD iDrop=0;

// AO - added contraint, 1 send thread per session.  Since this is not enforced by GetNextMessageToSend
// 5-21-98  we are effectively restricted to 1 send thread for the protocol.  We can fix this by adding
//      a sending state on the session and having GetNextMessageToSend skip sending sessions.
HRESULT ReliableSend(PPROTOCOL pProtocol, PSEND pSend)
{
	#define pBigFrame ((pPacket2)(pFrame))

	HRESULT  hr;
	PBUFFER  pBuffer;

	pPacket1  pFrame;
	PUCHAR   pFrameData;
	UINT     FrameDataLen;
	UINT     FrameTotalLen;
	UINT     MaxFrameLen;
	UINT     FrameHeaderLen;

	UINT     nFramesOutstanding;
	UINT     nFramesToSend;
	UINT     msk;
	UINT     shift;

	UINT     WrapSize;
	UINT     DPWrapSize;      // DirectPlay wrapping only. ([[DPLAY 0xFF]|],From,To)
	DWORD    tm=0;			  // The time, 0 if we haven't retrieved it yet.
	DWORD    tmExit=0;
	BOOL     bExitEarly=FALSE;

	DPSP_SENDDATA SendData;

	INT		iTemp;
	
	//
	// Sending algorithm is designed to handle NACKs only (there
	// is no special case for sending data the first time).  So
	// We send by making it look like the frames we want to send
	// have been NACKed.  Every frame we send, we clear the NACK
	// bit for.  If an actual NACK comes in, the bit is set.
	// When an ACK comes in, we shift the NACK and ACK masks
	// nACK-NR and if applicable, set new NACK bits.
	//

	Lock(&pSend->SendLock);

	if(pSend->SendState == Done){
		goto unlock_exit;
	}       


	nFramesOutstanding=(pSend->NS-pSend->NR);

	if( nFramesOutstanding < pSend->WindowSize){

		// Set NACK bits up to WindowSize (unless over nFrames);
		
		nFramesToSend=pSend->WindowSize-nFramesOutstanding;

		if(nFramesToSend > pSend->nFrames-pSend->NS){
			nFramesToSend=pSend->nFrames-pSend->NS;
		}

		pSend->NACKMask |= ((1<<nFramesToSend)-1)<<nFramesOutstanding;
		pSend->OpenWindow = nFramesOutstanding + nFramesToSend;
		DPF(9,"Send: pSend->NACKMask %x, OpenWindow %d\n",pSend->NACKMask, pSend->OpenWindow);
		
	}

	tmExit=timeGetTime()+1000; // always blow out of here in 1 second max.
	
Reload:
	msk=1;
	shift=0;
	
	MaxFrameLen=pSend->FrameSize;

	while(pSend->NACKMask){
	
		ASSERT_NACKMask(pSend);
		
		tm=timeGetTime();		// Getting the time is relatively expensive, so we do it once here and pass it around.

		if(((INT)tm - (INT)tmExit) > 0){
			DPF(0,"Breaking Out of Send Loop due to expiry of timer\n");
			bExitEarly=TRUE;
			break;
		}

	#if 1
		if((tm+unFp(pSend->pSession->FpAvgUnThrottleTime)-pSend->pSession->tNextSend) & 0x80000000){
			// we're still too early to do the next send, so throttled this session.
			goto throttle_exit;
		}
	#endif	


		if(pSend->NACKMask & msk){

			pBuffer=GetFrameBuffer(MaxFrameLen+pProtocol->m_dwSPHeaderSize+MAX_SEND_HEADER);
			
			if(!pBuffer){
    			pSend->SendState=ReadyToSend;
	    		SetEvent(pSend->pSession->pProtocol->m_hSendEvent); // keep the queue rolling.
				hr=DPERR_PENDING;
				goto exit;
			}

			WrapSize=pProtocol->m_dwSPHeaderSize;              // leave space for SP header.
			DPWrapSize=WrapSend(pProtocol, pSend, pBuffer); // fill in out address wrapping
			WrapSize+=DPWrapSize;

			pFrame=(pPacket1)&pBuffer->pData[WrapSize];    // protocol header after wrapping
			
			if(pSend->fSendSmall){
				pFrameData=&pFrame->data[0];
				FrameHeaderLen=(UINT)(pFrameData-(PUCHAR)pFrame);
			} else {
				pFrameData=&pBigFrame->data[0];
				FrameHeaderLen=(UINT)(pFrameData-(PUCHAR)pFrame);
			}

			// For calculating nFrames, we assumed MAX_SEND_HEADER, subtract out the unused portion
			// so we don't put to much data in the frame and mess up the accounting.
			pBuffer->len-=(MAX_SEND_HEADER-(FrameHeaderLen+DPWrapSize)); 

			FrameHeaderLen += WrapSize;     // now include wrapping and SPheader space.
			
			FrameDataLen=CopyDataToFrame(pFrameData, pBuffer->len-FrameHeaderLen, pSend, shift);

			if(!pSend->FrameDataLen){
				pSend->FrameDataLen=FrameDataLen;
			}       
			
			FrameTotalLen=FrameDataLen+FrameHeaderLen;

			pSend->BytesThisSend=FrameTotalLen-WrapSize; //only counting payload

			// Do that protocol thing
			BuildHeader(pSend,pFrame,shift,tm);

			// we know we don't have to check here since we have a reference
			// from finding the send to work on ON the send queue.  So it
			// can't go away til we return from this function.
			iTemp=AddSendRef(pSend,1);
			ASSERT(iTemp);
			
			if(pSend->NR+shift >= pSend->NS){
				pSend->NS = pSend->NR+shift+1;
			}       
			pSend->NACKMask &= ~msk;
			
			DPF(9,"S %2x %2x %2x\n",pBuffer->pData[0], pBuffer->pData[1], pBuffer->pData[2]);

			// Update the next time we are allowed to send.
			UpdateSendTime(pSend->pSession, pSend->BytesThisSend, tm, FALSE);

			Unlock(&pSend->SendLock);

			ASSERT(!(FrameTotalLen &0xFFFF0000));

			
			// Send this puppy...

			SendData.dwFlags        = pSend->dwFlags & ~DPSEND_GUARANTEED;
			SendData.idPlayerTo     = pSend->idTo;
			SendData.idPlayerFrom   = pSend->idFrom;
			SendData.lpMessage      = pBuffer->pData;
			SendData.dwMessageSize  = FrameTotalLen;
			SendData.bSystemMessage = 0;
			SendData.lpISP          = pProtocol->m_lpISP;

			ENTER_DPLAY();

			Lock(&pProtocol->m_SPLock);

		//	if(!(Drop[(iDrop++)%DropSize])){//DEBUG ONLY!

				hr=CALLSP(pProtocol->m_lpDPlay->pcbSPCallbacks->Send,&SendData); 
		//	}

			Unlock(&pProtocol->m_SPLock);

			LEAVE_DPLAY();

  #ifdef DEBUG
    if(hr != DPERR_PENDING && hr != DP_OK){
        DPF(0,"Wierd error %x from unreliable send in SP\n",hr);
        //DEBUG_BREAK();
    }
  #endif
			
			if(hr!=DPERR_PENDING){
				FreeFrameBuffer(pBuffer);
				if(!DecSendRef(pProtocol, pSend)){
					ASSERT(0);
					hr=DPERR_PENDING;
					goto exit;
				}
				if(hr != DP_OK){
					Lock(&pSend->SendLock);
					pSend->SendState = TimedOut; // kill the connection.
					SetEvent(pSend->pSession->pProtocol->m_hSendEvent); // keep the queue rolling.
					break;
				}
			}

			Lock(&pSend->SendLock);
		
		} /* endif (pSend->NACKMask & msk) */

		if(pSend->fUpdate){
			pSend->fUpdate=FALSE;
			goto Reload;
		}

		// Check if we are past windowsize, if so roll back the mask
		// Also if there are earlier bits to ACK.
		if((msk<<=1UL) >= (1UL<<pSend->WindowSize)){
			msk=1;
			shift=0;
		} else {
			shift++;
		}
		

	} /* end while (pSend->NACKMask) */

	if(pSend->SendState != Done && pSend->SendState != TimedOut){

		if(bExitEarly){
			pSend->SendState=ReadyToSend;
			SetEvent(pSend->pSession->pProtocol->m_hSendEvent); // keep the queue rolling.
		} else {
			pSend->SendState=WaitingForAck;
			StartRetryTimer(pSend);
		}	
	} else {
		// We have timed out the send due to killing the session, or
		// we got the final ACK, either way, don't touch the SendState
	}

unlock_exit:
	Unlock(&pSend->SendLock);

	hr=DPERR_PENDING; // Reliable sends are completed by the ACK.


	
exit:
	return hr;

throttle_exit:

	hr=DPERR_PENDING;
	
	pSend->SendState=Throttled;
	Unlock(&pSend->SendLock);

	Throttle(pSend->pSession, tm);

	return hr;
	
	#undef pBigFrame        
}

// TRUE, didn't reach end, FALSE, no more to send.
BOOL AdvanceSend(PSEND pSend, UINT AckedLen)
{
	BOOL rc=TRUE;

	// quick short circuit for small messages.
	if(AckedLen+pSend->SendOffset==pSend->MessageSize){
		rc=FALSE;
		goto exit;
	}
	
	if(pSend->SendOffset+AckedLen > pSend->MessageSize){
		AckedLen=pSend->MessageSize-pSend->SendOffset;
	}
		
	pSend->SendOffset+=AckedLen;
	
	while(AckedLen){
		if(pSend->pCurrentBuffer->len-pSend->CurrentBufferOffset >= AckedLen){
			pSend->CurrentBufferOffset+=AckedLen;
			rc=TRUE;
			break;
		} else {
			AckedLen -= (pSend->pCurrentBuffer->len-pSend->CurrentBufferOffset);
			pSend->pCurrentBuffer=pSend->pCurrentBuffer->pNext;
			pSend->CurrentBufferOffset=0;
			rc=FALSE;
		}
	}

exit:
	return rc;
}

HRESULT DGSend(PPROTOCOL pProtocol, PSEND  pSend)
{
	#define pBigFrame ((pPacket2)(pFrame))
	
	PBUFFER  pBuffer;

	pPacket1 pFrame;
	PUCHAR   pFrameData;
	UINT     FrameDataLen;
	UINT     FrameHeaderLen;
	UINT     FrameTotalLen;
	UINT     MaxFrameLen;

	UINT     nFramesToSend;

	UINT     WrapSize;
	UINT     DPWrapSize;      // DirectPlay wrapping only. ([[DPLAY 0xFF]|],From,To)

	DPSP_SENDDATA SendData;

	DWORD    tm;
	HRESULT  hr;
	
	Lock(&pSend->SendLock);

	nFramesToSend=pSend->nFrames-pSend->NR;

	MaxFrameLen=pSend->FrameSize;

	while(nFramesToSend){

		tm=timeGetTime();		// Getting the time is relatively expensive, so we do it once here and pass it around.
#if 1		
		if((tm+unFp(pSend->pSession->FpAvgUnThrottleTime)-pSend->pSession->tNextSend) & 0x80000000){
			// we're still too early to do the next send, so throttled this session.
			goto throttle_exit;
		}
#endif
		pBuffer=GetFrameBuffer(MaxFrameLen+pProtocol->m_dwSPHeaderSize+MAX_SEND_HEADER);
		
		if(!pBuffer){
			hr=DPERR_PENDING;
			goto exit;
		}

		WrapSize=pProtocol->m_dwSPHeaderSize;              // leave space for SP header.
		DPWrapSize=WrapSend(pProtocol, pSend, pBuffer); // fill in out address wrapping
		WrapSize+=DPWrapSize;

		pFrame=(pPacket1)&pBuffer->pData[WrapSize];    // protocol header after wrapping
		
		if(pSend->fSendSmall){
			pFrameData=&pFrame->data[0];
			FrameHeaderLen=(UINT)(pFrameData-(PUCHAR)pFrame);
		} else {
			pFrameData=&pBigFrame->data[0];
			FrameHeaderLen=(UINT)(pFrameData-(PUCHAR)pFrame);
		}

		// For calculating nFrames, we assumed MAX_SEND_HEADER, subtract out the unused portion
		// so we don't put to much data in the frame and mess up the accounting.
		pBuffer->len-=(MAX_SEND_HEADER-(FrameHeaderLen+DPWrapSize)); 

		FrameHeaderLen += WrapSize;     // now include wrapping and SPheader space.

		FrameDataLen=CopyDataToFrame(pFrameData, pBuffer->len-FrameHeaderLen, pSend, 0);

		FrameTotalLen=FrameDataLen+FrameHeaderLen;
		
		pSend->BytesThisSend=FrameTotalLen-WrapSize; //only counting payload
		
		// Do that protocol thing
		BuildHeader(pSend,pFrame,0,tm);

		//AddSendRef(pSend,1); //already locked, so just add one.
		ASSERT(pSend->RefCount); //verifies ++ below is ok.
		InterlockedIncrement((PLONG)&pSend->RefCount);  

		UpdateSendTime(pSend->pSession,pSend->BytesThisSend,tm,FALSE);
		
		Unlock(&pSend->SendLock);

		// Send this puppy...
		ASSERT(!(pSend->dwFlags & DPSEND_GUARANTEED));
		SendData.dwFlags        = pSend->dwFlags;
		SendData.idPlayerTo     = pSend->idTo;
		SendData.idPlayerFrom   = pSend->idFrom;
		SendData.lpMessage      = pBuffer->pData;
		SendData.dwMessageSize  = FrameTotalLen;
		SendData.bSystemMessage = 0;
		SendData.lpISP          = pProtocol->m_lpISP;

		ENTER_DPLAY();
		
		Lock(&pProtocol->m_SPLock);

		hr=CALLSP(pProtocol->m_lpDPlay->pcbSPCallbacks->Send,&SendData); 

		Unlock(&pProtocol->m_SPLock);

		LEAVE_DPLAY();

  #ifdef DEBUG
    if(hr != DPERR_PENDING && hr != DP_OK){
        DPF(0,"Wierd error %x from unreliable send in SP\n",hr);
        //DEBUG_BREAK();
    }
  #endif
		
		if(hr!=DPERR_PENDING){
			if(!DecSendRef(pProtocol,pSend)){
				// No async send support in Dplay at lower edge,
				// so we should never get here!
				ASSERT(0);
			}
			FreeFrameBuffer(pBuffer);
		}
		
		Lock(&pSend->SendLock);
		
		nFramesToSend--;
		
		AdvanceSend(pSend,FrameDataLen);
		pSend->NR++;
		pSend->NS++;
	}
	
	Unlock(&pSend->SendLock);

	DGCompleteSend(pSend); 

	hr=DPERR_PENDING;  // everything was sent, but already completed by DGCompleteSend

exit:
	return hr;

throttle_exit:
	hr=DPERR_PENDING;

	pSend->SendState=Throttled;
	Unlock(&pSend->SendLock);

	Throttle(pSend->pSession, tm);

	return hr;
	#undef pBigFrame        
}

BOOL DGCompleteSend(PSEND pSend)
{
	UINT bit;
	UINT MsgMask;
	PSESSION pSession;
	
	pSend->SendState=Done;
	pSession=pSend->pSession;

	Lock(&pSession->SessionLock);

	if(!pSend->fSendSmall){
		MsgMask = 0xFFFF;
	} else {
		MsgMask =0xFF;
	}       

	DPF(9,"CompleteSend\n");

	//
	// Update Session information for completion of this send.
	//
	
	bit = ((pSend->messageid-pSession->DGFirstMsg) & MsgMask)-1;

	// clear the message mask bit for the completed send.
	if(pSession->DGOutMsgMask & 1<<bit){
		pSession->DGOutMsgMask &= ~(1<<bit);
	} else {
		return FALSE;
	}
	
	// slide the first message count forward for each low
	// bit clear in Message mask.
	while(pSession->DGLastMsg-pSession->DGFirstMsg){
		if(!(pSession->DGOutMsgMask & 1)){
			pSession->DGFirstMsg=(pSession->DGFirstMsg+1)&MsgMask;
			pSession->DGOutMsgMask >>= 1;
			if(pSession->nWaitingForDGMessageid){
				pSession->pProtocol->m_bRescanQueue=TRUE;
				SetEvent(pSession->pProtocol->m_hSendEvent);
			}       
		} else {
			break;
		}
	}
	
	//
	// Return the Send to the pool and complete the waiting client.
	//

	Unlock(&pSession->SessionLock);
	
	ASSERT(pSend->RefCount);
	
	// Send completed, do completion

	DoSendCompletion(pSend, DP_OK);

	DecSendRef(pSession->pProtocol, pSend); // for completion.

	return TRUE;
}


// Send a fully formatted System packet (ACK, nACK, etc..)
HRESULT SystemSend(PPROTOCOL pProtocol, PSEND  pSend)
{
	PBUFFER  pBuffer;
	DPSP_SENDDATA SendData;
	HRESULT  hr;
	PSESSION pSession;

	pBuffer=pSend->pMessage;

	DPF(9,"System Send pBuffer %x pData %x len %d, idTo %x \n",pBuffer, pBuffer->pData, pBuffer->len, pSend->idTo);
	

	pSession=GetSysSessionByIndex(pProtocol, pSend->wIdTo); // adds a ref on session.
															//      |
	if(!pSession){											//      |
		hr=DPERR_INVALIDPLAYER;								//		|
		goto exit;											//      |
	}														//      |
															//      |
	SendData.idPlayerTo     = pSession->dpid;				//		|
	DecSessionRef(pSession); 								// <----+  frees ref here.
	
	// Send this puppy...
	SendData.dwFlags        = 0;
	SendData.idPlayerFrom   = pSend->idFrom;
	SendData.lpMessage      = pBuffer->pData;
	SendData.dwMessageSize  = pBuffer->len;
	SendData.bSystemMessage = 0;
	SendData.lpISP          = pProtocol->m_lpISP;

	ENTER_DPLAY();
	Lock(&pProtocol->m_SPLock);

	hr=CALLSP(pProtocol->m_lpDPlay->pcbSPCallbacks->Send,&SendData); 

	Unlock(&pProtocol->m_SPLock);

	LEAVE_DPLAY();

#ifdef DEBUG
	if(hr!=DP_OK){
		DPF(0,"UNSUCCESSFUL SEND in SYSTEM SEND, hr=%x\n",hr);
	}
#endif
exit:
	return hr;
	
	#undef pBigFrame        
}

VOID DoSendCompletion(PSEND pSend, INT Status)
{
	#ifdef DEBUG
	if(Status != DP_OK){
		DPF(8,"Send Error pSend %x, Status %x\n",pSend,Status);
	}
	#endif
	if(!(pSend->dwFlags & ASEND_PROTOCOL)){
		EnterCriticalSection(&pSend->pProtocol->m_SendQLock);
		pSend->pProtocol->m_dwBytesPending -= pSend->MessageSize;
		pSend->pProtocol->m_dwMessagesPending -= 1;
		DPF(8,"SC: Messages pending %d\n",pSend->pProtocol->m_dwMessagesPending);
		LeaveCriticalSection(&pSend->pProtocol->m_SendQLock);
	}	

	if(pSend->pAsyncInfo){
		// ASYNC_SEND
		if(pSend->AsyncInfo.pStatus){
			(*pSend->AsyncInfo.pStatus)=Status;
		}       
		if(pSend->AsyncInfo.SendCallBack){
			(*pSend->AsyncInfo.SendCallBack)(pSend->AsyncInfo.CallBackContext,Status);
		}
		if(pSend->AsyncInfo.hEvent){
			DPF(9,"ASYNC_SENDCOMPLETE: Signalling Event %x\n",pSend->AsyncInfo.hEvent);
			SetEvent(pSend->AsyncInfo.hEvent);
		}
	} else if (!(pSend->dwFlags&(ASEND_PROTOCOL|DPSEND_ASYNC))){
		// SYNC_SEND
		if(pSend->AsyncInfo.pStatus){
			(*pSend->AsyncInfo.pStatus)=Status;
		}       
		if(pSend->AsyncInfo.hEvent){
			DPF(9,"SYNC_SENDCOMPLETE: Signalling Event %x\n",pSend->AsyncInfo.hEvent);
			SetEvent(pSend->AsyncInfo.hEvent);
		}
	} else {
		// PROTOCOL INTERNAL ASYNC SEND
		if(pSend->AsyncInfo.pStatus){
			(*pSend->AsyncInfo.pStatus)=Status;
		}       
		if(pSend->AsyncInfo.SendCallBack){
			(*pSend->AsyncInfo.SendCallBack)(pSend->AsyncInfo.CallBackContext,Status);
		}
	}
}

/*=============================================================================

	SendHandler - Send the next message that needs to send packets.
    
    Description:

	Finds a message on the send queue that needs to send packets and deserves
	to use some bandwidth, either because it is highest priority or because
	all the higher priority messages are waiting for ACKs.  Then sends as many
	packets as possible before hitting the throttling limit.

	Returns when the throttle limit is hit, or all packets for this send have
	been sent.

    Parameters:     

		pARPD pObj - pointer to the ARPD object to send packets on.

    Return Values:


-----------------------------------------------------------------------------*/
HRESULT SendHandler(PPROTOCOL pProtocol)
{

	PSEND pSend;    
	HRESULT  hr=DP_OK;
	PSESSION pSession;

	// adds ref to send and session if found
	pSend=GetNextMessageToSend(pProtocol); 

	if(!pSend){
		goto nothing_to_send;
	}

    //DPF(4,"==>Send\n");

	switch(pSend->pSession->eState){

		case Open:
			
			switch(pSend->SendState){
			
				case Done:              // Send handlers must deal with Done.
					DPF(9,"Calling SendHandler for Done Send--should just return\n");
				case Sending:
					//
					// Send as many frames as we can given the window size.
					//

					// Send handlers dump packets on the wire, if they expect
					// to be completed later, they return PENDING in which case
					// their completion handlers must do the cleanup.  If they
					// return OK, it means everything for this send is done and
					// we do the cleanup.
				
					if(pSend->dwFlags & ASEND_PROTOCOL){
						hr=SystemSend(pProtocol, pSend);
					} else if(pSend->dwFlags & DPSEND_GUARANTEE){
						hr=ReliableSend(pProtocol, pSend);
					} else {
						hr=DGSend(pProtocol, pSend);
					}
					break;
					
				case TimedOut:
					hr=DPERR_CONNECTIONLOST;
					pSend->SendState=Done;
					break;

				case Cancelled:
					hr=DPERR_USERCANCEL;
					pSend->SendState=Done;
					break;

				case UserTimeOut:
					hr=DPERR_TIMEOUT;
					pSend->SendState=Done;
					break;

				default:        
					DPF(0,"SendHandler: Invalid pSend %x SendState: %d\n",pSend,pSend->SendState);
					ASSERT(0);
			}               
			break;

		case Closing:
			switch(pSend->SendState){
				case TimedOut:
					DPF(8,"Returning CONNECTIONLOST on timed out message %x\n",DPERR_CONNECTIONLOST);
					hr=DPERR_CONNECTIONLOST;
					break;
					
				default:	
					DPF(8,"Send for session in Closing State, returning %x\n",DPERR_INVALIDPLAYER);
					hr=DPERR_INVALIDPLAYER;
					break;
			}		
			pSend->SendState=Done;
			break;
			
		case Closed:
			DPF(8,"Send for session in Closed State, returning %x",DPERR_INVALIDPLAYER);
			hr=DPERR_INVALIDPLAYER;
			pSend->SendState=Done;
			break;
	}               

    //DPF(4,"<==Send Leaving,rc=%x\n",hr);

	if( hr != DPERR_PENDING ){
		Lock(&pSend->SendLock);
		ASSERT(pSend->RefCount);
		
		//
		// Send completed, do completion
		//
		DoSendCompletion(pSend, hr);

		Unlock(&pSend->SendLock);
		DecSendRef(pProtocol, pSend);   // for completion
	} 

	pSession=pSend->pSession;
	DecSendRef(pProtocol,pSend); // Balances GetNextMessageToSend
	DecSessionRef(pSession); // Balances GetNextMessageToSend
	return hr;

nothing_to_send:
	return DPERR_NOMESSAGES;
}

/*=============================================================================

	Build Header - fill in the frame header for a packet to be sent.
    
    Description:

	Enough space is left in the frame to go on the wire (pFrame) to fit the
	message header.  One of two types of headers is built, depending on the
	value of the fSendSmall field of the packet.  If fSendSmall is TRUE, a compact 
	header is built, this lowers overhead on slow media.  If fSendSmall is FALSE
	a larger header that can support larger windows is built.  The header
	is filled into the front of pFrame.

    Parameters:     

		pARPD pObj - pointer to the ARPD object to send packets on.

    Return Values:


-----------------------------------------------------------------------------*/

VOID BuildHeader(PSEND pSend,pPacket1 pFrame, UINT shift, DWORD tm)
{
	#define pBigFrame ((pPacket2)(pFrame))

	PSENDSTAT pStat=NULL;
	UINT      seq;

	UINT      bitEOM,bitSTA,bitSAK=0;
	DWORD     BytesSent;
	DWORD	  RemoteBytesReceived;
	DWORD     tRemoteBytesReceived;
	DWORD     bResetBias=FALSE;

	// on first frame of a message, set the start bit (STA).
	if(pSend->NR+shift==0){
		bitSTA=STA;
	} else {
		bitSTA=0;
	}

	// on the last frome of a message set the end of message bit (EOM)
	if(pSend->nFrames==pSend->NR+shift+1){
		bitEOM=EOM;
	} else {
		bitEOM=0;
	}

	// if we haven't set EOM and we haven't requested an ACK in 1/4 the
	// round trip latency, set the SAK bit, to ensure we have at least 
	// 2 ACK's in flight for feedback to the send throttle control system.
	// Don't create extra ACKs if round trip is less than 100 ms.
	if(!bitEOM || !(pSend->dwFlags & DPSEND_GUARANTEED)){
		DWORD tmDeltaSAK = tm-pSend->pSession->tLastSAK;
		if(((int)tmDeltaSAK > 50 ) &&
	       (tmDeltaSAK > (unFp(pSend->pSession->FpLocalAverageLatency)>>2))
	      )
		{
			bitSAK=SAK;
		} 
	}

	// If we re-transmitted we need to send a SAK
	// despite the SAK countdown.
	if((!bitSAK) &&
	   (pSend->dwFlags & DPSEND_GUARANTEED) &&
	   ((pSend->NACKMask & (pSend->NACKMask-1)) == 0) &&
	   (bitEOM==0)
	  )
	{
		bitSAK=SAK;
	}

	if(!(--pSend->SAKCountDown)){
		bitSAK=SAK;
	}

	if(bitSAK|bitEOM){
		pSend->pSession->tLastSAK = tm;
		pSend->SAKCountDown=pSend->SAKInterval;
		pStat=GetSendStat();
	}	
	
	if(pSend->fSendSmall){

		pFrame->flags=CMD|bitEOM|bitSTA|bitSAK;
		
		seq=(pSend->NR+shift+1) & pSend->SendSEQMSK;
		pFrame->messageid = (byte)pSend->messageid;
		pFrame->sequence  = (byte)seq;
		pFrame->serial    = (byte)(pSend->serial++);

		if(pStat){
			pStat->serial=pFrame->serial;
		}
		
	} else {
	
		pBigFrame->flags=CMD|BIG|bitEOM|bitSTA|bitSAK;
		
		seq=((pSend->NR+shift+1) & pSend->SendSEQMSK);
		pBigFrame->messageid = (word)pSend->messageid;
		pBigFrame->sequence  = (word)seq;
		pBigFrame->serial    = (byte)pSend->serial++;                           

		if(pStat){
			pStat->serial=pBigFrame->serial;
		}
		
	}

	if(pSend->dwFlags & DPSEND_GUARANTEE){
		pFrame->flags |= RLY;
	}

	// count the number of bytes we have sent.
	Lock(&pSend->pSession->SessionStatLock);
	pSend->pSession->BytesSent+=pSend->BytesThisSend;
	BytesSent=pSend->pSession->BytesSent;
	RemoteBytesReceived=pSend->pSession->RemoteBytesReceived;
	tRemoteBytesReceived=pSend->pSession->tRemoteBytesReceived;
	if(pStat && pSend->pSession->bResetBias &&
	   ((--pSend->pSession->bResetBias) == 0))
	{
		bResetBias=TRUE;			
	}
	Unlock(&pSend->pSession->SessionStatLock);

	if(pStat){
		pStat->sequence=seq;
		pStat->messageid=pSend->messageid;
		pStat->tSent=tm;
		pStat->LocalBytesSent=BytesSent;
		pStat->RemoteBytesReceived=RemoteBytesReceived;
		pStat->tRemoteBytesReceived=tRemoteBytesReceived;
		pStat->bResetBias=bResetBias;
		if(pSend->dwFlags & DPSEND_GUARANTEED){
			InsertBefore(&pStat->StatList,&pSend->StatList);
		} else {
			Lock(&pSend->pSession->SessionStatLock);
			InsertBefore(&pStat->StatList,&pSend->pSession->DGStatList);
			Unlock(&pSend->pSession->SessionStatLock);
		}
	}

	
	#undef pBigFrame
}

#if 0
// release sends waiting for an id.
VOID UnWaitSends(PSESSION pSession, DWORD fReliable)
{
	BILINK *pBilink;
	PSEND pSendWalker;

	pBilink=pSession->SendQ.next;

	while(pBilink != &pSession->SendQ){
		pSendWalker=CONTAINING_RECORD(pBilink,SEND,SendQ);
		pBilink=pBilink->next;
		if(pSendWalker->SendState==WaitingForId){
			if(fReliable){
				if(pSendWalker->dwFlags & DPSEND_GUARANTEED){
					pSendWalker->SendState=Start;
				}
			} else {
				if(!(pSendWalker->dwFlags & DPSEND_GUARANTEED)){
					pSendWalker->SendState=Start;
				}
			}
		
		}
	}
	if(fReliable){
		pSession->nWaitingForMessageid=0;
	} else {
		pSession->nWaitingForDGMessageid=0;
	}
}
#endif

// Check if a datagram send can be started, if it can update teh
// Session and the Send.
BOOL StartDatagramSend(PSESSION pSession, PSEND pSend, UINT MsgIdMask)
{
	BOOL bFoundSend;
	UINT bit;
//	BOOL bTransition=FALSE;

	if((pSession->DGLastMsg-pSession->DGFirstMsg < pSession->MaxCDGSends)){
	
		bFoundSend=TRUE;

		if(pSend->SendState==WaitingForId){
			InterlockedDecrement(&pSession->nWaitingForDGMessageid);
		}
		
		bit=(pSession->DGLastMsg-pSession->DGFirstMsg)&MsgIdMask;
		ASSERT(bit<30);
		pSession->DGOutMsgMask |= 1<<bit;
		pSession->DGLastMsg =(pSession->DGLastMsg+1)&MsgIdMask;
		
		pSend->messageid  =pSession->DGLastMsg;
		pSend->FrameSize  =pSession->MaxPacketSize-MAX_SEND_HEADER;

		// Calculate number of frames required for this send.
		pSend->nFrames    =(pSend->MessageSize/pSend->FrameSize);
		if(pSend->FrameSize*pSend->nFrames < pSend->MessageSize || !pSend->nFrames){
			pSend->nFrames++;
		}
		pSend->NR=0;
		pSend->FrameDataLen=0;// hack
		pSend->fSendSmall=pSession->fSendSmallDG;
		if(pSend->fSendSmall){
			pSend->SendSEQMSK = 0xFF;
		} else {
			pSend->SendSEQMSK = 0xFFFF;
		}
	} else {
#if 0
		if(pSession->fSendSmallDG && pSession->DGFirstMsg < 0xFF-MAX_SMALL_CSENDS) {
			// Ran out of IDs, Transition to Large headers.
			DPF(9,"OUT OF IDS, DATAGRAMS GOING TO LARGE FRAMES\n");
			pSession->MaxCDGSends   = MAX_LARGE_DG_CSENDS;
			pSession->DGWindowSize  = MAX_LARGE_WINDOW;
			pSession->fSendSmallDG  = FALSE;
			bTransition=TRUE;
		}
#endif
		bFoundSend=FALSE;
		
		if(pSend->SendState==Start){
			InterlockedIncrement(&pSession->nWaitingForDGMessageid);
			DPF(9,"StartDatagramSend: No Id's Avail: nWaitingForDGMessageid %x\n",pSession->nWaitingForDGMessageid);
			pSend->SendState=WaitingForId;
#if 0			
			if(bTransition){
				UnWaitSends(pSession,FALSE);
				SetEvent(pSession->pProtocol->m_hSendEvent);
			}
#endif			
		} else {
			DPF(9,"Couldn't start datagram send on pSend %x State %d pSession %x\n",pSend,pSend->SendState,pSession);
			if(pSend->SendState!=WaitingForId){
				ASSERT(0);
			}
		}

	}

	return bFoundSend;
}


BOOL StartReliableSend(PSESSION pSession, PSEND pSend, UINT MsgIdMask)
{
	BOOL bFoundSend;
	UINT bit;
//	BOOL bTransition=FALSE;

	ASSERT(pSend->dwFlags & DPSEND_GUARANTEED);

	if((pSession->LastMsg-pSession->FirstMsg & MsgIdMask) < pSession->MaxCSends){

		DPF(9,"StartReliableSend: FirstMsg: x%x LastMsg: x%x\n",pSession->FirstMsg, pSession->LastMsg);
	
		bFoundSend=TRUE;

		if(pSend->SendState==WaitingForId){
			InterlockedDecrement(&pSession->nWaitingForMessageid);
		}
		
		bit=(pSession->LastMsg-pSession->FirstMsg)&MsgIdMask;
		#ifdef DEBUG
		if(!(bit<pSession->MaxCSends)){
			DEBUG_BREAK();
		}
		#endif
		pSession->OutMsgMask |= 1<<bit;
		pSession->LastMsg =(pSession->LastMsg+1)&MsgIdMask;

		DPF(9,"StartReliableSend: pSend %x assigning id x%x\n",pSend,pSession->LastMsg);
		
		pSend->messageid  =pSession->LastMsg;
		pSend->FrameSize  =pSession->MaxPacketSize-MAX_SEND_HEADER;

		// Calculate number of frames required for this send.
		pSend->nFrames    =(pSend->MessageSize/pSend->FrameSize);
		if(pSend->FrameSize*pSend->nFrames < pSend->MessageSize || !pSend->nFrames){
			pSend->nFrames++;
		}
		pSend->NR=0;
		pSend->FrameDataLen=0;// hack
		pSend->fSendSmall=pSession->fSendSmall;
		if(pSend->fSendSmall){
			pSend->SendSEQMSK = 0xFF;
		} else {
			pSend->SendSEQMSK = 0xFFFF;
		}

	} else {
#if 0	
		if (pSession->fSendSmall && pSession->FirstMsg < 0xFF-MAX_SMALL_CSENDS){
			// Ran out of IDs, Transition to Large headers - but only if we aren't going
			// to confuse the wrapping code.
			DPF(8,"OUT OF IDS, RELIABLE SENDS GOING TO LARGE FRAMES\n");
			pSession->MaxCSends		= MAX_LARGE_CSENDS;
			pSession->WindowSize    = MAX_LARGE_WINDOW;
			pSession->fSendSmall    = FALSE;
			bTransition = TRUE;
		}
#endif
		bFoundSend=FALSE;
		
		if(pSend->SendState==Start){
			bFoundSend=FALSE;
			// Reliable, waiting for id.
			InterlockedIncrement(&pSession->nWaitingForMessageid);
			pSend->SendState=WaitingForId;
			DPF(9,"StartReliableSend: No Id's Avail: nWaitingForMessageid %x\n",pSession->nWaitingForMessageid);
#if 0			
			if(bTransition){
				UnWaitSends(pSession,TRUE);
				SetEvent(pSession->pProtocol->m_hSendEvent);
			}
#endif			
		} else {
			bFoundSend=FALSE;
			DPF(9,"Couldn't start reliable send on pSend %x State %d pSession %x\n",pSend,pSend->SendState,pSession);
			if(pSend->SendState!=WaitingForId){
				ASSERT(0);
			}
		}
	}
	
	return bFoundSend;
}


BOOL CheckUserTimeOut(PSEND pSend)
{
	if(pSend->dwTimeOut){
		if((timeGetTime()-pSend->dwSendTime) > pSend->dwTimeOut){
			pSend->SendState=UserTimeOut;
			return TRUE;
		} 
	}	
	return FALSE;
}
/*=============================================================================

	GetNextMessageToSend
    
    Description:

	Scans the send queue for a message that is the current priority and
	is in the ready to send state or throttled state (we shouldn't even
	get here unless the throttle was removed.)  If we find such a message
	we return a pointer to the caller.

	Adds a reference to the Send and the Session.

    Parameters:     

		PPROTOCOOL pProtocol - pointer to the PROTOCOL object to send packets on.

    Return Values:
	
		NULL  - no message should be sent.
		PSEND - message to send.

-----------------------------------------------------------------------------*/

PSEND GetNextMessageToSend(PPROTOCOL pProtocol)
{
	PSEND    pSend;
	BILINK  *pBilink;
	UINT     CurrentSendPri;
	BOOL     bFoundSend; 
	PSESSION pSession;

	UINT     MsgIdMask;

	Lock(&pProtocol->m_SendQLock);

	DPF(9,"==>GetNextMessageToSend\n");

Top:

	bFoundSend = FALSE;
	pProtocol->m_bRescanQueue=FALSE;
	
	if(EMPTY_BILINK(&pProtocol->m_GSendQ)){
		Unlock(&pProtocol->m_SendQLock);
		DPF(9,"GetNextMessageToSend: called with nothing in queue, heading for the door.\n");
		goto exit;
	}

	pBilink        = pProtocol->m_GSendQ.next;
	pSend          = CONTAINING_RECORD(pBilink, SEND, m_GSendQ);
	CurrentSendPri = pSend->Priority;

	while(pBilink != &pProtocol->m_GSendQ){

		pSession=pSend->pSession;
		ASSERT_SIGN(pSession, SESSION_SIGN);
		Lock(&pSession->SessionLock);

		if(pProtocol->m_bRescanQueue){
			DPF(9,"RESCAN of QUEUE FORCED IN GETNEXTMESSAGETOSEND\n");
			Unlock(&pSession->SessionLock);
			goto Top;
		}

		if(pSession->dwFlags & SESSION_UNTHROTTLED){
			// unthrottle happened, so rewind.
			DPF(9,"Unthrottling Session %x\n",pSession);
			pSession->dwFlags &= ~(SESSION_THROTTLED|SESSION_UNTHROTTLED);
		}

		Lock(&pSend->SendLock);
		
		switch(pSession->eState){

			case Open:

				if((pSend->dwFlags & DPSEND_GUARANTEE)?(pSession->fSendSmall):(pSession->fSendSmallDG)){
					MsgIdMask = 0xFF;
				} else {
					MsgIdMask = 0xFFFF;
				}

	
				if(!(pSend->dwFlags & ASEND_PROTOCOL) && (pSession->dwFlags & SESSION_THROTTLED)){
					// don't do sends on a throttled session, unless they are internal sends.
					break;
				}

				switch(pSend->SendState){

				
					case Start:
					case WaitingForId:

						DPF(9,"Found Send in State %d, try Going to Sending State\n",pSend->SendState);
						// Just starting, need an id.

						if(!(pSend->dwFlags & ASEND_PROTOCOL) && CheckUserTimeOut(pSend)){
							if(pSend->SendState==WaitingForId){
								// fixup WaitingForId count on timed out send.
								if(pSend->dwFlags&DPSEND_GUARANTEED){
									InterlockedDecrement(&pSession->nWaitingForMessageid);
								} else {
									InterlockedDecrement(&pSession->nWaitingForDGMessageid);
								}
							}
							bFoundSend=TRUE;
							break;
						}
							
						if(pSend->dwFlags&ASEND_PROTOCOL){
						
							DPF(9,"System Send in Start State, Going to Sending State\n");
							bFoundSend=TRUE;
							pSend->SendState=Sending;
							break;
							
						} else if(!(pSend->dwFlags&DPSEND_GUARANTEED)) {        

							//check_datagram: 
							bFoundSend=StartDatagramSend(pSession,pSend, MsgIdMask);

						} else {

							// NOT DataGram, .: reliable...
							//check_reliable: 
							bFoundSend=StartReliableSend(pSession,pSend, MsgIdMask);
							#ifdef DEBUG
								if(bFoundSend){
									BILINK *pBiSendWalker=pSend->SendQ.prev;
									PSEND pSendWalker;
									while(pBiSendWalker != &pSession->SendQ){
										pSendWalker=CONTAINING_RECORD(pBiSendWalker,SEND,SendQ);
										pBiSendWalker=pBiSendWalker->prev;
										if((pSendWalker->SendState==Start || pSendWalker->SendState==WaitingForId)&& 
											pSendWalker->dwFlags&DPSEND_GUARANTEED && 
											!(pSendWalker->dwFlags&ASEND_PROTOCOL) && 
											pSendWalker->Priority >= pSend->Priority){
											DPF(0,"Send %x got id %x but Send %x still in state %x on Session %x\n",pSend,pSend->messageid,pSendWalker,pSendWalker->SendState,pSession);
											DEBUG_BREAK();
										}
									}
								}
							#endif
						}
						if(bFoundSend){
							if(pSession->dwFlags & SESSION_THROTTLED)
							{
								pSend->SendState=Throttled;
								bFoundSend=FALSE;
							} else {
								pSend->SendState=Sending;
							}	
						}
						break;


					case ReadyToSend:
					
						DPF(9,"Found Send in ReadyToSend State, going to Sending State\n");
						bFoundSend=TRUE;
						if(pSession->dwFlags & SESSION_THROTTLED)
						{
							pSend->SendState=Throttled;
							bFoundSend=FALSE;
						} else {
							pSend->SendState=Sending;
						}	
						break;

						
					case Throttled:
					
						ASSERT(!(pSession->dwFlags & SESSION_THROTTLED));
						DPF(9,"Found Send in Throttled State, unthrottling going to Sending State\n");
						bFoundSend=TRUE;
						pSend->SendState=Sending;
						if(pSession->dwFlags & SESSION_THROTTLED)
						{
							pSend->SendState=Throttled;
							bFoundSend=FALSE;
						} else {
							pSend->SendState=Sending;
						}	
						break;


					case TimedOut:
					
						DPF(9,"Found TimedOut Send.\n");
						TimeOutSession(pSession);
						bFoundSend=TRUE;
						break;


					case Cancelled:
					
						bFoundSend=TRUE;
						break;


					default:        
						ASSERT(pSend->SendState <= Done);
						break;
				} /* end switch(SendState) */
				break;

			default:
				switch(pSend->SendState){
					case Sending:
					case Done:
						DPF(9,"GetNextMessageToSend: Session %x was in state %d ,pSend %x SendState %d, leaving...\n",pSession, pSession->eState, pSend, pSend->SendState);
						//bFoundSend=FALSE;
						break;

					case WaitingForAck:
						CancelRetryTimer(pSend);
						pSend->SendState=TimedOut;
						DPF(9,"Moved WaitingForAck send to TimedOut and returning pSession %x was in State %d pSend %x\n",pSession,pSession->eState,pSend);
						bFoundSend=TRUE;
						break;
						
					default:
						DPF(9,"GetNextMessageToSend: Session %x was in state %d ,returning pSend %x SendState %d\n",pSession, pSession->eState, pSend, pSend->SendState);
						bFoundSend=TRUE;
						break;
				}
				break;
				
		} /* end switch pSession->eState */     
				
		if(bFoundSend){
			if(AddSendRef(pSend,1)){
				InterlockedIncrement(&pSession->RefCount);
			} else {
				bFoundSend=FALSE;
			}
		} 

		Unlock(&pSend->SendLock);
			
		Unlock(&pSession->SessionLock);

		if(bFoundSend){
			if(pSend->NS==0){
				pSend->tLastACK=timeGetTime();
			}	
			break;
		} 

		pBilink=pBilink->next;
		pSend=CONTAINING_RECORD(pBilink, SEND, m_GSendQ);
		
	} /* end while (pBilink != &pProtocol->m_GSendQ) */

	Unlock(&pProtocol->m_SendQLock);
	
exit:
    if(bFoundSend){
    	DPF(9,"<==GetNextMessageToSend %x\n",pSend);
    	return pSend;
    } else {
    	DPF(9,"<==GetNextMessageToSend NULL\n");
    	return NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\protocol\psession.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    SESSION.C

Abstract:

	Management of the session structures

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
  12/10/96 aarono  Original
   6/6/98  aarono  Turn on throttling and windowing
   2/12/00 aarono  Concurrency issues, fix VOL usage and Refcount

--*/

#include <windows.h>
#include "newdpf.h"
#include <mmsystem.h>
#include <dplay.h>
#include <dplaysp.h>
#include <dplaypr.h>
#include "mydebug.h"
#include "arpd.h"
#include "arpdint.h"
#include "macros.h"
#include "mytimer.h"

/*=============================================================================

  Note on Session Locking and reference counting:
  ===============================================

  Sessions have a refcount that controls their existence.  When the refcount
  is non-zero, the session continues to exist.  When the refcount hits zero,
  the session is destroyed.
	
  On creation, the refcount for a session is set to 1.  Sessions are created
  when DirectPlay calls ProtocolCreatePlayer.  The session state is set to 
  Running during creation.  Each Session created also creates a reference
  count on the Protocol object.  This is so that the protocol does not
  shut down before all Sessions have been closed.

  When DirectPlay calls ProtocolDeletePlayer, the session's state is set
  to Closing and the reference count is reduced by one.  We then must wait
  until the session has been destroyed before we return from 
  ProtocolDeletePlayer, otherwise, the id may be recycled before we have
  freed up the slot in the session.

  Sends do NOT create references on the Session.  When a send thread starts
  referencing a Send, it creates a reference on the session the send is
  on.  When the send thread is no longer referencing the send, it deletes
  its' reference on the session.  When the reference count on the session
  is 0, it is safe to complete all pending sends with an error and free
  their resources. 

  Receives do NOT create references on the Session.  When the protocol's
  receive handler is called, a reference to the Session is created on 
  behalf of the receive thread.  When the receive thread is done processing,
  the reference is removed.  This prevents the Session from going away
  while a receive thread is processing.  When the reference count on the
  session is 0, it is safe to throw out all pending receives.  Ideally an
  ABORT message of some kind should be sent to the transmitter, but this
  is optional since it should time-out the transaction.

  If the reference count on the session hits 0, the session must be shut
  down and freed.  All pending sends are completed with an error.  All
  pending receives are thrown out and cleaned up.  All pending stats are
  thrown out.


	Session States:
    ===============
	Open     - set at creation.
	
	Closing  - set when we receive a call to ProtocolDeletePlayer.
	           No new receives or sends are accepted in closing state.
	           
	Closed   - Refcount is 0, we are now freeing everything.

-----------------------------------------------------------------------------*/

/*=============================================================================

	pPlayerFromId()

    Description:

    Parameters:     

    Return Values:

-----------------------------------------------------------------------------*/

LPDPLAYI_PLAYER pPlayerFromId(PPROTOCOL pProtocol, DPID idPlayer)
{
	LPDPLAYI_PLAYER pPlayer;
	LPDPLAYI_DPLAY lpDPlay;
	UINT index;

	lpDPlay=pProtocol->m_lpDPlay;

	if(idPlayer == DPID_SERVERPLAYER){
		pPlayer = lpDPlay->pServerPlayer;
	} else {
		index   = ((idPlayer ^ pProtocol->m_dwIDKey)&INDEX_MASK);
		ASSERT(index < 65535);
		pPlayer = (LPDPLAYI_PLAYER)(lpDPlay->pNameTable[index].dwItem);	
	}
	return pPlayer;
}

/*=============================================================================

	CreateNewSession

    Description:

    Parameters:     


    Return Values:



-----------------------------------------------------------------------------*/
HRESULT	CreateNewSession(PPROTOCOL pProtocol, DPID idPlayer)
{
	DWORD        dwUnmangledID;
	DWORD        iPlayer;
	DWORD        iSysPlayer;

	UINT         i;

	HRESULT      hr=DPERR_NOMEMORY;

	PSESSION     (*pSessionsNew)[];
	PSESSION     pSession;

	LPDPLAYI_PLAYER pPlayer;

	if(idPlayer != DPID_SERVERPLAYER) {

		// Convert the ID to an integer
		dwUnmangledID = idPlayer ^ pProtocol->m_dwIDKey;
	    iPlayer = dwUnmangledID & INDEX_MASK; 

		pPlayer=(LPDPLAYI_PLAYER)(pProtocol->m_lpDPlay->pNameTable[iPlayer].dwItem);
		ASSERT(pPlayer);

		// Note: System players are always created before non-system players.
		dwUnmangledID = pPlayer->dwIDSysPlayer ^ pProtocol->m_dwIDKey;
		iSysPlayer = dwUnmangledID & INDEX_MASK;

#ifdef DEBUG
		if(iSysPlayer==iPlayer){
			DPF(9,"PROTOCOL: CREATING SYSTEM PLAYER\n");
		}
#endif	

		DPF(9,"PROTOCOL: Creating Player id x%x %dd iPlayer %d iSysPlayer %d\n",idPlayer, idPlayer, iPlayer, iSysPlayer);

		if(iPlayer >= 0xFFFF){
			// use 0xFFFF to map messages starting in 'play' to 'pl'0xFFFF
			// so we can't have a real player at this iPlayer.
			DPF(0,"PROTOCOL: not allowing creation of player iPlayer %x\n",iPlayer);
			goto exit;
		}

		Lock(&pProtocol->m_SessionLock);

		//
		// Adjust session list size (if necessary).
		//
		if(pProtocol->m_SessionListSize <= iPlayer){
			// not long enough, reallocate - go over 16 to avoid thrashing on every one.
			pSessionsNew=My_GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT,(iPlayer+16)*sizeof(PSESSION));
			if(pSessionsNew){
				// Copy the old entries to the new list.
				if(pProtocol->m_pSessions){
					for(i=0;i<pProtocol->m_SessionListSize;i++){
						(*pSessionsNew)[i]=(*pProtocol->m_pSessions)[i];
					}
					// Free the old list.
					My_GlobalFree(pProtocol->m_pSessions);
				}
				// Put the new list in its place.
				pProtocol->m_pSessions=pSessionsNew;
				pProtocol->m_SessionListSize=iPlayer+16;
				DPF(9,"PROTOCOL: Grew sessionlist to %d entries\n",pProtocol->m_SessionListSize);
			}
		}

		// Allocate a session

		pSession=(PSESSION)My_GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, sizeof(SESSION));

		if(!pSession){
			goto exit2;
		}

		(*pProtocol->m_pSessions)[iPlayer]=pSession;
	
	} else {
		// SERVERPLAYER

		pPlayer = pPlayerFromId(pProtocol,idPlayer);
		iPlayer = SERVERPLAYER_INDEX;
		
		Lock(&pProtocol->m_SessionLock);
		
		pSession=(PSESSION)My_GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, sizeof(SESSION));

		if(!pSession){
			goto exit2;
		}
		
		ASSERT(!pProtocol->m_pServerPlayerSession);
		pProtocol->m_pServerPlayerSession=pSession;

		ASSERT(pPlayer->dwIDSysPlayer != DPID_SERVERPLAYER);

		// Note: System players are always created before non-system players.
		dwUnmangledID = pPlayer->dwIDSysPlayer ^ pProtocol->m_dwIDKey;
		iSysPlayer = dwUnmangledID & INDEX_MASK;

		DPF(8,"PROTOCOL:CreatePlayer: Creating SERVERPLAYER: pPlayer %x iPlayer %x iSysPlayer %x\n",pPlayer,iPlayer,iSysPlayer);
	}
	
	pProtocol->m_nSessions++;
	
	//
	// Session structure initialization
	//

	SET_SIGN(pSession, SESSION_SIGN);
	
	pSession->pProtocol=pProtocol;

	InitializeCriticalSection(&pSession->SessionLock);
	pSession->RefCount=1; // One Ref for creation.
	pSession->eState=Open;
	
	// Initialize the SendQ
	InitBilink(&pSession->SendQ);
	
	pSession->dpid=idPlayer;
	pSession->iSession=iPlayer;
	pSession->iSysPlayer=iSysPlayer;

	InitializeCriticalSection(&pSession->SessionStatLock);
	InitBilink(&pSession->DGStatList);
	pSession->DGFirstMsg = 0;
	pSession->DGLastMsg = 0;
	pSession->DGOutMsgMask = 0;
	pSession->nWaitingForDGMessageid=0;
	
	pSession->FirstMsg = 0;
	pSession->LastMsg  = 0;
	pSession->OutMsgMask = 0;
	pSession->nWaitingForMessageid=0;

	// we start the connection using small headers, if we see we can
	// get better perf with a large header during operation, then we
	// switch to the large header.
	pSession->MaxCSends     = 1;/*MAX_SMALL_CSENDS	- initial values adjusted after 1st ACK*/ 
	pSession->MaxCDGSends   = 1;/*MAX_SMALL_DG_CSENDS*/
	pSession->WindowSize	= 1;/*MAX_SMALL_WINDOW*/
	pSession->DGWindowSize  = 1;/*MAX_SMALL_WINDOW*/
	pSession->fFastLink     = FALSE; // start assuming slow link.
	pSession->fSendSmall    = TRUE; 
	pSession->fSendSmallDG  = TRUE;
	pSession->fReceiveSmall = TRUE;
	pSession->fReceiveSmallDG = TRUE;

#if 0
	// use this code to START with large packet headers
	pSession->MaxCSends		= MAX_LARGE_CSENDS;
	pSession->MaxCDGSends   = MAX_LARGE_DG_CSENDS;
	pSession->WindowSize	= MAX_LARGE_WINDOW;
	pSession->DGWindowSize  = MAX_LARGE_WINDOW;
	pSession->fSendSmall    = FALSE;
	pSession->fSendSmallDG  = FALSE;
#endif

	pSession->MaxPacketSize = pProtocol->m_dwSPMaxFrame; 
	

	pSession->FirstRlyReceive=pSession->LastRlyReceive=0;
	pSession->InMsgMask = 0;
	
	InitBilink(&pSession->pRlyReceiveQ);
	InitBilink(&pSession->pDGReceiveQ);
	InitBilink(&pSession->pRlyWaitingQ);

	InitSessionStats(pSession);

	pSession->SendRateThrottle = 28800;
	pSession->FpAvgUnThrottleTime = Fp(1); // assume 1 ms to schedule unthrottle (first guess)
	pSession->tNextSend=pSession->tLastSAK=timeGetTime();
	
	Unlock(&pProtocol->m_SessionLock);

	hr=DP_OK;

exit:
	return hr;

exit2:
	hr=DPERR_OUTOFMEMORY;
	return hr;
}

/*=============================================================================

    GetDPIDIndex - lookup a session based on the Index
    
    Description:

    Parameters:     

		DWORD index	- Find the dpid for this index

    Return Values:

		DPID - dpid of the index

-----------------------------------------------------------------------------*/


DPID GetDPIDByIndex(PPROTOCOL pProtocol, DWORD index)
{
	PSESSION pSession;
	DPID     dpid;

	Lock(&pProtocol->m_SessionLock);

	if(index == SERVERPLAYER_INDEX){
		dpid=DPID_SERVERPLAYER;
	} else if(index < pProtocol->m_SessionListSize && 
	         (pSession=(*pProtocol->m_pSessions)[index]))
	{
		Lock(&pSession->SessionLock);
		dpid=pSession->dpid;
		Unlock(&pSession->SessionLock);
	} else {
		dpid=0xFFFFFFFF;
		DPF(1,"GetDPIDByIndex, no id at index %d player may me gone or not yet created locally.\n",index);
	}
	
	Unlock(&pProtocol->m_SessionLock);
	return dpid;
}

WORD GetIndexByDPID(PPROTOCOL pProtocol, DPID dpid)
{
	DWORD dwUnmangledID;
	if(dpid == DPID_SERVERPLAYER){
		return SERVERPLAYER_INDEX;
	}
	dwUnmangledID = dpid ^ pProtocol->m_dwIDKey;
    return (WORD)(dwUnmangledID & INDEX_MASK); 
    
}
/*=============================================================================

    GetSysSessionByIndex - lookup a session based on the Index
    
    Description:

    Parameters:     

		DWORD index	- Find the session for this index

    Return Values:

    	NULL - if the SESSION is not found, 
    	else	   pointer to the Session.

	Notes:

		Adds a reference to the SESSION.  When done with the session pointer
		the caller must call DecSessionRef.

-----------------------------------------------------------------------------*/


PSESSION GetSysSessionByIndex(PPROTOCOL pProtocol, DWORD index)
{
	PSESSION pSession;
	
	Lock(&pProtocol->m_SessionLock);

	DPF(9,"==>GetSysSessionByIndex at index x%x\n", index);

	if( (index < pProtocol->m_SessionListSize) || (index == SERVERPLAYER_INDEX) ){

		// ptr to session at requested index.
		if(index == SERVERPLAYER_INDEX){
			pSession = pProtocol->m_pServerPlayerSession;
		} else {
			pSession = (*pProtocol->m_pSessions)[index];
		}	

		if(pSession){
			// ptr to system session for session at requested index.
			pSession=(*pProtocol->m_pSessions)[pSession->iSysPlayer];
			if(pSession){
				Lock(&pSession->SessionLock);
				if(pSession->eState==Open){
					InterlockedIncrement(&pSession->RefCount);
					Unlock(&pSession->SessionLock);
				} else {
					// Session is closing or closed, don't give ptr.
					Unlock(&pSession->SessionLock);
					pSession=NULL;
				}
			} 
		}
	} else {
		pSession=NULL;
	}

	DPF(9,"<===GetSysSessbyIndex pSession %x\n",pSession);
	
	Unlock(&pProtocol->m_SessionLock);
	return pSession;
}

/*=============================================================================

    GetSysSession - lookup a the system session of a session based on the DPID
    
    Description:

    Parameters:     

		DPID idPlayer	- Find the session for this player.

    Return Values:

    	NULL - if the SESSION is not found, or the DPID has been re-cycled.
    	else	   pointer to the Session.

	Notes:

		Adds a reference to the SESSION.  When done with the session pointer
		the caller must call DecSessionRef.

-----------------------------------------------------------------------------*/


PSESSION GetSysSession(PPROTOCOL pProtocol, DPID idPlayer)
{
	PSESSION pSession;
	DWORD    dwUnmangledID;
	DWORD    index;
	
	Lock(&pProtocol->m_SessionLock);

	if(idPlayer != DPID_SERVERPLAYER){
		dwUnmangledID = idPlayer ^ pProtocol->m_dwIDKey;
	    index = dwUnmangledID & INDEX_MASK; 
		pSession=(*pProtocol->m_pSessions)[index];
	} else {
		pSession=pProtocol->m_pServerPlayerSession;
	}

	if(pSession){

		if(pSession->dpid == idPlayer){
			pSession=(*pProtocol->m_pSessions)[pSession->iSysPlayer];
			if(pSession){
				Lock(&pSession->SessionLock);
				if(pSession->eState == Open){
					InterlockedIncrement(&pSession->RefCount);
					Unlock(&pSession->SessionLock);
				} else {
					// Closing, don't return value
					Unlock(&pSession->SessionLock);
					pSession=NULL;
				}
			} else {
				DPF(0,"GetSysSession: Looking on Session, Who's SysSession is gone!\n");
				ASSERT(0);
			}
			
		} else {
			DPF(1,"PROTOCOL: got dplay id that has been recycled (%x), now (%x)?\n",idPlayer,pSession->dpid);
			ASSERT(0);
			pSession=NULL;
		}
	}
	
	Unlock(&pProtocol->m_SessionLock);
	return pSession;
}

/*=============================================================================

    GetSession - lookup a session based on the DPID
    
    Description:

    Parameters:     

		DPID idPlayer	- Find the session for this player.

    Return Values:

    	NULL - if the SESSION is not found, or the DPID has been re-cycled.
    	else	   pointer to the Session.

	Notes:

		Adds a reference to the SESSION.  When done with the session pointer
		the caller must call DecSessionRef.

-----------------------------------------------------------------------------*/


PSESSION GetSession(PPROTOCOL pProtocol, DPID idPlayer)
{
	PSESSION pSession;
	DWORD    dwUnmangledID;
	DWORD    index;
	
	Lock(&pProtocol->m_SessionLock);

	if(idPlayer != DPID_SERVERPLAYER){
		dwUnmangledID = idPlayer ^ pProtocol->m_dwIDKey;
	    index = dwUnmangledID & INDEX_MASK; 
		pSession=(*pProtocol->m_pSessions)[index];
	} else {
		pSession=pProtocol->m_pServerPlayerSession;
	}

	if(pSession){

		if(pSession->dpid == idPlayer){
			Lock(&pSession->SessionLock);
			InterlockedIncrement(&pSession->RefCount);
			Unlock(&pSession->SessionLock);
		} else {
			DPF(1,"PROTOCOL: got dplay id that has been recycled (%x), now (%x)?\n",idPlayer,pSession->dpid);
			ASSERT(0);
			pSession=NULL;
		}
	}
	
	Unlock(&pProtocol->m_SessionLock);
	return pSession;
}

VOID ThrowOutReceiveQ(PPROTOCOL pProtocol, BILINK *pHead)
{
	PRECEIVE pReceiveWalker;
	BILINK *pBilink;
	
	pBilink = pHead->next;
	while( pBilink != pHead ){
		pReceiveWalker=CONTAINING_RECORD(pBilink, RECEIVE, pReceiveQ);
		ASSERT_SIGN(pReceiveWalker, RECEIVE_SIGN);
		ASSERT(!pReceiveWalker->fBusy);
		pBilink=pBilink->next;
		Lock(&pReceiveWalker->ReceiveLock);
		if(!pReceiveWalker->fBusy){
			Delete(&pReceiveWalker->pReceiveQ);
			Unlock(&pReceiveWalker->ReceiveLock);
			DPF(8,"Throwing Out Receive %x from Q %x\n",pReceiveWalker, pHead);
			FreeReceive(pProtocol,pReceiveWalker);
		} else {
			Unlock(&pReceiveWalker->ReceiveLock); 
		}	
	}	
}

/*=============================================================================

    DecSessionRef
    
    Description:

    Parameters:     

    Return Values:

-----------------------------------------------------------------------------*/

INT DecSessionRef(PSESSION pSession)
{
	PPROTOCOL pProtocol;
	INT count;

	PSEND pSendWalker;
	BILINK *pBilink;

	if(!pSession){
		return 0;
	}

	count = InterlockedDecrement(&pSession->RefCount);

	if(!count){

		// No more references!  Blow it away.
		DPF(9,"DecSessionRef:(firstchance) pSession %x, count=%d, Session Closed, called from %x \n",pSession,count,_ReturnAddress());
	
		pProtocol=pSession->pProtocol;

		Lock(&pProtocol->m_SessionLock);
		Lock(&pSession->SessionLock);
		
		if(!pSession->RefCount){
			// Remove any referece to the session from the protocol.
			if(pSession->iSession != SERVERPLAYER_INDEX){
				(*pProtocol->m_pSessions)[pSession->iSession]=NULL;
			} else {
				pProtocol->m_pServerPlayerSession=NULL;
			}
			pProtocol->m_nSessions--;
		} else {
			count=pSession->RefCount;
		}	

		Unlock(&pSession->SessionLock);
		Unlock(&pProtocol->m_SessionLock);

		// Session is floating free and we own it.  No one can reference
		// so we can safely blow it all away, don't need to lock during
		// these ops since no-one can reference any more...

		if(!count){

			DPF(9,"DecSessionRef(second chance): pSession %x, count=%d, Session Closed, called from %x \n",pSession,count,_ReturnAddress());
			//DEBUG_BREAK();
			pSession->eState=Closed;

			if(pSession->uUnThrottle){
				//timeKillEvent(pSession->uUnThrottle);
				CancelMyTimer(pSession->uUnThrottle, pSession->UnThrottleUnique);
			}

			// Free up Datagram send statistics.
			DeleteCriticalSection(&pSession->SessionStatLock);
			pBilink=pSession->DGStatList.next;
			while(pBilink != & pSession->DGStatList){
				PSENDSTAT pStat = CONTAINING_RECORD(pBilink, SENDSTAT, StatList);
				pBilink=pBilink->next;
				ReleaseSendStat(pStat);
			}
			
			// Complete pending sends.
			pBilink=pSession->SendQ.next;
			while(pBilink!=&pSession->SendQ){
				pSendWalker=CONTAINING_RECORD(pBilink, SEND, SendQ);
				pBilink=pBilink->next;
				
				CancelRetryTimer(pSendWalker);
				DoSendCompletion(pSendWalker, DPERR_CONNECTIONLOST);
				DecSendRef(pProtocol, pSendWalker);
					
			}
			
			//
			// throw out pending receives.
			//

			ThrowOutReceiveQ(pProtocol, &pSession->pDGReceiveQ);
			ThrowOutReceiveQ(pProtocol, &pSession->pRlyReceiveQ);
			ThrowOutReceiveQ(pProtocol, &pSession->pRlyWaitingQ);
			
			//
			// Free the session
			//
			if(pSession->hClosingEvent){
				DPF(5,"DecSessionRef: pSession %x Told Protocol DeletePlayer to continue\n",pSession);
				SetEvent(pSession->hClosingEvent);
			}
			UNSIGN(pSession->Signature);
			DeleteCriticalSection(&pSession->SessionLock);
			My_GlobalFree(pSession);
		}
		
	} else {
		DPF(9,"DecSessionRef: pSession %x count %d, called from %x\n",pSession, count, _ReturnAddress());
	}
	
	return count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\serial\bilink.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    BILINK.C

Abstract:

    Management for doubly linked lists

Author:

    George Joy

Environment:

    32-bit 'C'

Revision History:

--*/
#include <windows.h>
#include <dpf.h>
#include "bilink.h"

// Note: serialization of access to BILINK structures must 
//       take place in the calling code.  Operations are
//       not intrinsically atomic.

#ifdef DEBUG
int FindObject(
    BILINK *link,
    BILINK *list
    )
{
    BILINK *p = list->next;
    while(p != link && p != list)
        p= p->next;
    return (p==link);
}
#endif

void InsertAfter(
    BILINK *in,
    BILINK *after
    )
/*=========================================================================
 *  Description:
 *      Insert an object after a specified object in the doubly linked list.
 *      The after object could be the Head BILINK for adding to the head of a
 *      queue.
 *  Returns:
 *
 */
{
    #ifdef DEBUG
    if(FindObject(in,after)) {
        DPF(0,"Attempt to re-insert object in BILINK queue\n");
        DEBUG_BREAK();
    }
    #endif
    in->next = after->next;
    in->prev = after;
    after->next->prev = in;
    after->next = in;
}

void InsertBefore(
     BILINK *in,
     BILINK *before
    )
/*=========================================================================
 *  Description:
 * Inserts an  object before a specified object in the doubly linked list.
 * The before object could be the Head BILINK for adding to the end
 * of the queue
 * CALLED WITH INTERRUPTS_OFF
 *
 *  Returns:
 *
 */
{
    #ifdef DEBUG
    if(FindObject(in,before)) {
        DPF(0,"Attempt to re-insert object in BILINK queue\n");
        DEBUG_BREAK();
    }
    #endif
    in->next = before;
    in->prev = before->prev;
    before->prev->next = in;
    before->prev = in;
}

void Delete(
     BILINK *p
)
/*=========================================================================
 *  Description:
 *
 * Delete a  object from a doubly linked list. Make sure it IS on a list!
 * CALLED WITH INTERRUPTS OFF (must be atomic).
 *
 *  Returns:
 *
 */
{
    p->next->prev = p->prev;
    p->prev->next = p->next;
    // p->next = p->prev = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\protocol\timer.c ===
/*++

Copyright (c) 1996,1997  Microsoft Corporation

Module Name:

    TIMER.C

Abstract:

	Handle adjusting timer resolution for throttling and do thread pool

Author:

	Aaron Ogus (aarono)

Environment:

	Win32

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
   6/04/98 aarono  Original

--*/

#include <windows.h>
#include "newdpf.h"
#include <mmsystem.h>
#include <dplay.h>
#include <dplaysp.h>
#include <dplaypr.h>
#include "mydebug.h"
#include "arpd.h"
#include "arpdint.h"
#include "macros.h"
#include "mytimer.h"


#define DEFAULT_TIME_RESOLUTION 20	/* ms */
#define MIN_TIMER_THREADS	1
#define MAX_TIMER_THREADS 5


VOID QueueTimeout(PMYTIMER pTimer);
DWORD WINAPI TimerWorkerThread(LPVOID foo);


// Timer Resolution adjustments;
DWORD dwOldPeriod=DEFAULT_TIME_RESOLUTION; 
DWORD dwCurrentPeriod=DEFAULT_TIME_RESOLUTION;
DWORD dwPeriodInUse=DEFAULT_TIME_RESOLUTION;


BILINK MyTimerList={&MyTimerList, &MyTimerList};
CRITICAL_SECTION MyTimerListLock;

LPFPOOL pTimerPool=NULL;
DWORD uWorkaroundTimerID;

DWORD twInitCount=0;	//number of times init called, only inits on 0->1, deinit on 1->0

DWORD Unique=0;


CRITICAL_SECTION ThreadListLock;		// locks ALL this stuff.

BILINK ThreadList={&ThreadList,&ThreadList};	// ThreadPool grabs work from here.

DWORD nThreads=0;		// number of running threads.
DWORD ActiveReq=0;		// number of requests being processed.
DWORD PeakReqs=0;
DWORD bShutDown=FALSE;
DWORD bAlreadyCleanedUp=FALSE;
DWORD KillCount=0;
DWORD ExtraSignals=0;

HANDLE hWorkToDoSem;
HANDLE hShutDownPeriodicTimer;

DWORD_PTR uAdjustResTimer=0;
DWORD AdjustResUnique=0;

DWORD_PTR uAdjustThreadsTimer=0;
DWORD AdjustThreadsUnique=0;

// Sometimes scheduled retry timers don't run.  This runs every 10 seconds to catch
// timers that should have been expired.
void CALLBACK PeriodicTimer (UINT uID, UINT uMsg, DWORD_PTR dwUser, DWORD_PTR dw1, DWORD_PTR dw2)
{
	DWORD  time;
	PMYTIMER  pTimerWalker;
	BILINK *pBilink;
	DWORD dwReleaseCount=0;
	DWORD slowcount=0;

	if(bShutDown){
		if(!InterlockedExchange(&bAlreadyCleanedUp,1)){
			while(nThreads && slowcount < (60000/50)){	// don't wait more than 60 seconds.
				slowcount++;
				Sleep(50);
			}
			if(!nThreads){ // better to leak than to crash.
				DeleteCriticalSection(&MyTimerListLock);
				DeleteCriticalSection(&ThreadListLock);
			}	
			timeKillEvent(uID);
			ASSERT(hShutDownPeriodicTimer);
			SetEvent(hShutDownPeriodicTimer);
		}	
		return;
	}

	time=timeGetTime()+(dwCurrentPeriod/2);
		
	Lock(&MyTimerListLock);
	Lock(&ThreadListLock);

	pBilink=MyTimerList.next;

	while(pBilink!=&MyTimerList){
	
		pTimerWalker=CONTAINING_RECORD(pBilink, MYTIMER, Bilink);
		pBilink=pBilink->next;

		if(((INT)(time-pTimerWalker->TimeOut) > 0)){
			Delete(&pTimerWalker->Bilink);
			InsertBefore(&pTimerWalker->Bilink, &ThreadList);
			pTimerWalker->TimerState=QueuedForThread;
			dwReleaseCount++;
		} else {
			break;
		}

	}

	ActiveReq += dwReleaseCount;
	if(ActiveReq > PeakReqs){
		PeakReqs=ActiveReq;
	}
	
	ReleaseSemaphore(hWorkToDoSem,dwReleaseCount,NULL);

	Unlock(&ThreadListLock);
	Unlock(&MyTimerListLock);

}

#define min(a,b)            (((a) < (b)) ? (a) : (b))

VOID CALLBACK AdjustTimerResolution(UINT_PTR uID, UINT uMsg, DWORD_PTR dwUser, DWORD dw1, DWORD dw2)
{
	DWORD dwWantPeriod;

	dwWantPeriod=min(dwCurrentPeriod,dwOldPeriod);
	dwOldPeriod=dwCurrentPeriod;
	dwCurrentPeriod=DEFAULT_TIME_RESOLUTION;
	
	if(dwPeriodInUse != dwWantPeriod){
		dwPeriodInUse=dwWantPeriod;
		timeKillEvent(uWorkaroundTimerID);
		uWorkaroundTimerID=timeSetEvent(dwPeriodInUse, dwPeriodInUse, PeriodicTimer, 0, TIME_PERIODIC); 
	}
	uAdjustResTimer=SetMyTimer(1000,500,AdjustTimerResolution,0,&AdjustResUnique);
}

VOID CALLBACK AdjustThreads(UINT_PTR uID, UINT uMsg, DWORD_PTR dwUser, DWORD dw1, DWORD dw2)
{
	Lock(&ThreadListLock);
	if((PeakReqs < nThreads) && nThreads){
		KillCount=nThreads-PeakReqs;
		ReleaseSemaphore(hWorkToDoSem, KillCount, NULL);
	}
	PeakReqs=0;
	Unlock(&ThreadListLock);
	
	uAdjustThreadsTimer=SetMyTimer(60000,500,AdjustThreads,0,&AdjustThreadsUnique);
}

VOID SetTimerResolution(UINT msResolution)
{

	if(!msResolution || msResolution >= 20){
		return;
	}

	if(msResolution < dwCurrentPeriod){
		dwCurrentPeriod=msResolution;
	}
	
}

DWORD_PTR SetMyTimer(DWORD dwTimeOut, DWORD TimerRes, MYTIMERCALLBACK TimerCallBack, DWORD_PTR UserContext, PUINT pUnique)
{

	BILINK *pBilink;
	PMYTIMER pMyTimerWalker,pTimer;
	DWORD time;
	BOOL bInserted=FALSE;

	pTimer=pTimerPool->Get(pTimerPool);
	
	if(!pTimer){
		*pUnique=0;
		return 0;
	}

	pTimer->CallBack=TimerCallBack;
	pTimer->Context=UserContext;

	SetTimerResolution(TimerRes);
	
	Lock(&MyTimerListLock);
	
		++Unique;
		if(Unique==0){
			++Unique;
		}
		*pUnique=Unique;

		pTimer->Unique=Unique;
	
		time=timeGetTime();
		pTimer->TimeOut=time+dwTimeOut;
		pTimer->TimerState=WaitingForTimeout;
	

		// Insert this guy in the list by timeout time.
		pBilink=MyTimerList.prev;
		while(pBilink != &MyTimerList){
			pMyTimerWalker=CONTAINING_RECORD(pBilink, MYTIMER, Bilink);
			pBilink=pBilink->prev;
			
			if((int)(pTimer->TimeOut-pMyTimerWalker->TimeOut) > 0 ){
				InsertAfter(&pTimer->Bilink, &pMyTimerWalker->Bilink);
				bInserted=TRUE;
				break;
			}
		}

		if(!bInserted){
			InsertAfter(&pTimer->Bilink, &MyTimerList);
		}
	
	Unlock(&MyTimerListLock);

	return (DWORD_PTR)pTimer;
}


HRESULT CancelMyTimer(DWORD_PTR dwTimer, DWORD Unique)
{
	PMYTIMER pTimer=(PMYTIMER)dwTimer;
	HRESULT hr=DPERR_GENERIC;
	
	Lock(&MyTimerListLock);
	Lock(&ThreadListLock);

	if(pTimer->Unique == Unique){
		switch(pTimer->TimerState){
			case WaitingForTimeout:
				Delete(&pTimer->Bilink);
				pTimer->TimerState=End;
				pTimer->Unique=0;
				pTimerPool->Release(pTimerPool, pTimer);
				hr=DP_OK;
				break;

			case QueuedForThread:
				Delete(&pTimer->Bilink);
				pTimer->TimerState=End;
				pTimer->Unique=0;
				pTimerPool->Release(pTimerPool, pTimer);
				if(ActiveReq)ActiveReq--;
				ExtraSignals++;
				hr=DP_OK;
				break;

			default:
				break;
		}
	}

	Unlock(&ThreadListLock);
	Unlock(&MyTimerListLock);
	return hr;
}

HRESULT InitTimerWorkaround()
{
	DWORD dwJunk;
	HANDLE hWorker=NULL;

	if(twInitCount++){//DPLAY LOCK HELD DURING CALL
		return DP_OK;
	}
	
    pTimerPool=NULL;
    nThreads=0;		// number of running threads.
    ActiveReq=0;		// number of requests being processed.
    PeakReqs=0;
    bShutDown=FALSE;
    KillCount=0;
	ExtraSignals=0;
	bAlreadyCleanedUp=FALSE;
	hWorkToDoSem=0;
	hShutDownPeriodicTimer=0;
	uAdjustResTimer=0;
	uAdjustThreadsTimer=0;
	uWorkaroundTimerID=0;

	hWorkToDoSem=CreateSemaphoreA(NULL,0,65535,NULL);
	hShutDownPeriodicTimer=CreateEventA(NULL,FALSE,FALSE,NULL);

	InitializeCriticalSection(&MyTimerListLock);
	InitializeCriticalSection(&ThreadListLock);

	pTimerPool=FPM_Init(sizeof(MYTIMER),NULL,NULL,NULL);
	
	
	if(!hWorkToDoSem || !pTimerPool || !hShutDownPeriodicTimer){
		FiniTimerWorkaround();
		return DPERR_OUTOFMEMORY;
	}

	uWorkaroundTimerID=timeSetEvent(DEFAULT_TIME_RESOLUTION, DEFAULT_TIME_RESOLUTION, PeriodicTimer, 0, TIME_PERIODIC); 

	if(!uWorkaroundTimerID){
		FiniTimerWorkaround();
		return DPERR_OUTOFMEMORY;
	}

	nThreads=1;
	hWorker=CreateThread(NULL,4096, TimerWorkerThread, NULL, 0, &dwJunk);
	if(!hWorker){
		nThreads=0;
		FiniTimerWorkaround();
		return DPERR_OUTOFMEMORY;
	}
	CloseHandle(hWorker);

	uAdjustResTimer=SetMyTimer(1000,500,AdjustTimerResolution,0,&AdjustResUnique);
	uAdjustThreadsTimer=SetMyTimer(60000,500,AdjustThreads,0,&AdjustThreadsUnique);
	
	
	return DP_OK;

}

VOID FiniTimerWorkaround()
{
	UINT slowcount=0;
	BILINK *pBilink;
	PMYTIMER pTimer;

	if(--twInitCount){ //DPLAY LOCK HELD DURING CALL
		return;
	}

	if(uAdjustResTimer){
		CancelMyTimer(uAdjustResTimer, AdjustResUnique);
	}
	if(uAdjustThreadsTimer){
		CancelMyTimer(uAdjustThreadsTimer, AdjustThreadsUnique);
	}	
	//ASSERT_EMPTY_BILINK(&MyTimerList);
	//ASSERT_EMPTY_BILINK(&ThreadList);
	bShutDown=TRUE;
	ReleaseSemaphore(hWorkToDoSem,10000,NULL);
	while(nThreads && slowcount < (60000/50)){	// don't wait more than 60 seconds.
		slowcount++;
		Sleep(50);
	}
	
	if(uWorkaroundTimerID){
		if(hShutDownPeriodicTimer){
			WaitForSingleObject(hShutDownPeriodicTimer,INFINITE);
		}	
	} else {
		DeleteCriticalSection(&MyTimerListLock);
		DeleteCriticalSection(&ThreadListLock);
	}	

	if(hShutDownPeriodicTimer){
		CloseHandle(hShutDownPeriodicTimer);
		hShutDownPeriodicTimer=0;
	}

	CloseHandle(hWorkToDoSem);

	while(!EMPTY_BILINK(&MyTimerList)){
		pBilink=MyTimerList.next;
		pTimer=CONTAINING_RECORD(pBilink, MYTIMER, Bilink);
		pTimer->Unique=0;
		pTimer->TimerState=End;
		Delete(&pTimer->Bilink);
		pTimerPool->Release(pTimerPool, pTimer);
	}

	while(!EMPTY_BILINK(&MyTimerList)){
		pBilink=ThreadList.next;
		pTimer=CONTAINING_RECORD(pBilink, MYTIMER, Bilink);
		pTimer->Unique=0;
		pTimer->TimerState=End;
		Delete(&pTimer->Bilink);
		pTimerPool->Release(pTimerPool, pTimer);
	}
	
	if(pTimerPool){
		pTimerPool->Fini(pTimerPool,FALSE);
		pTimerPool=NULL;
	}
}


DWORD WINAPI TimerWorkerThread(LPVOID foo)
{
	BILINK *pBilink;
	PMYTIMER pTimer;
	HANDLE hNewThread;
	DWORD dwJunk;
	
	while (1){
	
		WaitForSingleObject(hWorkToDoSem, INFINITE);

		Lock(&ThreadListLock);

			if(bShutDown || (KillCount && nThreads > 1)){
				nThreads--;
				if(KillCount && !bShutDown){
					KillCount--;
				}	
				Unlock(&ThreadListLock);
				break;	
			}

			if(ExtraSignals){
				ExtraSignals--;
				Unlock(&ThreadListLock);
				continue;
			}

			if(KillCount){
				KillCount--;
				Unlock(&ThreadListLock);
				continue;
			}

			if(ActiveReq > nThreads && nThreads < MAX_TIMER_THREADS){
				nThreads++;
				hNewThread=CreateThread(NULL,4096, TimerWorkerThread, NULL, 0, &dwJunk);
				if(hNewThread){
					CloseHandle(hNewThread);
				} else {
					nThreads--;
				}
			}

			
			pBilink=ThreadList.next;

			if(pBilink == &ThreadList) {
				Unlock(&ThreadListLock);
				continue;
			};
			
			Delete(pBilink);	// pull off the list.
			
			pTimer=CONTAINING_RECORD(pBilink, MYTIMER, Bilink);

			// Call a callback

			pTimer->TimerState=InCallBack;
		
		Unlock(&ThreadListLock);
		
		(pTimer->CallBack)((UINT_PTR)pTimer, 0, pTimer->Context, 0, 0);

		pTimer->Unique=0;
		pTimer->TimerState=End;
		pTimerPool->Release(pTimerPool, pTimer);

		Lock(&ThreadListLock);
			
		if(ActiveReq)ActiveReq--;

		Unlock(&ThreadListLock);
	}	
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\serial\comport.h ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       comport.h
 *  Content:	Routines for COM port I/O
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *  4/10/96	kipo	created it
 *  4/15/96 kipo	added msinternal
 *	5/22/96	kipo	added support for RTSDTR flow control
 *	6/10/96	kipo	added modem support
 *	6/22/96	kipo	added support for EnumConnectionData().
 *  7/13/96	kipo	added GetComPortAddress()
 *  8/15/96	kipo	added CRC
 *  1/06/97 kipo	updated for objects
 *  2/11/97 kipo	pass player flags to GetAddress()
 *  2/18/97 kipo	allow multiple instances of service provider
 *  4/08/97 kipo	added support for separate modem and serial baud rates
 *  5/07/97 kipo	added support for modem choice list
 *  5/23/97 kipo	added support return status codes
 *  1/30/98 kipo	added hTerminateThreadEvent to fix bugs #15220 & #15228
 ***************************************************************************/

#ifndef __COMPORT_INCLUDED__
#define __COMPORT_INCLUDED__

#include <windows.h>
#include <windowsx.h>
#include <objbase.h>

#include "dplay.h"
#include "dplaysp.h"
#include "bilink.h"

typedef struct _DPCOMPORT DPCOMPORT;
typedef			DPCOMPORT *LPDPCOMPORT;

typedef HRESULT (*LPDISPOSECOMPORT)(LPDPCOMPORT globals);
typedef HRESULT (*LPCONNECTCOMPORT)(LPDPCOMPORT globals, BOOL bWaitForConnection, BOOL bReturnStatus);
typedef HRESULT (*LPDISCONNECTCOMPORT)(LPDPCOMPORT globals);
typedef HRESULT (*LPSETUPCOMPORT)(LPDPCOMPORT globals, HANDLE hCom);
typedef HRESULT (*LPSHUTDOWNCOMPORT)(LPDPCOMPORT globals);
typedef DWORD	(*LPREADCOMPORT)(LPDPCOMPORT globals, LPVOID lpvBuffer, DWORD nMaxLength);
typedef DWORD	(*LPWRITECOMPORT)(LPDPCOMPORT globals, LPVOID lpvBuffer, DWORD dwLength, BOOLEAN bQueueOnReenter);
typedef HRESULT (*LPGETCOMPORTBAUDRATE)(LPDPCOMPORT globals, LPDWORD lpdwBaudRate);
typedef HANDLE  (*LPGETCOMPORTHANDLE)(LPDPCOMPORT globals);
typedef HRESULT (*LPGETCOMPORTADDRESS)(LPDPCOMPORT globals, DWORD dwPlayerFlags, LPVOID lpAddress, LPDWORD lpdwAddressSize);
typedef HRESULT (*LPGETCOMPORTADDRESSCHOICES)(LPDPCOMPORT globals, LPVOID lpAddress, LPDWORD lpdwAddressSize);

typedef void (*LPREADROUTINE)(LPDIRECTPLAYSP);

// struct used for pending sends.
typedef struct _PENDING_SEND {
	BILINK Bilink;
	DWORD  dwBytesToWrite;
	UCHAR  Data[0];
} PENDING_SEND, *LPPENDING_SEND;

struct _DPCOMPORT {
	// com port globals
	HANDLE					hCom;			// handle to comm object

	HANDLE					hIOThread;		// handle to read thread
	DWORD					IOThreadID;		// ID of read thread
	HANDLE					hTerminateThreadEvent; // signalled to terminate the thread

	OVERLAPPED				readOverlapped;	// overlapped sections for asynch I/O
	OVERLAPPED				writeOverlapped;
	LPREADROUTINE			lpReadRoutine;	// routine to call when read is ready
	LPDIRECTPLAYSP			lpDPlay;		// pointer to IDirectPlaySP needed to call back into DPlay

	// need to queue sends if we are in the middle of writing and drain queue when done writing.
	CRITICAL_SECTION        csWriting;		// locks pending list and bWriting
	BILINK                  PendingSends;   // bilink list of pending sends
	BOOL                    bWriting;		// guards re-entry to WriteComPort()

	// com port methods
	LPDISPOSECOMPORT		Dispose;		// dispose
	LPCONNECTCOMPORT		Connect;		// connect
	LPDISCONNECTCOMPORT		Disconnect;		// disconnect
	LPSETUPCOMPORT			Setup;			// setup com port
	LPSHUTDOWNCOMPORT		Shutdown;		// shutdown com port
	LPREADCOMPORT			Read;			// read
	LPWRITECOMPORT			Write;			// write
	LPGETCOMPORTBAUDRATE	GetBaudRate;	// get baud rate
	LPGETCOMPORTHANDLE		GetHandle;		// get com port handle
	LPGETCOMPORTADDRESS		GetAddress;		// get address
	LPGETCOMPORTADDRESSCHOICES GetAddressChoices; // get address choices
};

extern HRESULT NewComPort(DWORD dwObjectSize,
						  LPDIRECTPLAYSP lpDPlay, LPREADROUTINE lpReadRoutine,
						  LPDPCOMPORT *lplpObject);
extern HRESULT NewModem(LPVOID lpConnectionData, DWORD dwConnectionDataSize,
						LPDIRECTPLAYSP lpDPlay, LPREADROUTINE lpReadRoutine,
						LPDPCOMPORT *storage);
extern HRESULT NewSerial(LPVOID lpConnectionData, DWORD dwConnectionDataSize,
						 LPDIRECTPLAYSP lpDPlay, LPREADROUTINE lpReadRoutine,
						 LPDPCOMPORT *storage);

extern DWORD GenerateCRC(LPVOID pBuffer, DWORD dwBufferSize);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\serial\dbgtopic.h ===
DEBUG_TOPIC(B,"&Blting")
DEBUG_TOPIC(C,"&Clipping")
DEBUG_TOPIC(D,"&DDraw Object")
DEBUG_TOPIC(F,"&Focus Changes")
DEBUG_TOPIC(H,"&HAL/HEL Calls")
DEBUG_TOPIC(I,"Internal Fn Entered")
DEBUG_TOPIC(K,"NT Kernel Calls")
DEBUG_TOPIC(L,"&Locking/Ownership")
DEBUG_TOPIC(O,"M&odes")
DEBUG_TOPIC(M,"&Memory")
DEBUG_TOPIC(P,"API &Parameters")
DEBUG_TOPIC(R,"&Reference Counting")
DEBUG_TOPIC(S,"&Surface Objects")
DEBUG_TOPIC(T,"Fil&ters")
DEBUG_TOPIC(V,"&Video Memory allocation")
DEBUG_TOPIC(W,"&Windows and Handles")
DEBUG_TOPIC(X,"Ad-Hoc Message &X")

#undef PROF_SECT
#define PROF_SECT "DirectPlay"

#undef DPF_MODULE_NAME
#ifdef START_STR
	#define DPF_MODULE_NAME START_STR
#else
	#define DPF_MODULE_NAME "DPSERIAL"
#endif


/*
 * Use this identifier to define which line in WIN.INI [DirectX] denotes the
 * debug control string
 */
#undef DPF_CONTROL_LINE
#define DPF_CONTROL_LINE "DPlayDebug"

/*
 * It is important that the first DEBUG_TOPIC appear at the top line of this
 * file, and that no other lines are interspersed between DEBUG_TOPIC lines.
 * (The debug system uses the __LINE__ pseudo-variable to identify topics)
 */

/*
 * Definitions for DPF detail levels:
 *
 * 0: Error useful for application developers.
 * 1: Warning useful for application developers.
 * 2: API Entered
 * 3: API parameters, API return values
 * 4: Driver conversation
 *
 * 5: Deeper program flow notifications
 * 6: Dump structures 
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\serial\comport.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       comport.c
 *  Content:	Routines for COM port I/O
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *  4/10/96	kipo	created it
 *  4/12/96 kipo	use GlobalAllocPtr to create memory
 *  4/15/96 kipo	added msinternal
 *	5/22/96	kipo	added support for RTSDTR flow control
 *	6/10/96	kipo	added modem support
 *	6/22/96	kipo	added support for EnumConnectionData(); added methods
 *					to NewComPort().
 *  7/13/96	kipo	added GetComPortAddress()
 *  8/15/96	kipo	added CRC
 *  8/16/96	kipo	loop on WriteFile to send large buffers
 *  8/19/96	kipo	update thread interface
 *  1/06/97 kipo	updated for objects
 *  2/18/97 kipo	allow multiple instances of service provider
 *  4/08/97 kipo	added support for separate modem and serial baud rates
 *  5/23/97 kipo	added support return status codes
 * 11/24/97 kipo	better error messages
 *  1/30/98 kipo	added hTerminateThreadEvent to fix bugs #15220 & #15228
 *@@END_MSINTERNAL
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>

#include "comport.h"
#include "dpf.h"
#include "macros.h"

// constants

#define READTIMEOUT			5000		// ms to wait before read times out
#define WRITETIMEOUT		5000		// ms to wait before write times out
#define WRITETOTALTIMEOUT	5000		// total ms to wait before write times out
#define IOBUFFERSIZE		4096		// size of read/write buffers in bytes

// prototypes

static HRESULT		SetupComPort(LPDPCOMPORT globals, HANDLE hCom);
static HRESULT		ShutdownComPort(LPDPCOMPORT globals);
static DWORD		ReadComPort(LPDPCOMPORT globals, LPVOID lpvBuffer, DWORD nMaxLength);
static DWORD		WriteComPort(LPDPCOMPORT globals, LPVOID lpvBuffer, DWORD dwBytesToWrite, BOOLEAN bQueueOnReenter);
static HRESULT		GetComPortBaudRate(LPDPCOMPORT globals, LPDWORD lpdwBaudRate);
static HANDLE		GetComPortHandle(LPDPCOMPORT globals);

static DWORD WINAPI	IOThread(LPVOID lpvParam1);

/*
 * NewComPort
 *
 * Creates a com port object of the given size. The readRoutine is called whenever
 * a byte is received in the input thread.
 */

HRESULT NewComPort(DWORD dwObjectSize,
				   LPDIRECTPLAYSP lpDPlay, LPREADROUTINE lpReadRoutine,
				   LPDPCOMPORT *lplpObject)
{
	LPDPCOMPORT		globals;
	DWORD			dwError;

	// allocate space for base object and our globals
	globals =(LPDPCOMPORT) SP_MemAlloc(dwObjectSize);
	if (globals == NULL)
	{
		dwError = GetLastError();
		return (HRESULT_FROM_WIN32(dwError));
	}

	// store read routine pointer and IDirectPlaySP pointer
	globals->lpReadRoutine = lpReadRoutine;
	globals->lpDPlay = lpDPlay;

	// fill in base methods
	globals->Dispose = NULL;
	globals->Connect = NULL;
	globals->Disconnect = NULL;
	globals->Setup = SetupComPort;
	globals->Shutdown = ShutdownComPort;
	globals->Read = ReadComPort;
	globals->Write = WriteComPort;
	globals->GetBaudRate = GetComPortBaudRate;
	globals->GetHandle = GetComPortHandle;
	globals->GetAddress = NULL;
	globals->GetAddressChoices = NULL;

	// return base object
	*lplpObject = globals;

	return (DP_OK);
}

/*
 * SetupComPort
 *
 * Sets up the COM port for overlapped I/O with a read thread.
 */

static HRESULT SetupComPort(LPDPCOMPORT globals, HANDLE hCom)
{
	COMMTIMEOUTS	timoutInfo;
	DWORD			dwError;

	// store com port handle
	globals->hCom = hCom;
	
	// wake up read thread when a byte arrives
	SetCommMask(globals->hCom, EV_RXCHAR);

	// setup read/write buffer for I/O
	SetupComm(globals->hCom, IOBUFFERSIZE, IOBUFFERSIZE);

	// set time outs
	timoutInfo.ReadIntervalTimeout = MAXDWORD;
	timoutInfo.ReadTotalTimeoutMultiplier = 0;
	timoutInfo.ReadTotalTimeoutConstant = 0;
	timoutInfo.WriteTotalTimeoutMultiplier = 0;
	timoutInfo.WriteTotalTimeoutConstant = WRITETOTALTIMEOUT;

	if (!SetCommTimeouts(globals->hCom, &timoutInfo))
		goto Failure;

	// create I/O event used for overlapped read

	ZeroMemory(&globals->readOverlapped, sizeof(OVERLAPPED));
	globals->readOverlapped.hEvent = CreateEvent(	NULL,	// no security
													TRUE,	// explicit reset req
													FALSE,	// initial event reset
													NULL );	// no name
	if (globals->readOverlapped.hEvent == NULL)
		goto Failure;

	// create I/O event used for overlapped write

	ZeroMemory(&globals->writeOverlapped, sizeof(OVERLAPPED));
	globals->writeOverlapped.hEvent = CreateEvent(	NULL,	// no security
													TRUE,	// explicit reset req
													FALSE,	// initial event reset
													NULL );	// no name
	if (globals->writeOverlapped.hEvent == NULL)
		goto Failure;

	// create event used to signal I/O thread to exit

	globals->hTerminateThreadEvent = CreateEvent(	NULL,	// no security
													TRUE,	// explicit reset req
													FALSE,	// initial event reset
													NULL );	// no name
	if (globals->hTerminateThreadEvent == NULL)
		goto Failure;

	// Init vars for pending queue
	InitializeCriticalSection(&globals->csWriting);
	InitBilink(&globals->PendingSends);
	globals->bWriting=FALSE;

	// create read thread

	globals->hIOThread = CreateThread(
								NULL,			// default security
								0,				// default stack size
								IOThread,		// pointer to thread routine
								globals,		// argument for thread
								0,				// start it right away
								&globals->IOThreadID);
	if (globals->hIOThread == NULL)
		goto Failure;

	// adjust thread priority to be higher than normal or the serial port will
	// back up and the game will slow down or lose messages.

	SetThreadPriority(globals->hIOThread, THREAD_PRIORITY_ABOVE_NORMAL);
	ResumeThread(globals->hIOThread);

	// assert DTR

	EscapeCommFunction(globals->hCom, SETDTR);

	return (DP_OK);

Failure:
	dwError = GetLastError();
	ShutdownComPort(globals);

	return (HRESULT_FROM_WIN32(dwError));
}

/*
 * ShutdownComPort
 *
 * Stop's all I/O on COM port and releases allocated resources.
 */

static HRESULT ShutdownComPort(LPDPCOMPORT globals)
{
	if (globals->hIOThread)
	{
		// the thread will wake up if we disable event notifications using
		// SetCommMask. Need to set the hTerminateThread event before doing
		// this so the thread will know to exit

		SetEvent(globals->hTerminateThreadEvent);
		SetCommMask(globals->hCom, 0);
		WaitForSingleObject(globals->hIOThread, INFINITE);

        CloseHandle (globals->hIOThread);
		globals->hIOThread = NULL;

		// purge any outstanding reads/writes

		EscapeCommFunction(globals->hCom, CLRDTR);
		PurgeComm(globals->hCom, PURGE_TXABORT | PURGE_RXABORT |
								 PURGE_TXCLEAR | PURGE_RXCLEAR );
	}

	if (globals->hTerminateThreadEvent)
	{
		CloseHandle(globals->hTerminateThreadEvent);
		globals->hTerminateThreadEvent = NULL;
	}

	if (globals->readOverlapped.hEvent)
	{
		CloseHandle(globals->readOverlapped.hEvent);
		globals->readOverlapped.hEvent = NULL;
	}

	if (globals->writeOverlapped.hEvent)
	{
		CloseHandle(globals->writeOverlapped.hEvent);
		globals->writeOverlapped.hEvent = NULL;
	}

	// the com port is shut down
	globals->hCom = NULL;

	// Free resources for pending queue
	DeleteCriticalSection(&globals->csWriting);

	return (DP_OK);
}

/*
 * ReadComPort
 *
 * Read bytes from COM port. Will block until all bytes have been read.
 */

static DWORD ReadComPort(LPDPCOMPORT globals, LPVOID lpvBuffer, DWORD nMaxLength)
{
	COMSTAT		ComStat;
	DWORD		dwErrorFlags, dwLength, dwError;

	ClearCommError(globals->hCom, &dwErrorFlags, &ComStat);

	dwLength = min(nMaxLength, ComStat.cbInQue);
	if (dwLength == 0)
		return (0);

	if (ReadFile(globals->hCom, lpvBuffer, dwLength, &dwLength, &globals->readOverlapped))
		return (dwLength);

	// deal with error
	dwError = GetLastError();
	if (dwError != ERROR_IO_PENDING)
	{
		DPF(0, "Error reading from com port: 0x%8X", dwError);
		return (0);
	}

	// wait for this transmission to complete

	if (WaitForSingleObject(globals->readOverlapped.hEvent, READTIMEOUT) != WAIT_OBJECT_0)
	{
		DPF(0, "Timed out reading com port after waiting %d ms", READTIMEOUT);
		return (0);
	}

	GetOverlappedResult(globals->hCom, &globals->readOverlapped, &dwLength, FALSE);
	globals->readOverlapped.Offset += dwLength;

   return (dwLength);
}

/*
 * WriteComPort
 *
 * Write bytes to COM port. Will block until all bytes have been written.
 */

static DWORD WriteComPort(LPDPCOMPORT globals, LPVOID lpvBuffer, DWORD dwBytesToWrite, BOOLEAN bQueueOnReenter)
{
	DWORD	dwLength;
	DWORD	dwBytesWritten;
	LPBYTE	lpData;
	DWORD	dwError;

	EnterCriticalSection(&globals->csWriting);
	
	if(!globals->bWriting || !bQueueOnReenter){
		globals->bWriting=TRUE;
		LeaveCriticalSection(&globals->csWriting);

		lpData = lpvBuffer;
		dwBytesWritten = 0;
		while (dwBytesWritten < dwBytesToWrite)
		{
			dwLength = dwBytesToWrite - dwBytesWritten;
			if (WriteFile(globals->hCom, lpData, dwLength, &dwLength, &globals->writeOverlapped))
			{
				dwBytesWritten += dwLength;
				globals->bWriting = FALSE;
				return (dwBytesWritten);
			}

			dwError = GetLastError();
			if (dwError != ERROR_IO_PENDING)
			{
				DPF(0, "Error writing to com port: 0x%8X", dwError);
				globals->bWriting = FALSE;
				return (dwBytesWritten);
			}

	 		// wait for this transmission to complete

			if (WaitForSingleObject(globals->writeOverlapped.hEvent, WRITETIMEOUT) != WAIT_OBJECT_0)
			{
				DPF(0, "Timed out writing to com port after waiting %d ms", WRITETIMEOUT);
				globals->bWriting = FALSE;
				return (dwBytesWritten);
			}

			if (GetOverlappedResult(globals->hCom, &globals->writeOverlapped, &dwLength, TRUE) == 0)
			{
				dwError = GetLastError();
				DPF(0, "Error writing to com port: 0x%8X", dwError);
				/*
				// a-josbor: this probably should return, but I'm unwilling to make the change so close to ship...
				globals->bWriting = FALSE;
				return (dwBytesWritten);
				*/
			}
			globals->writeOverlapped.Offset += dwLength;

			lpData += dwLength;
			dwBytesWritten += dwLength;
		}

		if(bQueueOnReenter){ // don't drain queue recurrsively.
			// Drain any pending sends.
			EnterCriticalSection(&globals->csWriting);
			while(!EMPTY_BILINK(&globals->PendingSends)){
			
				LPPENDING_SEND lpPendingSend;
				
				lpPendingSend=CONTAINING_RECORD(globals->PendingSends.next,PENDING_SEND,Bilink);
				Delete(&lpPendingSend->Bilink);
				
				LeaveCriticalSection(&globals->csWriting);
				WriteComPort(globals,lpPendingSend->Data,lpPendingSend->dwBytesToWrite,FALSE);
				SP_MemFree(lpPendingSend);
				EnterCriticalSection(&globals->csWriting);	
			}
			globals->bWriting=FALSE;
			LeaveCriticalSection(&globals->csWriting);
		}
		
	} else {
	
		LPPENDING_SEND lpPendingSend;
		
		// we are in the middle of writing, so copy this to the pending queue and it will get
		// sent after the current write.
		
		lpPendingSend = (LPPENDING_SEND) SP_MemAlloc(dwBytesToWrite+sizeof(PENDING_SEND));
		if(lpPendingSend){
			memcpy(lpPendingSend->Data,lpvBuffer,dwBytesToWrite);
			lpPendingSend->dwBytesToWrite=dwBytesToWrite;
			InsertBefore(&lpPendingSend->Bilink, &globals->PendingSends);

		}
		LeaveCriticalSection(&globals->csWriting);
		dwBytesWritten=dwBytesToWrite;
	}
	
	return (dwBytesWritten);
}

/*
 * GetComPortBaudRate
 *
 * Get baud rate of com port.
 */

static HRESULT GetComPortBaudRate(LPDPCOMPORT globals, LPDWORD lpdwBaudRate)
{
	DCB			dcb;
	DWORD		dwError;

	ZeroMemory(&dcb, sizeof(DCB));
	dcb.DCBlength = sizeof(DCB);

	if (!GetCommState(globals->hCom, &dcb))
		goto Failure;

	*lpdwBaudRate = dcb.BaudRate;

	return (DP_OK);

Failure:	
	dwError = GetLastError();

	return (HRESULT_FROM_WIN32(dwError));
}

/*
 * GetComPortHandle
 *
 * Get handle of com port.
 */

static HANDLE GetComPortHandle(LPDPCOMPORT globals)
{
	return (globals->hCom);
}

/*
 * IOThread
 *
 * Thread to wait for events from COM port. Will call the read routine if an byte
 * is received.
 */

DWORD WINAPI IOThread(LPVOID lpvParam1)
{
	LPDPCOMPORT	globals = (LPDPCOMPORT) lpvParam1;
	DWORD		dwTransfer, dwEvtMask;
	OVERLAPPED	os;
	HANDLE		events[3];
	DWORD		dwResult;

	// create I/O event used for overlapped read

	ZeroMemory(&os, sizeof(OVERLAPPED));
	os.hEvent = CreateEvent(NULL,	// no security
							TRUE,	// explicit reset req
							FALSE,	// initial event reset
							NULL );	// no name
	if (os.hEvent == NULL)
		goto CreateEventFailed;

	if (!SetCommMask(globals->hCom, EV_RXCHAR))
		goto SetComMaskFailed;

	// events to use when waiting for overlapped I/O to complete
	events[0] = globals->hTerminateThreadEvent;
	events[1] = os.hEvent;
	events[2] = (HANDLE) -1;		// work around Win95 bugs in WaitForMultipleObjects

	// spin until this event is signaled during Close.

	while (WaitForSingleObject(globals->hTerminateThreadEvent, 0) == WAIT_TIMEOUT)
	{
		dwEvtMask = 0;

		// wait for COM port event
		if (!WaitCommEvent(globals->hCom, &dwEvtMask, &os))
		{
			if (GetLastError() == ERROR_IO_PENDING)
			{
				// wait for overlapped I/O to complete or the terminating event
				// to be set. This lets us terminate this thread even if the I/O
				// never completes, which fixes a bug on NT 4.0

				dwResult = WaitForMultipleObjects(2, events, FALSE, INFINITE);
				
				// terminating event was set
				if (dwResult == WAIT_OBJECT_0)
				{
					break;		// exit the thread
				}

				// I/O completed
				else if (dwResult == (WAIT_OBJECT_0 + 1))
				{
					GetOverlappedResult(globals->hCom, &os, &dwTransfer, TRUE);
					os.Offset += dwTransfer;
				}
			}
		}

		// was a read event
		if (dwEvtMask & EV_RXCHAR)
		{
			if (globals->lpReadRoutine)
				globals->lpReadRoutine(globals->lpDPlay);	// call read routine
		}
	}

SetComMaskFailed:
	CloseHandle(os.hEvent);

CreateEventFailed:
	ExitThread(0);

	return (0);
}

/*
  Name   : "CRC-32"
   Width  : 32
   Poly   : 04C11DB7
   Init   : FFFFFFFF
   RefIn  : True
   RefOut : True
   XorOut : FFFFFFFF
   Check  : CBF43926

  This is supposedly what Ethernet uses
*/

#if 0
#define WIDTH		32
#define POLY		0x04C11DB7
#define INITVALUE	0xFFFFFFFF
#define REFIN		TRUE
#define XOROUT		0xFFFFFFFF
#define CHECK		0xCBF43926
#define WIDMASK		0xFFFFFFFF		// value is (2^WIDTH)-1
#endif

/*
  Name   : "CRC-16"
   Width  : 16
   Poly   : 8005
   Init   : 0000
   RefIn  : True
   RefOut : True
   XorOut : 0000
   Check  : BB3D
*/

#if 1
#define WIDTH		16
#define POLY		0x8005
#define INITVALUE	0
#define REFIN		TRUE
#define XOROUT		0
#define CHECK		0xBB3D
#define WIDMASK		0x0000FFFF		// value is (2^WIDTH)-1
#endif

#define BITMASK(X) (1L << (X))

DWORD crc_normal(LPBYTE blk_adr, DWORD blk_len, DWORD crctable[])
{
	DWORD	crc = INITVALUE;

	while (blk_len--)
		crc = crctable[((crc>>24) ^ *blk_adr++) & 0xFFL] ^ (crc << 8);

	return (crc ^ XOROUT);
}

DWORD crc_reflected(LPBYTE blk_adr, DWORD blk_len, DWORD crctable[])
{
	DWORD	crc = INITVALUE;

	while (blk_len--)
		crc = crctable[(crc ^ *blk_adr++) & 0xFFL] ^ (crc >> 8);

	return (crc ^ XOROUT);
}

DWORD reflect(DWORD v, int b)
/* Returns the value v with the bottom b [0,32] bits reflected. */
/* Example: reflect(0x3e23L,3) == 0x3e26                        */
{
	int		i;
	DWORD	t = v;

	for (i = 0; i < b; i++)
	{
		if (t & 1L)
			v |=  BITMASK((b-1)-i);
		else
			v &= ~BITMASK((b-1)-i);
		t >>= 1;
	}
	return v;
}

DWORD cm_tab (int index)
{
	int   i;
	DWORD r;
	DWORD topbit = (DWORD) BITMASK(WIDTH-1);
	DWORD inbyte = (DWORD) index;

	if (REFIN)
		inbyte = reflect(inbyte, 8);

	r = inbyte << (WIDTH-8);
	for (i = 0; i < 8; i++)
	{
		if (r & topbit)
			r = (r << 1) ^ POLY;
		else
			r <<= 1;
	}

	if (REFIN)
		r = reflect(r, WIDTH);

	return (r & WIDMASK);
}

void generate_table(DWORD dwTable[])
{
	int	i;

	for (i = 0; i < 256; i++)
	{
		dwTable[i] = cm_tab(i);
	}
}

// todo - make this a static table
DWORD	gCRCTable[256];
BOOL	gTableCreated = FALSE;

DWORD GenerateCRC(LPVOID pBuffer, DWORD dwBufferSize)
{
	if (!gTableCreated)
	{
		generate_table(gCRCTable);
		gTableCreated = TRUE;
	}

	return (crc_reflected(pBuffer, dwBufferSize, gCRCTable));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\serial\dial.h ===
/*==========================================================================
 *
 *  Copyright (C) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dial.c
 *  Content:	Header for TAPI  routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *  6/10/96	kipo	created it
 *	7/08/96 kipo	added support for new dialogs
 *	8/10/96 kipo	added support for dialing location
 *	3/04/97 kipo	close com port handle when deallocating call; use string
 *					table for modem strings; updated debug output.
 *	3/24/97 kipo	added support for specifying which modem to use
 *  4/08/97 kipo	added support for separate modem and serial baud rates
 *  5/07/97 kipo	added support for modem choice list
 * 11/25/97 kipo	set TAPI_CURRENT_VERSION to 1.4 so the NT build won't
 *					use NT-only features (15209)
 *  5/07/98 a-peterz Track call errors in DPDIAL
 *@@END_MSINTERNAL
 ***************************************************************************/

// need to add this line so that NT builds won't define Tapi 2.0 by default,
// which causes it to link with ANSI versions of Tapi functions that are not
// available on Win 95, causing LoadLibrary to fail.

#define TAPI_CURRENT_VERSION 0x00010004

#include "tapi.h"
#include "comport.h"

#define TAPIVERSION			0x00010003	// TAPI version to require
#define LINEDROPTIMEOUT		5000		// ms to wait for call to drop
#define SUCCESS				0
#define MAXSTRINGSIZE		400

// DPDIAL.dwCallError values
enum { CALL_OK, CALL_LINEERROR, CALL_DISCONNECTED, CALL_CLOSED };

typedef LONG	LINERESULT;

typedef struct {
	HLINEAPP		hLineApp;			// handle to line application
	HLINE			hLine;				// handle to the line device
	HCALL			hCall;				// handle to the call
	HANDLE			hComm;				// handle to com port
	LPDPCOMPORT		lpComPort;			// pointer to com port object
	DWORD			dwAPIVersion;       // api version
	DWORD			dwNumLines;			// number of line devices supported by the service provider
	DWORD           dwLineID;			// line id of open line
	DWORD_PTR   	dwCallState;		// current call state of session
	DWORD			dwAsyncID;			// id of pending async operation
	DWORD			dwCallError;		// last error
} DPDIAL, *LPDPDIAL;

extern LINERESULT dialInitialize(HINSTANCE hInst, LPTSTR szAppName, LPDPCOMPORT lpComPort, LPDPDIAL *storage);
extern LINERESULT dialShutdown(LPDPDIAL globals);
extern LINERESULT dialLineOpen(LPDPDIAL globals, DWORD dwLine);
extern LINERESULT dialLineClose(LPDPDIAL globals);
extern LINERESULT dialMakeCall(LPDPDIAL globals, LPTSTR szDestination);
extern LINERESULT dialDropCall(LPDPDIAL globals);
extern LINERESULT dialDeallocCall(LPDPDIAL globals);
extern BOOL		  dialIsConnected(LPDPDIAL globals);
extern LINERESULT dialGetBaudRate(LPDPDIAL globals, LPDWORD lpdwBaudRate);
extern LRESULT	  dialGetDeviceIDFromName(LPDPDIAL globals, LPCSTR szTargetName, DWORD *lpdwDeviceID);
extern LINERESULT dialGetModemList(LPDPDIAL globals, BOOL bAnsi, LPVOID *lplpData, LPDWORD lpdwDataSize);
extern void		  dialFillModemComboBox(LPDPDIAL globals, HWND hwndDlg, int item, DWORD dwDefaultDevice);
extern void		  dialFillLocationComboBox(LPDPDIAL globals, HWND hwndDlg, int item, DWORD dwDefaultLocation);
extern LINERESULT dialTranslateDialog(LPDPDIAL globals, HWND hWnd,
							   DWORD dwDeviceID, LPTSTR szPhoneNumber);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\serial\dial.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dial.c
 *  Content:	Wrappers for TAPI routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *  6/10/96	kipo	created it
 *  6/22/96	kipo	close com port when disconnected; allow checking for
 *					valid TAPI lines during NewComPort().
 *	7/08/96 kipo	added support for new dialogs
 *	8/10/96 kipo	added support for dialing location
 *  1/06/97 kipo	updated for objects
 *  1/24/97 kipo	bug #5400: Compaq Presario was overwriting the dev caps
 *					buffer, causing a crash. Fixed to allocated a larger
 *					buffer with some slop as a workaround.
 *	3/04/97 kipo	close com port handle when deallocating call; use string
 *					table for modem strings; updated debug output.
 *	3/24/97 kipo	added support for specifying which modem to use
 *  4/08/97 kipo	added support for separate modem and serial baud rates
 *  5/07/97 kipo	added support for modem choice list
 *  5/23/97 kipo	added support return status codes
 *  4/21/98 a-peterz #22920 Handle LINE_CLOSE message
 *  5/07/98 a-peterz #15251 Track call errors in DPDIAL
 * 10/13/99	johnkan	#413516 - Mismatch between modem dialog selection and TAPI device ID
 * 12/22/00 aarono   #190380 - use process heap for memory allocation
 *@@END_MSINTERNAL
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>

#include "dputils.h"
#include "macros.h"
#include "dial.h"

void FAR PASCAL LineCallBackProc(DWORD hDevice, DWORD dwMessage, DWORD_PTR dwInstance,
								 DWORD_PTR dwParam1, DWORD_PTR dwParam2, DWORD_PTR dwParam3);
void		ProcessConnectedState(LPDPDIAL globals, HCALL hCall, DWORD dwCallStateDetail, DWORD dwCallPrivilege);
void		ProcessDisconnectedState(LPDPDIAL globals, HCALL hCall, DWORD dwCallStateDetail, DWORD dwCallPrivilege);
void		ProcessIdleState(LPDPDIAL globals, HCALL hCall, DWORD dwCallStateDetail, DWORD dwCallPrivilege);
void		ProcessOfferingState(LPDPDIAL globals, HCALL hCall, DWORD dwCallPrivilege);
void		ProcessReplyMessage(LPDPDIAL globals, DWORD asyncID, LINERESULT lResult);
LINERESULT dialGetDevCaps(LPDPDIAL globals, DWORD dwLine, DWORD dwAPIVersion, LPLINEDEVCAPS	*lpDevCapsRet);
LINERESULT dialGetCommHandle(LPDPDIAL globals);
LINERESULT dialCloseCommHandle(LPDPDIAL globals);
LINERESULT dialTranslateAddress(LPDPDIAL globals, DWORD dwDeviceID, DWORD dwAPIVersion,
								LPCSTR lpszDialAddress,
								LPLINETRANSLATEOUTPUT *lpLineTranslateOutputRet);
LPSTR		GetLineErrStr(LONG err);
LPSTR		GetCallStateStr(DWORD callState);
LPSTR		GetLineMsgStr(DWORD msg);

#ifdef DEBUG
extern LONG lineError(LONG err, LPSTR modName, DWORD lineNum);
#define LINEERROR(err)	(lineError(err, DPF_MODNAME, __LINE__))
#else
#define LINEERROR(err)	(err)
#endif

/* dial initialize */

#undef DPF_MODNAME
#define DPF_MODNAME	"dialInitialize"

LINERESULT dialInitialize(HINSTANCE hInst, LPTSTR szAppName,
						  LPDPCOMPORT lpComPort, LPDPDIAL *storage)
{
	LPDPDIAL		globals;
	LINERESULT		lResult;				/* Stores return code from TAPI calls */

	// create globals
	globals =(LPDPDIAL) SP_MemAlloc(sizeof(DPDIAL));
	FAILWITHACTION(globals == NULL, lResult = LINEERR_NOMEM, Failure);

	DPF(3, "lineInitialize");
	DPF(3, ">  hInstance: %08X", hInst);
	DPF(3, ">  szAppName: %s", szAppName);

	// init the line
	lResult = lineInitialize(&globals->hLineApp,
							 hInst,
							 LineCallBackProc,
							 szAppName,
							 &globals->dwNumLines);
	FAILIF(LINEERROR(lResult), Failure);

	DPF(3, "<   hLineApp: %08X", globals->hLineApp);
	DPF(3, "< dwNumLines: %d", globals->dwNumLines);

	// no lines available
	FAILWITHACTION(globals->dwNumLines == 0, lResult = LINEERR_NODEVICE, Failure);

	// store pointer to com port object
	globals->lpComPort = lpComPort;

	*storage = globals;
	return (SUCCESS);

Failure:
	dialShutdown(globals);

	return (lResult);
}

/* dial shutdown */

#undef DPF_MODNAME
#define DPF_MODNAME	"dialShutdown"

LINERESULT dialShutdown(LPDPDIAL globals)
{
	LINERESULT	lResult;

	if (globals == NULL)
		return (SUCCESS);

	if (globals->hLineApp)
	{
		dialDropCall(globals);
		dialDeallocCall(globals);
		dialLineClose(globals);

		DPF(3, "lineShutdown");
		DPF(3, ">   hLineApp: %08X", globals->hLineApp);

		lResult = lineShutdown(globals->hLineApp);
		LINEERROR(lResult);
	}

	SP_MemFree(globals);

	return (SUCCESS);
}

/* dialLineOpen - wrapper for lineOpen */

#undef DPF_MODNAME
#define DPF_MODNAME	"dialLineOpen"

LINERESULT dialLineOpen(LPDPDIAL globals, DWORD dwLine)
{
	LINEEXTENSIONID lineExtensionID;		// Will be set to 0 to indicate no known extensions
    LPLINEDEVCAPS	lpLineDevCaps = NULL;
	LINERESULT		lResult;

	// fail if line is already open
	FAILWITHACTION(globals->hLine != 0, lResult = LINEERR_INVALLINEHANDLE, Failure);

	/* negotiate API version for each line */
	lResult = lineNegotiateAPIVersion(globals->hLineApp, dwLine,
					TAPIVERSION, TAPIVERSION,
					&globals->dwAPIVersion, &lineExtensionID);
	FAILIF(LINEERROR(lResult), Failure);

	lResult = dialGetDevCaps(globals, dwLine, globals->dwAPIVersion, &lpLineDevCaps);
	FAILIF(LINEERROR(lResult), Failure);

	/* check for supported media mode.  If not datamodem, continue to next line */
	FAILWITHACTION(!(lpLineDevCaps->dwMediaModes & LINEMEDIAMODE_DATAMODEM),
					lResult = LINEERR_NODEVICE, Failure);

	DPF(3, "lineOpen");
	DPF(3, ">   hLineApp: %08X", globals->hLineApp);
	DPF(3, "> dwDeviceID: %d", dwLine);

	// reset error tracking
	globals->dwCallError = CALL_OK;

	/* open the line that supports data modems */
	lResult = lineOpen( globals->hLineApp, dwLine, &globals->hLine,
						globals->dwAPIVersion, 0L,
						(DWORD_PTR) globals,
						LINECALLPRIVILEGE_OWNER, LINEMEDIAMODE_DATAMODEM,
						NULL);
	FAILIF(LINEERROR(lResult), Failure);

	DPF(3, "<      hLine: %08X", globals->hLine);

	/* if we are here then we found a compatible line */
	globals->dwLineID = dwLine;
	globals->dwCallState = LINECALLSTATE_IDLE;	// line is now idle and ready to make/receive calls
	lResult = SUCCESS;

Failure:
	if (lpLineDevCaps)
		SP_MemFree(lpLineDevCaps);
	return (lResult);
}

/* dialLineClose - wrapper for lineClose */

#undef DPF_MODNAME
#define DPF_MODNAME	"dialLineClose"

LINERESULT dialLineClose(LPDPDIAL globals)
{
	LINERESULT	lResult;

	// fail if line is already closed
	FAILWITHACTION(globals->hLine == 0, lResult = LINEERR_INVALLINEHANDLE, Failure);

	DPF(3, "lineClose");
	DPF(3, ">      hLine: %08X", globals->hLine);

	lResult = lineClose(globals->hLine);
	LINEERROR(lResult);

	globals->hLine = 0;

Failure:
	return (lResult);
}

/* dialMakeCall - wrapper for lineMakeCall */

#undef DPF_MODNAME
#define DPF_MODNAME	"dialMakeCall"

LINERESULT dialMakeCall(LPDPDIAL globals, LPTSTR szDestination)
{
	LINECALLPARAMS			callparams;
	LINERESULT				lResult;

	// fail if line not open or if call is already open
	FAILWITHACTION(globals->hLine == 0, lResult = LINEERR_INVALLINEHANDLE, Failure);
	FAILWITHACTION(globals->hCall != 0, lResult = LINEERR_INVALCALLHANDLE, Failure);

	// set call parameters
	ZeroMemory(&callparams, sizeof(LINECALLPARAMS));
	callparams.dwBearerMode = LINEBEARERMODE_VOICE;
	callparams.dwMediaMode = LINEMEDIAMODE_DATAMODEM;
	callparams.dwTotalSize = sizeof(LINECALLPARAMS);

	DPF(3, "lineMakeCall");
	DPF(3, ">      hLine: %08X", globals->hLine);
	DPF(3, "> szDestAddr: \"%s\"", szDestination);

	lResult = lineMakeCall(globals->hLine, &globals->hCall, szDestination, 0, &callparams);

	// lResult will be > 0 if call is asynchronous
	FAILWITHACTION(lResult < 0, LINEERROR(lResult), Failure);
	FAILMSG(lResult == 0);

	DPF(3, "<      hCall: %08X", globals->hCall);
	DPF(3, "<  dwAsyncID: %d", lResult);

	globals->dwAsyncID = lResult;			// store async ID
	lResult = SUCCESS;

Failure:
	return (lResult);
}

/* dialDropCall - wrapper for lineDrop */

#undef DPF_MODNAME
#define DPF_MODNAME	"dialDropCall"

LINERESULT dialDropCall(LPDPDIAL globals)
{
	MSG			msg;
	DWORD		dwStopTicks;
	LINERESULT	lResult;

	// fail if line not open or if call not open
	FAILWITHACTION(globals->hLine == 0, lResult = LINEERR_INVALLINEHANDLE, Failure);
	FAILWITHACTION(globals->hCall == 0, lResult = LINEERR_INVALCALLHANDLE, Failure);

	DPF(3, "lineDrop");
	DPF(3, ">      hCall: %08X", globals->hCall);

	lResult = lineDrop(globals->hCall, NULL, 0);

	// lResult will be > 0 if call is asynchronous
	FAILWITHACTION(lResult < 0, LINEERROR(lResult), Failure);
	FAILMSG(lResult == 0);

	DPF(3, "<  dwAsyncID: %d", lResult);

	globals->dwAsyncID = lResult;			// store async ID

	// wait for call to get dropped
	dwStopTicks = GetTickCount() + LINEDROPTIMEOUT;
	while (GetTickCount() < dwStopTicks)
	{
		// see if reply has occured and we are idle
		if ((globals->dwAsyncID == 0) &&
			(globals->dwCallState == LINECALLSTATE_IDLE))
		{
			break;
		}

		// give TAPI a chance to call our callback
        if (PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
		{
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
	}

	lResult = SUCCESS;

Failure:
	return (lResult);
}

/* dialDeallocCall - wrapper for lineDeallocCall */

#undef DPF_MODNAME
#define DPF_MODNAME	"dialDeallocCall"

LINERESULT dialDeallocCall(LPDPDIAL globals)
{
	LINERESULT	lResult;

	// fail if line not open or if call not open
	FAILWITHACTION(globals->hLine == 0, lResult = LINEERR_INVALLINEHANDLE, Failure);
	FAILWITHACTION(globals->hCall == 0, lResult = LINEERR_INVALCALLHANDLE, Failure);

	// close the com port
	dialCloseCommHandle(globals);

	DPF(3, "lineDeallocateCall");
	DPF(3, ">      hCall: %08X", globals->hCall);

	lResult = lineDeallocateCall(globals->hCall);
	LINEERROR(lResult);

	globals->hCall = 0;

Failure:
	return (lResult);
}

/* dialIsConnected- returns TRUE if call is connected */

#undef DPF_MODNAME
#define DPF_MODNAME	"dialIsConnected"

BOOL dialIsConnected(LPDPDIAL globals)
{
	// connected if we have a call handle and the state is connected
	if ((globals->hCall) &&
		(globals->dwCallState == LINECALLSTATE_CONNECTED))
		return (TRUE);
	else
		return (FALSE);
}

/* callback function */

#undef DPF_MODNAME
#define DPF_MODNAME	"LineCallBackProc"

void FAR PASCAL LineCallBackProc(DWORD hDevice, DWORD dwMessage, DWORD_PTR dwInstance,
								 DWORD_PTR dwParam1, DWORD_PTR dwParam2, DWORD_PTR dwParam3)
{
	LPDPDIAL	globals = (LPDPDIAL) dwInstance;

	DPF(3, "Line message: %s", GetLineMsgStr(dwMessage));

    switch (dwMessage)
	{
	case LINE_LINEDEVSTATE:
		break;

	case LINE_CALLSTATE:

		globals->dwCallState = dwParam1;

		DPF(3, "  call state: %s", GetCallStateStr((DWORD)globals->dwCallState));

		switch (globals->dwCallState)
		{
		case LINECALLSTATE_OFFERING:
			ProcessOfferingState(globals, (HCALL) hDevice, (DWORD)dwParam3);
			break;

		case LINECALLSTATE_CONNECTED:
			ProcessConnectedState(globals, (HCALL) hDevice, (DWORD)dwParam2, (DWORD)dwParam3);
			break;

		case LINECALLSTATE_DISCONNECTED:
			ProcessDisconnectedState(globals, (HCALL) hDevice, (DWORD)dwParam2, (DWORD)dwParam3);
			break;

		case LINECALLSTATE_IDLE:
			ProcessIdleState(globals, (HCALL) hDevice, (DWORD)dwParam2, (DWORD)dwParam3);
			break;

		case LINECALLSTATE_BUSY:
			break;
		}
		break;

	case LINE_REPLY:
		ProcessReplyMessage(globals, (DWORD)dwParam1, (LINERESULT) dwParam2);
		break;

	/* other messages that can be processed */
	case LINE_CLOSE:
		// the line has shut itself down
		globals->hLine = 0;
		globals->dwCallError = CALL_CLOSED;
		break;
	case LINE_ADDRESSSTATE:
		break;
	case LINE_CALLINFO:
		break;
	case LINE_DEVSPECIFIC:
		break;
	case LINE_DEVSPECIFICFEATURE:
		break;
	case LINE_GATHERDIGITS:
		break;
	case LINE_GENERATE:
		break;
	case LINE_MONITORDIGITS:
		break;
	case LINE_MONITORMEDIA:
		break;
	case LINE_MONITORTONE:
		break;
	} /* switch */

} /* LineCallBackProc */

/* ProcessOfferingState - handler for LINECALLSTATE_OFFERING state */

#undef DPF_MODNAME
#define DPF_MODNAME	"ProcessOfferingState"

void ProcessOfferingState(LPDPDIAL globals, HCALL hCall, DWORD dwCallPrivilege)
{
	LINERESULT	lResult;

	DDASSERT(hCall);
	DDASSERT(globals->hCall == 0);
	DDASSERT(globals->dwAsyncID == 0);

	DPF(3, "       hCall: %08X", hCall);
	DPF(3, "   privilege: %08X", (DWORD)dwCallPrivilege);

	// fail if we don't own the call
	FAILIF(dwCallPrivilege != LINECALLPRIVILEGE_OWNER, Failure);

	// answer the call
	lResult = lineAnswer(hCall, NULL, 0);

	// lResult will be > 0 if call is asynchronous
	FAILWITHACTION(lResult < 0, LINEERROR(lResult), Failure);
	FAILMSG(lResult == 0);

	globals->hCall = hCall;					// store call handle
	globals->dwAsyncID = lResult;			// store async ID

Failure:
	return;
}

/* ProcessConnectedState - handler for LINECALLSTATE_CONNECTED state */

#undef DPF_MODNAME
#define DPF_MODNAME	"ProcessConnectedState"

void ProcessConnectedState(LPDPDIAL globals, HCALL hCall, DWORD dwCallStateDetail, DWORD dwCallPrivilege)
{
	LINERESULT		lResult;
	HRESULT			hr;

	DDASSERT(hCall);
	DDASSERT(globals->hCall);
	DDASSERT(globals->hCall == hCall);

	DPF(3, "       hCall: %08X", hCall);
	DPF(3, "   privilege: %08X", dwCallPrivilege);
	DPF(3, "      detail: %08X", dwCallStateDetail);

	// get the id of the COM device connected to the modem
	// NOTE: once we get the handle, it is our responsibility to close it
	lResult = dialGetCommHandle(globals);
	FAILIF(LINEERROR(lResult), Failure);

	DPF(3, "    hComPort: %08X", globals->hComm);

	// setup com port
	hr = globals->lpComPort->Setup(globals->lpComPort, globals->hComm);
	FAILIF(FAILED(hr), Failure);		

	{
		DWORD	dwBaudRate;

		lResult = dialGetBaudRate(globals, &dwBaudRate);
	}

Failure:
	return;
}

/* ProcessDisconnectedState - handler for LINECALLSTATE_DISCONNECTED state */

#undef DPF_MODNAME
#define DPF_MODNAME	"ProcessDisconnectedState"

void ProcessDisconnectedState(LPDPDIAL globals, HCALL hCall, DWORD dwCallStateDetail, DWORD dwCallPrivilege)
{
	LINERESULT		lResult;

	DDASSERT(hCall);
	DDASSERT(globals->hCall);
	DDASSERT(globals->hCall == hCall);

	DPF(3, "       hCall: %08X", hCall);
	DPF(3, "   privilege: %08X", dwCallPrivilege);
	DPF(3, "      detail: %08X", dwCallStateDetail);

	// record error
	globals->dwCallError = CALL_DISCONNECTED;

	// shutdown com port and deallocate call handle
	lResult = dialDeallocCall(globals);
	FAILMSG(LINEERROR(lResult));
}

/* ProcessIdleState - handler for LINECALLSTATE_IDLE state */

#undef DPF_MODNAME
#define DPF_MODNAME	"ProcessIdleState"

void ProcessIdleState(LPDPDIAL globals, HCALL hCall, DWORD dwCallStateDetail, DWORD dwCallPrivilege)
{
	DDASSERT(hCall);

	DPF(3, "       hCall: %08X", hCall);
	DPF(3, "   privilege: %08X", dwCallPrivilege);
	DPF(3, "      detail: %08X", dwCallStateDetail);
}

/* ProcessReplyMessage - handler for LINE_REPLY message */

#undef DPF_MODNAME
#define DPF_MODNAME	"ProcessReplyMessage"

void ProcessReplyMessage(LPDPDIAL globals, DWORD dwAsyncID, LINERESULT lResult)
{
	DDASSERT(dwAsyncID);
	DDASSERT(globals->dwAsyncID);
	DDASSERT(globals->dwAsyncID == dwAsyncID);

	DPF(3, "   dwAsyncID: %d", dwAsyncID);
	DPF(3, "       error: %d", lResult);

	// check for an error
	if (LINEERROR(lResult))
		globals->dwCallError = CALL_LINEERROR;


	// reset field so we know reply happened
	globals->dwAsyncID = 0;
}

/* dialGetDevCaps - wrapper for lineGetDevCaps */

/*	Bug #5400

	My trusty Compaq Presario returns two line devices. The second device says it
	needs 555 bytes for dev caps, but when you give it a pointer to a 555-byte block
	it actually writes 559 (!) bytes into the buffer! Whoah, Bessy!

	This makes Windows very unhappy in strange and magical ways.

	The fix is to start with a very large buffer (1024 bytes?) like all the samples do
	and then leave some slop in subsequent reallocs, which should hopefully clean up
	after these messy critters.
*/

#define DEVCAPSINITIALSIZE	1024		// size of first alloc
#define DEVCAPSSLOP			100			// extra space that loser service providers can party on

#undef DPF_MODNAME
#define DPF_MODNAME	"dialGetDevCaps"

LINERESULT dialGetDevCaps(LPDPDIAL globals, DWORD dwLine, DWORD dwAPIVersion, LPLINEDEVCAPS	*lpDevCapsRet)
{
	LPLINEDEVCAPS	lpDevCaps;
	LINERESULT		lResult;
	LPVOID			lpTemp;

	// create a buffer for dev caps
	lpDevCaps = (LPLINEDEVCAPS) SP_MemAlloc(DEVCAPSINITIALSIZE + DEVCAPSSLOP);
	FAILWITHACTION(lpDevCaps == NULL, lResult = LINEERROR(LINEERR_NOMEM), Failure);
	lpDevCaps->dwTotalSize = DEVCAPSINITIALSIZE;

	while (TRUE)
	{
		// get device caps
		lResult = lineGetDevCaps(globals->hLineApp, dwLine,
								 dwAPIVersion, 0, lpDevCaps);

		if (lResult == SUCCESS)
		{
			// make sure there is enough space
			if (lpDevCaps->dwNeededSize <= lpDevCaps->dwTotalSize)
				break;		// there is enough space, so exit
		}
		else if (lResult != LINEERR_STRUCTURETOOSMALL)
		{
			LINEERROR(lResult);
			goto Failure;
		}

		// reallocate buffer if not big enough */

		lpTemp = SP_MemReAlloc(lpDevCaps, lpDevCaps->dwNeededSize + DEVCAPSSLOP);
		FAILWITHACTION(lpTemp == NULL, lResult = LINEERROR(LINEERR_NOMEM), Failure);

		lpDevCaps = lpTemp;
		lpDevCaps->dwTotalSize = lpDevCaps->dwNeededSize;
	}

	*lpDevCapsRet = lpDevCaps;
	return (SUCCESS);

Failure:
	if (lpDevCaps)
		SP_MemFree(lpDevCaps);
	return (lResult);
}

/* dialGetCallInfo - wrapper for lineGetCallInfo */

#undef DPF_MODNAME
#define DPF_MODNAME	"dialGetCallInfo"

LINERESULT dialGetCallInfo(LPDPDIAL globals, LPLINECALLINFO *lpCallInfoRet)
{
	LPLINECALLINFO	lpCallInfo;
	LINERESULT		lResult;
	LPVOID			lpTemp;

	// create a buffer for call info
	lpCallInfo = (LPLINECALLINFO) SP_MemAlloc(sizeof(LINECALLINFO));
	FAILWITHACTION(lpCallInfo == NULL, lResult = LINEERROR(LINEERR_NOMEM), Failure);
	lpCallInfo->dwTotalSize = sizeof(LINECALLINFO);

	while (TRUE)
	{
		// get device info
		lResult = lineGetCallInfo(globals->hCall, lpCallInfo);

		if (lResult == SUCCESS)
		{
			// make sure there is enough space
			if (lpCallInfo->dwNeededSize <= lpCallInfo->dwTotalSize)
				break;		// there is enough space, so exit
		}
		else if (lResult != LINEERR_STRUCTURETOOSMALL)
		{
			LINEERROR(lResult);
			goto Failure;
		}

		// reallocate buffer if not big enough */

		lpTemp = SP_MemReAlloc(lpCallInfo, lpCallInfo->dwNeededSize);
		FAILWITHACTION(lpTemp == NULL, lResult = LINEERROR(LINEERR_NOMEM), Failure);

		lpCallInfo = lpTemp;
		lpCallInfo->dwTotalSize = lpCallInfo->dwNeededSize;
	}

	*lpCallInfoRet = lpCallInfo;
	return (SUCCESS);

Failure:
	if (lpCallInfo)
		SP_MemFree(lpCallInfo);
	return (lResult);
}

/* dialGetBaudRate - get baud rate of current connecton */

#undef DPF_MODNAME
#define DPF_MODNAME	"dialGetBaudRate"

LINERESULT dialGetBaudRate(LPDPDIAL globals, LPDWORD lpdwBaudRate)
{
	LPLINECALLINFO	lpCallInfo;
	LINERESULT		lResult;

	lResult = dialGetCallInfo(globals, &lpCallInfo);
	if LINEERROR(lResult)
		return (lResult);

	*lpdwBaudRate = lpCallInfo->dwRate;

	SP_MemFree(lpCallInfo);

	return (SUCCESS);
}

/* dialGetTranslateCaps - wrapper for lineGetTranslateCaps */

#undef DPF_MODNAME
#define DPF_MODNAME	"dialGetTranslateCaps"

LINERESULT dialGetTranslateCaps(LPDPDIAL globals, DWORD dwAPIVersion, LPLINETRANSLATECAPS *lpTranslateCapsRet)
{
	LPLINETRANSLATECAPS	lpTranslateCaps;
	LPVOID				lpTemp;
	LINERESULT			lResult;

	// create a buffer for translate caps
	lpTranslateCaps = (LPLINETRANSLATECAPS) SP_MemAlloc(sizeof(LINETRANSLATECAPS));
	FAILWITHACTION(lpTranslateCaps == NULL, lResult = LINEERROR(LINEERR_NOMEM), Failure);
	lpTranslateCaps->dwTotalSize = sizeof(LINETRANSLATECAPS);

	while (TRUE)
	{
		// get translate caps
		lResult = lineGetTranslateCaps(globals->hLineApp, dwAPIVersion, lpTranslateCaps);

		if (lResult == SUCCESS)
		{
			// make sure there is enough space
			if (lpTranslateCaps->dwNeededSize <= lpTranslateCaps->dwTotalSize)
				break;		// there is enough space, so exit
		}
		else if (lResult != LINEERR_STRUCTURETOOSMALL)
		{
			LINEERROR(lResult);
			goto Failure;
		}

		// reallocate buffer if not big enough */

		lpTemp = SP_MemReAlloc(lpTranslateCaps, lpTranslateCaps->dwNeededSize);
		FAILWITHACTION(lpTemp == NULL, lResult = LINEERROR(LINEERR_NOMEM), Failure);

		lpTranslateCaps = lpTemp;
		lpTranslateCaps->dwTotalSize = lpTranslateCaps->dwNeededSize;
	}

	*lpTranslateCapsRet = lpTranslateCaps;
	return (SUCCESS);

Failure:
	if (lpTranslateCaps)
		SP_MemFree(lpTranslateCaps);
	return (lResult);
}

/* dialGetCommHandle - wrapper for lineGetID */

#undef DPF_MODNAME
#define DPF_MODNAME	"dialGetCommHandle"

/* structure returned by Unimodem which contains device handle and name */
typedef struct {
	HANDLE			hComm;
	CHAR			szDeviceName[1];
} COMMID, *LPCOMMID;

LINERESULT dialGetCommHandle(LPDPDIAL globals)
{
	LPCOMMID	lpCommID;
	VARSTRING	*vs, *temp;
	LINERESULT	lResult;

    vs = (VARSTRING *) SP_MemAlloc(sizeof(VARSTRING));
	FAILWITHACTION(vs == NULL, lResult = LINEERR_NOMEM, Failure);

    vs->dwTotalSize = sizeof(VARSTRING);
    vs->dwStringFormat = STRINGFORMAT_BINARY;

	while (TRUE)
	{
		// get line ID
		lResult = lineGetID(0, 0L, globals->hCall, LINECALLSELECT_CALL, vs, "comm/datamodem");

		if (lResult == SUCCESS)
		{
			// make sure there is enough space
			if (vs->dwNeededSize <= vs->dwTotalSize)
				break;		// there is enough space, so exit
		}
		else if (lResult != LINEERR_STRUCTURETOOSMALL)
		{
			LINEERROR(lResult);
			goto Failure;
		}

		// reallocate buffer if not big enough */

		temp = SP_MemReAlloc(vs, vs->dwNeededSize);
		FAILWITHACTION(temp == NULL, lResult = LINEERROR(LINEERR_NOMEM), Failure);

		vs = temp;
		vs->dwTotalSize = vs->dwNeededSize;
	}

    lpCommID = (LPCOMMID) ((LPSTR)vs + vs->dwStringOffset);
//    lstrcpy(globals->szDeviceName, cid->szDeviceName);
	globals->hComm = lpCommID->hComm;

Failure:
	if (vs)
		SP_MemFree(vs);
	return (lResult);
}

/*	dialCloseCommHandle - make sure com port is closed */

/*	NOTE: As per the docs for the "comm/datamodem" device class,
	the handle to the com port returned by lineGetID() MUST be explictly
	closed using CloseHandle() or you will not be able to to open this
	line again!
*/

#undef DPF_MODNAME
#define DPF_MODNAME	"dialCloseCommHandle"

LINERESULT dialCloseCommHandle(LPDPDIAL globals)
{
	HANDLE	hCom;

	// make sure the com port globals are available
	if (globals->lpComPort)
	{
			// get handle to com port
			hCom = globals->lpComPort->GetHandle(globals->lpComPort);

			// make sure its closed down
			if (hCom)
			{
				globals->lpComPort->Shutdown(globals->lpComPort);
				CloseHandle(hCom);
			}
	}

	return (SUCCESS);
}

/* dialTranslateAddress - wrapper for lineTranslateAddress */

#undef DPF_MODNAME
#define DPF_MODNAME	"dialTranslateAddress"

LINERESULT dialTranslateAddress(LPDPDIAL globals, DWORD dwDeviceID, DWORD dwAPIVersion,
								LPCSTR lpszDialAddress,
								LPLINETRANSLATEOUTPUT *lpLineTranslateOutputRet)
{
	LPLINETRANSLATEOUTPUT	lpLineTranslateOutput;
	LPVOID					lpTemp;
	LINERESULT				lResult;

	// create a buffer for translate caps
	lpLineTranslateOutput = (LPLINETRANSLATEOUTPUT) SP_MemAlloc(sizeof(LINETRANSLATEOUTPUT));
	FAILWITHACTION(lpLineTranslateOutput == NULL, lResult = LINEERROR(LINEERR_NOMEM), Failure);
	lpLineTranslateOutput->dwTotalSize = sizeof(LINETRANSLATEOUTPUT);

	while (TRUE)
	{
		// translate address
		lResult = lineTranslateAddress(globals->hLineApp, dwDeviceID, dwAPIVersion,
									   lpszDialAddress, 0, LINETRANSLATEOPTION_CANCELCALLWAITING,
									   lpLineTranslateOutput);

		if (lResult == SUCCESS)
		{
			// make sure there is enough space
			if (lpLineTranslateOutput->dwNeededSize <= lpLineTranslateOutput->dwTotalSize)
				break;		// there is enough space, so exit
		}
		else if (lResult != LINEERR_STRUCTURETOOSMALL)
		{
			LINEERROR(lResult);
			goto Failure;
		}

		// reallocate buffer if not big enough */

		lpTemp = SP_MemReAlloc(lpLineTranslateOutput, lpLineTranslateOutput->dwNeededSize);
		FAILWITHACTION(lpTemp == NULL, lResult = LINEERROR(LINEERR_NOMEM), Failure);

		lpLineTranslateOutput = lpTemp;
		lpLineTranslateOutput->dwTotalSize = lpLineTranslateOutput->dwNeededSize;
	}

	*lpLineTranslateOutputRet = lpLineTranslateOutput;
	return (SUCCESS);

Failure:
	if (lpLineTranslateOutput)
		SP_MemFree(lpLineTranslateOutput);
	return (lResult);
}

LINERESULT dialTranslateDialog(LPDPDIAL globals, HWND hWnd,
							   DWORD dwDeviceID, LPTSTR szPhoneNumber)
{
	LINERESULT	lResult;

	lResult = lineTranslateDialog(globals->hLineApp, dwDeviceID,
		TAPIVERSION, hWnd, szPhoneNumber);

	return (lResult);
}

//
//  FUNCTION: void dialFillModemComboBox(HWND)
//
//  PURPOSE: Fills the modem control with the available line devices.
//
//  PARAMETERS:
//    hwndDlg - handle to the current "Dial" dialog
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
//    This function enumerates through all the TAPI line devices and
//    queries each for the device name.  The device name is then put into
//    the 'TAPI Line' control.  These device names are kept in order rather
//    than sorted.  This allows "Dial" to know which device ID the user
//    selected just by the knowing the index of the selected string.
//
//    There are default values if there isn't a device name, if there is
//    an error on the device, or if the device name is an empty string.
//    The device name is also checked to make sure it is null terminated.
//
//    Note that a Legacy API Version is negotiated.  Since the fields in
//    the LINEDEVCAPS structure that we are interested in haven't moved, we
//    can negotiate a lower API Version than this sample is designed for
//    and still be able to access the necessary structure members.
//
//    The first line that is usable by TapiComm is selected as the 'default'
//    line.  Also note that if there was a previously selected line, this
//    remains the default line.  This would likely only occur if this
//    function is called after the dialog has initialized once; for example,
//    if a new line is added.
//
//

LINERESULT dialGetModemName(LPDPDIAL globals, DWORD dwDeviceID,
						 LPSTR lpszModemName, DWORD dwModemNameSize)
{
    LPLINEDEVCAPS	lpLineDevCaps = NULL;
    LPSTR			lpszLineName;
	LINEEXTENSIONID lineExtensionID;	// Will be set to 0 to indicate no known extensions
	DWORD			dwAPIVersion;       // api version
	DWORD			dwStrSize;
	LINERESULT		lResult;

	/* negotiate API version for each line */
	lResult = lineNegotiateAPIVersion(globals->hLineApp, dwDeviceID,
					TAPIVERSION, TAPIVERSION,
					&dwAPIVersion, &lineExtensionID);
	if LINEERROR(lResult)
		goto FAILURE;

	lResult = dialGetDevCaps(globals, dwDeviceID, dwAPIVersion, &lpLineDevCaps);
	if LINEERROR(lResult)
		goto FAILURE;

    if ((lpLineDevCaps->dwLineNameSize) &&
        (lpLineDevCaps->dwLineNameOffset) &&
        (lpLineDevCaps->dwStringFormat == STRINGFORMAT_ASCII) &&
        (lpLineDevCaps->dwMediaModes & LINEMEDIAMODE_DATAMODEM))
    {
        // This is the name of the device.
        lpszLineName = ((char *) lpLineDevCaps) + lpLineDevCaps->dwLineNameOffset;

        if (lpszLineName[0] != '\0')
        {
			// Reverse indented to make this fit

			// Make sure the device name is null terminated.
			if (lpszLineName[lpLineDevCaps->dwLineNameSize -1] != '\0')
			{
				// If the device name is not null terminated, null
				// terminate it.  Yes, this looses the end character.
				// Its a bug in the service provider.
				lpszLineName[lpLineDevCaps->dwLineNameSize-1] = '\0';
				DPF(0, "Device name for device 0x%lx is not null terminated.", dwDeviceID);
			}
        }
        else // Line name started with a NULL.
		{
			lResult = LINEERR_OPERATIONFAILED;
            goto FAILURE;
		}
    }
    else  // DevCaps doesn't have a valid line name.  Unnamed.
	{
		lResult = LINEERR_OPERATIONFAILED;
        goto FAILURE;
	}

	// return modem name (make sure it fits)
	dwStrSize = strlen(lpszLineName) + 1;
	if (dwStrSize <= dwModemNameSize)
		CopyMemory(lpszModemName, lpszLineName, dwStrSize);
	else
	{
		CopyMemory(lpszModemName, lpszLineName, dwModemNameSize - 1);
		lpszModemName[dwModemNameSize - 1] = '\0';
	}

FAILURE:
	if (lpLineDevCaps)
		SP_MemFree(lpLineDevCaps);

	return (lResult);
}

LINERESULT dialGetModemList(LPDPDIAL globals, BOOL bAnsi, LPVOID *lplpData, LPDWORD lpdwDataSize)
{
    DWORD			dwDeviceID;
	CHAR			szModemName[MAXSTRINGSIZE];
	LPBYTE			lpData;
	DWORD			dwDataSize, dwStrBytes, dwStrLen;
	LINERESULT		lResult;

	// make space for all possible strings plus terminating null
	lpData = (LPBYTE) SP_MemAlloc(globals->dwNumLines * MAXSTRINGSIZE * sizeof(WCHAR) + sizeof(WCHAR));
	FAILWITHACTION(lpData == NULL, lResult = LINEERR_NOMEM, Failure);

	dwDataSize = 0;
    for (dwDeviceID = 0; dwDeviceID < globals->dwNumLines; dwDeviceID ++)
    {
		lResult = dialGetModemName(globals, dwDeviceID, szModemName, MAXSTRINGSIZE);
		if LINEERROR(lResult)
			continue;

		if (bAnsi)
		{
			dwStrBytes = (lstrlen(szModemName) + 1) * sizeof(CHAR);
			memcpy(lpData + dwDataSize, szModemName, dwStrBytes);
		}
		else
		{
			// NOTE: AnsiToWide returns the character count INCLUDING the terminating null character
			dwStrLen = AnsiToWide((LPWSTR) (lpData + dwDataSize), szModemName, MAXSTRINGSIZE * sizeof(WCHAR));
			dwStrBytes = dwStrLen * sizeof(WCHAR);
		}

		dwDataSize += dwStrBytes;
	}

	// put a null at end of list to terminate it
	if (bAnsi)
	{
		*(lpData + dwDataSize) = 0;
		dwDataSize += sizeof(CHAR);
	}
	else
	{
		*((LPWSTR) (lpData + dwDataSize)) = 0;
		dwDataSize += sizeof(WCHAR);
	}

	// return buffer pointer and size
	*lplpData = lpData;
	*lpdwDataSize = dwDataSize;

	return (SUCCESS);

Failure:
	return (lResult);
}

void dialFillModemComboBox(LPDPDIAL globals, HWND hwndDlg, int item, DWORD dwDefaultDevice)
{
    DWORD			dwDeviceID;
	CHAR			szModemName[MAXSTRINGSIZE];
	LINERESULT		lResult;


	for (dwDeviceID = 0; dwDeviceID < globals->dwNumLines; dwDeviceID ++)
    {
		//
		// Attempt to get the modem name.  If this fails, don't add the modem
		// to the dialog.
		//
		lResult = dialGetModemName(globals, dwDeviceID, szModemName, MAXSTRINGSIZE);
		if ( LINEERROR(lResult) == FALSE )
		{
			//
			// This line appears to be usable, put the device name into the
			// dialog control and associate the TAPI modem ID with it
			//
			lResult = (DWORD) SendDlgItemMessage(hwndDlg, item,
				CB_ADDSTRING, 0, (LPARAM) szModemName);

			if ( lResult != CB_ERRSPACE )
			{
				DWORD_PTR	TempReturn;


				//
				// We've managed to get this entry into the control, make sure
				// we associate the proper TAPI modem ID with this item.  This
				// should never fail.
				//
				TempReturn = SendDlgItemMessage( hwndDlg, item, CB_SETITEMDATA, lResult, dwDeviceID );
				DDASSERT( TempReturn != CB_ERR );

				// If this line is usable and we don't have a default initial
				// line yet, make this the initial line.
				if (dwDefaultDevice == MAXDWORD)
					dwDefaultDevice = lResult;
			}
		}
	}

    if (dwDefaultDevice == MAXDWORD)
        dwDefaultDevice = 0;

    // Set the initial default line
    SendDlgItemMessage(hwndDlg, item,
        CB_SETCURSEL, dwDefaultDevice, 0);
}

LRESULT dialGetDeviceIDFromName(LPDPDIAL globals, LPCSTR szTargetName, DWORD *lpdwDeviceID)
{
    DWORD			dwDeviceID;
	CHAR			szModemName[MAXSTRINGSIZE];
	LINERESULT		lResult;

    for (dwDeviceID = 0; dwDeviceID < globals->dwNumLines; dwDeviceID ++)
    {
		lResult = dialGetModemName(globals, dwDeviceID, szModemName, MAXSTRINGSIZE);
		if LINEERROR(lResult)
			continue;

		if (strcmp(szModemName, szTargetName) == 0)
		{
			*lpdwDeviceID = dwDeviceID;
			return (SUCCESS);
		}
	}

	return (LINEERR_OPERATIONFAILED);
}

//
//  FUNCTION: void dialFillLocationComboBox(HWND)
//
//  PURPOSE: Fills the control with the available calling from locations.
//
//  PARAMETERS:
//    hwndDlg - handle to the current "Dial" dialog
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
//

void dialFillLocationComboBox(LPDPDIAL globals, HWND hwndDlg, int item, DWORD dwDefaultLocation)
{
    LPLINETRANSLATECAPS	lpTranslateCaps = NULL;
	LPLINELOCATIONENTRY lpLocationEntry;
	DWORD				dwCounter;
	LONG				index;
	LINERESULT			lResult;

	// get translate caps
	lResult = dialGetTranslateCaps(globals, TAPIVERSION, &lpTranslateCaps);
	if LINEERROR(lResult)
		return;

    // Find the location information in the TRANSLATECAPS
    lpLocationEntry = (LPLINELOCATIONENTRY)
        (((LPBYTE) lpTranslateCaps) + lpTranslateCaps->dwLocationListOffset);

    // First empty the combobox
    SendDlgItemMessage(hwndDlg, item, CB_RESETCONTENT, (WPARAM) 0, (LPARAM) 0);

    // enumerate all the locations
    for (dwCounter = 0; dwCounter < lpTranslateCaps->dwNumLocations; dwCounter++)
    {
        // Put each one into the combobox
        index = (DWORD)SendDlgItemMessage(hwndDlg, item,
						CB_ADDSTRING,
						(WPARAM) 0,
						(LPARAM) (((LPBYTE) lpTranslateCaps) +
						lpLocationEntry[dwCounter].dwLocationNameOffset));

        // Is this location the 'current' location?
        if (lpLocationEntry[dwCounter].dwPermanentLocationID ==
            lpTranslateCaps->dwCurrentLocationID)
        {
            // Set this to be the active location.
            SendDlgItemMessage(hwndDlg, item, CB_SETCURSEL, (WPARAM) index, (LPARAM) 0);
        }
    }

	if (lpTranslateCaps)
		SP_MemFree(lpTranslateCaps);
}


char	gTempStr[200];

LONG lineError(LONG err, LPSTR modName, DWORD lineNum)
{
	if (err)
		DPF(0, "TAPI line error in %s at line %d : %s", modName, lineNum, GetLineErrStr(err));

	return (err);
}

LPSTR GetCallStateStr(DWORD callState)
{
	switch (callState)
	{
	case LINECALLSTATE_IDLE: return ("LINECALLSTATE_IDLE");
	case LINECALLSTATE_OFFERING: return ("LINECALLSTATE_OFFERING");
	case LINECALLSTATE_ACCEPTED: return ("LINECALLSTATE_ACCEPTED");
	case LINECALLSTATE_DIALTONE: return ("LINECALLSTATE_DIALTONE");
	case LINECALLSTATE_DIALING: return ("LINECALLSTATE_DIALING");
	case LINECALLSTATE_RINGBACK: return ("LINECALLSTATE_RINGBACK");
	case LINECALLSTATE_BUSY: return ("LINECALLSTATE_BUSY");
	case LINECALLSTATE_SPECIALINFO: return ("LINECALLSTATE_SPECIALINFO");
	case LINECALLSTATE_CONNECTED: return ("LINECALLSTATE_CONNECTED");
	case LINECALLSTATE_PROCEEDING: return ("LINECALLSTATE_PROCEEDING");
	case LINECALLSTATE_ONHOLD: return ("LINECALLSTATE_ONHOLD");
	case LINECALLSTATE_CONFERENCED: return ("LINECALLSTATE_CONFERENCED");
	case LINECALLSTATE_ONHOLDPENDCONF: return ("LINECALLSTATE_ONHOLDPENDCONF");
	case LINECALLSTATE_ONHOLDPENDTRANSFER: return ("LINECALLSTATE_ONHOLDPENDTRANSFER");
	case LINECALLSTATE_DISCONNECTED: return ("LINECALLSTATE_DISCONNECTED");
	case LINECALLSTATE_UNKNOWN: return ("LINECALLSTATE_UNKNOWN");
	}

	wsprintf(gTempStr, "UNKNOWN CALL STATE = %lu", callState);
	return (gTempStr);
}

LPSTR GetLineMsgStr(DWORD msg)
{
	switch (msg)
	{
	case LINE_ADDRESSSTATE: return ("LINE_ADDRESSSTATE");
	case LINE_CALLINFO: return ("LINE_CALLINFO");
	case LINE_CALLSTATE: return ("LINE_CALLSTATE");
	case LINE_CLOSE: return ("LINE_CLOSE");
	case LINE_DEVSPECIFIC: return ("LINE_DEVSPECIFIC");
	case LINE_DEVSPECIFICFEATURE: return ("LINE_DEVSPECIFICFEATURE");
	case LINE_GATHERDIGITS: return ("LINE_GATHERDIGITS");
	case LINE_GENERATE: return ("LINE_GENERATE");
	case LINE_LINEDEVSTATE: return ("LINE_LINEDEVSTATE");
	case LINE_MONITORDIGITS: return ("LINE_MONITORDIGITS");
	case LINE_MONITORMEDIA: return ("LINE_MONITORMEDIA");
	case LINE_MONITORTONE: return ("LINE_MONITORTONE");
	case LINE_REPLY: return ("LINE_REPLY");
	case LINE_REQUEST: return ("LINE_REQUEST");
	}

	wsprintf(gTempStr, "UNKNOWN LINE MESSAGE = %lu", msg);
	return (gTempStr);
}


LPSTR GetLineErrStr(LONG err)
{
	switch (err)
	{
	case LINEERR_ADDRESSBLOCKED: return ("LINEERR_ADDRESSBLOCKED");
	case LINEERR_ALLOCATED: return ("LINEERR_ALLOCATED");
	case LINEERR_BADDEVICEID: return ("LINEERR_BADDEVICEID");
	case LINEERR_BEARERMODEUNAVAIL: return ("LINEERR_BEARERMODEUNAVAIL");
	case LINEERR_CALLUNAVAIL: return ("LINEERR_CALLUNAVAIL");
	case LINEERR_COMPLETIONOVERRUN: return ("LINEERR_COMPLETIONOVERRUN");
	case LINEERR_CONFERENCEFULL: return ("LINEERR_CONFERENCEFULL");
	case LINEERR_DIALBILLING: return ("LINEERR_DIALBILLING");
	case LINEERR_DIALQUIET: return ("LINEERR_DIALQUIET");
	case LINEERR_DIALDIALTONE: return ("LINEERR_DIALDIALTONE");
	case LINEERR_DIALPROMPT: return ("LINEERR_DIALPROMPT");
	case LINEERR_INCOMPATIBLEAPIVERSION: return ("LINEERR_INCOMPATIBLEAPIVERSION");
	case LINEERR_INCOMPATIBLEEXTVERSION: return ("LINEERR_INCOMPATIBLEEXTVERSION");
	case LINEERR_INIFILECORRUPT: return ("LINEERR_INIFILECORRUPT");
	case LINEERR_INUSE: return ("LINEERR_INUSE");
	case LINEERR_INVALADDRESS: return ("LINEERR_INVALADDRESS");
	case LINEERR_INVALADDRESSID: return ("LINEERR_INVALADDRESSID");
	case LINEERR_INVALADDRESSMODE: return ("LINEERR_INVALADDRESSMODE");
	case LINEERR_INVALADDRESSSTATE: return ("LINEERR_INVALADDRESSSTATE");
	case LINEERR_INVALAPPHANDLE: return ("LINEERR_INVALAPPHANDLE");
	case LINEERR_INVALAPPNAME: return ("LINEERR_INVALAPPNAME");
	case LINEERR_INVALBEARERMODE: return ("LINEERR_INVALBEARERMODE");
	case LINEERR_INVALCALLCOMPLMODE: return ("LINEERR_INVALCALLCOMPLMODE");
	case LINEERR_INVALCALLHANDLE: return ("LINEERR_INVALCALLHANDLE");
	case LINEERR_INVALCALLPARAMS: return ("LINEERR_INVALCALLPARAMS");
	case LINEERR_INVALCALLPRIVILEGE: return ("LINEERR_INVALCALLPRIVILEGE");
	case LINEERR_INVALCALLSELECT: return ("LINEERR_INVALCALLSELECT");
	case LINEERR_INVALCALLSTATE: return ("LINEERR_INVALCALLSTATE");
	case LINEERR_INVALCALLSTATELIST: return ("LINEERR_INVALCALLSTATELIST");
	case LINEERR_INVALCARD: return ("LINEERR_INVALCARD");
	case LINEERR_INVALCOMPLETIONID: return ("LINEERR_INVALCOMPLETIONID");
	case LINEERR_INVALCONFCALLHANDLE: return ("LINEERR_INVALCONFCALLHANDLE");
	case LINEERR_INVALCONSULTCALLHANDLE: return ("LINEERR_INVALCONSULTCALLHANDLE");
	case LINEERR_INVALCOUNTRYCODE: return ("LINEERR_INVALCOUNTRYCODE");
	case LINEERR_INVALDEVICECLASS: return ("LINEERR_INVALDEVICECLASS");
	case LINEERR_INVALDIGITLIST: return ("LINEERR_INVALDIGITLIST");
	case LINEERR_INVALDIGITMODE: return ("LINEERR_INVALDIGITMODE");
	case LINEERR_INVALDIGITS: return ("LINEERR_INVALDIGITS");
	case LINEERR_INVALFEATURE: return ("LINEERR_INVALFEATURE");
	case LINEERR_INVALGROUPID: return ("LINEERR_INVALGROUPID");
	case LINEERR_INVALLINEHANDLE: return ("LINEERR_INVALLINEHANDLE");
	case LINEERR_INVALLINESTATE: return ("LINEERR_INVALLINESTATE");
	case LINEERR_INVALLOCATION: return ("LINEERR_INVALLOCATION");
	case LINEERR_INVALMEDIALIST: return ("LINEERR_INVALMEDIALIST");
	case LINEERR_INVALMEDIAMODE: return ("LINEERR_INVALMEDIAMODE");
	case LINEERR_INVALMESSAGEID: return ("LINEERR_INVALMESSAGEID");
	case LINEERR_INVALPARAM: return ("LINEERR_INVALPARAM");
	case LINEERR_INVALPARKMODE: return ("LINEERR_INVALPARKMODE");
	case LINEERR_INVALPOINTER: return ("LINEERR_INVALPOINTER");
	case LINEERR_INVALPRIVSELECT: return ("LINEERR_INVALPRIVSELECT");
	case LINEERR_INVALRATE: return ("LINEERR_INVALRATE");
	case LINEERR_INVALREQUESTMODE: return ("LINEERR_INVALREQUESTMODE");
	case LINEERR_INVALTERMINALID: return ("LINEERR_INVALTERMINALID");
	case LINEERR_INVALTERMINALMODE: return ("LINEERR_INVALTERMINALMODE");
	case LINEERR_INVALTIMEOUT: return ("LINEERR_INVALTIMEOUT");
	case LINEERR_INVALTONE: return ("LINEERR_INVALTONE");
	case LINEERR_INVALTONELIST: return ("LINEERR_INVALTONELIST");
	case LINEERR_INVALTONEMODE: return ("LINEERR_INVALTONEMODE");
	case LINEERR_INVALTRANSFERMODE: return ("LINEERR_INVALTRANSFERMODE");
	case LINEERR_LINEMAPPERFAILED: return ("LINEERR_LINEMAPPERFAILED");
	case LINEERR_NOCONFERENCE: return ("LINEERR_NOCONFERENCE");
	case LINEERR_NODEVICE: return ("LINEERR_NODEVICE");
	case LINEERR_NODRIVER: return ("LINEERR_NODRIVER");
	case LINEERR_NOMEM: return ("LINEERR_NOMEM");
	case LINEERR_NOMULTIPLEINSTANCE: return ("LINEERR_NOMULTIPLEINSTANCE");
	case LINEERR_NOREQUEST: return ("LINEERR_NOREQUEST");
	case LINEERR_NOTOWNER: return ("LINEERR_NOTOWNER");
	case LINEERR_NOTREGISTERED: return ("LINEERR_NOTREGISTERED");
	case LINEERR_OPERATIONFAILED: return ("LINEERR_OPERATIONFAILED");
	case LINEERR_OPERATIONUNAVAIL: return ("LINEERR_OPERATIONUNAVAIL");
	case LINEERR_RATEUNAVAIL: return ("LINEERR_RATEUNAVAIL");
	case LINEERR_REINIT: return ("LINEERR_REINIT");
	case LINEERR_RESOURCEUNAVAIL: return ("LINEERR_RESOURCEUNAVAIL");
	case LINEERR_STRUCTURETOOSMALL: return ("LINEERR_STRUCTURETOOSMALL");
	case LINEERR_TARGETNOTFOUND: return ("LINEERR_TARGETNOTFOUND");
	case LINEERR_TARGETSELF: return ("LINEERR_TARGETSELF");
	case LINEERR_UNINITIALIZED: return ("LINEERR_UNINITIALIZED");
	case LINEERR_USERUSERINFOTOOBIG: return ("LINEERR_USERUSERINFOTOOBIG");
	}

	wsprintf(gTempStr, "UNKNOWN LINE ERROR = %ld", err);
	return (gTempStr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\serial\dllmain.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dllmain.c
 *  Content:	Main entry point for the DLL.
 *  History:
 *@@BEGIN_MSINTERNAL
 *   Date	By	Reason
 *   ====	==	======
 *  4/10/96	kipo	created it
 *  4/15/96 kipo	added msinternal
 *  6/18/96 kipo	changed ghInstance to be an HINSTANCE
 * 12/22/00 aarono   #190380 - use process heap for memory allocation
 *@@END_MSINTERNAL
 ***************************************************************************/

#include <windows.h>

#include "dpf.h"
#include "macros.h"

DWORD		gdwRefCount = 0;		// no. of attached processes
HINSTANCE	ghInstance = NULL;		// instance of our DLL

/*
 * DllMain
 *
 * Main entry point for DLL.
 */

#undef DPF_MODNAME
#define DPF_MODNAME "DllMain"

BOOL WINAPI DllMain(HINSTANCE hmod, DWORD dwReason, LPVOID lpvReserved)
{
	switch( dwReason )
	{
	case DLL_PROCESS_ATTACH:

		DisableThreadLibraryCalls( hmod );
		DPFINIT(); // bugbug : dpfinit for every proc?

		DPF( 0, "====> ENTER: DLLMAIN(%08lx): Process Attach: %08lx, tid=%08lx", DllMain,
				GetCurrentProcessId(), GetCurrentThreadId() );
			
		// initialize memory
		if( gdwRefCount == 0 )
		{
			DPF(0,"dllmain - starting up!");

			// do one-time initializations
			INIT_DPSP_CSECT();	

	        if( !MemInit() )
	        {
		        DPF( 0, "LEAVING, COULD NOT MemInit" );
		        return FALSE;
	        }

			// save the instance
			ghInstance = hmod;
		}

		gdwRefCount++;
		break;

	case DLL_PROCESS_DETACH:

		DPF( 2, "====> ENTER: DLLMAIN(%08lx): Process Detach %08lx, tid=%08lx",
			DllMain, GetCurrentProcessId(), GetCurrentThreadId() );
		
		gdwRefCount--;        
		if (gdwRefCount == 0) 
		{
			DPF(0,"DPMODEMX - dllmain - going away!");
			
		    #ifdef DEBUG
	    	    MemState();
		    #endif // debug
	    
	        MemFini(); 

		    FINI_DPSP_CSECT();

		} 
		break;

	default:
		break;
	}

    return TRUE;

} // DllMain
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\serial\daytona\makefile.inc ===
misc :
	copy ..\..\common\newdpf.h .
	copy ..\..\common\newdpf.c .
	copy ..\..\common\dputils.c .
	copy ..\..\common\memalloc.c .
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\serial\win9x\newdpf.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       newdpf.h
 *  Content:    new debug printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   10-oct-95  jeffno  initial implementation
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DEBUGPF_H
#define __DEBUGPF_H

#include <stdarg.h>
#include <windows.h>
#include <memlog.h>

#ifdef __cplusplus
	extern "C" {
#endif
#ifndef DPF_MODNAME
    extern char * DPF_MODNAME;
#endif

#if defined(DEBUG) || defined(DBG)

    #undef DEBUG_TOPIC
    #define DEBUG_TOPIC(flag,name) flag,
    typedef enum DEBUG_TOPICS {
        A=1,    /* For API Usage */
    #include "DBGTOPIC.H"
        LAST_TOPIC
    };

    #line 21
/*
    #undef DBG
    #define DBG 1
    */
    #undef DEBUG
    #define DEBUG
    #if defined( _WIN32 ) && !defined(WINNT)
	#define DEBUG_BREAK()       _try { _asm { int 3 } } _except (EXCEPTION_EXECUTE_HANDLER) {;}
    #else
	#define DEBUG_BREAK()       DebugBreak()
    #endif


    /*
     * DEBUG_TOPIC
     * This structure describes a debugging topic and associates a single-letter key to it.
     */

    #define DEBUG_TOPIC_NAME_LENGTH 59
    typedef struct
    {
        DWORD   dwSize; //for versioning
        char    cKey;
        char    cName[DEBUG_TOPIC_NAME_LENGTH];
    } DPF_DEBUG_TOPIC;

    /*
     * PROC_STATS
     * This struct saves statistics about each proc as maintained by DebugEnterProc
     */
    typedef struct
    {
        char            cName[DEBUG_TOPIC_NAME_LENGTH];
        DWORD           dwCalls;
#ifdef WIN32
        LARGE_INTEGER   liTotalTime;
        LARGE_INTEGER   liLastEnteredAt;
#else
        DWORD           dwFiller[8];
#endif
    } DPF_PROC_STATS;

    #define MAX_PROC_ORDINAL 100

    /*
     * Debugging output/flow-control calls
     */
    typedef struct {
    	UINT stat_ThrottleRate;
		UINT stat_BytesSent;
		UINT stat_BackLog;
	 	UINT stat_BytesLost;
	 	UINT stat_RemBytesReceived;
		UINT stat_Latency; 
		UINT stat_MinLatency;
		UINT stat_AvgLatency;
		UINT stat_AvgDevLatency;
		UINT stat_USER1;
		UINT stat_USER2;
		UINT stat_USER3;
		UINT stat_USER4;
		UINT stat_USER5;	// remote tDelta
		UINT stat_USER6;	// Remote tDelta sign (0=+ve, 1=-ve)
	} IN_WRITESTATS, *PIN_WRITESTATS;

	typedef struct {
		UINT	hr;
	} OUT_WRITESTATS, *POUT_WRITESTATS;

   extern void DbgWriteStats(PIN_WRITESTATS pIn);
  
   extern void DebugSetTopicsAndLevels(char * pcTopicsAndLevelsToDisplay);
   extern void DebugHalt(void);       //Break if control level allows
   extern int  DebugSetFileLineEtc(LPSTR szFile, DWORD dwLineNumber,LPSTR szFnName);
   extern int  DebugPrintf(volatile DWORD dwDetail, ...);
   extern void DebugSetMute(BOOL bMuteFlag);
   extern void DebugPrintfInit(void);
   extern void DebugEnterAPI(char *,LPDWORD);
   extern void _DDAssert(LPCSTR szFile, int nLine, LPCSTR szCondition);
 
    #define dprintf(a,b)                            DebugPrintf(a,b);
    #define DPFINIT()                               DebugPrintfInit();
    #define DPF                                     DebugSetFileLineEtc(__FILE__,__LINE__,DPF_MODNAME),DebugPrintf
    #define DPF_ERR(a)                              DebugSetFileLineEtc(__FILE__,__LINE__,DPF_MODNAME),DebugPrintf( 0, a )
    #define DPF_ENTERAPI(pIface)                    DebugEnterAPI(DPF_MODNAME,(LPDWORD)pIface)
    #define DPF_APIRETURNS(hr)                      DPF(3,"   %s returns %08x (%d)",DPF_MODNAME,hr,hr&0xfff)
    #define DDASSERT(condition)                     if (!(condition)) _DDAssert(__FILE__, __LINE__, #condition)
    #define DPF_MUTEWHEN(c)                         {DebugSetMute((BOOL) (c) );}
    #define DPF_SPEWWHEN(c)                         {DebugSetMute((BOOL) (!(c)) );}
    #define DPF_SETTOPICS(t)
    #define DPF_STRUCT(level,topic,struct_identifier,struct_ptr)    {extern void DUMP_##struct_identifier(DWORD,DWORD,LP##struct_identifier);\
                                                    DUMP_##struct_identifier(level,topic,struct_ptr);}


#else
    #pragma warning(disable:4002)
    #define DbgWriteStats()
    #define dprintf()
    #define DPFINIT()
    #define DPFFINI()
    #define DPF()
    #define DPF_ENTERAPI()
    #define DPF_APIRETURNS()
    #define DPF_DUMP()
    #define DPF_DUMPHEX()
    #define DPF_DUMPGUID()
    #define DDASSERT()
    #define DPF_ERR()
    #define DEBUG_BREAK()
    #define DPF_MUTEWHEN()
    #define DPF_SPEWWHEN()
    #define DPF_SETTOPICS()
    #define DPF_DUMPGUID()
    #define DPF_STRUCT()

#endif


#ifdef _WIN32

#ifdef DEBUG
    __inline DWORD myclockrate() {LARGE_INTEGER li; QueryPerformanceFrequency(&li); return li.LowPart;}
    __inline DWORD myclock()	 {LARGE_INTEGER li; QueryPerformanceCounter(&li);   return li.LowPart;}

    #define TIMEVAR(t)    DWORD t ## T; DWORD t ## N
    #define TIMEZERO(t)   t ## T = 0, t ## N = 0
    #define TIMESTART(t)  t ## T -= myclock(), t ## N ++
    #define TIMESTOP(t)   t ## T += myclock()
    #define TIMEFMT(t)	  ((DWORD)(t) / myclockrate()), (((DWORD)(t) * 1000 / myclockrate())%1000)
    #define TIMEOUT(t)    if (t ## N) DPF(1, #t ": %ld calls, %ld.%03ld sec (%ld.%03ld)", t ## N, TIMEFMT(t ## T), TIMEFMT(t ## T / t ## N))
#else
    #define TIMEVAR(t)
    #define TIMEZERO(t)
    #define TIMESTART(t)
    #define TIMESTOP(t)
    #define TIMEFMT(t)
    #define TIMEOUT(t)
#endif

#endif


#ifdef __cplusplus
}
#endif

#endif //__DEBUG_PF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\serial\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dpserial.rc
//
#define IDS_COM1                        1
#define IDS_COM2                        2
#define IDS_COM3                        3
#define IDS_COM4                        4
#define IDS_BAUD1                       16
#define IDS_BAUD2                       17
#define IDS_BAUD3                       18
#define IDS_BAUD4                       19
#define IDS_BAUD5                       20
#define IDS_BAUD6                       21
#define IDS_BAUD7                       22
#define IDS_BAUD8                       23
#define IDS_BAUD9                       24
#define IDS_BAUD10                      25
#define IDS_BAUD11                      26
#define IDS_BAUD12                      27
#define IDS_BAUD13                      28
#define IDS_BAUD14                      29
#define IDS_BAUD15                      30
#define IDS_STOPBIT1                    32
#define IDS_STOPBIT2                    33
#define IDS_STOPBIT3                    34
#define IDS_PARITY1                     35
#define IDS_PARITY2                     36
#define IDS_PARITY3                     37
#define IDS_PARITY4                     38
#define IDS_FLOW1                       39
#define IDS_FLOW2                       40
#define IDS_FLOW3                       41
#define IDS_FLOW4                       42
#define IDS_FLOW5                       43
#define IDS_COULDNOTOPENLINE            44
#define IDS_WAITINGFORCONNECTION        45
#define IDS_DIALING                     46
#define IDS_COULDNOTDIAL                47
#define IDD_MODEM_DIAL                  101
#define IDD_MODEM_STATUS                102
#define IDD_MODEMDIALOG                 103
#define IDD_SETTINGSDIALOG              300
#define IDD_MODEM_ANSWER                301
#define IDI_MODEM                       701
#define IDC_BAUDRATE                    1000
#define IDC_NUMBEREDIT                  1000
#define IDC_STOPBITS                    1001
#define IDC_PARITY                      1002
#define IDC_COMPORT                     1003
#define IDC_FLOW                        1009
#define IDC_NUMBER                      1009
#define IDC_DIALPROPERTIES              1010
#define IDC_DIALINGFROM                 1012
#define IDC_MODEM                       1013
#define IDC_CONFIGUREMODEM              1014
#define IDC_STATUS                      1017

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\serial\modem.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       modem.c
 *  Content:	Routines for modem I/O
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *  6/10/96	kipo	created it
 *  6/22/96	kipo	added support for EnumConnectionData(); dim "OK" button
 *					until user types at least one character.
 *	6/25/96	kipo	updated for DPADDRESS
 *	7/08/96 kipo	added support for new dialogs
 *  7/13/96	kipo	added GetModemAddress()
 *	7/16/96	kipo	changed address types to be GUIDs instead of 4CC
 *	8/10/96 kipo	added support for dialing location
 *	8/15/96 kipo	commented out support for dialing location
 *  9/04/96 dereks  fixed focus in dial/answer dialogs
 *  1/06/97 kipo	updated for objects
 *  2/11/97 kipo	pass player flags to GetAddress()
 *  2/18/97 kipo	allow multiple instances of service provider
 *	3/04/97 kipo	close com port handle when deallocating call; use string
 *					table for modem strings; updated debug output.
 *	3/17/97 kipo	added support for Unicode phone numbers
 *	3/24/97 kipo	added support for specifying which modem to use
 *  4/08/97 kipo	added support for separate modem and serial baud rates
 *  5/07/97 kipo	added support for modem choice list
 *  5/23/97 kipo	added support return status codes
 *  5/25/97 kipo	use DPERR_CONNECTING error to return status; set focus
 *					on cancel button in status window
 *  6/03/97 kipo	really make the cancel button work with return
 *  2/01/98 kipo	Display an error string in status dialog if line goes
 *					idle while dialing. Fixes bug #15251
 *  5/08/98 a-peterz #15251 - Better error state detection
 * 10/13/99	johnkan	#413516 - Mismatch between modem dialog selection and TAPI device ID
 * 12/22/00 aarono   #190380 - use process heap for memory allocation
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>

#include "dplaysp.h"
#include "dputils.h"
#include "dial.h"
#include "dpf.h"
#include "resource.h"
#include "macros.h"

// constants

enum {
	PHONENUMBERSIZE = 200,				// size of phone number string
	MODEMNAMESIZE = 200,				// size of modem name string
	TEMPSTRINGSIZE = 300,				// size of temporary strings
	MODEMTIMEOUT = 30 * 1000,			// milliseconds to wait for phone to connect
	MODEMSLEEPTIME = 50,				// milliseconds to sleep while waiting for modem
	TIMERINTERVAL = 100,
	MAXPHONENUMBERS = 10
};

// bit masks used to select connection actions
enum {
	DIALCALL		= (0 << 0),			// make a call
	ANSWERCALL		= (1 << 0),			// answer a call

	NOSETTINGS		= (0 << 1),			// no phone settings are set
	HAVESETTINGS	= (1 << 1),			// phone settings are set

	STATUSDIALOG	= (0 << 2),			// show a connection status dialog
	RETURNSTATUS	= (1 << 2)			// return status to app
};

#define MRU_SP_KEY			L"Modem Connection For DirectPlay"
#define MRU_NUMBER_KEY		L"Phone Number"

// structures

// modem object
typedef struct {
	DPCOMPORT	comPort;				// base object globals
	LPDPDIAL	lpDial;					// dialing globals
	BOOL		bHaveSettings;			// set to TRUE if we have settings
	BOOL		bAnswering;				// set to TRUE if we are answering
	DWORD		dwDeviceID;				// device id to use
	DWORD		dwLocation;				// location to use
	TCHAR		szPhoneNumber[PHONENUMBERSIZE];	// phone number to use
} DPMODEM, *LPDPMODEM;

// globals

// this is defined in dllmain.c
extern HINSTANCE		ghInstance;

// this is defined in dpserial.c
extern GUID				DPMODEM_GUID;

// prototypes

static HRESULT			DisposeModem(LPDPCOMPORT baseObject);
static HRESULT			ConnectModem(LPDPCOMPORT baseObject, BOOL bWaitForConnection, BOOL bReturnStatus);
static HRESULT			DisconnectModem(LPDPCOMPORT baseObject);
static HRESULT			GetModemBaudRate(LPDPCOMPORT baseObject, LPDWORD lpdwBaudRate);
static HRESULT			GetModemAddress(LPDPCOMPORT baseObject, DWORD dwPlayerFlags,
										LPVOID lpAddress, LPDWORD lpdwAddressSize);

static BOOL FAR PASCAL	EnumAddressData(REFGUID lpguidDataType, DWORD dwDataSize,
										LPCVOID lpData, LPVOID lpContext);
static HRESULT			GetModemAddressChoices(LPDPCOMPORT baseObject,
								LPVOID lpAddress, LPDWORD lpdwAddressSize);
static BOOL FAR PASCAL	EnumMRUPhoneNumbers(LPCVOID lpData, DWORD dwDataSize, LPVOID lpContext);
static void				UpdateButtons(HWND hWnd);

BOOL					DoDialSetup(HINSTANCE hInstance, HWND hWndParent, LPDPMODEM globals);
BOOL					DoDial(HINSTANCE hInstance, HWND hWndParent, LPDPMODEM globals);
BOOL					DoAnswerSetup(HINSTANCE hInstance, HWND hWndParent, LPDPMODEM globals);
BOOL					DoAnswer(HINSTANCE hInstance, HWND hWndParent, LPDPMODEM globals);
HRESULT					DoDialStatus(LPDPMODEM globals);
HRESULT					DoAnswerStatus(LPDPMODEM globals);

/*
 * NewModem
 *
 * Create new modem object. Open TAPI and verify there are lines available.
 */

HRESULT NewModem(LPVOID lpConnectionData, DWORD dwConnectionDataSize,
				 LPDIRECTPLAYSP lpDPlay, LPREADROUTINE lpReadRoutine,
				 LPDPCOMPORT *storage)
{
	LPDPCOMPORT baseObject;
	LPDPMODEM	globals;
	LINERESULT	lResult;
	HRESULT		hr;

	// create base object with enough space for our globals
	hr = NewComPort(sizeof(DPMODEM), lpDPlay, lpReadRoutine, &baseObject);
	if FAILED(hr)
		return (hr);

	// fill in methods we implement
	baseObject->Dispose = DisposeModem;
	baseObject->Connect = ConnectModem;
	baseObject->Disconnect = DisconnectModem;
	baseObject->GetBaudRate = GetModemBaudRate;
	baseObject->GetAddress = GetModemAddress;
	baseObject->GetAddressChoices = GetModemAddressChoices;

	globals = (LPDPMODEM) baseObject;

	// initialize TAPI
	lResult = dialInitialize(ghInstance, TEXT("TapiSP"), (LPDPCOMPORT) globals, &globals->lpDial);
	if (lResult)
	{
		hr = DPERR_UNAVAILABLE;
		goto Failure;
	}

	// check for valid connection data
	if (lpConnectionData)
	{
		baseObject->lpDPlay->lpVtbl->EnumAddress(baseObject->lpDPlay, EnumAddressData,
									lpConnectionData, dwConnectionDataSize,
									globals);
	}

	// return object pointer
	*storage = baseObject;

	return (DP_OK);

Failure:
	DisposeModem(baseObject);

	return (hr);
}

/*
 * EnumConnectionData
 *
 * Search for valid connection data
 */

static BOOL FAR PASCAL EnumAddressData(REFGUID lpguidDataType, DWORD dwDataSize,
							LPCVOID lpData, LPVOID lpContext)
{
	LPDPMODEM	globals = (LPDPMODEM) lpContext;
	CHAR		szModemName[MODEMNAMESIZE];

	// this is an ANSI phone number
	if ((IsEqualGUID(lpguidDataType, &DPAID_Phone)) &&
		(dwDataSize) )
	{
		// make sure there is room (for terminating null too)
		if (dwDataSize > (PHONENUMBERSIZE - 1))
			dwDataSize = (PHONENUMBERSIZE - 1);
		CopyMemory(globals->szPhoneNumber, lpData, dwDataSize);

		globals->bHaveSettings = TRUE;		// we have a phone number
	}

	// this is an UNICODE phone number
	else if ((IsEqualGUID(lpguidDataType, &DPAID_PhoneW)) &&
			 (dwDataSize) )
	{
		if (WideToAnsi(globals->szPhoneNumber, (LPWSTR) lpData, PHONENUMBERSIZE))
			globals->bHaveSettings = TRUE;	// we have a phone number
	}

	// this is an ANSI modem name
	else if ((IsEqualGUID(lpguidDataType, &DPAID_Modem)) &&
			 (dwDataSize) )
	{
		// search modem list for this name
		if (dialGetDeviceIDFromName(globals->lpDial, lpData, &globals->dwDeviceID) == SUCCESS)
			globals->bHaveSettings = TRUE;	// can answer the phone
	}

	// this is a UNICODE modem name
	else if ((IsEqualGUID(lpguidDataType, &DPAID_ModemW)) &&
			 (dwDataSize) )
	{
		// search modem list for this name
		if (WideToAnsi(szModemName, (LPWSTR) lpData, MODEMNAMESIZE))
		{
			if (dialGetDeviceIDFromName(globals->lpDial, szModemName, &globals->dwDeviceID) == SUCCESS)
				globals->bHaveSettings = TRUE;	// we have a phone number
		}
	}

	return (TRUE);
}

/*
 * DisposeModem
 *
 * Dispose modem object.
 */

static HRESULT DisposeModem(LPDPCOMPORT baseObject)
{
	LPDPMODEM	globals = (LPDPMODEM) baseObject;
	LPDPDIAL	lpDial = globals->lpDial;
	LINERESULT	lResult;

	// shut down modem
	if (lpDial)
		lResult = dialShutdown(lpDial);

	// free object
	SP_MemFree((HGLOBAL) baseObject);

	return (DP_OK);
}

/*
 * ConnectModem
 *
 * Dial number based on user settings.
 */

static HRESULT ConnectModem(LPDPCOMPORT baseObject,
							BOOL bWaitForConnection, BOOL bReturnStatus)
{
	LPDPMODEM	globals = (LPDPMODEM) baseObject;
	LPDPDIAL	lpDial = globals->lpDial;
	DWORD		dwFeatures;
	BOOL		bResult;
	HRESULT		hr;

	// dial object has not been created?
	if (lpDial == NULL)
		return (DPERR_INVALIDPARAM);

	// are we already connected?
	if (dialIsConnected(lpDial))
		return (DP_OK);

	// remember if we are answering or not
	globals->bAnswering = bWaitForConnection;

	dwFeatures = 0;

	if (globals->bAnswering)
		dwFeatures |= ANSWERCALL;

	if (globals->bHaveSettings)
		dwFeatures |= HAVESETTINGS;

	if (bReturnStatus)
		dwFeatures |= RETURNSTATUS;

	hr = DP_OK;

	switch (dwFeatures)
	{
		case (STATUSDIALOG | NOSETTINGS   | DIALCALL):

			bResult = DoDialSetup(ghInstance, GetForegroundWindow(), globals);
			if (!bResult)
				goto FAILURE;

			globals->bHaveSettings = TRUE;
			break;

		case (STATUSDIALOG | NOSETTINGS   | ANSWERCALL):

			bResult = DoAnswerSetup(ghInstance, GetForegroundWindow(), globals);
			if (!bResult)
				goto FAILURE;

			globals->bHaveSettings = TRUE;
			break;

		case (STATUSDIALOG | HAVESETTINGS | DIALCALL):

			bResult = DoDial(ghInstance, GetForegroundWindow(), globals);
			if (!bResult)
				goto FAILURE;
			break;

		case (STATUSDIALOG | HAVESETTINGS | ANSWERCALL):

			bResult = DoAnswer(ghInstance, GetForegroundWindow(), globals);
			if (!bResult)
				goto FAILURE;
			break;

		case (RETURNSTATUS   | NOSETTINGS   | DIALCALL):
		case (RETURNSTATUS   | NOSETTINGS   | ANSWERCALL):

			DPF(0, "Invalid flags - no phone number or modem specified");
			hr = DPERR_INVALIDPARAM;
			break;

		case (RETURNSTATUS   | HAVESETTINGS | DIALCALL):

			hr = DoDialStatus(globals);
			break;

		case (RETURNSTATUS   | HAVESETTINGS | ANSWERCALL):

			hr = DoAnswerStatus(globals);
			break;
	}

	return (hr);

FAILURE:
	DisconnectModem(baseObject);

	return (DPERR_USERCANCEL);
}

/*
 * DisconnectModem
 *
 * Hang up any call in progress.
 */

static HRESULT DisconnectModem(LPDPCOMPORT baseObject)
{
	LPDPMODEM	globals = (LPDPMODEM) baseObject;
	LPDPDIAL	lpDial = globals->lpDial;

	// dial object has not been created?
	if (lpDial == NULL)
		return (DPERR_INVALIDPARAM);

	// disconnect the call
	dialDropCall(lpDial);
	dialDeallocCall(lpDial);
	dialLineClose(lpDial);

	return (DP_OK);
}

/*
 * GetModemAddress
 *
 * Return current modem address if available.
 */

static HRESULT GetModemAddress(LPDPCOMPORT baseObject, DWORD dwPlayerFlags,
							   LPVOID lpAddress, LPDWORD lpdwAddressSize)
{
	LPDPMODEM					globals = (LPDPMODEM) baseObject;
	LPDPDIAL					lpDial = globals->lpDial;
	WCHAR						szPhoneNumberW[PHONENUMBERSIZE];
	DPCOMPOUNDADDRESSELEMENT	addressElements[3];
	HRESULT						hr;

	// no settings?
	if (!globals->bHaveSettings)
		return (DPERR_UNAVAILABLE);

	// dial object has not been created?
	if (lpDial == NULL)
		return (DPERR_UNAVAILABLE);

	// not connected?
	if (!dialIsConnected(lpDial))
		return (DPERR_UNAVAILABLE);

	// if we answered there is no way for us to know a phone number
	if (globals->bAnswering)
		return (DPERR_UNAVAILABLE);

	// we can't know the phone number of local players, only remote players
	if (dwPlayerFlags & DPLAYI_PLAYER_PLAYERLOCAL)
		return (DPERR_UNAVAILABLE);

	// get UNICODE version of phone number
	if (!AnsiToWide(szPhoneNumberW, globals->szPhoneNumber, PHONENUMBERSIZE))
		return (DPERR_GENERIC);

	// service provider chunk
	addressElements[0].guidDataType = DPAID_ServiceProvider;
	addressElements[0].dwDataSize = sizeof(GUID);
	addressElements[0].lpData = &DPMODEM_GUID;

	// ANSI phone number
	addressElements[1].guidDataType = DPAID_Phone;
	addressElements[1].dwDataSize = lstrlen(globals->szPhoneNumber) + 1;
	addressElements[1].lpData = globals->szPhoneNumber;

	// UNICODE phone number
	addressElements[2].guidDataType = DPAID_PhoneW;
	addressElements[2].dwDataSize = (lstrlen(globals->szPhoneNumber) + 1) * sizeof(WCHAR);
	addressElements[2].lpData = szPhoneNumberW;

	// create the address
	hr = baseObject->lpDPlay->lpVtbl->CreateCompoundAddress(baseObject->lpDPlay,
						addressElements, 3,
						lpAddress, lpdwAddressSize);
	return (hr);
}

/*
 * GetModemAddressChoices
 *
 * Return modem address choices
 */

static HRESULT GetModemAddressChoices(LPDPCOMPORT baseObject,
					LPVOID lpAddress, LPDWORD lpdwAddressSize)
{
	LPDPMODEM					globals = (LPDPMODEM) baseObject;
	LPDPDIAL					lpDial = globals->lpDial;
	DPCOMPOUNDADDRESSELEMENT	addressElements[3];
	LINERESULT					lResult;
	HRESULT						hr;

	// dial object has not been created?
	if (lpDial == NULL)
		return (DPERR_UNAVAILABLE);

	ZeroMemory(addressElements, sizeof(addressElements));

	// service provider chunk
	addressElements[0].guidDataType = DPAID_ServiceProvider;
	addressElements[0].dwDataSize = sizeof(GUID);
	addressElements[0].lpData = &DPMODEM_GUID;

	// get ANSI modem name list
	addressElements[1].guidDataType = DPAID_Modem;
	lResult = dialGetModemList(lpDial, TRUE,
					&addressElements[1].lpData,
					&addressElements[1].dwDataSize);
	if (lResult)
	{
		hr = DPERR_OUTOFMEMORY;
		goto Failure;
	}

	// Unicode modem name list
	addressElements[2].guidDataType = DPAID_ModemW;
	lResult = dialGetModemList(lpDial, FALSE,
					&addressElements[2].lpData,
					&addressElements[2].dwDataSize);
	if (lResult)
	{
		hr = DPERR_OUTOFMEMORY;
		goto Failure;
	}

	// create the address
	hr = baseObject->lpDPlay->lpVtbl->CreateCompoundAddress(baseObject->lpDPlay,
						addressElements, 3,
						lpAddress, lpdwAddressSize);

Failure:
	if (addressElements[1].lpData)
		SP_MemFree(addressElements[1].lpData);
	if (addressElements[2].lpData)
		SP_MemFree(addressElements[2].lpData);

	return (hr);

}

/*
 * GetModemBaudRate
 *
 * Get baud rate of modem connnection.
 */

static HRESULT GetModemBaudRate(LPDPCOMPORT baseObject, LPDWORD lpdwBaudRate)
{
	LPDPMODEM	globals = (LPDPMODEM) baseObject;
	LPDPDIAL	lpDial = globals->lpDial;
	LINERESULT	lResult;

	lResult = dialGetBaudRate(lpDial, lpdwBaudRate);

	if (lResult == SUCCESS)
		return (DP_OK);
	else
		return (DPERR_UNAVAILABLE);
}

// Local prototypes
INT_PTR CALLBACK DialSetupWndProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK AnswerSetupWndProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK ModemStatusWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

void ChangeDialingProperties(HWND hWnd, LPDPDIAL lpDial);
void ConfigureModem(HWND hWnd);
void CenterWindow(HWND, HWND);


// ---------------------------------------------------------------------------
// DoDialSetup
// ---------------------------------------------------------------------------
// Description:             Gets modem setup information from the user.
// Arguments:
//  HINSTANCE               [in] Instance handle to load resources from.
//  HWND                    [in] Parent window handle.
//  LPDPMODEM				[in] modem globals
// Returns:
//  BOOL                    TRUE on success.
BOOL DoDialSetup(HINSTANCE hInstance, HWND hWndParent, LPDPMODEM globals)
{
	INT_PTR	iResult;

    iResult = DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_MODEM_DIAL), hWndParent, DialSetupWndProc, (LPARAM) globals);
	return (iResult > 0);
}


// ---------------------------------------------------------------------------
// DialSetupWndProc
// ---------------------------------------------------------------------------
// Description:             Message callback function for dial setup dialog.
// Arguments:
//  HWND                    [in] Dialog window handle.
//  UINT                    [in] Window message identifier.
//  WPARAM                  [in] Depends on message.
//  LPARAM                  [in] Depends on message.
// Returns:
//  BOOL                    TRUE if message was processed internally.
INT_PTR CALLBACK DialSetupWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPDPMODEM	globals = (LPDPMODEM) GetWindowLongPtr(hWnd, DWLP_USER);

    switch(uMsg)
    {
        case WM_INITDIALOG:
			// modem info pointer passed in lParam
			globals = (LPDPMODEM) lParam;

             // save the globals with the window
			SetWindowLongPtr(hWnd, DWLP_USER, (LONG_PTR)globals);

			// Center over the parent window
            CenterWindow(hWnd, GetParent(hWnd));

/*			gDPlay->lpVtbl->EnumMRUEntries(gDPlay,
								MRU_SP_KEY, MRU_NUMBER_KEY,
								EnumMRUPhoneNumbers, (LPVOID) hWnd);
*/
			if (lstrlen(globals->szPhoneNumber))
				SetDlgItemText(hWnd, IDC_NUMBER, globals->szPhoneNumber);
/*			else
				SendDlgItemMessage(hWnd,
									IDC_NUMBER,
									CB_SETCURSEL,
									(WPARAM) 0,
									(LPARAM) 0);
*/
/*			SendDlgItemMessage(hWnd,
							   IDC_NUMBER,
							   CB_SETCURSEL,
							   (WPARAM) 0,
							   (LPARAM) 0);
*/
            // initialize the modem selection combo box
			dialFillModemComboBox(globals->lpDial, hWnd, IDC_MODEM, globals->dwDeviceID);

			// initialize location combo box
//			dialFillLocationComboBox(lpModemInfo->lpDial, hWnd, IDC_DIALINGFROM, gModemSettings.dwLocation);
			UpdateButtons(hWnd);

            // Set focus so Derek won't have a cow
            SetFocus(GetDlgItem(hWnd, IDC_NUMBER));

            break;

        case WM_DESTROY:
            // Return failure
            EndDialog(hWnd, FALSE);

            break;

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDC_NUMBER:
					switch (HIWORD(wParam))
					{
					case EN_CHANGE:
//					case CBN_EDITCHANGE:
						UpdateButtons(hWnd);
						break;
					}
                    break;
/*
                case IDC_DIALPROPERTIES:

					ChangeDialingProperties(hWnd, lpModemInfo->lpDial);
					dialFillLocationComboBox(lpModemInfo->lpDial, hWnd, IDC_DIALINGFROM, gModemSettings.dwLocation);

                    break;
*/
                case IDC_CONFIGUREMODEM:

					ConfigureModem(hWnd);

                    break;

				case IDOK:
				{
					DWORD	dwModemSelection;


                    // Gather dialing info

					// Get phone number
					GetDlgItemText(hWnd, IDC_NUMBER, globals->szPhoneNumber, PHONENUMBERSIZE);

					//
					// get current modem selection and then get the assoicated
					// TAPI modem ID
					//
					dwModemSelection = (DWORD)SendDlgItemMessage(hWnd,
													IDC_MODEM,
													CB_GETCURSEL,
													(WPARAM) 0,
													(LPARAM) 0);
					DDASSERT( dwModemSelection != CB_ERR );

					globals->dwDeviceID = (DWORD)SendDlgItemMessage(hWnd,
													IDC_MODEM,
													CB_GETITEMDATA,
													(WPARAM) dwModemSelection,
													(LPARAM) 0);
					DDASSERT( globals->dwDeviceID != CB_ERR );

/*					if (lstrlen(gModemSettings.szPhoneNumber))
					{
						gDPlay->lpVtbl->AddMRUEntry(gDPlay,
											MRU_SP_KEY, MRU_NUMBER_KEY,
											gModemSettings.szPhoneNumber, lstrlen(gModemSettings.szPhoneNumber),
											MAXPHONENUMBERS);
					}
*/
                    // Dial...
					if (DoDial(ghInstance, hWnd, globals))
	                    EndDialog(hWnd, TRUE);

					break;
				}

                case IDCANCEL:
                    // Return failure
                    EndDialog(hWnd, FALSE);

                    break;
            }

            break;
    }

    // Allow for default processing
    return FALSE;
}

// ---------------------------------------------------------------------------
// DoDial
// ---------------------------------------------------------------------------
// Description:             Dials the modem
// Arguments:
//  HINSTANCE               [in] Instance handle to load resources from.
//  HWND                    [in] Parent window handle.
//  LPDPMODEM				[in] modem globals
// Returns:
//  BOOL                    TRUE on success.
BOOL DoDial(HINSTANCE hInstance, HWND hWndParent, LPDPMODEM globals)
{
	INT_PTR	iResult;

    iResult = DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_MODEM_STATUS), hWndParent, ModemStatusWndProc, (LPARAM) globals);
	return (iResult > 0);
}

// ---------------------------------------------------------------------------
// DoAnswerSetup
// ---------------------------------------------------------------------------
// Description:             Gets modem setup information from the user.
// Arguments:
//  HINSTANCE               [in] Instance handle to load resources from.
//  HWND                    [in] Parent window handle.
//  LPDPMODEM				[in] modem globals
// Returns:
//  BOOL                    TRUE on success.
BOOL DoAnswerSetup(HINSTANCE hInstance, HWND hWndParent, LPDPMODEM globals)
{
	INT_PTR	iResult;

	iResult = DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_MODEM_ANSWER), hWndParent, AnswerSetupWndProc, (LPARAM) globals);
	return (iResult > 0);
}

// ---------------------------------------------------------------------------
// AnswerSetupWndProc
// ---------------------------------------------------------------------------
// Description:             Message callback function for modem setup dialog.
// Arguments:
//  HWND                    [in] Dialog window handle.
//  UINT                    [in] Window message identifier.
//  WPARAM                  [in] Depends on message.
//  LPARAM                  [in] Depends on message.
// Returns:
//  BOOL                    TRUE if message was processed internally.
INT_PTR CALLBACK AnswerSetupWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPDPMODEM	globals = (LPDPMODEM) GetWindowLongPtr(hWnd, DWLP_USER);

    switch(uMsg)
    {
		case WM_INITDIALOG:
			// modem info pointer passed in lParam
			globals = (LPDPMODEM) lParam;

             // save the globals with the window
			SetWindowLongPtr(hWnd, DWLP_USER, (LONG_PTR) globals);

            // Center over the parent window
            CenterWindow(hWnd, GetParent(hWnd));

            // Initialize the modem selection combo box
			dialFillModemComboBox(globals->lpDial, hWnd, IDC_MODEM, globals->dwDeviceID);

            // Set focus so Derek won't have a cow
            SetFocus(GetDlgItem(hWnd, IDC_MODEM));

            break;

        case WM_DESTROY:
            // Return failure
            EndDialog(hWnd, FALSE);

            break;

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDC_CONFIGUREMODEM:
					ConfigureModem(hWnd);

                    break;

				case IDOK:
				{
					DWORD	dwModemSelection;


					//
					// Get the current selection and then the associated TAPI
					// modem ID.
					//
					dwModemSelection = (DWORD)SendDlgItemMessage(hWnd,
													IDC_MODEM,
													CB_GETCURSEL,
													(WPARAM) 0,
													(LPARAM) 0);

					globals->dwDeviceID = (DWORD)SendDlgItemMessage(hWnd,
													IDC_MODEM,
													CB_GETITEMDATA,
													(WPARAM) dwModemSelection,
													(LPARAM) 0);

                    // Answer...
					if (DoAnswer(ghInstance, hWnd, globals))
	                    EndDialog(hWnd, TRUE);

                    break;
				}

                case IDCANCEL:
                    // Return failure
                    EndDialog(hWnd, FALSE);

                    break;
            }

            break;
    }

    // Allow for default processing
    return FALSE;
}


// ---------------------------------------------------------------------------
// DoAnswer
// ---------------------------------------------------------------------------
// Description:             Answers the modem
// Arguments:
//  HINSTANCE               [in] Instance handle to load resources from.
//  HWND                    [in] Parent window handle.
//  LPDPMODEM				[in] modem globals
// Returns:
//  BOOL                    TRUE on success.
BOOL DoAnswer(HINSTANCE hInstance, HWND hWndParent, LPDPMODEM globals)
{
	INT_PTR	iResult;

    iResult = DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_MODEM_STATUS), hWndParent, ModemStatusWndProc, (LPARAM) globals);
	return (iResult > 0);
}

// ---------------------------------------------------------------------------
// ModemStatusWndProc
// ---------------------------------------------------------------------------
// Description:             Message callback function for dial setup dialog.
// Arguments:
//  HWND                    [in] Dialog window handle.
//  UINT                    [in] Window message identifier.
//  WPARAM                  [in] Depends on message.
//  LPARAM                  [in] Depends on message.
// Returns:
//  BOOL                    TRUE if message was processed internally.
INT_PTR CALLBACK ModemStatusWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPDPMODEM		globals = (LPDPMODEM) GetWindowLongPtr(hWnd, DWLP_USER);
	static UINT_PTR	uTimer = 0; /* timer identifier */
	LINERESULT		lResult;
	TCHAR			szStr[TEMPSTRINGSIZE];	// temp string
	TCHAR			szTableStr[TEMPSTRINGSIZE];	// temp string

    switch(uMsg)
    {
        case WM_INITDIALOG:
			// modem info pointer passed in lParam
			globals = (LPDPMODEM) lParam;

             // save the globals with the window
			SetWindowLongPtr(hWnd, DWLP_USER, (LONG_PTR) globals);

            // Center over the parent window
            CenterWindow(hWnd, GetParent(hWnd));

			// Set focus so Allen won't have a cow
            SetFocus(GetDlgItem(hWnd, IDCANCEL));

			// make sure line is closed
			if (globals->lpDial->hLine)
				dialLineClose(globals->lpDial);

			// open a line
			lResult = dialLineOpen(globals->lpDial, globals->dwDeviceID);
			if (lResult)
			{
				// line would not open, so show an error
				if (LoadString(ghInstance, IDS_COULDNOTOPENLINE, szStr, sizeof(szStr)))
					SetDlgItemText(hWnd, IDC_STATUS, szStr);
				break;
			}

			if (globals->bAnswering)
			{
				// already have settings, so just exit
				if (globals->bHaveSettings)
					EndDialog(hWnd, TRUE);

				// display "please wait" string
				if (LoadString(ghInstance, IDS_WAITINGFORCONNECTION, szStr, sizeof(szStr)))
					SetDlgItemText(hWnd, IDC_STATUS, szStr);
			}
			else
			{
				if (LoadString(ghInstance, IDS_DIALING, szTableStr, sizeof(szTableStr)))
				{
					wsprintf(szStr, szTableStr, globals->szPhoneNumber);
					SetDlgItemText(hWnd, IDC_STATUS, szStr);
				}

				// dial phone number
				lResult = dialMakeCall(globals->lpDial, globals->szPhoneNumber);
				if (lResult < 0)
				{
					// could not dial call, so show an error
					if (LoadString(ghInstance, IDS_COULDNOTDIAL, szStr, sizeof(szStr)))
						SetDlgItemText(hWnd, IDC_STATUS, szStr);
					break;
				}

				// reset to zero so that we don't get a false no connection below
				globals->lpDial->dwCallState = 0;
			}

			uTimer = SetTimer(hWnd, 1, TIMERINTERVAL, NULL);
			break;

		case WM_TIMER:

			if (dialIsConnected(globals->lpDial))
			{
				if (uTimer)
				{
					KillTimer(hWnd, uTimer);
					uTimer = 0;
				}

				// give the other side some time to set up
				Sleep(500);

	            EndDialog(hWnd, TRUE);
			}

			// see if line has failed
			else if (globals->lpDial->dwCallError != CALL_OK)
			{
				// show an error
				if (LoadString(ghInstance,
							   globals->bAnswering ? IDS_COULDNOTOPENLINE : IDS_COULDNOTDIAL,
							   szStr, sizeof(szStr)))
					SetDlgItemText(hWnd, IDC_STATUS, szStr);
			}
			break;

        case WM_DESTROY:
			if (uTimer)
			{
				KillTimer(hWnd, uTimer);
				uTimer = 0;
			}
            break;

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDOK:
                case IDCANCEL:
					// disconnect the call
					dialDropCall(globals->lpDial);
					dialDeallocCall(globals->lpDial);
					dialLineClose(globals->lpDial);

					// Return failure
					EndDialog(hWnd, FALSE);
                    break;
            }
            break;
    }

    // Allow for default processing
    return FALSE;
}

HRESULT DoDialStatus(LPDPMODEM globals)
{
	LINERESULT		lResult;


	// see if line had an error or went idle
	if ((globals->lpDial->dwCallError != CALL_OK) ||
		((globals->lpDial->hLine) &&
		 (globals->lpDial->dwCallState == LINECALLSTATE_IDLE)))
	{
		DPF(3, "DoDialStatus error recovery");
		// some errors don't close the line so we will
		if (globals->lpDial->hLine)
			dialLineClose(globals->lpDial);
		// reset the error state
		globals->lpDial->dwCallError = CALL_OK;
		return (DPERR_NOCONNECTION);
	}

	// line is not open
	if (!globals->lpDial->hLine)
	{
		lResult = dialLineOpen(globals->lpDial, globals->dwDeviceID);
		if (lResult)
			return (DPERR_NOCONNECTION);

		lResult = dialMakeCall(globals->lpDial, globals->szPhoneNumber);
		if (lResult < 0)
		{
			dialLineClose(globals->lpDial);
			return (DPERR_NOCONNECTION);
		}

		// reset to zero so that we don't get a false "no connection" before we dial
		globals->lpDial->dwCallState = 0;
	}

	// if we got here then call is in progress
	return (DPERR_CONNECTING);
}

HRESULT DoAnswerStatus(LPDPMODEM globals)
{
	LINERESULT		lResult;

	// see if line had an error
	if (globals->lpDial->dwCallError != CALL_OK)
	{
		// some errors don't close the line so we will
		if (globals->lpDial->hLine)
			dialLineClose(globals->lpDial);
		// reset the error state
		globals->lpDial->dwCallError = CALL_OK;
		return (DPERR_NOCONNECTION);
	}

	// open a line
	if (!globals->lpDial->hLine)
	{
		lResult = dialLineOpen(globals->lpDial, globals->dwDeviceID);
		if (lResult)
			return (DPERR_NOCONNECTION);
	}

	// if we got here then we are ready to answer a call
	return (DP_OK);
}

static BOOL FAR PASCAL EnumMRUPhoneNumbers(LPCVOID lpData, DWORD dwDataSize, LPVOID lpContext)
{
	HWND	hWnd = (HWND) lpContext;

	SendDlgItemMessage(hWnd,
						IDC_NUMBER,
						CB_ADDSTRING,
						(WPARAM) 0,
						(LPARAM) lpData);
	return (TRUE);
}

static void UpdateButtons(HWND hWnd)
{
	LONG_PTR	len;

	// see how much text has been typed into number edit
    len = SendDlgItemMessage(hWnd,
							IDC_NUMBER,
							WM_GETTEXTLENGTH,
							(WPARAM) 0,
							(LPARAM) 0);

	// only enable "Connect" button if text has been entered
	EnableWindow(GetDlgItem(hWnd, IDOK), (len == 0) ? FALSE : TRUE);
}

void ChangeDialingProperties(HWND hWnd, LPDPDIAL lpDial)
{
	TCHAR		szPhoneNumber[PHONENUMBERSIZE];
	DWORD		dwModemSelection;
	DWORD		dwDeviceID;
	LINERESULT	lResult;



	dwModemSelection = (DWORD)SendDlgItemMessage(hWnd,
								IDC_MODEM,
								CB_GETCURSEL,
								(WPARAM) 0,
								(LPARAM) 0);
	DDASSERT( dwModemSelection != CB_ERR );

	dwDeviceID = (DWORD)SendDlgItemMessage(hWnd,
								IDC_MODEM,
								CB_GETITEMDATA,
								(WPARAM) dwModemSelection,
								(LPARAM) 0);
	DDASSERT( dwDeviceID != CB_ERR );
	if (dwDeviceID == CB_ERR)
		return;

	GetDlgItemText(hWnd, IDC_NUMBER, szPhoneNumber, PHONENUMBERSIZE);

	lResult = dialTranslateDialog(lpDial, hWnd, dwDeviceID, szPhoneNumber);
}

void ConfigureModem(HWND hWnd)
{
	DWORD		dwDeviceID;
	DWORD		dwModemSelection;
	LINERESULT	lResult;


	//
	// get the current modem selection and then get the associated TAPI modem ID
	//
	dwModemSelection = (DWORD)SendDlgItemMessage(hWnd,
								IDC_MODEM,
								CB_GETCURSEL,
								(WPARAM) 0,
								(LPARAM) 0);
	DDASSERT( dwModemSelection != CB_ERR );

	dwDeviceID = (DWORD)SendDlgItemMessage(hWnd,
								IDC_MODEM,
								CB_GETITEMDATA,
								(WPARAM) dwModemSelection,
								(LPARAM) 0);
	DDASSERT( dwDeviceID != CB_ERR );
	if (dwDeviceID != CB_ERR)
		lResult = lineConfigDialog(dwDeviceID, hWnd, "comm/datamodem");
}

// ---------------------------------------------------------------------------
// CenterWidow
// ---------------------------------------------------------------------------
// Description:             Centers one window over another.
// Arguments:
//  HWND                    [in] Window handle.
//  HWND                    [in] Parent window handle.  NULL centers the
//                               window over the desktop.
// Returns:
//  void
void CenterWindow(HWND hWnd, HWND hWndParent)
{
    RECT                    rcWindow, rcParent;
    int                     x, y;

    // Get child window rect
    GetWindowRect(hWnd,  &rcWindow);

    // Get parent window rect
//    if(!hWndParent || !IsWindow(hWndParent))
    {
        hWndParent = GetDesktopWindow();
    }

    GetWindowRect(hWndParent, &rcParent);

    // Calculate XY coordinates
    x = ((rcParent.right - rcParent.left) - (rcWindow.right - rcWindow.left)) / 2;
    y = ((rcParent.bottom - rcParent.top) - (rcWindow.bottom - rcWindow.top)) / 2;

    // Center the window
    SetWindowPos(hWnd, NULL, x, y, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\serial\dpserial.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpserial.c
 *  Content:	Implementation of serial port service provider
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *	4/10/96	kipo	created it
 *	4/12/96 kipo	updated for new interfaces
 *	4/15/96 kipo	added msinternal
 *	5/22/96	kipo	updated for new interfaces
 *	6/10/96	kipo	updated for new interfaces
 *	6/10/96	kipo	added modem support
 *	6/18/96 kipo	use guid to choose serial/modem connection
 *	6/20/96 kipo	updated for new interfaces
 *	6/21/96 kipo	Bug #2078. Changed modem service provider GUID so it's not the
 *					same as the DPlay 1.0 GUID, so games that are checking won't
 *					put up their loopy modem-specific UI.
 *	6/21/96	kipo	updated for latest interfaces; return error if message size is too big.
 *	6/22/96	kipo	updated for latest interfaces; use connection data; return version
 *	6/23/96	kipo	updated for latest service provider interfaces.
 *	6/24/96	kipo	divide baud rate by 100 to conform to DPlay 1.0 usage.
 *	6/25/96	kipo	added WINAPI prototypes and updated for DPADDRESS
 *  7/13/96	kipo	added support for GetAddress() method.
 *  7/13/96	kipo	don't print as many errors for invalid messages.
 *  8/10/96	kipo	return DPERR_SESSIONLOST on write failures
 *	8/13/96 kipo	added CRC
 *	8/21/96 kipo	return a value for dwHeaderLength in caps 
 *	9/07/96	kip		changed latency and timeout values
 *  1/06/97 kipo	updated for objects
 *  2/11/97 kipo	pass player flags to GetAddress()
 *  2/11/97 kipo	SPInit was needlessly clearing the dwFlags field of the
 *					callback table.
 *  2/18/97 kipo	allow multiple instances of service provider
 *	3/04/97 kipo	updated debug output; make sure we linke with dplayx.dll
 *  4/08/97 kipo	added support for separate modem and serial baud rates
 *  5/07/97 kipo	added support for modem choice list
 *  5/23/97 kipo	added support return status codes
 *  5/15/98 a-peterz When Write fails, return DPERR_NOCONNECTION (#23745)
 * 12/22/00 aarono   #190380 - use process heap for memory allocation
 ***************************************************************************/

#define INITGUID
#include <windows.h>
#include <windowsx.h>

#include <objbase.h>
#include <initguid.h>

#include "dpf.h"
#include "dplaysp.h"
#include "comport.h"
#include "macros.h"

// macros

#ifdef DEBUG
	#define DPF_ERRVAL(a, b)  DPF( 0, DPF_MODNAME ": " a, b );
#else
	#define DPF_ERRVAL(a, b)
#endif

// constants

#define SPMINORVERSION      0x0000				// service provider-specific version number
#define VERSIONNUMBER		(DPSP_MAJORVERSION | SPMINORVERSION) // version number for service provider

#define MESSAGETOKEN		0x2BAD				// token to signify start of message
#define MESSAGEHEADERLEN	sizeof(MESSAGEHEADER) // size of message header
#define MESSAGEMAXSIZEINT	0x0000FFFF			// maximum size of an internal message
#define MESSAGEMAXSIZEEXT	(MESSAGEMAXSIZEINT - MESSAGEHEADERLEN)	// maximum size of an external message

typedef enum {
	NEWMESSAGESTATE = 0,						// start reading a new message
	READHEADERSTATE,							// read the message header
	READDATASTATE,								// read the message data
	SKIPDATASTATE								// skip the message data
} MESSAGESTATE;

// structures

// message header
typedef struct {
	WORD	wToken;								// message token
	WORD	wMessageSize;						// length of message
	WORD	wMessageCRC;						// CRC checksum value for message body
	WORD	wHeaderCRC;							// CRC checksum value for header
} MESSAGEHEADER, *LPMESSAGEHEADER;

// service provider context
typedef struct {
	LPDPCOMPORT		lpComPort;					// pointer to com port data structure
	MESSAGESTATE	msReadState;				// current read state
	BYTE			lpReadHeader[MESSAGEHEADERLEN];	// buffer for message header
	LPBYTE			lpReadBuffer;				// buffer for message data
	DWORD			dwReadBufferSize;			// size of message buffer in bytes
	DWORD			dwReadCount;				// no. bytes read into message buffer
	DWORD			dwReadTotal;				// no. total bytes to read into message buffer
	DWORD			dwSkipCount;				// no. bytes skipped to find message header
	LPDIRECTPLAYSP	lpDPlay;					// pointer to IDirectPlaySP needed to call back into DPlay
} SPCONTEXT, *LPSPCONTEXT;

// {0F1D6860-88D9-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPSERIAL_GUID,						// GUID for serial service provider
0xf1d6860, 0x88d9, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

// {44EAA760-CB68-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPMODEM_GUID,						// GUID for modem service provider
0x44eaa760, 0xcb68, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

CRITICAL_SECTION csMem;

/*
 * GetSPContext
 *
 * Get service provider context from DirectPlay.
 */

#undef DPF_MODNAME
#define DPF_MODNAME	"GetSPContext"

LPSPCONTEXT GetSPContext(LPDIRECTPLAYSP lpDPlay)
{
	LPSPCONTEXT	lpContext = NULL;
	DWORD		dwContextSize = 0;
	HRESULT		hr;

	// no dplay interface?
	if (lpDPlay == NULL)
	{
		DPF_ERR("DPlaySP interface is NULL!");
		goto FAILURE;
	}

	// get pointer to context from DPlay
	hr = lpDPlay->lpVtbl->GetSPData(lpDPlay, &lpContext, &dwContextSize, DPGET_LOCAL);
	if FAILED(hr)
	{
		DPF_ERRVAL("could not get context: 0x%08X", hr);
		goto FAILURE;
	}

	// make sure size is correct
	if (dwContextSize != sizeof(SPCONTEXT))
	{
		DPF_ERR("invalid context size!");
		goto FAILURE;
	}

	return (lpContext);

FAILURE:
	return (NULL);
}

/*
 * SetupMessageHeader
 *
 * Initialize the service provider-specific header put
 * in front of every message.
 */

#undef DPF_MODNAME
#define DPF_MODNAME	"SetupMessageHeader"

HRESULT SetupMessageHeader(LPVOID pvMessage, DWORD dwMessageSize)
{
	LPMESSAGEHEADER	pMessageHeader = (LPMESSAGEHEADER) pvMessage;

	// make sure message will fit in header
	if (dwMessageSize > MESSAGEMAXSIZEINT)
		return (DPERR_SENDTOOBIG);

	// set message header
	pMessageHeader->wToken = (WORD) MESSAGETOKEN;

	// set message size
	pMessageHeader->wMessageSize = (WORD) dwMessageSize;

	// generate CRC for message body
	pMessageHeader->wMessageCRC = (WORD) GenerateCRC(((LPBYTE) pvMessage) + MESSAGEHEADERLEN,
										dwMessageSize - MESSAGEHEADERLEN);

	// generate CRC for message header
	pMessageHeader->wHeaderCRC = (WORD) GenerateCRC(pvMessage, MESSAGEHEADERLEN - sizeof(pMessageHeader->wHeaderCRC));

	return (DP_OK);
}

/*
 * GetMessageLength
 *
 * Check for valid message header and return length of message.
 */

#undef DPF_MODNAME
#define DPF_MODNAME	"GetMessageLength"

DWORD GetMessageLength(LPBYTE header)
{
	LPMESSAGEHEADER	pMessageHeader = (LPMESSAGEHEADER) header;
	DWORD			byteCount;

	// check for token we put in front of every message
	if (pMessageHeader->wToken != MESSAGETOKEN)
		goto FAILURE;

	// check CRC for message header
	if (pMessageHeader->wHeaderCRC != (WORD) GenerateCRC(header, MESSAGEHEADERLEN - sizeof(pMessageHeader->wHeaderCRC)))
		goto FAILURE;

	// get length of message
	byteCount = pMessageHeader->wMessageSize;
	if (byteCount <= MESSAGEHEADERLEN)
	{
		DPF_ERRVAL("bad message size: %d", byteCount);
		goto FAILURE;
	}

	return (byteCount);

FAILURE:
	return (0);
}

/*
 * SetupToReadMessage
 *
 * Create/resize buffer to fit length of message and initialize header.
 */

#undef DPF_MODNAME
#define DPF_MODNAME	"SetupToReadMessage"

BOOL SetupToReadMessage(LPSPCONTEXT lpContext)
{
	// no buffer, so create one
	if (lpContext->lpReadBuffer == NULL)
	{
		lpContext->lpReadBuffer = SP_MemAlloc(lpContext->dwReadTotal);
		if (lpContext->lpReadBuffer == NULL)
		{
			DPF_ERRVAL("could not create message buffer: %d", GetLastError());
			goto FAILURE;
		}
		lpContext->dwReadBufferSize = lpContext->dwReadTotal;
	}

	// existing buffer not big enough, so resize
	else if (lpContext->dwReadBufferSize < lpContext->dwReadTotal)
	{
		HANDLE	h;
		h = SP_MemReAlloc(lpContext->lpReadBuffer, lpContext->dwReadTotal);
		if (h == NULL)
		{
			DPF_ERRVAL("could not reallocate message buffer: %d", GetLastError());
			goto FAILURE;
		}
		lpContext->lpReadBuffer = h;
		lpContext->dwReadBufferSize = lpContext->dwReadTotal;
	}

	// copy message header to buffer
	CopyMemory(lpContext->lpReadBuffer, lpContext->lpReadHeader, lpContext->dwReadCount);

	return (TRUE);

FAILURE:
	return (FALSE);
}

/*
 * ReadRoutine
 *
 * Read bytes from COM port using a state machine to assemble a message.
 * When message is assembled, call back to DirectPlay to deliver it.
 */

#undef DPF_MODNAME
#define DPF_MODNAME	"ReadRoutine"

void ReadRoutine(LPDIRECTPLAYSP	lpDPlay)
{
	LPSPCONTEXT	lpContext;
	DWORD		byteCount;
	    
	// get service provider context
	lpContext = GetSPContext(lpDPlay);
	if (lpContext == NULL)
	{
		DPF_ERR("invalid context!");
		return;
	}

	while (1)
	{
		switch (lpContext->msReadState)
		{
		// start reading a new message
		case NEWMESSAGESTATE:
			lpContext->dwReadCount = 0;
			lpContext->dwReadTotal = MESSAGEHEADERLEN;
			lpContext->msReadState = READHEADERSTATE;
			lpContext->dwSkipCount = 0;
			break;

		// read message header
		case READHEADERSTATE:
			byteCount = lpContext->lpComPort->Read(lpContext->lpComPort,
									&lpContext->lpReadHeader[lpContext->dwReadCount],
									lpContext->dwReadTotal - lpContext->dwReadCount);
			if (byteCount == 0)
				return;

			lpContext->dwReadCount += byteCount;
			if (lpContext->dwReadCount == lpContext->dwReadTotal) // got enough for a header
			{
				lpContext->dwReadTotal = GetMessageLength(lpContext->lpReadHeader);	// see if it's real
				if (lpContext->dwReadTotal)
				{
					if (lpContext->dwSkipCount)
						DPF_ERRVAL("%d bytes skipped", lpContext->dwSkipCount);

					if (SetupToReadMessage(lpContext))	// prepare to read message
						lpContext->msReadState = READDATASTATE;
					else
						lpContext->msReadState = SKIPDATASTATE;
				}
				else									// bad message header - reset
				{
					DWORD	i;

					if (lpContext->dwSkipCount == 0)
						DPF_ERR("invalid message header - skipping bytes");		

					lpContext->dwReadCount = MESSAGEHEADERLEN - 1; // throw away first byte and try again
					lpContext->dwReadTotal = MESSAGEHEADERLEN;
					lpContext->dwSkipCount += 1;

					for (i = 0; i < lpContext->dwReadCount; i++)	// shuffle down one byte
						lpContext->lpReadHeader[i] = lpContext->lpReadHeader[i + 1];
				}
			}
			break;

		// read message data
		case READDATASTATE:
			byteCount = lpContext->lpComPort->Read(lpContext->lpComPort,
									&lpContext->lpReadBuffer[lpContext->dwReadCount],
									lpContext->dwReadTotal - lpContext->dwReadCount);
			if (byteCount == 0)
				return;

			lpContext->dwReadCount += byteCount;
			if (lpContext->dwReadCount == lpContext->dwReadTotal)	// have read entire message
			{
				LPMESSAGEHEADER		pMessageHeader;

				// check for CRC errors
				pMessageHeader = (LPMESSAGEHEADER) lpContext->lpReadBuffer;
				if (pMessageHeader->wMessageCRC != (WORD) GenerateCRC(lpContext->lpReadBuffer + MESSAGEHEADERLEN, lpContext->dwReadTotal - MESSAGEHEADERLEN))
				{
					DPF_ERR("Message dropped - CRC did not match!");
				}
				else
				{
					DPF(5, "%d byte message received", lpContext->dwReadTotal);

					// deliver message to DirectPlay
					lpContext->lpDPlay->lpVtbl->HandleMessage(lpContext->lpDPlay,		// DirectPlay instance
										  lpContext->lpReadBuffer + MESSAGEHEADERLEN,	// pointer to message data
										  lpContext->dwReadTotal - MESSAGEHEADERLEN,	// length of message data
										  NULL);										// pointer to header (unused here)
				}
				lpContext->msReadState = NEWMESSAGESTATE;		// go read next message
			}
			break;

		// skip message data
		case SKIPDATASTATE:
			DPF_ERR("Skipping data!");
			while (lpContext->lpComPort->Read(lpContext->lpComPort, &lpContext->lpReadHeader[0], 1))	// spin until entire message discarded
			{
				lpContext->dwReadCount += 1;
				if (lpContext->dwReadCount == lpContext->dwReadTotal)
				{
					lpContext->msReadState = NEWMESSAGESTATE;
					break;
				}
			}
			break;

		default:
			DPF_ERRVAL("bad read state: %d", lpContext->msReadState);
			break;
		}
	}
}

/*
 * SP_EnumSessions
 *
 * Broadcast a message to the network.
 */

#undef DPF_MODNAME
#define DPF_MODNAME	"SP_EnumSessions"

HRESULT WINAPI SP_EnumSessions(LPDPSP_ENUMSESSIONSDATA ped) 
{
	LPSPCONTEXT	lpContext;
	DWORD		byteCount;
	HRESULT		hr;

	DPF(5,"entering SP_EnumSessions");
    
	// get service provider context
	lpContext = GetSPContext(ped->lpISP);
	if (lpContext == NULL)
	{
		DPF_ERR("invalid context!");
		hr = DPERR_NOINTERFACE;
		goto FAILURE;
	}

	// make connection
	hr = lpContext->lpComPort->Connect(lpContext->lpComPort, FALSE, ped->bReturnStatus);
	if FAILED(hr)
	{
		if (hr != DPERR_CONNECTING)
			DPF_ERRVAL("error making connection: 0x%08X", hr);
		goto FAILURE;
	}

	// see if connection has been lost
   	if (lpContext->lpComPort->GetHandle(lpContext->lpComPort) == NULL)
	{
		DPF_ERR("connection lost!");
		hr = DPERR_SESSIONLOST;
		goto FAILURE;
	}

	// setup the message
	hr = SetupMessageHeader(ped->lpMessage, ped->dwMessageSize);
	if FAILED(hr)
	{
		DPF_ERR("message too large!");
		goto FAILURE;
	}

	// send message
	byteCount = lpContext->lpComPort->Write(lpContext->lpComPort, ped->lpMessage, ped->dwMessageSize, TRUE);
	if (byteCount != ped->dwMessageSize)
	{
		DPF(0, "error writing message: %d requested, %d actual", ped->dwMessageSize, byteCount);
		hr = DPERR_CONNECTIONLOST;
		goto FAILURE;
	}

	DPF(5, "%d byte enum sessions message sent", byteCount);

	return (DP_OK);

FAILURE:
	return (hr);

} // EnumSessions

/*
 * SP_Send
 *
 * Send a message to a particular player or group.
 */

#undef DPF_MODNAME
#define DPF_MODNAME	"SP_Send"

HRESULT WINAPI SP_Send(LPDPSP_SENDDATA psd)
{
	LPSPCONTEXT	lpContext;
	DWORD		byteCount;
	HRESULT		hr;

	DPF(5,"entering SP_Send");

	// get service provider context
	lpContext = GetSPContext(psd->lpISP);
	if (lpContext == NULL)
	{
		DPF_ERR("invalid context!");
		hr = DPERR_NOINTERFACE;
		goto FAILURE;
	}

	// see if connection has been lost
   	if (lpContext->lpComPort->GetHandle(lpContext->lpComPort) == NULL)
	{
		DPF_ERR("connection lost!");
		hr = DPERR_SESSIONLOST;
		goto FAILURE;
	}

	// setup the message
	hr = SetupMessageHeader(psd->lpMessage, psd->dwMessageSize);
	if FAILED(hr)
	{
		DPF_ERR("message too large!");
		goto FAILURE;
	}

	// send message
	byteCount = lpContext->lpComPort->Write(lpContext->lpComPort, psd->lpMessage, psd->dwMessageSize, TRUE);
	if (byteCount != psd->dwMessageSize)
	{
		DPF(0, "error writing message: %d requested, %d actual", psd->dwMessageSize, byteCount);
		hr = DPERR_CONNECTIONLOST;
		goto FAILURE;
	}

	DPF(5, "%d byte message sent", byteCount);

    return (DP_OK);

FAILURE:
	return (hr);

} // Send

/*
 * SP_Reply
 *
 * Send a reply to a message.
 */

#undef DPF_MODNAME
#define DPF_MODNAME	"SP_Reply"

HRESULT WINAPI SP_Reply(LPDPSP_REPLYDATA prd)
{
	LPSPCONTEXT	lpContext;
	DWORD		byteCount;
	HRESULT		hr;

	DPF(5,"entering Reply");
    
	// get service provider context
	lpContext = GetSPContext(prd->lpISP);
	if (lpContext == NULL)
	{
		DPF_ERR("invalid context!");
		hr = DPERR_NOINTERFACE;
		goto FAILURE;
	}

	// see if connection has been lost
	if (lpContext->lpComPort->GetHandle(lpContext->lpComPort) == NULL)
	{
		DPF_ERR("connection lost!");
		hr = DPERR_SESSIONLOST;
		goto FAILURE;
	}
	
	// setup the message
	hr = SetupMessageHeader(prd->lpMessage, prd->dwMessageSize);
	if FAILED(hr)
	{
		DPF_ERR("message too large!");
		goto FAILURE;
	}

	// send message
	byteCount = lpContext->lpComPort->Write(lpContext->lpComPort, prd->lpMessage, prd->dwMessageSize, TRUE);
	if (byteCount != prd->dwMessageSize)
	{
		DPF(0, "error writing message: %d requested, %d actual", prd->dwMessageSize, byteCount);
		hr = DPERR_CONNECTIONLOST;
		goto FAILURE;
	}

	DPF(5, "%d byte reply message sent", byteCount);

    return (DP_OK);

FAILURE:
	return (hr);

} // Reply

/*
 * SP_Open
 *
 * Open the service provider.
 */

#undef DPF_MODNAME
#define DPF_MODNAME	"SP_Open"

HRESULT WINAPI SP_Open(LPDPSP_OPENDATA pod) 
{
	LPSPCONTEXT	lpContext;
	HRESULT		hr;

	DPF(5,"entering Open");
    
	// get service provider context
	lpContext = GetSPContext(pod->lpISP);
	if (lpContext == NULL)
	{
		DPF_ERR("invalid context!");
		hr = DPERR_NOINTERFACE;
		goto FAILURE;
	}

	// make connection
	hr = lpContext->lpComPort->Connect(lpContext->lpComPort, pod->bCreate, pod->bReturnStatus);
	if FAILED(hr)
	{
		DPF_ERRVAL("error making connection: 0x%08X", hr);
		goto FAILURE;
	}

	return (DP_OK);

FAILURE:
	return (hr);

} // Open

/*
 * SP_GetCaps
 *
 * Return capabilities of service provider.
 *
 * Only the fields that matter to this service provider have
 * to be set here, since all the fields are preset to
 * default values.
 */

#undef DPF_MODNAME
#define DPF_MODNAME	"SP_GetCaps"

HRESULT WINAPI SP_GetCaps(LPDPSP_GETCAPSDATA pcd) 
{
	LPSPCONTEXT	lpContext;
	LPDPCAPS	lpCaps;
	HRESULT		hr;
    
	DPF(5,"entering GetCaps");

	// get service provider context
	lpContext = GetSPContext(pcd->lpISP);
	if (lpContext == NULL)
	{
		DPF_ERR("invalid context!");
		hr = DPERR_NOINTERFACE;
		goto FAILURE;
	}

	// make sure caps buffer is large enough
	lpCaps = pcd->lpCaps;
	if (lpCaps->dwSize < sizeof(DPCAPS))
	{
		DPF_ERR("caps buffer too small");
		hr = DPERR_BUFFERTOOSMALL;
		goto FAILURE;
	}

	// don't zero out caps as DPlay has pre-initialized some default caps for us
	lpCaps->dwSize = sizeof(DPCAPS);
	lpCaps->dwMaxBufferSize = MESSAGEMAXSIZEEXT;	// return maximum external message size
	lpCaps->dwHeaderLength = MESSAGEHEADERLEN;		// return size of message header
	lpCaps->dwFlags = 0;							// have DPlay do the keep-alives
	lpCaps->dwLatency = 250;						// todo - base these on baud rate ACK!!!
	lpCaps->dwTimeout = 2500; 
	
	// if we have connected we can get the baud rate
	if (lpContext->lpComPort->GetHandle(lpContext->lpComPort))
	{
		DWORD	dwBaudRate;

		// try to get baud rate
		hr = lpContext->lpComPort->GetBaudRate(lpContext->lpComPort, &dwBaudRate);
		if SUCCEEDED(hr)
		{
			lpCaps->dwHundredBaud = dwBaudRate / 100;	// return baud rate in hundreds of baud
		}
	}

	return (DP_OK);

FAILURE:
	return (hr);

} // GetCaps

/*
 * SP_GetAddress
 *
 * Return network address of a given player.
 *
 */

#undef DPF_MODNAME
#define DPF_MODNAME	"SP_GetAddress"

HRESULT WINAPI SP_GetAddress(LPDPSP_GETADDRESSDATA pga) 
{
	LPSPCONTEXT	lpContext;
	HRESULT		hr;
    
	DPF(5,"entering GetAddress");

	// get service provider context
	lpContext = GetSPContext(pga->lpISP);
	if (lpContext == NULL)
	{
		DPF_ERR("invalid context!");
		hr = DPERR_NOINTERFACE;
		goto FAILURE;
	}

	hr = lpContext->lpComPort->GetAddress(lpContext->lpComPort, pga->dwFlags, pga->lpAddress, pga->lpdwAddressSize);

FAILURE:
	return (hr);

} // GetAddress

/*
 * SP_GetAddressChoices
 *
 * Return address choices for this service provider
 *
 */

#undef DPF_MODNAME
#define DPF_MODNAME	"SP_GetAddressChoices"

HRESULT WINAPI SP_GetAddressChoices(LPDPSP_GETADDRESSCHOICESDATA pga) 
{
	LPSPCONTEXT	lpContext;
	HRESULT		hr;
    
	DPF(5,"entering GetAddressChoices");

	// get service provider context
	lpContext = GetSPContext(pga->lpISP);
	if (lpContext == NULL)
	{
		DPF_ERR("invalid context!");
		hr = DPERR_NOINTERFACE;
		goto FAILURE;
	}

	hr = lpContext->lpComPort->GetAddressChoices(lpContext->lpComPort, pga->lpAddress, pga->lpdwAddressSize);

FAILURE:
	return (hr);

} // GetAddressChoices

/*
 * SP_Shutdown
 *
 * Turn off all I/O on service provider and release all allocated
 * memory and resources.
 */

#undef DPF_MODNAME
#define DPF_MODNAME	"SP_Shutdown"

HRESULT WINAPI SP_ShutdownEx(LPDPSP_SHUTDOWNDATA psd) 
{
	LPSPCONTEXT	lpContext;
	HRESULT		hr;

	DPF(5,"entering Shutdown");
    
	// get service provider context
	lpContext = GetSPContext(psd->lpISP);
	if (lpContext == NULL)
	{
		DPF_ERR("invalid context!");
		hr = DPERR_NOINTERFACE;
		goto FAILURE;
	}

	if (lpContext->lpComPort)
	{
		lpContext->lpComPort->Dispose(lpContext->lpComPort);
		lpContext->lpComPort = NULL;
	}

	if (lpContext->lpReadBuffer)
	{
		SP_MemFree(lpContext->lpReadBuffer);
		lpContext->lpReadBuffer = NULL;
	}

	lpContext->lpDPlay = NULL;

	// OK to release DPLAYX.DLL
	gdwDPlaySPRefCount++;

    return (DP_OK);

FAILURE:
	return (hr);

} // Shutdown

/*
 * SPInit
 *
 * This is the main entry point for the service provider. This should be
 * the only entry point exported from the DLL.
 *
 * Allocate any needed resources and return the supported callbacks.
 */

#undef DPF_MODNAME
#define DPF_MODNAME	"SPInit"

HRESULT WINAPI SPInit(LPSPINITDATA pid) 
{
	SPCONTEXT			context;
	LPSPCONTEXT			lpContext;
	LPDPSP_SPCALLBACKS	lpcbTable;
	HRESULT				hr;

	DPF(5,"entering SPInit");

	// check to make sure table is big enough
	lpcbTable = pid->lpCB;
	if (lpcbTable->dwSize < sizeof(DPSP_SPCALLBACKS))		// table not big enough
	{
		DPF_ERR("callback table too small");
		hr = DPERR_BUFFERTOOSMALL;
		goto FAILURE;
	}

	// initialize context
	ZeroMemory(&context, sizeof(SPCONTEXT));
	lpContext = &context;
	lpContext->msReadState = NEWMESSAGESTATE;
	lpContext->lpDPlay = pid->lpISP;					// save pointer to IDPlaySP so we can pass it back later

	// check for correct GUID
	if (IsEqualGUID(pid->lpGuid, &DPSERIAL_GUID))
	{
		hr = NewSerial(pid->lpAddress, pid->dwAddressSize,
					   lpContext->lpDPlay, ReadRoutine,
					   &lpContext->lpComPort);
	}
	else if (IsEqualGUID(pid->lpGuid, &DPMODEM_GUID))
	{
		hr = NewModem(pid->lpAddress, pid->dwAddressSize,
					  lpContext->lpDPlay, ReadRoutine,
					  &lpContext->lpComPort);
	}
	else
	{
		DPF_ERR("unknown service provider GUID");
		hr = DPERR_INVALIDPARAM;
	}

	if FAILED(hr)
	{
		DPF_ERRVAL("error opening com port: 0x%08X", hr);
		goto FAILURE;
	}

	// return size of header we need on every message so
	// DirectPlay will leave room for it.
 	pid->dwSPHeaderSize = MESSAGEHEADERLEN;

	// return version number so DirectPlay will treat us with respect
	pid->dwSPVersion = VERSIONNUMBER;

	// set up callbacks
    lpcbTable->dwSize = sizeof(DPSP_SPCALLBACKS);			// MUST set the return size of the table
    lpcbTable->Send = SP_Send;
    lpcbTable->EnumSessions = SP_EnumSessions;
    lpcbTable->Reply = SP_Reply;
	lpcbTable->GetCaps = SP_GetCaps;
	lpcbTable->GetAddress = SP_GetAddress;
	lpcbTable->GetAddressChoices = SP_GetAddressChoices;
    lpcbTable->Open = SP_Open;
	lpcbTable->ShutdownEx = SP_ShutdownEx;

	// save context with DPlay so we can get it later
	hr = lpContext->lpDPlay->lpVtbl->SetSPData(lpContext->lpDPlay, lpContext, sizeof(SPCONTEXT), DPSET_LOCAL);
	if FAILED(hr)
	{
		DPF_ERRVAL("could not store context: 0x%08X", hr);
		goto FAILURE;
	}

	// make sure DPLAYX.DLL sticks around
	gdwDPlaySPRefCount++;

	return (DP_OK);

FAILURE:
	return (hr);

} // SPInit
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\serial\serial.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       serial.c
 *  Content:	Routines for serial I/O
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *  6/10/96	kipo	created it
 *  6/22/96	kipo	added support for EnumConnectionData()
 *	6/25/96	kipo	updated for DPADDRESS
 *  7/13/96	kipo	added GetSerialAddress()
 *	7/16/96	kipo	changed address types to be GUIDs instead of 4CC
 *	8/21/96	kipo	move comport address into dplobby.h
 *  1/06/97 kipo	updated for objects
 *  2/11/97 kipo	pass player flags to GetAddress()
 *  2/18/97 kipo	allow multiple instances of service provider
 *	3/17/97 kipo	deal with errors returned by DialogBoxParam()
 *  5/07/97 kipo	added support for modem choice list
 * 12/22/00 aarono   #190380 - use process heap for memory allocation
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>

#include "dplaysp.h"
#include "comport.h"
#include "resource.h"
#include "macros.h"

// constants

typedef enum {
	ASCII_XON = 0x11,
	ASCII_XOFF = 0x13
};

// serial object
typedef struct {
	DPCOMPORT			comPort;		// base object globals
	BOOL				bHaveSettings;	// set to TRUE after settings dialog has been displayed
	DPCOMPORTADDRESS	settings;		// settings to use
} DPSERIAL, *LPDPSERIAL;

// dialog choices for serial port settings

static DWORD	gComPorts[] =		{ 1, 2, 3, 4 };

static DWORD	gBaudRates[] =		{ CBR_110, CBR_300, CBR_600, CBR_1200, CBR_2400,
									  CBR_4800, CBR_9600, CBR_14400, CBR_19200, CBR_38400,
									  CBR_56000, CBR_57600, CBR_115200, CBR_128000, CBR_256000 };

static DWORD	gStopBits[] =		{ ONESTOPBIT, ONE5STOPBITS, TWOSTOPBITS };

static DWORD	gParities[] =		{ NOPARITY, EVENPARITY, ODDPARITY, MARKPARITY };

static DWORD	gFlowControls[] =	{ DPCPA_NOFLOW, DPCPA_XONXOFFFLOW, DPCPA_RTSFLOW, DPCPA_DTRFLOW, DPCPA_RTSDTRFLOW };

// globals

// this is defined in dllmain.c
extern HINSTANCE		ghInstance;

// this is defined in dpserial.c
extern GUID				DPSERIAL_GUID;

// prototypes

static HRESULT			DisposeSerial(LPDPCOMPORT baseObject);
static HRESULT			ConnectSerial(LPDPCOMPORT baseObject, BOOL bWaitForConnection, BOOL bReturnStatus);
static HRESULT			DisconnectSerial(LPDPCOMPORT baseObject);
static HRESULT			GetSerialAddress(LPDPCOMPORT baseObject, DWORD dwPlayerFlags,
										 LPVOID lpAddress, LPDWORD lpdwAddressSize);
static HRESULT			GetSerialAddressChoices(LPDPCOMPORT baseObject,
									     LPVOID lpAddress, LPDWORD lpdwAddressSize);

static BOOL				SetupConnection(HANDLE hCom, LPDPCOMPORTADDRESS portSettings);
static BOOL FAR PASCAL	EnumAddressData(REFGUID lpguidDataType, DWORD dwDataSize,
										LPCVOID lpData, LPVOID lpContext);
static BOOL				GetSerialSettings(HINSTANCE hInstance, HWND hWndParent, LPDPSERIAL globals);
static UINT_PTR CALLBACK SettingsDialog(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
static void				InitDialog(HWND hDlg, LPDPCOMPORTADDRESS settings);
static void				GetSettingsFromDialog(HWND hDlg, LPDPCOMPORTADDRESS settings);
static int				ValueToIndex(LPDWORD buf, int bufLen, DWORD value);
static void				FillComboBox(HWND hDlg, int dlgItem, int startStr, int stopStr);

/*
 * NewSerial
 *
 * Create new serial port object.
 */
HRESULT NewSerial(LPVOID lpConnectionData, DWORD dwConnectionDataSize,
				  LPDIRECTPLAYSP lpDPlay, LPREADROUTINE lpReadRoutine,
				  LPDPCOMPORT *storage)
{
	LPDPCOMPORT baseObject;
	LPDPSERIAL	globals;
	HRESULT		hr;

	// create base object with enough space for our globals
	hr = NewComPort(sizeof(DPSERIAL), lpDPlay, lpReadRoutine, &baseObject);
	if FAILED(hr)
		return (hr);

	// fill in methods we implement
	baseObject->Dispose = DisposeSerial;
	baseObject->Connect = ConnectSerial;
	baseObject->Disconnect = DisconnectSerial;
	baseObject->GetAddress = GetSerialAddress;
	baseObject->GetAddressChoices = GetSerialAddressChoices;

	// setup default settings
	globals = (LPDPSERIAL) baseObject;
	globals->settings.dwComPort = 1;					// COM port to use (1-4)
	globals->settings.dwBaudRate = CBR_57600;			// baud rate (100-256k)
	globals->settings.dwStopBits = ONESTOPBIT;			// no. stop bits (1-2)
	globals->settings.dwParity = NOPARITY;				// parity (none, odd, even, mark)
	globals->settings.dwFlowControl = DPCPA_RTSDTRFLOW;	// flow control (none, xon/xoff, rts, dtr)

	// check for valid connection data
	if (lpConnectionData)
	{
		baseObject->lpDPlay->lpVtbl->EnumAddress(baseObject->lpDPlay, EnumAddressData, 
									lpConnectionData, dwConnectionDataSize,
									globals);
	}

	// return object pointer
	*storage = baseObject;

	return (DP_OK);
}

/*
 * EnumConnectionData
 *
 * Search for valid connection data
 */

static BOOL FAR PASCAL EnumAddressData(REFGUID lpguidDataType, DWORD dwDataSize,
							LPCVOID lpData, LPVOID lpContext)
{
	LPDPSERIAL			globals = (LPDPSERIAL) lpContext;
	LPDPCOMPORTADDRESS	settings = (LPDPCOMPORTADDRESS) lpData;

	// this is a com port chunk
	if ( IsEqualGUID(lpguidDataType, &DPAID_ComPort) &&
		 (dwDataSize == sizeof(DPCOMPORTADDRESS)) )
	{
		// make sure it's valid!
		if ((ValueToIndex(gComPorts, sizeof(gComPorts), settings->dwComPort) >= 0) &&
			(ValueToIndex(gBaudRates, sizeof(gBaudRates), settings->dwBaudRate) >= 0) &&
			(ValueToIndex(gStopBits, sizeof(gStopBits), settings->dwStopBits) >= 0) &&
			(ValueToIndex(gParities, sizeof(gParities), settings->dwParity) >= 0) &&
			(ValueToIndex(gFlowControls, sizeof(gFlowControls), settings->dwFlowControl) >= 0))
		{
			globals->settings = *settings;		// copy the data
			globals->bHaveSettings = TRUE;		// we have valid settings
		}
	}

	return (TRUE);
}

/*
 * DisposeSerial
 *
 * Dispose serial port object.
 */

static HRESULT DisposeSerial(LPDPCOMPORT baseObject)
{
	LPDPSERIAL	globals = (LPDPSERIAL) baseObject;

	// make sure we are disconnected
	DisconnectSerial(baseObject);

	// free object
	SP_MemFree((HGLOBAL) baseObject);

	return (DP_OK);
}

/*
 * ConnectSerial
 *
 * Open serial port and configure based on user settings.
 */

static HRESULT ConnectSerial(LPDPCOMPORT baseObject,
							 BOOL bWaitForConnection, BOOL bReturnStatus)
{
	LPDPSERIAL	globals = (LPDPSERIAL) baseObject;
	HANDLE		hCom;
	TCHAR		portName[10];
	HRESULT		hr;

	// see if com port is already connected
	hCom = baseObject->GetHandle(baseObject);
	if (hCom)
		return (DP_OK);

	// ask user for settings if we have not already
	if (!globals->bHaveSettings)
	{
		if (!GetSerialSettings(ghInstance, GetForegroundWindow(), globals))
		{
			hr = DPERR_USERCANCEL;
			goto Failure;
		}

		globals->bHaveSettings = TRUE;
	}

	// open specified com port
	CopyMemory(portName, "COM0", 5);
	portName[3] += (BYTE) globals->settings.dwComPort;

	hCom = CreateFile(	portName,
						GENERIC_READ | GENERIC_WRITE,
						0,    /* comm devices must be opened w/exclusive-access */
						NULL, /* no security attrs */
						OPEN_EXISTING, /* comm devices must use OPEN_EXISTING */
						FILE_ATTRIBUTE_NORMAL | 
						FILE_FLAG_OVERLAPPED, // overlapped I/O
						NULL  /* hTemplate must be NULL for comm devices */
						);

	if (hCom == INVALID_HANDLE_VALUE)
	{
		hCom = NULL;
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Failure;
	}

	// configure com port to proper settings
	if (!SetupConnection(hCom, &globals->settings))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Failure;
	}

	// setup com port
	hr = baseObject->Setup(baseObject, hCom);
	if FAILED(hr)
		goto Failure;

	return (DP_OK);

Failure:
	if (hCom)
		CloseHandle(hCom);

	return (hr);
}

/*
 * DisconnectSerial
 *
 * Close serial port.
 */

static HRESULT DisconnectSerial(LPDPCOMPORT baseObject)
{
	HANDLE		hCom;
	HRESULT		hr;

	hCom = baseObject->GetHandle(baseObject);

	// com port is already disconnected
	if (hCom == NULL)
		return (DP_OK);

	// shut down com port
	hr = baseObject->Shutdown(baseObject);

	// close com port
	CloseHandle(hCom);

	return (hr);
}

/*
 * SetupConnection
 *
 * Configure serial port with specified settings.
 */

static BOOL SetupConnection(HANDLE hCom, LPDPCOMPORTADDRESS portSettings)
{
	DCB		dcb;

	dcb.DCBlength = sizeof(DCB);
	if (!GetCommState(hCom, &dcb))
		return (FALSE);

	// setup various port settings

	dcb.fBinary = TRUE;
	dcb.BaudRate = portSettings->dwBaudRate;
	dcb.ByteSize = 8;
	dcb.StopBits = (BYTE) portSettings->dwStopBits;

	dcb.Parity = (BYTE) portSettings->dwParity;
	if (portSettings->dwParity == NOPARITY)
		dcb.fParity = FALSE;
	else
		dcb.fParity = TRUE;

	// setup hardware flow control

	if ((portSettings->dwFlowControl == DPCPA_DTRFLOW) ||
		(portSettings->dwFlowControl == DPCPA_RTSDTRFLOW))
	{
		dcb.fOutxDsrFlow = TRUE;
		dcb.fDtrControl = DTR_CONTROL_HANDSHAKE;
	}
	else
	{
		dcb.fOutxDsrFlow = FALSE;
		dcb.fDtrControl = DTR_CONTROL_ENABLE;
	}

	if ((portSettings->dwFlowControl == DPCPA_RTSFLOW) ||
		(portSettings->dwFlowControl == DPCPA_RTSDTRFLOW))
	{
		dcb.fOutxCtsFlow = TRUE;
		dcb.fRtsControl = RTS_CONTROL_HANDSHAKE;
	}
	else
	{
		dcb.fOutxCtsFlow = FALSE;
		dcb.fRtsControl = RTS_CONTROL_ENABLE;
	}

	// setup software flow control

	if (portSettings->dwFlowControl == DPCPA_XONXOFFFLOW)
	{
		dcb.fInX = TRUE;
		dcb.fOutX = TRUE;
	}
	else
	{
		dcb.fInX = FALSE;
		dcb.fOutX = FALSE;
	}

	dcb.XonChar = ASCII_XON;
	dcb.XoffChar = ASCII_XOFF;
	dcb.XonLim = 100;
	dcb.XoffLim = 100;

	if (!SetCommState( hCom, &dcb ))
	   return (FALSE);

	return (TRUE);
}

/*
 * GetSerialAddress
 *
 * Return current serial port info if available.
 */

static HRESULT GetSerialAddress(LPDPCOMPORT baseObject, DWORD dwPlayerFlags,
								LPVOID lpAddress, LPDWORD lpdwAddressSize)
{
	LPDPSERIAL	globals = (LPDPSERIAL) baseObject;
	HRESULT		hResult;

	// no settings yet
	if (!globals->bHaveSettings)
		return (DPERR_UNAVAILABLE);

	hResult = baseObject->lpDPlay->lpVtbl->CreateAddress(baseObject->lpDPlay,
						&DPSERIAL_GUID, &DPAID_ComPort,
						&globals->settings, sizeof(DPCOMPORTADDRESS),
						lpAddress, lpdwAddressSize);

	return (hResult);
}

/*
 * GetSerialAddressChoices
 *
 * Return current serial address choices
 */

static HRESULT GetSerialAddressChoices(LPDPCOMPORT baseObject,
									   LPVOID lpAddress, LPDWORD lpdwAddressSize)
{
	LPDPSERIAL	globals = (LPDPSERIAL) baseObject;

	// currently the serial provider does not support any choices
	return (E_NOTIMPL);
}

/*
 * GetComPortSettings
 *
 * Displays a dialog to gather and return the COM port settings.
 */

static BOOL GetSerialSettings(HINSTANCE hInstance, HWND hWndParent, LPDPSERIAL globals)
{
	INT_PTR	iResult;

    iResult = (INT_PTR)DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_SETTINGSDIALOG), hWndParent, SettingsDialog, (LPARAM) globals);
	return (iResult > 0);
}

/*
 * SettingsDialog
 *
 * The dialog callback routine to display and edit the COM port settings.
 */

static UINT_PTR CALLBACK SettingsDialog(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
	LPDPSERIAL			globals = (LPDPSERIAL) GetWindowLongPtr(hDlg, DWLP_USER);
	HWND				hWndCtl;
	BOOL				msgHandled = FALSE;
    
	switch (msg)
	{
	case WM_INITDIALOG:
		// serial info pointer passed in lParam
		globals = (LPDPSERIAL) lParam;

         // save the globals with the window
		SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR) globals);

		hWndCtl = GetDlgItem(hDlg, IDC_COMPORT);

		// make sure our dialog item is there
		if (hWndCtl == NULL)
		{
			EndDialog(hDlg, FALSE);
			msgHandled = TRUE;
		}
		else
		{
			InitDialog(hDlg, &globals->settings);	// setup our dialog
			SetFocus(hWndCtl);				// focus on com port combo box
			msgHandled = FALSE;				// keep windows from setting input focus for us
		}
		break;

    case WM_COMMAND:

		if (HIWORD(wParam) == 0)
		{
			switch (LOWORD(wParam))
			{
			case IDOK:						// return settings
				GetSettingsFromDialog(hDlg, &globals->settings);
				EndDialog(hDlg, TRUE);
				msgHandled = TRUE;
 				break;

			case IDCANCEL:					// cancel
				EndDialog(hDlg, FALSE);
				msgHandled = TRUE;
 				break;
			}
		}
		break;
    }

    return (msgHandled);
}

/*
 * InitDialog
 *
 * Initialize the dialog controls to display the given COM port settings.
 */

static void InitDialog(HWND hDlg, LPDPCOMPORTADDRESS settings)
{
	// fill dialog combo boxes with items from string table
	FillComboBox(hDlg, IDC_COMPORT, IDS_COM1, IDS_COM4);
	FillComboBox(hDlg, IDC_BAUDRATE, IDS_BAUD1, IDS_BAUD15);
	FillComboBox(hDlg, IDC_STOPBITS, IDS_STOPBIT1, IDS_STOPBIT3);
	FillComboBox(hDlg, IDC_PARITY, IDS_PARITY1, IDS_PARITY4);
	FillComboBox(hDlg, IDC_FLOW, IDS_FLOW1, IDS_FLOW5);

	// select default values in combo boxes
	SendDlgItemMessage(hDlg, IDC_COMPORT, CB_SETCURSEL,
					   ValueToIndex(gComPorts, sizeof(gComPorts), settings->dwComPort), 0);
	SendDlgItemMessage(hDlg, IDC_BAUDRATE, CB_SETCURSEL,
					   ValueToIndex(gBaudRates, sizeof(gBaudRates), settings->dwBaudRate), 0);
	SendDlgItemMessage(hDlg, IDC_STOPBITS, CB_SETCURSEL,
					   ValueToIndex(gStopBits, sizeof(gStopBits), settings->dwStopBits), 0);
	SendDlgItemMessage(hDlg, IDC_PARITY, CB_SETCURSEL,
					   ValueToIndex(gParities, sizeof(gParities), settings->dwParity), 0);
	SendDlgItemMessage(hDlg, IDC_FLOW, CB_SETCURSEL,
					   ValueToIndex(gFlowControls, sizeof(gFlowControls), settings->dwFlowControl), 0);
}

/*
 * GetSettingsFromDialog
 *
 * Get the COM port settings from the dialog controls.
 */

static void GetSettingsFromDialog(HWND hDlg, LPDPCOMPORTADDRESS settings)
{
	INT_PTR		index;

	index = SendDlgItemMessage(hDlg, IDC_COMPORT, CB_GETCURSEL, 0, 0);
	if (index == CB_ERR)
		return;

	settings->dwComPort = gComPorts[index];

	index = SendDlgItemMessage(hDlg, IDC_BAUDRATE, CB_GETCURSEL, 0, 0);
	if (index == CB_ERR)
		return;

	settings->dwBaudRate = gBaudRates[index];

	index = SendDlgItemMessage(hDlg, IDC_STOPBITS, CB_GETCURSEL, 0, 0);
	if (index == CB_ERR)
		return;

	settings->dwStopBits = gStopBits[index];

	index = SendDlgItemMessage(hDlg, IDC_PARITY, CB_GETCURSEL, 0, 0);
	if (index == CB_ERR)
		return;

	settings->dwParity = gParities[index];

	index = SendDlgItemMessage(hDlg, IDC_FLOW, CB_GETCURSEL, 0, 0);
	if (index == CB_ERR)
		return;

	settings->dwFlowControl = gFlowControls[index];
}

/*
 * FillComboBox
 *
 * Add the specified strings to the combo box.
 */

#define MAXSTRINGSIZE	200

static void FillComboBox(HWND hDlg, int dlgItem, int startStr, int stopStr)
{
	int		i;
	TCHAR	str[MAXSTRINGSIZE];

	for (i = startStr; i <= stopStr; i++)
	{
		if (LoadString(ghInstance, i, str, MAXSTRINGSIZE))
			SendDlgItemMessage(hDlg, dlgItem, CB_ADDSTRING, (WPARAM) 0, (LPARAM) str);
	}
}

/*
 * ValueToIndex
 *
 * Convert a settings value to a combo box selection index.
 */

static int ValueToIndex(LPDWORD buf, int bufLen, DWORD value)
{
	int		i;

	bufLen /= sizeof(DWORD);
	for (i = 0; i < bufLen; i++)
		if (buf[i] == value)
			return (i);

	return (-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\serial\sources.inc ===
MAJORCOMP=windows
MINORCOMP=GDI
UMTYPE=windows

TARGETNAME=dpmodemx
TARGETTYPE=DYNLINK

USE_MAPSYM=1

INCLUDES= \
	$(DXROOT)\inc; \
	 ..\..\misc; \
	 ..\; \
	 ..\..\dplay; \
	 ..\..\dplobby; \
	 ..\..\common; \
	 $(BASEDIR)\public\sdk\inc\mfc42;

TARGETPATH=obj


#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
           $(BASEDIR)\public\sdk\lib\*\libc.lib    \
	   $(BASEDIR)\public\sdk\lib\*\user32.lib    \
	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib  \
	   $(BASEDIR)\public\sdk\lib\*\tapi32.lib \
	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
	   ..\..\dplay\$(PLAT_DIR)\obj$(BUILD_ALT_DIR)\*\dplayx.lib

DLLENTRY=DllMain

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

!IFDEF PENTIUMCOUNTER
C_DEFINES=$(C_DEFINES) -DPENTIUMCOUNTER
ASM_DEFINES=$(ASM_DEFINES) -DPENTIUMCOUNTER
!endif

C_DEFINES=$(C_DEFINES) -DUSE_CRITSECTS -DWIN16_SEPARATE -DNEW_DPF

LINKER_FLAGS=-SECTION:share,RWS

SOURCES= \
	..\dllmain.c \
	..\dpserial.c \
	..\comport.c \
	..\serial.c \
	..\modem.c \
	..\dial.c \
	..\bilink.c \
	..\dpserial.rc \
	memalloc.c \
	newdpf.c \
	dputils.c


DLLDEF=..\dpserial.def

NTTARGETFILE0=MISC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\serial\macros.h ===
/*==========================================================================
 *
 *  Copyright (C) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       macros.c
 *  Content:	debugging macros
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *  6/10/96	kipo	created it
 * 12/22/00 aarono   #190380 - use process heap for memory allocation
 *@@END_MSINTERNAL
 ***************************************************************************/

#include "dpf.h"
#include "memalloc.h"

#define FAILMSG(condition) \
	if ((condition)) { \
		DPF(0, DPF_MODNAME " line %d : Failed because " #condition "", __LINE__); \
	}

#define FAILERR(err, label) \
	if ((err)) { \
		DPF(0, DPF_MODNAME " line %d : Error = %d", __LINE__, (err)); \
		goto label; \
	}

#define FAILIF(condition, label) \
	if ((condition)) { \
		DPF(0, DPF_MODNAME " line %d : Failed because " #condition "", __LINE__); \
		goto label; \
	}

#define FAILWITHACTION(condition, action, label) \
	if ((condition)) { \
		DPF(0, DPF_MODNAME " line %d : Failed because " #condition "", __LINE__); \
		{ action; } \
		goto label; \
	}

extern CRITICAL_SECTION csMem;
#define INIT_DPSP_CSECT() InitializeCriticalSection(&csMem);
#define FINI_DPSP_CSECT() DeleteCriticalSection(&csMem);

// Wrap Malloc
void _inline __cdecl SP_MemFree( LPVOID lptr )
{
	EnterCriticalSection(&csMem);
	MemFree(lptr);
	LeaveCriticalSection(&csMem);
}

LPVOID _inline __cdecl SP_MemAlloc(UINT size)
{
	LPVOID lpv;
	EnterCriticalSection(&csMem);
	lpv = MemAlloc(size);
	LeaveCriticalSection(&csMem);
	return lpv;
}

LPVOID _inline __cdecl SP_MemReAlloc(LPVOID lptr, UINT size)
{
	EnterCriticalSection(&csMem);
	lptr = MemReAlloc(lptr, size);
	LeaveCriticalSection(&csMem);
	return lptr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\serial\win9x\makefile.inc ===
misc :
	copy ..\..\common\newdpf.h .
	copy ..\..\common\newdpf.c .
	copy ..\..\common\dputils.c .
	copy ..\..\common\memalloc.c .
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\vxd\messages.asm ===
;*****************************************************************************
;
;	(C) Copyright MICROSOFT  Corp, 1994
;
;       Title:      MESSAGES.ASM
;                             
;       Version:    1.00
;
;       Date:       07-Jul-1994
;
;       Author:     
;
;-----------------------------------------------------------------------------
;
;       Change log:
;
;          Date     Rev Description
;       ----------- --- ------------------------------------------------------
;
;=============================================================================
	.386

	include vmm.inc
	
	CREATE_MESSAGES EQU TRUE

	include msgmacro.inc
	include messages.inc

	END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\vxd\dbgprint.c ===
// DbgPrint - does debug prints to Out_Debug_String.  This allows messages to be
//            printed when using SOFT-ICE/W to debug VxDs.
//
//      File courtesy Hans Hurvig.
//

void DbgPrint(char *afmt, ...);

#include <basedef.h>
#include <vmm.h>
#include <stdarg.h>


#define DBGPRINT_BUFFER_SIZE 1024
UCHAR    DbgBuf [DBGPRINT_BUFFER_SIZE+1];
PUCHAR   pDbgBuf = DbgBuf;
PUCHAR   pDbgBufEnd = DbgBuf+DBGPRINT_BUFFER_SIZE;

UCHAR DbgHexChars[] = "0123456789ABCDEF";

#ifdef DBCS_SUPPORT
UCHAR    DbgLeadByte=0; // Nonzero lead byte if in the middle of outputting a DBCS char
#endif

_inline void DbgFlush(void)
{
    if (pDbgBuf != DbgBuf) {
        *pDbgBuf = 0;
        VMM_Out_Debug_String ( pDbgBuf = DbgBuf );
    }
}

_inline void DbgPutcLiteral(UCHAR c)
{
    if (pDbgBuf >= pDbgBufEnd) {
        DbgFlush();
    }
    *(pDbgBuf++) = c;
}

_inline void DbcPutHexByteLiteral(UCHAR c)
{
    DbgPutcLiteral(DbgHexChars[c >> 4]);
    DbgPutcLiteral(DbgHexChars[c & 0x0F]);
}

void _fastcall DbgPutc(UCHAR c)
{
#ifdef DBCS_SUPPORT
    if (DbgLeadByte != 0) {
        UCHAR c1 = DbgLeadByte;

        DbgLeadByte = 0;
        DbgPutcLiteral('<');
        DbcPutHexByteLiteral(c1);
        DbcPutHexByteLiteral(c);
        DbgPutcLiteral('>');
    } else if (c == '\0') {
        DbgPutcLiteral('<');
        DbcPutHexByteLiteral('N');
        DbcPutHexByteLiteral('U');
        DbcPutHexByteLiteral('L');
        DbgPutcLiteral('>');
    } else if (IsDBCSLeadByte(c)) {
        DbgLeadByte = c;
    } else
#endif
    
    if (c == '\n') {
        DbgPutcLiteral('\r');
        DbgPutcLiteral('\n');
    } else if (c >= 0x7f || c < ' ') {
        DbgPutcLiteral('<');
        DbcPutHexByteLiteral(c);
        DbgPutcLiteral('>');
    } else {
        DbgPutcLiteral(c);
    }

}

void
putl(unsigned long ul, unsigned short base, short mindig, UCHAR pad)
{
    static UCHAR buf[12];
    register UCHAR *cp = buf;

    buf[0] = 0;
    do {
        --mindig;
        *++cp = DbgHexChars[ul % base];
    } while ((ul /= base) != 0);

    for ( ; mindig > 0 ; --mindig)
        DbgPutc(pad);

    do {
        DbgPutc(*cp);
    } while (*--cp);
}

void DbgPrint(char *afmt, ...)
{
    register int c;
    PUCHAR psz;
    unsigned short base;
    /** va_list list; **/
    PUCHAR list;
    PUCHAR oldfmt;
    register UCHAR *fmt = afmt;

    va_start(list, afmt);

    for (; (c = *fmt) != 0 ; ++fmt) {
        oldfmt = fmt;
        if (c != '%') {
            DbgPutc((UCHAR)c);
#ifdef DBCS_SUPPORT
            if (IsDBCSLeadByte(c)) {
                c = *(++fmt);
                if (c == '\0')
                    goto endloop;
                DbgPutc((UCHAR)c);
            }
#endif
        } else {
            char fLong = 0;
            char fFar = 0;
            unsigned short minchr = 0, maxchr = 0xffff;
            char fLJ = 0;
            char pad = ' ';
            
            base = 10;
            if (fmt[1] == '-') {
                fLJ++;
                fmt++;
            }

            if (fmt[1] == '0')
                pad = '0';

            while ((c = *++fmt) >= '0' && c <= '9')
                minchr = minchr*10 + c - '0';

            if (c == '.') {
                maxchr = 0;
                while ((c = *++fmt) >= '0' && c <= '9')
                    maxchr = maxchr*10 + c - '0';
            }

            if (c == 'l') {
                fLong = 1;
                c = *++fmt;
            }
            if (c == 'F') {
                fFar = 1;
                c = *++fmt;
            }

            switch (c) {
            case 'c':
                DbgPutc((char) va_arg(list, int));
                break;

            case 'p':
            case 'P':
                if (fLong) {
                    DbgFlush();
                    if (fFar)
                        VMM_Out_Debug_Data_Label( va_arg(list, void *) );
                    else
                        VMM_Out_Debug_Code_Label( va_arg(list, void *) );
                    break;
                }

                // not a "long" pointer; treat like 'X'

            case 'x':
            case 'X':
                base = 16;
            case 'd':
                putl(va_arg(list, unsigned long), base, minchr, pad);
                break;

            case 's':
                psz = va_arg(list, char *);
                {
                    unsigned   sln;
                    unsigned   i;

                    if (!fLong)
                        sln = strlen(psz);
                    else {
                        sln = *(unsigned char *)psz;         // Treat "l" attrib on string as PSTRING
                        psz++;
                    }

                    if (maxchr) {
                        if (sln > maxchr)
                            sln = maxchr;
                    }

                    if (minchr && !fLJ) {
                        while (minchr-- > sln)
                            DbgPutc(' ');
                    }

                    for (i=0;i<sln;i++)
                        DbgPutc(*psz++);
                    while (i++ < minchr)
                        DbgPutc(' ');
                }
                break;

            case '%':
                DbgPutc('%');
                break;

            default:
                DbgPutc('%');
                fmt = oldfmt;
                break;
            }
        }
    }

endloop:
    va_end(list);
    DbgFlush();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\tools\dplog\dplog.c ===
// DPLOG.cpp : Defines the entry point for the console application.
//

#include "windows.h"
#include "stdio.h"
#include "memlog.h"

int _cdecl main(int argc, char* argv[])
{
	HANDLE hFile=0;
	HANDLE hMutex=0;
	LPVOID lpMemory=NULL;
	UINT timebase=0;
	UINT i=0;
	
	PSHARED_LOG_FILE pLogFile	=NULL;
	PLOG_ENTRY 		 pLog		=NULL;
    PLOG_ENTRY       pReadEntry =NULL;

	hFile=CreateFileMappingA(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, DPLOG_SIZE, BASE_LOG_FILENAME);
	if (!hFile){
		goto exit;
	}
	hMutex=CreateMutexA(NULL, FALSE, BASE_LOG_MUTEXNAME); 
	if (!hMutex){
		goto exit;
	}
	lpMemory=MapViewOfFile(hFile, FILE_MAP_ALL_ACCESS, 0, 0, 0);
	if(!lpMemory){
		goto exit;
	}

	pLogFile=(PSHARED_LOG_FILE)lpMemory;
	pLog=(PLOG_ENTRY)(pLogFile+1);

	WaitForSingleObject(hMutex,INFINITE);

	if(pLogFile->cInUse == pLogFile->nEntries){
		// dump last half of buffer
		for(i=pLogFile->iWrite; i < pLogFile->nEntries; i++){
			pReadEntry=(PLOG_ENTRY)(((CHAR *)pLog)+(i*(pLogFile->cbLine+sizeof(LOG_ENTRY))));
			printf("%4d: %8x %6d %2x %s\n",i,pReadEntry->hThread,pReadEntry->tLogged-timebase,pReadEntry->DebugLevel, pReadEntry->str);
			timebase=pReadEntry->tLogged;
		}
	}

	// dump firt part of buffer

	for(i=0;i<pLogFile->iWrite;i++){
		pReadEntry=(PLOG_ENTRY)(((CHAR *)pLog)+(i*(pLogFile->cbLine+sizeof(LOG_ENTRY))));
		printf("%4d: %8x %6d %2x %s\n",i,pReadEntry->hThread,pReadEntry->tLogged-timebase,pReadEntry->DebugLevel, pReadEntry->str);
		timebase=pReadEntry->tLogged;
	}

	ReleaseMutex(hMutex);
	UnmapViewOfFile(lpMemory);

exit:
	if(hFile){
		CloseHandle(hFile);
	}
	if(hMutex){
		CloseHandle(hMutex);
	}
	
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\vxd\debugext.asm ===
.LALL
;*****************************************************************************
;
;	(C) Copyright MICROSOFT  Corp, 1993
;
;       Title:      DPLAY.ASM
;                             
;       Version:    1.00
;
;       Date:       16-Mar-1993
;
;       Author:     AaronO (mostly stolen from SnowBall vxdinit.asm)
;
;-----------------------------------------------------------------------------
;
;       Change log:
;
;          Date     Rev Description
;       ----------- --- ------------------------------------------------------
;       16-Mar-1993 AWO Original (splurped from SnowBall vxdinit.asm)
;
;=============================================================================
;
; 	Main VxD module for the NWSERVER NCP server:
;
;		Real mode initialization
;		VxD Initialization, including server VM creation
;		VxD PM API support
;		ServerStarvation checker
;
;-----------------------------------------------------------------------------
; BUGBUG: make sure everything is cleaned up from getting rid of VM here.
;-----------------------------------------------------------------------------
        TITLE $DEBUG
        .386P


include vmm.inc
include debug.inc
include shell.inc

include perf.inc        ;performance monitor
include msgmacro.inc
include messages.inc

MASM=1


ifdef DEBUG
extrn  _Debug_Query : near
extrn  _DebugQueryCmdStr : byte
extrn  _DebugQueryCmdStrLen : dword
endif

VxD_LOCKED_CODE_SEG

DPLAY_Device_Id equ 444h

Declare_Virtual_Device DPLAY, 1, 0, DPLAY_Control, DPLAY_Device_Id, \
                        Undefined_Init_Order, 0, 0


;=============================================================================
; 			VxD Control Dispatch table
;-----------------------------------------------------------------------------

Begin_Control_Dispatch DPLAY
;   Control_Dispatch Set_Device_Focus,     SERVER_Set_Device_Focus
;   Control_Dispatch QUERY_DESTROY,        NWSERVER_Query_Destroy
;    Control_Dispatch SYS_CRITICAL_INIT,    NWSERVER_Critical_Init
    Control_Dispatch DEVICE_INIT,          DPLAY_Device_Init
;    Control_Dispatch INIT_COMPLETE,        NWSERVER_Init_Complete
    Control_Dispatch DEBUG_QUERY,          DPLAY_Debug_Query
;   Control_Dispatch Create_VM, 	   SERVER_Create_VM
;   Control_Dispatch SYS_VM_TERMINATE,     NWSERVER_Exit
;   Control_Dispatch SYS_CRITICAL_EXIT,    NWSERVER_Critical_Exit
;   Control_Dispatch VM_NOT_EXECUTEABLE,   NWSERVER_VM_Not_Exec
;   Control_Dispatch END_PM_APP, 	   NWSERVER_End_PM_App
;   Control_Dispatch Device_Reboot_Notify, NWSERVER_Reboot
;    Control_Dispatch DESTROY_THREAD,       NWSERVER_Destroy_Thread
;   Control_Dispatch BEGIN_PM_APP,         NWSERVER_Begin_PM_App
;    Control_Dispatch KERNEL32_INITIALIZED, NWSERVER_Kernel32Initialized
;    Control_Dispatch KERNEL32_SHUTDOWN,    NWSERVER_Kernel32Shutdown
;    Control_Dispatch W32_DeviceIoControl,  NWSERVER_Win32_API
;PNP_NEW_DEVNODE	     EQU 22h
;    Control_Dispatch PNP_NEW_DEVNODE,      NWSERVER_PNPNewDevNode
;    Control_Dispatch System_Exit,          NWSERVER_System_Exit
    Control_Dispatch W32_DEVICEIOCONTROL,     DPLAY_W32_DeviceIOControl, sCall, <ecx, ebx, edx, esi>

End_Control_Dispatch DPLAY

;
; DbgPrint is defined in DbgPrint.c in this case.
;
_VMM_Out_Debug_String PROC NEAR PUBLIC
        push    esi
        mov     esi, [esp].8
        VMMcall Out_Debug_String
        pop     esi
        ret
_VMM_Out_Debug_String ENDP

; VOID VMM_Out_Debug_Code_Label(PVOID Address)
;
; Outputs a flat pointer as a symbolic label
;
_VMM_Out_Debug_Code_Label PROC NEAR PUBLIC
        mov     eax, [esp].4
	mov	dx, cs
	Trace_Out	"?DX:EAX", nocrlf
        ret
_VMM_Out_Debug_Code_Label ENDP

; VOID VMM_Out_Debug_Data_Label(PVOID Address)
;
; Outputs a flat pointer as a symbolic label
;
_VMM_Out_Debug_Data_Label PROC NEAR PUBLIC
        mov     eax, [esp].4
	mov	dx, ds
	Trace_Out	"?DX:EAX", nocrlf
        ret
_VMM_Out_Debug_Data_Label ENDP


_VMM_Get_Sys_VM_Handle	proc public
	push	ebx
	VMMcall	Get_Sys_VM_Handle
	mov	eax, ebx
	pop	ebx
	ret
_VMM_Get_Sys_VM_Handle	endp

_VMM_Get_Profile_String	proc public
	push	ebp
	mov	ebp, esp

	push	esi
	push	edi

	mov	esi, [ebp+8]		; Section name
	mov	edi, [ebp+12]		; Key name
	mov	edx, [ebp+16]		; default
	VMMcall	Get_Profile_String
	mov	eax, edx

	pop	edi
	pop	esi

	pop	ebp
	ret
_VMM_Get_Profile_String	endp

_VMM_Get_Profile_Hex_Int	proc public
	push	ebp
	mov	ebp, esp

	push	esi
	push	edi

	mov	esi, [ebp+8]		; Section name
	mov	edi, [ebp+12]		; Key name
	mov	eax, [ebp+16]		; default
	VMMcall	Get_Profile_Hex_Int

	pop	edi
	pop	esi

	pop	ebp
	ret
_VMM_Get_Profile_Hex_Int	endp

_C_HeapAllocate PROC NEAR PUBLIC
	mov     eax,ss:[esp+8]
	mov     edx,ss:[esp+4]
	push    eax
	push    edx
	VMMCall _HeapAllocate
	add     esp,8
	ret
_C_HeapAllocate ENDP

_C_HeapFree PROC NEAR PUBLIC
	mov     edx,ss:[esp+4]
	push    0
	push    edx
	VMMcall _HeapFree
	add     esp,8
	ret
_C_HeapFree ENDP

_GetThreadHandle PROC NEAR PUBLIC
	push	edi
	VMMcall Get_Cur_Thread_Handle
	mov     eax,edi
	pop 	edi
	ret
_GetThreadHandle ENDP

_VMM_Create_Semaphore		proc public
	mov	ecx, [esp+4]		; First arg = Initial token count
	VMMCall	Create_Semaphore
	jnc	vcs_1
	xor	eax, eax
vcs_1:
	ret
_VMM_Create_Semaphore		endp

_VMM_Destroy_Semaphore		proc public
	mov	eax, [esp+4]		; First arg = Semaphore handle
	VMMJmp	Destroy_Semaphore
_VMM_Destroy_Semaphore		endp

_VMM_Signal_Semaphore		proc public
	mov	eax, [esp+4]		; First arg = Semaphore handle
	VMMJmp	Signal_Semaphore
_VMM_Signal_Semaphore		endp

; VMM_Wait_Semaphore_Ints - Waits on a semaphore, allowing ints to be processed in this thread
;
_VMM_Wait_Semaphore_Ints	proc public
	mov	eax, [esp+4]		; First arg = Semaphore handle
    mov	ecx, Block_Force_Svc_Ints+Block_Svc_Ints
	VMMJmp	Wait_Semaphore
_VMM_Wait_Semaphore_Ints		endp

;Get system time in milliseconds
_VMM_Get_System_Time		proc public
	VMMJmp Get_System_Time
_VMM_Get_System_Time		endp

;**************************************************************************
;
; MAP_Client_Ptr - convert a pointer to a 0:32 flat pointer
;
; IN  eax = client Segment/Selector
; IN  ebx = client Offset
; IN  edi = points o Client Reg Structure
;
; OUT edx = flat client ptr
;**************************************************************************
MAP_Client_Ptr proc near uses ecx

        ;borrow the client DS:DX
        movzx ecx, [edi].Client_DS
        push ecx
        movzx ecx, [edi].Client_DX
        push ecx

        mov [edi].Client_DS, ax
        mov [edi].Client_DX, bx
        Client_Ptr_Flat edx, DS, DX

        ;restore the contents of the client regs
        pop ecx
        mov [edi].Client_DX, cx
        pop ecx
        mov [edi].Client_DS, cx

        RET

MAP_Client_Ptr ENDP

;*****************************************************************************
;    DPLAYGetVersion - returns the version number of DPLAY DEBUG module
;
;    ENTRY:
;
;    EXIT: Carry is clear, ax=DPLAYVXD version <AH=Major AL = Minor>
;=============================================================================

BeginProc DPLAYGetVersion Service
    mov  eax, 001h
    clc
    ret
EndProc DPLAYGetVersion


; NOTE: The following assumes (craftily) that the command tail for the debug query
;       dot-command is passed in by VMM in FS:[ESI].
;
BeginProc   DPLAY_Debug_Query

	xor	ebx, ebx
	mov	ax, fs
	test	ax, ax
	jz	dq1

	push	esi
	push	ds

	lea	edi, _DebugQueryCmdStr
	mov	ecx, _DebugQueryCmdStrLen
	mov	ds, ax
	cld
	rep	movsb
	xor	eax, eax
	stosb

	pop	ds
	pop	esi

	lea	ebx, _DebugQueryCmdStr

dq1:
	push	ebx
        call    _Debug_Query
	add	esp, 4
	ret
EndProc     DPLAY_Debug_Query

VxD_LOCKED_CODE_ENDS

VxD_LOCKED_DATA_SEG

;====================================================================
; STATISTICS for performance monitor
;--------------------------------------------------------------------
	public hPerfId
hPerfId					dd	?


	public _stat_ThrottleRate
_stat_ThrottleRate		dd	?	

	public _stat_BytesSent
_stat_BytesSent			dd	?

	public _stat_BackLog
_stat_BackLog			dd	?

	public	_stat_BytesLost
_stat_BytesLost			dd	?	

	public  _stat_RemBytesReceived
_stat_RemBytesReceived	dd	?

	public	_stat_Latency
_stat_Latency			dd	?

	public	_stat_MinLatency
_stat_MinLatency		dd	?

	public	_stat_AvgLatency
_stat_AvgLatency		dd	?

	public	_stat_AvgDevLatency
_stat_AvgDevLatency		dd	?

	public	_stat_USER1
_stat_USER1				dd	?	

	public	_stat_USER2
_stat_USER2				dd	?	

	public	_stat_USER3
_stat_USER3				dd	?	

	public  _stat_USER4
_stat_USER4				dd 	?

	public  _stat_USER5
_stat_USER5				dd 	?

	public  _stat_USER6
_stat_USER6				dd 	?

Vxd_LOCKED_DATA_ENDS


VXD_ICODE_SEG

DPLAY_Device_Init proc near public

	LocalVar hStatNULL, DWORD
	LocalVar hStat2, DWORD
	LocalVar hStat1, DWORD

        ; Do STATISTICS VxD stuff

    GET_MESSAGE_PTR <PerfName>, ebx
    GET_MESSAGE_PTR <PerfNodeName>, ecx
        Reg_Perf_Srv 0,0,ebx,ecx,0
        or      eax, eax        ; Q: perf.386 around?
        jz      ir0             ; N: skip it
        mov     hPerfId, eax

    GET_MESSAGE_PTR <PerfThrottleNam>, ebx
    GET_MESSAGE_PTR <PerfThrottleNodeNam>, ecx     
    GET_MESSAGE_PTR <PerfThrottleDsc>, edx         
        Reg_Perf_Stat hPerfId,0,0,ebx,ecx,0,edx,_stat_ThrottleRate

    GET_MESSAGE_PTR <PerfBWNam>, ebx
    GET_MESSAGE_PTR <PerfBWNodeNam>, ecx     
    GET_MESSAGE_PTR <PerfBWDsc>, edx         
        Reg_Perf_Stat hPerfId,0,<PSTF_RATE>,ebx,ecx,0,edx,_stat_BytesSent

    GET_MESSAGE_PTR <PerfBackLogNam>, ebx
    GET_MESSAGE_PTR <PerfBackLogNodeNam>, ecx     
    GET_MESSAGE_PTR <PerfBackLogDsc>, edx         
        Reg_Perf_Stat hPerfId,0,0,ebx,ecx,0,edx,_stat_BackLog

    GET_MESSAGE_PTR <PerfBytesLostNam>, ebx
    GET_MESSAGE_PTR <PerfBytesLostNodeNam>, ecx     
    GET_MESSAGE_PTR <PerfBytesLostDsc>, edx         
        Reg_Perf_Stat hPerfId,0,<PSTF_RATE>,ebx,ecx,0,edx,_stat_BytesLost

    GET_MESSAGE_PTR <PerfLocThroughputNam>, ebx
    GET_MESSAGE_PTR <PerfLocThroughputNodeNam>, ecx     
    GET_MESSAGE_PTR <PerfThroughputDsc>, edx         
        Reg_Perf_Stat hPerfId,0,<PSTF_RATE>,ebx,ecx,0,edx,_stat_RemBytesReceived

    GET_MESSAGE_PTR <PerfLastLatNam>, ebx
    GET_MESSAGE_PTR <PerfLastLatNodeNam>, ecx     
    GET_MESSAGE_PTR <PerfLastLatDsc>, edx         
        Reg_Perf_Stat hPerfId,0,0,ebx,ecx,0,edx,_stat_Latency

    GET_MESSAGE_PTR <PerfMinLatNam>, ebx
    GET_MESSAGE_PTR <PerfMinLatNodeNam>, ecx     
    GET_MESSAGE_PTR <PerfMinLatDsc>, edx         
        Reg_Perf_Stat hPerfId,0,0,ebx,ecx,0,edx,_stat_MinLatency

    GET_MESSAGE_PTR <PerfAvgLatNam>, ebx
    GET_MESSAGE_PTR <PerfAvgLatNodeNam>, ecx     
    GET_MESSAGE_PTR <PerfAvgLatDsc>, edx         
        Reg_Perf_Stat hPerfId,0,0,ebx,ecx,0,edx,_stat_AvgLatency

    GET_MESSAGE_PTR <PerfAvgDevLatNam>, ebx
    GET_MESSAGE_PTR <PerfAvgDevLatNodeNam>, ecx     
    GET_MESSAGE_PTR <PerfAvgDevLatDsc>, edx         
        Reg_Perf_Stat hPerfId,0,0,ebx,ecx,0,edx,_stat_AvgDevLatency
        
    GET_MESSAGE_PTR <PerfUSER1Nam>, ebx
    GET_MESSAGE_PTR <PerfUSER1NodeNam>, ecx     
    GET_MESSAGE_PTR <PerfUSER1Dsc>, edx         
        Reg_Perf_Stat hPerfId,0,0,ebx,ecx,0,edx,_stat_USER1

    GET_MESSAGE_PTR <PerfUSER2Nam>, ebx
    GET_MESSAGE_PTR <PerfUSER2NodeNam>, ecx     
    GET_MESSAGE_PTR <PerfUSER2Dsc>, edx         
        Reg_Perf_Stat hPerfId,0,0,ebx,ecx,0,edx,_stat_USER2

    GET_MESSAGE_PTR <PerfUSER3Nam>, ebx
    GET_MESSAGE_PTR <PerfUSER3NodeNam>, ecx     
    GET_MESSAGE_PTR <PerfUSER3Dsc>, edx         
        Reg_Perf_Stat hPerfId,0,0,ebx,ecx,0,edx,_stat_USER3

    GET_MESSAGE_PTR <PerfUSER4Nam>, ebx
    GET_MESSAGE_PTR <PerfUSER4NodeNam>, ecx     
    GET_MESSAGE_PTR <PerfUSER4Dsc>, edx         
        Reg_Perf_Stat hPerfId,0,0,ebx,ecx,0,edx,_stat_USER4

    GET_MESSAGE_PTR <PerfUSER5Nam>, ebx
    GET_MESSAGE_PTR <PerfUSER5NodeNam>, ecx     
    GET_MESSAGE_PTR <PerfUSER5Dsc>, edx         
        Reg_Perf_Stat hPerfId,0,0,ebx,ecx,0,edx,_stat_USER5

    GET_MESSAGE_PTR <PerfUSER6Nam>, ebx
    GET_MESSAGE_PTR <PerfUSER6NodeNam>, ecx     
    GET_MESSAGE_PTR <PerfUSER6Dsc>, edx         
        Reg_Perf_Stat hPerfId,0,0,ebx,ecx,0,edx,_stat_USER6
;
;    GET_MESSAGE_PTR <PerfTPSNam>, ebx
;    GET_MESSAGE_PTR <PerfTPSNodeNam>, ecx     
;    GET_MESSAGE_PTR <PerfTPSDsc>, edx         
;        Reg_Perf_Stat hPerfId,0,<PSTF_RATE>,ebx,ecx,0,edx,_stat_Transactions
;
;
;    GET_MESSAGE_PTR <PerfBReadNam>, ebx
;    GET_MESSAGE_PTR <PerfBReadNodeNam>, ecx     
;    GET_MESSAGE_PTR <PerfBReadDsc>, edx         
;        Reg_Perf_Stat hPerfId,0,<PSTF_RATE>,ebx,ecx,0,edx,_stat_BRead
;	mov	[hStat1], eax
;
;    GET_MESSAGE_PTR <PerfBWriteNam>, ebx
;    GET_MESSAGE_PTR <PerfBWriteNodeNam>, ecx     
;    GET_MESSAGE_PTR <PerfBWriteDsc>, edx         
;        Reg_Perf_Stat hPerfId,0,<PSTF_RATE>,ebx,ecx,0,edx,_stat_BWrite
;	mov	[hStat2], eax
;	mov	[hStatNull],0
;
;	lea	eax,hStat1
;    GET_MESSAGE_PTR <PerfThroughputNam>, ebx
;    GET_MESSAGE_PTR <PerfThroughputNodeNam>, ecx     
;    GET_MESSAGE_PTR <PerfThroughputDsc>, edx         
;        Reg_Perf_Stat hPerfId,0,<PSTF_COMPLEX OR PSTF_RATE>,ebx,ecx,0,edx,eax

ir0:
	clc
ir1:
	LeaveProc
	Return

DPLAY_Device_Init endp

VXD_ICODE_ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\wsock\bilink.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    BILINK.H

Abstract:

    Management for doubly linked lists

Author:

    George Joy

Environment:

    32-bit 'C'

Revision History:

--*/// BILINK.H

#ifndef _BILINK_

#define _BILINK_

#if !defined(offsetof)
	#define offsetof(type, field) ((int)(&((type *)0)->field))
#endif	

typedef struct BILINK {
    struct BILINK *next;
    struct BILINK *prev;
} BILINK;

/* XLATOFF */

#define EMPTY_BILINK(_pBilink) ((_pBilink)->next==(_pBilink))

#ifdef DEBUG
    #define ASSERT_EMPTY_BILINK(_b) ASSERT((_b)->next==(_b))
#else
    #define ASSERT_EMPTY_BILINK(_b)
#endif

// This only works for BILINKS that are the first item in a structure.
#define BilinkToList( _pBilink ) \
	(_pBilink)->prev->next=NULL;

#define InitBilink( _pBilink ) \
    (_pBilink)->prev=(_pBilink)->next=(_pBilink);

#ifdef DEBUG

int FindObject(
    BILINK *link,
    BILINK *list
    );
#endif

void InsertAfter(
    BILINK *in,
    BILINK *after
    );

void InsertBefore(
     BILINK *in,
     BILINK *before
    );

void Delete(
     BILINK *p
);

/* XLATON */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\vxd\messages.inc ===
;*****************************************************************************
;
;	(C) Copyright MICROSOFT  Corp, 1994
;
;       Title:      MESSAGES.INC
;                             
;       Version:    1.00
;
;       Date:       07-Jul-1994
;
;       Author:     
;
;-----------------------------------------------------------------------------
;
;       Change log:
;
;          Date     Rev Description
;       ----------- --- ------------------------------------------------------
;
;=============================================================================
;
; Init segment messages.


VxD_IMESSAGE_SEG

        DECLARE_MESSAGE <PerfName>, \
                <"DirectPlay Protocol">
        DECLARE_MESSAGE <PerfNodeName>, \
                <"DPPROT">

        DECLARE_MESSAGE <PerfThrottleNam>, \       
                <"Throttle (bytes/sec)">
        DECLARE_MESSAGE <PerfThrottleNodeNam>, \
                <"ThrottleBPSec">
        DECLARE_MESSAGE <PerfThrottleDsc>, \
                <"Upper Limit Protocol will send at">

        DECLARE_MESSAGE <PerfBWNam>, \       
                <"Bytes sent/second">
        DECLARE_MESSAGE <PerfBWNodeNam>, \
                <"BWritSec">
        DECLARE_MESSAGE <PerfBWDsc>, \
                <"Bytes sent by the protocol per second">

        DECLARE_MESSAGE <PerfBackLogNam>, \       
                <"Bytes backlog">
        DECLARE_MESSAGE <PerfBackLogNodeNam>, \
                <"BBackLog">
        DECLARE_MESSAGE <PerfBackLogDsc>, \
                <"Bytes unacked in pipe">

        DECLARE_MESSAGE <PerfBytesLostNam>, \       
                <"Bytes dropped/second">
        DECLARE_MESSAGE <PerfBytesLostNodeNam>, \
                <"BDroppedSec">
        DECLARE_MESSAGE <PerfBytesLostDsc>, \
                <"Bytes dropped/wasted per second">

        DECLARE_MESSAGE <PerfLocThroughputNam>, \
                <"Bytes received by remote/second">
        DECLARE_MESSAGE <PerfLocThroughputNodeNam>, \
                <"ThroughputSecRoundTrip">
        DECLARE_MESSAGE <PerfThroughputDsc>, \
                <"Total received at remote (delayed by latency)">

        DECLARE_MESSAGE <PerfLastLatNam>, \
                <"Last Latency">
        DECLARE_MESSAGE <PerfLastLatNodeNam>, \
                <"LastLat">
        DECLARE_MESSAGE <PerfLastLatDsc>, \
                <"Last round trip latency">
                
        DECLARE_MESSAGE <PerfMinLatNam>, \
                <"Min observed Latency (ms)">
        DECLARE_MESSAGE <PerfMinLatNodeNam>, \
                <"MinLatency">
        DECLARE_MESSAGE <PerfMinLatDsc>, \
                <"Minimum observed Round Trip Latency (ms)">

        DECLARE_MESSAGE <PerfAvgLatNam>, \
                <"Average Latency">
        DECLARE_MESSAGE <PerfAvgLatNodeNam>, \
                <"AvgLat">
        DECLARE_MESSAGE <PerfAvgLatDsc>, \
                <"Average latency, last 16 samples">

        DECLARE_MESSAGE <PerfAvgDevLatNam>, \
                <"Average Dev Latency">
        DECLARE_MESSAGE <PerfAvgDevLatNodeNam>, \
                <"AvgDevLat">
        DECLARE_MESSAGE <PerfAvgDevLatDsc>, \
                <"Average Deviation latency, 16 samples">

        DECLARE_MESSAGE <PerfUSER1Nam>, \
                <"Retries mod 20">
        DECLARE_MESSAGE <PerfUSER1NodeNam>, \
                <"USER1">
        DECLARE_MESSAGE <PerfUSER1Dsc>, \
                <"Retries mod 20">

        DECLARE_MESSAGE <PerfUSER2Nam>, \
                <"Protocol Memory In Use">
        DECLARE_MESSAGE <PerfUSER2NodeNam>, \
                <"USER2">
        DECLARE_MESSAGE <PerfUSER2Dsc>, \
                <"Protocol Memory In Use">

        DECLARE_MESSAGE <PerfUSER3Nam>, \
                <"Dplay Memory In Use">
        DECLARE_MESSAGE <PerfUSER3NodeNam>, \
                <"USER3">
        DECLARE_MESSAGE <PerfUSER3Dsc>, \
                <"Dplay Memory In Use">

        DECLARE_MESSAGE <PerfUSER4Nam>, \
                <"Throttle waits mod 20">
        DECLARE_MESSAGE <PerfUSER4NodeNam>, \
                <"USER4">
        DECLARE_MESSAGE <PerfUSER4Dsc>, \
                <"Throttle waits mod 20">

        DECLARE_MESSAGE <PerfUSER5Nam>, \
                <"Remote Clock Delta">
        DECLARE_MESSAGE <PerfUSER5NodeNam>, \
                <"USER5">
        DECLARE_MESSAGE <PerfUSER5Dsc>, \
                <"Remote Clock Delta Change">

        DECLARE_MESSAGE <PerfUSER6Nam>, \
                <"Remote Clock Bias Reset Mod 10">
        DECLARE_MESSAGE <PerfUSER6NodeNam>, \
                <"USER6">
        DECLARE_MESSAGE <PerfUSER6Dsc>, \
                <"Remote Clock Bias Reset Mod 10">
                
VxD_IMESSAGE_ENDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\vxd\debug.c ===
#define UINT_PTR UINT
#define DWORD_PTR DWORD


#include <dplay.h>
#include <dplaypr.h>
#include <arpdint.h>
#include <mcontext.h>

//#include <basedef.h>
#include <vmm.h>


/*
    GetArg - Gets a command line argument from a string.

    IN          ppArg = pointer to pointer to argument string
    OUT        *ppArg = pointer to next argument, or NULL if this was the last.
    Returns     Pointer to uppercase ASCIZ argument with delimeters stripped, 
or NULL if
                no more arguments.

    Note        Not reentrant

*/
#define MAX_ARG_LEN 30

UCHAR CmdArg[MAX_ARG_LEN+1] = {0};

PUCHAR GetArg(PUCHAR *ppArg)
{
    // Note - Always returns at least one blank argument if string is valid, even
    //        if the string is empty.

    PUCHAR pDest = CmdArg;
    UCHAR c;
    UINT i;

    #define pArg (*ppArg)

    // If end of command already reached, fail

    if (!pArg)
        return NULL;

    // Skip leading whitespace

    while (*pArg == ' ' || *pArg == '\t')
        pArg++;

    // Copy the argument

    for (i = 0; i < MAX_ARG_LEN; i++) {
        if ((c = *pArg) == 0 || c == '\t' || c == ' ' || c == ';' ||
                          c == '\n' || c == ',')
            break;
        if (c >= 'a' && c <= 'z')
            c -= ('a' - 'A');
        *(pDest++) = c;
        pArg++;
    }

    // Null terminate the result

    *pDest = '\0';

    // Skip trailing whitespace

    while (*pArg == ' ' || *pArg == '\t')
        pArg++;

    // strip up to one comma

    if (*pArg == ',')
        pArg++;

    // If end of command reached, make next request fail

    else if (*pArg == 0 || *pArg == ';' || *pArg == '\n')
        pArg = NULL;

    // return copy

    return CmdArg;

    #undef pArg
}
/*
    AtoI - Convert a string to a signed or unsigned integer

    IN          pStr = ASCIZ representation of number with optional leading/trailing
                       whitespace and optional leading '-'.
                Radix = Radix to use for conversion (2, 8, 10, or 16)
    OUT        *pResult = Numeric result, or unchanged on failure
    Returns     1 on success, 0 if malformed string.

    Note        Not reentrant

*/
UINT AtoI(PUCHAR pStr, UINT Radix, PUINT pResult)
{
    UINT r = 0;
    UINT Sign = 0;
    UCHAR c;
    UINT d;

    while (*pStr == ' ' || *pStr == '\t')
        pStr++;

    if (*pStr == '-') {
        Sign = 1;
        pStr++;
    }

    if (*pStr == 0)
        return 0;                   // Empty string!

    while ((c = *pStr) != 0 && c != ' ' && c != '\t') {
        if (c >= '0' && c <= '9')
            d = c - '0';
        else if (c >= 'A' && c <= 'F')
            d = c - ('A' - 10);
        else if (c >= 'a' && c <= 'f')
            d = c - ('a' - 10);
        else
            return 0;               // Not a digit
        if (d >= Radix)
            return 0;               // Not in radix
        r = r*Radix+d;
        pStr++;
    }

    while (*pStr == ' ' || *pStr == '\t')
        pStr++;

    if (*pStr != 0)
        return 0;                   // Garbage at end of string

    if (Sign)
        r = (UINT)(-(INT)r);
    *pResult = r;

    return 1;                       // Success!

}

/*
    GetNumericArg - Gets a numeric command line argument from a string.

    IN          ppArg = pointer to pointer to argument string
                Radix = radix to use for conversion (2, 8, 10, or 16)
    OUT        *ppArg = pointer to next argument, or NULL if this was the last.
               *pResult = numeric result on success; unchanged on failure
    Returns     1 on success, 0 on malformed string or no more arguments

    Note        Not reentrant

*/
UINT GetNumericArg(PUCHAR *ppArg, UINT Radix, PVOID pResult)
{
    PUCHAR pA = GetArg(ppArg);
    UINT rc;

    if (!pA)
        return 0;           // No argument

    rc = AtoI(pA, Radix, (PUINT)pResult);

    if (!rc)
        DbgPrint("? Invalid base-%d value, %s\n", Radix, pA);

    return rc;
}

/*
    GetDecimalArg - Gets a decimal command line argument from a string.

    IN          ppArg = pointer to pointer to argument string
    OUT        *ppArg = pointer to next argument, or NULL if this was the last.
               *pResult = numeric result on success; unchanged on failure
    Returns     1 on success, 0 on malformed string or no more arguments

    Note        Not reentrant

*/
UINT GetDecimalArg(PUCHAR *ppArg, PVOID pResult)
{
    return GetNumericArg(ppArg, 10, pResult);
}

/*
    GetHexArg - Gets a hexadecimal command line argument from a string.

    IN          ppArg = pointer to pointer to argument string
    OUT        *ppArg = pointer to next argument, or NULL if this was the last.
               *pResult = numeric result on success; unchanged on failure
    Returns     1 on success, 0 on malformed string or no more arguments

    Note        Not reentrant

*/
UINT GetHexArg(PUCHAR *ppArg, PVOID pResult)
{
    return GetNumericArg(ppArg, 16, pResult);
}

extern VOID DumpLog(UINT start);
extern VOID DumpWholeLog(VOID);
extern SetLogLevel(UINT level, UINT fExact);

VOID DQLog(PUCHAR pArgs)
{
	UINT record;
	
	if(!GetDecimalArg(&pArgs, &record)){
		DumpWholeLog();
	} else {
		DumpLog(record);
	}
}

VOID DQLogLast(PUCHAR pArgs)
{
	UINT nDump;
	if(!GetDecimalArg(&pArgs, &nDump)){
		DumpLogLast(50);
	} else {
		DumpLogLast(nDump);
	}
}

VOID DQLogLevel(PUCHAR pArgs)
{
	UINT level;
	
	if (!GetDecimalArg(&pArgs, &level))
		return;

	SetLogLevel(level,FALSE);	
}

VOID DQLogExact(PUCHAR pArgs)
{
	UINT level;
	
	if (!GetDecimalArg(&pArgs, &level))
		return;

	SetLogLevel(level,TRUE);	
}

VOID PrintThisFlags(DWORD dwFlags)
{
	DWORD	dwMask, dwField, dwBitCount;

	dwBitCount = 0;
	dwMask = 1;
	while (dwMask)
	{
		dwField = dwFlags & dwMask;
		if (dwField)
		{
			if (dwBitCount == 0)
				DbgPrint("                         (");
			else
				DbgPrint(" |\n                          ");

			switch (dwField)
			{
			case DPLAYI_DPLAY_PENDING:
				DbgPrint("DPLAYI_DPLAY_PENDING");
				break;

			case DPLAYI_DPLAY_SESSIONLOST:
				DbgPrint("DPLAYI_DPLAY_SESSIONLOST");
				break;

			case DPLAYI_DPLAY_CLOSED:
				DbgPrint("DPLAYI_DPLAY_CLOSED");
				break;

			case DPLAYI_DPLAY_DX3INGAME:
				DbgPrint("DPLAYI_DPLAY_DX3INGAME");
				break;

			case DPLAYI_DPLAY_EXECUTINGPENDING:
				DbgPrint("DPLAYI_DPLAY_EXECUTINGPENDING");
				break;

			case DPLAYI_DPLAY_DX3SP:
				DbgPrint("DPLAYI_DPLAY_DX3SP");
				break;

			case DPLAYI_DPLAY_UNINITIALIZED:
				DbgPrint("DPLAYI_DPLAY_UNINITIALIZED");
				break;

			case DPLAYI_DPLAY_ENUM:
				DbgPrint("DPLAYI_DPLAY_ENUM");
				break;

			case DPLAYI_DPLAY_KEEPALIVE:
				DbgPrint("DPLAYI_DPLAY_KEEPALIVE");
				break;

			case DPLAYI_DPLAY_LOBBYOWNS:
				DbgPrint("DPLAYI_DPLAY_LOBBYOWNS");
				break;

			case DPLAYI_DPLAY_SECURITY:
				DbgPrint("DPLAYI_DPLAY_SECURITY");
				break;

			case DPLAYI_DPLAY_ENUMACTIVE:
				DbgPrint("DPLAYI_DPLAY_ENUMACTIVE");
				break;

			case DPLAYI_DPLAY_ENCRYPTION:
				DbgPrint("DPLAYI_DPLAY_ENCRYPTION");
				break;

			case DPLAYI_DPLAY_SPSECURITY:
				DbgPrint("DPLAYI_DPLAY_SPSECURITY");
				break;

			case DPLAYI_DPLAY_HANDLEMULTICAST:
				DbgPrint("DPLAYI_DPLAY_HANDLEMULTICAST");
				break;

			case DPLAYI_DPLAY_SPUNRELIABLE:
				DbgPrint("DPLAYI_DPLAY_SPUNRELIABLE");
				break;

			case DPLAYI_DPLAY_PROTOCOL:
				DbgPrint("DPLAYI_DPLAY_PROTOCOL");
				break;

			case DPLAYI_DPLAY_PROTOCOLNOORDER:
				DbgPrint("DPLAYI_DPLAY_PROTOCOLNOORDER");
				break;
				
			default:
				DbgPrint("unknown: %08x", dwField);
				break;
			}

			dwBitCount++;
		}
		dwMask <<= 1;
	}

	if (dwBitCount)
		DbgPrint(")\n");
}


VOID DQThis(PUCHAR pArgs)
{
	DPLAYI_DPLAY	*this;

	if (!GetHexArg(&pArgs, &this))
		return;

	DbgPrint("\nThis\n\n");
	DbgPrint("dwSize                  : %d\n", this->dwSize);
	DbgPrint("pInterfaces             : %08x\n", this->pInterfaces);
	DbgPrint("dwRefCnt                : %d\n", this->dwRefCnt);
	DbgPrint("dwFlags                 : %08x\n", this->dwFlags);
	PrintThisFlags(this->dwFlags);
	DbgPrint("pcbSPCallbacks          : %08x\n", this->pcbSPCallbacks);
	DbgPrint("pPlayers                : %08x\n", this->pPlayers);
	DbgPrint("pGroups                 : %08x\n", this->pGroups);
	DbgPrint("pSysPlayer              : %08x\n", this->pSysPlayer);
	DbgPrint("pNameTable              : %08x\n", this->pNameTable);
	DbgPrint("nGroups                 : %d\n", this->nGroups);
	DbgPrint("nPlayers                : %d\n", this->nPlayers);
	DbgPrint("uiNameTableSize         : %d\n", this->uiNameTableSize);
	DbgPrint("uiNameTableLastUsed     : %d\n", this->uiNameTableLastUsed);
	DbgPrint("lpsdDesc                : %08x\n", this->lpsdDesc);
	DbgPrint("pMessageList            : %08x\n", this->pMessageList);
	DbgPrint("pLastMessage		  : %08x\n", this->pLastMessage);
	DbgPrint("nMessages               : %d\n", this->nMessages);
	DbgPrint("dwSPHeaderSize          : %d\n", this->dwSPHeaderSize);
	DbgPrint("pMessagesPending        : %08x\n", this->pMessagesPending);
	DbgPrint("pLastPendingMessage	  : %08x\n", this->pLastPendingMessage);
	DbgPrint("nMessagesPending        : %d\n", this->nMessagesPending);
	DbgPrint("dwSPMaxMessage          : %d\n", this->dwSPMaxMessage);
	DbgPrint("dwSPMaxMessageGuaranteed: %d\n", this->dwSPMaxMessageGuaranteed);
	DbgPrint("pPacketList             : %08x\n", this->pPacketList);
	DbgPrint("hDPlayThread            : %08x\n", this->hDPlayThread);
	DbgPrint("hSPModule               : %08x\n", this->hSPModule);
	DbgPrint("hDPlayThreadEvent       : %08x\n", this->hDPlayThreadEvent);
	DbgPrint("pNameServer             : %08x\n", this->pNameServer);
	DbgPrint("pSysGroup               : %08x\n", this->pSysGroup);
	DbgPrint("pServerPlayer           : %08x\n", this->pServerPlayer);
	DbgPrint("pPerfData               : %08x\n", this->pPerfData);
	DbgPrint("pPerfThread             : %08x\n", this->hPerfThread);
	DbgPrint("hPerfEvent              : %08x\n", this->hPerfEvent);
	DbgPrint("pSecurityDesc           : %08x\n", this->pSecurityDesc);
	DbgPrint("ulMaxContextBufferSize  : %d\n", this->ulMaxContextBufferSize);
	DbgPrint("ulMaxSignatureSize      : %d\n", this->ulMaxSignatureSize);
	DbgPrint("hCSP                    : %08x\n", this->hCSP);
	DbgPrint("hPublicKey              : %08x\n", this->hPublicKey);
	DbgPrint("pPublicKey              : %08x\n", this->pPublicKey);
	DbgPrint("dwPublicKeySize         : %d\n", this->dwPublicKeySize);
	DbgPrint("pUserCredentials        : %08x\n", this->pUserCredentials);
	DbgPrint("LoginState              : %d\n", this->LoginState);
	DbgPrint("phCredential            : %08x\n", this->phCredential);
	DbgPrint("phContext               : %08x\n", this->phContext);
	DbgPrint("hEncryptionKey          : %08x\n", this->hEncryptionKey);
	DbgPrint("hDecryptionKey          : %08x\n", this->hDecryptionKey);
	DbgPrint("hServerPublicKey        : %08x\n", this->hServerPublicKey);
	DbgPrint("pspNode                 : %08x\n", this->pspNode);
	DbgPrint("pvSPLocalData           : %08x\n", this->pvSPLocalData);
	DbgPrint("dwSPLocalDataSize       : %d\n", this->dwSPLocalDataSize);
	DbgPrint("pISP                    : %08x\n", this->pISP);
	DbgPrint("pNextObject             : %08x\n", this->pNextObject);
	DbgPrint("dwLastEnum              : %d\n", this->dwLastEnum);
	DbgPrint("dwLastPing              : %d\n", this->dwLastPing);
	DbgPrint("dwEnumTimeout           : %d\n", this->dwEnumTimeout);
	DbgPrint("pbAsyncEnumBuffer       : %08x\n", this->pbAsyncEnumBuffer);
	DbgPrint("dwEnumBufferSize        : %d\n", this->dwEnumBufferSize);
	DbgPrint("lpLobbyObject           : %08x\n", this->lpLobbyObject);
	DbgPrint("lpLaunchingLobbyObject  : %08x\n", this->lpLaunchingLobbyObject);
	DbgPrint("pSessionList            : %08x\n", this->pSessionList);
	DbgPrint("dwMinVersion            : %d\n", this->dwMinVersion);
	DbgPrint("pAddForwardList         : %08x\n", this->pAddForwardList);
	DbgPrint("pProtocol               : %08x\n", this->pProtocol);
	DbgPrint("lpPlayerMsgPool         : %08x\n", this->lpPlayerMsgPool);
	DbgPrint("lpSendParmsPool         : %08x\n", this->lpSendParmsPool);
	DbgPrint("dwPlayerReservations    : %08x\n", this->dwPlayerReservations);
	DbgPrint("dwLastReservationTime   : %08x\n", this->dwLastReservationTime);
	DbgPrint("dwSPVersion             : %08x\n", this->dwSPVersion);
	DbgPrint("dwZombieCount           : %08x\n", this->dwZombieCount);
}

VOID DQContextPool(PUCHAR pArgs)
{
	DPLAYI_DPLAY	*this;
	UINT iNext;
	UINT i=0,j=0;
	PVOID pv;

	if (!GetHexArg(&pArgs, &this))
		return;

	DbgPrint("Dumping Message Context Pool\n");
	DbgPrint("----------------------------\n");

	for(i=0;i<MSG_FAST_CONTEXT_POOL_SIZE+1;i++)
	{
		DbgPrint("[%d]",i);
		if(this->GrpMsgContextPool[i]){
			pv=this->GrpMsgContextPool;
			while(pv){
				DbgPrint("(%x)->\n",pv);
				pv=*((LPVOID *)pv);
				j++;
				if(j==10){
					DbgPrint("\n");
					j=0;
				}
			}
		} 
		DbgPrint("\n");
	}
}

VOID DQContextList(PUCHAR pArgs)
{
	DPLAYI_DPLAY	*pIDP;
	PMSGCONTEXTTABLE this;
	UINT iNext;
	UINT i=0,j;

	if (!GetHexArg(&pArgs, &pIDP))
		return;

	this=pIDP->pMsgContexts;

	DbgPrint("Dumping pMsgContexts at %x off of IDplay %x:\n",this,pIDP);
	DbgPrint("------------------------------------------------------------\n");
	DbgPrint("nUnique 		: %x\n",this->nUnique);
	DbgPrint("nTableSize    : %d\n",this->nTableSize);
	DbgPrint("FreeList:\n");
	iNext=this->iNextAvail;
	while(iNext != LIST_END){
		DbgPrint("[%d]->",iNext);
		iNext=this->MsgContextEntry[iNext].iNextAvail;
		i++;
		if(i==10){
			DbgPrint("\n");
			i=0;
		}
	}
	DbgPrint("\nFull Dump:\n");
	for(i=0;i<this->nTableSize;i++){
		DbgPrint("[%d] psp %x nUnique %x nContexts %d",i,
				this->MsgContextEntry[i].psp,this->MsgContextEntry[i].nUnique,
				this->MsgContextEntry[i].nContexts);
		if(this->MsgContextEntry[i].nUnique){
			DbgPrint(" Context List @ %x:\n",this->MsgContextEntry[i].papv);
			for(j=0;j<this->MsgContextEntry[i].nContexts;j++){
				DbgPrint("[%x] %x\n", j, *(((PVOID *)this->MsgContextEntry[i].papv)+j));
			}
		} else {
			DbgPrint(" NONE\n");
		}
	}

}

VOID PrintPlayerFlags(DWORD dwFlags)
{
	DWORD	dwMask, dwField, dwBitCount;

	dwBitCount = 0;
	dwMask = 1;
	while (dwMask)
	{
		dwField = dwFlags & dwMask;
		if (dwField)
		{
			if (dwBitCount == 0)
				DbgPrint("                         (");
			else
				DbgPrint(" |\n                          ");

			switch (dwField)
			{
			case DPLAYI_PLAYER_SYSPLAYER:
				DbgPrint("DPLAYI_PLAYER_SYSPLAYER");
				break;

			case DPLAYI_PLAYER_NAMESRVR:
				DbgPrint("DPLAYI_PLAYER_NAMESRVR");
				break;

			case DPLAYI_PLAYER_PLAYERINGROUP:
				DbgPrint("DPLAYI_PLAYER_PLAYERINGROUP");
				break;

			case DPLAYI_PLAYER_PLAYERLOCAL:
				DbgPrint("DPLAYI_PLAYER_PLAYERLOCAL");
				break;

			case DPLAYI_PLAYER_CREATEDPLAYEREVENT:
				DbgPrint("DPLAYI_PLAYER_CREATEDPLAYEREVENT");
				break;

			case DPLAYI_GROUP_SYSGROUP:
				DbgPrint("DPLAYI_GROUP_SYSGROUP");
				break;

			case DPLAYI_GROUP_DPLAYOWNS:
				DbgPrint("DPLAYI_GROUP_DPLAYOWNS");
				break;

			case DPLAYI_PLAYER_APPSERVER:
				DbgPrint("DPLAYI_PLAYER_APPSERVER");
				break;

			case DPLAYI_GROUP_STAGINGAREA:
				DbgPrint("DPLAYI_GROUP_STAGINGAREA");
				break;

			case DPLAYI_GROUP_HIDDEN:
				DbgPrint("DPLAYI_GROUP_HIDDEN");
				break;

			case DPLAYI_PLAYER_OWNER:
				DbgPrint("DPLAYI_PLAYER_OWNER");
				break;

			case DPLAYI_DPLAY_SPUNRELIABLE: 
				DbgPrint("DPLAYI_DPLAY_SPUNRELIABLE\n");
				break;

			case DPLAYI_DPLAY_PROTOCOL:
				DbgPrint("DPLAYI_DPLAY_PROTOCOL\n");
				break;
				
			case DPLAYI_DPLAY_PROTOCOLNOORDER:
				DbgPrint("DPLAYI_DPLAY_PROTOCOLNOORDER\n");
				break;

			case DPLAYI_PLAYER_ON_DEATH_ROW:
				DbgPrint("DPLAYI_PLAYER_ON_DEATH_ROW");
				break;

			case DPLAYI_PLAYER_DOESNT_HAVE_NAMETABLE:
				DbgPrint("DPLAYI_PLAYER_DOESNT_HAVE_NAMETABLE");
				break;

			case DPLAYI_PLAYER_CONNECTION_LOST:
				DbgPrint("DPLAYI_PLAYER_CONNECTION_LOST");
				break;

			case DPLAYI_PLAYER_BEING_DESTROYED:
				DbgPrint("DPLAYI_PLAYER_BEING_DESTROYED");
				break;
				
			default:
				DbgPrint("unknown: %08x", dwField);
				break;
			}

			dwBitCount++;
		}
		dwMask <<= 1;
	}

	if (dwBitCount)
		DbgPrint(")\n");
}

VOID DQFixedMemPool(PUCHAR pArgs)
{
	void *pv;
	PFPOOL pPool;
	UINT i;

	if (!GetHexArg(&pArgs, &pPool))
		return;

	DbgPrint("MemoryPool @ (%x) : ItemSize (%d)\n",pPool,pPool->cbItemSize);
	DbgPrint("-------------------------------------------------\n");
	DbgPrint("nAllocated : %d\n",pPool->nAllocated);
	DbgPrint("nInUse     : %d\n",pPool->nInUse);
	DbgPrint("nMaxInUse  : %d\n",pPool->nMaxInUse);

	DbgPrint("\nfnGet      : %x\n",pPool->Get);
	DbgPrint(  "fnRelease  : %x\n",pPool->Release);
	DbgPrint(  "fnScale    : %x\n",pPool->Scale);
	DbgPrint(  "fnFini     : %x\n",pPool->Fini);

	DbgPrint("fnBlockInitAlloc  :%x\n",pPool->fnBlockInitAlloc);
	DbgPrint("fnBlockInit       :%x\n",pPool->fnBlockInit);
	DbgPrint("fnBlockFini       :%x\n",pPool->fnBlockFini);

	DbgPrint("FreeList->");
	pv=pPool->pPool;
	i=0;
	while(pv){
		DbgPrint("(%x)->",pv);
		pv=*((void **)pv);
		i++;
		if(i==6){
			i=0;
			DbgPrint("\n");
		}
	}
	DbgPrint("NULL");
	
}

VOID DQSendParms(PUCHAR pArgs)
{
	PSENDPARMS psp;
	UINT i;

	if (!GetHexArg(&pArgs, &psp))
		return;

	DbgPrint( "SENDPARMS @ (%x)\n",psp);
	DbgPrint( "----------------------\n");
	DbgPrint( "idFrom %x   pPlayerFrom:%x\n",psp->idFrom,psp->pPlayerFrom);
	
	if(psp->pPlayerTo){
		DbgPrint( "  idTo %x   pPlayerTo  :%x\n",psp->idTo, psp->pPlayerTo);
	}
	if(psp->pGroupTo){
		DbgPrint( "  idTo %x   pGroupTo  :%x\n",psp->idTo, psp->pGroupTo);
	}	
	DbgPrint( "RefCount   :%d\n",psp->RefCount);
	DbgPrint( "lpData     :%x\n",psp->lpData);
	DbgPrint( "dwDataSize :%d\n",psp->dwDataSize);
	DbgPrint( "dwFlags    :%x\n",psp->dwFlags);
	DbgPrint( "dwPriority :%x\n",psp->dwPriority);
	DbgPrint( "dwTimeout  :%d\n",psp->dwTimeout);
	DbgPrint( "hContext   :%x\n",psp->hContext);
	DbgPrint( "nContext   :%d\n",psp->nContext);
	DbgPrint( "nComplete  :%d\n",psp->nComplete);
	DbgPrint( "hr         :%x\n",psp->hr);
	DbgPrint( "dwSendTime :%x\n",psp->dwSendTime);
	DbgPrint( "dwCompTime :%x\n",psp->dwSendCompletionTime);
	DbgPrint( "\nSG Buffers:\n-----------\n");

	for(i=0;i<psp->cBuffers;i++){
		DbgPrint("Addr %x Len %d fnFree %x\n",psp->Buffers[i].pData,psp->Buffers[i].len,psp->BufFree[i].fnFree);
	}
	DbgPrint( "dwTotalSize:%d\n",psp->dwTotalSize);
}

VOID DQProtocolReceive(PUCHAR pArgs)
{
	PRECEIVE pR;

	if (!GetHexArg(&pArgs, &pR))
		return;

#ifdef SIGN
	DbgPrint("Signature       : %08x\n",	    pR->Signature);		// Signature for SIGN
#endif
	DbgPrint("pNext           : %08x\n",	    pR->pNext);
/*	
	union {
		BILINK          pReceiveQ;
		struct _RECEIVE *      pNext;
	};	
	BILINK		    RcvBuffList;     // List of receive buffers that make up the message.
	CRITICAL_SECTION ReceiveLock;
*/

	DbgPrint("pSession          : %08x\n",	    pR->pSession);

        DbgPrint("fBusy             : %08x\n",      pR->fBusy);
	
	DbgPrint("fReliable         : %08x\n",	    pR->fReliable);
	DbgPrint("fEOM              : %08x\n",	    pR->fEOM);
	DbgPrint("command           : %08x\n",	    pR->command);
	DbgPrint("messageid         : %08x\n",	    pR->messageid);
	DbgPrint("MessageSize       : %08x\n\n",	pR->MessageSize);
	DbgPrint("iNR               : %08x\n",	    pR->iNR);
	DbgPrint("NR                : %08x\n",	    pR->NR);
	DbgPrint("NS                : %08x\n",	    pR->NS);
	DbgPrint("RCVMask           : %08x\n",	    pR->RCVMask);
	DbgPrint("pSPHeader         : %08x\n",	    pR->pSPHeader);

	//UCHAR           SPHeader[0];

}


VOID DQProtocolSend(PUCHAR pArgs)
{
	PSEND	pS;

	if (!GetHexArg(&pArgs, &pS))
		return;
		
#ifdef SIGN
	DbgPrint("Signature           : %08x\n", pS->Signature);
#endif
//	CRITICAL_SECTION SendLock;          // Lock for Send Structure
	DbgPrint("RefCount            : %d\n", pS->RefCount);

	DbgPrint("SendState:          %08x\n", pS->SendState);	// State of this message's transmission.

	// Lists and Links...
	
//	union {
//		struct _SEND *pNext;			// linking on free pool
//		BILINK		   SendQ;			// linking on session send queue
//	};
//	BILINK         m_GSendQ;			// Global Priority Queue
	DbgPrint("pSession:     %08x\n",pS->pSession); // pointer to SESSIONion(gets a ref)

	// Send Information
	
	DbgPrint("idFrom:       %08x\n",pS->idFrom);
	DbgPrint("idTo:         %08x\n",pS->idTo);
	DbgPrint("wIdTo:        %08x\n",pS->wIdTo);		// index in table
	DbgPrint("wIdFrom:      %08x\n",pS->wIdFrom);       // index in table
	DbgPrint("dwFlags:      %08x\n",pS->dwFlags);       // Send Flags (include reliable)
	DbgPrint("pMessage:     %08x\n",pS->pMessage);	// Buffer chain describing message.
	DbgPrint("MessageSize:  %08x\n",pS->MessageSize);		// Total size of the message.
	DbgPrint("FrameDataLen: %08x\n",pS->FrameDataLen);       // Data area of each frame.
	DbgPrint("nFrames:      %08x\n",pS->nFrames);	    // Number of frames for this message.

	DbgPrint("Priority:     %08x\n",pS->Priority);       // Send Priority.

	// Vars for reliability
	DbgPrint("fSendSmall:   %08x\n",pS->fSendSmall);
	DbgPrint("fUpdate:      %08x\n",pS->fUpdate);       // update to NS,NR NACKMask made by receive.
	DbgPrint("messageid:    %08x\n",pS->messageid);		// Message ID number.
	DbgPrint("serial:       %08x\n",pS->serial);       // serial number.
	DbgPrint("OpenWindows   %08x\n",pS->OpenWindow);
	DbgPrint("NS:           %08x\n",pS->NS);    	// Sequence Sent.
	DbgPrint("NR:           %08x\n",pS->NR);		// Sequence ACKED.
	DbgPrint("SendSEQMSK:   %08x\n",pS->SendSEQMSK);		// Mask to use. - BUGBUG: determine speed at start
	DbgPrint("NACKMask:     %08x\n",pS->NACKMask);       // Bit pattern of NACKed frames.
	

	// These are the values at NR - updated by ACKs
	DbgPrint("SendOffset:          %08x\n",pS->SendOffset);		// Current offset we are sending.
	DbgPrint("pCurrentBuffer:      %08x\n",pS->pCurrentBuffer);  	// Current buffer being sent.
	DbgPrint("CurrentBufferOffset: %08x\n",pS->CurrentBufferOffset);// Offset in the current buffer of next packet.

	// info to update link characteristics when ACKs come in.
	
	//BILINK         StatList:			// Info for packets already sent.
	
	// Operational Characteristics

//	DbgPrint("PendedRetryTimer:    %08x\n",pS->PendedRetryTimer);
//	DbgPrint("CancelledRetryTimer: %08x\n",pS->CancelledRetryTimer);
	DbgPrint("uRetryTimer:         %08x\n",pS->uRetryTimer);
	DbgPrint("RetryCount:          %08x\n",pS->RetryCount);// Number of times we retransmitted.
	DbgPrint("WindowSize:          %08x\n",pS->WindowSize);// Maximum Window Size.
	DbgPrint("tLastACK:            %08x\n",pS->tLastACK);// Time we last got an ACK.

	//BUGBUG:
	DbgPrint("PacketSize:          %08x\n",pS->PacketSize);// Size of packets to send.
	DbgPrint("FrameSize:           %08x\n",pS->FrameSize);// Size of Frames for this send.

	// Completion Vars
	DbgPrint("hEvent:              %08x\n",pS->hEvent);// Event to wait on for internal send.
	DbgPrint("Status:              %08x\n",pS->Status);// Send Completion Status.

	DbgPrint("pAsyncInfo:          %08x\n",pS->pAsyncInfo);// ptr to Info for completing Async send(NULL=>internal send)
//	DbgPrint("AsyncInfo:           // actual info (copied at send call).
	
} 


VOID DQProtocolSession(PUCHAR pArgs)
{
	PSESSION	pS;

	if (!GetHexArg(&pArgs, &pS))
		return;

	DbgPrint("pProtocol           : %08x\n", pS->pProtocol);

#ifdef SIGN
	DbgPrint("Signature           : %08x\n", pS->Signature);
#endif

	// Identification

//	DbgPrint(" SessionLock;           // Lock for the SESSIONion.
	DbgPrint("RefCount            : %d\n", pS->RefCount);
	DbgPrint("eState              : %d\n", pS->eState);
	DbgPrint("hClosingEvent       : %d\n", pS->hClosingEvent);

	DbgPrint("fSendSmall          : %d\n", pS->fSendSmall);     
	DbgPrint("fSendSmallDG        : %d\n", pS->fSendSmallDG);
	
	DbgPrint("dpid                : %08x\n",pS->dpid);
	DbgPrint("iSession;           : %d\n", pS->iSession);
	
	DbgPrint("MaxPacketSize       : x%08x %d\n",pS->MaxPacketSize,pS->MaxPacketSize);

	DbgPrint("\n Operating Parameters:SEND \n --------- --------------- \n");

	// Operating parameters -- Send

	// Common

	DbgPrint("Common:\n");
	DbgPrint("MaxCSends           : %d\n",pS->MaxCSends);

	DbgPrint("Reliable:\n");
	// Reliable

	DbgPrint("FirstMsg    : %08x\n",pS->FirstMsg);				// First message number being transmitted
	DbgPrint("LastMsg     : %08x\n",pS->LastMsg);				// Last message number being transmitted
	DbgPrint("OutMsgMask  : %08x\n",pS->OutMsgMask);           // relative to FirstMsg, unacked messages

	DbgPrint("nWaitingForMessageid: %08x\n", pS->nWaitingForMessageid);

	// DataGram
	DbgPrint("Datagram:\n");

	DbgPrint("DGFirstMsg    : %08x\n",pS->DGFirstMsg);
	DbgPrint("DGLastMsg     : %08x\n",pS->DGLastMsg);
	DbgPrint("DGOutMsgMask  : %08x\n",pS->DGOutMsgMask);

	DbgPrint("nWaitingForDGMessageid: %08x\n",pS->nWaitingForDGMessageid);

	// Send stats are tracked seperately since sends may
	// no longer be around when completions come in.
	
	//BILINK           OldStatList;		
	

	// Operating parameters -- Receive
	DbgPrint("\n Operating Parameters:RECEIVE \n --------- ------------------ \n");

	// DataGram Receive.
//	BILINK           pDGReceiveQ;            // queue of ongoing datagram receives

	// Reliable Receive.
//	BILINK	         pRlyReceiveQ;			 // queue of ongoing reliable receives
//	BILINK           pRlyWaitingQ;           // Queue of out of order reliable receives waiting.
											 // only used when PROTOCOL_NO_ORDER not set.
	DbgPrint("FirstRlyReceive : %08x\n",pS->FirstRlyReceive);
	DbgPrint("LastRlyReceive  : %08x\n",pS->LastRlyReceive);
	DbgPrint("InMsgMask       : %08x\n",pS->InMsgMask);

	DbgPrint("\n Operating Parameters:STATS \n --------- ---------------- \n");
 

	// Operational characteristics - MUST BE DWORD ALIGNED!!!

	DbgPrint("WindowSize           :%d\n",pS->WindowSize);
	DbgPrint("DGWindowSize         :%d\n",pS->DGWindowSize);

	
	DbgPrint("MaxRetry             :%d\n",pS->MaxRetry);	// Usualy max retries before dropping.
	DbgPrint("MinDropTime          :%d\n",pS->MinDropTime);	// Min time to retry before dropping.
	DbgPrint("MaxDropTime          :%d\n",pS->MaxDropTime);	// After this time always drop.

	DbgPrint("LocalBytesReceived   :%d\n",pS->LocalBytesReceived);    // Total Data Bytes received (including retries).
	DbgPrint("RemoteBytesReceived  :%d\n",pS->RemoteBytesReceived);   // Last value from remote.

	DbgPrint("LongestLatency       :%d\n",pS->LongestLatency);		// longest observed latency (msec)
	DbgPrint("ShortestLatency      :%d\n",pS->ShortestLatency);		// shortest observed latency(msec)
	
	DbgPrint("FpAverageLatency     :%d\n",pS->FpAverageLatency/256);
	DbgPrint("FpLocalAverageLatency:%d\n",pS->FpLocalAverageLatency/256);	// Local average latency    (msec 24.8) (across fewer samples)
	
	DbgPrint("FpLocalAvgDeviation  :%d\n",pS->FpLocalAvgDeviation/256);   // average deviation of latency. (msec 24.8)

	DbgPrint("Bandwidth            :%d\n",pS->Bandwidth);				// latest observed bandwidth (bps)
	DbgPrint("HighestBandwidth     :%d\n",pS->HighestBandwidth);    // highest observed bandwidth (bps)

}


void PrintWideString(LPWSTR lpwStr, LONG lFieldWidth)
{
	if (lpwStr)
	{
		while (*lpwStr)
		{
			DbgPrint("%c", *lpwStr);
			lpwStr++;
			lFieldWidth--;
		}
	}
	while (lFieldWidth > 0)
	{
		DbgPrint(" ");
		lFieldWidth--;
	}
}

void PrintNameString(LPWSTR lpwStr)
{
	if (lpwStr)
	{
		DbgPrint(" \"");
		PrintWideString(lpwStr, 0);
		DbgPrint("\"\n");
	}
	else
		DbgPrint("\n");
}

// this is from the winsock file dpsp.h
typedef struct _SPPLAYERDATA 
{
	SOCKADDR saddrStream,saddrDatagram;
}SPPLAYERDATA,*LPSPPLAYERDATA;

void PrintSocketInfo(SOCKADDR *lpSockAddr)
{
	switch (lpSockAddr->sa_family)
	{
	case AF_INET:
		DbgPrint("port = %d, ip = %d.%d.%d.%d",
			*((u_short *)&lpSockAddr->sa_data[0]),
			(BYTE) lpSockAddr->sa_data[2],
			(BYTE) lpSockAddr->sa_data[3],
			(BYTE) lpSockAddr->sa_data[4],
			(BYTE) lpSockAddr->sa_data[5]);
		break;

	case AF_IPX:
		DbgPrint("IPX");
		break;

	default:
		DbgPrint("Unknown");
		break;
	}
}

void PrintAddress(LPVOID lpData, DWORD dwDataSize)
{
	if ((lpData) && (dwDataSize == sizeof(SPPLAYERDATA)))
	{
		LPSPPLAYERDATA	this = (LPSPPLAYERDATA) lpData;

		DbgPrint("                         (Stream  : ");
		PrintSocketInfo(&this->saddrStream);
		DbgPrint("\n                          Datagram: ");
		PrintSocketInfo(&this->saddrDatagram);
		DbgPrint(")\n");
	}
}

VOID DQPlayer(PUCHAR pArgs)
{
	DPLAYI_PLAYER	*this;

	if (!GetHexArg(&pArgs, &this))
		return;

	DbgPrint("\nPlayer\n\n");
	DbgPrint("dwSize                  : %d\n", this->dwSize);
	DbgPrint("dwFlags                 : %08x\n", this->dwFlags);
	PrintPlayerFlags(this->dwFlags);
	DbgPrint("dwID                    : %08x\n", this->dwID);
	DbgPrint("lpszShortName           : %08x", this->lpszShortName);
	PrintNameString(this->lpszShortName);
	DbgPrint("lpszLongName            : %08x", this->lpszLongName);
	PrintNameString(this->lpszLongName);
	DbgPrint("pvPlayerData            : %08x\n", this->pvPlayerData);
	DbgPrint("dwPlayerDataSize        : %d\n", this->dwPlayerDataSize);
	DbgPrint("pvPlayerLocalData       : %08x\n", this->pvPlayerLocalData);
	DbgPrint("dwPlayerLocalDataSize   : %d\n", this->dwPlayerLocalDataSize);
	DbgPrint("pvSPData                : %08x\n", this->pvSPData);
	PrintAddress(this->pvSPData, this->dwSPDataSize);
	DbgPrint("dwSPDataSize            : %d\n", this->dwSPDataSize);
	DbgPrint("pvSPLocalData           : %08x\n", this->pvSPLocalData);
	DbgPrint("dwSPLocalDataSize       : %d\n", this->dwSPLocalDataSize);
	DbgPrint("dwIDSysPlayer           : %08x\n", this->dwIDSysPlayer);
	DbgPrint("dwVersion               : %08x\n", this->dwVersion);
	DbgPrint("lpDP                    : %08x\n", this->lpDP);
	DbgPrint("nGroups                 : %d\n", this->nGroups);
	DbgPrint("dwIDParent              : %08x\n", this->dwIDParent);
	DbgPrint("pNextPlayer:            : %08x\n", this->pNextPlayer);
	DbgPrint("hEvent                  : %08x\n", this->hEvent);
	DbgPrint("dwNPings                : %d\n", this->dwNPings);
	DbgPrint("nPendingSends           : %d\n", this->nPendingSends);
	DbgPrint("dwChatterCount          : %d\n", this->dwChatterCount);
	DbgPrint("dwUnansweredPings       : %d\n", this->dwUnansweredPings);
	DbgPrint("dwProtLastSendBytes     : %d\n", this->dwProtLastSendBytes);
	DbgPrint("dwProtLastRcvdBytes     : %d\n", this->dwProtLastRcvdBytes);
	DbgPrint("dwTimeToDie		      : %d\n", this->dwTimeToDie);
	DbgPrint("pClientInfo             : %08x\n", this->pClientInfo);
	DbgPrint("pOwnerGroupList         : %08x\n", this->pOwnerGroupList);
}

VOID DQPlayerList(PUCHAR pArgs)
{
	DPLAYI_PLAYER	*this;

	if (!GetHexArg(&pArgs, &this))
		return;

	DbgPrint("\nPlayer List\n\n");
	DbgPrint(" pPlayer  dwFlags   dwID  dwVersion short name      long name       address\n");
//            00000000 00000000 00000000 00000000 123456789012345 123456789012345

	while (this)
	{
		DbgPrint("%08x %08x %08x %08x ",
			this, this->dwFlags, this->dwID, this->dwVersion);
		
		PrintWideString(this->lpszShortName, 16);
		PrintWideString(this->lpszLongName, 16);

		if ((this->pvSPData) && (this->dwSPDataSize == sizeof(SPPLAYERDATA)))
		{
			LPSPPLAYERDATA	lpSocketAddr = (LPSPPLAYERDATA) this->pvSPData;

			PrintSocketInfo(&lpSocketAddr->saddrStream);
		}

		DbgPrint("\n");

		this = this->pNextPlayer;
	}
}

VOID DQGroup(PUCHAR pArgs)
{
	DPLAYI_GROUP	*this;

	if (!GetHexArg(&pArgs, &this))
		return;

	DbgPrint("\nGroup\n\n");
	DbgPrint("dwSize                  : %d\n", this->dwSize);
	DbgPrint("dwFlags                 : %08x\n", this->dwFlags);
	PrintPlayerFlags(this->dwFlags);
	DbgPrint("dwID                    : %08x\n", this->dwID);
	DbgPrint("lpszShortName           : %08x", this->lpszShortName);
	PrintNameString(this->lpszShortName);
	DbgPrint("lpszLongName            : %08x", this->lpszLongName);
	PrintNameString(this->lpszLongName);
	DbgPrint("pvPlayerData            : %08x\n", this->pvPlayerData);
	DbgPrint("dwPlayerDataSize        : %d\n", this->dwPlayerDataSize);
	DbgPrint("pvPlayerLocalData       : %08x\n", this->pvPlayerLocalData);
	DbgPrint("dwPlayerLocalDataSize   : %d\n", this->dwPlayerLocalDataSize);
	DbgPrint("pvSPData                : %08x\n", this->pvSPData);
	PrintAddress(this->pvSPData, this->dwSPDataSize);
	DbgPrint("dwSPDataSize            : %d\n", this->dwSPDataSize);
	DbgPrint("pvSPLocalData           : %08x\n", this->pvSPLocalData);
	DbgPrint("dwSPLocalDataSize       : %d\n", this->dwSPLocalDataSize);
	DbgPrint("dwIDSysPlayer           : %08x\n", this->dwIDSysPlayer);
	DbgPrint("dwVersion               : %08x\n", this->dwVersion);
	DbgPrint("lpDP                    : %08x\n", this->lpDP);
	DbgPrint("nGroups                 : %d\n", this->nGroups);
	DbgPrint("dwIDParent              : %08x\n", this->dwIDParent);
	DbgPrint("pGroupnodes:            : %08x\n", this->pGroupnodes);
	DbgPrint("pSysPlayerGroupnodes    : %08x\n", this->pSysPlayerGroupnodes);
	DbgPrint("pNextGroup              : %08x\n", this->pNextGroup);
	DbgPrint("nPlayers                : %d\n", this->nPlayers);
	DbgPrint("pSubgroups              : %08x\n", this->pSubgroups);
	DbgPrint("nSubgroups              : %d\n", this->nSubgroups);
	DbgPrint("dwOwnerID               : %08x\n", this->dwOwnerID);
}

VOID DQGroupList(PUCHAR pArgs)
{
	DPLAYI_GROUP	*this;

	if (!GetHexArg(&pArgs, &this))
		return;

	DbgPrint("\nGroup List\n\n");
	DbgPrint("  pGroup  dwFlags   dwID  dwVersion nPlr nGrp nSubGrp short name      long name\n");
//            00000000 00000000 00000000 00000000    4    4       4 123456789012345

	while (this)
	{
		DbgPrint("%08x %08x %08x %08x %4d %4d %7d ",
			this, this->dwFlags, this->dwID, this->dwVersion,
			this->nPlayers, this->nGroups, this->nSubgroups);

		PrintWideString(this->lpszShortName, 16);
		PrintWideString(this->lpszLongName, 16);
		DbgPrint("\n");

		this = this->pNextGroup;
	}
}

VOID PrintSessionDescFlags(DWORD dwFlags)
{
	DWORD	dwMask, dwField, dwBitCount;

	dwBitCount = 0;
	dwMask = 1;
	while (dwMask)
	{
		dwField = dwFlags & dwMask;
		if (dwField)
		{
			if (dwBitCount == 0)
				DbgPrint("                         (");
			else
				DbgPrint(" |\n                          ");

			switch (dwField)
			{
			case DPSESSION_NEWPLAYERSDISABLED:
				DbgPrint("DPSESSION_NEWPLAYERSDISABLED");
				break;

			case DPSESSION_MIGRATEHOST:
				DbgPrint("DPSESSION_MIGRATEHOST");
				break;

			case DPSESSION_NOMESSAGEID:
				DbgPrint("DPSESSION_NOMESSAGEID");
				break;

			case DPSESSION_NOPLAYERMGMT:
				DbgPrint("DPSESSION_NOPLAYERMGMT");
				break;

			case DPSESSION_JOINDISABLED:
				DbgPrint("DPSESSION_JOINDISABLED");
				break;

			case DPSESSION_KEEPALIVE:
				DbgPrint("DPSESSION_KEEPALIVE");
				break;

			case DPSESSION_NODATAMESSAGES:
				DbgPrint("DPSESSION_NODATAMESSAGES");
				break;

			case DPSESSION_SECURESERVER:
				DbgPrint("DPSESSION_SECURESERVER");
				break;

			case DPSESSION_PRIVATE:
				DbgPrint("DPSESSION_PRIVATE");
				break;

			case DPSESSION_PASSWORDREQUIRED:
				DbgPrint("DPSESSION_PASSWORDREQUIRED");
				break;


			case DPSESSION_MULTICASTSERVER:
				DbgPrint("DPSESSION_MULTICASTSERVER");
				break;


			case DPSESSION_CLIENTSERVER:
				DbgPrint("DPSESSION_CLIENTSERVER");
				break;

			default:
				DbgPrint("unknown: %08x", dwField);
				break;
			}

			dwBitCount++;
		}
		dwMask <<= 1;
	}

	if (dwBitCount)
		DbgPrint(")\n");
}

VOID DQSessionDesc(PUCHAR pArgs)
{
	DPSESSIONDESC2	*this;

	if (!GetHexArg(&pArgs, &this))
		return;

	DbgPrint("\nSession Desc\n\n");
	DbgPrint("dwSize                  : %d\n", this->dwSize);
	DbgPrint("dwFlags                 : %08x\n", this->dwFlags);
	PrintSessionDescFlags(this->dwFlags);
	DbgPrint("guidInstance            : %08x %08x %08x %08x\n",
		*((LPDWORD)(&this->guidInstance) + 0),
		*((LPDWORD)(&this->guidInstance) + 1),
		*((LPDWORD)(&this->guidInstance) + 2),
		*((LPDWORD)(&this->guidInstance) + 3));
	DbgPrint("guidApplication         : %08x %08x %08x %08x\n",
		*((LPDWORD)(&this->guidApplication) + 0),
		*((LPDWORD)(&this->guidApplication) + 1),
		*((LPDWORD)(&this->guidApplication) + 2),
		*((LPDWORD)(&this->guidApplication) + 3));
	DbgPrint("dwMaxPlayers            : %d\n", this->dwMaxPlayers);
	DbgPrint("dwCurrentPlayers        : %d\n", this->dwCurrentPlayers);
	DbgPrint("lpszSessionName         : %08x", this->lpszSessionName);
	PrintNameString(this->lpszSessionName);
	DbgPrint("lpszPassword            : %08x", this->lpszPassword);
	PrintNameString(this->lpszPassword);
	DbgPrint("dwReserved1             : %08x\n", this->dwReserved1);
	DbgPrint("dwReserved2             : %08x\n", this->dwReserved2);
	DbgPrint("dwUser1                 : %08x\n", this->dwUser1);
	DbgPrint("dwUser2                 : %08x\n", this->dwUser2);
	DbgPrint("dwUser3                 : %08x\n", this->dwUser3);
	DbgPrint("dwUser4                 : %08x\n", this->dwUser4);
}

/*
    DQInfo - handles dot-commands of the form:

        .NWSERVER INFO

*/
VOID DQInfo(PUCHAR pArgs)
{
	DbgPrint("Hello World!\n");
}


UINT RequestTraceLevel = 0;

VOID DQTraceRequestsOn(PUCHAR pArgs)
{
    RequestTraceLevel = 1;
}

VOID DQTraceRequestsOff(PUCHAR pArgs)
{
    RequestTraceLevel = 0;
}

VOID DQTraceRequestsBreak(PUCHAR pArgs)
{
    RequestTraceLevel = 2;
}


typedef VOID (*pQDHandler)(PUCHAR pCmd);

typedef struct {
    PUCHAR  pName;      // Command name (unique part uppercase, optional lowercase)
    pQDHandler pHandler;
} QD, *pQD;

QD QueryDispatch[] = {
	{ "L"            , DQLog                   },
	{ "LL"           , DQLogLast               },
	{ "LV"           , DQLogLevel              },
	{ "LE"			 , DQLogExact              },
    { "Info"         , DQInfo                  },
    { "t"			 , DQThis                  },
    { "p"			 , DQPlayer                },
    { "pl"			 , DQPlayerList            },
    { "pr"           , DQProtocolReceive       },
    { "ps"           , DQProtocolSession       },
    { "psp"          , DQSendParms             },
    { "pool"         , DQFixedMemPool          },
    { "g"			 , DQGroup                 },
    { "gl"			 , DQGroupList             },
    { "ss"           , DQProtocolSend          },
    { "sd"			 , DQSessionDesc           },
    { "cl"           , DQContextList           },
    { "cp"           , DQContextPool           },
    { ""             , 0   }
};

QD TraceDispatch[] = {
    { ""            , 0   }
};

QD TraceRequestDispatch[] = {
    { "ON"    , DQTraceRequestsOn       },
    { "OFf"   , DQTraceRequestsOff      },
    { "Break" , DQTraceRequestsBreak    },
    { ""            , 0   }
};

UINT QDMatch(PUCHAR pU, PUCHAR pT)
{
    while (*pU == *pT) {
        if (*pU == 0)
            return 1;
        pU++;
        pT++;
    }

    if (*pT < 'a')
        return 0;

    while (*pT != 0 && *pU == (*pT - ('a' - 'A'))) {
        pU++;
        pT++;
    }

    if (*pU != 0)
        return 0;

    return 1;
}

pQD LookUpQD(PUCHAR pCmd, pQD pTable)
{
    UINT i;

    if (!pCmd)
        return NULL;

    for (i = 0; pTable[i].pHandler != NULL; i++) {
        if (QDMatch(pCmd, pTable[i].pName))
            return &(pTable[i]);
    }
    return NULL;
}

#define MAX_DEBUG_QUERY_COMMAND_LENGTH 100

UCHAR DebugQueryCmdStr[MAX_DEBUG_QUERY_COMMAND_LENGTH+1] = "";
UINT DebugQueryCmdStrLen = MAX_DEBUG_QUERY_COMMAND_LENGTH;

void DQparse ( PUCHAR pCmd, pQD pqt )
{

    UCHAR c;
    PUCHAR pCmdName;
    pQD pq;

    pCmdName = GetArg(&pCmd);

    if ( (pq = LookUpQD(pCmdName, pqt)) ) {
        (*pq->pHandler)(pCmd);
    } else {
        DbgPrint("====== DPLAY Debugging VXD (DPLAY.VXD) ======\n\n");
        DbgPrint("    t  <addr>                               - dump this pointer\n");
        DbgPrint("    p  <addr>                               - dump player\n");
        DbgPrint("    pl <addr>                               - dump player list\n");
        DbgPrint("    g  <addr>                               - dump group\n");
        DbgPrint("    gl <addr>                               - dump group list\n");
        DbgPrint("    sd <addr>                               - dump session desc\n");
        DbgPrint("    psp <addr>                              - dump SENDPARMS\n");
        DbgPrint("    cl  <addr-this>                         - dump context list off of this\n");
        DbgPrint("    cp  <addr-this>                         - dump context pool off of this\n");
        DbgPrint("    L  <record>                             - dump log starting at record#\n");
        DbgPrint("    LL <numrecords>                         - dump the last numrecords\n");
        DbgPrint("    LV <level>                              - set log debug level (<=)\n");
        DbgPrint("    LE <level>                              - set log debug level (equal only)\n");
        DbgPrint("    ps <addr>                               - dump protocol session\n");
        DbgPrint("    ss <addr>                               - dump protocol send\n");
        DbgPrint("    pr <addr>                               - dump protocol receive\n");
        DbgPrint("\n");
    }
}

VOID DQTrace(PUCHAR pArgs)
{
    DQparse(pArgs, TraceDispatch);
}

VOID DQTraceRequests(PUCHAR pArgs)
{
    DQparse(pArgs, TraceRequestDispatch);
}

void Debug_Query ( PUCHAR pCmd )
{
    DQparse(pCmd, QueryDispatch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\vxd\w32ioctl.c ===
//***************************************************************************
//
//
//
//***************************************************************************

// Macros:

#define CreateSemaphore()       (VMM_Create_Semaphore(0))
#define DestroySemaphore(_s)    (VMM_Destroy_Semaphore(_s))

#define signal(_s)              (VMM_Signal_Semaphore(_s))
#define wait(_s)                (VMM_Wait_Semaphore_Ints(_s))
#define wait_idle(_s)           (VMM_Wait_Semaphore_Idle(_s))

#define CreateResourceLock()    (VMM_Create_Semaphore(1))
#define DestroyResourceLock(_s) (VMM_Destroy_Semaphore(_s))
#define lock(_s)                (VMM_Wait_Semaphore_Ints(_s))
#define unlock(_s)              (VMM_Signal_Semaphore(_s))

#define WANTVXDWRAPS

#include <basedef.h>
#include <vmm.h>
#include <vcomm.h>
#include <debug.h>
#include <vxdwraps.h>
#include <configmg.h>  
#include <vwin32.h>
#include <winerror.h>

typedef DIOCPARAMETERS *LPDIOC;

#pragma VxD_LOCKED_CODE_SEG
#pragma VxD_LOCKED_DATA_SEG

#define ASSERT(_A) if(!(_A)){_asm int 3}

DWORD _stdcall LogInit(DWORD dwDDB, DWORD hDevice, LPDIOC lpDIOCParams);
DWORD _stdcall LogWrite(DWORD dwDDB, DWORD hDevice, LPDIOC lpDIOCParams);
DWORD _stdcall StatsWrite(DWORD dwDDB, DWORD hDevice, LPDIOC lpDIOCParams);

#define FIRST_DEBUG_PROC 100

DWORD ( _stdcall *DebugProcs[] )(DWORD, DWORD, LPDIOC) = {
	LogInit,
	LogWrite,
	StatsWrite
};

#define MAX_DEBUG_PROC (sizeof(DebugProcs)/sizeof(DWORD)+FIRST_DEBUG_PROC-1)

typedef struct _LOGENTRY {
	DWORD   ThreadHandle;
	DWORD   tLogged;
	CHAR	debuglevel;
	CHAR    str[1];
} LOGENTRY, *PLOGENTRY;

PUCHAR pLog=NULL;
UINT   nCharsPerLine;
UINT   nLogEntries;

UINT   iLogWritePos;
UINT   nLogEntriesInUse;

UINT   LogInitCount=0;

UINT   LogLevel=255;
UINT   LogExact=FALSE;

UINT   LogLock=0;

#define Entry(_i) ((PLOGENTRY)(pLog+((sizeof(LOGENTRY)+nCharsPerLine)*_i)))

typedef struct {
	UINT	nLogEntries;
	UINT    nCharsPerLine;
} IN_LOGINIT, *PIN_LOGINIT;

typedef struct {
	UINT    hr;
} OUT_LOGINIT, *POUT_LOGINIT;

typedef struct {
	CHAR	debuglevel;
	CHAR    str[1];
} IN_LOGWRITE, *PIN_LOGWRITE;

typedef struct {
	UINT	hr;
} OUT_LOGWRITE, *POUT_LOGWRITE;

extern	UINT stat_ThrottleRate;
extern	UINT stat_BytesSent;
extern	UINT stat_BackLog;
extern	UINT stat_BytesLost;
extern	UINT stat_RemBytesReceived;
extern	UINT stat_Latency; 
extern	UINT stat_MinLatency;
extern	UINT stat_AvgLatency;
extern  UINT stat_AvgDevLatency;
extern	UINT stat_USER1;
extern	UINT stat_USER2;
extern	UINT stat_USER3;
extern  UINT stat_USER4;
extern  UINT stat_USER5;
extern  UINT stat_USER6;

typedef struct {
	UINT stat_ThrottleRate;
	UINT stat_BytesSent;
	UINT stat_BackLog;
 	UINT stat_BytesLost;
 	UINT stat_RemBytesReceived;
	UINT stat_Latency; 
	UINT stat_MinLatency;
	UINT stat_AvgLatency;
	UINT stat_AvgDevLatency;
	UINT stat_USER1;
	UINT stat_USER2;
	UINT stat_USER3;
	UINT stat_USER4;
	UINT stat_USER5;	// remote clock delta change from average
	UINT stat_USER6;    // sign of change
} IN_WRITESTATS, *PIN_WRITESTATS;

typedef struct {
	UINT	hr;
} OUT_WRITESTATS, *POUT_WRITESTATS;

VOID _stdcall ZeroStats();

/****************************************************************************
                  DPLAY_W32_DeviceIOControl
****************************************************************************/
DWORD _stdcall DPLAY_W32_DeviceIOControl(DWORD  dwService,
                                         DWORD  dwDDB,
                                         DWORD  hDevice,
                                         LPDIOC lpDIOCParms)
{
    DWORD dwRetVal = 0;

    if ( dwService == DIOC_OPEN )
    {
      dwRetVal = 0;	// I/F supported!
    }
    else if ( dwService == DIOC_CLOSEHANDLE )
    {
      if(LogInitCount)
      {
      	if(!(--LogInitCount)){
      		DestroyResourceLock(LogLock);
      		LogLock=0;
	      	C_HeapFree(pLog);
	      	pLog=NULL;
	      	ZeroStats();
	    }  	
      }	
      dwRetVal = VXD_SUCCESS;	// ok, we're closed.
    }
    else if ((dwService >= FIRST_DEBUG_PROC) && (dwService <= MAX_DEBUG_PROC))
    {
      dwRetVal = (DebugProcs[dwService-FIRST_DEBUG_PROC])
                 (dwDDB, hDevice, lpDIOCParms);
    }
    else
    {
      dwRetVal = ERROR_NOT_SUPPORTED;
    }
    return(dwRetVal);
}

DWORD _stdcall LogInit(DWORD dwDDB, DWORD hDevice, LPDIOC lpDIOCParams)
{
	PIN_LOGINIT  pIn;
	POUT_LOGINIT pOut;
	UINT hr=0;

	pIn=(PIN_LOGINIT)lpDIOCParams->lpvInBuffer;
	pOut=(POUT_LOGINIT)lpDIOCParams->lpvOutBuffer;

	ASSERT(lpDIOCParams->cbInBuffer>=sizeof(IN_LOGINIT));
	ASSERT(lpDIOCParams->cbOutBuffer>=sizeof(OUT_LOGINIT));

	if(!LogInitCount){

		if(!pLog){
		
			LogLock=CreateResourceLock();
			nCharsPerLine	 = pIn->nCharsPerLine;
			nLogEntries   	 = pIn->nLogEntries;
			iLogWritePos 	 = 0;
			nLogEntriesInUse = 0;

			pLog=(CHAR *)C_HeapAllocate(pIn->nLogEntries*(sizeof(LOGENTRY)+pIn->nCharsPerLine),HEAPZEROINIT);
		}

		if(!pLog){
			pOut->hr=ERROR_NOT_ENOUGH_MEMORY;
		} else	{
			DbgPrint("DPLAYVXD: Logging on, allocated %d entries of length %d each\n",pIn->nLogEntries,pIn->nCharsPerLine);
			pOut->hr=ERROR_SUCCESS;
			LogInitCount=1;
		}	
		lpDIOCParams->lpcbBytesReturned=sizeof(OUT_LOGINIT);

	} else {
		pOut->hr=ERROR_SUCCESS;
		LogInitCount++;
	}
    return NO_ERROR;
}

DWORD _stdcall LogWrite(DWORD dwDDB, DWORD hDevice, LPDIOC lpDIOCParams)
{
	PIN_LOGWRITE pIn;
	POUT_LOGWRITE pOut;
	
	pIn=(PIN_LOGWRITE)lpDIOCParams->lpvInBuffer;
	pOut=(POUT_LOGWRITE)lpDIOCParams->lpvOutBuffer;

	ASSERT(lpDIOCParams->cbInBuffer>=sizeof(IN_LOGWRITE));
	ASSERT(lpDIOCParams->cbOutBuffer>=sizeof(OUT_LOGWRITE));

	if(LogInitCount){
		UINT BytesToCopy;
		PLOGENTRY pLogEntry;
		
		// make sure NULL terminated string
		BytesToCopy=lpDIOCParams->cbInBuffer-sizeof(IN_LOGWRITE)+1;
		if(BytesToCopy > nCharsPerLine){
			BytesToCopy=nCharsPerLine;
		}
		pIn->str[BytesToCopy-1]=0;

		lock(LogLock);
		
		pLogEntry=Entry(iLogWritePos);
		
		if(iLogWritePos+1 > nLogEntriesInUse){
			nLogEntriesInUse+=1;
		}
		iLogWritePos=(iLogWritePos+1)%nLogEntries;
		
		pLogEntry->ThreadHandle=GetThreadHandle();
		pLogEntry->tLogged=VMM_Get_System_Time();
		memcpy(&pLogEntry->debuglevel,pIn,BytesToCopy+sizeof(IN_LOGWRITE)-1);

		unlock(LogLock);
		
		pOut->hr=ERROR_SUCCESS;
	} else {
		pOut->hr=0x80000008;//E_FAIL
	}
	
	return NO_ERROR;
}

VOID SetLogLevel(UINT level, UINT fExact)
{
	LogExact=fExact;
	LogLevel=level;
	if(LogExact)
	{
		DbgPrint("DPLAY VXD: Log printing is Exact at level %d\n",LogLevel);
	} else {	
		DbgPrint("DPLAY VXD: Log printing is level %d and below\n",LogLevel);
	}	
}

DumpLogEntry(PLOGENTRY pLogEntry, UINT i, BOOL fResetTimeBase)
{
	static UINT timebase=0;
	if(pLogEntry){
		DbgPrint("%4d: %8x %6d %2x %s\n",i,pLogEntry->ThreadHandle, pLogEntry->tLogged-timebase,pLogEntry->debuglevel, pLogEntry->str);
		timebase=pLogEntry->tLogged;
	}	
	if(fResetTimeBase){
		timebase=0;
	}
}

VOID DumpLog(UINT relstart)
{
	UINT nToDump=50;
	UINT c=0,i;
	PLOGENTRY pLogEntry;
	UINT start;

	start=relstart;
	
	if(nLogEntriesInUse==nLogEntries){
		start=(iLogWritePos+start)%nLogEntries;
	}

	DumpLogEntry(NULL, 0, TRUE);

	DbgPrint("Total Entries: %d, Current Position %d, dumping from record %d, %d ahead of start\n",nLogEntriesInUse,iLogWritePos,start,relstart);

	for(i=start;i<nLogEntries && c<nToDump;i++){
		pLogEntry=Entry(i);
		if((LogExact)?(pLogEntry->debuglevel==LogLevel):(pLogEntry->debuglevel<=LogLevel)){
			c++;
			DumpLogEntry(pLogEntry,i,FALSE);
		}	
	}
	// Dump from beginning to current pos.
	for(i=0;i<iLogWritePos && c<nToDump;i++,c++){
		if((LogExact)?(pLogEntry->debuglevel==LogLevel):(pLogEntry->debuglevel<=LogLevel)){
			c++;
			DumpLogEntry(pLogEntry,i,FALSE);
		}	
	}
	
}

VOID DumpLogLast(UINT nToDump)
{
	UINT c=0,i;
	PLOGENTRY pLogEntry;
	UINT start;

	//BUGBUG: only works when all debug levels being dumped.
	if(iLogWritePos > nToDump){
		start=(iLogWritePos-nToDump);
	}else{
		start=(nLogEntries-(nToDump-iLogWritePos));
	}	

	DumpLogEntry(NULL,0,TRUE);
	
	DbgPrint("Total Entries: %d, Current Position %d, dumping from record %d\n",nLogEntriesInUse,iLogWritePos,start);

	for(i=start;i<nLogEntries && c<nToDump;i++){
		pLogEntry=Entry(i);
		if((LogExact)?(pLogEntry->debuglevel==LogLevel):(pLogEntry->debuglevel<=LogLevel)){
			c++;
			DumpLogEntry(pLogEntry,i,FALSE);
		}	
	}
	// Dump from beginning to current pos.
	for(i=0;i<iLogWritePos && c<nToDump;i++,c++){
		pLogEntry=Entry(i);
		if((LogExact)?(pLogEntry->debuglevel==LogLevel):(pLogEntry->debuglevel<=LogLevel)){
			c++;
			DumpLogEntry(pLogEntry,i,FALSE);
		}	
	}
	
}

VOID DumpWholeLog(VOID)
{
	UINT i;
	PLOGENTRY pLogEntry;

	DumpLogEntry(NULL,0,TRUE);

	// Dump from 1 after current pos to end.
	if(nLogEntriesInUse==nLogEntries){
		for(i=iLogWritePos;i<nLogEntries;i++){
			pLogEntry=Entry(i);
			if((LogExact)?(pLogEntry->debuglevel==LogLevel):(pLogEntry->debuglevel<=LogLevel)){
				DumpLogEntry(pLogEntry,i,FALSE);
			}	
		}
	}
	// Dump from beginning to current pos.
	for(i=0;i<iLogWritePos;i++){
			pLogEntry=Entry(i);
			if((LogExact)?(pLogEntry->debuglevel==LogLevel):(pLogEntry->debuglevel<=LogLevel)){
				DumpLogEntry(pLogEntry,i,FALSE);
			}	
	}
}

DWORD _stdcall StatsWrite(DWORD dwDDB, DWORD hDevice, LPDIOC lpDIOCParams)
{
	PIN_WRITESTATS  pIn;
	POUT_WRITESTATS pOut;
	UINT hr=0;
	DWORD cbInBuffer;
	
	pIn=(PIN_WRITESTATS)lpDIOCParams->lpvInBuffer;
	pOut=(POUT_WRITESTATS)lpDIOCParams->lpvOutBuffer;

	ASSERT(lpDIOCParams->cbInBuffer>=sizeof(DWORD));
	ASSERT(lpDIOCParams->cbOutBuffer>=sizeof(OUT_WRITESTATS));

	cbInBuffer=lpDIOCParams->cbInBuffer;
	
	if(pIn->stat_ThrottleRate!=0xFFFFFFFF)stat_ThrottleRate=pIn->stat_ThrottleRate;
	cbInBuffer-=sizeof(DWORD);if(!cbInBuffer)goto end;
	if(pIn->stat_BytesSent!=0xFFFFFFFF)stat_BytesSent=pIn->stat_BytesSent;
	cbInBuffer-=sizeof(DWORD);if(!cbInBuffer)goto end;
	if(pIn->stat_BackLog!=0xFFFFFFFF)stat_BackLog=pIn->stat_BackLog;
	cbInBuffer-=sizeof(DWORD);if(!cbInBuffer)goto end;
 	if(pIn->stat_BytesLost!=0xFFFFFFFF)stat_BytesLost=pIn->stat_BytesLost;
	cbInBuffer-=sizeof(DWORD);if(!cbInBuffer)goto end;
 	if(pIn->stat_RemBytesReceived!=0xFFFFFFFF)stat_RemBytesReceived=pIn->stat_RemBytesReceived;
	cbInBuffer-=sizeof(DWORD);if(!cbInBuffer)goto end;
	if(pIn->stat_Latency!=0xFFFFFFFF)stat_Latency=pIn->stat_Latency;
	cbInBuffer-=sizeof(DWORD);if(!cbInBuffer)goto end;
	if(pIn->stat_MinLatency!=0xFFFFFFFF)stat_MinLatency=pIn->stat_MinLatency;
	cbInBuffer-=sizeof(DWORD);if(!cbInBuffer)goto end;
	if(pIn->stat_AvgLatency!=0xFFFFFFFF)stat_AvgLatency=pIn->stat_AvgLatency;
	cbInBuffer-=sizeof(DWORD);if(!cbInBuffer)goto end;
	if(pIn->stat_AvgDevLatency!=0xFFFFFFFF)stat_AvgDevLatency=pIn->stat_AvgDevLatency;
	cbInBuffer-=sizeof(DWORD);if(!cbInBuffer)goto end;
	if(pIn->stat_USER1!=0xFFFFFFFF)stat_USER1=pIn->stat_USER1;
	cbInBuffer-=sizeof(DWORD);if(!cbInBuffer)goto end;
	if(pIn->stat_USER2!=0xFFFFFFFF)stat_USER2=pIn->stat_USER2;
	cbInBuffer-=sizeof(DWORD);if(!cbInBuffer)goto end;
	if(pIn->stat_USER3!=0xFFFFFFFF)stat_USER3=pIn->stat_USER3;
	cbInBuffer-=sizeof(DWORD);if(!cbInBuffer)goto end;
	if(pIn->stat_USER4!=0xFFFFFFFF)stat_USER4=pIn->stat_USER4;
	cbInBuffer-=sizeof(DWORD);if(!cbInBuffer)goto end;
	if(pIn->stat_USER5!=0xFFFFFFFF)stat_USER5=pIn->stat_USER5;
	cbInBuffer-=sizeof(DWORD);if(!cbInBuffer)goto end;
	if(pIn->stat_USER6!=0xFFFFFFFF)stat_USER6=pIn->stat_USER6;
end:
	pOut->hr=ERROR_SUCCESS;
	return NO_ERROR;	
}

VOID _stdcall ZeroStats()
{
	stat_ThrottleRate=0;
	stat_BytesSent=0;
	stat_BackLog=0;
 	stat_BytesLost=0;
 	stat_RemBytesReceived=0;
	stat_Latency=0; 
	stat_MinLatency=0;
	stat_AvgLatency=0;
	stat_AvgDevLatency=0;
	stat_USER1=0;
	stat_USER2=0;
	stat_USER3=0;
	stat_USER4=0;
	stat_USER5=0;
	stat_USER6=0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\wsock\bilink.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    BILINK.C

Abstract:

    Management for doubly linked lists

Author:

    George Joy

Environment:

    32-bit 'C'

Revision History:

--*/
#include <windows.h>
#include "dpsp.h"
#include <dpf.h>
#include "bilink.h"

// Note: serialization of access to BILINK structures must 
//       take place in the calling code.  Operations are
//       not intrinsically atomic.

#ifdef DEBUG
int FindObject(
    BILINK *link,
    BILINK *list
    )
{
    BILINK *p = list->next;
    while(p != link && p != list)
        p= p->next;
    return (p==link);
}
#endif

void InsertAfter(
    BILINK *in,
    BILINK *after
    )
/*=========================================================================
 *  Description:
 *      Insert an object after a specified object in the doubly linked list.
 *      The after object could be the Head BILINK for adding to the head of a
 *      queue.
 *  Returns:
 *
 */
{
    #ifdef DEBUG
    if(FindObject(in,after)) {
        DPF(0,"Attempt to re-insert object in BILINK queue\n");
        DEBUG_BREAK();
    }
    #endif
    in->next = after->next;
    in->prev = after;
    after->next->prev = in;
    after->next = in;
}

void InsertBefore(
     BILINK *in,
     BILINK *before
    )
/*=========================================================================
 *  Description:
 * Inserts an  object before a specified object in the doubly linked list.
 * The before object could be the Head BILINK for adding to the end
 * of the queue
 * CALLED WITH INTERRUPTS_OFF
 *
 *  Returns:
 *
 */
{
    #ifdef DEBUG
    if(FindObject(in,before)) {
        DPF(0,"Attempt to re-insert object in BILINK queue\n");
        DEBUG_BREAK();
    }
    #endif
    in->next = before;
    in->prev = before->prev;
    before->prev->next = in;
    before->prev = in;
}

void Delete(
     BILINK *p
)
/*=========================================================================
 *  Description:
 *
 * Delete a  object from a doubly linked list. Make sure it IS on a list!
 * CALLED WITH INTERRUPTS OFF (must be atomic).
 *
 *  Returns:
 *
 */
{
    ASSERT(p && p->prev && p->next);
    ASSERT(p->prev->next == p && p->next->prev == p);
    p->next->prev = p->prev;
    p->prev->next = p->next;
    // p->next = p->prev = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\wsock\fpm.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       fpm.h
 *  Content:	fixed size pool manager
 *
 *  History:
 *   Date		By		Reason
 *   ======		==		======
 *  12-18-97  aarono    Original
 ***************************************************************************/

#ifndef _FPM_H_
#define _FPM_H_

typedef struct FPOOL *PFPOOL, *LPFPOOL;

typedef BOOL (*FN_BLOCKINITALLOC)(void * pvItem);
typedef VOID (*FN_BLOCKINIT)(void * pvItem);
typedef VOID (*FN_BLOCKFINI)(void *pvItem);

LPFPOOL FPM_Init(
	unsigned int size,						// size of blocks in pool
	FN_BLOCKINITALLOC fnBlockInitAlloc,     // fn called for each new alloc
	FN_BLOCKINIT      fnBlockInit,          // fn called each time block used
	FN_BLOCKFINI      fnBlockFini           // fn called before releasing mem
	);

typedef void * (*FPM_GET)(LPFPOOL pPool);
typedef void   (*FPM_RELEASE)(LPFPOOL pPool, void *pvItem);
typedef void   (*FPM_SCALE)(LPFPOOL pPool);
typedef void   (*FPM_FINI)(LPFPOOL pPool, int bFORCE);

typedef struct FPOOL {
	// external
	FPM_GET		Get;
	FPM_RELEASE Release;
	FPM_SCALE   Scale;
	FPM_FINI    Fini;
	
	// internal
	FN_BLOCKINITALLOC fnBlockInitAlloc;
	FN_BLOCKINIT      fnBlockInit;
	FN_BLOCKFINI      fnBlockFini;
	
	int    cbItemSize;
	void * pPool;
	int    nAllocated;
	int    nInUse;
	int    nMaxInUse;
	int    bInScale;
	
	CRITICAL_SECTION cs;
	
} FPOOL, *LPFPOOL, *PFPOOL;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\wsock\dbgtopic.h ===
DEBUG_TOPIC(B,"&Blting")
DEBUG_TOPIC(C,"&Clipping")
DEBUG_TOPIC(D,"&DDraw Object")
DEBUG_TOPIC(F,"&Focus Changes")
DEBUG_TOPIC(H,"&HAL/HEL Calls")
DEBUG_TOPIC(I,"Internal Fn Entered")
DEBUG_TOPIC(K,"NT Kernel Calls")
DEBUG_TOPIC(L,"&Locking/Ownership")
DEBUG_TOPIC(O,"M&odes")
DEBUG_TOPIC(M,"&Memory")
DEBUG_TOPIC(P,"API &Parameters")
DEBUG_TOPIC(R,"&Reference Counting")
DEBUG_TOPIC(S,"&Surface Objects")
DEBUG_TOPIC(T,"Fil&ters")
DEBUG_TOPIC(V,"&Video Memory allocation")
DEBUG_TOPIC(W,"&Windows and Handles")
DEBUG_TOPIC(X,"Ad-Hoc Message &X")

#undef PROF_SECT
#define PROF_SECT "DirectPlay"

#undef DPF_MODULE_NAME
#ifdef START_STR
	#define DPF_MODULE_NAME START_STR
#else
	#define DPF_MODULE_NAME "DPWSOCK"
#endif


/*
 * Use this identifier to define which line in WIN.INI [DirectX] denotes the
 * debug control string
 */
#undef DPF_CONTROL_LINE
#define DPF_CONTROL_LINE "DPlayDebug"

/*
 * It is important that the first DEBUG_TOPIC appear at the top line of this
 * file, and that no other lines are interspersed between DEBUG_TOPIC lines.
 * (The debug system uses the __LINE__ pseudo-variable to identify topics)
 */

/*
 * Definitions for DPF detail levels:
 *
 * 0: Error useful for application developers.
 * 1: Warning useful for application developers.
 * 2: API Entered
 * 3: API parameters, API return values
 * 4: Driver conversation
 *
 * 5: Deeper program flow notifications
 * 6: Dump structures 
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\wsock\dpsp.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpsp.c
 *  Content:	sample direct play service provider, based on winsock
 *  History:
 *  Date		By		Reason
 *  ====		==		======
 *  1/96		andyco	created it
 *  2/8/96		andyco	steam + dgram model, including name server support
 *	2/15/96		andyco	added reliable receive.  added send (udp + stream). 
 *						added macros for dwReserved to clean up, (and provide
 *						means for reducing # dwords reserved per player)
 *	3/13/96		andyco	relaible send + receive for all players. MW2
 *	3/16/96		andyco	shutdown method - code cleanup - shared stream receive, etc.
 *	3/19/96		andyco	new message macros (IS_VALID, GET_MESSAGE_SIZE). see dpmess.h
 *	4/3/96		andyco	moved start up / shut down winsock code here from dllmain 
 *	4/10/96		andyco	added spplayerdata
 *	4/12/96		andyco	got rid of dpmess.h! use DPlay_ instead of message macros
 *	4/18/96		andyco	added multihomed support, started ipx
 *	4/23/96		andyco	ipx support.  ipx only - no spx.  spx doesn't support
 *						graceful disconnect (winsock bug?) so we don't know
 *						when it's safe to closesocket.
 *	4/25/96		andyco	messages now have blobs (sockaddr's) instead of dwReserveds  
 *	5/31/96		andyco	all non-system players share a socket (gsStream and 
 *						gsDGramSocket).
 *	6/9/96		andyco	ouch.  dplayi_player + group are gone!
 *	6/19/96		andyco	sp sets own header!
 *	6/22/96		andyco	no more stashing goodies in sessiondesc.  tossed cookies.
 *	6/23/96		kipo	updated for latest service provider interfaces.
 *	6/25/96		kipo	added WINAPI prototypes and updated for DPADDRESS;
 *						added version.
 *	7/11/96		andyco	reset gsEnumSocket to INVALID_SOCKET if spInit fails
 *						#2348.  added sp_getaddress.
 *	7/18/96		andyco	added dphelp for server socket
 *	7/16/96		kipo	changed address types to be GUIDs instead of 4CC
 *  8/1/96		andyco	fixed up caps.  dplay allocs sp data, not us.  
 *  8/9/96		andyco	throw DPCAPS_GUARANTEEDOPTIMIZED for AF_INET
 *	8/12/96		andyco	changed failure check on inithelper
 *	8/15/96		andyco	added sp local data + clean up on thread terminate
 *	8/30/96		andyco	clean it up b4 you shut it down! added globaldata.
 *	9/1/96		andyco	right said thread!  if you spin it, they won't block.
 *						bagosockets.
 * 	9/4/96		andyco	kill threads at shutdown only. add all threads to
 *						threadlist. don't add thread to list if it's already
 *						done.
 *	11/11/96	andyco	check for NULL header or data when creating
 *						non-local players (support game server). Memset our 
 *						sockaddr to 0 before calling getserveraddress.
 *	12/18/96	andyco	de-threading - use a fixed # of prealloced threads.
 *						cruised the enum socket / thread - use the system
 *						socket / thread instead
 *	1/15/97		andyco	return actual hr on open failure (bug 5197) instead of
 *						just DP_OK.  also, allow system messages to go in the 
 *						socket cache. 
 *	1/17/97		andyco	workaround for nt bug 68093 - recvfrom returns buffer size
 *						instead of WSAEMSGSIZE
 *	1/23/97		kipo	return an error code from StartDPHelp() so Open() returns
 *						an error if you cannot host a session.
 *	1/24/97		andyco	handle incoming message when receive thread isn't running yet
 *	2/7/97		andyco  store globals w/ IDirectPlaySP, so we can have > 1 SP per DLL.
 *	2/10/97		andyco	remove sockets from receive list if we get an error when receiving 
 *						on them.  this keeps us from going into a spin on select(...).
 *	2/15/97		andyco	wait on accept thread b4 receive thread.  pass port to 
 *						helperdeletedplayserver.
 *	3/04/97		kipo	external definition of gdwDPlaySPRefCount now in dplaysp.h
 *	3/18/97		andyco	create socket at spinit to verify support for requested
 *						address family
 *	3/18/97		kipo	GetServerAddress() now returns an error so that we can
 *						return DPERR_USERCANCEL from the EnumSessions dialog
 *	3/25/97		andyco	tweaked shutdown code to send message to streamreceivethreadproc
 *						to exit, rather than nuking the control socket which
 *						would sometimes hang.
 *	4/11/97		andyco	make sure it's really the control socket @ init
 *	5/12/97		kipo	return DPERR_UNAVAILABLE if SP could not be opened (i.e. if
 *						IPX not installed) to be compatible with the modem SP; added
 *						support for Unicode IP address strings.
 *	5/18/97		andyco	close threads + sockets at close.  this way, we don't hold
 *						sockets across sessions.
 *	6/11/97		andyco	changed reply thread proc to flush q when waking up
 *	6/18/97		andyco	check for bogus reply headers, just to be safe
 *	6/19/97		myronth	Fixed handle leak (#10059)
 *	6/20/97		andyco	check for bogus IPX install by looking for sa_nodenum
 *						of all 0's at SPInit.  raid 9625.
 *	7/11/97		andyco	added async reply thread and ws2 support
 *	7/30/97		andyco	call wsastartup w/ version 1.1 if app has already 
 *						called it.
 *   8/4/97		andyco	added support for DPSEND_ASYNC (no return status) so 
 *						we can make addforward async
 *	8/25/97		sohailm updated stream receive logic to avoid congestion (bug #10952)
 *	9/05/97		kipo	Fixed memphis bug #43655 to deal with getsockopt failing
 *	12/5/97		andyco	voice support
 *	01/5/98		sohailm	fd set now grows dynamically - allows for any number of clients (#15244).
 *	01/14/98	sohailm	don't look for Winsock2.0 on non-nt platforms for IPX (#15253)
 *	1/20/98		myronth	#ifdef'd out voice support
 *	1/21/98    a-PeterZ	Fix #15242 SP_GetAddress supports local players
 *	1/27/98		sohailm	added Firewall support.
 *	1/30/98		sohailm	bug fix for 17731
 *	2/09/98    a-PeterZ	Fix #17737 ReceiveList Memory Leak
 *  2/13/98     aarono  added async support
 *  2/13/98     aarono  made IPX return proper header size
 *	2/16/98    a-PeterZ	Fix #15342 Detect no local connection in SP_EnumSessions and SP_Open
 *	2/18/98    a-peterz Comment byte order mess-up with SERVER_xxx_PORT constants
 *  2/24/98     aarono  Bug#18646 fix startup/close race crashing stress.
 *  3/3/98      aarono  Bug#19188 remove accept thread 
 *  3/30/98     aarono  changed KillSocket on StreamAccept socket to closesocket
 *  4/6/98      aarono  mapped WSAECONNRESET to DPERR_CONNECTIONLOST
 *  4/23/98     aarono  workaround Winsock shutdown bug.
 *                       The workaround for DPLAY would be to close all accepted sockets first 
 * 						 and only then listening socket. (VadimE)
 *  6/19/98     aarono  map WSAENETRESET and WSAENOTCONN to DPERR_CONNECTIONLOST too.
 *                      required since we now turn on keepalives on reliable
 *                      connections.
 * 12/15/98     aarono  Fix Async Enum.
 *  7/9/99      aarono  Cleaning up GetLastError misuse, must call right away,
 *                      before calling anything else, including DPF.
 *  1/12/2000   aarono  Added Rsip support
 *  2/21/2000   aarono  Fix socket leaks
 * 10/15/2000   aarono  Force separate ports for Inbound/Outbound there seems to be a race
 *                      condition either in sockets or us in Millennium (win2k too?) too late
 *                      for full fix, may want to investigate furthur for later version.
 *
 ***************************************************************************/

/***************************************************************************
*  summary -                                                                
* 	+ SPInit is the entry point called by dplay. SP fills in callbacks,		
* 		does any other init stuff there.                                    
* 	+ All dplay callbacks start with SP_                                    
*                                                                           
*****************************************************************************/

// todo - need a meaningful mapping from socket errors to hresults

// todo - figure out when to pop a message box to the user for tragic errors

#define INITGUID

#include <dplobby.h>
#include "dpsp.h"
#include "fpm.h"
#include <initguid.h>
#include "helpcli.h"
#if USE_RSIP
#include "rsip.h"
#elif USE_NATHELP
#include "nathelp.h"
#endif
#include "mmsystem.h"
#include "dpnathlp.h"

/*			*/
/*  globals	*/
/*			*/
WSADATA gwsaData; // from wsastartup
HINSTANCE hWS2; // dynaload the ws2_32.dll, so if it's not installed (e.g. win 95 gold)
				// we still load

// stuff for ddhelp
DWORD dwHelperPid; // for ddhelp
HANDLE hModule;  // for ddhelp

CRITICAL_SECTION gcsDPSPCritSection;
CRITICAL_SECTION csMem;
#ifdef DEBUG
int gCSCount;
#endif

HRESULT StartReplyThread(LPGLOBALDATA pgd);

#undef DPF_MODNAME
#define DPF_MODNAME	"DEBUGPRINTSOCKADDR"

#ifdef DEBUG
void DebugPrintAddr(UINT nLevel,LPSTR pStr,SOCKADDR * psockaddr)
{
	switch (psockaddr->sa_family)
	{
		case AF_INET: 
		{
			SOCKADDR_IN * pin;
			pin = (SOCKADDR_IN *)psockaddr;
			DPF(nLevel,"%s af = AF_INET : address =  %s : port = %d\n",pStr,
				inet_ntoa(pin->sin_addr),ntohs(pin->sin_port));
			break;
			
		}
		case AF_IPX: 
		{
			SOCKADDR_IPX * pipx;
			pipx = (SOCKADDR_IPX *)psockaddr;
			DPF(nLevel,"%s AF = AF_IPX : sa_socket = %d : sa_net.sa_nodenum = \n",pStr,pipx->sa_socket);
			DPF(nLevel,"%02x%02x%02x%02x.%02x%02x%02x%02x%02x%02x\n",
					(UCHAR)pipx->sa_netnum[0],(UCHAR)pipx->sa_netnum[1],
					(UCHAR)pipx->sa_netnum[2],(UCHAR)pipx->sa_netnum[3],
					(UCHAR)pipx->sa_nodenum[0],(UCHAR)pipx->sa_nodenum[1],
					(UCHAR)pipx->sa_nodenum[2],(UCHAR)pipx->sa_nodenum[3],
					(UCHAR)pipx->sa_nodenum[4],(UCHAR)pipx->sa_nodenum[5]);
			break;
			
		}

		default:
			ASSERT(FALSE);
			break;
	}

} // DebugPrintAddr

void DebugPrintSocket(UINT level,LPSTR pStr,SOCKET * pSock) 
{
	SOCKADDR sockaddr;
	int addrlen=sizeof(sockaddr);

	if (getsockname(*pSock,&sockaddr,&addrlen) == 0)
	{
		DEBUGPRINTADDR(level,pStr,&sockaddr);
	}
	else
	{
		DPF(0, "Couldn't get socket 0x%p name!", *pSock);
	}
	
}
#endif // debug

#if USE_RSIP
HRESULT GetLocalAliases(LPGLOBALDATA pgd, LPSPPLAYERDATA lpPublicData, LPSPPLAYERDATA lpLocalData)
{
	HRESULT hr=DP_OK;

	
	DPF(8, "GetLocalAliases: Parameters: (0x%x, 0x%x, 0x%x)", pgd, lpPublicData, lpLocalData);

	// local aliases may be the public addresses, so copy first and only overwrite if there
	// are actual local aliases.
	memcpy(lpLocalData, lpPublicData, sizeof(SPPLAYERDATA));
	if(pgd->sRsip != INVALID_SOCKET)
	{
		hr=rsipQueryLocalAddress(pgd,TRUE,&lpPublicData->saddrStream, &lpLocalData->saddrStream);
		if (hr != DP_OK)
		{
			//
			// Stream socket address not found.
			//
		}
		else
		{
			hr=rsipQueryLocalAddress(pgd,FALSE,&lpPublicData->saddrDatagram, &lpLocalData->saddrDatagram);
			if (hr != DP_OK)
			{
				//
				// Datagram socket address not found.
				//
			}
		}
	}	
	
	DPF(8, "GetLocalAliases: Returning [0x%lx]", hr);
	
	return hr;
}
#endif

#if USE_NATHELP
HRESULT GetLocalAliases(LPGLOBALDATA pgd, LPSPPLAYERDATA lpPublicData, LPSPPLAYERDATA lpLocalData)
{
	HRESULT hr=DP_OK;

	
	DPF(8, "GetLocalAliases: Parameters: (0x%x, 0x%x, 0x%x)", pgd, lpPublicData, lpLocalData);

	// local aliases may be the public addresses, so copy first and only overwrite if there
	// are actual local aliases.
	memcpy(lpLocalData, lpPublicData, sizeof(SPPLAYERDATA));
	if(pgd->pINatHelp)
	{
		hr=IDirectPlayNATHelp_QueryAddress(
			pgd->pINatHelp, 
			&pgd->INADDRANY, 
			&lpPublicData->saddrStream, 
			&lpLocalData->saddrStream, 
			sizeof(SOCKADDR_IN), 
			DPNHQUERYADDRESS_TCP|DPNHQUERYADDRESS_CACHENOTFOUND);
		
		if (hr != DPNH_OK)
		{
			//
			// Stream socket address not found.
			//
		}
		else
		{
			hr=IDirectPlayNATHelp_QueryAddress(
				pgd->pINatHelp, 
				&pgd->INADDRANY, 
				&lpPublicData->saddrDatagram, 
				&lpLocalData->saddrDatagram, 
				sizeof(SOCKADDR_IN), 
				DPNHQUERYADDRESS_CACHENOTFOUND);
			if (hr != DPNH_OK)
			{
				//
				// Datagram socket address not found.
				//
			}
		}
	}	
	
	DPF(8, "GetLocalAliases: Returning [0x%lx]", hr);
	
	return hr;
}
#endif


HRESULT GetSPPlayerData(LPGLOBALDATA pgd, IDirectPlaySP * lpISP, DPID idPlayer, LPSPPLAYERDATA *ppPlayerData, DWORD *lpdwSize)
{
	HRESULT hr;
	DWORD dwSize;
	BOOL bAlreadyTried=FALSE; // already tried to get local mapping for remote, so just return local

	
	DPF(8, "GetSPPlayerData: Parameters: (0x%x, 0x%x, %u/%x, 0x%x, 0x%x)", pgd, lpISP, idPlayer, idPlayer, ppPlayerData, lpdwSize);
	
	#if USE_RSIP 

	    if(pgd->sRsip != INVALID_SOCKET){
	
GetLocal:	    
			hr = lpISP->lpVtbl->GetSPPlayerData(lpISP,idPlayer,ppPlayerData,lpdwSize,DPGET_LOCAL);
			if(FAILED(hr)){
				if(hr!=DPERR_INVALIDPLAYER){
					ASSERT(FALSE);
				}
				goto Exit;
			}
			if (*lpdwSize==0 && !bAlreadyTried )
			{
				SPPLAYERDATA Local_pd;     // Local as in the local addresses
				LPSPPLAYERDATA pRemote_pd; // Remote as in the public addresses 
				// We haven't go the local alias for the public addresses yet.
									
				hr= lpISP->lpVtbl->GetSPPlayerData(lpISP,idPlayer,&pRemote_pd,lpdwSize,DPGET_REMOTE);
				if(FAILED(hr)){
					if(hr!=DPERR_INVALIDPLAYER){
						ASSERT(0);
					}
					goto Exit;
				}
				if(*lpdwSize == sizeof(SPPLAYERDATA)){
					// see if there are local aliases for the remote addresses - if there are no local aliases,
					// this simply returns the same information that is used in the LOCAL data.
					GetLocalAliases(pgd, pRemote_pd, &Local_pd);
					
					hr=lpISP->lpVtbl->SetSPPlayerData(lpISP, idPlayer, &Local_pd, sizeof(SPPLAYERDATA), DPSET_LOCAL);
					if(hr == DP_OK){
						goto GetLocal;
					}	
				} else {
					bAlreadyTried=TRUE;
					goto GetLocal;
				}
			}

			goto Exit;

		} else {
		
			hr = lpISP->lpVtbl->GetSPPlayerData(lpISP,idPlayer,ppPlayerData,lpdwSize,DPGET_REMOTE);
			if (FAILED(hr))
			{
				DPF(1, "GetSPPlayerData for player %d returned err %d", idPlayer, hr);
				if (hr != DPERR_INVALIDPLAYER) 	// this can happen because of race conditions
					ASSERT(FALSE);
				goto Exit;
			}

			goto Exit;
		}

	#elif USE_NATHELP

	    if(pgd->pINatHelp){
	
GetLocal:	    
			hr = lpISP->lpVtbl->GetSPPlayerData(lpISP,idPlayer,ppPlayerData,lpdwSize,DPGET_LOCAL);
			if(FAILED(hr)){
				if(hr!=DPERR_INVALIDPLAYER){
					ASSERT(FALSE);
				}
				goto Exit;
			}
			if (*lpdwSize==0 && !bAlreadyTried )
			{
				SPPLAYERDATA Local_pd;     // Local as in the local addresses
				LPSPPLAYERDATA pRemote_pd; // Remote as in the public addresses 
				// We haven't go the local alias for the public addresses yet.
									
				hr= lpISP->lpVtbl->GetSPPlayerData(lpISP,idPlayer,&pRemote_pd,lpdwSize,DPGET_REMOTE);
				if(FAILED(hr)){
					if(hr!=DPERR_INVALIDPLAYER){
						ASSERT(0);
					}
					goto Exit;
				}
				if(*lpdwSize == sizeof(SPPLAYERDATA)){
					// see if there are local aliases for the remote addresses - if there are no local aliases,
					// this simply returns the same information that is used in the LOCAL data.
					GetLocalAliases(pgd, pRemote_pd, &Local_pd);
					
					hr=lpISP->lpVtbl->SetSPPlayerData(lpISP, idPlayer, &Local_pd, sizeof(SPPLAYERDATA), DPSET_LOCAL);
					if(hr == DP_OK){
						goto GetLocal;
					}	
				} else {
					bAlreadyTried=TRUE;
					goto GetLocal;
				}
			}

			goto Exit;

		} else {
		
			hr = lpISP->lpVtbl->GetSPPlayerData(lpISP,idPlayer,ppPlayerData,lpdwSize,DPGET_REMOTE);
			if (FAILED(hr))
			{
				DPF(1, "GetSPPlayerData for player %d returned err %d", idPlayer, hr);
				if (hr != DPERR_INVALIDPLAYER) 	// this can happen because of race conditions
					ASSERT(FALSE);
				goto Exit;
			}

			goto Exit;
		}

	#else
	
		hr = lpISP->lpVtbl->GetSPPlayerData(lpISP,idPlayer,ppPlayerData,lpdwSize,DPGET_REMOTE);
		if (FAILED(hr))
		{
			DPF(1, "GetSPPlayerData for player %d returned err %d", idPlayer, hr);
			if (hr != DPERR_INVALIDPLAYER) 	// this can happen because of race conditions
				ASSERT(FALSE);
			goto Exit;
		}

		goto Exit;

	#endif

Exit:

	DPF(8, "GetSPPlayerData: Returning [0x%lx]", hr);

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME	"GetHostAddr"

// Helper function to retrieve host IP Address(es).
// System owns structure returned.
PHOSTENT GetHostAddr(void)
{
	char pHostName[HOST_NAME_LENGTH];
	PHOSTENT phostent;
	UINT err;

	if (0 != gethostname(pHostName, HOST_NAME_LENGTH)) 
	{
		err = WSAGetLastError();
		DPF(0,"could not get host name - err = %d\n",err);
		return NULL;
	}
	
	phostent = gethostbyname(pHostName);
	if (NULL == phostent) 
	{
		err = WSAGetLastError();
		DPF(0,"could not get address for '%s' - err = %d\n", pHostName, err);
		return NULL;
	}

	return phostent;
} // GetHostAddr

#undef DPF_MODNAME
#define DPF_MODNAME	"DatagramListenThread"

void SetMessageHeader(LPDWORD pdwMsg,DWORD dwSize, DWORD dwToken)
{

	if (dwSize > SPMAXMESSAGELEN)
	{
		ASSERT(FALSE);
	}

	*pdwMsg = dwSize | dwToken;	

	return ;

}// SetMessageHeader

#undef DPF_MODNAME
#define DPF_MODNAME	"DatagramReceiveThread"

// our initial guess at the size of the dgram receive buffer.
// any messages bigger than this will be truncated BUT when we 
// receive a too big message, we double the buffer size (winsock
// won't tell us exactly how big the message was, so we guess).
// a-josbor: I thought 1024 was really stingy, so I bumped this up to 16K
#define BUF_SIZE 0x4000
#define MAX_BUF_SIZE 0x010000
DWORD WINAPI DgramListenThreadProc(LPVOID pvCast)
{
    UINT err;
	LPBYTE pBuffer;
    INT addrlen=sizeof(SOCKADDR);
    SOCKADDR sockaddr; // the from address
	DWORD dwBufSize = BUF_SIZE;
	IDirectPlaySP * pISP = (IDirectPlaySP *)pvCast;
	LPGLOBALDATA pgd;
	DWORD dwDataSize = sizeof(GLOBALDATA);
	SOCKET sSocket;
	HRESULT hr;

    DPF(2,"starting udp listen thread ");

	// get the global data
	hr =pISP->lpVtbl->GetSPData(pISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		ExitThread(0);
		return 0;
	}
	
	// use the dgram socket
	sSocket = pgd->sSystemDGramSocket;

  DPF(0,"Thread listening on socket %d UDP\n",sSocket);
  DEBUGPRINTSOCK(0,"SocketAddr for listen:",&sSocket);

	
	ENTER_DPSP();
	
	pBuffer = SP_MemAlloc(BUF_SIZE);
	
	LEAVE_DPSP();
	
	if (!pBuffer)
	{
		DPF_ERR("could not alloc dgram receive buffer");
		DEBUG_BREAK();
		ExitThread(0);
		return 0;
	}


    while (1)
    {
        err = recvfrom(sSocket,pBuffer,dwBufSize,0,&sockaddr,&addrlen);
        if ( (SOCKET_ERROR == err)  || (dwBufSize == err))
        {
		
			if (dwBufSize == err)
			{
				// this works around NT bug 68093
				err = WSAEMSGSIZE;
			}
			else 
			{
	            err = WSAGetLastError();				
			}
	        
			DPF(2,"\n udp recv error - err = %d socket = %d",err,(DWORD)sSocket);
			
			if (WSAEMSGSIZE == err)
			{
				// buffer too small!
				if(dwBufSize < MAX_BUF_SIZE) 
				{
					dwBufSize *= 2;
									
					ENTER_DPSP();
					
					pBuffer = SP_MemReAlloc(pBuffer,dwBufSize);
					
					LEAVE_DPSP();
					
					if (!pBuffer)
					{
						DPF_ERR("could not realloc dgram receive buffer");
						DEBUG_BREAK();
						ExitThread(0);
						return 0;
					}
				} else {
					// we aren't accepting any message larger than MAX_BUF_SIZE
				}
				// we don't pass dplay this message, since it was truncated...
			}
			else 
			{
		      if(pgd->bShutdown || err == WSAENOTSOCK || err == WSAESHUTDOWN || err == WSAEINTR){
				// bail on shutdown only.
				DPF(0,"Got err %d on datagram socket, bailing, bShutdown = %d\n",err,pgd->bShutdown);
				goto ERROR_EXIT;
			  }else if(err == WSAECONNRESET){
			  		// expected errors we are going to ignore.
			      DEBUGPRINTADDR(0,"Winsock gave a WSAECONNRESET on a DATAGRAM socket : ",&sockaddr);
			  } else {
			  		// Getting some kind of consistent error, don't totally crush the cpu
			  		// until we shutdown.  Some of these may be normal.
			  		DPF(0,"DGListen Got err %d on datagram socket, sleeping 1ms\n",err);
				  	Sleep(1);
			  }
			}
        }
        else if ( (err >= sizeof(DWORD)) &&  (VALID_DPWS_MESSAGE(pBuffer)) )
        {
		
			DEBUGPRINTADDR(8,"received udp message from : ",&sockaddr);
			if (VALID_SP_MESSAGE(pBuffer))
			{
				// it came from another dplay (not from our dplay helper)
				// if it came from our helper, we've already poked the ip addr
				// into the message body
				switch (pgd->AddressFamily)
				{
					case AF_IPX:
						IPX_SetNodenum((LPVOID)pBuffer,(SOCKADDR_IPX *)&sockaddr);
						break;
					case AF_INET:
						IP_SetAddr((LPVOID)pBuffer,(SOCKADDR_IN *)&sockaddr);
						break;
					default:
						ASSERT(FALSE);
						break;
				}
				
			}

			// pass message to dplays handler
            pISP->lpVtbl->HandleMessage(pISP,pBuffer + sizeof(MESSAGEHEADER),
            	err -  sizeof(MESSAGEHEADER), pBuffer);
    	}
		else 
		{
			DEBUGPRINTADDR(8,"received udp message from : ",&sockaddr);		
			// it must be just a raw send...
            pISP->lpVtbl->HandleMessage(pISP,pBuffer,err,NULL);
		}
    }

ERROR_EXIT:
	DPF(2,"UDP Listen thread exiting");
  DPF(0,"Exiting from listening on Socket %d\n",sSocket);
	
	ENTER_DPSP();
	
	if (pBuffer) SP_MemFree(pBuffer);
	
	LEAVE_DPSP();

    // all done
    ExitThread(0);
    return 0;

} // UDPListenThreadProc

#undef DPF_MODNAME
#define DPF_MODNAME	"StreamListenThread"

// make sure the buffer is big enough to fit the message size
HRESULT MakeBufferSpace(LPBYTE * ppBuffer,LPDWORD pdwBufferSize,DWORD dwMessageSize)
{
	HRESULT hr = DP_OK;

	ASSERT(ppBuffer);
	ASSERT(pdwBufferSize);
		    
	ENTER_DPSP();
	
	if (!*ppBuffer)
	{
		DPF(8, "Allocating space for message of size %d", dwMessageSize);

		// need to alloc receive buffer?
		*ppBuffer = SP_MemAlloc(dwMessageSize);
        if (!*ppBuffer)
        {
        	DPF_ERR("could not alloc stream receive buffer - out of memory");        
            hr = E_OUTOFMEMORY;
            goto CLEANUP_EXIT;
        }
		*pdwBufferSize = dwMessageSize;
	}
	// make sure receive buffer can hold data
	else if (dwMessageSize > *pdwBufferSize) 
	{
		LPVOID pvTemp;

		DPF(8, "ReAllocating space for message of size %d", dwMessageSize);

		// realloc buffer to hold data
		pvTemp = SP_MemReAlloc(*ppBuffer,dwMessageSize);
		if (!pvTemp)
		{
        	DPF_ERR("could not realloc stream receive buffer - out of memory");
            hr = E_OUTOFMEMORY;
            goto CLEANUP_EXIT;
		}
		*ppBuffer = pvTemp;
		*pdwBufferSize = dwMessageSize;
	}

    // fall through
    
CLEANUP_EXIT: 
    
	LEAVE_DPSP();
    return hr;    
    
}  // MakeBufferSpace

// is this sockaddr local to this machine?
BOOL IsLocalIP(SOCKADDR_IN sockaddr)
{
	PHOSTENT phostent;
	IN_ADDR hostaddr;
	HRESULT hr = DP_OK;
	int i;

	phostent = GetHostAddr();
	if (NULL == phostent) 
	{
		return FALSE;
	}

	i=0;
	while (phostent->h_addr_list[i])
	{
		memcpy(&hostaddr,phostent->h_addr_list[i],sizeof(hostaddr));
		if (hostaddr.s_addr == sockaddr.sin_addr.s_addr )
		{
			return TRUE;
		}
		i++;
	}

	return FALSE;
}  // IsLocalIP

// adds socket to our send list
HRESULT AddSocketToBag(LPGLOBALDATA pgd, SOCKET socket, DPID dpid, SOCKADDR *psockaddr, DWORD dwFlags)
{
	UINT i=0;
	BOOL bFound = FALSE;
	BOOL bTrue = TRUE;
	HRESULT hr=DP_OK;
		
	ASSERT(psockaddr);

	ENTER_DPSP();

	// see if we can find an empty slot
	i=0;
	while (( i < pgd->nSocketsInBag) && !bFound)
	{
		if (INVALID_SOCKET == pgd->BagOSockets[i].sSocket) bFound = TRUE;
		else i++;
	}
	if (!bFound)	
	{
		// no space. bummer
		DPF(5,"no space in bag o' sockets. slowness ensues");
		hr = E_FAIL;
		goto CLEANUP_EXIT;
	}

	DPF(5,"adding new socket to bag for id = %d, slot = %d",dpid,i);
	DEBUGPRINTSOCK(7, "Adding socket to bag - ",&socket);
	
	pgd->BagOSockets[i].dwPlayerID = dpid;	
	pgd->BagOSockets[i].sSocket = socket;
	pgd->BagOSockets[i].sockaddr = *psockaddr;
	pgd->BagOSockets[i].dwFlags = dwFlags;

	// fall through

CLEANUP_EXIT:
	LEAVE_DPSP();
	return hr;
}

void FreeConnection(LPCONNECTION pConnection)
{
	if (pConnection->pBuffer && (pConnection->pBuffer != pConnection->pDefaultBuffer)) 
	{
		SP_MemFree(pConnection->pBuffer);
		pConnection->pBuffer = NULL;
	}
	if (pConnection->pDefaultBuffer) 
	{
		SP_MemFree(pConnection->pDefaultBuffer);
		pConnection->pDefaultBuffer = NULL;
	}

	// initialize connection 
    pConnection->socket = INVALID_SOCKET; // this tells us if connection is valid
	pConnection->dwCurMessageSize = 0;
	pConnection->dwTotalMessageSize = 0;
	pConnection->dwFlags = 0;
}


HRESULT AddSocketToReceiveList(LPGLOBALDATA pgd,SOCKET sSocket,DWORD dwFlags)
{
    UINT i = 0;
    UINT err, iNewSlot;
	BOOL bFoundSlot = FALSE;
    HRESULT hr = DP_OK;
    INT addrlen=sizeof(SOCKADDR);
	LPCONNECTION pNewConnection=NULL;
	DWORD dwCurrentSize,dwNewSize;
    
    ENTER_DPSP();
	
    // look for an empty slot 
    while ( (i < pgd->ReceiveList.nConnections) && !bFoundSlot)
    {
    	if (INVALID_SOCKET == pgd->ReceiveList.pConnection[i].socket)
    	{
    		bFoundSlot = TRUE;			
			iNewSlot = i;
    	}
        else 
        {
        	i++;
        }
    }
    
    {
      // Turn on keepalive on all inbound sockets so if the remote
      // goes away without exiting cleanly, we will (eventually) dump the socket.
      // (AO 2/17/00)
      
   		// All our sockets have KEEPALIVE...
  		BOOL bTrue = TRUE;

  		// turn ON keepalive
  		if (SOCKET_ERROR == setsockopt(sSocket, SOL_SOCKET, SO_KEEPALIVE, (CHAR FAR *)&bTrue, sizeof(bTrue)))
  		{
  				err = WSAGetLastError();
  				DPF(0,"Failed to turn ON keepalive - continue : err = %d\n",err);
  		}
    }

    if (!bFoundSlot)
    {		
		// allocate space for list of connections
		dwCurrentSize = pgd->ReceiveList.nConnections * sizeof(CONNECTION);
		dwNewSize = dwCurrentSize +  INITIAL_RECEIVELIST_SIZE * sizeof(CONNECTION);		
		hr =  MakeBufferSpace((LPBYTE *)&(pgd->ReceiveList.pConnection),&dwCurrentSize,dwNewSize);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			goto ERROR_EXIT;
		}		
		ASSERT(dwCurrentSize == dwNewSize);
		
        // set all the new entries to INVALID
        for (i = pgd->ReceiveList.nConnections + 1; 
        	i < pgd->ReceiveList.nConnections + INITIAL_RECEIVELIST_SIZE; i++ )
        {
        	pgd->ReceiveList.pConnection[i].socket = INVALID_SOCKET;
        }
        
        // store the new socket in the 1st new spot
		iNewSlot = pgd->ReceiveList.nConnections;

        // allocate space for an fd set (fd_count + fd_array)
		if (pgd->ReceiveList.nConnections)
		{
	        dwCurrentSize = sizeof(u_int) + pgd->ReceiveList.nConnections * sizeof(SOCKET);
	        dwNewSize =	dwCurrentSize + INITIAL_RECEIVELIST_SIZE * sizeof(SOCKET);
		}
		else
		{
			dwCurrentSize = 0;
			dwNewSize = sizeof(u_int) + INITIAL_RECEIVELIST_SIZE * sizeof(SOCKET);
		}
		hr =  MakeBufferSpace((LPBYTE *)&(pgd->readfds.pfdbigset),&dwCurrentSize,dwNewSize);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			goto ERROR_EXIT;
		}		
		ASSERT(dwCurrentSize == dwNewSize);
		
        // update the # of connections
        pgd->ReceiveList.nConnections += INITIAL_RECEIVELIST_SIZE; 
		// update the fd_array buffer size
		pgd->readfds.dwArraySize = pgd->ReceiveList.nConnections;
        
    } // !bFoundSlot

	// we have a space holder for a connection when we get here
	
	// Initialize new connection 
	pNewConnection = &(pgd->ReceiveList.pConnection[iNewSlot]);
    pNewConnection->socket = sSocket;
    pNewConnection->dwFlags = dwFlags;

	if(dwFlags != SP_STREAM_ACCEPT){

		// allocate a default receive buffer if don't have one already
	    if (!pNewConnection->pDefaultBuffer)
	    {
	    	pNewConnection->pDefaultBuffer = SP_MemAlloc(DEFAULT_RECEIVE_BUFFERSIZE);
	    	if (!pNewConnection->pDefaultBuffer)
			{
				hr = DPERR_OUTOFMEMORY;
			    DPF_ERR("could not alloc default receive buffer - out of memory");        
				goto ERROR_EXIT;
			}
	    }
	    
		// receive buffer initially points to our default buffer
		pNewConnection->pBuffer = pNewConnection->pDefaultBuffer;
		
		// remember the address we are connected to
		err = getpeername(pNewConnection->socket, &(pNewConnection->sockAddr), &addrlen);
		if (SOCKET_ERROR == err) 
		{
			err = WSAGetLastError();
			DPF(1,"could not getpeername err = %d\n",err);
		}

		DEBUGPRINTADDR(8, "Socket is connected to address - ",&(pNewConnection->sockAddr));

	}
	
	LEAVE_DPSP();

	DPF(5, "Added new socket at index %d", iNewSlot);


	// success
	return DP_OK;

	// not a fall through
	
ERROR_EXIT:

	if (pNewConnection)
	{
		KillSocket(pNewConnection->socket,TRUE,FALSE);
		FreeConnection(pNewConnection);
	}
	LEAVE_DPSP();
    return hr;
    
}  // AddSocketToReceiveList

// updates the player associated with a socket in the send list
void UpdateSocketPlayerID(LPGLOBALDATA pgd, SOCKADDR *pSockAddr, DPID dpidPlayer)
{
	UINT i=0;
	IN_ADDR *pIPCurrent, *pIPFind;
	BOOL bFound = FALSE;

	ASSERT(pSockAddr);

	DEBUGPRINTADDR(8, "Updating player id for socket connected to - ",pSockAddr);

	ENTER_DPSP();

	while (!bFound && (i < pgd->nSocketsInBag))
    {
		pIPCurrent = &(((SOCKADDR_IN *)&pgd->BagOSockets[i].sockaddr)->sin_addr);
		pIPFind = &(((SOCKADDR_IN *)pSockAddr)->sin_addr);

		// todo - we are only comparing the IP here, need to look at the complete socket address
		if ((INVALID_SOCKET != pgd->BagOSockets[i].sSocket) && 
			!memcmp(pIPCurrent, pIPFind, sizeof(IN_ADDR)))
    	{			
			bFound = TRUE;
			// update the player id
			pgd->BagOSockets[i].dwPlayerID = dpidPlayer;
    	}

    	i++;
    }

    LEAVE_DPSP();

    return;
}

BOOL FindSocketInReceiveList(LPGLOBALDATA pgd, SOCKADDR *pSockAddr, SOCKET * psSocket)
{
	UINT i=0;
	IN_ADDR *pIPCurrent, *pIPFind;
	BOOL bFound = FALSE;

	ASSERT(psSocket);

	ENTER_DPSP();

	while (!bFound && (i < pgd->ReceiveList.nConnections))
    {
		pIPCurrent = &(((SOCKADDR_IN *)&pgd->ReceiveList.pConnection[i].sockAddr)->sin_addr);
		pIPFind = &(((SOCKADDR_IN *)pSockAddr)->sin_addr);

		// todo - we are only comparing the IP here, need to look at the complete socket address
		if ((INVALID_SOCKET != pgd->ReceiveList.pConnection[i].socket) && 
			!memcmp(pIPCurrent, pIPFind, sizeof(IN_ADDR)))
    	{
			*psSocket = pgd->ReceiveList.pConnection[i].socket;
			bFound = TRUE;
    	}

    	i++;
    }

    LEAVE_DPSP();
    
	return bFound;
}

BOOL FindSocketInBag(LPGLOBALDATA pgd, SOCKADDR *pSockAddr, SOCKET * psSocket, LPDPID lpdpidPlayer)
{
	UINT i=0;
	IN_ADDR *pIPCurrent, *pIPFind;
	BOOL bFound = FALSE;

	ASSERT(psSocket);
	ASSERT(lpdpidPlayer);

	ENTER_DPSP();
	

	while (!bFound && (i < pgd->nSocketsInBag))
    {
		pIPCurrent = &(((SOCKADDR_IN *)&pgd->BagOSockets[i].sockaddr)->sin_addr);
		pIPFind = &(((SOCKADDR_IN *)pSockAddr)->sin_addr);

		if ((INVALID_SOCKET != pgd->BagOSockets[i].sSocket) &&
			!memcmp(pIPCurrent, pIPFind, sizeof(IN_ADDR)))
		{
			*psSocket = pgd->BagOSockets[i].sSocket;
			*lpdpidPlayer = pgd->BagOSockets[i].dwPlayerID;

			DPF(8, "Found socket in send list for id %d", *lpdpidPlayer);
			bFound = TRUE;
    	}

    	i++;
    }

    LEAVE_DPSP();
    
	return bFound;
}

void RemoveSocketFromBag(LPGLOBALDATA pgd, SOCKET socket)
{
	BOOL bFound = FALSE;
	UINT i=0;
	
	ENTER_DPSP();

    // look for the socket
    while (!bFound && (i < pgd->nSocketsInBag))
    {
    	if (socket == pgd->BagOSockets[i].sSocket)
    	{
			pgd->BagOSockets[i].sSocket = INVALID_SOCKET;
			bFound = TRUE;
    	}
        else 
        {
        	i++;
        }
    } // while

	LEAVE_DPSP();
}

void RemoveSocketFromReceiveList(LPGLOBALDATA pgd, SOCKET socket)
{
    UINT i = 0;
	BOOL bFound = FALSE;
	SOCKET sSocket=INVALID_SOCKET;
	DWORD dwSocketFlags=0;

    ENTER_DPSP();
    
    // look for the corresponding connection
    while ( !bFound && (i < pgd->ReceiveList.nConnections))
    {
    	if (socket == pgd->ReceiveList.pConnection[i].socket)
    	{
			DEBUGPRINTSOCK(8, "Removing socket from receive list - ", &socket);
			socket = pgd->ReceiveList.pConnection[i].socket;			
			dwSocketFlags = pgd->ReceiveList.pConnection[i].dwFlags;
			FreeConnection(&pgd->ReceiveList.pConnection[i]);
			bFound = TRUE;
    	}
        else 
        {
        	i++;
        }
    } // while
    
    LEAVE_DPSP();
	
	if (bFound)
	{
		KillSocket(socket, TRUE, FALSE);
		if (dwSocketFlags & SP_CONNECTION_FULLDUPLEX)
			RemoveSocketFromBag(pgd,sSocket);
	}

	return ;	
	
} //RemoveSocketFromReceiveList

HRESULT HandleSPMessage(IDirectPlaySP *pISP, LPGLOBALDATA pgd, LPCONNECTION pConnection)
{
	HRESULT hr;
	
	switch (SP_MESSAGE_TOKEN(pConnection->pBuffer)) 
	{		
		// VALID_SP_MESSAGE
		case TOKEN:
		{
			if (SPMESSAGEHEADERLEN == pConnection->dwTotalMessageSize)
			{
	    		// if we get a message w/ 0 size, it means we've accepted a connection
				// and need to add the new socket to our recv list...
				// basically, it's a no-op for the receive loop
				return DP_OK;
			}
			
			// now, we've read all the bits
			// store the address we received from w/ the message
			// todo - don't store address if it's a player - player message
			switch (pgd->AddressFamily)
			{
				case AF_INET:
					if (pgd->dwFlags & DPSP_OUTBOUNDONLY)
					{
						((LPMESSAGEHEADER)pConnection->pBuffer)->sockaddr = pConnection->sockAddr;
					}
					else
					{
						IP_SetAddr((LPVOID)pConnection->pBuffer,(SOCKADDR_IN *)&pConnection->sockAddr);
					}
					break;
				case AF_IPX:
					IPX_SetNodenum((LPVOID)pConnection->pBuffer,(SOCKADDR_IPX *)&pConnection->sockAddr);
					break;
				default:
					ASSERT(FALSE);
					break;
			}
			
			// pass message to dplays handler
			// need to drop the lock here...
			ASSERT( 1 == gCSCount);
			
			DPF(8, "received a complete message - handing it off to dplay");

			LEAVE_DPSP();
			
			// received a complete message - hand it off to dplay
			pISP->lpVtbl->HandleMessage(pISP, pConnection->pBuffer + sizeof(MESSAGEHEADER),
	        		pConnection->dwTotalMessageSize - sizeof(MESSAGEHEADER),pConnection->pBuffer);
			
			ENTER_DPSP();

		} 
		break;
		
 		// VALID_SERVER_MESSAGE
 		case SERVER_TOKEN:
		{
			HandleServerMessage(pgd, pConnection->socket, pConnection->pBuffer + sizeof(MESSAGEHEADER), 
	        		pConnection->dwTotalMessageSize - sizeof(MESSAGEHEADER));
	        		
		}
		break;

		// if we get this token, the sender wants us to reuse the connection
		// so put it in the send list
		case REUSE_TOKEN:
		{
			DEBUGPRINTSOCK(8, "Received reuse message on - ", &pConnection->socket);

			// we only allow reusing connections in client/server mode at this time.
			// peer-peer can't work without making inbound connections
			if (pgd->dwSessionFlags & DPSESSION_CLIENTSERVER)
			{
				DEBUGPRINTSOCK(8, "Reusing connection - ", &pConnection->socket);

				hr = AddSocketToBag(pgd, pConnection->socket, 0, &pConnection->sockAddr, 
									SP_CONNECTION_FULLDUPLEX);
				if (FAILED(hr))
				{
					DEBUGPRINTSOCK(0, "Failed to reuse connection - ",&pConnection->socket);
					return hr;
				}
			}
			else
			{
				DPF(2, "Not accepting reuse request in peer-peer");
				return E_FAIL;

			}
		}
		break;

		default:
		{
			DPF(0, "Received a message with invalid token - 0x%08x",SP_MESSAGE_TOKEN(pConnection->pBuffer));
		}
		break;
	
	} // switch

	return DP_OK;
	
} // HandleSPMessage

/*
 ** StreamReceive
 *
 *  CALLED BY: StreamReceiveThreadProc
 *
 *  PARAMETERS:
 *		sSocket - socket to receive on
 *		ppBuffer - buffer to receive into - alloc'ed / realloc'ed  as necessary
 *		pdwBuffersize - size of pBuffer
 *
 *  DESCRIPTION:
 *		pull the bytes out of sSocket until no more bytes
 *
 *  RETURNS: E_FAIL on sockerr, or DP_OK. 
 *
 */
HRESULT StreamReceive(IDirectPlaySP * pISP,LPGLOBALDATA pgd, LPCONNECTION pConnection)
{
	HRESULT hr = DP_OK;
    UINT err;
    DWORD dwBytesReceived=0;
	DWORD dwMessageSize = 0;
	LPBYTE pReceiveBuffer=NULL;
	DWORD dwReceiveBufferSize;
	
	// is it a new message ?
	if (pConnection->dwCurMessageSize == 0)
	{
		// make sure we have a buffer to recive data in
		if (!pConnection->pDefaultBuffer)
		{
			DEBUGPRINTADDR(0, "No buffer to receive data - removing connection to - ",&pConnection->sockAddr);
			goto CLEANUP_EXIT;
		}
		// receive the header first
		pConnection->dwTotalMessageSize = SPMESSAGEHEADERLEN;
	}

	// continue receiving message
	pReceiveBuffer = pConnection->pBuffer + pConnection->dwCurMessageSize;
	dwReceiveBufferSize = pConnection->dwTotalMessageSize - pConnection->dwCurMessageSize;

	DPF(8,"Attempting to receive %d bytes", dwReceiveBufferSize);

   	DEBUGPRINTSOCK(8,">>> receiving data on socket - ",&pConnection->socket);

	// receive data from socket 
	// note - make exactly one call to recv after select otherwise we'll hang
	dwBytesReceived = recv(pConnection->socket, (LPBYTE)pReceiveBuffer, dwReceiveBufferSize, 0);

	if (0 == dwBytesReceived)
	{
		// remote side has shutdown connection gracefully
	   	DEBUGPRINTSOCK(8,"<<< received data on socket - ",&pConnection->socket);
		hr = DP_OK;
		DEBUGPRINTSOCK(5,"Remote side has shutdown connection gracefully - ",&pConnection->socket);
		goto CLEANUP_EXIT;
	}
	else if (SOCKET_ERROR == dwBytesReceived)
	{
		err = WSAGetLastError();

   		DEBUGPRINTSOCK(8,"<<< received data on socket - ",&pConnection->socket);
		DPF(0,"STREAMRECEIVEE: receive error - err = %d",err);
		hr = E_UNEXPECTED;            
		goto CLEANUP_EXIT;
	}

	DPF(5, "received %d bytes", dwBytesReceived);
	
	// we have received this much message so far
	pConnection->dwCurMessageSize += dwBytesReceived;

	// did we receive the header
	if (pConnection->dwCurMessageSize == SPMESSAGEHEADERLEN)
	{
		// we just completed receiving message header

		// make sure its valid
		if (VALID_DPWS_MESSAGE(pConnection->pDefaultBuffer))
		{
			 dwMessageSize = SP_MESSAGE_SIZE(pConnection->pDefaultBuffer); // total message size			

#ifdef BIGMESSAGEDEFENSE
			// make sure it is not greater that the max message len
			if (dwMessageSize > pgd->dwMaxMessageSize)
			{
				DPF(0, "Got message (%d bytes) that's bigger than max allowed len (%d)! Disconnecting sender.\n",
					dwMessageSize - sizeof(MESSAGEHEADER), pgd->dwMaxMessageSize - sizeof(MESSAGEHEADER));
				ASSERT(dwMessageSize <= pgd->dwMaxMessageSize);
								
				// we want to receive another 12 bytes so that DPLAY can have
				//	something to look at to decide whether or not to continue
				//	receiving this message.  So instead of setting dwMessageSize
				//	to its real size, we fake it out.
				dwMessageSize = SPMESSAGEHEADERLEN + 12;
			}
#endif
		}
		else 
		{
			DPF(2,"got invalid message - token = 0x%08x",SP_MESSAGE_TOKEN(pConnection->pDefaultBuffer));
			ASSERT(FALSE);
			hr = E_UNEXPECTED;
			goto CLEANUP_EXIT;
		}

		// prepare to receive rest of the message (after the token)
		if (dwMessageSize) 
		{
			pConnection->dwTotalMessageSize = dwMessageSize;

			// which buffer to receive message in ?
			if (dwMessageSize > DEFAULT_RECEIVE_BUFFERSIZE)
			{
				ASSERT(pConnection->pBuffer == pConnection->pDefaultBuffer);
				// get a new buffer to fit the message
				pConnection->pBuffer = SP_MemAlloc(dwMessageSize);
				if (!pConnection->pBuffer)
				{
					DPF(0,"Failed to allocate receive buffer for message - out of memory");
					goto CLEANUP_EXIT;
				}
				// copy header into new message buffer
				memcpy(pConnection->pBuffer, pConnection->pDefaultBuffer, SPMESSAGEHEADERLEN);
			}
		}
	}
#ifdef BIGMESSAGEDEFENSE
	// this MIGHT be because the message is really huge, and we're just getting
	// enough to hand to DPLAY
	else if (pConnection->dwCurMessageSize == SPMESSAGEHEADERLEN + 12)
	{
		dwMessageSize = SP_MESSAGE_SIZE(pConnection->pBuffer);
		if (dwMessageSize > pgd->dwMaxMessageSize)
		{
			DPSP_MSGTOOBIG	msgTooBigErr;
			
			// okay.  This is message is too big, and we now have enough data
			// to hand to DPLAY.  Find out if it wants us to continue receiving,
			//	or bail on this connection

			// call into DPLAY to let it do its thing
			msgTooBigErr.dwType = DPSPWARN_MESSAGETOOBIG;	
			msgTooBigErr.pReceiveBuffer = pConnection->pBuffer + sizeof(MESSAGEHEADER);
			msgTooBigErr.dwBytesReceived = pConnection->dwCurMessageSize;
			msgTooBigErr.dwMessageSize = dwMessageSize - sizeof(MESSAGEHEADER);
			
			LEAVE_DPSP();

			pISP->lpVtbl->HandleSPWarning(pISP, &msgTooBigErr, sizeof(DPSP_MSGTOOBIG), pConnection->pBuffer);
			
			ENTER_DPSP();

//			now, kill the connection
			hr = E_UNEXPECTED;
			goto CLEANUP_EXIT;
		}
	}
#endif

	// did we receive a complete message ?
	if (pConnection->dwCurMessageSize == pConnection->dwTotalMessageSize)
	{
		// process message
		hr = HandleSPMessage(pISP, pgd, pConnection);
		
		// cleanup up new receive buffer if any
		if (pConnection->dwTotalMessageSize > DEFAULT_RECEIVE_BUFFERSIZE)
		{
			DPF(8, "Releasing receive buffer of size %d", pConnection->dwTotalMessageSize);
			if (pConnection->pBuffer) SP_MemFree(pConnection->pBuffer);
		}			
		// initialize message information
		pConnection->dwCurMessageSize = 0;
		pConnection->dwTotalMessageSize = 0;
		pConnection->pBuffer = pConnection->pDefaultBuffer;

		if (FAILED(hr))
		{
			goto CLEANUP_EXIT;
		}
	}

	// all done
	return DP_OK;	
	
CLEANUP_EXIT:

	RemoveSocketFromReceiveList(pgd,pConnection->socket);
	return hr;
	 	
} // StreamReceive


void EmptyConnectionList(LPGLOBALDATA pgd)
{
	UINT i;
	
	ENTER_DPSP();
	
	for (i=0;i<pgd->ReceiveList.nConnections ;i++ )
	{
		if (INVALID_SOCKET != pgd->ReceiveList.pConnection[i].socket)
		{
			KillSocket(pgd->ReceiveList.pConnection[i].socket,TRUE,FALSE);
			FreeConnection(&(pgd->ReceiveList.pConnection[i]));
		}
	}
	
	LEAVE_DPSP();
	
	return ;
	
}  // EmptyConnectionList

// when we get a control event, we need to send a message to the control
// socket (to wake up the receive thread proc).
// this finds the ip addr of this machine to send to. 
HRESULT GetDefaultHostAddr(SOCKADDR * psockaddr)
{
    PHOSTENT phostent;
    IN_ADDR hostaddr;
	    	
    ((LPSOCKADDR_IN)psockaddr)->sin_addr.s_addr = 0;
	
    // find an ip address for this machine
    // we use the default, since all our sends are to local 
    // name servers (no homing issues)
    phostent = GetHostAddr();
    if (NULL == phostent) 
    {
        return E_FAIL;
    }
    DPF(5,"found host name %s \n",phostent->h_name);

    memcpy(&hostaddr,phostent->h_addr_list[0],sizeof(hostaddr));

    DPF(5,"GetDefaultHostAddr ::  found host addr = %s \n",inet_ntoa(hostaddr));
    
    // store the default sockaddr for this system
    ((LPSOCKADDR_IN)psockaddr)->sin_addr.s_addr = hostaddr.s_addr;
	
    return DP_OK;
	
} // GetDefaultHostAddr

// watch our list of sockets, waiting for one to have data to be received, or to be closed
DWORD WINAPI StreamReceiveThreadProc(LPVOID pvCast)
{
	HRESULT hr;
	int rval;
	UINT i = 0;
    UINT err;
    DWORD dwBufferSize = 0;    
	UINT nSelected;
	IDirectPlaySP * pISP = (IDirectPlaySP *)pvCast;
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	TIMEVAL tv={0,250000};	// 250000 us = 1/4 sec.
	DWORD dwPrevSelectLastError=0;
	
	// get the global data
	hr =pISP->lpVtbl->GetSPData(pISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		ExitThread(0);
		return 0;
	}

	AddSocketToReceiveList(pgd,pgd->sSystemStreamSocket,SP_STREAM_ACCEPT);

    while (1)
    {
		ENTER_DPSP();

		ASSERT(pgd->readfds.pfdbigset);

    	// add all sockets in our recv list to readfds
		FD_ZERO(pgd->readfds.pfdbigset);
		nSelected = 0;
		for (i=0;i < pgd->ReceiveList.nConnections ; i++)
		{
        	if (INVALID_SOCKET != pgd->ReceiveList.pConnection[i].socket)
        	{
		        FD_BIG_SET(pgd->ReceiveList.pConnection[i].socket,&pgd->readfds);
				nSelected++;
        	}
		}

		LEAVE_DPSP();

		if (0 == nSelected)		
		{
			if (pgd->bShutdown)
			{
				DPF(2,"stream receive thread proc detected shutdown - bailing");
				goto CLEANUP_EXIT;
			}
			// we should have at least one?
			DPF_ERR("No sockets in receive list - missing control socket? bailing!");
			ASSERT(FALSE);
			goto CLEANUP_EXIT;
		}

		// now, we wait for something to happen w/ our socket set
		rval = select(0,(fd_set *)(pgd->readfds.pfdbigset),NULL,NULL,&tv);
        if (SOCKET_ERROR == rval)
        {
        	err = WSAGetLastError();
        	if(dwPrevSelectLastError==err){
        		DPF(0,"Got two bogus last errors of(%x) from select, bailing",err);
        		goto CLEANUP_EXIT;
        	}
			// WSAEINTR is returned when a socket is shutdown behind us - this can happen
			// when a socket is removed from the receivelist
        	if (WSAEINTR != err)
			{
				dwPrevSelectLastError=err;
	            DPF(2,"StreamReceiveThreadProc failing w/ sockerr = %d\n - trying again",err);
				ASSERT(FALSE);				
	        	rval = 0; // try again...
			} else {
				dwPrevSelectLastError=0;
			}
        } else {
			dwPrevSelectLastError=0;
        }

		// shut 'em down?
        if (pgd->bShutdown)
        {
        	DPF(2,"receive thread proc detected bShutdown - bailing");
            goto CLEANUP_EXIT;
        }
        
		// a-josbor: why are we waking up with 0 events?
		// in any case, a workaround is to just go back to sleep if we have
		// no real events
		if ( rval == 0)
		{
			continue;
		}

    	DPF(5,"receive thread proc - events on %d sockets",rval);
		i = 0;
		
		ENTER_DPSP();
		
        while (rval>0)
        {
	        // walk the receive list, dealing w/ all new sockets
			if (i >= pgd->ReceiveList.nConnections)
			{
				DPF(0, "nConnections = %d, selected = %d", pgd->ReceiveList.nConnections, i);
				ASSERT(FALSE); // should never happen
				rval = 0; // just to be safe, reset
			}
            
            if (pgd->ReceiveList.pConnection[i].socket != INVALID_SOCKET)
            {
            	// see if it's in the set
                if (FD_ISSET(pgd->ReceiveList.pConnection[i].socket,pgd->readfds.pfdbigset))
                {
					DPF(8, "Receiving on socket %d from ReceiveList", i);

					if(pgd->ReceiveList.pConnection[i].dwFlags != SP_STREAM_ACCEPT){

	                	// got one! this socket has something going on...
						hr = StreamReceive(pISP, pgd, &(pgd->ReceiveList.pConnection[i]));
	                    if (FAILED(hr))
	                    {
							DPF(1,"Stream Receive failed - hr = 0x%08lx\n",hr);
	                    }
	                    
                    } else {
                    
               		    // accept any incoming connection
               		    SOCKADDR sockaddr; 
					    INT addrlen=sizeof(sockaddr);
					    SOCKET sSocket;
					    
					    sSocket = accept(pgd->sSystemStreamSocket,&sockaddr,&addrlen);
					    if (INVALID_SOCKET == sSocket) 
					    {
					        err = WSAGetLastError();
				            DPF(2,"\n stream accept error - err = %d socket = %d",err,(DWORD)sSocket);
					    } else {
						    DEBUGPRINTADDR(5,"stream - accepted connection from",&sockaddr);
							
							// add the new socket to our receive q
							hr = AddSocketToReceiveList(pgd,sSocket,0);
							if (FAILED(hr))
							{
								ASSERT(FALSE);
							}
						}	
                    }
                    rval--; // one less to hunt for
                } // IS_SET
            } // != INVALID_SOCKET

            i++;
                
   		} // while rval
		
		LEAVE_DPSP();
		
	} // while 1

CLEANUP_EXIT:

	EmptyConnectionList(pgd);
	    
    return 0;
    
} // StreamReceiveThreadProc

// send a message of 0 length telling receiver to reuse connection
HRESULT SendReuseConnectionMessage(SOCKET sSocket)
{
	DWORD dwMessage;
	HRESULT hr=DP_OK;
	UINT err;
	
	// send a 0 sized message (w/ our header) to the stream socket, to tell 
	// receive thread proc to reuse this socket for replies to us
	SetMessageHeader(&dwMessage,0,REUSE_TOKEN);
	
    err = send(sSocket,(LPBYTE)&dwMessage,sizeof(DWORD),0);
    if (SOCKET_ERROR == err) 
    {
        err = WSAGetLastError();

		// if we're shutdown, don't print a scary
		DPF(0,"SendReuseControlMessage failed with error - err = %d\n",err);
		hr = E_FAIL;
	}	

	return hr;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CreateAndConnectSocket"

// called by reliable send and DoTCPEnumSessions
HRESULT CreateAndConnectSocket(LPGLOBALDATA pgd,SOCKET * psSocket,DWORD dwType,LPSOCKADDR psockaddr, BOOL bOutBoundOnly)
{
	UINT err;
	HRESULT hr;
	int iAddrLen = sizeof(SOCKADDR);

	ASSERT(psSocket);
	
	hr = CreateSocket(pgd,psSocket,dwType,0,INADDR_ANY,&err,FALSE);
    if (FAILED(hr)) 
    {
        DPF(0,"createandconnect :: create socket failed - err = %d\n",err);
       	return hr;
    }
	
	// try to connect	
	hr = SPConnect(psSocket,(LPSOCKADDR)psockaddr,iAddrLen, bOutBoundOnly);
    if (FAILED(hr)) 
    {
        DEBUGPRINTADDR(0, "createandconnect - connect socket failed - ", psockaddr);
		goto ERROR_EXIT;
    }

	if (bOutBoundOnly)
	{
		// so we receive the reply (server will reuse the connection)
		hr = AddSocketToReceiveList(pgd, *psSocket,SP_CONNECTION_FULLDUPLEX);
		if (FAILED(hr))
		{
			DPF(0, "failed to add socket to receive list");
			goto ERROR_EXIT;
		}
	}
	
	return DP_OK;
	// not a fall through

ERROR_EXIT:
	if (INVALID_SOCKET != *psSocket)
	{
		err = closesocket(*psSocket);
		if (SOCKET_ERROR == err) 
		{
			err = WSAGetLastError();
			DPF(0,"send closesocket error - err = %d\n",err);
			return E_UNEXPECTED;
		}
	    *psSocket = INVALID_SOCKET;
	}

	return hr;	
	
}  // CreateAndConnectSocket


#undef DPF_MODNAME
#define DPF_MODNAME	"EnumSessions"

// starts the streamacceptthread (TCP) or the dgramlistenthreadproc (IPX) so we can 
// get replies from the nameserver for our requests
HRESULT StartupEnumThread(IDirectPlaySP * pISP,LPGLOBALDATA pgd)
{
	HRESULT hr;
	UINT err;
	DWORD dwThreadID;
	
	// set up socket
	if (AF_IPX == pgd->AddressFamily) // ipx gets dgram socket
	{
		if (pgd->hDGramReceiveThread)
		{
			return DP_OK; // already running
		}
		
		ASSERT(INVALID_SOCKET == pgd->sSystemDGramSocket);
		
	    hr = CreateSocket(pgd,&(pgd->sSystemDGramSocket),SOCK_DGRAM,0,INADDR_ANY,&err,TRUE);
		if (FAILED(hr)) 
		{
			DPF(0,"could not create enum socket - err = %d\n",err);
			return hr;
		}
		
		pgd->hDGramReceiveThread = CreateThread(NULL,0,DgramListenThreadProc,
			(LPVOID)pISP,0,&dwThreadID);
		if (!pgd->hDGramReceiveThread)
		{
			ASSERT(FALSE);
		} else SetThreadPriority(pgd->hDGramReceiveThread, THREAD_PRIORITY_ABOVE_NORMAL);
	}
	else  // everything else uses reliable
	{
		if (pgd->hStreamReceiveThread)
		{
			return DP_OK; // already running
		}
		
		// create system stream socket so we can start listening for connections
		ASSERT(INVALID_SOCKET == pgd->sSystemStreamSocket);
		hr = CreateAndInitStreamSocket(pgd); 
		if (FAILED(hr)) 
		{
			ASSERT(FALSE);
			return hr;
		}

		#if USE_RSIP
			if(pgd->sRsip != INVALID_SOCKET){

				DWORD addrlen;
				SOCKADDR_IN sockaddr_in;
				SOCKADDR_IN sockaddr_inpublic;

				addrlen=sizeof(SOCKADDR_IN);
		    	err = getsockname(pgd->sSystemStreamSocket,(LPSOCKADDR)&sockaddr_in,&addrlen);
				if (SOCKET_ERROR == err)
				{
					err = WSAGetLastError();
					DPF(0,"Startup Enum thread (RSIP) could not get socket name - err = %d\n",err);
				} else {
					hr=rsipAssignPort(pgd,1,sockaddr_in.sin_port,(LPSOCKADDR)&sockaddr_inpublic,NULL);
					if(hr==DP_OK){
						memcpy(&pgd->saddrpubSystemStreamSocket, &sockaddr_inpublic, sizeof(SOCKADDR));
					} else {
						DPF(0,"Couldn't get port assignment for system stream port\n");
						memcpy(&pgd->saddrpubSystemStreamSocket, &sockaddr_in, sizeof(SOCKADDR));
					}	
				}

			}
		#endif

		// start the enum accept thread (listen for new connections)
		if(hWS2){
		    pgd->hStreamReceiveThread = CreateThread(NULL,0,FastStreamReceiveThreadProc,		   
			(LPVOID)pISP,0,&dwThreadID);
		}else{
		    pgd->hStreamReceiveThread = CreateThread(NULL,0,StreamReceiveThreadProc,		   
			(LPVOID)pISP,0,&dwThreadID);
		}
		
		if (!pgd->hStreamReceiveThread)
		{
			DPF(0, "Failed to start stream receive thread");
			ASSERT(FALSE);
		} else SetThreadPriority(pgd->hStreamReceiveThread, THREAD_PRIORITY_ABOVE_NORMAL);
	}
	
	return DP_OK;
	
} // StartupEnumThread

/*
 *		Creates a dgram socket, sends enum sessions request, and closes socket.  
 *
 *		reply is received in streamlistenthreadproc and passed into dplay.
 */
HRESULT DoUDPEnumSessions(LPGLOBALDATA pgd, SOCKADDR *lpSockAddr, DWORD dwAddrSize,
	LPDPSP_ENUMSESSIONSDATA ped)
{
	SOCKET sSocket;
	HRESULT hr;
	BOOL bTrue=TRUE;
	UINT err;

	DEBUGPRINTADDR(5,"enum unreliable - sending to ",lpSockAddr); 
	
  	hr = CreateSocket(pgd,&sSocket,SOCK_DGRAM,0,INADDR_ANY,&err,FALSE);
	if (FAILED(hr)) 
	{
		DPF(0,"!!! enum - could not create socket error = %d\n",err);
	    return E_FAIL;
	}
    
    // enable broadcast on our socket
    if( SOCKET_ERROR == setsockopt( sSocket,SOL_SOCKET,SO_BROADCAST,(char FAR *)&bTrue,
                    sizeof(bTrue) ) )
    {
        err = WSAGetLastError();
		DPF(0,"enum - could not set broadcast err = %d\n",err);
        goto CLEANUP_EXIT;
    }

	// send out the enum message
    err = sendto(sSocket,ped->lpMessage,ped->dwMessageSize,0,lpSockAddr,dwAddrSize);
    if (SOCKET_ERROR == err) 
    {
        err = WSAGetLastError();
        DPF(0,"send error - err = %d\n",err);
        hr = E_UNEXPECTED;
    }

	// fall through

CLEANUP_EXIT:
	KillSocket(sSocket,FALSE,FALSE);
	return hr;
} // DoUDPEnumSessions

// A very short lived thread -- may hang in connect with invalid id to connect to.
DWORD WINAPI TCPEnumSessionsAsyncThread(LPVOID lpv)
{
	LPGLOBALDATA pgd=(LPGLOBALDATA) lpv;
	HRESULT hr;
	UINT err;


	
	DPF(8,"==> Entering TCPEnumSessionsAsyncThread(0x%08x)\n", lpv);
	
	pgd->sEnum = INVALID_SOCKET;

	DEBUGPRINTADDR(5,"enum reliable - sending to ",&pgd->saEnum); 
	
	// get us a new connection
	hr = CreateAndConnectSocket(pgd,&pgd->sEnum,SOCK_STREAM,&pgd->saEnum,pgd->bOutBoundOnly);
	if (FAILED(hr))
	{
		DPF(0, "Failed to get socket for enum sessions - hr: 0x%08x",hr);
		goto EXIT;
	}


	DPF(5, "Sending %u byte async TCP enum via socket 0x%x.",
		pgd->dwEnumMessageSize, pgd->sEnum);
	
	// send the request
    err = send(pgd->sEnum,pgd->lpEnumMessage,pgd->dwEnumMessageSize,0);
    if (SOCKET_ERROR == err) 
    {
        err = WSAGetLastError();
        DPF(0,"send error - err = %d\n",err);
		DEBUGPRINTADDR(0,"reliable send  - FAILED - sending to ",&pgd->saEnum);
		hr = E_FAIL;
		goto ERROR_EXIT;
		// fall through
    }

    if (!pgd->bOutBoundOnly)
    {
    	DEBUGPRINTSOCK(5,"Closing enum sessions connection - ", &pgd->sEnum);
    	// close the connection
    	KillSocket(pgd->sEnum,TRUE,FALSE);
    	pgd->sEnum=INVALID_SOCKET;
    }

	goto EXIT;
    // not a fall through

ERROR_EXIT:
	if (INVALID_SOCKET != pgd->sEnum) 	{
		KillSocket(pgd->sEnum,TRUE,FALSE);
		pgd->sEnum=INVALID_SOCKET;
	}	
EXIT:

	ENTER_DPSP();
	if(pgd->hTCPEnumAsyncThread){
		CloseHandle(pgd->hTCPEnumAsyncThread);
		pgd->hTCPEnumAsyncThread=0;
	}	
	if(pgd->lpEnumMessage){
		SP_MemFree(pgd->lpEnumMessage);
		pgd->lpEnumMessage=0;
	}
	LEAVE_DPSP();
	DPF(5,"<== Leaving TCPEnumSessionsAsyncThread\n");
	return 0;
	
} // TCPEnumSessionsAsyncThread

/*
 *		Creates a stream socket, sends enum sessions request, and closes socket 
 *		depending on bHostWillReuseConnection. If bHostWillReuseConnection is TRUE, server will
 *		close the connection after sending reply.
 *
 *		reply is received in streamlistenthreadproc and passed into dplay.
 */
HRESULT DoTCPEnumSessionsAsync(LPGLOBALDATA pgd, SOCKADDR *lpSockAddr, DWORD dwAddrSize,	
LPDPSP_ENUMSESSIONSDATA ped,BOOL bOutBoundOnly)
{
	DWORD dwJunk;
	HRESULT hr=DP_OK;

	// First see if we have a thread running already, if we do cancel it.

	KillTCPEnumAsyncThread(pgd);

	// package the request up and hand it to the thread.

	ENTER_DPSP();

	pgd->lpEnumMessage=SP_MemAlloc(ped->dwMessageSize);
	
	if(pgd->lpEnumMessage){
		memcpy(pgd->lpEnumMessage, ped->lpMessage, ped->dwMessageSize);
		pgd->dwEnumMessageSize=ped->dwMessageSize;
	} else {
		hr=DPERR_OUTOFMEMORY;
		goto EXIT;
	}

	memcpy(&pgd->saEnum,lpSockAddr,dwAddrSize);
	pgd->dwEnumAddrSize=dwAddrSize;
	pgd->bOutBoundOnly=bOutBoundOnly;
	pgd->sEnum=INVALID_SOCKET;

	if(!(pgd->hTCPEnumAsyncThread=CreateThread(NULL,0,TCPEnumSessionsAsyncThread,pgd,0,&dwJunk))){
		SP_MemFree(pgd->lpEnumMessage);
		pgd->lpEnumMessage=NULL;
		hr=DPERR_OUTOFMEMORY;
	}
	
EXIT:	
	LEAVE_DPSP();
	return hr;
}

/*
 ** EnumSessions
 *
 *  CALLED BY: DPLAY
 *
 *  PARAMETERS: ped - see dplayi.h
 *
 *  DESCRIPTION:
 *	
 *		creates a stream socket. sends a message to the address specified by the user.
 *		fills in return address so server can reply.  
 *
 *		reply is received in streamlistenthreadproc and passed into dplay.
 *
 *  RETURNS:
 *		DP_OK always.
 *
 */
HRESULT WINAPI SP_EnumSessions(LPDPSP_ENUMSESSIONSDATA ped) 
{
#ifdef DEBUG
    SOCKET sSocket; // bcast socket
#endif // DEBUG
    SOCKADDR sockaddr;
    INT addrlen=sizeof(SOCKADDR);
    HRESULT hr;
    DWORD dwErr=0;
	BOOL bTrue = TRUE;
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	BOOL bOutBoundOnly = FALSE;

	DPF(5,"SP_EnumSessions");

	// get the global data
	hr =ped->lpISP->lpVtbl->GetSPData(ped->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}
	
	// Do we have an active IP address?  If not and DUN is enabled, a DUN
	// dialog will pop for enum to a specific machine.
	// bReturnStatus means no extra dialogs are wanted so we will abort
	// if there are no local connections.
	if (ped->bReturnStatus && AF_INET == pgd->AddressFamily)
	{
		PHOSTENT phostent = GetHostAddr();
		if (!phostent || phostent->h_addr_list[0] == 0) 
		{
			DPF(0, "No Dial-up network or netcard present");
			return DPERR_NOCONNECTION;	// no local IP address = no network
		}
	}

	memset(&sockaddr,0,sizeof(sockaddr));
	// find out where we should send request to
	hr = GetServerAddress(pgd,&sockaddr);
	if (FAILED(hr))
	{
		DPF_ERR("failed to get enumeration address");
		return hr;
	}

	if (!pgd->hReplyThread)
	{
		hr = StartReplyThread(pgd);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}
	}
	
	hr = StartupEnumThread(ped->lpISP,pgd);
	if (FAILED(hr))
	{
		DPF(0," could not start enum handler - hr = 0x%08lx\n",hr);
		return hr;
	}
	
	// set message header
	SetMessageHeader(ped->lpMessage,ped->dwMessageSize,TOKEN);

	SetReturnAddress(ped->lpMessage,SERVICE_SOCKET(pgd),SERVICE_SADDR_PUBLIC(pgd));		
	
#ifdef DEBUG	
	sSocket = SERVICE_SOCKET(pgd); // we'll borrow this var for our debug spew
	DEBUGPRINTSOCK(5,"enum - return address = ",&sSocket); 
#endif // DEBUG

	hr = DoUDPEnumSessions(pgd, &sockaddr, addrlen, ped);
	if (FAILED(hr))
	{
		return hr;
	}

	// send a reliable enum sessions as well, duplicates will be filtered by dplay
	if ((pgd->AddressFamily == AF_INET) && (INADDR_BROADCAST != ((LPSOCKADDR_IN)&sockaddr)->sin_addr.s_addr))
	{				
		// poke the correct server port
		if (pgd->wApplicationPort)
		{
			// if app specified a port, let's use the mode specified
			// because we'll be enuming the app directly
			// ISSUE: FOR RSIP we need to get the full address and ask for the alias again.
			((LPSOCKADDR_IN)&sockaddr)->sin_port = htons(pgd->wApplicationPort);
			bOutBoundOnly = (pgd->dwFlags & DPSP_OUTBOUNDONLY);
		}
		else
		{
			// otherwise send enum to dplaysvr
			// see byte-order comment in dpsp.h for this constant
			((LPSOCKADDR_IN)&sockaddr)->sin_port = SERVER_STREAM_PORT;
			bOutBoundOnly = FALSE;
		}
		
		if(!pgd->hTCPEnumAsyncThread) {
			hr = DoTCPEnumSessionsAsync(pgd, &sockaddr, addrlen, ped, bOutBoundOnly);
		} else {
			DPF(2, "Not issuing reliable enum request, there is one already running.\n");
		}
	}
	
	// fall through

    DPF(5,"enum exiting");
    
    return DP_OK;

}// EnumSessions


#undef DPFSessions


#undef DPF_MODNAME
#define DPF_MODNAME	"SP_GetAddress"

// helper to handle local player address(es)
HRESULT WINAPI SP_GetAddressLocal(LPDPSP_GETADDRESSDATA pad)
{
	int i, j, count;
	HRESULT hr = DP_OK;
	PHOSTENT phostent;
	char *pszIPAddr, *pszBuf = NULL;
	WCHAR *pszIPAddrW, *pszBufW = NULL;
	LPDPCOMPOUNDADDRESSELEMENT paDPAddrEl = NULL;

	phostent = GetHostAddr();
	if (!phostent || !phostent->h_addr_list[0]) 
	{
		return DPERR_GENERIC;
	}

	// how many IP addresses do we have?
	for (count=0; phostent->h_addr_list[count]; count++) {}

	// allocate our DPAddress assembly buffers
	// ANSI and UNICODE elements for each IP address plus one SP guid
	// max size of IP address dot notation = 15 + terminator = 16
	ENTER_DPSP();
	// addressElement array
	paDPAddrEl = SP_MemAlloc(sizeof(DPCOMPOUNDADDRESSELEMENT)*(2*count + 1));
	// one big buffer each for ANSI and UNICODE strings
	pszIPAddr = pszBuf = SP_MemAlloc(16*count);
	pszIPAddrW = pszBufW = SP_MemAlloc(sizeof(WCHAR)*(16*count));
	if (!paDPAddrEl || !pszBuf || !pszBufW)
	{
		ASSERT(FALSE);
		SP_MemFree(paDPAddrEl);
		SP_MemFree(pszBuf);
		SP_MemFree(pszBufW);
		LEAVE_DPSP();
		return DPERR_NOMEMORY;
	}
	LEAVE_DPSP();
	
	// service provider chunk
	paDPAddrEl[0].guidDataType = DPAID_ServiceProvider;
	paDPAddrEl[0].dwDataSize = sizeof(GUID);
	paDPAddrEl[0].lpData = (LPVOID) &GUID_TCP;

	// make an ANSI and UNICODE string of each IP address
	for (i=0, j=1; i < count; i++)
	{
		DWORD dwStrLen;		// includes terminator
		IN_ADDR hostaddr;

		memcpy(&hostaddr, phostent->h_addr_list[i], sizeof(hostaddr));
		strcpy(pszIPAddr, inet_ntoa(hostaddr));
		dwStrLen = (DWORD)AnsiToWide(pszIPAddrW, pszIPAddr, 16);
		if (dwStrLen == 0 || dwStrLen > 16)
		{
			ASSERT(FALSE);
			hr = DPERR_GENERIC;
			goto cleanup;
		}

		paDPAddrEl[j].guidDataType = DPAID_INet;
		paDPAddrEl[j].dwDataSize = dwStrLen;
		paDPAddrEl[j++].lpData = pszIPAddr;
		paDPAddrEl[j].guidDataType = DPAID_INetW;
		paDPAddrEl[j].dwDataSize = dwStrLen * sizeof(WCHAR);
		paDPAddrEl[j++].lpData = pszIPAddrW;
		pszIPAddr += 16;	// bump buffer ptrs by max str size
		pszIPAddrW += 16;
	}

	// create the address
	hr = pad->lpISP->lpVtbl->CreateCompoundAddress(pad->lpISP,
				paDPAddrEl, 2*count+1, pad->lpAddress, pad->lpdwAddressSize);

cleanup:
	ENTER_DPSP();
	SP_MemFree(paDPAddrEl);
	SP_MemFree(pszBuf);
	SP_MemFree(pszBufW);
	LEAVE_DPSP();

	return hr;
} // SP_GetAddressLocal

// get the ip address of the player from its playerdata
// ask winsock to convert that to a hostname
HRESULT WINAPI SP_GetAddress(LPDPSP_GETADDRESSDATA pad)
{
	HRESULT hr = DP_OK;
	LPSPPLAYERDATA ppd;
	DWORD dwSize = sizeof(SPPLAYERDATA);
	LPSTR pszNetName;
	UINT nStrLen;
	LPSOCKADDR_IN psockaddr;
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	DPCOMPOUNDADDRESSELEMENT addressElements[3];
	WCHAR szNetNameW[HOST_NAME_LENGTH];

	// get the global data
	hr = pad->lpISP->lpVtbl->GetSPData(pad->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}
	

	if (AF_IPX == pgd->AddressFamily)
	{
		// not gonna happen
		return E_NOTIMPL;
	}
	
	hr = pad->lpISP->lpVtbl->GetSPPlayerData(pad->lpISP,pad->idPlayer,&ppd,&dwSize,DPGET_REMOTE);
	if (FAILED(hr))
	{
		DPF(1, "GetSPPlayerData for player %d returned err %d", pad->idPlayer, hr);
		if (hr != DPERR_INVALIDPLAYER) 	// this can happen because of race conditions
			ASSERT(FALSE);
		return hr;
	}

	#if USE_RSIP
		if (pad->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL && pgd->sRsip==INVALID_SOCKET)	
		{
			// We use a different approach for local players
			return SP_GetAddressLocal(pad);
		}
	#elif USE_NATHELP
		if (pad->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL && (!pgd->pINatHelp))	
		{
			// We use a different approach for local players
			return SP_GetAddressLocal(pad);
		}
	#else
		if (pad->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)	
		{
			// We use a different approach for local players
			return SP_GetAddressLocal(pad);
		}
	#endif
		else 
		{
			psockaddr = (LPSOCKADDR_IN)DGRAM_PSOCKADDR(ppd);
			if(psockaddr->sin_addr.s_addr == 0){
			    return SP_GetAddressLocal(pad);
			}
			pszNetName = inet_ntoa(psockaddr->sin_addr);
		}
	
	if (!pszNetName)
	{
		// rut ro
		DPF_ERR("got no string back from getaddress");
		return E_FAIL;
	}
	nStrLen = strlen(pszNetName)+1;

	DPF(2,"get address found address for player id %d = %s\n",pad->idPlayer,pszNetName);

	// get UNICODE version of address
	if (!AnsiToWide(szNetNameW, pszNetName, HOST_NAME_LENGTH))
		return (DPERR_GENERIC);

	// service provider chunk
	addressElements[0].guidDataType = DPAID_ServiceProvider;
	addressElements[0].dwDataSize = sizeof(GUID);
	addressElements[0].lpData = (LPVOID) &GUID_TCP;

	// ANSI name
	addressElements[1].guidDataType = DPAID_INet;
	addressElements[1].dwDataSize = nStrLen;
	addressElements[1].lpData = pszNetName;

	// UNICODE name
	addressElements[2].guidDataType = DPAID_INetW;
	addressElements[2].dwDataSize = nStrLen * sizeof(WCHAR);
	addressElements[2].lpData = szNetNameW;

	// create the address
	hr = pad->lpISP->lpVtbl->CreateCompoundAddress(pad->lpISP,
						addressElements, 3,
						pad->lpAddress, pad->lpdwAddressSize);

	return hr;

} // SP_GetAddress

#undef DPF_MODNAME
#define DPF_MODNAME	"Reply"
// called by ReplyThreadProc to send the reply out on the wire
HRESULT SendReply(LPGLOBALDATA pgd,LPREPLYLIST prd)
{
	HRESULT hr;
	SOCKET sSocket;
	UINT addrlen = sizeof(SOCKADDR);
	UINT err;
	BOOL bConnectionExists = FALSE;

	// now, send out prd		
	switch (pgd->AddressFamily)
    {
		case AF_INET:
		{
			DPID dpidPlayer=0;

#ifdef FULLDUPLEX_SUPPORT
			// if client wants us to reuse a connection, it would have indicated so and the connection
			// would have been added to our send list by now. See if it exists.
			
			// todo - we don't want to search the receive list everytime -  find a better way
			bConnectionExists = FindSocketInBag(pgd, &prd->sockaddr, &prd->sSocket,&dpidPlayer);
#endif // FULLDUPLEX_SUPPORT
			
			if (!bConnectionExists)
			{

				// socket didn't exist in our send list, let's send it on a new temporary connection
				
				DEBUGPRINTADDR(8,"Sending reply on a new connection to - ", &(prd->sockaddr));				

				hr = CreateSocket(pgd,&sSocket,SOCK_STREAM,0,INADDR_ANY,&err,FALSE);
				if (FAILED(hr)) 
				{
					DPF(0,"create reply socket failed - err = %d\n",err);
					return hr;
				}

				SetReturnAddress(prd->lpMessage,pgd->sSystemStreamSocket,SERVICE_SADDR_PUBLIC(pgd));		
				hr = SPConnect(&sSocket,(LPSOCKADDR)&(prd->sockaddr),addrlen,FALSE);
				if (FAILED(hr))
				{
					DEBUGPRINTADDR(0,"reply - connect failed - addr = ",(LPSOCKADDR)&(prd->sockaddr));
				}
				else 
				{
					DPF(5, "Sending %u byte reply via socket 0x%x.",
						prd->dwMessageSize, sSocket);
					DEBUGPRINTADDR(5,"Replying over new connection to - ", &(prd->sockaddr));
					
					err = send(sSocket,prd->lpMessage,prd->dwMessageSize,0);					
					if (SOCKET_ERROR == err) 
				    {
				        err = WSAGetLastError();
				        DPF(0,"reply - send error - err = %d\n",err);
						hr = E_FAIL;
				    }
				}
				
				// nuke the socket
				KillSocket(sSocket,TRUE,FALSE);
				
			}
			else
			{
				DPF(5, "Sending %u byte reply via socket 0x%x.",
					prd->dwMessageSize, prd->sSocket);
				DEBUGPRINTADDR(5, "Sending reply over existing connection to - ", &(prd->sockaddr));				

				err = send(prd->sSocket,prd->lpMessage,prd->dwMessageSize,0);					
				if (SOCKET_ERROR == err) 
				{
				       err = WSAGetLastError();
				       DPF(0,"reply - send error - err = %d\n",err);
					hr = E_FAIL;
				}

				// close the connection if it's a temporary one (no player id yet).
				if (0 == dpidPlayer)
				{
					RemoveSocketFromReceiveList(pgd,prd->sSocket);
					RemoveSocketFromBag(pgd,prd->sSocket);
				}
			}
			
			break;
		}

		case AF_IPX:
		{
			hr = CreateSocket(pgd,&sSocket,SOCK_DGRAM,0,INADDR_ANY,&err,FALSE);
			if (FAILED(hr)) 
			{
				DPF(0,"create reply socket failed - err = %d\n",err);
				return hr;
			}

			SetReturnAddress(prd->lpMessage,pgd->sSystemDGramSocket,DGRAM_SADDR_RSIP(pgd));		
    		err = sendto(sSocket,prd->lpMessage,prd->dwMessageSize,0,
				(LPSOCKADDR)&(prd->sockaddr),addrlen);
			if (SOCKET_ERROR == err) 
		    {
		        err = WSAGetLastError();
		        DPF(0,"reply - send error - err = %d\n",err);
				hr = E_FAIL;
		    }

			// nuke the socket
			KillSocket(sSocket,FALSE,FALSE);

			break;
		}
	
		default:
			hr = E_FAIL;		
			ASSERT(FALSE);
			break;
    }  
	
	return hr;
	
} // SendReply


DWORD WINAPI ReplyThreadProc(LPVOID pvCast)
{
	LPREPLYLIST prd,prdNext;
	HRESULT hr=DP_OK;
	DWORD dwRet;
	DWORD tWait;
	LPGLOBALDATA pgd = (LPGLOBALDATA) pvCast;
	
	#if (USE_RSIP || USE_NATHELP)
	DWORD tLast;
	DWORD tNow;
	#define RSIP_RENEW_TEST_INTERVAL 60000
	#endif

	#if (USE_RSIP || USE_NATHELP)
		tNow=timeGetTime();
		tLast=tNow;
	#endif

	
	while (1)
	{
	
		#if (USE_RSIP || USE_NATHELP)
		wait:
			#if USE_RSIP
			tWait=(tLast+RSIP_RENEW_TEST_INTERVAL)-tNow;
			#else
			tWait=(tLast+pgd->NatHelpCaps.dwRecommendedGetCapsInterval)-tNow;
			#endif
			if((int)tWait < 0){
				tWait=0;
			}
			ASSERT(!(tWait &0x80000000));
		#else
			tWait=INFINITE;
		#endif

		// wait on our event.  when it's set, we either split, or empty the reply list
		dwRet = WaitForSingleObject(pgd->hReplyEvent,tWait);

		#if (USE_RSIP || USE_NATHELP)
			tNow=timeGetTime();
			if(dwRet == WAIT_TIMEOUT){

				#if USE_RSIP
					if(pgd->sRsip != INVALID_SOCKET){
						rsipPortExtend(pgd, tNow);
						rsipCacheClear(pgd, tNow);
						goto wait; // back to waiting...
					} else {
						tLast=tNow;
						goto wait;
					}
				#endif	

				#if USE_NATHELP
					if(pgd->pINatHelp){
						natGetCapsUpdate(pgd);
						tLast=timeGetTime();
						goto wait; // back to waiting...
					} else {
						tLast=tNow;
						goto wait;
					}
				#endif
			}	
		#endif

		if (WAIT_OBJECT_0 != dwRet)
		{
			ASSERT(FALSE);
			goto CLEANUP_EXIT;
		}

		// shutdown?		
		if (pgd->bShutdown)
		{
			goto CLEANUP_EXIT;
		}

	Top:
		// find our reply node
		ENTER_DPSP();
		
		// take the first one off the list
		prd = pgd->pReplyList;		
		if (pgd->pReplyList) pgd->pReplyList = pgd->pReplyList->pNextReply;
		
		LEAVE_DPSP();
		
		while (prd)
		{
			hr = SendReply(pgd,prd);
			if (FAILED(hr))
			{
				DPF_ERR("SendReply failed hr = 0x%08lx\n");
				// we can't reach the guy, clean out other async sends.
				RemovePendingAsyncSends(pgd, prd->dwPlayerTo);
				goto Top;
			}
			
			// free up the reply node
			ENTER_DPSP();
				
			if (prd->lpMessage) SP_MemFree(prd->lpMessage);
			SP_MemFree(prd);

			// take the next one off the list
			prd = pgd->pReplyList;
			if (pgd->pReplyList) pgd->pReplyList = pgd->pReplyList->pNextReply;
				
			LEAVE_DPSP();
		}

	} // 1

CLEANUP_EXIT:
	
	ENTER_DPSP();

	// cleanout reply list
	prd = pgd->pReplyList;	
	while (prd)
	{
		prdNext = prd->pNextReply;
		if (prd->lpMessage) SP_MemFree(prd->lpMessage);
		SP_MemFree(prd);
		prd = prdNext;
	}
	pgd->pReplyList = NULL;
	
	CloseHandle(pgd->hReplyEvent);
	pgd->hReplyEvent = 0;
	
	LEAVE_DPSP();
	
	DPF(6,"replythreadproc exit");

	return 0;
	
}  // ReplyThreadProc

HRESULT StartReplyThread(LPGLOBALDATA pgd)
{
	HANDLE hThread;
	DWORD dwThreadID;
	
	// 1st, create the event
	pgd->hReplyEvent = CreateEvent(NULL,FALSE,FALSE,NULL);	
	if (!pgd->hReplyEvent)
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	// now, spin the thread	
	if (hWS2 && (AF_IPX != pgd->AddressFamily))
	{
	    hThread = CreateThread(NULL,0,AsyncSendThreadProc,pgd,0,&dwThreadID);	
	}
	else 
	{
	    hThread = CreateThread(NULL,0,ReplyThreadProc,pgd,0,&dwThreadID);		
	}

	if (!hThread)
	{
		ASSERT(FALSE);
		return E_FAIL;
	}
	pgd->hReplyThread = hThread;
	
	return DP_OK;
	
} // StartReplyThread

HRESULT WINAPI InternalSP_Reply(LPDPSP_REPLYDATA prd, DPID dwPlayerID)
{
    LPSOCKADDR psockaddr;
    SOCKADDR saddrlocal;
    HRESULT hr=DP_OK;
	LPMESSAGEHEADER phead;
	LPBYTE pSendBufferCopy;
	LPREPLYLIST prl,prlList;	
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;


	DPF(5, "InternalSP_Reply: Parameters: (0x%x, %u/0x%x)", prd, dwPlayerID, dwPlayerID);

	// get the global data
	hr =prd->lpISP->lpVtbl->GetSPData(prd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}
	
	if (prd->dwMessageSize > SPMAXMESSAGELEN)
	{
		ASSERT(FALSE); 
		return DPERR_SENDTOOBIG;
	}

	// check the header
	if (!prd->lpSPMessageHeader || !VALID_DPWS_MESSAGE(prd->lpSPMessageHeader))
	{
		DPF_ERR("	YIKES! Got invalid SP header - can't reply ");
		ASSERT(FALSE);
		return E_FAIL;
	}
    
	// get the address to reply to
	phead = (LPMESSAGEHEADER)prd->lpSPMessageHeader;
    psockaddr = &(phead->sockaddr);
    #if USE_RSIP
    	if(pgd->sRsip != INVALID_SOCKET){
    		hr=rsipQueryLocalAddress(pgd, TRUE, psockaddr, &saddrlocal);
    		if(hr==DP_OK){
    			DPF(7, "Found local alias for reply address\n");
    			psockaddr=&saddrlocal;
    			phead->sockaddr=saddrlocal;  // whack the rsip address into the reply address.
    		} else {
    			DPF(7,"No local alias found for reply address\n");
    		}
    	}
    	
    #elif USE_NATHELP
    	if(pgd->pINatHelp){
    		hr=IDirectPlayNATHelp_QueryAddress(
    					pgd->pINatHelp, 
						&pgd->INADDRANY,
						psockaddr, 
						&saddrlocal, 
						sizeof(SOCKADDR_IN), 
						DPNHQUERYADDRESS_TCP|DPNHQUERYADDRESS_CACHENOTFOUND);

    		if(hr==DP_OK){
    			DPF(7, "Found local alias for reply address\n");
    			psockaddr=&saddrlocal;
    			phead->sockaddr=saddrlocal;  // whack the rsip address into the reply address.
    		} else {
    			DPF(7,"No local alias found for reply address\n");
    		}
    	}
    #endif
	DEBUGPRINTADDR(5,"reply - sending to ",psockaddr);

    DPF(7,"reply - q'ing %d bytes hEvent = 0x%08lx\n",prd->dwMessageSize,pgd->hReplyEvent);

	// stick the message size in the message
	SetMessageHeader(prd->lpMessage,prd->dwMessageSize,TOKEN);

	if(hWS2 && (pgd->AddressFamily==AF_INET)){
		hr=FastReply(pgd, prd, dwPlayerID);
		return hr;
	}


	// build a copy of everything for our receive thread
	ENTER_DPSP();
	
	prl = SP_MemAlloc(sizeof(REPLYLIST));
	
	if (!prl)
	{
		LEAVE_DPSP();				
		DPF_ERR("could not send reply - out of memory");
		return E_OUTOFMEMORY;
	}

	
	pSendBufferCopy = SP_MemAlloc(prd->dwMessageSize);
	if (!pSendBufferCopy)
	{
		SP_MemFree(prl);
		LEAVE_DPSP();
		DPF_ERR("could not send reply - out of memory");
		return E_OUTOFMEMORY;
	}
	
	memcpy(pSendBufferCopy,prd->lpMessage,prd->dwMessageSize);
	
	prl->lpMessage = pSendBufferCopy;
	prl->dwMessageSize = prd->dwMessageSize;
	prl->sockaddr = *psockaddr;
	prl->sSocket = INVALID_SOCKET;
	// since are replies could be sent async, we need to keep track
	// of how many bytes have gone out
	prl->pbSend = pSendBufferCopy;
	prl->dwBytesLeft = prd->dwMessageSize;
	prl->dwPlayerTo=dwPlayerID; 	
	// put prl on the end of the reply list
	prlList = pgd->pReplyList;
	if (!prlList)
	{
		pgd->pReplyList = prl;	
	}
	else
	{
		// find the end
		while (prlList->pNextReply) prlList = prlList->pNextReply;
		ASSERT(!prlList->pNextReply);
		prlList->pNextReply = prl;
	}
	 
	// do we need to start the reply event?
	if (!pgd->hReplyThread)
	{
		hr = StartReplyThread(pgd);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}
	}
	
	LEAVE_DPSP();
		
	// tell the reply event to do its thing
	SetEvent(pgd->hReplyEvent);
	
	DPF(5, "InternalSP_Reply: Return [DP_OK]");
	
    return DP_OK;
	
}	// reply

/*
 ** Reply
 *
 *  CALLED BY: DPLAY
 *
 *  PARAMETERS: prd - see dplayi.h
 *
 *  DESCRIPTION:
 *		when one of the receive loops calls into dplay, dplay may call reply.
 *		the receive loop extracts the return address out of the message, and passes
 *		it to dplay .  dplay passes this to reply (via prd), which figures out how to send the
 *		return message.
 *		
 *
 *  RETURNS:   E_FAIL on a socket error or DP_OK.
 *
 */
HRESULT WINAPI SP_Reply(LPDPSP_REPLYDATA prd)
{
	return InternalSP_Reply(prd, 0);
}



#undef DPF_MODNAME
#define DPF_MODNAME	"StartDPHelp"

// 
// if we're starting up a nameserver, register it w/ dphelp.exe
// see %MANROOT%\misc\w95help.c and %MANROOT%\ddhelp\dphelp.c
HRESULT StartDPHelp(LPGLOBALDATA pgd, USHORT port)
{
	DWORD hpid = 0, dwFlags=0;
	HRESULT	hr;

	CreateHelperProcess( &hpid );
	
	if (!hpid)
	{
		// could't start one...
		return DPERR_UNAVAILABLE;
	}

	if (!WaitForHelperStartup())
	{
		return DPERR_UNAVAILABLE;
	}
	
	hr = HelperAddDPlayServer(port);

	return hr;

}  // StartDPHelp


//
// we've just created a player of type dwFlags. 
// if it's a system player, see if we need to start up our receive thread procs
//
HRESULT StartPlayerListenThreads(IDirectPlaySP * pISP,LPGLOBALDATA pgd,DWORD dwFlags)
{
	DWORD dwThreadID;
	HANDLE hThread;
		
	if ( !(dwFlags & DPLAYI_PLAYER_SYSPLAYER) ) return DP_OK;
	
	if (!pgd->hDGramReceiveThread)
	{
		ASSERT(INVALID_SOCKET != pgd->sSystemDGramSocket);
	    hThread = CreateThread(NULL,0,DgramListenThreadProc,
			(LPVOID)pISP,0,&dwThreadID);
		ASSERT(hThread);
		if(pgd->hDGramReceiveThread = hThread){ // check for non-zero hThread
			SetThreadPriority(hThread, THREAD_PRIORITY_ABOVE_NORMAL);
		}
		
	}
	if ( (AF_IPX != pgd->AddressFamily) && !(pgd->hStreamReceiveThread) )
	{		
		ASSERT(INVALID_SOCKET != pgd->sSystemStreamSocket);

		if(hWS2){
		    hThread = CreateThread(NULL,0,FastStreamReceiveThreadProc,		   
			(LPVOID)pISP,0,&dwThreadID);
		}else{
		    hThread = CreateThread(NULL,0,StreamReceiveThreadProc,		   
			(LPVOID)pISP,0,&dwThreadID);
		}
			
		ASSERT(hThread);		
		if(pgd->hStreamReceiveThread = hThread){ // check for non-zero hThread
			SetThreadPriority(hThread, THREAD_PRIORITY_ABOVE_NORMAL);
		}
	}

	return DP_OK;
	
} // StartPlayerListenThreads
	
// create a player.  get a stream and dgram socket for it, and start their listen threads.
HRESULT WINAPI SP_CreatePlayer(LPDPSP_CREATEPLAYERDATA pcpd) 
{
    HRESULT hr=DP_OK;
	LPSPPLAYERDATA ppd, ppdpublic;
	DWORD dwSize = sizeof(SPPLAYERDATA);
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;


	DPF(6, "SP_CreatePlayer: Parameters: (0x%x)", pcpd);

	// get the global data
	hr =pcpd->lpISP->lpVtbl->GetSPData(pcpd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

	if (!(pcpd->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
	{
		LPMESSAGEHEADER pmsg;

		hr = pcpd->lpISP->lpVtbl->GetSPPlayerData(pcpd->lpISP,pcpd->idPlayer,&ppd,&dwSize,DPGET_REMOTE);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			return hr;
		}

		if (sizeof(SPPLAYERDATA) != dwSize)
		{
			// this can happen if it's a game server supplied player
		 	DPF(6, "SP_CreatePlayer: Returning: [DP_OK] (player data size %u != %u)",
		 		sizeof(SPPLAYERDATA), dwSize);
			return DP_OK;
		}
		
		if(pcpd->cbSPDataSize < sizeof(MESSAGEHEADER))
		{
			DPF_ERR("SECURITY ERROR: SP_CreatePlayer: invalid message header size\n");
			return E_FAIL;
		}
		pmsg = (LPMESSAGEHEADER)pcpd->lpSPMessageHeader;
		if (!pmsg)
		{
			// this can happen if it's a game server supplied player
		 	DPF(6, "SP_CreatePlayer: Returning: [DP_OK] (no message header)");
			return DP_OK;
		}
		// make it multihomed.  we passed the received address w/ the createplayer message.
		// set the receive address on the player here.

		// if the ip addr wasn't set, this player hasn't been "homed" yet.
		// we set it here.
		if (AF_INET == pgd->AddressFamily)
		{
			IP_GetAddr((SOCKADDR_IN *)DGRAM_PSOCKADDR(ppd),(SOCKADDR_IN *)&(pmsg->sockaddr));
			IP_GetAddr((SOCKADDR_IN *)STREAM_PSOCKADDR(ppd),(SOCKADDR_IN *)&(pmsg->sockaddr));
			
#ifdef FULLDUPLEX_SUPPORT
			// if client want's us to reuse a connection, the socket would have been added to the 
			// send bag already, but the id would be 0. Update the player id.
			UpdateSocketPlayerID(pgd,&pmsg->sockaddr,pcpd->idPlayer);
#endif // FULLDUPLEX_SUPPORT		
		}
		else if (AF_IPX == pgd->AddressFamily) 
		{
			IPX_GetNodenum((SOCKADDR_IPX *)DGRAM_PSOCKADDR(ppd),(SOCKADDR_IPX *)&(pmsg->sockaddr));
			IPX_GetNodenum((SOCKADDR_IPX *)STREAM_PSOCKADDR(ppd),(SOCKADDR_IPX *)&(pmsg->sockaddr));
		}

		hr = GetSPPlayerData(pgd, pcpd->lpISP, pcpd->idPlayer, &ppd, &dwSize); // Force LOCAL_DATA to get set.
	 	if (hr != DP_OK)
	 	{
	 		DPF(0, "Failed setting SP player data (err = 0x%lx)!  Ignoring.", hr);
	 	}

 		DPF(6, "SP_CreatePlayer: Returning: [DPN_OK] (not local player)");
		
		return DP_OK;
	} // !Local

	// it's local, so get it some sockets + threads if we need to

	// alloc the sp player data for this player
	ENTER_DPSP();
	
	ppd = SP_MemAlloc(sizeof(SPPLAYERDATA));
	
	LEAVE_DPSP();
	
	if (!ppd) 
	{
		DPF_ERR("could not alloc player data struct");
		return E_OUTOFMEMORY;
	}

	hr =  CreatePlayerDgramSocket(pgd,ppd,pcpd->dwFlags);
	if (FAILED(hr))
	{
		DPF_ERR("could not create dgram socket"); 
		goto CLEANUP_EXIT;
	}

	if (AF_IPX != pgd->AddressFamily)
	{
		hr =  CreatePlayerStreamSocket(pgd,ppd,pcpd->dwFlags);
		if (FAILED(hr))
		{
			DPF_ERR("could not create stream socket"); 
			goto CLEANUP_EXIT;
		}
	}

	#if USE_RSIP
		if(pgd->sRsip != INVALID_SOCKET){

			SPPLAYERDATA pdpublic;
			DWORD dwBindId;

			ppdpublic=&pdpublic;
		
			// Get a public address for the datagram and stream sockets
			hr=rsipAssignPort(pgd, 
							  0, /* UDP */
							  ((SOCKADDR_IN *)&ppd->saddrDatagram)->sin_port, 
							  &ppdpublic->saddrDatagram, 
							  &dwBindId);
			if(hr!=DP_OK){
				ASSERT(FALSE);
				goto CLEANUP_EXIT;
			}

							  
			hr=rsipAssignPort(pgd, 
							  1, /* TCP */
							  ((SOCKADDR_IN *)&ppd->saddrStream)->sin_port, 
							  &ppdpublic->saddrStream, 
							  NULL);


			if(hr!=DP_OK){
				rsipFreePort(pgd, dwBindId);
				ASSERT(FALSE);
				goto CLEANUP_EXIT;
			}

			if( (((PSOCKADDR_IN)(&ppdpublic->saddrDatagram))->sin_addr.s_addr == 0) ||
			   (((PSOCKADDR_IN)(&ppdpublic->saddrStream))->sin_addr.s_addr == 0) )
			{
				// rsip server not really working (not yet dialed), so backoff to old behaviour

				// store the ppd

				DPF(0,"RSIP service present but not dialed, acting as though no RSIP present\n");
				//we actually don't want to close the connection, because there may be a host or other
				//clients on this segment that ARE registered with the RSIP agent (which still operates
				//for lookups even when the Internet connection is down).  So by keeping the RSIP
				//control channel active we can still join and play with local players that started up
				//while the NAT was connected to the internet.
				
				//rsipCloseConnection(pgd);  -- actually lets not close the connection (see above).

				goto non_rsip;
				
			} else {   


				// store the ppdpublic, these are the addresses that will go in the name table as the address of the player
				hr = pcpd->lpISP->lpVtbl->SetSPPlayerData(pcpd->lpISP,pcpd->idPlayer,ppdpublic,dwSize,DPSET_REMOTE);
				if (FAILED(hr))
				{
					ASSERT(FALSE);
					goto CLEANUP_EXIT;
				}

				// store the ppd locally so we can remember the local addresses if we need it.
				hr = pcpd->lpISP->lpVtbl->SetSPPlayerData(pcpd->lpISP,pcpd->idPlayer,ppd,dwSize,DPSET_LOCAL);
				if (FAILED(hr))
				{
					ASSERT(FALSE);
					goto CLEANUP_EXIT;
				}

				// remember these addresses for sends requiring a return address.
				memcpy(&pgd->saddrpubSystemDGramSocket, &ppdpublic->saddrDatagram, sizeof(SOCKADDR));
				memcpy(&pgd->saddrpubSystemStreamSocket, &ppdpublic->saddrStream, sizeof(SOCKADDR));
				}	
			
		} else {

	non_rsip:	
			// store the ppd
			hr = pcpd->lpISP->lpVtbl->SetSPPlayerData(pcpd->lpISP,pcpd->idPlayer,ppd,dwSize,DPSET_REMOTE);
			if (FAILED(hr))
			{
				ASSERT(FALSE);
				goto CLEANUP_EXIT;
			}
		}
		
	#elif USE_NATHELP // NOT USING RSIP

		if(pgd->pINatHelp){

			SPPLAYERDATA pdpublic;
			ppdpublic = &pdpublic;

			// in the NATHELP case the public aliases are already filled in (we might want to verify that though).
			ppdpublic->saddrStream   = pgd->saddrpubSystemStreamSocket;
			ppdpublic->saddrDatagram = pgd->saddrpubSystemDGramSocket;

			if( (((PSOCKADDR_IN)(&ppdpublic->saddrDatagram))->sin_addr.s_addr == 0) ||
			   (((PSOCKADDR_IN)(&ppdpublic->saddrStream))->sin_addr.s_addr == 0) )
			{
				// rsip server not really working (not yet dialed), so backoff to old behaviour

				// store the ppd

				DPF(0,"RSIP service present but not dialed, acting as though no RSIP present\n");
				//we actually don't want to close the connection, because there may be a host or other
				//clients on this segment that ARE registered with the RSIP agent (which still operates
				//for lookups even when the Internet connection is down).  So by keeping the RSIP
				//control channel active we can still join and play with local players that started up
				//while the NAT was connected to the internet.
				
				//rsipCloseConnection(pgd);  -- actually lets not close the connection (see above).

				goto non_nathelp;
				
			} else {	

				// store the ppdpublic, these are the addresses that will go in the name table as the address of the player
				hr = pcpd->lpISP->lpVtbl->SetSPPlayerData(pcpd->lpISP,pcpd->idPlayer,ppdpublic,dwSize,DPSET_REMOTE);
				if (FAILED(hr))
				{
					ASSERT(FALSE);
					goto CLEANUP_EXIT;
				}

				// store the ppd locally so we can remember the local addresses if we need it.
				hr = pcpd->lpISP->lpVtbl->SetSPPlayerData(pcpd->lpISP,pcpd->idPlayer,ppd,dwSize,DPSET_LOCAL);
				if (FAILED(hr))
				{
					ASSERT(FALSE);
					goto CLEANUP_EXIT;
				}
				
			}
			
		} else {
		non_nathelp:	
				// store the ppd
				hr = pcpd->lpISP->lpVtbl->SetSPPlayerData(pcpd->lpISP,pcpd->idPlayer,ppd,dwSize,DPSET_REMOTE);
				if (FAILED(hr))
				{
					ASSERT(FALSE);
					goto CLEANUP_EXIT;
				}
		}
	
	#else
	
		// store the ppd
		hr = pcpd->lpISP->lpVtbl->SetSPPlayerData(pcpd->lpISP,pcpd->idPlayer,ppd,dwSize,DPSET_REMOTE);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			goto CLEANUP_EXIT;
		}
	#endif // USE_RSIP
	
	// see if we need to start listen thread for this player type.
	hr = StartPlayerListenThreads(pcpd->lpISP,pgd,pcpd->dwFlags);
	
	// if we need ddhelp, start it up
	if ((AF_IPX != pgd->AddressFamily) && (pcpd->dwFlags & DPLAYI_PLAYER_NAMESRVR))
	{
		// it's ok to pass dgram port to dplaysvr always - we use the same number for stream
		// socket as well
	    hr = StartDPHelp(pgd,IP_DGRAM_PORT(ppd));
	    if (FAILED(hr))
	    {
			// ddhelp.exe barfed
	    	DPF_ERR(" CREATE SERVER - COULD NOT START ENUM LISTEN APPLICATION");
			DPF_ERR(" GAME WILL PLAY - BUT WILL NOT RECEIVE ENUMSESSIONS REQUESTS");
			goto CLEANUP_EXIT;
	    }
	    
		#if USE_RSIP
		//if(pgd->sRsip!=INVALID_SOCKET){
		//	rsipListenPort(pgd, FALSE, SERVER_DGRAM_PORT, NULL, &pgd->dwBindDGEnumListener);
		//}
		#endif

	}

	// fall through to clean up
CLEANUP_EXIT:	

	ENTER_DPSP();
	
	if (ppd) SP_MemFree(ppd);
	
	LEAVE_DPSP();
	
 	DPF(6, "SP_CreatePlayer: Returning: [0x%lx] (cleanup exit)", hr);
	
    return hr;

} // CreatePlayer

#undef DPF_MODNAME
#define DPF_MODNAME	"RemovePlayerFromSocketBag"
void RemovePlayerFromSocketBag(LPGLOBALDATA pgd,DWORD dwID)
{
	UINT i=0;
	BOOL bFound = FALSE;
	SOCKET sSocket=INVALID_SOCKET;
	DWORD dwSocketFlags;
	
	if (0 == dwID)
	{
		return;
	}

	ENTER_DPSP();

	// see if we've got one
	while (!bFound && (i<pgd->nSocketsInBag))
	{
		if (pgd->BagOSockets[i].dwPlayerID == dwID) 
		{
			bFound = TRUE;
			sSocket = pgd->BagOSockets[i].sSocket;			
			dwSocketFlags = pgd->BagOSockets[i].dwFlags;
			
			DPF(5,"removing socket from bag id = %d, slot = %d",dwID,i);
			pgd->BagOSockets[i].sSocket = INVALID_SOCKET;
			pgd->BagOSockets[i].dwPlayerID = 0;
		}
		else i++;
	}

	LEAVE_DPSP();
	
	if (bFound)	
	{
		if (INVALID_SOCKET == sSocket) return ;

		// if socket is fullduplex, remove it from the receive list as well
		if (dwSocketFlags & DPSP_OUTBOUNDONLY)
		{
			// this function will kill the socket as well
			RemoveSocketFromReceiveList(pgd,sSocket);
		}
		else
		{		
			KillSocket(sSocket,TRUE,FALSE);
		}
	}

	return ;
	
} // RemovePlayerFromSocketBag

HRESULT WINAPI SP_DeletePlayer(LPDPSP_DELETEPLAYERDATA pdpd) 
{
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	HRESULT hr;
	DWORD sleepcount=0;


	DPF(6, "Entering SP_DeletePlayer, player %d, flags 0x%x, lpISP 0x%08x\n",
		pdpd->idPlayer, pdpd->dwFlags, pdpd->lpISP);
	
	// get the global data
	hr =pdpd->lpISP->lpVtbl->GetSPData(pdpd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

	// give the reply list 5 seconds to clear out
	while(bAsyncSendsPending(pgd, pdpd->idPlayer)){
		Sleep(100);
		if(sleepcount++ == 50){
			break;
		}
	}

	RemovePendingAsyncSends(pgd, pdpd->idPlayer);

	// if it's not local, we don't care
	if (!(pdpd->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
	{
		if(hWS2 && pgd->AddressFamily == AF_INET){
			#if 0
			PPLAYERCONN pConn;
			LPSPPLAYERDATA ppd;
			DWORD dwSize = sizeof(SPPLAYERDATA);

			if(pdpd->dwFlags & DPLAYI_PLAYER_SYSPLAYER)
			{
				hr = GetSPPlayerData(pgd,pdpd->lpISP,pdpd->idPlayer,&ppd,&dwSize);
				
				EnterCriticalSection(&pgd->csFast);
				
				while(pConn = FindPlayerById(pgd, pdpd->idPlayer)){
					CleanPlayerConn(pgd, pConn, FALSE);
					DecRefConnExist(pgd, pConn); // dump existence ref
					DecRefConn(pgd, pConn); // dump find ref
				}
				if(hr==DP_OK){
					while(pConn=FindPlayerBySocket(pgd,&ppd->saddrStream)){
						CleanPlayerConn(pgd, pConn, FALSE);
						DecRefConnExist(pgd, pConn); // dump existence ref
						DecRefConn(pgd, pConn); // dump find ref
					}
					while(pConn=FindConnInPendingList(pgd,&ppd->saddrStream)){
						CleanPlayerConn(pgd, pConn, FALSE);
						DecRefConnExist(pgd, pConn); // dump existence ref
						DecRefConn(pgd, pConn); // dump find ref
					}
				}

				LeaveCriticalSection(&pgd->csFast);
			}
			#endif
		} else {
			RemovePlayerFromSocketBag(pgd,pdpd->idPlayer);
		}	
		return DP_OK;
	}
	
	// if it's not a sysplayer - we're done
	// if its a sysplayer, we kill 'em, cause we may need to rebind to a new port
	if (!(pdpd->dwFlags & DPLAYI_PLAYER_SYSPLAYER))
	{
		return DP_OK;
	}

	if ( (pdpd->dwFlags & DPLAYI_PLAYER_NAMESRVR)  && (AF_IPX != pgd->AddressFamily) )
	{
		USHORT port;
		LPSPPLAYERDATA ppd;
		DWORD dwSize = sizeof(SPPLAYERDATA);
		 
		// we need to get the port to to delete the server 
		//hr = pdpd->lpISP->lpVtbl->GetSPPlayerData(pdpd->lpISP,pdpd->idPlayer,&ppd,&dwSize,DPGET_REMOTE);
		hr = GetSPPlayerData(pgd,pdpd->lpISP,pdpd->idPlayer,&ppd,&dwSize);
		if ( FAILED(hr) || (sizeof(SPPLAYERDATA) != dwSize) )
		{
			ASSERT(FALSE);
		}
		else 
		{
			// tell dplaysvr to delete this server
			port = IP_DGRAM_PORT(ppd);
		    if ( !HelperDeleteDPlayServer(port) )
		    {
				// ddhelp.exe barfed
		    	DPF_ERR(" could not unregister w/ dphelp");
				// keep going...
		    }
		    #if USE_RSIP
		    	if(pgd->sRsip != INVALID_SOCKET){
		    		// NOTE: don't really need to do this since 
		    		// we only ever delete the nameserver if we are shutting
		    		// him down, and hence will close the RSIP connection releasing
		    		// all the bindings anyway
		    		//rsipFreePort(pgd, pgd->dwBindDGEnumListener);
		    	}
		    #endif
		}
	}
	
	DPF(6, "Leaving SP_DestroyPlayer, returning DPN_OK");

	return DP_OK;

} // DeletePlayer

#undef DPF_MODNAME
#define DPF_MODNAME	"UnreliableSend"
HRESULT UnreliableSend(LPDPSP_SENDDATA psd)
{
    SOCKADDR sockaddr;
    INT iAddrLen = sizeof(sockaddr);
    HRESULT hr=DP_OK;
    UINT err;
	DWORD dwSize = sizeof(SPPLAYERDATA);
	LPSPPLAYERDATA ppdTo;
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	
	// get the global data
	hr =psd->lpISP->lpVtbl->GetSPData(psd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

	if (pgd->iMaxUdpDg && (psd->dwMessageSize >= pgd->iMaxUdpDg))
	{
		return DPERR_SENDTOOBIG;
	}

	// get to address	
    if (0 == psd->idPlayerTo) 
    {
		sockaddr = pgd->saddrNS;
    }
    else
    {
		hr = GetSPPlayerData(pgd,psd->lpISP,psd->idPlayerTo,&ppdTo,&dwSize);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			return hr;
		}

		sockaddr = *(DGRAM_PSOCKADDR(ppdTo));
    }

	// put the token + size on front of the mesage
	SetMessageHeader(psd->lpMessage,psd->dwMessageSize,TOKEN);

	if (psd->bSystemMessage) 
    {
		SetReturnAddress(psd->lpMessage,SERVICE_SOCKET(pgd),SERVICE_SADDR_PUBLIC(pgd));
    } // reply
	else 
	{
		// see if we can send this message w/ no header
		// if the message is smaller than a dword, or, if it's a valid sp header (fooling us
		// on the other end, don't send any header
		if ( !((psd->dwMessageSize >= sizeof(DWORD)) &&  !(VALID_SP_MESSAGE(psd->lpMessage))) )
		{
			psd->lpMessage = (LPBYTE)psd->lpMessage +sizeof(MESSAGEHEADER);
			psd->dwMessageSize -= sizeof(MESSAGEHEADER);
		}
	}
    
	DEBUGPRINTADDR(5,"unreliable send - sending to ",&sockaddr);	

   	err = sendto(pgd->sSystemDGramSocket,psd->lpMessage,psd->dwMessageSize,0,
   		(LPSOCKADDR)&sockaddr,iAddrLen);
    if (SOCKET_ERROR == err) 
    {
        err = WSAGetLastError();
        DPF(0,"send error - err = %d, ignoring\n",err);
        hr = DP_OK; // ignore errors on datagram socket.
    }

// fall through...
    return hr;
        
} // UnreliableSend

#undef DPF_MODNAME
#define DPF_MODNAME	"GetSocketFromBag"

// see if we can find or create a connected socket in our
// bag o' sockets for player dwID
HRESULT GetSocketFromBag(LPGLOBALDATA pgd,SOCKET * psSocket, DWORD dwID,
LPSOCKADDR psockaddr)
{
	HRESULT hr;
	UINT i=0;
	BOOL bFound = FALSE;
	BOOL bTrue = TRUE;
	UINT err;
	SOCKET sSocket;
	
	DPF(8, "GetSocketFromBag for id %d",dwID);

	if (0 == dwID)
	{
		// need a real id
		return E_FAIL;
	}

	ENTER_DPSP();

	// see if we've got one	already hooked up
	while ((i < pgd->nSocketsInBag) && !bFound)
	{
		// if it's a valid socket and the id's match, use it
		if ( (INVALID_SOCKET != pgd->BagOSockets[i].sSocket) && 
			(pgd->BagOSockets[i].dwPlayerID == dwID) )
		{
			bFound = TRUE;
		}
		else i++;
	}

	LEAVE_DPSP();

	if (bFound)	
	{
		// bingo! got one
		DPF(7, "Found socket in bag for player %d",dwID);
		*psSocket = pgd->BagOSockets[i].sSocket;
		return DP_OK;
	}

	// we don't have a socket for this player, let's get a new one
	DPF(5,"adding new socket to bag for id = %d, slot = %d",dwID,i);

	// create and connect socket
	hr = CreateAndConnectSocket(pgd,&sSocket,SOCK_STREAM,psockaddr, (pgd->dwFlags & DPSP_OUTBOUNDONLY));
	if (FAILED(hr))
	{
		return hr;
	}

	// enable keepalives
    if( SOCKET_ERROR == setsockopt( sSocket,SOL_SOCKET,SO_KEEPALIVE,
		(char FAR *)&bTrue,sizeof(bTrue) ) )
    {
        err = WSAGetLastError();
		DPF(2,"create - could not turn on keepalive err = %d\n",err);
		// keep trying
    }

	hr = AddSocketToBag(pgd, sSocket, dwID, psockaddr,0);
	if (FAILED(hr))
	{
		DPF(0,"Failed to add socket to bag: hr = 0x%08x", hr);
		return hr;
	}
	DPF(7,"Created a new socket for player %d",dwID);
	
	*psSocket = sSocket ;

	return hr;
	
} // GetSocketFromBag


#undef DPF_MODNAME
#define DPF_MODNAME	"ReliableSend"

HRESULT ReliableSend(LPDPSP_SENDDATA psd)
{
    SOCKET sSocket = INVALID_SOCKET;
    SOCKADDR sockaddr;
    INT iAddrLen = sizeof(sockaddr);
    HRESULT hr;
	DWORD dwSize = sizeof(SPPLAYERDATA);
	LPSPPLAYERDATA ppdTo, ppdToPublic;
	BOOL fKillSocket = FALSE; // don't kill this socket, it's from the bago
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;

	// get the global data
	hr =psd->lpISP->lpVtbl->GetSPData(psd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

	// get player to
    if (0 == psd->idPlayerTo) 
    {
		sockaddr = pgd->saddrNS;
    }
    else
    {
		hr = GetSPPlayerData(pgd,psd->lpISP,psd->idPlayerTo,&ppdTo,&dwSize);
		if (FAILED(hr))
		{
			DPF(1, "GetSPPlayerData for player %d returned err %d", psd->idPlayerTo, hr);
			if (hr != DPERR_INVALIDPLAYER) 	// this can happen because of race conditions
				ASSERT(FALSE);
			return hr;
		}

		sockaddr = *(STREAM_PSOCKADDR(ppdTo));
    }

	if (psd->bSystemMessage) 
	{
		SetReturnAddress(psd->lpMessage,SERVICE_SOCKET(pgd),SERVICE_SADDR_PUBLIC(pgd));
	}

	// put the token + size on front of the mesage
	SetMessageHeader(psd->lpMessage,psd->dwMessageSize,TOKEN);

	DEBUGPRINTADDR(5,"reliable send - sending to ",&sockaddr);

	if(hWS2 && pgd->AddressFamily == AF_INET){

		hr = FastInternalReliableSend(pgd,psd,&sockaddr);
		
	} else {
		hr = InternalReliableSend(pgd,psd->idPlayerTo,&sockaddr, psd->lpMessage, psd->dwMessageSize);
	
	}

    return hr;
    
} // InternalReliableSend

// puts together a replynode, and calls sp_reply to do 
// an async send
HRESULT AsyncSend(LPDPSP_SENDDATA psd)
{
    SOCKADDR sockaddr;
    INT iAddrLen = sizeof(sockaddr);
    HRESULT hr;
	DWORD dwSize = sizeof(SPPLAYERDATA);
	LPSPPLAYERDATA ppdTo;
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	MESSAGEHEADER head;
	DPSP_REPLYDATA rd;
	
	// get the global data
	hr =psd->lpISP->lpVtbl->GetSPData(psd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

	// get player to
    if (0 == psd->idPlayerTo) 
    {
		sockaddr = pgd->saddrNS;
    }
    else
    {
		hr = GetSPPlayerData(pgd,psd->lpISP,psd->idPlayerTo,&ppdTo,&dwSize);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			return hr;
		}

		sockaddr = *(STREAM_PSOCKADDR(ppdTo));
    }

	// write the return address into the on the wire message
	SetReturnAddress(psd->lpMessage,SERVICE_SOCKET(pgd),SERVICE_SADDR_PUBLIC(pgd));

	// put the token + size on front of the mesage
	SetMessageHeader(psd->lpMessage,psd->dwMessageSize,TOKEN);
	
	// set up a header.  this will be passed to reply, and will tell the reply thread
	// whre to send the message
	head.sockaddr = sockaddr;
	// put our token on the front so the reply thread knows its a valid reply
	SetMessageHeader((LPDWORD)(&head),0,TOKEN); 
	
	// use SP_Reply to send this for us...
	memset(&rd,0,sizeof(rd));
	rd.lpSPMessageHeader = &head;
	rd.lpMessage = psd->lpMessage;
	rd.dwMessageSize = psd->dwMessageSize;
   	rd.lpISP = psd->lpISP;
	
	hr = InternalSP_Reply(&rd,psd->idPlayerTo);
	
	return hr;

} // AsyncSend

#ifdef SENDEX

HRESULT WINAPI SP_GetMessageQueue(LPDPSP_GETMESSAGEQUEUEDATA pgqd)
{

	LPGLOBALDATA pgd;
	DWORD        dwDataSize;
	BILINK       *pBilinkWalker;
	DWORD        dwNumMsgs = 0;
	DWORD        dwNumBytes = 0;

	LPSENDINFO lpSendInfo;
	HRESULT hr;

	hr = pgqd->lpISP->lpVtbl->GetSPData(pgqd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);

	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

	EnterCriticalSection(&pgd->csSendEx);

	if(!pgqd->idFrom && !pgqd->idTo){
		// just wants totals, I already know that!
		dwNumMsgs  = pgd->dwMessagesPending;
		dwNumBytes = pgd->dwBytesPending;
	} else {
		// gotta walk the list.
		pBilinkWalker=pgd->PendingSendQ.next;
		while(pBilinkWalker != &pgd->PendingSendQ) 
		{
			lpSendInfo=CONTAINING_RECORD(pBilinkWalker, SENDINFO, PendingSendQ);
			pBilinkWalker=pBilinkWalker->next;

			if(pgqd->idTo && pgqd->idFrom) {
			
				if(lpSendInfo->idTo==pgqd->idTo && lpSendInfo->idFrom==pgqd->idFrom){
					dwNumMsgs++;
					dwNumBytes+=lpSendInfo->dwMessageSize;
				}	
				
			} else if (pgqd->idTo){
				if(lpSendInfo->idTo==pgqd->idTo){
					dwNumMsgs++;
					dwNumBytes+=lpSendInfo->dwMessageSize;
				}	
			} else if (pgqd->idFrom) {
				if(lpSendInfo->idFrom==pgqd->idFrom){
					dwNumMsgs++;
					dwNumBytes+=lpSendInfo->dwMessageSize;
				}	
			} else {
				ASSERT(0);
			}
		}
	}

	LeaveCriticalSection(&pgd->csSendEx);

	if(pgqd->lpdwNumMsgs){
		*pgqd->lpdwNumMsgs = dwNumMsgs;
	}
	if(pgqd->lpdwNumBytes){
		*pgqd->lpdwNumBytes = dwNumBytes;
	}	
	
	
	return DP_OK;

}

HRESULT WINAPI SP_SendEx(LPDPSP_SENDEXDATA psd)
{
    HRESULT hr=DP_OK;
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	LPSENDINFO lpSendInfo;

	DPF(9,"==>SP_SendEx dwSize %d dwFlags %x", psd->dwMessageSize,psd->dwFlags);

	// get the global data
	hr =psd->lpISP->lpVtbl->GetSPData(psd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

	if (psd->dwMessageSize >= SPMAXMESSAGELEN)
	{
		return DPERR_SENDTOOBIG;
	}

	// overlapped and SPheader buffer are allocated together.
	lpSendInfo     = pgd->pSendInfoPool->Get(pgd->pSendInfoPool);
	if(!lpSendInfo){
		hr=DPERR_OUTOFMEMORY;
		DPF(0,"WSOCK: sendex couldn't allocate overlapped, out of memory!\n");
		goto EXIT;
	}

	lpSendInfo->dwFlags = 0;
	lpSendInfo->SendArray[0].buf = (CHAR *)(lpSendInfo+1);
	lpSendInfo->SendArray[0].len = sizeof(MESSAGEHEADER);

	ASSERT(psd->cBuffers < MAX_SG-1); 
	
	memcpy(&lpSendInfo->SendArray[1], psd->lpSendBuffers, psd->cBuffers*sizeof(SGBUFFER));

	if ((psd->dwFlags & DPSEND_GUARANTEE) && (AF_IPX != pgd->AddressFamily))
    {
        hr = ReliableSendEx(psd,lpSendInfo);	
		if (hr!=DPERR_PENDING && FAILED(hr)) {
			pgd->pSendInfoPool->Release(pgd->pSendInfoPool, lpSendInfo);
			DPF(0,"reliable sendex failed - error - hr = 0x%08lx\n",hr);
		}
    }
    else
    {
    	hr = UnreliableSendEx(psd,lpSendInfo);
		if (hr!=DPERR_PENDING && FAILED(hr)) {
			pgd->pSendInfoPool->Release(pgd->pSendInfoPool, lpSendInfo);
			DPF(0,"unreliable sendex failed - error -  hr = 0x%08lx\n",hr);
		}	
    }
EXIT:
	DPF(9,"<==SP_SendEx %x",hr);
    return hr;

} // send



HRESULT ReliableSendEx(LPDPSP_SENDEXDATA psd, LPSENDINFO pSendInfo)
{
    SOCKET sSocket = INVALID_SOCKET;
    SOCKADDR sockaddr;
    INT iAddrLen = sizeof(sockaddr);
    HRESULT hr;
	DWORD dwSize = sizeof(SPPLAYERDATA);
	LPSPPLAYERDATA ppdTo;
	BOOL fKillSocket = FALSE; // don't kill this socket, it's from the bago
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;

	// get the global data
	hr =psd->lpISP->lpVtbl->GetSPData(psd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

	// get player to
    if (0 == psd->idPlayerTo) 
    {
		sockaddr = pgd->saddrNS;
    }
    else
    {
		hr = GetSPPlayerData(pgd,psd->lpISP,psd->idPlayerTo,&ppdTo,&dwSize);
		if (FAILED(hr))
		{
			DPF(1, "GetSPPlayerData for player %d returned err %d", psd->idPlayerTo, hr);
			if (hr != DPERR_INVALIDPLAYER) 	// this can happen because of race conditions
				ASSERT(FALSE);
			return hr;
		}

		sockaddr = *(STREAM_PSOCKADDR(ppdTo));
    }

	if (psd->bSystemMessage) 
	{
		SetReturnAddress((pSendInfo->SendArray)[0].buf,SERVICE_SOCKET(pgd),SERVICE_SADDR_PUBLIC(pgd));
	}

	// put the token + size on front of the mesage
	SetMessageHeader((LPVOID)(pSendInfo->SendArray)[0].buf,psd->dwMessageSize+sizeof(MESSAGEHEADER),TOKEN);

	DEBUGPRINTADDR(5,"reliable send ex - sending to ",&sockaddr);

	//hr = InternalReliableSendEx(pgd,psd,pSendInfo,&sockaddr);
	hr = FastInternalReliableSendEx(pgd,psd,pSendInfo,&sockaddr);

    return hr;
    
} // ReliableSendEx

#endif //SENDEX

HRESULT InternalReliableSend(LPGLOBALDATA pgd, DPID idPlayerTo, SOCKADDR *
							lpSockAddr, LPBYTE lpMessage, DWORD dwMessageSize)
{
	HRESULT hr;
	SOCKET sSocket = INVALID_SOCKET;
	UINT err;


	DPF(6, "InternalReliableSend: Parameters: (0x%x, %u/0x%x, 0x%x, 0x%x, %u)",
		pgd, idPlayerTo, idPlayerTo, lpSockAddr, lpMessage, dwMessageSize);

	// see if we have a connection already
	hr = GetSocketFromBag(pgd,&sSocket,idPlayerTo,lpSockAddr);		
	if (SUCCEEDED(hr))
	{
		DPF(5, "Sending %u byte message via socket 0x%x from bag.",
			dwMessageSize, sSocket);
		DEBUGPRINTADDR(5, "Sending message over connection to - ", lpSockAddr);				
		
		// we do, send the message
		err = send(sSocket,lpMessage,dwMessageSize,0);
		if (SOCKET_ERROR == err) 
		{
			err = WSAGetLastError();
			// we got a socket from the bag.  send failed,
			// so we're cruising it from the bag
			DPF(0,"send error - err = %d\n",err);
			DPF(4,"send failed - removing socket from bag");
			RemovePlayerFromSocketBag(pgd,idPlayerTo);
			if(err==WSAECONNRESET || err==WSAENETRESET || err==WSAENOTCONN){
				hr=DPERR_CONNECTIONLOST;
			} else {
				hr = E_FAIL;
			}
		}
		
		goto EXIT;
	}

	// if we reach here, we don't have a connection so get a new one

	hr = CreateAndConnectSocket(pgd,&sSocket,SOCK_STREAM,lpSockAddr, (pgd->dwFlags & DPSP_OUTBOUNDONLY));
	if (FAILED(hr))
	{
		goto CLEANUP_EXIT;
	}

	
	DPF(5, "Sending %u byte message via new socket 0x%x.",
		dwMessageSize, sSocket);
	DEBUGPRINTADDR(5, "Sending message over connection to - ", lpSockAddr);				

	// send the message
	err = send(sSocket,lpMessage,dwMessageSize,0);
	if (SOCKET_ERROR == err) 
	{
		err = WSAGetLastError();
		DPF(0,"send error - err = %d\n",err);
		if(err == WSAECONNRESET || err==WSAENETRESET || err==WSAENOTCONN){
			hr = DPERR_CONNECTIONLOST;
		} else {
			hr = E_FAIL;
		}	
		goto CLEANUP_EXIT;
	}

	// success
	hr = DP_OK;

	// fall through

	
CLEANUP_EXIT:

	// if we are in outbound only mode, receiver will close the connection, so don't bother
	if ((INVALID_SOCKET != sSocket) && !(pgd->dwFlags & DPSP_OUTBOUNDONLY))
	{
		KillSocket(sSocket, TRUE, FALSE);
	}

	// fall through


EXIT:
	
 	DPF(6, "InternalReliableSend: Returning: [0x%lx]", hr);
	
	return hr;
}

// called when a to player can't be reached or is deleted.
VOID RemovePendingAsyncSends(LPGLOBALDATA pgd, DPID dwPlayerTo)
{
	LPREPLYLIST prl, prlPrev;
	#ifdef DEBUG
	DWORD dwBlowAwayCount=0;
	#endif
	if(!dwPlayerTo){
		return;
	}
	
	ENTER_DPSP();
	
	prlPrev = (LPREPLYLIST)(&pgd->pReplyList); // HACKHACK, treat struct as dummy node.
	prl     = pgd->pReplyList;
	
	while(prl){
		if(prl->dwPlayerTo == dwPlayerTo){
			prlPrev->pNextReply=prl->pNextReply;
			
			if(prl->sSocket != INVALID_SOCKET){
				KillSocket(prl->sSocket,TRUE,TRUE);
			}
			if(prl->lpMessage) {
				SP_MemFree(prl->lpMessage);
			}	
			SP_MemFree(prl);
			#ifdef DEBUG
			dwBlowAwayCount++;
			#endif
		} else {
			prlPrev=prl;
		}	
		prl=prlPrev->pNextReply;
		
	}
	DPF(4,"RemovePendingAsyncSends for player %x, blew away %d pending sends\n",dwPlayerTo,dwBlowAwayCount);
	LEAVE_DPSP();
}

// In order to ensure send ordering even if we are doing async sends, we 
// check and wait for any pending async sends to complete.  If they don't complete
// in 5 seconds then we make the send async.
BOOL bAsyncSendsPending(LPGLOBALDATA pgd, DPID dwPlayerTo)
{
	LPREPLYLIST prlList;

	if(!dwPlayerTo){
		return FALSE;
	}
	ENTER_DPSP();
	prlList = pgd->pReplyList;
	while(prlList){
		if(prlList->dwPlayerTo == dwPlayerTo){
			LEAVE_DPSP();
			return TRUE;
		}
		prlList=prlList->pNextReply;
	}
	LEAVE_DPSP()
	return FALSE;
}


HRESULT WINAPI SP_Send(LPDPSP_SENDDATA psd)
{
    HRESULT hr=DP_OK;
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;

	// get the global data
	hr =psd->lpISP->lpVtbl->GetSPData(psd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

	if (psd->dwMessageSize >= SPMAXMESSAGELEN)
	{
		return DPERR_SENDTOOBIG;
	}

	if ((psd->dwFlags & DPSEND_GUARANTEE) && (AF_IPX != pgd->AddressFamily))
    {

		if(hWS2){
			// Fast Path...
			hr = ReliableSend(psd);
		} else 

		if (psd->dwFlags & DPSEND_ASYNC) hr = AsyncSend(psd);
        else {
        	if(bAsyncSendsPending(pgd, psd->idPlayerTo)){
        		hr = AsyncSend(psd);
        	} else {
	        	hr = ReliableSend(psd);	
	        }	
        }
        if (FAILED(hr)) DPF(0,"reliable send failed - error - hr = 0x%08lx\n",hr);
    }
    else
    {
    	hr = UnreliableSend(psd);
		if (FAILED(hr)) DPF(0,"unreliable send failed - error -  hr = 0x%08lx\n",hr);
    }

    return hr;

} // send


#ifdef SENDEX
HRESULT InitGlobalsInPlace(LPGLOBALDATA pgd)
{
	InitBilink(&pgd->PendingSendQ);
	InitBilink(&pgd->ReadyToSendQ);
	pgd->dwBytesPending=0;	
	pgd->dwMessagesPending=0;
	// Initialize the pool for send headers and overlapped stucts
	pgd->pSendInfoPool=FPM_Init(sizeof(SENDINFO)+sizeof(MESSAGEHEADER),NULL,NULL,NULL);
	
	if(!pgd->pSendInfoPool){
		goto ERROR_EXIT;
	}
	
	InitializeCriticalSection(&pgd->csSendEx);

	return DP_OK;
	
ERROR_EXIT:
	return DPERR_NOMEMORY;
}
#endif

void KillTCPEnumAsyncThread(LPGLOBALDATA pgd)
{
	HANDLE hTCPEnumAsyncThread;
	DWORD SleepCount=0;

	ENTER_DPSP();

	if(pgd->hTCPEnumAsyncThread){
	
		DPF(8,"Killing Running Async TCP enum thread\n");
		//hTCPEnumAsyncThread is 0, thread knows we are 
		//waiting for thread to finish, so we own closing 
		// the handle.
		hTCPEnumAsyncThread=pgd->hTCPEnumAsyncThread;
		pgd->hTCPEnumAsyncThread=0;

		// We need to close the socket out from under the
		// TCPEnum thread in order to have it continue and
		// exit.  So make sure the socket has been allocated
		// first, but don't wait if the thread has exited 
		// already (which is why we check lpEnumMessage.)
		while(pgd->sEnum==INVALID_SOCKET && pgd->lpEnumMessage){
			LEAVE_DPSP();
			Sleep(500);	
			ENTER_DPSP();
			if(SleepCount++ > 10 )break; // don't wait more than 5 seconds.
		}

		if(pgd->sEnum!=INVALID_SOCKET){
			if(pgd->bOutBoundOnly){
				RemoveSocketFromReceiveList(pgd,pgd->sEnum);
			} else {
				closesocket(pgd->sEnum);
			}
		}	
		LEAVE_DPSP();
		
		WaitForSingleObject(hTCPEnumAsyncThread,150*1000);
		CloseHandle(hTCPEnumAsyncThread);
		
		DPF(8,"Async enum thread is dead.\n");
	} else {
		LEAVE_DPSP();
	}	
}		

void InitGlobals(LPGLOBALDATA pgd)
{
	DPF(8, "InitGlobals: Parameters: (0x%x)", pgd);
	
	if(pgd->hTCPEnumAsyncThread){
		KillTCPEnumAsyncThread(pgd);
	}

	if(pgd->bFastSock){
		FastSockFini(pgd);
	}	

	ENTER_DPSP();

	if (pgd->BagOSockets)	
	{
		SP_MemFree(pgd->BagOSockets);
	}
	
	if (pgd->ReceiveList.pConnection)
	{
		 SP_MemFree(pgd->ReceiveList.pConnection);
	}

	if (pgd->readfds.pfdbigset)
	{
		 SP_MemFree(pgd->readfds.pfdbigset);
	}
	
#ifdef SENDEX	
	if(pgd->bSendThreadRunning){
		pgd->bStopSendThread=TRUE;
		SetEvent(pgd->hSendWait);
	}
	while(pgd->bSendThreadRunning){
		Sleep(0);
	}
	if(pgd->hSendWait){
		CloseHandle(pgd->hSendWait);
		pgd->hSendWait=NULL;
	}
	if(pgd->pSendInfoPool){
		pgd->pSendInfoPool->Fini(pgd->pSendInfoPool,0);
		DeleteCriticalSection(&pgd->csSendEx);
		//pgd->pSendInfoPool=NULL; //by memset below.
	}
#endif
	// set global data to 0	
	memset(pgd,0,sizeof(GLOBALDATA));

	// uses INVALID_SOCKET, not 0, to indicate bogus socket
	pgd->sSystemDGramSocket= INVALID_SOCKET;
	pgd->sSystemStreamSocket= INVALID_SOCKET;
#if USE_RSIP
	pgd->sRsip = INVALID_SOCKET;
#endif
#if USE_NATHELP
	pgd->pINatHelp = NULL;
#endif
#ifdef BIGMESSAGEDEFENSE
	pgd->dwMaxMessageSize = SPMAXMESSAGELEN;
#endif
	pgd->uEnumAddress = 0;

	LEAVE_DPSP();

	DPF(8, "InitGlobals: Leave");
} // InitGlobals

HRESULT WaitForThread(HANDLE hThread)
{
	DWORD dwRet;
	
	if (!hThread) return DP_OK;
	
	// we assume the thread has been told to go away
	// we wait for it to do so
	dwRet = WaitForSingleObject(hThread,INFINITE);
	if (WAIT_OBJECT_0 != dwRet)
	{
		ASSERT(FALSE);
		return E_FAIL;
	}
	
	CloseHandle(hThread);
	
	return DP_OK;
} // WaitForThread

HRESULT WINAPI SP_Shutdown(LPDPSP_SHUTDOWNDATA psd) 
{
	UINT err;
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	HRESULT hr;
	DPSP_CLOSEDATA cd;
	BOOL bFree;
	
	DPF(2," dpwsock - got shutdown!!\n");

	// get the global data
	hr = psd->lpISP->lpVtbl->GetSPData(psd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

#if USE_RSIP
	// Shutdown rsip channel, to save time...
	if(pgd->AddressFamily == AF_INET){
		rsipFini(pgd);
	}	
#endif
#if USE_NATHELP
	// Shutdown nat helper
	if(pgd->AddressFamily == AF_INET){
		natFini(pgd);
	}	
#endif
	
	// call close
	cd.lpISP = psd->lpISP;
	hr = SP_Close(&cd);
	if (FAILED(hr))
	{
		DPF(0," shutdown - could not close SP hr = 0x%08lx\n",hr);
		ASSERT(FALSE);
		// rut roh!  - keep trying
	}

	// reset everything...
	InitGlobals(pgd);

	DPF(2,"shutdown, calling WSACleanup");
	// it's ok to call this for each idirectplaysp that goes away, since
	// we called WSAStartup once for each one at SPInit
    if ( SOCKET_ERROR == WSACleanup()) 
    {
		err = WSAGetLastError();
    	DPF(0,"could not stop winsock err = %d\n",err);
		// keep trying...
    }

	// if we have a winsock2, free it 
	if (hWS2)
	{
		bFree = FreeLibrary(hWS2);
		if (!bFree)
		{
			DWORD dwError = GetLastError();
			DPF(0,"SP_Shutdown - could not free ws2 library - error = %d\n",dwError);
			// keep trying
		}
		hWS2 = NULL;
	}
	

	gdwDPlaySPRefCount--;

	DPF(2,"shutdown leaving");
	return DP_OK;
	
} //Shutdown

// sp only sets fields it cares about
HRESULT WINAPI SP_GetCaps(LPDPSP_GETCAPSDATA pcd) 
{
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	HRESULT hr;

	DPF(5,"SP_GetCaps");
	
	// get the global data
	hr =pcd->lpISP->lpVtbl->GetSPData(pcd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

	if (AF_IPX == pgd->AddressFamily)
	{
		// IPX
		pcd->lpCaps->dwHeaderLength = sizeof(MESSAGEHEADER);
		pcd->lpCaps->dwMaxBufferSize = IPX_MAX_DGRAM;
	}
	// else, they want AF_INET
	else 
	{
		// AF_INET optimizes guaranteed
		pcd->lpCaps->dwFlags |= DPCAPS_GUARANTEEDOPTIMIZED;
		
		if (pcd->dwFlags & DPGETCAPS_GUARANTEED)
		{
			// TCP
			pcd->lpCaps->dwHeaderLength = sizeof(MESSAGEHEADER);
			pcd->lpCaps->dwMaxBufferSize = SPMAXMESSAGELEN -sizeof(MESSAGEHEADER);
			pcd->lpCaps->dwMaxPlayers = pgd->nSocketsInBag;
		}
		else 
		{
			// UDP
			pcd->lpCaps->dwHeaderLength = sizeof(MESSAGEHEADER);
			pcd->lpCaps->dwMaxBufferSize = pgd->iMaxUdpDg-sizeof(MESSAGEHEADER);
		}
	}

	// set async caps flags
	if(pgd->bSendThreadRunning){
		// we are supporting async.
		pcd->lpCaps->dwFlags |= (DPCAPS_ASYNCSUPPORTED);
	}
	
	// set the timeout
	if(pcd->idPlayer){
		// we don't track player latency, so say we don't know and
		// give higher level stuff a chance to make a guess
		pcd->lpCaps->dwLatency = 0;
	} else {
		pcd->lpCaps->dwLatency = pgd->dwLatency;
	}	
	pcd->lpCaps->dwTimeout = SPTIMEOUT(pcd->lpCaps->dwLatency);

	return DP_OK;

} // SP_GetCaps

HRESULT WINAPI SP_Open(LPDPSP_OPENDATA pod) 
{
	LPMESSAGEHEADER phead;
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	HRESULT hr;
	
	DPF(5, "SP_Open: Parameters: (0x%x)", pod);

	// get the global data
	hr =pod->lpISP->lpVtbl->GetSPData(pod->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

	// do we have a TCP connection?
	if (AF_INET == pgd->AddressFamily)
	{
		PHOSTENT phostent = GetHostAddr();
		if (!phostent || phostent->h_addr_list[0] == 0) 
		{
			DPF(0, "No Dial-up network or netcard present");
			return DPERR_NOCONNECTION;	// no local IP address = no network
		}
	}

	// remember session information so we know if we need to turn off nagling
	pgd->dwSessionFlags = pod->dwSessionFlags;

	if (pod->dwOpenFlags & DPOPEN_CREATE)
	{
		// host should never go into this mode
		pgd->dwFlags &= ~(DPSP_OUTBOUNDONLY);
	}
	if (!pgd->hReplyThread)
	{
		hr = StartReplyThread(pgd);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}
	}

	if (pod->bCreate) 
		return DP_OK; // all done

	phead =  (LPMESSAGEHEADER)pod->lpSPMessageHeader;
	// get name server address out of phead, stores it in pgd->saddrNS
	pgd->saddrNS = phead->sockaddr;

	#if USE_RSIP
		// Get local alias for the name server (if it has one).
		if(pgd->sRsip!=INVALID_SOCKET){
        	SOCKADDR saddr;

        	hr=rsipQueryLocalAddress(pgd, TRUE, &pgd->saddrNS, &saddr);
        	if(hr==DP_OK){
        		DEBUGPRINTADDR(7, "Name Servers Socket is ",&pgd->saddrNS);
        		DEBUGPRINTADDR(7, "Got Local Alias for name server socket ",&saddr);
        		memcpy(&pgd->saddrNS, &saddr, sizeof(SOCKADDR));
        	} else {
        		DEBUGPRINTADDR(7, "Name Servers Socket has no local alias and is ",&pgd->saddrNS);
        	}
        }
    #endif    
    #if USE_NATHELP
		// Get local alias for the name server (if it has one).
		if(pgd->pINatHelp){
        	SOCKADDR saddr;
        	
			hr=IDirectPlayNATHelp_QueryAddress(
				pgd->pINatHelp, 
				&pgd->INADDRANY, 
				&pgd->saddrNS, 
				&saddr, 
				sizeof(SOCKADDR_IN), 
				DPNHQUERYADDRESS_TCP|DPNHQUERYADDRESS_CACHENOTFOUND
				);
			
        	if(hr==DP_OK){
        		DEBUGPRINTADDR(7, "Name Servers Socket is ",&pgd->saddrNS);
        		DEBUGPRINTADDR(7, "Got Local Alias for name server socket ",&saddr);
        		memcpy(&pgd->saddrNS, &saddr, sizeof(SOCKADDR));
        	} else {
        		DEBUGPRINTADDR(7, "Name Servers Socket has no local alias and is ",&pgd->saddrNS);
        	}
        }
    #endif

	// make sure we have a thread running to get the nametable
	hr = StartupEnumThread(pod->lpISP,pgd);
	if (FAILED(hr))
	{
		DPF(0," could not start open threads - hr = 0x%08lx\n",hr);
		return hr;
	}
	
	DPF(5, "SP_Open: Returning [DP_OK]");
	
	return DP_OK;

} // SP_Open


#ifdef DEBUG
// make sure there are no connected sockets left in the bug
void VerifySocketBagIsEmpty(LPGLOBALDATA pgd)
{
	UINT i=0;

	while (i < pgd->nSocketsInBag)
	{
		if (INVALID_SOCKET != pgd->BagOSockets[i].sSocket) 
		{
			DPF_ERR("socket bag not empty at close!");
			ASSERT(FALSE);
		}
		i++;
	}

} // VerifySocketBagIsEmpty
#endif // DEBUG

HRESULT WINAPI SP_Close(LPDPSP_CLOSEDATA pcd)
{
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	HRESULT hr;
	DWORD sleepcount=0;

	
	DPF(2, "SP_Close: Parameters (0x%x)", pcd);
	
	// get the global data
	hr =pcd->lpISP->lpVtbl->GetSPData(pcd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}


	// Stop asynchronous TCP enumeration thread if it's running
	KillTCPEnumAsyncThread(pgd);


	// give the reply list 5 seconds to clear out
	while(pgd->pReplyList){
		Sleep(100);
		if(sleepcount++ == 50){
			break;
		}
	}


	// reset the nameserver address
	memset(&(pgd->saddrNS),0,sizeof(SOCKADDR));

	pgd->bShutdown = TRUE;

	if(pgd->bFastSock){
		FastSockCleanConnList(pgd);
	}	

	
	DPF(2,"close, datagram sockets");
	
	KillSocket(pgd->sSystemDGramSocket,FALSE,TRUE);
	pgd->sSystemDGramSocket = INVALID_SOCKET;



	DPF(2,"Waiting for stream receive thread");

	WaitForThread(pgd->hStreamReceiveThread);
	pgd->hStreamReceiveThread = NULL;



	DPF(2,"close stream socket");

	if(pgd->sSystemStreamSocket != INVALID_SOCKET)
	{
		closesocket(pgd->sSystemStreamSocket);
		pgd->sSystemStreamSocket = INVALID_SOCKET;
		pgd->SystemStreamPort = 0;
	}
	//pgd->SystemStreamPortOut = 0;



	DPF(2,"close, waiting on threads");

	// signal the reply thread
	if (pgd->hReplyEvent)
	{
		SetEvent(pgd->hReplyEvent);
	}

	WaitForThread(pgd->hDGramReceiveThread);
	pgd->hDGramReceiveThread = NULL;
	
	WaitForThread(pgd->hReplyThread);
	pgd->hReplyThread = NULL;

	// if it was ipx, and the nameserver has migrated to us, we may have a spare thread 
	// we need to make sure is gone
	if (AF_IPX == pgd->AddressFamily) 
	{
		WaitForThread(pgd->hIPXSpareThread);	
		pgd->hIPXSpareThread = NULL;
	}
	
	pgd->bShutdown = FALSE;
	
#ifdef DEBUG	
	// verify that the bag o' sockets is really empty
	VerifySocketBagIsEmpty(pgd);
#endif 

	while(pgd->dwMessagesPending){
		DPF(0,"Waiting for pending messages to complete\n");
		Sleep(55);
	}

	// moved above...
	//if(pgd->bFastSock){
	//	FastSockCleanConnList(pgd);
	//}	
	
	DPF(5, "SP_Close: Returning [DP_OK]");

	return DP_OK;

} // SP_Close

#ifdef FIND_IP
//
// we get the ip addr of our host.  this is for debug purposes only.
// we never use the ip addr of our host, since it may be multihomed.
// the receiving system assigns our players their ip addresses
HRESULT DebugFindIPAddresses(void)
{
	PHOSTENT phostent;
	IN_ADDR hostaddr;
	int i;

	phostent = GetHostAddr();
	if (NULL == phostent) 
	{
		return E_FAIL;
	}
	DPF(0,"dpwsock - running on host name %s\n",phostent->h_name);

	i=0;
	while (phostent->h_addr_list[i])
	{
		memcpy(&hostaddr,phostent->h_addr_list[i],sizeof(hostaddr));
		DPF(0,"sp - found host addr = %s \n",inet_ntoa(hostaddr));
		i++;
	}

	return DP_OK;

} // DebugFindIPAddresses

#endif  // FIND_IP


/*
 * EnumConnectionData
 *
 * Search for valid connection data
 */

BOOL FAR PASCAL EnumConnectionData(REFGUID lpguidDataType, DWORD dwDataSize,
							LPCVOID lpData, LPVOID lpContext)
{
	LPGLOBALDATA pgd = (LPGLOBALDATA) lpContext;
	
	// this is an ANSI internet address
	if (IsEqualGUID(lpguidDataType, &DPAID_INet))
	{
		// make sure there is room (for terminating null too)
		if (dwDataSize > ADDR_BUFFER_SIZE)
			dwDataSize = (ADDR_BUFFER_SIZE - 1);

		// copy string for use later
		memcpy(pgd->szServerAddress, lpData, dwDataSize);

		pgd->bHaveServerAddress = TRUE;		// we have a server address
	}
	// this is a UNICODE internet address
	else if (IsEqualGUID(lpguidDataType, &DPAID_INetW))
	{
		if (WideToAnsi(pgd->szServerAddress, (LPWSTR) lpData, ADDR_BUFFER_SIZE))
			pgd->bHaveServerAddress = TRUE;	// we have a server address
	}
	else if (IsEqualGUID(lpguidDataType, &DPAID_INetPort))
	{
		pgd->wApplicationPort = *(LPWORD)lpData;
		DPF(5, "Application port specified in dp address: %d",pgd->wApplicationPort);
	}
	
#ifdef BIGMESSAGEDEFENSE
	else if (IsEqualGUID(lpguidDataType, &DPAID_MaxMessageSize))
	{
		pgd->dwMaxMessageSize = *(LPDWORD)lpData;
		ASSERT(pgd->dwMaxMessageSize > 11);	// set an arbitrary minimum
		if (pgd->dwMaxMessageSize < 12)
			pgd->dwMaxMessageSize = 12;
		DPF(5, "Max message size specified in dp address: %d",pgd->dwMaxMessageSize);
		pgd->dwMaxMessageSize += sizeof(MESSAGEHEADER);	// add a little extra for the shop
	}
#endif

	return TRUE;

} // EnumConnectionData

// nSockets was passed into spinit as dwReserved2
HRESULT InitBagOSockets(LPGLOBALDATA pgd,DWORD nSockets)
{
	UINT i;

	ENTER_DPSP();
		
	if (0 == nSockets)
	{
		pgd->nSocketsInBag = MAX_CONNECTED_SOCKETS;
	}
	else 
	{
		pgd->nSocketsInBag = nSockets;
	}
	
	pgd->BagOSockets = SP_MemAlloc(pgd->nSocketsInBag * sizeof(PLAYERSOCK));
	
	LEAVE_DPSP();
	
	if (!pgd->BagOSockets)
	{
		pgd->nSocketsInBag = 0;
		DPF_ERR("could not alloc space for socket cache - out of memory");
		return E_OUTOFMEMORY; 
	}
	
	for (i=0;i<pgd->nSocketsInBag;i++ )
	{
		pgd->BagOSockets[i].sSocket = INVALID_SOCKET;
	}
	
	return DP_OK ;
} // InitBagOSockets

// CheckIPXInstall
// 		on win 95 gold
// 		go to control panel / network
// 		select your net card / properties
// 		select bindings tab.  unbind ipx.
// 		socket(...) call succeeds, but sendto(...) hangs.
// 		we check here that the sa_nodenum is not 0,0,0,0,0,0
// 		if it is, we will hang later, so we fail.  andyco.
//
HRESULT CheckIPXInstall(SOCKET sSocket)
{
	int cbOpt;
	UINT err;
	IPX_ADDRESS_DATA  IpxData;
  	char pSixZeros[6];
	
	if (INVALID_SOCKET == sSocket)
	{
		return E_FAIL;		
	}

	// go ask the driver for our ipx address
   	memset( &IpxData, 0, sizeof(IpxData));
	cbOpt = sizeof( IpxData );
	err = getsockopt( sSocket, NSPROTO_IPX, IPX_ADDRESS,
               (char*) &IpxData, &cbOpt );
	if (SOCKET_ERROR == err)
	{
		err = WSAGetLastError();
		DPF(0," could not test ipx getopt - err = %d\n",err);
		return E_FAIL;
	}
	
	// see if it's 0
	memset(pSixZeros,0,6*sizeof(char));	
	if (0 == memcmp(pSixZeros,&(IpxData.nodenum),6))
	{
		DPF_ERR("found invalid IPX install!");
		DPF_ERR("IPX has been improperly un-installed by unbinding from net adaptor");
		return E_FAIL;
	}
	
	return DP_OK;

} // CheckIPXInstall

// main entry point for service provider
// sp should fill in callbacks (pSD->lpCB) and do init stuff here
HRESULT WINAPI SPInit(LPSPINITDATA pSD) 
{
    HRESULT hr;
	UINT err;
	GLOBALDATA gd,*pgd;
	UINT dwSize;
	SOCKET sVerifySocket; // used to verify support for the requested address family
						  // so, if they ask for ipx, and it's not installed, we fail here 
	WORD wVersion;
	OSVERSIONINFO osInfo;
	HANDLE hAlertThread;

	// initialize global data
	memset(&gd,0,sizeof(gd));
	InitGlobals(&gd);

	ASSERT(pSD->lpGuid);
	if (IsEqualIID(pSD->lpGuid,&GUID_IPX))
	{
		DPF(0,"---------------- DPWSOCK -- RUNNING IPX -------------");
		gd.AddressFamily = AF_IPX;		
	}
	else 
	{
		if (IsEqualIID(pSD->lpGuid,&GUID_LOCAL_TCP))
		{
			gd.uEnumAddress = INADDR_BROADCAST;
			DPF(0," ** DPWSOCK -- RUNNING LOCAL TCP / IP ** ");			
		}
		else 
		{
			DPF(0," ** DPWSOCK -- RUNNING INTERNET TCP / IP ** ");
		}

		gd.AddressFamily = AF_INET;			
	}
	
	// find out what os we are running on
	memset(&osInfo,0,sizeof(osInfo));
	osInfo.dwOSVersionInfoSize = sizeof(osInfo);
	if (!GetVersionEx(&osInfo)) 
	{
		err = GetLastError();
		DPF(0,"Failed to get OS information - err = %d\n", err);
		return DPERR_GENERIC;
	}	

	DPF(0,"SPInit: Running on OS Version: %d.%d.%d\n",osInfo.dwMajorVersion, osInfo.dwMinorVersion, osInfo.dwBuildNumber&0xFFFF);

	if( (osInfo.dwMajorVersion < 4) || (osInfo.dwMajorVersion==4 && osInfo.dwMinorVersion < 90) ){
		// Win2K        5.0.2195
		// Millennium  	4.90.2xxx
		// Win98 Gold 	4.10.1998
		// Win98 SE		4.10.2222
		// not on Millennium or Win2K, so workaround sockets bug.  Use separate sockets
		// for outbound and inbound connections.
		DPF(0,"DETECTED platform before Millennium or Win2K, using separate inbound/outbound Sockets\n");
		gd.bSeparateIO=TRUE;
	}

	// I/O on just one port was NOT working, too late to fix for DX8 (ao-10/25/00), force to 2 port IO.
	// Failure was during simulataneous connect process, found on Millennium 8 player launch from zone.
	gd.bSeparateIO=TRUE; 

	// start up sockets
	if (gwsaData.wVersion)
	{
		// note - there is a bug in winsock 1.1.  if you've called WSAStartup 1x in a process,
		// then if any subsequent call asks for a version # > then that returned to the first
		// call, we get WSAEVERNOTSUPPORTED.  So, if we've already got a version in the wsadata,
		// we make sure to use that
		wVersion = gwsaData.wVersion;
		
	}
	// otherwise, ask for winsock 2.0
	else 
	{
		// if we are trying to initialize IPX on a non-NT platform, don't look for Winsock 2.0
		// Only look for Winsock 1.1 as Winsock 2.0 functionality is not supported for IPX on
		// Memphis and Win'95.
		if ((AF_IPX == gd.AddressFamily) && (VER_PLATFORM_WIN32_NT != osInfo.dwPlatformId))
			wVersion = MAKEWORD(1,1);
		else
			wVersion = MAKEWORD(2,0);
	}
	
    err = WSAStartup(wVersion, &gwsaData);
	if (WSAVERNOTSUPPORTED == err)
	{
		// they (the app) must have already called WSAStartup.  see note above 
		// about winsock 1.1 bug.
		wVersion = MAKEWORD(1,1);
	    err = WSAStartup(wVersion, &gwsaData);
	}
	if (err) 
	{
        DPF(0,"could not start winsock err = %d\n",err);
        return E_FAIL;
    }

	DPF(1,"spinit - name = %ls,dwReserved1 = %d,dwReserved2 = %d\n",pSD->lpszName,
		pSD->dwReserved1,pSD->dwReserved2);		

	gd.iMaxUdpDg = gwsaData.iMaxUdpDg;

	DPF(0,"detected winsock version %d.%d\n",LOBYTE(gwsaData.wVersion),HIBYTE(gwsaData.wVersion));	
	if (LOBYTE(gwsaData.wVersion) >= 2)
	{
		hr = InitWinsock2();
		if (FAILED(hr))
		{
			DPF_ERR("detected winsock 2, but could not init it! yikes!");
			ASSERT(FALSE);
		}
	}

	DPF(1,"\nspinit - setting latency to %d\n\n", pSD->dwReserved1);
	gd.dwLatency = pSD->dwReserved1;
	
	hr = InitBagOSockets(&gd,pSD->dwReserved2);	
	if (FAILED(hr))
	{
		DPF_ERR("could not init socket cache. bailing");
		goto ERROR_EXIT;
	}
				
	// make sure support exists for address family
    hr = CreateSocket(&gd,&sVerifySocket,SOCK_DGRAM,0,INADDR_ANY,&err,FALSE);
	if (FAILED(hr)) 
	{
		DPF(0,"	COULD NOT CREATE SOCKET IN REQUESTED ADDRESS FAMILY af = %d, err = %d\n",gd.AddressFamily,err);
		DPF(0," SERVICE PROVIDER INITIALIZATION FAILED");
		// return the same error as the modem service provider
		hr = DPERR_UNAVAILABLE;
		goto ERROR_EXIT;
	}

	if (LOBYTE(gwsaData.wVersion) >= 2)
	{
		// get max udp buffer size through getsockopt because
		// WSAStartup doesn't return this info from winsock 2.0 onwards.
		hr = GetMaxUdpBufferSize(sVerifySocket, &gd.iMaxUdpDg);
		if (FAILED(hr))
		{
			DPF(0,"Failed to get max udp buffer size");
			// since memphis still returns this value in WSAStartup
			// use it. This is just a workaround for memphis bug #43655
			if (gwsaData.iMaxUdpDg)
			{
				DPF(0, "Using iMaxUdpDg value from WSAStartup: %d", gwsaData.iMaxUdpDg);
				gd.iMaxUdpDg = gwsaData.iMaxUdpDg;
			}
			else
			{
				DPF_ERR("No max UDP buffer size could be found!");

				// all done w/ verify socket
				KillSocket(sVerifySocket,FALSE,TRUE);
				goto ERROR_EXIT;
			}
		}
	}

	// check that the IPX stack won't hose us
	if (AF_IPX == gd.AddressFamily)
	{
		hr = CheckIPXInstall(sVerifySocket);
		if (FAILED(hr))
		{
			DPF_ERR("SPInit Failing - corrupt IPX install");
			hr = DPERR_UNAVAILABLE;
			// all done w/ verify socket
			KillSocket(sVerifySocket,FALSE,TRUE);
			goto ERROR_EXIT;
		}
	}
	
	// all done w/ verify socket
	KillSocket(sVerifySocket,FALSE,TRUE);

#ifdef FIND_IP
	// print out the ip address(es) of this host
	DebugFindIPAddresses();
#endif 

    // set up callbacks
    pSD->lpCB->CreatePlayer = SP_CreatePlayer;
    pSD->lpCB->DeletePlayer = SP_DeletePlayer;
    pSD->lpCB->Send = SP_Send;
    pSD->lpCB->EnumSessions = SP_EnumSessions;
    pSD->lpCB->Reply = SP_Reply;
	pSD->lpCB->ShutdownEx = SP_Shutdown;
	pSD->lpCB->GetCaps = SP_GetCaps;
	pSD->lpCB->Open = SP_Open;
	pSD->lpCB->CloseEx = SP_Close;
	pSD->lpCB->GetAddress = SP_GetAddress;

#ifdef SENDEX
	if(LOBYTE(gwsaData.wVersion) >= 2)
	{
		DPF(1,"SENDEX being provided by SP\n");
		// Only do new functions when Winsock 2 functions avail.
		// NOTE: not supported on IPX with win9x at present, but reports 1.1 in this case.
		
    	//pSD->lpCB->SendToGroupEx = SP_SendToGroupEx;             // optional - not impl
    	//pSD->lpCB->Cancel        = SP_Cancel;                    // optional - not impl
	    pSD->lpCB->SendEx		   = SP_SendEx;                    // required for async
    	pSD->lpCB->GetMessageQueue = SP_GetMessageQueue;    
    } else {
    	DPF(1,"SENDEX not being provided by SP on winsock ver < 2\n");
    }
#endif

	// we put (at most) 1 sockaddr and one dword (size) in each message
	pSD->dwSPHeaderSize = sizeof(MESSAGEHEADER);

	// return version number so DirectPlay will treat us with respect
	pSD->dwSPVersion = VERSIONNUMBER;

	// look at connnection data
	if (pSD->dwAddressSize)
	{
		// ask dplay to enum the chunks for us. if one of them is
		// af_inet, we'll use it as our name servers address
		pSD->lpISP->lpVtbl->EnumAddress(pSD->lpISP, EnumConnectionData, 
								 pSD->lpAddress, pSD->dwAddressSize,
								 &gd);
	}

#ifdef FULLDUPLEX_SUPPORT
	// get the flags from registry
	hr = GetFlagsFromRegistry(pSD->lpGuid, &gd.dwFlags);
	if (FAILED(hr))
	{
		DPF(2, "Failed to get sp flags from the registry");		
	}
#endif // FULLDUPLEX_SUPPORT

#if USE_RSIP
	if(	gd.AddressFamily == AF_INET ){
		rsipInit(&gd, pSD->lpGuid);
	}
#endif
#if USE_NATHELP
	if(	gd.AddressFamily == AF_INET ){
		natInit(&gd, pSD->lpGuid);
	}
#endif	

	// store the globaldata
	hr = pSD->lpISP->lpVtbl->SetSPData(pSD->lpISP,&gd,sizeof(GLOBALDATA),DPSET_LOCAL);
	if (FAILED(hr))
	{
		ASSERT(FALSE);
		goto ERROR_EXIT;
	}
	
	hr = pSD->lpISP->lpVtbl->GetSPData(pSD->lpISP,&pgd,&dwSize,DPGET_LOCAL);

	if (FAILED(hr))
	{
		ASSERT(FALSE);
		goto ERROR_EXIT;
	}
#ifdef SENDEX	
	if(LOBYTE(gwsaData.wVersion) >= 2) {
		// some globals are self referential, can't set until here.
		hr=InitGlobalsInPlace(pgd);
		if(FAILED(hr))
		{
			ASSERT(FALSE);
			goto ERROR_EXIT;
		}

		// added alertable thread.
		pgd->hSendWait=CreateEvent(NULL, FALSE, FALSE, NULL); // autoreset.
		if(!pgd->hSendWait){
			ASSERT(FALSE);
			goto ERROR_EXIT;
		}
		pgd->bSendThreadRunning=TRUE;
		hAlertThread=CreateThread(NULL, 4000, SPSendThread, pgd, 0, (ULONG *)&hAlertThread);
		if(!hAlertThread){
			pgd->bSendThreadRunning=FALSE;
			ASSERT(FALSE);
			goto ERROR_EXIT;
		} else {
			SetThreadPriority(hAlertThread, THREAD_PRIORITY_ABOVE_NORMAL);
		}
		CloseHandle(hAlertThread);// don't need a handle.
	}
	
#endif	
	if(hWS2){
		if(!FastSockInit(pgd)){
			goto ERROR_EXIT;
		}
	}	

	
	gdwDPlaySPRefCount++;

	
	// success!
	return DP_OK;    

ERROR_EXIT:

	DPF_ERR("SPInit - abnormal exit");

	// call this again to clean up anything we alloc'ed
	InitGlobals(&gd);
	
	DPF(2,"SPInit - calling WSACleanup");
    if ( SOCKET_ERROR == WSACleanup()) 
    {
		err = WSAGetLastError();
    	DPF(0,"could not stop winsock err = %d\n",err);
    }

	return hr;

} // SPInit
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\wsock\dllmain.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dllmain.c
 *  Content:	dpwsock.dll initialization
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   2/1	andyco	created it
 ***************************************************************************/
//#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include "dpf.h"
#include "dpsp.h"
#include "memalloc.h"
#include "helpcli.h"

DWORD dwRefCnt=0;// the # of attached processes
BOOL bFirstTime;

#undef DPF_MODNAME
#define DPF_MODNAME "dpwsock sp dllmain"

HANDLE ghInstance; // save this for our dialog box

/*
 * DllMain
 */
BOOL WINAPI DllMain(HINSTANCE hmod, DWORD dwReason, LPVOID lpvReserved)
{

    switch( dwReason )
    {
	
	case DLL_PROCESS_ATTACH:
	
	    DisableThreadLibraryCalls( hmod );
	    DPFINIT(); // bugbug : dpfinit for every proc?

	    DPF( 0, "====> ENTER: DLLMAIN(%08lx): Process Attach: %08lx, tid=%08lx", DllMain,
	            GetCurrentProcessId(), GetCurrentThreadId() );
	    	
	    /*
	     * initialize memory
	     */
	    if( dwRefCnt == 0 )
	    {
			INIT_DPSP_CSECT();	
			
	        if( !MemInit() )
	        {
		        DPF( 0, "LEAVING, COULD NOT MemInit" );
		        return FALSE;
	        }

			// save the instance
			ghInstance = hmod;
			
	    }

    	dwRefCnt++;

        break;

    case DLL_PROCESS_DETACH:

	    DPF( 2, "====> ENTER: DLLMAIN(%08lx): Process Detach %08lx, tid=%08lx",
	        DllMain, GetCurrentProcessId(), GetCurrentThreadId() );
	    
	    dwRefCnt--;        
      	if (0==dwRefCnt) 
       	{
	
			DPF(0,"DPWSOCK - dllmain - going away!");

		    #ifdef DEBUG
	    	    MemState();
		    #endif // debug
	    
	        MemFini(); 
			
			FINI_DPSP_CSECT();

			HelpcliFini();
       	} 
	    break;

    default:
        break;
    }

    return TRUE;

} /* DllMain */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\wsock\dpsp.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplayi.h
 *  Content:	DirectPlay data structures
 *  History:
 *   Date		By	Reason
 *   ====		==	======
 *	1/96		andyco	created it
 *  1/26/96		andyco	list data structures
 *	4/10/96		andyco	removed dpmess.h
 *	4/23/96		andyco	added ipx support
 *	4/25/96		andyco	messages now have blobs (sockaddr's) instead of dwReserveds  
 *	8/10/96		kipo	update max message size to be (2^20) - 1
 *	8/15/96		andyco	added local data
 *	8/30/96		andyco	clean it up b4 you shut it down! added globaldata.
 *	9/3/96		andyco	bagosockets
 *	12/18/96	andyco	de-threading - use a fixed # of prealloced threads.
 *						cruised the enum socket / thread - use the system
 *						socket / thread instead. updated global struct.
 *	2/7/97		andyco	moved all per IDirectPlay globals into globaldata
 *	3/17/97		kipo	GetServerAddress() now returns an error so that we can
 *						return DPERR_USERCANCEL from the EnumSessions dialog
 *	3/25/97		andyco	dec debug lock counter b4 dropping lock! 
 *	4/11/97		andyco	added saddrControlSocket
 *	5/12/97		kipo	added ADDR_BUFFER_SIZE constant and removed unused variables
 *	5/15/97		andyco	added ipx spare thread to global data - used when nameserver 
 *						migrates to this host to make sure that old system receive 
 *						thread shuts down 
 *	6/22/97		kipo	include wsnwlink.h
 *	7/11/97		andyco	added support for ws2 + async reply thread
 *	8/25/97		sohailm	added DEFAULT_RECEIVE_BUFFERSIZE
 *	12/5/97		andyco	voice support
 *	01/5/97		sohailm	added fd big set related definitions and macros (#15244).
 *	1/20/98		myronth	#ifdef'd out voice support
 *	1/27/98		sohailm	added firewall support
 *  2/13/98     aarono  added async support
 *	2/18/98    a-peterz Comment byte order mess-up with SERVER_xxx_PORT constants
 *  3/3/98      aarono  Bug#19188 remove accept thread 
 *  12/15/98    aarono  make async enum run async
 *  01/12/2000  aarono  added rsip support
 *  09/12/2000  aarono  workaround winsock bug, only allow 1 pending async send per socket
 *                       otherwise data can get misordered. (MB#43990)
 **************************************************************************/

#ifndef __DPSP_INCLUDED__
#define __DPSP_INCLUDED__
#include "windows.h"
#include "windowsx.h"
#include "wsipx.h"
#include "wsnwlink.h"
#include "dplaysp.h"
#include "bilink.h"
#include "fpm.h"
#include "dpf.h"
#include "dputils.h"
#include "memalloc.h"
#include "resource.h"
#include <winsock.h>

// to turn off SendEx support, comment this flag out.
#define SENDEX 1

// NOTE! USE_RSIP and USE_NATHLP should be mutually exclusive
// to turn off RSIP support, comment this flag out.
//#define USE_RSIP 1

// turn ON to use NATHLP helper DLL 
#define USE_NATHELP 1

#if USE_NATHELP
#include "dpnathlp.h"
#endif

// use ddraw's assert code (see orion\misc\dpf.h)
#define ASSERT DDASSERT

typedef WORD PORT;
typedef UINT SOCKERR;

// server ports
// Oops! We forgot to convert these constants to net byte order in the code so we
// are really using port 47624 (0xBA08) instead of 2234 (0x08BA)
// We are living with the mistake.
#define SERVER_STREAM_PORT 2234
#define SERVER_DGRAM_PORT 2234

// range of ports used by sp (these are properly converted in the code)
#define DPSP_MIN_PORT	2300
#define DPSP_MAX_PORT	2400
#define DPSP_NUM_PORTS   ((DPSP_MAX_PORT - DPSP_MIN_PORT)+1)

#define SPMESSAGEHEADERLEN (sizeof(DWORD))
#define DEFAULT_RECEIVE_BUFFERSIZE	(4*1024)	// default receive buffer size per connection

// token means this message was received from a remote
// dplay.  
#define TOKEN 0xFAB00000

// helper_token means this message was forwarded by our server helper (host)
#define HELPER_TOKEN 0xCAB00000

// server_token means this message is exchanged with dplaysvr (needed to distinguish 
// messages from a remote dpwsockx)
#define SERVER_TOKEN 0xBAB00000

// tells receiver to reuse the connection for replies (needed to support fullduplex
// connections)
#define REUSE_TOKEN 0xAAB00000

// we linger on async sends for 2.5 seconds before hard closing them
// this avoids letting the socket get into the TIME_WAIT state for 4 minutes.
// essentially we are doing a close with linger for 2.5 secs followed by an abort.
#define LINGER_TIME 2500

// masks
#define TOKEN_MASK 0xFFF00000
#define SIZE_MASK (~TOKEN_MASK)

// maxmessagelen = 2^20 (need 12 bits for token)
#define SPMAXMESSAGELEN ( 1048576 - 1)
#define VALID_SP_MESSAGE(pMsg) ( (*((DWORD *)pMsg) & TOKEN_MASK) == TOKEN ? TRUE : FALSE)
#define VALID_HELPER_MESSAGE(pMsg) ( (*((DWORD *)pMsg) & TOKEN_MASK) == HELPER_TOKEN ? TRUE : FALSE)
#define VALID_REUSE_MESSAGE(pMsg) ( (*((DWORD *)pMsg) & TOKEN_MASK) == REUSE_TOKEN ? TRUE : FALSE)
#define VALID_SERVER_MESSAGE(pMsg) ( (*((DWORD *)pMsg) & TOKEN_MASK) == SERVER_TOKEN ? TRUE : FALSE)
#define SP_MESSAGE_SIZE(pMsg) ( (*((DWORD *)pMsg) & SIZE_MASK))
#define SP_MESSAGE_TOKEN(pMsg) ( (*((DWORD *)pMsg) & TOKEN_MASK))

#define VALID_DPWS_MESSAGE(pMsg) (  VALID_SP_MESSAGE(pMsg) || VALID_HELPER_MESSAGE(pMsg) || \
									VALID_SERVER_MESSAGE(pMsg) || VALID_REUSE_MESSAGE(pMsg) )
#define VALID_DPLAYSVR_MESSAGE(pMsg) (	VALID_SP_MESSAGE(pMsg) || VALID_SERVER_MESSAGE(pMsg) || \
										VALID_REUSE_MESSAGE(pMsg) )

// the actual value is ~ 1500 bytes.
// we use 1024 to be safe (IPX won't packetize for us - it can only 
// send what the underlying net can handle (MTU))
#define IPX_MAX_DGRAM 1024

// relation of timeout to latency
#define TIMEOUT_SCALE 10
#define SPTIMEOUT(latency) (TIMEOUT_SCALE * latency)

// the default size of the socket cache (gBagOSockets)
#define MAX_CONNECTED_SOCKETS 64

// the initial size of the receive list
#define INITIAL_RECEIVELIST_SIZE 16

// version number for service provider
#define SPMINORVERSION      0x0000				// service provider-specific version number
#define VERSIONNUMBER		(DPSP_MAJORVERSION | SPMINORVERSION) // version number for service provider

// biggest user enterable addess
#define ADDR_BUFFER_SIZE 128
								 
// macro picks the service socket depending on ipx vs. tcp
// ipx uses dgram, tcp uses stream
#define SERVICE_SOCKET(pgd) ( (pgd->AddressFamily == AF_IPX) \
	? pgd->sSystemDGramSocket : pgd->sSystemStreamSocket)

#if USE_RSIP

#define SERVICE_SADDR_PUBLIC(pgd)( (pgd->sRsip == INVALID_SOCKET) \
	? (NULL) : (&pgd->saddrpubSystemStreamSocket) )

#define DGRAM_SADDR_RSIP(pgd) ( (pgd->sRsip == INVALID_SOCKET) \
	? (NULL) : (&pgd->saddrpubSystemDGramSocket) )

#elif USE_NATHELP

#define SERVICE_SADDR_PUBLIC(pgd)( (pgd->pINatHelp) \
	? (&pgd->saddrpubSystemStreamSocket):NULL )

#define DGRAM_SADDR_RSIP(pgd) ( (pgd->pINatHelp) \
	? (&pgd->saddrpubSystemDGramSocket):NULL )

#else

#define SERVICE_SADDR_PUBLIC(pgd) NULL
#define DGRAM_SADDR_RSIP(pgd) NULL
#endif

//
// In order to listen to any number of sockets we need our own version
// of fd_set and FD_SET().  We call them fd_big_set and FD_BIG_SET().
//
typedef struct fd_big_set {
    u_int   fd_count;           // how many are SET?   
    SOCKET  fd_array[0];        // an array of SOCKETs 
} fd_big_set;

// stolen from winsock2.h

#ifndef _WINSOCK2API_

typedef HANDLE WSAEVENT;

typedef struct _WSAOVERLAPPED {
    DWORD        Internal;
    DWORD        InternalHigh;
    DWORD        Offset;
    DWORD        OffsetHigh;
    WSAEVENT     hEvent;
} WSAOVERLAPPED, FAR * LPWSAOVERLAPPED;

typedef struct _WSABUF {
    u_long      len;     /* the length of the buffer */
    char FAR *  buf;     /* the pointer to the buffer */
} WSABUF, FAR * LPWSABUF;
 
#endif // _WINSOCK2API_

#define MAX_SG 9
typedef WSABUF SENDARRAY[MAX_SG];
typedef SENDARRAY *PSENDARRAY;

#define SI_RELIABLE 0x0000001
#define SI_DATAGRAM 0x0000002
#define SI_INTERNALBUFF 0x00000004

typedef struct _SENDINFO {
	WSAOVERLAPPED wsao;
	SENDARRAY     SendArray;	// Array of buffers
	DWORD         dwFlags;
	DWORD         dwSendFlags;  // DPLAY Send Flags.
	UINT          iFirstBuf;	// First buffer in array to use
	UINT          cBuffers;		// number of buffers to send (starting at iFirstBuf)
	BILINK        PendingSendQ; // when we're pending
	BILINK		  PendingConnSendQ; // send queue for pending connections, also for pending when an async send is outstanding.
	BILINK        ReadyToSendQ; // still waiting to send on this queue.
	DPID          idTo;
	DPID          idFrom;
	SOCKET        sSocket;		// reliable sends
	SOCKADDR      sockaddr;		// datagram sends
	DWORD_PTR     dwUserContext;
	DWORD         dwMessageSize;
	DWORD         RefCount;
	LONG          Status;
	struct _PLAYERCONN *pConn;
	struct _GLOBALDATA *pgd;
	IDirectPlaySP * lpISP;			//  indication interface
} SENDINFO, *PSENDINFO, FAR *LPSENDINFO;

//
// This code is stolen from winsock.h.  It does the same thing as FD_SET()
// except that it assumes the fd_array is large enough.  AddSocketToReceiveList()
// grows the buffer as needed, so this better always be true.
//

#define FD_BIG_SET(fd, address) do { \
    ASSERT((address)->dwArraySize > (address)->pfdbigset->fd_count); \
    (address)->pfdbigset->fd_array[(address)->pfdbigset->fd_count++]=(fd);\
} while(0)

typedef struct fds {
	DWORD		dwArraySize;	// # of sockets that can be stored in pfdbigset->fd_array buffer
	fd_big_set	*pfdbigset;		
} FDS;

typedef struct _CONNECTION
{
	SOCKET	socket;				// socket we can receive off of
	DWORD	dwCurMessageSize;	// current message size
	DWORD	dwTotalMessageSize;	// total message size
	SOCKADDR sockAddr;			// addresses connected to
	LPBYTE	pBuffer;			// points to either default or temporary receive buffer
	LPBYTE	pDefaultBuffer;		// default receive buffer (pBuffer points to this by default)
	// added in DX6
	DWORD	dwFlags;			// connection attributes e.g. SP_CONNECION_FULLDUPLEX
} CONNECTION, *LPCONNECTION;

typedef struct _RECEIVELIST
{
	UINT nConnections;			// how many peers are we connected to
	LPCONNECTION pConnection;// list of connections
} RECEIVELIST;

typedef struct _REPLYLIST * LPREPLYLIST;
typedef struct _REPLYLIST
{
	LPREPLYLIST pNextReply; // next reply in list
	LPVOID	lpMessage; // bufffer to send
	SOCKADDR sockaddr;  // addr to send to
	DWORD dwMessageSize;
	SOCKET sSocket; // socket to send on
	LPBYTE pbSend; // index into message pointing to next byte to send
	DWORD  dwBytesLeft; // how many bytes are left to send
	DWORD  dwPlayerTo; // dpid of to player, 0=>not in use.
	DWORD  tSent;	// time we sent the last bit of reply.
} REPLYLIST;

// w store one of these w/ each sys player
typedef struct _SPPLAYERDATA 
{
	SOCKADDR saddrStream,saddrDatagram;
}SPPLAYERDATA,*LPSPPLAYERDATA;

	
// the message header
typedef struct _MESSAGEHEADER
{
	DWORD dwMessageSize; // size of message
	SOCKADDR sockaddr;
} MESSAGEHEADER,*LPMESSAGEHEADER;


// this is one element in our bagosockets
typedef struct _PLAYERSOCK
{
	SOCKET sSocket;
	DPID dwPlayerID;
	// added in DX6
	SOCKADDR sockaddr;
	DWORD dwFlags;			// SP_CONNECTION_FULLDUPLEX, etc.
} PLAYERSOCK,*LPPLAYERSOCK;

// PLAYERCONN structure is used for describing the reliable connection between
// this node and the remote player ID.
#define PLAYER_HASH_SIZE	256
#define SOCKET_HASH_SIZE  256

#define PLYR_CONN_PENDING		0x00000001	// connection pending.
#define PLYR_ACCEPT_PENDING		0x00000002  // expecting an accept(got WSAEISCONN on connect attempt).
#define PLYR_CONNECTED       	0x00000004  // connection has succeeded.
#define PLYR_ACCEPTED 			0x00000008
// players using old dpwsockx will use seperate inbound/outbound connections.
#define PLYR_NEW_CLIENT			0x00000010  // player uses just 1 socket.
#define PLYR_SOCKHASH			0x00000020
#define PLYR_DPIDHASH			0x00000040
#define PLYR_PENDINGLIST      0x00000080
#define PLYR_OLD_CLIENT			0x00000100

#define PLYR_DESTROYED        0x80000000	// already Dumped existence ref.

typedef struct _PLAYERCONN {
	struct _PLAYERCONN *pNextP;			// dwPlayerId hash table list.
	struct _PLAYERCONN *pNextS;			// IOSock hash table list.
	DWORD       dwRefCount;				// References.
	DPID		dwPlayerID;
	SOCKET		sSocket;
	DWORD		lNetEventsSocket;
	SOCKET		sSocketIn;				// they may have a different inbound socket.
	DWORD		lNetEventsSocketIn;
	DWORD		dwFlags;
VOL	BOOL		bSendOutstanding;		// if we have a send in process.  only 1 at a time per connection.
	BILINK		PendingConnSendQ;			// Sends waiting for connection to complete, and now also for sends to complete.
	BILINK      InboundPendingList;   // On the list of pending inbound connections

	// index of listener list we are listening in.(not the index in the list).
	INT			iEventHandle;

	
	PCHAR		pReceiveBuffer;				// if we get bigger than 4K.
	PCHAR		pDefaultReceiveBuffer;		// 4K Receive Buffer
	DWORD		cbReceiveBuffer;			// total size of receive buffer
	DWORD		cbReceived;					// total bytes received in buffer
	DWORD		cbExpected;					// number of bytes we're trying to receive.

	BOOL		bCombine;					// whether we combined with another connection.
	BOOL		bTrusted;					// whether we trust the remote client
	// this is the socket address corresponding to the sSocket which may
	// be used for both inbound and outbound connections.  Socket hash keys
	// off of this value.  Which will be the "reply" address of any inbound
	// messages not associated with a player.
	union {							
		SOCKADDR	sockaddr;
		SOCKADDR_IN sockaddr_in;
	}	IOSock;

	// clients without the new dpwsockx.dll will connect with a socket they
	// are not listening on.  This is the address we are receiving from,
	// corresponds to sSocketIn.
	union {
		SOCKADDR	sockaddr;
		SOCKADDR_IN sockaddr_in;
	}	IOnlySock;

} PLAYERCONN, *PPLAYERCONN;

// number of handles we distribute listens across so we can use
// wait for multiple objects and WSAEvent Select for listening.
#define NUM_EVENT_HANDLES			48
#define MAX_EVENTS_PER_HANDLE		32
//#define NUM_EVENT_HANDLES			3
//#define MAX_EVENTS_PER_HANDLE		2
#define INVALID_EVENT_SLOT 0xFFFFFFFF

// Note this sets an absolute cap of 48*32 = 1536 listeners
// per session.  Any connect attempts after that must be failed.
// Note also, with old clients this can mean a max of half that
// many actual players. (We could pull out listening from a player
// if he got a different inbound connection rather than re-using
// the outbound connection to solve this) 

typedef struct _EVENTLIST {
VOL	DWORD		nConn;		// number of 
	PPLAYERCONN pConn[MAX_EVENTS_PER_HANDLE];
} EVENTLIST, *PEVENTLIST;

#if USE_RSIP
typedef struct _RSIP_LEASE_RECORD {
	struct _RSIP_LEASE_RECORD * pNext;
	DWORD   dwRefCount;
	BOOL    ftcp_udp;
	DWORD	tExpiry;
	DWORD   bindid;
	DWORD   addrV4; // remote IP address
	SHORT   rport; 	// remote port
	SHORT	port;	// local port
} RSIP_LEASE_RECORD, *PRSIP_LEASE_RECORD;

// Cache of queried address mappings so we don't
// need to requery the mappings over and over
typedef struct _ADDR_ENTRY {
	struct _ADDR_ENTRY *pNext;
	BOOL	ftcp_udp;
	DWORD	tExpiry;
	DWORD	addr;
	DWORD	raddr;
	WORD	port;
	WORD	rport;
} ADDR_ENTRY, *PADDR_ENTRY;
#endif

// flags that describe a socket
#define SP_CONNECTION_FULLDUPLEX	0x00000001
// stream accept socket in the socket list.
#define SP_STREAM_ACCEPT            0x00000002	

#ifdef SENDEX
typedef struct FPOOL *LPFPOOL;
#endif

typedef struct _GLOBALDATA
{
	IDirectPlaySP * pISP;

	SOCKET sSystemDGramSocket;
	SOCKET sSystemStreamSocket;
	HANDLE hStreamReceiveThread;	// does receive and accept.
	HANDLE hDGramReceiveThread;
	HANDLE hReplyThread;
	RECEIVELIST ReceiveList;  // the list of sockets that StreamReceiveThread is listening on
	// reply thread	
	LPREPLYLIST pReplyList; // list of replies for reply thread to send
	LPREPLYLIST pReplyCloseList; // list of replies to close.
	HANDLE hReplyEvent; // signal the replythread that something is up
	// bago sockets stuff
	LPPLAYERSOCK BagOSockets; // socket cache
	UINT nSocketsInBag; // how many sockets in our bag
	ULONG uEnumAddress; // address entered by user for game server
	ULONG AddressFamily;
	SOCKADDR saddrNS; // address for name server
	DWORD dwLatency; // from dwreserved1 in registry
	BOOL bShutdown;
	BOOL bHaveServerAddress;
    CHAR szServerAddress[ADDR_BUFFER_SIZE];
	HANDLE	hIPXSpareThread; // if nameserver migrates to this host, we start a new receive thread 
							// (bound to our well known socket).  this is the handle to our old receive
							// thread - at shutdown, we need to make sure it's gone
	UINT iMaxUdpDg;			// maximum udp datagram size
	// added in DX6
	FDS	readfds;			// dynamic read fdset
	DWORD dwFlags;			// DPSP_OUTBOUNDONLY, etc.
	DWORD dwSessionFlags;	// session flags passed by app
	WORD wApplicationPort;	// port used for creating system player sockets
	
#ifdef BIGMESSAGEDEFENSE
	DWORD 	dwMaxMessageSize;	// the max message size we should receive
#endif

	HANDLE  hTCPEnumAsyncThread; // fix async enum.
	LPVOID  lpEnumMessage;
	DWORD   dwEnumMessageSize;
	SOCKADDR saEnum;
	DWORD    dwEnumAddrSize;
	SOCKET   sEnum;
	BOOL     bOutBoundOnly;

	HANDLE   hSelectEvent;

#ifdef SENDEX
	CRITICAL_SECTION csSendEx;  // locks sendex data.
	LPFPOOL	pSendInfoPool;     // pool for allocating SENDINFO+SPHeaders for scatter gather sends
	DWORD   dwBytesPending;		// count of total bytes in pending messages.
	DWORD   dwMessagesPending;  // count of total bytes pending.
	BILINK  PendingSendQ;
	BILINK  ReadyToSendQ;
	HANDLE  hSendWait;         // alert thread wait here.
	HANDLE  BogusHandle;	   // don't be fooled by waitfor multiple probs in Win9x, put -1 here.
	BOOL    bSendThreadRunning;
	BOOL    bStopSendThread;
#endif

#if USE_RSIP
VOL	SOCKET  	sRsip;
	SOCKADDR_IN	saddrGateway;
	CRITICAL_SECTION csRsip;
	DWORD       msgid;
	DWORD		clientid;

	// cache the public addresses of these sockets so we don't 
	// need to keep querying the name server every time.
	SOCKADDR saddrpubSystemDGramSocket;
	SOCKADDR saddrpubSystemStreamSocket;

	DWORD	dwBindDGEnumListener;
	
	PRSIP_LEASE_RECORD 	pRsipLeaseRecords;	// list of leases.
	PADDR_ENTRY        	pAddrEntry;			// cache of mappings.
	DWORD 		 		tuRetry;		//microseconds starting retry time.
#endif

#if USE_NATHELP
	HMODULE				hNatHelp;		// module handle for dpnhxxx.dll
	IDirectPlayNATHelp	*pINatHelp;		// interface pointer for IDirectPlayNATHelp object
	DPNHCAPS			NatHelpCaps;

	// we only ever map 2 ports, 1 for UDP, 1 for TCP.
	DPNHHANDLE			hNatHelpUDP;
	DPNHHANDLE			hNatHelpTCP;
	SOCKADDR			saddrpubSystemDGramSocket;
	SOCKADDR			saddrpubSystemStreamSocket;
    SOCKADDR            INADDRANY;
#endif

	SHORT				SystemStreamPort;		// will always be in 2300-2400 range when valid.
	//SHORT				SystemStreamPortOut;	// When running on Win9x < Millenium, need to use separate outbound port.
	BOOL				bSeparateIO;			// When set workaround Winsock bug in Win9x < Millenium
	BOOL		 		bFastSock;				// if we are using FastSocket support.
	CRITICAL_SECTION	csFast;					//  guards fast socket structures

	BILINK		 		InboundPendingList;		// connected from remote, but haven't created local player yet.

VOL	PPLAYERCONN  		PlayerHash[PLAYER_HASH_SIZE];
VOL	PPLAYERCONN	 		SocketHash[SOCKET_HASH_SIZE];

	HANDLE				hAccept;
	HANDLE				EventHandles[NUM_EVENT_HANDLES];
	HANDLE				BackStop;				// Invalid handle to avoid Win95 bug in Wait for Multiple Objects
	
	EVENTLIST			EventList[NUM_EVENT_HANDLES];

	UINT			    iEventAlloc;		// runs around through EventList Index to try next allocation
	INT					nEventSlotsAvail;

} GLOBALDATA,*LPGLOBALDATA;

/*
 * SP Flags (from registry)
 */
#define DPSP_OUTBOUNDONLY	0x00000001

/*
 * DPLAYSVR - DPWSOCKX communication related information
 */

// MSG_HDR indicates a dpwsock system message
#define MSG_HDR 0x736F636B

#define SP_MSG_VERSION	1	// DX6

#define IS_VALID_DPWS_MESSAGE(pMsg) (MSG_HDR == (*((DWORD *)(pMsg))) )
#define COMMAND_MASK 0X0000FFFF

#define GET_MESSAGE_VERSION(pMsg) ( ((pMsg)->dwCmdToken & ~COMMAND_MASK) >> 16 )
#define GET_MESSAGE_COMMAND(pMsg) ( (pMsg)->dwCmdToken & COMMAND_MASK)

#define SET_MESSAGE_HDR(pMsg)  (*((DWORD *)(pMsg)) = MSG_HDR )
#define SET_MESSAGE_COMMAND(pMsg,dwCmd) ((pMsg)->dwCmdToken = ((dwCmd & COMMAND_MASK) \
	| (SP_MSG_VERSION<<16)) )

typedef struct {
	DWORD dwHeader;
    DWORD dwCmdToken;	
} MSG_GENERIC, *LPMSG_GENERIC;


// DPLAYSVR


// macros for manipulating the sockaddr in the player data
#ifdef DEBUG
extern int gCSCount;
#endif
extern CRITICAL_SECTION gcsDPSPCritSection;	// defined in dllmain.c
extern CRITICAL_SECTION csMem;
#define INIT_DPSP_CSECT() InitializeCriticalSection(&gcsDPSPCritSection);InitializeCriticalSection(&csMem);
#define FINI_DPSP_CSECT() DeleteCriticalSection(&gcsDPSPCritSection);DeleteCriticalSection(&csMem);
#ifdef DEBUG
#define ENTER_DPSP() EnterCriticalSection(&gcsDPSPCritSection),gCSCount++;
#define LEAVE_DPSP() gCSCount--,LeaveCriticalSection(&gcsDPSPCritSection);
#else
#define ENTER_DPSP() EnterCriticalSection(&gcsDPSPCritSection);
#define LEAVE_DPSP() LeaveCriticalSection(&gcsDPSPCritSection);
#endif // DEBUG

// get a pointer to the players socket address - used by macros below
#define DGRAM_PSOCKADDR(ppd) ((SOCKADDR *)&(((LPSPPLAYERDATA)ppd)->saddrDatagram))
#define STREAM_PSOCKADDR(ppd) ((SOCKADDR *)&(((LPSPPLAYERDATA)ppd)->saddrStream))

// get the udp ip addr from a player
#define IP_DGRAM_ADDR(ppd) 	(((SOCKADDR_IN *)DGRAM_PSOCKADDR(ppd))->sin_addr.s_addr)
#define IP_DGRAM_PORT(ppd) 	(((SOCKADDR_IN *)DGRAM_PSOCKADDR(ppd))->sin_port)

// get the stream ip addr from a player
#define IP_STREAM_ADDR(ppd) 	(((SOCKADDR_IN *)STREAM_PSOCKADDR(ppd))->sin_addr.s_addr)
#define IP_STREAM_PORT(ppd) 	(((SOCKADDR_IN *)STREAM_PSOCKADDR(ppd))->sin_port)

// used to get the name of the computer we're running on in spinit
#define HOST_NAME_LENGTH 50


// if it's not ipx, it's ip
// {685BC400-9D2C-11cf-A9CD-00AA006886E3}
DEFINE_GUID(GUID_IPX, 
0x685bc400, 0x9d2c, 0x11cf, 0xa9, 0xcd, 0x0, 0xaa, 0x0, 0x68, 0x86, 0xe3);

// 36E95EE0-8577-11cf-960C-0080C7534E82
DEFINE_GUID(GUID_TCP,
0x36E95EE0, 0x8577, 0x11cf, 0x96, 0xc, 0x0, 0x80, 0xc7, 0x53, 0x4e, 0x82);

// {3A826E00-31DF-11d0-9CF9-00A0C90A43CB}
DEFINE_GUID(GUID_LOCAL_TCP, 
0x3a826e00, 0x31df, 0x11d0, 0x9c, 0xf9, 0x0, 0xa0, 0xc9, 0xa, 0x43, 0xcb);


// globals
// ghinstance is used when putting up the dialog box to prompt for ip addr
extern HANDLE ghInstance; // set in dllmain. instance handle for dpwsock.dll

#ifdef DEBUG

extern void DebugPrintAddr(UINT level,LPSTR pStr,SOCKADDR * psockaddr);
#define DEBUGPRINTADDR(n,pstr,psockaddr) DebugPrintAddr(n,pstr,psockaddr);
extern void DebugPrintSocket(UINT level,LPSTR pStr,SOCKET * pSock);
#define DEBUGPRINTSOCK(n,pstr,psock) DebugPrintSocket(n,pstr,psock);

#else // debug

#define DEBUGPRINTADDR(n,pstr,psockaddr)
#define DEBUGPRINTSOCK(n,pstr,psock)

#endif // debug

// global vars
extern BOOL gbVoiceOpen; // set to TRUE if we have nm call open

// from dpsp.c
extern HRESULT WaitForThread(HANDLE hThread);
extern HRESULT SetupControlSocket();
extern HRESULT WINAPI SP_Close(LPDPSP_CLOSEDATA pcd);
extern HRESULT InternalReliableSend(LPGLOBALDATA pgd, DPID idPlayerTo, SOCKADDR *
	lpSockAddr, LPBYTE lpMessage, DWORD dwMessageSize);
extern HRESULT DoTCPEnumSessions(LPGLOBALDATA pgd, SOCKADDR *lpSockAddr, DWORD dwAddrSize,
	LPDPSP_ENUMSESSIONSDATA ped, BOOL bHostWillReuseConnection);
extern HRESULT SendControlMessage(LPGLOBALDATA pgd);
extern HRESULT SendReuseConnectionMessage(SOCKET sSocket);
extern HRESULT AddSocketToBag(LPGLOBALDATA pgd, SOCKET socket, DPID dpid, SOCKADDR *psockaddr, DWORD dwFlags);
extern BOOL FindSocketInReceiveList(LPGLOBALDATA pgd, SOCKADDR *pSockAddr, SOCKET * psSocket);
extern void RemoveSocketFromReceiveList(LPGLOBALDATA pgd, SOCKET socket);
extern void RemoveSocketFromBag(LPGLOBALDATA pgd, SOCKET socket);
extern BOOL FindSocketInBag(LPGLOBALDATA pgd, SOCKADDR *pSockAddr, SOCKET * psSocket, LPDPID lpdpidPlayer);
extern HRESULT GetSocketFromBag(LPGLOBALDATA pgd,SOCKET * psSocket, DWORD dwID, LPSOCKADDR psockaddr);
extern HRESULT CreateAndConnectSocket(LPGLOBALDATA pgd,SOCKET * psSocket,DWORD dwType,LPSOCKADDR psockaddr, BOOL bOutBoundOnly);
extern void RemovePlayerFromSocketBag(LPGLOBALDATA pgd,DWORD dwID);
extern void SetMessageHeader(LPDWORD pdwMsg,DWORD dwSize, DWORD dwToken);
extern void KillTCPEnumAsyncThread(LPGLOBALDATA pgd);

// Support for SendEx in dpsp.c

extern HRESULT UnreliableSendEx(LPDPSP_SENDEXDATA psd, LPSENDINFO lpSendInfo);
extern HRESULT ReliableSendEx(LPDPSP_SENDEXDATA psd, LPSENDINFO pSendInfo);
extern VOID RemovePendingAsyncSends(LPGLOBALDATA pgd, DPID dwPlayerTo);
extern BOOL bAsyncSendsPending(LPGLOBALDATA pgd, DPID dwPlayerTo);
extern HRESULT GetSPPlayerData(LPGLOBALDATA pgd, IDirectPlaySP * lpISP, DPID idPlayer, LPSPPLAYERDATA *ppPlayerData, DWORD *lpdwSize);

// from winsock.c
extern HRESULT FAR PASCAL CreateSocket(LPGLOBALDATA pgd,SOCKET * psock,INT type,
	WORD port,ULONG address,SOCKERR * perr, BOOL bInRange);
extern HRESULT SPConnect(SOCKET* psSocket, LPSOCKADDR psockaddr,UINT addrlen, BOOL bOutBoundOnly);
extern HRESULT CreateAndInitStreamSocket(LPGLOBALDATA pgd);
extern HRESULT SetPlayerAddress(LPGLOBALDATA pgd,LPSPPLAYERDATA ppd,SOCKET sSocket,BOOL fStream); 
extern HRESULT CreatePlayerDgramSocket(LPGLOBALDATA pgd,LPSPPLAYERDATA ppd,DWORD dwFlags); 
extern HRESULT CreatePlayerStreamSocket(LPGLOBALDATA pgd,LPSPPLAYERDATA ppd,DWORD dwFlags); 
extern HRESULT SetDescriptionAddress(LPSPPLAYERDATA ppd,LPDPSESSIONDESC2 lpsdDesc);
extern HRESULT SetReturnAddress(LPVOID pmsg,SOCKET sSocket, LPSOCKADDR psaddr);
extern HRESULT GetReturnAddress(LPVOID pmsg,LPSOCKADDR psockaddr);
extern HRESULT GetServerAddress(LPGLOBALDATA pgd,LPSOCKADDR psockaddr) ;
extern void IPX_SetNodenum(LPVOID pmsg,SOCKADDR_IPX * psockaddr);
extern void IP_GetAddr(SOCKADDR_IN * paddrDest,SOCKADDR_IN * paddrSrc) ;
extern void IP_SetAddr(LPVOID pBuffer,SOCKADDR_IN * psockaddr);
extern void IPX_GetNodenum(SOCKADDR_IPX * paddrDest,SOCKADDR_IPX * paddrSrc) ;
extern HRESULT KillSocket(SOCKET sSocket,BOOL fStream,BOOL fHard);
extern HRESULT KillPlayerSockets();
extern HRESULT GetAddress(ULONG * puAddress,char *pBuffer,int cch);
extern HRESULT KillThread(HANDLE hThread);

// from wsock2.c
extern DWORD WINAPI AsyncSendThreadProc(LPVOID pvCast);
extern HRESULT InitWinsock2();
extern HRESULT GetMaxUdpBufferSize(SOCKET socket, unsigned int * lpiSize);

extern HRESULT InternalReliableSendEx(LPGLOBALDATA pgd, LPDPSP_SENDEXDATA psd, 
				LPSENDINFO pSendInfo, SOCKADDR *lpSockAddr);
extern DWORD WINAPI SPSendThread(LPVOID lpv);
extern void QueueForSend(LPGLOBALDATA pgd,LPSENDINFO pSendInfo);
extern BOOL SetExclusivePortAccess(SOCKET sNew);
extern BOOL SetSharedPortAccess(SOCKET sNew);


// from handler.c
extern HRESULT HandleServerMessage(LPGLOBALDATA pgd, SOCKET sSocket, LPBYTE pBuffer, DWORD dwSize);

#ifdef FULLDUPLEX_SUPPORT
// from registry.c
extern HRESULT GetFlagsFromRegistry(LPGUID lpguidSP, LPDWORD lpdwFlags);
#endif // FULLDUPLEX_SUPPORT

#if USE_RSIP
// from registry.c
extern HRESULT GetGatewayFromRegistry(LPGUID lpguidSP, LPBYTE lpszGateway, DWORD cbszGateway);
#elif USE_NATHELP
// from registry.c
extern HRESULT GetNATHelpDLLFromRegistry(LPGUID lpguidSP, LPBYTE lpszNATHelpDLL, DWORD cbszNATHelpDLL);
#endif

extern BOOL FastSockInit(LPGLOBALDATA pgd);
extern VOID FastSockFini(LPGLOBALDATA pgd);
extern PPLAYERCONN CreatePlayerConn(LPGLOBALDATA pgd, DPID dpid, SOCKADDR *psockaddr);
extern PPLAYERCONN FindPlayerById(LPGLOBALDATA pgd, DPID dpid);
extern PPLAYERCONN FindPlayerBySocket(LPGLOBALDATA pgd, SOCKADDR *psockaddr);
extern HRESULT AddConnToPlayerHash(LPGLOBALDATA pgd, PPLAYERCONN pConn);
extern HRESULT AddConnToSocketHash(LPGLOBALDATA pgd, PPLAYERCONN pConn);
extern PPLAYERCONN RemoveConnFromSocketHash(LPGLOBALDATA pgd, PPLAYERCONN pConn);
extern PPLAYERCONN RemoveConnFromPlayerHash(LPGLOBALDATA pgd, PPLAYERCONN pConn);
extern VOID QueueSendOnConn(LPGLOBALDATA pgd, PPLAYERCONN pConn, PSENDINFO pSendInfo);
extern PPLAYERCONN GetPlayerConn(LPGLOBALDATA pgd, DPID dpid, SOCKADDR *psockaddr);
extern INT DecRefConn(LPGLOBALDATA pgd, PPLAYERCONN pConn);
extern INT DecRefConnExist(LPGLOBALDATA pgd, PPLAYERCONN pConn);
extern HRESULT FastInternalReliableSend(LPGLOBALDATA pgd, LPDPSP_SENDDATA psd, SOCKADDR *lpSockAddr);
extern HRESULT FastInternalReliableSendEx(LPGLOBALDATA pgd, LPDPSP_SENDEXDATA psd, LPSENDINFO pSendInfo, SOCKADDR *lpSockAddr);
extern PPLAYERCONN CleanPlayerConn(LPGLOBALDATA pgd, PPLAYERCONN pConn, BOOL bHard);
extern HRESULT FastReply(LPGLOBALDATA pgd, LPDPSP_REPLYDATA prd, DPID dwPlayerID);
extern PPLAYERCONN FindConnInPendingList(LPGLOBALDATA pgd, SOCKADDR *psaddr);
extern DWORD WINAPI FastStreamReceiveThreadProc(LPVOID pvCast);
extern VOID FastSockCleanConnList(LPGLOBALDATA pgd);
extern INT DecRefConn(LPGLOBALDATA pgd, PPLAYERCONN pConn);
extern VOID QueueNextSend(LPGLOBALDATA pgd,PPLAYERCONN pConn);


// Wrap Malloc
void _inline __cdecl SP_MemFree( LPVOID lptr )
{
	EnterCriticalSection(&csMem);
	MemFree(lptr);
	LeaveCriticalSection(&csMem);
}

LPVOID _inline __cdecl SP_MemAlloc(UINT size)
{
	LPVOID lpv;
	EnterCriticalSection(&csMem);
	lpv = MemAlloc(size);
	LeaveCriticalSection(&csMem);
	return lpv;
}

LPVOID _inline __cdecl SP_MemReAlloc(LPVOID lptr, UINT size)
{
	LPVOID lpv;
	EnterCriticalSection(&csMem);
	lpv = MemReAlloc(lptr, size);
	LeaveCriticalSection(&csMem);
	return lpv;
}

#define AddRefConn(_p) InterlockedIncrement(&((_p)->dwRefCount))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\wsock\fpm.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       fpm.c
 *  Content:	fixed size pool manager
 *
 *  History:
 *   Date		By		Reason
 *   ======		==		======
 *  12-18-97  aarono    Original
 ***************************************************************************/

#include "windows.h"
#include "dpsp.h"
#include "fpm.h"

#ifdef SENDEX

BOOL FN_BOOL_DUMMY(void *pvItem)
{
	return TRUE;
}

VOID FN_VOID_DUMMY(void *pvItem)
{
	return;
}

void * FPM_Get(LPFPOOL this)
{
	void * pvItem;

	EnterCriticalSection(&this->cs);
	
	if(!this->pPool){
	
		LeaveCriticalSection(&this->cs);
		pvItem = SP_MemAlloc(this->cbItemSize);

		if((pvItem) && !(*this->fnBlockInitAlloc)(pvItem) ){
			SP_MemFree(pvItem);
			pvItem=NULL;
		}

		EnterCriticalSection(&this->cs);

		if(pvItem){	
			this->nAllocated++;
		}
		
	} else {
		pvItem=this->pPool;
		this->pPool=*((void **)pvItem);
	}

	if(pvItem){
	
		(*this->fnBlockInit)(pvItem);
		
		this->nInUse++;
		if(this->nInUse > this->nMaxInUse){
			this->nMaxInUse = this->nInUse;
		}
	}

	LeaveCriticalSection(&this->cs);

	return pvItem;
}

#ifdef DEBUG
void DebugCheckList(void *pvList, void *pvItem)
{
	void *pvWalker;
	DWORD n=0;
	pvWalker=pvList;

	while(pvWalker){
		if(pvWalker==pvItem){
			DPF(0,"ERROR: Found Item %x in List %x, item # %d\n",pvList,pvItem,n);
			DEBUG_BREAK();
		}
		n++;
		pvWalker=*((void **)pvWalker);
	}
}
#else
#define DebugCheckList()
#endif

void FPM_Release(LPFPOOL this, void *pvItem)
{
	EnterCriticalSection(&this->cs);
	DebugCheckList(this->pPool, pvItem); //NOTE: debug only.
	this->nInUse--;
	*((void**)pvItem)=this->pPool;
	this->pPool=pvItem;
	LeaveCriticalSection(&this->cs);
	
}

void FPM_Scale(LPFPOOL this)
{
	void * pvItem;

	if(!InterlockedExchange(&this->bInScale,1)){

		EnterCriticalSection(&this->cs);

		while((this->nAllocated > this->nMaxInUse) && this->pPool){
			pvItem = this->pPool;
			this->pPool=*((void **)pvItem);
			LeaveCriticalSection(&this->cs);
			(*this->fnBlockFini)(pvItem);
			SP_MemFree(pvItem);
			EnterCriticalSection(&this->cs);
			this->nAllocated--;
		}
		
		this->nMaxInUse=this->nInUse;

		LeaveCriticalSection(&this->cs);

		InterlockedExchange(&this->bInScale,0);
	}
}

VOID FPM_Fini(LPFPOOL this, int bFORCE)
{
	void *pvItem;

	while(this->pPool){
		pvItem = this->pPool;
		this->pPool=*((void **)pvItem);
		(*this->fnBlockFini)(pvItem);
		SP_MemFree(pvItem);
		this->nAllocated--;
	}
	if(this->nAllocated){
		DPF(0,"WSOCK: Exiting with unfreed FPM pool items\n");
	}
	DeleteCriticalSection(&this->cs);
	SP_MemFree(this);
}

LPFPOOL FPM_Init(
	unsigned int size, 
	FN_BLOCKINITALLOC fnBlockInitAlloc,
	FN_BLOCKINIT      fnBlockInit, 
	FN_BLOCKFINI      fnBlockFini)
{
	LPFPOOL pPool;
	
	if(!(pPool=(LPFPOOL)SP_MemAlloc(sizeof(FPOOL))))
	{
	  return NULL;
	}

	InitializeCriticalSection(&pPool->cs);
	
	// by zero init.
	//pPool.pPool      = NULL;
	//pPool.nAllocated = 0;
	//pPool.nInUse     = 0;
	//pPool.nMaxInUse  = 0;
	//pPool.bInScale   = FALSE;

	if(fnBlockInitAlloc){
		pPool->fnBlockInitAlloc = fnBlockInitAlloc;
	} else {
		pPool->fnBlockInitAlloc = FN_BOOL_DUMMY;
	}
	if(fnBlockInit){
		pPool->fnBlockInit      = fnBlockInit;
	} else {
		pPool->fnBlockInit      = FN_VOID_DUMMY;
	}
	if(fnBlockFini){
		pPool->fnBlockFini      = fnBlockFini;
	} else {
		pPool->fnBlockFini      = FN_VOID_DUMMY;
	}

	pPool->Get    = FPM_Get;
	pPool->Release= FPM_Release;
	pPool->Scale  = FPM_Scale;
	pPool->Fini   = FPM_Fini;

	pPool->cbItemSize = size;
	
	return pPool;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\wsock\fastsock.c ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       fastsock.c
 *  Content:	new socket management to speed up massive multiplayer games
 *  History:
 *
 *  Date		By		Reason
 *  ==========	==		======
 *  01/23/2000  aarono  created
 *  05/08/2000  aarono  B#34466 Fix ordering problem in DecRefConnExist
 *  07/07/2000  aarono  added WSAEHOSTUNREACH for disconnected links in GetPlayerConn
 *  08/30/2000  aarono  workaround PAST bug MB#43599
 *                      fix MB#43586 Win2K stopping, not handling WSAEWOULDBLOCK on
 *                      receive properly (was dropping link).
 *  02/02/2001  aarono 	B#300219 STRESS: don't break on WSAENOBUFS from winsock
 *  02/21/2001  a-aogus don't allow large receives from untrusted sources.
 ***************************************************************************/

#define INCL_WINSOCK_API_TYPEDEFS 1 // includes winsock 2 fn proto's, for getprocaddress
#include <winsock2.h>
#include "dpsp.h"
#if USE_RSIP
#include "rsip.h"
#elif USE_NATHELP
#include "nathelp.h"
#endif
#include "mmsystem.h"

LPFN_WSAWAITFORMULTIPLEEVENTS g_WSAWaitForMultipleEvents;
LPFN_WSASEND g_WSASend;
LPFN_WSASENDTO g_WSASendTo;
LPFN_WSACLOSEEVENT g_WSACloseEvent;
LPFN_WSACREATEEVENT g_WSACreateEvent;
LPFN_WSAENUMNETWORKEVENTS g_WSAEnumNetworkEvents;
LPFN_WSAEVENTSELECT g_WSAEventSelect;
LPFN_GETSOCKOPT g_getsockopt;

HRESULT FastPlayerEventSelect(LPGLOBALDATA pgd, PPLAYERCONN pConn, BOOL bSelect);
VOID FastAccept(LPGLOBALDATA pgd, LPWSANETWORKEVENTS pNetEvents);

HRESULT ProcessConnEvents(
	LPGLOBALDATA pgd, 
	PPLAYERCONN pConn, 
	LPWSANETWORKEVENTS pSockEvents, 	
	LPWSANETWORKEVENTS pSockInEvents
);

extern DWORD wsaoDecRef(LPSENDINFO pSendInfo);

PPLAYERCONN CleanPlayerConn(LPGLOBALDATA pgd, PPLAYERCONN pConn, BOOL bHard);

PPLAYERCONN FastCombine(LPGLOBALDATA pgd, PPLAYERCONN pConn, SOCKADDR *psockaddr);
VOID RemoveConnFromPendingList(LPGLOBALDATA pgd, PPLAYERCONN pConn);


/*=============================================================================

	PlayerConnnection management:
	-----------------------------

	For datagram sends, there is one port on each machine used as a target,
	and since no connection is required, only 1 socket is used for datagram
	sends and receives.  Since datagrams are allowed to be dropped, there is
	no race between sending from one side to the other until player creation
	since its ok to drop the receives that occure before player creation on 
	this machine occurs.  Actually there is a race, but we don't care.

	For reliable sends there are numerous race conditions that exist.  First
	the actual creation of the link between this client and the remote
	machine is going to become a race.  Since we are connecting to and from
	the same ports to create the link, only one link will get set up, either
	it will get set up due to a connect to us, or it will get set up by us
	connecting to them.

	They connect to us:

	In the case where they connect to us first, there may be reliable data
	arriving at our node that would get thrown out it we indicated it to 
	the dplay layer, because dplay has not yet created the player.  To avoid
	this problem we queue any incoming receives and wait until the player
	has been created locally before indicating that data to the dplay layer.
	We pend any incoming data on a PLAYERCONN structure that we put on the
	PendingConnList on the global data.  The PLAYERCONN structure can be
	fully initialized except we won't know the playerid of the remote player,
	as a result of which we cannot put the PLAYERCONN into the PlayerHash
	hash table.

	Note there is an additional problem of not knowing which player a connect
	is from.  This means we need to put the queueing in the dplay layer,
	not in the dpwsock layer.

	We connect to them:

	When we go to establish the connection with the remote, we must do it
	asynchronously so as not to block in case we are a server.  During the
	connection process, we first look on the PendingConnList and see if
	the remote hasn't already connected to us.  If it has, we pick up the
	socket from the conn list and immediately indicate any pending data.

	If we failed to find the connection in the Pending list, this doesn't
	mean they won't still beat us but we are going to try and connect to 
	them first.  We create our connect structure and put it in the hash
	table and mark it pending.  We also put it on the pending connect list
	so any incoming connection could find it.  We then issue an asynchronous
	connect on the socket.

	When the connect completes any pending sends are then sent by the
	send thread.  If the connect fails because the other side connected
	to us first, then we wait for the thread accepting connections to find
	the connection structure and send out the pending sends.

	Since they may be connecting from an old client, there is no guarantee
	that their inbound connection and our outbound connection will use the
	same socket.  Each player structure must therefore contain both an
	inbound and outbound socket.


=============================================================================*/

#ifdef DEBUG
VOID DUMPCONN(PPLAYERCONN pConn, DWORD dwLevel)
{
	DPF(8,"Conn %x dwRefCount %d sSocket %d sSocketIn %d dwFlags %x iEventHandle %d\n",
		pConn, pConn->dwRefCount, pConn->sSocket, pConn->sSocketIn, pConn->dwFlags, pConn->iEventHandle);

	if(dwLevel >= 1	){
		if(pConn->dwFlags & PLYR_NEW_CLIENT){
			DEBUGPRINTADDR(8,"NEW CLIENT: Socket",&pConn->IOSock.sockaddr);
		}
		if(pConn->dwFlags & PLYR_OLD_CLIENT){
			DEBUGPRINTADDR(8,"OLD CLIENT: Socket Out",&pConn->IOSock.sockaddr);
			DEBUGPRINTADDR(8,"OLD CLIENT: Socket In",&pConn->IOnlySock.sockaddr);
		}
	}

	if(dwLevel >= 2){
		DPF(8,"Receive... pReceiveBuffer %x, cbReceiveBuffer %d, cbReceived %d, cbExpected %d\n",
			pConn->pReceiveBuffer, pConn->cbReceiveBuffer, pConn->cbReceived, pConn->cbExpected);
	}

}

#else
#define DUMPCONN(pConn,Level)
#endif


int myclosesocket(LPGLOBALDATA pgd, SOCKET socket)
{
  DWORD lNonBlock=1;
  int err;
  
  if(socket==INVALID_SOCKET){
     DPF(0,"Closing invalid socket... bad bad bad\n");
     DEBUG_BREAK();
  }
  if(socket==pgd->sSystemStreamSocket){
      DPF(0,"Closing listen socket... bad bad bad\n");
      DEBUG_BREAK();
  }
  
  err = ioctlsocket(socket,FIONBIO,&lNonBlock);
  if (SOCKET_ERROR == err)
  {
  	err = WSAGetLastError();
	DPF(0,"myclosesocket: could not set non-blocking mode on socket err = %d!",err);
  }
  
  return closesocket(socket);
}

// TRUE -> same port and IP addr.
BOOL _inline bSameAddr(SOCKADDR *psaddr, SOCKADDR *psaddr2)
{
	SOCKADDR_IN *psaddr_in  = (SOCKADDR_IN *)psaddr;
	SOCKADDR_IN *psaddr_in2 = (SOCKADDR_IN *)psaddr2;

	if( (psaddr_in->sin_port == psaddr_in2->sin_port) &&
		!memcmp(&psaddr_in->sin_addr,&psaddr_in2->sin_addr, 4 ))
	{ 
		return TRUE;
	} else {
		return FALSE;
	}
}

//
// HashPlayer() - hash a dpid to a 0->PLAYER_HASH_SIZE index.
//
UINT _inline HashPlayer(DPID dpid){
	UINT Hash=0;
	Hash = ((dpid & 0xFF000000)>>24) ^ ((dpid & 0xFF0000)>>16) ^ ((dpid & 0xFF00)>>8) ^ (dpid & 0xFF);
	Hash = Hash % PLAYER_HASH_SIZE;
	DPF(8,"Player Hash %d\n",Hash);
	return Hash;
}

//
// HashSocket() - hash a socket id, including port
//
UINT _inline HashSocket(SOCKADDR *psockaddr){
	unsigned char *pc = (char *)(&(*(SOCKADDR_IN *)(psockaddr)).sin_port);
	UINT Hash=0;

	Hash = *pc ^ *(pc+1) ^ *(pc+2) ^ *(pc+3) ^ *(pc+4) ^ *(pc+5);

	Hash = Hash % SOCKET_HASH_SIZE;
	DPF(8,"Socket Hash %d\n",Hash);
	return Hash;
}

/*=============================================================================

	FastSockInit - Initialize Fask socket processing
	
	
    Description:


    Parameters:

    	pgd  - Service Provider's global data blob for this instance

    Return Values:


-----------------------------------------------------------------------------*/
BOOL FastSockInit(LPGLOBALDATA pgd)
{
	BOOL bReturn = TRUE;
	INT i;

	try {
	
		InitializeCriticalSection(&pgd->csFast);
		
	} except ( EXCEPTION_EXECUTE_HANDLER) {

		// Catch STATUS_NOMEMORY
		DPF(0,"FastSockInit: Couldn't allocate critical section, bailing\n");
		bReturn=FALSE;
		goto exit;
	}

	// Start at -1 so we get the Accept handle too. 
	for(i=-1; i<NUM_EVENT_HANDLES; i++){
		pgd->EventHandles[i]=CreateEvent(NULL, FALSE, FALSE, NULL);
		if(!pgd->EventHandles[i]){
			DPF(0,"FastSockInit: Failed to allocate handles, bailing\n");
			for(;i>-1;--i){
				CloseHandle(pgd->EventHandles[i]);
			}
			bReturn = FALSE;
			goto err_exit1;
		}
	}

	// could initialize all the listenerlists to 0, but that would be pointless.
	pgd->BackStop=INVALID_HANDLE_VALUE;

	pgd->nEventSlotsAvail = NUM_EVENT_HANDLES * MAX_EVENTS_PER_HANDLE;

	InitBilink(&pgd->InboundPendingList);

	DPF(8,"FastSock Init: nEventSlots %d\n",pgd->nEventSlotsAvail);

	pgd->bFastSock=TRUE;
	
exit:
	return bReturn;

err_exit1:
	DeleteCriticalSection(&pgd->csFast);
	return bReturn;
}

/*=============================================================================

	FastSockCleanConnList - Release connections
	
	
    Description:


    Parameters:

    	pgd  - Service Provider's global data blob for this instance

    Return Values:


-----------------------------------------------------------------------------*/

VOID FastSockCleanConnList(LPGLOBALDATA pgd)
{
	PPLAYERCONN pConn,pNextConn;
	BILINK *pBilink, *pBilinkWalker;
	INT i;

	DPF(8,"==>FastSockCleanConnList\n");

	DPF(8,"Cleaning up Player ID hash Table\n");

	EnterCriticalSection(&pgd->csFast);

	for(i=0;i<PLAYER_HASH_SIZE; i++){
		pConn=pgd->PlayerHash[i];
		pgd->PlayerHash[i]=NULL;
		while(pConn)
		{
			pNextConn=pConn->pNextP;
			DPF(8,"Destroying Connection for Playerid %x\n",pConn->dwPlayerID);
			DUMPCONN(pConn,3);
			CleanPlayerConn(pgd, pConn, TRUE);
			DecRefConnExist(pgd, pConn); // dump existence ref.
			DecRefConn(pgd,pConn); // dump playerid table ref.
			pConn=pNextConn;
		}
	}

	// Clean up socket hash table entries
	DPF(8,"Cleaning up Socket hash Table\n");

	for(i=0;i<SOCKET_HASH_SIZE; i++)
	{
		pConn=pgd->SocketHash[i];
		pgd->SocketHash[i]=NULL;
		while(pConn)
		{
			pNextConn=pConn->pNextP;
			DPF(8,"Destroying Connection for Playerid %x\n",pConn->dwPlayerID);
			DUMPCONN(pConn,3);
			CleanPlayerConn(pgd, pConn, TRUE);
			DecRefConnExist(pgd, pConn); // dump existence ref.
			DecRefConn(pgd,pConn); // dump socket table ref.
			pConn=pNextConn;
		}
	}

	// Clean up inbound list.
	DPF(8,"Cleaning up Inbound Pending List\n");

	pBilink=pgd->InboundPendingList.next;

	while(pBilink != &pgd->InboundPendingList)
	{
		pBilinkWalker=pBilink->next;
		pConn=CONTAINING_RECORD(pBilink, PLAYERCONN, InboundPendingList);
		DPF(8,"Destroying Connection for Playerid %x\n",pConn->dwPlayerID);
		DUMPCONN(pConn,3);
		CleanPlayerConn(pgd, pConn, TRUE);
		DecRefConnExist(pgd, pConn);
		//DecRefConn(pgd,pConn); // dump inbound list ref --no, gets handled in CleanPlayerConn for this case
		pBilink=pBilinkWalker;
	}
	InitBilink(&pgd->InboundPendingList);

	LeaveCriticalSection(&pgd->csFast);

	ASSERT(pgd->nEventSlotsAvail == NUM_EVENT_HANDLES * MAX_EVENTS_PER_HANDLE);
	DPF(8,"<==FastSockCleanConnList\n");
}

/*=============================================================================

	FastSockFini - Release resources for fast socket processing.
	
	
    Description:


    Parameters:

    	pgd  - Service Provider's global data blob for this instance

    Return Values:


-----------------------------------------------------------------------------*/
VOID FastSockFini(LPGLOBALDATA pgd)
{
	BOOL bReturn = TRUE;
	INT i;

	DPF(8,"==>FastSockFini\n");

	for(i=-1;i<NUM_EVENT_HANDLES;i++){
		CloseHandle(pgd->EventHandles[i]);
	}

	// Clean up player hash table entries

	FastSockCleanConnList(pgd);

	DeleteCriticalSection(&pgd->csFast);

	pgd->bFastSock=FALSE;

	DPF(8,"<==FastSockFini\n");
}


/*=============================================================================

	GetEventHandle - Allocate an event handle for the connection
	
    Description:


    Parameters:

    	pgd  - Service Provider's global data blob for this instance
    	pConn - connection to add processing for on the event.

    Return Values:


-----------------------------------------------------------------------------*/
BOOL GetEventHandle(LPGLOBALDATA pgd, PPLAYERCONN pConn)
{
	UINT i;
	int index;
	int iEvent=-1;	// index of event
	int iConn;	// index into connections on this event

	int bFoundSlot = FALSE;

	i=(pgd->iEventAlloc+(NUM_EVENT_HANDLES-1))%NUM_EVENT_HANDLES;

	while(pgd->iEventAlloc != i){


		if(pgd->EventList[pgd->iEventAlloc].nConn < MAX_EVENTS_PER_HANDLE){
			// Found a winner.
			iEvent = pgd->iEventAlloc;
			iConn=pgd->EventList[iEvent].nConn++;

			DPF(8,"GetEventHandle: For Conn %x, using Event index %d, Slot %d\n",pConn,iEvent,iConn);
			
			pgd->EventList[iEvent].pConn[iConn]=pConn;
			pConn->iEventHandle=iEvent;
			bFoundSlot=TRUE;
			pgd->nEventSlotsAvail--;
			DPF(8,"GetEventHandle: EventSlots Left %d\n",pgd->nEventSlotsAvail);
			if(!pgd->nEventSlotsAvail){
				DPF(0,"Out of Event slots, no new connections will be accepted\n");
			}
			break;
		}

		pgd->iEventAlloc = (pgd->iEventAlloc+1)%NUM_EVENT_HANDLES;
	}

	// advance the index so we distribute the load across the handles.
	pgd->iEventAlloc = (pgd->iEventAlloc+1)%NUM_EVENT_HANDLES;

	DPF(8,"iEventAlloc %d\n",pgd->iEventAlloc);

	ASSERT(iEvent != -1);

	return bFoundSlot;

}


/*=============================================================================

	FreeEventHandle - Remove the event handle for the connection
	
    Description:


    Parameters:

    	pgd  - Service Provider's global data blob for this instance
    	pConn - connection to remove processing for on the event.

    Return Values:


-----------------------------------------------------------------------------*/
VOID FreeEventHandle(LPGLOBALDATA pgd, PPLAYERCONN pConn)
{
	int iEvent;
	int iLastConn;
	UINT iConn;

	iEvent = pConn->iEventHandle;

	if(iEvent == INVALID_EVENT_SLOT){
		DPF(1,"WARN: tried to free invalid event\n");
		return;
	}

	for(iConn=0;iConn<pgd->EventList[iEvent].nConn;iConn++){

		if(pgd->EventList[iEvent].pConn[iConn]==pConn){

			ASSERT(pgd->EventList[iEvent].nConn);
			
			iLastConn = pgd->EventList[iEvent].nConn-1;

			// copy the last entry over this entry (could be 0 over 0, but who cares?)
			pgd->EventList[iEvent].pConn[iConn]=pgd->EventList[iEvent].pConn[iLastConn];
			pgd->EventList[iEvent].nConn--;

			ASSERT((INT)(pgd->EventList[iEvent].nConn) >= 0);
			
			pgd->nEventSlotsAvail++;
			pConn->iEventHandle = INVALID_EVENT_SLOT;
			DPF(8,"FreeEventHandle index %d Slot %d nConn %d on slot Total Slots Left %d\n",iEvent,iConn,pgd->EventList[iEvent].nConn,pgd->nEventSlotsAvail);
			return;
		}
	}

	DPF(0,"UH OH, couldn't free event handle!\n");
	DEBUG_BREAK();
	
}
/*=============================================================================

	FindPlayerById - Find the connection structure for a player
	
	
    Description:

		Finds a player and returns the connection structure with a reference


    Parameters:

    	pgd  - Service Provider's global data blob for this instance
		dpid - player id of the player we are trying to find connection for.

    Return Values:

		PPLAYERCONN - player connection structure
		NULL - Didn't find the player connection.

-----------------------------------------------------------------------------*/

PPLAYERCONN FindPlayerById(LPGLOBALDATA pgd, DPID dpid)
{
	PPLAYERCONN pConn;

	EnterCriticalSection(&pgd->csFast);

	pConn = pgd->PlayerHash[HashPlayer(dpid)];

	while(pConn && pConn->dwPlayerID != dpid){
		pConn = pConn->pNextP;
	}

	if(pConn){
		DPF(8,"FindPlayerById, found %x\n",pConn);
		DUMPCONN(pConn, 1);
		AddRefConn(pConn);
	}

	LeaveCriticalSection(&pgd->csFast);

	return pConn;
}

/*=============================================================================

	FindPlayerBySocket - Find the connection structure for a player
	
	
    Description:

		Finds a player and returns the connection structure with a reference

    Parameters:

    	pgd  - Service Provider's global data blob for this instance
		psockaddr - socketaddr of the player we are trying to find connection for.

    Return Values:

		PPLAYERCONN - player connection structure
		NULL - Didn't find the player connection.

-----------------------------------------------------------------------------*/

PPLAYERCONN FindPlayerBySocket(LPGLOBALDATA pgd, SOCKADDR *psockaddr)
{
	PPLAYERCONN pConn;

	EnterCriticalSection(&pgd->csFast);

	DEBUGPRINTADDR(8,"FindPlyrBySock",psockaddr);
	
	pConn = pgd->SocketHash[HashSocket(psockaddr)];

	while(pConn && !bSameAddr(psockaddr, &pConn->IOSock.sockaddr))
	{
		DEBUGPRINTADDR(8,"FPBS: doesn't match",&pConn->IOSock.sockaddr);
		pConn = pConn->pNextS;
	}

	if(pConn){
		DPF(8,"FindPlayerBySocket, found %x\n",pConn);
		DUMPCONN(pConn,1);
		AddRefConn(pConn);
	}

	LeaveCriticalSection(&pgd->csFast);

	return pConn;
}

/*=============================================================================

	CreatePlayerConn - Create a player connection structure
	
    Description: Fast lock must be held!


    Parameters:

    	pgd  - Service Provider's global data blob for this instance
		dpid - dpid of the player (if known, else DPID_UNKNOWN)
		psockaddr - socket address (if known)

    Return Values:

		ptr to created player conn, or NULL if we couldn't create (out of mem).

-----------------------------------------------------------------------------*/
PPLAYERCONN CreatePlayerConn(LPGLOBALDATA pgd, DPID dpid, SOCKADDR *psockaddr)
{
	PPLAYERCONN pConn;
	// Allocate and initialize a Player connection structure
	if(dpid != DPID_UNKNOWN && (pConn=FindPlayerById(pgd, dpid)))
	{
		return pConn; //Player already exists for this id.
	}

	if(!(pConn=SP_MemAlloc(sizeof(PLAYERCONN)+DEFAULT_RECEIVE_BUFFERSIZE)))
	{
		return pConn; //NULL
	}

	if(!GetEventHandle(pgd, pConn)){
		SP_MemFree(pConn);
		return NULL;		
	}

	pConn->pDefaultReceiveBuffer 	= (PCHAR)(pConn+1);
	pConn->pReceiveBuffer 			= pConn->pDefaultReceiveBuffer;
	pConn->cbReceiveBuffer 			= DEFAULT_RECEIVE_BUFFERSIZE;
	pConn->cbReceived      			= 0;

	pConn->dwRefCount   = 1;
	pConn->dwPlayerID 	= dpid;
	pConn->sSocket    	= INVALID_SOCKET;
	pConn->sSocketIn	= INVALID_SOCKET;
	pConn->dwFlags      = 0;

	pConn->bTrusted     = FALSE;

	InitBilink(&pConn->PendingConnSendQ);
	InitBilink(&pConn->InboundPendingList);

	if(psockaddr){
		// Don't yet know if this guy can re-use sockets, bang only
		// socket we know about so far into both slots.

		memcpy(&pConn->IOSock.sockaddr, psockaddr, sizeof(SOCKADDR));
		memcpy(&pConn->IOnlySock.sockaddr, psockaddr, sizeof(SOCKADDR));
	}


	DPF(8,"CreatedPlayerConn %x\n",pConn);
	DUMPCONN(pConn,3);

	return pConn;
	
}

/*=============================================================================

	DestroyPlayerConn - Remove the connection from any lists, shut down any
						active sockets.
	
    Description:


    Parameters:

    	pgd  - Service Provider's global data blob for this instance
		pConn 


    Return Values:

		Pulls the player Conn off of any hash tables and lists it lives on
		and gets rid of its existence count.  No guarantee that this will
		actually free the object though, that happens when the last reference
		is released.

-----------------------------------------------------------------------------*/
PPLAYERCONN CleanPlayerConn(LPGLOBALDATA pgd, PPLAYERCONN pConn, BOOL bHard)
{
	LINGER Linger;
	int err;
	LPREPLYLIST prd;

#ifdef DEBUG
		DWORD dwTime;

	dwTime=timeGetTime();
#endif		

	EnterCriticalSection(&pgd->csFast);

	DPF(8,"==>CLEANPLAYERCONN %x time %d\n",pConn,dwTime);
	DUMPCONN(pConn,3);
	
	// Remove from listening.

	FastPlayerEventSelect(pgd, pConn, FALSE);

	// Dump event handle.

	FreeEventHandle(pgd, pConn);

	// Remove from lists.
	if(pConn->dwFlags & PLYR_PENDINGLIST)
	{
		RemoveConnFromPendingList(pgd, pConn);
	}

	if(pConn->dwFlags & PLYR_DPIDHASH)
	{
		RemoveConnFromPlayerHash(pgd,pConn);
	}

	if(pConn->dwFlags & PLYR_SOCKHASH)
	{
		RemoveConnFromSocketHash(pgd,pConn);
	}
	
	// Close all sockets.

	// When closing the sockets we want to avoid a bunch of nastiness where data sometimes isn't delivered
	// because we close the socket before the data is sent, but we don't want to linger the socket because
	// then it gets into a TIME_WAIT state where the same connection cannot be re-established for 4 minutes
	// which wrecks havoc with our tests and can cause connection problems since DirectPlay uses a limited
	// range (100 ports) between machines.  So we set the socket to hard close (avoiding TIME_WAIT) but use
	// the "Reply" clean up code path to close the sockets down.

	if(pConn->sSocket != INVALID_SOCKET)
	{

		DPF(8,"Closing Socket %d\n",pConn->sSocket);
	
		Linger.l_onoff=TRUE; Linger.l_linger=0; // avoid TIME_WAIT
		if(SOCKET_ERROR == setsockopt( pConn->sSocket,SOL_SOCKET,SO_LINGER,(char FAR *)&Linger,sizeof(Linger)))
		{
			DPF(0,"DestroyPlayerConn:Couldn't set linger to short for hard close\n");
		}
		
		ENTER_DPSP();

		prd=SP_MemAlloc(sizeof(REPLYLIST));
		
		if(!prd){
			
			LEAVE_DPSP();

			DPF(8,"Closing Socket %d\n",pConn->sSocket);
			err=myclosesocket(pgd,pConn->sSocket);
			if(err == SOCKET_ERROR){
				err=WSAGetLastError();
				DPF(8,"Error Closing Socket %x, err=%d\n", pConn->sSocket,err);
			}
		} else {

			// very tricky, overloading the reply close list to close this socket with our own linger...
			prd->pNextReply=pgd->pReplyCloseList;
			pgd->pReplyCloseList=prd;
			prd->sSocket=pConn->sSocket;
			prd->tSent=timeGetTime();
			prd->lpMessage=NULL;

			LEAVE_DPSP();
		}
			
		pConn->sSocket=INVALID_SOCKET;
		if(pConn->sSocketIn==INVALID_SOCKET){
			pConn->dwFlags &= ~(PLYR_CONNECTED|PLYR_ACCEPTED);
		} else {
			pConn->dwFlags &= ~(PLYR_CONNECTED);
		}
	}

	if(pConn->sSocketIn != INVALID_SOCKET)
	{
		// may have to close another socket.
		DPF(8,"Closing SocketIn %d\n",pConn->sSocketIn);

		Linger.l_onoff=TRUE; Linger.l_linger=0; // avoid TIME_WAIT
		if(SOCKET_ERROR == setsockopt(pConn->sSocketIn,SOL_SOCKET,SO_LINGER,(char FAR *)&Linger,sizeof(Linger)))
		{
			DPF(0,"DestroyPlayerConn:Couldn't set linger to short for hard close\n");
		}

		ENTER_DPSP();

		prd=SP_MemAlloc(sizeof(REPLYLIST));
		
		if(!prd){
			LEAVE_DPSP();
			err=myclosesocket(pgd,pConn->sSocketIn);
			if(err == SOCKET_ERROR){
				err=WSAGetLastError();
				DPF(8,"Error Closing Socket %x, err=%d\n", pConn->sSocketIn,err);
			}
		} else {

			// very tricky, overloading the reply close list to close this socket with our own linger...
			prd->pNextReply=pgd->pReplyCloseList;
			pgd->pReplyCloseList=prd;
			prd->sSocket=pConn->sSocketIn;
			prd->tSent=timeGetTime();
			prd->lpMessage=NULL;

			LEAVE_DPSP();
		}	
			
		pConn->sSocketIn=INVALID_SOCKET;
		pConn->dwFlags &= ~(PLYR_ACCEPTED);
		
	}

	// Free extra buffer.
	if(pConn->pReceiveBuffer != pConn->pDefaultReceiveBuffer){
		SP_MemFree(pConn->pReceiveBuffer);
		pConn->pReceiveBuffer = pConn->pDefaultReceiveBuffer;
	}

	// Dump Send Queue if present.
	while(!EMPTY_BILINK(&pConn->PendingConnSendQ)){
	
		PSENDINFO pSendInfo;

		pSendInfo=CONTAINING_RECORD(pConn->PendingConnSendQ.next, SENDINFO, PendingConnSendQ);
		Delete(&pSendInfo->PendingConnSendQ);
		pSendInfo->Status = DPERR_CONNECTIONLOST;
		EnterCriticalSection(&pgd->csSendEx);
		pSendInfo->RefCount = 1;
		LeaveCriticalSection(&pgd->csSendEx);
		wsaoDecRef(pSendInfo);
		
	}

	DUMPCONN(pConn,3);
#ifdef DEBUG	
	dwTime = timeGetTime()-dwTime;
	if(dwTime > 1000){
		DPF(0,"Took way too long in CleanPlayerConn, elapsed %d ms\n",dwTime);
		//DEBUG_BREAK();	// removed break due to stress hits
	}
#endif	
	DPF(8,"<==CleanPlayerConn total time %d ms\n",dwTime);

	LeaveCriticalSection(&pgd->csFast);

	return pConn;
	
}

/*=============================================================================

	DecRefConn - Decrement reference on PlayerConn, when it hits 0, free it.
	
    Description:


    Parameters:

		pConn - player connection.

    Return Values:

		decrements the reference on a player conn.  If it hits 0, frees it.

-----------------------------------------------------------------------------*/
INT DecRefConn(LPGLOBALDATA pgd, PPLAYERCONN pConn)
{
	INT count;
	
	count=InterlockedDecrement(&pConn->dwRefCount);

	if(!count){
		CleanPlayerConn(pgd, pConn, FALSE);
		DPF(8,"Freeing Connection pConn %x\n",pConn);
		SP_MemFree(pConn);
	}

	#ifdef DEBUG
	if(count & 0x80000000){
		DPF(0,"DecRefConn: Conn refcount for conn %x has gone negative count %x\n",pConn,count);
		DUMPCONN(pConn,2);
		DEBUG_BREAK();
	}
	#endif
	
	return count;
}

/*=============================================================================

	DecRefConnExist - Dumps Existence ref if not already dumped.
	
    Description:


    Parameters:

		pConn - player connection.

    Return Values:

-----------------------------------------------------------------------------*/
INT DecRefConnExist(LPGLOBALDATA pgd, PPLAYERCONN pConn)
{
	INT count;

	EnterCriticalSection(&pgd->csFast);

	if(!(pConn->dwFlags & PLYR_DESTROYED)){
		pConn->dwFlags |= PLYR_DESTROYED;
		count=DecRefConn(pgd,pConn);
	} else {
		count=pConn->dwRefCount;
	}
	LeaveCriticalSection(&pgd->csFast);
	return count;
}

/*=============================================================================

	AddConnToPlayerHash - puts a connection in the player hash table.
	
    Description: The fast lock must be held!


    Parameters:

    	pgd   - Service Provider's global data blob for this instance
		pConn - connection to put in the hash table.

    Return Values:

		None.

-----------------------------------------------------------------------------*/

HRESULT AddConnToPlayerHash(LPGLOBALDATA pgd, PPLAYERCONN pConn)
{
	PPLAYERCONN pConn2;
	INT i;
	HRESULT hr=DP_OK;

	#ifdef DEBUG
	if(pConn->dwPlayerID == DPID_UNKNOWN){
		DEBUG_BREAK();
	}
	#endif

	ASSERT(!(pConn->dwFlags & PLYR_DPIDHASH));

	if(!(pConn->dwFlags & PLYR_DPIDHASH)){

		if(pConn2 = FindPlayerById(pgd, pConn->dwPlayerID)){
			DPF(0,"AddConnToPlayerHash: Player in %x id %d already exists, pConn=%x\n",pConn,pConn->dwPlayerID,pConn2);
			DecRefConn(pgd, pConn2);
			hr=DPERR_GENERIC;
			goto exit;
		}

		DPF(8,"Adding Conn %x to Player ID Hash\n",pConn);
		DUMPCONN(pConn,1);	

		// add a reference for being in the player hash table.
		AddRefConn(pConn);

		i=HashPlayer(pConn->dwPlayerID);

		ASSERT(i<PLAYER_HASH_SIZE);
		
		pConn->pNextP = pgd->PlayerHash[i];
		pgd->PlayerHash[i] = pConn;

		pConn->dwFlags |= PLYR_DPIDHASH;
	} else {
		DPF(1,"WARNING:tried to add Conn %x to Player Hash again\n",pConn);
	}

exit:
	return hr;
}

/*=============================================================================

	RemoveConnFromPlayerHash - pull a connection from the player hash table.
	
    Description:


    Parameters:

    	pgd   - Service Provider's global data blob for this instance
		pConn - connection to put in the hash table.

    Return Values:

		PPLAYERCONN - removed from hash, here it is.
		NULL - couldn't find it.

-----------------------------------------------------------------------------*/

PPLAYERCONN RemoveConnFromPlayerHash(LPGLOBALDATA pgd, PPLAYERCONN pConnIn)
{
	PPLAYERCONN pConn=NULL,pConnPrev;
	INT i;

	if(pConnIn->dwFlags & PLYR_DPIDHASH){

		i=HashPlayer(pConnIn->dwPlayerID);

		EnterCriticalSection(&pgd->csFast);
		
		pConn = pgd->PlayerHash[i];
		pConnPrev = CONTAINING_RECORD(&pgd->PlayerHash[i], PLAYERCONN, pNextP); // sneaky

		while(pConn && pConn != pConnIn){
			pConnPrev = pConn;
			pConn = pConn->pNextP;
		}

		if(pConn){
			DPF(8,"Removing Conn %x from Player ID Hash\n",pConn);
			DUMPCONN(pConn,1);	
			pConnPrev->pNextP = pConn->pNextP;
			pConn->dwFlags &= ~(PLYR_DPIDHASH);

			i=DecRefConn(pgd, pConn); // remove reference for player hash table
			ASSERT(i);
		}	

		LeaveCriticalSection(&pgd->csFast);

	}
	
	return pConn;
}

/*=============================================================================

	AddConnToSocketHash - puts a connection in the socket hash table.
	
    Description:


    Parameters:

    	pgd   - Service Provider's global data blob for this instance
		pConn - connection to put in the hash table.

    Return Values:

		None.

-----------------------------------------------------------------------------*/

HRESULT AddConnToSocketHash(LPGLOBALDATA pgd, PPLAYERCONN pConn)
{
	PPLAYERCONN pConn2;
	INT i;
	HRESULT hr=DP_OK;


	EnterCriticalSection(&pgd->csFast);

	if(!(pConn->dwFlags & PLYR_SOCKHASH)){

		if(pConn2 = FindPlayerBySocket(pgd, &pConn->IOSock.sockaddr)){
			DecRefConn(pgd, pConn2);
			DPF(0,"AddConnToPlayerHash: Player in %x id %d already exists, pConn=%x\n",pConn,pConn->dwPlayerID,pConn2);
			hr=DPERR_GENERIC;
			goto exit;
		}

		DPF(8,"Adding Conn %x to Socket Hash\n",pConn);
		DUMPCONN(pConn,1);	

		// add a reference for being in the socket hash.
		AddRefConn(pConn);

		i=HashSocket(&pConn->IOSock.sockaddr);

		ASSERT(i<SOCKET_HASH_SIZE);
		
		pConn->pNextS = pgd->SocketHash[i];
		pgd->SocketHash[i] = pConn;

		pConn->dwFlags |= PLYR_SOCKHASH;

	} else {
		DPF(0,"WARNING: tried to add pConn %x to socket hash again\n",pConn);
		DEBUG_BREAK();
	}

exit:
	LeaveCriticalSection(&pgd->csFast);
	return hr;
}

/*=============================================================================

	RemoveConnFromSockHash - pull a connection from the socket hash table.
	
    Description:


    Parameters:

    	pgd   - Service Provider's global data blob for this instance
		pConn - connection to put in the hash table.

    Return Values:

		PPLAYERCONN - removed from hash, here it is.
		NULL - couldn't find it.

-----------------------------------------------------------------------------*/

PPLAYERCONN RemoveConnFromSocketHash(LPGLOBALDATA pgd, PPLAYERCONN pConnIn)
{
	PPLAYERCONN pConn=NULL,pConnPrev;
	UINT i;

	if(pConnIn->dwFlags & PLYR_SOCKHASH){
	
		i=HashSocket(&pConnIn->IOSock.sockaddr);

		DPF(8,"Removing Player %x from Socket Hash\n",pConnIn);

		EnterCriticalSection(&pgd->csFast);

		pConn = pgd->SocketHash[i];
		pConnPrev = CONTAINING_RECORD(&pgd->SocketHash[i], PLAYERCONN, pNextS); // sneaky

		while(pConn && pConn!=pConnIn){
			pConnPrev = pConn;
			pConn = pConn->pNextS;
		}

		if(pConn){
			pConnPrev->pNextS = pConn->pNextS;
			pConn->dwFlags &= ~(PLYR_SOCKHASH);

			i=DecRefConn(pgd, pConn); // remove reference for socket hash table
			ASSERT(i);
		}

		LeaveCriticalSection(&pgd->csFast);
	}

	return pConn;

	
}

/*=============================================================================

	FindConnInPendingList - finds a connection from the pending list
	
    Description:

    Parameters:

    	pgd   - Service Provider's global data blob for this instance
		pConn - connection to put in the hash table.

    Return Values:

		PPLAYERCONN - pointer ot connection if found, and adds a reference.

-----------------------------------------------------------------------------*/
PPLAYERCONN FindConnInPendingList(LPGLOBALDATA pgd, SOCKADDR *psaddr)
{
	PPLAYERCONN pConnWalker=NULL, pConn=NULL;
	BILINK *pBilink;
	
	EnterCriticalSection(&pgd->csFast);

	pBilink=pgd->InboundPendingList.next;

	while(pBilink != &pgd->InboundPendingList){
		pConnWalker=CONTAINING_RECORD(pBilink, PLAYERCONN, InboundPendingList);
		if(bSameAddr(psaddr, &pConnWalker->IOnlySock.sockaddr)){
			AddRefConn(pConnWalker);
			pConn=pConnWalker;
			break;
		}
		pBilink=pBilink->next;
	}

	if(pConn){
		DPF(8,"Found Conn %x in Pending List\n",pConn);
		DUMPCONN(pConn,3);
		AddRefConn(pConn);
	}

	LeaveCriticalSection(&pgd->csFast);

	return pConn;
}


/*=============================================================================

	AddConnToPendingList - puts a connection on the pending list
	
    Description:

		The Pending list keeps the list of connections that we have received
		from, but haven't received any information on yet.  Until we receive
		from one of these connections, we don't have any way to know exactly
		who the connection is from.  When we receive from one of these with
		a return address in the message, we can make an association with
		an outbound connection (if present) and can put this node in the
		socket hash table at that time.


    Parameters:

    	pgd   - Service Provider's global data blob for this instance
		pConn - connection to put in the hash table.

    Return Values:

		None.

-----------------------------------------------------------------------------*/

HRESULT AddConnToPendingList(LPGLOBALDATA pgd, PPLAYERCONN pConn)
{
	PPLAYERCONN pConn2;
	INT i;
	HRESULT hr=DP_OK;

	EnterCriticalSection(&pgd->csFast);

	if(pConn2 = FindConnInPendingList(pgd, &pConn->IOnlySock.sockaddr)){
		// OPTIMIZATION: should we remove the socket from the list here, it must be old.
		DPF(0,"AddConnToPendingList: Player in %x id %d already exists, pConn=%x\n",pConn,pConn->dwPlayerID,pConn2);
		DecRefConn(pgd, pConn2);
		hr=DPERR_GENERIC;
		goto exit;
	}

	InsertAfter(&pConn->InboundPendingList,&pgd->InboundPendingList);

	AddRefConn(pConn);
	pConn->dwFlags |= PLYR_PENDINGLIST;

	DPF(8,"Added Conn %x to PendingList\n",pConn);

exit:	
	LeaveCriticalSection(&pgd->csFast);
	return hr;
}

/*=============================================================================

	RemoveConnFromPendingList
	
    Description:

    Parameters:

    	pgd   - Service Provider's global data blob for this instance
		pConn - connection to put in the hash table.

    Return Values:

		None.

-----------------------------------------------------------------------------*/

VOID RemoveConnFromPendingList(LPGLOBALDATA pgd, PPLAYERCONN pConn)
{
	if(pConn->dwFlags & PLYR_PENDINGLIST)
	{
		ASSERT(!EMPTY_BILINK(&pConn->InboundPendingList));
		Delete(&pConn->InboundPendingList);
		pConn->dwFlags &= ~(PLYR_PENDINGLIST);
		DecRefConn(pgd, pConn);
		DPF(8,"Removed Conn %x From Pending List\n",pConn);
	}
}

/*=============================================================================

	GetPlayerConn - Finds or creates a player conn and starts connecting it.
	
    Description:


    Parameters:

    	pgd  - Service Provider's global data blob for this instance
		dpid - dpid of the player (if known)
		psockaddr - socket address (if known)

    Return Values:

		if found, creates a reference.

-----------------------------------------------------------------------------*/
PPLAYERCONN GetPlayerConn(LPGLOBALDATA pgd, DPID dpid, SOCKADDR *psockaddr)
{
	PPLAYERCONN pConn=NULL;
	SOCKET sSocket;
	SOCKADDR_IN saddr;
	INT rc,err;
	DWORD dwSize;
	BOOL bTrue=TRUE;
	u_long lNonBlock = 1; // passed to ioctlsocket to make socket non-blocking
	u_long lBlock = 0; // passed to ioctlsocket to make socket blocking

	BOOL bCreated=FALSE;


	EnterCriticalSection(&pgd->csFast);
	
	// Do we already know this player by id?
	if(dpid != DPID_UNKNOWN) {
		if (pConn=FindPlayerById(pgd, dpid))
		{
			DPF(8,"GetPlayerConn: Found Con for dpid %x pConn %x\n",dpid,pConn);
			goto exit; //Player already exists for this id.
		}
	} 
	
	if(pConn=FindPlayerBySocket(pgd, psockaddr)){
		if(pConn->dwFlags & (PLYR_CONNECTED|PLYR_CONN_PENDING))
		{
			DPF(8,"GetPlayerConn: Found Conn by socketaddr pConn %x\n",pConn);
			if(dpid != DPID_UNKNOWN){
				pConn->dwPlayerID=dpid;
				AddConnToPlayerHash(pgd, pConn);
			}	
			DUMPCONN(pConn,1);
			goto exit;
		}
		
	} else {
	
		// do we already know this player by connection?
		if(psockaddr && (pConn=FindConnInPendingList(pgd, psockaddr)) )
		{
			//NOTE: I think we always catch this case in FastCombine
			//       We may get it before the combine happens?
			if(!(pConn->dwFlags & PLYR_CONNECTED|PLYR_CONN_PENDING)){ //only once...
			
				// hey, this is a bi-directional socket, so make it so.
				ASSERT(pConn->dwPlayerID == DPID_UNKNOWN);

				if((dpid != DPID_UNKNOWN) && (pConn->dwPlayerID == DPID_UNKNOWN))
				{
					ASSERT(! (pConn->dwFlags & PLYR_DPIDHASH));
					pConn->dwPlayerID = dpid; 
					AddConnToPlayerHash(pgd, pConn);
				}

				if(!(pConn->dwFlags & PLYR_SOCKHASH)){
					AddConnToSocketHash(pgd, pConn);
				}	

				ASSERT(pConn->sSocketIn != INVALID_SOCKET);
				ASSERT(pConn->sSocket == INVALID_SOCKET);
				pConn->sSocket = pConn->sSocketIn;
				pConn->sSocketIn = INVALID_SOCKET;
				
				if(pConn->dwFlags & PLYR_ACCEPTED){
					pConn->dwFlags |= (PLYR_CONNECTED | PLYR_NEW_CLIENT);
				} else {
					ASSERT(pConn->dwFlags & PLYR_ACCEPT_PENDING);
					pConn->dwFlags |= (PLYR_CONN_PENDING | PLYR_NEW_CLIENT);
				}

				RemoveConnFromPendingList(pgd,pConn); // found a home, don't need on pending list anymore

			}

			DPF(8,"GetPlayerConn FoundConn in Pending List pConn %x\n",pConn);
			DUMPCONN(pConn,3);
			goto exit;

		}

	}

	// Have critical section...
	
	// Doesn't already exist, so create one.

	if(!pConn){
		DPF(8,"GetPlayerConn: No Conn Found, creating\n");
		pConn = CreatePlayerConn(pgd, dpid, psockaddr);
		if(!pConn){
			DPF(8, "CreatePlayerConn Failed\n");
			goto exit;
		}	
		if(dpid != DPID_UNKNOWN)AddConnToPlayerHash(pgd, pConn);
		if(psockaddr)AddConnToSocketHash(pgd,pConn);
		bCreated=TRUE;
		AddRefConn(pConn); // need ref to return to caller.
	} else {
		// already have ref to return to caller as result of find.
	}

	// have critical section and a pConn, maybe created (see bCreated), and a return ref.

	ASSERT(pConn->sSocket == INVALID_SOCKET);
	ASSERT(!(pConn->dwFlags & (PLYR_CONN_PENDING|PLYR_CONNECTED)));

	//if(pgd->bSeparateIO && !(pgd->SystemStreamPortOut))
	ASSERT(pgd->bSeparateIO);
	{
		// Workaround Win9x < Millennium sockets bug.  Can't use same port for
		// inbound/outbound traffic, because Win9x will not accept connections in 
		// some cases.  So we create a socket for outbound traffic (and re-use
		// that port for all outbound traffic).

		
		rc=CreateSocket(pgd, &sSocket, SOCK_STREAM, 0, INADDR_ANY, &err, FALSE);

		if(rc != DP_OK){
			DPF(0,"Couldn't create Outbound socket on Win9x < Millennium platform, rc=%x , wserr=%d\n",rc, err);
			goto err_exit;
		}

		dwSize = sizeof(saddr);
		err=getsockname(sSocket, (SOCKADDR *)&saddr, &dwSize);

		if(err){
			DPF(0,"Couldn't get socket name?\n");
			DEBUG_BREAK();
		}

		//pgd->SystemStreamPortOut = saddr.sin_port;
		//DPF(2,"System stream out port is now %d.",ntohs(pgd->SystemStreamPortOut));
		DPF(2,"Stream out socket %x port is now %d.",sSocket, ntohs(saddr.sin_port));


		bTrue = SetSharedPortAccess(sSocket);
		if (! bTrue)
		{
			DPF(0,"Failed to to set shared mode on socket - continue\n");
		}
	}
	/*
	else
	{
		// Normal execution path. 

		sSocket = socket(AF_INET, SOCK_STREAM, 0);


		// Bind it to our system address (so we only use one address for a change)
		memset(&saddr,0,sizeof(SOCKADDR_IN));
		saddr.sin_family	  = AF_INET;
		saddr.sin_addr.s_addr = htonl(INADDR_ANY);
		if(pgd->bSeparateIO && pgd->SystemStreamPortOut){
			saddr.sin_port        = pgd->SystemStreamPortOut;	// part of Win9x Hack. (see above)
		} else {
			saddr.sin_port        = pgd->SystemStreamPort;
		}	

		ASSERT(pgd->SystemStreamPort);
		DPF(7,"Using port %d.",ntohs(saddr.sin_port));

		// Set socket for address re-use
		bTrue = SetSharedPortAccess(sSocket);
		if (! bTrue)
		{
			DPF(0,"Failed to to set shared mode on socket - continue\n");
		}
		
		rc = bind(sSocket, (SOCKADDR *)&saddr, sizeof(saddr));

		if(rc){
			err = WSAGetLastError();
			DPF(0,"Failed to bind socket to port %d, error=%d.",ntohs(saddr.sin_port),err);
			goto err_exit;	// sends will fail until player killed.
		}
	}
	*/

				
	// turn ON keepalive
	if (SOCKET_ERROR == setsockopt(sSocket, SOL_SOCKET, SO_KEEPALIVE, (CHAR FAR *)&bTrue, sizeof(bTrue)))
	{
		err = WSAGetLastError();
		DPF(0,"Failed to turn ON keepalive - continue : err = %d\n",err);
	}

	ASSERT(bTrue);
	
	// turn off nagling - always, avoids race on closing socket w/o linger, otherwise must linger socket.

		DPF(5, "Turning nagling off on outbound socket");
		if (SOCKET_ERROR == setsockopt(sSocket, IPPROTO_TCP, TCP_NODELAY, (CHAR FAR *)&bTrue, sizeof(bTrue)))
		{
			err = WSAGetLastError();
			DPF(0,"Failed to turn off naggling - continue : err = %d\n",err);
		}

	// update connection info.
	
	pConn->dwFlags |= PLYR_CONN_PENDING;
	pConn->sSocket = sSocket;
	
	//
	// Now Connect this puppy
	//

	// set socket to non-blocking
	rc = ioctlsocket(sSocket,FIONBIO,&lNonBlock);
	if (SOCKET_ERROR == rc)
	{
		err = WSAGetLastError();
		DPF(0,"could not set non-blocking mode on socket err = %d!",err);
		DPF(0,"will revert to synchronous behavior.  bummer");
	}

	FastPlayerEventSelect(pgd,pConn, TRUE);


	DEBUGPRINTADDR(4, "Fast connecting socket:", psockaddr);

	rc = connect(sSocket,psockaddr,sizeof(SOCKADDR));
	
	if(SOCKET_ERROR == rc)
	{
		err = WSAGetLastError();
		if(err == WSAEISCONN || err == WSAEADDRINUSE || err == WSAEACCES){
			// must be an accept about to happen
			DPF(8,"Hey, we're already connected! got extended error %d on connect\n",err);
			pConn->dwFlags |= PLYR_ACCEPT_PENDING;
		} else if (err == WSAEWOULDBLOCK) {
			// this is what we should normally get.
			DPF(8,"Conn is pending connection %x\n",pConn);	
		} else if (err == WSAEHOSTUNREACH) {
			DEBUGPRINTADDR(8,"Can't reach host, not connecting\n",psockaddr);
			goto err_exit;
		} else if (err == WSAENOBUFS) {
			DEBUGPRINTADDR(8,"Winsock out of memory, not connecting\n",psockaddr);
			goto err_exit;
		} else {
			DPF(0,"Trying to connect UH OH, very bad things, err=%d\n",err);
			DEBUG_BREAK();
			goto err_exit;	// sends will fail until player deleted.
		}
	} else {
		// Very unlikely, but WOO HOO, connected.
		DPF(0,"Very surprising, connect didn't return pending on async call?");
		pConn->dwFlags &= ~(PLYR_CONN_PENDING);
		pConn->dwFlags |= PLYR_CONNECTED;
	}

exit:
	LeaveCriticalSection(&pgd->csFast);

	DPF(8,"<===GetPlayerConn %x\n",pConn);
	return pConn;

err_exit:
	pConn->dwFlags &= ~(PLYR_CONN_PENDING);
	if(bCreated){
		// better blow it away.
		DPF(0,"GetPlayerConn: Severe error connection Conn we made, so blowing it away.\n");
		CleanPlayerConn(pgd,pConn,TRUE);  // clean up
		DecRefConnExist(pgd,pConn);  // dump existence
		DecRefConn(pgd,pConn);       // bye bye...(ref we had for caller)
	} else {
		if(pConn) { 
			DecRefConn(pgd,pConn);
		}		
	}
	pConn=NULL; // Connection Lost.

	goto exit;
}

/*=============================================================================

	FastPlayerEventSelect - start listening for events for a player.
	
    Description:

		Starts the appropriate events waiting for a signal for a 
		PlayerConn structure.


    Parameters:

    	pgd   - Service Provider's global data blob for this instance
		pConn - Player to start waiting for events on

    Return Values:


-----------------------------------------------------------------------------*/

HRESULT FastPlayerEventSelect(LPGLOBALDATA pgd, PPLAYERCONN pConn, BOOL bSelect)
{

	HRESULT hr=DP_OK;
	DWORD lEvents;
	INT rc;
	UINT err;

	DPF(8,"FastPlayerEventSelect pConn %x, bSelect %d\n",pConn, bSelect);
	DUMPCONN(pConn,0);

	if(pConn->sSocket != INVALID_SOCKET){
		if(bSelect){
			lEvents = FD_READ|FD_CLOSE;
			if(pConn->dwFlags & PLYR_CONN_PENDING){
				lEvents |= FD_CONNECT;
			}
			if(!EMPTY_BILINK(&pConn->PendingConnSendQ)){
				lEvents |= FD_WRITE;
			}
		} else {
			lEvents = 0;
		}
		DPF(8,"Selecting %x on IO Socket...\n",lEvents);
		DEBUGPRINTADDR(8,"IO Socket",&pConn->IOSock.sockaddr);
		rc=g_WSAEventSelect(pConn->sSocket, pgd->EventHandles[pConn->iEventHandle],lEvents);
		if(rc == SOCKET_ERROR){
			err = WSAGetLastError();
			DPF(0,"FastPlayerEventSelect: failed to do select on 2-way socket extended error=%d\n",err);
			hr=DPERR_GENERIC;
		}
	}

	if(pConn->sSocketIn != INVALID_SOCKET){
		if(bSelect){
			lEvents = FD_READ|FD_CLOSE;
		} else {
			lEvents = 0;
		}
		DPF(8,"Selecting %x on IOnly Socket...\n",lEvents);
		DEBUGPRINTADDR(8,"IOnly Socket",&pConn->IOnlySock.sockaddr);
		rc=g_WSAEventSelect(pConn->sSocketIn, pgd->EventHandles[pConn->iEventHandle], lEvents);
		if(rc == SOCKET_ERROR){
			err = WSAGetLastError();
			DPF(0,"FastPlayerEventSelect: failed to do select on receive-only socket extended error=%d\n",err);
			hr=DPERR_GENERIC;
		}
 	}
 	DPF(8,"<==FastPlayerEventSelect pConn %x\n",pConn);
 	return hr;
}




/*=============================================================================

	FastStreamReceiveThreadProc - version of stream recevie thread proc
								  that uses Winsock 2.0 functions for 
								  greater speed.
	
    Description:


    Parameters:

    	pgd   - Service Provider's global data blob for this instance
		pConn - connection to put in the hash table.

    Return Values:

		PPLAYERCONN - removed from hash, here it is.
		NULL - couldn't find it.

-----------------------------------------------------------------------------*/


DWORD WINAPI FastStreamReceiveThreadProc(LPVOID pvCast)
{
	IDirectPlaySP * pISP = (IDirectPlaySP *)pvCast;

	HRESULT 		hr;
	UINT 			i,j;
	UINT			err; 
	INT				rc;
	DWORD 			dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA 	pgd;

	WSANETWORKEVENTS NetEvents1, NetEvents2;
	LPWSANETWORKEVENTS pNetEvents1, pNetEvents2;
							
	DWORD			Event;
	PPLAYERCONN	pConn;
	DWORD		nConn;
	
	// get the global data
	hr = pISP->lpVtbl->GetSPData(pISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("FastStreamReceiveThreadProc: couldn't get SP data from DirectPlay - failing");
		ExitThread(0);
		return 0;
	}

	pgd->pISP = pISP;	// why not do this somewhere easier? -- because old dplay didn't.

	listen(pgd->sSystemStreamSocket, 200);
	
	err = g_WSAEventSelect(pgd->sSystemStreamSocket, pgd->hAccept, FD_ACCEPT);

	if(err){
		err = WSAGetLastError();
		DPF(0,"FastStreamReceiveThreadProc: Event select for accept socket failed err=%d\n",err);
		ExitThread(0);
		return 0;
	}

    while (1)
    {

		if (pgd->bShutdown)
		{
			DPF(2,"FastStreamReceiveThreadProc: detected shutdown - bailing");
			goto CLEANUP_EXIT;
		}

		Event=WaitForMultipleObjectsEx(NUM_EVENT_HANDLES+1, &pgd->hAccept, FALSE, 2500, TRUE);

		if(Event != WAIT_TIMEOUT)
		{
			i = Event - WAIT_OBJECT_0;
			if( i <= NUM_EVENT_HANDLES)
			{

				DPF(8,"GotSignal on iEvent %d Event %x\n", i, pgd->EventHandles[i]);
				// Go to the signalled object and look for events on its sockets.

				if(i != 0){

					i--;	// go from hAccept based index to table index.

					EnterCriticalSection(&pgd->csFast);

					// loop through the connections tied to this event and 
					// see if there is any work to do for this connection.

					nConn=pgd->EventList[i].nConn;
					
					for (j=0;j<nConn;j++){
					
						pConn = pgd->EventList[i].pConn[j];

						if(pConn){

							AddRefConn(pConn); // lock it down.

							pConn->bCombine=FALSE;

							// Check for events on the connection.
							NetEvents1.lNetworkEvents=0;
							NetEvents2.lNetworkEvents=0;
							pNetEvents1=NULL;
							pNetEvents2=NULL;
							
							if(pConn->sSocket != INVALID_SOCKET){
								rc=g_WSAEnumNetworkEvents(pConn->sSocket, 0, &NetEvents1);
								if(NetEvents1.lNetworkEvents){
									pNetEvents1 = &NetEvents1;
								}
							}
							if(pConn->sSocketIn != INVALID_SOCKET){
								rc=g_WSAEnumNetworkEvents(pConn->sSocketIn, 0, &NetEvents2);
								if(NetEvents2.lNetworkEvents){
									pNetEvents2 = &NetEvents2;
								}
							}
							if(pNetEvents1 || pNetEvents2){
								DPF(8,"Found Events on Connection %x\n",pConn);
								// There are events for this connection, deal with it!
								hr=ProcessConnEvents(pgd, pConn, pNetEvents1, pNetEvents2); // can drop csFast

								if(FAILED(hr)){
									if(hr==DPERR_CONNECTIONLOST){
										CleanPlayerConn(pgd, pConn, TRUE);
										DecRefConnExist(pgd, pConn); // destory existence ref.
									} else {
										DPF(0,"Unexpected error processing connection events err=%x\n",hr);
									}
								}	
							}	

							if(pConn->bCombine || (nConn != pgd->EventList[i].nConn)){
								// list changed, re-scan.
								nConn = pgd->EventList[i].nConn;
								j=0;
							}
							DecRefConn(pgd, pConn); // set it free

						}
					}
					
					LeaveCriticalSection(&pgd->csFast);
	
				} else {
					// it's the accept socket, someone just connected to us. Yeah!
					do{
						rc = g_WSAEnumNetworkEvents(pgd->sSystemStreamSocket,0,&NetEvents1);
	  					if(NetEvents1.lNetworkEvents & FD_ACCEPT)
	  					{
	  						EnterCriticalSection(&pgd->csFast);
	  						FastAccept(pgd, &NetEvents1);
	  						LeaveCriticalSection(&pgd->csFast);
	  					}	
					}while(NetEvents1.lNetworkEvents & FD_ACCEPT);


				}
			}
		} 

        
	}// while TRUE

CLEANUP_EXIT:
	    
    return 0;
    
} // StreamReceiveThreadProc

/*=============================================================================

	FastHandleMessage - Indicate a message to the DirectPlay layer.
	
    Description:


    Parameters:

    	pgd   - Service Provider's global data blob for this instance
		pConn - connection to put in the hash table.

    Return Values:


-----------------------------------------------------------------------------*/

HRESULT FastHandleMessage(LPGLOBALDATA pgd, PPLAYERCONN *ppConn)
{
	PPLAYERCONN pConn = *ppConn;
	
	if(SP_MESSAGE_TOKEN(pConn->pReceiveBuffer)==TOKEN && pConn->cbReceived != SPMESSAGEHEADERLEN)
	{
		ASSERT(pgd->AddressFamily == AF_INET);
		
		if(pConn->dwFlags & PLYR_NEW_CLIENT){
			IP_SetAddr((LPVOID)pConn->pReceiveBuffer, &pConn->IOSock.sockaddr_in);
		} else {
			IP_SetAddr((LPVOID)pConn->pReceiveBuffer, &pConn->IOnlySock.sockaddr_in);
		}

		if( !(pConn->dwFlags & PLYR_OLD_CLIENT)	&& 	// already combined
		     (pConn->sSocket == INVALID_SOCKET)	&&	// just checking
		    !(pConn->lNetEventsSocketIn & FD_CLOSE) // don't bother if we're gonna blow it away
		    ){
			LPMESSAGEHEADER phead = (LPMESSAGEHEADER)pConn->pReceiveBuffer;
			pConn=*ppConn=FastCombine(pgd, pConn, &(phead->sockaddr));
		}

		LeaveCriticalSection(&pgd->csFast);

#if DUMPBYTES
		{
			PCHAR pBuf;
			UINT buflen;
			UINT i=0;

			pBuf = pConn->pReceiveBuffer+sizeof(MESSAGEHEADER);
			buflen = pConn->cbReceived-sizeof(MESSAGEHEADER);

			while (((i + 16) < buflen) && (i < 4*16)){
				DPF(9, "%08x %08x %08x %08x",*(PUINT)(&pBuf[i]),*(PUINT)(&pBuf[i+4]),*(PUINT)(&pBuf[i+8]),*(PUINT)(&pBuf[i+12]));
				i += 16;
			}	
		}
#endif

		pgd->pISP->lpVtbl->HandleMessage(pgd->pISP, 
										 pConn->pReceiveBuffer+sizeof(MESSAGEHEADER),
										 pConn->cbReceived-sizeof(MESSAGEHEADER), 
										 pConn->pReceiveBuffer);

		EnterCriticalSection(&pgd->csFast);

		if(pConn->pReceiveBuffer != pConn->pDefaultReceiveBuffer){
			DPF(8,"Releasing big receive buffer of size %d\n",pConn->cbReceiveBuffer);
			SP_MemFree(pConn->pReceiveBuffer);
		}
		pConn->cbReceived=0;
		pConn->cbExpected=0;
		pConn->cbReceiveBuffer = DEFAULT_RECEIVE_BUFFERSIZE;
		pConn->pReceiveBuffer=pConn->pDefaultReceiveBuffer;

		if(pConn->pReceiveBuffer != (PCHAR)(pConn+1)){
		    DEBUG_BREAK();
		}

	}

	return DP_OK;
}

/*=============================================================================

	FastReceive - Receive data on a connection.
	
    Description:

		First receives a message header, then receives the message.
		When a full message is received, it is indicated.


    Parameters:

    	pgd   - Service Provider's global data blob for this instance
		pConn - connection to put in the hash table.

    Return Values:


-----------------------------------------------------------------------------*/
HRESULT FastReceive(LPGLOBALDATA pgd, PPLAYERCONN *ppConn)
{
	PPLAYERCONN pConn;
	PCHAR pBuffer;			// receive buffer pointer.
	DWORD cbBuffer;			// receive buffer size.
	SOCKET sSocket;			// socket to receive on
	INT		err;			// sockets error.
	DWORD	cbReceived;		// actual bytes received on this recv call.

	DWORD	cbMessageSize=0;	// size of the message to receive
	HRESULT hr;

	pConn=*ppConn;

	if(pConn->cbExpected == 0){
		// all messages have a header, let get that first.
		pConn->cbExpected = SPMESSAGEHEADERLEN;
	}

	// point to place in buffer we're going to receive latest data.
	// don't get more than we expect, or we would have to be smart
	// about setting up messages.
	pBuffer  = pConn->pReceiveBuffer+pConn->cbReceived;
	cbBuffer = pConn->cbExpected-pConn->cbReceived;

  if(cbBuffer > pConn->cbReceiveBuffer){
      DPF(0,"Receive would overrun buffer\n");
      DEBUG_BREAK();
  }

	if(pConn->dwFlags & PLYR_NEW_CLIENT){
		// new client does bi-directional on socket.
		sSocket = pConn->sSocket;
	} else {
		// old clients have separate receive socket.
		sSocket = pConn->sSocketIn;
	}

	ASSERT(sSocket != INVALID_SOCKET);

	DPF(8,"Attempting to receive %d bytes", cbBuffer);
   	DEBUGPRINTSOCK(8,">>> receiving data on socket - ",&sSocket);

	cbReceived = recv(sSocket, pBuffer, cbBuffer, 0); // <----- Receive that data!

	if(cbReceived == 0){
		// remote side has shutdown connection gracefully
   		DEBUGPRINTSOCK(8,"<<< received notification on socket - ",&sSocket);
		DEBUGPRINTSOCK(5,"Remote side has shutdown connection gracefully - ",&sSocket);
		hr = DPERR_CONNECTIONLOST;
		goto ERROR_EXIT;

	} else if (cbReceived == SOCKET_ERROR){
		err = WSAGetLastError();
		if(err == WSAEWOULDBLOCK){
			DPF(1,"WARN: Got WSAEWOULDBLOCK on non-blocking receive, round and round we go...\n");
			goto exit;
		}
   		DEBUGPRINTSOCK(8,"<<< received notification on socket - ",&sSocket);
		DPF(0,"STREAMRECEIVEE: receive error - err = %d",err);
		hr = DPERR_CONNECTIONLOST;            
		goto ERROR_EXIT;

	}

	DPF(5, "received %d bytes", cbReceived);

	pConn->cbReceived += cbReceived;

	if(pConn->cbReceived == SPMESSAGEHEADERLEN){
		// got the header, set up for the body of the message.
		if(VALID_DPWS_MESSAGE(pConn->pReceiveBuffer))
		{
			cbMessageSize = SP_MESSAGE_SIZE(pConn->pReceiveBuffer);
		} else {
			// Bad data.  Shut this baby down!
			DPF(2,"got invalid message - token = 0x%08x",SP_MESSAGE_TOKEN(pConn->pReceiveBuffer));
			hr = DPERR_CONNECTIONLOST;
			goto ERROR_EXIT;
		}
		
	}

	if(cbMessageSize)
	{

		pConn->cbExpected = cbMessageSize;

		if(cbMessageSize > DEFAULT_RECEIVE_BUFFERSIZE){

			if(!pConn->bTrusted){
				// until the connection is trusted, don't allow big messages to come in.
				DPF(0,"Rejecting large receive size %d, on untrusted connection pConn %x, dropping link",cbMessageSize);
				hr=DPERR_CONNECTIONLOST;
				goto ERROR_EXIT;
			}
			
			pConn->pReceiveBuffer = SP_MemAlloc(cbMessageSize);
			if(!pConn->pReceiveBuffer){
				DPF(0,"Failed to allocate receive buffer for message - out of memory");
				hr=DPERR_CONNECTIONLOST;
				goto ERROR_EXIT;
			}
			pConn->cbReceiveBuffer = cbMessageSize;
			// copy header into new message buffer
			memcpy(pConn->pReceiveBuffer, pConn->pDefaultReceiveBuffer, SPMESSAGEHEADERLEN);
		}
	}

	if(pConn->cbExpected == pConn->cbReceived)
	{
		// hey, got a whole message, send it up.
		hr = FastHandleMessage(pgd, ppConn);		// <---- INDICATE THE MESSAGE
		#ifdef DEBUG
		if(pConn != *ppConn){
			DPF(8,"Connections pConn %x pNewConn %x combined\n",pConn, *ppConn);
		}
		#endif
		pConn = *ppConn;
	
		if(FAILED(hr)){
			goto ERROR_EXIT;
		}
		
	}

exit:
	return DP_OK;

	ERROR_EXIT:
		return hr;
}


/*=============================================================================

	QueueSendOnConn - queue a send on a connection until we know it is ok to send.
	
    Description:

		Note: can only have 1 send outstanding to winsock per socket because of a winsock bug.

    Parameters:

    	pgd   - Service Provider's global data blob for this instance
		pConn - connection to put in the hash table.
		pSendInfo - send to queue.

    Return Values:

		PPLAYERCONN - removed from hash, here it is.
		NULL - couldn't find it.

-----------------------------------------------------------------------------*/
VOID QueueSendOnConn(LPGLOBALDATA pgd, PPLAYERCONN pConn, PSENDINFO pSendInfo)
{
	EnterCriticalSection(&pgd->csFast);
		InsertBefore(&pSendInfo->PendingConnSendQ, &pConn->PendingConnSendQ);
	LeaveCriticalSection(&pgd->csFast);
}

/*=============================================================================

	QueueNextSend - Move a pending send into the real sendq.
	
    Description:


    Parameters:

    	pgd   - Service Provider's global data blob for this instance
		pConn - connection to put in the hash table.
		pSendInfo - send to queue.

    Return Values:

		PPLAYERCONN - removed from hash, here it is.
		NULL - couldn't find it.

-----------------------------------------------------------------------------*/

VOID QueueNextSend(LPGLOBALDATA pgd,PPLAYERCONN pConn)
{
	BILINK *pBilink;
	
	EnterCriticalSection(&pgd->csFast);

	DPF(8,"==>QueueNextSend pConn %x",pConn);

	while(!EMPTY_BILINK(&pConn->PendingConnSendQ) && !pConn->bSendOutstanding)
	{
		PSENDINFO pSendInfo;
		
		pBilink=pConn->PendingConnSendQ.next;
		pSendInfo=CONTAINING_RECORD(pBilink, SENDINFO, PendingConnSendQ);
		Delete(pBilink);
		DPF(8,"QueueNextSend: Queuing pConn %x pSendInfo %x\n",pConn,pSendInfo);
		QueueForSend(pgd,pSendInfo);
	}

	DPF(8,"<==QueueNextSend pConn %x",pConn);

	LeaveCriticalSection(&pgd->csFast);
}

/*=============================================================================

	FastCombine - see if this socket should be made bidirectional
	
    Description:

	There are 3 cases where we want to combine connections.

	1.  We have accepted the connection, we receive data and that
	    data tells us the back connection is an existing outbound
	    connection.  In this case we combine the connections

	    a. The return address is the same as the from address, 
	       in this case it is a NEW client, and we mark it so
	       and will use the same connection for outbound traffic

	    b. The return address is different thant the from address
	       in this case it is an OLD client, and we mark it so
	       and will need to establish the outbound connection 
	       later.

	2.  We receive data on a connection and there is no outbound
	    connection yet, but inbound and outbound connections are
	    different.  We know that it is an "old" client and
	    eventually we will have to connect back.  We mark the
	    connection as OLD and when the connection back is 
	    made it will use this same Connection since it will match
	    up on the target address.
	    
    Parameters:

    	pgd   - Service Provider's global data blob for this instance
		pConn - connection to put in the hash table.
		psockaddr - outbound socket address.

    Return Values:

    	PPLAYERCONN pConn - if this isn't the same as the pConn on the way
    						in, then the connections have been combined.
    					  - the old connection will disappear when decrefed.
    					  - a reference is added for the returned connection
    					    if it is not the original.

	Note: csFast Held across this call.  Nothing here is supposed to block...?

-----------------------------------------------------------------------------*/
PPLAYERCONN FastCombine(LPGLOBALDATA pgd, PPLAYERCONN pConn, SOCKADDR *psockaddr_in)
{
	PPLAYERCONN pConnFind=NULL;
	SOCKADDR sockaddr,*psockaddr;
	// See if there is already a player with this target address...

	DPF(8,"==>FastCombine pConn %x\n",pConn);
	DEBUGPRINTADDR(8,"==>FastCombine saddr",psockaddr_in);

	#if USE_RSIP
	if(pgd->sRsip != INVALID_SOCKET){
		HRESULT hr;
		hr=rsipQueryLocalAddress(pgd, TRUE, psockaddr_in, &sockaddr);
		if(hr==DP_OK){
			psockaddr=&sockaddr;
		} else {
			psockaddr=psockaddr_in;
		}
	} else {
		psockaddr=psockaddr_in;
	}
	#elif USE_NATHELP
	if(pgd->pINatHelp){
		HRESULT hr;

		hr=IDirectPlayNATHelp_QueryAddress(
				pgd->pINatHelp, 
				&pgd->INADDRANY, 
				psockaddr_in, 
				&sockaddr, 
				sizeof(SOCKADDR_IN), 
				DPNHQUERYADDRESS_TCP|DPNHQUERYADDRESS_CACHENOTFOUND
				);

		if(hr==DP_OK){
			psockaddr=&sockaddr;
		} else {
			psockaddr=psockaddr_in;
		}
	} else {
		psockaddr=psockaddr_in;
	}
	#else
		psockaddr=psockaddr_in;
	#endif

	if(!pConn->bCombine) // don't combine more than once, we can't handle it.
	{
	
		pConnFind=FindPlayerBySocket(pgd, psockaddr);

		if(pConnFind){
			// We already have a connection to this guy.  See if the back-connection
			// is dead, if it is merge the two.
			ASSERT(pConnFind != pConn);

			if(!(pConnFind->dwFlags & (PLYR_ACCEPTED|PLYR_ACCEPT_PENDING))){

				// In order to get here, the client must be an old style client.
				// Otherwise, the connect for the outbound would have failed, since
				// we would be re-using the address.

				// Already correctly in the socket hash.
				// Old conn gets pulled from pending list by CleanPlayerConn.
			
				ASSERT(pConnFind->sSocketIn == INVALID_SOCKET);

				DPF(8,"FastCombine: Merging Connections pConn %x, pConnFound %x\n",pConn,pConnFind);
				DUMPCONN(pConn,3);
				DUMPCONN(pConnFind,3);

				//
				// Merge the receive socket into the outbound player connection.
				//

				// copy socket information
				pConnFind->sSocketIn = pConn->sSocketIn;
				memcpy(&pConnFind->IOnlySock.sockaddr, &pConn->IOnlySock.sockaddr, sizeof(SOCKADDR));

				// copy over receive data.
				pConnFind->cbExpected = pConn->cbExpected;
				pConnFind->cbReceived = pConn->cbReceived;
				if(pConn->pReceiveBuffer != pConn->pDefaultReceiveBuffer){
					pConnFind->pReceiveBuffer 	= pConn->pReceiveBuffer;
					pConnFind->cbReceiveBuffer = pConn->cbReceiveBuffer;
					pConn->pReceiveBuffer    	= pConn->pDefaultReceiveBuffer;
				} else {
				  ASSERT(pConn->cbReceiveBuffer == DEFAULT_RECEIVE_BUFFERSIZE);
					memcpy(pConnFind->pReceiveBuffer, pConn->pReceiveBuffer, pConn->cbReceived);
				}
				pConnFind->dwFlags |= (PLYR_ACCEPTED | PLYR_OLD_CLIENT);

				// point events to the correct connection. Overrides old conn's select.
				// Do this first so we don't drop any events.
				pConnFind->lNetEventsSocketIn=pConn->lNetEventsSocketIn;
				pConnFind->lNetEventsSocket=pConn->lNetEventsSocket;

				FastPlayerEventSelect(pgd, pConnFind, TRUE);

				// clean up old connection, but don't close the socket
				pConn->dwFlags &= ~(PLYR_ACCEPTED);
				pConn->sSocketIn = INVALID_SOCKET;
				ASSERT(pConn->sSocket==INVALID_SOCKET);
				CleanPlayerConn(pgd, pConn, FALSE);
				pConn->bCombine=TRUE;		  // tell receive thread, to reload.
				DecRefConnExist(pgd, pConn); // destroy existence ref

				DPF(8,"MergedConn pConnFound%x\n",pConnFind);
				DUMPCONN(pConnFind,3);
				pConnFind->bCombine=TRUE; // to prevent re-combine.
				if(pConn->bTrusted){
					pConnFind->bTrusted=TRUE;
				}
				// leaves 1 reference for the caller.
				return pConnFind;
				
			}
			
			DecRefConn(pgd, pConnFind); // found but can't combine... dump find ref.

		} 

	} else {
		DPF(0,"Called Fast Combine with already combined connection, may be bad\n");
	}
	// if we got here, we didn't combine.

	if(bSameAddr(psockaddr,&pConn->IOnlySock.sockaddr)){
		// If destination and source sockets match
		// Promote this one to do both 
		pConn->sSocket   = pConn->sSocketIn;
		pConn->sSocketIn = INVALID_SOCKET;
		pConn->dwFlags |= (PLYR_NEW_CLIENT | PLYR_CONNECTED);
		if(!(pConn->dwFlags & PLYR_SOCKHASH)){// Hmmm, maybe always already in it.
			AddConnToSocketHash(pgd, pConn);
		}
		RemoveConnFromPendingList(pgd, pConn);
		DPF(8,"FastCombine: Promoted Connection to Bi-Directional %x\n",pConn);
		DUMPCONN(pConn,3);
		
	} else {
		ASSERT(!(pConn->dwFlags & PLYR_NEW_CLIENT));
		pConn->dwFlags |= PLYR_OLD_CLIENT;
		// Remove from inbound hash, change to outbound hash.
		memcpy(&pConn->IOSock.sockaddr, psockaddr, sizeof(SOCKADDR));
		if(pConnFind && (pConnFind->dwFlags & (PLYR_CONNECTED|PLYR_CONN_PENDING))){
			// already connecting...
		}	else {
			// ok this is the back connection.
			RemoveConnFromPendingList(pgd, pConn);
			RemoveConnFromSocketHash(pgd, pConn);
			AddConnToSocketHash(pgd, pConn);
		}
		DPF(8,"FastCombine: Connection is Old Client %x\n",pConn);
		DUMPCONN(pConn,3);
	}
	
	FastPlayerEventSelect(pgd,pConn,TRUE);  // make sure we're listening to all the right things.

	DPF(8,"<==FastCombine\n");

	return pConn;
	
}

/*=============================================================================

	FastDropInbound - drop the inbound port for an old style client.
	
    Description:


    Parameters:

    	pgd   - Service Provider's global data blob for this instance
		pConn - connection to put in the hash table.

    Return Values:


-----------------------------------------------------------------------------*/
VOID FastDropInbound(LPGLOBALDATA pgd, PPLAYERCONN pConn)
{
	LINGER Linger;
	int err;
	LPREPLYLIST prd;

#ifdef DEBUG
	DWORD dwTime;
	dwTime=timeGetTime();
#endif	

	// See if there is already a player with this target address...
	DPF(8, "==>FastDropInbound pConn %x",pConn);

	pConn->dwFlags &= ~(PLYR_OLD_CLIENT|PLYR_ACCEPTED|PLYR_ACCEPT_PENDING);

	if (pConn->sSocketIn != INVALID_SOCKET)
	{
		// Hard close inbound socket to avoid TIME_WAIT.
		BOOL bNoLinger=TRUE;
		if (SOCKET_ERROR == setsockopt( pConn->sSocketIn,SOL_SOCKET,SO_DONTLINGER,(char FAR *)&bNoLinger,sizeof(bNoLinger)))
		{
			DPF(0, "FastDropInbound:Couldn't set linger to \"don't linger\".");
		}
	}

	RemoveConnFromPendingList(pgd, pConn);

	if(pConn->sSocketIn != INVALID_SOCKET)
	{
	
		err=g_WSAEventSelect(pConn->sSocketIn, 0, 0);
		if (err)
		{
			err=GetLastError();
			DPF(8, "Error trying to deselect sSocketIn %d.",pConn->sSocketIn);
		}
		else
		{
			DPF(8, "Deselected socket %d.",pConn->sSocketIn);
		}

		ENTER_DPSP();

		prd=SP_MemAlloc(sizeof(REPLYLIST));
		if (!prd)
		{
			LEAVE_DPSP();
			
			DPF(1, "Closing Socket %d immediately.", pConn->sSocketIn);
			
			myclosesocket(pgd,pConn->sSocketIn);
		}
		else
		{
			DPF(4, "Beginning delayed socket %d close.", pConn->sSocketIn);
			
			// very tricky, overloading the reply close list to close this socket with our own linger...
			prd->pNextReply=pgd->pReplyCloseList;
			pgd->pReplyCloseList=prd;
			prd->sSocket=pConn->sSocketIn;
			prd->tSent=timeGetTime();
			prd->lpMessage=NULL;

			LEAVE_DPSP();
		}

		pConn->sSocketIn = INVALID_SOCKET;
	}
	//memset(&pConn->IOnlySock,0,sizeof(pConn->IOnlySock));	

	//
	// reset receive information.
	//
	
	// Free extra buffer.
	if (pConn->pReceiveBuffer != pConn->pDefaultReceiveBuffer)
	{
		SP_MemFree(pConn->pReceiveBuffer);
	}

	pConn->	cbReceiveBuffer=DEFAULT_RECEIVE_BUFFERSIZE;
	pConn->cbReceived=0;
	pConn->cbExpected=0;

#ifdef DEBUG
	dwTime = timeGetTime()-dwTime;
	if(dwTime > 1000)
	{
		DPF(0, "Took way too long in FastDropInbound, elapsed %d ms.",dwTime);
		//DEBUG_BREAK();	// removed break due to stress hits.
	}
#endif	

	// Will shut down select for inbound.(done before close now.
	//FastPlayerEventSelect(pgd,pConn,TRUE);

	DPF(8, "<==FastDropInbound");

}
/*=============================================================================

	ProcessConnEvents - handle the events on a connection.
	
    Description:


    Parameters:

    	pgd   - Service Provider's global data blob for this instance
		pConn - connection to put in the hash table.
		pSockEvents - socket events on the bi-directional socket OR NULL
		pSockInEvents - socket events for the inbound only socket OR NULL

    Return Values:

		PPLAYERCONN - removed from hash, here it is.
		NULL - couldn't find it.

-----------------------------------------------------------------------------*/

HRESULT ProcessConnEvents(
	LPGLOBALDATA pgd, 
	PPLAYERCONN pConn, 
	LPWSANETWORKEVENTS pSockEvents, 
	LPWSANETWORKEVENTS pSockInEvents
)
{
	WSANETWORKEVENTS SockEvents;
	HRESULT hr=DP_OK;
	INT err;

	PPLAYERCONN pConnIn;	// connection passed by FastStreamReceiveThreadProc;

	pConnIn=pConn;

	DPF(8,"==>ProcessConnEvents pConn %x\n",pConn);

	// store in the conn, so downstream routines know what we're processing.
	if(pSockEvents){
		pConn->lNetEventsSocket=pSockEvents->lNetworkEvents;
	} else {
		pConn->lNetEventsSocket=0;
	}
	if(pSockInEvents){
		pConn->lNetEventsSocketIn=pSockInEvents->lNetworkEvents;
	} else {
		pConn->lNetEventsSocketIn=0;
	}
	
	if(pSockEvents){
		DPF(8,"SockEvents %x pConn %x\n",pSockEvents->lNetworkEvents,pConn);
		if(pSockEvents->lNetworkEvents & FD_READ){
		
			// Keep reading until all the readings done.
			ASSERT(!pSockInEvents);
			ASSERT(!(pConn->dwFlags & PLYR_OLD_CLIENT));
			pConn->dwFlags |= (PLYR_NEW_CLIENT|PLYR_ACCEPTED);
			do {
				// will indicate data if whole message received.
				hr=FastReceive(pgd, &pConn);		// can drop csFast
				if(hr!=DP_OK){
					goto exit;
				}
				err=g_WSAEnumNetworkEvents(pConn->sSocket, 0, &SockEvents);
				if(err==SOCKET_ERROR){
					err = WSAGetLastError();
					DPF(8,"Error on EnumNetworkEvents, LastError = %d\n",err);
					goto exit;
				} else {
					DPF(8,"ProcessConnEvents, Polling Sock NetEvents pConn %d Events %x\n",pConn, SockEvents.lNetworkEvents);
				}
				if(SockEvents.lNetworkEvents & FD_CLOSE && !(pSockEvents->lNetworkEvents & FD_CLOSE)){
				  pSockEvents->lNetworkEvents |= FD_CLOSE;
				  pSockEvents->iErrorCode[FD_CLOSE_BIT] = SockEvents.iErrorCode[FD_CLOSE_BIT];
				}
			} while (SockEvents.lNetworkEvents & FD_READ);	
		} 

		if(pSockEvents->lNetworkEvents & FD_WRITE){
			// connection succeeded, send any pending sends now
			QueueNextSend(pgd,pConn);
			pConn->dwFlags |= PLYR_CONNECTED;
			pConn->dwFlags &= ~(PLYR_CONN_PENDING);
			g_WSAEventSelect(pConn->sSocket, pgd->EventHandles[pConn->iEventHandle], FD_READ|FD_CLOSE);
		}

		if(pSockEvents->lNetworkEvents & FD_CONNECT)
		{
			// Check the connect status.
			if(pSockEvents->iErrorCode[FD_CONNECT_BIT]){
				DPF(0,"Connect Error %d\n",pSockEvents->iErrorCode[FD_CONNECT_BIT]);
				hr=DPERR_CONNECTIONLOST;
				goto exit;
			}
			// don't want to know about connect any more...
			pConn->dwFlags |= PLYR_CONNECTED;
			pConn->dwFlags &= ~(PLYR_CONN_PENDING);
			g_WSAEventSelect(pConn->sSocket, pgd->EventHandles[pConn->iEventHandle], FD_READ|FD_WRITE|FD_CLOSE);
		}

		if(pSockEvents->lNetworkEvents & FD_CLOSE)
		{
			DPF(8,"Outbound (Maybe I/O) Connection Closed\n");
			hr=DPERR_CONNECTIONLOST;
			goto exit;
		}
	}

	if(pSockInEvents)
	{
		ASSERT(!(pConn->dwFlags & PLYR_NEW_CLIENT));
		DPF(8,"SockEvents (IOnly) %x pConn %x\n",pSockInEvents->lNetworkEvents, pConn);

		// Need to read first, don't want to drop the data on close
		if(pSockInEvents->lNetworkEvents & FD_READ)
		{
			do{
				// Careful here, we may combine connections changing pConn.
				hr=FastReceive(pgd, &pConn);	// can drop csFast
				if(hr!=DP_OK)
				{
					FastDropInbound(pgd, pConn);
					hr=DP_OK;
					goto exit;
				}
				if(pConn->sSocketIn == INVALID_SOCKET){
					// new pConn may be bi-directional.
					if(pConn->sSocket == INVALID_SOCKET){
						hr=DPERR_CONNECTIONLOST;
						goto exit;
					} else {
						hr=DP_OK;
						goto exit;
					}
				}
				err=g_WSAEnumNetworkEvents(pConn->sSocketIn, 0, &SockEvents);
				if(err==SOCKET_ERROR){
					err = WSAGetLastError();
					DPF(8,"Error on EnumNetworkEvents, LastError = %d\n",err);
					goto exit;
				} else {
					DPF(8,"ProcessConnEvents, Polling SockIn NetEvents pConn %x Events %x\n",pConn,SockEvents.lNetworkEvents);
				}
				if((SockEvents.lNetworkEvents & FD_CLOSE) && !(pSockInEvents->lNetworkEvents & FD_CLOSE)){
				  pSockInEvents->lNetworkEvents |= FD_CLOSE;
				  pSockInEvents->iErrorCode[FD_CLOSE_BIT] = SockEvents.iErrorCode[FD_CLOSE_BIT];
				}

			} while (SockEvents.lNetworkEvents & FD_READ);
		}

		if(pSockInEvents->lNetworkEvents & FD_CLOSE)
		{
			if(pConn->sSocket == INVALID_SOCKET){
				DPF(8,"ProcessConn Events, Got Close on Inbound Only, returning ConnectionLost\n");
				ASSERT(!(pConn->dwFlags & (PLYR_CONN_PENDING|PLYR_CONNECTED)));
				hr=DPERR_CONNECTIONLOST;
			} else {
				DPF(8,"ProcessConn Events, Got Close on I/O Connection dropping inbound only.\n");
				FastDropInbound(pgd, pConn);
				hr=DP_OK;
			}	
			goto exit;
		}
		

	}
	
exit:

	pConn->lNetEventsSocket=0;
	pConn->lNetEventsSocketIn=0;

	if(pConn != pConnIn){
		// During a call to FastReceive, connections were combined and
		// we were given a reference, now we drop that reference.
		DecRefConn(pgd, pConn);
	}

	DPF(8,"<==ProcessConnEvents hr=0x%x\n",hr);


	return hr;
}

/*=============================================================================

	FastAccept - accept a connection
	
    Description:


    Parameters:

    	pgd   - Service Provider's global data blob for this instance
		pNetEvents - socket events on the accept socket

    Return Values:

	Note: csFast held across this call.  Nothing here should block.

-----------------------------------------------------------------------------*/

VOID FastAccept(LPGLOBALDATA pgd, LPWSANETWORKEVENTS pNetEvents)
{
	SOCKADDR 	sockaddr;
	INT 		addrlen = sizeof(sockaddr);
	SOCKET 		sSocket;

	PPLAYERCONN pConn;

	UINT 		err;		// last error

	DPF(8,"==>FastAccept\n");

    sSocket = accept(pgd->sSystemStreamSocket,&sockaddr,&addrlen);

    
    if (INVALID_SOCKET == sSocket) 
    {
        err = WSAGetLastError();
        DPF(2,"FastAccept: stream accept error - err = %d socket = %d",err,(DWORD)sSocket);
		DEBUG_BREAK();
        
    } else {

		// All our sockets have KEEPALIVE...
		BOOL bTrue = TRUE;

	    DEBUGPRINTADDR(5,"FastAccept - accepted connection from",&sockaddr);
			
		// turn ON keepalive
		if (SOCKET_ERROR == setsockopt(sSocket, SOL_SOCKET, SO_KEEPALIVE, (CHAR FAR *)&bTrue, sizeof(bTrue)))
		{
				err = WSAGetLastError();
				DPF(0,"Failed to turn ON keepalive - continue : err = %d\n",err);
		}
		
		// add the new socket to our receive q

		// need to allocate a connection structure, lets see if someone is waiting on this accept
		pConn=FindPlayerBySocket(pgd, &sockaddr);

		if(pConn){
			if(pConn->sSocket == INVALID_SOCKET){
				// we found the connection because a connect is waiting for it.  
				ASSERT(pConn->dwFlags & PLYR_ACCEPT_PENDING);
				ASSERT(pConn->dwFlags & PLYR_NEW_CLIENT);
				ASSERT(bSameAddr(&sockaddr, &pConn->IOSock.sockaddr));

				pConn->sSocket = sSocket;
				pConn->dwFlags &= ~(PLYR_ACCEPT_PENDING);
				pConn->dwFlags |= (PLYR_CONNECTED|PLYR_ACCEPTED);
				FastPlayerEventSelect(pgd,pConn,TRUE);

				DPF(8,"Found Pending Connection, now connected\n");
				DUMPCONN(pConn,3);

			} else {
				if(TRUE /*pgd->bSeparateIO*/){
					// more work for Win9x < Mill 
					// 8/30/00 ao - now we turn this on in all cases because we need to allow
					// for a NATed client to have different inbound and outbound connections to
					// workaround the NAT PAST bug where it picks a random from port for
					// the outbound link when we haven't received before sending on an ASSIGNED port.
					DPF(0,"New client connecting back to me, but I treat as old for compat\n");
					pConn->sSocketIn=sSocket;
					pConn->dwFlags |= PLYR_ACCEPTED|PLYR_OLD_CLIENT;
					pConn->bCombine=TRUE;
					FastPlayerEventSelect(pgd,pConn,TRUE);
				} else {
					DPF(0,"Nice race, already have a connection pConn %x, re-use\n", pConn);
					closesocket(sSocket);
				}	
			}
			
			DecRefConn(pgd, pConn); // remove reference from FindPlayerBySocket().

		} else {


			if(pConn=FindConnInPendingList(pgd, &sockaddr)){
				// This guy's in the pending list, blow old conn away.
				DPF(8,"Found Accept for Player in Pending List, blow away old one\n");
				CleanPlayerConn(pgd, pConn, TRUE);
				DecRefConnExist(pgd, pConn); // dump existence ref.
				DecRefConn(pgd, pConn); // dump our ref.
			}

			//
			// No connection, we need to create one.  
			//


			// make sure we have room.
			if(pgd->nEventSlotsAvail && (pConn = CreatePlayerConn(pgd, DPID_UNKNOWN, &sockaddr))){

				DPF(8,"Creating new Connection for Accept %x\n",pConn);
				// put on pending list...
				pConn->sSocketIn = sSocket;
				AddConnToPendingList(pgd, pConn);
				pConn->dwFlags |= PLYR_ACCEPTED;
				FastPlayerEventSelect(pgd, pConn, TRUE);

			} else {

				// No room for more accept events ... blow this socket out!

				LINGER Linger;
				
				DPF(0,"FastAccept: VERY BAD, Out of Event Slots, can't accept any new connections, killing this one\n");
				
				Linger.l_onoff=FALSE;
				Linger.l_linger=0;
				
				if( SOCKET_ERROR == setsockopt( sSocket,SOL_SOCKET,SO_LINGER,(char FAR *)&Linger, sizeof(Linger) ) ){
					err = WSAGetLastError();
					DPF(0,"Couldn't set linger on socket, can't kill now, so it will be an orphan...bad.bad.bad\n");
				} else {
					// don't need to shutdown the socket, since we don't have any data on it.
					myclosesocket(pgd,sSocket);
				}
			
			}		
		}
		
	}
	
	DPF(8,"<==FastAccept\n");
	
}



/*=============================================================================

	FastInternalReliableSend - reliable send using fast socket code.
	
    Description:


    Parameters:

    Return Values:

-----------------------------------------------------------------------------*/

HRESULT FastInternalReliableSend(LPGLOBALDATA pgd, LPDPSP_SENDDATA psd, SOCKADDR *lpSockAddr)
{
	HRESULT hr=DP_OK;
	SOCKET sSocket = INVALID_SOCKET;
	UINT err;

	PPLAYERCONN pConn=NULL;
	LPSENDINFO pSendInfo=NULL;
	PCHAR pBuffer=NULL;
	DPID idPlayerTo;


	DPF(6, "FastInternalReliableSend: Parameters: (0x%x, 0x%x, 0x%x)",
		pgd, psd, lpSockAddr);


	EnterCriticalSection(&pgd->csFast);

	if(psd->idPlayerTo){
		idPlayerTo=psd->idPlayerTo;
	} else {
		idPlayerTo=DPID_UNKNOWN;
	}

	pConn = GetPlayerConn(pgd, idPlayerTo, lpSockAddr); // adds a ref

	if(!pConn){
		hr=DPERR_CONNECTIONLOST;
		goto exit;
	}

	// Always go async, since we are on a non-blocking mode socket.
	{
		// make this puppy asynchronous.... malloc ICK!
		
		pSendInfo = pgd->pSendInfoPool->Get(pgd->pSendInfoPool);
		pBuffer = SP_MemAlloc(psd->dwMessageSize);
		
		if(!pSendInfo || !pBuffer){
			hr=DPERR_OUTOFMEMORY;
			goto CLEANUP_EXIT;
		}

		SetReturnAddress(psd->lpMessage,pgd->sSystemStreamSocket,SERVICE_SADDR_PUBLIC(pgd));		

		memcpy(pBuffer, psd->lpMessage, psd->dwMessageSize);

		pSendInfo->SendArray[0].buf = pBuffer;
		pSendInfo->SendArray[0].len = psd->dwMessageSize;

		pSendInfo->iFirstBuf = 0;
		pSendInfo->cBuffers  = 1;
		pSendInfo->sSocket = pConn->sSocket;

		//CommonInitForSend

		pSendInfo->pConn        = pConn;
		pSendInfo->dwMessageSize= psd->dwMessageSize;
		pSendInfo->dwUserContext= 0;
		pSendInfo->RefCount     = 3;		// one for completion, 1 for this routine, 1 for async completion of send.
		pSendInfo->pgd          = pgd;
		pSendInfo->lpISP        = pgd->pISP;
		pSendInfo->Status       = DP_OK;
		pSendInfo->idTo         = psd->idPlayerTo;
		pSendInfo->idFrom       = psd->idPlayerFrom;
		pSendInfo->dwSendFlags  = psd->dwFlags|DPSEND_ASYNC;

		pSendInfo->dwFlags = SI_RELIABLE | SI_INTERNALBUFF;

		EnterCriticalSection(&pgd->csSendEx);
	
			InsertBefore(&pSendInfo->PendingSendQ,&pgd->PendingSendQ);
			pgd->dwBytesPending += psd->dwMessageSize;
			pgd->dwMessagesPending += 1;
		
		LeaveCriticalSection(&pgd->csSendEx);

		// End CommonInit for Send.

		if((pConn->dwFlags & PLYR_CONNECTED) && EMPTY_BILINK(&pConn->PendingConnSendQ) && !pConn->bSendOutstanding){
			QueueForSend(pgd, pSendInfo);	// send it
		} else {
			QueueSendOnConn(pgd, pConn, pSendInfo);
		}	

		wsaoDecRef(pSendInfo);
		
	}

	// success
	hr = DP_OK;
exit:
	
	if(pConn){
		DecRefConn(pgd,pConn);
	}

	LeaveCriticalSection(&pgd->csFast);
	
 	DPF(6, "FastInternalReliableSend: Returning: [0x%lx] (exit)", hr);

	return hr;

CLEANUP_EXIT:

	if(pConn){
		DecRefConn(pgd, pConn); // balance Get
	}

	LeaveCriticalSection(&pgd->csFast);

	if(pBuffer){
		SP_MemFree(pBuffer);
	}
	if(pSendInfo){
		SP_MemFree(pSendInfo);
	}
	
 	DPF(6, "FastInternalReliableSend: Returning: [0x%lx] (cleanup exit)", hr);

	return hr;
}

/*=============================================================================

	FastInternalReliableSendEx - reliable send using fast socket code.
	
    Description:


    Parameters:

    Return Values:

-----------------------------------------------------------------------------*/

HRESULT FastInternalReliableSendEx(LPGLOBALDATA pgd, LPDPSP_SENDEXDATA psd, LPSENDINFO pSendInfo, SOCKADDR *lpSockAddr)
{
	HRESULT hr=DP_OK;
	SOCKET sSocket = INVALID_SOCKET;
	UINT err;

	PPLAYERCONN pConn=NULL;
	PCHAR pBuffer=NULL;
	DPID idPlayerTo;
	UINT i;
	DWORD dwOffset;


	DPF(6, "FastInternalReliableSendEx: Parameters: (0x%x, 0x%x, 0x%x, 0x%x)",
		pgd, psd, pSendInfo, lpSockAddr);

	EnterCriticalSection(&pgd->csFast);

	if(psd->idPlayerTo){
		idPlayerTo=psd->idPlayerTo;
	} else {
		idPlayerTo=DPID_UNKNOWN;
	}

	pConn = GetPlayerConn(pgd, idPlayerTo, lpSockAddr); // adds a ref

	if(!pConn){
		hr=DPERR_CONNECTIONLOST;
		goto exit;
	}

	// SECURITY: we will trust anyone we send data to.  
	pConn->bTrusted = TRUE;

	// Always go async, since we are on a non-blocking mode socket.
	{
		// make this puppy asynchronous.... malloc ICK!

		if(!(psd->dwFlags & DPSEND_ASYNC))
		{
			pBuffer = SP_MemAlloc(psd->dwMessageSize+sizeof(MESSAGEHEADER));
			if(!pBuffer){
				hr=DPERR_OUTOFMEMORY;
				goto CLEANUP_EXIT;
			}
		}
		
		pSendInfo->sSocket = pConn->sSocket;

		//CommonInitForSend

		pSendInfo->pConn			= pConn;
		pSendInfo->dwMessageSize	= psd->dwMessageSize;
		pSendInfo->dwUserContext	= (DWORD_PTR)psd->lpDPContext;
		pSendInfo->RefCount     	= 3;		// one for completion, 1 for this routine, 1 for async completion of send.
		pSendInfo->pgd          	= pgd;
		pSendInfo->lpISP        	= pgd->pISP;
		pSendInfo->Status       	= DP_OK;
		pSendInfo->idTo        		= psd->idPlayerTo;
		pSendInfo->idFrom       	= psd->idPlayerFrom;
		pSendInfo->dwSendFlags  	= psd->dwFlags|DPSEND_ASYNC;
		pSendInfo->iFirstBuf		= 0;

		if(psd->dwFlags & DPSEND_ASYNC) {
			pSendInfo->dwFlags 	= SI_RELIABLE;
			pSendInfo->cBuffers	= psd->cBuffers+1;
		} else {
			// in sync case we need to copy the buffers since the upper layer
			// is expecting ownership back immediately.  Sync sends can't expect
			// thrilling performance anyway so this should not show up in perf.

			// copy message into one contiguous buffer.
			dwOffset=0;
			for( i = 0 ; i < psd->cBuffers+1 ; i++)
			{
				memcpy(pBuffer+dwOffset, pSendInfo->SendArray[i].buf, pSendInfo->SendArray[i].len);
				dwOffset += pSendInfo->SendArray[i].len;
			}
			
			pSendInfo->dwFlags 			= SI_RELIABLE | SI_INTERNALBUFF;
			pSendInfo->cBuffers			= 1;
			pSendInfo->SendArray[0].buf	= pBuffer;
			pSendInfo->SendArray[0].len	= psd->dwMessageSize+sizeof(MESSAGEHEADER);
		}

		EnterCriticalSection(&pgd->csSendEx);
	
			InsertBefore(&pSendInfo->PendingSendQ,&pgd->PendingSendQ);
			pgd->dwBytesPending += psd->dwMessageSize;
			pgd->dwMessagesPending += 1;
		
		LeaveCriticalSection(&pgd->csSendEx);

		// End CommonInit for Send.

		if((pConn->dwFlags & PLYR_CONNECTED) && EMPTY_BILINK(&pConn->PendingConnSendQ) && !pConn->bSendOutstanding){
			QueueForSend(pgd, pSendInfo);	// send it
		} else {
			QueueSendOnConn(pgd, pConn, pSendInfo);
		}	

		wsaoDecRef(pSendInfo);
		
	}

	// success
	if(psd->dwFlags & DPSEND_ASYNC)
	{
		hr = DPERR_PENDING;
	}else {
		hr = DP_OK;
	}	
exit:
	
	if(pConn){
		DecRefConn(pgd,pConn);
	}

	LeaveCriticalSection(&pgd->csFast);
	
 	DPF(6, "FastInternalReliableSendEx: Returning: [0x%lx] (exit)", hr);

	return hr;

CLEANUP_EXIT:

	if(pConn){
		DecRefConn(pgd, pConn); // balance Get
	}

	LeaveCriticalSection(&pgd->csFast);

	if(pBuffer){
		SP_MemFree(pBuffer);
	}
	
 	DPF(6, "FastInternalReliableSendEx: Returning: [0x%lx] (cleanup exit)", hr);

	return hr;
}

/*=============================================================================

	FastReply - reliable reply using fast socket code.
	
    Description:

    Parameters:

    Return Values:

-----------------------------------------------------------------------------*/

HRESULT FastReply(LPGLOBALDATA pgd, LPDPSP_REPLYDATA prd, DPID dwPlayerID)
{
	HRESULT hr=DP_OK;
	SOCKET sSocket = INVALID_SOCKET;
	UINT err;

	PPLAYERCONN pConn=NULL;
	LPSENDINFO pSendInfo=NULL;
	PCHAR pBuffer=NULL;

	SOCKADDR *psaddr;
	LPMESSAGEHEADER phead;

	DPF(8,"==>FastReply\n");

	phead=(LPMESSAGEHEADER)prd->lpSPMessageHeader;
	psaddr=&phead->sockaddr;

	if(dwPlayerID == 0){
		dwPlayerID = DPID_UNKNOWN;
	}

	EnterCriticalSection(&pgd->csFast);

	pConn = GetPlayerConn(pgd, dwPlayerID, psaddr); // adds a ref

	if(!pConn){
		hr = DPERR_CONNECTIONLOST;
		goto exit;
	}

	// make this puppy asynchronous.... malloc ICK!
	
	pSendInfo = pgd->pSendInfoPool->Get(pgd->pSendInfoPool);
	pBuffer = SP_MemAlloc(prd->dwMessageSize);
	
	if(!pSendInfo || !pBuffer){
		hr=DPERR_OUTOFMEMORY;
		goto CLEANUP_EXIT;
	}

	SetReturnAddress(prd->lpMessage,pgd->sSystemStreamSocket,SERVICE_SADDR_PUBLIC(pgd));		

	memcpy(pBuffer, prd->lpMessage, prd->dwMessageSize);

	pSendInfo->SendArray[0].buf = pBuffer;
	pSendInfo->SendArray[0].len = prd->dwMessageSize;

	pSendInfo->iFirstBuf = 0;
	pSendInfo->cBuffers  = 1;

	pSendInfo->sSocket = pConn->sSocket;

	//CommonInitForSend

	pSendInfo->pConn	   = pConn;
	pSendInfo->dwMessageSize= prd->dwMessageSize;
	pSendInfo->dwUserContext= 0;
	pSendInfo->RefCount     = 3;		// one for send routine, one for completion, 1 for this routine
	pSendInfo->pgd          = pgd;
	pSendInfo->lpISP        = pgd->pISP;
	pSendInfo->Status       = DP_OK;
	pSendInfo->idTo         = dwPlayerID;
	pSendInfo->idFrom       = 0;
	pSendInfo->dwSendFlags  = DPSEND_GUARANTEE|DPSEND_ASYNC;
	pSendInfo->Status       = DP_OK;

	pSendInfo->dwFlags = SI_RELIABLE | SI_INTERNALBUFF;

	EnterCriticalSection(&pgd->csSendEx);

		InsertBefore(&pSendInfo->PendingSendQ,&pgd->PendingSendQ);
		pgd->dwBytesPending += prd->dwMessageSize;
		pgd->dwMessagesPending += 1;
	
	LeaveCriticalSection(&pgd->csSendEx);

    DPF(9,"pConn->dwFlags & PLYR_CONNECTED = %x",pConn->dwFlags & PLYR_CONNECTED);
    DPF(9,"EMPTY_BILINK PendingConnSendQ   = %x",EMPTY_BILINK(&pConn->PendingConnSendQ));
    DPF(9,"!pConn->bSendOutstanding        = %x",!pConn->bSendOutstanding);
	// End CommonInit for Send.
	if((pConn->dwFlags & PLYR_CONNECTED) && EMPTY_BILINK(&pConn->PendingConnSendQ) && !pConn->bSendOutstanding){
	    DPF(9,"==>QueueForSend");
		QueueForSend(pgd, pSendInfo);	// send it
	} else {
	    DPF(9,"==>QueueSendOnConn");
		QueueSendOnConn(pgd, pConn, pSendInfo);
	}	
	wsaoDecRef(pSendInfo);
	
	// success
	hr = DP_OK;

exit:

	if(pConn){
		DecRefConn(pgd, pConn);
	}

	LeaveCriticalSection(&pgd->csFast);

	DPF(8,"<==Fast Reply\n");

	return hr;

CLEANUP_EXIT:


	if(pConn){
		DecRefConn(pgd, pConn); // balance Get
	}

	LeaveCriticalSection(&pgd->csFast);

	if(pBuffer){
		SP_MemFree(pBuffer);
	}
	if(pSendInfo){
		SP_MemFree(pSendInfo);
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\wsock\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dpwsock.rc
//
#define IDD_DIALOG1                     101
#define IDD_SELECTSERVER                101
#define IDC_EDIT1                       1000
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\wsock\handler.c ===
#include "dpsp.h"

#undef DPF_MODNAME
#define DPF_MODNAME	"HandleMessage"

// this function is called with dpws lock taken
HRESULT HandleServerMessage(LPGLOBALDATA pgd, SOCKET sSocket, LPBYTE pBuffer, DWORD dwSize)
{
	LPMSG_GENERIC pMessage = (LPMSG_GENERIC) pBuffer;
	DWORD dwType;
	DWORD dwVersion;
	HRESULT hr=DP_OK;

	ASSERT(pMessage);
	
	dwType = GET_MESSAGE_COMMAND(pMessage);
	dwVersion = GET_MESSAGE_VERSION(pMessage);
	
	switch (dwType) {
			
	default:
		DPF(0,"dpwsock received unrecognized message of type 0x%08x\n",dwType);
		break;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\wsock\helpcli.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	   helpcli.c
 *  Content:	client code to talk to dplaysvr.exe
 *					allows multiple dplay winscock clients to share
 *					a single port.  see %manroot%\dplay\dplaysvr\dphelp.c
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	2/15/97		andyco	created from w95help.h
 *
 ***************************************************************************/
#include "helpcli.h"

extern DWORD	dwHelperPid;


//**********************************************************************
// Globals
//**********************************************************************
BOOL					g_fDaclInited = FALSE;
SECURITY_ATTRIBUTES		g_sa;
BYTE					g_abSD[SECURITY_DESCRIPTOR_MIN_LENGTH];
PSECURITY_ATTRIBUTES	g_psa = NULL;
PACL					g_pEveryoneACL = NULL;





//**********************************************************************
// ------------------------------
// DNGetNullDacl - Get a SECURITY_ATTRIBUTE structure that specifies a 
//					NULL DACL which is accessible by all users.
//					Taken from IDirectPlay8 code base.
//
// Entry:		Nothing
//
// Exit:		PSECURITY_ATTRIBUTES
// ------------------------------
#undef DPF_MODNAME 
#define DPF_MODNAME "DNGetNullDacl"
PSECURITY_ATTRIBUTES DNGetNullDacl()
{
	PSID                     psidEveryone      = NULL;
	SID_IDENTIFIER_AUTHORITY siaWorld = SECURITY_WORLD_SID_AUTHORITY;
	DWORD					 dwAclSize;

	// This is done to make this function independent of DNOSIndirectionInit so that the debug
	// layer can call it before the indirection layer is initialized.
	if (!g_fDaclInited)
	{
		if (!InitializeSecurityDescriptor((SECURITY_DESCRIPTOR*)g_abSD, SECURITY_DESCRIPTOR_REVISION))
		{
			DPF(0, "Failed to initialize security descriptor" );
			goto Error;
		}

		// Create SID for the Everyone group.
		if (!AllocateAndInitializeSid(&siaWorld, 1, SECURITY_WORLD_RID, 0,
                                      0, 0, 0, 0, 0, 0, &psidEveryone))
		{
			DPF(0, "Failed to allocate Everyone SID" );
			goto Error;
		}

		dwAclSize = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(psidEveryone) - sizeof(DWORD);

		// Allocate the ACL, this won't be a tracked allocation and we will let process cleanup destroy it
		g_pEveryoneACL = (PACL)HeapAlloc(GetProcessHeap(), 0, dwAclSize);
		if (g_pEveryoneACL == NULL)
		{
			DPF(0, "Failed to allocate ACL buffer" );
			goto Error;
		}

		// Intialize the ACL.
		if (!InitializeAcl(g_pEveryoneACL, dwAclSize, ACL_REVISION))
		{
			DPF(0, "Failed to initialize ACL" );
			goto Error;
		}

		// Add the ACE.
		if (!AddAccessAllowedAce(g_pEveryoneACL, ACL_REVISION, GENERIC_ALL, psidEveryone))
		{
			DPF(0, "Failed to add ACE to ACL" );
			goto Error;
		}

		// We no longer need the SID that was allocated.
		FreeSid(psidEveryone);
		psidEveryone = NULL;

		// Add the ACL to the security descriptor..
		if (!SetSecurityDescriptorDacl((SECURITY_DESCRIPTOR*)g_abSD, TRUE, g_pEveryoneACL, FALSE))
		{
			DPF(0, "Failed to add ACL to security descriptor" );
			goto Error;
		}

		g_sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		g_sa.lpSecurityDescriptor = g_abSD;
		g_sa.bInheritHandle = FALSE;

		g_psa = &g_sa;

		g_fDaclInited = TRUE;
	}
Error:
	if (psidEveryone)
	{
		FreeSid(psidEveryone);
		psidEveryone = NULL;
	}
	return g_psa;
}
//**********************************************************************


/*
 * sendRequest
 *
 * communicate a request to DPHELP
 */
static BOOL sendRequest( LPDPHELPDATA req_phd )
{
	OSVERSIONINFOA	VersionInfo;
	BOOL			fUseGlobalNamespace;
	LPDPHELPDATA	phd;
	HANDLE			hmem;
	HANDLE			hmutex;
	HANDLE			hackevent;
	HANDLE			hstartevent;
	BOOL			rc;


	// Determine if we're running on NT.
	memset(&VersionInfo, 0, sizeof(VersionInfo));
	VersionInfo.dwOSVersionInfoSize = sizeof(VersionInfo);
	if (GetVersionExA(&VersionInfo))
	{
		if (VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
		{
			DPF(2, "Running on NT version %u.%u.%u, using global namespace.",
				VersionInfo.dwMajorVersion, VersionInfo.dwMinorVersion, VersionInfo.dwBuildNumber);
			fUseGlobalNamespace = TRUE;
		}
		else
		{
			DPF(2, "Running on 9x version %u.%u.%u, not using global namespace.",
				VersionInfo.dwMajorVersion, VersionInfo.dwMinorVersion, LOWORD(VersionInfo.dwBuildNumber));
			fUseGlobalNamespace = FALSE;
		}
	}
	else
	{
		DPF(0, "Could not determine OS version, assuming global namespace not needed.");
		fUseGlobalNamespace = FALSE;
	}


	/*
	 * get events start/ack events
	 */
	if (fUseGlobalNamespace)
	{
		hstartevent = CreateEvent( DNGetNullDacl(), FALSE, FALSE, "Global\\" DPHELP_EVENT_NAME );
	}
	else
	{
		hstartevent = CreateEvent( NULL, FALSE, FALSE, DPHELP_EVENT_NAME );
	}
	if( hstartevent == NULL )
	{
		return FALSE;
	}

	if (fUseGlobalNamespace)
	{
		hackevent = CreateEvent( DNGetNullDacl(), FALSE, FALSE, "Global\\" DPHELP_ACK_EVENT_NAME );
	}
	else
	{
		hackevent = CreateEvent( NULL, FALSE, FALSE, DPHELP_ACK_EVENT_NAME );
	}
	if( hackevent == NULL )
	{
		CloseHandle( hstartevent );
		return FALSE;
	}

	/*
	 * create shared memory area
	 */
	if (fUseGlobalNamespace)
	{
		hmem = CreateFileMapping( INVALID_HANDLE_VALUE, DNGetNullDacl(),
								PAGE_READWRITE, 0, sizeof( DPHELPDATA ),
								"Global\\" DPHELP_SHARED_NAME );
	}
	else
	{
		hmem = CreateFileMapping( INVALID_HANDLE_VALUE, NULL,
								PAGE_READWRITE, 0, sizeof( DPHELPDATA ),
								DPHELP_SHARED_NAME );
	}
	if( hmem == NULL )
	{
		DPF( 1, "Could not create file mapping!" );
		CloseHandle( hstartevent );
		CloseHandle( hackevent );
		return FALSE;
	}

	phd = (LPDPHELPDATA) MapViewOfFile( hmem, FILE_MAP_ALL_ACCESS, 0, 0, 0 );
	if( phd == NULL )
	{
		DPF( 1, "Could not create view of file!" );
		CloseHandle( hmem );
		CloseHandle( hstartevent );
		CloseHandle( hackevent );
		return FALSE;
	}

	/*
	 * wait for access to the shared memory
	 */
	if (fUseGlobalNamespace)
	{
		hmutex = OpenMutex( SYNCHRONIZE, FALSE, "Global\\" DPHELP_MUTEX_NAME );
	}
	else
	{
		hmutex = OpenMutex( SYNCHRONIZE, FALSE, DPHELP_MUTEX_NAME );
	}
	if( hmutex == NULL )
	{
		DPF( 1, "Could not create mutex!" );
		UnmapViewOfFile( phd );
		CloseHandle( hmem );
		CloseHandle( hstartevent );
		CloseHandle( hackevent );
		return FALSE;
	}
	WaitForSingleObject( hmutex, INFINITE );

	/*
	 * wake up DPHELP with our request
	 */
	memcpy( phd, req_phd, sizeof( DPHELPDATA ) );
	if( SetEvent( hstartevent ) )
	{
		WaitForSingleObject( hackevent, INFINITE );
		memcpy( req_phd, phd, sizeof( DPHELPDATA ) );
		rc = TRUE;
	}
	else
	{
		DPF( 1, "Could not signal event to notify DPHELP!" );
		rc = FALSE;
	}

	/*
	 * done with things
	 */
	ReleaseMutex( hmutex );
	CloseHandle( hmutex );
	CloseHandle( hstartevent );
	CloseHandle( hackevent );
	UnmapViewOfFile( phd );
	CloseHandle( hmem );
	return rc;

} /* sendRequest */


/*
 * HelpcliFini
 *
 * Free resources allocated to talk to DPlaySvr.
 */
void HelpcliFini(void)
{
	if (g_pEveryoneACL)
	{
		HeapFree(GetProcessHeap(), 0, g_pEveryoneACL);
		g_pEveryoneACL = NULL;
	}

	g_psa = NULL;
	g_fDaclInited = FALSE;
} /* HelpcliFini */


/*
 * WaitForHelperStartup
 */
BOOL WaitForHelperStartup( void )
{
	OSVERSIONINFOA	VersionInfo;
	BOOL			fUseGlobalNamespace;
	HANDLE			hevent;
	DWORD			rc;

	
	// Determine if we're running on NT.
	memset(&VersionInfo, 0, sizeof(VersionInfo));
	VersionInfo.dwOSVersionInfoSize = sizeof(VersionInfo);
	if (GetVersionExA(&VersionInfo))
	{
		if (VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
		{
			DPF(2, "Running on NT version %u.%u.%u, using global namespace.",
				VersionInfo.dwMajorVersion, VersionInfo.dwMinorVersion, VersionInfo.dwBuildNumber);
			fUseGlobalNamespace = TRUE;
		}
		else
		{
			DPF(2, "Running on 9x version %u.%u.%u, not using global namespace.",
				VersionInfo.dwMajorVersion, VersionInfo.dwMinorVersion, LOWORD(VersionInfo.dwBuildNumber));
			fUseGlobalNamespace = FALSE;
		}
	}
	else
	{
		rc = GetLastError();
		DPF(0, "Could not determine OS version (err = %u), assuming global namespace not needed.", rc);
		fUseGlobalNamespace = FALSE;
	}

	if (fUseGlobalNamespace)
	{
		hevent = CreateEvent( DNGetNullDacl(), TRUE, FALSE, "Global\\" DPHELP_STARTUP_EVENT_NAME );
	}
	else
	{
		hevent = CreateEvent( NULL, TRUE, FALSE, DPHELP_STARTUP_EVENT_NAME );
	}
	if( hevent == NULL )
	{
		return FALSE;
	}
	DPF( 3, "Wait DPHELP startup event to be triggered" );
	rc = WaitForSingleObject( hevent, INFINITE );
	CloseHandle( hevent );
	return TRUE;

} /* WaitForHelperStartup */

/*
 * CreateHelperProcess
 */
BOOL CreateHelperProcess( LPDWORD ppid )
{
	OSVERSIONINFOA	VersionInfo;
	BOOL			fUseGlobalNamespace;
	DWORD			rc;
	STARTUPINFO		si;
	PROCESS_INFORMATION	pi;
	HANDLE			h;
	char			szDPlaySvrPath[MAX_PATH + sizeof("\\dplaysvr.exe") + 1];
	char			szDPlaySvr[sizeof("dplaysvr.exe")] = "dplaysvr.exe";

	
	// Determine if we're running on NT.
	memset(&VersionInfo, 0, sizeof(VersionInfo));
	VersionInfo.dwOSVersionInfoSize = sizeof(VersionInfo);
	if (GetVersionExA(&VersionInfo))
	{
		if (VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
		{
			//DPF(2, "Running on NT version %u.%u.%u, using global namespace.",
			//	VersionInfo.dwMajorVersion, VersionInfo.dwMinorVersion, VersionInfo.dwBuildNumber);
			fUseGlobalNamespace = TRUE;
		}
		else
		{
			//DPF(2, "Running on 9x version %u.%u.%u, not using global namespace.",
			//	VersionInfo.dwMajorVersion, VersionInfo.dwMinorVersion, LOWORD(VersionInfo.dwBuildNumber));
			fUseGlobalNamespace = FALSE;
		}
	}
	else
	{
		rc = GetLastError();
		DPF(0, "Could not determine OS version (err = %u), assuming global namespace not needed.", rc);
		fUseGlobalNamespace = FALSE;
	}
	
	if( dwHelperPid == 0 )
	{
		if (fUseGlobalNamespace)
		{
			h = OpenEvent( SYNCHRONIZE, FALSE, "Global\\" DPHELP_STARTUP_EVENT_NAME );
		}
		else
		{
			h = OpenEvent( SYNCHRONIZE, FALSE, DPHELP_STARTUP_EVENT_NAME );
		}
		if( h == NULL )
		{
			// Get Windows system directory name
			if (GetSystemDirectory(szDPlaySvrPath, (MAX_PATH + 1)) == 0)
			{
				DPF( 0, "Could not get system directory" );
				return FALSE;
			}
			strcat(szDPlaySvrPath, "\\dplaysvr.exe");
			
			si.cb = sizeof(STARTUPINFO);
			si.lpReserved = NULL;
			si.lpDesktop = NULL;
			si.lpTitle = NULL;
			si.dwFlags = 0;
			si.cbReserved2 = 0;
			si.lpReserved2 = NULL;

			DPF( 3, "Creating helper process dplaysvr.exe now" );
			if( !CreateProcess(szDPlaySvrPath, szDPlaySvr,  NULL, NULL, FALSE,
							   NORMAL_PRIORITY_CLASS,
							   NULL, NULL, &si, &pi) )
			{
				DPF( 2, "Could not create dplaysvr.exe" );
				return FALSE;
			}
			dwHelperPid = pi.dwProcessId;
			DPF( 3, "Helper Process created" );
		}
		else
		{
			DPHELPDATA	hd;
			memset(&hd,0,sizeof(DPHELPDATA)); // make prefix happy.
			DPF( 3, "dplaysvr already exists, waiting for dplaysvr event" );
			WaitForSingleObject( h, INFINITE );
			CloseHandle( h );
			DPF( 3, "Asking for DPHELP pid" );
			hd.req = DPHELPREQ_RETURNHELPERPID;
			sendRequest( &hd );
			dwHelperPid = hd.pid;
			DPF( 3, "DPHELP pid = %08lx", dwHelperPid );
		}
		*ppid = dwHelperPid;
		return TRUE;
	}
	*ppid = dwHelperPid;
	return FALSE;

} /* CreateHelperProcess */

// notify dphelp.c that we have a new server on this system
HRESULT HelperAddDPlayServer(USHORT port)
{
	DPHELPDATA hd;
	DWORD pid = GetCurrentProcessId();

	memset(&hd, 0, sizeof(DPHELPDATA));
	hd.req = DPHELPREQ_DPLAYADDSERVER;
	hd.pid = pid;
	hd.port = port;
	if (sendRequest(&hd)) return hd.hr;
	else return E_FAIL;
				
} // HelperAddDPlayServer

// server is going away
BOOL HelperDeleteDPlayServer(USHORT port)
{
	DPHELPDATA hd;
	DWORD pid = GetCurrentProcessId();

	memset(&hd, 0, sizeof(DPHELPDATA));
	hd.req = DPHELPREQ_DPLAYDELETESERVER;
	hd.pid = pid;
	hd.port = port;
	return sendRequest(&hd);

} // HelperDeleteDPlayServer
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\wsock\helpcli.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       helpcli.h
 *  Content:	header file for dplay helper interface
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	2/15/97		andyco	created from w95help.h
 *
 ***************************************************************************/
#ifndef __HELPCLI_INCLUDED__
#define __HELPCLI_INCLUDED__
#include "windows.h"
#include "dplaysvr.h"
#include "dpf.h"

#ifdef __cplusplus
extern "C" {
#endif

extern void HelpcliFini( void );

extern BOOL CreateHelperProcess( LPDWORD ppid );
extern BOOL WaitForHelperStartup( void );
extern HRESULT HelperAddDPlayServer(USHORT port);
extern BOOL HelperDeleteDPlayServer(USHORT port);

#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\wsock\leverage.c ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       leverage.c
 *  Content:	code to allow third parties to hook our wsock sp
 *  History:
 *   Date	By		Reason
 *   ====	==		======
 *	8/30/96	andyco	moved this code from dpsp.c for more better clean
 *	2/18/98 a-peterz Comment byte order for address and port parameters
 **************************************************************************/

#include "dpsp.h"

#undef DPF_MODNAME
#define DPF_MODNAME	"dpwsock helper functions- "


// the functions below are exported from dpwsock so sp's sitting on 
// top of us can hook our enum routine (e.g. for Kali)
// return the port of our enum socket (net byte order)
HRESULT DPWS_GetEnumPort(IDirectPlaySP * pISP,LPWORD pPort)
{
	SOCKADDR_IN sockaddr;
	int iAddrLen = sizeof(SOCKADDR);
	UINT err;
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	HRESULT hr;
		
	if (!pISP)
	{
		DPF_ERR("must pass in IDirectPlaySP pointer!");
		return E_FAIL;
	}
	
	// get the global data
	hr =pISP->lpVtbl->GetSPData(pISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		ExitThread(0);
		return 0;

	}

	if (AF_IPX == pgd->AddressFamily) 
	{
		DPF(0," could not get the enum port for AF_IPX");
		return E_FAIL;
	}

	ASSERT(pPort);
	ASSERT(INVALID_SOCKET != pgd->sSystemStreamSocket);
	
    err = getsockname(pgd->sSystemStreamSocket,(SOCKADDR *)&sockaddr,&iAddrLen);
    if (SOCKET_ERROR == err) 
    {
        err = WSAGetLastError();
        DPF(0,"GetEnumPort - getsockname - err = %d\n",err);
		return E_FAIL;
    } 

	*pPort = sockaddr.sin_port;
	
	return DP_OK;
} // GetEnumPort

// takes a port and an ip (both in net byte order) and builds a message header
HRESULT DPWS_BuildIPMessageHeader(IDirectPlaySP * pISP,LPVOID pvMessageHeader,LPDWORD
 	pdwMessageHeaderSize,WORD port,DWORD inaddr)
{
	LPMESSAGEHEADER	phead;
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	HRESULT hr;
		
	if (!pISP)
	{
		DPF_ERR("must pass in IDirectPlaySP pointer!");
		return E_FAIL;
	}
	
	// get the global data
	hr =pISP->lpVtbl->GetSPData(pISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		ExitThread(0);
		return 0;

	}

	ASSERT(pdwMessageHeaderSize);
	if ( (*pdwMessageHeaderSize < sizeof(MESSAGEHEADER)) || (NULL == pvMessageHeader))
	{
		*pdwMessageHeaderSize = sizeof(MESSAGEHEADER);
		return DPERR_BUFFERTOOSMALL;
	}

	if (AF_IPX == pgd->AddressFamily)
	{
		DPF_ERR("can't set header for ipx");
		return E_NOTIMPL;
	}

	phead = (LPMESSAGEHEADER)pvMessageHeader;
	((SOCKADDR_IN *)&(phead->sockaddr))->sin_family =  AF_INET;
	((SOCKADDR_IN *)&(phead->sockaddr))->sin_addr.s_addr =  inaddr;
	((SOCKADDR_IN *)&(phead->sockaddr))->sin_port =  port;

	DEBUGPRINTADDR(5,"BuildIPMessageHeader - setting header to",&(phead->sockaddr));

	return DP_OK;

} // BuildIPMessageHeader


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\wsock\nathelp.h ===
#if USE_NATHELP
// from nathelp.c
BOOL natGetCapsUpdate(LPGLOBALDATA pgd);
BOOL natInit(LPGLOBALDATA pgd,LPGUID lpguidSP);
VOID natFini(LPGLOBALDATA pgd);
VOID natDeregisterPorts(LPGLOBALDATA pgd);
HRESULT natRegisterPort(LPGLOBALDATA pgd, BOOL ftcp_udp, WORD port);
VOID natDeregisterPort(LPGLOBALDATA pgd, BOOL ftcp_udp);
BOOL natIsICSMachine(LPGLOBALDATA pgd);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\wsock\daytona\makefile.inc ===
misc :
	copy ..\..\common\newdpf.h .
	copy ..\..\common\newdpf.c .
	copy ..\..\common\memalloc.c .
	copy ..\..\common\dputils.c .
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\wsock\daytona\newdpf.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       newdpf.h
 *  Content:    new debug printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   10-oct-95  jeffno  initial implementation
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DEBUGPF_H
#define __DEBUGPF_H

#include <stdarg.h>
#include <windows.h>
#include <memlog.h>

#ifdef __cplusplus
	extern "C" {
#endif
#ifndef DPF_MODNAME
    extern char * DPF_MODNAME;
#endif

#if defined(DEBUG) || defined(DBG)

    #undef DEBUG_TOPIC
    #define DEBUG_TOPIC(flag,name) flag,
    typedef enum DEBUG_TOPICS {
        A=1,    /* For API Usage */
    #include "DBGTOPIC.H"
        LAST_TOPIC
    };

    #line 21
/*
    #undef DBG
    #define DBG 1
    */
    #undef DEBUG
    #define DEBUG
    #if defined( _WIN32 ) && !defined(WINNT)
	#define DEBUG_BREAK()       _try { _asm { int 3 } } _except (EXCEPTION_EXECUTE_HANDLER) {;}
    #else
	#define DEBUG_BREAK()       DebugBreak()
    #endif


    /*
     * DEBUG_TOPIC
     * This structure describes a debugging topic and associates a single-letter key to it.
     */

    #define DEBUG_TOPIC_NAME_LENGTH 59
    typedef struct
    {
        DWORD   dwSize; //for versioning
        char    cKey;
        char    cName[DEBUG_TOPIC_NAME_LENGTH];
    } DPF_DEBUG_TOPIC;

    /*
     * PROC_STATS
     * This struct saves statistics about each proc as maintained by DebugEnterProc
     */
    typedef struct
    {
        char            cName[DEBUG_TOPIC_NAME_LENGTH];
        DWORD           dwCalls;
#ifdef WIN32
        LARGE_INTEGER   liTotalTime;
        LARGE_INTEGER   liLastEnteredAt;
#else
        DWORD           dwFiller[8];
#endif
    } DPF_PROC_STATS;

    #define MAX_PROC_ORDINAL 100

    /*
     * Debugging output/flow-control calls
     */
    typedef struct {
    	UINT stat_ThrottleRate;
		UINT stat_BytesSent;
		UINT stat_BackLog;
	 	UINT stat_BytesLost;
	 	UINT stat_RemBytesReceived;
		UINT stat_Latency; 
		UINT stat_MinLatency;
		UINT stat_AvgLatency;
		UINT stat_AvgDevLatency;
		UINT stat_USER1;
		UINT stat_USER2;
		UINT stat_USER3;
		UINT stat_USER4;
		UINT stat_USER5;	// remote tDelta
		UINT stat_USER6;	// Remote tDelta sign (0=+ve, 1=-ve)
	} IN_WRITESTATS, *PIN_WRITESTATS;

	typedef struct {
		UINT	hr;
	} OUT_WRITESTATS, *POUT_WRITESTATS;

   extern void DbgWriteStats(PIN_WRITESTATS pIn);
  
   extern void DebugSetTopicsAndLevels(char * pcTopicsAndLevelsToDisplay);
   extern void DebugHalt(void);       //Break if control level allows
   extern int  DebugSetFileLineEtc(LPSTR szFile, DWORD dwLineNumber,LPSTR szFnName);
   extern int  DebugPrintf(volatile DWORD dwDetail, ...);
   extern void DebugSetMute(BOOL bMuteFlag);
   extern void DebugPrintfInit(void);
   extern void DebugEnterAPI(char *,LPDWORD);
   extern void _DDAssert(LPCSTR szFile, int nLine, LPCSTR szCondition);
 
    #define dprintf(a,b)                            DebugPrintf(a,b);
    #define DPFINIT()                               DebugPrintfInit();
    #define DPF                                     DebugSetFileLineEtc(__FILE__,__LINE__,DPF_MODNAME),DebugPrintf
    #define DPF_ERR(a)                              DebugSetFileLineEtc(__FILE__,__LINE__,DPF_MODNAME),DebugPrintf( 0, a )
    #define DPF_ENTERAPI(pIface)                    DebugEnterAPI(DPF_MODNAME,(LPDWORD)pIface)
    #define DPF_APIRETURNS(hr)                      DPF(3,"   %s returns %08x (%d)",DPF_MODNAME,hr,hr&0xfff)
    #define DDASSERT(condition)                     if (!(condition)) _DDAssert(__FILE__, __LINE__, #condition)
    #define DPF_MUTEWHEN(c)                         {DebugSetMute((BOOL) (c) );}
    #define DPF_SPEWWHEN(c)                         {DebugSetMute((BOOL) (!(c)) );}
    #define DPF_SETTOPICS(t)
    #define DPF_STRUCT(level,topic,struct_identifier,struct_ptr)    {extern void DUMP_##struct_identifier(DWORD,DWORD,LP##struct_identifier);\
                                                    DUMP_##struct_identifier(level,topic,struct_ptr);}


#else
    #pragma warning(disable:4002)
    #define DbgWriteStats()
    #define dprintf()
    #define DPFINIT()
    #define DPFFINI()
    #define DPF()
    #define DPF_ENTERAPI()
    #define DPF_APIRETURNS()
    #define DPF_DUMP()
    #define DPF_DUMPHEX()
    #define DPF_DUMPGUID()
    #define DDASSERT()
    #define DPF_ERR()
    #define DEBUG_BREAK()
    #define DPF_MUTEWHEN()
    #define DPF_SPEWWHEN()
    #define DPF_SETTOPICS()
    #define DPF_DUMPGUID()
    #define DPF_STRUCT()

#endif


#ifdef _WIN32

#ifdef DEBUG
    __inline DWORD myclockrate() {LARGE_INTEGER li; QueryPerformanceFrequency(&li); return li.LowPart;}
    __inline DWORD myclock()	 {LARGE_INTEGER li; QueryPerformanceCounter(&li);   return li.LowPart;}

    #define TIMEVAR(t)    DWORD t ## T; DWORD t ## N
    #define TIMEZERO(t)   t ## T = 0, t ## N = 0
    #define TIMESTART(t)  t ## T -= myclock(), t ## N ++
    #define TIMESTOP(t)   t ## T += myclock()
    #define TIMEFMT(t)	  ((DWORD)(t) / myclockrate()), (((DWORD)(t) * 1000 / myclockrate())%1000)
    #define TIMEOUT(t)    if (t ## N) DPF(1, #t ": %ld calls, %ld.%03ld sec (%ld.%03ld)", t ## N, TIMEFMT(t ## T), TIMEFMT(t ## T / t ## N))
#else
    #define TIMEVAR(t)
    #define TIMEZERO(t)
    #define TIMESTART(t)
    #define TIMESTOP(t)
    #define TIMEFMT(t)
    #define TIMEOUT(t)
#endif

#endif


#ifdef __cplusplus
}
#endif

#endif //__DEBUG_PF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\wsock\nathelp.c ===
/*==========================================================================
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       nathelp.c
 *  Content:   usage for nat helper DLL
 *
 *  History:
 *  Date			By		Reason
 *  ====			==		======
 *  02/22/2001		aarono	Original
 *  04/16/2001		vanceo	Use one of the split DirectPlayNATHelp interfaces only.
 *
 *  Notes:
 *   
 ***************************************************************************/


#define INCL_WINSOCK_API_TYPEDEFS 1 // includes winsock 2 fn proto's, for getprocaddress
#define FD_SETSIZE 1
#include <winsock2.h>
#include "dpsp.h"
#include "mmsystem.h"
#if USE_NATHELP

#include "dpnathlp.h"

BOOL natGetCapsUpdate(LPGLOBALDATA pgd)
{
	HRESULT hr;
	//
	// Get Nat Capabilities - may block for a second.
	//
	
	memset(&pgd->NatHelpCaps,0,sizeof(DPNHCAPS));
	pgd->NatHelpCaps.dwSize=sizeof(DPNHCAPS);
	hr=IDirectPlayNATHelp_GetCaps(pgd->pINatHelp, &pgd->NatHelpCaps, DPNHGETCAPS_UPDATESERVERSTATUS);
	
	if(FAILED(hr))
	{
		DPF(0,"NatHelp failed to GetCaps, hr=%x\n",hr);
		return FALSE;
	}

	if (hr == DPNHSUCCESS_ADDRESSESCHANGED)
	{
		DPF(1,"NAT Help reports addresses changed, possible connection problems may occur.");
	}

	return TRUE;

}

/*=============================================================================

	natInit	- Initialize nat helper i/f
	
    Description:


    Parameters:

    	pgd  - Service Provider's global data blob for this instance

    Return Values:


-----------------------------------------------------------------------------*/
BOOL natInit(LPGLOBALDATA pgd,LPGUID lpguidSP)
{
	HRESULT hr;
	char szNATHelpPath[256];
	PFN_DIRECTPLAYNATHELPCREATE pfnNatHelpCreate = NULL;
	char *apszNATHelps[3];
	HMODULE ahNatHelps[3];
	IDirectPlayNATHelp *apINatHelps[3];
	DPNHCAPS adpnhcNatHelpCaps[3];
	DWORD dwNumNatHelps = 0;
	DWORD dwCurrentNatHelp;


	pgd->hNatHelp = NULL;
	pgd->pINatHelp = NULL;

	pgd->hNatHelpTCP = 0;
	pgd->hNatHelpUDP = 0;

    // build an internet INADDRANY
    memset(&pgd->INADDRANY,0,sizeof(SOCKADDR));
    pgd->INADDRANY.sa_family=AF_INET;


	memset(ahNatHelps, 0, sizeof(ahNatHelps));
	memset(apINatHelps, 0, sizeof(apINatHelps));

	//
	// See if there's a registry setting.
	//
	hr = GetNATHelpDLLFromRegistry((LPGUID) (&DPSPGUID_TCPIP), szNATHelpPath, 256);
	if (hr == S_OK)
	{
		DPF(1, "Got NAT Help DLL \"%s\" from registry.\n", szNATHelpPath);
		apszNATHelps[dwNumNatHelps++] = szNATHelpPath;
	}
	else
	{
		DPF(4, "Couldn't get NAT Help DLL from registry, hr=%x.\n", hr);
	}

	//
	// Add the default entries if the registry didn't already specify them.
	//
	if (_strnicmp(szNATHelpPath + strlen(szNATHelpPath) - strlen("dpnhupnp.dll"), "dpnhupnp.dll", strlen("dpnhupnp.dll")) != 0)
	{
		apszNATHelps[dwNumNatHelps++] = "dpnhupnp.dll";
	}
	if (_strnicmp(szNATHelpPath + strlen(szNATHelpPath) - strlen("dpnhpast.dll"), "dpnhpast.dll", strlen("dpnhpast.dll")) != 0)
	{
		apszNATHelps[dwNumNatHelps++] = "dpnhpast.dll";
	}

	//
	// Loop through the registry specified and default NAT Helpers and attempt
	// to load them.
	//
	for(dwCurrentNatHelp = 0; dwCurrentNatHelp < dwNumNatHelps; dwCurrentNatHelp++)
	{
		pgd->hNatHelp = LoadLibrary(apszNATHelps[dwCurrentNatHelp]);
		if (pgd->hNatHelp != NULL)
		{
			pfnNatHelpCreate = (PFN_DIRECTPLAYNATHELPCREATE) GetProcAddress(pgd->hNatHelp,
																		"DirectPlayNATHelpCreate");
			if (pfnNatHelpCreate != NULL)
			{
				hr = pfnNatHelpCreate(&IID_IDirectPlayNATHelp, (void **) (&pgd->pINatHelp));
				if (hr == DP_OK)
				{
					//
					// Initialize the NAT Helper interface.
					//		
					hr = IDirectPlayNATHelp_Initialize(pgd->pINatHelp, 0);
					if (hr == DP_OK)
					{
						//
						// Get the capabilities.  If it succeeds, remember the information and move on.
						//
						if (natGetCapsUpdate(pgd))
						{
							DPF(3, "Successfully retrieved caps for NAT Help \"%s\", flags = 0x%x.",
								apszNATHelps[dwCurrentNatHelp], pgd->NatHelpCaps.dwFlags);
							ahNatHelps[dwCurrentNatHelp] = pgd->hNatHelp;
							pgd->hNatHelp = NULL;
							apINatHelps[dwCurrentNatHelp] = pgd->pINatHelp;
							pgd->pINatHelp = NULL;
							memcpy(&adpnhcNatHelpCaps[dwCurrentNatHelp], &pgd->NatHelpCaps, sizeof(DPNHCAPS));
							continue;
						}
						else
						{
							DPF(0, "Couldn't get NAT Help \"%s\" caps, hr=%x!", apszNATHelps[dwCurrentNatHelp], hr);
						}
						
						IDirectPlayNATHelp_Close(pgd->pINatHelp, 0);
					}
					else
					{
						DPF(0, "NAT Help \"%s\" failed to initialize, hr=%x!", apszNATHelps[dwCurrentNatHelp], hr);
					}
					
					IDirectPlayNATHelp_Release(pgd->pINatHelp);
					pgd->pINatHelp = NULL;
				}
				else
				{
					DPF(0, "Couldn't create NAT Help \"%s\" interface, hr = %x!", apszNATHelps[dwCurrentNatHelp], hr);
				}
			}
			else
			{
				DPF(0, "Couldn't get NAT Help DLL \"%s\" entry point!", apszNATHelps[dwCurrentNatHelp]);
			}
			
			FreeLibrary(pgd->hNatHelp);
			pgd->hNatHelp = NULL;
		}
		else
		{
			DPF(0, "Couldn't load NAT Help DLL \"%s\"!", apszNATHelps[dwCurrentNatHelp]);
		}
	}


	//
	// Now go through and pick the first helper that detected a NAT.
	//
	for(dwCurrentNatHelp = 0; dwCurrentNatHelp < dwNumNatHelps; dwCurrentNatHelp++)
	{
		if ((apINatHelps[dwCurrentNatHelp] != NULL) &&
			(adpnhcNatHelpCaps[dwCurrentNatHelp].dwFlags & DPNHCAPSFLAG_GATEWAYPRESENT))
		{
			DPF(2, "Gateway detected by NAT Help \"%s\", flags = 0x%x.",
				apszNATHelps[dwCurrentNatHelp], adpnhcNatHelpCaps[dwCurrentNatHelp].dwFlags);
			pgd->hNatHelp = ahNatHelps[dwCurrentNatHelp];
			ahNatHelps[dwCurrentNatHelp] = NULL;
			pgd->pINatHelp = apINatHelps[dwCurrentNatHelp];
			apINatHelps[dwCurrentNatHelp] = NULL;
			memcpy(&pgd->NatHelpCaps, &adpnhcNatHelpCaps[dwCurrentNatHelp], sizeof(DPNHCAPS));
			break;
		}
	}

	//
	// If we didn't get a helper that way, pick the first one that detected a firewall.
	//
	if (pgd->pINatHelp != NULL)
	{
		for(dwCurrentNatHelp = 0; dwCurrentNatHelp < dwNumNatHelps; dwCurrentNatHelp++)
		{
			if ((apINatHelps[dwCurrentNatHelp] != NULL) &&
				(adpnhcNatHelpCaps[dwCurrentNatHelp].dwFlags & DPNHCAPSFLAG_LOCALFIREWALLPRESENT))
			{
				DPF(2, "Firewall detected by NAT Help \"%s\", flags = 0x%x.",
					apszNATHelps[dwCurrentNatHelp], adpnhcNatHelpCaps[dwCurrentNatHelp].dwFlags);
				pgd->hNatHelp = ahNatHelps[dwCurrentNatHelp];
				ahNatHelps[dwCurrentNatHelp] = NULL;
				pgd->pINatHelp = apINatHelps[dwCurrentNatHelp];
				apINatHelps[dwCurrentNatHelp] = NULL;
				memcpy(&pgd->NatHelpCaps, &adpnhcNatHelpCaps[dwCurrentNatHelp], sizeof(DPNHCAPS));
				break;
			}
		}
	}

	//
	// Now go through and release all the other NAT helpers, or pick the first one that
	// successfully loaded if we didn't pick one already.
	//
	for(dwCurrentNatHelp = 0; dwCurrentNatHelp < dwNumNatHelps; dwCurrentNatHelp++)
	{
		if (apINatHelps[dwCurrentNatHelp] != NULL)
		{
			if (pgd->pINatHelp == NULL)
			{
				DPF(2, "Using first loaded NAT Help \"%s\", flags = 0x%x.",
					apszNATHelps[dwCurrentNatHelp], adpnhcNatHelpCaps[dwCurrentNatHelp].dwFlags);
				pgd->hNatHelp = ahNatHelps[dwCurrentNatHelp];
				ahNatHelps[dwCurrentNatHelp] = NULL;
				pgd->pINatHelp = apINatHelps[dwCurrentNatHelp];
				apINatHelps[dwCurrentNatHelp] = NULL;
				memcpy(&pgd->NatHelpCaps, &adpnhcNatHelpCaps[dwCurrentNatHelp], sizeof(DPNHCAPS));
			}
			else
			{
				IDirectPlayNATHelp_Close(apINatHelps[dwCurrentNatHelp], 0);
				IDirectPlayNATHelp_Release(apINatHelps[dwCurrentNatHelp]);
				apINatHelps[dwCurrentNatHelp] = NULL;
				FreeLibrary(ahNatHelps[dwCurrentNatHelp]);
				ahNatHelps[dwCurrentNatHelp] = NULL;
			}
		}
	}

	if (pgd->pINatHelp == NULL)
	{
		DPF(1, "No NAT Help loaded.");
		pgd->NatHelpCaps.dwRecommendedGetCapsInterval = INFINITE;
		return FALSE;
	}

#ifdef DEBUG
	if (! (pgd->NatHelpCaps.dwFlags & DPNHCAPSFLAG_PUBLICADDRESSAVAILABLE))
	{
		DPF(1, "NAT Help loaded, no NAT/firewall detected, or it doesn't currently have a public address (flags = 0x%x).",
			pgd->NatHelpCaps.dwFlags);
	}
#endif // DEBUG

	return TRUE;
}

/*=============================================================================

	natFini - Shut down NATHELP support
	
	
    Description:


    Parameters:

    	pgd  - Service Provider's global data blob for this instance

    Return Values:

		None.

-----------------------------------------------------------------------------*/
VOID natFini(LPGLOBALDATA pgd)
{

	// natDeregisterPorts(pgd); - vance says we don't need to do this.
	if(pgd->pINatHelp)
	{
        IDirectPlayNATHelp_Close(pgd->pINatHelp, 0);
    	pgd->hNatHelpTCP = 0;
	    pgd->hNatHelpUDP = 0;
		IDirectPlayNATHelp_Release(pgd->pINatHelp);
		pgd->pINatHelp=NULL;
	}	

	if(pgd->hNatHelp)
	{
		FreeLibrary(pgd->hNatHelp);
		pgd->hNatHelp=NULL;
	}
		
}

/*=============================================================================

	natRegisterPort - Get a port mapping.
	
	
    Description:

		Note only one mapping each for TCP and UDP are supported (for simplicity).

    Parameters:

    	pgd  - Service Provider's global data blob for this instance

    Return Values:

		None.

-----------------------------------------------------------------------------*/
HRESULT natRegisterPort(LPGLOBALDATA pgd, BOOL ftcp_udp, WORD port)
{
	SOCKADDR_IN 	sockaddr_in, sockaddr_inpublic;
	DWORD			dwFlags, dwSize;
	DPNHHANDLE		hPortMapping;
	HRESULT 		hr=DP_OK;
	
	memset(&sockaddr_in , 0 ,sizeof(sockaddr_in));
	sockaddr_in.sin_family          = AF_INET;
	sockaddr_in.sin_addr.S_un.S_addr= INADDR_ANY;
	sockaddr_in.sin_port            = htons(port);

	if (ftcp_udp)
	{
		dwFlags = DPNHREGISTERPORTS_TCP;
	}
	else
	{
		dwFlags = 0;
	}

	hr=IDirectPlayNATHelp_RegisterPorts(pgd->pINatHelp, (SOCKADDR *)&sockaddr_in, sizeof(sockaddr_in), 1, 15*60000, &hPortMapping, dwFlags);
	if (hr != DPNH_OK)
	{
		DPF(0,"NATHelp_RegisterPorts registration failed, hr=%x",hr);
		hr = DPERR_GENERIC;
	}
	else
	{
		dwSize=sizeof(sockaddr_inpublic);
		hr = IDirectPlayNATHelp_GetRegisteredAddresses(pgd->pINatHelp, hPortMapping, (SOCKADDR *)&sockaddr_inpublic, &dwSize, NULL, NULL, 0);
		switch (hr)
		{
			case DPNH_OK:
			{
	      		DPF(2, "NATHelp successfully mapped port to %s:%u.",
	      			inet_ntoa(sockaddr_inpublic.sin_addr), ntohs(sockaddr_inpublic.sin_port) );
	      		
				if (ftcp_udp)
				{
					ASSERT(!pgd->hNatHelpTCP);
					if(pgd->hNatHelpTCP)
					{
						DPF(0,"WARNING: trying to map a TCP connection when one is already mapped?\n");
					}
					pgd->hNatHelpTCP=hPortMapping;
					
					memcpy(&pgd->saddrpubSystemStreamSocket, &sockaddr_inpublic, sizeof(SOCKADDR_IN));
				}
				else
				{
					ASSERT(!pgd->hNatHelpUDP);
					if (pgd->hNatHelpUDP)
					{
						DPF(0,"WARNING: trying to map a UDP connection when one is already mapped?\n");
					}
					pgd->hNatHelpUDP=hPortMapping;
					
					memcpy(&pgd->saddrpubSystemDGramSocket, &sockaddr_inpublic, sizeof(SOCKADDR_IN));
				}
				break;
			}
			
			case DPNHERR_PORTUNAVAILABLE:
			{
	      		DPF(0, "NATHelp reported port %u is unavailable!", port);
		    		
				hr=IDirectPlayNATHelp_DeregisterPorts(pgd->pINatHelp, hPortMapping, 0);
				if (hr != DP_OK)
				{
					DPF(0,"NATHelp_DeregisterPorts returned %x\n",hr);
				}
				
				hr = DPNHERR_PORTUNAVAILABLE;
				break;
			}
			
			default:
			{
		    	DPF(1, "NATHelp couldn't map port %u, (err = 0x%lx).", port, hr);
		    	
				if (ftcp_udp)
				{
					ASSERT(!pgd->hNatHelpTCP);
					if(pgd->hNatHelpTCP)
					{
						DPF(0,"WARNING: trying to map a TCP connection when one is already mapped?\n");
					}
					pgd->hNatHelpTCP=hPortMapping;
				}
				else
				{
					ASSERT(!pgd->hNatHelpUDP);
					if (pgd->hNatHelpUDP)
					{
						DPF(0,"WARNING: trying to map a UDP connection when one is already mapped?\n");
					}
					pgd->hNatHelpUDP=hPortMapping;
				}

				hr = DPERR_GENERIC;
				break;
			}
		}
	}
	
	return hr;
}


/*=============================================================================

	natDeregisterPort - Get rid of either UDP or TCP port mappings
	
	
    Description:


    Parameters:

    	pgd  - Service Provider's global data blob for this instance

    Return Values:

		None.

-----------------------------------------------------------------------------*/
VOID natDeregisterPort(LPGLOBALDATA pgd, BOOL ftcp_udp)
{
	HRESULT hr;

	if(ftcp_udp && pgd->hNatHelpTCP){
	    DPF(8,"Deregister TCP port\n");
		hr=IDirectPlayNATHelp_DeregisterPorts(pgd->pINatHelp, pgd->hNatHelpTCP, 0);
		if(hr!=DP_OK){
			DPF(0,"NATHelp_DeRegisterPorts returned %x\n",hr);
		}
		pgd->hNatHelpTCP=0;

		memset(&pgd->saddrpubSystemStreamSocket, 0, sizeof(SOCKADDR_IN));
	}
	if(!ftcp_udp && pgd->hNatHelpUDP){
	    DPF(8,"Deregistering UDP port\n");
		hr=IDirectPlayNATHelp_DeregisterPorts(pgd->pINatHelp, pgd->hNatHelpUDP, 0);
		if(hr!=DP_OK){
			DPF(0,"NATHelp_DeRegisterPorts returned %x\n",hr);
		}
		pgd->hNatHelpUDP=0;

		memset(&pgd->saddrpubSystemDGramSocket, 0, sizeof(SOCKADDR_IN));
	}	
}




/*=============================================================================

	natIsICSMachine - Return TRUE if this machine is a Windows ICS machine, FALSE otherwise
	
	
    Description:


    Parameters:

    	pgd  - Service Provider's global data blob for this instance

    Return Values:

		None.

-----------------------------------------------------------------------------*/
BOOL natIsICSMachine(LPGLOBALDATA pgd)
{
	if (pgd->pINatHelp != NULL)
	{
		if ((pgd->NatHelpCaps.dwFlags & DPNHCAPSFLAG_GATEWAYPRESENT) &&
			(pgd->NatHelpCaps.dwFlags & DPNHCAPSFLAG_GATEWAYISLOCAL))
		{
			DPF(1, "Local internet gateway present, flags = 0x%x.", pgd->NatHelpCaps.dwFlags);
			return TRUE;
		}
		else
		{
			DPF(1, "No local internet gateway present, flags = 0x%x.", pgd->NatHelpCaps.dwFlags);
		}
	}
	else
	{
		DPF(1, "NAT Help not loaded.");
	}

	return FALSE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\wsock\win9x\makefile.inc ===
misc :
	copy ..\..\common\newdpf.h .
	copy ..\..\common\newdpf.c .
	copy ..\..\common\dputils.c .
	copy ..\..\common\memalloc.c .
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\wsock\registry.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       registry.c
 *
 *  History:
 *  Date		By		Reason
 *  ====		==		======
 *  ???
 *  12/28/99    aarono  added query for required key for Win95 rsip support
 *  04/19/01    vanceo  added nathelp DLL retrieval and copied to dplaysvr
 *
 ***************************************************************************/



#include "dpsp.h"

#define REGISTRY_NAMELEN	512
// space (in bytes) for a human readable (unicode) guid + some extra
#define GUID_STRING_SIZE 80

#define SZ_SP_KEY		"Software\\Microsoft\\DirectPlay\\Service Providers"
#define SZ_GUID			"Guid"
#define SZ_FLAGS		"dwFlags"

#define SZ_GATEWAY		"Gateway"
#define SZ_NATHELP		"NATHelp"

#undef DPF_MODNAME
#define DPF_MODNAME "FindApplicationInRegistry"

// convert a hex char to an int - used by str to guid conversion
// we wrote our own, since the ole one is slow, and requires ole32.dll
// we use ansi strings here, since guids won't get internationalized
int GetDigit(LPSTR lpstr)
{
	char ch = *lpstr;
    
    if (ch >= '0' && ch <= '9')
        return(ch - '0');
    if (ch >= 'a' && ch <= 'f')
        return(ch - 'a' + 10);
    if (ch >= 'A' && ch <= 'F')
        return(ch - 'A' + 10);
    return(0);
}
// walk the string, writing pairs of bytes into the byte stream (guid)
// we need to write the bytes into the byte stream from right to left
// or left to right as indicated by fRightToLeft
void ConvertField(LPBYTE lpByte,LPSTR * ppStr,int iFieldSize,BOOL fRightToLeft)
{
	int i;

	for (i=0;i<iFieldSize ;i++ )
	{
		// don't barf on the field separators
		if ('-' == **ppStr) (*ppStr)++; 
		if (fRightToLeft == TRUE)
		{
			// work from right to left within the byte stream
			*(lpByte + iFieldSize - (i+1)) = 16*GetDigit(*ppStr) + GetDigit((*ppStr)+1);
		} 
		else 
		{
			// work from  left to right within the byte stream
			*(lpByte + i) = 16*GetDigit(*ppStr) + GetDigit((*ppStr)+1);
		}
		*ppStr+=2; // get next two digit pair
	}
} // ConvertField


// convert the passed in string to a real GUID
// walk the guid, setting each byte in the guid to the two digit hex pair in the
// passed string
HRESULT GUIDFromString(LPSTR lpStr, GUID * pGuid)
{
	BYTE * lpByte; // byte index into guid
	int iFieldSize; // size of current field we're converting
	// since its a guid, we can do a "brute force" conversion
	
	// make sure we have a {xxxx-...} type guid
	if ('{' !=  *lpStr) return E_FAIL;
	lpStr++;
	
	lpByte = (BYTE *)pGuid;
	// data 1
	iFieldSize = sizeof(unsigned long);
	ConvertField(lpByte,&lpStr,iFieldSize,TRUE);
	lpByte += iFieldSize;

	// data 2
	iFieldSize = sizeof(unsigned short);
	ConvertField(lpByte,&lpStr,iFieldSize,TRUE);
	lpByte += iFieldSize;

	// data 3
	iFieldSize = sizeof(unsigned short);
	ConvertField(lpByte,&lpStr,iFieldSize,TRUE);
	lpByte += iFieldSize;

	// data 4
	iFieldSize = 8*sizeof(unsigned char);
	ConvertField(lpByte,&lpStr,iFieldSize,FALSE);
	lpByte += iFieldSize;

	// make sure we ended in the right place
	if ('}' != *lpStr) 
	{
		DPF_ERR("invalid guid!!");
		memset(pGuid,0,sizeof(GUID));
		return E_FAIL;
	}

	return DP_OK;
}// GUIDFromString

BOOL FindSPInRegistry(LPGUID lpguid, LPSTR lpszSPName, DWORD dwNameSize, HKEY * lphkey)
{
	HKEY	hkeyDPSPs, hkeySP;
	DWORD	dwIndex = 0;
	CHAR	szGuidStr[GUID_STRING_SIZE];
	DWORD	dwGuidStrSize = GUID_STRING_SIZE;
	DWORD	dwType = REG_SZ;
	GUID	guidSP;
	LONG	lReturn;
	BOOL	bFound = FALSE;
	DWORD	dwSaveNameSize = dwNameSize;


	DPF(7, "Entering FindSPInRegistry");
	DPF(8, "Parameters: 0x%08x, 0x%08x, %lu, 0x%08x",
			lpguid, lpszSPName, dwNameSize, lphkey);

 	// Open the Applications key
	lReturn = RegOpenKeyExA(HKEY_LOCAL_MACHINE, SZ_SP_KEY, 0,
							KEY_READ, &hkeyDPSPs);
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERR("Unable to open DPlay service provider registry key!");
		return FALSE;
	}

	// Walk the list of sps in the registry, looking for
	// the sp with the right GUID
	while(!bFound)
	{
		// Open the next SP key
		dwSaveNameSize = dwNameSize;
		dwGuidStrSize = GUID_STRING_SIZE;
		lReturn = RegEnumKeyExA(hkeyDPSPs, dwIndex++, lpszSPName,
						&dwSaveNameSize, NULL, NULL, NULL, NULL);

		// If the enum returns no more SPs, we want to bail
		if(lReturn != ERROR_SUCCESS)
			break;
		
		// Open the SP key		
		lReturn = RegOpenKeyExA(hkeyDPSPs, lpszSPName, 0,
									KEY_READ, &hkeySP);
		if(lReturn != ERROR_SUCCESS)
		{
			DPF_ERR("Unable to open sp key!");
			continue;
		}

		// Get the GUID of the SP
		lReturn = RegQueryValueExA(hkeySP, SZ_GUID, NULL, &dwType,
									(LPBYTE)szGuidStr, &dwGuidStrSize);
		if(lReturn != ERROR_SUCCESS)
		{
			RegCloseKey(hkeySP);
			DPF_ERR("Unable to query GUID key value!");
			continue;
		}

		// Convert the string to a real GUID & Compare it to the passed in one
		GUIDFromString(szGuidStr, &guidSP);
		if(IsEqualGUID(&guidSP, lpguid))
		{
			bFound = TRUE;
			break;
		}

		// Close the SP key
		RegCloseKey(hkeySP);
	}

	// Close the SPs key
	RegCloseKey(hkeyDPSPs);

	if(bFound)
		*lphkey = hkeySP;

	return bFound;


} // FindSPInRegistry



#undef DPF_MODNAME
#define DPF_MODNAME "GetKeyValue"
BOOL GetKeyValue(HKEY hkeyApp, LPSTR lpszKey, DWORD dwType, LPBYTE * lplpValue)
{
	DWORD	dwSize;
	LPBYTE	lpTemp = NULL;
	LONG	lReturn;


	DPF(7, "Entering GetKeyValue");
	DPF(8, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			hkeyApp, lpszKey, lplpValue);

	ASSERT(lplpValue);

	// Get the size of the buffer for the Path
	lReturn = RegQueryValueExA(hkeyApp, lpszKey, NULL, &dwType, NULL, &dwSize);
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERR("Error getting size of key value!");
		return FALSE;
	}

	// If the size is 1, then it is an empty string (only contains a
	// null terminator).  Treat this the same as a NULL string or a
	// missing key and fail it.
	if(dwSize <= 1)
		return FALSE;

	ENTER_DPSP();
	
	// Alloc the buffer for the Path
	lpTemp = SP_MemAlloc(dwSize);

	LEAVE_DPSP();
	
	if(!lpTemp)
	{
		DPF_ERR("Unable to allocate temporary string for Path!");
		return FALSE;
	}

	// Get the value itself
	lReturn = RegQueryValueExA(hkeyApp, lpszKey, NULL, &dwType,
							(LPBYTE)lpTemp, &dwSize);
	if(lReturn != ERROR_SUCCESS)
	{
		SP_MemFree(lpTemp);
		DPF_ERR("Unable to get key value!");
		return FALSE;
	}

	*lplpValue = lpTemp;
	return TRUE;

} // GetKeyValue


#undef DPF_MODNAME
#define DPF_MODNAME "GetFlagsFromRegistry"
HRESULT GetFlagsFromRegistry(LPGUID lpguidSP, LPDWORD lpdwFlags)
{
	LPSTR	lpszSPName=NULL;
	HKEY	hkeySP = NULL;
	LPBYTE	lpValue=NULL;
	DWORD	dwSize = 0;
	HRESULT hr = DP_OK;


	DPF(7, "Entering GetFlagsFromRegistry");
	DPF(8, "Parameters: 0x%08x, 0x%08x", lpguidSP, lpdwFlags);

	ENTER_DPSP();
	
	// Allocate memory for the App Name
	lpszSPName = SP_MemAlloc(REGISTRY_NAMELEN);

	LEAVE_DPSP();
	
	if(!lpszSPName)
	{
		DPF_ERR("Unable to allocate memory for sp name!");
		return E_OUTOFMEMORY;
	}
	
	// Open the registry key for the App
	if(!FindSPInRegistry(lpguidSP, lpszSPName,REGISTRY_NAMELEN, &hkeySP))
	{
		DPF_ERR("Unable to find sp in registry!");
		hr = E_FAIL;
		goto CLEANUP_EXIT;
	}

	// Get the port value.
	if(!GetKeyValue(hkeySP, SZ_FLAGS, REG_BINARY, &lpValue))
	{
		DPF_ERR("Unable to get flags value from registry!");
		hr = E_FAIL;
		goto CLEANUP_EXIT;
	}

	*lpdwFlags = *(LPDWORD)lpValue;

	// fall through

CLEANUP_EXIT:

	if (lpszSPName) SP_MemFree(lpszSPName);
	if (lpValue) SP_MemFree(lpValue);
	
	// Close the Apps key
	if(hkeySP)
		RegCloseKey(hkeySP);

	return hr;

} // GetFlagsFromRegistry


#if USE_RSIP

#undef DPF_MODNAME
#define DPF_MODNAME "GetGatewayFromRegistry"
HRESULT GetGatewayFromRegistry(LPGUID lpguidSP, LPBYTE lpszGateway, DWORD cbszGateway)
{
	LPSTR	lpszSPName=NULL;
	HKEY	hkeySP = NULL;
	LPBYTE	lpValue=NULL;
	DWORD	dwSize = 0;
	HRESULT hr = DP_OK;


	DPF(7, "Entering GetGatewayFromRegistry");
	DPF(8, "Parameters: 0x%08x, 0x%08x %d", lpguidSP, lpszGateway, cbszGateway);

	ENTER_DPSP();
	
	// Allocate memory for the SP Name
	lpszSPName = SP_MemAlloc(REGISTRY_NAMELEN);

	LEAVE_DPSP();
	
	if(!lpszSPName)
	{
		DPF_ERR("Unable to allocate memory for sp name!");
		return E_OUTOFMEMORY;
	}
	
	// Open the registry key for the SP
	if(!FindSPInRegistry(lpguidSP, lpszSPName,REGISTRY_NAMELEN, &hkeySP))
	{
		DPF_ERR("Unable to find sp in registry!");
		hr = E_FAIL;
		goto CLEANUP_EXIT;
	}

	// Get the gateway value.
	if(!GetKeyValue(hkeySP, SZ_GATEWAY, REG_SZ, &lpValue))
	{
		DPF_ERR("Unable to get key value from registry!");
		hr = E_FAIL;
		goto CLEANUP_EXIT;
	}

	dwSize = strlen(lpValue)+1;
	if(dwSize > cbszGateway){
		DPF_ERR("Not enough room for gateway address");
		goto CLEANUP_EXIT;
	}
	memcpy(lpszGateway, lpValue, dwSize);

	// fall through

CLEANUP_EXIT:

	if (lpszSPName) SP_MemFree(lpszSPName);
	if (lpValue) SP_MemFree(lpValue);
	
	// Close the Apps key
	if(hkeySP)
		RegCloseKey(hkeySP);

	return hr;

} // GetGatewayFromRegistry


#elif USE_NATHELP // !  USE_RSIP

#undef DPF_MODNAME
#define DPF_MODNAME "GetNATHelpDLLFromRegistry"
HRESULT GetNATHelpDLLFromRegistry(LPGUID lpguidSP, LPBYTE lpszNATHelpDLL, DWORD cbszNATHelpDLL)
{
	LPSTR	lpszSPName=NULL;
	HKEY	hkeySP = NULL;
	LPBYTE	lpValue=NULL;
	DWORD	dwSize = 0;
	HRESULT hr = DP_OK;


	DPF(7, "Entering GetNATHelpDLLFromRegistry");
	DPF(8, "Parameters: 0x%08x, 0x%08x %d", lpguidSP, lpszNATHelpDLL, cbszNATHelpDLL);

	ENTER_DPSP();
	
	// Allocate memory for the SP Name
	lpszSPName = SP_MemAlloc(REGISTRY_NAMELEN);

	LEAVE_DPSP();
	
	if(!lpszSPName)
	{
		DPF_ERR("Unable to allocate memory for sp name!");
		return E_OUTOFMEMORY;
	}
	
	// Open the registry key for the SP
	if(!FindSPInRegistry(lpguidSP, lpszSPName,REGISTRY_NAMELEN, &hkeySP))
	{
		DPF_ERR("Unable to find sp in registry!");
		hr = E_FAIL;
		goto CLEANUP_EXIT;
	}

	// Get the gateway value.
	if(!GetKeyValue(hkeySP, SZ_NATHELP, REG_SZ, &lpValue))
	{
		DPF(1, "Unable to get NATHelp key value from registry.");
		hr = E_FAIL;
		goto CLEANUP_EXIT;
	}

	dwSize = strlen(lpValue)+1;
	if(dwSize > cbszNATHelpDLL){
		DPF_ERR("Not enough room for NATHelp DLL path");
		goto CLEANUP_EXIT;
	}
	memcpy(lpszNATHelpDLL, lpValue, dwSize);

	// fall through

CLEANUP_EXIT:

	if (lpszSPName) SP_MemFree(lpszSPName);
	if (lpValue) SP_MemFree(lpValue);
	
	// Close the Apps key
	if(hkeySP)
		RegCloseKey(hkeySP);

	return hr;

} // GetNATHelpDLLFromRegistry

#endif // USE_NATHELP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\wsock\spvoice.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpsp.c
 *  Content:	sample direct play service provider, based on winsock
 *  History:
 *  Date		By		Reason
 *  ====		==		======
 *  10/31/96	andyco	created it. happy holloween!
 ***************************************************************************/

#include "dpsp.h"

// get the player data for pod.  extract ip addr.  use netmeeting to place call.
HRESULT WINAPI SP_OpenVoice(LPDPSP_OPENVOICEDATA pod) 
{
    SOCKADDR_IN * pin;
    INT iAddrLen = sizeof(SOCKADDR_IN);
    HRESULT hr=DP_OK;
	DWORD dwSize = sizeof(SPPLAYERDATA);
	LPSPPLAYERDATA ppdTo;
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	
	// get the global data
	hr =pod->lpISP->lpVtbl->GetSPData(pod->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}
	// tcp only!
	if (pgd->AddressFamily != AF_INET)
	{
		DPF_ERR("voice only supported for TCP / IP");
		ASSERT(FALSE);
		return E_FAIL;
	}

	// get to address	
	hr = pod->lpISP->lpVtbl->GetSPPlayerData(pod->lpISP,pod->idTo,&ppdTo,&dwSize,DPGET_REMOTE);
	if (FAILED(hr))
	{
		ASSERT(FALSE);
		return hr;
	}

	pin = (SOCKADDR_IN *) DGRAM_PSOCKADDR(ppdTo);

	DPF(0,"calling hostname = %s\n",inet_ntoa(pin->sin_addr));
	hr = OpenVoice(inet_ntoa(pin->sin_addr));
	if (FAILED(hr))
	{
		DPF(0,"open voice failed - hr = 0x%08lx\n",hr);
		
	} 
	else 
	{
		gbVoiceOpen = TRUE;
	}
	
	return hr;
	
} // SP_OpenVoice

HRESULT WINAPI SP_CloseVoice(LPDPSP_CLOSEVOICEDATA pod) 
{
	HRESULT hr;
	
	hr = CloseVoice();
	if (FAILED(hr))
	{
		DPF(0,"close voice failed - hr = 0x%08lx\n",hr);
	} 

	// even if it failed, give up on this call...
	gbVoiceOpen = FALSE;		
	return hr;
	
} // SP_CloseVoice
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\wsock\sources.inc ===
MAJORCOMP=windows
MINORCOMP=GDI
UMTYPE=windows

TARGETNAME=dpwsockx
TARGETTYPE=DYNLINK

USE_MAPSYM=1

INCLUDES= \
     $(DXROOT)\inc;\
	 ..\..\misc; \
	 ..\; \
	 ..\..\dplay; \
	 ..\..\dplaysvr; \
	 ..\..\common; \
	 ..\..\nmvoice; \
	 ..\..\..\dpnathlp\inc; \
	 ..\..\..\dplobby\dplobby;

TARGETPATH=OBJ

# Make VC5 compatible libs (Manbugs 44478)
!ifdef DIRECTX_REDIST
LIBRARIAN_FLAGS = $(LIBRARIAN_FLAGS) /link50compat
!endif

#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
           $(BASEDIR)\public\sdk\lib\*\libc.lib    \
	   $(BASEDIR)\public\sdk\lib\*\user32.lib    \
	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib  \
	   $(BASEDIR)\public\sdk\lib\*\wsock32.lib \
	   $(BASEDIR)\public\sdk\lib\*\ole32.lib \
	   $(BASEDIR)\public\sdk\lib\*\oleaut32.lib \
	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
	   ..\..\dplay\$(PLAT_DIR)\obj$(BUILD_ALT_DIR)\*\dplayx.lib


!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

!IFDEF PENTIUMCOUNTER
C_DEFINES=$(C_DEFINES) -DPENTIUMCOUNTER
ASM_DEFINES=$(ASM_DEFINES) -DPENTIUMCOUNTER
!endif

C_DEFINES=$(C_DEFINES) -DUSE_CRITSECTS -DWIN16_SEPARATE -DNEW_DPF

LINKER_FLAGS=-SECTION:share,RWS

SOURCES= \
	..\fastsock.c \
	..\nathelp.c \
	..\bilink.c \
	..\registry.c \
	..\fpm.c \
	..\wsock2.c \
	..\leverage.c \
	..\dpsp.c \
	..\winsock.c \
	..\dllmain.c \
	..\helpcli.c \
	..\handler.c \
	..\dpwsock.rc \
	memalloc.c \
	newdpf.c \
	dputils.c

DLLENTRY=_DllMainCRTStartup
DLLDEF=..\dpwsockx.def
NTTARGETFILE0=MISC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\wsock\winsock.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       winsock.c
 *  Content:	windows socket support for dpsp
 *  History:
 *  Date		By		Reason
 *  ====		==		======
 *	3/15/96		andyco	created it
 *	4/12/96		andyco	got rid of dpmess.h! use DPlay_ instead of message macros
 *	4/18/96		andyco	added multihomed support, started ipx
 *	4/25/96		andyco	messages now have blobs (sockaddr's) instead of dwReserveds  
 *	5/31/96		andyco	all non-system players share a socket (gsStream and 
 *						gsDGramSocket).
 *	7/18/96		andyco	added dphelp for server socket
 *	8/1/96		andyco	no retry on connect failure
 *	8/15/96		andyco	local + remote data	- killthread
 *	8/30/96		andyco	clean it up b4 you shut it down! added globaldata.
 *	9/4/96		andyco	took out bye_bye message
 *	12/18/96	andyco	de-threading - use a fixed # of prealloced threads.
 *						cruised the enum socket / thread - use the system
 *						socket / thread instead
 *	3/17/97		kipo	rewrote server dialog code to not use global variable
 *						to return the address and to return any errors getting
 *						the address, especially DPERR_USERCANCEL
 *	5/12/97		kipo	the server address string is now stored in the globals
 *						at SPInit and resolved when you do EnumSessions so we
 *						will return any errors at that time instead of popping
 *						the dialog again. Fixes bug #5866
 *	11/19/97	myronth	Changed LB_SETCURSEL to CB_SETCURSEL (#12711)
 *	01/27/98	sohaim	added firewall support.
 *  02/13/98    aarono  added async support.
 *   2/18/98   a-peterz Comment byte order for address and port params (CreateSocket)
 *   6/19/98    aarono  turned on keepalive on reliable sockets.  If we
 *                      don't do this we can hang if the send target crashes
 *                      while in a low buffer (i.e. no buffer) state.
 *    7/9/99    aarono  Cleaning up GetLastError misuse, must call right away,
 *                      before calling anything else, including DPF.
 *    1/12/99   aarono  added rsip support
 *    2/21/00   aarono  fix socket leaks
 ***************************************************************************/

#include "dpsp.h"
#if USE_RSIP
#include "rsip.h"
#elif USE_NATHELP
#include "nathelp.h"
#endif

// backlog for listen() api.  no constant in winsock, so we ask for the moon
#define LISTEN_BACKLOG 60

// how long to wait, in ms, til we abort a blocking WinSock connect() call
#define CONNECT_WATCHER_TIMEOUT		15000

/*
 ** CreateSocket
 *
 *  CALLED BY: all over
 *
 *  PARAMETERS:
 *		pgd - pointer to a global data
 *		psock - new socket. return value.
 *		type - stream or datagram
 *		port - what port we bind to (host byte order)
 *		address - what address to use (net byte order)
 *		*perr - set to the last socket error if fn fails
 *		bInRange - use reserved range of ports; we also use this to determine whether we need to try mapping it on the NAT or not
 *
 *  DESCRIPTION:
 *		creates a new socket.  binds to port specified, at the address specified
 *
 *  RETURNS: DP_OK or E_FAIL. if E_FAIL, *perr is set with socket error code (see winsock.h)
 *
 */

HRESULT FAR PASCAL CreateSocket(LPGLOBALDATA pgd,SOCKET * psock,INT type,WORD wApplicationPort,ULONG address, 
	SOCKERR * perr,BOOL bInRange)
{
	WORD wRebindPort = 0;
    SOCKET  sNew;
    SOCKADDR sockAddr;
    int bTrue = TRUE;
	int protocol = 0;
	BOOL bBroadcast = FALSE;
	WORD wPort;
	BOOL bBound = FALSE;
	UINT err;
#if USE_NATHELP
	BOOL bPortMapped=FALSE;
	BOOL ftcp_udp;
#endif

    *psock = INVALID_SOCKET; // in case we bail

    //  Create the socket.
	if (AF_IPX == pgd->AddressFamily) 
	{
		// set up protocol for ipx
		if (SOCK_STREAM == type)
		{
			protocol = NSPROTO_SPXII;
		} 
		else protocol = NSPROTO_IPX;
	}

Rebind:

   	sNew = socket( pgd->AddressFamily, type, protocol);
   	
    if (INVALID_SOCKET == sNew) 
    {
        // no cleanup needed, just bail
    	*perr = WSAGetLastError();
        return E_FAIL;
    }

	if (wRebindPort == 0)
	{
		DPF(8,"Creating new socket %d (app port = %u, bInRange = %i)",sNew,wApplicationPort,bInRange);
	}
	else
	{
		DPF(8,"Rebinding to port %u, new socket %d",wRebindPort,sNew);
	}

    //  try to bind an address to the socket.
	// set up the sockaddr
	memset(&sockAddr,0,sizeof(sockAddr));
	switch (pgd->AddressFamily)
	{
		case AF_INET:
			{
				if ((SOCK_STREAM == type))
				{
					// turn ON keepalive
					if (SOCKET_ERROR == setsockopt(sNew, SOL_SOCKET, SO_KEEPALIVE, (CHAR FAR *)&bTrue, sizeof(bTrue)))
					{
						err = WSAGetLastError();
						DPF(0,"Failed to turn ON keepalive - continue : err = %d\n",err);
					}

					ASSERT(bTrue);
					
					// turn off nagling
					if(pgd->dwSessionFlags & DPSESSION_OPTIMIZELATENCY) 
					{

						DPF(5, "Turning nagling off on socket");
						if (SOCKET_ERROR == setsockopt(sNew, IPPROTO_TCP, TCP_NODELAY, (CHAR FAR *)&bTrue, sizeof(bTrue)))
						{
							err = WSAGetLastError();
							DPF(0,"Failed to turn off nagling - continue : err = %d\n",err);
						}
					}

					// Start out preventing others from using this port (and keeping us
					// from sharing a port with another copy of DPlay).  This may fail
					// if we're not on NT, or we're not admin.  The default settings
					// will still work (and are pretty much as secure with the .NET
					// Server behavior changes).
					// The next time through we need to allow sharing in order for
					// the fastsock code to work properly.
					if (wRebindPort == 0)
					{
						SetExclusivePortAccess(sNew);
					}
					else
					{
						SetSharedPortAccess(sNew);
					}
				}

				((SOCKADDR_IN *)&sockAddr)->sin_family      = PF_INET;
				((SOCKADDR_IN *)&sockAddr)->sin_addr.s_addr = address;
				((SOCKADDR_IN *)&sockAddr)->sin_port        = (wRebindPort == 0) ? htons(wApplicationPort) : htons(wRebindPort);
				if (bInRange && !wApplicationPort && !wRebindPort)
				{
#ifdef RANDOM_PORTS
					USHORT rndoffset;
#else // ! RANDOM_PORTS
					USHORT	wInitialPort;
#endif // ! RANDOM_PORTS

			    	
					DPF(5, "Application didn't specify a port - using dplay range");

#ifdef RANDOM_PORTS
					rndoffset=(USHORT)(GetTickCount()%DPSP_NUM_PORTS); //(USHORT)(0);// make predictable!
					if (type != SOCK_STREAM)
					{
						// workaround bug in winsock using the same socket.
						rndoffset = ((rndoffset + DPSP_NUM_PORTS/2) % DPSP_NUM_PORTS);
					}
					wPort = DPSP_MIN_PORT+rndoffset;
#else // ! RANDOM_PORTS
					wInitialPort = DPSP_MIN_PORT;
					if (type != SOCK_STREAM)
					{
						// workaround bug in winsock using the same socket.
						wInitialPort = wInitialPort + (DPSP_NUM_PORTS / 2);
					}

					// minimize problem with ICS machine stealing client's NAT connection entries by
					// picking a different starting point on the ICS machine
					if (natIsICSMachine(pgd))
					{
						wInitialPort += (DPSP_NUM_PORTS / 4);
					}
					
					wPort = wInitialPort;
#endif // ! RANDOM_PORTS
					
					do
					{
#if USE_NATHELP
						HRESULT hr;

						if (pgd->pINatHelp)
						{
					        if (type == SOCK_STREAM)
					        {
					            if (pgd->hNatHelpTCP)
					            {
					            	DPF(1, "Already have registered TCP port 0x%x.", pgd->hNatHelpTCP);
					                goto pass_nat;
					            }

    					        ftcp_udp=TRUE;
					        }
					        else
					        {
					            if (pgd->hNatHelpUDP)
					            {
					            	DPF(1, "Already have registered UDP port 0x%x.", pgd->hNatHelpUDP);
					                goto pass_nat;
					            }

    					        ftcp_udp=FALSE;
					        }
					        
					        hr = natRegisterPort(pgd, ftcp_udp, wPort);
					        if (hr == DPNHERR_PORTUNAVAILABLE)
					        {
					            DPF(1,"CreateSocket: NatHelp said port %u was already in use, trying another.",
					            	wPort);
					            goto try_next_port;
					        }

					        if (hr != DP_OK)
					        {
					            DPF(1,"CreateSocket: NatHelp returned error 0x%x, port %u will not have mapping.",
					            	hr, wPort);
					        }
					        else
					        {
					            bPortMapped=TRUE;
					            DPF(1,"CreateSocket: NatHelp successfully mapped port %u.", wPort);
					        }
						}  

pass_nat:
	
#endif

						DPF(5, "Trying to bind to port %d",wPort);
						((SOCKADDR_IN *)&sockAddr)->sin_port = htons(wPort);
						// do the bind
						if( SOCKET_ERROR != bind( sNew, (LPSOCKADDR)&sockAddr, sizeof(sockAddr) ) )
						{
							bBound = TRUE;
							DPF(5, "Successfully bound to port %d", wPort);				    
						}
						else
						{
							err = WSAGetLastError();
					    	DPF(1, "Bind to specific port failed (err %u), continuing.", err);
					    
try_next_port:
	
#if USE_NATHELP
				            if (bPortMapped)
				            {
				                natDeregisterPort(pgd,ftcp_udp);
				                bPortMapped=FALSE;
				            }
#endif    
					    	if(++wPort > DPSP_MAX_PORT){
					    		wPort=DPSP_MIN_PORT;
					    	}
						}	
					}
#ifdef RANDOM_PORTS
					while (!bBound && (wPort != DPSP_MIN_PORT+rndoffset));				    
#else // ! RANDOM_PORTS
					while (!bBound && (wPort != wInitialPort));				    
#endif // ! RANDOM_PORTS
			    }	
			    else
		    	{
			    	DPF(5, "Application specified a port (%u), it doesn't need to be in dplay range (%i), or rebinding (port %u).",
			    		wApplicationPort, bInRange, wRebindPort);
		    	}
		    }
			break;
			
		case AF_IPX:
			{
			    ((SOCKADDR_IPX *)&sockAddr)->sa_family      = (SHORT)pgd->AddressFamily;
			    ((SOCKADDR_IPX *)&sockAddr)->sa_socket		= wApplicationPort;
				// nodenum?
				memset(&(((SOCKADDR_IPX *)&sockAddr)->sa_nodenum),0,6);
				
			}
			break;
			
		default:
			ASSERT(FALSE);
			break;

	} // switch

	// do the bind
    if( !bBound && (SOCKET_ERROR == bind( sNew, (LPSOCKADDR)&sockAddr, sizeof(sockAddr))) )
    {
    	// Winsock sometimes complains if you attempt to rebind too quickly.  Wait a bit, then
    	// try again a few times.
    	if (wRebindPort != 0)
    	{
    		DWORD	dwSleepTime;

    		dwSleepTime = 50;
    		do
	    	{
	    		dwSleepTime *= 2;	// 100, 200, 400, 800
	    		if (dwSleepTime >= 1000)
	    		{
	    			goto ERROR_EXIT;
	    		}

	    		err = WSAGetLastError();
				DPF(1, "Port %u reused too quickly, waiting %u ms then trying again (err = %u).",
					wRebindPort, dwSleepTime, err);
	    		Sleep(dwSleepTime);
    		}
    		while (bind( sNew, (LPSOCKADDR)&sockAddr, sizeof(sockAddr)) == SOCKET_ERROR);
    	}
    	else
    	{
	        goto ERROR_EXIT;
    	}
    }

    // if this is the first time through the loop for a AF_INET stream socket, we need to shutdown
    // and rebind using shared access.
    if ((wRebindPort == 0) && (pgd->AddressFamily == AF_INET) && (type==SOCK_STREAM))
    {
    	wRebindPort = ntohs(((SOCKADDR_IN *)&sockAddr)->sin_port);

    	// Make sure we know the port to rebind.
    	if (wRebindPort == 0)
    	{
    		int	iAddrLen;

    		iAddrLen = sizeof(sockAddr);
    		if (getsockname(sNew, &sockAddr, &iAddrLen) == SOCKET_ERROR)
    		{
	 	        goto ERROR_EXIT;
	   		}
    		
	      	wRebindPort = ntohs(((SOCKADDR_IN *)&sockAddr)->sin_port);
	      	ASSERT(wRebindPort != 0);
	  	}
    	
    	DPF(8, "Closing socket 0x%p (port %u).", sNew, wRebindPort);
    	closesocket(sNew);
    	sNew = INVALID_SOCKET;
    	bBound = FALSE;
    	goto Rebind;
    }

    // success!
    *psock = sNew;

	if(type==SOCK_STREAM){
		DEBUGPRINTSOCK(8,"created a new stream socket (bound) - ",psock);
	} else {
		DEBUGPRINTSOCK(8,"created a new datagram socket (bound) - ",psock);
	}

    return DP_OK;

ERROR_EXIT:
    // clean up and bail
    *perr = WSAGetLastError();
	DPF(0,"create socket failed- err = %d\n",*perr);
    closesocket(sNew);
#if USE_NATHELP
    if (bPortMapped)
    {
        natDeregisterPort(pgd,ftcp_udp);
        bPortMapped=FALSE;
    }
#endif    
    return E_FAIL;

}   // CreateSocket

#undef DPF_MODNAME
#define DPF_MODNAME	"KillSocket"

HRESULT KillSocket(SOCKET sSocket,BOOL fStream,BOOL fHard)
{
	UINT err;

    if (INVALID_SOCKET == sSocket) 
    {
		return E_FAIL;
    }

	if (!fStream)
    {
		DPF(8,"killsocket - closing datagram socket %d\n",
			sSocket);
		
        if (SOCKET_ERROR == closesocket(sSocket)) 
        {
	        err = WSAGetLastError();
			DPF(0,"killsocket - dgram close err = %d\n",err);
			return E_FAIL;
        }
    }
	else 
	{
		LINGER Linger;

	   	if (fHard)
		{
			// LINGER T/O=0 => Shutdown hard.
			Linger.l_onoff=TRUE; // turn linger on
			Linger.l_linger=0; // nice small time out
		}
	   	else
		{
			// NOLINGER => shutdown clean, but not hard.
			Linger.l_onoff=FALSE; // turn linger off -- SO_NOLINGER
			Linger.l_linger=0; // nice small time out
		}

	    if( SOCKET_ERROR == setsockopt( sSocket,SOL_SOCKET,SO_LINGER,(char FAR *)&Linger,
	                    sizeof(Linger) ) )
	    {
	        err = WSAGetLastError();
			DPF(0,"killsocket - stream setopt err = %d\n",err);
	    }

#if 0
		DWORD lNonBlock=0;
		err = ioctlsocket(sSocket,FIONBIO,&lNonBlock);
		if (SOCKET_ERROR == err)
		{
			err = WSAGetLastError();
			DPF(0,"could not set blocking mode on socket err = %d!",err);
		}
#endif		

#if 0
		if (SOCKET_ERROR == shutdown(sSocket,2)) 
		{
			// this may well fail, if e.g. no one is using this socket right now...
			// the error would be wsaenotconn 
	        err = WSAGetLastError();
			DPF(5,"killsocket - stream shutdown err = %d\n",err);
		}
#endif

		DPF(8,"killsocket - %s closing stream socket %d:",
			((fHard) ? "hard" : "soft"), sSocket);
		DEBUGPRINTSOCK(8,"Addr :",&sSocket);
        if (SOCKET_ERROR == closesocket(sSocket)) 
        {
	        err = WSAGetLastError();
			DPF(0,"killsocket - stream close err = %d\n",err);
			return E_FAIL;
        }
        else
        {
        	DPF(8,"killsocket - closed socket %d\n",sSocket);
        }
    }

	return DP_OK;
	
}// KillSocket

#undef DPF_MODNAME
#define DPF_MODNAME	"CreateAndInitStreamSocket"

// set up a stream socket to receive connections
// used w/ the gGlobalData.sStreamAcceptSocket
HRESULT CreateAndInitStreamSocket(LPGLOBALDATA pgd)
{
	HRESULT hr;
	UINT err;
	LINGER Linger;
	BOOL bTrue=TRUE;
	SOCKADDR_IN saddr;
	INT dwSize;

    hr = CreateSocket(pgd,&(pgd->sSystemStreamSocket),SOCK_STREAM,pgd->wApplicationPort,INADDR_ANY,&err,TRUE);
    if (FAILED(hr)) 
    {
        DPF(0,"init listen socket failed - err = %d\n",err);
        return hr ;
    }

	bTrue = SetSharedPortAccess(pgd->sSystemStreamSocket);
	if (! bTrue)
	{
		DPF(0,"Failed to to set shared mode on socket - continue\n");
	}

	// get the socket address, and keep it around for future reference.
	dwSize = sizeof(saddr);
	err=getsockname(pgd->sSystemStreamSocket, (SOCKADDR *)&saddr, &dwSize);

	if(err){
		DPF(0,"Couldn't get socket name?\n");
		DEBUG_BREAK();
	}

	pgd->SystemStreamPort = saddr.sin_port;

    // set up socket w/ max listening connections
    err = listen(pgd->sSystemStreamSocket,LISTEN_BACKLOG);
    if (SOCKET_ERROR == err) 
    {
        err = WSAGetLastError();
        DPF(0,"init listen socket / listen error - err = %d\n",err);
        return E_FAIL ;
    }

	// set for hard disconnect
	Linger.l_onoff=1;
	Linger.l_linger=0;
    
    if( SOCKET_ERROR == setsockopt( pgd->sSystemStreamSocket,SOL_SOCKET,SO_LINGER,
		(char FAR *)&Linger,sizeof(Linger) ) )
    {
        err = WSAGetLastError();
		DPF(0,"Delete service socket - stream setopt err = %d\n",err);
    }
	
	DEBUGPRINTSOCK(1,"enum - listening on",&(pgd->sSystemStreamSocket));
	return DP_OK;
	
} // CreateAndInitStreamSocket



#undef DPF_MODNAME
#define DPF_MODNAME	"SPConnect"
// connect socket to sockaddr
HRESULT SPConnect(SOCKET* psSocket, LPSOCKADDR psockaddr,UINT addrlen, BOOL bOutBoundOnly)
{
	UINT err;
	HRESULT hr = DP_OK;
	DWORD dwLastError;
	u_long lNonBlock = 1; // passed to ioctlsocket to make socket non-blocking
	u_long lBlock = 0; // passed to ioctlsocket to make socket blocking again
	fd_set fd_setConnect;
	fd_set fd_setExcept;
	TIMEVAL timevalConnect;


	DPF(6, "SPConnect: Parameters (0x%x, 0x%x, %u, %i)", psSocket, psockaddr, addrlen, bOutBoundOnly);
	

	err=ioctlsocket(*psSocket, FIONBIO, &lNonBlock);	// make socket non-blocking
	if(SOCKET_ERROR == err){
		dwLastError=WSAGetLastError();
		DPF(0,"sp - failed to set socket %d to non-blocking mode err= %d\n", *psSocket, dwLastError);
		return DPERR_CONNECTIONLOST;
	}


	DEBUGPRINTADDR(4, "Connecting socket:", psockaddr);

	// Start the socket connecting.
    err = connect(*psSocket,psockaddr,addrlen);
    
	if(SOCKET_ERROR == err) {
		dwLastError=WSAGetLastError();
		if(dwLastError != WSAEWOULDBLOCK){
			DPF(0,"sp - connect failed err= %d\n", dwLastError);
			hr = DPERR_CONNECTIONLOST;
			goto err_exit;
		}
		// we are going to wait for either the connect to succeed (socket to be writeable)
		// or the connect to fail (except fdset bit to be set).  So we init an FDSET with
		// the socket that is connecting and wait.
		FD_ZERO(&fd_setConnect);
		FD_SET(*psSocket, &fd_setConnect);

		FD_ZERO(&fd_setExcept);
		FD_SET(*psSocket, &fd_setExcept);

		timevalConnect.tv_sec=0;
		timevalConnect.tv_usec=CONNECT_WATCHER_TIMEOUT*1000; //msec -> usec
		
		err = select(0, NULL, &fd_setConnect, &fd_setExcept, &timevalConnect);

		// err is the number of sockets with activity or 0 for timeout 
		// or SOCKET_ERROR for error
		
		if(SOCKET_ERROR == err) {
			dwLastError=WSAGetLastError();
			DPF(0,"sp - connect failed err= %d\n", dwLastError);
			hr = DPERR_CONNECTIONLOST;
			goto err_exit;
		} else if (0==err){
			// timed out
			DPF(0,"Connect timed out on socket %d\n",*psSocket);
			hr = DPERR_CONNECTIONLOST;
			goto err_exit;
		}

		// Now see if the connect succeeded or the connect got an exception
		if(!(FD_ISSET(*psSocket, &fd_setConnect))){
			#ifdef DEBUG
				DWORD optval=0;
				DWORD optlen=sizeof(optval);
				DPF(0,"Connect did not succeed on socket %d\n",*psSocket);
				if(FD_ISSET(*psSocket,&fd_setExcept)){
					DPF(0,"FD Except Set IS Set (expected)\n");
				} else {
					DPF(0,"FD Except Set IS NOT SET (unexpected)\n");
				}
				err=getsockopt(*psSocket, SOL_SOCKET, SO_ERROR, (char *)&optval, &optlen);
				DPF(0,"Socket error %x\n",optval);
			#endif
			return DPERR_CONNECTIONLOST;
		}

		if(FD_ISSET(*psSocket,&fd_setExcept)){
			DPF(0,"Got exception on socket %d during connect\n",*psSocket);
			hr = DPERR_CONNECTIONLOST;
			goto err_exit;
		}
	}

	err=ioctlsocket(*psSocket, FIONBIO, &lBlock);	// make socket blocking again

	DEBUGPRINTSOCK(8,"successfully connected socket - ", psSocket);

	if (bOutBoundOnly)
	{
		DEBUGPRINTADDR(5, "Sending reuse connection message to - ",psockaddr);
		// tell receiver to reuse connection
		hr = SendReuseConnectionMessage(*psSocket);
	}
	
	DPF(6, "SPConnect: Return: [0x%lx]", hr);

	return hr;

err_exit:
	err=ioctlsocket(*psSocket, FIONBIO, &lBlock);	// make socket blocking again
	
	DPF(6, "SPConnect: Return (err exit): [0x%lx]", hr);
	
	return hr;

} //SPConnect
    

#undef DPF_MODNAME
#define DPF_MODNAME	"SetPlayerAddress"
// we've created a socket for a player. store its address in the players
// spplayerdata struct.  
HRESULT SetPlayerAddress(LPGLOBALDATA pgd,LPSPPLAYERDATA ppd,SOCKET sSocket,BOOL fStream) 
{
	SOCKADDR sockaddr;
	UINT err;
	int iAddrLen = sizeof(SOCKADDR);

    err = getsockname(sSocket,&sockaddr,&iAddrLen);
    if (SOCKET_ERROR == err) 
    {
        err = WSAGetLastError();
        DPF(0,"setplayeraddress - getsockname - err = %d\n",err);
        DPF(0,"closing socket %d\n",sSocket);
        closesocket(sSocket);
		return E_FAIL;
    } 

	if (fStream) 
	{
		switch (pgd->AddressFamily)
		{
			case AF_INET:
				DEBUGPRINTADDR(7, "Setting player AF_INET stream socket address:", &sockaddr);
				
				STREAM_PSOCKADDR(ppd)->sa_family = AF_INET;
				IP_STREAM_PORT(ppd) = ((SOCKADDR_IN * )&sockaddr)->sin_port;
				// we don't know the address of the local player (multihomed!)
				IP_STREAM_ADDR(ppd) = 0; 
				break;

			case AF_IPX:
			{
				SOCKADDR_IPX * pipx = (SOCKADDR_IPX * )STREAM_PSOCKADDR(ppd);
				
				pipx->sa_family = AF_IPX;
				pipx->sa_socket = ((SOCKADDR_IPX*)&sockaddr)->sa_socket;
				memset(pipx->sa_nodenum,0,6);
				break;

			}

			default:
				ASSERT(FALSE);
		}
	} // stream
	else 
	{
		switch (pgd->AddressFamily)
		{
			case AF_INET:
				DEBUGPRINTADDR(7, "Setting player AF_INET datagram socket address:", &sockaddr);
				
				DGRAM_PSOCKADDR(ppd)->sa_family = AF_INET;
				IP_DGRAM_PORT(ppd) = ((SOCKADDR_IN *)&sockaddr)->sin_port;
				// we don't know the address of the local player (multihomed!)
				IP_DGRAM_ADDR(ppd) = 0; 
				break;

			case AF_IPX:
			{
				SOCKADDR_IPX * pipx = (SOCKADDR_IPX * )DGRAM_PSOCKADDR(ppd);
				
				pipx->sa_family = AF_IPX;
				pipx->sa_socket = ((SOCKADDR_IPX*)&sockaddr)->sa_socket;
				memset(pipx->sa_nodenum,0,6);
				break;

			}

			default:
				ASSERT(FALSE);
		}

	} // dgram

	return DP_OK;	
} // SetPlayerAddress

#undef DPF_MODNAME
#define DPF_MODNAME	"GetIPXNameServerSocket"

// called by CreatePlayerDgramSocket
// bind to our well known port for ipx
HRESULT GetIPXNameServerSocket(LPGLOBALDATA pgd)
{
	BOOL bTrue = TRUE;
	SOCKET sSocket;
	HRESULT hr;
	UINT err;
	
	// if there already was a receive thread, we need to kill
	// the socket, and remember the thread, so at shutdown we
	// can make sure it's gone.  note - we can't wait for it to 
	// leave now, since dplay hasn't dropped its locks, and
	// the thread may be blocked on dplay
	if (pgd->hDGramReceiveThread)
	{
		// it's ipx, and we're deleting the system player
		// we need to get rid of the system sockets, so that if we recreate as 
		// nameserver we can bind to a specific port...
		// ipx only uses datagram, so we only stop those...kill the socket
		ASSERT(INVALID_SOCKET != pgd->sSystemDGramSocket);
		KillSocket(pgd->sSystemDGramSocket,FALSE,TRUE);
		pgd->sSystemDGramSocket = INVALID_SOCKET;
		
		// remember the old thread - we'll need to make sure it's gone when we 
		// shut down
		pgd->hIPXSpareThread = pgd->hDGramReceiveThread;
		pgd->hDGramReceiveThread = NULL;
	}
	
    DPF(2,"ipx - creating name server dgram socket\n");
	
	// use name server port
    hr = CreateSocket(pgd,&sSocket,SOCK_DGRAM,SERVER_DGRAM_PORT,INADDR_ANY,&err,FALSE);
	if (FAILED(hr))
	{
		DPF(0,"IPX - DPLAY SERVER SOCKET IS ALREADY IN USE.  PLEASE SHUTDOWN ANY");
		DPF(0,"OTHER NETWORK APPLICATIONS AND TRY AGAIN");
		// boned!
		return DPERR_CANNOTCREATESERVER;
	}

    if( SOCKET_ERROR == setsockopt( sSocket,SOL_SOCKET,SO_BROADCAST,(char FAR *)&bTrue,
                sizeof(bTrue) ) )
    {
        err = WSAGetLastError();
		DPF(0,"create - could not set broadcast err = %d\n",err);
		// keep trying
    }

	DEBUGPRINTSOCK(2,"name server dgram socket (bound) - ",&sSocket);
	
	pgd->sSystemDGramSocket = sSocket;
	
	return DP_OK;

} // GetIPXNameServerSocket

HRESULT CreatePlayerDgramSocket(LPGLOBALDATA pgd,LPSPPLAYERDATA ppd,DWORD dwFlags)
{
	HRESULT hr=DP_OK;
	UINT err;
	SOCKET sSocket;
	
    if ( (AF_IPX == pgd->AddressFamily) && (dwFlags & DPLAYI_PLAYER_NAMESRVR))
    {
		//
		// AF_INET uses ddhelp to bind the nameserver to a specific port 
		// (SERVER_DGRAM_PORT).  AF_IPX binds to that port here.
		hr = GetIPXNameServerSocket(pgd);
		if (FAILED(hr))
		{
			return hr;
		}
		// store this for setting player address below
		sSocket = pgd->sSystemDGramSocket;
    } 
	else if (dwFlags & DPLAYI_PLAYER_SYSPLAYER) 
    {
		if (INVALID_SOCKET == pgd->sSystemDGramSocket)
		{

			hr = CreateSocket(pgd,&sSocket,SOCK_DGRAM,pgd->wApplicationPort,INADDR_ANY,&err,TRUE);
		    if (FAILED(hr)) 
		    {
		    	DPF(0,"create sysplayer dgram socket failed - err = %d\n",err);
				return hr;
		    }
				
			#ifdef DEBUG
		    if (dwFlags & DPLAYI_PLAYER_NAMESRVR) 
		    {
		    	DEBUGPRINTSOCK(2,"name server dgram socket - ",&sSocket);
		    }
			#endif // DEBUG
			
			pgd->sSystemDGramSocket = sSocket;
		}
		else 
		{
			// store this for setting player address below
			sSocket = pgd->sSystemDGramSocket;	
		}
    }
	else 
	{
	
		ASSERT(INVALID_SOCKET != pgd->sSystemDGramSocket);
		sSocket = pgd->sSystemDGramSocket;	
	}

	// store the ip + port w/ the player...    
	hr = SetPlayerAddress(pgd,ppd,sSocket,FALSE);

	
	return hr; 
}  // CreatePlayerDgramSocket

HRESULT CreatePlayerStreamSocket(LPGLOBALDATA pgd,LPSPPLAYERDATA ppd,DWORD dwFlags) 
{
	SOCKET sSocket;
	HRESULT hr=DP_OK;
	UINT err;
	BOOL bListen = TRUE; // set if we created socket, + need to set it's listen
	BOOL bTrue = TRUE;
	DWORD dwSize;
	SOCKADDR_IN saddr;
	
	if (dwFlags & DPLAYI_PLAYER_SYSPLAYER) 
    {
		if (INVALID_SOCKET == pgd->sSystemStreamSocket)
		{
	    	hr = CreateSocket(pgd,&sSocket,SOCK_STREAM,pgd->wApplicationPort,INADDR_ANY,&err,TRUE);
		    if (FAILED(hr)) 
		    {
		    	DPF(0,"create player stream socket failed - err = %d\n",err);
				return hr;
		    }
			
			#ifdef DEBUG
		    if (dwFlags & DPLAYI_PLAYER_NAMESRVR) 
		    {
		    	DEBUGPRINTSOCK(2,"name server stream socket - ",&sSocket);
		    }
			#endif // DEBUG

			
			bTrue = SetSharedPortAccess(sSocket);
			if (! bTrue)
			{
				DPF(0,"Failed to to set shared mode on socket - continue\n");
			}
			
			pgd->sSystemStreamSocket = sSocket;

			// get the socket address, and keep it around for future reference.
			dwSize = sizeof(saddr);
			err=getsockname(pgd->sSystemStreamSocket, (SOCKADDR *)&saddr, &dwSize);

			if(err){
				DPF(0,"Couldn't get socket name?\n");
				DEBUG_BREAK();
			}
			pgd->SystemStreamPort = saddr.sin_port;
		}
		else
		{
			sSocket = pgd->sSystemStreamSocket;	
			bListen = FALSE;
		}
    		
    }
	else 
	{
		ASSERT (INVALID_SOCKET != pgd->sSystemStreamSocket);
		sSocket = pgd->sSystemStreamSocket;	
		bListen = FALSE;			
	}
	
	if (bListen)
	{
		// set up socket to receive connections
	    err = listen(sSocket,LISTEN_BACKLOG);
		if (SOCKET_ERROR == err) 
		{
			err = WSAGetLastError();
			ASSERT(FALSE);
		    DPF(0,"ACK! stream socket listen failed - err = %d\n",err);
			// keep trying
		}
	}
	
	hr = SetPlayerAddress(pgd,ppd,sSocket,TRUE);
	return hr;

} // CreatePlayerStreamSocket


#undef DPF_MODNAME
#define DPF_MODNAME	"PokeAddr"


// poke an ip addr into a message blob
void IP_SetAddr(LPVOID pmsg,SOCKADDR_IN * paddrSrc)
{
	LPSOCKADDR_IN  paddrDest; // tempo variable, makes casting less ugly
	LPMESSAGEHEADER phead;

	phead = (LPMESSAGEHEADER)pmsg;
	// todo - validate header

	// leave the port intact, copy over the ip addr
	paddrDest = (SOCKADDR_IN *)&(phead->sockaddr);
	// poke the new ip addr into the message header
	// only rehome addresses that aren't already homed.
	if(paddrDest->sin_addr.s_addr == 0){
		paddrDest->sin_addr.s_addr = paddrSrc->sin_addr.s_addr;
	}	

	return;
	
} // IP_SetAddr

// get an ip addr from a message blob
void IP_GetAddr(SOCKADDR_IN * paddrDest,SOCKADDR_IN * paddrSrc) 
{
	// leave the port intact, copy over the nodenum
	if (0 == paddrDest->sin_addr.s_addr)
	{
		DPF(2,"remote player - setting address!! =  %s\n",inet_ntoa(paddrSrc->sin_addr));
		paddrDest->sin_addr.s_addr = paddrSrc->sin_addr.s_addr;
	}

	return;
		
} // IP_GetAddr

// poke the ipx nodenumber / a message
void IPX_SetNodenum(LPVOID pmsg,SOCKADDR_IPX * paddrSrc)
{
	LPSOCKADDR_IPX  paddrDest;	 // tempo variable, makes casting less ugly
	LPMESSAGEHEADER phead; 

	phead = (LPMESSAGEHEADER)pmsg;
	// todo - validate header
	
	// leave the port intact, copy over the nodenum
	paddrDest = (SOCKADDR_IPX *)&(phead->sockaddr);
	memcpy(paddrDest->sa_nodenum,paddrSrc->sa_nodenum,6);
	memcpy(paddrDest->sa_netnum,paddrSrc->sa_netnum,4);

	return;

}  // IPX_SetNodenum
							   
// reconstruct the nodenum from the msg
void IPX_GetNodenum(SOCKADDR_IPX * paddrDest,SOCKADDR_IPX * paddrSrc) 
{
	char sa_nodenum_zero[6];

	memset(sa_nodenum_zero,0,6);

	// if the nodenum is zero, set it
	if (0 == memcmp(paddrDest->sa_nodenum,sa_nodenum_zero,6))
	{
			DEBUGPRINTADDR(4,"IPX - setting remote player address",(SOCKADDR *)paddrSrc);
			// leave the port intact, copy over the nodenum
			memcpy(paddrDest->sa_nodenum,paddrSrc->sa_nodenum,6);
			memcpy(paddrDest->sa_netnum,paddrSrc->sa_netnum,4);
	}
	return;
} // IPX_GetNodenum

// store the port of the socket w/ the message, so the receiving end
// can reconstruct the address to reply to
//  psaddr will override the address if present
HRESULT SetReturnAddress(LPVOID pmsg,SOCKET sSocket, LPSOCKADDR psaddrPublic) 
{
	#define psaddr_inPublic ((LPSOCKADDR_IN)psaddrPublic)

    SOCKADDR sockaddr;
    INT addrlen=sizeof(SOCKADDR);
	LPMESSAGEHEADER phead;
	UINT err;

	// Note: extra test for 0 IP address may be extraneous (but certainly won't hurt).
	if(psaddrPublic && psaddr_inPublic->sin_addr.s_addr ){

		// We are behind an RSIP gateway, so put the public address in the header
	
		phead = (LPMESSAGEHEADER)pmsg;
		phead->sockaddr = *psaddrPublic;

		DEBUGPRINTADDR(8,"setting return address (using rsip public address) = ",&phead->sockaddr);
		
	} else {
		// find out what port gGlobalData.sEnumSocket is on
		DPF(8,"==>GetSockName\n");
	    err = getsockname(sSocket,(LPSOCKADDR)&sockaddr,&addrlen);
		DPF(8,"<==GetSockName\n");
		if (SOCKET_ERROR == err)
		{
			err = WSAGetLastError();
			DPF(0,"could not get socket name - err = %d\n",err);
			return DP_OK;
		}

		DEBUGPRINTADDR(8,"setting return address = ",&sockaddr);

		phead = (LPMESSAGEHEADER)pmsg;
		// todo - validate header

		phead->sockaddr = sockaddr;
	}
	
	return DP_OK;

	#undef psaddr_inPublic

} // SetReturnAddress

// code below all called by GetServerAddress. For IP, prompts user for ip address 
// for name server.
#undef DPF_MODNAME
#define DPF_MODNAME	"GetAddress"
// get the ip address from the pBuffer passed in by a user
// can either be a real ip, or a hostname
// called after the user fills out our dialog box
HRESULT GetAddress(ULONG * puAddress,char *pBuffer,int cch)
{
	UINT uiAddr;
	UINT err;
	PHOSTENT phostent;
	IN_ADDR hostaddr;

	if ( (0 == cch)  || (!pBuffer) || (0 == strlen(pBuffer)) )
	{
		*puAddress = INADDR_BROADCAST;
		return (DP_OK);
	} 
	
	// try inet_addr first
	uiAddr = inet_addr(pBuffer);

	if(0 == uiAddr)	// fix bug where "" buffer passed in.
	{
		*puAddress = INADDR_BROADCAST;
		return (DP_OK);
	}
	
	if (INADDR_NONE != uiAddr) 
	{
		// found it
		*puAddress = uiAddr;
		return (DP_OK);
	}
	
	// try hostbyname
	phostent = gethostbyname(pBuffer);
	if (NULL == phostent ) 
	{
		err = WSAGetLastError();
		DPF(0,"could not get host address - err = %d\n",err);
		return (DPERR_INVALIDPARAM);
	}
	memcpy(&hostaddr,phostent->h_addr,sizeof(hostaddr));
	DPF(1,"name server address = %s \n",inet_ntoa(hostaddr));
	*puAddress = hostaddr.s_addr;

	return (DP_OK);
} // GetAddress

// put up a dialog asking for a network address
// call get address to convert user specified address to network usable address
// called by GetServerAddress
INT_PTR CALLBACK DlgServer(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
	HWND hWndCtl;
    char pBuffer[ADDR_BUFFER_SIZE];
	UINT cch;
	ULONG *lpuEnumAddress;
	HRESULT hr;

    switch (msg)
    {
    case WM_INITDIALOG:
		// set focus on edit box
        hWndCtl = GetDlgItem(hDlg, IDC_EDIT1);
        if (hWndCtl == NULL)
        {
            EndDialog(hDlg, FALSE);
            return(TRUE);
        }
        SetFocus(hWndCtl);
        SendMessage(hWndCtl, CB_SETCURSEL, 0, 0);

		// save pointer to enum address with the window
		SetWindowLongPtr(hDlg, DWLP_USER, (LONG) lParam);
        return(FALSE);


    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
		case IDOK:
			// get text entered in control
			cch = GetDlgItemText(hDlg, IDC_EDIT1, pBuffer, ADDR_BUFFER_SIZE);

			// get pointer to return address in
			lpuEnumAddress = (ULONG *) GetWindowLongPtr(hDlg, DWLP_USER);

			// convert string to enum address
            hr = GetAddress(lpuEnumAddress,pBuffer,cch);
			if (FAILED(hr))
				EndDialog(hDlg, hr);
			else
				EndDialog(hDlg, TRUE);
            return(TRUE);

		case IDCANCEL:
	        EndDialog(hDlg, FALSE);
	        return(TRUE);
		}
		break;
    }
    return (FALSE);
} // DlgServer

/*
 ** GetServerAddress
 *
 *  CALLED BY: EnumSessions
 *
 *  DESCRIPTION: launches the select network address dialog
 *
 *  RETURNS:  ip address (sockaddr.sin_addr.s_addr)
 *
 */
HRESULT ServerDialog(ULONG *lpuEnumAddress)
{
	HWND hwnd;
	INT_PTR	iResult;
	HRESULT hr;
	
	// we have a valid enum address
	if (*lpuEnumAddress)
		return (DP_OK);

	// use the fg window as our parent, since a ddraw app may be full screen
	// exclusive
	hwnd = GetForegroundWindow();

	iResult = DialogBoxParam(ghInstance, MAKEINTRESOURCE(IDD_SELECTSERVER), hwnd,
							 DlgServer, (LPARAM) lpuEnumAddress);
	if (iResult == -1)
	{
		DPF_ERR("GetServerAddress - dialog failed");
		hr = DPERR_GENERIC;
	}
	else if (iResult < 0)
	{
		DPF(0, "GetServerAddress - dialog failed: %08X", iResult);
		hr = (HRESULT) iResult;
	}
	else if (iResult == 0)
    {
		hr = DPERR_USERCANCEL;
    }
	else
	{
		hr = DP_OK;
	}
		
	return (hr);
	
} //ServerDialog 

// called by enumsessions - find out where server is...
HRESULT GetServerAddress(LPGLOBALDATA pgd,LPSOCKADDR psockaddr) 
{
	HRESULT hr;

	if (AF_IPX == pgd->AddressFamily)
	{
		((LPSOCKADDR_IPX)psockaddr)->sa_family      = AF_IPX;
	    ((LPSOCKADDR_IPX)psockaddr)->sa_socket 		= SERVER_DGRAM_PORT;
		memset(&(((LPSOCKADDR_IPX)psockaddr)->sa_nodenum),0xff,sizeof(((LPSOCKADDR_IPX)psockaddr)->sa_nodenum));
	
		hr = DP_OK;	
	}
	else
	{
		if (pgd->bHaveServerAddress)
		{
			// use enum address passed to SPInit
            hr = GetAddress(&pgd->uEnumAddress,pgd->szServerAddress,strlen(pgd->szServerAddress));
		}
		else
		{
			// ask user for enum address
			hr = ServerDialog(&pgd->uEnumAddress);
		}

		if (SUCCEEDED(hr))
		{
			// setup winsock to enum this address
			((LPSOCKADDR_IN)psockaddr)->sin_family      = AF_INET;
			((LPSOCKADDR_IN)psockaddr)->sin_addr.s_addr = pgd->uEnumAddress;		
			// see byte-order comment in dpsp.h for this constant
			((LPSOCKADDR_IN)psockaddr)->sin_port 		= SERVER_DGRAM_PORT;

			#if USE_RSIP
				#define IP_SOCKADDR(a) (((SOCKADDR_IN *)(&a))->sin_addr.s_addr)
				// Make sure the address we are enumming doesn't have a local alias.
				// If it does, use the local alias instead of the public address.
	            if(pgd->sRsip!=INVALID_SOCKET && 
	            	pgd->uEnumAddress != INADDR_BROADCAST && 
	            	pgd->uEnumAddress != INADDR_LOOPBACK){
	            	
	            	SOCKADDR saddr;

	            	hr=rsipQueryLocalAddress(pgd, FALSE, psockaddr, &saddr);
	            	if(hr==DP_OK){
	            		// If there is an alias, go broadcast.  This works just as well
	            		// and avoids problems where more than 1 mapped shared
	            		// UDP port is allocated.

		        		DEBUGPRINTADDR(7, "Enum Socket is ",psockaddr);
		        		DEBUGPRINTADDR(7, "Got Local Alias for Enum socket ",&saddr);

       					IP_SOCKADDR(*psockaddr)=0xFFFFFFFF;
#if 0
		        		if(IP_SOCKADDR(saddr)==IP_SOCKADDR(*psockaddr))
		        		{
		        			DPF(7, "Alias had same IP as queried, assuming local ICS, so using broadcast enum\n");
        					IP_SOCKADDR(*psockaddr)=0xFFFFFFFF;
        				} else {
		            		memcpy(psockaddr, &saddr, sizeof(SOCKADDR));
		            	}	
 #endif       				
	            	}else{
	            		DEBUGPRINTADDR(7,"No local alias for Enum socket ",psockaddr);
	            		hr = DP_OK;
	            	}
	            	
	            }
	            #undef IP_SOCKADDR
	        #elif USE_NATHELP
				#define IP_SOCKADDR(a) (((SOCKADDR_IN *)(&a))->sin_addr.s_addr)
				// Make sure the address we are enumming doesn't have a local alias.
				// If it does, use the local alias instead of the public address.
	            if(pgd->pINatHelp && 
	            	pgd->uEnumAddress != INADDR_BROADCAST && 
	            	pgd->uEnumAddress != INADDR_LOOPBACK){
	            	
	            	SOCKADDR saddr;
	            	
	            	hr=IDirectPlayNATHelp_QueryAddress(
	            		pgd->pINatHelp, 
						&pgd->INADDRANY, 
						psockaddr, 
						&saddr, 
						sizeof(SOCKADDR_IN), 
						DPNHQUERYADDRESS_CACHENOTFOUND
						);

	            	if(hr==DP_OK){
	            		// If there is an alias, go broadcast.  This works just as well
	            		// and avoids problems where more than 1 mapped shared
	            		// UDP port is allocated.
	            		
		        		DEBUGPRINTADDR(7, "Enum Socket is ",psockaddr);
		        		DEBUGPRINTADDR(7, "Got Local Alias for Enum socket ",&saddr);
		        		
       					IP_SOCKADDR(*psockaddr)=0xFFFFFFFF;
	            	}else{
	            		DEBUGPRINTADDR(7,"No local alias for Enum socket ",psockaddr);
	            		hr = DP_OK;
	            	}
	            	
	            }
	            #undef IP_SOCKADDR
	        #endif
		}
		else
		{
			DPF(0, "Invalid server address: 0x%08lx", hr); 
		}
	}	

	return (hr);
} // GetServerAddress
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\wsock\wsock2.c ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       wsock2.c
 *  Content:	DirectPlay Winsock 2 SP support.  Called from dpsp.c.
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	7/11//97	andyco	created it
 *  2/13/98     aarono  added async support.
 *  4/6/98      aarono  mapped WSAECONNRESET to DPERR_CONNECTIONLOST
 *  6/6/98      aarono  B#27187 fix ref counting on send blocks in sync error case
 *  7/9/99      aarono  Cleaning up GetLastError misuse, must call right away,
 *                      before calling anything else, including DPF.
 *  1/12/2000   aarono  added rsip support
 *  2/21/2000   aarono  fix socket leaks
 **************************************************************************/

// this module is for async connections and sends
// only used w/ TCP:IP - IPX is dgram only, so we don't bother...
// currently only used as the reply thread proc for async replies. see dpsp.c::sp_reply

#define INCL_WINSOCK_API_TYPEDEFS 1 // includes winsock 2 fn proto's, for getprocaddress
#include <winsock2.h>
#include "dpsp.h"
#if USE_RSIP
#include "rsip.h"
#elif USE_NATHELP
#include "nathelp.h"
#endif
#include "mmsystem.h"

#undef DPF_MODNAME
#define DPF_MODNAME	"AsyncSendThreadProc"

extern HINSTANCE hWS2; 	// dynaload the ws2_32.dll, so if it's not installed
						// (e.g. win 95 gold) we still load

// prototypes for our dynaload fn's						

LPFN_WSAWAITFORMULTIPLEEVENTS g_WSAWaitForMultipleEvents;
LPFN_WSASEND g_WSASend;
LPFN_WSASENDTO g_WSASendTo;
LPFN_WSACLOSEEVENT g_WSACloseEvent;
LPFN_WSACREATEEVENT g_WSACreateEvent;
LPFN_WSAENUMNETWORKEVENTS g_WSAEnumNetworkEvents;
LPFN_WSAEVENTSELECT g_WSAEventSelect;
LPFN_GETSOCKOPT g_getsockopt;

// attempt to load the winsock 2 dll, and get our proc addresses from it
HRESULT InitWinsock2()
{
	// load winsock library
    hWS2 = LoadLibrary("ws2_32.dll");
	if (!hWS2)
	{
		DPF(0,"Could not load ws2_32.dll\n");
		// reset our winsock 2 global
		goto LOADLIBRARYFAILED;
	}

	// get pointers to the entry points we need
	g_WSAWaitForMultipleEvents = (LPFN_WSAWAITFORMULTIPLEEVENTS)GetProcAddress(hWS2, "WSAWaitForMultipleEvents");
	if(!g_WSAWaitForMultipleEvents) goto GETPROCADDRESSFAILED;

	g_WSASend = (LPFN_WSASEND)GetProcAddress(hWS2, "WSASend");
	if (!g_WSASend) goto GETPROCADDRESSFAILED;

	g_WSASendTo = (LPFN_WSASENDTO)GetProcAddress(hWS2, "WSASendTo");
	if (!g_WSASendTo) goto GETPROCADDRESSFAILED;

    g_WSAEventSelect = ( LPFN_WSAEVENTSELECT )GetProcAddress(hWS2, "WSAEventSelect");
	if (!g_WSAEventSelect) goto GETPROCADDRESSFAILED;

	g_WSAEnumNetworkEvents = (LPFN_WSAENUMNETWORKEVENTS)GetProcAddress(hWS2, "WSAEnumNetworkEvents");
	if (!g_WSAEnumNetworkEvents) goto GETPROCADDRESSFAILED;

	g_WSACreateEvent = (LPFN_WSACREATEEVENT)GetProcAddress(hWS2, "WSACreateEvent");
	if (!g_WSACreateEvent) goto GETPROCADDRESSFAILED;

	g_WSACloseEvent = (LPFN_WSACLOSEEVENT)GetProcAddress(hWS2, "WSACloseEvent");
	if (!g_WSACloseEvent) goto GETPROCADDRESSFAILED;

	g_getsockopt = (LPFN_GETSOCKOPT)GetProcAddress(hWS2, "getsockopt");
	if (!g_getsockopt) goto GETPROCADDRESSFAILED;

	return DP_OK;	

GETPROCADDRESSFAILED:

	DPF(0,"Could not find required Winsock entry point");
	FreeLibrary(hWS2);
	hWS2 = NULL;
	// fall through
	
LOADLIBRARYFAILED:

	g_WSAEventSelect = NULL;
	g_WSAEnumNetworkEvents = NULL;
	g_WSACreateEvent = NULL;
	g_WSACloseEvent = NULL;

	return DPERR_UNAVAILABLE;
	
} // InitWinsock2

// remove the reply node from the list
void DeleteReplyNode(LPGLOBALDATA pgd,LPREPLYLIST prd, BOOL bKillSocket)
{	
	LPREPLYLIST prdPrev;
	
	ENTER_DPSP();

	// 1st, remove prd from the list
	
	// is it the root?
	if (prd == pgd->pReplyList) pgd->pReplyList = pgd->pReplyList->pNextReply;
	else
	{
		BOOL bFound = FALSE;
		
		// it's not the root - take it out of the middle
		prdPrev = pgd->pReplyList;
		while (prdPrev && !bFound)
		{
			if (prdPrev->pNextReply == prd)
			{
				prdPrev->pNextReply = prd->pNextReply;
				bFound = TRUE;
			}
			else
			{
				prdPrev = prdPrev->pNextReply;
			}
		} // while
		
		ASSERT(bFound);
		
	} // not the root

	// now clean up prd
	
	// nuke the socket
	if (bKillSocket)
		KillSocket(prd->sSocket,TRUE,FALSE);
	
	// free up the node
	if (prd->lpMessage) SP_MemFree(prd->lpMessage);
	SP_MemFree(prd);
	
	LEAVE_DPSP();
	
	return ;

} // DeleteReplyNode

VOID MoveReplyNodeToCloseList(LPGLOBALDATA pgd,LPREPLYLIST prd)
{
	LPREPLYLIST pPrev, pNode;

	DPF(8,"==>MoveReplyToCloseList prd %x\n",prd);

	pNode=pgd->pReplyList;
	pPrev=CONTAINING_RECORD(&pgd->pReplyList, REPLYLIST, pNextReply);

	while(pNode){
		if(prd==pNode){
			pPrev->pNextReply = pNode->pNextReply;
			pNode->pNextReply = pgd->pReplyCloseList;
			pgd->pReplyCloseList = pNode;
			pNode->tSent=timeGetTime();
			break;
		}

		pPrev=pNode;
		pNode=pNode->pNextReply;
	}
	DPF(8,"<==MoveReplyToCloseList prd %x\n",prd);
}

/*
 **  AsyncConnectAndSend
 *
 *  CALLED BY: AsyncSendThreadProc
 *
 *  DESCRIPTION:
 *			
 *			if necessary, creates a non-blocking socket, and initiates a connection
 *				to address specified in prd
 *			once connection has been completed, does a synchronous (blocking) send and
 *				removes prd from the global list
 */
HRESULT AsyncConnectAndSend(LPGLOBALDATA pgd,LPREPLYLIST prd)
{
	UINT err;
	HRESULT hr;
	UINT addrlen = sizeof(SOCKADDR);	
	BOOL bConnectionExists = FALSE;
	BOOL bKillConnection = TRUE;

	if (INVALID_SOCKET == prd->sSocket)
	{
		u_long lNonBlock = 1; // passed to ioctlsocket to make socket non-blocking
		DPID dpidPlayer=0;
		
#ifdef FULLDUPLEX_SUPPORT	
		// if client wants us to reuse a connection, it would have indicated so and the connection
		// would have been added to our send list by now. See if it exists.
		
		// TODO - we don't want to search the list everytime -  find a better way
		bConnectionExists = FindSocketInBag(pgd, &prd->sockaddr, &prd->sSocket, &dpidPlayer);
#endif // FULLDUPLEX_SUPPORT

		if (!bConnectionExists)
		{
			SOCKET sSocket;	

			// socket didn't exist in our send list, let's send it on a new temporary connection
			DEBUGPRINTADDR(4, "Sending async reply on a new connection to - ", &(prd->sockaddr));				
			
			// need to get the new socket
			hr = CreateSocket(pgd,&sSocket,SOCK_STREAM,0,INADDR_ANY,&err,FALSE);
			if (FAILED(hr))
			{
				DPF(0,"create async socket failed - err = %d\n",err);
				return hr;
			}
			
			prd->sSocket = sSocket;
			
			// set socket to non-blocking
			err = ioctlsocket(prd->sSocket,FIONBIO,&lNonBlock);
			if (SOCKET_ERROR == err)
			{
				err = WSAGetLastError();
				DPF(0,"could not set non-blocking mode on socket err = %d!",err);
				DPF(0,"will revert to synchronous behavior.  bummer");
			}

			err=g_WSAEventSelect(prd->sSocket, pgd->hSelectEvent, FD_WRITE|FD_CONNECT|FD_CLOSE);
			if (SOCKET_ERROR == err)
			{
				err = WSAGetLastError();
				DPF(0,"could not do event select on socket err = %d!",err);
				DPF(0,"giving up on send..\n");
				goto CLEANUP_EXIT;
			}
			// now, start the connect
			SetReturnAddress(prd->lpMessage,pgd->sSystemStreamSocket,SERVICE_SADDR_PUBLIC(pgd));		


			err = connect(prd->sSocket,&prd->sockaddr,addrlen);
			if (SOCKET_ERROR == err)
			{
				err = WSAGetLastError();
				if (WSAEWOULDBLOCK == err)
				{
					// this is expected. the operation needs time to complete.
					// select will tell us when the socket is good to go.
					return DP_OK;
				}
				// else it's a real error!
				DPF(0,"async reply - connect failed - error = %d\n",err);			
				DEBUGPRINTADDR(0,"async reply - connect failed - addr = ",(LPSOCKADDR)&(prd->sockaddr));
				goto CLEANUP_EXIT;
			}
		}
		else
		{
			// we found our connection, let's reuse it
			// set it to non-blocking
			
			DEBUGPRINTADDR(6, "Sending async reply on an existing connection to - ", &(prd->sockaddr));				

			err = ioctlsocket(prd->sSocket,FIONBIO,&lNonBlock);
			if (SOCKET_ERROR == err)
			{
				err = WSAGetLastError();
				DPF(0,"could not set non-blocking mode on socket err = %d!",err);
				DPF(0,"will revert to synchronous behavior.  bummer");
			}

			// once we have a player id, the session has started. let's hold on to the connection
			// we have and reuse it for the rest of the session
			if (dpidPlayer) bKillConnection = FALSE;
			
		} // FindSocketInBag
	
	} // INVALID_SOCKET

	// once we get here, we should have a connected socket ready to send!
	err = 0;
	// keep spitting bits at the socket until we finish or get an error
	while ((prd->dwBytesLeft != 0) && (SOCKET_ERROR != err))
	{
		DPF(5, "AsyncConnectAndSend: Sending %u bytes via socket 0x%x.",
			prd->dwBytesLeft, prd->sSocket);
		DEBUGPRINTADDR(5, "AsyncConnectAndSend: Sending message over connection to - ", &prd->sockaddr);	
		
	    err = send(prd->sSocket,prd->pbSend,prd->dwBytesLeft,0);
		if (SOCKET_ERROR != err)
		{
			// some bytes went out on the wire
			prd->dwBytesLeft -= err; // we just sent err bytes
			prd->pbSend	+= err; // advance our send buffer by err bytes		
		}
	}
	// now, we've either finished the send, or we have an error
	if (SOCKET_ERROR == err)
	{
		err = WSAGetLastError();
		if (WSAEWOULDBLOCK == err)
		{
			DPF(8,"async send - total sent %d left to send %d\n",prd->pbSend,prd->dwBytesLeft);
			// this means we couldn't send any bytes w/o blocking
			// that's ok.  we'll let select tell us when it's ready to not block			
			return DP_OK; 	
		}
		// else it's a real eror!
		// any other error, we give up and clean up this reply
		DPF(0,"async send - send failed - error = %d\n",err);			
		DEBUGPRINTADDR(0,"async send - send failed - addr = ",(LPSOCKADDR)&(prd->sockaddr));
	}
	else ASSERT(0 == prd->dwBytesLeft); // if it's not an error, we better have sent it all

	DPF(8,"async send - total left to send %d (done)\n",prd->dwBytesLeft);
	
	// fall through

CLEANUP_EXIT:

	
	err = g_WSAEventSelect(prd->sSocket,pgd->hSelectEvent,0);
	if(SOCKET_ERROR == err){
		err = WSAGetLastError();
		DPF(8,"async send - error %d deselecting socket %s\n",err,prd->sSocket);
	}

	if (bConnectionExists && bKillConnection)
	{
		// close the connection after we're done
		RemoveSocketFromReceiveList(pgd,prd->sSocket);
		RemoveSocketFromBag(pgd,prd->sSocket);
		// so DeleteReplyNode won't try to kill socket again
		prd->sSocket = INVALID_SOCKET;
	}
	// remove the node from the list
	MoveReplyNodeToCloseList(pgd,prd);
	
	return DP_OK;

} // AsyncConnectAndSend

#if 0
// walk the reply list, tell winsock to watch any of the nodes which has a valid socket
// (i.e. has a connection or send pending)
HRESULT DoEventSelect(LPGLOBALDATA pgd,WSAEVENT hSelectEvent)
{
	UINT err;
	LPREPLYLIST prd;

	ENTER_DPSP();
	
	prd = pgd->pReplyList;
	while (prd)
	{
		if (INVALID_SOCKET != prd->sSocket)
		{
			// have winscok tell us when anything good (connection complete, ready to write more data)
			// happens on this socket
			err = g_WSAEventSelect(prd->sSocket,hSelectEvent,FD_WRITE | FD_CONNECT | FD_CLOSE);
			if (SOCKET_ERROR == err)
			{
				err = WSAGetLastError();
				DPF(0,"could not do event select ! err = %d!",err);
				// keep trying...
			}
		} // invalid_socket
		
		prd = prd->pNextReply;
	}

	LEAVE_DPSP();
	
	return DP_OK;
	
} // DoEventSelect
#endif

// wsaeventselect woke us up.  one or more of our sockets had something happen
// (e.g. connect completed, send ready for more data, etc.)
// walk the reply list, find nodes who need to be serviced
void ServiceReplyList(LPGLOBALDATA pgd,WSAEVENT hEvent)
{
	UINT err;
	LPREPLYLIST prd,prdNext;
	WSANETWORKEVENTS WSANetEvents;

	ENTER_DPSP();
	
Top:	
	prd = pgd->pReplyList;
	while (prd)
	{
		// save this now - asyncconnectandsend could destroy prd
		prdNext = prd->pNextReply;
		if (INVALID_SOCKET != prd->sSocket)
		{
			// go ask winsock if this socket had anything intersting happen
			err = g_WSAEnumNetworkEvents(prd->sSocket,NULL,&WSANetEvents);

			if (SOCKET_ERROR == err)
			{
				err = WSAGetLastError();
				DPF(0,"could not enum events!! err = %d!",err);
				// keep trying...
			}
			else
			{
				BOOL bError=FALSE;
				// no error - go see what we got
				DPF(8,"Got NetEvents %x for socket %d\n",WSANetEvents.lNetworkEvents, prd->sSocket);
				DEBUGPRINTSOCK(8," socket addr -\n", &prd->sSocket);
				if ((WSANetEvents.lNetworkEvents & FD_CONNECT) || (WSANetEvents.lNetworkEvents & FD_WRITE))
				{
					DWORD dwPlayerTo;
					
					// was there an error?
					if (WSANetEvents.iErrorCode[FD_CONNECT_BIT])
					{
						// we got a connect error!
						DPF(0,"async reply - WSANetEvents - connect failed - error = %d\n",
							WSANetEvents.iErrorCode[FD_CONNECT_BIT]);
						DEBUGPRINTADDR(0,"async reply - connect failed - addr = ",
							(LPSOCKADDR)&(prd->sockaddr));
						dwPlayerTo = prd->dwPlayerTo;
						DeleteReplyNode(pgd,prd,TRUE);
						RemovePendingAsyncSends(pgd, dwPlayerTo);
						goto Top;
							
					}

					if (WSANetEvents.iErrorCode[FD_WRITE_BIT])
					{
						// we got a send error!
						DPF(0,"async reply - WSANetEvents - send failed - error = %d\n",
							WSANetEvents.iErrorCode[FD_WRITE_BIT]);
						DEBUGPRINTADDR(0,"async reply - send failed - addr = ",
							(LPSOCKADDR)&(prd->sockaddr));
						dwPlayerTo = prd->dwPlayerTo;
						DeleteReplyNode(pgd,prd,TRUE);
						RemovePendingAsyncSends(pgd, dwPlayerTo);
						goto Top;
					}
					
					if(WSANetEvents.lNetworkEvents & FD_CLOSE){
						dwPlayerTo = prd->dwPlayerTo;
						DeleteReplyNode(pgd,prd,TRUE);
						RemovePendingAsyncSends(pgd, dwPlayerTo);
						goto Top;
					}
					// note - we try + send even if there was an error.	seems like it's worth a shot...
					// go try + send

					AsyncConnectAndSend(pgd,prd);
				}
			}
		} // invalid_socket
		else
		{
			// it it's an invalid socket, we need to init our connect and send
			AsyncConnectAndSend(pgd,prd);	
		}
		
		prd = prdNext;		
		
	}

	LEAVE_DPSP();
	
	return ;
	
} // ServiceReplyList

VOID ServiceReplyCloseList(LPGLOBALDATA pgd, DWORD tNow, BOOL fWait)
{
	UINT err;
	LPREPLYLIST prdPrev,prd,prdNext;

	DPF(8,"==>ServiceReplyCloseList\n");

	prdPrev = CONTAINING_RECORD(&pgd->pReplyCloseList, REPLYLIST, pNextReply);
	prd = pgd->pReplyCloseList;
	
	while (prd)
	{
		prdNext = prd->pNextReply;

		if((tNow-prd->tSent) > LINGER_TIME || fWait){

			while((tNow-prd->tSent) < LINGER_TIME){
				Sleep(500);
				tNow=timeGetTime();
			}
		
			// close that puppy
			KillSocket(prd->sSocket,TRUE,TRUE);
		
			// free up the node
			if (prd->lpMessage) SP_MemFree(prd->lpMessage);
			SP_MemFree(prd);
			prdPrev->pNextReply = prdNext;
			prd = prdNext;
		} else {
			prdPrev=prd;
			prd=prdNext;
		}
	}	
	DPF(8,"<==ServiceReplyCloseList\n");
}

// this thread works on doing async sends
DWORD WINAPI AsyncSendThreadProc(LPVOID pvCast)
{
	HRESULT hr=DP_OK;
	LPGLOBALDATA pgd = (LPGLOBALDATA) pvCast;
	HANDLE hHandleList[3];
	DWORD rc;
	DWORD tWait;
	WSAEVENT hSelectEvent; // event used by WSASelectEvent

	DWORD tLast;
	DWORD tNow;
	#if (USE_RSIP || USE_NATHELP)
	DWORD tLastRsip;
	#endif

	DPF(8,"Entered AsyncSendThreadProc\n");


	// get the event 4 selectevent
	hSelectEvent = g_WSACreateEvent();

	pgd->hSelectEvent = hSelectEvent;

	if (WSA_INVALID_EVENT == hSelectEvent)
	{
		rc = WSAGetLastError();
		DPF(0,"could not create winsock event - rc = %d\n",rc);
		ExitThread(0);
		return 0;
	}
	
	hHandleList[0] = hSelectEvent;
	hHandleList[1] = pgd->hReplyEvent;
	// This extra handle is here because of a Windows 95 bug.  Windows
	// will occasionally miss when it walks the handle table, causing
	// my thread to wait on the wrong handles.  By putting a guaranteed
	// invalid handle at the end of our array, the kernel will do a
	// forced re-walk of the handle table and find the correct handles.
	hHandleList[2] = INVALID_HANDLE_VALUE;

		tNow=timeGetTime();
		tLast=tNow;
	#if (USE_RSIP || USE_NATHELP)
		tLastRsip=tNow;
	#endif

#if USE_RSIP
	ASSERT(2*LINGER_TIME < RSIP_RENEW_TEST_INTERVAL);
#endif

	while (1)
	{
		// tell winsock to watch all of our reply nodes.  it will set our event
		// when something cool happens...
		//DoEventSelect(pgd,hSelectEvent); -- do on creation only, its sticky.

		wait:
			// we only poll every 2 linger times because it really isn't a resource
			// contraint expect at close, which will not linger as much.
			
			tWait=(tLast+2*LINGER_TIME)-tNow;
			if((int)tWait < 0){
				tWait=0;
			}
			ASSERT(!(tWait &0x80000000));

		// wait on our event.  when it's set, we either split, or empty the reply list
		rc = WaitForMultipleObjectsEx(2,hHandleList,FALSE,tWait,TRUE);

		tNow=timeGetTime();
		if(rc == WAIT_TIMEOUT){
		
		#if (USE_RSIP || USE_NATHELP)
			#if USE_RSIP
				if(pgd->sRsip != INVALID_SOCKET){
					if((tNow - tLastRsip) >= RSIP_RENEW_TEST_INTERVAL)
					{
						tLastRsip=tNow;
						rsipPortExtend(pgd, tNow);
						rsipCacheClear(pgd, tNow);
					}	
				} else {
					tLastRsip=tNow;
				}
			#endif	
			#if USE_NATHELP
				if(pgd->pINatHelp){
					if((tNow - tLastRsip) >= pgd->NatHelpCaps.dwRecommendedGetCapsInterval)
					{
						natGetCapsUpdate(pgd);
						tLastRsip = timeGetTime();
					}	
				} else {
					tLastRsip=tNow;
				}
			#endif	
		#endif

			tLast=tNow;
			
			ENTER_DPSP();
				if(pgd->pReplyCloseList)
				{
					ServiceReplyCloseList(pgd,tNow,FALSE);
				}
			LEAVE_DPSP();

			goto wait;
		}	
		
		if ((DWORD)-1 == rc)
		{
			DWORD dwError = GetLastError();
			// rut roh!  errror on the wait
			DPF(0,"!!!!!	error on WaitForMultipleObjects -- async reply bailing -- dwError = %d",dwError);
			goto CLEANUP_EXIT;			
			
		}
		
		if (rc == WAIT_OBJECT_0)	// a-josbor: need to reset this manual event
		{
			ResetEvent(hSelectEvent);
		}
		
		// ok.  someone woke us up.  it could be 1. shutdown,  or 2. one
		// of our sockets needs attention (i.e. a connect completed), or 3. someone
		// put a new reply node on the list
		
		// shutdown?		
		if (pgd->bShutdown)
		{
			goto CLEANUP_EXIT;
		}
		
		DPF(8,"In AsyncSendThreadProc, servicing event %d\n", rc - WAIT_OBJECT_0);

		// otherwise, it must be a socket in need or a new replynode
		ServiceReplyList(pgd,hSelectEvent);
	} // 1

CLEANUP_EXIT:
	
	ENTER_DPSP();

	// cleanout reply list
	while (pgd->pReplyList) DeleteReplyNode(pgd,pgd->pReplyList,TRUE);
	
	ServiceReplyCloseList(pgd,tNow,TRUE);
	ASSERT(pgd->pReplyCloseList==NULL);
	
	CloseHandle(pgd->hReplyEvent);
	pgd->hReplyEvent = 0;

	LEAVE_DPSP();

	g_WSACloseEvent(hSelectEvent);
	
	DPF(6,"replythreadproc exit");
	
	return 0;

} // AsyncSendThreadProc


HRESULT GetMaxUdpBufferSize(SOCKET socket, UINT * piMaxUdpDg)
{
	INT iBufferSize;
	INT err;

	ASSERT(piMaxUdpDg);

	iBufferSize = sizeof(UINT);
	err = g_getsockopt(socket, SOL_SOCKET, SO_MAX_MSG_SIZE, (LPBYTE)piMaxUdpDg, &iBufferSize);
	if (SOCKET_ERROR == err)
	{
		DPF(0,"getsockopt for SO_MAX_MSG_SIZE returned err = %d", WSAGetLastError());
		return DPERR_UNAVAILABLE;
	}

	return DP_OK;
}

#ifdef SENDEX

DWORD wsaoDecRef(LPSENDINFO pSendInfo)
{
	#define pgd (pSendInfo->pgd)
	
	DWORD count;
	
	EnterCriticalSection(&pgd->csSendEx);
	count=(--pSendInfo->RefCount);

	if(!count){
	
		Delete(&pSendInfo->PendingSendQ);
		pgd->dwBytesPending -= pSendInfo->dwMessageSize;
		pgd->dwMessagesPending -= 1;
		
		LeaveCriticalSection(&pgd->csSendEx);

		DPF(8,"wsaoDecRef pSendInfo %x, Refcount=0 , SC context %x, status=%x \n",pSendInfo, pSendInfo->dwUserContext,pSendInfo->Status);


		if(pSendInfo->dwFlags & SI_INTERNALBUFF){
			SP_MemFree(pSendInfo->SendArray[0].buf);
		} else {
			if(pSendInfo->dwSendFlags & DPSEND_ASYNC){
				pSendInfo->lpISP->lpVtbl->SendComplete(pSendInfo->lpISP,(LPVOID)pSendInfo->dwUserContext,pSendInfo->Status);
			}	
		}
		
		pgd->pSendInfoPool->Release(pgd->pSendInfoPool, pSendInfo);
		
	} else {
	
		DPF(8,"wsaoDecRef pSendInfo %x, Refcount= %d\n",pSendInfo,pSendInfo->RefCount);
		LeaveCriticalSection(&pgd->csSendEx);
		
	}

	if(count& 0x80000000){
		DEBUG_BREAK();
	}
	
	return count;
	
	#undef pgd
}


VOID CompleteSend(LPSENDINFO pSendInfo)
{
	if(pSendInfo->pConn){
		EnterCriticalSection(&pSendInfo->pgd->csFast);
		pSendInfo->pConn->bSendOutstanding = FALSE;
		LeaveCriticalSection(&pSendInfo->pgd->csFast);
		QueueNextSend(pSendInfo->pgd, pSendInfo->pConn);
		DecRefConn(pSendInfo->pgd, pSendInfo->pConn);
	} 

	wsaoDecRef(pSendInfo);
}

void CALLBACK SendComplete(
  DWORD dwError,
  DWORD cbTransferred,
  LPWSAOVERLAPPED lpOverlapped,
  DWORD dwFlags
)
{
	LPSENDINFO lpSendInfo=(LPSENDINFO)CONTAINING_RECORD(lpOverlapped,SENDINFO,wsao);

	DPF(8,"DPWSOCK:SendComplete, lpSendInfo %x\n",lpSendInfo);

	if(dwError){
		DPF(0,"DPWSOCK: send completion error, dwError=x%x\n",dwError);
		lpSendInfo->Status=DPERR_GENERIC;
	}

	CompleteSend(lpSendInfo);
}

HRESULT DoSend(LPGLOBALDATA pgd, LPSENDINFO pSendInfo)
{
	#define fAsync (pSendInfo->dwSendFlags & DPSEND_ASYNC)
	
	DWORD dwBytesSent;
	UINT err;
	HRESULT hr=DP_OK;


	if (pSendInfo->dwFlags & SI_RELIABLE)
	{
	
		// Reliable Send
		DPF(8,"WSASend, pSendInfo %x\n",pSendInfo);

#if DUMPBYTES
		{
			PCHAR pBuf;
			UINT buflen;
			UINT i=0;

			pBuf = 	 ((LPWSABUF)&pSendInfo->SendArray[pSendInfo->iFirstBuf+pSendInfo->cBuffers-1])->buf;
			buflen =  ((LPWSABUF)&pSendInfo->SendArray[pSendInfo->iFirstBuf+pSendInfo->cBuffers-1])->len;

			while (((i + 16) < buflen) && (i < 4*16)){
				DPF(9, "%08x %08x %08x %08x",*(PUINT)(&pBuf[i]),*(PUINT)(&pBuf[i+4]),*(PUINT)(&pBuf[i+8]),*(PUINT)(&pBuf[i+12]));
				i += 16;
			}	
		}
#endif


		// send the message
		err = g_WSASend(pSendInfo->sSocket,
					  (LPWSABUF)&pSendInfo->SendArray[pSendInfo->iFirstBuf],
					  pSendInfo->cBuffers,
					  &dwBytesSent,
				  	  0,				/*flags*/
				  	  (fAsync)?(&pSendInfo->wsao):NULL,
				  	  (fAsync)?(SendComplete):NULL);

		if(!err){
				DPF(8,"WSASend, sent synchronously, pSendInfo %x\n",pSendInfo);
				wsaoDecRef(pSendInfo);
				hr=DP_OK;
		} else {

			if (SOCKET_ERROR == err)
			{
			
				err = WSAGetLastError();

				if(err==WSA_IO_PENDING){
					hr=DPERR_PENDING;
					wsaoDecRef(pSendInfo);
					DPF(8,"ASYNC SEND Pending pSendInfo %x\n",pSendInfo);
				} else {
					DPF(8,"WSASend Error %d\n",err);
					ASSERT(err != WSAEWOULDBLOCK); // vadime assures this never happens. (aarono 9-12-00)
					if(err==WSAECONNRESET){
						hr=DPERR_CONNECTIONLOST;
					} else {
						hr=DPERR_GENERIC;
					}	
					if(fAsync){
						// Got an error, need to dump 2 refs.
						pSendInfo->Status=hr;
						wsaoDecRef(pSendInfo);
					}	
					CompleteSend(pSendInfo);
					// we got a socket from the bag.  send failed,
					// so we're cruising it from the bag
					if(!(pSendInfo->dwFlags & SI_INTERNALBUFF))
					{
						DPF(0,"send error - err = %d\n",err);
					}		
				}	
			
			}
		}	
	
	} else {
	
		// Datagram Send
		DEBUGPRINTADDR(5,"unreliable send - sending to ",&pSendInfo->sockaddr);	
		// send the message
		err = g_WSASendTo(pSendInfo->sSocket,
						  (LPWSABUF)&pSendInfo->SendArray[pSendInfo->iFirstBuf],
						  pSendInfo->cBuffers,
						  &dwBytesSent,
						  0,				/*flags*/
						  (LPSOCKADDR)&pSendInfo->sockaddr,
					      sizeof(SOCKADDR),
					  	  (fAsync)?(&pSendInfo->wsao):NULL,
					  	  (fAsync)?(SendComplete):NULL);


		if(!err){
			hr=DP_OK;
			wsaoDecRef(pSendInfo);
		} else {
		    if (SOCKET_ERROR == err)
		    {
		        err = WSAGetLastError();
		
		        if(err==WSA_IO_PENDING){
		        	hr=DPERR_PENDING;
					wsaoDecRef(pSendInfo);
				} else {
					hr=DPERR_GENERIC;
					if(fAsync){
						// some error, force completion.
						pSendInfo->Status=DPERR_GENERIC;
						wsaoDecRef(pSendInfo);
					}	
					wsaoDecRef(pSendInfo);
			        DPF(0,"send error - err = %d\n",err);
		        }
		    } else {
		    	DEBUG_BREAK();// SHOULD NEVER HAPPEN
		    }

		}
		
	}
	return hr;
	
	#undef fAsync
}

// Alert thread provides a thread for send completions to run on.

DWORD WINAPI SPSendThread(LPVOID lpv)
{
	LPGLOBALDATA pgd=(LPGLOBALDATA) lpv;
	LPSENDINFO  pSendInfo;

	DWORD rcWait=WAIT_IO_COMPLETION;
	BILINK *pBilink;
	BOOL bSent;

	pgd->BogusHandle=INVALID_HANDLE_VALUE;	// workaround win95 wait for multiple bug.
	
	while(!pgd->bStopSendThread){
		rcWait=g_WSAWaitForMultipleEvents(1,&pgd->hSendWait,FALSE,INFINITE,TRUE);
		#ifdef DEBUG
		if(rcWait==WAIT_IO_COMPLETION){
			DPF(8,"ooooh, IO completion\n");
		}
		#endif

		do {
			bSent = FALSE;
		
			EnterCriticalSection(&pgd->csSendEx);

			pBilink=pgd->ReadyToSendQ.next;

			if(pBilink != &pgd->ReadyToSendQ){
				Delete(pBilink);
				LeaveCriticalSection(&pgd->csSendEx);
				pSendInfo=CONTAINING_RECORD(pBilink, SENDINFO, ReadyToSendQ);
				DoSend(pgd, pSendInfo);
				bSent=TRUE;
			} else {
				LeaveCriticalSection(&pgd->csSendEx);
			}	
		} while (bSent);
	}	

	pgd->bSendThreadRunning=FALSE;
	
	return FALSE;
	
	#undef hWait
}



void QueueForSend(LPGLOBALDATA pgd,LPSENDINFO pSendInfo)
{
	EnterCriticalSection(&pgd->csSendEx);
	
		if(pSendInfo->pConn){
			// Note csFast is taken for pConn to be non-NULL
			AddRefConn(pSendInfo->pConn);
			pSendInfo->pConn->bSendOutstanding = TRUE;
		}	
		
		InsertBefore(&pSendInfo->ReadyToSendQ,&pgd->ReadyToSendQ);
		
	LeaveCriticalSection(&pgd->csSendEx);
	
	SetEvent(pgd->hSendWait);
}

// some common code for InternalReliableSendEx and UnreliableSendEx
VOID CommonInitForSend(LPGLOBALDATA pgd,LPDPSP_SENDEXDATA psd,LPSENDINFO pSendInfo)
{

	pSendInfo->pConn		= NULL;
	pSendInfo->dwMessageSize= psd->dwMessageSize;
	pSendInfo->dwUserContext= (DWORD_PTR)psd->lpDPContext;
	pSendInfo->RefCount     = 2;		// one for completion, 1 for this routine
	pSendInfo->pgd          = pgd;
	pSendInfo->lpISP        = psd->lpISP;
	pSendInfo->Status       = DP_OK;
	pSendInfo->idTo         = psd->idPlayerTo;
	pSendInfo->idFrom       = psd->idPlayerFrom;
	pSendInfo->dwSendFlags  = psd->dwFlags;
	
	if(psd->lpdwSPMsgID){
		*psd->lpdwSPMsgID=0;
	}	

	EnterCriticalSection(&pgd->csSendEx);
	
		InsertBefore(&pSendInfo->PendingSendQ,&pgd->PendingSendQ);
		pgd->dwBytesPending += psd->dwMessageSize;
		pgd->dwMessagesPending += 1;
		
	LeaveCriticalSection(&pgd->csSendEx);
}

VOID UnpendSendInfo(LPGLOBALDATA pgd, LPSENDINFO pSendInfo)
{
	EnterCriticalSection(&pgd->csSendEx);
	Delete(&pSendInfo->PendingSendQ);
	pgd->dwBytesPending -= pSendInfo->dwMessageSize;
	pgd->dwMessagesPending -= 1;
	LeaveCriticalSection(&pgd->csSendEx);
}


HRESULT UnreliableSendEx(LPDPSP_SENDEXDATA psd, LPSENDINFO pSendInfo)
{
    SOCKADDR sockaddr;
    INT iAddrLen = sizeof(sockaddr);
    HRESULT hr=DP_OK;
    UINT err;
	DWORD dwSize = sizeof(SPPLAYERDATA);
	LPSPPLAYERDATA ppdTo;
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;

	BOOL bSendHeader;
	
	// get the global data
	hr =psd->lpISP->lpVtbl->GetSPData(psd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

	if (pgd->iMaxUdpDg && (psd->dwMessageSize >= pgd->iMaxUdpDg))
	{
		return DPERR_SENDTOOBIG;
	}

	// get to address	
    if (0 == psd->idPlayerTo)
    {
		sockaddr = pgd->saddrNS;
    }
    else
    {
		hr = GetSPPlayerData(pgd,psd->lpISP,psd->idPlayerTo,&ppdTo,&dwSize);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			return hr;
		}

		sockaddr = *(DGRAM_PSOCKADDR(ppdTo));
    }

	// put the token + size on front of the mesage
	SetMessageHeader((LPVOID)(pSendInfo->SendArray[0].buf),psd->dwMessageSize+sizeof(MESSAGEHEADER),TOKEN);
   	bSendHeader=TRUE;
   	
	if (psd->bSystemMessage)
    {
		SetReturnAddress(pSendInfo->SendArray[0].buf,SERVICE_SOCKET(pgd),SERVICE_SADDR_PUBLIC(pgd));
    } // reply
	else
	{
		// see if we can send this message w/ no header
		// if the message is smaller than a dword, or, if it's a valid sp header (fooling us
		// on the other end, don't send any header
		if ( !((psd->dwMessageSize >= sizeof(DWORD)) &&  !(VALID_SP_MESSAGE(pSendInfo->SendArray[0].buf))) )
		{
			bSendHeader=FALSE;
		}
	}

    CommonInitForSend(pgd,psd,pSendInfo);
	pSendInfo->dwFlags      |= SI_DATAGRAM;
	pSendInfo->sSocket      = pgd->sSystemDGramSocket;
	pSendInfo->sockaddr     = sockaddr;

	if(bSendHeader){
		pSendInfo->iFirstBuf=0;
		pSendInfo->cBuffers =psd->cBuffers+1;
	} else {
		pSendInfo->iFirstBuf=1;
		pSendInfo->cBuffers=psd->cBuffers;
	}

	if(psd->dwFlags & DPSEND_ASYNC){
		QueueForSend(pgd,pSendInfo);
		hr=DPERR_PENDING;
	} else {
		hr=DoSend(pgd,pSendInfo);
		if(hr==DP_OK || hr==DPERR_PENDING){
			wsaoDecRef(pSendInfo);
		} else {
			UnpendSendInfo(pgd, pSendInfo);
		}
	}
	
	return hr;

} // UnreliableSendEx
#endif //SendEx

BOOL SetExclusivePortAccess(SOCKET sNew)
{
	BOOL bReturn = TRUE;
	BOOL bValue;
	UINT err;

	// turn on exclusive port use to avoid hijacking, note this only works on NT4 SP4 and later.
	// on other OSes this will fail, but that is ok, we will ignore.

	DPF(5, "Turning reuse OFF and exclusive access ON for socket 0x%p", sNew);
	
	bValue = FALSE;
	if (SOCKET_ERROR == setsockopt(sNew, SOL_SOCKET, SO_REUSEADDR, (CHAR FAR *)&bValue, sizeof(bValue)))
	{
		err = WSAGetLastError();
		DPF(1,"WARN: Failed to set shared port use to FALSE - continue : err = %d\n",err);
		bReturn = FALSE;
	}

	bValue = TRUE;
	if (SOCKET_ERROR == setsockopt(sNew, SOL_SOCKET, SO_EXCLUSIVEADDRUSE, (CHAR FAR *)&bValue, sizeof(bValue)))
	{
		err = WSAGetLastError();
		DPF(1,"WARN: Failed to set exclusive port use to TRUE - continue : err = %d\n",err);
		bReturn = FALSE;
	}

	return bReturn;
}

BOOL SetSharedPortAccess(SOCKET sNew)
{
	BOOL bReturn = TRUE;
	BOOL bValue;
	UINT err;

	// turn on port sharing.

	DPF(5, "Turning exclusive access OFF and reuse ON for socket 0x%p", sNew);
  	
	bValue = FALSE;
	if (SOCKET_ERROR == setsockopt(sNew, SOL_SOCKET, SO_EXCLUSIVEADDRUSE, (CHAR FAR *)&bValue, sizeof(bValue)))
	{
		err = WSAGetLastError();
		DPF(1,"WARN: Failed to set exclusive port use to FALSE - continue : err = %d\n",err);
		bReturn = FALSE;
	}
 
	bValue = TRUE;
	if (SOCKET_ERROR == setsockopt(sNew, SOL_SOCKET, SO_REUSEADDR, (CHAR FAR *)&bValue, sizeof(bValue)))
	{
		err = WSAGetLastError();
		DPF(1,"WARN: Failed to set shared port use to TRUE - continue : err = %d\n",err);
		bReturn = FALSE;
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\bagarray.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       BagArray.h
 *  Content:	CBagArray / CBagPtrArray Declaration
 *
 *  History:
 *   Date		By			Reason
 *   ======		==			======
 *  12-12-2001	simonpow	Created
 ***************************************************************************/
 
 
#ifndef __BAGARRAY_H__
#define __BAGARRAY_H__

#include "AutoArray.h"

/*
 * CBagArray.
 * Represents an unordered collection of elements held in an array.
 * This class is useful when your repeatedly scanning a set of values
 * or objects and don't care what their order is, and have no
 * need to maintain persistent reference to specific entries.
 * Each time you remove an entry it fills the empty slot with
 * the current top entry in the array. Hence, whilst removes cause
 * the array order to change, it means scans always take minimal time.
 * 
 * Memory management relies on CAutoArray so see comments on that for more info.
 *
 * If you need a CBagArray of pointers use the CBagPtrArray specialisation of it 
 * This is declared below CBagArray.
 */
 
template <class T> class CBagArray
{
public:

		//provides the type of entries held
	typedef T Entry;

		//array starts 0 zero and by default grows in multiples
		//of 16 elements at a time
	CBagArray(DWORD dwSizeMultiple=16) : m_data(dwSizeMultiple), m_dwTopFreeSlot(0)
		{ };

		//standard d'tor
	~CBagArray()
		{};

	/*
	 * Memory Management
	 */

		//Delete existing contents and reset the size multiplier
		//Pass 0 for size multiplier to retain the existing value
	void Reset(DWORD dwSizeMultiple=16)
		{ m_data.Reset(dwSizeMultiple); m_dwTopFreeSlot=0; };
	
		//ensure that there is enough space in the array to hold at least 
		//'numElements' without needing to re-create and copy the data
		//Returns FALSE if it fails due to a memory alloc failure
	BOOL AllocAtLeast(DWORD dwNumElements)
		{	return m_data.AllocAtLeast(dwNumElements);	};
		
		//ensure that there is enough space in the array
		//to hold at least an additional 'numElements'
		//Returns FALSE if it fails due to a memory alloc failure
	BOOL AllocExtra(DWORD dwNumElements)
		{	return m_data.AllocAtLeast(dwNumElements+m_dwTopFreeSlot);	};


	/* 
	 * Adding elements to bag
	 */

		//add an element.
		//Returns FALSE if it fails due to a memory alloc failure
	BOOL AddElement(const T& elem)
		{	return m_data.SetElement(m_dwTopFreeSlot++, elem);	};
	
		//add a series of entries to the end of the array
		//N.B. Don't pass pointers into data in this bag as 'pElem'!
		//e.g. Don't do bag.AddElements(bag.GetAllElements, bag.GetNumElements());
		//Returns FALSE if it fails due to a memory alloc failure
	BOOL AddElements(const T * pElems, DWORD dwNumElem);

		//add the entries from another bag to the end of this one
		//N.B. Don't pass bag to itself (e.g. Don't do bag.AddElements(bag); )
		//Returns FALSE if it fails due to a memory alloc failure
	BOOL AddElements(const CBagArray<T>& bag);

		//add an entry and don't check if more memory is needed!
		//*ONLY* use this if you know the array already
		//has enough space. A good example of use is adding a
		//sequence of x entries pre-fixed with an AllocExtra(x)
	void AddElementNoCheck(const T& elem)
		{	m_data.SetExistingElement(m_dwTopFreeSlot++, elem);	};

	/*
	 * Removing entries
	 * N.B. These cause the order of the elements to change
	 */

		//remove the first entry that matches 'elem'
		//returns TRUE if 'dataEntry' is found or FALSE if it isn't
	BOOL RemoveElementByValue(const T& elem);
	
		//return an entry by its *current* index in the array
		//N.B. A remove operation can disturb the order in the array. 
		//Therefore you can't call this repeatedly without checking 
		//your certain your removing the right thing
	inline void RemoveElementByIndex(DWORD dwIndex);
	
		//remove all the current entries
	void RemoveAllElements()
		{	m_dwTopFreeSlot=0;	};
	
	
	/*
	 * Accessing bag contents
	 * N.B. Treat any pointers into bag contents very carefully.
	 * Adding new elements to the bag or using the Alloc* methods
	 * can cause them to become invalid
	 */
	
		//returns the number of entries
	DWORD GetNumElements() const
		{	return m_dwTopFreeSlot;	};

		//return true if the array is empty
	BOOL IsEmpty() const
		{	return (m_dwTopFreeSlot==0);	};
	
		//return value at a specific index
	T GetElementValue(DWORD dwIndex) const
		{	return m_data.GetElementValue(dwIndex);	};

		//return reference to an element at specific index
	T& GetElementRef(DWORD dwIndex)
		{	return m_data.GetElementRef(dwIndex);	};

		//return constant reference to an element at specific index
	const T& GetElementRef(DWORD dwIndex) const
		{	return m_data.GetElementRef(dwIndex);	};

		//return a pointer to an element
	T * GetElementPtr(DWORD dwIndex)
		{	return m_data.GetElementPtr(dwIndex);	};

		//returns pointer to array of all elements
	T * GetAllElements()
		{	return m_data.GetAllElements();	};

		//copy dwNumElements from dwIndex into pDestArray
	inline void CopyElements(T * pDestArray, DWORD dwIndex, DWORD dwNumElements);

		//copy all the elements from the bag to pDestArray
	void CopyAllElements(T * pDestArray)
		{	CopyElements(pDestArray, 0, m_dwTopFreeSlot);	};

	/*
	 * Searching Bag
	 */

		//find an instance of 'elem' in bag. If found returns TRUE
		//and sets 'pdwIndex' to index of element
	BOOL FindElement(const T& elem, DWORD * pdwIndex) const;

		//returns TRUE if 'elem' is present in bag
	BOOL IsElementPresent(const T& elem) const
		{	DWORD dwIndex; return (FindElement(elem, &dwIndex));	};


protected:

	CAutoArray<T> m_data;
	DWORD m_dwTopFreeSlot;

};

/*
 * Specialisation of CBagArray for handling pointers
 * If you ever need to declare a bag of pointers (e.g. char *)
 * declare it as an CBagPtrArray (e.g. CBagPtrArray<char *>).
 * This specilisation uses a CBagArray<void *> underneath and hence
 * re-uses the same code between all types of CBagPtrArray.
 */ 

template <class T> class CBagPtrArray : public CBagArray<void *>
{
public:

	typedef T Entry;

	typedef CBagArray<void * > Base;

	CBagPtrArray(DWORD dwSizeMultiple=16) : CBagArray<void*>(dwSizeMultiple)
		{ };

	BOOL AddElement(T elem)
		{	return Base::AddElement((void * ) elem);	};
	
	BOOL AddElements(const T * pElems, DWORD dwNumElem)
		{	return Base::AddElements((void** ) pElems, dwNumElem);	};

	BOOL AddElements(const CBagArray<T>& bag)
		{	return Base::AddElements((CBagArray<void*>&) bag);	};

	void AddElementNoCheck(T elem)
		{	return Base::AddElementNoCheck((void * ) elem);	};

	BOOL RemoveElementByValue(T elem)
		{	return Base::RemoveElementByValue((void * ) elem);	};

	T GetElementValue(DWORD dwIndex) const
		{	return (T ) m_data.GetElementValue(dwIndex);	};

	T& GetElementRef(DWORD dwIndex)
		{	return (T& ) m_data.GetElementRef(dwIndex);	};

	const T& GetElementRef(DWORD dwIndex) const
		{	return (const T&) m_data.GetElementRef(dwIndex);	};

	T * GetElementPtr(DWORD dwIndex)
		{	return (T* ) m_data.GetElementPtr(dwIndex);	};

	T * GetAllElements()
		{	return (T* ) m_data.GetAllElements();	};

	BOOL FindElement(T elem, DWORD * pdwIndex) const
		{	return Base::FindElement((void*) elem, pdwIndex);	};

	BOOL IsElementPresent(T elem) const
		{	DWORD dwIndex; return (Base::FindElement((void * ) elem, &dwIndex));	};
};


/*
 * Inline methods for CBagArray
 */


template <class T>
void CBagArray<T>::RemoveElementByIndex(DWORD dwIndex)
{
	DNASSERT(dwIndex<m_dwTopFreeSlot);
	m_dwTopFreeSlot--;
	if (dwIndex!=m_dwTopFreeSlot)
		m_data.SetExistingElement(dwIndex, m_data.GetElementRef(m_dwTopFreeSlot));
}

template <class T>
void CBagArray<T>::CopyElements(T * pDestArray, DWORD dwIndex, DWORD dwNumElements)
{
	DNASSERT(dwIndex+dwNumElements<=m_dwTopFreeSlot);
	T * pScan=m_data.GetElementPtr(dwIndex);
	T * pEndScan=pScan+dwNumElements;
	while (pScan!=pEndScan)
		*pDestArray++=*pScan++;
}

/*
 * If not building with explicit template instantiation then also
 * include all other methods for CBagArray
 */

#ifndef DPNBUILD_EXPLICIT_TEMPLATES
#include "BagArray.inl"
#endif

#endif	//#ifndef __CBAGARRAY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\callstack.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       CallStack.cpp
 *  Content:	Call stack tracking class
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	08/13/2001	masonb	Created
 *
 ***************************************************************************/

#include "dncmni.h"

#ifdef DBG

#ifndef DPNBUILD_NOIMAGEHLP
#define	_IMAGEHLP_SOURCE_
#include	<Imagehlp.h>
#endif // !DPNBUILD_NOIMAGEHLP

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

#ifndef DPNBUILD_NOIMAGEHLP
//
// prototypes for ImageHlp.DLL functions we get from LoadLibrary().
//
typedef DWORD	(__stdcall * PIMAGEHELP_SYMGETOPTIONS)( void );
typedef DWORD	(__stdcall * PIMAGEHELP_SYMSETOPTIONS)( DWORD SymOptions );
typedef	BOOL	(__stdcall * PIMAGEHELP_SYMINITIALIZE)( HANDLE hProcess, PSTR pUserSearchPath, BOOL fInvadeProcess );
typedef BOOL	(__stdcall * PIMAGEHELP_SYMGETSYMFROMADDR)( HANDLE hProcess, DWORD dwAddress, PDWORD pdwDisplacement, PIMAGEHLP_SYMBOL pSymbol );
typedef BOOL	(__stdcall * PIMAGEHELP_SYMGETSYMFROMADDR64)( HANDLE hProcess, DWORD_PTR dwAddress, PDWORD_PTR pdwDisplacement, PIMAGEHLP_SYMBOL64 pSymbol );

#endif // !DPNBUILD_NOIMAGEHLP

//**********************************************************************
// Class function definitions
//**********************************************************************

void	CCallStack::NoteCurrentCallStack( void )
{
	void		**CallersEBP = NULL;
	void		*ReturnAddr;
	UINT_PTR	i,iCount;
	const void	*StackTop;
	const void	*StackBottom;
	static const void	*const min_dll_base = NULL;


	StackTop = GetStackTop();
	StackBottom = GetStackBottom();
	memset(	m_CallStack, 0x00, sizeof( m_CallStack ) );

#ifdef	_X86_
	_asm
	{
		mov eax,[ebp]
		mov CallersEBP,eax
	}
#endif	// _X86_

	_try
	{
		//
		// this code can generate exception if it steps back too far...
		//
 		for ( i = 0, iCount = 0; i < CALLSTACK_DEPTH; iCount++ )
		{
			if ( ( CallersEBP < StackBottom ) || ( CallersEBP >= StackTop ) )
				break;
			ReturnAddr = CallersEBP[ 1 ];
			if ( ( iCount > 0 ) || ( ReturnAddr >= min_dll_base ) ) // iCount check skips memory_alloc_debug
				m_CallStack[ i++ ] = ReturnAddr;
			CallersEBP = reinterpret_cast<void**>( *CallersEBP ); // get callers callers ebp
		}
	}
	_except(EXCEPTION_EXECUTE_HANDLER)  // went too far back on the stack, rest of array is filled with zeros
	{
//		DPFX(DPFPREP,  0, "Benign access violation creating return address stack." );
	}
}

const void* CCallStack::GetStackTop( void ) const
{
	void	*pReturn = NULL;

#ifdef	_X86_
	_asm	mov eax,dword ptr fs:[4]
	_asm	mov pReturn, eax
#endif	// _X86_

	return	pReturn;
}

const void	*CCallStack::GetStackBottom( void ) const
{
	void	*pReturn = NULL;

#ifdef	_X86_
	_asm	mov eax,dword ptr fs:[8]
	_asm	mov pReturn, eax
#endif	// _X86_

	return	pReturn;
}

void CCallStack::GetCallStackString( TCHAR *const pOutputString ) const
{
	static const TCHAR	CallStackTitle[] = _T("\nCALL STACK:\n");
	static const TCHAR	CallStackTitleWithSymbols[] = _T("\nCALL STACK:\tFUNCTION DETAILS:\n");
	
#ifndef DPNBUILD_NOIMAGEHLP 
	static enum
	{
		IMAGEHELP_STATUS_UNKNOWN,
		IMAGEHELP_STATUS_LOADED,
		IMAGEHELP_STATUS_LOAD_FAILED
	} ImageHelpStatus = IMAGEHELP_STATUS_UNKNOWN;

	static HINSTANCE	hImageHelp = NULL;
	static PIMAGEHELP_SYMGETOPTIONS			pSymGetOptions = NULL;
	static PIMAGEHELP_SYMSETOPTIONS			pSymSetOptions = NULL;
	static PIMAGEHELP_SYMINITIALIZE			pSymInitialize = NULL;

#ifndef	_WIN64	
	static PIMAGEHELP_SYMGETSYMFROMADDR		pSymGetSymFromAddr = NULL;
#else
	static PIMAGEHELP_SYMGETSYMFROMADDR64	pSymGetSymFromAddr = NULL;
#endif	// _WIN64

	//
	// if ImageHelp isn't loaded attempt to load it
	//
	if ( ImageHelpStatus == IMAGEHELP_STATUS_UNKNOWN )
	{
		ImageHelpStatus = IMAGEHELP_STATUS_LOAD_FAILED;

		hImageHelp = LoadLibrary( _T("ImageHLP.DLL") );
		if ( hImageHelp == NULL )
		{
			goto FailedImageHelpLoad;
		}

		pSymGetOptions = reinterpret_cast<PIMAGEHELP_SYMGETOPTIONS>( GetProcAddress( hImageHelp, "SymGetOptions" ) );
		pSymSetOptions = reinterpret_cast<PIMAGEHELP_SYMSETOPTIONS>( GetProcAddress( hImageHelp, "SymSetOptions" ) );
		pSymInitialize = reinterpret_cast<PIMAGEHELP_SYMINITIALIZE>( GetProcAddress( hImageHelp, "SymInitialize" ) );

#ifndef	_WIN64		
		pSymGetSymFromAddr = reinterpret_cast<PIMAGEHELP_SYMGETSYMFROMADDR>( GetProcAddress( hImageHelp, "SymGetSymFromAddr" ) );
#else	// _WIN64
		pSymGetSymFromAddr = reinterpret_cast<PIMAGEHELP_SYMGETSYMFROMADDR64>( GetProcAddress( hImageHelp, "SymGetSymFromAddr64" ) );
#endif	// _WIN64

		if ( ( pSymGetOptions == NULL ) ||
			 ( pSymSetOptions == NULL ) ||
			 ( pSymInitialize == NULL ) ||
			 ( pSymGetSymFromAddr == NULL ) )
		{
			goto FailedImageHelpLoad;
		}

		pSymSetOptions( SYMOPT_DEFERRED_LOADS | pSymGetOptions() );

		if ( pSymInitialize( GetCurrentProcess(), NULL, TRUE ) == FALSE )
		{
			if ( pSymInitialize( GetCurrentProcess(), NULL, FALSE ) == FALSE )
			{
				goto FailedImageHelpLoad;
			}
		}

		ImageHelpStatus = IMAGEHELP_STATUS_LOADED;
	}

FailedImageHelpLoad:
	if ( ImageHelpStatus == IMAGEHELP_STATUS_LOADED )
	{
		memcpy( pOutputString, CallStackTitleWithSymbols, sizeof( CallStackTitleWithSymbols ) );
	}
	else
#endif // !DPNBUILD_NOIMAGEHLP
	{
		memcpy( pOutputString, CallStackTitle, sizeof( CallStackTitle ) );
	}

	for ( DWORD dwIndex = 0; ( ( dwIndex < CALLSTACK_DEPTH ) && ( m_CallStack[ dwIndex ] != NULL ) ); dwIndex++ )
	{
		TCHAR	AddressBuffer[ CALLSTACK_BUFFER_SIZE ];


#ifndef DPNBUILD_NOIMAGEHLP
		if ( ImageHelpStatus == IMAGEHELP_STATUS_LOADED )
		{
			TCHAR	ImageBuffer[ CALLSTACK_BUFFER_SIZE + sizeof(IMAGEHLP_SYMBOL) ];
			DWORD_PTR	dwFunctionDisplacement;
#ifndef	_WIN64
			IMAGEHLP_SYMBOL	*const pImageHelpSymbol = reinterpret_cast<IMAGEHLP_SYMBOL*>( ImageBuffer );
#else	// _WIN64
			IMAGEHLP_SYMBOL64	*const pImageHelpSymbol = reinterpret_cast<IMAGEHLP_SYMBOL64*>( ImageBuffer );
#endif	// _WIN64


			pImageHelpSymbol->SizeOfStruct = sizeof( *pImageHelpSymbol );
			pImageHelpSymbol->Flags = 0;
			pImageHelpSymbol->Address = reinterpret_cast<DWORD_PTR>( m_CallStack[ dwIndex ] );
            pImageHelpSymbol->MaxNameLength = sizeof( ImageBuffer ) - sizeof( *pImageHelpSymbol ) - 14;   // account for \t%s+0x00000000\n\0
            if ( pSymGetSymFromAddr( GetCurrentProcess(),
									 reinterpret_cast<DWORD_PTR>( m_CallStack[ dwIndex ] ),
									 &dwFunctionDisplacement,
									 pImageHelpSymbol
									 ) != FALSE )
            {
                if ( dwFunctionDisplacement != 0 )
				{
#ifdef _X86_
					wsprintf( AddressBuffer, _T("0x%x\t%hs+0x%x\n"), (DWORD)m_CallStack[ dwIndex ], pImageHelpSymbol->Name, dwFunctionDisplacement );
#else
					wsprintf( AddressBuffer, _T("0x%p\t%hs+0x%x\n"), m_CallStack[ dwIndex ], pImageHelpSymbol->Name, dwFunctionDisplacement );
#endif // _X86_
				}
                else
				{
#ifdef _X86_
                    wsprintf( AddressBuffer, _T("0x%x\t%hs\n"), (DWORD)m_CallStack[ dwIndex ], pImageHelpSymbol->Name );
#else
                    wsprintf( AddressBuffer, _T("0x%p\t%hs\n"), m_CallStack[ dwIndex ], pImageHelpSymbol->Name );
#endif // _X86_
				}

				_tcscat( pOutputString, AddressBuffer );

				//
				// continue FOR loop
				//
				continue;
            }
		}	
#endif // !DPNBUILD_NOIMAGEHLP

#ifdef _X86_
		wsprintf( AddressBuffer, _T("0x%08x\n"), (DWORD)m_CallStack[ dwIndex ] );
#else
		wsprintf( AddressBuffer, _T("0x%p\n"), m_CallStack[ dwIndex ] );
#endif // _X86_
		_tcscat( pOutputString, AddressBuffer );
	}

	return;
}
//**********************************************************************

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\callstack.h ===
/*==========================================================================
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       CallStack.h
 *  Content:	Call stack tracking class
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	08/13/2001	masonb	Created
 *
 ***************************************************************************/

#ifndef	__CALLSTACK_H__
#define	__CALLSTACK_H__

#ifdef DBG

//**********************************************************************
// Constant definitions
//**********************************************************************

//
// Size of temp buffer to build strings into.
// If the call stack depth is increased, increase the size of the buffer
// to prevent stack corruption with long symbol names.
//
#define	CALLSTACK_BUFFER_SIZE	8192
#define CALLSTACK_DEPTH			12

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

class	CCallStack
{
	public:
		CCallStack(){}
		~CCallStack(){}

		void	NoteCurrentCallStack( void );
		void	GetCallStackString( TCHAR *const pOutputString ) const;

	private:
		const void*		m_CallStack[CALLSTACK_DEPTH];
		const void		*GetStackTop( void ) const;
		const void		*GetStackBottom( void ) const;
};

#endif // DBG

#endif	// __CALLSTACK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\autoarray.inl ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       AutoArray.inl
 *  Content:	CAutoArray methods
 *
 *  History:
 *   Date		By			Reason
 *   ======		==			======
 *  12-12-2001	simonpow	Created
 ***************************************************************************/

template <class T>
void CAutoArray<T>::SetExistingElements(DWORD dwIndex, const T * pElemData, DWORD dwNumElem)
{
	DNASSERT(dwIndex+dwNumElem<=m_dwSize);
		//have to handle the case where pElemData is actually a pointer
		//into this arrays data (don't want to overwrite original data
		//with copied data prematurely).
		//copy from top down if destination is in front of source
	T * pDest=m_pData+dwIndex;
	if (pDest>pElemData)
	{
		T * pDestScan=pDest+dwNumElem-1;
		pElemData+=(dwNumElem-1);
		while (pDestScan>=pDest)
			*pDestScan--=*pElemData--;
	}
		//otherwise it must be bottom up 
	else
	{
		T * pDestScan=pDest;
		pDest+=dwNumElem;
		while (pDestScan<pDest)
			*pDestScan++=*pElemData++;
	}
}

//make array larger so index falls within its range
//N.B. Caller must have tested that dwIndex>=m_dwSize already!

template <class T> 
BOOL CAutoArray<T>::GrowToAtLeast(DWORD dwIndex)
{
		//allocate new memory block
	DWORD dwNewSize=GetArraySize(dwIndex);
	T * pNewData=new T[dwNewSize];
	if (!pNewData)
		return FALSE;
		//if we've got existing data copy it to new block
	if (m_pData)
	{
		for (DWORD dwLoop=0; dwLoop<m_dwSize; dwLoop++)
			pNewData[dwLoop]=m_pData[dwLoop];
		delete[] m_pData;
	}
		//set state based on newly allocated block
	m_pData=pNewData;
	m_dwSize=dwNewSize;
	return TRUE;
}

//Set a block of elements in the array

template <class T>
BOOL CAutoArray<T>::SetElements(DWORD dwIndex, const T * pElemData, DWORD dwNumElem)
{
		//calculate the top dwIndex+1 we need to touch
	DWORD dwCeilingIndex=dwIndex+dwNumElem;
	DWORD dwLoop;
		//Are we going to exceed current array size
	if (dwCeilingIndex<=m_dwSize)
	{
			//No=easy case, just set new elements
		for (dwLoop=dwIndex; dwLoop<dwCeilingIndex; dwLoop++)
			m_pData[dwLoop]=*pElemData++;
		return TRUE;
	}
		//need to grow the array, calc size/allocate new array based on the top index
	DWORD dwNewSize=GetArraySize(dwCeilingIndex-1);
	T * pNewData=new T[dwNewSize];
	if (!pNewData)
		return FALSE;
		//copy in new elements. N.B. We have do this now and not leave it to
		//end since elem could be a pointer to our own data. Hence, if we
		//wait we'll either have duff data (if we only copied the elements that
		//will survive) or we'll risk overwriting elements that we've only
		//just copied
	for (dwLoop=dwIndex; dwLoop<dwCeilingIndex; dwLoop++)
		pNewData[dwLoop]=*pElemData++;
		//copy across any old elements, clipping against the block
		//of elements just inserted
	if (m_pData)
	{
		if (dwIndex<m_dwSize)
			m_dwSize=dwIndex;
		for (dwLoop=0; dwLoop<m_dwSize; dwLoop++)
			pNewData[dwLoop]=m_pData[dwLoop];
		delete[] m_pData;
	}
	m_pData=pNewData;
	m_dwSize=dwNewSize;
	return TRUE;
}

//Move a block of elements within the array

template <class T>
BOOL CAutoArray<T>::MoveElements(DWORD dwIndex, DWORD dwNumElements, 
										DWORD dwNewIndex, BOOL bCopySemantics)
{
	DNASSERT(dwIndex+dwNumElements<=m_dwSize);
	DWORD dw;
		//Are we shifting element block down?
	if (dwNewIndex<=dwIndex)
	{
			//Yes=easy case. Just copy elements from bottom up 
		for (dw=0; dw<dwNumElements; dw++)
			m_pData[dwNewIndex+dw]=m_pData[dwIndex+dw];
		return TRUE;
	}
		//New to move element up. Do we need to grow array?
	dw=dwNewIndex+dwNumElements-1;
	if (dw<m_dwSize)
	{
			//No=easy case. Just copy elements top down
		dwNewIndex--;
		dwIndex--;
		for (dw=dwNumElements; dw>0; dw--)
			m_pData[dwNewIndex+dw]=m_pData[dwIndex+dw];
		return TRUE;
	}
		//array does need to grow, so create larger array
	DWORD dwNewSize=GetArraySize(dw);
	T * pNewData=new T[dwNewSize];
	if (!pNewData)
		return FALSE;
	if (m_pData)
	{
			//copy across block of elements below the 
			//block we've got to move
		for (dw=0; dw<dwIndex; dw++)
			pNewData[dw]=m_pData[dw];

			//move the block of elements we were originally
			//asked to move
		for (dw=0; dw<dwNumElements; dw++)
			pNewData[dwNewIndex+dw]=m_pData[dwIndex+dw];
		
			//if we were asked to use copy type semantics
			//then copy across the portion of the moved block
			//that isn't being overwritten in its new position
		if (bCopySemantics)
		{
			for (dw=dwIndex; dw<dwNewIndex; dw++)
				pNewData[dw]=m_pData[dw];
		}

			//move elements above the block we were originally asked
			//to move. This copy needs to be clipped against the bottom
			//of the moved element block.
		if (dwNewIndex<m_dwSize)
			m_dwSize=dwNewIndex;
		for (dw=dwIndex+dwNumElements; dw<m_dwSize; dw++)
			pNewData[dw]=m_pData[dw];

			//release the old array memory
		delete[] m_pData;
	}
	m_pData=pNewData;
	m_dwSize=dwNewSize;
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\autoarray.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       AutoArray.h
 *  Content:	CAutoArray / CAutoPtrArray Declarations
 *
 *  History:
 *   Date		By			Reason
 *   ======		==			======
 *  12-12-2001	simonpow	Created
 ***************************************************************************/


#ifndef __AUTOARRAY_H__
#define __AUTOARRAY_H__

#include "dndbg.h"

/*
 * CAutoArray class
 * Provides automatic memory management for an array. As elements
 * are added to it or moved within it the array will automatically
 * grow to hold them.
 * The growth policy is dictated by a size multiple value, with the
 * array size always being an exact multiple of a pre-defined value.
 * e.g. If the size multiple is set to 32 then possible array sizes
 * are 32, 64, 96, 128, etc.
 * In this scenario setting element 100 on array that is currently
 * only 32 elements big will cause the array to grow to 128 elemments.
 * i.e. The next largest multiple to hold the required value
 *
 * For arrays of pointers use the specialisation CAutoPtrArray
 * declared below CAutoArray
 */

template <class T> class CAutoArray 
{
public:

		//provide the type of entries stored in array 
	typedef T Entry;
	
	/*
	 * Construction and destruction
	 */

		//array is by default zero size, and grows in multiples
		//of 16 elements at a time
	CAutoArray(DWORD dwSizeMultiple=16)
	{
		DNASSERT(dwSizeMultiple);
		m_dwSize=0;
		m_dwSizeMultiple=dwSizeMultiple;
		m_pData=(T * ) 0;
	};

		//delete array and data
	~CAutoArray()
	{
		if (m_pData) 
			delete[] m_pData;
	};
		

	/*
	 * Memory management
	 */

		//resets the array (deleting any allocated data)
		//ands set a new size multiple value.
		//Pass 0 for dwSizeMultiple to leave existing value unchanged
	void Reset(DWORD dwSizeMultiple=16)
	{
		if (dwSizeMultiple)
			m_dwSizeMultiple=dwSizeMultiple;
		m_dwSize=0;
		if (m_pData)
		{
			delete[] m_pData;
			m_pData=(T * ) NULL;
		}
	};

		//ensure the array has space for at least 'numElements'. 
		//This is useful if you know your about to grow the array, as it 
		//allows you to minimise the number of memory allocations
		//Returns FALSE is a memory allocation fails
	BOOL AllocAtLeast(DWORD dwNumElements)
	{
		if (dwNumElements>m_dwSize)
			return GrowToAtLeast(dwNumElements-1);
		return TRUE;
	}
	
		//returns number of bytes currently allocated to array
		//This will always be a multiple of 'dwSizeMultiple' passed to
		//constructor or Reset method
	DWORD GetCurrentSize()
		{	return m_dwSize;	};

	/*
	 * Moving elements
	 */

		//move the block of 'dwNum' elements starting at 'dwIndex' to the 
		//'dwNewIndex'. The new location can be either beyond or before
		//the current index. The array will be grown automatically if needed
		//If 'bCopySemantics' is FALSE then the data in the source block location (dwIndex to
		//dwIndex+dwNumElements) will be left undefined. Otherwise it'll be preserved in
		//its original form (except where/if its overwritten by the destination block).
		//Returns FALSE is a memory allocation fails
	BOOL MoveElements(DWORD dwIndex, DWORD dwNumElements, DWORD dwNewIndex, BOOL bCopySemantics);


	/*
	 * Setting elements
	 */
		
		//set a block of 'dwNumElem' elements starting at 'dwIndex' to the
		//values provided in 'pElemData'. If any of the locations set are
		//beyond the current array size the array will be automatically
		//grown. Returns FALSE is a memory allocation fails
	BOOL SetElements(DWORD dwIndex, const T * pElemData, DWORD dwNumElem);
		
		//set the single element at 'dwIndex' to value 'data'
		//array will automatically grow if necessary
		//Returns FALSE is a memory allocation fails
	BOOL SetElement(DWORD dwIndex, const T& elem)
	{
		if (dwIndex>=m_dwSize && GrowToAtLeast(dwIndex)==FALSE)
			return FALSE;
		m_pData[dwIndex]=elem;
		return TRUE;
	};

		//set the value of an existing element. This doesn't try to 
		//grow array so its up to the caller to ensure dwIndex is in range
	void SetExistingElement(DWORD dwIndex, const T& elem)
		{ DNASSERT(dwIndex<m_dwSize);	m_pData[dwIndex]=elem;	};

		//set the values of 'dwNumElem' elements to 'pElemData' starting
		//from 'dwIndex. This doesn't check if array needs to grow so
		//its left to caller to ensure dwIndex and dwNumElem are in range 
	void SetExistingElements(DWORD dwIndex, const T * pElemData, DWORD dwNumElem);
	

	/*
	 * Getting Elements
	 * Upto the caller to ensure that index's passed in are in range
	 * Array isn't grown just so we can return garbage!
	 * Also note that a pointer/reference into the array can only
	 * be taken temporarily. Setting/moving elements may cause the
	 * array to be reallocated and hence invalidate the pointer/references
	 */ 
	
		//return value of an element
	T GetElementValue(DWORD dwIndex) const
		{	DNASSERT(dwIndex<m_dwSize);	return m_pData[dwIndex];	};

		//return a reference to an element
	T& GetElementRef(DWORD dwIndex)
		{	DNASSERT(dwIndex<m_dwSize);	return m_pData[dwIndex];	};

		//return a constant reference to an element
	const T& GetElementRef(DWORD dwIndex) const
		{	DNASSERT(dwIndex<m_dwSize);	return m_pData[dwIndex];	};

		//return a pointer to an element
	T * GetElementPtr(DWORD dwIndex)
		{	DNASSERT(dwIndex<m_dwSize);	return m_pData+dwIndex;	};
		
		//returns pointer to array of all elements
	T * GetAllElements()
		{	return m_pData;	};

protected:
			
		//make array large so 'dwIndex' falls within its range
		//N.B. Caller must have tested that dwIndex>=m_dwSize already!
	BOOL GrowToAtLeast(DWORD dwIndex);

		//return the size of array needed to hold index, based on current size multiple
	DWORD GetArraySize(DWORD dwIndex)
		{	return ((dwIndex/m_dwSizeMultiple)+1)*m_dwSizeMultiple;	};

		//array of data
	T * m_pData;
		//size of the array of data
	DWORD m_dwSize;
		//multiple for size
	DWORD m_dwSizeMultiple;
};

/*
 * Specialisation of CAutoArray designed for handling pointers.
 * Whatever the type of pointer stored, this class will always
 * use a CAutoArray<void*> underneath, hence ensuring the same
 * code is reused between all CAutoPtrArray types
 */

template <class T> class CAutoPtrArray : public CAutoArray<void *>
{
public:

	typedef T Entry;
	typedef CAutoArray<void *> Base;

	CAutoPtrArray(DWORD dwSizeMultiple=16) : CAutoArray<void * >(dwSizeMultiple)
		{};

	BOOL SetElements(DWORD dwIndex, const T * pElemData, DWORD dwNumElem)
		{	return Base::SetElements(dwIndex, (void **) pElemData, dwNumElem);	};
	
	BOOL SetElement(DWORD dwIndex, T elem)
		{	return Base::SetElement(dwIndex, elem);	};
	
	void SetExistingElement(DWORD dwIndex, T elem)
		{ DNASSERT(dwIndex<m_dwSize);	m_pData[dwIndex]=(void * ) elem;	};

	void SetExistingElements(DWORD dwIndex, const T * pElemData, DWORD dwNumElem)
		{	return Base::SetExistingElements(dwIndex, (void **) pElemData, dwNumElem);	};

	T GetElementValue(DWORD dwIndex) const
		{	DNASSERT(dwIndex<m_dwSize);	return (T) m_pData[dwIndex];	};

	T& GetElementRef(DWORD dwIndex)
		{	DNASSERT(dwIndex<m_dwSize);	return (T&) m_pData[dwIndex];	};
	
	const T& GetElementRef(DWORD dwIndex) const
		{	DNASSERT(dwIndex<m_dwSize);	return (const T&) m_pData[dwIndex];	};

	T * GetElementPtr(DWORD dwIndex)
		{	DNASSERT(dwIndex<m_dwSize);	return (T* ) m_pData+dwIndex;	};
		
	T * GetAllElements()
		{	return (T* ) m_pData;	};
};


/*
 * If not building with explicit template instantiation then
 * include all methods for CAutoArray
 */

#ifndef DPNBUILD_EXPLICIT_TEMPLATES
#include "AutoArray.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\classfactory.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ClassFactory.cpp
 *  Content:	Base ClassFactory implementation
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	07/20/2001	masonb	Created
 *
 ***************************************************************************/

#include "dncmni.h"
#include "fixedpool.h"


#ifndef DPNBUILD_LIBINTERFACE
// Globals
extern CFixedPool g_fpClassFactories;


#undef DPF_MODNAME
#define DPF_MODNAME "DPCF_QueryInterface"
STDMETHODIMP DPCF_QueryInterface(IClassFactory *pInterface, REFIID riid, LPVOID *ppv)
{
	HRESULT hr = S_OK;

	DPFX(DPFPREP, 3,"Parameters: pInterface [0x%p], riid [0x%p], ppv [0x%p]", pInterface, riid, ppv);

	if (riid == IID_IUnknown)
	{
		DPFX(DPFPREP, 5,"riid = IID_IUnknown");
		*ppv = pInterface;
		pInterface->lpVtbl->AddRef( pInterface );
	}
	else if (riid == IID_IClassFactory)
	{
		DPFX(DPFPREP, 5,"riid = IID_IClassFactory");
		*ppv = pInterface;
		pInterface->lpVtbl->AddRef( pInterface );
	}
	else
	{
		DPFX(DPFPREP, 5,"riid not found !");
		*ppv = NULL;
		hr = E_NOINTERFACE;
	}

	DPFX(DPFPREP, 3,"Returning: hResultCode = [%lx], *ppv = [%p]", hr, *ppv);

	return hr;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DPCF_AddRef"
STDMETHODIMP_(ULONG) DPCF_AddRef(IClassFactory *pInterface)
{
	_IDirectPlayClassFactory* pDPClassFactory = (_IDirectPlayClassFactory*) pInterface;

	DPFX(DPFPREP, 3,"Parameters: pInterface [%p], New Ref Count[%d]", pInterface, pDPClassFactory->lRefCount + 1);

	return DNInterlockedIncrement( &pDPClassFactory->lRefCount );
}


#undef DPF_MODNAME
#define DPF_MODNAME "DPCF_Release"

STDMETHODIMP_(ULONG) DPCF_Release(IClassFactory *pInterface)
{
	_IDirectPlayClassFactory* pDPClassFactory = (_IDirectPlayClassFactory*) pInterface;
	LONG lRefCount;

	DPFX(DPFPREP, 3,"Parameters: pInterface [%p], New Ref Count[%d]", pInterface, pDPClassFactory->lRefCount - 1);

	lRefCount = DNInterlockedDecrement( &pDPClassFactory->lRefCount );
	if( lRefCount == 0 )
	{
		DPFX(DPFPREP, 5,"Freeing class factory object: lpcfObj [%p]", pInterface);

		DNInterlockedDecrement(pDPClassFactory->plClassFacObjCount);

		g_fpClassFactories.Release(pDPClassFactory);
	}

	return lRefCount;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPCF_LockServer"
STDMETHODIMP DPCF_LockServer(IClassFactory *pInterface, BOOL fLock)
{
	_IDirectPlayClassFactory* pDPClassFactory = (_IDirectPlayClassFactory*) pInterface;

	DPFX(DPFPREP, 3,"Parameters: lpv [%p], fLock [%lx]", pInterface, fLock);

	if (fLock)
	{
		DNInterlockedIncrement(pDPClassFactory->plClassFacObjCount);
	}
	else
	{
		DNInterlockedDecrement(pDPClassFactory->plClassFacObjCount);
	}

	return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPCFUtil_DllGetClassObject"
HRESULT DPCFUtil_DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv, IClassFactoryVtbl* pVtbl, LONG* plClassFacObjCount)
{
	HRESULT hr = S_OK;
	_PIDirectPlayClassFactory pClassFactory;

	DPFX(DPFPREP, 3,"Parameters: rclsid [%p], riid [%p], ppv [%p]", rclsid, riid, ppv);

	*ppv = NULL;

	// Allocate Class Factory object
	pClassFactory = (_IDirectPlayClassFactory*)g_fpClassFactories.Get();
	if (pClassFactory == NULL)
	{
		DPFERR("Out of memory allocating class factory");
		return E_OUTOFMEMORY;
	}

	DPFX(DPFPREP, 5,"pClassFactory = [%p]",pClassFactory);

	pClassFactory->lpVtbl = pVtbl;
	pClassFactory->lRefCount = 0;
	pClassFactory->clsid = rclsid;
	pClassFactory->plClassFacObjCount = plClassFacObjCount;

	// Query to find the interface
	hr = pClassFactory->lpVtbl->QueryInterface((IClassFactory*)pClassFactory, riid, ppv);
	if (hr != S_OK)
	{
		DPFERR("GetClassObject asked for unknown interface");
		DNFree(pClassFactory);
	}
	else
	{
		DNInterlockedIncrement(plClassFacObjCount);
	}

	DPFX(DPFPREP, 3,"Return: hr = [%lx], *ppv = [%p]", hr, *ppv);

	return hr;
}

#endif // ! DPNBUILD_LIBINTERFACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\classbilink.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ClassBilink.h
 *  Content:	Class-based bilink
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	09/17/99	jtk		Derived from bilink.c
 *	08/15/00	masonb		Changed assert to DNASSERT and added DNASSERT(this)
 *
 ***************************************************************************/

#ifndef __CLASS_BILINK_H__
#define __CLASS_BILINK_H__

#include "dndbg.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_COMMON

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifndef	CONTAINING_OBJECT
#define CONTAINING_OBJECT(address, type, field) ((type *)( \
                                                  (PCHAR)(address) - \
                                                  (UINT_PTR)(&((type *)0)->field)))
#endif // CONTAINING_OBJECT

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function Prototypes
//**********************************************************************

//**********************************************************************
// Class definitions
//**********************************************************************

class	CBilink
{
public:
	CBilink(){};
	~CBilink(){};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CBilink::Initialize"
	void	Initialize( void )
	{
		DNASSERT( this != NULL );

		m_pNext = this;
		m_pPrev = this;
	}

	#undef DPF_MODNAME
	#define DPF_MODNAME "CBilink::GetNext"
	CBilink	*GetNext( void ) const 
	{ 
		DNASSERT( this != NULL );

		return m_pNext; 
	}

	#undef DPF_MODNAME
	#define DPF_MODNAME "CBilink::GetPrev"
	CBilink *GetPrev( void ) const 
	{ 
		DNASSERT( this != NULL );

		return m_pPrev; 
	}

	#undef DPF_MODNAME
	#define DPF_MODNAME "CBilink::IsEmpty"
	BOOL	IsEmpty( void ) const
	{
		DNASSERT( this != NULL );
		DNASSERT( m_pNext != NULL );

		if ( ( m_pNext == m_pPrev ) &&
			 ( m_pNext == this ) )
		{
			return	TRUE;
		}

		return	FALSE;
	}

	#undef DPF_MODNAME
	#define DPF_MODNAME "CBilink::IsListMember"
	BOOL	IsListMember( const CBilink *const pList ) const
	{
		CBilink *	pTemp;


		DNASSERT( this != NULL );
		DNASSERT( pList != NULL );

		pTemp = pList->GetNext();
		while ( pTemp != pList )
		{
			if ( pTemp == this )
			{
				return	TRUE;
			}
			pTemp = pTemp->GetNext();
		}

		return	FALSE;
	}

	#undef DPF_MODNAME
	#define DPF_MODNAME "CBilink::InsertAfter"
	void	InsertAfter( CBilink* const pList )
	{
		DNASSERT( this != NULL );
		DNASSERT( pList->m_pNext != NULL );
		DNASSERT( pList->m_pPrev != NULL );
		DNASSERT( !IsListMember( pList ) );
		DNASSERT( IsEmpty() );

		m_pNext = pList->m_pNext;
		m_pPrev = pList;
		pList->m_pNext->m_pPrev = this;
		pList->m_pNext = this;
	}

	#undef DPF_MODNAME
	#define DPF_MODNAME "CBilink::InsertBefore"
	void	InsertBefore( CBilink* const pList )
	{
		DNASSERT( this != NULL );
		DNASSERT( pList->m_pNext != NULL );
		DNASSERT( pList->m_pPrev != NULL );
		DNASSERT( !IsListMember( pList ) );
		DNASSERT( IsEmpty() );

		m_pNext = pList;
		m_pPrev = pList->m_pPrev;
		pList->m_pPrev->m_pNext = this;
		pList->m_pPrev = this;
	}

	#undef DPF_MODNAME
	#define DPF_MODNAME "CBilink::RemoveFromList"
	void	RemoveFromList( void )
	{
		DNASSERT( this != NULL );
		DNASSERT( m_pNext != NULL );
		DNASSERT( m_pPrev != NULL );
		DNASSERT( m_pNext->m_pPrev == this );
		DNASSERT( m_pPrev->m_pNext == this );

		m_pNext->m_pPrev = m_pPrev;
		m_pPrev->m_pNext = m_pNext;
		Initialize();
	}

private:
	CBilink	*m_pNext;
	CBilink	*m_pPrev;
};

#undef DPF_MODNAME
#undef DPF_SUBCOMP

#endif	// __CLASS_BILINK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\bagarray.inl ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       BagArray.inl
 *  Content:	CBagArray methods
 *
 *  History:
 *   Date		By			Reason
 *   ======		==			======
 *  12-12-2001	simonpow	Created
 ***************************************************************************/


template <class T>
BOOL CBagArray<T>::AddElements(const T * pElems, DWORD dwNumElem)
{
		//ensure pointer passed isn't into this bags contents!
	DNASSERT(!(pElems>=m_data.GetAllElements() && pElems<m_data.GetAllElements()+m_data.GetCurrentSize()));
	if (!m_data.AllocAtLeast(m_dwTopFreeSlot+dwNumElem))
		return FALSE;
	for (DWORD dwLoop=0; dwLoop<dwNumElem; dwLoop++)
		m_data.SetExistingElement(dwLoop+m_dwTopFreeSlot, pElems[dwLoop]);
	m_dwTopFreeSlot+=dwNumElem;
	return TRUE;
}

template <class T>	
BOOL CBagArray<T>::AddElements(const CBagArray<T>& bag)
{
		//ensure bag supplied isn't this bag
	DNASSERT(this!=&bag);
	if (!m_data.AllocAtLeast(m_dwTopFreeSlot+bag.GetNumElements()))
		return FALSE;
	for (DWORD dwLoop=0; dwLoop<bag.GetNumElements(); dwLoop++)
		m_data.SetExistingElement(dwLoop+m_dwTopFreeSlot, bag.GetElementRef(dwLoop));
	m_dwTopFreeSlot+=bag.GetNumElements();
	return TRUE;
}

template <class T>
BOOL CBagArray<T>::RemoveElementByValue(const T& elem)
{
	for (DWORD dwLoop=0; dwLoop<m_dwTopFreeSlot; dwLoop++)
	{
		if (m_data.GetElementRef(dwLoop)==elem)
		{
			m_dwTopFreeSlot--;
			if (dwLoop!=m_dwTopFreeSlot)
				m_data.SetExistingElement(dwLoop, m_data.GetElementRef(m_dwTopFreeSlot));
			return TRUE;
		}
	}
	return FALSE;
}

template <class T>
BOOL CBagArray<T>::FindElement(const T& elem, DWORD * pdwIndex) const
{
	for (DWORD dwLoop=0; dwLoop<m_dwTopFreeSlot; dwLoop++)
	{
		if (m_data.GetElementRef(dwLoop)==elem)
		{
			*pdwIndex=dwLoop;
			return TRUE;
		}
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\classfactory.h ===
/*==========================================================================
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ClassFactory.h
 *  Content:	Base ClassFactory implementation
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	07/20/2001	masonb	Created
 *
 ***************************************************************************/

#ifndef __CLASS_FACTORY_H__
#define __CLASS_FACTORY_H__


#ifdef DPNBUILD_LIBINTERFACE

#define GET_OBJECT_FROM_INTERFACE(a)	(a)

#else // ! DPNBUILD_LIBINTERFACE

/*==========================================================================
 *
 * Instructions for use:
 * 
 * 1) Declare an object count variable: LONG g_lLobbyObjectCount = 0;
 * 2) Implement a standard IClassFactory::CreateInstance function capable of
 *    creating your object.
 * 3) Declare a VTBL variable: IClassFactoryVtbl DN_MyVtbl = 
 *        {DPCF_QueryInterface, DPCF_AddRef, DPCF_Release, <Your CreateInstance func>, DPCF_LockServer};
 * 4) In DllGetClassObject, call DPCFUtil_DllGetClassObject passing appropriate parameters
 * 5) In DllCanUnloadNow return S_OK if your object count variable is zero, or S_FALSE if it isn't
 *
 ***************************************************************************/


//**********************************************************************
// Class Factory definitions
//**********************************************************************

typedef struct _IDirectPlayClassFactory 
{	
	IClassFactoryVtbl	*lpVtbl;		// lpVtbl Must be first element (to match external imp.)
	LONG				lRefCount;
	CLSID				clsid;
	LONG*				plClassFacObjCount;
} _IDirectPlayClassFactory, *_PIDirectPlayClassFactory;

STDMETHODIMP DPCF_QueryInterface(IClassFactory* pInterface, REFIID riid, LPVOID *ppv);
STDMETHODIMP_(ULONG) DPCF_AddRef(IClassFactory*  pInterface);
STDMETHODIMP_(ULONG) DPCF_Release(IClassFactory*  pInterface);
STDMETHODIMP DPCF_LockServer(IClassFactory *pInterface, BOOL fLock);

HRESULT DPCFUtil_DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv, IClassFactoryVtbl* pVtbl, LONG* plClassFacObjCount);

//**********************************************************************
// COM Object definitions
//**********************************************************************

extern CFixedPool g_fpInterfaceLists;
extern CFixedPool g_fpObjectDatas;

#define GET_OBJECT_FROM_INTERFACE(a)	((INTERFACE_LIST*)(a))->pObject->pvData

struct _INTERFACE_LIST;
struct _OBJECT_DATA;

typedef struct _INTERFACE_LIST 
{
	void			*lpVtbl;
	LONG			lRefCount;
	IID				iid;
	_INTERFACE_LIST	*pIntNext;
	_OBJECT_DATA	*pObject;
} INTERFACE_LIST, *LPINTERFACE_LIST;

typedef struct _OBJECT_DATA 
{
	LONG			lRefCount;
	void			*pvData;
	_INTERFACE_LIST	*pIntList;
} OBJECT_DATA, *LPOBJECT_DATA;

#endif // ! DPNBUILD_LIBINTERFACE

#endif // __CLASS_FACTORY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\comutil.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       comutil.h
 *  Content:    Defines COM helper functions for DPLAY8 project.
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   06/07/00	rmt		Created
 *   06/27/00	rmt		Added abstraction for COM_Co(Un)Initialize
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef DPNBUILD_NOCOMEMULATION

HRESULT COM_Init();
HRESULT COM_CoInitialize( void * pvParam );
void COM_CoUninitialize();
void COM_Free();
STDAPI COM_CoCreateInstance( REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, REFIID riid, LPVOID *ppv, BOOL fWarnUser );

#else

#define COM_Init() S_OK
#define COM_CoInitialize(x) CoInitializeEx(NULL, COINIT_MULTITHREADED)
#define COM_CoUninitialize() CoUninitialize();
#define COM_Free() 
#define COM_CoCreateInstance(rclsid, pUnkOuter, dwClsContext, riid, ppv, warnuser ) CoCreateInstance(rclsid, pUnkOuter, dwClsContext, riid, ppv)

#endif // DPNBUILD_NOCOMEMULATION
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\comutil.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       comutil.cpp
 *  Content:    Contains implementation of COM helper functions for DPLAY8 project.
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   06/07/00	rmt		Created
 *   06/15/2000 rmt     Fixed small bug in COM_CoCreateInstance which was causing AV
 *   06/27/00	rmt		Added abstraction for COM_Co(Un)Initialize
 *   07/06/00	rmt		Modified to match updated creg usage
 *   08/08/2000	rmt		Bug #41736 - AV in call to lstrcpy by COM_GetDllName
 *   01/11/2001	rmt		MANBUG #48487 - DPLAY: Crashes if CoCreate() isn't called.  
 *   03/14/2001 rmt		WINBUG #342420 - Restore COM emulation layer to operation.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncmni.h"
#include "comutil.h"

#ifndef DPNBUILD_NOCOMEMULATION


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_COMMON

HRESULT COM_GetDLLName( const GUID* pguidCLSID, TCHAR *szPath, DWORD *pdwSizeInBytes );

typedef HRESULT (WINAPI *PFNDLLGETCLASSOBJECT)(REFCLSID rclsid,REFIID riid,LPVOID *ppvObj );
typedef HRESULT (WINAPI *PFNDLLCANUNLOADNOW)(void);

CBilink g_blComEntriesGlobal;
DNCRITICAL_SECTION csComEntriesLock;

typedef struct _COMDLL_ENTRY
{
    HMODULE                 hDLL;
    TCHAR                   szFileName[_MAX_PATH];
    GUID                    clsid;
    PFNDLLGETCLASSOBJECT    pfnGetClassObject;
    PFNDLLCANUNLOADNOW      pfnCanUnloadNow;
    CBilink                 blComEntries;
} COMDLL_ENTRY, *PCOMDLL_ENTRY;

#undef DPF_MODNAME
#define DPF_MODNAME "COM_Init"
HRESULT COM_Init()
{
    g_blComEntriesGlobal.Initialize();
    if (DNInitializeCriticalSection( &csComEntriesLock ) == FALSE)
	{
		return DPNERR_OUTOFMEMORY;
	}
    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "COM_Free"
void COM_Free()
{
    CBilink *pblSearch;
    PCOMDLL_ENTRY pEntry;

    pblSearch = g_blComEntriesGlobal.GetNext();

    while( pblSearch != &g_blComEntriesGlobal )
    {
        pEntry = CONTAINING_OBJECT( pblSearch, COMDLL_ENTRY, blComEntries );
        pblSearch = pblSearch->GetNext();

        FreeLibrary( pEntry->hDLL );
        DNFree(pEntry);
    }

    DNDeleteCriticalSection( &csComEntriesLock );
}

#undef DPF_MODNAME
#define DPF_MODNAME "COM_CoInitialize"
HRESULT COM_CoInitialize( void * pvParam )
{
	return CoInitializeEx( pvParam, COINIT_MULTITHREADED );
}

#undef DPF_MODNAME
#define DPF_MODNAME "COM_CoUninitialize"
void COM_CoUninitialize()
{
	CoUninitialize();
}

#undef DPF_MODNAME
#define DPF_MODNAME "COM_GetEntry"
HRESULT COM_GetEntry( const GUID* pclsid, PCOMDLL_ENTRY *ppEntry )
{
    CBilink *pblSearch;
    PCOMDLL_ENTRY pEntry;
    HRESULT hr;
    DWORD dwSize;

    DNEnterCriticalSection( &csComEntriesLock );

    pblSearch = g_blComEntriesGlobal.GetNext();

    while( pblSearch != &g_blComEntriesGlobal )
    {
        pEntry = CONTAINING_OBJECT( pblSearch, COMDLL_ENTRY, blComEntries );

        // This should never happen, but makes prefix happy
        if( !pEntry )
        {
            DNASSERT( FALSE );
            DNLeaveCriticalSection( &csComEntriesLock );
            return DPNERR_GENERIC;
        }

        if( pEntry->clsid == *pclsid )
        {
            *ppEntry = pEntry;
            DNLeaveCriticalSection( &csComEntriesLock );
            return DPN_OK;
        }

        pblSearch = pblSearch->GetNext();
    }

    pEntry = (COMDLL_ENTRY*) DNMalloc(sizeof(COMDLL_ENTRY));
    if (pEntry == NULL)
    {
        DPFERR( "Error allocating COM entry" );
        hr = DPNERR_OUTOFMEMORY;
        goto LOAD_FAILED;
    }
    memset( pEntry, 0x00, sizeof( COMDLL_ENTRY ) );

    pEntry->clsid = *pclsid;
    pEntry->blComEntries.Initialize();

    dwSize = _MAX_PATH * sizeof(TCHAR);

    hr = COM_GetDLLName( pclsid, pEntry->szFileName, &dwSize );
    if( FAILED( hr ) )
    {
        DPFERR( "Unable to find DLL name for COM object" );
        goto LOAD_FAILED;
    }

    pEntry->hDLL = LoadLibrary( pEntry->szFileName );
    if( !pEntry->hDLL )
    {
#ifdef DBG
        hr = GetLastError();
        DPFX(DPFPREP,  0, "Unable to load libary err=0x%x", hr );
#endif // DBG
        hr = DPNERR_GENERIC;
        goto LOAD_FAILED;
    }

    pEntry->pfnGetClassObject = (PFNDLLGETCLASSOBJECT) GetProcAddress( pEntry->hDLL, _TWINCE("DllGetClassObject") );
    if (pEntry->pfnGetClassObject == NULL)
    {
#ifdef DBG
        hr = GetLastError();
        DPFX(DPFPREP,  0, "Unable to get \"DllGetClassObject\" function pointer err=0x%x", hr );
#endif // DBG
        hr = DPNERR_GENERIC;
        goto LOAD_FAILED;
    }
    
    pEntry->pfnCanUnloadNow = (PFNDLLCANUNLOADNOW) GetProcAddress( pEntry->hDLL, _TWINCE("DllCanUnloadNow") );
    if (pEntry->pfnCanUnloadNow == NULL)
    {
#ifdef DBG
        hr = GetLastError();
        DPFX(DPFPREP,  0, "Unable to get \"DllCanUnloadNow\" function pointer err=0x%x", hr );
#endif // DBG
        hr = DPNERR_GENERIC;
        goto LOAD_FAILED;
    }
    

    pEntry->blComEntries.InsertBefore( &g_blComEntriesGlobal );

    DNLeaveCriticalSection( &csComEntriesLock );

    *ppEntry = pEntry;

    return DPN_OK;

LOAD_FAILED:

    if( pEntry != NULL )
    {
        if( pEntry->hDLL != NULL )
        {
            FreeLibrary( pEntry->hDLL );
        }

        DNFree(pEntry);
    }

    DNLeaveCriticalSection( &csComEntriesLock );

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "COM_GetDLLName"
HRESULT COM_GetDLLName( const GUID* pguidCLSID, TCHAR *szPath, DWORD *pdwSizeInBytes )
{
    CRegistry cregRoot;
    CRegistry cregCLSID;
    CRegistry cregInProc;

    HRESULT hr = DPN_OK;
    BOOL fSuccess;
    WCHAR *wszTmpPath = NULL;
    DWORD dwTmpSize = 0;

    fSuccess = cregRoot.Open( HKEY_CLASSES_ROOT, L"CLSID", TRUE, FALSE );

    if( !fSuccess )
    {
        DPFX(DPFPREP,  0, "Error opening HKEY_CLASSES_ROOT\\CLSID" );
        hr = E_FAIL;
        goto COM_GETDLLNAME_ERROR;
    }

    fSuccess = cregCLSID.Open( cregRoot, pguidCLSID, TRUE, FALSE );

    if( !fSuccess )
    {
        DPFX(DPFPREP,  0, "Error opening specified CLSID" );
        hr = E_FAIL;
        goto COM_GETDLLNAME_ERROR;
    }

    fSuccess = cregInProc.Open( cregCLSID, L"InprocServer32", TRUE, FALSE );

    if( !fSuccess )
    {
        DPFX(DPFPREP,  0, "Error opening inprocserver key" );
        hr = E_FAIL;
        goto COM_GETDLLNAME_ERROR;
    }

    cregCLSID.Close();
    cregRoot.Close();

    fSuccess = cregInProc.ReadString( L"", wszTmpPath, &dwTmpSize );

    if( !dwTmpSize )
    {
        DPFX(DPFPREP,  0, "Error opening default key" );
        hr = E_FAIL;
        goto COM_GETDLLNAME_ERROR;
    }

    if( dwTmpSize > *pdwSizeInBytes )
    {
    	DPFX(DPFPREP,  0, "Buffer too small" );
    	hr = DPNERR_BUFFERTOOSMALL;
    	*pdwSizeInBytes = dwTmpSize;
    	goto COM_GETDLLNAME_ERROR;
    }

    *pdwSizeInBytes = dwTmpSize;

    if (!szPath)
    {
    	DPFX(DPFPREP,  0, "Invalid param - NULL szPath" );
    	hr = DPNERR_INVALIDPARAM;
    	goto COM_GETDLLNAME_ERROR;
    }

#ifdef UNICODE
    wszTmpPath = szPath;
#else
    wszTmpPath = (WCHAR*) DNMalloc(dwTmpSize * sizeof(WCHAR));

    if( !wszTmpPath )
    {
        DPFX(DPFPREP,  0, "Error allocating memory" );
        hr = DPNERR_OUTOFMEMORY;
        goto COM_GETDLLNAME_ERROR;
    }
#endif // UNICODE

    fSuccess = cregInProc.ReadString( L"", wszTmpPath, &dwTmpSize );

    if( !fSuccess )
    {
        DPFX(DPFPREP,  0, "Error opening default key" );
        hr = E_FAIL;
        goto COM_GETDLLNAME_ERROR;
    }

#ifndef UNICODE
    if( FAILED( hr = STR_jkWideToAnsi(szPath,wszTmpPath, *pdwSizeInBytes ) ) )
    {
        DPFX(DPFPREP,  0, "Error converting path to DLL to ANSI hr=0x%x", hr );
        hr = E_FAIL;
    }

    DNFree(wszTmpPath);
#endif // !UNICODE

    return hr;

COM_GETDLLNAME_ERROR:

#ifndef UNICODE
    if( wszTmpPath )
    {
        DNFree(wszTmpPath);
    }
#endif // !UNICODE

    return hr;

}


// DP_CoCreateInstance
//
// This CoCreateInstance can be used instead of CoCreateInstance and will manually perform the
// steps neccessary to do a CoCreateInstance if COM has not been initialized.
//
#undef DPF_MODNAME
#define DPF_MODNAME "COM_CoCreateInstance"
STDAPI COM_CoCreateInstance( REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, REFIID riid, LPVOID *ppv, BOOL fWarnUser )
{
    HRESULT hr;
    PCOMDLL_ENTRY pEntry;
    IClassFactory *pClassFactory;

    hr = CoCreateInstance( rclsid, pUnkOuter, dwClsContext, riid, ppv );

    if( hr == CO_E_NOTINITIALIZED )
    {
    	if( fWarnUser )
    	{
    		DPFX(DPFPREP, 0, "=====================================================================================" );
    		DPFX(DPFPREP, 0, "" );
    		DPFX(DPFPREP, 0, "The DirectPlay8/Voice create functions are no longer supported.  It is recommended" );
    		DPFX(DPFPREP, 0, "that your application be updated to use CoCreateInstance instead." );
     		DPFX(DPFPREP, 0, "" );    		
    		DPFX(DPFPREP, 0, "=====================================================================================" );    			
    	}
    	
        hr = COM_GetEntry( &rclsid, &pEntry );

        if( FAILED( hr ) )
            return hr;

        hr = (*pEntry->pfnGetClassObject)( rclsid, IID_IClassFactory, (void **) &pClassFactory );

        if( FAILED( hr ) )
        {
            DPFX(DPFPREP,  0, "Failed getting class object on dynamic entry hr=0x%x", hr );
            return hr;
        }


        hr = pClassFactory->lpVtbl->CreateInstance( pClassFactory, pUnkOuter, riid, ppv );

        if( FAILED( hr ) )
        {
            DPFX(DPFPREP,  0, "Class factory returned an error hr=0x%x", hr );
        }

        pClassFactory->lpVtbl->Release(pClassFactory);

        return hr;

    } 

    return hr;
}

#endif // !DPNBUILD_NOCOMEMULATION
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\creg.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		creg.cpp
 *  Content:	
 *			This module contains the implementation of the CRegistry class.
 *			For a class description, see creg.h
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	07/16/99	rodtoll	Created
 *	08/18/99	rodtoll	Added Register/UnRegister that can be used to
 *						allow COM objects to register themselves.
 *	08/25/99	rodtoll	Updated to provide read/write of binary (blob) data
 *	10/05/99	rodtoll	Added DPF_MODNAMEs
 *	10/07/99	rodtoll	Updated to work in Unicode
 *	10/08/99	rodtoll	Fixes to DeleteKey / Reg/UnReg for Win9X
 *	10/15/99	rodtoll	Plugged some memory leaks
 *	10/27/99	pnewson	added Open() call that takes a GUID
 *	01/18/00	mjn		Added GetMaxKeyLen function
 *	01/24/00	mjn		Added GetValueSize function
 * 	01/24/00	rodtoll	Fixed error handling for ReadString (Unicode version)
 * 	04/21/2000 	rodtoll Bug #32889 - Does not run on Win2k on non-admin account 
 *             	rodtoll Bug #32952 - Does not run on Win95 GOLD w/o IE4 -- modified
 *                     	to allow reads of REG_BINARY when expecting REG_DWORD
 *	05/02/00	mjn		Changed CRegistry::Open() to use KEY_READ when Create set to FALSE
 *  06/08/00    rmt     Updated to use common string utils
 *  07/06/00	rmt		Modified to allow seperate read/write parameter
 * 	07/09/2000	rodtoll	Added signature bytes 
 *  07/21/00	rmt		Fixed a memory leak
 *  08/08/2000	rmt		Bug #41736 - AV in call to lstrcpy by COM_GetDllName 
 *	08/28/2000	masonb	Voice Merge: Modified platform checks to use osind.cpp layer
 *  08/30/2000	rodtoll	Bug #171822 - PREFIX Bug
 *  04/13/2001	VanceO	Moved granting registry permissions into common, and
 *						added DeleteValue and EnumValues.
 *  06/19/2001  RichGr  DX8.0 added special security rights for "everyone" - remove them if
 *                      they exist with new RemoveAllAccessSecurityPermissions() method.
 ***************************************************************************/

#include "dncmni.h"


#ifndef DPNBUILD_NOREGISTRY


#ifdef WINNT

// Security function prototypes

typedef BOOL (*PALLOCATEANDINITIALIZESID)(
  PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, // authority
  BYTE nSubAuthorityCount,                        // count of subauthorities
  DWORD dwSubAuthority0,                          // subauthority 0
  DWORD dwSubAuthority1,                          // subauthority 1
  DWORD dwSubAuthority2,                          // subauthority 2
  DWORD dwSubAuthority3,                          // subauthority 3
  DWORD dwSubAuthority4,                          // subauthority 4
  DWORD dwSubAuthority5,                          // subauthority 5
  DWORD dwSubAuthority6,                          // subauthority 6
  DWORD dwSubAuthority7,                          // subauthority 7
  PSID *pSid                                      // SID
);

typedef VOID (*PBUILDTRUSTEEWITHSID)(
  PTRUSTEE pTrustee,  // structure
  PSID pSid           // trustee name
);

typedef DWORD (*PSETENTRIESINACL)(
  ULONG cCountOfExplicitEntries,           // number of entries
  PEXPLICIT_ACCESS pListOfExplicitEntries, // buffer
  PACL OldAcl,                             // original ACL
  PACL *NewAcl                             // new ACL
);

typedef DWORD (*PSETSECURITYINFO)(
  HANDLE handle,                     // handle to object
  SE_OBJECT_TYPE ObjectType,         // object type
  SECURITY_INFORMATION SecurityInfo, // buffer
  PSID psidOwner,                    // new owner SID
  PSID psidGroup,                    // new primary group SID
  PACL pDacl,                        // new DACL
  PACL pSacl                         // new SACL
);

typedef PVOID (*PFREESID)(
  PSID pSid   // SID to free
);

#endif // WINNT


#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::CRegistry"
// CRegistry Constructor
//
// This is the default constructor for the registry class.  It
// is used to construct a registry object which has not yet
// opened a handle to the registry.  Open must be called before
// this object can be used.
//
// Parameters:
// N/A
//
// Returns:
// N/A
//
CRegistry::CRegistry( ): m_isOpen(FALSE), m_dwSignature(VSIG_CREGISTRY)
{
}

// CRegistry Destructor
//
// This is the destructor for the class, and will close the connection
// to the registry if this object has one open.
//
// Parameters:
// N/A
//
// Returns:
// N/A
//
CRegistry::~CRegistry() 
{
	if( m_isOpen ) 
	{
		Close();
	}

	m_dwSignature = VSIG_CREGISTRY_FREE;
}

// DeleteSubKey
//
// This function causes the key specified by the string equivalent of
// the pGuidName parameter to be deleted from the point in the registry
// this object is rooted at, if the key exists.  If the object does not
// have an open connection to the registry, or the keyName is not specified
//
// Parmaters:
// const GUID *pGuidName - GUID whose equivalent string needs to be deleted
//
// Returns:
// BOOL - returns TRUE on success, FALSE on failure
//
BOOL CRegistry::DeleteSubKey( const GUID *pGuidName )
{

   	WCHAR wszGuidString[GUID_STRING_LEN];
	
	DNASSERT( pGuidName != NULL );

	// convert the guid to a string
	if(!StringFromGUID2(*pGuidName, wszGuidString, GUID_STRING_LEN))
	{
		DPFX(DPFPREP, 0, "StringFromGUID2 failed");
		return FALSE;
	}

	return DeleteSubKey(wszGuidString);
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::DeleteSubKey"
// DeleteSubKey
//
// This function causes the key specified by the keyName parameter
// to be deleted from the point in the registry this object is rooted
// at, if the key exists.  If the object does not have an open connection
// to the registry, or the keyName is not specified, FALSE is returned
//
// Parmaters:
// const TCHAR *keyName - key name to delete
//
// Returns:
// BOOL - returns TRUE on success, FALSE on failure
//
BOOL CRegistry::DeleteSubKey( const LPCWSTR keyName ) 
{

	if( keyName == NULL || !IsOpen() ) 
	{
		return FALSE;
	}

	LONG	retValue;
	
#ifdef UNICODE
	retValue = RegDeleteKeyW( m_regHandle, keyName );
#else
	LPSTR lpstrKeyName;

	if( FAILED( STR_AllocAndConvertToANSI( &lpstrKeyName, keyName ) ) )
	{
		return FALSE;
	}
	else
	{
		retValue = RegDeleteKeyA( m_regHandle, lpstrKeyName );

		DNFree(lpstrKeyName);
	}
#endif // UNICODE
	return (retValue == ERROR_SUCCESS);
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::DeleteValue"
// DeleteValue
//
// This function causes the value specified by the valueName parameter
// to be deleted from the point in the registry this object is rooted
// at, if the value exists.  If the object does not have an open connection
// to the registry, or the valueName is not specified, FALSE is returned
//
// Parmaters:
// const TCHAR *keyName - key name to delete
//
// Returns:
// BOOL - returns TRUE on success, FALSE on failure
//
BOOL CRegistry::DeleteValue( const LPCWSTR valueName ) 
{

	if( valueName == NULL || !IsOpen() ) return FALSE;

	LONG	retValue;
	
#ifdef UNICODE
	retValue = RegDeleteValueW( m_regHandle, valueName );
#else
	LPSTR lpstrValueName;

	if( FAILED( STR_AllocAndConvertToANSI( &lpstrValueName, valueName ) ) )
	{
		return FALSE;
	}
	else
	{
		retValue = RegDeleteValueA( m_regHandle, lpstrValueName );

		DNFree(lpstrValueName);
	}
#endif // UNICODE

	return (retValue == ERROR_SUCCESS);
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::Open"
// Open
//
// This function opens a connection to the registry in the branch
// specified by branch with the path specified by pathName.  If
// the path doesn't exist in the registry it will be created if
// the create parameters is set to true, otherwise the call will
// fail.
//
// If this object already has an open connection to the registry
// the previous connection will be closed before this one is
// attempted.
//
// Parameters:
// HKEY branch - A handle to a registry location where the open
//               will be rooted.  E.g. HKEY_LOCAL_MACHINE
// const TCHAR *path - The path relative to the root specified by
//                    branch where the registry connection will
//                    be opened.
// BOOL create - Settings this parameter conrols how this function
//               handles opens on paths which don't exists.  If set
//               to TRUE the path will be created, if set to FALSE
//               the function will fail if the path doesn't exist.
//
// Returns:
// BOOL - TRUE on success, FALSE on failure.
//
BOOL CRegistry::Open( HKEY branch, const LPCWSTR pathName, BOOL fReadOnly, BOOL create, BOOL fCustomSAM, REGSAM samCustom ) 
{

	DWORD	dwResult;	// Temp used in call to RegXXXX
	LONG	result;		// used to store results

	if( pathName == NULL )
		return FALSE;

	// If there is an open connection, close it.
	if( m_isOpen ) 
	{
		Close();
	}

	m_fReadOnly = fReadOnly;

#ifdef UNICODE
	// Create or open the key based on create parameter
	if( create ) 
	{
		result = RegCreateKeyExW( branch, pathName, 0, NULL, REG_OPTION_NON_VOLATILE, (fCustomSAM) ? samCustom : KEY_ALL_ACCESS,
				                 NULL, &m_regHandle, &dwResult );
	} 
	else 
	{
		result = RegOpenKeyExW( branch, pathName, 0, (fReadOnly) ? KEY_READ : ((fCustomSAM) ? samCustom : KEY_ALL_ACCESS), &m_regHandle );
	}
#else
	LPSTR lpszKeyName;

	if( STR_AllocAndConvertToANSI( &lpszKeyName, pathName ) == S_OK && pathName )
	{
		if( create ) 
		{
			result = RegCreateKeyExA( branch, lpszKeyName, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
					                 NULL, &m_regHandle, &dwResult );
		} 
		else 
		{
			result = RegOpenKeyExA( branch, lpszKeyName, 0, (fReadOnly) ? KEY_READ : KEY_ALL_ACCESS, &m_regHandle );
		}

		DNFree(lpszKeyName);
	}
	else
	{
		return FALSE;
	}
#endif // UNICODE

	// If succesful, initialize object, otherwise set it to
	// not open state.
	if( result == ERROR_SUCCESS ) 
	{
		m_isOpen	 = TRUE;
		m_baseHandle = branch;
		return TRUE;

	} 
	else 
	{
		m_isOpen = FALSE;
		return FALSE;
	}

}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::Open"
// Open
//
// This function opens a connection to the registry in the branch
// specified by branch with the path specified by pathName.  If
// the path doesn't exist in the registry it will be created if
// the create parameters is set to true, otherwise the call will
// fail.
//
// In this version of the function, the path is specified as
// a guid instead of a string. The function will attempt to open
// a key with a name in the form "{CB4961DB-D2FA-43f3-942A-991D9294DDBB}"
// that corresponds to the guid as you would expect.
//
// If this object already has an open connection to the registry
// the previous connection will be closed before this one is
// attempted.
//
// Parameters:
// HKEY branch - A handle to a registry location where the open
//               will be rooted.  E.g. HKEY_LOCAL_MACHINE
// const LPGUID lpguid - The path relative to the root specified by
//                    branch where the registry connection will
//                    be opened. See comment above.
// BOOL create - Settings this parameter conrols how this function
//               handles opens on paths which don't exists.  If set
//               to TRUE the path will be created, if set to FALSE
//               the function will fail if the path doesn't exist.
//
// Returns:
// BOOL - TRUE on success, FALSE on failure.
//
BOOL CRegistry::Open( HKEY branch, const GUID* lpguid, BOOL fReadOnly, BOOL create, BOOL fCustomSAM, REGSAM samCustom ) 
{
	WCHAR wszGuidString[GUID_STRING_LEN];
	
	DNASSERT( lpguid != NULL );

	// convert the guid to a string
	if (!StringFromGUID2(*lpguid, wszGuidString, GUID_STRING_LEN))
	{
		DPFX(DPFPREP, 0, "StringFromGUID2 failed");
		return FALSE;
	}

	return Open(branch, wszGuidString, fReadOnly, create, fCustomSAM, samCustom);
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::Close"
// Close
//
// This function will close an open connection to the registry
// if this object has one.  Otherwise it does nothing.
//
// Parameters:
// N/A
//
// Returns:
// BOOL - Returns TRUE on success, FALSE on failure.  If the object
//        is not open it will return TRUE.
//
BOOL CRegistry::Close() 
{

	LONG retValue;

	if( m_isOpen ) 
	{
		retValue = RegCloseKey( m_regHandle );
        if( retValue == ERROR_SUCCESS )
        {
            m_isOpen = FALSE;
            return TRUE;
        }
        else
        {
            return FALSE;
        }
	} 
	else 
	{
		return TRUE;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::EnumKeys"
// EnumKeys
//
// This function can be used to enumerate the keys at the point
// in the registry rooted at the root this object was opened
// with, at the path specified when opening the object.
//
// To properly enumerate the keys you should pass 0 as the index on
// the first call, and increment the index parameter by one on each
// call.  You can stop enumerating when the function returns FALSE.
//
// Parameters:
// LPWSTR lpwStrName - The current key in the enumeration will be returned
//                 in this string.  Unless the enumeration fails or
//                 ended at which case this parameter won't be touched.
//
// LPDWORD lpdwStringLen - pointer to length of string buffer, or place to
//						to store size required.
//
// DWORD index - The current enum index.  See above for details.
//
// Returns:
// BOOL - FALSE when enumeration is done or on error, TRUE otherwise.
//
BOOL CRegistry::EnumKeys( LPWSTR lpwStrName, LPDWORD lpdwStringLen, DWORD index )
{
#ifdef UNICODE
	wchar_t buffer[MAX_REGISTRY_STRING_SIZE];
	DWORD   bufferSize = MAX_REGISTRY_STRING_SIZE;
	FILETIME tmpTime;

	if( RegEnumKeyExW( m_regHandle, index, buffer, &bufferSize, NULL, NULL, NULL, &tmpTime ) != ERROR_SUCCESS )
	{
	    return FALSE;
	}
	else
	{
	    if( bufferSize+1 > *lpdwStringLen  )
	    {
	    	*lpdwStringLen = bufferSize+1;
	    	return FALSE;
	    }

	    lstrcpyW( lpwStrName, buffer );

		*lpdwStringLen = bufferSize+1;
	    
	    return TRUE;
	}	
#else
	char buffer[MAX_REGISTRY_STRING_SIZE];
	DWORD   bufferSize = MAX_REGISTRY_STRING_SIZE;
	FILETIME tmpTime;

	if( RegEnumKeyExA( m_regHandle, index, buffer, &bufferSize, NULL, NULL, NULL, &tmpTime ) != ERROR_SUCCESS )
	{
	    return FALSE;
	}
	else
	{
	    if( bufferSize+1 > *lpdwStringLen )
	    {
	    	*lpdwStringLen = bufferSize+1;
	    	return FALSE;
	    }

	    if( FAILED( STR_jkAnsiToWide( lpwStrName, buffer, *lpdwStringLen ) ) )
	    {
	    	return FALSE;
	    }
	    else
	    {
			*lpdwStringLen = bufferSize+1;
	    	return TRUE;
	    }
	}	
#endif // UNICODE
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::EnumValues"
// EnumValues
//
// This function can be used to enumerate the values at the point
// in the registry rooted at the root this object was opened
// with, at the path specified when opening the object.
//
// To properly enumerate the values you should pass 0 as the index on
// the first call, and increment the index parameter by one on each
// call.  You can stop enumerating when the function returns FALSE.
//
// Parameters:
// LPWSTR lpwStrName - The current value in the enumeration will be returned
//                 in this string.  Unless the enumeration fails or
//                 ended at which case this parameter won't be touched.
//
// LPDWORD lpdwStringLen - pointer to length of string buffer, or place to
//						to store size required.
//
// DWORD index - The current enum index.  See above for details.
//
// Returns:
// BOOL - FALSE when enumeration is done or on error, TRUE otherwise.
//
BOOL CRegistry::EnumValues( LPWSTR lpwStrName, LPDWORD lpdwStringLen, DWORD index )
{
#ifdef UNICODE
	wchar_t buffer[MAX_REGISTRY_STRING_SIZE];
	DWORD   bufferSize = MAX_REGISTRY_STRING_SIZE;

	if( RegEnumValueW( m_regHandle, index, buffer, &bufferSize, NULL, NULL, NULL, NULL ) != ERROR_SUCCESS )
	{
	    return FALSE;
	}
	else
	{
	    if( bufferSize+1 > *lpdwStringLen  )
	    {
	    	*lpdwStringLen = bufferSize+1;
	    	return FALSE;
	    }

	    lstrcpyW( lpwStrName, buffer );

		*lpdwStringLen = bufferSize+1;
	    
	    return TRUE;
	}	
#else
	char buffer[MAX_REGISTRY_STRING_SIZE];
	DWORD   bufferSize = MAX_REGISTRY_STRING_SIZE;

	if( RegEnumValueA( m_regHandle, index, buffer, &bufferSize, NULL, NULL, NULL, NULL ) != ERROR_SUCCESS )
	{
	    return FALSE;
	}
	else
	{
	    if( bufferSize+1 > *lpdwStringLen )
	    {
	    	*lpdwStringLen = bufferSize+1;
	    	return FALSE;
	    }

	    if( FAILED( STR_jkAnsiToWide( lpwStrName, buffer, *lpdwStringLen ) ) )
	    {
	    	return FALSE;
	    }
	    else
	    {
			*lpdwStringLen = bufferSize+1;
	    	return TRUE;
	    }
	}	
#endif // UNICODE
}


// This comment documents ALL of the Read<Data Type> functions which
// follow.
//
// CRegistry Read<Data Type> Functions
//
// The set of ReadXXXXX functions for the CRegistry class are
// responsible for reading <data type> type data from the registry.
// The object must have an open connection to the registry before
// any of these functions may be used.  A connection to the registry
// can be made with the Open call or the constructors.
//
// Parameters:
// const TCHAR *keyName - The keyname of the data you wish to read
// <datatype> & - A reference to the specific data type where
//				  the data will be placed on a succesful read.
//                This parameter will be unaffected if the read
//                fails.
//
// Returns:
// BOOL - Returns TRUE on success, FALSE on failure.
//


// This comment documents ALL of the Write<Data Type> functions which
// follow.
//
// CRegistry Write<Data Type> Functions
//
// The set of Write<Data Type> functions for the CRegistry class are
// responsible for writing <data type> type data to the registry.
// The object must have an open connection to the registry before
// any of these functions may be used.  A connection to the registry
// can be made with the Open call or the constructors.
//
// Parameters:
// const TCHAR *keyName - The keyname of the data you wish to write
// <datatype> & - A reference to the specific data type which
//                contains the data to be written to the registry.
//
// Returns:
// BOOL - Returns TRUE on success, FALSE on failure.
//
#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::WriteString"
// WriteString
//
// Writes Strings's to the registry, see block comment above
// for details.
//
BOOL CRegistry::WriteString( LPCWSTR keyName, const LPCWSTR lpwstrValue )
{

	LONG		retValue;
	
	if( keyName == NULL || !IsOpen() || lpwstrValue == NULL ) 
	{
		return FALSE;
	}

	if( m_fReadOnly )
	{
	    DPFX(DPFPREP, 0, "Attempt to Write to read-only CRegistry key");
	    return FALSE;
	}

#ifdef UNICODE
	retValue = RegSetValueExW( m_regHandle, keyName, 0, REG_SZ, (const unsigned char *) lpwstrValue, (lstrlenW( lpwstrValue )+1)*sizeof(wchar_t) );	
#else
	LPSTR lpstrKeyName;
	LPSTR lpstrValue;
	
	if( FAILED( STR_AllocAndConvertToANSI( &lpstrKeyName, keyName ) ) )
	{
		return FALSE;
	}

	if( FAILED( STR_AllocAndConvertToANSI( &lpstrValue, lpwstrValue ) ) )
	{
		DNFree(lpstrKeyName);
		return FALSE;
	}
	
	retValue = RegSetValueExA( m_regHandle, lpstrKeyName, 0, REG_SZ, (const unsigned char *) lpstrValue, lstrlenA( lpstrValue )+1 );

	DNFree(lpstrKeyName);
	DNFree(lpstrValue);
#endif // UNICODE

	return (retValue == ERROR_SUCCESS);

}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::ReadString"
// ReadString
//
// Reads CString's from the registry, see block comment above
// for details.
//
BOOL CRegistry::ReadString( const LPCWSTR keyName, LPWSTR lpwstrValue, LPDWORD lpdwLength )
{
	if( keyName == NULL || !IsOpen() ) 
	{
		return FALSE;
	}

	LONG		retValue;
	DWORD		tmpSize;
	DWORD		tmpType;	

#ifdef UNICODE
	wchar_t		buffer[MAX_REGISTRY_STRING_SIZE];
	tmpSize = MAX_REGISTRY_STRING_SIZE*sizeof(wchar_t);
	
	retValue = RegQueryValueExW( m_regHandle, keyName, 0, &tmpType, (unsigned char *) &buffer[0], &tmpSize );
	if (retValue != ERROR_SUCCESS)
	{
		return FALSE;
	}

	if( (tmpSize/2) > *lpdwLength || !lpwstrValue )
	{
		*lpdwLength = (tmpSize/2);
		return FALSE;
	}

	lstrcpyW( lpwstrValue, buffer );

	*lpdwLength = (tmpSize/2);

	return TRUE;
#else
	LPSTR lpstrKeyName;
	char buffer[MAX_REGISTRY_STRING_SIZE];
	tmpSize = MAX_REGISTRY_STRING_SIZE;

	if( FAILED( STR_AllocAndConvertToANSI( &lpstrKeyName, keyName ) ) )
	{
		return FALSE;
	}
		
	retValue = RegQueryValueExA( m_regHandle, lpstrKeyName, 0, &tmpType, (unsigned char *) &buffer[0], &tmpSize );
	if (retValue != ERROR_SUCCESS)
	{
		DNFree(lpstrKeyName);
		return FALSE;
	}

	DNFree(lpstrKeyName);

	if( tmpSize > *lpdwLength || !lpwstrValue )
	{
		*lpdwLength = tmpSize;
		return FALSE;
	}

	if( FAILED( STR_jkAnsiToWide( lpwstrValue, buffer, *lpdwLength ) ) )
	{
		return FALSE;
	}

	*lpdwLength = tmpSize;	

	if( retValue == ERROR_SUCCESS && tmpType == REG_SZ ) 
	{
		return TRUE;
	} 
	else 
	{
		return FALSE;
	}
#endif // UNICODE
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::WriteGUID"
// WriteGUID
//
// Writes GUID's to the registry, see block comment above
// for details.  The GUID is written in the format it is usually
// displayed.  (But without the '{''s).
//
BOOL CRegistry::WriteGUID( LPCWSTR keyName, const GUID &guid )
{
	LONG retValue;
	WCHAR wszGuidString[GUID_STRING_LEN];

	if( m_fReadOnly )
	{
	    DPFX(DPFPREP, 0, "Attempt to Write to read-only CRegistry key");
	    return FALSE;
	}

	if (!StringFromGUID2(guid, wszGuidString, GUID_STRING_LEN))
	{
		DPFX(DPFPREP, 0, "StringFromGUID2 failed");
		return FALSE;
	}

#ifdef UNICODE
	retValue = RegSetValueExW( m_regHandle, keyName, 0, REG_SZ, (const unsigned char *) wszGuidString, (lstrlenW( wszGuidString )+1)*sizeof(wchar_t) );
#else
	HRESULT hr;
	LPSTR lpstrKeyName;
	LPSTR lpstrKeyValue;

	hr = STR_AllocAndConvertToANSI( &lpstrKeyName, keyName );
	if (FAILED(hr))
	{
		DPFX(DPFPREP, 0, "STR_AllocAndConvertToANSI failed, code: 0x%08x", hr);
		return FALSE;
	}
	
	hr = STR_AllocAndConvertToANSI( &lpstrKeyValue, wszGuidString );
	if (FAILED(hr))
	{
		DPFX(DPFPREP, 0, "STR_AllocAndConvertToANSI failed, code: 0x%08x", hr);
		DNFree(lpstrKeyName);
		return FALSE;
	}

	retValue = RegSetValueExA( m_regHandle, lpstrKeyName, 0, REG_SZ, (const unsigned char *) lpstrKeyValue, lstrlenA( lpstrKeyValue )+1);

	DNFree(lpstrKeyName);
	DNFree(lpstrKeyValue);
#endif // UNICODE
	
	if( retValue == ERROR_SUCCESS )
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::ReadGUID"
// ReadGUID
//
// Reads GUID's from the registry, see block comment above
// for details.  The GUID must be stored in the format written by
// the WriteGUID function or it will not be read correctly.
//
BOOL CRegistry::ReadGUID( LPCWSTR keyName, GUID* pguid )
{
	wchar_t		buffer[MAX_REGISTRY_STRING_SIZE];
	DWORD		dwLength = MAX_REGISTRY_STRING_SIZE;
    HRESULT hr;

    if( !ReadString( keyName, buffer, &dwLength ) )
    {
        return FALSE;
    }
    else
    {
    	hr = CLSIDFromString(buffer, pguid);
    	if (FAILED(hr))
    	{
    		DPFX(DPFPREP, 0, "CLSIDFromString failed, code: 0x%08x", hr);
    		return FALSE;
    	}
    	return TRUE;
    }
}



#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::WriteDWORD"
// WriteDWORD
//
// Writes DWORDS to the registry, see block comment above
// for details.
//
BOOL CRegistry::WriteDWORD( LPCWSTR keyName, DWORD value ) 
{

	LONG		retValue;

	if( keyName == NULL || !IsOpen() ) 
	{
		return FALSE;
	}

	if( m_fReadOnly )
	{
	    DPFX(DPFPREP, 0, "Attempt to Write to read-only CRegistry key");
	    return FALSE;
	}

#ifdef UNICODE
	retValue = RegSetValueExW( m_regHandle, keyName, 0, REG_DWORD, (const unsigned char *) &value, sizeof( DWORD ) );		
#else
	LPSTR lpszKeyName;

	if( FAILED( STR_AllocAndConvertToANSI( &lpszKeyName, keyName ) ) )
	{
		return FALSE;
	}

	retValue = RegSetValueExA( m_regHandle, lpszKeyName, 0, REG_DWORD, (const unsigned char *) &value, sizeof( DWORD ) );

	DNFree(lpszKeyName);
#endif // UNICODE

	return (retValue == ERROR_SUCCESS);
}



#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::ReadDWORD"
// ReadDWORD
//
// Reads DWORDS from the registry, see block comment above
// for details.
//
BOOL CRegistry::ReadDWORD( LPCWSTR keyName, DWORD* presult ) 
{

	if( keyName == NULL || !IsOpen() ) 
	{
		return FALSE;
	}

	LONG		retValue;
	DWORD		tmpValue;
	DWORD		tmpType;
	DWORD		tmpSize;

	tmpSize = sizeof( DWORD );

#ifdef UNICODE
	retValue = RegQueryValueExW( m_regHandle, keyName, 0, &tmpType, (unsigned char *) &tmpValue, &tmpSize );
#else
	LPSTR lpszKeyName;

	if( FAILED( STR_AllocAndConvertToANSI( &lpszKeyName, keyName ) ) )
	{
		return FALSE;
	}

	retValue = RegQueryValueExA( m_regHandle, lpszKeyName, 0, &tmpType, (unsigned char *) &tmpValue, &tmpSize );
	
	DNFree(lpszKeyName);
#endif // UNICODE

	if( retValue == ERROR_SUCCESS && (tmpType == REG_DWORD || tmpType == REG_BINARY) && tmpSize == sizeof(DWORD) ) 
	{
		*presult = tmpValue;
		return TRUE;
	} 
	else 
	{
		return FALSE;
	}
}

#ifndef DPNBUILD_NOCOMREGISTER

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::Register"
BOOL CRegistry::Register( LPCWSTR lpszProgID, const LPCWSTR lpszDesc, const LPCWSTR lpszProgName, const GUID* pguidCLSID, LPCWSTR lpszVerIndProgID )
{
	CRegistry core;

	DNASSERT( lpszDesc != NULL );
	DNASSERT( lpszProgID != NULL );

	// Build a string representation of the GUID from the GUID
    wchar_t lpszGUID[GUID_STRING_LEN];
    wchar_t lpszKeyName[_MAX_PATH];

	// convert the guid to a string
	if (!StringFromGUID2(*pguidCLSID, lpszGUID, GUID_STRING_LEN))
	{
		DPFX(DPFPREP, 0, "StringFromGUID2 failed");
		return FALSE;
	}

	// Write the HKEY_CLASSES_ROOT\CLSID\{GUID} section
    swprintf( lpszKeyName, L"CLSID\\%s", lpszGUID );

    if( !core.Open( HKEY_CLASSES_ROOT, lpszKeyName, FALSE, TRUE ) )
    {
		DPFX(DPFPREP,  0, "Unable to open/create registry key \"%ls\"", lpszKeyName );
		return FALSE;
    }

    core.WriteString( L"", lpszDesc );
    core.Close();

	// Write the HKEY_CLASSES_ROOT\CLSID\{GUID}\InProcServer32 section
    swprintf( lpszKeyName, L"CLSID\\%s\\InProcServer32", lpszGUID );

    if( !core.Open( HKEY_CLASSES_ROOT, lpszKeyName, FALSE, TRUE ) )
    {
    	DPFX(DPFPREP,  0, "Unable to open/create registry key \"%ls\"", lpszKeyName );
    	return FALSE;
    }
    core.WriteString( L"", lpszProgName );
    core.WriteString( L"ThreadingModel", L"Both" );
    core.Close();

	// Write the HKEY_CLASSES_ROOT\CLSID\{GUID}\VersionIndependentProgID section
    if( lpszVerIndProgID != NULL )
    {
	    swprintf( lpszKeyName, L"CLSID\\%s\\VersionIndependentProgID", lpszGUID );

	    if( !core.Open( HKEY_CLASSES_ROOT, lpszKeyName, FALSE, TRUE ) )
	    {
	    	DPFX(DPFPREP,  0, "Unable to open/create verind registry key \"%ls\"", lpszKeyName );
	    	return FALSE;
	    }
    
	    core.WriteString( L"", lpszVerIndProgID );
	    core.Close();
	}

	// Write the HKEY_CLASSES_ROOT\CLSID\{GUID}\ProgID section
    swprintf( lpszKeyName, L"CLSID\\%s\\ProgID", lpszGUID );

    if( !core.Open( HKEY_CLASSES_ROOT, lpszKeyName, FALSE, TRUE ) )
    {
    	DPFX(DPFPREP,  0, "Unable to open/create verind registry key \"%ls\"", lpszKeyName );
    	return FALSE;
    }

    core.WriteString( L"", lpszProgID );
    core.Close();

	// Write The VersionIND ProgID
	
	if( lpszVerIndProgID != NULL )
	{
		if( !core.Open( HKEY_CLASSES_ROOT, lpszVerIndProgID, FALSE, TRUE ) )
		{
			DPFX(DPFPREP,  0, "Unable to open/create reg key \"%ls\"", lpszVerIndProgID );
		}
		else
		{
			core.WriteString( L"", lpszDesc );
			core.Close();			
		}

		swprintf( lpszKeyName, L"%s\\CLSID", lpszVerIndProgID );

		if( !core.Open( HKEY_CLASSES_ROOT, lpszKeyName, FALSE, TRUE ) )
		{
			DPFX(DPFPREP,  0, "Unable to open/create reg key \"%ls\"", lpszKeyName );
		}
		else
		{
			core.WriteString( L"", lpszGUID );
			core.Close();
		}

		swprintf( lpszKeyName, L"%s\\CurVer", lpszVerIndProgID );

		if( !core.Open( HKEY_CLASSES_ROOT, lpszKeyName, FALSE, TRUE ) )
		{
			DPFX(DPFPREP,  0, "Unable to open/create reg key \"%ls\"", lpszKeyName );
		}
		else
		{
			core.WriteString( L"", lpszProgID );
			core.Close();
		}		
	}

	if( !core.Open( HKEY_CLASSES_ROOT, lpszProgID, FALSE, TRUE ) )
	{
		DPFX(DPFPREP,  0, "Unable to open/create reg key \"%ls\"", lpszKeyName );
	}
	else
	{
		core.WriteString( L"", lpszDesc );
		core.Close();
	}
	
	swprintf( lpszKeyName, L"%s\\CLSID", lpszProgID );

	if( !core.Open( HKEY_CLASSES_ROOT, lpszKeyName, FALSE, TRUE ) )
	{
		DPFX(DPFPREP,  0, "Unable to open/create reg key \"%ls\"", lpszKeyName );
	}
	else
	{
		core.WriteString( L"", lpszGUID );
		core.Close();
	}

	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::UnRegister"
BOOL CRegistry::UnRegister( const GUID* pguidCLSID )
{
	CRegistry core, cregClasses, cregSub;

	// Build a string representation of the GUID from the GUID
    wchar_t lpszGUID[GUID_STRING_LEN];
    wchar_t lpszKeyName[_MAX_PATH];
    wchar_t szProgID[MAX_REGISTRY_STRING_SIZE];
    wchar_t szVerIndProgID[MAX_REGISTRY_STRING_SIZE];
    DWORD dwSize = MAX_REGISTRY_STRING_SIZE;

	// convert the guid to a string
	if (!StringFromGUID2(*pguidCLSID, lpszGUID, GUID_STRING_LEN))
	{
		DPFX(DPFPREP, 0, "StringFromGUID2 failed");
		return FALSE;
	}

	if( !cregClasses.Open( HKEY_CLASSES_ROOT, L"", FALSE, FALSE ) )
	{
		DPFX(DPFPREP,  0, "Unable to open HKEY_CLASSES_ROOT" );
		return FALSE;
	}

	// Write the HKEY_CLASSES_ROOT\CLSID\{GUID} section
    swprintf( lpszKeyName, L"CLSID\\%s\\ProgID", lpszGUID );

	if( !core.Open( HKEY_CLASSES_ROOT, lpszKeyName, FALSE, FALSE ) )
	{
		DPFX(DPFPREP,  0, "Unable to open \"%ls\"", lpszKeyName );
		return FALSE;
	}

	dwSize = MAX_REGISTRY_STRING_SIZE;	

    if( core.ReadString( L"", szProgID, &dwSize ) )
    {
    	swprintf( lpszKeyName, L"%s\\CLSID", szProgID );
    	
    	if( !cregClasses.DeleteSubKey( lpszKeyName ) )
    	{
    		DPFX(DPFPREP,  0, "Unable to delete \"%ls\"", lpszKeyName );
    		return FALSE;
    	}
    	
    	if( !cregClasses.DeleteSubKey( szProgID ) )
    	{
    		DPFX(DPFPREP,  0, "Unable to delete HKEY_CLASSES_ROOT/ProgID" );

    		return FALSE;
    	}
    }

	core.Close();

    swprintf( lpszKeyName, L"CLSID\\%s\\VersionIndependentProgID", lpszGUID );

	if( !core.Open( HKEY_CLASSES_ROOT, lpszKeyName, FALSE, FALSE ) )
	{
		DPFX(DPFPREP,  0, "Unable to open \"%ls\"", lpszKeyName );
		return FALSE;
	}

	dwSize = MAX_REGISTRY_STRING_SIZE;
	
    if( core.ReadString( L"", szVerIndProgID, &dwSize ) )
    {
    	swprintf( lpszKeyName, L"%s\\CLSID", szVerIndProgID );

    	if( !cregClasses.DeleteSubKey( lpszKeyName ) )
    	{
    		DPFX(DPFPREP,  0, "Unable to delete \"%ls\"", lpszKeyName );
    		return FALSE;
    	}

    	swprintf( lpszKeyName, L"%s\\CurVer", szVerIndProgID );

    	if( !cregClasses.DeleteSubKey( lpszKeyName ) )
    	{
    		DPFX(DPFPREP,  0, "Unable to delete \"%ls\"", lpszKeyName );
    		return FALSE;
    	}
    	
    	
    	if( !cregClasses.DeleteSubKey( szVerIndProgID ) )
    	{
    		DPFX(DPFPREP,  0, "Unable to delete \"HKEY_CLASSES_ROOT/%ls\"", szVerIndProgID);

    		return FALSE;
    	}
    }

    core.Close();

	swprintf( lpszKeyName, L"CLSID\\%s\\InprocServer32", lpszGUID );

	if( !cregClasses.DeleteSubKey( lpszKeyName ) )
	{
		DPFX(DPFPREP,  0, "Unable to delete \"%ls\"", lpszKeyName );
		return FALSE;	
	}	
	
	swprintf( lpszKeyName, L"CLSID\\%s\\ProgID", lpszGUID );

	if( !cregClasses.DeleteSubKey( lpszKeyName ) )
	{
		DPFX(DPFPREP,  0, "Unable to delete \"%ls\"", lpszKeyName );
		return FALSE;	
	}	
	
	swprintf( lpszKeyName, L"CLSID\\%s\\VersionIndependentProgID", lpszGUID );

	if( !cregClasses.DeleteSubKey( lpszKeyName ) )
	{
		DPFX(DPFPREP,  0, "Unable to delete \"%ls\"", lpszKeyName );
		return FALSE;	
	}	

	swprintf( lpszKeyName, L"CLSID\\%s", lpszGUID );

	if( !cregClasses.DeleteSubKey( lpszKeyName ) )
	{
		DPFX(DPFPREP,  0, "Unable to delete \"%ls\"", lpszKeyName );
		return FALSE;	
	}

    return TRUE;
}

#endif // !DPNBUILD_NOCOMREGISTER

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::ReadBlob"
BOOL CRegistry::ReadBlob( LPCWSTR keyName, LPBYTE lpbBuffer, LPDWORD lpdwSize )
{
	if( keyName == NULL || !IsOpen() ) return FALSE;

	LONG		retValue;
	DWORD		tmpType;

#ifdef UNICODE
	retValue = RegQueryValueExW( m_regHandle, keyName, 0, &tmpType, lpbBuffer, lpdwSize );	
#else
	LPSTR lpszKeyName;
		
	if( FAILED( STR_AllocAndConvertToANSI( &lpszKeyName, keyName ) ) )
	{
		return FALSE;
	}

	retValue = RegQueryValueExA( m_regHandle, lpszKeyName, 0, &tmpType, lpbBuffer, lpdwSize );

	DNFree(lpszKeyName);
#endif // UNICODE
	
	if( retValue == ERROR_SUCCESS && tmpType == REG_BINARY ) 
	{
		return TRUE;
	} 
	else 
	{
		return FALSE;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::WriteBlob"
BOOL CRegistry::WriteBlob( LPCWSTR keyName, const BYTE* const lpbBuffer, DWORD dwSize )
{
	LONG		retValue;

	if( keyName == NULL || !IsOpen() ) 
	{
		return FALSE;
	}

	if( m_fReadOnly )
	{
	    DPFX(DPFPREP, 0, "Attempt to Write to read-only CRegistry key");
	    return FALSE;
	}

#ifdef UNICODE
	retValue = RegSetValueExW( m_regHandle, keyName, 0, REG_BINARY, lpbBuffer, dwSize );
#else
	LPSTR lpszKeyName;
	
	if( FAILED( STR_AllocAndConvertToANSI( &lpszKeyName, keyName ) ) )
		return FALSE;

	retValue = RegSetValueExA( m_regHandle, lpszKeyName, 0, REG_BINARY, lpbBuffer, dwSize );
	
	DNFree(lpszKeyName);	
#endif // UNICODE

	return (retValue == ERROR_SUCCESS);
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::GetMaxKeyLen"
BOOL CRegistry::GetMaxKeyLen( DWORD* pdwMaxKeyLen )
{
	LONG	retVal;

#ifdef UNICODE
	retVal = RegQueryInfoKeyW( m_regHandle,NULL,NULL,NULL,NULL,pdwMaxKeyLen,
			NULL,NULL,NULL,NULL,NULL,NULL);
#else
	retVal = RegQueryInfoKeyA( m_regHandle,NULL,NULL,NULL,NULL,pdwMaxKeyLen,
			NULL,NULL,NULL,NULL,NULL,NULL);
#endif // UNICODE

	return (retVal == ERROR_SUCCESS);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::GetValueLength"
// GetValueLength
//
// Determines the length of a particular key value
//
BOOL CRegistry::GetValueLength( const LPCWSTR keyName, DWORD *const pdwValueLength )
{
	LONG		retValue;
	DWORD		tmpLength;

	if ( keyName == NULL || pdwValueLength == NULL || !IsOpen() )
	{
		return FALSE;
	}

#ifdef UNICODE
	DWORD	dwType;
		
	retValue = RegQueryValueExW( m_regHandle, keyName, 0, &dwType, NULL, &tmpLength );
	if (retValue != ERROR_SUCCESS)
	{
		return FALSE;
	}

	//
	// if this is a string, we need to compensate for WCHAR characters being
	// returned
	//
	if ( dwType == REG_SZ )
	{
		tmpLength /= sizeof( WCHAR );
	}
#else
	LPSTR lpstrKeyName;

	if( FAILED( STR_AllocAndConvertToANSI( &lpstrKeyName, keyName ) ) )
	{
		return FALSE;
	}
		
	retValue = RegQueryValueExA( m_regHandle, lpstrKeyName, 0, NULL, NULL, &tmpLength );

	DNFree(lpstrKeyName);	

	if (retValue != ERROR_SUCCESS)
	{
		return FALSE;
	}
#endif // UNICODE

	*pdwValueLength = tmpLength;

	return TRUE;
}


#ifdef WINNT

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::GrantAllAccessSecurityPermissions"
// GrantAllAccessSecurityPermissions
//
// Gives the given key all access for everyone rights
//
// Taken from hresMumbleKeyEx in diregutl.c in the dinput tree.
//
BOOL CRegistry::GrantAllAccessSecurityPermissions()
{
	BOOL						fResult = FALSE;
	HRESULT						hr;
    EXPLICIT_ACCESS				ExplicitAccess;
    PACL						pACL = NULL;
	PSID						pSid = NULL;
	HMODULE						hModuleADVAPI32 = NULL;
	SID_IDENTIFIER_AUTHORITY	authority = SECURITY_WORLD_SID_AUTHORITY;
	PALLOCATEANDINITIALIZESID	pAllocateAndInitializeSid = NULL;
	PBUILDTRUSTEEWITHSID		pBuildTrusteeWithSid = NULL;
	PSETENTRIESINACL			pSetEntriesInAcl = NULL;
	PSETSECURITYINFO			pSetSecurityInfo = NULL;
	PFREESID					pFreeSid = NULL;

	hModuleADVAPI32 = LoadLibrary( _T("advapi32.dll") );

	if( !hModuleADVAPI32 )
	{
		DPFX(DPFPREP,  0, "Failed loading advapi32.dll" );
		goto EXIT;
	}

	pFreeSid = reinterpret_cast<PFREESID>( GetProcAddress( hModuleADVAPI32, "FreeSid" ) );
	pSetSecurityInfo = reinterpret_cast<PSETSECURITYINFO>( GetProcAddress( hModuleADVAPI32, "SetSecurityInfo" ) );
	pSetEntriesInAcl = reinterpret_cast<PSETENTRIESINACL>( GetProcAddress( hModuleADVAPI32, "SetEntriesInAclA" ) );
	pBuildTrusteeWithSid = reinterpret_cast<PBUILDTRUSTEEWITHSID>( GetProcAddress( hModuleADVAPI32, "BuildTrusteeWithSidA" ) );
	pAllocateAndInitializeSid = reinterpret_cast<PALLOCATEANDINITIALIZESID>( GetProcAddress( hModuleADVAPI32, "AllocateAndInitializeSid" ) );

	if( !pFreeSid || !pSetSecurityInfo || !pSetEntriesInAcl || !pBuildTrusteeWithSid || !pAllocateAndInitializeSid )
	{
		DPFX(DPFPREP,  0, "Failed loading entry points" );
		goto EXIT;
	}

    // Describe the access we want to create the key with
    ZeroMemory (&ExplicitAccess, sizeof(ExplicitAccess) );
    ExplicitAccess.grfAccessPermissions = ((KEY_ALL_ACCESS & ~WRITE_DAC) & ~WRITE_OWNER);
    									/*KEY_QUERY_VALUE | KEY_SET_VALUE 
                                        | KEY_CREATE_SUB_KEY | KEY_ENUMERATE_SUB_KEYS
                                        | KEY_NOTIFY | KEY_CREATE_LINK
                                        | DELETE | READ_CONTROL; */
    ExplicitAccess.grfAccessMode = SET_ACCESS;      // discard any existing AC info
    ExplicitAccess.grfInheritance =  SUB_CONTAINERS_AND_OBJECTS_INHERIT;

	if (pAllocateAndInitializeSid(
				&authority,
				1, 
				SECURITY_WORLD_RID,  0, 0, 0, 0, 0, 0, 0,
				&pSid
				))
	{
		pBuildTrusteeWithSid(&(ExplicitAccess.Trustee), pSid );

		hr = pSetEntriesInAcl( 1, &ExplicitAccess, NULL, &pACL );

		if( hr == ERROR_SUCCESS )
		{
			hr = pSetSecurityInfo( m_regHandle, SE_REGISTRY_KEY, DACL_SECURITY_INFORMATION, NULL, NULL, pACL, NULL ); 

			if( FAILED( hr ) )
			{
				DPFX(DPFPREP,  0, "Unable to set security for key.  Error! hr=0x%x", hr );
			}
			else
			{
				fResult = TRUE;
			}
		} 
		else
		{
			DPFX(DPFPREP,  0, "SetEntriesInACL failed, hr=0x%x", hr );
		}
	}
	else
	{
		hr = GetLastError();
		DPFX(DPFPREP,  0, "AllocateAndInitializeSid failed lastError=0x%x", hr );
	}

EXIT:

	if( pACL )
	{
		LocalFree( pACL );
	}

	//Cleanup pSid
	if (pSid != NULL)
	{
		(pFreeSid)(pSid);
	}

	if( hModuleADVAPI32 )
	{
		FreeLibrary( hModuleADVAPI32 );
	}

	return fResult;
}


#endif // WINNT

#ifdef WINNT

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::RemoveAllAccessSecurityPermissions"
// RemoveAllAccessSecurityPermissions
//
// Removes "all access for everyone" rights from the specified key.
// This is identical to GrantAllAccessSecurityPermissions(), except that
// now we REVOKE_ACCESS instead of SET_ACCESS, and we don't have to fill
// out the rest of the EXPLICIT_ACCESS struct.
//
//
BOOL CRegistry::RemoveAllAccessSecurityPermissions()
{
	BOOL						fResult = FALSE;
	HRESULT						hr;
    EXPLICIT_ACCESS				ExplicitAccess;
    PACL						pACL = NULL;
	PSID						pSid = NULL;
	HMODULE						hModuleADVAPI32 = NULL;
	SID_IDENTIFIER_AUTHORITY	authority = SECURITY_WORLD_SID_AUTHORITY;
	PALLOCATEANDINITIALIZESID	pAllocateAndInitializeSid = NULL;
	PBUILDTRUSTEEWITHSID		pBuildTrusteeWithSid = NULL;
	PSETENTRIESINACL			pSetEntriesInAcl = NULL;
	PSETSECURITYINFO			pSetSecurityInfo = NULL;
	PFREESID					pFreeSid = NULL;

	hModuleADVAPI32 = LoadLibrary( _T("advapi32.dll") );

	if( !hModuleADVAPI32 )
	{
		DPFX(DPFPREP,  0, "Failed loading advapi32.dll" );
		goto EXIT;
	}

	pFreeSid = reinterpret_cast<PFREESID>( GetProcAddress( hModuleADVAPI32, "FreeSid" ) );
	pSetSecurityInfo = reinterpret_cast<PSETSECURITYINFO>( GetProcAddress( hModuleADVAPI32, "SetSecurityInfo" ) );
	pSetEntriesInAcl = reinterpret_cast<PSETENTRIESINACL>( GetProcAddress( hModuleADVAPI32, "SetEntriesInAclA" ) );
	pBuildTrusteeWithSid = reinterpret_cast<PBUILDTRUSTEEWITHSID>( GetProcAddress( hModuleADVAPI32, "BuildTrusteeWithSidA" ) );
	pAllocateAndInitializeSid = reinterpret_cast<PALLOCATEANDINITIALIZESID>( GetProcAddress( hModuleADVAPI32, "AllocateAndInitializeSid" ) );

	if( !pFreeSid || !pSetSecurityInfo || !pSetEntriesInAcl || !pBuildTrusteeWithSid || !pAllocateAndInitializeSid )
	{
		DPFX(DPFPREP,  0, "Failed loading entry points" );
		goto EXIT;
	}

    ZeroMemory (&ExplicitAccess, sizeof(ExplicitAccess) );
	ExplicitAccess.grfAccessMode = REVOKE_ACCESS;		//Remove any existing ACEs for the specified trustee

	if (pAllocateAndInitializeSid(
				&authority,
				1, 
				SECURITY_WORLD_RID,  0, 0, 0, 0, 0, 0, 0,	// trustee is "Everyone"
				&pSid
				))
	{
		pBuildTrusteeWithSid(&(ExplicitAccess.Trustee), pSid );

		hr = pSetEntriesInAcl( 1, &ExplicitAccess, NULL, &pACL );

		if( hr == ERROR_SUCCESS )
		{
			hr = pSetSecurityInfo( m_regHandle, SE_REGISTRY_KEY, DACL_SECURITY_INFORMATION, NULL, NULL, pACL, NULL ); 

			if( FAILED( hr ) )
			{
				DPFX(DPFPREP,  0, "Unable to set security for key.  Error! hr=0x%x", hr );
			}
			else
			{
				fResult = TRUE;
			}
		} 
		else
		{
			DPFX(DPFPREP,  0, "SetEntriesInACL failed, hr=0x%x", hr );
		}
	}
	else
	{
		hr = GetLastError();
		DPFX(DPFPREP,  0, "AllocateAndInitializeSid failed lastError=0x%x", hr );
	}

EXIT:

	if( pACL )
	{
		LocalFree( pACL );
	}

	//Cleanup pSid
	if (pSid != NULL)
	{
		(pFreeSid)(pSid);
	}

	if( hModuleADVAPI32 )
	{
		FreeLibrary( hModuleADVAPI32 );
	}

	return fResult;
}

#endif // WINNT


#endif // ! DPNBUILD_NOREGISTRY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\critsectracking.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       MemoryTracking.cpp
 *  Content:	Debug memory tracking for detecting leaks, overruns, etc.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	1/10/2002	masonb	Created
 *
 ***************************************************************************/

#include "dncmni.h"

#ifndef DPNBUILD_ONLYONETHREAD
#ifdef DBG


//
// Uncomment this line to turn critical section internal structure validation on.
//
//#define DNCS_VALIDATE



#define	DN_INVALID_THREAD_ID			-1

CBilink				g_blAllCritSecs;
CBilink				g_blGlobalCritSecsHeldGroup;
CRITICAL_SECTION	g_CSLock;
DWORD				g_dwNumCritSecsAllocated = 0;
DWORD				g_dwNumCritSecsEntered = 0;


#ifdef DNCS_VALIDATE
void DNCSTrackInternalValidate();
#else // ! DNCS_VALIDATE
#define DNCSTrackInternalValidate()
#endif // DNCS_VALIDATE


#undef DPF_MODNAME
#define DPF_MODNAME "DNCSTrackInitialize"
BOOL DNCSTrackInitialize()
{
	g_blAllCritSecs.Initialize();
	g_blGlobalCritSecsHeldGroup.Initialize();

	if ( DNOSInitializeCriticalSection(&g_CSLock) == FALSE )
	{
		DPFX(DPFPREP,  0, "Failed to initialize critical section tracking code!" );
		DNASSERT( FALSE );
		return FALSE;
	}

	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DNCSTrackDeinitialize"
void DNCSTrackDeinitialize()
{
	DeleteCriticalSection(&g_CSLock);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DNCSTrackDumpLeaks"
BOOL DNCSTrackDumpLeaks()
{
	DNCRITICAL_SECTION* pCS;
	TCHAR CallStackBuffer[CALLSTACK_BUFFER_SIZE];
	BOOL fLeaked = FALSE;

	EnterCriticalSection(&g_CSLock);
	while (!g_blAllCritSecs.IsEmpty())
	{
		pCS = CONTAINING_OBJECT(g_blAllCritSecs.GetNext(), DNCRITICAL_SECTION, blAllCritSecs);
		
		pCS->AllocCallStack.GetCallStackString(CallStackBuffer);

		DPFX(DPFPREP,  0, "Critical Section leaked at address 0x%p\n%s", pCS, CallStackBuffer );

		pCS->blAllCritSecs.RemoveFromList();

		DeleteCriticalSection(&pCS->CriticalSection);

		fLeaked = TRUE;
	}
	LeaveCriticalSection(&g_CSLock);

	return fLeaked;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DNCSTrackInitializeCriticalSection"
BOOL DNCSTrackInitializeCriticalSection( DNCRITICAL_SECTION *const pCriticalSection )
{
	BOOL fReturn;

	DNASSERT( pCriticalSection != NULL );
	memset( pCriticalSection, 0x00, sizeof( *pCriticalSection ) );

	pCriticalSection->OwningThreadID = DN_INVALID_THREAD_ID;
	pCriticalSection->MaxLockCount = -1;
	pCriticalSection->blCritSecsHeld.Initialize();
	pCriticalSection->blAllCritSecs.Initialize();
	pCriticalSection->pblCritSecsHeldGroup = &g_blGlobalCritSecsHeldGroup;

	fReturn = DNOSInitializeCriticalSection(&pCriticalSection->CriticalSection);
	if ( fReturn != FALSE )
	{
		pCriticalSection->AllocCallStack.NoteCurrentCallStack();

		EnterCriticalSection(&g_CSLock);
		pCriticalSection->blAllCritSecs.InsertBefore(&g_blAllCritSecs);
		g_dwNumCritSecsAllocated++;
		DNCSTrackInternalValidate();
		LeaveCriticalSection(&g_CSLock);
	}

	return	fReturn;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DNCSTrackDeleteCriticalSection"
void DNCSTrackDeleteCriticalSection( DNCRITICAL_SECTION *const pCriticalSection )
{
	DNASSERT( pCriticalSection != NULL );
	DNASSERT( pCriticalSection->LockCount == 0 );

	EnterCriticalSection(&g_CSLock);

	pCriticalSection->blAllCritSecs.RemoveFromList();
	g_dwNumCritSecsAllocated--;

	// NOTE: If they delete the CS without leaving it, still remove it from the held list.
	// If asserts are on, this will have asserted above at LockCount == 0.
	// Calling this is safe whether it is on the list or not.
	pCriticalSection->blCritSecsHeld.RemoveFromList();

	DNCSTrackInternalValidate();
	
	LeaveCriticalSection(&g_CSLock);

	DeleteCriticalSection( &pCriticalSection->CriticalSection );
	memset( &pCriticalSection->CriticalSection, 0x00, sizeof( pCriticalSection->CriticalSection ) );
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCSTrackSetCriticalRecursionCount"
void DNCSTrackSetCriticalSectionRecursionCount( DNCRITICAL_SECTION *const pCriticalSection, const UINT_PTR RecursionCount )
{
	DNASSERT( pCriticalSection != NULL );

	pCriticalSection->MaxLockCount = RecursionCount + 1;

	DNASSERT( pCriticalSection->MaxLockCount != 0 );
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCSTrackSetCriticalSectionGroup"
void DNCSTrackSetCriticalSectionGroup( DNCRITICAL_SECTION *const pCriticalSection, CBilink * const pblGroup )
{
	DNASSERT( pCriticalSection != NULL );
	DNASSERT( pblGroup != NULL );

	pCriticalSection->pblCritSecsHeldGroup = pblGroup;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCSTrackSetCriticalSectionLockOrder"
void DNCSTrackSetCriticalSectionLockOrder( DNCRITICAL_SECTION *const pCriticalSection, const DWORD dwLockOrder )
{
	DNASSERT( pCriticalSection != NULL );
	DNASSERT( dwLockOrder > 0 );

	pCriticalSection->dwLockOrder = dwLockOrder;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCSTrackEnterCriticalSection"
void DNCSTrackEnterCriticalSection( DNCRITICAL_SECTION *const pCriticalSection )
{
	UINT_PTR	ThisThreadID;

	DNASSERT( pCriticalSection != NULL );

	EnterCriticalSection( &pCriticalSection->CriticalSection );

	ThisThreadID = GetCurrentThreadId();
	if ( pCriticalSection->OwningThreadID != ThisThreadID )
	{
		DNASSERT( pCriticalSection->OwningThreadID == DN_INVALID_THREAD_ID );
		DNASSERT( pCriticalSection->LockCount == 0 );
	
		pCriticalSection->OwningThreadID = ThisThreadID;
	}
	else
	{
		DNASSERT( pCriticalSection->LockCount != 0 );
	}

	if ( pCriticalSection->LockCount == 0 )
	{
		pCriticalSection->CallStack.NoteCurrentCallStack();

		// Track this critical section that was just entered for the first time.

		EnterCriticalSection(&g_CSLock);

		pCriticalSection->LockCount++;

		//
		// If this critical section has a lock order, assert that we're not
		// violating it.
		//
		if (pCriticalSection->dwLockOrder != 0)
		{
			CBilink *				pBilink;
			DNCRITICAL_SECTION *	pCS;

			pBilink = pCriticalSection->pblCritSecsHeldGroup->GetNext();
			while (pBilink != pCriticalSection->pblCritSecsHeldGroup)
			{
				pCS = CONTAINING_OBJECT(pBilink, DNCRITICAL_SECTION, blCritSecsHeld);
				if (pCS->dwLockOrder != 0)
				{
					DNASSERT( pCS->dwLockOrder <= pCriticalSection->dwLockOrder );
				}
				pBilink = pBilink->GetNext();
			}
		}
		
		pCriticalSection->blCritSecsHeld.InsertBefore(pCriticalSection->pblCritSecsHeldGroup);
		DNASSERT(g_dwNumCritSecsEntered < g_dwNumCritSecsAllocated);
		g_dwNumCritSecsEntered++;
		DNCSTrackInternalValidate();
		LeaveCriticalSection(&g_CSLock);
	}
	else
	{
		pCriticalSection->LockCount++;
	}

	if ( pCriticalSection->LockCount > pCriticalSection->MaxLockCount )
	{
		if ( pCriticalSection->MaxLockCount == 1 )
		{
			TCHAR	CallStackBuffer[ CALLSTACK_BUFFER_SIZE ];

			//
			// Exceeded recursion depth of 1, display stack of call originally
			// holding the lock.
			//
			pCriticalSection->CallStack.GetCallStackString( CallStackBuffer );

			DPFX(DPFPREP, 0, "Critical section 0x%p has been reentered!\nOriginal Holder's Stack:\n%s", pCriticalSection, CallStackBuffer);

			DNASSERT(FALSE);
		}
		else
		{
			//
			// exceeded recursion depth, check your code!!
			//
			DNASSERT(FALSE);
		}
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCSTrackLeaveCriticalSection"
void DNCSTrackLeaveCriticalSection( DNCRITICAL_SECTION *const pCriticalSection )
{
	DNASSERT( pCriticalSection != NULL );
	DNASSERT( pCriticalSection->OwningThreadID == GetCurrentThreadId() );
	DNASSERT( pCriticalSection->LockCount <= pCriticalSection->MaxLockCount );
	DNASSERT( pCriticalSection->LockCount != 0 );

	if ( pCriticalSection->LockCount == 1 )
	{
		memset( &pCriticalSection->CallStack, 0x00, sizeof( pCriticalSection->CallStack ) );
		pCriticalSection->OwningThreadID = DN_INVALID_THREAD_ID;

		// Track this critical section being left for the last time.
		EnterCriticalSection(&g_CSLock);
		pCriticalSection->LockCount--;
		pCriticalSection->blCritSecsHeld.RemoveFromList();
		DNASSERT(g_dwNumCritSecsEntered > 0);
		g_dwNumCritSecsEntered--;
		DNCSTrackInternalValidate();
		LeaveCriticalSection(&g_CSLock);
	}
	else
	{
		pCriticalSection->LockCount--;
	}

	LeaveCriticalSection( &pCriticalSection->CriticalSection );
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCSTrackCriticalSectionIsTakenByThisThread"
void DNCSTrackCriticalSectionIsTakenByThisThread( const DNCRITICAL_SECTION *const pCriticalSection, const BOOL fFlag )
{
	DNASSERT( fFlag == ( pCriticalSection->OwningThreadID == GetCurrentThreadId() ) );
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCSTrackNoCriticalSectionsTakenByThisThread"
void DNCSTrackNoCriticalSectionsTakenByThisThread( CBilink * pblGroup )
{
	CBilink* pBilink;
	DNCRITICAL_SECTION* pCS;

	if (pblGroup == NULL)
	{
		pblGroup = &g_blGlobalCritSecsHeldGroup;
	}

	EnterCriticalSection(&g_CSLock);

	pBilink = pblGroup->GetNext();
	while (pBilink != pblGroup)
	{
		pCS = CONTAINING_OBJECT(pBilink, DNCRITICAL_SECTION, blCritSecsHeld);
		DNASSERT( pCS->OwningThreadID != GetCurrentThreadId() );
		pBilink = pBilink->GetNext();
	}

	DNCSTrackInternalValidate();

	LeaveCriticalSection(&g_CSLock);
}



#ifdef DNCS_VALIDATE

#undef DPF_MODNAME
#define DPF_MODNAME "DNCSTrackInternalValidate"
void DNCSTrackInternalValidate()
{
	CBilink* pBilink;
	DNCRITICAL_SECTION* pCS;
	DWORD dwNumAllocated = 0;
	DWORD dwNumEntered = 0;

	//
	// The global critical section lock must be held!
	//

	DNASSERT(g_dwNumCritSecsEntered <= g_dwNumCritSecsAllocated);
	
	pBilink = g_blAllCritSecs.GetNext();
	while (pBilink != &g_blAllCritSecs)
	{
		DNASSERT(pBilink->GetNext() != pBilink);
		DNASSERT(pBilink->GetPrev() != pBilink);
		DNASSERT(pBilink->IsListMember(&g_blAllCritSecs));
		
		pCS = CONTAINING_OBJECT(pBilink, DNCRITICAL_SECTION, blAllCritSecs);

		dwNumAllocated++;
		if (pCS->blCritSecsHeld.IsEmpty())
		{
			DNASSERT(pCS->LockCount == 0);
		}
		else
		{
			DNASSERT(pCS->LockCount > 0);
			dwNumEntered++;
		}

		pBilink = pBilink->GetNext();		
	}
	
	DNASSERT(dwNumAllocated == g_dwNumCritSecsAllocated);
	DNASSERT(dwNumEntered == g_dwNumCritSecsEntered);
}

#endif // DNCS_VALIDATE


#endif // DBG
#endif // !DPNBUILD_ONLYONETHREAD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\createin.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       createin.h
 *  Content:	defines functions required by the generic class factory
 *
 *
 *	The generic class factory (classfac.c) requires these functions to be
 *	implemented by the COM object(s) its supposed to be generating
 *
 *	GP_ stands for "General Purpose"
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	10/13/98	jwo		Created it.
 ***************************************************************************/

#ifndef __CREATEINS__
#define __CREATEINS__


#ifndef DPNBUILD_LIBINTERFACE


#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// you must implement this function to create an instance of your COM object
HRESULT	DoCreateInstance(LPCLASSFACTORY This, LPUNKNOWN pUnkOuter, REFCLSID rclsid, REFIID riid,
    						LPVOID *ppvObj);

// you must implement this function.  Given a class id, you must respond
//	whether or not your DLL implements it
BOOL	IsClassImplemented(REFCLSID rclsid);

#ifdef __cplusplus
}
#endif // __cplusplus


#endif // ! DPNBUILD_LIBINTERFACE

#endif // __CREATEINS__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\critsectracking.h ===
/*==========================================================================
 *
 *  Copyright (C) 2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       CritsecTracking.h
 *  Content:	Debug critical section tracking for detecting leaks, nesting, etc.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 	1/10/2002	masonb	Created
 *
 ***************************************************************************/

#ifndef	__CRITSECTRACKING_H__
#define	__CRITSECTRACKING_H__

#include "callstack.h"
#include "classbilink.h"

#ifdef DPNBUILD_ONLYONETHREAD

#define	DNEnterCriticalSection( arg )
#define	DNLeaveCriticalSection( arg )
#define DNInitializeCriticalSection( pCriticalSection )	TRUE
#define DNDeleteCriticalSection( pCriticalSection )
#define	DebugSetCriticalSectionRecursionCount( pCS, Count )
#define	DebugSetCriticalSectionGroup( pCS, pblGroup )
#define	DebugSetCriticalSectionLockOrder( pCS, dwLockOrder )
#define	AssertCriticalSectionIsTakenByThisThread( pCS, Flag )
#define	AssertNoCriticalSectionsTakenByThisThread()
#define	AssertNoCriticalSectionsFromGroupTakenByThisThread( pblGroup )

#else // !DPNBUILD_ONLYONETHREAD

#ifdef DBG

struct DNCRITICAL_SECTION
{
	CRITICAL_SECTION	CriticalSection;

	UINT_PTR		OwningThreadID;
	UINT_PTR		MaxLockCount;
	UINT_PTR		LockCount;
	CCallStack		CallStack;
	CCallStack		AllocCallStack;
	CBilink			blAllCritSecs;
	CBilink			blCritSecsHeld;
	CBilink *		pblCritSecsHeldGroup;
	DWORD			dwLockOrder;
};

BOOL DNCSTrackInitialize();
void DNCSTrackDeinitialize();
BOOL DNCSTrackDumpLeaks();

BOOL	DNCSTrackInitializeCriticalSection( DNCRITICAL_SECTION *const pCriticalSection );
void	DNCSTrackDeleteCriticalSection( DNCRITICAL_SECTION *const pCriticalSection );
void	DNCSTrackEnterCriticalSection( DNCRITICAL_SECTION *const pCriticalSection );
void	DNCSTrackLeaveCriticalSection( DNCRITICAL_SECTION *const pCriticalSection );
void	DNCSTrackSetCriticalSectionRecursionCount( DNCRITICAL_SECTION *const pCriticalSection, const UINT_PTR RecursionCount );
void	DNCSTrackSetCriticalSectionGroup( DNCRITICAL_SECTION *const pCriticalSection, CBilink * const pblGroup );
void	DNCSTrackSetCriticalSectionLockOrder( DNCRITICAL_SECTION *const pCriticalSection, const DWORD dwLockOrder );
void	DNCSTrackCriticalSectionIsTakenByThisThread( const DNCRITICAL_SECTION *const pCriticalSection, const BOOL fFlag );
void	DNCSTrackNoCriticalSectionsTakenByThisThread( CBilink * pblGroup );

#define	DNInitializeCriticalSection( arg )				DNCSTrackInitializeCriticalSection( arg )
#define	DNDeleteCriticalSection( arg )					DNCSTrackDeleteCriticalSection( arg )
#define	DNEnterCriticalSection( arg )					DNCSTrackEnterCriticalSection( arg )
#define	DNLeaveCriticalSection( arg )					DNCSTrackLeaveCriticalSection( arg )
#define	DebugSetCriticalSectionRecursionCount( pCS, Count )		DNCSTrackSetCriticalSectionRecursionCount( pCS, Count )
#define	DebugSetCriticalSectionGroup( pCS, pblGroup )			DNCSTrackSetCriticalSectionGroup( pCS, pblGroup )
#define	DebugSetCriticalSectionLockOrder( pCS, dwLockOrder )		DNCSTrackSetCriticalSectionLockOrder( pCS, dwLockOrder )
#define	AssertCriticalSectionIsTakenByThisThread( pCS, Flag )		DNCSTrackCriticalSectionIsTakenByThisThread( pCS, Flag )
#define	AssertNoCriticalSectionsTakenByThisThread()			DNCSTrackNoCriticalSectionsTakenByThisThread( NULL )
#define	AssertNoCriticalSectionsFromGroupTakenByThisThread( pblGroup )	DNCSTrackNoCriticalSectionsTakenByThisThread( pblGroup )

#else // !DBG

#define DNCRITICAL_SECTION CRITICAL_SECTION

#define	DNInitializeCriticalSection( arg )				DNOSInitializeCriticalSection( arg )
#define	DNDeleteCriticalSection( arg )					DeleteCriticalSection( arg )
#define	DNEnterCriticalSection( arg )					EnterCriticalSection( arg )
#define	DNLeaveCriticalSection( arg )					LeaveCriticalSection( arg )
#define	DebugSetCriticalSectionRecursionCount( pCS, Count )
#define	DebugSetCriticalSectionGroup( pCS, pblGroup )
#define	DebugSetCriticalSectionLockOrder( pCS, dwLockOrder )
#define	AssertCriticalSectionIsTakenByThisThread( pCS, Flag )
#define	AssertNoCriticalSectionsTakenByThisThread()
#define	AssertNoCriticalSectionsFromGroupTakenByThisThread( pblGroup )

#endif // DBG
#endif // DPNBUILD_ONLYONETHREAD

#endif	// __CRITSECTRACKING_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\dncmni.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DNCOMMONi.h
 *  Content:    DirectPlay Common master internal header file.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/28/01    masonb  Created.
 *
 ***************************************************************************/

#ifndef __DNCOMMONI_H__
#define __DNCOMMONI_H__

//
// Build configuration include
//
#include "dpnbuild.h"

// 
// Public includes
//
#if ((defined(_XBOX)) && (! defined(XBOX_ON_DESKTOP)))
#include <xtl.h>
#include <stdio.h>	// for DNGetProfileInt
#else // ! _XBOX or XBOX_ON_DESKTOP
#include <windows.h>
#include <mmsystem.h>
#ifndef WINCE
#include <inetmsg.h>
#endif // ! WINCE
#include <tapi.h>
#include <stdio.h> // swscanf being used by guidutil.cpp
#ifdef WINNT
#include <accctrl.h>
#include <aclapi.h>
#endif // WINNT
#include <winsock.h>
#endif // ! _XBOX or XBOX_ON_DESKTOP
#include <tchar.h>
#ifndef _XBOX
#include <wincrypt.h>
#endif

// 
// DirectPlay public includes
//
#include "dplay8.h"

// 
// Common private includes
//
#include "dndbg.h"
#include "osind.h"
#include "FixedPool.h"
#include "classbilink.h"
#include "dneterrors.h"
#include "creg.h"
#include "strutils.h"
#include "ReadWriteLock.h"
#include "HandleTable.h"
#include "ClassFactory.h"
#include "HashTable.h"
#include "CallStack.h"
#include "dnnbqueue.h"
#include "dnslist.h"
#include "CritsecTracking.h"
#include "HandleTracking.h"
#include "MemoryTracking.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_COMMON


#endif // __DNCOMMONI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\creg.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		creg.h
 *  Content:	definition of the CRegistry class
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	07/16/99	rodtoll	Created
 *	08/18/99	rodtoll	Added Register/UnRegister that can be used to
 *						allow COM objects to register themselves.
 *	08/25/99	rodtoll	Updated to provide read/write of binary (blob) data
 *	10/07/99	rodtoll	Updated to work in Unicode
 *	10/27/99	pnewson	added Open() call that takes a GUID
 *	01/18/00	mjn		Added GetMaxKeyLen function
 *	01/24/00	mjn		Added GetValueSize function
 *	04/05/2000	jtk		Changed GetVauleSize to GetValueLength and modified to return WCHAR lengths
 * 	04/21/2000   	rodtoll Bug #32889 - Does not run on Win2k on non-admin account 
 *      	        rodtoll Bug #32952 - Does not run on Win95 GOLD w/o IE4 -- modified
 *		                to allow reads of REG_BINARY when expecting REG_DWORD 
 * 	07/09/2000	rodtoll	Added signature bytes 
 *	08/28/2000	masonb	Voice Merge: Modified platform checks to use osind.cpp layer (removed CRegistry::CheckUnicodePlatform)
 *  04/13/2001	VanceO	Moved granting registry permissions into common, and
 *						added DeleteValue and EnumValues.
 *  06/19/2001  RichGr  DX8.0 added special security rights for "everyone" - remove them if
 *                      they exist with new RemoveAllAccessSecurityPermissions() method.
 *
 ***************************************************************************/

#ifndef __CREGISTRY_H
#define __CREGISTRY_H


#ifndef DPNBUILD_NOREGISTRY


// Useful definition
#define MAX_REGISTRY_STRING_SIZE		_MAX_PATH+1

#define DPN_KEY_ALL_ACCESS				((KEY_ALL_ACCESS & ~WRITE_DAC) & ~WRITE_OWNER)


#define VSIG_CREGISTRY			'GERV'
#define VSIG_CREGISTRY_FREE		'GER_'

#define ReadBOOL( keyname, boolptr ) ReadDWORD( (keyname), (DWORD*) (boolptr) )
#define WriteBOOL( keyname, boolval ) WriteDWORD( (keyname), (DWORD) (boolval) )


// CRegistry
//
// This class handles reading/writing to the windows registry.  Each instance
// of the CRegistry class is attached to a single registry handle, which is
// an open handle to a point in the registry tree.
//
class CRegistry
{

public:

	CRegistry();
	~CRegistry();

    BOOL        EnumKeys( LPWSTR lpwStrName, LPDWORD lpdwStringLen, DWORD index = 0 );
    BOOL        EnumValues( LPWSTR lpwStrName, LPDWORD lpdwStringLen, DWORD index = 0 );

	BOOL		Open( const HKEY branch, const LPCWSTR pathName, BOOL fReadOnly = TRUE, BOOL create = FALSE, BOOL fCustomSAM = FALSE, REGSAM samCustom = NULL);
	BOOL		Open( const HKEY branch, const GUID* lpguid, BOOL fReadOnly = TRUE, BOOL create = FALSE, BOOL fCustomSAM = FALSE, REGSAM samCustom = NULL);
	BOOL		Close();

	BOOL		IsOpen() const	{ return m_isOpen;	};

	BOOL		DeleteSubKey( LPCWSTR keyName );
	BOOL        	DeleteSubKey( const GUID *pGuidName );

	BOOL		DeleteValue( LPCWSTR valueName );

    BOOL        ReadGUID( LPCWSTR keyName, GUID* guid );
    BOOL        WriteGUID( LPCWSTR keyName, const GUID &guid );

	BOOL		WriteString( LPCWSTR keyName, const LPCWSTR lpwstrValue );
	BOOL		ReadString( LPCWSTR keyName, LPWSTR lpwstrValue, LPDWORD lpdwLength );

	BOOL		WriteDWORD( LPCWSTR keyName, DWORD value );
	BOOL		ReadDWORD( LPCWSTR keyName, DWORD* presult );

	BOOL		ReadBlob( LPCWSTR keyName, LPBYTE lpbBuffer, LPDWORD lpdwSize );
	BOOL		WriteBlob( LPCWSTR keyName, const BYTE* const lpbBuffer, DWORD dwSize );

	BOOL		GetMaxKeyLen( DWORD* pdwMaxKeyLen );
	BOOL		GetValueLength( const LPCWSTR keyName, DWORD *const pdwValueLength );

#ifdef WINNT
	BOOL		GrantAllAccessSecurityPermissions();
	BOOL		RemoveAllAccessSecurityPermissions();
#endif // WINNT

#ifndef DPNBUILD_NOCOMREGISTER
	static BOOL	Register( LPCWSTR lpszProgID, LPCWSTR lpszDesc, LPCWSTR lpszProgName, const GUID* pguidCLSID, LPCWSTR lpszVerIndProgID );
	static BOOL UnRegister( const GUID* pguidCLSID );
#endif // !DPNBUILD_NOCOMREGISTER

	// Data access functions
	operator	HKEY() const		{ return m_regHandle; };
	HKEY		GetBaseHandle() const { return m_baseHandle; };
	HKEY		GetHandle() const { return m_regHandle; };

protected:

	DWORD	m_dwSignature;	// Signature
	BOOL    m_fReadOnly;

	BOOL	m_isOpen;		// BOOL indicating if the object is open
	HKEY	m_regHandle;	// Handle to the registry which is represented by this object
	HKEY	m_baseHandle;	// Handle to the root of the part of the registry
							// this object is in.  E.g. HKEY_LOCAL_MACHINE
};


#endif // ! DPNBUILD_NOREGISTRY


#endif // __CREGISTRY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\dndbg.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dndbg.c
 *  Content:	debug support for DirectPlay8
 *				
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  05-20-99	aarono	Created
 *  07-16-99	johnkan	Fixed include of OSInd.h, defined WSPRINTF macro
 *  07-19-99	vanceo	Explicitly declared OutStr as returning void for NT
 *						Build environment.
 *	07-22-99	a-evsch	Check for multiple Inits,  and release CritSec when DebugPrintf
 *						returns early.
 *	08-02-99	a-evsch	Added LOGPF support. LW entries only go into shared-file log
 *	08-31-99	johnkan	Removed include of <OSIND.H>
 *  02-17-00  	rodtoll	Added Memory / String validation routines
 *  05-23-00    RichGr  IA64: Changed some DWORDs to DWORD_PTRs to make va_arg work OK.
 *  07-16-00    jchauvin IA64:  Added %p parsing to change back to %x for Win9x machines in DebugPrintf, DebugPrintfNoLock, LogPrintf
 *  07-24-00    RichGr  IA64: As there's no separate build for Win9x, added code to detect Win9x for the %p parse-and-replace.
 *	07-29-00	masonb	Rewrite to add logging by subcomponent, perf improvements, process ID
 *	08/28/2000	masonb	Voice Merge: Modified asm in DebugPrintf to preserve registers that may have affected Voice
 *  03/29/2001  RichGr  If DPINST is defined for Performance Instrumentation, allow free build to pick up the code.
 *	
 *  Notes:
 *	
 *  Use /Oi compiler option for strlen()
 *
 ***************************************************************************/

#include "dncmni.h"
#include "memlog.h"

#if defined(DBG) || defined(DPINST)

void DebugPrintfInit(void);
void DebugPrintfFini(void);

// The constructor of this will be called prior to DllMain and the destructor
// after DllMain, so we can be assured of having the logging code properly
// initialized and deinitialized for the life of the module.
struct _InitDbg
{
	_InitDbg() { DebugPrintfInit(); }
	~_InitDbg() { DebugPrintfFini(); }
} DbgInited;

//===============
// Debug  support
//===============

/*******************************************************************************
	This file contains support for the following types of logging:
		1. Logging to a VXD (Win9x only)
		2. Logging to a shared memory region
		3. Logging to the Debug Output
		4. Logging to a message box
		5. FUTURE: Logging to a file

	General:
	========

	Debug Logging and playback is designed to operate on both Win9x and
	Windows NT (Windows 2000).  A shared file is used to capture information
	and can be played back using dp8log.exe.

	Under NT you can use the 'dt' command of NTSD to dump structures.  For
	example:

		dt DIRECTPLAYOBJECT <some memory address>

	will show all of the members of the DIRECTPLAYOBJECT structure at the
	specified address.  Some features are available only in post-Win2k
	versions of NTSD which can be obtained at http://dbg.

	Logging:
	========

	Debug Logging is controlled by settings in the WIN.INI file, under
	the section heading [DirectPlay8].  There are several settings:

	debug=9

	controls the default debug level.  All messages, at or below that debug level
	are printed.  You can control logging by each component specified in the
	g_rgszSubCompName member by adding its name to the end of the 'debug' setting:

	debug.addr=9

	sets the logging level for the addressing subcomponent to 9, leaving all
	others at either their specified level or the level specified by 'debug'
	if there is no specific level specified.

	The second setting controls where the log is seen.  If not specified, all
	debug logs are sent through the standard DebugPrint and will appear in a
	debugger if it is attached.

	log=0 {no debug output}
	log=1 {spew to console only}
	log=2 {spew to shared memory log only}
	log=3 {spew to console and shared memory log}
	log=4 {spew to message box}

	This setting can also be divided by subcomponent, so:

	log=3
	log.protocol=2

	sends logs for the 'protocol' subcomponent to the shared memory log only, and
	all other logs to both locations.

	example win.ini...

	[DirectPlay8]
	Debug=7		; lots of spew
	log=2		; don't spew to debug window

	[DirectPlay8]
	Debug=0		; only fatal errors spewed to debug window

	Asserts:
	========
	Asserts are used to validate assumptions in the code.  For example
	if you know that the variable jojo should be > 700 and are depending
	on it in subsequent code, you SHOULD put an assert before the code
	that acts on that assumption.  The assert would look like:

	DNASSERT(jojo>700);

	Asserts generally will produce 3 lines of debug spew to highlight the
	breaking of the assumption.  You can add text to your asserts by ANDing:
	
	  DNASSERT(jojo>700 && "Jojo was too low");
	
	Will show the specified text when the assert occurs. For testing, you might
	want to set the system to break in on asserts.  This is done in the
	[DirectPlay8] section of WIN.INI by setting BreakOnAssert=TRUE:

	[DirectPlay8]
	Debug=0
	BreakOnAssert=1
	Verbose=1

	The Verbose setting enables logging of file, function, and line information.

	Debug Breaks:
	=============
	When something really severe happens and you want the system to break in
	so that you can debug it later, you should put a debug break in the code
	path.  Some people use the philosophy that all code paths must be
	verified by hand tracing each one in the debugger.  If you abide by this
	you should place a DEBUG_BREAK() in every code path and remove them
	from the source as you trace each.  When you have good coverage but
	some unhit paths (error conditions) you should force those paths in
	the debugger.

	Debug Logging to Shared Memory Region:
	======================================

	All processes will share the same memory region, and will log the specified amount
	of activity.  The log can be viewed with the DPLOG.EXE utility.

	Debug Logging to Debug Output:
	==============================
	This option uses OutputDebugString to log the specified amount of activity.

	Debug Logging to Message Box:
	==============================
	This option uses MessageBox to log the specified amount of activity.

==============================================================================*/

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_COMMON

#define ASSERT_BUFFER_SIZE   8192
#define ASSERT_BANNER_STRING "************************************************************"
#define ASSERT_MESSAGE_LEVEL 0

#define PROF_SECT		_T("DirectPlay8")

DWORD g_dwMemLogNumEntries = DPLOG_DEFAULT_ENTRIES;		// Default Num entries for MEM log, settable in win.ini
DWORD g_dwMemLogLineSize = DPLOG_MAX_STRING;	// Default number of bytes per log entry

//
// Globals for shared memory based logging
//
#ifndef DPNBUILD_SINGLEPROCESS
HANDLE g_hMemLogFile = 0; // NOTE: This is 0 because CreateFileMapping returns 0 on failure
HANDLE g_hMemLogMutex = 0; // NOTE: This is 0 because CreateMutex returns 0 on failure
#endif // ! DPNBUILD_SINGLEPROCESS
PSHARED_LOG_FILE g_pMemLog = 0;

BOOL g_fMemLogInited = FALSE;

#ifndef DPNBUILD_SINGLEPROCESS
DWORD g_fAssertGrabMutex = FALSE;
#endif // ! DPNBUILD_SINGLEPROCESS

// Values for g_rgDestination
#define LOG_TO_DEBUG    1
#define LOG_TO_MEM      2
#define LOG_TO_MSGBOX   4

LPTSTR g_rgszSubCompName[] =
{
	_T("UNK"),			// DN_SUBCOMP_GLOBAL		0
	_T("CORE"),			// DN_SUBCOMP_CORE			1
	_T("ADDR"),			// DN_SUBCOMP_ADDR			2
	_T("LOBBY"),		// DN_SUBCOMP_LOBBY			3
	_T("PROTOCOL"),		// DN_SUBCOMP_PROTOCOL		4
	_T("VOICE"),		// DN_SUBCOMP_VOICE			5
	_T("DPNSVR"),		// DN_SUBCOMP_DPNSVR		6
	_T("WSOCK"),		// DN_SUBCOMP_WSOCK			7
	_T("MODEM"),		// DN_SUBCOMP_MODEM			8
	_T("COMMON"),		// DN_SUBCOMP_COMMON		9
	_T("NATHELP"),		// DN_SUBCOMP_NATHELP		10
	_T("TOOLS"),		// DN_SUBCOMP_TOOLS			11
	_T("THREADPOOL"),	// DN_SUBCOMP_THREADPOOL	12
	_T("BLUETOOTH"),	// DN_SUBCOMP_BLUETOOTH		13
	_T("MAX"),			// DN_SUBCOMP_MAX			14	// NOTE: this should never get used, but
														// is needed due to the way DebugPrintfInit
														// is written, since it reads one past the end.
};

#define MAX_SUBCOMPS (sizeof(g_rgszSubCompName)/sizeof(g_rgszSubCompName[0]) - 1)

UINT	g_rgLevel[MAX_SUBCOMPS]			= {0};
UINT	g_rgDestination[MAX_SUBCOMPS]	= {LOG_TO_DEBUG | LOG_TO_MEM};
UINT	g_rgBreakOnAssert[MAX_SUBCOMPS]	= {1};// if non-zero, causes DEBUG_BREAK on false asserts.

// if TRUE, file/line/module information is printed and logged.
DWORD	g_fLogFileAndLine = FALSE;	



// Create a shared file for logging information on the fly
// This support allows the current log to be dumped from the
// user mode DP8LOG.EXE application.  This is useful when debugging
// in MSSTUDIO or in NTSD.  When DP8LOG.EXE is invoked, note that
// the application will get halted until the log is completely dumped
// so it is best to dump the log to a file.

#undef DPF_MODNAME
#define DPF_MODNAME "InitMemLogString"
static BOOL InitMemLogString(VOID)
{
	if(!g_fMemLogInited)
	{
		BOOL fInitLogFile = TRUE;

#ifdef DPNBUILD_SINGLEPROCESS
		g_pMemLog = (PSHARED_LOG_FILE)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (DPLOG_HEADERSIZE + (DPLOG_ENTRYSIZE*g_dwMemLogNumEntries)));
		if (!g_pMemLog)
		{
			return FALSE;
		}
#else // ! DPNBUILD_SINGLEPROCESS
		g_hMemLogFile = CreateFileMapping(INVALID_HANDLE_VALUE, DNGetNullDacl(), PAGE_READWRITE, 0, (DPLOG_HEADERSIZE + (DPLOG_ENTRYSIZE*g_dwMemLogNumEntries)), GLOBALIZE_STR _T(BASE_LOG_MEMFILENAME));
		if (!g_hMemLogFile)
		{
			return FALSE;
		}
		if (GetLastError() == ERROR_ALREADY_EXISTS)
		{
			fInitLogFile = FALSE;
		}

		g_hMemLogMutex = CreateMutex(DNGetNullDacl(), FALSE, GLOBALIZE_STR _T(BASE_LOG_MUTEXNAME));
		if (!g_hMemLogMutex)
		{
			CloseHandle(g_hMemLogFile);
			g_hMemLogFile = 0;
			return FALSE;
		}
		g_pMemLog = (PSHARED_LOG_FILE)MapViewOfFile(g_hMemLogFile, FILE_MAP_ALL_ACCESS,0,0,0);
		if (!g_pMemLog)
		{
			CloseHandle(g_hMemLogMutex);
			g_hMemLogMutex = 0;
			CloseHandle(g_hMemLogFile);
			g_hMemLogFile = 0;
			return FALSE;
		}
#endif // ! DPNBUILD_SINGLEPROCESS

		// NOTE: The above 3 functions do return NULL in the case of a failure,
		// not INVALID_HANDLE_VALUE
		if (fInitLogFile)
		{
			g_pMemLog->nEntries = g_dwMemLogNumEntries;
			g_pMemLog->cbLine   = g_dwMemLogLineSize;
			g_pMemLog->iWrite   = 0;
		}
		else
		{
			// This happens when someone before us has already created the mem log.  Could be a previous DPlay instance or TestNet.
			g_dwMemLogNumEntries = g_pMemLog->nEntries;
			g_dwMemLogLineSize = g_pMemLog->cbLine;
		}

		if (g_dwMemLogNumEntries && g_dwMemLogLineSize)
		{
			g_fMemLogInited = TRUE;
		}
	}
	return g_fMemLogInited;
}

// Log a string to a shared file.  This file can be dumped using the
// DPLOG.EXE utility.
//
// dwLength is in bytes and does not include the '\0'
//
void MemLogString(LPCTSTR str, size_t dwLength)
{
	PMEMLOG_ENTRY pEntry;
	size_t cbCopy;


	// If this isn't inited, InitMemLogString failed earlier
	if(!g_fMemLogInited)
	{
		return;
	}

#ifndef DPNBUILD_SINGLEPROCESS
	WaitForSingleObject(g_hMemLogMutex, INFINITE);
#endif // ! DPNBUILD_SINGLEPROCESS

	pEntry = (PMEMLOG_ENTRY)(((PUCHAR)(g_pMemLog + 1)) + (g_pMemLog->iWrite * (sizeof(MEMLOG_ENTRY) + g_dwMemLogLineSize)));
	g_pMemLog->iWrite = (g_pMemLog->iWrite + 1) % g_dwMemLogNumEntries;

#ifndef DPNBUILD_SINGLEPROCESS
	ReleaseMutex(g_hMemLogMutex);
#endif // ! DPNBUILD_SINGLEPROCESS

	pEntry->tLogged = GETTIMESTAMP();

	cbCopy = dwLength + sizeof(TCHAR);		// Add the terminating NULL
	if(cbCopy > g_dwMemLogLineSize)
	{
		cbCopy = g_dwMemLogLineSize;
	}
	memcpy(pEntry->str, str, cbCopy);
	pEntry->str[(cbCopy / sizeof(TCHAR)) - 2] = _T('\n');		// Ensure we always end with a return
	pEntry->str[(cbCopy / sizeof(TCHAR)) - 1] = _T('\0');		// Ensure we always NULL terminate
}

// DebugPrintfInit() - initialize DPF support.
void DebugPrintfInit()
{
	BOOL fUsingMemLog = FALSE;

	TCHAR szLevel[32] = {0};
	_tcscpy(szLevel, _T("debug"));

	TCHAR szDest[32] = {0};
	_tcscpy(szDest, _T("log"));

	TCHAR szBreak[32] = {0};
	_tcscpy(szBreak, _T("breakonassert"));

	// Loop through all the subcomps, and get the level and destination for each
	for (int iSubComp = 0; iSubComp < MAX_SUBCOMPS; iSubComp++)
	{
		// NOTE: The setting under "debug" sets the default and will be used if you
		// don't specify settings for each subcomp
		g_rgLevel[iSubComp] = DNGetProfileInt(PROF_SECT, szLevel, g_rgLevel[0]);
		g_rgDestination[iSubComp] = DNGetProfileInt(PROF_SECT, szDest, g_rgDestination[0]);
		g_rgBreakOnAssert[iSubComp] = DNGetProfileInt( PROF_SECT, szBreak, g_rgBreakOnAssert[0]);

		if (g_rgDestination[iSubComp] & LOG_TO_MEM)
		{
			fUsingMemLog = TRUE;
		}

		// Set up for the next subcomp
		_tcscpy(szLevel + 5, _T(".")); // 5 is strlen of "debug", we are building debug.addr, etc.
		_tcscpy(szLevel + 6, g_rgszSubCompName[iSubComp + 1]);

		_tcscpy(szDest + 3, _T(".")); // 3 is strlen of "log", we are building log.addr, etc.
		_tcscpy(szDest + 4, g_rgszSubCompName[iSubComp + 1]);

		_tcscpy(szBreak + 13, _T(".")); // 13 is strlen of "breakonassert", we are building breakonassert.addr, etc.
		_tcscpy(szBreak + 14, g_rgszSubCompName[iSubComp + 1]);
	}

	g_dwMemLogNumEntries = DNGetProfileInt( PROF_SECT, _T("MemLogEntries"), DPLOG_DEFAULT_ENTRIES);
	g_fLogFileAndLine = DNGetProfileInt( PROF_SECT, _T("Verbose"), 0);
#ifndef DPNBUILD_SINGLEPROCESS
	g_fAssertGrabMutex = DNGetProfileInt( PROF_SECT, _T("AssertGrabMutex"), 0);
#endif // ! DPNBUILD_SINGLEPROCESS

	if (fUsingMemLog)
	{
		// Open the shared log file
		InitMemLogString();	
	}
}

// DebugPrintfFini() - release resources used by DPF support.
void DebugPrintfFini()
{
	if(g_pMemLog)
	{
#ifdef DPNBUILD_SINGLEPROCESS
		HeapFree(GetProcessHeap(), 0, g_pMemLog);
#else // ! DPNBUILD_SINGLEPROCESS
		UnmapViewOfFile(g_pMemLog);
#endif // ! DPNBUILD_SINGLEPROCESS
		g_pMemLog = NULL;
	}
#ifndef DPNBUILD_SINGLEPROCESS
	if(g_hMemLogMutex)
	{
		CloseHandle(g_hMemLogMutex);
		g_hMemLogMutex = 0;
	}
	if(g_hMemLogFile)
	{
		CloseHandle(g_hMemLogFile);
		g_hMemLogFile = 0;
	}
#endif // ! DPNBUILD_SINGLEPROCESS
	g_fMemLogInited = FALSE;
}

void DebugPrintfX(LPCTSTR szFile, DWORD dwLine, LPCTSTR szModName, DWORD dwSubComp, DWORD dwDetail, ...)
{
	DNASSERT(dwSubComp < MAX_SUBCOMPS);

	if(g_rgLevel[dwSubComp] < dwDetail)
	{
		return;
	}
	
	TCHAR  cMsg[ ASSERT_BUFFER_SIZE ];
	va_list argptr;
	LPTSTR pszCursor = cMsg;

	va_start(argptr, dwDetail);


#ifdef UNICODE
	WCHAR szFormat[ASSERT_BUFFER_SIZE];
	LPSTR szaFormat;
	szaFormat = (LPSTR) va_arg(argptr, DWORD_PTR);
	STR_jkAnsiToWide(szFormat, szaFormat, ASSERT_BUFFER_SIZE);
#else
	LPSTR szFormat;
	szFormat = (LPSTR) va_arg(argptr, DWORD_PTR);
#endif // UNICODE


	cMsg[0] = 0;

#ifdef WIN95
    TCHAR  *psz = NULL;
	CHAR  cTemp[ ASSERT_BUFFER_SIZE ];
		
    strcpy(cTemp, szFormat);                // Copy to a local string that we can modify.
	szFormat = cTemp;					    // Point szFormat at the local string

    while (psz = strstr(szFormat, "%p"))    // Look for each "%p".
       *(psz+1) = 'x';                      // Substitute 'x' for 'p'.  Don't try to expand
#endif // WIN95

	// Prints out / logs as:
	// 1. Verbose
	// subcomp:dwDetail:ProcessId:ThreadId:File:Function:Line:DebugString
	// e.g.
	// ADDR:2:0450:0378:(c:\somefile.cpp)BuildURLA(L25)Can you believe it?
	//
	// 2. Regular
	// subcomp:dwDetail:ProcessId:ThreadId:Function:DebugString

#ifndef DPNBUILD_SINGLEPROCESS
	pszCursor += wsprintf(pszCursor,_T("%s:%1d:%04x:%04x:"),g_rgszSubCompName[dwSubComp],dwDetail,GetCurrentProcessId(),GetCurrentThreadId());
#else
	pszCursor += wsprintf(pszCursor,_T("%s:%1d:%04x:"),g_rgszSubCompName[dwSubComp],dwDetail,GetCurrentThreadId());
#endif // ! DPNBUILD_SINGLEPROCESS

	if (g_fLogFileAndLine)
	{
		LPCTSTR c;

		int i = _tcslen(szFile);
		if (i < 25)
		{
			c = szFile;
		}
		else
		{
			c = szFile + i - 25;
		}

		pszCursor += wsprintf(pszCursor, _T("(%s)(L%d)"), c, dwLine);
	}

	pszCursor += wsprintf(pszCursor, _T("%s: "), szModName);

	pszCursor += wvsprintf(pszCursor, szFormat, argptr);

	_tcscpy(pszCursor, _T("\n"));
	pszCursor += _tcslen(pszCursor);

	if(g_rgDestination[dwSubComp] & LOG_TO_DEBUG)
	{
		// log to debugger output
		OutputDebugString(cMsg);
	}

	if(g_rgDestination[dwSubComp] & LOG_TO_MEM)
	{
		// log to shared file, pass length not including '\0'
		MemLogString(cMsg, ((PBYTE)pszCursor - (PBYTE)cMsg));
	}	

#ifndef _XBOX
	if(g_rgDestination[dwSubComp] & LOG_TO_MSGBOX)
	{
		// log to Message Box
		MessageBox(NULL, cMsg, _T("DirectPlay Log"), MB_OK);
	}
#endif // ! _XBOX

	va_end(argptr);

	return;
}


//
// NOTE: I don't want to get into error checking for buffer overflows when
// trying to issue an assertion failure message. So instead I just allocate
// a buffer that is "bug enough" (I know, I know...)
//

void _DNAssert( LPCTSTR szFile, DWORD dwLine, LPCTSTR szFnName, DWORD dwSubComp, LPCTSTR szCondition, DWORD dwLevel )
{
    TCHAR buffer[ASSERT_BUFFER_SIZE];


	// For level 1 we always print the message to the log, but we may not actually break.  For other levels
	// we either print and break or do neither.
	if (dwLevel <= g_rgBreakOnAssert[dwSubComp] || dwLevel == 1)
	{
		// Build the debug stream message
		wsprintf( buffer, _T("ASSERTION FAILED! File: %s Line: %d: %s"), szFile, dwLine, szCondition);

		// Actually issue the message. These messages are considered error level
		// so they all go out at error level priority.

		DebugPrintfX(szFile, dwLine, szFnName, dwSubComp, ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );
		DebugPrintfX(szFile, dwLine, szFnName, dwSubComp, ASSERT_MESSAGE_LEVEL, "%s", buffer );
		DebugPrintfX(szFile, dwLine, szFnName, dwSubComp, ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );

		// Should we drop into the debugger?
		if(g_rgBreakOnAssert[dwSubComp])
		{
#ifndef DPNBUILD_SINGLEPROCESS
			// Don't let dpnsvr keep writing to the log
			if (g_hMemLogMutex && g_fAssertGrabMutex)
			{
				WaitForSingleObject(g_hMemLogMutex, INFINITE);
			}
#endif // ! DPNBUILD_SINGLEPROCESS

			// Into the debugger we go...
			DEBUG_BREAK();

#ifndef DPNBUILD_SINGLEPROCESS
			if (g_hMemLogMutex && g_fAssertGrabMutex)
			{
				ReleaseMutex(g_hMemLogMutex);
			}
#endif // ! DPNBUILD_SINGLEPROCESS
		}
	}
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\dndbg.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 - 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dndbg.h
 *  Content:	debug support functions for DirectNet
 *				
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  05-20-99	aarono	Created
 *	07-16-99	johnkan	Added DEBUG_ONLY, DBG_CASSERT, fixed DPFERR to take an argument
 *  02-17-00	rodtoll	Added Memory / String validation routines
 *  05-23-00	RichGr  IA64: Changed some DWORDs to DWORD_PTRs to make va_arg work OK.
 *  07-27-00	masonb	Rewrite to make sub-component stuff work, improve perf
 *  08/28/2000	masonb	Voice Merge: Part of header guard was missing (#define _DNDBG_H_)
 *  10/25/2001	vanceo	Use NT build friendly BUGBUG, TODO, plus add PRINTVALUE.
 *
 ***************************************************************************/

#ifndef _DNDBG_H_
#define _DNDBG_H_

#ifdef __cplusplus
	extern "C" {
#endif // __cplusplus

// DEBUG_BREAK()
#if defined(DBG) || defined(DPINST)
	#define DEBUG_BREAK() DebugBreak()
#endif // defined(DBG) || defined(DPINST)


//==================================================================================
// Useful macros based on some DNet code (which was taken from code by ToddLa)
//==================================================================================
//
// Macros that generate compile time messages.  Use these with #pragma:
//
//	#pragma TODO(vanceo, "Fix this later")
//	#pragma BUGBUG(vanceo, "Busted!")
//	#pragma PRINTVALUE(DPERR_SOMETHING)
//
// To turn them off, define TODO_OFF, BUGBUG_OFF, PRINTVALUE_OFF in your project
// preprocessor defines.
//
//
// If we're building under VC, (as denoted by the preprocessor define
// DPNBUILD_ENV_NT), these expand to look like:
//
//	D:\directory\file.cpp(101) : BUGBUG: vanceo: Busted!
//
// in your output window, and you should be able to double click on it to jump
// directly to that location (line 101 of D:\directory\file.cpp).
//
// If we're building under the NT build environment, these expand to look like:
//
//	BUGBUG: vanceo: D:\directory\file.cpp(101) : Busted!
//
// because (at least right now) the build process thinks that a failure occurred if
// a message beginning with a filename and line number is printed.  It used to work
// just fine, but who knows.
//

#ifdef DPNBUILD_ENV_NT
#define __TODO(user, msgstr, n)								message("TODO: " #user ": " __FILE__ "(" #n ") : " msgstr)
#define __BUGBUG(user, msgstr, n)							message("BUGBUG: " #user ": " __FILE__ "(" #n ") : " msgstr)
#define __PRINTVALUE(itemnamestr, itemvaluestr, n)			message("PRINTVALUE: " __FILE__ "(" #n ") : " itemnamestr " = " itemvaluestr)
#else // ! DPNBUILD_ENV_NT
#define __TODO(user, msgstr, n)								message(__FILE__ "(" #n ") : TODO: " #user ": " msgstr)
#define __BUGBUG(user, msgstr, n)							message(__FILE__ "(" #n ") : BUGBUG: " #user ": " msgstr)
#define __PRINTVALUE(itemnamestr, itemvaluestr, n)			message(__FILE__ "(" #n ") : PRINTVALUE: " itemnamestr " = " itemvaluestr)
#endif // ! DPNBUILD_ENV_NT


#define _TODO(user, msgstr, n)								__TODO(user, msgstr, n)
#define _BUGBUG(user, msgstr, n)							__BUGBUG(user, msgstr, n)
#define _PRINTVALUE(itemstr, item, n)						__PRINTVALUE(itemstr, #item, n)


#ifdef TODO_OFF
#define TODO(user, msgstr)
#else
#define TODO(user, msgstr)									_TODO(user, msgstr, __LINE__)
#endif // TODO_OFF

#ifdef BUGBUG_OFF
#define BUGBUG(user, msgstr)
#else
#define BUGBUG(user, msgstr)								_BUGBUG(user, msgstr, __LINE__)
#endif // BUGBUG_OFF

#ifdef PRINTVALUE_OFF
#define PRINTVALUE(item)
#else
#define PRINTVALUE(item)									_PRINTVALUE(#item, item, __LINE__)
#endif // PRINTVALUE_OFF



//========================
// Debug Logging support
//========================

/*=============================================================================
 Usage:

 In code, you can use DPF to print to the log or the debug windows of the
 running application.  The format of DPF (debug printf) is as follows:

	DPFX(DPFPREP,level, string *fmt, arg1, arg2, ...);

 level specifies how important this debug printf is.  The standard convention
 for debug levels is as follows.  This is no way strictly enforced for
 personal use, but by the time the code is checked in, it should be as close
 to this as possible...

  DPF_ERRORLEVEL:		Error useful for application developers.
  DPF_WARNINGLEVEL:		Warning useful for application developers.
  DPF_ENTRYLEVEL:		API Entered
  DPF_APIPARAM:			API parameters, API return values
  DPF_LOCKS:			Driver conversation
  DPF_INFOLEVEL:		Deeper program flow notifications
  DPF_STRUCTUREDUMP:	Dump structures
  DPF_TRACELEVEL:		Trace messages

 When printing a critical error, you can use:
	
	  DPERR( "String" );

 which will print a string at debug level zero.

 In order to cause the code to stop and break in.  You can use ASSERT() or
 DEBUG_BREAK().  In order for ASSERT to break in, you must have
 BreakOnAssert set in the win.ini file section (see osindep.cpp).

=============================================================================*/

#define DPF_ERRORLEVEL			0
#define DPF_WARNINGLEVEL		1
#define DPF_ENTRYLEVEL			2
#define DPF_APIPARAM			3
#define DPF_LOCKS				4
#define DPF_INFOLEVEL			5
#define DPF_STRUCTUREDUMP		6
#define DPF_TRACELEVEL			9

// For Voice
#define DVF_ERRORLEVEL			0
#define DVF_WARNINGLEVEL		1
#define DVF_ENTRYLEVEL			2
#define DVF_APIPARAM			3
#define DVF_LOCKS				4
#define DVF_INFOLEVEL			5
#define DVF_STRUCTUREDUMP		6
#define DVF_TRACELEVEL			9

/*
 * List of all possible sub-components. If you add additional
 * components you also need to update the g_rgszSubCompName 
 * variable defined in dndbg.cpp
 */

#define DN_SUBCOMP_GLOBAL		0
#define DN_SUBCOMP_CORE			1
#define DN_SUBCOMP_ADDR			2
#define DN_SUBCOMP_LOBBY		3
#define DN_SUBCOMP_PROTOCOL		4
#define DN_SUBCOMP_VOICE		5
#define DN_SUBCOMP_DPNSVR		6
#define DN_SUBCOMP_WSOCK		7
#define DN_SUBCOMP_MODEM		8
#define DN_SUBCOMP_COMMON		9
#define DN_SUBCOMP_NATHELP		10
#define DN_SUBCOMP_TOOLS		11
#define DN_SUBCOMP_THREADPOOL	12
#define DN_SUBCOMP_BLUETOOTH	13

#ifdef DBG

extern void DebugPrintfX(LPCTSTR szFile, DWORD dwLineNumber,LPCTSTR szFnName, DWORD dwSubComp, DWORD dwDetail, ...);
extern void _DNAssert(LPCTSTR szFile, DWORD dwLineNumber, LPCTSTR szFnName, DWORD dwSubComp, LPCTSTR szCondition, DWORD dwLevel);

#define DPFX						DebugPrintfX

#define DPFPREP						_T(__FILE__),__LINE__,_T(DPF_MODNAME), DPF_SUBCOMP

#define DPFERR(a) 					DebugPrintfX(DPFPREP, DPF_ERRORLEVEL, a )
#ifdef DPNBUILD_USEASSUME
#define DNASSERT(condition)			__assume(condition)
#define DNASSERTX(condition, level)	DBG_CASSERT(level > 1); if (!(condition)) _DNAssert(DPFPREP, _T(#condition), level)
#else // ! DPNBUILD_USEASSUME
#define DNASSERT(condition) 		if (!(condition)) _DNAssert(DPFPREP, _T(#condition), 1)
#define DNASSERTX(condition, level)	if (!(condition)) _DNAssert(DPFPREP, _T(#condition), level)
#endif // ! DPNBUILD_USEASSUME

#define DBG_CASSERT(exp)			switch (0) case 0: case exp:
#define DEBUG_ONLY(arg)				arg
#define DPF_RETURN(a) 				DPFX(DPFPREP,DPF_APIPARAM,"Returning: 0x%lx",a);    return a;
#define DPF_ENTER() 				DPFX(DPFPREP,DPF_TRACELEVEL, "Enter");
#define DPF_EXIT() 					DPFX(DPFPREP,DPF_TRACELEVEL, "Exit");


#else // NOT DBG

	// C4002: too many actual parameters for macro 'identifier'
	#pragma warning(disable:4002)
	#define DPFX()
	#define DPFERR(a)
#ifdef DPNBUILD_USEASSUME
	#define DNASSERT(condition)			__assume(condition)
	#define DNASSERTX(condition, level)
#else // ! DPNBUILD_USEASSUME
	#define DNASSERT(condition)
	#define DNASSERTX(condition, level)
#endif // ! DPNBUILD_USEASSUME
	#define DBG_CASSERT(exp)
#ifndef DEBUG_ONLY
	#define DEBUG_ONLY(arg)
#endif
	#define DPF_RETURN(a)				return a;	
	#define DPF_ENTER()
	#define DPF_EXIT()

#endif // DBG

#ifdef __cplusplus
	}	//extern "C"
#endif // __cplusplus

#endif // _DNDBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\dneterrors.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DNetErrors.cpp
 *  Content:    Function for expanding Play8 errors to debug output
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/04/98  johnkan	Created
 *	07/22/99	a-evsch	removed DPF_MODNAME.  This is defined in DbgInfo.h
 *	01/24/00	mjn		Added DPNERR_NOHOSTPLAYER error
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include	"dncmni.h"
#include	<Limits.h>

#ifdef DBG

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************
static	char	*GetDNErrorString( const HRESULT DNError );
#ifndef DPNBUILD_NOSERIALSP
static	char	*GetTAPIErrorString( const HRESULT TAPIError );
#endif // ! DPNBUILD_NOSERIALSP
static	char	*GetWIN32ErrorString( const LONG Error );
static	char	*GetWinsockErrorString( const DWORD WinsockError );

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// LclDisplayString - display user string
//
// Entry:		Pointer to string
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "LclDisplayString"

void	LclDisplayString( DWORD ErrorLevel, char *pString )
{
	// was there no error?
	if ( pString != NULL )
	{
		DPFX(DPFPREP,  ErrorLevel, pString );
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// LclDisplayError - display error code
//
// Entry:		Error type
//				Error level
//				Error code
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "LclDisplayError"

void	LclDisplayError( EC_TYPE ErrorType, DWORD ErrorLevel, HRESULT ErrorCode )
{
	char	*pString;


	switch ( ErrorType )
	{
		// DirectNet error
		case EC_DPLAY8:
		{
			pString = GetDNErrorString( ErrorCode );
			break;
		}

		// Win32
		case EC_WIN32:
		{
			pString = GetWIN32ErrorString( ErrorCode );
			break;
		}

#ifndef DPNBUILD_NOSERIALSP
		// TAPI
		case EC_TAPI:
		{
			pString = GetTAPIErrorString( ErrorCode );
			break;
		}
#endif // ! DPNBUILD_NOSERIALSP

		// winsock
		case EC_WINSOCK:
		{
			pString = GetWinsockErrorString( ErrorCode );
			break;
		}

		// unknown type
		default:
		{
			DNASSERT( FALSE );
			pString = "Unknown error type!";
			break;
		}
	}

	LclDisplayString( ErrorLevel, pString );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// GetDNErrorString - convert DirectNet error to a string
//
// Entry:		Error code
//
// Exit:		Pointer to string
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "GetDNErrorString"

static	char	*GetDNErrorString( HRESULT ErrorCode )
{
	char *pString = NULL;


	// what was the error
	switch ( ErrorCode )
	{

		case DPN_OK:
		{
//			no output if no error
//			pString = "DN_OK";
			break;
		}

		case REGDB_E_CLASSNOTREG:
		{
			pString = "REGDB_E_CLASSNOTREG";
			break;
		}

		//
		//	DPN_SUCCESS codes
		//
		case DPNSUCCESS_EQUAL:
		{
			pString = "DPNSUCCESS_EQUAL";
			break;
		}

		case DPNSUCCESS_NOPLAYERSINGROUP:
		{
			pString = "DPNSUCCESS_NOPLAYERSINGROUP";
			break;
		}

		case DPNSUCCESS_NOTEQUAL:
		{
			pString = "DPNSUCCESS_NOTEQUAL";
			break;
		}

//		case DPNSUCCESS_PENDING:
//		{
//
//			Same as DPNERR_PENDING below
//
//			pString = "DPNSUCCESS_PENDING";
//			break;
//		}

		//
		//	Real DPNERR codes
		//
		case DPNERR_ABORTED:
		{
			pString = "DPNERR_ABORTED";
			break;
		}

		case DPNERR_ADDRESSING:
		{
			pString = "DPNERR_ADDRESSING";
			break;
		}

		case DPNERR_ALREADYCLOSING:
		{
			pString = "DPNERR_ALREADYCLOSING";
			break;
		}

		case DPNERR_ALREADYCONNECTED:
		{
			pString = "DPNERR_ALREADYCONNECTED";
			break;
		}

		case DPNERR_ALREADYDISCONNECTING:
		{
			pString = "DPNERR_ALREADYDISCONNECTING";
			break;
		}

		case DPNERR_ALREADYINITIALIZED:
		{
			pString = "DPNERR_ALREADYINITIALIZED";
			break;
		}

		case DPNERR_ALREADYREGISTERED:
		{
			pString = "DPNERR_ALREADYREGISTERED";
			break;
		}

		case DPNERR_BUFFERTOOSMALL:
		{
			pString = "DPNERR_BUFFERTOOSMALL";
			break;
		}

		case DPNERR_CANNOTCANCEL:
		{
			pString = "DPNERR_CANNOTCANCEL";
			break;
		}

		case DPNERR_CANTCREATEGROUP:
		{
			pString = "DPNERR_CANTCREATEGROUP";
			break;
		}

		case DPNERR_CANTCREATEPLAYER:
		{
			pString = "DPNERR_CANTCREATEPLAYER";
			break;
		}

		case DPNERR_CANTLAUNCHAPPLICATION:
		{
			pString = "DPNERR_CANTLAUNCHAPPLICATION";
			break;
		}

		case DPNERR_CONNECTING:
		{
			pString = "DPNERR_CONNECTING";
			break;
		}

		case DPNERR_CONNECTIONLOST:
		{
			pString = "DPNERR_CONNECTIONLOST";
			break;
		}

		case DPNERR_CONVERSION:
		{
			pString = "DPNERR_CONVERSION";
			break;
		}

		case DPNERR_DATATOOLARGE:
		{
			pString = "DPNERR_DATATOOLARGE";
			break;
		}

		case DPNERR_DOESNOTEXIST:
		{
			pString = "DPNERR_DOESNOTEXIST";
			break;
		}

		case DPNERR_DPNSVRNOTAVAILABLE:
		{
			pString = "DPNERR_DPNSVRNOTAVAILABLE";
			break;
		}

		case DPNERR_DUPLICATECOMMAND:
		{
			pString = "DPNERR_DUPLICATECOMMAND";
			break;
		}

		case DPNERR_ENDPOINTNOTRECEIVING:
		{
			pString = "DPNERR_ENDPOINTNOTRECEIVING";
			break;
		}

		case DPNERR_ENUMQUERYTOOLARGE:
		{
			pString = "DPNERR_ENUMQUERYTOOLARGE";
			break;
		}

		case DPNERR_ENUMRESPONSETOOLARGE:
		{
			pString = "DPNERR_ENUMRESPONSETOOLARGE";
			break;
		}

		case DPNERR_EXCEPTION:
		{
			pString = "DPNERR_EXCEPTION";
			break;
		}

		case DPNERR_GENERIC:
		{
			pString = "DPNERR_GENERIC";
			break;
		}

		case DPNERR_GROUPNOTEMPTY:
		{
			pString = "DPNERR_GROUPNOTEMPTY";
			break;
		}

		case DPNERR_HOSTING:
		{
			pString = "DPNERR_HOSTING";
			break;
		}

		case DPNERR_HOSTREJECTEDCONNECTION:
		{
			pString = "DPNERR_HOSTREJECTEDCONNECTION";
			break;
		}

		case DPNERR_HOSTTERMINATEDSESSION:
		{
			pString = "DPNERR_HOSTTERMINATEDSESSION";
			break;
		}

		case DPNERR_INCOMPLETEADDRESS:
		{
			pString = "DPNERR_INCOMPLETEADDRESS";
			break;
		}

		case DPNERR_INVALIDADDRESSFORMAT:
		{
			pString = "DPNERR_INVALIDADDRESSFORMAT";
			break;
		}

		case DPNERR_INVALIDAPPLICATION:
		{
			pString = "DPNERR_INVALIDAPPLICATION";
			break;
		}

		case DPNERR_INVALIDCOMMAND:
		{
			pString = "DPNERR_INVALIDCOMMAND";
			break;
		}

		case DPNERR_INVALIDENDPOINT:
		{
			pString = "DPNERR_INVALIDENDPOINT";
			break;
		}

		case DPNERR_INVALIDFLAGS:
		{
			pString = "DPNERR_INVALIDFLAGS";
			break;
		}

		case DPNERR_INVALIDGROUP:
		{
			pString = "DPNERR_INVALIDGROUP";
			break;
		}

		case DPNERR_INVALIDHANDLE:
		{
			pString = "DPNERR_INVALIDHANDLE";
			break;
		}

		case DPNERR_INVALIDINSTANCE:
		{
			pString = "DPNERR_INVALIDINSTANCE";
			break;
		}

		case DPNERR_INVALIDINTERFACE:
		{
			pString = "DPNERR_INVALIDINTERFACE";
			break;
		}

		case DPNERR_INVALIDDEVICEADDRESS:
		{
			pString = "DPNERR_INVALIDDEVICEADDRESS";
			break;
		}

		case DPNERR_INVALIDOBJECT:
		{
			pString = "DPNERR_INVALIDOBJECT";
			break;
		}

		case DPNERR_INVALIDPARAM:
		{
			pString = "DPNERR_INVALIDPARAM";
			break;
		}

		case DPNERR_INVALIDPASSWORD:
		{
			pString = "DPNERR_INVALIDPASSWORD";
			break;
		}

		case DPNERR_INVALIDPLAYER:
		{
			pString = "DPNERR_INVALIDPLAYER";
			break;
		}

		case DPNERR_INVALIDPOINTER:
		{
			pString = "DPNERR_INVALIDPOINTER";
			break;
		}

		case DPNERR_INVALIDPRIORITY:
		{
			pString = "DPNERR_INVALIDPRIORITY";
			break;
		}

		case DPNERR_INVALIDHOSTADDRESS:
		{
			pString = "DPNERR_INVALIDHOSTADDRESS";
			break;
		}

		case DPNERR_INVALIDSTRING:
		{
			pString = "DPNERR_INVALIDSTRING";
			break;
		}

		case DPNERR_INVALIDURL:
		{
			pString = "DPNERR_INVALIDURL";
			break;
		}

		case DPNERR_INVALIDVERSION:
		{
			pString = "DPNERR_INVALIDVERSION";
			break;
		}

		case DPNERR_NOCAPS:
		{
			pString = "DPNERR_NOCAPS";
			break;
		}

		case DPNERR_NOCONNECTION:
		{
			pString = "DPNERR_NOCONNECTION";
			break;
		}

		case DPNERR_NOHOSTPLAYER:
		{
			pString = "DPNERR_NOHOSTPLAYER";
			break;
		}

		case DPNERR_NOINTERFACE:
		{
			pString = "DPNERR_NOINTERFACE";
			break;
		}

		case DPNERR_NOMOREADDRESSCOMPONENTS:
		{
			pString = "DPNERR_NOMOREADDRESSCOMPONENTS";
			break;
		}

		case DPNERR_NORESPONSE:
		{
			pString = "DPNERR_NORESPONSE";
			break;
		}

		case DPNERR_NOTALLOWED:
		{
			pString = "DPNERR_NOTALLOWED";
			break;
		}

		case DPNERR_NOTHOST:
		{
			pString = "DPNERR_NOTHOST";
			break;
		}

		case DPNERR_NOTREADY:
		{
			pString = "DPNERR_NOTREADY";
			break;
		}

		case DPNERR_NOTREGISTERED:
		{
			pString = "DPNERR_NOTREGISTERED";
			break;
		}

		case DPNERR_OUTOFMEMORY:
		{
			pString = "DPNERR_OUTOFMEMORY";
			break;
		}

		case DPNERR_PENDING:
		{
			pString = "DPNERR_PENDING";
			break;
		}

		case DPNERR_PLAYERLOST:
		{
			pString = "DPNERR_PLAYERLOST";
			break;
		}
		case DPNERR_PLAYERNOTINGROUP:
		{
			pString = "DPNERR_PLAYERNOTINGROUP";
			break;
		}
		case DPNERR_PLAYERNOTREACHABLE:
		{
			pString = "DPNERR_PLAYERNOTREACHABLE";
			break;
		}

		case DPNERR_SENDTOOLARGE:
		{
			pString = "DPNERR_SENDTOOLARGE";
			break;
		}

		case DPNERR_SESSIONFULL:
		{
			pString = "DPNERR_SESSIONFULL";
			break;
		}

		case DPNERR_TABLEFULL:
		{
			pString = "DPNERR_TABLEFULL";
			break;
		}

		case DPNERR_TIMEDOUT:
		{
			pString = "DPNERR_TIMEDOUT";
			break;
		}

		case DPNERR_UNINITIALIZED:
		{
			pString = "DPNERR_UNINITIALIZED";
			break;
		}

		case DPNERR_UNSUPPORTED:
		{
			pString = "DPNERR_UNSUPPORTED";
			break;
		}

		case DPNERR_USERCANCEL:
		{
			pString = "DPNERR_USERCANCEL";
			break;
		}

		// unknown error code, possibly a new one?
		default:
		{
			DPFX(DPFPREP, 0, "Unknown DPlay error code %u/0x%lx", ErrorCode, ErrorCode );

			pString = "Unknown DPlay8 error code";
			break;
		}
	}

	return	pString;
}
//**********************************************************************


#ifndef DPNBUILD_NOSERIALSP

//**********************************************************************
// ------------------------------
// GetTAPIErrorString - convert TAPI error code to a string
//
// Entry:		Error code
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "GetTAPIErrorString"

static	char	*GetTAPIErrorString( const HRESULT TAPIError )
{
	char	*pString;


	switch ( TAPIError )
	{
		// The specified address is blocked from being dialed on the specified call.
		case LINEERR_ADDRESSBLOCKED:
		{
			pString = "LINEERR_ADDRESSBLOCKED";
			break;
		}

		// The line cannot be opened due to a persistent condition, such as that of a serial port being exclusively opened by another process.
		case LINEERR_ALLOCATED:
		{
			pString = "LINEERR_ALLOCATED";
			break;
		}

		// The specified device identifier or line device identifier (such as in a dwDeviceID parameter) is invalid or out of range.
		case LINEERR_BADDEVICEID:
		{
			pString = "LINEERR_BADDEVICEID";
			break;
		}

		// The call's bearer mode cannot be changed to the specified bearer mode.
		case LINEERR_BEARERMODEUNAVAIL:
		{
			pString = "LINEERR_BEARERMODEUNAVAIL";
			break;
		}

		// All call appearances on the specified address are currently in use.
		case LINEERR_CALLUNAVAIL:
		{
			pString = "LINEERR_CALLUNAVAIL";
			break;
		}

		// The maximum number of outstanding call completions has been exceeded.
		case LINEERR_COMPLETIONOVERRUN:
		{
			pString = "LINEERR_COMPLETIONOVERRUN";
			break;
		}

		// The maximum number of parties for a conference has been reached, or the requested number of parties cannot be satisfied.
		case LINEERR_CONFERENCEFULL:
		{
			pString = "LINEERR_CONFERENCEFULL";
			break;
		}

		// The dialable address parameter contains dialing control characters that are not processed by the service provider.
		case LINEERR_DIALBILLING:
		{
			pString = "LINEERR_DIALBILLING";
			break;
		}

		// The dialable address parameter contains dialing control characters that are not processed by the service provider.
		case LINEERR_DIALQUIET:
		{
			pString = "LINEERR_DIALQUIET";
			break;
		}

		// The dialable address parameter contains dialing control characters that are not processed by the service provider.
		case LINEERR_DIALDIALTONE:
		{
			pString = "LINEERR_DIALDIALTONE";
			break;
		}

		// The dialable address parameter contains dialing control characters that are not processed by the service provider.
		case LINEERR_DIALPROMPT:
		{
			pString = "LINEERR_DIALPROMPT";
			break;
		}

		// The application requested an API version or version range that is either incompatible or cannot be supported by the Telephony API implementation and/or corresponding service provider.
		case LINEERR_INCOMPATIBLEAPIVERSION:
		{
			pString = "LINEERR_INCOMPATIBLEAPIVERSION";
			break;
		}

		// The application requested an extension version range that is either invalid or cannot be supported by the corresponding service provider.
		case LINEERR_INCOMPATIBLEEXTVERSION:
		{
			pString = "LINEERR_INCOMPATIBLEEXTVERSION";
			break;
		}

		// The telephon.ini file cannot be read or understood properly by TAPI because of internal inconsistencies or formatting problems. For example, the [Locations], [Cards], or [Countries] section of the telephon.ini file may be corrupted or inconsistent.
		case LINEERR_INIFILECORRUPT:
		{
			pString = "LINEERR_INIFILECORRUPT";
			break;
		}

		// The line device is in use and cannot currently be configured, allow a party to be added, allow a call to be answered, allow a call to be placed, or allow a call to be transferred.
		case LINEERR_INUSE:
		{
			pString = "LINEERR_INUSE";
			break;
		}

		// A specified address is either invalid or not allowed. If invalid, the address contains invalid characters or digits, or the destination address contains dialing control characters (W, @, $, or ?) that are not supported by the service provider. If not allowed, the specified address is either not assigned to the specified line or is not valid for address redirection.
		case LINEERR_INVALADDRESS:
		{
			pString = "LINEERR_INVALADDRESS";
			break;
		}

		// The specified address identifier is either invalid or out of range.
		case LINEERR_INVALADDRESSID:
		{
			pString = "LINEERR_INVALADDRESSID";
			break;
		}

		// The specified address mode is invalid.
		case LINEERR_INVALADDRESSMODE:
		{
			pString = "LINEERR_INVALADDRESSMODE";
			break;
		}

		// dwAddressStates contains one or more bits that are not LINEADDRESSSTATE_ constants.
		case LINEERR_INVALADDRESSSTATE:
		{
			pString = "LINEERR_INVALADDRESSSTATE";
			break;
		}

#ifndef WINCE
		// The specified agent activity is not valid.
		case LINEERR_INVALAGENTACTIVITY:
		{
			pString = "LINEERR_INVALAGENTACTIVITY";
			break;
		}

		// The specified agent group information is not valid or contains errors. The requested action has not been carried out.
		case LINEERR_INVALAGENTGROUP:
		{
			pString = "LINEERR_INVALAGENTGROUP";
			break;
		}

		// The specified agent identifier is not valid.
		case LINEERR_INVALAGENTID:
		{
			pString = "LINEERR_INVALAGENTID";
			break;
		}

//		// The specified agent skill information is not valid.
//		case LINEERR_INVALAGENTSKILL:
//		{
//			pString = "LINEERR_INVALAGENTSKILL";
//			break;
//		}

		// The specified agent state is not valid or contains errors. No changes have been made to the agent state of the specified address.
		case LINEERR_INVALAGENTSTATE:
		{
			pString = "LINEERR_INVALAGENTSTATE";
			break;
		}
#endif // WINCE
//		// The specified agent supervisor information is not valid.
//		case LINEERR_INVALAGENTSUPERVISOR:
//		{
//			pString = "LINEERR_INVALAGENTSUPERVISOR";
//			break;
//		}

		// The application handle (such as specified by a hLineApp parameter) or the appliction registration handle is invalid.
		case LINEERR_INVALAPPHANDLE:
		{
			pString = "LINEERR_INVALAPPHANDLE";
			break;
		}

		// The specified application name is invalid. If an application name is specified by the application, it is assumed that the string does not contain any non-displayable characters, and is zero-terminated.
		case LINEERR_INVALAPPNAME:
		{
			pString = "LINEERR_INVALAPPNAME";
			break;
		}

		// The specified bearer mode is invalid.
		case LINEERR_INVALBEARERMODE:
		{
			pString = "LINEERR_INVALBEARERMODE";
			break;
		}

		// The specified completion is invalid.
		case LINEERR_INVALCALLCOMPLMODE:
		{
			pString = "LINEERR_INVALCALLCOMPLMODE";
			break;
		}

		// The specified call handle is not valid. For example, the handle is not NULL but does not belong to the given line. In some cases, the specified call device handle is invalid.
		case LINEERR_INVALCALLHANDLE:
		{
			pString = "LINEERR_INVALCALLHANDLE";
			break;
		}

		// The specified call parameters are invalid.
		case LINEERR_INVALCALLPARAMS:
		{
			pString = "LINEERR_INVALCALLPARAMS";
			break;
		}

		// The specified call privilege parameter is invalid.
		case LINEERR_INVALCALLPRIVILEGE:
		{
			pString = "LINEERR_INVALCALLPRIVILEGE";
			break;
		}

		// The specified select parameter is invalid.
		case LINEERR_INVALCALLSELECT:
		{
			pString = "LINEERR_INVALCALLSELECT";
			break;
		}

		// The current state of a call is not in a valid state for the requested operation.
		case LINEERR_INVALCALLSTATE:
		{
			pString = "LINEERR_INVALCALLSTATE";
			break;
		}

		// The specified call state list is invalid.
		case LINEERR_INVALCALLSTATELIST:
		{
			pString = "LINEERR_INVALCALLSTATELIST";
			break;
		}

		// The permanent card identifier specified in dwCard could not be found in any entry in the [Cards] section in the registry.
		case LINEERR_INVALCARD:
		{
			pString = "LINEERR_INVALCARD";
			break;
		}

		// The completion identifier is invalid.
		case LINEERR_INVALCOMPLETIONID:
		{
			pString = "LINEERR_INVALCOMPLETIONID";
			break;
		}

		// The specified call handle for the conference call is invalid or is not a handle for a conference call.
		case LINEERR_INVALCONFCALLHANDLE:
		{
			pString = "LINEERR_INVALCONFCALLHANDLE";
			break;
		}

		// The specified consultation call handle is invalid.
		case LINEERR_INVALCONSULTCALLHANDLE:
		{
			pString = "LINEERR_INVALCONSULTCALLHANDLE";
			break;
		}

		// The specified country code is invalid.
		case LINEERR_INVALCOUNTRYCODE:
		{
			pString = "LINEERR_INVALCOUNTRYCODE";
			break;
		}

		// The line device has no associated device for the given device class, or the specified line does not support the indicated device class.
		case LINEERR_INVALDEVICECLASS:
		{
			pString = "LINEERR_INVALDEVICECLASS";
			break;
		}

		// The specified digit list is invalid.
		case LINEERR_INVALDIGITLIST:
		{
			pString = "LINEERR_INVALDIGITLIST";
			break;
		}

		// The specified digit mode is invalid.
		case LINEERR_INVALDIGITMODE:
		{
			pString = "LINEERR_INVALDIGITMODE";
			break;
		}

		// The specified termination digits are not valid.
		case LINEERR_INVALDIGITS:
		{
			pString = "LINEERR_INVALDIGITS";
			break;
		}

		// The dwFeature parameter is invalid.
		case LINEERR_INVALFEATURE:
		{
			pString = "LINEERR_INVALFEATURE";
			break;
		}

		// The specified group identifier is invalid.
		case LINEERR_INVALGROUPID:
		{
			pString = "LINEERR_INVALGROUPID";
			break;
		}

		// The specified call, device, line device, or line handle is invalid.
		case LINEERR_INVALLINEHANDLE:
		{
			pString = "LINEERR_INVALLINEHANDLE";
			break;
		}

		// The device configuration may not be changed in the current line state. The line may be in use by another application or a dwLineStates parameter contains one or more bits that are not LINEDEVSTATE_ constants. The LINEERR_INVALLINESTATE value can also indicate that the device is DISCONNECTED or OUTOFSERVICE. These states are indicated by setting the bits corresponding to the LINEDEVSTATUSFLAGS_CONNECTED and LINEDEVSTATUSFLAGS_INSERVICE values to 0 in the dwDevStatusFlags member of the LINEDEVSTATUS structure returned by the lineGetLineDevStatus function.
		case LINEERR_INVALLINESTATE:
		{
			pString = "LINEERR_INVALLINESTATE";
			break;
		}

		// The permanent location identifier specified in dwLocation could not be found in any entry in the [Locations] section in the registry.
		case LINEERR_INVALLOCATION:
		{
			pString = "LINEERR_INVALLOCATION";
			break;
		}

		// The specified media list is invalid.
		case LINEERR_INVALMEDIALIST:
		{
			pString = "LINEERR_INVALMEDIALIST";
			break;
		}

		// The list of media types to be monitored contains invalid information, the specified media mode parameter is invalid, or the service provider does not support the specified media mode. The media modes supported on the line are listed in the dwMediaModes member in the LINEDEVCAPS structure.
		case LINEERR_INVALMEDIAMODE:
		{
			pString = "LINEERR_INVALMEDIAMODE";
			break;
		}

		// The number given in dwMessageID is outside the range specified by the dwNumCompletionMessages member in the LINEADDRESSCAPS structure.
		case LINEERR_INVALMESSAGEID:
		{
			pString = "LINEERR_INVALMESSAGEID";
			break;
		}

		// A parameter (such as dwTollListOption, dwTranslateOptions, dwNumDigits, or a structure pointed to by lpDeviceConfig) contains invalid values, a country code is invalid, a window handle is invalid, or the specified forward list parameter contains invalid information.
		case LINEERR_INVALPARAM:
		{
			pString = "LINEERR_INVALPARAM";
			break;
		}

		// The specified park mode is invalid.
		case LINEERR_INVALPARKMODE:
		{
			pString = "LINEERR_INVALPARKMODE";
			break;
		}

#ifndef WINCE
		// The specified password is not correct and the requested action has not been carried out.
		case LINEERR_INVALPASSWORD:
		{
			pString = "LINEERR_INVALPASSWORD";
			break;
		}
#endif // WINCE

		// One or more of the specified pointer parameters (such as lpCallList, lpdwAPIVersion, lpExtensionID, lpdwExtVersion, lphIcon, lpLineDevCaps, and lpToneList) are invalid, or a required pointer to an output parameter is NULL.
		case LINEERR_INVALPOINTER:
		{
			pString = "LINEERR_INVALPOINTER";
			break;
		}

		// An invalid flag or combination of flags was set for the dwPrivileges parameter.
		case LINEERR_INVALPRIVSELECT:
		{
			pString = "LINEERR_INVALPRIVSELECT";
			break;
		}

		// The specified bearer mode is invalid.
		case LINEERR_INVALRATE:
		{
			pString = "LINEERR_INVALRATE";
			break;
		}

		// The specified request mode is invalid.
		case LINEERR_INVALREQUESTMODE:
		{
			pString = "LINEERR_INVALREQUESTMODE";
			break;
		}

		// The specified terminal mode parameter is invalid.
		case LINEERR_INVALTERMINALID:
		{
			pString = "LINEERR_INVALTERMINALID";
			break;
		}

		// The specified terminal modes parameter is invalid.
		case LINEERR_INVALTERMINALMODE:
		{
			pString = "LINEERR_INVALTERMINALMODE";
			break;
		}

		// Timeouts are not supported or the values of either or both of the parameters dwFirstDigitTimeout or dwInterDigitTimeout fall outside the valid range specified by the call's line-device capabilities.
		case LINEERR_INVALTIMEOUT:
		{
			pString = "LINEERR_INVALTIMEOUT";
			break;
		}

		// The specified custom tone does not represent a valid tone or is made up of too many frequencies or the specified tone structure does not describe a valid tone.
		case LINEERR_INVALTONE:
		{
			pString = "LINEERR_INVALTONE";
			break;
		}

		// The specified tone list is invalid.
		case LINEERR_INVALTONELIST:
		{
			pString = "LINEERR_INVALTONELIST";
			break;
		}

		// The specified tone mode parameter is invalid.
		case LINEERR_INVALTONEMODE:
		{
			pString = "LINEERR_INVALTONEMODE";
			break;
		}

		// The specified transfer mode parameter is invalid.
		case LINEERR_INVALTRANSFERMODE:
		{
			pString = "LINEERR_INVALTRANSFERMODE";
			break;
		}

		// LINEMAPPER was the value passed in the dwDeviceID parameter, but no lines were found that match the requirements specified in the lpCallParams parameter.
		case LINEERR_LINEMAPPERFAILED:
		{
			pString = "LINEERR_LINEMAPPERFAILED";
			break;
		}

		// The specified call is not a conference call handle or a participant call.
		case LINEERR_NOCONFERENCE:
		{
			pString = "LINEERR_NOCONFERENCE";
			break;
		}

		// The specified device identifier, which was previously valid, is no longer accepted because the associated device has been removed from the system since TAPI was last initialized. Alternately, the line device has no associated device for the given device class.
		case LINEERR_NODEVICE:
		{
			pString = "LINEERR_NODEVICE";
			break;
		}

		// Either tapiaddr.dll could not be located or the telephone service provider for the specified device found that one of its components is missing or corrupt in a way that was not detected at initialization time. The user should be advised to use the Telephony Control Panel to correct the problem.
		case LINEERR_NODRIVER:
		{
			pString = "LINEERR_NODRIVER";
			break;
		}

		// Insufficient memory to perform the operation, or unable to lock memory.
		case LINEERR_NOMEM:
		{
			pString = "LINEERR_NOMEM";
			break;
		}

		// A telephony service provider which does not support multiple instances is listed more than once in the [Providers] section in the registry. The application should advise the user to use the Telephony Control Panel to remove the duplicated driver.
		case LINEERR_NOMULTIPLEINSTANCE:
		{
			pString = "LINEERR_NOMULTIPLEINSTANCE";
			break;
		}

		// There currently is no request pending of the indicated mode, or the application is no longer the highest-priority application for the specified request mode.
		case LINEERR_NOREQUEST:
		{
			pString = "LINEERR_NOREQUEST";
			break;
		}

		// The application does not have owner privilege to the specified call.
		case LINEERR_NOTOWNER:
		{
			pString = "LINEERR_NOTOWNER";
			break;
		}

		// The application is not registered as a request recipient for the indicated request mode.
		case LINEERR_NOTREGISTERED:
		{
			pString = "LINEERR_NOTREGISTERED";
			break;
		}

		// The operation failed for an unspecified or unknown reason.
		case LINEERR_OPERATIONFAILED:
		{
			pString = "LINEERR_OPERATIONFAILED";
			break;
		}

		// The operation is not available, such as for the given device or specified line.
		case LINEERR_OPERATIONUNAVAIL:
		{
			pString = "LINEERR_OPERATIONUNAVAIL";
			break;
		}

		// The service provider currently does not have enough bandwidth available for the specified rate.
		case LINEERR_RATEUNAVAIL:
		{
			pString = "LINEERR_RATEUNAVAIL";
			break;
		}

		// If TAPI reinitialization has been requested, for example as a result of adding or removing a telephony service provider, then lineInitialize, lineInitializeEx, or lineOpen requests are rejected with this error until the last application shuts down its usage of the API (using lineShutdown), at which time the new configuration becomes effective and applications are once again permitted to call lineInitialize or lineInitializeEx.
		case LINEERR_REINIT:
		{
			pString = "LINEERR_REINIT";
			break;
		}

		// Insufficient resources to complete the operation. For example, a line cannot be opened due to a dynamic resource overcommitment.
		case LINEERR_RESOURCEUNAVAIL:
		{
			pString = "LINEERR_RESOURCEUNAVAIL";
			break;
		}

		// The dwTotalSize member indicates insufficient space to contain the fixed portion of the specified structure.
		case LINEERR_STRUCTURETOOSMALL:
		{
			pString = "LINEERR_STRUCTURETOOSMALL";
			break;
		}

		// A target for the call handoff was not found. This can occur if the named application did not open the same line with the LINECALLPRIVILEGE_OWNER bit in the dwPrivileges parameter of lineOpen. Or, in the case of media-mode handoff, no application has opened the same line with the LINECALLPRIVILEGE_OWNER bit in the dwPrivileges parameter of lineOpen and with the media mode specified in the dwMediaMode parameter having been specified in the dwMediaModes parameter of lineOpen.
		case LINEERR_TARGETNOTFOUND:
		{
			pString = "LINEERR_TARGETNOTFOUND";
			break;
		}

		// The application invoking this operation is the target of the indirect handoff. That is, TAPI has determined that the calling application is also the highest priority application for the given media mode.
		case LINEERR_TARGETSELF:
		{
			pString = "LINEERR_TARGETSELF";
			break;
		}

		// The operation was invoked before any application called lineInitialize , lineInitializeEx.
		case LINEERR_UNINITIALIZED:
		{
			pString = "LINEERR_UNINITIALIZED";
			break;
		}

		// The string containing user-user information exceeds the maximum number of bytes specified in the dwUUIAcceptSize, dwUUIAnswerSize, dwUUIDropSize, dwUUIMakeCallSize, or dwUUISendUserUserInfoSize member of LINEDEVCAPS, or the string containing user-user information is too long.
		case LINEERR_USERUSERINFOTOOBIG:
		{
			pString = "LINEERR_USERUSERINFOTOOBIG";
			break;
		}

		default:
		{
			DPFX(DPFPREP, 0, "Unknown TAPI error code %u/0x%lx", TAPIError, TAPIError );

			pString = "Unknown TAPI error";
			break;
		}
	}

	return	pString;
}
//**********************************************************************

#endif // ! DPNBUILD_NOSERIALSP


//**********************************************************************
// ------------------------------
// GetWIN32ErrorString - convert system error to a string
//
// Entry:		Error code
//
// Exit:		Pointer to string
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "GetWIN32ErrorString"

static	char	*GetWIN32ErrorString( const LONG Error )
{
	char	*pString;

	switch ( Error )
	{
		case ERROR_SUCCESS:
		{
			// 0 The operation completed successfully.  ERROR_SUCCESS
			pString = "ERROR_SUCCESS";
			break;
		}

		case ERROR_INVALID_FUNCTION:
		{
			// 1 Incorrect function.  ERROR_INVALID_FUNCTION
			pString = "ERROR_INVALID_FUNCTION";
			break;
		}

		case ERROR_FILE_NOT_FOUND:
		{
			// 2 The system cannot find the file specified.  ERROR_FILE_NOT_FOUND
			pString = "ERROR_FILE_NOT_FOUND";
			break;
		}

		case ERROR_PATH_NOT_FOUND:
		{
			// 3 The system cannot find the path specified.  ERROR_PATH_NOT_FOUND
			pString = "ERROR_PATH_NOT_FOUND";
			break;
		}

		case ERROR_TOO_MANY_OPEN_FILES:
		{
			// 4 The system cannot open the file.  ERROR_TOO_MANY_OPEN_FILES
			pString = "ERROR_TOO_MANY_OPEN_FILES";
			break;
		}

		case ERROR_ACCESS_DENIED:
		{
			// 5 Access is denied.  ERROR_ACCESS_DENIED
			pString = "ERROR_ACCESS_DENIED";
			break;
		}

		case ERROR_INVALID_HANDLE:
		{
			// 6 The handle is invalid.  ERROR_INVALID_HANDLE
			pString = "ERROR_INVALID_HANDLE";
			break;
		}

		case ERROR_ARENA_TRASHED:
		{
			// 7 The storage control blocks were destroyed.  ERROR_ARENA_TRASHED
			pString = "ERROR_ARENA_TRASHED";
			break;
		}

		case ERROR_NOT_ENOUGH_MEMORY:
		{
			// 8 Not enough storage is available to process this command.  ERROR_NOT_ENOUGH_MEMORY
			pString = "ERROR_NOT_ENOUGH_MEMORY";
			break;
		}

		case ERROR_INVALID_BLOCK:
		{
			// 9 The storage control block address is invalid.  ERROR_INVALID_BLOCK
			pString = "ERROR_INVALID_BLOCK";
			break;
		}

		case ERROR_BAD_ENVIRONMENT:
		{
			// 10 The environment is incorrect.  ERROR_BAD_ENVIRONMENT
			pString = "ERROR_BAD_ENVIRONMENT";
			break;
		}

		case ERROR_BAD_FORMAT:
		{
			// 11 An attempt was made to load a program with an incorrect format.  ERROR_BAD_FORMAT
			pString = "ERROR_BAD_FORMAT";
			break;
		}

		case ERROR_INVALID_ACCESS:
		{
			// 12 The access code is invalid.  ERROR_INVALID_ACCESS
			pString = "ERROR_INVALID_ACCESS";
			break;
		}

		case ERROR_INVALID_DATA:
		{
			// 13 The data is invalid.  ERROR_INVALID_DATA
			pString = "ERROR_INVALID_DATA";
			break;
		}

		case ERROR_OUTOFMEMORY:
		{
			// 14 Not enough storage is available to complete this operation.  ERROR_OUTOFMEMORY
			pString = "ERROR_OUTOFMEMORY";
			break;
		}

		case ERROR_INVALID_DRIVE:
		{
			// 15 The system cannot find the drive specified.  ERROR_INVALID_DRIVE
			pString = "ERROR_INVALID_DRIVE";
			break;
		}

		case ERROR_CURRENT_DIRECTORY:
		{
			// 16 The directory cannot be removed.  ERROR_CURRENT_DIRECTORY
			pString = "ERROR_CURRENT_DIRECTORY";
			break;
		}

		case ERROR_NOT_SAME_DEVICE:
		{
			// 17 The system cannot move the file to a different disk drive.  ERROR_NOT_SAME_DEVICE
			pString = "ERROR_NOT_SAME_DEVICE";
			break;
		}

		case ERROR_NO_MORE_FILES:
		{
			// 18 There are no more files.  ERROR_NO_MORE_FILES
			pString = "ERROR_NO_MORE_FILES";
			break;
		}

		case ERROR_WRITE_PROTECT:
		{
			// 19 The media is write protected.  ERROR_WRITE_PROTECT
			pString = "ERROR_WRITE_PROTECT";
			break;
		}

		case ERROR_BAD_UNIT:
		{
			// 20 The system cannot find the device specified.  ERROR_BAD_UNIT
			pString = "ERROR_BAD_UNIT";
			break;
		}

		case ERROR_NOT_READY:
		{
			// 21 The device is not ready.  ERROR_NOT_READY
			pString = "ERROR_NOT_READY";
			break;
		}

		case ERROR_BAD_COMMAND:
		{
			// 22 The device does not recognize the command.  ERROR_BAD_COMMAND
			pString = "ERROR_BAD_COMMAND";
			break;
		}

		case ERROR_CRC:
		{
			// 23 Data error (cyclic redundancy check).  ERROR_CRC
			pString = "ERROR_CRC";
			break;
		}

		case ERROR_BAD_LENGTH:
		{
			// 24 The program issued a command but the command length is incorrect.  ERROR_BAD_LENGTH
			pString = "ERROR_BAD_LENGTH";
			break;
		}

		case ERROR_SEEK:
		{
			// 25 The drive cannot locate a specific area or track on the disk.  ERROR_SEEK
			pString = "ERROR_SEEK";
			break;
		}

		case ERROR_NOT_DOS_DISK:
		{
			// 26 The specified disk or diskette cannot be accessed.  ERROR_NOT_DOS_DISK
			pString = "ERROR_NOT_DOS_DISK";
			break;
		}

		case ERROR_SECTOR_NOT_FOUND:
		{
			// 27 The drive cannot find the sector requested.  ERROR_SECTOR_NOT_FOUND
			pString = "ERROR_SECTOR_NOT_FOUND";
			break;
		}

		case ERROR_OUT_OF_PAPER:
		{
			// 28 The printer is out of paper.  ERROR_OUT_OF_PAPER
			pString = "ERROR_OUT_OF_PAPER";
			break;
		}

		case ERROR_WRITE_FAULT:
		{
			// 29 The system cannot write to the specified device.  ERROR_WRITE_FAULT
			pString = "ERROR_WRITE_FAULT";
			break;
		}

		case ERROR_READ_FAULT:
		{
			// 30 The system cannot read from the specified device.  ERROR_READ_FAULT
			pString = "ERROR_READ_FAULT";
			break;
		}

		case ERROR_GEN_FAILURE:
		{
			// 31 A device attached to the system is not functioning.  ERROR_GEN_FAILURE
			pString = "ERROR_GEN_FAILURE";
			break;
		}

		case ERROR_SHARING_VIOLATION:
		{
			// 32 The process cannot access the file because it is being used by another process.  ERROR_SHARING_VIOLATION
			pString = "ERROR_SHARING_VIOLATION";
			break;
		}

		case ERROR_LOCK_VIOLATION:
		{
			// 33 The process cannot access the file because another process has locked a portion of the file.  ERROR_LOCK_VIOLATION
			pString = "ERROR_LOCK_VIOLATION";
			break;
		}

		case ERROR_WRONG_DISK:
		{
			// 34 The wrong diskette is in the drive. Insert %2 (Volume Serial Number: %3) into drive %1.  ERROR_WRONG_DISK
			pString = "ERROR_WRONG_DISK";
			break;
		}

		case ERROR_SHARING_BUFFER_EXCEEDED:
		{
			// 36 Too many files opened for sharing.  ERROR_SHARING_BUFFER_EXCEEDED
			pString = "ERROR_SHARING_BUFFER_EXCEEDED";
			break;
		}

		case ERROR_HANDLE_EOF:
		{
			// 38 Reached the end of the file.  ERROR_HANDLE_EOF
			pString = "ERROR_HANDLE_EOF";
			break;
		}

		case ERROR_HANDLE_DISK_FULL:
		{
			// 39 The disk is full.  ERROR_HANDLE_DISK_FULL
			pString = "ERROR_HANDLE_DISK_FULL";
			break;
		}

		case ERROR_NOT_SUPPORTED:
		{
			// 50 The network request is not supported.  ERROR_NOT_SUPPORTED
			pString = "ERROR_NOT_SUPPORTED";
			break;
		}

		case ERROR_REM_NOT_LIST:
		{
			// 51 The remote computer is not available.  ERROR_REM_NOT_LIST
			pString = "ERROR_REM_NOT_LIST";
			break;
		}

		case ERROR_DUP_NAME:
		{
			// 52 A duplicate name exists on the network.  ERROR_DUP_NAME
			pString = "ERROR_DUP_NAME";
			break;
		}

		case ERROR_BAD_NETPATH:
		{
			// 53 The network path was not found.  ERROR_BAD_NETPATH
			pString = "ERROR_BAD_NETPATH";
			break;
		}

		case ERROR_NETWORK_BUSY:
		{
			// 54 The network is busy.  ERROR_NETWORK_BUSY
			pString = "ERROR_NETWORK_BUSY";
			break;
		}

		case ERROR_DEV_NOT_EXIST:
		{
			// 55 The specified network resource or device is no longer available.  ERROR_DEV_NOT_EXIST
			pString = "ERROR_DEV_NOT_EXIST";
			break;
		}

		case ERROR_TOO_MANY_CMDS:
		{
			// 56 The network BIOS command limit has been reached.  ERROR_TOO_MANY_CMDS
			pString = "ERROR_TOO_MANY_CMDS";
			break;
		}

		case ERROR_ADAP_HDW_ERR:
		{
			// 57 A network adapter hardware error occurred.  ERROR_ADAP_HDW_ERR
			pString = "ERROR_ADAP_HDW_ERR";
			break;
		}

		case ERROR_BAD_NET_RESP:
		{
			// 58 The specified server cannot perform the requested operation.  ERROR_BAD_NET_RESP
			pString = "ERROR_BAD_NET_RESP";
			break;
		}

		case ERROR_UNEXP_NET_ERR:
		{
			// 59 An unexpected network error occurred.  ERROR_UNEXP_NET_ERR
			pString = "ERROR_UNEXP_NET_ERR";
			break;
		}

		case ERROR_BAD_REM_ADAP:
		{
			// 60 The remote adapter is not compatible.  ERROR_BAD_REM_ADAP
			pString = "ERROR_BAD_REM_ADAP";
			break;
		}

		case ERROR_PRINTQ_FULL:
		{
			// 61 The printer queue is full.  ERROR_PRINTQ_FULL
			pString = "ERROR_PRINTQ_FULL";
			break;
		}

		case ERROR_NO_SPOOL_SPACE:
		{
			// 62 Space to store the file waiting to be printed is not available on the server.  ERROR_NO_SPOOL_SPACE
			pString = "ERROR_NO_SPOOL_SPACE";
			break;
		}

		case ERROR_PRINT_CANCELLED:
		{
			// 63 Your file waiting to be printed was deleted.  ERROR_PRINT_CANCELLED
			pString = "ERROR_PRINT_CANCELLED";
			break;
		}

		case ERROR_NETNAME_DELETED:
		{
			// 64 The specified network name is no longer available.  ERROR_NETNAME_DELETED
			pString = "ERROR_NETNAME_DELETED";
			break;
		}

		case ERROR_NETWORK_ACCESS_DENIED:
		{
			// 65 Network access is denied.  ERROR_NETWORK_ACCESS_DENIED
			pString = "ERROR_NETWORK_ACCESS_DENIED";
			break;
		}

		case ERROR_BAD_DEV_TYPE:
		{
			// 66 The network resource type is not correct.  ERROR_BAD_DEV_TYPE
			pString = "ERROR_BAD_DEV_TYPE";
			break;
		}

		case ERROR_BAD_NET_NAME:
		{
			// 67 The network name cannot be found.  ERROR_BAD_NET_NAME
			pString = "ERROR_BAD_NET_NAME";
			break;
		}

		case ERROR_TOO_MANY_NAMES:
		{
			// 68 The name limit for the local computer network adapter card was exceeded.  ERROR_TOO_MANY_NAMES
			pString = "ERROR_TOO_MANY_NAMES";
			break;
		}

		case ERROR_TOO_MANY_SESS:
		{
			// 69 The network BIOS session limit was exceeded.  ERROR_TOO_MANY_SESS
			pString = "ERROR_TOO_MANY_SESS";
			break;
		}

		case ERROR_SHARING_PAUSED:
		{
			// 70 The remote server has been paused or is in the process of being started.  ERROR_SHARING_PAUSED
			pString = "ERROR_SHARING_PAUSED";
			break;
		}

		case ERROR_REQ_NOT_ACCEP:
		{
			// 71 No more connections can be made to this remote computer at this time because there are already as many connections as the computer can accept.  ERROR_REQ_NOT_ACCEP
			pString = "ERROR_REQ_NOT_ACCEP";
			break;
		}

		case ERROR_REDIR_PAUSED:
		{
			// 72 The specified printer or disk device has been paused.  ERROR_REDIR_PAUSED
			pString = "ERROR_REDIR_PAUSED";
			break;
		}

		case ERROR_FILE_EXISTS:
		{
			// 80 The file exists.  ERROR_FILE_EXISTS
			pString = "ERROR_FILE_EXISTS";
			break;
		}

		case ERROR_CANNOT_MAKE:
		{
			// 82 The directory or file cannot be created.  ERROR_CANNOT_MAKE
			pString = "ERROR_CANNOT_MAKE";
			break;
		}

		case ERROR_FAIL_I24:
		{
			// 83 Fail on INT 24.  ERROR_FAIL_I24
			pString = "ERROR_FAIL_I24";
			break;
		}

		case ERROR_OUT_OF_STRUCTURES:
		{
			// 84 Storage to process this request is not available.  ERROR_OUT_OF_STRUCTURES
			pString = "ERROR_OUT_OF_STRUCTURES";
			break;
		}

		case ERROR_ALREADY_ASSIGNED:
		{
			// 85 The local device name is already in use.  ERROR_ALREADY_ASSIGNED
			pString = "ERROR_ALREADY_ASSIGNED";
			break;
		}

		case ERROR_INVALID_PASSWORD:
		{
			// 86 The specified network password is not correct.  ERROR_INVALID_PASSWORD
			pString = "ERROR_INVALID_PASSWORD";
			break;
		}

		case ERROR_INVALID_PARAMETER:
		{
			// 87 The parameter is incorrect.  ERROR_INVALID_PARAMETER
			pString = "ERROR_INVALID_PARAMETER";
			break;
		}

		case ERROR_NET_WRITE_FAULT:
		{
			// 88 A write fault occurred on the network.  ERROR_NET_WRITE_FAULT
			pString = "ERROR_NET_WRITE_FAULT";
			break;
		}

		case ERROR_NO_PROC_SLOTS:
		{
			// 89 The system cannot start another process at this time.  ERROR_NO_PROC_SLOTS
			pString = "ERROR_NO_PROC_SLOTS";
			break;
		}

		case ERROR_TOO_MANY_SEMAPHORES:
		{
			// 100 Cannot create another system semaphore.  ERROR_TOO_MANY_SEMAPHORES
			pString = "ERROR_TOO_MANY_SEMAPHORES";
			break;
		}

		case ERROR_EXCL_SEM_ALREADY_OWNED:
		{
			// 101 The exclusive semaphore is owned by another process.  ERROR_EXCL_SEM_ALREADY_OWNED
			pString = "ERROR_EXCL_SEM_ALREADY_OWNED";
			break;
		}

		case ERROR_SEM_IS_SET:
		{
			// 102 The semaphore is set and cannot be closed.  ERROR_SEM_IS_SET
			pString = "ERROR_SEM_IS_SET";
			break;
		}

		case ERROR_TOO_MANY_SEM_REQUESTS:
		{
			// 103 The semaphore cannot be set again.  ERROR_TOO_MANY_SEM_REQUESTS
			pString = "ERROR_TOO_MANY_SEM_REQUESTS";
			break;
		}

		case ERROR_INVALID_AT_INTERRUPT_TIME:
		{
			// 104 Cannot request exclusive semaphores at interrupt time.  ERROR_INVALID_AT_INTERRUPT_TIME
			pString = "ERROR_INVALID_AT_INTERRUPT_TIME";
			break;
		}

		case ERROR_SEM_OWNER_DIED:
		{
			// 105 The previous ownership of this semaphore has ended.  ERROR_SEM_OWNER_DIED
			pString = "ERROR_SEM_OWNER_DIED";
			break;
		}

		case ERROR_SEM_USER_LIMIT:
		{
			// 106 Insert the diskette for drive %1.  ERROR_SEM_USER_LIMIT
			pString = "ERROR_SEM_USER_LIMIT";
			break;
		}

		case ERROR_DISK_CHANGE:
		{
			// 107 The program stopped because an alternate diskette was not inserted.  ERROR_DISK_CHANGE
			pString = "ERROR_DISK_CHANGE";
			break;
		}

		case ERROR_DRIVE_LOCKED:
		{
			// 108 The disk is in use or locked by another process.  ERROR_DRIVE_LOCKED
			pString = "ERROR_DRIVE_LOCKED";
			break;
		}

		case ERROR_BROKEN_PIPE:
		{
			// 109 The pipe has been ended.  ERROR_BROKEN_PIPE
			pString = "ERROR_BROKEN_PIPE";
			break;
		}

		case ERROR_OPEN_FAILED:
		{
			// 110 The system cannot open the device or file specified.  ERROR_OPEN_FAILED
			pString = "ERROR_OPEN_FAILED";
			break;
		}

		case ERROR_BUFFER_OVERFLOW:
		{
			// 111 The file name is too long.  ERROR_BUFFER_OVERFLOW
			pString = "ERROR_BUFFER_OVERFLOW";
			break;
		}

		case ERROR_DISK_FULL:
		{
			// 112 There is not enough space on the disk.  ERROR_DISK_FULL
			pString = "ERROR_DISK_FULL";
			break;
		}

		case ERROR_NO_MORE_SEARCH_HANDLES:
		{
			// 113 No more internal file identifiers available.  ERROR_NO_MORE_SEARCH_HANDLES
			pString = "ERROR_NO_MORE_SEARCH_HANDLES";
			break;
		}

		case ERROR_INVALID_TARGET_HANDLE:
		{
			// 114 The target internal file identifier is incorrect.  ERROR_INVALID_TARGET_HANDLE
			pString = "ERROR_INVALID_TARGET_HANDLE";
			break;
		}

		case ERROR_INVALID_CATEGORY:
		{
			// 117 The IOCTL call made by the application program is not correct.  ERROR_INVALID_CATEGORY
			pString = "ERROR_INVALID_CATEGORY";
			break;
		}

		case ERROR_INVALID_VERIFY_SWITCH:
		{
			// 118 The verify-on-write switch parameter value is not correct.  ERROR_INVALID_VERIFY_SWITCH
			pString = "ERROR_INVALID_VERIFY_SWITCH";
			break;
		}

		case ERROR_BAD_DRIVER_LEVEL:
		{
			// 119 The system does not support the command requested.  ERROR_BAD_DRIVER_LEVEL
			pString = "ERROR_BAD_DRIVER_LEVEL";
			break;
		}

		case ERROR_CALL_NOT_IMPLEMENTED:
		{
			// 120 This function is not supported on this system.  ERROR_CALL_NOT_IMPLEMENTED
			pString = "ERROR_CALL_NOT_IMPLEMENTED";
			break;
		}

		case ERROR_SEM_TIMEOUT:
		{
			// 121 The semaphore timeout period has expired.  ERROR_SEM_TIMEOUT
			pString = "ERROR_SEM_TIMEOUT";
			break;
		}

		case ERROR_INSUFFICIENT_BUFFER:
		{
			// 122 The data area passed to a system call is too small.  ERROR_INSUFFICIENT_BUFFER
			pString = "ERROR_INSUFFICIENT_BUFFER";
			break;
		}

		case ERROR_INVALID_NAME:
		{
			// 123 The filename, directory name, or volume label syntax is incorrect.  ERROR_INVALID_NAME
			pString = "ERROR_INVALID_NAME";
			break;
		}

		case ERROR_INVALID_LEVEL:
		{
			// 124 The system call level is not correct.  ERROR_INVALID_LEVEL
			pString = "ERROR_INVALID_LEVEL";
			break;
		}

		case ERROR_NO_VOLUME_LABEL:
		{
			// 125 The disk has no volume label.  ERROR_NO_VOLUME_LABEL
			pString = "ERROR_NO_VOLUME_LABEL";
			break;
		}

		case ERROR_MOD_NOT_FOUND:
		{
			// 126 The specified module could not be found.  ERROR_MOD_NOT_FOUND
			pString = "ERROR_MOD_NOT_FOUND";
			break;
		}

		case ERROR_PROC_NOT_FOUND:
		{
			// 127 The specified procedure could not be found.  ERROR_PROC_NOT_FOUND
			pString = "ERROR_PROC_NOT_FOUND";
			break;
		}

		case ERROR_WAIT_NO_CHILDREN:
		{
			// 128 There are no child processes to wait for.  ERROR_WAIT_NO_CHILDREN
			pString = "ERROR_WAIT_NO_CHILDREN";
			break;
		}

		case ERROR_CHILD_NOT_COMPLETE:
		{
			// 129 The %1 application cannot be run in Win32 mode.  ERROR_CHILD_NOT_COMPLETE
			pString = "ERROR_CHILD_NOT_COMPLETE";
			break;
		}

		case ERROR_DIRECT_ACCESS_HANDLE:
		{
			// 130 Attempt to use a file handle to an open disk partition for an operation other than raw disk I/O.  ERROR_DIRECT_ACCESS_HANDLE
			pString = "ERROR_DIRECT_ACCESS_HANDLE";
			break;
		}

		case ERROR_NEGATIVE_SEEK:
		{
			// 131 An attempt was made to move the file pointer before the beginning of the file.  ERROR_NEGATIVE_SEEK
			pString = "ERROR_NEGATIVE_SEEK";
			break;
		}

		case ERROR_SEEK_ON_DEVICE:
		{
			// 132 The file pointer cannot be set on the specified device or file.  ERROR_SEEK_ON_DEVICE
			pString = "ERROR_SEEK_ON_DEVICE";
			break;
		}

		case ERROR_IS_JOIN_TARGET:
		{
			// 133 A JOIN or SUBST command cannot be used for a drive that contains previously joined drives.  ERROR_IS_JOIN_TARGET
			pString = "ERROR_IS_JOIN_TARGET";
			break;
		}

		case ERROR_IS_JOINED:
		{
			// 134 An attempt was made to use a JOIN or SUBST command on a drive that has already been joined.  ERROR_IS_JOINED
			pString = "ERROR_IS_JOINED";
			break;
		}

		case ERROR_IS_SUBSTED:
		{
			// 135 An attempt was made to use a JOIN or SUBST command on a drive that has already been substituted.  ERROR_IS_SUBSTED
			pString = "ERROR_IS_SUBSTED";
			break;
		}

		case ERROR_NOT_JOINED:
		{
			// 136 The system tried to delete the JOIN of a drive that is not joined.  ERROR_NOT_JOINED
			pString = "ERROR_NOT_JOINED";
			break;
		}

		case ERROR_NOT_SUBSTED:
		{
			// 137 The system tried to delete the substitution of a drive that is not substituted.  ERROR_NOT_SUBSTED
			pString = "ERROR_NOT_SUBSTED";
			break;
		}

		case ERROR_JOIN_TO_JOIN:
		{
			// 138 The system tried to join a drive to a directory on a joined drive.  ERROR_JOIN_TO_JOIN
			pString = "ERROR_JOIN_TO_JOIN";
			break;
		}

		case ERROR_SUBST_TO_SUBST:
		{
			// 139 The system tried to substitute a drive to a directory on a substituted drive.  ERROR_SUBST_TO_SUBST
			pString = "ERROR_SUBST_TO_SUBST";
			break;
		}

		case ERROR_JOIN_TO_SUBST:
		{
			// 140 The system tried to join a drive to a directory on a substituted drive.  ERROR_JOIN_TO_SUBST
			pString = "ERROR_JOIN_TO_SUBST";
			break;
		}

		case ERROR_SUBST_TO_JOIN:
		{
			// 141 The system tried to SUBST a drive to a directory on a joined drive.  ERROR_SUBST_TO_JOIN
			pString = "ERROR_SUBST_TO_JOIN";
			break;
		}

		case ERROR_BUSY_DRIVE:
		{
			// 142 The system cannot perform a JOIN or SUBST at this time.  ERROR_BUSY_DRIVE
			pString = "ERROR_BUSY_DRIVE";
			break;
		}

		case ERROR_SAME_DRIVE:
		{
			// 143 The system cannot join or substitute a drive to or for a directory on the same drive.  ERROR_SAME_DRIVE
			pString = "ERROR_SAME_DRIVE";
			break;
		}

		case ERROR_DIR_NOT_ROOT:
		{
			// 144 The directory is not a subdirectory of the root directory.  ERROR_DIR_NOT_ROOT
			pString = "ERROR_DIR_NOT_ROOT";
			break;
		}

		case ERROR_DIR_NOT_EMPTY:
		{
			// 145 The directory is not empty.  ERROR_DIR_NOT_EMPTY
			pString = "ERROR_DIR_NOT_EMPTY";
			break;
		}

		case ERROR_IS_SUBST_PATH:
		{
			// 146 The path specified is being used in a substitute.  ERROR_IS_SUBST_PATH
			pString = "ERROR_IS_SUBST_PATH";
			break;
		}

		case ERROR_IS_JOIN_PATH:
		{
			// 147 Not enough resources are available to process this command.  ERROR_IS_JOIN_PATH
			pString = "ERROR_IS_JOIN_PATH";
			break;
		}

		case ERROR_PATH_BUSY:
		{
			// 148 The path specified cannot be used at this time.  ERROR_PATH_BUSY
			pString = "ERROR_PATH_BUSY";
			break;
		}

		case ERROR_IS_SUBST_TARGET:
		{
			// 149 An attempt was made to join or substitute a drive for which a directory on the drive is the target of a previous substitute.  ERROR_IS_SUBST_TARGET
			pString = "ERROR_IS_SUBST_TARGET";
			break;
		}

		case ERROR_SYSTEM_TRACE:
		{
			// 150 System trace information was not specified in your CONFIG.SYS file, or tracing is disallowed.  ERROR_SYSTEM_TRACE
			pString = "ERROR_SYSTEM_TRACE";
			break;
		}

		case ERROR_INVALID_EVENT_COUNT:
		{
			// 151 The number of specified semaphore events for DosMuxSemWait is not correct.  ERROR_INVALID_EVENT_COUNT
			pString = "ERROR_INVALID_EVENT_COUNT";
			break;
		}

		case ERROR_TOO_MANY_MUXWAITERS:
		{
			// 152 DosMuxSemWait did not execute; too many semaphores are already set.  ERROR_TOO_MANY_MUXWAITERS
			pString = "ERROR_TOO_MANY_MUXWAITERS";
			break;
		}

		case ERROR_INVALID_LIST_FORMAT:
		{
			// 153 The DosMuxSemWait list is not correct.  ERROR_INVALID_LIST_FORMAT
			pString = "ERROR_INVALID_LIST_FORMAT";
			break;
		}

		case ERROR_LABEL_TOO_LONG:
		{
			// 154 The volume label you entered exceeds the label character limit of the target file system.  ERROR_LABEL_TOO_LONG
			pString = "ERROR_LABEL_TOO_LONG";
			break;
		}

		case ERROR_TOO_MANY_TCBS:
		{
			// 155 Cannot create another thread.  ERROR_TOO_MANY_TCBS
			pString = "ERROR_TOO_MANY_TCBS";
			break;
		}

		case ERROR_SIGNAL_REFUSED:
		{
			// 156 The recipient process has refused the signal.  ERROR_SIGNAL_REFUSED
			pString = "ERROR_SIGNAL_REFUSED";
			break;
		}

		case ERROR_DISCARDED:
		{
			// 157 The segment is already discarded and cannot be locked.  ERROR_DISCARDED
			pString = "ERROR_DISCARDED";
			break;
		}

		case ERROR_NOT_LOCKED:
		{
			// 158 The segment is already unlocked.  ERROR_NOT_LOCKED
			pString = "ERROR_NOT_LOCKED";
			break;
		}

		case ERROR_BAD_THREADID_ADDR:
		{
			// 159 The address for the thread ID is not correct.  ERROR_BAD_THREADID_ADDR
			pString = "ERROR_BAD_THREADID_ADDR";
			break;
		}

		case ERROR_BAD_ARGUMENTS:
		{
			// 160 The argument string passed to DosExecPgm is not correct.  ERROR_BAD_ARGUMENTS
			pString = "ERROR_BAD_ARGUMENTS";
			break;
		}

		case ERROR_BAD_PATHNAME:
		{
			// 161 The specified path is invalid.  ERROR_BAD_PATHNAME
			pString = "ERROR_BAD_PATHNAME";
			break;
		}

		case ERROR_SIGNAL_PENDING:
		{
			// 162 A signal is already pending.  ERROR_SIGNAL_PENDING
			pString = "ERROR_SIGNAL_PENDING";
			break;
		}

		case ERROR_MAX_THRDS_REACHED:
		{
			// 164 No more threads can be created in the system.  ERROR_MAX_THRDS_REACHED
			pString = "ERROR_MAX_THRDS_REACHED";
			break;
		}

		case ERROR_LOCK_FAILED:
		{
			// 167 Unable to lock a region of a file.  ERROR_LOCK_FAILED
			pString = "ERROR_LOCK_FAILED";
			break;
		}

		case ERROR_BUSY:
		{
			// 170 The requested resource is in use.  ERROR_BUSY
			pString = "ERROR_BUSY";
			break;
		}

		case ERROR_CANCEL_VIOLATION:
		{
			// 173 A lock request was not outstanding for the supplied cancel region.  ERROR_CANCEL_VIOLATION
			pString = "ERROR_CANCEL_VIOLATION";
			break;
		}

		case ERROR_ATOMIC_LOCKS_NOT_SUPPORTED:
		{
			// 174 The file system does not support atomic changes to the lock type.  ERROR_ATOMIC_LOCKS_NOT_SUPPORTED
			pString = "ERROR_ATOMIC_LOCKS_NOT_SUPPORTED";
			break;
		}

		case ERROR_INVALID_SEGMENT_NUMBER:
		{
			// 180 The system detected a segment number that was not correct.  ERROR_INVALID_SEGMENT_NUMBER
			pString = "ERROR_INVALID_SEGMENT_NUMBER";
			break;
		}

		case ERROR_INVALID_ORDINAL:
		{
			// 182 The operating system cannot run %1.  ERROR_INVALID_ORDINAL
			pString = "ERROR_INVALID_ORDINAL";
			break;
		}

		case ERROR_ALREADY_EXISTS:
		{
			// 183 Cannot create a file when that file already exists.  ERROR_ALREADY_EXISTS
			pString = "ERROR_ALREADY_EXISTS";
			break;
		}

		case ERROR_INVALID_FLAG_NUMBER:
		{
			// 186 The flag passed is not correct.  ERROR_INVALID_FLAG_NUMBER
			pString = "ERROR_INVALID_FLAG_NUMBER";
			break;
		}

		case ERROR_SEM_NOT_FOUND:
		{
			// 187 The specified system semaphore name was not found.  ERROR_SEM_NOT_FOUND
			pString = "ERROR_SEM_NOT_FOUND";
			break;
		}

		case ERROR_INVALID_STARTING_CODESEG:
		{
			// 188 The operating system cannot run %1.  ERROR_INVALID_STARTING_CODESEG
			pString = "ERROR_INVALID_STARTING_CODESEG";
			break;
		}

		case ERROR_INVALID_STACKSEG:
		{
			// 189 The operating system cannot run %1.  ERROR_INVALID_STACKSEG
			pString = "ERROR_INVALID_STACKSEG";
			break;
		}

		case ERROR_INVALID_MODULETYPE:
		{
			// 190 The operating system cannot run %1.  ERROR_INVALID_MODULETYPE
			pString = "ERROR_INVALID_MODULETYPE";
			break;
		}

		case ERROR_INVALID_EXE_SIGNATURE:
		{
			// 191 Cannot run %1 in Win32 mode.  ERROR_INVALID_EXE_SIGNATURE
			pString = "ERROR_INVALID_EXE_SIGNATURE";
			break;
		}

		case ERROR_EXE_MARKED_INVALID:
		{
			// 192 The operating system cannot run %1.  ERROR_EXE_MARKED_INVALID
			pString = "ERROR_EXE_MARKED_INVALID";
			break;
		}

		case ERROR_BAD_EXE_FORMAT:
		{
			// 193 is not a valid Win32 application.  ERROR_BAD_EXE_FORMAT
			pString = "ERROR_BAD_EXE_FORMAT";
			break;
		}

		case ERROR_ITERATED_DATA_EXCEEDS_64k:
		{
			// 194 The operating system cannot run %1.  ERROR_ITERATED_DATA_EXCEEDS_64k
			pString = "ERROR_ITERATED_DATA_EXCEEDS_64k";
			break;
		}

		case ERROR_INVALID_MINALLOCSIZE:
		{
			// 195 The operating system cannot run %1.  ERROR_INVALID_MINALLOCSIZE
			pString = "ERROR_INVALID_MINALLOCSIZE";
			break;
		}

		case ERROR_DYNLINK_FROM_INVALID_RING:
		{
			// 196 The operating system cannot run this application program.  ERROR_DYNLINK_FROM_INVALID_RING
			pString = "ERROR_DYNLINK_FROM_INVALID_RING";
			break;
		}

		case ERROR_IOPL_NOT_ENABLED:
		{
			// 197 The operating system is not presently configured to run this application.  ERROR_IOPL_NOT_ENABLED
			pString = "ERROR_IOPL_NOT_ENABLED";
			break;
		}

		case ERROR_INVALID_SEGDPL:
		{
			// 198 The operating system cannot run %1.  ERROR_INVALID_SEGDPL
			pString = "ERROR_INVALID_SEGDPL";
			break;
		}

		case ERROR_AUTODATASEG_EXCEEDS_64k:
		{
			// 199 The operating system cannot run this application program.  ERROR_AUTODATASEG_EXCEEDS_64k
			pString = "ERROR_AUTODATASEG_EXCEEDS_64k";
			break;
		}

		case ERROR_RING2SEG_MUST_BE_MOVABLE:
		{
			// 200 The code segment cannot be greater than or equal to 64K.  ERROR_RING2SEG_MUST_BE_MOVABLE
			pString = "ERROR_RING2SEG_MUST_BE_MOVABLE";
			break;
		}

		case ERROR_RELOC_CHAIN_XEEDS_SEGLIM:
		{
			// 201 The operating system cannot run %1.  ERROR_RELOC_CHAIN_XEEDS_SEGLIM
			pString = "ERROR_RELOC_CHAIN_XEEDS_SEGLIM";
			break;
		}

		case ERROR_INFLOOP_IN_RELOC_CHAIN:
		{
			// 202 The operating system cannot run %1.  ERROR_INFLOOP_IN_RELOC_CHAIN
			pString = "ERROR_INFLOOP_IN_RELOC_CHAIN";
			break;
		}

		case ERROR_ENVVAR_NOT_FOUND:
		{
			// 203 The system could not find the environment option that was entered.  ERROR_ENVVAR_NOT_FOUND
			pString = "ERROR_ENVVAR_NOT_FOUND";
			break;
		}

		case ERROR_NO_SIGNAL_SENT:
		{
			// 205 No process in the command subtree has a signal handler.  ERROR_NO_SIGNAL_SENT
			pString = "ERROR_NO_SIGNAL_SENT";
			break;
		}

		case ERROR_FILENAME_EXCED_RANGE:
		{
			// 206 The filename or extension is too long.  ERROR_FILENAME_EXCED_RANGE
			pString = "ERROR_FILENAME_EXCED_RANGE";
			break;
		}

		case ERROR_RING2_STACK_IN_USE:
		{
			// 207 The ring 2 stack is in use.  ERROR_RING2_STACK_IN_USE
			pString = "ERROR_RING2_STACK_IN_USE";
			break;
		}

		case ERROR_META_EXPANSION_TOO_LONG:
		{
			// 208 The global filename characters, * or ?, are entered incorrectly or too many global filename characters are specified.  ERROR_META_EXPANSION_TOO_LONG
			pString = "ERROR_META_EXPANSION_TOO_LONG";
			break;
		}

		case ERROR_INVALID_SIGNAL_NUMBER:
		{
			// 209 The signal being posted is not correct.  ERROR_INVALID_SIGNAL_NUMBER
			pString = "ERROR_INVALID_SIGNAL_NUMBER";
			break;
		}

		case ERROR_THREAD_1_INACTIVE:
		{
			// 210 The signal handler cannot be set.  ERROR_THREAD_1_INACTIVE
			pString = "ERROR_THREAD_1_INACTIVE";
			break;
		}

		case ERROR_LOCKED:
		{
			// 212 The segment is locked and cannot be reallocated.  ERROR_LOCKED
			pString = "ERROR_LOCKED";
			break;
		}

		case ERROR_TOO_MANY_MODULES:
		{
			// 214 Too many dynamic-link modules are attached to this program or dynamic-link module.  ERROR_TOO_MANY_MODULES
			pString = "ERROR_TOO_MANY_MODULES";
			break;
		}

		case ERROR_NESTING_NOT_ALLOWED:
		{
			// 215 Can't nest calls to LoadModule.  ERROR_NESTING_NOT_ALLOWED
			pString = "ERROR_NESTING_NOT_ALLOWED";
			break;
		}

		case ERROR_EXE_MACHINE_TYPE_MISMATCH:
		{
			// 216 The image file %1 is valid, but is for a machine type other than the current machine.  ERROR_EXE_MACHINE_TYPE_MISMATCH
			pString = "ERROR_EXE_MACHINE_TYPE_MISMATCH";
			break;
		}

		case ERROR_BAD_PIPE:
		{
			// 230 The pipe state is invalid.  ERROR_BAD_PIPE
			pString = "ERROR_BAD_PIPE";
			break;
		}

		case ERROR_PIPE_BUSY:
		{
			// 231 All pipe instances are busy.  ERROR_PIPE_BUSY
			pString = "ERROR_PIPE_BUSY";
			break;
		}

		case ERROR_NO_DATA:
		{
			// 232 The pipe is being closed.  ERROR_NO_DATA
			pString = "ERROR_NO_DATA";
			break;
		}

		case ERROR_PIPE_NOT_CONNECTED:
		{
			// 233 No process is on the other end of the pipe.  ERROR_PIPE_NOT_CONNECTED
			pString = "ERROR_PIPE_NOT_CONNECTED";
			break;
		}

		case ERROR_MORE_DATA:
		{
			// 234 More data is available.  ERROR_MORE_DATA
			pString = "ERROR_MORE_DATA";
			break;
		}

		case ERROR_VC_DISCONNECTED:
		{
			// 240 The session was canceled.  ERROR_VC_DISCONNECTED
			pString = "ERROR_VC_DISCONNECTED";
			break;
		}

		case ERROR_INVALID_EA_NAME:
		{
			// 254 The specified extended attribute name was invalid.  ERROR_INVALID_EA_NAME
			pString = "ERROR_INVALID_EA_NAME";
			break;
		}

		case ERROR_EA_LIST_INCONSISTENT:
		{
			// 255 The extended attributes are inconsistent.  ERROR_EA_LIST_INCONSISTENT
			pString = "ERROR_EA_LIST_INCONSISTENT";
			break;
		}

		case ERROR_NO_MORE_ITEMS:
		{
			// 259 No more data is available.  ERROR_NO_MORE_ITEMS
			pString = "ERROR_NO_MORE_ITEMS";
			break;
		}

		case ERROR_CANNOT_COPY:
		{
			// 266 The copy functions cannot be used.  ERROR_CANNOT_COPY
			pString = "ERROR_CANNOT_COPY";
			break;
		}

		case ERROR_DIRECTORY:
		{
			// 267 The directory name is invalid.  ERROR_DIRECTORY
			pString = "ERROR_DIRECTORY";
			break;
		}

		case ERROR_EAS_DIDNT_FIT:
		{
			// 275 The extended attributes did not fit in the buffer.  ERROR_EAS_DIDNT_FIT
			pString = "ERROR_EAS_DIDNT_FIT";
			break;
		}

		case ERROR_EA_FILE_CORRUPT:
		{
			// 276 The extended attribute file on the mounted file system is corrupt.  ERROR_EA_FILE_CORRUPT
			pString = "ERROR_EA_FILE_CORRUPT";
			break;
		}

		case ERROR_EA_TABLE_FULL:
		{
			// 277 The extended attribute table file is full.  ERROR_EA_TABLE_FULL
			pString = "ERROR_EA_TABLE_FULL";
			break;
		}

		case ERROR_INVALID_EA_HANDLE:
		{
			// 278 The specified extended attribute handle is invalid.  ERROR_INVALID_EA_HANDLE
			pString = "ERROR_INVALID_EA_HANDLE";
			break;
		}

		case ERROR_EAS_NOT_SUPPORTED:
		{
			// 282 The mounted file system does not support extended attributes.  ERROR_EAS_NOT_SUPPORTED
			pString = "ERROR_EAS_NOT_SUPPORTED";
			break;
		}

		case ERROR_NOT_OWNER:
		{
			// 288 Attempt to release mutex not owned by caller.  ERROR_NOT_OWNER
			pString = "ERROR_NOT_OWNER";
			break;
		}

		case ERROR_TOO_MANY_POSTS:
		{
			// 298 Too many posts were made to a semaphore.  ERROR_TOO_MANY_POSTS
			pString = "ERROR_TOO_MANY_POSTS";
			break;
		}

		case ERROR_PARTIAL_COPY:
		{
			// 299 Only part of a ReadProcessMemoty or WriteProcessMemory request was completed.  ERROR_PARTIAL_COPY
			pString = "ERROR_PARTIAL_COPY";
			break;
		}

		case ERROR_OPLOCK_NOT_GRANTED:
		{
			// 300 The oplock request is denied.  ERROR_OPLOCK_NOT_GRANTED
			pString = "ERROR_OPLOCK_NOT_GRANTED";
			break;
		}

		case ERROR_INVALID_OPLOCK_PROTOCOL:
		{
			// 301 An invalid oplock acknowledgment was received by the system.  ERROR_INVALID_OPLOCK_PROTOCOL
			pString = "ERROR_INVALID_OPLOCK_PROTOCOL";
			break;
		}

		case ERROR_MR_MID_NOT_FOUND:
		{
			// 317 The system cannot find message text for message number 0x%1 in the message file for %2.  ERROR_MR_MID_NOT_FOUND
			pString = "ERROR_MR_MID_NOT_FOUND";
			break;
		}

		case ERROR_INVALID_ADDRESS:
		{
			// 487 Attempt to access invalid address.  ERROR_INVALID_ADDRESS
			pString = "ERROR_INVALID_ADDRESS";
			break;
		}

		case ERROR_ARITHMETIC_OVERFLOW:
		{
			// 534 Arithmetic result exceeded 32 bits.  ERROR_ARITHMETIC_OVERFLOW
			pString = "ERROR_ARITHMETIC_OVERFLOW";
			break;
		}

		case ERROR_PIPE_CONNECTED:
		{
			// 535 There is a process on other end of the pipe.  ERROR_PIPE_CONNECTED
			pString = "ERROR_PIPE_CONNECTED";
			break;
		}

		case ERROR_PIPE_LISTENING:
		{
			// 536 Waiting for a process to open the other end of the pipe.  ERROR_PIPE_LISTENING
			pString = "ERROR_PIPE_LISTENING";
			break;
		}

		case ERROR_EA_ACCESS_DENIED:
		{
			// 994 Access to the extended attribute was denied.  ERROR_EA_ACCESS_DENIED
			pString = "ERROR_EA_ACCESS_DENIED";
			break;
		}

		case ERROR_OPERATION_ABORTED:
		{
			// 995 The I/O operation has been aborted because of either a thread exit or an application request.  ERROR_OPERATION_ABORTED
			pString = "ERROR_OPERATION_ABORTED";
			break;
		}

		case ERROR_IO_INCOMPLETE:
		{
			// 996 Overlapped I/O event is not in a signaled state.  ERROR_IO_INCOMPLETE
			pString = "ERROR_IO_INCOMPLETE";
			break;
		}

		case ERROR_IO_PENDING:
		{
			// 997 Overlapped I/O operation is in progress.  ERROR_IO_PENDING
			pString = "ERROR_IO_PENDING";
			break;
		}

		case ERROR_NOACCESS:
		{
			// 998 Invalid access to memory location.  ERROR_NOACCESS
			pString = "ERROR_NOACCESS";
			break;
		}

		case ERROR_SWAPERROR:
		{
			// 999 Error performing inpage operation.  ERROR_SWAPERROR
			pString = "ERROR_SWAPERROR";
			break;
		}

		case ERROR_STACK_OVERFLOW:
		{
			// 1001 Recursion too deep; the stack overflowed.  ERROR_STACK_OVERFLOW
			pString = "ERROR_STACK_OVERFLOW";
			break;
		}

		case ERROR_INVALID_MESSAGE:
		{
			// 1002 The window cannot act on the sent message.  ERROR_INVALID_MESSAGE
			pString = "ERROR_INVALID_MESSAGE";
			break;
		}

		case ERROR_CAN_NOT_COMPLETE:
		{
			// 1003 Cannot complete this function.  ERROR_CAN_NOT_COMPLETE
			pString = "ERROR_CAN_NOT_COMPLETE";
			break;
		}

		case ERROR_INVALID_FLAGS:
		{
			// 1004 Invalid flags.  ERROR_INVALID_FLAGS
			pString = "ERROR_INVALID_FLAGS";
			break;
		}

		case ERROR_UNRECOGNIZED_VOLUME:
		{
			// 1005 The volume does not contain a recognized file system. Please make sure that all required file system drivers are loaded and that the volume is not corrupted.  ERROR_UNRECOGNIZED_VOLUME
			pString = "ERROR_UNRECOGNIZED_VOLUME";
			break;
		}

		case ERROR_FILE_INVALID:
		{
			// 1006 The volume for a file has been externally altered so that the opened file is no longer valid.  ERROR_FILE_INVALID
			pString = "ERROR_FILE_INVALID";
			break;
		}

		case ERROR_FULLSCREEN_MODE:
		{
			// 1007 The requested operation cannot be performed in full-screen mode.  ERROR_FULLSCREEN_MODE
			pString = "ERROR_FULLSCREEN_MODE";
			break;
		}

		case ERROR_NO_TOKEN:
		{
			// 1008 An attempt was made to reference a token that does not exist.  ERROR_NO_TOKEN
			pString = "ERROR_NO_TOKEN";
			break;
		}

		case ERROR_BADDB:
		{
			// 1009 The configuration registry database is corrupt.  ERROR_BADDB
			pString = "ERROR_BADDB";
			break;
		}

		case ERROR_BADKEY:
		{
			// 1010 The configuration registry key is invalid.  ERROR_BADKEY
			pString = "ERROR_BADKEY";
			break;
		}

		case ERROR_CANTOPEN:
		{
			// 1011 The configuration registry key could not be opened.  ERROR_CANTOPEN
			pString = "ERROR_CANTOPEN";
			break;
		}

		case ERROR_CANTREAD:
		{
			// 1012 The configuration registry key could not be read.  ERROR_CANTREAD
			pString = "ERROR_CANTREAD";
			break;
		}

		case ERROR_CANTWRITE:
		{
			// 1013 The configuration registry key could not be written.  ERROR_CANTWRITE
			pString = "ERROR_CANTWRITE";
			break;
		}

		case ERROR_REGISTRY_RECOVERED:
		{
			// 1014 One of the files in the registry database had to be recovered by use of a log or alternate copy. The recovery was successful.  ERROR_REGISTRY_RECOVERED
			pString = "ERROR_REGISTRY_RECOVERED";
			break;
		}

		case ERROR_REGISTRY_CORRUPT:
		{
			// 1015 The registry is corrupted. The structure of one of the files that contains registry data is corrupted, or the system's image of the file in memory is corrupted, or the file could not be recovered because the alternate copy or log was absent or corrupted.  ERROR_REGISTRY_CORRUPT
			pString = "ERROR_REGISTRY_CORRUPT";
			break;
		}

		case ERROR_REGISTRY_IO_FAILED:
		{
			// 1016 An I/O operation initiated by the registry failed unrecoverably. The registry could not read in, or write out, or flush, one of the files that contain the system's image of the registry.  ERROR_REGISTRY_IO_FAILED
			pString = "ERROR_REGISTRY_IO_FAILED";
			break;
		}

		case ERROR_NOT_REGISTRY_FILE:
		{
			// 1017 The system has attempted to load or restore a file into the registry, but the specified file is not in a registry file format.  ERROR_NOT_REGISTRY_FILE
			pString = "ERROR_NOT_REGISTRY_FILE";
			break;
		}

		case ERROR_KEY_DELETED:
		{
			// 1018 Illegal operation attempted on a registry key that has been marked for deletion.  ERROR_KEY_DELETED
			pString = "ERROR_KEY_DELETED";
			break;
		}

		case ERROR_NO_LOG_SPACE:
		{
			// 1019 System could not allocate the required space in a registry log.  ERROR_NO_LOG_SPACE
			pString = "ERROR_NO_LOG_SPACE";
			break;
		}

		case ERROR_KEY_HAS_CHILDREN:
		{
			// 1020 Cannot create a symbolic link in a registry key that already has subkeys or values.  ERROR_KEY_HAS_CHILDREN
			pString = "ERROR_KEY_HAS_CHILDREN";
			break;
		}

		case ERROR_CHILD_MUST_BE_VOLATILE:
		{
			// 1021 Cannot create a stable subkey under a volatile parent key.  ERROR_CHILD_MUST_BE_VOLATILE
			pString = "ERROR_CHILD_MUST_BE_VOLATILE";
			break;
		}

		case ERROR_NOTIFY_ENUM_DIR:
		{
			// 1022 A notify change request is being completed and the information is not being returned in the caller's buffer. The caller now needs to enumerate the files to find the changes.  ERROR_NOTIFY_ENUM_DIR
			pString = "ERROR_NOTIFY_ENUM_DIR";
			break;
		}

		case ERROR_DEPENDENT_SERVICES_RUNNING:
		{
			// 1051 A stop control has been sent to a service that other running services are dependent on.  ERROR_DEPENDENT_SERVICES_RUNNING
			pString = "ERROR_DEPENDENT_SERVICES_RUNNING";
			break;
		}

		case ERROR_INVALID_SERVICE_CONTROL:
		{
			// 1052 The requested control is not valid for this service.  ERROR_INVALID_SERVICE_CONTROL
			pString = "ERROR_INVALID_SERVICE_CONTROL";
			break;
		}

		case ERROR_SERVICE_REQUEST_TIMEOUT:
		{
			// 1053 The service did not respond to the start or control request in a timely fashion.  ERROR_SERVICE_REQUEST_TIMEOUT
			pString = "ERROR_SERVICE_REQUEST_TIMEOUT";
			break;
		}

		case ERROR_SERVICE_NO_THREAD:
		{
			// 1054 A thread could not be created for the service.  ERROR_SERVICE_NO_THREAD
			pString = "ERROR_SERVICE_NO_THREAD";
			break;
		}

		case ERROR_SERVICE_DATABASE_LOCKED:
		{
			// 1055 The service database is locked.  ERROR_SERVICE_DATABASE_LOCKED
			pString = "ERROR_SERVICE_DATABASE_LOCKED";
			break;
		}

		case ERROR_SERVICE_ALREADY_RUNNING:
		{
			// 1056 An instance of the service is already running.  ERROR_SERVICE_ALREADY_RUNNING
			pString = "ERROR_SERVICE_ALREADY_RUNNING";
			break;
		}

		case ERROR_INVALID_SERVICE_ACCOUNT:
		{
			// 1057 The account name is invalid or does not exist.  ERROR_INVALID_SERVICE_ACCOUNT
			pString = "ERROR_INVALID_SERVICE_ACCOUNT";
			break;
		}

		case ERROR_SERVICE_DISABLED:
		{
			// 1058 The service cannot be started, either because it is disabled or because it has no enabled devices associated with it.  ERROR_SERVICE_DISABLED
			pString = "ERROR_SERVICE_DISABLED";
			break;
		}

		case ERROR_CIRCULAR_DEPENDENCY:
		{
			// 1059 Circular service dependency was specified.  ERROR_CIRCULAR_DEPENDENCY
			pString = "ERROR_CIRCULAR_DEPENDENCY";
			break;
		}

		case ERROR_SERVICE_DOES_NOT_EXIST:
		{
			// 1060 The specified service does not exist as an installed service.  ERROR_SERVICE_DOES_NOT_EXIST
			pString = "ERROR_SERVICE_DOES_NOT_EXIST";
			break;
		}

		case ERROR_SERVICE_CANNOT_ACCEPT_CTRL:
		{
			// 1061 The service cannot accept control messages at this time.  ERROR_SERVICE_CANNOT_ACCEPT_CTRL
			pString = "ERROR_SERVICE_CANNOT_ACCEPT_CTRL";
			break;
		}

		case ERROR_SERVICE_NOT_ACTIVE:
		{
			// 1062 The service has not been started.  ERROR_SERVICE_NOT_ACTIVE
			pString = "ERROR_SERVICE_NOT_ACTIVE";
			break;
		}

		case ERROR_FAILED_SERVICE_CONTROLLER_CONNECT:
		{
			// 1063 The service process could not connect to the service controller.  ERROR_FAILED_SERVICE_CONTROLLER_CONNECT
			pString = "ERROR_FAILED_SERVICE_CONTROLLER_CONNECT";
			break;
		}

		case ERROR_EXCEPTION_IN_SERVICE:
		{
			// 1064 An exception occurred in the service when handling the control request.  ERROR_EXCEPTION_IN_SERVICE
			pString = "ERROR_EXCEPTION_IN_SERVICE";
			break;
		}

		case ERROR_DATABASE_DOES_NOT_EXIST:
		{
			// 1065 The database specified does not exist.  ERROR_DATABASE_DOES_NOT_EXIST
			pString = "ERROR_DATABASE_DOES_NOT_EXIST";
			break;
		}

		case ERROR_SERVICE_SPECIFIC_ERROR:
		{
			// 1066 The service has returned a service-specific error code.  ERROR_SERVICE_SPECIFIC_ERROR
			pString = "ERROR_SERVICE_SPECIFIC_ERROR";
			break;
		}

		case ERROR_PROCESS_ABORTED:
		{
			// 1067 The process terminated unexpectedly.  ERROR_PROCESS_ABORTED
			pString = "ERROR_PROCESS_ABORTED";
			break;
		}

		case ERROR_SERVICE_DEPENDENCY_FAIL:
		{
			// 1068 The dependency service or group failed to start.  ERROR_SERVICE_DEPENDENCY_FAIL
			pString = "ERROR_SERVICE_DEPENDENCY_FAIL";
			break;
		}

		case ERROR_SERVICE_LOGON_FAILED:
		{
			// 1069 The service did not start due to a logon failure.  ERROR_SERVICE_LOGON_FAILED
			pString = "ERROR_SERVICE_LOGON_FAILED";
			break;
		}

		case ERROR_SERVICE_START_HANG:
		{
			// 1070 After starting, the service hung in a start-pending state.  ERROR_SERVICE_START_HANG
			pString = "ERROR_SERVICE_START_HANG";
			break;
		}

		case ERROR_INVALID_SERVICE_LOCK:
		{
			// 1071 The specified service database lock is invalid.  ERROR_INVALID_SERVICE_LOCK
			pString = "ERROR_INVALID_SERVICE_LOCK";
			break;
		}

		case ERROR_SERVICE_MARKED_FOR_DELETE:
		{
			// 1072 The specified service has been marked for deletion.  ERROR_SERVICE_MARKED_FOR_DELETE
			pString = "ERROR_SERVICE_MARKED_FOR_DELETE";
			break;
		}

		case ERROR_SERVICE_EXISTS:
		{
			// 1073 The specified service already exists.  ERROR_SERVICE_EXISTS
			pString = "ERROR_SERVICE_EXISTS";
			break;
		}

		case ERROR_ALREADY_RUNNING_LKG:
		{
			// 1074 The system is currently running with the last-known-good configuration.  ERROR_ALREADY_RUNNING_LKG
			pString = "ERROR_ALREADY_RUNNING_LKG";
			break;
		}

		case ERROR_SERVICE_DEPENDENCY_DELETED:
		{
			// 1075 The dependency service does not exist or has been marked for deletion.  ERROR_SERVICE_DEPENDENCY_DELETED
			pString = "ERROR_SERVICE_DEPENDENCY_DELETED";
			break;
		}

		case ERROR_BOOT_ALREADY_ACCEPTED:
		{
			// 1076 The current boot has already been accepted for use as the last-known-good control set.  ERROR_BOOT_ALREADY_ACCEPTED
			pString = "ERROR_BOOT_ALREADY_ACCEPTED";
			break;
		}

		case ERROR_SERVICE_NEVER_STARTED:
		{
			// 1077 No attempts to start the service have been made since the last boot.  ERROR_SERVICE_NEVER_STARTED
			pString = "ERROR_SERVICE_NEVER_STARTED";
			break;
		}

		case ERROR_DUPLICATE_SERVICE_NAME:
		{
			// 1078 The name is already in use as either a service name or a service display name.  ERROR_DUPLICATE_SERVICE_NAME
			pString = "ERROR_DUPLICATE_SERVICE_NAME";
			break;
		}

		case ERROR_DIFFERENT_SERVICE_ACCOUNT:
		{
			// 1079 The account specified for this service is different from the account specified for other services running in the same process.  ERROR_DIFFERENT_SERVICE_ACCOUNT
			pString = "ERROR_DIFFERENT_SERVICE_ACCOUNT";
			break;
		}

		case ERROR_CANNOT_DETECT_DRIVER_FAILURE:
		{
			// 1080 Failure actions can only be set for Win32 services, not for drivers.  ERROR_CANNOT_DETECT_DRIVER_FAILURE
			pString = "ERROR_CANNOT_DETECT_DRIVER_FAILURE";
			break;
		}

		case ERROR_CANNOT_DETECT_PROCESS_ABORT:
		{
			// 1081 This service runs in the same process as the service control manager. Therefore, the service control manager cannot take action if this service's process terminates unexpectedly.  ERROR_CANNOT_DETECT_PROCESS_ABORT
			pString = "ERROR_CANNOT_DETECT_PROCESS_ABORT";
			break;
		}

		case ERROR_NO_RECOVERY_PROGRAM:
		{
			// 1082 No recovery program has been configured for this service.  ERROR_NO_RECOVERY_PROGRAM
			pString = "ERROR_NO_RECOVERY_PROGRAM";
			break;
		}

		case ERROR_END_OF_MEDIA:
		{
			// 1100 The physical end of the tape has been reached.  ERROR_END_OF_MEDIA
			pString = "ERROR_END_OF_MEDIA";
			break;
		}

		case ERROR_FILEMARK_DETECTED:
		{
			// 1101 A tape access reached a filemark.  ERROR_FILEMARK_DETECTED
			pString = "ERROR_FILEMARK_DETECTED";
			break;
		}

		case ERROR_BEGINNING_OF_MEDIA:
		{
			// 1102 The beginning of the tape or a partition was encountered.  ERROR_BEGINNING_OF_MEDIA
			pString = "ERROR_BEGINNING_OF_MEDIA";
			break;
		}

		case ERROR_SETMARK_DETECTED:
		{
			// 1103 A tape access reached the end of a set of files.  ERROR_SETMARK_DETECTED
			pString = "ERROR_SETMARK_DETECTED";
			break;
		}

		case ERROR_NO_DATA_DETECTED:
		{
			// 1104 No more data is on the tape.  ERROR_NO_DATA_DETECTED
			pString = "ERROR_NO_DATA_DETECTED";
			break;
		}

		case ERROR_PARTITION_FAILURE:
		{
			// 1105 Tape could not be partitioned.  ERROR_PARTITION_FAILURE
			pString = "ERROR_PARTITION_FAILURE";
			break;
		}

		case ERROR_INVALID_BLOCK_LENGTH:
		{
			// 1106 When accessing a new tape of a multivolume partition, the current blocksize is incorrect.  ERROR_INVALID_BLOCK_LENGTH
			pString = "ERROR_INVALID_BLOCK_LENGTH";
			break;
		}

		case ERROR_DEVICE_NOT_PARTITIONED:
		{
			// 1107 Tape partition information could not be found when loading a tape.  ERROR_DEVICE_NOT_PARTITIONED
			pString = "ERROR_DEVICE_NOT_PARTITIONED";
			break;
		}

		case ERROR_UNABLE_TO_LOCK_MEDIA:
		{
			// 1108 Unable to lock the media eject mechanism.  ERROR_UNABLE_TO_LOCK_MEDIA
			pString = "ERROR_UNABLE_TO_LOCK_MEDIA";
			break;
		}

		case ERROR_UNABLE_TO_UNLOAD_MEDIA:
		{
			// 1109 Unable to unload the media.  ERROR_UNABLE_TO_UNLOAD_MEDIA
			pString = "ERROR_UNABLE_TO_UNLOAD_MEDIA";
			break;
		}

		case ERROR_MEDIA_CHANGED:
		{
			// 1110 The media in the drive may have changed.  ERROR_MEDIA_CHANGED
			pString = "ERROR_MEDIA_CHANGED";
			break;
		}

		case ERROR_BUS_RESET:
		{
			// 1111 The I/O bus was reset.  ERROR_BUS_RESET
			pString = "ERROR_BUS_RESET";
			break;
		}

		case ERROR_NO_MEDIA_IN_DRIVE:
		{
			// 1112 No media in drive.  ERROR_NO_MEDIA_IN_DRIVE
			pString = "ERROR_NO_MEDIA_IN_DRIVE";
			break;
		}

		case ERROR_NO_UNICODE_TRANSLATION:
		{
			// 1113 No mapping for the Unicode character exists in the target multi-byte code page.  ERROR_NO_UNICODE_TRANSLATION
			pString = "ERROR_NO_UNICODE_TRANSLATION";
			break;
		}

		case ERROR_DLL_INIT_FAILED:
		{
			// 1114 A dynamic link library (DLL) initialization routine failed.  ERROR_DLL_INIT_FAILED
			pString = "ERROR_DLL_INIT_FAILED";
			break;
		}

		case ERROR_SHUTDOWN_IN_PROGRESS:
		{
			// 1115 A system shutdown is in progress.  ERROR_SHUTDOWN_IN_PROGRESS
			pString = "ERROR_SHUTDOWN_IN_PROGRESS";
			break;
		}

		case ERROR_NO_SHUTDOWN_IN_PROGRESS:
		{
			// 1116 Unable to abort the system shutdown because no shutdown was in progress.  ERROR_NO_SHUTDOWN_IN_PROGRESS
			pString = "ERROR_NO_SHUTDOWN_IN_PROGRESS";
			break;
		}

		case ERROR_IO_DEVICE:
		{
			// 1117 The request could not be performed because of an I/O device error.  ERROR_IO_DEVICE
			pString = "ERROR_IO_DEVICE";
			break;
		}

		case ERROR_SERIAL_NO_DEVICE:
		{
			// 1118 No serial device was successfully initialized. The serial driver will unload.  ERROR_SERIAL_NO_DEVICE
			pString = "ERROR_SERIAL_NO_DEVICE";
			break;
		}

		case ERROR_IRQ_BUSY:
		{
			// 1119 Unable to open a device that was sharing an interrupt request (IRQ) with other devices. At least one other device that uses that IRQ was already opened.  ERROR_IRQ_BUSY
			pString = "ERROR_IRQ_BUSY";
			break;
		}

		case ERROR_MORE_WRITES:
		{
			// 1120 A serial I/O operation was completed by another write to the serial port. The IOCTL_SERIAL_XOFF_COUNTER reached zero.)  ERROR_MORE_WRITES
			pString = "ERROR_MORE_WRITES";
			break;
		}

		case ERROR_COUNTER_TIMEOUT:
		{
			// 1121 A serial I/O operation completed because the timeout period expired. The IOCTL_SERIAL_XOFF_COUNTER did not reach zero.)  ERROR_COUNTER_TIMEOUT
			pString = "ERROR_COUNTER_TIMEOUT";
			break;
		}

		case ERROR_FLOPPY_ID_MARK_NOT_FOUND:
		{
			// 1122 No ID address mark was found on the floppy disk.  ERROR_FLOPPY_ID_MARK_NOT_FOUND
			pString = "ERROR_FLOPPY_ID_MARK_NOT_FOUND";
			break;
		}

		case ERROR_FLOPPY_WRONG_CYLINDER:
		{
			// 1123 Mismatch between the floppy disk sector ID field and the floppy disk controller track address.  ERROR_FLOPPY_WRONG_CYLINDER
			pString = "ERROR_FLOPPY_WRONG_CYLINDER";
			break;
		}

		case ERROR_FLOPPY_UNKNOWN_ERROR:
		{
			// 1124 The floppy disk controller reported an error that is not recognized by the floppy disk driver.  ERROR_FLOPPY_UNKNOWN_ERROR
			pString = "ERROR_FLOPPY_UNKNOWN_ERROR";
			break;
		}

		case ERROR_FLOPPY_BAD_REGISTERS:
		{
			// 1125 The floppy disk controller returned inconsistent results in its registers.  ERROR_FLOPPY_BAD_REGISTERS
			pString = "ERROR_FLOPPY_BAD_REGISTERS";
			break;
		}

		case ERROR_DISK_RECALIBRATE_FAILED:
		{
			// 1126 While accessing the hard disk, a recalibrate operation failed, even after retries.  ERROR_DISK_RECALIBRATE_FAILED
			pString = "ERROR_DISK_RECALIBRATE_FAILED";
			break;
		}

		case ERROR_DISK_OPERATION_FAILED:
		{
			// 1127 While accessing the hard disk, a disk operation failed even after retries.  ERROR_DISK_OPERATION_FAILED
			pString = "ERROR_DISK_OPERATION_FAILED";
			break;
		}

		case ERROR_DISK_RESET_FAILED:
		{
			// 1128 While accessing the hard disk, a disk controller reset was needed, but even that failed.  ERROR_DISK_RESET_FAILED
			pString = "ERROR_DISK_RESET_FAILED";
			break;
		}

		case ERROR_EOM_OVERFLOW:
		{
			// 1129 Physical end of tape encountered.  ERROR_EOM_OVERFLOW
			pString = "ERROR_EOM_OVERFLOW";
			break;
		}

		case ERROR_NOT_ENOUGH_SERVER_MEMORY:
		{
			// 1130 Not enough server storage is available to process this command.  ERROR_NOT_ENOUGH_SERVER_MEMORY
			pString = "ERROR_NOT_ENOUGH_SERVER_MEMORY";
			break;
		}

		case ERROR_POSSIBLE_DEADLOCK:
		{
			// 1131 A potential deadlock condition has been detected.  ERROR_POSSIBLE_DEADLOCK
			pString = "ERROR_POSSIBLE_DEADLOCK";
			break;
		}

		case ERROR_MAPPED_ALIGNMENT:
		{
			// 1132 The base address or the file offset specified does not have the proper alignment.  ERROR_MAPPED_ALIGNMENT
			pString = "ERROR_MAPPED_ALIGNMENT";
			break;
		}

		case ERROR_SET_POWER_STATE_VETOED:
		{
			// 1140 An attempt to change the system power state was vetoed by another application or driver.  ERROR_SET_POWER_STATE_VETOED
			pString = "ERROR_SET_POWER_STATE_VETOED";
			break;
		}

		case ERROR_SET_POWER_STATE_FAILED:
		{
			// 1141 The system BIOS failed an attempt to change the system power state.  ERROR_SET_POWER_STATE_FAILED
			pString = "ERROR_SET_POWER_STATE_FAILED";
			break;
		}

		case ERROR_TOO_MANY_LINKS:
		{
			// 1142 An attempt was made to create more links on a file than the file system supports.  ERROR_TOO_MANY_LINKS
			pString = "ERROR_TOO_MANY_LINKS";
			break;
		}

		case ERROR_OLD_WIN_VERSION:
		{
			// 1150 The specified program requires a newer version of Windows.  ERROR_OLD_WIN_VERSION
			pString = "ERROR_OLD_WIN_VERSION";
			break;
		}

		case ERROR_APP_WRONG_OS:
		{
			// 1151 The specified program is not a Windows or MS-DOS program.  ERROR_APP_WRONG_OS
			pString = "ERROR_APP_WRONG_OS";
			break;
		}

		case ERROR_SINGLE_INSTANCE_APP:
		{
			// 1152 Cannot start more than one instance of the specified program.  ERROR_SINGLE_INSTANCE_APP
			pString = "ERROR_SINGLE_INSTANCE_APP";
			break;
		}

		case ERROR_RMODE_APP:
		{
			// 1153 The specified program was written for an earlier version of Windows.  ERROR_RMODE_APP
			pString = "ERROR_RMODE_APP";
			break;
		}

		case ERROR_INVALID_DLL:
		{
			// 1154 One of the library files needed to run this application is damaged.  ERROR_INVALID_DLL
			pString = "ERROR_INVALID_DLL";
			break;
		}

		case ERROR_NO_ASSOCIATION:
		{
			// 1155 No application is associated with the specified file for this operation.  ERROR_NO_ASSOCIATION
			pString = "ERROR_NO_ASSOCIATION";
			break;
		}

		case ERROR_DDE_FAIL:
		{
			// 1156 An error occurred in sending the command to the application.  ERROR_DDE_FAIL
			pString = "ERROR_DDE_FAIL";
			break;
		}

		case ERROR_DLL_NOT_FOUND:
		{
			// 1157 One of the library files needed to run this application cannot be found.  ERROR_DLL_NOT_FOUND
			pString = "ERROR_DLL_NOT_FOUND";
			break;
		}

		case ERROR_NO_MORE_USER_HANDLES:
		{
			// 1158 The current process has used all of its system allowance of handles for Window Manager objects.  ERROR_NO_MORE_USER_HANDLES
			pString = "ERROR_NO_MORE_USER_HANDLES";
			break;
		}

		case ERROR_MESSAGE_SYNC_ONLY:
		{
			// 1159 The message can be used only with synchronous operations.  ERROR_MESSAGE_SYNC_ONLY
			pString = "ERROR_MESSAGE_SYNC_ONLY";
			break;
		}

		case ERROR_SOURCE_ELEMENT_EMPTY:
		{
			// 1160 The indicated source element has no media.  ERROR_SOURCE_ELEMENT_EMPTY
			pString = "ERROR_SOURCE_ELEMENT_EMPTY";
			break;
		}

		case ERROR_DESTINATION_ELEMENT_FULL:
		{
			// 1161 The indicated destination element already contains media.  ERROR_DESTINATION_ELEMENT_FULL
			pString = "ERROR_DESTINATION_ELEMENT_FULL";
			break;
		}

		case ERROR_ILLEGAL_ELEMENT_ADDRESS:
		{
			// 1162 The indicated element does not exist.  ERROR_ILLEGAL_ELEMENT_ADDRESS
			pString = "ERROR_ILLEGAL_ELEMENT_ADDRESS";
			break;
		}

		case ERROR_MAGAZINE_NOT_PRESENT:
		{
			// 1163 The indicated element is part of a magazine that is not present.  ERROR_MAGAZINE_NOT_PRESENT
			pString = "ERROR_MAGAZINE_NOT_PRESENT";
			break;
		}

		case ERROR_DEVICE_REINITIALIZATION_NEEDED:
		{
			// 1164 The indicated device requires reinitialization due to hardware errors.  ERROR_DEVICE_REINITIALIZATION_NEEDED
			pString = "ERROR_DEVICE_REINITIALIZATION_NEEDED";
			break;
		}

		case ERROR_DEVICE_REQUIRES_CLEANING:
		{
			// 1165 The device has indicated that cleaning is required before further operations are attempted.  ERROR_DEVICE_REQUIRES_CLEANING
			pString = "ERROR_DEVICE_REQUIRES_CLEANING";
			break;
		}

		case ERROR_DEVICE_DOOR_OPEN:
		{
			// 1166 The device has indicated that its door is open.  ERROR_DEVICE_DOOR_OPEN
			pString = "ERROR_DEVICE_DOOR_OPEN";
			break;
		}

		case ERROR_DEVICE_NOT_CONNECTED:
		{
			// 1167 The device is not connected.  ERROR_DEVICE_NOT_CONNECTED
			pString = "ERROR_DEVICE_NOT_CONNECTED";
			break;
		}

		case ERROR_NOT_FOUND:
		{
			// 1168 Element not found.  ERROR_NOT_FOUND
			pString = "ERROR_NOT_FOUND";
			break;
		}

		case ERROR_NO_MATCH:
		{
			// 1169 There was no match for the specified key in the index.  ERROR_NO_MATCH
			pString = "ERROR_NO_MATCH";
			break;
		}

		case ERROR_SET_NOT_FOUND:
		{
			// 1170 The property set specified does not exist on the object.  ERROR_SET_NOT_FOUND
			pString = "ERROR_SET_NOT_FOUND";
			break;
		}

		case ERROR_POINT_NOT_FOUND:
		{
			// 1171 The point passed to GetMouseMovePoints is not in the buffer.  ERROR_POINT_NOT_FOUND
			pString = "ERROR_POINT_NOT_FOUND";
			break;
		}

		case ERROR_NO_TRACKING_SERVICE:
		{
			// 1172 The tracking (workstation) service is not running.  ERROR_NO_TRACKING_SERVICE
			pString = "ERROR_NO_TRACKING_SERVICE";
			break;
		}

		case ERROR_NO_VOLUME_ID:
		{
			// 1173 The Volume ID could not be found.  ERROR_NO_VOLUME_ID
			pString = "ERROR_NO_VOLUME_ID";
			break;
		}

		case ERROR_BAD_DEVICE:
		{
			// 1200 The specified device name is invalid.  ERROR_BAD_DEVICE
			pString = "ERROR_BAD_DEVICE";
			break;
		}

		case ERROR_CONNECTION_UNAVAIL:
		{
			// 1201 The device is not currently connected but it is a remembered connection.  ERROR_CONNECTION_UNAVAIL
			pString = "ERROR_CONNECTION_UNAVAIL";
			break;
		}

		case ERROR_DEVICE_ALREADY_REMEMBERED:
		{
			// 1202 An attempt was made to remember a device that had previously been remembered.  ERROR_DEVICE_ALREADY_REMEMBERED
			pString = "ERROR_DEVICE_ALREADY_REMEMBERED";
			break;
		}

		case ERROR_NO_NET_OR_BAD_PATH:
		{
			// 1203 No network provider accepted the given network path.  ERROR_NO_NET_OR_BAD_PATH
			pString = "ERROR_NO_NET_OR_BAD_PATH";
			break;
		}

		case ERROR_BAD_PROVIDER:
		{
			// 1204 The specified network provider name is invalid.  ERROR_BAD_PROVIDER
			pString = "ERROR_BAD_PROVIDER";
			break;
		}

		case ERROR_CANNOT_OPEN_PROFILE:
		{
			// 1205 Unable to open the network connection profile.  ERROR_CANNOT_OPEN_PROFILE
			pString = "ERROR_CANNOT_OPEN_PROFILE";
			break;
		}

		case ERROR_BAD_PROFILE:
		{
			// 1206 The network connection profile is corrupted.  ERROR_BAD_PROFILE
			pString = "ERROR_BAD_PROFILE";
			break;
		}

		case ERROR_NOT_CONTAINER:
		{
			// 1207 Cannot enumerate a noncontainer.  ERROR_NOT_CONTAINER
			pString = "ERROR_NOT_CONTAINER";
			break;
		}

		case ERROR_EXTENDED_ERROR:
		{
			// 1208 An extended error has occurred.  ERROR_EXTENDED_ERROR
			pString = "ERROR_EXTENDED_ERROR";
			break;
		}

		case ERROR_INVALID_GROUPNAME:
		{
			// 1209 The format of the specified group name is invalid.  ERROR_INVALID_GROUPNAME
			pString = "ERROR_INVALID_GROUPNAME";
			break;
		}

		case ERROR_INVALID_COMPUTERNAME:
		{
			// 1210 The format of the specified computer name is invalid.  ERROR_INVALID_COMPUTERNAME
			pString = "ERROR_INVALID_COMPUTERNAME";
			break;
		}

		case ERROR_INVALID_EVENTNAME:
		{
			// 1211 The format of the specified event name is invalid.  ERROR_INVALID_EVENTNAME
			pString = "ERROR_INVALID_EVENTNAME";
			break;
		}

		case ERROR_INVALID_DOMAINNAME:
		{
			// 1212 The format of the specified domain name is invalid.  ERROR_INVALID_DOMAINNAME
			pString = "ERROR_INVALID_DOMAINNAME";
			break;
		}

		case ERROR_INVALID_SERVICENAME:
		{
			// 1213 The format of the specified service name is invalid.  ERROR_INVALID_SERVICENAME
			pString = "ERROR_INVALID_SERVICENAME";
			break;
		}

		case ERROR_INVALID_NETNAME:
		{
			// 1214 The format of the specified network name is invalid.  ERROR_INVALID_NETNAME
			pString = "ERROR_INVALID_NETNAME";
			break;
		}

		case ERROR_INVALID_SHARENAME:
		{
			// 1215 The format of the specified share name is invalid.  ERROR_INVALID_SHARENAME
			pString = "ERROR_INVALID_SHARENAME";
			break;
		}

		case ERROR_INVALID_PASSWORDNAME:
		{
			// 1216 The format of the specified password is invalid.  ERROR_INVALID_PASSWORDNAME
			pString = "ERROR_INVALID_PASSWORDNAME";
			break;
		}

		case ERROR_INVALID_MESSAGENAME:
		{
			// 1217 The format of the specified message name is invalid.  ERROR_INVALID_MESSAGENAME
			pString = "ERROR_INVALID_MESSAGENAME";
			break;
		}

		case ERROR_INVALID_MESSAGEDEST:
		{
			// 1218 The format of the specified message destination is invalid.  ERROR_INVALID_MESSAGEDEST
			pString = "ERROR_INVALID_MESSAGEDEST";
			break;
		}

		case ERROR_SESSION_CREDENTIAL_CONFLICT:
		{
			// 1219 The credentials supplied conflict with an existing set of credentials.  ERROR_SESSION_CREDENTIAL_CONFLICT
			pString = "ERROR_SESSION_CREDENTIAL_CONFLICT";
			break;
		}

		case ERROR_REMOTE_SESSION_LIMIT_EXCEEDED:
		{
			// 1220 An attempt was made to establish a session to a network server, but there are already too many sessions established to that server.  ERROR_REMOTE_SESSION_LIMIT_EXCEEDED
			pString = "ERROR_REMOTE_SESSION_LIMIT_EXCEEDED";
			break;
		}

		case ERROR_DUP_DOMAINNAME:
		{
			// 1221 The workgroup or domain name is already in use by another computer on the network.  ERROR_DUP_DOMAINNAME
			pString = "ERROR_DUP_DOMAINNAME";
			break;
		}

		case ERROR_NO_NETWORK:
		{
			// 1222 The network is not present or not started.  ERROR_NO_NETWORK
			pString = "ERROR_NO_NETWORK";
			break;
		}

		case ERROR_CANCELLED:
		{
			// 1223 The operation was canceled by the user.  ERROR_CANCELLED
			pString = "ERROR_CANCELLED";
			break;
		}

		case ERROR_USER_MAPPED_FILE:
		{
			// 1224 The requested operation cannot be performed on a file with a user-mapped section open.  ERROR_USER_MAPPED_FILE
			pString = "ERROR_USER_MAPPED_FILE";
			break;
		}

		case ERROR_CONNECTION_REFUSED:
		{
			// 1225 The remote system refused the network connection.  ERROR_CONNECTION_REFUSED
			pString = "ERROR_CONNECTION_REFUSED";
			break;
		}

		case ERROR_GRACEFUL_DISCONNECT:
		{
			// 1226 The network connection was gracefully closed.  ERROR_GRACEFUL_DISCONNECT
			pString = "ERROR_GRACEFUL_DISCONNECT";
			break;
		}

		case ERROR_ADDRESS_ALREADY_ASSOCIATED:
		{
			// 1227 The network transport endpoint already has an address associated with it.  ERROR_ADDRESS_ALREADY_ASSOCIATED
			pString = "ERROR_ADDRESS_ALREADY_ASSOCIATED";
			break;
		}

		case ERROR_ADDRESS_NOT_ASSOCIATED:
		{
			// 1228 An address has not yet been associated with the network endpoint.  ERROR_ADDRESS_NOT_ASSOCIATED
			pString = "ERROR_ADDRESS_NOT_ASSOCIATED";
			break;
		}

		case ERROR_CONNECTION_INVALID:
		{
			// 1229 An operation was attempted on a nonexistent network connection.  ERROR_CONNECTION_INVALID
			pString = "ERROR_CONNECTION_INVALID";
			break;
		}

		case ERROR_CONNECTION_ACTIVE:
		{
			// 1230 An invalid operation was attempted on an active network connection.  ERROR_CONNECTION_ACTIVE
			pString = "ERROR_CONNECTION_ACTIVE";
			break;
		}

		case ERROR_NETWORK_UNREACHABLE:
		{
			// 1231 The remote network is not reachable by the transport.  ERROR_NETWORK_UNREACHABLE
			pString = "ERROR_NETWORK_UNREACHABLE";
			break;
		}

		case ERROR_HOST_UNREACHABLE:
		{
			// 1232 The remote system is not reachable by the transport.  ERROR_HOST_UNREACHABLE
			pString = "ERROR_HOST_UNREACHABLE";
			break;
		}

		case ERROR_PROTOCOL_UNREACHABLE:
		{
			// 1233 The remote system does not support the transport protocol.  ERROR_PROTOCOL_UNREACHABLE
			pString = "ERROR_PROTOCOL_UNREACHABLE";
			break;
		}

		case ERROR_PORT_UNREACHABLE:
		{
			// 1234 No service is operating at the destination network endpoint on the remote system.  ERROR_PORT_UNREACHABLE
			pString = "ERROR_PORT_UNREACHABLE";
			break;
		}

		case ERROR_REQUEST_ABORTED:
		{
			// 1235 The request was aborted.  ERROR_REQUEST_ABORTED
			pString = "ERROR_REQUEST_ABORTED";
			break;
		}

		case ERROR_CONNECTION_ABORTED:
		{
			// 1236 The network connection was aborted by the local system.  ERROR_CONNECTION_ABORTED
			pString = "ERROR_CONNECTION_ABORTED";
			break;
		}

		case ERROR_RETRY:
		{
			// 1237 The operation could not be completed. A retry should be performed.  ERROR_RETRY
			pString = "ERROR_RETRY";
			break;
		}

		case ERROR_CONNECTION_COUNT_LIMIT:
		{
			// 1238 A connection to the server could not be made because the limit on the number of concurrent connections for this account has been reached.  ERROR_CONNECTION_COUNT_LIMIT
			pString = "ERROR_CONNECTION_COUNT_LIMIT";
			break;
		}

		case ERROR_LOGIN_TIME_RESTRICTION:
		{
			// 1239 Attempting to log in during an unauthorized time of day for this account.  ERROR_LOGIN_TIME_RESTRICTION
			pString = "ERROR_LOGIN_TIME_RESTRICTION";
			break;
		}

		case ERROR_LOGIN_WKSTA_RESTRICTION:
		{
			// 1240 The account is not authorized to log in from this station.  ERROR_LOGIN_WKSTA_RESTRICTION
			pString = "ERROR_LOGIN_WKSTA_RESTRICTION";
			break;
		}

		case ERROR_INCORRECT_ADDRESS:
		{
			// 1241 The network address could not be used for the operation requested.  ERROR_INCORRECT_ADDRESS
			pString = "ERROR_INCORRECT_ADDRESS";
			break;
		}

		case ERROR_ALREADY_REGISTERED:
		{
			// 1242 The service is already registered.  ERROR_ALREADY_REGISTERED
			pString = "ERROR_ALREADY_REGISTERED";
			break;
		}

		case ERROR_SERVICE_NOT_FOUND:
		{
			// 1243 The specified service does not exist.  ERROR_SERVICE_NOT_FOUND
			pString = "ERROR_SERVICE_NOT_FOUND";
			break;
		}

		case ERROR_NOT_AUTHENTICATED:
		{
			// 1244 The operation being requested was not performed because the user has not been authenticated.  ERROR_NOT_AUTHENTICATED
			pString = "ERROR_NOT_AUTHENTICATED";
			break;
		}

		case ERROR_NOT_LOGGED_ON:
		{
			// 1245 The operation being requested was not performed because the user has not logged on to the network. The specified service does not exist.  ERROR_NOT_LOGGED_ON
			pString = "ERROR_NOT_LOGGED_ON";
			break;
		}

		case ERROR_CONTINUE:
		{
			// 1246 Continue with work in progress.  ERROR_CONTINUE
			pString = "ERROR_CONTINUE";
			break;
		}

		case ERROR_ALREADY_INITIALIZED:
		{
			// 1247 An attempt was made to perform an initialization operation when initialization has already been completed.  ERROR_ALREADY_INITIALIZED
			pString = "ERROR_ALREADY_INITIALIZED";
			break;
		}

		case ERROR_NO_MORE_DEVICES:
		{
			// 1248 No more local devices.  ERROR_NO_MORE_DEVICES
			pString = "ERROR_NO_MORE_DEVICES";
			break;
		}

		case ERROR_NO_SUCH_SITE:
		{
			// 1249 The specified site does not exist.  ERROR_NO_SUCH_SITE
			pString = "ERROR_NO_SUCH_SITE";
			break;
		}

		case ERROR_DOMAIN_CONTROLLER_EXISTS:
		{
			// 1250 A domain controller with the specified name already exists.  ERROR_DOMAIN_CONTROLLER_EXISTS
			pString = "ERROR_DOMAIN_CONTROLLER_EXISTS";
			break;
		}

		case ERROR_DS_NOT_INSTALLED:
		{
			// 1251 An error occurred while installing the Windows NT directory service. Please view the event log for more information.  ERROR_DS_NOT_INSTALLED
			pString = "ERROR_DS_NOT_INSTALLED";
			break;
		}

		case ERROR_NOT_ALL_ASSIGNED:
		{
			// 1300 Not all privileges referenced are assigned to the caller.  ERROR_NOT_ALL_ASSIGNED
			pString = "ERROR_NOT_ALL_ASSIGNED";
			break;
		}

		case ERROR_SOME_NOT_MAPPED:
		{
			// 1301 Some mapping between account names and security IDs was not done.  ERROR_SOME_NOT_MAPPED
			pString = "ERROR_SOME_NOT_MAPPED";
			break;
		}

		case ERROR_NO_QUOTAS_FOR_ACCOUNT:
		{
			// 1302 No system quota limits are specifically set for this account.  ERROR_NO_QUOTAS_FOR_ACCOUNT
			pString = "ERROR_NO_QUOTAS_FOR_ACCOUNT";
			break;
		}

		case ERROR_LOCAL_USER_SESSION_KEY:
		{
			// 1303 No encryption key is available. A well-known encryption key was returned.  ERROR_LOCAL_USER_SESSION_KEY
			pString = "ERROR_LOCAL_USER_SESSION_KEY";
			break;
		}

		case ERROR_NULL_LM_PASSWORD:
		{
			// 1304 The Windows NT password is too complex to be converted to a LAN Manager password. The LAN Manager password returned is a NULL string.  ERROR_NULL_LM_PASSWORD
			pString = "ERROR_NULL_LM_PASSWORD";
			break;
		}

		case ERROR_UNKNOWN_REVISION:
		{
			// 1305 The revision level is unknown.  ERROR_UNKNOWN_REVISION
			pString = "ERROR_UNKNOWN_REVISION";
			break;
		}

		case ERROR_REVISION_MISMATCH:
		{
			// 1306 Indicates two revision levels are incompatible.  ERROR_REVISION_MISMATCH
			pString = "ERROR_REVISION_MISMATCH";
			break;
		}

		case ERROR_INVALID_OWNER:
		{
			// 1307 This security ID may not be assigned as the owner of this object.  ERROR_INVALID_OWNER
			pString = "ERROR_INVALID_OWNER";
			break;
		}

		case ERROR_INVALID_PRIMARY_GROUP:
		{
			// 1308 This security ID may not be assigned as the primary group of an object.  ERROR_INVALID_PRIMARY_GROUP
			pString = "ERROR_INVALID_PRIMARY_GROUP";
			break;
		}

		case ERROR_NO_IMPERSONATION_TOKEN:
		{
			// 1309 An attempt has been made to operate on an impersonation token by a thread that is not currently impersonating a client.  ERROR_NO_IMPERSONATION_TOKEN
			pString = "ERROR_NO_IMPERSONATION_TOKEN";
			break;
		}

		case ERROR_CANT_DISABLE_MANDATORY:
		{
			// 1310 The group may not be disabled.  ERROR_CANT_DISABLE_MANDATORY
			pString = "ERROR_CANT_DISABLE_MANDATORY";
			break;
		}

		case ERROR_NO_LOGON_SERVERS:
		{
			// 1311 There are currently no logon servers available to service the logon request.  ERROR_NO_LOGON_SERVERS
			pString = "ERROR_NO_LOGON_SERVERS";
			break;
		}

		case ERROR_NO_SUCH_LOGON_SESSION:
		{
			// 1312 A specified logon session does not exist. It may already have been terminated.  ERROR_NO_SUCH_LOGON_SESSION
			pString = "ERROR_NO_SUCH_LOGON_SESSION";
			break;
		}

		case ERROR_NO_SUCH_PRIVILEGE:
		{
			// 1313 A specified privilege does not exist.  ERROR_NO_SUCH_PRIVILEGE
			pString = "ERROR_NO_SUCH_PRIVILEGE";
			break;
		}

		case ERROR_PRIVILEGE_NOT_HELD:
		{
			// 1314 A required privilege is not held by the client.  ERROR_PRIVILEGE_NOT_HELD
			pString = "ERROR_PRIVILEGE_NOT_HELD";
			break;
		}

		case ERROR_INVALID_ACCOUNT_NAME:
		{
			// 1315 The name provided is not a properly formed account name.  ERROR_INVALID_ACCOUNT_NAME
			pString = "ERROR_INVALID_ACCOUNT_NAME";
			break;
		}

		case ERROR_USER_EXISTS:
		{
			// 1316 The specified user already exists.  ERROR_USER_EXISTS
			pString = "ERROR_USER_EXISTS";
			break;
		}

		case ERROR_NO_SUCH_USER:
		{
			// 1317 The specified user does not exist.  ERROR_NO_SUCH_USER
			pString = "ERROR_NO_SUCH_USER";
			break;
		}

		case ERROR_GROUP_EXISTS:
		{
			// 1318 The specified group already exists.  ERROR_GROUP_EXISTS
			pString = "ERROR_GROUP_EXISTS";
			break;
		}

		case ERROR_NO_SUCH_GROUP:
		{
			// 1319 The specified group does not exist.  ERROR_NO_SUCH_GROUP
			pString = "ERROR_NO_SUCH_GROUP";
			break;
		}

		case ERROR_MEMBER_IN_GROUP:
		{
			// 1320 Either the specified user account is already a member of the specified group, or the specified group cannot be deleted because it contains a member.  ERROR_MEMBER_IN_GROUP
			pString = "ERROR_MEMBER_IN_GROUP";
			break;
		}

		case ERROR_MEMBER_NOT_IN_GROUP:
		{
			// 1321 The specified user account is not a member of the specified group account.  ERROR_MEMBER_NOT_IN_GROUP
			pString = "ERROR_MEMBER_NOT_IN_GROUP";
			break;
		}

		case ERROR_LAST_ADMIN:
		{
			// 1322 The last remaining administration account cannot be disabled or deleted.  ERROR_LAST_ADMIN
			pString = "ERROR_LAST_ADMIN";
			break;
		}

		case ERROR_WRONG_PASSWORD:
		{
			// 1323 Unable to update the password. The value provided as the current password is incorrect.  ERROR_WRONG_PASSWORD
			pString = "ERROR_WRONG_PASSWORD";
			break;
		}

		case ERROR_ILL_FORMED_PASSWORD:
		{
			// 1324 Unable to update the password. The value provided for the new password contains values that are not allowed in passwords.  ERROR_ILL_FORMED_PASSWORD
			pString = "ERROR_ILL_FORMED_PASSWORD";
			break;
		}

		case ERROR_PASSWORD_RESTRICTION:
		{
			// 1325 Unable to update the password because a password update rule has been violated.  ERROR_PASSWORD_RESTRICTION
			pString = "ERROR_PASSWORD_RESTRICTION";
			break;
		}

		case ERROR_LOGON_FAILURE:
		{
			// 1326 Logon failure: unknown user name or bad password.  ERROR_LOGON_FAILURE
			pString = "ERROR_LOGON_FAILURE";
			break;
		}

		case ERROR_ACCOUNT_RESTRICTION:
		{
			// 1327 Logon failure: user account restriction.  ERROR_ACCOUNT_RESTRICTION
			pString = "ERROR_ACCOUNT_RESTRICTION";
			break;
		}

		case ERROR_INVALID_LOGON_HOURS:
		{
			// 1328 Logon failure: account logon time restriction violation.  ERROR_INVALID_LOGON_HOURS
			pString = "ERROR_INVALID_LOGON_HOURS";
			break;
		}

		case ERROR_INVALID_WORKSTATION:
		{
			// 1329 Logon failure: user not allowed to log on to this computer.  ERROR_INVALID_WORKSTATION
			pString = "ERROR_INVALID_WORKSTATION";
			break;
		}

		case ERROR_PASSWORD_EXPIRED:
		{
			// 1330 Logon failure: the specified account password has expired.  ERROR_PASSWORD_EXPIRED
			pString = "ERROR_PASSWORD_EXPIRED";
			break;
		}

		case ERROR_ACCOUNT_DISABLED:
		{
			// 1331 Logon failure: account currently disabled.  ERROR_ACCOUNT_DISABLED
			pString = "ERROR_ACCOUNT_DISABLED";
			break;
		}

		case ERROR_NONE_MAPPED:
		{
			// 1332 No mapping between account names and security IDs was done.  ERROR_NONE_MAPPED
			pString = "ERROR_NONE_MAPPED";
			break;
		}

		case ERROR_TOO_MANY_LUIDS_REQUESTED:
		{
			// 1333 Too many local user identifiers (LUIDs) were requested at one time.  ERROR_TOO_MANY_LUIDS_REQUESTED
			pString = "ERROR_TOO_MANY_LUIDS_REQUESTED";
			break;
		}

		case ERROR_LUIDS_EXHAUSTED:
		{
			// 1334 No more local user identifiers (LUIDs) are available.  ERROR_LUIDS_EXHAUSTED
			pString = "ERROR_LUIDS_EXHAUSTED";
			break;
		}

		case ERROR_INVALID_SUB_AUTHORITY:
		{
			// 1335 The subauthority part of a security ID is invalid for this particular use.  ERROR_INVALID_SUB_AUTHORITY
			pString = "ERROR_INVALID_SUB_AUTHORITY";
			break;
		}

		case ERROR_INVALID_ACL:
		{
			// 1336 The access control list (ACL) structure is invalid.  ERROR_INVALID_ACL
			pString = "ERROR_INVALID_ACL";
			break;
		}

		case ERROR_INVALID_SID:
		{
			// 1337 The security ID structure is invalid.  ERROR_INVALID_SID
			pString = "ERROR_INVALID_SID";
			break;
		}

		case ERROR_INVALID_SECURITY_DESCR:
		{
			// 1338 The security descriptor structure is invalid.  ERROR_INVALID_SECURITY_DESCR
			pString = "ERROR_INVALID_SECURITY_DESCR";
			break;
		}

		case ERROR_BAD_INHERITANCE_ACL:
		{
			// 1340 The inherited access control list (ACL) or access control entry (ACE) could not be built.  ERROR_BAD_INHERITANCE_ACL
			pString = "ERROR_BAD_INHERITANCE_ACL";
			break;
		}

		case ERROR_SERVER_DISABLED:
		{
			// 1341 The server is currently disabled.  ERROR_SERVER_DISABLED
			pString = "ERROR_SERVER_DISABLED";
			break;
		}

		case ERROR_SERVER_NOT_DISABLED:
		{
			// 1342 The server is currently enabled.  ERROR_SERVER_NOT_DISABLED
			pString = "ERROR_SERVER_NOT_DISABLED";
			break;
		}

		case ERROR_INVALID_ID_AUTHORITY:
		{
			// 1343 The value provided was an invalid value for an identifier authority.  ERROR_INVALID_ID_AUTHORITY
			pString = "ERROR_INVALID_ID_AUTHORITY";
			break;
		}

		case ERROR_ALLOTTED_SPACE_EXCEEDED:
		{
			// 1344 No more memory is available for security information updates.  ERROR_ALLOTTED_SPACE_EXCEEDED
			pString = "ERROR_ALLOTTED_SPACE_EXCEEDED";
			break;
		}

		case ERROR_INVALID_GROUP_ATTRIBUTES:
		{
			// 1345 The specified attributes are invalid, or incompatible with the attributes for the group as a whole.  ERROR_INVALID_GROUP_ATTRIBUTES
			pString = "ERROR_INVALID_GROUP_ATTRIBUTES";
			break;
		}

		case ERROR_BAD_IMPERSONATION_LEVEL:
		{
			// 1346 Either a required impersonation level was not provided, or the provided impersonation level is invalid.  ERROR_BAD_IMPERSONATION_LEVEL
			pString = "ERROR_BAD_IMPERSONATION_LEVEL";
			break;
		}

		case ERROR_CANT_OPEN_ANONYMOUS:
		{
			// 1347 Cannot open an anonymous level security token.  ERROR_CANT_OPEN_ANONYMOUS
			pString = "ERROR_CANT_OPEN_ANONYMOUS";
			break;
		}

		case ERROR_BAD_VALIDATION_CLASS:
		{
			// 1348 The validation information class requested was invalid.  ERROR_BAD_VALIDATION_CLASS
			pString = "ERROR_BAD_VALIDATION_CLASS";
			break;
		}

		case ERROR_BAD_TOKEN_TYPE:
		{
			// 1349 The type of the token is inappropriate for its attempted use.  ERROR_BAD_TOKEN_TYPE
			pString = "ERROR_BAD_TOKEN_TYPE";
			break;
		}

		case ERROR_NO_SECURITY_ON_OBJECT:
		{
			// 1350 Unable to perform a security operation on an object that has no associated security.  ERROR_NO_SECURITY_ON_OBJECT
			pString = "ERROR_NO_SECURITY_ON_OBJECT";
			break;
		}

		case ERROR_CANT_ACCESS_DOMAIN_INFO:
		{
			// 1351 Indicates a Windows NT Server could not be contacted or that objects within the domain are protected such that necessary information could not be retrieved.  ERROR_CANT_ACCESS_DOMAIN_INFO
			pString = "ERROR_CANT_ACCESS_DOMAIN_INFO";
			break;
		}

		case ERROR_INVALID_SERVER_STATE:
		{
			// 1352 The security account manager (SAM) or local security authority (LSA) server was in the wrong state to perform the security operation.  ERROR_INVALID_SERVER_STATE
			pString = "ERROR_INVALID_SERVER_STATE";
			break;
		}

		case ERROR_INVALID_DOMAIN_STATE:
		{
			// 1353 The domain was in the wrong state to perform the security operation.  ERROR_INVALID_DOMAIN_STATE
			pString = "ERROR_INVALID_DOMAIN_STATE";
			break;
		}

		case ERROR_INVALID_DOMAIN_ROLE:
		{
			// 1354 This operation is only allowed for the Primary Domain Controller of the domain.  ERROR_INVALID_DOMAIN_ROLE
			pString = "ERROR_INVALID_DOMAIN_ROLE";
			break;
		}

		case ERROR_NO_SUCH_DOMAIN:
		{
			// 1355 The specified domain did not exist.  ERROR_NO_SUCH_DOMAIN
			pString = "ERROR_NO_SUCH_DOMAIN";
			break;
		}

		case ERROR_DOMAIN_EXISTS:
		{
			// 1356 The specified domain already exists.  ERROR_DOMAIN_EXISTS
			pString = "ERROR_DOMAIN_EXISTS";
			break;
		}

		case ERROR_DOMAIN_LIMIT_EXCEEDED:
		{
			// 1357 An attempt was made to exceed the limit on the number of domains per server.  ERROR_DOMAIN_LIMIT_EXCEEDED
			pString = "ERROR_DOMAIN_LIMIT_EXCEEDED";
			break;
		}

		case ERROR_INTERNAL_DB_CORRUPTION:
		{
			// 1358 Unable to complete the requested operation because of either a catastrophic media failure or a data structure corruption on the disk.  ERROR_INTERNAL_DB_CORRUPTION
			pString = "ERROR_INTERNAL_DB_CORRUPTION";
			break;
		}

		case ERROR_INTERNAL_ERROR:
		{
			// 1359 The security account database contains an internal inconsistency.  ERROR_INTERNAL_ERROR
			pString = "ERROR_INTERNAL_ERROR";
			break;
		}

		case ERROR_GENERIC_NOT_MAPPED:
		{
			// 1360 Generic access types were contained in an access mask which should already be mapped to nongeneric types.  ERROR_GENERIC_NOT_MAPPED
			pString = "ERROR_GENERIC_NOT_MAPPED";
			break;
		}

		case ERROR_BAD_DESCRIPTOR_FORMAT:
		{
			// 1361 A security descriptor is not in the right format (absolute or self-relative).  ERROR_BAD_DESCRIPTOR_FORMAT
			pString = "ERROR_BAD_DESCRIPTOR_FORMAT";
			break;
		}

		case ERROR_NOT_LOGON_PROCESS:
		{
			// 1362 The requested action is restricted for use by logon processes only. The calling process has not registered as a logon process.  ERROR_NOT_LOGON_PROCESS
			pString = "ERROR_NOT_LOGON_PROCESS";
			break;
		}

		case ERROR_LOGON_SESSION_EXISTS:
		{
			// 1363 Cannot start a new logon session with an ID that is already in use.  ERROR_LOGON_SESSION_EXISTS
			pString = "ERROR_LOGON_SESSION_EXISTS";
			break;
		}

		case ERROR_NO_SUCH_PACKAGE:
		{
			// 1364 A specified authentication package is unknown.  ERROR_NO_SUCH_PACKAGE
			pString = "ERROR_NO_SUCH_PACKAGE";
			break;
		}

		case ERROR_BAD_LOGON_SESSION_STATE:
		{
			// 1365 The logon session is not in a state that is consistent with the requested operation.  ERROR_BAD_LOGON_SESSION_STATE
			pString = "ERROR_BAD_LOGON_SESSION_STATE";
			break;
		}

		case ERROR_LOGON_SESSION_COLLISION:
		{
			// 1366 The logon session ID is already in use.  ERROR_LOGON_SESSION_COLLISION
			pString = "ERROR_LOGON_SESSION_COLLISION";
			break;
		}

		case ERROR_INVALID_LOGON_TYPE:
		{
			// 1367 A logon request contained an invalid logon type value.  ERROR_INVALID_LOGON_TYPE
			pString = "ERROR_INVALID_LOGON_TYPE";
			break;
		}

		case ERROR_CANNOT_IMPERSONATE:
		{
			// 1368 Unable to impersonate using a named pipe until data has been read from that pipe.  ERROR_CANNOT_IMPERSONATE
			pString = "ERROR_CANNOT_IMPERSONATE";
			break;
		}

		case ERROR_RXACT_INVALID_STATE:
		{
			// 1369 The transaction state of a registry subtree is incompatible with the requested operation.  ERROR_RXACT_INVALID_STATE
			pString = "ERROR_RXACT_INVALID_STATE";
			break;
		}

		case ERROR_RXACT_COMMIT_FAILURE:
		{
			// 1370 An internal security database corruption has been encountered.  ERROR_RXACT_COMMIT_FAILURE
			pString = "ERROR_RXACT_COMMIT_FAILURE";
			break;
		}

		case ERROR_SPECIAL_ACCOUNT:
		{
			// 1371 Cannot perform this operation on built-in accounts.  ERROR_SPECIAL_ACCOUNT
			pString = "ERROR_SPECIAL_ACCOUNT";
			break;
		}

		case ERROR_SPECIAL_GROUP:
		{
			// 1372 Cannot perform this operation on this built-in special group.  ERROR_SPECIAL_GROUP
			pString = "ERROR_SPECIAL_GROUP";
			break;
		}

		case ERROR_SPECIAL_USER:
		{
			// 1373 Cannot perform this operation on this built-in special user.  ERROR_SPECIAL_USER
			pString = "ERROR_SPECIAL_USER";
			break;
		}

		case ERROR_MEMBERS_PRIMARY_GROUP:
		{
			// 1374 The user cannot be removed from a group because the group is currently the user's primary group.  ERROR_MEMBERS_PRIMARY_GROUP
			pString = "ERROR_MEMBERS_PRIMARY_GROUP";
			break;
		}

		case ERROR_TOKEN_ALREADY_IN_USE:
		{
			// 1375 The token is already in use as a primary token.  ERROR_TOKEN_ALREADY_IN_USE
			pString = "ERROR_TOKEN_ALREADY_IN_USE";
			break;
		}

		case ERROR_NO_SUCH_ALIAS:
		{
			// 1376 The specified local group does not exist.  ERROR_NO_SUCH_ALIAS
			pString = "ERROR_NO_SUCH_ALIAS";
			break;
		}

		case ERROR_MEMBER_NOT_IN_ALIAS:
		{
			// 1377 The specified account name is not a member of the local group.  ERROR_MEMBER_NOT_IN_ALIAS
			pString = "ERROR_MEMBER_NOT_IN_ALIAS";
			break;
		}

		case ERROR_MEMBER_IN_ALIAS:
		{
			// 1378 The specified account name is already a member of the local group.  ERROR_MEMBER_IN_ALIAS
			pString = "ERROR_MEMBER_IN_ALIAS";
			break;
		}

		case ERROR_ALIAS_EXISTS:
		{
			// 1379 The specified local group already exists.  ERROR_ALIAS_EXISTS
			pString = "ERROR_ALIAS_EXISTS";
			break;
		}

		case ERROR_LOGON_NOT_GRANTED:
		{
			// 1380 Logon failure: the user has not been granted the requested logon type at this computer.  ERROR_LOGON_NOT_GRANTED
			pString = "ERROR_LOGON_NOT_GRANTED";
			break;
		}

		case ERROR_TOO_MANY_SECRETS:
		{
			// 1381 The maximum number of secrets that may be stored in a single system has been exceeded.  ERROR_TOO_MANY_SECRETS
			pString = "ERROR_TOO_MANY_SECRETS";
			break;
		}

		case ERROR_SECRET_TOO_LONG:
		{
			// 1382 The length of a secret exceeds the maximum length allowed.  ERROR_SECRET_TOO_LONG
			pString = "ERROR_SECRET_TOO_LONG";
			break;
		}

		case ERROR_INTERNAL_DB_ERROR:
		{
			// 1383 The local security authority database contains an internal inconsistency.  ERROR_INTERNAL_DB_ERROR
			pString = "ERROR_INTERNAL_DB_ERROR";
			break;
		}

		case ERROR_TOO_MANY_CONTEXT_IDS:
		{
			// 1384 During a logon attempt, the user's security context accumulated too many security IDs.  ERROR_TOO_MANY_CONTEXT_IDS
			pString = "ERROR_TOO_MANY_CONTEXT_IDS";
			break;
		}

		case ERROR_LOGON_TYPE_NOT_GRANTED:
		{
			// 1385 Logon failure: the user has not been granted the requested logon type at this computer.  ERROR_LOGON_TYPE_NOT_GRANTED
			pString = "ERROR_LOGON_TYPE_NOT_GRANTED";
			break;
		}

		case ERROR_NT_CROSS_ENCRYPTION_REQUIRED:
		{
			// 1386 A cross-encrypted password is necessary to change a user password.  ERROR_NT_CROSS_ENCRYPTION_REQUIRED
			pString = "ERROR_NT_CROSS_ENCRYPTION_REQUIRED";
			break;
		}

		case ERROR_NO_SUCH_MEMBER:
		{
			// 1387 A new member could not be added to a local group because the member does not exist.  ERROR_NO_SUCH_MEMBER
			pString = "ERROR_NO_SUCH_MEMBER";
			break;
		}

		case ERROR_INVALID_MEMBER:
		{
			// 1388 A new member could not be added to a local group because the member has the wrong account type.  ERROR_INVALID_MEMBER
			pString = "ERROR_INVALID_MEMBER";
			break;
		}

		case ERROR_TOO_MANY_SIDS:
		{
			// 1389 Too many security IDs have been specified.  ERROR_TOO_MANY_SIDS
			pString = "ERROR_TOO_MANY_SIDS";
			break;
		}

		case ERROR_LM_CROSS_ENCRYPTION_REQUIRED:
		{
			// 1390 A cross-encrypted password is necessary to change this user password.  ERROR_LM_CROSS_ENCRYPTION_REQUIRED
			pString = "ERROR_LM_CROSS_ENCRYPTION_REQUIRED";
			break;
		}

		case ERROR_NO_INHERITANCE:
		{
			// 1391 Indicates an ACL contains no inheritable components.  ERROR_NO_INHERITANCE
			pString = "ERROR_NO_INHERITANCE";
			break;
		}

		case ERROR_FILE_CORRUPT:
		{
			// 1392 The file or directory is corrupted and unreadable.  ERROR_FILE_CORRUPT
			pString = "ERROR_FILE_CORRUPT";
			break;
		}

		case ERROR_DISK_CORRUPT:
		{
			// 1393 The disk structure is corrupted and unreadable.  ERROR_DISK_CORRUPT
			pString = "ERROR_DISK_CORRUPT";
			break;
		}

		case ERROR_NO_USER_SESSION_KEY:
		{
			// 1394 There is no user session key for the specified logon session.  ERROR_NO_USER_SESSION_KEY
			pString = "ERROR_NO_USER_SESSION_KEY";
			break;
		}

		case ERROR_LICENSE_QUOTA_EXCEEDED:
		{
			// 1395 The service being accessed is licensed for a particular number of connections. No more connections can be made to the service at this time because there are already as many connections as the service can accept.  ERROR_LICENSE_QUOTA_EXCEEDED
			pString = "ERROR_LICENSE_QUOTA_EXCEEDED";
			break;
		}

		case ERROR_INVALID_WINDOW_HANDLE:
		{
			// 1400 Invalid window handle.  ERROR_INVALID_WINDOW_HANDLE
			pString = "ERROR_INVALID_WINDOW_HANDLE";
			break;
		}

		case ERROR_INVALID_MENU_HANDLE:
		{
			// 1401 Invalid menu handle.  ERROR_INVALID_MENU_HANDLE
			pString = "ERROR_INVALID_MENU_HANDLE";
			break;
		}

		case ERROR_INVALID_CURSOR_HANDLE:
		{
			// 1402 Invalid cursor handle.  ERROR_INVALID_CURSOR_HANDLE
			pString = "ERROR_INVALID_CURSOR_HANDLE";
			break;
		}

		case ERROR_INVALID_ACCEL_HANDLE:
		{
			// 1403 Invalid accelerator table handle.  ERROR_INVALID_ACCEL_HANDLE
			pString = "ERROR_INVALID_ACCEL_HANDLE";
			break;
		}

		case ERROR_INVALID_HOOK_HANDLE:
		{
			// 1404 Invalid hook handle.  ERROR_INVALID_HOOK_HANDLE
			pString = "ERROR_INVALID_HOOK_HANDLE";
			break;
		}

		case ERROR_INVALID_DWP_HANDLE:
		{
			// 1405 Invalid handle to a multiple-window position structure.  ERROR_INVALID_DWP_HANDLE
			pString = "ERROR_INVALID_DWP_HANDLE";
			break;
		}

		case ERROR_TLW_WITH_WSCHILD:
		{
			// 1406 Cannot create a top-level child window.  ERROR_TLW_WITH_WSCHILD
			pString = "ERROR_TLW_WITH_WSCHILD";
			break;
		}

		case ERROR_CANNOT_FIND_WND_CLASS:
		{
			// 1407 Cannot find window class.  ERROR_CANNOT_FIND_WND_CLASS
			pString = "ERROR_CANNOT_FIND_WND_CLASS";
			break;
		}

		case ERROR_WINDOW_OF_OTHER_THREAD:
		{
			// 1408 Invalid window; it belongs to other thread.  ERROR_WINDOW_OF_OTHER_THREAD
			pString = "ERROR_WINDOW_OF_OTHER_THREAD";
			break;
		}

		case ERROR_HOTKEY_ALREADY_REGISTERED:
		{
			// 1409 Hot key is already registered.  ERROR_HOTKEY_ALREADY_REGISTERED
			pString = "ERROR_HOTKEY_ALREADY_REGISTERED";
			break;
		}

		case ERROR_CLASS_ALREADY_EXISTS:
		{
			// 1410 Class already exists.  ERROR_CLASS_ALREADY_EXISTS
			pString = "ERROR_CLASS_ALREADY_EXISTS";
			break;
		}

		case ERROR_CLASS_DOES_NOT_EXIST:
		{
			// 1411 Class does not exist.  ERROR_CLASS_DOES_NOT_EXIST
			pString = "ERROR_CLASS_DOES_NOT_EXIST";
			break;
		}

		case ERROR_CLASS_HAS_WINDOWS:
		{
			// 1412 Class still has open windows.  ERROR_CLASS_HAS_WINDOWS
			pString = "ERROR_CLASS_HAS_WINDOWS";
			break;
		}

		case ERROR_INVALID_INDEX:
		{
			// 1413 Invalid index.  ERROR_INVALID_INDEX
			pString = "ERROR_INVALID_INDEX";
			break;
		}

		case ERROR_INVALID_ICON_HANDLE:
		{
			// 1414 Invalid icon handle.  ERROR_INVALID_ICON_HANDLE
			pString = "ERROR_INVALID_ICON_HANDLE";
			break;
		}

		case ERROR_PRIVATE_DIALOG_INDEX:
		{
			// 1415 Using private DIALOG window words.  ERROR_PRIVATE_DIALOG_INDEX
			pString = "ERROR_PRIVATE_DIALOG_INDEX";
			break;
		}

		case ERROR_LISTBOX_ID_NOT_FOUND:
		{
			// 1416 The list box identifier was not found.  ERROR_LISTBOX_ID_NOT_FOUND
			pString = "ERROR_LISTBOX_ID_NOT_FOUND";
			break;
		}

		case ERROR_NO_WILDCARD_CHARACTERS:
		{
			// 1417 No wildcards were found.  ERROR_NO_WILDCARD_CHARACTERS
			pString = "ERROR_NO_WILDCARD_CHARACTERS";
			break;
		}

		case ERROR_CLIPBOARD_NOT_OPEN:
		{
			// 1418 Thread does not have a clipboard open.  ERROR_CLIPBOARD_NOT_OPEN
			pString = "ERROR_CLIPBOARD_NOT_OPEN";
			break;
		}

		case ERROR_HOTKEY_NOT_REGISTERED:
		{
			// 1419 Hot key is not registered.  ERROR_HOTKEY_NOT_REGISTERED
			pString = "ERROR_HOTKEY_NOT_REGISTERED";
			break;
		}

		case ERROR_WINDOW_NOT_DIALOG:
		{
			// 1420 The window is not a valid dialog window.  ERROR_WINDOW_NOT_DIALOG
			pString = "ERROR_WINDOW_NOT_DIALOG";
			break;
		}

		case ERROR_CONTROL_ID_NOT_FOUND:
		{
			// 1421 Control ID not found.  ERROR_CONTROL_ID_NOT_FOUND
			pString = "ERROR_CONTROL_ID_NOT_FOUND";
			break;
		}

		case ERROR_INVALID_COMBOBOX_MESSAGE:
		{
			// 1422 Invalid message for a combo box because it does not have an edit control.  ERROR_INVALID_COMBOBOX_MESSAGE
			pString = "ERROR_INVALID_COMBOBOX_MESSAGE";
			break;
		}

		case ERROR_WINDOW_NOT_COMBOBOX:
		{
			// 1423 The window is not a combo box.  ERROR_WINDOW_NOT_COMBOBOX
			pString = "ERROR_WINDOW_NOT_COMBOBOX";
			break;
		}

		case ERROR_INVALID_EDIT_HEIGHT:
		{
			// 1424 Height must be less than 256.  ERROR_INVALID_EDIT_HEIGHT
			pString = "ERROR_INVALID_EDIT_HEIGHT";
			break;
		}

		case ERROR_DC_NOT_FOUND:
		{
			// 1425 Invalid device context (DC) handle.  ERROR_DC_NOT_FOUND
			pString = "ERROR_DC_NOT_FOUND";
			break;
		}

		case ERROR_INVALID_HOOK_FILTER:
		{
			// 1426 Invalid hook procedure type.  ERROR_INVALID_HOOK_FILTER
			pString = "ERROR_INVALID_HOOK_FILTER";
			break;
		}

		case ERROR_INVALID_FILTER_PROC:
		{
			// 1427 Invalid hook procedure.  ERROR_INVALID_FILTER_PROC
			pString = "ERROR_INVALID_FILTER_PROC";
			break;
		}

		case ERROR_HOOK_NEEDS_HMOD:
		{
			// 1428 Cannot set nonlocal hook without a module handle.  ERROR_HOOK_NEEDS_HMOD
			pString = "ERROR_HOOK_NEEDS_HMOD";
			break;
		}

		case ERROR_GLOBAL_ONLY_HOOK:
		{
			// 1429 This hook procedure can only be set globally.  ERROR_GLOBAL_ONLY_HOOK
			pString = "ERROR_GLOBAL_ONLY_HOOK";
			break;
		}

		case ERROR_JOURNAL_HOOK_SET:
		{
			// 1430 The journal hook procedure is already installed.  ERROR_JOURNAL_HOOK_SET
			pString = "ERROR_JOURNAL_HOOK_SET";
			break;
		}

		case ERROR_HOOK_NOT_INSTALLED:
		{
			// 1431 The hook procedure is not installed.  ERROR_HOOK_NOT_INSTALLED
			pString = "ERROR_HOOK_NOT_INSTALLED";
			break;
		}

		case ERROR_INVALID_LB_MESSAGE:
		{
			// 1432 Invalid message for single-selection list box.  ERROR_INVALID_LB_MESSAGE
			pString = "ERROR_INVALID_LB_MESSAGE";
			break;
		}

		case ERROR_SETCOUNT_ON_BAD_LB:
		{
			// 1433 LB_SETCOUNT sent to non-lazy list box.  ERROR_SETCOUNT_ON_BAD_LB
			pString = "ERROR_SETCOUNT_ON_BAD_LB";
			break;
		}

		case ERROR_LB_WITHOUT_TABSTOPS:
		{
			// 1434 This list box does not support tab stops.  ERROR_LB_WITHOUT_TABSTOPS
			pString = "ERROR_LB_WITHOUT_TABSTOPS";
			break;
		}

		case ERROR_DESTROY_OBJECT_OF_OTHER_THREAD:
		{
			// 1435 Cannot destroy object created by another thread.  ERROR_DESTROY_OBJECT_OF_OTHER_THREAD
			pString = "ERROR_DESTROY_OBJECT_OF_OTHER_THREAD";
			break;
		}

		case ERROR_CHILD_WINDOW_MENU:
		{
			// 1436 Child windows cannot have menus.  ERROR_CHILD_WINDOW_MENU
			pString = "ERROR_CHILD_WINDOW_MENU";
			break;
		}

		case ERROR_NO_SYSTEM_MENU:
		{
			// 1437 The window does not have a system menu.  ERROR_NO_SYSTEM_MENU
			pString = "ERROR_NO_SYSTEM_MENU";
			break;
		}

		case ERROR_INVALID_MSGBOX_STYLE:
		{
			// 1438 Invalid message box style.  ERROR_INVALID_MSGBOX_STYLE
			pString = "ERROR_INVALID_MSGBOX_STYLE";
			break;
		}

		case ERROR_INVALID_SPI_VALUE:
		{
			// 1439 Invalid system-wide (SPI_*) parameter.  ERROR_INVALID_SPI_VALUE
			pString = "ERROR_INVALID_SPI_VALUE";
			break;
		}

		case ERROR_SCREEN_ALREADY_LOCKED:
		{
			// 1440 Screen already locked.  ERROR_SCREEN_ALREADY_LOCKED
			pString = "ERROR_SCREEN_ALREADY_LOCKED";
			break;
		}

		case ERROR_HWNDS_HAVE_DIFF_PARENT:
		{
			// 1441 All handles to windows in a multiple-window position structure must have the same parent.  ERROR_HWNDS_HAVE_DIFF_PARENT
			pString = "ERROR_HWNDS_HAVE_DIFF_PARENT";
			break;
		}

		case ERROR_NOT_CHILD_WINDOW:
		{
			// 1442 The window is not a child window.  ERROR_NOT_CHILD_WINDOW
			pString = "ERROR_NOT_CHILD_WINDOW";
			break;
		}

		case ERROR_INVALID_GW_COMMAND:
		{
			// 1443 Invalid GW_* command.  ERROR_INVALID_GW_COMMAND
			pString = "ERROR_INVALID_GW_COMMAND";
			break;
		}

		case ERROR_INVALID_THREAD_ID:
		{
			// 1444 Invalid thread identifier.  ERROR_INVALID_THREAD_ID
			pString = "ERROR_INVALID_THREAD_ID";
			break;
		}

		case ERROR_NON_MDICHILD_WINDOW:
		{
			// 1445 Cannot process a message from a window that is not a multiple document interface (MDI) window.  ERROR_NON_MDICHILD_WINDOW
			pString = "ERROR_NON_MDICHILD_WINDOW";
			break;
		}

		case ERROR_POPUP_ALREADY_ACTIVE:
		{
			// 1446 Popup menu already active.  ERROR_POPUP_ALREADY_ACTIVE
			pString = "ERROR_POPUP_ALREADY_ACTIVE";
			break;
		}

		case ERROR_NO_SCROLLBARS:
		{
			// 1447 The window does not have scroll bars.  ERROR_NO_SCROLLBARS
			pString = "ERROR_NO_SCROLLBARS";
			break;
		}

		case ERROR_INVALID_SCROLLBAR_RANGE:
		{
			// 1448 Scroll bar range cannot be greater than 0x7FFF.  ERROR_INVALID_SCROLLBAR_RANGE
			pString = "ERROR_INVALID_SCROLLBAR_RANGE";
			break;
		}

		case ERROR_INVALID_SHOWWIN_COMMAND:
		{
			// 1449 Cannot show or remove the window in the way specified.  ERROR_INVALID_SHOWWIN_COMMAND
			pString = "ERROR_INVALID_SHOWWIN_COMMAND";
			break;
		}

		case ERROR_NO_SYSTEM_RESOURCES:
		{
			// 1450 Insufficient system resources exist to complete the requested service.  ERROR_NO_SYSTEM_RESOURCES
			pString = "ERROR_NO_SYSTEM_RESOURCES";
			break;
		}

		case ERROR_NONPAGED_SYSTEM_RESOURCES:
		{
			// 1451 Insufficient system resources exist to complete the requested service.  ERROR_NONPAGED_SYSTEM_RESOURCES
			pString = "ERROR_NONPAGED_SYSTEM_RESOURCES";
			break;
		}

		case ERROR_PAGED_SYSTEM_RESOURCES:
		{
			// 1452 Insufficient system resources exist to complete the requested service.  ERROR_PAGED_SYSTEM_RESOURCES
			pString = "ERROR_PAGED_SYSTEM_RESOURCES";
			break;
		}

		case ERROR_WORKING_SET_QUOTA:
		{
			// 1453 Insufficient quota to complete the requested service.  ERROR_WORKING_SET_QUOTA
			pString = "ERROR_WORKING_SET_QUOTA";
			break;
		}

		case ERROR_PAGEFILE_QUOTA:
		{
			// 1454 Insufficient quota to complete the requested service.  ERROR_PAGEFILE_QUOTA
			pString = "ERROR_PAGEFILE_QUOTA";
			break;
		}

		case ERROR_COMMITMENT_LIMIT:
		{
			// 1455 The paging file is too small for this operation to complete.  ERROR_COMMITMENT_LIMIT
			pString = "ERROR_COMMITMENT_LIMIT";
			break;
		}

		case ERROR_MENU_ITEM_NOT_FOUND:
		{
			// 1456 A menu item was not found.  ERROR_MENU_ITEM_NOT_FOUND
			pString = "ERROR_MENU_ITEM_NOT_FOUND";
			break;
		}

		case ERROR_INVALID_KEYBOARD_HANDLE:
		{
			// 1457 Invalid keyboard layout handle.  ERROR_INVALID_KEYBOARD_HANDLE
			pString = "ERROR_INVALID_KEYBOARD_HANDLE";
			break;
		}

		case ERROR_HOOK_TYPE_NOT_ALLOWED:
		{
			// 1458 Hook type not allowed.  ERROR_HOOK_TYPE_NOT_ALLOWED
			pString = "ERROR_HOOK_TYPE_NOT_ALLOWED";
			break;
		}

		case ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION:
		{
			// 1459 This operation requires an interactive window station.  ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION
			pString = "ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION";
			break;
		}

		case ERROR_TIMEOUT:
		{
			// 1460 This operation returned because the timeout period expired.  ERROR_TIMEOUT
			pString = "ERROR_TIMEOUT";
			break;
		}

		case ERROR_INVALID_MONITOR_HANDLE:
		{
			// 1461 Invalid monitor handle.  ERROR_INVALID_MONITOR_HANDLE
			pString = "ERROR_INVALID_MONITOR_HANDLE";
			break;
		}

		case ERROR_EVENTLOG_FILE_CORRUPT:
		{
			// 1500 The event log file is corrupted.  ERROR_EVENTLOG_FILE_CORRUPT
			pString = "ERROR_EVENTLOG_FILE_CORRUPT";
			break;
		}

		case ERROR_EVENTLOG_CANT_START:
		{
			// 1501 No event log file could be opened, so the event logging service did not start.  ERROR_EVENTLOG_CANT_START
			pString = "ERROR_EVENTLOG_CANT_START";
			break;
		}

		case ERROR_LOG_FILE_FULL:
		{
			// 1502 The event log file is full.  ERROR_LOG_FILE_FULL
			pString = "ERROR_LOG_FILE_FULL";
			break;
		}

		case ERROR_EVENTLOG_FILE_CHANGED:
		{
			// 1503 The event log file has changed between read operations.  ERROR_EVENTLOG_FILE_CHANGED
			pString = "ERROR_EVENTLOG_FILE_CHANGED";
			break;
		}

		/*
		//
		// Headers from NT build environment do not know about this error code
		//
		case ERROR_INSTALL_SERVICE:
		{
			// 1601 Failure accessing install service.  ERROR_INSTALL_SERVICE
			pString = "ERROR_INSTALL_SERVICE";
			break;
		}
		*/

		case ERROR_INSTALL_USEREXIT:
		{
			// 1602 The user canceled the installation.  ERROR_INSTALL_USEREXIT
			pString = "ERROR_INSTALL_USEREXIT";
			break;
		}

		case ERROR_INSTALL_FAILURE:
		{
			// 1603 Fatal error during installation.  ERROR_INSTALL_FAILURE
			pString = "ERROR_INSTALL_FAILURE";
			break;
		}

		case ERROR_INSTALL_SUSPEND:
		{
			// 1604 Installation suspended, incomplete.  ERROR_INSTALL_SUSPEND
			pString = "ERROR_INSTALL_SUSPEND";
			break;
		}

		case ERROR_UNKNOWN_PRODUCT:
		{
			// 1605 Product code not registered.  ERROR_UNKNOWN_PRODUCT
			pString = "ERROR_UNKNOWN_PRODUCT";
			break;
		}

		case ERROR_UNKNOWN_FEATURE:
		{
			// 1606 Feature ID not registered.  ERROR_UNKNOWN_FEATURE
			pString = "ERROR_UNKNOWN_FEATURE";
			break;
		}

		case ERROR_UNKNOWN_COMPONENT:
		{
			// 1607 Component ID not registered.  ERROR_UNKNOWN_COMPONENT
			pString = "ERROR_UNKNOWN_COMPONENT";
			break;
		}

		case ERROR_UNKNOWN_PROPERTY:
		{
			// 1608 Unknown property.  ERROR_UNKNOWN_PROPERTY
			pString = "ERROR_UNKNOWN_PROPERTY";
			break;
		}

		case ERROR_INVALID_HANDLE_STATE:
		{
			// 1609 Handle is in an invalid state.  ERROR_INVALID_HANDLE_STATE
			pString = "ERROR_INVALID_HANDLE_STATE";
			break;
		}

		case ERROR_BAD_CONFIGURATION:
		{
			// 1610 Configuration data corrupt.  ERROR_BAD_CONFIGURATION
			pString = "ERROR_BAD_CONFIGURATION";
			break;
		}

		case ERROR_INDEX_ABSENT:
		{
			// 1611 Language not available.  ERROR_INDEX_ABSENT
			pString = "ERROR_INDEX_ABSENT";
			break;
		}

		case ERROR_INSTALL_SOURCE_ABSENT:
		{
			// 1612 Install source unavailable.  ERROR_INSTALL_SOURCE_ABSENT
			pString = "ERROR_INSTALL_SOURCE_ABSENT";
			break;
		}

		/*
		//
		// Headers from NT build environment do not know about this error code
		//
		case ERROR_BAD_DATABASE_VERSION:
		{
			// 1613 Database version unsupported.  ERROR_BAD_DATABASE_VERSION
			pString = "ERROR_BAD_DATABASE_VERSION";
			break;
		}
		*/

		case ERROR_PRODUCT_UNINSTALLED:
		{
			// 1614 Product is uninstalled.  ERROR_PRODUCT_UNINSTALLED
			pString = "ERROR_PRODUCT_UNINSTALLED";
			break;
		}

		case ERROR_BAD_QUERY_SYNTAX:
		{
			// 1615 SQL query syntax invalid or unsupported.  ERROR_BAD_QUERY_SYNTAX
			pString = "ERROR_BAD_QUERY_SYNTAX";
			break;
		}

		case ERROR_INVALID_FIELD:
		{
			// 1616 Record field does not exist.  ERROR_INVALID_FIELD
			pString = "ERROR_INVALID_FIELD";
			break;
		}

		case RPC_S_INVALID_STRING_BINDING:
		{
			// 1700 The string binding is invalid.  RPC_S_INVALID_STRING_BINDING
			pString = "RPC_S_INVALID_STRING_BINDING";
			break;
		}

		case RPC_S_WRONG_KIND_OF_BINDING:
		{
			// 1701 The binding handle is not the correct type.  RPC_S_WRONG_KIND_OF_BINDING
			pString = "RPC_S_WRONG_KIND_OF_BINDING";
			break;
		}

		case RPC_S_INVALID_BINDING:
		{
			// 1702 The binding handle is invalid.  RPC_S_INVALID_BINDING
			pString = "RPC_S_INVALID_BINDING";
			break;
		}

		case RPC_S_PROTSEQ_NOT_SUPPORTED:
		{
			// 1703 The RPC protocol sequence is not supported.  RPC_S_PROTSEQ_NOT_SUPPORTED
			pString = "RPC_S_PROTSEQ_NOT_SUPPORTED";
			break;
		}

		case RPC_S_INVALID_RPC_PROTSEQ:
		{
			// 1704 The RPC protocol sequence is invalid.  RPC_S_INVALID_RPC_PROTSEQ
			pString = "RPC_S_INVALID_RPC_PROTSEQ";
			break;
		}

		case RPC_S_INVALID_STRING_UUID:
		{
			// 1705 The string universal unique identifier (UUID) is invalid.  RPC_S_INVALID_STRING_UUID
			pString = "RPC_S_INVALID_STRING_UUID";
			break;
		}

		case RPC_S_INVALID_ENDPOINT_FORMAT:
		{
			// 1706 The endpoint format is invalid.  RPC_S_INVALID_ENDPOINT_FORMAT
			pString = "RPC_S_INVALID_ENDPOINT_FORMAT";
			break;
		}

		case RPC_S_INVALID_NET_ADDR:
		{
			// 1707 The network address is invalid.  RPC_S_INVALID_NET_ADDR
			pString = "RPC_S_INVALID_NET_ADDR";
			break;
		}

		case RPC_S_NO_ENDPOINT_FOUND:
		{
			// 1708 No endpoint was found.  RPC_S_NO_ENDPOINT_FOUND
			pString = "RPC_S_NO_ENDPOINT_FOUND";
			break;
		}

		case RPC_S_INVALID_TIMEOUT:
		{
			// 1709 The timeout value is invalid.  RPC_S_INVALID_TIMEOUT
			pString = "RPC_S_INVALID_TIMEOUT";
			break;
		}

		case RPC_S_OBJECT_NOT_FOUND:
		{
			// 1710 The object universal unique identifier (UUID) was not found.  RPC_S_OBJECT_NOT_FOUND
			pString = "RPC_S_OBJECT_NOT_FOUND";
			break;
		}

		case RPC_S_ALREADY_REGISTERED:
		{
			// 1711 The object universal unique identifier (UUID) has already been registered.  RPC_S_ALREADY_REGISTERED
			pString = "RPC_S_ALREADY_REGISTERED";
			break;
		}

		case RPC_S_TYPE_ALREADY_REGISTERED:
		{
			// 1712 The type universal unique identifier (UUID) has already been registered.  RPC_S_TYPE_ALREADY_REGISTERED
			pString = "RPC_S_TYPE_ALREADY_REGISTERED";
			break;
		}

		case RPC_S_ALREADY_LISTENING:
		{
			// 1713 The RPC server is already listening.  RPC_S_ALREADY_LISTENING
			pString = "RPC_S_ALREADY_LISTENING";
			break;
		}

		case RPC_S_NO_PROTSEQS_REGISTERED:
		{
			// 1714 No protocol sequences have been registered.  RPC_S_NO_PROTSEQS_REGISTERED
			pString = "RPC_S_NO_PROTSEQS_REGISTERED";
			break;
		}

		case RPC_S_NOT_LISTENING:
		{
			// 1715 The RPC server is not listening.  RPC_S_NOT_LISTENING
			pString = "RPC_S_NOT_LISTENING";
			break;
		}

		case RPC_S_UNKNOWN_MGR_TYPE:
		{
			// 1716 The manager type is unknown.  RPC_S_UNKNOWN_MGR_TYPE
			pString = "RPC_S_UNKNOWN_MGR_TYPE";
			break;
		}

		case RPC_S_UNKNOWN_IF:
		{
			// 1717 The interface is unknown.  RPC_S_UNKNOWN_IF
			pString = "RPC_S_UNKNOWN_IF";
			break;
		}

		case RPC_S_NO_BINDINGS:
		{
			// 1718 There are no bindings.  RPC_S_NO_BINDINGS
			pString = "RPC_S_NO_BINDINGS";
			break;
		}

		case RPC_S_NO_PROTSEQS:
		{
			// 1719 There are no protocol sequences.  RPC_S_NO_PROTSEQS
			pString = "RPC_S_NO_PROTSEQS";
			break;
		}

		case RPC_S_CANT_CREATE_ENDPOINT:
		{
			// 1720 The endpoint cannot be created.  RPC_S_CANT_CREATE_ENDPOINT
			pString = "RPC_S_CANT_CREATE_ENDPOINT";
			break;
		}

		case RPC_S_OUT_OF_RESOURCES:
		{
			// 1721 Not enough resources are available to complete this operation.  RPC_S_OUT_OF_RESOURCES
			pString = "RPC_S_OUT_OF_RESOURCES";
			break;
		}

		case RPC_S_SERVER_UNAVAILABLE:
		{
			// 1722 The RPC server is unavailable.  RPC_S_SERVER_UNAVAILABLE
			pString = "RPC_S_SERVER_UNAVAILABLE";
			break;
		}

		case RPC_S_SERVER_TOO_BUSY:
		{
			// 1723 The RPC server is too busy to complete this operation.  RPC_S_SERVER_TOO_BUSY
			pString = "RPC_S_SERVER_TOO_BUSY";
			break;
		}

		case RPC_S_INVALID_NETWORK_OPTIONS:
		{
			// 1724 The network options are invalid.  RPC_S_INVALID_NETWORK_OPTIONS
			pString = "RPC_S_INVALID_NETWORK_OPTIONS";
			break;
		}

		case RPC_S_NO_CALL_ACTIVE:
		{
			// 1725 There are no remote procedure calls active on this thread.  RPC_S_NO_CALL_ACTIVE
			pString = "RPC_S_NO_CALL_ACTIVE";
			break;
		}

		case RPC_S_CALL_FAILED:
		{
			// 1726 The remote procedure call failed.  RPC_S_CALL_FAILED
			pString = "RPC_S_CALL_FAILED";
			break;
		}

		case RPC_S_CALL_FAILED_DNE:
		{
			// 1727 The remote procedure call failed and did not execute.  RPC_S_CALL_FAILED_DNE
			pString = "RPC_S_CALL_FAILED_DNE";
			break;
		}

		case RPC_S_PROTOCOL_ERROR:
		{
			// 1728 A remote procedure call (RPC) protocol error occurred.  RPC_S_PROTOCOL_ERROR
			pString = "RPC_S_PROTOCOL_ERROR";
			break;
		}

		case RPC_S_UNSUPPORTED_TRANS_SYN:
		{
			// 1730 The transfer syntax is not supported by the RPC server.  RPC_S_UNSUPPORTED_TRANS_SYN
			pString = "RPC_S_UNSUPPORTED_TRANS_SYN";
			break;
		}

		case RPC_S_UNSUPPORTED_TYPE:
		{
			// 1732 The universal unique identifier (UUID) type is not supported.  RPC_S_UNSUPPORTED_TYPE
			pString = "RPC_S_UNSUPPORTED_TYPE";
			break;
		}

		case RPC_S_INVALID_TAG:
		{
			// 1733 The tag is invalid.  RPC_S_INVALID_TAG
			pString = "RPC_S_INVALID_TAG";
			break;
		}

		case RPC_S_INVALID_BOUND:
		{
			// 1734 The array bounds are invalid.  RPC_S_INVALID_BOUND
			pString = "RPC_S_INVALID_BOUND";
			break;
		}

		case RPC_S_NO_ENTRY_NAME:
		{
			// 1735 The binding does not contain an entry name.  RPC_S_NO_ENTRY_NAME
			pString = "RPC_S_NO_ENTRY_NAME";
			break;
		}

		case RPC_S_INVALID_NAME_SYNTAX:
		{
			// 1736 The name syntax is invalid.  RPC_S_INVALID_NAME_SYNTAX
			pString = "RPC_S_INVALID_NAME_SYNTAX";
			break;
		}

		case RPC_S_UNSUPPORTED_NAME_SYNTAX:
		{
			// 1737 The name syntax is not supported.  RPC_S_UNSUPPORTED_NAME_SYNTAX
			pString = "RPC_S_UNSUPPORTED_NAME_SYNTAX";
			break;
		}

		case RPC_S_UUID_NO_ADDRESS:
		{
			// 1739 No network address is available to use to construct a universal unique identifier (UUID).  RPC_S_UUID_NO_ADDRESS
			pString = "RPC_S_UUID_NO_ADDRESS";
			break;
		}

		case RPC_S_DUPLICATE_ENDPOINT:
		{
			// 1740 The endpoint is a duplicate.  RPC_S_DUPLICATE_ENDPOINT
			pString = "RPC_S_DUPLICATE_ENDPOINT";
			break;
		}

		case RPC_S_UNKNOWN_AUTHN_TYPE:
		{
			// 1741 The authentication type is unknown.  RPC_S_UNKNOWN_AUTHN_TYPE
			pString = "RPC_S_UNKNOWN_AUTHN_TYPE";
			break;
		}

		case RPC_S_MAX_CALLS_TOO_SMALL:
		{
			// 1742 The maximum number of calls is too small.  RPC_S_MAX_CALLS_TOO_SMALL
			pString = "RPC_S_MAX_CALLS_TOO_SMALL";
			break;
		}

		case RPC_S_STRING_TOO_LONG:
		{
			// 1743 The string is too long.  RPC_S_STRING_TOO_LONG
			pString = "RPC_S_STRING_TOO_LONG";
			break;
		}

		case RPC_S_PROTSEQ_NOT_FOUND:
		{
			// 1744 The RPC protocol sequence was not found.  RPC_S_PROTSEQ_NOT_FOUND
			pString = "RPC_S_PROTSEQ_NOT_FOUND";
			break;
		}

		case RPC_S_PROCNUM_OUT_OF_RANGE:
		{
			// 1745 The procedure number is out of range.  RPC_S_PROCNUM_OUT_OF_RANGE
			pString = "RPC_S_PROCNUM_OUT_OF_RANGE";
			break;
		}

		case RPC_S_BINDING_HAS_NO_AUTH:
		{
			// 1746 The binding does not contain any authentication information.  RPC_S_BINDING_HAS_NO_AUTH
			pString = "RPC_S_BINDING_HAS_NO_AUTH";
			break;
		}

		case RPC_S_UNKNOWN_AUTHN_SERVICE:
		{
			// 1747 The authentication service is unknown.  RPC_S_UNKNOWN_AUTHN_SERVICE
			pString = "RPC_S_UNKNOWN_AUTHN_SERVICE";
			break;
		}

		case RPC_S_UNKNOWN_AUTHN_LEVEL:
		{
			// 1748 The authentication level is unknown.  RPC_S_UNKNOWN_AUTHN_LEVEL
			pString = "RPC_S_UNKNOWN_AUTHN_LEVEL";
			break;
		}

		case RPC_S_INVALID_AUTH_IDENTITY:
		{
			// 1749 The security context is invalid.  RPC_S_INVALID_AUTH_IDENTITY
			pString = "RPC_S_INVALID_AUTH_IDENTITY";
			break;
		}

		case RPC_S_UNKNOWN_AUTHZ_SERVICE:
		{
			// 1750 The authorization service is unknown.  RPC_S_UNKNOWN_AUTHZ_SERVICE
			pString = "RPC_S_UNKNOWN_AUTHZ_SERVICE";
			break;
		}

		case EPT_S_INVALID_ENTRY:
		{
			// 1751 The entry is invalid.  EPT_S_INVALID_ENTRY
			pString = "EPT_S_INVALID_ENTRY";
			break;
		}

		case EPT_S_CANT_PERFORM_OP:
		{
			// 1752 The server endpoint cannot perform the operation.  EPT_S_CANT_PERFORM_OP
			pString = "EPT_S_CANT_PERFORM_OP";
			break;
		}

		case EPT_S_NOT_REGISTERED:
		{
			// 1753 There are no more endpoints available from the endpoint mapper.  EPT_S_NOT_REGISTERED
			pString = "EPT_S_NOT_REGISTERED";
			break;
		}

		case RPC_S_NOTHING_TO_EXPORT:
		{
			// 1754 No interfaces have been exported.  RPC_S_NOTHING_TO_EXPORT
			pString = "RPC_S_NOTHING_TO_EXPORT";
			break;
		}

		case RPC_S_INCOMPLETE_NAME:
		{
			// 1755 The entry name is incomplete.  RPC_S_INCOMPLETE_NAME
			pString = "RPC_S_INCOMPLETE_NAME";
			break;
		}

		case RPC_S_INVALID_VERS_OPTION:
		{
			// 1756 The version option is invalid.  RPC_S_INVALID_VERS_OPTION
			pString = "RPC_S_INVALID_VERS_OPTION";
			break;
		}

		case RPC_S_NO_MORE_MEMBERS:
		{
			// 1757 There are no more members.  RPC_S_NO_MORE_MEMBERS
			pString = "RPC_S_NO_MORE_MEMBERS";
			break;
		}

		case RPC_S_NOT_ALL_OBJS_UNEXPORTED:
		{
			// 1758 There is nothing to unexport.  RPC_S_NOT_ALL_OBJS_UNEXPORTED
			pString = "RPC_S_NOT_ALL_OBJS_UNEXPORTED";
			break;
		}

		case RPC_S_INTERFACE_NOT_FOUND:
		{
			// 1759 The interface was not found.  RPC_S_INTERFACE_NOT_FOUND
			pString = "RPC_S_INTERFACE_NOT_FOUND";
			break;
		}

		case RPC_S_ENTRY_ALREADY_EXISTS:
		{
			// 1760 The entry already exists.  RPC_S_ENTRY_ALREADY_EXISTS
			pString = "RPC_S_ENTRY_ALREADY_EXISTS";
			break;
		}

		case RPC_S_ENTRY_NOT_FOUND:
		{
			// 1761 The entry is not found.  RPC_S_ENTRY_NOT_FOUND
			pString = "RPC_S_ENTRY_NOT_FOUND";
			break;
		}

		case RPC_S_NAME_SERVICE_UNAVAILABLE:
		{
			// 1762 The name service is unavailable.  RPC_S_NAME_SERVICE_UNAVAILABLE
			pString = "RPC_S_NAME_SERVICE_UNAVAILABLE";
			break;
		}

		case RPC_S_INVALID_NAF_ID:
		{
			// 1763 The network address family is invalid.  RPC_S_INVALID_NAF_ID
			pString = "RPC_S_INVALID_NAF_ID";
			break;
		}

		case RPC_S_CANNOT_SUPPORT:
		{
			// 1764 The requested operation is not supported.  RPC_S_CANNOT_SUPPORT
			pString = "RPC_S_CANNOT_SUPPORT";
			break;
		}

		case RPC_S_NO_CONTEXT_AVAILABLE:
		{
			// 1765 No security context is available to allow impersonation.  RPC_S_NO_CONTEXT_AVAILABLE
			pString = "RPC_S_NO_CONTEXT_AVAILABLE";
			break;
		}

		case RPC_S_INTERNAL_ERROR:
		{
			// 1766 An internal error occurred in a remote procedure call (RPC).  RPC_S_INTERNAL_ERROR
			pString = "RPC_S_INTERNAL_ERROR";
			break;
		}

		case RPC_S_ZERO_DIVIDE:
		{
			// 1767 The RPC server attempted an integer division by zero.  RPC_S_ZERO_DIVIDE
			pString = "RPC_S_ZERO_DIVIDE";
			break;
		}

		case RPC_S_ADDRESS_ERROR:
		{
			// 1768 An addressing error occurred in the RPC server.  RPC_S_ADDRESS_ERROR
			pString = "RPC_S_ADDRESS_ERROR";
			break;
		}

		case RPC_S_FP_DIV_ZERO:
		{
			// 1769 A floating-point operation at the RPC server caused a division by zero.  RPC_S_FP_DIV_ZERO
			pString = "RPC_S_FP_DIV_ZERO";
			break;
		}

		case RPC_S_FP_UNDERFLOW:
		{
			// 1770 A floating-point underflow occurred at the RPC server.  RPC_S_FP_UNDERFLOW
			pString = "RPC_S_FP_UNDERFLOW";
			break;
		}

		case RPC_S_FP_OVERFLOW:
		{
			// 1771 A floating-point overflow occurred at the RPC server.  RPC_S_FP_OVERFLOW
			pString = "RPC_S_FP_OVERFLOW";
			break;
		}

		case RPC_X_NO_MORE_ENTRIES:
		{
			// 1772 The list of RPC servers available for the binding of auto handles has been exhausted.  RPC_X_NO_MORE_ENTRIES
			pString = "RPC_X_NO_MORE_ENTRIES";
			break;
		}

		case RPC_X_SS_CHAR_TRANS_OPEN_FAIL:
		{
			// 1773 Unable to open the character translation table file.  RPC_X_SS_CHAR_TRANS_OPEN_FAIL
			pString = "RPC_X_SS_CHAR_TRANS_OPEN_FAIL";
			break;
		}

		case RPC_X_SS_CHAR_TRANS_SHORT_FILE:
		{
			// 1774 The file containing the character translation table has fewer than bytes.  RPC_X_SS_CHAR_TRANS_SHORT_FILE
			pString = "RPC_X_SS_CHAR_TRANS_SHORT_FILE";
			break;
		}

		case RPC_X_SS_IN_NULL_CONTEXT:
		{
			// 1775 A null context handle was passed from the client to the host during a remote procedure call.  RPC_X_SS_IN_NULL_CONTEXT
			pString = "RPC_X_SS_IN_NULL_CONTEXT";
			break;
		}

		case RPC_X_SS_CONTEXT_DAMAGED:
		{
			// 1777 The context handle changed during a remote procedure call.  RPC_X_SS_CONTEXT_DAMAGED
			pString = "RPC_X_SS_CONTEXT_DAMAGED";
			break;
		}

		case RPC_X_SS_HANDLES_MISMATCH:
		{
			// 1778 The binding handles passed to a remote procedure call do not match.  RPC_X_SS_HANDLES_MISMATCH
			pString = "RPC_X_SS_HANDLES_MISMATCH";
			break;
		}

		case RPC_X_SS_CANNOT_GET_CALL_HANDLE:
		{
			// 1779 The stub is unable to get the remote procedure call handle.  RPC_X_SS_CANNOT_GET_CALL_HANDLE
			pString = "RPC_X_SS_CANNOT_GET_CALL_HANDLE";
			break;
		}

		case RPC_X_NULL_REF_POINTER:
		{
			// 1780 A null reference pointer was passed to the stub.  RPC_X_NULL_REF_POINTER
			pString = "RPC_X_NULL_REF_POINTER";
			break;
		}

		case RPC_X_ENUM_VALUE_OUT_OF_RANGE:
		{
			// 1781 The enumeration value is out of range.  RPC_X_ENUM_VALUE_OUT_OF_RANGE
			pString = "RPC_X_ENUM_VALUE_OUT_OF_RANGE";
			break;
		}

		case RPC_X_BYTE_COUNT_TOO_SMALL:
		{
			// 1782 The byte count is too small.  RPC_X_BYTE_COUNT_TOO_SMALL
			pString = "RPC_X_BYTE_COUNT_TOO_SMALL";
			break;
		}

		case RPC_X_BAD_STUB_DATA:
		{
			// 1783 The stub received bad data.  RPC_X_BAD_STUB_DATA
			pString = "RPC_X_BAD_STUB_DATA";
			break;
		}

		case ERROR_INVALID_USER_BUFFER:
		{
			// 1784 The supplied user buffer is not valid for the requested operation.  ERROR_INVALID_USER_BUFFER
			pString = "ERROR_INVALID_USER_BUFFER";
			break;
		}

		case ERROR_UNRECOGNIZED_MEDIA:
		{
			// 1785 The disk media is not recognized. It may not be formatted.  ERROR_UNRECOGNIZED_MEDIA
			pString = "ERROR_UNRECOGNIZED_MEDIA";
			break;
		}

		case ERROR_NO_TRUST_LSA_SECRET:
		{
			// 1786 The workstation does not have a trust secret.  ERROR_NO_TRUST_LSA_SECRET
			pString = "ERROR_NO_TRUST_LSA_SECRET";
			break;
		}

		case ERROR_NO_TRUST_SAM_ACCOUNT:
		{
			// 1787 The SAM database on the Windows NT Server does not have a computer account for this workstation trust relationship.  ERROR_NO_TRUST_SAM_ACCOUNT
			pString = "ERROR_NO_TRUST_SAM_ACCOUNT";
			break;
		}

		case ERROR_TRUSTED_DOMAIN_FAILURE:
		{
			// 1788 The trust relationship between the primary domain and the trusted domain failed.  ERROR_TRUSTED_DOMAIN_FAILURE
			pString = "ERROR_TRUSTED_DOMAIN_FAILURE";
			break;
		}

		case ERROR_TRUSTED_RELATIONSHIP_FAILURE:
		{
			// 1789 The trust relationship between this workstation and the primary domain failed.  ERROR_TRUSTED_RELATIONSHIP_FAILURE
			pString = "ERROR_TRUSTED_RELATIONSHIP_FAILURE";
			break;
		}

		case ERROR_TRUST_FAILURE:
		{
			// 1790 The network logon failed.  ERROR_TRUST_FAILURE
			pString = "ERROR_TRUST_FAILURE";
			break;
		}

		case RPC_S_CALL_IN_PROGRESS:
		{
			// 1791 A remote procedure call is already in progress for this thread.  RPC_S_CALL_IN_PROGRESS
			pString = "RPC_S_CALL_IN_PROGRESS";
			break;
		}

		case ERROR_NETLOGON_NOT_STARTED:
		{
			// 1792 An attempt was made to logon, but the network logon service was not started.  ERROR_NETLOGON_NOT_STARTED
			pString = "ERROR_NETLOGON_NOT_STARTED";
			break;
		}

		case ERROR_ACCOUNT_EXPIRED:
		{
			// 1793 The user's account has expired.  ERROR_ACCOUNT_EXPIRED
			pString = "ERROR_ACCOUNT_EXPIRED";
			break;
		}

		case ERROR_REDIRECTOR_HAS_OPEN_HANDLES:
		{
			// 1794 The redirector is in use and cannot be unloaded.  ERROR_REDIRECTOR_HAS_OPEN_HANDLES
			pString = "ERROR_REDIRECTOR_HAS_OPEN_HANDLES";
			break;
		}

		case ERROR_PRINTER_DRIVER_ALREADY_INSTALLED:
		{
			// 1795 The specified printer driver is already installed.  ERROR_PRINTER_DRIVER_ALREADY_INSTALLED
			pString = "ERROR_PRINTER_DRIVER_ALREADY_INSTALLED";
			break;
		}

		case ERROR_UNKNOWN_PORT:
		{
			// 1796 The specified port is unknown.  ERROR_UNKNOWN_PORT
			pString = "ERROR_UNKNOWN_PORT";
			break;
		}

		case ERROR_UNKNOWN_PRINTER_DRIVER:
		{
			// 1797 The printer driver is unknown.  ERROR_UNKNOWN_PRINTER_DRIVER
			pString = "ERROR_UNKNOWN_PRINTER_DRIVER";
			break;
		}

		case ERROR_UNKNOWN_PRINTPROCESSOR:
		{
			// 1798 The print processor is unknown.  ERROR_UNKNOWN_PRINTPROCESSOR
			pString = "ERROR_UNKNOWN_PRINTPROCESSOR";
			break;
		}

		case ERROR_INVALID_SEPARATOR_FILE:
		{
			// 1799 The specified separator file is invalid.  ERROR_INVALID_SEPARATOR_FILE
			pString = "ERROR_INVALID_SEPARATOR_FILE";
			break;
		}

		case ERROR_INVALID_PRIORITY:
		{
			// 1800 The specified priority is invalid.  ERROR_INVALID_PRIORITY
			pString = "ERROR_INVALID_PRIORITY";
			break;
		}

		case ERROR_INVALID_PRINTER_NAME:
		{
			// 1801 The printer name is invalid.  ERROR_INVALID_PRINTER_NAME
			pString = "ERROR_INVALID_PRINTER_NAME";
			break;
		}

		case ERROR_PRINTER_ALREADY_EXISTS:
		{
			// 1802 The printer already exists.  ERROR_PRINTER_ALREADY_EXISTS
			pString = "ERROR_PRINTER_ALREADY_EXISTS";
			break;
		}

		case ERROR_INVALID_PRINTER_COMMAND:
		{
			// 1803 The printer command is invalid.  ERROR_INVALID_PRINTER_COMMAND
			pString = "ERROR_INVALID_PRINTER_COMMAND";
			break;
		}

		case ERROR_INVALID_DATATYPE:
		{
			// 1804 The specified datatype is invalid.  ERROR_INVALID_DATATYPE
			pString = "ERROR_INVALID_DATATYPE";
			break;
		}

		case ERROR_INVALID_ENVIRONMENT:
		{
			// 1805 The environment specified is invalid.  ERROR_INVALID_ENVIRONMENT
			pString = "ERROR_INVALID_ENVIRONMENT";
			break;
		}

		case RPC_S_NO_MORE_BINDINGS:
		{
			// 1806 There are no more bindings.  RPC_S_NO_MORE_BINDINGS
			pString = "RPC_S_NO_MORE_BINDINGS";
			break;
		}

		case ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT:
		{
			// 1807 The account used is an interdomain trust account. Use your global user account or local user account to access this server.  ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT
			pString = "ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT";
			break;
		}

		case ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT:
		{
			// 1808 The account used is a computer account. Use your global user account or local user account to access this server.  ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT
			pString = "ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT";
			break;
		}

		case ERROR_NOLOGON_SERVER_TRUST_ACCOUNT:
		{
			// 1809 The account used is a server trust account. Use your global user account or local user account to access this server.  ERROR_NOLOGON_SERVER_TRUST_ACCOUNT
			pString = "ERROR_NOLOGON_SERVER_TRUST_ACCOUNT";
			break;
		}

		case ERROR_DOMAIN_TRUST_INCONSISTENT:
		{
			// 1810 The name or security ID (SID) of the domain specified is inconsistent with the trust information for that domain.  ERROR_DOMAIN_TRUST_INCONSISTENT
			pString = "ERROR_DOMAIN_TRUST_INCONSISTENT";
			break;
		}

		case ERROR_SERVER_HAS_OPEN_HANDLES:
		{
			// 1811 The server is in use and cannot be unloaded.  ERROR_SERVER_HAS_OPEN_HANDLES
			pString = "ERROR_SERVER_HAS_OPEN_HANDLES";
			break;
		}

		case ERROR_RESOURCE_DATA_NOT_FOUND:
		{
			// 1812 The specified image file did not contain a resource section.  ERROR_RESOURCE_DATA_NOT_FOUND
			pString = "ERROR_RESOURCE_DATA_NOT_FOUND";
			break;
		}

		case ERROR_RESOURCE_TYPE_NOT_FOUND:
		{
			// 1813 The specified resource type cannot be found in the image file.  ERROR_RESOURCE_TYPE_NOT_FOUND
			pString = "ERROR_RESOURCE_TYPE_NOT_FOUND";
			break;
		}

		case ERROR_RESOURCE_NAME_NOT_FOUND:
		{
			// 1814 The specified resource name cannot be found in the image file.  ERROR_RESOURCE_NAME_NOT_FOUND
			pString = "ERROR_RESOURCE_NAME_NOT_FOUND";
			break;
		}

		case ERROR_RESOURCE_LANG_NOT_FOUND:
		{
			// 1815 The specified resource language ID cannot be found in the image file.  ERROR_RESOURCE_LANG_NOT_FOUND
			pString = "ERROR_RESOURCE_LANG_NOT_FOUND";
			break;
		}

		case ERROR_NOT_ENOUGH_QUOTA:
		{
			// 1816 Not enough quota is available to process this command.  ERROR_NOT_ENOUGH_QUOTA
			pString = "ERROR_NOT_ENOUGH_QUOTA";
			break;
		}

		case RPC_S_NO_INTERFACES:
		{
			// 1817 No interfaces have been registered.  RPC_S_NO_INTERFACES
			pString = "RPC_S_NO_INTERFACES";
			break;
		}

		case RPC_S_CALL_CANCELLED:
		{
			// 1818 The remote procedure call was cancelled.  RPC_S_CALL_CANCELLED
			pString = "RPC_S_CALL_CANCELLED";
			break;
		}

		case RPC_S_BINDING_INCOMPLETE:
		{
			// 1819 The binding handle does not contain all required information.  RPC_S_BINDING_INCOMPLETE
			pString = "RPC_S_BINDING_INCOMPLETE";
			break;
		}

		case RPC_S_COMM_FAILURE:
		{
			// 1820 A communications failure occurred during a remote procedure call.  RPC_S_COMM_FAILURE
			pString = "RPC_S_COMM_FAILURE";
			break;
		}

		case RPC_S_UNSUPPORTED_AUTHN_LEVEL:
		{
			// 1821 The requested authentication level is not supported.  RPC_S_UNSUPPORTED_AUTHN_LEVEL
			pString = "RPC_S_UNSUPPORTED_AUTHN_LEVEL";
			break;
		}

		case RPC_S_NO_PRINC_NAME:
		{
			// 1822 No principal name registered.  RPC_S_NO_PRINC_NAME
			pString = "RPC_S_NO_PRINC_NAME";
			break;
		}

		case RPC_S_NOT_RPC_ERROR:
		{
			// 1823 The error specified is not a valid Windows RPC error code.  RPC_S_NOT_RPC_ERROR
			pString = "RPC_S_NOT_RPC_ERROR";
			break;
		}

		case RPC_S_UUID_LOCAL_ONLY:
		{
			// 1824 A UUID that is valid only on this computer has been allocated.  RPC_S_UUID_LOCAL_ONLY
			pString = "RPC_S_UUID_LOCAL_ONLY";
			break;
		}

		case RPC_S_SEC_PKG_ERROR:
		{
			// 1825 A security package specific error occurred.  RPC_S_SEC_PKG_ERROR
			pString = "RPC_S_SEC_PKG_ERROR";
			break;
		}

		case RPC_S_NOT_CANCELLED:
		{
			// 1826 Thread is not canceled.  RPC_S_NOT_CANCELLED
			pString = "RPC_S_NOT_CANCELLED";
			break;
		}

		case RPC_X_INVALID_ES_ACTION:
		{
			// 1827 Invalid operation on the encoding/decoding handle.  RPC_X_INVALID_ES_ACTION
			pString = "RPC_X_INVALID_ES_ACTION";
			break;
		}

		case RPC_X_WRONG_ES_VERSION:
		{
			// 1828 Incompatible version of the serializing package.  RPC_X_WRONG_ES_VERSION
			pString = "RPC_X_WRONG_ES_VERSION";
			break;
		}

		case RPC_X_WRONG_STUB_VERSION:
		{
			// 1829 Incompatible version of the RPC stub.  RPC_X_WRONG_STUB_VERSION
			pString = "RPC_X_WRONG_STUB_VERSION";
			break;
		}

		case RPC_X_INVALID_PIPE_OBJECT:
		{
			// 1830 The RPC pipe object is invalid or corrupted.  RPC_X_INVALID_PIPE_OBJECT
			pString = "RPC_X_INVALID_PIPE_OBJECT";
			break;
		}

		case RPC_X_WRONG_PIPE_ORDER:
		{
			// 1831 An invalid operation was attempted on an RPC pipe object.  RPC_X_WRONG_PIPE_ORDER
			pString = "RPC_X_WRONG_PIPE_ORDER";
			break;
		}

		case RPC_X_WRONG_PIPE_VERSION:
		{
			// 1832 Unsupported RPC pipe version.  RPC_X_WRONG_PIPE_VERSION
			pString = "RPC_X_WRONG_PIPE_VERSION";
			break;
		}

		case RPC_S_GROUP_MEMBER_NOT_FOUND:
		{
			// 1898 The group member was not found.  RPC_S_GROUP_MEMBER_NOT_FOUND
			pString = "RPC_S_GROUP_MEMBER_NOT_FOUND";
			break;
		}

		case EPT_S_CANT_CREATE:
		{
			// 1899 The endpoint mapper database entry could not be created.  EPT_S_CANT_CREATE
			pString = "EPT_S_CANT_CREATE";
			break;
		}

		case RPC_S_INVALID_OBJECT:
		{
			// 1900 The object universal unique identifier (UUID) is the nil UUID.  RPC_S_INVALID_OBJECT
			pString = "RPC_S_INVALID_OBJECT";
			break;
		}

		case ERROR_INVALID_TIME:
		{
			// 1901 The specified time is invalid.  ERROR_INVALID_TIME
			pString = "ERROR_INVALID_TIME";
			break;
		}

		case ERROR_INVALID_FORM_NAME:
		{
			// 1902 The specified form name is invalid.  ERROR_INVALID_FORM_NAME
			pString = "ERROR_INVALID_FORM_NAME";
			break;
		}

		case ERROR_INVALID_FORM_SIZE:
		{
			// 1903 The specified form size is invalid.  ERROR_INVALID_FORM_SIZE
			pString = "ERROR_INVALID_FORM_SIZE";
			break;
		}

		case ERROR_ALREADY_WAITING:
		{
			// 1904 The specified printer handle is already being waited on  ERROR_ALREADY_WAITING
			pString = "ERROR_ALREADY_WAITING";
			break;
		}

		case ERROR_PRINTER_DELETED:
		{
			// 1905 The specified printer has been deleted.  ERROR_PRINTER_DELETED
			pString = "ERROR_PRINTER_DELETED";
			break;
		}

		case ERROR_INVALID_PRINTER_STATE:
		{
			// 1906 The state of the printer is invalid.  ERROR_INVALID_PRINTER_STATE
			pString = "ERROR_INVALID_PRINTER_STATE";
			break;
		}

		case ERROR_PASSWORD_MUST_CHANGE:
		{
			// 1907 The user must change his password before he logs on the first time.  ERROR_PASSWORD_MUST_CHANGE
			pString = "ERROR_PASSWORD_MUST_CHANGE";
			break;
		}

		case ERROR_DOMAIN_CONTROLLER_NOT_FOUND:
		{
			// 1908 Could not find the domain controller for this domain.  ERROR_DOMAIN_CONTROLLER_NOT_FOUND
			pString = "ERROR_DOMAIN_CONTROLLER_NOT_FOUND";
			break;
		}

		case ERROR_ACCOUNT_LOCKED_OUT:
		{
			// 1909 The referenced account is currently locked out and may not be logged on to.  ERROR_ACCOUNT_LOCKED_OUT
			pString = "ERROR_ACCOUNT_LOCKED_OUT";
			break;
		}

		case OR_INVALID_OXID:
		{
			// 1910 The object exporter specified was not found.  OR_INVALID_OXID
			pString = "OR_INVALID_OXID";
			break;
		}

		case OR_INVALID_OID:
		{
			// 1911 The object specified was not found.  OR_INVALID_OID
			pString = "OR_INVALID_OID";
			break;
		}

		case OR_INVALID_SET:
		{
			// 1912 The object resolver set specified was not found.  OR_INVALID_SET
			pString = "OR_INVALID_SET";
			break;
		}

		case RPC_S_SEND_INCOMPLETE:
		{
			// 1913 Some data remains to be sent in the request buffer.  RPC_S_SEND_INCOMPLETE
			pString = "RPC_S_SEND_INCOMPLETE";
			break;
		}

		case RPC_S_INVALID_ASYNC_HANDLE:
		{
			// 1914 Invalid asynchronous remote procedure call handle.  RPC_S_INVALID_ASYNC_HANDLE
			pString = "RPC_S_INVALID_ASYNC_HANDLE";
			break;
		}

		case RPC_S_INVALID_ASYNC_CALL:
		{
			// 1915 Invalid asynchronous RPC call handle for this operation.  RPC_S_INVALID_ASYNC_CALL
			pString = "RPC_S_INVALID_ASYNC_CALL";
			break;
		}

		case RPC_X_PIPE_CLOSED:
		{
			// 1916 The RPC pipe object has already been closed.  RPC_X_PIPE_CLOSED
			pString = "RPC_X_PIPE_CLOSED";
			break;
		}

		case RPC_X_PIPE_DISCIPLINE_ERROR:
		{
			// 1917 The RPC call completed before all pipes were processed.  RPC_X_PIPE_DISCIPLINE_ERROR
			pString = "RPC_X_PIPE_DISCIPLINE_ERROR";
			break;
		}

		case RPC_X_PIPE_EMPTY:
		{
			// 1918 No more data is available from the RPC pipe.  RPC_X_PIPE_EMPTY
			pString = "RPC_X_PIPE_EMPTY";
			break;
		}

		case ERROR_NO_SITENAME:
		{
			// 1919 No site name is available for this machine.  ERROR_NO_SITENAME
			pString = "ERROR_NO_SITENAME";
			break;
		}

		case ERROR_CANT_ACCESS_FILE:
		{
			// 1920 The file can not be accessed by the system.  ERROR_CANT_ACCESS_FILE
			pString = "ERROR_CANT_ACCESS_FILE";
			break;
		}

		case ERROR_CANT_RESOLVE_FILENAME:
		{
			// 1921 The name of the file cannot be resolved by the system.  ERROR_CANT_RESOLVE_FILENAME
			pString = "ERROR_CANT_RESOLVE_FILENAME";
			break;
		}

		case ERROR_DS_MEMBERSHIP_EVALUATED_LOCALLY:
		{
			// 1922 The directory service evaluated group memberships locally.  ERROR_DS_MEMBERSHIP_EVALUATED_LOCALLY
			pString = "ERROR_DS_MEMBERSHIP_EVALUATED_LOCALLY";
			break;
		}

		case ERROR_DS_NO_ATTRIBUTE_OR_VALUE:
		{
			// 1923 The specified directory service attribute or value does not exist.  ERROR_DS_NO_ATTRIBUTE_OR_VALUE
			pString = "ERROR_DS_NO_ATTRIBUTE_OR_VALUE";
			break;
		}

		case ERROR_DS_INVALID_ATTRIBUTE_SYNTAX:
		{
			// 1924 The attribute syntax specified to the directory service is invalid.  ERROR_DS_INVALID_ATTRIBUTE_SYNTAX
			pString = "ERROR_DS_INVALID_ATTRIBUTE_SYNTAX";
			break;
		}

		case ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED:
		{
			// 1925 The attribute type specified to the directory service is not defined.  ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED
			pString = "ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED";
			break;
		}

		case ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS:
		{
			// 1926 The specified directory service attribute or value already exists.  ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS
			pString = "ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS";
			break;
		}

		case ERROR_DS_BUSY:
		{
			// 1927 The directory service is busy.  ERROR_DS_BUSY
			pString = "ERROR_DS_BUSY";
			break;
		}

		case ERROR_DS_UNAVAILABLE:
		{
			// 1928 The directory service is unavailable.  ERROR_DS_UNAVAILABLE
			pString = "ERROR_DS_UNAVAILABLE";
			break;
		}

		case ERROR_DS_NO_RIDS_ALLOCATED:
		{
			// 1929 The directory service was unable to allocate a relative identifier.  ERROR_DS_NO_RIDS_ALLOCATED
			pString = "ERROR_DS_NO_RIDS_ALLOCATED";
			break;
		}

		case ERROR_DS_NO_MORE_RIDS:
		{
			// 1930 The directory service has exhausted the pool of relative identifiers.  ERROR_DS_NO_MORE_RIDS
			pString = "ERROR_DS_NO_MORE_RIDS";
			break;
		}

		case ERROR_DS_INCORRECT_ROLE_OWNER:
		{
			// 1931 The requested operation could not be performed because the directory service is not the master for that type of operation.  ERROR_DS_INCORRECT_ROLE_OWNER
			pString = "ERROR_DS_INCORRECT_ROLE_OWNER";
			break;
		}

		case ERROR_DS_RIDMGR_INIT_ERROR:
		{
			// 1932 The directory service was unable to initialize the subsystem that allocates relative identifiers.  ERROR_DS_RIDMGR_INIT_ERROR
			pString = "ERROR_DS_RIDMGR_INIT_ERROR";
			break;
		}

		case ERROR_DS_OBJ_CLASS_VIOLATION:
		{
			// 1933 The requested operation did not satisfy one or more constraints associated with the class of the object.  ERROR_DS_OBJ_CLASS_VIOLATION
			pString = "ERROR_DS_OBJ_CLASS_VIOLATION";
			break;
		}

		case ERROR_DS_CANT_ON_NON_LEAF:
		{
			// 1934 The directory service can perform the requested operation only on a leaf object.  ERROR_DS_CANT_ON_NON_LEAF
			pString = "ERROR_DS_CANT_ON_NON_LEAF";
			break;
		}

		case ERROR_DS_CANT_ON_RDN:
		{
			// 1935 The directory service cannot perform the requested operation on the RDN attribute of an object.  ERROR_DS_CANT_ON_RDN
			pString = "ERROR_DS_CANT_ON_RDN";
			break;
		}

		case ERROR_DS_CANT_MOD_OBJ_CLASS:
		{
			// 1936 The directory service detected an attempt to modify the object class of an object.  ERROR_DS_CANT_MOD_OBJ_CLASS
			pString = "ERROR_DS_CANT_MOD_OBJ_CLASS";
			break;
		}

		case ERROR_DS_CROSS_DOM_MOVE_ERROR:
		{
			// 1937 The requested cross domain move operation could not be performed.  ERROR_DS_CROSS_DOM_MOVE_ERROR
			pString = "ERROR_DS_CROSS_DOM_MOVE_ERROR";
			break;
		}

		case ERROR_DS_GC_NOT_AVAILABLE:
		{
			// 1938 Unable to contact the global catalog server.  ERROR_DS_GC_NOT_AVAILABLE
			pString = "ERROR_DS_GC_NOT_AVAILABLE";
			break;
		}

		case ERROR_INVALID_PIXEL_FORMAT:
		{
			// 2000 The pixel format is invalid.  ERROR_INVALID_PIXEL_FORMAT
			pString = "ERROR_INVALID_PIXEL_FORMAT";
			break;
		}

		case ERROR_BAD_DRIVER:
		{
			// 2001 The specified driver is invalid.  ERROR_BAD_DRIVER
			pString = "ERROR_BAD_DRIVER";
			break;
		}

		case ERROR_INVALID_WINDOW_STYLE:
		{
			// 2002 The window style or class attribute is invalid for this operation.  ERROR_INVALID_WINDOW_STYLE
			pString = "ERROR_INVALID_WINDOW_STYLE";
			break;
		}

		case ERROR_METAFILE_NOT_SUPPORTED:
		{
			// 2003 The requested metafile operation is not supported.  ERROR_METAFILE_NOT_SUPPORTED
			pString = "ERROR_METAFILE_NOT_SUPPORTED";
			break;
		}

		case ERROR_TRANSFORM_NOT_SUPPORTED:
		{
			// 2004 The requested transformation operation is not supported.  ERROR_TRANSFORM_NOT_SUPPORTED
			pString = "ERROR_TRANSFORM_NOT_SUPPORTED";
			break;
		}

		case ERROR_CLIPPING_NOT_SUPPORTED:
		{
			// 2005 The requested clipping operation is not supported.  ERROR_CLIPPING_NOT_SUPPORTED
			pString = "ERROR_CLIPPING_NOT_SUPPORTED";
			break;
		}

		case ERROR_CONNECTED_OTHER_PASSWORD:
		{
			// 2108 The network connection was made successfully, but the user had to be prompted for a password other than the one originally specified.  ERROR_CONNECTED_OTHER_PASSWORD
			pString = "ERROR_CONNECTED_OTHER_PASSWORD";
			break;
		}

		case ERROR_BAD_USERNAME:
		{
			// 2202 The specified username is invalid.  ERROR_BAD_USERNAME
			pString = "ERROR_BAD_USERNAME";
			break;
		}

		case ERROR_NOT_CONNECTED:
		{
			// 2250 This network connection does not exist.  ERROR_NOT_CONNECTED
			pString = "ERROR_NOT_CONNECTED";
			break;
		}

		case ERROR_INVALID_CMM:
		{
			// 2300 The specified color management module is invalid.  ERROR_INVALID_CMM
			pString = "ERROR_INVALID_CMM";
			break;
		}

		case ERROR_INVALID_PROFILE:
		{
			// 2301 The specified color profile is invalid.  ERROR_INVALID_PROFILE
			pString = "ERROR_INVALID_PROFILE";
			break;
		}

		case ERROR_TAG_NOT_FOUND:
		{
			// 2302 The specified tag was not found.  ERROR_TAG_NOT_FOUND
			pString = "ERROR_TAG_NOT_FOUND";
			break;
		}

		case ERROR_TAG_NOT_PRESENT:
		{
			// 2303 A required tag is not present.  ERROR_TAG_NOT_PRESENT
			pString = "ERROR_TAG_NOT_PRESENT";
			break;
		}

		case ERROR_DUPLICATE_TAG:
		{
			// 2304 The specified tag is already present.  ERROR_DUPLICATE_TAG
			pString = "ERROR_DUPLICATE_TAG";
			break;
		}

		case ERROR_PROFILE_NOT_ASSOCIATED_WITH_DEVICE:
		{
			// 2305 The specified color profile is not associated with any device.  ERROR_PROFILE_NOT_ASSOCIATED_WITH_DEVICE
			pString = "ERROR_PROFILE_NOT_ASSOCIATED_WITH_DEVICE";
			break;
		}

		case ERROR_PROFILE_NOT_FOUND:
		{
			// 2306 The specified color profile was not found.  ERROR_PROFILE_NOT_FOUND
			pString = "ERROR_PROFILE_NOT_FOUND";
			break;
		}

		case ERROR_INVALID_COLORSPACE:
		{
			// 2307 The specified color space is invalid.  ERROR_INVALID_COLORSPACE
			pString = "ERROR_INVALID_COLORSPACE";
			break;
		}

		case ERROR_ICM_NOT_ENABLED:
		{
			// 2308 Image Color Management is not enabled.  ERROR_ICM_NOT_ENABLED
			pString = "ERROR_ICM_NOT_ENABLED";
			break;
		}

		case ERROR_DELETING_ICM_XFORM:
		{
			// 2309 There was an error while deleting the color transform.  ERROR_DELETING_ICM_XFORM
			pString = "ERROR_DELETING_ICM_XFORM";
			break;
		}

		case ERROR_INVALID_TRANSFORM:
		{
			// 2310 The specified color transform is invalid.  ERROR_INVALID_TRANSFORM
			pString = "ERROR_INVALID_TRANSFORM";
			break;
		}

		case ERROR_OPEN_FILES:
		{
			// 2401 This network connection has files open or requests pending.  ERROR_OPEN_FILES
			pString = "ERROR_OPEN_FILES";
			break;
		}

		case ERROR_ACTIVE_CONNECTIONS:
		{
			// 2402 Active connections still exist.  ERROR_ACTIVE_CONNECTIONS
			pString = "ERROR_ACTIVE_CONNECTIONS";
			break;
		}

		case ERROR_DEVICE_IN_USE:
		{
			// 2404 The device is in use by an active process and cannot be disconnected.  ERROR_DEVICE_IN_USE
			pString = "ERROR_DEVICE_IN_USE";
			break;
		}

		case ERROR_UNKNOWN_PRINT_MONITOR:
		{
			// 3000 The specified print monitor is unknown.  ERROR_UNKNOWN_PRINT_MONITOR
			pString = "ERROR_UNKNOWN_PRINT_MONITOR";
			break;
		}

		case ERROR_PRINTER_DRIVER_IN_USE:
		{
			// 3001 The specified printer driver is currently in use.  ERROR_PRINTER_DRIVER_IN_USE
			pString = "ERROR_PRINTER_DRIVER_IN_USE";
			break;
		}

		case ERROR_SPOOL_FILE_NOT_FOUND:
		{
			// 3002 The spool file was not found.  ERROR_SPOOL_FILE_NOT_FOUND
			pString = "ERROR_SPOOL_FILE_NOT_FOUND";
			break;
		}

		case ERROR_SPL_NO_STARTDOC:
		{
			// 3003 A StartDocPrinter call was not issued.  ERROR_SPL_NO_STARTDOC
			pString = "ERROR_SPL_NO_STARTDOC";
			break;
		}

		case ERROR_SPL_NO_ADDJOB:
		{
			// 3004 An AddJob call was not issued.  ERROR_SPL_NO_ADDJOB
			pString = "ERROR_SPL_NO_ADDJOB";
			break;
		}

		case ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED:
		{
			// 3005 The specified print processor has already been installed.  ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED
			pString = "ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED";
			break;
		}

		case ERROR_PRINT_MONITOR_ALREADY_INSTALLED:
		{
			// 3006 The specified print monitor has already been installed.  ERROR_PRINT_MONITOR_ALREADY_INSTALLED
			pString = "ERROR_PRINT_MONITOR_ALREADY_INSTALLED";
			break;
		}

		case ERROR_INVALID_PRINT_MONITOR:
		{
			// 3007 The specified print monitor does not have the required functions.  ERROR_INVALID_PRINT_MONITOR
			pString = "ERROR_INVALID_PRINT_MONITOR";
			break;
		}

		case ERROR_PRINT_MONITOR_IN_USE:
		{
			// 3008 The specified print monitor is currently in use.  ERROR_PRINT_MONITOR_IN_USE
			pString = "ERROR_PRINT_MONITOR_IN_USE";
			break;
		}

		case ERROR_PRINTER_HAS_JOBS_QUEUED:
		{
			// 3009 The requested operation is not allowed when there are jobs queued to the printer.  ERROR_PRINTER_HAS_JOBS_QUEUED
			pString = "ERROR_PRINTER_HAS_JOBS_QUEUED";
			break;
		}

		case ERROR_SUCCESS_REBOOT_REQUIRED:
		{
			// 3010 The requested operation is successful. Changes will not be effective until the system is rebooted.  ERROR_SUCCESS_REBOOT_REQUIRED
			pString = "ERROR_SUCCESS_REBOOT_REQUIRED";
			break;
		}

		case ERROR_SUCCESS_RESTART_REQUIRED:
		{
			// 3011 The requested operation is successful. Changes will not be effective until the service is restarted.  ERROR_SUCCESS_RESTART_REQUIRED
			pString = "ERROR_SUCCESS_RESTART_REQUIRED";
			break;
		}

		case ERROR_WINS_INTERNAL:
		{
			// 4000 WINS encountered an error while processing the command.  ERROR_WINS_INTERNAL
			pString = "ERROR_WINS_INTERNAL";
			break;
		}

		case ERROR_CAN_NOT_DEL_LOCAL_WINS:
		{
			// 4001 The local WINS can not be deleted.  ERROR_CAN_NOT_DEL_LOCAL_WINS
			pString = "ERROR_CAN_NOT_DEL_LOCAL_WINS";
			break;
		}

		case ERROR_STATIC_INIT:
		{
			// 4002 The importation from the file failed.  ERROR_STATIC_INIT
			pString = "ERROR_STATIC_INIT";
			break;
		}

		case ERROR_INC_BACKUP:
		{
			// 4003 The backup failed. Was a full backup done before?  ERROR_INC_BACKUP
			pString = "ERROR_INC_BACKUP";
			break;
		}

		case ERROR_FULL_BACKUP:
		{
			// 4004 The backup failed. Check the directory to which you are backing the database.  ERROR_FULL_BACKUP
			pString = "ERROR_FULL_BACKUP";
			break;
		}

		case ERROR_REC_NON_EXISTENT:
		{
			// 4005 The name does not exist in the WINS database.  ERROR_REC_NON_EXISTENT
			pString = "ERROR_REC_NON_EXISTENT";
			break;
		}

		case ERROR_RPL_NOT_ALLOWED:
		{
			// 4006 Replication with a nonconfigured partner is not allowed.  ERROR_RPL_NOT_ALLOWED
			pString = "ERROR_RPL_NOT_ALLOWED";
			break;
		}

		case ERROR_DHCP_ADDRESS_CONFLICT:
		{
			// 4100 The DHCP client has obtained an IP address that is already in use on the network. The local interface will be disabled until the DHCP client can obtain a new address.  ERROR_DHCP_ADDRESS_CONFLICT
			pString = "ERROR_DHCP_ADDRESS_CONFLICT";
			break;
		}

		case ERROR_WMI_GUID_NOT_FOUND:
		{
			// 4200 The GUID passed was not recognized as valid by a WMI data provider.  ERROR_WMI_GUID_NOT_FOUND
			pString = "ERROR_WMI_GUID_NOT_FOUND";
			break;
		}

		case ERROR_WMI_INSTANCE_NOT_FOUND:
		{
			// 4201 The instance name passed was not recognized as valid by a WMI data provider.  ERROR_WMI_INSTANCE_NOT_FOUND
			pString = "ERROR_WMI_INSTANCE_NOT_FOUND";
			break;
		}

		case ERROR_WMI_ITEMID_NOT_FOUND:
		{
			// 4202 The data item ID passed was not recognized as valid by a WMI data provider.  ERROR_WMI_ITEMID_NOT_FOUND
			pString = "ERROR_WMI_ITEMID_NOT_FOUND";
			break;
		}

		case ERROR_WMI_TRY_AGAIN:
		{
			// 4203 The WMI request could not be completed and should be retried.  ERROR_WMI_TRY_AGAIN
			pString = "ERROR_WMI_TRY_AGAIN";
			break;
		}

		case ERROR_WMI_DP_NOT_FOUND:
		{
			// 4204 The WMI data provider could not be located.  ERROR_WMI_DP_NOT_FOUND
			pString = "ERROR_WMI_DP_NOT_FOUND";
			break;
		}

		case ERROR_WMI_UNRESOLVED_INSTANCE_REF:
		{
			// 4205 The WMI data provider references an instance set that has not been registered.  ERROR_WMI_UNRESOLVED_INSTANCE_REF
			pString = "ERROR_WMI_UNRESOLVED_INSTANCE_REF";
			break;
		}

		case ERROR_WMI_ALREADY_ENABLED:
		{
			// 4206 The WMI data block or event notification has already been enabled.  ERROR_WMI_ALREADY_ENABLED
			pString = "ERROR_WMI_ALREADY_ENABLED";
			break;
		}

		case ERROR_WMI_GUID_DISCONNECTED:
		{
			// 4207 The WMI data block is no longer available.  ERROR_WMI_GUID_DISCONNECTED
			pString = "ERROR_WMI_GUID_DISCONNECTED";
			break;
		}

		case ERROR_WMI_SERVER_UNAVAILABLE:
		{
			// 4208 The WMI data service is not available.  ERROR_WMI_SERVER_UNAVAILABLE
			pString = "ERROR_WMI_SERVER_UNAVAILABLE";
			break;
		}

		case ERROR_WMI_DP_FAILED:
		{
			// 4209 The WMI data provider failed to carry out the request.  ERROR_WMI_DP_FAILED
			pString = "ERROR_WMI_DP_FAILED";
			break;
		}

		case ERROR_WMI_INVALID_MOF:
		{
			// 4210 The WMI MOF information is not valid.  ERROR_WMI_INVALID_MOF
			pString = "ERROR_WMI_INVALID_MOF";
			break;
		}

		case ERROR_WMI_INVALID_REGINFO:
		{
			// 4211 The WMI registration information is not valid.  ERROR_WMI_INVALID_REGINFO
			pString = "ERROR_WMI_INVALID_REGINFO";
			break;
		}

		case ERROR_INVALID_MEDIA:
		{
			// 4300 The media identifier does not represent a valid medium.  ERROR_INVALID_MEDIA
			pString = "ERROR_INVALID_MEDIA";
			break;
		}

		case ERROR_INVALID_LIBRARY:
		{
			// 4301 The library identifier does not represent a valid library.  ERROR_INVALID_LIBRARY
			pString = "ERROR_INVALID_LIBRARY";
			break;
		}

		case ERROR_INVALID_MEDIA_POOL:
		{
			// 4302 The media pool identifier does not represent a valid media pool.  ERROR_INVALID_MEDIA_POOL
			pString = "ERROR_INVALID_MEDIA_POOL";
			break;
		}

		case ERROR_DRIVE_MEDIA_MISMATCH:
		{
			// 4303 The drive and medium are not compatible or exist in different libraries.  ERROR_DRIVE_MEDIA_MISMATCH
			pString = "ERROR_DRIVE_MEDIA_MISMATCH";
			break;
		}

		case ERROR_MEDIA_OFFLINE:
		{
			// 4304 The medium currently exists in an offline library and must be online to perform this operation.  ERROR_MEDIA_OFFLINE
			pString = "ERROR_MEDIA_OFFLINE";
			break;
		}

		case ERROR_LIBRARY_OFFLINE:
		{
			// 4305 The operation cannot be performed on an offline library.  ERROR_LIBRARY_OFFLINE
			pString = "ERROR_LIBRARY_OFFLINE";
			break;
		}

		case ERROR_EMPTY:
		{
			// 4306 The library, drive, or media pool is empty.  ERROR_EMPTY
			pString = "ERROR_EMPTY";
			break;
		}

		case ERROR_NOT_EMPTY:
		{
			// 4307 The library, drive, or media pool must be empty to perform this operation.  ERROR_NOT_EMPTY
			pString = "ERROR_NOT_EMPTY";
			break;
		}

		case ERROR_MEDIA_UNAVAILABLE:
		{
			// 4308 No media is currently available in this media pool or library.  ERROR_MEDIA_UNAVAILABLE
			pString = "ERROR_MEDIA_UNAVAILABLE";
			break;
		}

		case ERROR_RESOURCE_DISABLED:
		{
			// 4309 A resource required for this operation is disabled.  ERROR_RESOURCE_DISABLED
			pString = "ERROR_RESOURCE_DISABLED";
			break;
		}

		case ERROR_INVALID_CLEANER:
		{
			// 4310 The media identifier does not represent a valid cleaner.  ERROR_INVALID_CLEANER
			pString = "ERROR_INVALID_CLEANER";
			break;
		}

		case ERROR_UNABLE_TO_CLEAN:
		{
			// 4311 The drive cannot be cleaned or does not support cleaning.  ERROR_UNABLE_TO_CLEAN
			pString = "ERROR_UNABLE_TO_CLEAN";
			break;
		}

		case ERROR_OBJECT_NOT_FOUND:
		{
			// 4312 The object identifier does not represent a valid object.  ERROR_OBJECT_NOT_FOUND
			pString = "ERROR_OBJECT_NOT_FOUND";
			break;
		}

		case ERROR_DATABASE_FAILURE:
		{
			// 4313 Unable to read from or write to the database.  ERROR_DATABASE_FAILURE
			pString = "ERROR_DATABASE_FAILURE";
			break;
		}

		case ERROR_DATABASE_FULL:
		{
			// 4314 The database is full.  ERROR_DATABASE_FULL
			pString = "ERROR_DATABASE_FULL";
			break;
		}

		case ERROR_MEDIA_INCOMPATIBLE:
		{
			// 4315 The medium is not compatible with the device or media pool.  ERROR_MEDIA_INCOMPATIBLE
			pString = "ERROR_MEDIA_INCOMPATIBLE";
			break;
		}

		case ERROR_RESOURCE_NOT_PRESENT:
		{
			// 4316 The resource required for this operation does not exist.  ERROR_RESOURCE_NOT_PRESENT
			pString = "ERROR_RESOURCE_NOT_PRESENT";
			break;
		}

		case ERROR_INVALID_OPERATION:
		{
			// 4317 The operation identifier is not valid.  ERROR_INVALID_OPERATION
			pString = "ERROR_INVALID_OPERATION";
			break;
		}

		case ERROR_MEDIA_NOT_AVAILABLE:
		{
			// 4318 The media is not mounted or ready for use.  ERROR_MEDIA_NOT_AVAILABLE
			pString = "ERROR_MEDIA_NOT_AVAILABLE";
			break;
		}

		case ERROR_DEVICE_NOT_AVAILABLE:
		{
			// 4319 The device is not ready for use.  ERROR_DEVICE_NOT_AVAILABLE
			pString = "ERROR_DEVICE_NOT_AVAILABLE";
			break;
		}

		case ERROR_REQUEST_REFUSED:
		{
			// 4320 The operator or administrator has refused the request.  ERROR_REQUEST_REFUSED
			pString = "ERROR_REQUEST_REFUSED";
			break;
		}

		case ERROR_FILE_OFFLINE:
		{
			// 4350 The remote storage service was not able to recall the file.  ERROR_FILE_OFFLINE
			pString = "ERROR_FILE_OFFLINE";
			break;
		}

		case ERROR_REMOTE_STORAGE_NOT_ACTIVE:
		{
			// 4351 The remote storage service is not operational at this time.  ERROR_REMOTE_STORAGE_NOT_ACTIVE
			pString = "ERROR_REMOTE_STORAGE_NOT_ACTIVE";
			break;
		}

		case ERROR_REMOTE_STORAGE_MEDIA_ERROR:
		{
			// 4352 The remote storage service encountered a media error.  ERROR_REMOTE_STORAGE_MEDIA_ERROR
			pString = "ERROR_REMOTE_STORAGE_MEDIA_ERROR";
			break;
		}

		case ERROR_NOT_A_REPARSE_POINT:
		{
			// 4390 The file or directory is not a reparse point.  ERROR_NOT_A_REPARSE_POINT
			pString = "ERROR_NOT_A_REPARSE_POINT";
			break;
		}

		case ERROR_REPARSE_ATTRIBUTE_CONFLICT:
		{
			// 4391 The reparse point attribute cannot be set because it conflicts with an existing attribute.  ERROR_REPARSE_ATTRIBUTE_CONFLICT
			pString = "ERROR_REPARSE_ATTRIBUTE_CONFLICT";
			break;
		}

		case ERROR_DEPENDENT_RESOURCE_EXISTS:
		{
			// 5001 The cluster resource cannot be moved to another group because other resources are dependent on it.  ERROR_DEPENDENT_RESOURCE_EXISTS
			pString = "ERROR_DEPENDENT_RESOURCE_EXISTS";
			break;
		}

		case ERROR_DEPENDENCY_NOT_FOUND:
		{
			// 5002 The cluster resource dependency cannot be found.  ERROR_DEPENDENCY_NOT_FOUND
			pString = "ERROR_DEPENDENCY_NOT_FOUND";
			break;
		}

		case ERROR_DEPENDENCY_ALREADY_EXISTS:
		{
			// 5003 The cluster resource cannot be made dependent on the specified resource because it is already dependent.  ERROR_DEPENDENCY_ALREADY_EXISTS
			pString = "ERROR_DEPENDENCY_ALREADY_EXISTS";
			break;
		}

		case ERROR_RESOURCE_NOT_ONLINE:
		{
			// 5004 The cluster resource is not online.  ERROR_RESOURCE_NOT_ONLINE
			pString = "ERROR_RESOURCE_NOT_ONLINE";
			break;
		}

		case ERROR_HOST_NODE_NOT_AVAILABLE:
		{
			// 5005 A cluster node is not available for this operation.  ERROR_HOST_NODE_NOT_AVAILABLE
			pString = "ERROR_HOST_NODE_NOT_AVAILABLE";
			break;
		}

		case ERROR_RESOURCE_NOT_AVAILABLE:
		{
			// 5006 The cluster resource is not available.  ERROR_RESOURCE_NOT_AVAILABLE
			pString = "ERROR_RESOURCE_NOT_AVAILABLE";
			break;
		}

		case ERROR_RESOURCE_NOT_FOUND:
		{
			// 5007 The cluster resource could not be found.  ERROR_RESOURCE_NOT_FOUND
			pString = "ERROR_RESOURCE_NOT_FOUND";
			break;
		}

		case ERROR_SHUTDOWN_CLUSTER:
		{
			// 5008 The cluster is being shut down.  ERROR_SHUTDOWN_CLUSTER
			pString = "ERROR_SHUTDOWN_CLUSTER";
			break;
		}

		case ERROR_CANT_EVICT_ACTIVE_NODE:
		{
			// 5009 A cluster node cannot be evicted from the cluster while it is online.  ERROR_CANT_EVICT_ACTIVE_NODE
			pString = "ERROR_CANT_EVICT_ACTIVE_NODE";
			break;
		}

		case ERROR_OBJECT_ALREADY_EXISTS:
		{
			// 5010 The object already exists.  ERROR_OBJECT_ALREADY_EXISTS
			pString = "ERROR_OBJECT_ALREADY_EXISTS";
			break;
		}

		case ERROR_OBJECT_IN_LIST:
		{
			// 5011 The object is already in the list.  ERROR_OBJECT_IN_LIST
			pString = "ERROR_OBJECT_IN_LIST";
			break;
		}

		case ERROR_GROUP_NOT_AVAILABLE:
		{
			// 5012 The cluster group is not available for any new requests.  ERROR_GROUP_NOT_AVAILABLE
			pString = "ERROR_GROUP_NOT_AVAILABLE";
			break;
		}

		case ERROR_GROUP_NOT_FOUND:
		{
			// 5013 The cluster group could not be found.  ERROR_GROUP_NOT_FOUND
			pString = "ERROR_GROUP_NOT_FOUND";
			break;
		}

		case ERROR_GROUP_NOT_ONLINE:
		{
			// 5014 The operation could not be completed because the cluster group is not online.  ERROR_GROUP_NOT_ONLINE
			pString = "ERROR_GROUP_NOT_ONLINE";
			break;
		}

		case ERROR_HOST_NODE_NOT_RESOURCE_OWNER:
		{
			// 5015 The cluster node is not the owner of the resource.  ERROR_HOST_NODE_NOT_RESOURCE_OWNER
			pString = "ERROR_HOST_NODE_NOT_RESOURCE_OWNER";
			break;
		}

		case ERROR_HOST_NODE_NOT_GROUP_OWNER:
		{
			// 5016 The cluster node is not the owner of the group.  ERROR_HOST_NODE_NOT_GROUP_OWNER
			pString = "ERROR_HOST_NODE_NOT_GROUP_OWNER";
			break;
		}

		case ERROR_RESMON_CREATE_FAILED:
		{
			// 5017 The cluster resource could not be created in the specified resource monitor.  ERROR_RESMON_CREATE_FAILED
			pString = "ERROR_RESMON_CREATE_FAILED";
			break;
		}

		case ERROR_RESMON_ONLINE_FAILED:
		{
			// 5018 The cluster resource could not be brought online by the resource monitor.  ERROR_RESMON_ONLINE_FAILED
			pString = "ERROR_RESMON_ONLINE_FAILED";
			break;
		}

		case ERROR_RESOURCE_ONLINE:
		{
			// 5019 The operation could not be completed because the cluster resource is online.  ERROR_RESOURCE_ONLINE
			pString = "ERROR_RESOURCE_ONLINE";
			break;
		}

		case ERROR_QUORUM_RESOURCE:
		{
			// 5020 The cluster resource could not be deleted or brought offline because it is the quorum resource.  ERROR_QUORUM_RESOURCE
			pString = "ERROR_QUORUM_RESOURCE";
			break;
		}

		case ERROR_NOT_QUORUM_CAPABLE:
		{
			// 5021 The cluster could not make the specified resource a quorum resource because it is not capable of being a quorum resource.  ERROR_NOT_QUORUM_CAPABLE
			pString = "ERROR_NOT_QUORUM_CAPABLE";
			break;
		}

		case ERROR_CLUSTER_SHUTTING_DOWN:
		{
			// 5022 The cluster software is shutting down.  ERROR_CLUSTER_SHUTTING_DOWN
			pString = "ERROR_CLUSTER_SHUTTING_DOWN";
			break;
		}

		case ERROR_INVALID_STATE:
		{
			// 5023 The group or resource is not in the correct state to perform the requested operation.  ERROR_INVALID_STATE
			pString = "ERROR_INVALID_STATE";
			break;
		}

		case ERROR_RESOURCE_PROPERTIES_STORED:
		{
			// 5024 The properties were stored but not all changes will take effect until the next time the resource is brought online.  ERROR_RESOURCE_PROPERTIES_STORED
			pString = "ERROR_RESOURCE_PROPERTIES_STORED";
			break;
		}

		case ERROR_NOT_QUORUM_CLASS:
		{
			// 5025 The cluster could not make the specified resource a quorum resource because it does not belong to a shared storage class.  ERROR_NOT_QUORUM_CLASS
			pString = "ERROR_NOT_QUORUM_CLASS";
			break;
		}

		case ERROR_CORE_RESOURCE:
		{
			// 5026 The cluster resource could not be deleted since it is a core resource.  ERROR_CORE_RESOURCE
			pString = "ERROR_CORE_RESOURCE";
			break;
		}

		case ERROR_QUORUM_RESOURCE_ONLINE_FAILED:
		{
			// 5027 The quorum resource failed to come online.  ERROR_QUORUM_RESOURCE_ONLINE_FAILED
			pString = "ERROR_QUORUM_RESOURCE_ONLINE_FAILED";
			break;
		}

		case ERROR_QUORUMLOG_OPEN_FAILED:
		{
			// 5028 The quorum log could not be created or mounted successfully.  ERROR_QUORUMLOG_OPEN_FAILED
			pString = "ERROR_QUORUMLOG_OPEN_FAILED";
			break;
		}

		case ERROR_CLUSTERLOG_CORRUPT:
		{
			// 5029 The cluster log is corrupt.  ERROR_CLUSTERLOG_CORRUPT
			pString = "ERROR_CLUSTERLOG_CORRUPT";
			break;
		}

		case ERROR_CLUSTERLOG_RECORD_EXCEEDS_MAXSIZE:
		{
			// 5030 The record could not be written to the cluster log since it exceeds the maximum size.  ERROR_CLUSTERLOG_RECORD_EXCEEDS_MAXSIZE
			pString = "ERROR_CLUSTERLOG_RECORD_EXCEEDS_MAXSIZE";
			break;
		}

		case ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE:
		{
			// 5031 The cluster log exceeds its maximum size.  ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE
			pString = "ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE";
			break;
		}

		case ERROR_CLUSTERLOG_CHKPOINT_NOT_FOUND:
		{
			// 5032 No checkpoint record was found in the cluster log.  ERROR_CLUSTERLOG_CHKPOINT_NOT_FOUND
			pString = "ERROR_CLUSTERLOG_CHKPOINT_NOT_FOUND";
			break;
		}

		case ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE:
		{
			// 5033 The minimum required disk space needed for logging is not available.  ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE
			pString = "ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE";
			break;
		}

		case ERROR_ENCRYPTION_FAILED:
		{
			// 6000 The specified file could not be encrypted.  ERROR_ENCRYPTION_FAILED
			pString = "ERROR_ENCRYPTION_FAILED";
			break;
		}

		case ERROR_DECRYPTION_FAILED:
		{
			// 6001 The specified file could not be decrypted.  ERROR_DECRYPTION_FAILED
			pString = "ERROR_DECRYPTION_FAILED";
			break;
		}

		case ERROR_FILE_ENCRYPTED:
		{
			// 6002 The specified file is encrypted and the user does not have the ability to decrypt it.  ERROR_FILE_ENCRYPTED
			pString = "ERROR_FILE_ENCRYPTED";
			break;
		}

		case ERROR_NO_RECOVERY_POLICY:
		{
			// 6003 There is no encryption recovery policy configured for this system.  ERROR_NO_RECOVERY_POLICY
			pString = "ERROR_NO_RECOVERY_POLICY";
			break;
		}

		case ERROR_NO_EFS:
		{
			// 6004 The required encryption driver is not loaded for this system.  ERROR_NO_EFS
			pString = "ERROR_NO_EFS";
			break;
		}

		case ERROR_WRONG_EFS:
		{
			// 6005 The file was encrypted with a different encryption driver than is currently loaded.  ERROR_WRONG_EFS
			pString = "ERROR_WRONG_EFS";
			break;
		}

		case ERROR_NO_USER_KEYS:
		{
			// 6006 There are no EFS keys defined for the user.  ERROR_NO_USER_KEYS
			pString = "ERROR_NO_USER_KEYS";
			break;
		}

		case ERROR_FILE_NOT_ENCRYPTED:
		{
			// 6007 The specified file is not encrypted.  ERROR_FILE_NOT_ENCRYPTED
			pString = "ERROR_FILE_NOT_ENCRYPTED";
			break;
		}

		case ERROR_NOT_EXPORT_FORMAT:
		{
			// 6008 The specified file is not in the defined EFS export format.  ERROR_NOT_EXPORT_FORMAT
			pString = "ERROR_NOT_EXPORT_FORMAT";
			break;
		}

		case ERROR_NO_BROWSER_SERVERS_FOUND:
		{
			// 6118 The list of servers for this workgroup is not currently available  ERROR_NO_BROWSER_SERVERS_FOUND
			pString = "ERROR_NO_BROWSER_SERVERS_FOUND";
			break;
		}

		default:
		{
			DPFX(DPFPREP, 0, "Unknown Win32 error code %u/0x%lx", Error, Error );

			pString = "Unknown Win32 error code!";
			break;
		}
	}

	return	pString;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// GetWinsockErrorString - convert system error to a string
//
// Entry:		Error code
//
// Exit:		Pointer to string
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "GetWinsockErrorString"

static	char	*GetWinsockErrorString( const DWORD WinsockError )
{
	char	*pString = NULL;


	// what was the error code?
	switch ( WinsockError )
	{
		case WSAEINTR:
		{
			pString = "WSAEINTR";
			break;
		}

		case WSAEBADF:
		{
			pString = "WSAEBADF";
			break;
		}

		case WSAEACCES:
		{
			pString = "WSAEACCES";
			break;
		}

		case WSAEFAULT:
		{
			pString = "WSAEFAULT";
			break;
		}

		case WSAEINVAL:
		{
			pString = "WSAEINVAL";
			break;
		}

		case WSAEMFILE:
		{
			pString = "WSAEMFILE";
			break;
		}

		case WSAEWOULDBLOCK:
		{
			pString = "WSAEWOULDBLOCK";
			break;
		}

		case WSAEINPROGRESS:
		{
			pString = "WSAEINPROGRESS";
			break;
		}

		case WSAEALREADY:
		{
			pString = "WSAEALREADY";
			break;
		}

		case WSAENOTSOCK:
		{
			pString = "WSAENOTSOCK";
			break;
		}

		case WSAEDESTADDRREQ:
		{
			pString = "WSAEDESTADDRREQ";
			break;
		}

		case WSAEMSGSIZE:
		{
			pString = "WSAEMSGSIZE";
			break;
		}

		case WSAEPROTOTYPE:
		{
			pString = "WSAEPROTOTYPE";
			break;
		}

		case WSAENOPROTOOPT:
		{
			pString = "WSAENOPROTOOPT";
			break;
		}

		case WSAEPROTONOSUPPORT:
		{
			pString = "WSAEPROTONOSUPPORT";
			break;
		}

		case WSAESOCKTNOSUPPORT:
		{
			pString = "WSAESOCKTNOSUPPORT";
			break;
		}

		case WSAEOPNOTSUPP:
		{
			pString = "WSAEOPNOTSUPP";
			break;
		}

		case WSAEPFNOSUPPORT:
		{
			pString = "WSAEPFNOSUPPORT";
			break;
		}

		case WSAEAFNOSUPPORT:
		{
			pString = "WSAEAFNOSUPPORT";
			break;
		}

		case WSAEADDRINUSE:
		{
			pString = "WSAEADDRINUSE";
			break;
		}

		case WSAEADDRNOTAVAIL:
		{
			pString = "WSAEADDRNOTAVAIL";
			break;
		}

		case WSAENETDOWN:
		{
			pString = "WSAENETDOWN";
			break;
		}

		case WSAENETUNREACH:
		{
			pString = "WSAENETUNREACH";
			break;
		}

		case WSAENETRESET:
		{
			pString = "WSAENETRESET";
			break;
		}

		case WSAECONNABORTED:
		{
			pString = "WSAECONNABORTED";
			break;
		}

		case WSAECONNRESET:
		{
			pString = "WSAECONNRESET";
			break;
		}

		case WSAENOBUFS:
		{
			pString = "WSAENOBUFS";
			break;
		}

		case WSAEISCONN:
		{
			pString = "WSAEISCONN";
			break;
		}

		case WSAENOTCONN:
		{
			pString = "WSAENOTCONN";
			break;
		}

		case WSAESHUTDOWN:
		{
			pString = "WSAESHUTDOWN";
			break;
		}

		case WSAETOOMANYREFS:
		{
			pString = "WSAETOOMANYREFS";
			break;
		}

		case WSAETIMEDOUT:
		{
			pString = "WSAETIMEDOUT";
			break;
		}

		case WSAECONNREFUSED:
		{
			pString = "WSAECONNREFUSED";
			break;
		}

		case WSAELOOP:
		{
			pString = "WSAELOOP";
			break;
		}

		case WSAENAMETOOLONG:
		{
			pString = "WSAENAMETOOLONG";
			break;
		}

		case WSAEHOSTDOWN:
		{
			pString = "WSAEHOSTDOWN";
			break;
		}

		case WSAEHOSTUNREACH:
		{
			pString = "WSAEHOSTUNREACH";
			break;
		}

		case WSAENOTEMPTY:
		{
			pString = "WSAENOTEMPTY";
			break;
		}

		case WSAEPROCLIM:
		{
			pString = "WSAEPROCLIM";
			break;
		}

		case WSAEUSERS:
		{
			pString = "WSAEUSERS";
			break;
		}

		case WSAEDQUOT:
		{
			pString = "WSAEDQUOT";
			break;
		}

		case WSAESTALE:
		{
			pString = "WSAESTALE";
			break;
		}

		case WSAEREMOTE:
		{
			pString = "WSAEREMOTE";
			break;
		}

		case WSASYSNOTREADY:
		{
			pString = "WSASYSNOTREADY";
			break;
		}

		case WSAVERNOTSUPPORTED:
		{
			pString = "WSAVERNOTSUPPORTED";
			break;
		}

		case WSANOTINITIALISED:
		{
			pString = "WSANOTINITIALISED";
			break;
		}

		case WSAEDISCON:
		{
			pString = "WSAEDISCON";
			break;
		}

		case WSAENOMORE:
		{
			pString = "WSAENOMORE";
			break;
		}

		case WSAECANCELLED:
		{
			pString = "WSAECANCELLED";
			break;
		}

		case WSAEINVALIDPROCTABLE:
		{
			pString = "WSAEINVALIDPROCTABLE";
			break;
		}

		case WSAEINVALIDPROVIDER:
		{
			pString = "WSAEINVALIDPROVIDER";
			break;
		}

		case WSAEPROVIDERFAILEDINIT:
		{
			pString = "WSAEPROVIDERFAILEDINIT";
			break;
		}

		case WSASYSCALLFAILURE:
		{
			pString = "WSASYSCALLFAILURE";
			break;
		}

		case WSASERVICE_NOT_FOUND:
		{
			pString = "WSASERVICE_NOT_FOUND";
			break;
		}

		case WSATYPE_NOT_FOUND:
		{
			pString = "WSATYPE_NOT_FOUND";
			break;
		}

		case WSA_E_NO_MORE:
		{
			pString = "WSA_E_NO_MORE";
			break;
		}

		case WSA_E_CANCELLED:
		{
			pString = "WSA_E_CANCELLED";
			break;
		}

		case WSAEREFUSED:
		{
			pString = "WSAEREFUSED";
			break;
		}

		/* Authoritative Answer: Host not found */
		case WSAHOST_NOT_FOUND:
		{
			pString = "WSAHOST_NOT_FOUND";
			break;
		}

		/* Non-Authoritative: Host not found, or SERVERFAIL */
		case WSATRY_AGAIN:
		{
			pString = "WSATRY_AGAIN";
			break;
		}

		/* Non-recoverable errors, FORMERR, REFUSED, NOTIMP */
		case WSANO_RECOVERY:
		{
			pString = "WSANO_RECOVERY";
			break;
		}

		/* Valid name, no data record of requested type */
		case WSANO_DATA:
		{
			pString = "WSANO_DATA";
			break;
		}

// same error value as WSANO_DATA
//		/* no address, look for MX record */
//		case WSANO_ADDRESS:
//		{
//			pString = "WSANO_ADDRESS";
//			break;
//		}

		/* at least one Reserve has arrived */
		case WSA_QOS_RECEIVERS:
		{
			pString = "WSA_QOS_RECEIVERS";
			break;
		}

		/* at least one Path has arrived */
		case WSA_QOS_SENDERS:
		{
			pString = "WSA_QOS_SENDERS";
			break;
		}

		/* there are no senders */
		case WSA_QOS_NO_SENDERS:
		{
			pString = "WSA_QOS_NO_SENDERS";
			break;
		}

		/* there are no receivers */
		case WSA_QOS_NO_RECEIVERS:
		{
			pString = "WSA_QOS_NO_RECEIVERS";
			break;
		}

		/* Reserve has been confirmed */
		case WSA_QOS_REQUEST_CONFIRMED:
		{
			pString = "WSA_QOS_REQUEST_CONFIRMED";
			break;
		}

		/* error due to lack of resources */
		case WSA_QOS_ADMISSION_FAILURE:
		{
			pString = "WSA_QOS_ADMISSION_FAILURE";
			break;
		}

		/* rejected for administrative reasons - bad credentials */
		case WSA_QOS_POLICY_FAILURE:
		{
			pString = "WSA_QOS_POLICY_FAILURE";
			break;
		}

		/* unknown or conflicting style */
		case WSA_QOS_BAD_STYLE:
		{
			pString = "WSA_QOS_BAD_STYLE";
			break;
		}

		/* problem with some part of the filterspec or providerspecific
		 * buffer in general */
		 case WSA_QOS_BAD_OBJECT:
		{
			pString = "WSA_QOS_BAD_OBJECT";
			break;
		}

		/* problem with some part of the flowspec */
		case WSA_QOS_TRAFFIC_CTRL_ERROR:
		{
			pString = "WSA_QOS_TRAFFIC_CTRL_ERROR";
			break;
		}

		/* general error */
		case WSA_QOS_GENERIC_ERROR:
		{
			pString = "WSA_QOS_GENERIC_ERROR";
			break;
		}

		default:
		{
			DPFX(DPFPREP, 0, "Unknown WinSock error code %u/0x%lx", WinsockError, WinsockError );

			pString = "Unknown WinSock error";
			break;
		}
	}

	return	pString;
}
//**********************************************************************



#ifndef DPNBUILD_NOSERIALSP

//
// Make this function appear under the modem provider spew
//
#undef DPF_SUBCOMP
#define DPF_SUBCOMP	DN_SUBCOMP_MODEM

//**********************************************************************
// ------------------------------
// LclDisplayTAPIMessage - display TAPI Message contents
//
// Entry:		output type
//				error level
//				pointer to TAPI message
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "LclDisplayTAPIMessage"
void	LclDisplayTAPIMessage( DWORD ErrorLevel, const LINEMESSAGE *const pLineMessage )
{
	DPFX(DPFPREP,  ErrorLevel, "Message: hDevice: 0x%08x\tdwMessageID: 0x%08x\tdwCallbackInstance: 0x%p", pLineMessage->hDevice, pLineMessage->dwMessageID, pLineMessage->dwCallbackInstance );
	DPFX(DPFPREP,  ErrorLevel, "dwParam1: 0x%p\tdwParam2: 0x%p\tdwParam3: 0x%p", pLineMessage->dwParam1, pLineMessage->dwParam2, pLineMessage->dwParam3 );

	// what was the message?
	switch ( pLineMessage->dwMessageID )
	{
	    case LINE_ADDRESSSTATE:
	    {
	    	DPFX(DPFPREP,  ErrorLevel, "LINE_ADDRESSSTATE" );
	    	break;
	    }

	    case LINE_AGENTSPECIFIC:
	    {
	    	DPFX(DPFPREP,  ErrorLevel, "LINE_AGENTSPECIFIC" );
	    	break;
	    }

	    case LINE_AGENTSTATUS:
	    {
	    	DPFX(DPFPREP,  ErrorLevel, "LINE_AGENTSTATUS" );
	    	break;
	    }

	    case LINE_APPNEWCALL:
	    {
	    	DPFX(DPFPREP,  ErrorLevel, "LINE_APPNEWCALL" );
			DPFX(DPFPREP,  ErrorLevel, "Active line: 0x%08x\tCallback instance: 0x%p", pLineMessage->hDevice, pLineMessage->dwCallbackInstance );
	    	DPFX(DPFPREP,  ErrorLevel, "Line address: 0x%p\tNew handle: 0x%p\tPrivilege: 0x%p", pLineMessage->dwParam1, pLineMessage->dwParam2, pLineMessage->dwParam3 );

	    	DNASSERT( pLineMessage->dwParam3 == LINECALLPRIVILEGE_OWNER );
			DBG_CASSERT( sizeof( HCALL ) == sizeof( DWORD ) );
			DBG_CASSERT( sizeof( DWORD ) == sizeof( UINT ) );
			DNASSERT( pLineMessage->dwParam2 <= UINT_MAX );

			break;
	    }

	    case LINE_CALLINFO:
	    {
	    	DPFX(DPFPREP,  ErrorLevel, "LINE_CALLINFO" );
	    	break;
	    }

	    case LINE_CALLSTATE:
	    {
	    	DPFX(DPFPREP,  ErrorLevel, "LINE_CALLSTATE" );
	    	// what is the call state?
	    	switch ( pLineMessage->dwParam1 )
	    	{
	    		// The call is idle-no call actually exists.
	    		case LINECALLSTATE_IDLE:
	    		{
	    			DPFX(DPFPREP,  ErrorLevel, "LINECALLSTATE_IDLE" );
	    			break;
	    		}

	    		// The call is being offered to the station, signaling the arrival of a new call. In some environments, a call in the offering state does not automatically alert the user. Alerting is done by the switch instructing the line to ring; it does not affect any call states.
	    		case LINECALLSTATE_OFFERING:
	    		{
	    			DPFX(DPFPREP,  ErrorLevel, "LINECALLSTATE_OFFERING" );

	    			switch ( pLineMessage->dwParam2 )
	    			{
	    				// Indicates that the call is alerting at the current station (is accompanied by LINEDEVSTATE_RINGING messages), and if any application is set up to automatically answer, it may do so.
	    				// MSDN states that 0 is assumed to be LINEOFFERINGMODE_ACTIVE
	    				case 0:
	    				case LINEOFFERINGMODE_ACTIVE:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEOFFERINGMODE_ACTIVE" );
	    					break;
	    				}

	    				// Indicates that the call is being offered at more than one station, but the current station is not alerting (for example, it may be an attendant station where the offering status is advisory, such as blinking a light).
	    				case LINEOFFERINGMODE_INACTIVE:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEOFFERINGMODE_INACTIVE" );
	    					break;
	    				}

	    				default:
	    				{
	    					DNASSERT( FALSE );
	    					break;
	    				}
	    			}

	    			break;
	    		}

	    		// The call was offering and has been accepted. This indicates to other (monitoring) applications that the current owner application has claimed responsibility for answering the call. In ISDN, this also indicates that alerting to both parties has started.
	    		case LINECALLSTATE_ACCEPTED:
	    		{
	    			DPFX(DPFPREP,  ErrorLevel, "LINECALLSTATE_ACCEPTED" );
	    			break;
	    		}

	    		// The call is receiving a dial tone from the switch, which means that the switch is ready to receive a dialed number.
	    		case LINECALLSTATE_DIALTONE:
	    		{
	    			DPFX(DPFPREP,  ErrorLevel, "LINECALLSTATE_DIALTONE" );

	    			switch ( pLineMessage->dwParam2 )
	    			{
	    				// This is a "normal" dial tone, which typically is a continuous tone.
	    				case LINEDIALTONEMODE_NORMAL:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEDIALTONEMODE_NORMAL" );
	    					break;
	    				}

	    				// This is a special dial tone indicating that a certain condition is currently in effect.
	    				case LINEDIALTONEMODE_SPECIAL:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEDIALTONEMODE_SPECIAL" );
	    					break;
	    				}

	    				// This is an internal dial tone, as within a PBX.
	    				case LINEDIALTONEMODE_INTERNAL:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEDIALTONEMODE_INTERNAL" );
	    					break;
	    				}

	    				// This is an external (public network) dial tone.
	    				case LINEDIALTONEMODE_EXTERNAL:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEDIALTONEMODE_EXTERNAL" );
	    					break;
	    				}

	    				// The dial tone mode is currently unknown, but may become known later.
	    				case LINEDIALTONEMODE_UNKNOWN:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEDIALTONEMODE_UNKNOWN" );
	    					break;
	    				}

	    				// The dial tone mode is unavailable and cannot become known.
	    				case LINEDIALTONEMODE_UNAVAIL:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEDIALTONEMODE_UNAVAIL" );
	    					break;
	    				}

	    				default:
	    				{
	    					DNASSERT( FALSE );
	    					break;
	    				}
	    			}

	    			break;
	    		}

	    		// Destination address information (a phone number) is being sent to the switch over the call. Note that lineGenerateDigits does not place the line into the dialing state.
	    		case LINECALLSTATE_DIALING:
	    		{
	    			DPFX(DPFPREP,  ErrorLevel, "LINECALLSTATE_DIALING" );
	    			break;
	    		}

	    		// The call is receiving ringback from the called address. Ringback indicates that the other station has been reached and is being alerted.
	    		case LINECALLSTATE_RINGBACK:
	    		{
	    			DPFX(DPFPREP,  ErrorLevel, "LINECALLSTATE_RINGBACK" );
	    			break;
	    		}

	    		// The call is receiving a busy tone. Busy tone indicates that the call cannot be completedeither a circuit (trunk) or the remote party's station are in use.
	    		case LINECALLSTATE_BUSY:
	    		{
	    			DPFX(DPFPREP,  ErrorLevel, "LINECALLSTATE_BUSY" );

	    			switch ( pLineMessage->dwParam2 )
	    			{
	    				// The busy signal indicates that the called party's station is busy. This is usually signaled by means of a "normal" busy tone.
	    				case LINEBUSYMODE_STATION:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEBUSYMODE_STATION" );
	    					break;
	    				}

	    				// The busy signal indicates that a trunk or circuit is busy. This is usually signaled with a "long" busy tone.
	    				case LINEBUSYMODE_TRUNK:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEBUSYMODE_TRUNK" );
	    					break;
	    				}

	    				// The busy signal's specific mode is currently unknown, but may become known later.
	    				case LINEBUSYMODE_UNKNOWN:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEBUSYMODE_UNKNOWN" );
	    					break;
	    				}

	    				// The busy signal's specific mode is unavailable and cannot become known.
	    				case LINEBUSYMODE_UNAVAIL:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEBUSYMODE_UNAVAIL" );
	    					break;
	    				}

	    				default:
	    				{
	    					DNASSERT( FALSE );
	    					break;
	    				}
	    			}

	    			break;
	    		}

	    		// Special information is sent by the network. Special information is typically sent when the destination cannot be reached.
	    		case LINECALLSTATE_SPECIALINFO:
	    		{
	    			DPFX(DPFPREP,  ErrorLevel, "LINECALLSTATE_SPECIALINFO" );

	    			switch ( pLineMessage->dwParam2 )
	    			{
	    				// This special information tone precedes a "no circuit" or emergency announcement (trunk blockage category).
	    				case LINESPECIALINFO_NOCIRCUIT:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINESPECIALINFO_NOCIRCUIT" );
	    					break;
	    				}

	    				// This special information tone precedes a vacant number, AIS, Centrex number change and nonworking station, access code not dialed or dialed in error, or manual intercept operator message (customer irregularity category).
	    				case LINESPECIALINFO_CUSTIRREG:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINESPECIALINFO_CUSTIRREG" );
	    					break;
	    				}

	    				// This special information tone precedes a reorder announcement (equipment irregularity category).
	    				case LINESPECIALINFO_REORDER:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINESPECIALINFO_REORDER" );
	    					break;
	    				}

	    				// Specifics about the special information tone are currently unknown but may become known later.
	    				case LINESPECIALINFO_UNKNOWN:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINESPECIALINFO_UNKNOWN" );
	    					break;
	    				}

	    				// Specifics about the special information tone are unavailable and cannot become known.
	    				case LINESPECIALINFO_UNAVAIL:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINESPECIALINFO_UNAVAIL" );
	    					break;
	    				}

	    				default:
	    				{
	    					DNASSERT( FALSE );
	    					break;
	    				}
	    			}

	    			break;
	    		}

	    		// The call has been established and the connection is made. Information is able to flow over the call between the originating address and the destination address.
	    		case LINECALLSTATE_CONNECTED:
	    		{
	    			DPFX(DPFPREP,  ErrorLevel, "LINECALLSTATE_CONNECTED" );

	    			switch ( pLineMessage->dwParam2 )
	    			{
	    				// Indicates that the call is connected at the current station (the current station is a participant in the call).
	    				// case zero is supposed to be assumed 'Active'
	    				case 0:
	    				case LINECONNECTEDMODE_ACTIVE:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINECONNECTEDMODE_ACTIVE" );
	    					break;
	    				}

	    				// Indicates that the call is active at one or more other stations, but the current station is not a participant in the call.
	    				case LINECONNECTEDMODE_INACTIVE:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINECONNECTEDMODE_INACTIVE" );
	    					break;
	    				}

	    				// Indicates that the station is an active participant in the call, but that the remote party has placed the call on hold (the other party considers the call to be in the onhold state). Normally, such information is available only when both endpoints of the call fall within the same switching domain.
	    				case LINECONNECTEDMODE_ACTIVEHELD:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINECONNECTEDMODE_ACTIVEHELD" );
	    					break;
	    				}

	    				// Indicates that the station is not an active participant in the call, and that the remote party has placed the call on hold.
	    				case LINECONNECTEDMODE_INACTIVEHELD:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINECONNECTEDMODE_INACTIVEHELD" );
	    					break;
	    				}

	    				// Indicates that the service provider received affirmative notification that the call has entered the connected state (for example, through answer supervision or similar mechanisms).
	    				case LINECONNECTEDMODE_CONFIRMED:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINECONNECTEDMODE_CONFIRMED" );
	    					break;
	    				}
	    				default:
	    				{
	    					DNASSERT( FALSE );
	    					break;
	    				}
	    			}

	    			// note that we're connected
	    			DBG_CASSERT( sizeof( pLineMessage->hDevice ) == sizeof( HCALL ) );

	    			break;
	    		}

	    		// Dialing has completed and the call is proceeding through the switch or telephone network.
	    		case LINECALLSTATE_PROCEEDING:
	    		{
	    			DPFX(DPFPREP,  ErrorLevel, "LINECALLSTATE_PROCEEDING" );
	    			break;
	    		}

	    		// The call is on hold by the switch.
	    		case LINECALLSTATE_ONHOLD:
	    		{
	    			DPFX(DPFPREP,  ErrorLevel, "LINECALLSTATE_ONHOLD" );
	    			break;
	    		}

	    		// The call is currently a member of a multiparty conference call.
	    		case LINECALLSTATE_CONFERENCED:
	    		{
	    			DPFX(DPFPREP,  ErrorLevel, "LINECALLSTATE_CONFERENCED" );
	    			break;
	    		}

	    		// The call is currently on hold while it is being added to a conference.
	    		case LINECALLSTATE_ONHOLDPENDCONF:
	    		{
	    			DPFX(DPFPREP,  ErrorLevel, "LINECALLSTATE_ONHOLDPENDCONF" );
	    			break;
	    		}

	    		// The call is currently on hold awaiting transfer to another number.
	    		case LINECALLSTATE_ONHOLDPENDTRANSFER:
	    		{
	    			DPFX(DPFPREP,  ErrorLevel, "LINECALLSTATE_ONHOLDPENTRANSFER" );
	    			break;
	    		}

	    		// The remote party has disconnected from the call.
	    		case LINECALLSTATE_DISCONNECTED:
	    		{
	    			DPFX(DPFPREP,  ErrorLevel, "LINECALLSTATE_DISCONNECTED" );

	    			switch ( pLineMessage->dwParam2 )
	    			{

	    				// This is a "normal" disconnect request by the remote party, the call was terminated normally.
	    				case LINEDISCONNECTMODE_NORMAL:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEDISCONNECTMODE_NORMAL" );
	    					break;
	    				}

	    				// The reason for the disconnect request is unknown.
	    				case LINEDISCONNECTMODE_UNKNOWN:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEDISCONNECTMODE_UNKNOWN" );
	    					break;
	    				}

	    				// The remote user has rejected the call.
	    				case LINEDISCONNECTMODE_REJECT:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEDISCONNECTMODE_REJECT" );
	    					break;
	    				}

	    				// The call was picked up from elsewhere.
	    				case LINEDISCONNECTMODE_PICKUP:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEDISCONNECTMODE_PICKUP" );
	    					break;
	    				}

	    				// The call was forwarded by the switch.
	    				case LINEDISCONNECTMODE_FORWARDED:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEDISCONNECTMODE_FORWARDED" );
	    					break;
	    				}

	    				// The remote user's station is busy.
	    				case LINEDISCONNECTMODE_BUSY:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEDISCONNECTMODE_BUSY" );
	    					break;
	    				}

	    				// The remote user's station does not answer.
	    				case LINEDISCONNECTMODE_NOANSWER:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEDISCONNECTMODE_NOANSWER" );
	    					break;
	    				}

	    				// A dial tone was not detected within a service-provider defined timeout, at a point during dialing when one was expected (such as at a "W" in the dialable string). This can also occur without a service-provider-defined timeout period or without a value specified in the dwWaitForDialTone member of the LINEDIALPARAMS structure.
	    				case LINEDISCONNECTMODE_NODIALTONE:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEDISCONNECTMODE_NODIALTONE" );
	    					break;
	    				}

	    				// The destination address in invalid.
	    				case LINEDISCONNECTMODE_BADADDRESS:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEDISCONNECTMODE_BADADDRESS" );
	    					break;
	    				}

	    				// The remote user could not be reached.
	    				case LINEDISCONNECTMODE_UNREACHABLE:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEDISCONNECTMODE_UNREACHABLE" );
	    					break;
	    				}

	    				// The network is congested.
	    				case LINEDISCONNECTMODE_CONGESTION:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEDISCONNECTMODE_CONGESTION" );
	    					break;
	    				}

	    				// The remote user's station equipment is incompatible for the type of call requested.
	    				case LINEDISCONNECTMODE_INCOMPATIBLE:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEDISCONNECTMODE_INCOMPATIBLE" );
	    					break;
	    				}

	    				// The reason for the disconnect is unavailable and cannot become known later.
	    				case LINEDISCONNECTMODE_UNAVAIL:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEDISCONNECTMODE_UNAVAIL" );
	    					break;
	    				}

	    				default:
	    				{
	    					DNASSERT( FALSE );
	    					break;
	    				}
	    			}

	    			// note that we've disconnected
	    			DBG_CASSERT( sizeof( pLineMessage->hDevice ) == sizeof( HCALL ) );

	    			break;
	    		}

	    		// The state of the call is not known. This may be due to limitations of the call-progress detection implementation.
	    		case LINECALLSTATE_UNKNOWN:
	    		{
	    			DPFX(DPFPREP,  ErrorLevel, "LINECALLSTATE_UNKNOWN" );
	    			break;
	    		}
	    	}

	    	// what are our priveleges?
	    	switch ( pLineMessage->dwParam3 )
	    	{
	    		// no privilege change
	    		case 0:
	    		{
	    			break;
	    		}

	    		// we're now monitoring the call
	    		case LINECALLPRIVILEGE_MONITOR:
	    		{
	    			DPFX(DPFPREP,  ErrorLevel, "We're now monitoring the call" );
	    			break;
	    		}

	    		// we're now owning the call
	    		case LINECALLPRIVILEGE_OWNER:
	    		{
	    			DPFX(DPFPREP,  ErrorLevel, "We're now owner of the call" );
	    			break;
	    		}

	    		default:
	    		{
	    			// unknown privilege
	    			DNASSERT( FALSE );
	    			break;
	    		}
	    	}

	    	break;
	    }

	    case LINE_CLOSE:
	    {
	    	DPFX(DPFPREP,  ErrorLevel, "LINE_CLOSE" );
	    	break;
	    }

	    case LINE_DEVSPECIFIC:
	    {
	    	DPFX(DPFPREP,  ErrorLevel, "LINE_DEVSPECIFIC" );
	    	break;
	    }

	    case LINE_DEVSPECIFICFEATURE:
	    {
	    	DPFX(DPFPREP,  ErrorLevel, "LINE_DEVSPECIFICFEATURE" );
	    	break;
	    }

	    case LINE_GATHERDIGITS:
	    {
	    	DPFX(DPFPREP,  ErrorLevel, "LINE_GATHERDIGITS" );
	    	break;
	    }

	    case LINE_GENERATE:
	    {
	    	DPFX(DPFPREP,  ErrorLevel, "LINE_GENERATE" );
	    	break;
	    }

	    case LINE_LINEDEVSTATE:
	    {
	    	DPFX(DPFPREP,  ErrorLevel, "LINE_LINEDEVSTATE" );
	    	break;
	    }

	    case LINE_MONITORDIGITS:
	    {
	    	DPFX(DPFPREP,  ErrorLevel, "LINE_MONITORDIGITS" );
	    	break;
	    }

	    case LINE_MONITORMEDIA:
	    {
	    	DPFX(DPFPREP,  ErrorLevel, "LINE_MONITORMEDIA" );
	    	break;
	    }

	    case LINE_MONITORTONE:
	    {
	    	DPFX(DPFPREP,  ErrorLevel, "LINE_MONITORTONE" );
	    	break;
	    }

	    case LINE_REPLY:
	    {
	    	// dwDevice and dwParam3 are supposed to be zero
	    	DNASSERT( pLineMessage->hDevice == 0 );

	    	DPFX(DPFPREP,  ErrorLevel, "LINE_REPLY" );
			DPFX(DPFPREP,  ErrorLevel, "hDevice: 0x%08x\tdwMessageID: 0x%08x\tdwCallbackInstance: 0x%p", pLineMessage->hDevice, pLineMessage->dwMessageID, pLineMessage->dwCallbackInstance );
	    	DPFX(DPFPREP,  ErrorLevel, "dwParam1: 0x%p\tdwParam2: 0x%p\tdwParam3: 0x%p", pLineMessage->dwParam1, pLineMessage->dwParam2, pLineMessage->dwParam3 );

	    	break;
	    }

	    case LINE_REQUEST:
	    {
	    	DPFX(DPFPREP,  ErrorLevel, "LINE_REQUEST" );
	    	break;
	    }

	    default:
	    {
			DPFX(DPFPREP, 0, "Unknown TAPI message %u/0x%lx", pLineMessage->dwMessageID, pLineMessage->dwMessageID );
	    	DNASSERT( FALSE );
	    	break;
	    }
	}

	return;
}
//**********************************************************************

#endif // ! DPNBUILD_NOSERIALSP

#endif	// DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\dnnbqueue.h ===
/*==========================================================================
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	   dnnbqueue.h
 *  Content:	DirectPlay implementations of OS NBQueue functions
 *
 *  History:
 *  Date		By		Reason
 *  ====		==		======
 *  10/31/2001	vanceo	Adapted from ntos\inc\ex.h and ntos\ex\nbqueue.c.
 *
 ***************************************************************************/

#ifndef __DNNBQUEUE_H__
#define __DNNBQUEUE_H__



//
// A non-blocking queue is a singly linked list of queue entries with a head
// pointer and a tail pointer.  The head and tail pointers use sequenced
// pointers as do next links in the entries themselves.  The queueing
// discipline is FIFO.  New entries are inserted at the tail of the list and
// current entries are removed from the front of the list.
//
// Non-blocking queues require an SList containing a DNNBQUEUE_BLOCK for each
// entry to be tracked by the queue, plus one extra for bookkeeping.  The
// initialization and insert functions will assert (or access violate) if no
// pre-allocated DNNBQUEUE_BLOCKs are found in the SList.  The DNNBQUEUE_BLOCK
// objects should just be cast directly to a DNSLIST_ENTRY when populating the
// SList.
//
// It is important to remember that the duration a DNNBQUEUE_BLOCK is used for
// tracking purproses will differ from any particular entry's duration in the
// queue.  Therefore pre-allocated DNNBQUEUE_BLOCKs should not come from the
// same memory blocks as the entries being queued, unless it is guaranteed that
// the non-blocking queue will be de-initialized before any of the entries are
// freed.
//

typedef struct _DNNBQUEUE_BLOCK
{
	ULONG64		Next;
	ULONG64		Data;
} DNNBQUEUE_BLOCK, * PDNNBQUEUE_BLOCK;



//
// NBQueue access methods
//

PVOID WINAPI DNInitializeNBQueueHead(DNSLIST_HEADER * const pSlistHeadFreeNodes);

void WINAPI DNDeinitializeNBQueueHead(PVOID const pvQueueHeader);

void WINAPI DNInsertTailNBQueue(PVOID const pvQueueHeader, const ULONG64 Value);

ULONG64 WINAPI DNRemoveHeadNBQueue(PVOID const pvQueueHeader);

BOOL WINAPI DNIsNBQueueEmpty(PVOID const pvQueueHeader);

void WINAPI DNAppendListNBQueue(PVOID const pvQueueHeader,
								DNSLIST_ENTRY * const pSlistEntryAppend,
								INT_PTR iValueOffset);




#endif // __DNNBQUEUE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\dnslist.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dnslist.cpp
 *  Content:    DirectPlay implementations of OS SLIST functions
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  10/30/2001	masonb	Created
 *  11/07/2001	vanceo	Added InterlockedPushListSList and made DNInitializeSListHead return value on Win64
 *
 ***************************************************************************/

#include "dncmni.h"

//
// We build separate NT and 9x binaries, but even in the NT binary we can't be sure the system has the
// SLIST functions available since they weren't on Win2k.  The only place we can be sure that the SLIST
// functions are available is on 64-bit NT platforms.
//
// Single thread builds don't need interlocked operations, so we don't include use the assembly here.
//

#ifndef DPNBUILD_ONLYONETHREAD

#if defined(_X86_)

__declspec(naked)
DNSLIST_ENTRY* WINAPI DNInterlockedPopEntrySList(DNSLIST_HEADER * ListHead)
{
	__asm 
    {
		push ebx
		push ebp

		mov ebp, dword ptr [esp+0x0C]     ; Place ListHead in ebp
		mov edx, dword ptr [ebp+0x04]     ; Place Depth and Sequence into edx
		mov eax, dword ptr [ebp+0x00]     ; Place Next into eax
redo:
		or eax, eax                       ; Test eax against zero
		jz done                           ; If 0 return
		lea ecx, dword ptr [edx-01]       ; ecx = ((Sequence << 16) | Depth) - 1, Depth goes down by one
		mov ebx, dword ptr [eax]          ; Move Next->Next into ebx
#ifdef DPNBUILD_ONLYONEPROCESSOR
		cmpxchg8b qword ptr [ebp]         ; Exchange Next out in favor of Next->Next along with Depth and Sequence values
#else // ! DPNBUILD_ONLYONEPROCESSOR
		lock cmpxchg8b qword ptr [ebp]    ; Exchange Next out in favor of Next->Next along with Depth and Sequence values
#endif // ! DPNBUILD_ONLYONEPROCESSOR
		jne redo
done:
		pop ebp
		pop ebx
#ifdef WINCE
		ret
#else // !WINCE
		ret 4
#endif // WINCE
	}
}

__declspec(naked)
DNSLIST_ENTRY* WINAPI DNInterlockedPushEntrySList(DNSLIST_HEADER * ListHead, DNSLIST_ENTRY * ListEntry)
{
	__asm 
	{
		push ebx
		push ebp

		mov ebp, dword ptr [esp+0x0C]       ; Place ListHead in ebp
		mov ebx, dword ptr [esp+0x10]       ; Place ListEntry in ebx
		mov edx, dword ptr [ebp+0x04]       ; put ListHead Depth and Sequence into edx
		mov eax, dword ptr [ebp+0x00]       ; put ListHead->Next into eax
redo:
		mov dword ptr [ebx], eax            ; set ListEntry->Next to ListHead->Next
		lea ecx, dword ptr [edx+0x00010001] ; add 1 to the Depth and Sequence
#ifdef DPNBUILD_ONLYONEPROCESSOR
		cmpxchg8b qword ptr [ebp]           ; atomically exchange ListHead with ListEntry if ListHead hasn't changed
#else // ! DPNBUILD_ONLYONEPROCESSOR
		lock cmpxchg8b qword ptr [ebp]      ; atomically exchange ListHead with ListEntry if ListHead hasn't changed
#endif // ! DPNBUILD_ONLYONEPROCESSOR
		jne redo                            ; if the compare failed, try again

		pop ebp
		pop ebx
#ifdef WINCE
		ret
#else // !WINCE
		ret 8
#endif // WINCE
	}
}

__declspec(naked)
DNSLIST_ENTRY* WINAPI DNInterlockedFlushSList(DNSLIST_HEADER * ListHead)
{
	__asm
	{
		push ebx
		push ebp

		xor ebx, ebx					  ; Zero out ebx
		mov ebp, dword ptr [esp+0x0C]     ; Place ListHead in ebp
		mov edx, dword ptr [ebp+0x04]     ; Place Depth and Sequence into edx
		mov eax, dword ptr [ebp+0x00]     ; Place Next into eax
redo:
		or eax, eax                       ; Test eax against zero
		jz done                           ; If 0 return
		mov ecx, edx                      ; Place Depth and Sequence into ecx
		mov cx, bx                        ; Zero out Depth
#ifdef DPNBUILD_ONLYONEPROCESSOR
		cmpxchg8b qword ptr [ebp]         ; atomically exchange ListHead with ListEntry if ListHead hasn't changed
#else // ! DPNBUILD_ONLYONEPROCESSOR
		lock cmpxchg8b qword ptr [ebp]    ; atomically exchange ListHead with ListEntry if ListHead hasn't changed
#endif // ! DPNBUILD_ONLYONEPROCESSOR
		jne redo                          ; if the compare failed, try again
done:
		pop ebp
		pop ebx
#ifdef WINCE
		ret
#else // !WINCE
		ret 4
#endif // WINCE
	}
}

__declspec(naked)
DNSLIST_ENTRY* WINAPI DNInterlockedPushListSList(DNSLIST_HEADER * ListHead, DNSLIST_ENTRY * List, DNSLIST_ENTRY * ListEnd, USHORT Count)
{
	__asm 
	{
		push	ebx							; save nonvolatile registers
		push	ebp							;

		mov		ebp, dword ptr [esp+0x0C]	; save ListHead address
		mov		ebx, dword ptr [esp+0x10]	; save List address
		mov		edx,[ebp] + 4				; get current sequence number
		mov		eax,[ebp] + 0				; get current next link
Epshl10:
		mov		ecx, [esp+0x14]				; Fetch address of ListEnd
		mov		[ecx], eax					; Store new forward pointer in tail entry
		lea		ecx, [edx+0x010000]			; increment sequence number
		add		ecx, [esp+0x18]				; Add in new count to create correct depth
#ifdef DPNBUILD_ONLYONEPROCESSOR
		cmpxchg8b qword ptr [ebp]			; compare and exchange
#else // ! DPNBUILD_ONLYONEPROCESSOR
		lock cmpxchg8b qword ptr [ebp]		; compare and exchange
#endif // ! DPNBUILD_ONLYONEPROCESSOR
		jnz		short Epshl10				; if z clear, exchange failed

		pop		ebp							; restore nonvolatile registers
		pop		ebx							;
#ifdef WINCE
		ret
#else // !WINCE
		ret 16
#endif // WINCE
	}
}

#elif defined(_ARM_) || defined(_AMD64_) || defined(_IA64_)

// For now, ARM, IA64 and AMD64 do not have assembly versions of these, and it's important to
// note that while our custom implementation *is* interlocked on those platforms, it is *not* atomic.
// This means that the list won't get corrupted, but the items will not be transferred from the
// source list to the target list in a single interlocked operation.  Additionally, the items from the
// source list will be added in reverse order.
DNSLIST_ENTRY* WINAPI DNInterlockedPushListSList(DNSLIST_HEADER * ListHead, DNSLIST_ENTRY * List, DNSLIST_ENTRY * ListEnd, USHORT Count)
{
	DNSLIST_ENTRY* pslEntryCurrent;
	DNSLIST_ENTRY* pslEntryNext;
	DNSLIST_ENTRY* pslEntryReturn = NULL;

	pslEntryCurrent = List;
	do
	{
		pslEntryNext = pslEntryCurrent->Next;

		DNSLIST_ENTRY* pslEntryTemp = DNInterlockedPushEntrySList(ListHead, pslEntryCurrent);
		if (pslEntryReturn == NULL)
		{
			pslEntryReturn = pslEntryTemp;
		}
		pslEntryCurrent = pslEntryNext;
	}
	while (pslEntryCurrent != NULL);

	return pslEntryReturn;
}

#else
#error ("No other platform known")
#endif // Platform

#endif // ! DPNBUILD_ONLYONETHREAD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\dneterrors.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DNetErrors.h
 *  Content:    Function for expanding DNet errors to debug output
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   12/04/98  johnkan	Created
 *@@END_MSINTERNAL
 *
 ***************************************************************************/


#ifndef	__DNET_ERRORS_H__
#define	__DNET_ERRORS_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//
// enumerated values to determine error class
typedef	enum
{
	EC_DPLAY8,
#ifndef DPNBUILD_NOSERIALSP
	EC_TAPI,
#endif // ! DPNBUILD_NOSERIALSP
	EC_WIN32,
	EC_WINSOCK

	// no entry for TAPI message output

} EC_TYPE;

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifdef DBG

// ErrorLevel = DPF level for outputting errors
// DNErrpr = DirectNet error code

#define	DisplayString( ErrorLevel, String )			LclDisplayString( ErrorLevel, String )
#define	DisplayErrorCode( ErrorLevel, Win32Error )	LclDisplayError( EC_WIN32, ErrorLevel, Win32Error )
#define	DisplayDNError( ErrorLevel, DNError )		LclDisplayError( EC_DPLAY8, ErrorLevel, DNError )
#define	DisplayWinsockError( ErrorLevel, WinsockError )	LclDisplayError( EC_WINSOCK, ErrorLevel, WinsockError )
#ifndef DPNBUILD_NOSERIALSP
#define	DisplayTAPIError( ErrorLevel, TAPIError )	LclDisplayError( EC_TAPI, ErrorLevel, TAPIError )
#define	DisplayTAPIMessage( ErrorLevel, pTAPIMessage )	LclDisplayTAPIMessage( ErrorLevel, pTAPIMessage )
#endif // ! DPNBUILD_NOSERIALSP

#else // DBG

#define	DisplayString( ErrorLevel, String )
#define	DisplayErrorCode( ErrorLevel, Win32Error )
#define	DisplayDNError( ErrorLevel, DNError )
#define	DisplayWinsockError( ErrorLevel, WinsockError )
#ifndef DPNBUILD_NOSERIALSP
#define	DisplayTAPIError( ErrorLevel, TAPIError )
#define	DisplayTAPIMessage( ErrorLevel, pTAPIMessage )
#endif // ! DPNBUILD_NOSERIALSP

#endif // DBG

//**********************************************************************
// Structure definitions
//**********************************************************************

#ifndef DPNBUILD_NOSERIALSP
typedef struct linemessage_tag	LINEMESSAGE;
#endif // ! DPNBUILD_NOSERIALSP

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

#ifdef __cplusplus
extern	"C"	{
#endif // __cplusplus

#ifdef DBG
// don't call this function directly, use the 'DisplayDNError' macro
void	LclDisplayError( EC_TYPE ErrorType, DWORD ErrorLevel, HRESULT ErrorCode );
void	LclDisplayString( DWORD ErrorLevel, char *pString );
#ifndef DPNBUILD_NOSERIALSP
void	LclDisplayTAPIMessage( DWORD ErrorLevel, const LINEMESSAGE *const pLineMessage );
#endif // ! DPNBUILD_NOSERIALSP
#endif // DBG

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __DNET_ERRORS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\dnnbqueue.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	   dnnbqueue.cpp
 *  Content:	DirectPlay implementations of OS NBQueue functions
 *
 *  History:
 *  Date		By		Reason
 *  ====		==		======
 *	04/24/2000	davec	Created nbqueue.c
 *	10/31/2001	vanceo	Converted for use in DPlay source
 *
 ***************************************************************************/


#include "dncmni.h"




// Until this gets ported, we won't use the NBQueue functions if WINCE is
// defined.
// Also, for DPNBUILD_ONLYONETHREAD builds we want to use the fallback code
// because the critical sections get compiled away and we're left with a simple
// queue.
//=============================================================================
#if ((defined(WINCE)) || (defined(DPNBUILD_ONLYONETHREAD)))
//=============================================================================

//
// For now, the Windows CE NBQueue is just a critical section protected list.
// On DPNBUILD_ONLYONETHREAD builds, we use the same structure because
// the critical section will be compiled away.
//
typedef struct _DNNBQUEUE_HEADER
{
	DNSLIST_HEADER *	pSlistHeadFreeNodes;	// pointer to Slist containing free nodes, the user must add 1 DNNBQUEUE_BLOCK for every item to be in the queue + 1 extra
	DNNBQUEUE_BLOCK *	pHead;
	DNNBQUEUE_BLOCK *	pTail;
#ifndef DPNBUILD_ONLYONETHREAD
	DNCRITICAL_SECTION	csLock;
#endif // !DPNBUILD_ONLYONETHREAD
} DNNBQUEUE_HEADER, *PDNNBQUEUE_HEADER;




#undef DPF_MODNAME
#define DPF_MODNAME "DNInitializeNBQueueHead"
//=============================================================================
// DNInitializeNBQueueHead
//-----------------------------------------------------------------------------
//
// Description:	   This function creates and initializes a non-blocking queue
//				header.  The specified SList must contain at least one pre-
//				allocated DNNBQUEUE_BLOCK.
//
// Arguments:
//	DNSLIST_HEADER * pSlistHeadFreeNodes	- Pointer to list with free nodes.
//
// Returns: Pointer to queue header memory if successful, NULL if failed.
//=============================================================================
PVOID WINAPI DNInitializeNBQueueHead(DNSLIST_HEADER * const pSlistHeadFreeNodes)
{
	DNNBQUEUE_HEADER *	pQueueHeader;


	DNASSERT(pSlistHeadFreeNodes != NULL);
	pQueueHeader = (DNNBQUEUE_HEADER*) DNMalloc(sizeof(DNNBQUEUE_HEADER));
	if (pQueueHeader != NULL)
	{
		pQueueHeader->pSlistHeadFreeNodes	= pSlistHeadFreeNodes;
		pQueueHeader->pHead					= NULL;
		pQueueHeader->pTail					= NULL;

		if (! DNInitializeCriticalSection(&pQueueHeader->csLock))
		{
			DNFree(pQueueHeader);
			pQueueHeader = NULL;
		}
		else
		{
			DebugSetCriticalSectionRecursionCount(&pQueueHeader->csLock, 0);
		}
	}

	return pQueueHeader;
} // DNInitializeNBQueueHead



#undef DPF_MODNAME
#define DPF_MODNAME "DNDeinitializeNBQueueHead"
//=============================================================================
// DNDeinitializeNBQueueHead
//-----------------------------------------------------------------------------
//
// Description:	   This function cleans up a previously initialized non-
//				blocking queue header.
//
// Arguments:
//	PVOID pvQueueHeader		- Pointer to queue header.
//
// Returns: None.
//=============================================================================
void WINAPI DNDeinitializeNBQueueHead(PVOID const pvQueueHeader)
{
	DNNBQUEUE_HEADER *	pQueueHeader;


	DNASSERT(pvQueueHeader != NULL);
	pQueueHeader = (DNNBQUEUE_HEADER*) pvQueueHeader;

	DNASSERT(pQueueHeader->pHead == NULL);
	DNASSERT(pQueueHeader->pTail == NULL);
	DNDeleteCriticalSection(&pQueueHeader->csLock);

	DNFree(pQueueHeader);
	pQueueHeader = NULL;
} // DNDeinitializeNBQueueHead



#undef DPF_MODNAME
#define DPF_MODNAME "DNInsertTailNBQueue"
//=============================================================================
// DNInsertTailNBQueue
//-----------------------------------------------------------------------------
//
// Description:	   This function inserts the specified value at the tail of the
//				specified non-blocking queue.
//
// Arguments:
//	PVOID pvQueueHeader		- Pointer to queue header.
//	ULONG64 Value			- Value to insert.
//
// Returns: None.
//=============================================================================
void WINAPI DNInsertTailNBQueue(PVOID const pvQueueHeader, const ULONG64 Value)
{
	DNNBQUEUE_HEADER *	pQueueHeader;
	DNNBQUEUE_BLOCK *	pQueueNode;


	DNASSERT(pvQueueHeader != NULL);
	pQueueHeader = (DNNBQUEUE_HEADER*) pvQueueHeader;

	DNASSERT(Value != 0);

	//
	// Retrieve a queue node from the SLIST owned by the specified non-blocking
	// queue.  If this fails, we will assert or crash.
	//
	DBG_CASSERT(sizeof(DNNBQUEUE_BLOCK) >= sizeof(DNSLIST_ENTRY));
	pQueueNode = (DNNBQUEUE_BLOCK*) DNInterlockedPopEntrySList(pQueueHeader->pSlistHeadFreeNodes);
	DNASSERT(pQueueNode != NULL);

	pQueueNode->Next = NULL;
	pQueueNode->Data = Value;

	DNEnterCriticalSection(&pQueueHeader->csLock);

	if (pQueueHeader->pTail == NULL)
	{
		DNASSERT(pQueueHeader->pHead == NULL);
		pQueueHeader->pHead = pQueueNode;
	}
	else
	{
		DNASSERT(pQueueHeader->pTail->Next == NULL);
		pQueueHeader->pTail->Next = (ULONG64) pQueueNode;
	}
	pQueueHeader->pTail = pQueueNode;

	DNLeaveCriticalSection(&pQueueHeader->csLock);
} // DNInsertTailNBQueue



#undef DPF_MODNAME
#define DPF_MODNAME "DNRemoveHeadNBQueue"
//=============================================================================
// DNRemoveHeadNBQueue
//-----------------------------------------------------------------------------
//
// Description:	  This function removes a queue entry from the head of the
//				specified non-blocking queue and returns its value.
//
// Arguments:
//	PVOID pvQueueHeader		- Pointer to queue header.
//
// Returns: First value retrieved, or 0 if none.
//=============================================================================
ULONG64 WINAPI DNRemoveHeadNBQueue(PVOID const pvQueueHeader)
{
	DNNBQUEUE_HEADER *	pQueueHeader;
	ULONG64				ReturnValue;
	DNNBQUEUE_BLOCK *	pNode;


	DNASSERT(pvQueueHeader != NULL);
	pQueueHeader = (DNNBQUEUE_HEADER*) pvQueueHeader;

	DNEnterCriticalSection(&pQueueHeader->csLock);

	pNode = pQueueHeader->pHead;
	if (pNode != NULL)
	{
		DNASSERT(pQueueHeader->pTail != NULL);
		pQueueHeader->pHead = (DNNBQUEUE_BLOCK*) pNode->Next;
		if (pQueueHeader->pHead == NULL)
		{
			DNASSERT(pQueueHeader->pTail == pNode);
			pQueueHeader->pTail = NULL;
		}

		DNLeaveCriticalSection(&pQueueHeader->csLock);

		ReturnValue = pNode->Data;

		//
		// Return the node that was removed for the list by inserting the node in
		// the associated SLIST.
		//
		DNInterlockedPushEntrySList(pQueueHeader->pSlistHeadFreeNodes,
								  (DNSLIST_ENTRY*) pNode);
	}
	else
	{
		DNASSERT(pQueueHeader->pTail == NULL);
		DNLeaveCriticalSection(&pQueueHeader->csLock);

		ReturnValue = 0;
	}

	return ReturnValue;
} // DNRemoveHeadNBQueue




#undef DPF_MODNAME
#define DPF_MODNAME "DNIsNBQueueEmpty"
//=============================================================================
// DNIsNBQueueEmpty
//-----------------------------------------------------------------------------
//
// Description:	  This function returns TRUE if the queue contains no items at
//				this instant, FALSE if there are items.
//
// Arguments:
//	PVOID pvQueueHeader		- Pointer to queue header.
//
// Returns: TRUE if queue is empty, FALSE otherwise.
//=============================================================================
BOOL WINAPI DNIsNBQueueEmpty(PVOID const pvQueueHeader)
{
	DNNBQUEUE_HEADER *	pQueueHeader;
	BOOL				fReturn;


	DNASSERT(pvQueueHeader != NULL);
	pQueueHeader = (DNNBQUEUE_HEADER*) pvQueueHeader;

	DNEnterCriticalSection(&pQueueHeader->csLock);
	fReturn = (pQueueHeader->pHead == NULL) ? TRUE : FALSE;
	DNLeaveCriticalSection(&pQueueHeader->csLock);

	return fReturn;
} // DNIsNBQueueEmpty




#undef DPF_MODNAME
#define DPF_MODNAME "DNAppendListNBQueue"
//=============================================================================
// DNAppendListNBQueue
//-----------------------------------------------------------------------------
//
// Description:	   This function appends a queue of items to the tail of the
//				specified non-blocking queue.  The queue of items to be added
//				must be linked in the form of an SLIST, where the actual
//				ULONG64 value to be queued is the DNSLIST_ENTRY pointer minus
//				iValueOffset.
//
// Arguments:
//	PVOID pvQueueHeader					- Pointer to queue header.
//	DNSLIST_ENTRY * pSlistEntryAppend	- Pointer to first item to append.
//	INT_PTR iValueOffset				- How far DNSLIST_ENTRY field is offset
//
// Returns: None.
//=============================================================================
void WINAPI DNAppendListNBQueue(PVOID const pvQueueHeader,
								DNSLIST_ENTRY * const pSlistEntryAppend,
								INT_PTR iValueOffset)
{
	DNNBQUEUE_HEADER *	pQueueHeader;
	DNSLIST_ENTRY *		pCurrent;
	DNNBQUEUE_BLOCK *	pFirstQueueNode;
	DNNBQUEUE_BLOCK *	pLastQueueNode;
	DNNBQUEUE_BLOCK *	pCurrentQueueNode;


	DNASSERT(pvQueueHeader != NULL);
	pQueueHeader = (DNNBQUEUE_HEADER*) pvQueueHeader;

	DNASSERT(pSlistEntryAppend != NULL);

	//
	// Retrieve queue nodes for each value to add from the SLIST owned by the
	// specified non-blocking queue.  If this fails, we will assert or crash.
	//
	pFirstQueueNode = NULL;
	pCurrent = pSlistEntryAppend;
	do
	{
		DBG_CASSERT(sizeof(DNNBQUEUE_BLOCK) >= sizeof(DNSLIST_ENTRY));
		pCurrentQueueNode = (DNNBQUEUE_BLOCK*) DNInterlockedPopEntrySList(pQueueHeader->pSlistHeadFreeNodes);
		DNASSERT(pCurrentQueueNode != NULL);

		//
		// Initialize the queue node next pointer and value.
		//
		pCurrentQueueNode->Next		= NULL;
		pCurrentQueueNode->Data		= (ULONG64) (pCurrent - iValueOffset);

		//
		// Link the item as appropriate.
		//
		if (pFirstQueueNode == NULL)
		{
			pFirstQueueNode = pCurrentQueueNode;
			pLastQueueNode = pCurrentQueueNode;
		}
		else
		{
			pLastQueueNode->Next = (ULONG64) pCurrentQueueNode;
			pLastQueueNode = pCurrentQueueNode;
		}

		pCurrent = pCurrent->Next;
	}
	while (pCurrent != NULL);


	//
	// Lock the queue and append the list.
	//

	DNEnterCriticalSection(&pQueueHeader->csLock);

	if (pQueueHeader->pTail == NULL)
	{
		DNASSERT(pQueueHeader->pHead == NULL);
		pQueueHeader->pHead = pFirstQueueNode;
	}
	else
	{
		DNASSERT(pQueueHeader->pTail->Next == NULL);
		pQueueHeader->pTail->Next = (ULONG64) pFirstQueueNode;
	}
	pQueueHeader->pTail = pLastQueueNode;

	DNLeaveCriticalSection(&pQueueHeader->csLock);
} // DNAppendListNBQueue



//=============================================================================
#else // ! WINCE and ! DPNBUILD_ONLYONETHREAD
//=============================================================================

// Forward declare the generic node structure.
typedef struct _DNNBQUEUE_NODE	DNNBQUEUE_NODE, *PDNNBQUEUE_NODE;


//
// Define inline functions to pack and unpack pointers in the platform
// specific non-blocking queue pointer structure, as well as
// InterlockedCompareExchange64.
//

//-----------------------------------------------------------------------------
#if defined(_AMD64_)
//-----------------------------------------------------------------------------

typedef union _DNNBQUEUE_POINTER
{
	struct
	{
		LONG64	Node : 48;
		LONG64	Count : 16;
	};
	LONG64	Data;
} DNNBQUEUE_POINTER, * PDNNBQUEUE_POINTER;


__inline VOID PackNBQPointer(IN PDNNBQUEUE_POINTER Entry, IN PDNNBQUEUE_NODE Node)
{
	Entry->Node = (LONG64)Node;
	return;
}

__inline PDNNBQUEUE_NODE UnpackNBQPointer(IN PDNNBQUEUE_POINTER Entry)
{
	return (PDNNBQUEUE_NODE)((LONG64)(Entry->Node));
}

//
// For whatever reason we need to redirect through an inline, the compiler doesn't
// like the casting when calling it directly through a macro.
//
inline LONG64 _DNInterlockedCompareExchange64(volatile PVOID * Destination, PVOID Exchange, PVOID Comperand)
	{ return reinterpret_cast<LONG64>(InterlockedCompareExchangePointer(Destination, Exchange, Comperand)); }

#define DNInterlockedCompareExchange64(Destination, Exchange, Comperand) \
	_DNInterlockedCompareExchange64((volatile PVOID*) (Destination), reinterpret_cast<void*>(Exchange), reinterpret_cast<void*>(Comperand))

//-----------------------------------------------------------------------------
#elif defined(_IA64_)
//-----------------------------------------------------------------------------

typedef union _DNNBQUEUE_POINTER
{
	struct
	{
		LONG64	Node : 45;
		LONG64	Region : 3;
		LONG64	Count : 16;
	};
	LONG64	Data;
} DNNBQUEUE_POINTER, *PDNNBQUEUE_POINTER;


__inline VOID PackNBQPointer(IN PDNNBQUEUE_POINTER Entry, IN PDNNBQUEUE_NODE Node)
{
	Entry->Node = (LONG64)Node;
	Entry->Region = (LONG64)Node >> 61;
	return;
}
__inline PDNNBQUEUE_NODE UnpackNBQPointer(IN PDNNBQUEUE_POINTER Entry)
{
	LONG64 Value;

	Value = Entry->Node & 0x1fffffffffffffff;
	Value |= Entry->Region << 61;
	return (PDNNBQUEUE_NODE)(Value);
}
//
// For whatever reason we need to redirect through an inline, the compiler doesn't
// like the casting when calling it directly through a macro.
//
inline LONG64 _DNInterlockedCompareExchange64(volatile PVOID * Destination, PVOID Exchange, PVOID Comperand)
	{ return reinterpret_cast<LONG64>(InterlockedCompareExchangePointer(Destination, Exchange, Comperand)); }
#define DNInterlockedCompareExchange64(Destination, Exchange, Comperand) \
	_DNInterlockedCompareExchange64((volatile PVOID*) (Destination), reinterpret_cast<void*>(Exchange), reinterpret_cast<void*>(Comperand))

//-----------------------------------------------------------------------------
#elif defined(_X86_)
//-----------------------------------------------------------------------------

typedef union _DNNBQUEUE_POINTER
{
	struct
	{
		LONG	Count;
		LONG	Node;
	};
	LONG64	Data;
} DNNBQUEUE_POINTER, *PDNNBQUEUE_POINTER;


__inline VOID PackNBQPointer(IN PDNNBQUEUE_POINTER Entry, IN PDNNBQUEUE_NODE Node)
{
	Entry->Node = (LONG)Node;
	return;
}

__inline PDNNBQUEUE_NODE UnpackNBQPointer(IN PDNNBQUEUE_POINTER Entry)
{
	return (PDNNBQUEUE_NODE)(Entry->Node);
}

#define DNInterlockedCompareExchange64(Destination, Exchange, Comperand) \
	xInterlockedCompareExchange64(Destination, &(Exchange), &(Comperand))

__declspec(naked)
LONG64 __fastcall xInterlockedCompareExchange64(IN OUT LONG64 volatile * Destination, IN PLONG64 Exchange, IN PLONG64 Comperand)
{
	__asm 
	{
		// Save nonvolatile registers and read the exchange and comperand values.
		push ebx					; save nonvolatile registers
		push ebp					;
		mov ebp, ecx				; set destination address
		mov ebx, [edx]				; get exchange value
		mov ecx, [edx] + 4			;
		mov edx, [esp] + 12			; get comperand address
		mov eax, [edx]				; get comperand value
		mov edx, [edx] + 4			;

   lock cmpxchg8b qword ptr [ebp]	; compare and exchange

		// Restore nonvolatile registers and return result in edx:eax.
		pop ebp						; restore nonvolatile registers
		pop ebx						;

		ret 4
	}
}

//-----------------------------------------------------------------------------
#else
//-----------------------------------------------------------------------------

#error "no target architecture"

//-----------------------------------------------------------------------------
#endif
//-----------------------------------------------------------------------------


struct _DNNBQUEUE_NODE
{
	DNNBQUEUE_POINTER	Next;
	ULONG64				Value;
};

typedef struct _DNNBQUEUE_HEADER
{
	DNSLIST_HEADER *	pSlistHeadFreeNodes;	// pointer to Slist containing free nodes, the user must add 1 DNNBQUEUE_BLOCK for every item to be in the queue + 1 extra
	DNNBQUEUE_POINTER	Head;
	DNNBQUEUE_POINTER	Tail;
} DNNBQUEUE_HEADER, *PDNNBQUEUE_HEADER;





/*
//=============================================================================
// Globals
//=============================================================================
#if ((defined(DBG)) && (defined(_X86_)))
DNCRITICAL_SECTION		g_csValidation;
DWORD					g_dwEntries;
#endif // DBG and _X86_
*/





#undef DPF_MODNAME
#define DPF_MODNAME "DNInitializeNBQueueHead"
//=============================================================================
// DNInitializeNBQueueHead
//-----------------------------------------------------------------------------
//
// Description:	   This function creates and initializes a non-blocking queue
//				header.  The specified SList must contain at least one pre-
//				allocated DNNBQUEUE_BLOCK.
//
// Arguments:
//	DNSLIST_HEADER * pSlistHeadFreeNodes	- Pointer to list with free nodes.
//
// Returns: Pointer to queue header memory if successful, NULL if failed.
//=============================================================================
PVOID WINAPI DNInitializeNBQueueHead(DNSLIST_HEADER * const pSlistHeadFreeNodes)
{
	DNNBQUEUE_HEADER *	pQueueHeader;
	DNNBQUEUE_NODE *	pQueueNode;


	DNASSERT(pSlistHeadFreeNodes != NULL);
	pQueueHeader = (DNNBQUEUE_HEADER*) DNMalloc(sizeof(DNNBQUEUE_HEADER));
	if (pQueueHeader != NULL)
	{
		pQueueHeader->pSlistHeadFreeNodes = pSlistHeadFreeNodes;

		pQueueNode = (DNNBQUEUE_NODE*) DNInterlockedPopEntrySList(pQueueHeader->pSlistHeadFreeNodes);
		DNASSERT(pQueueNode != NULL);


		//
		// Initialize the initial root node's next pointer and value.
		//
		pQueueNode->Next.Data	= 0;
		pQueueNode->Value		= 0;

		//
		// Initialize the head and tail pointers in the queue header.
		//
		PackNBQPointer(&pQueueHeader->Head, pQueueNode);
		pQueueHeader->Head.Count	= 0;
		PackNBQPointer(&pQueueHeader->Tail, pQueueNode);
		pQueueHeader->Tail.Count	= 0;

	/*
#if ((defined(DBG)) && (defined(_X86_)))
		DNInitializeCriticalSection(&g_csValidation);
		g_dwEntries = 1;
#endif // DBG and _X86_
	*/
	}

	return pQueueHeader;
} // DNInitializeNBQueueHead




#undef DPF_MODNAME
#define DPF_MODNAME "DNDeinitializeNBQueueHead"
//=============================================================================
// DNDeinitializeNBQueueHead
//-----------------------------------------------------------------------------
//
// Description:	   This function cleans up a previously initialized non-
//				blocking queue header.
//
// Arguments:
//	PVOID pvQueueHeader		- Pointer to queue header.
//
// Returns: None.
//=============================================================================
void WINAPI DNDeinitializeNBQueueHead(PVOID const pvQueueHeader)
{
	DNNBQUEUE_HEADER *	pQueueHeader;
	DNNBQUEUE_NODE *	pQueueNode;
#ifdef DBG
	DNNBQUEUE_NODE *	pQueueNodeCompare;
#endif // DBG


	DNASSERT(pvQueueHeader != NULL);
	pQueueHeader = (DNNBQUEUE_HEADER*) pvQueueHeader;

	//
	// There should be just the root node left.
	//
	pQueueNode = UnpackNBQPointer(&pQueueHeader->Head);
#ifdef DBG
	DNASSERT(pQueueNode != NULL);
	pQueueNodeCompare = UnpackNBQPointer(&pQueueHeader->Tail);
	DNASSERT(pQueueNode == pQueueNodeCompare);
#endif // DBG

	//
	// Return the node that was removed for the list by
	// inserting the node in the associated SLIST.
	//
	DNInterlockedPushEntrySList(pQueueHeader->pSlistHeadFreeNodes,
								(DNSLIST_ENTRY*) pQueueNode);

	DNFree(pQueueHeader);
	pQueueHeader = NULL;
} // DNDeinitializeNBQueueHead





#undef DPF_MODNAME
#define DPF_MODNAME "DNInsertTailNBQueue"
//=============================================================================
// DNInsertTailNBQueue
//-----------------------------------------------------------------------------
//
// Description:	   This function inserts the specified value at the tail of the
//				specified non-blocking queue.
//
// Arguments:
//	PVOID pvQueueHeader		- Pointer to queue header.
//	ULONG64 Value			- Value to insert.
//
// Returns: None.
//=============================================================================
void WINAPI DNInsertTailNBQueue(PVOID const pvQueueHeader, const ULONG64 Value)
{
	DNNBQUEUE_HEADER *	pQueueHeader;
	DNNBQUEUE_POINTER	Insert;
	DNNBQUEUE_POINTER	Next;
	DNNBQUEUE_NODE *	pNextNode;
	DNNBQUEUE_NODE *	pQueueNode;
	DNNBQUEUE_POINTER	Tail;
	DNNBQUEUE_NODE *	pTailNode;


	DNASSERT(pvQueueHeader != NULL);
	pQueueHeader = (DNNBQUEUE_HEADER*) pvQueueHeader;

	DNASSERT(Value != 0);

	//
	// Retrieve a queue node from the SLIST owned by the specified non-blocking
	// queue.  If this fails, we will assert or crash.
	//
	DBG_CASSERT(sizeof(DNNBQUEUE_NODE) >= sizeof(DNSLIST_ENTRY));
	pQueueNode = (DNNBQUEUE_NODE*) DNInterlockedPopEntrySList(pQueueHeader->pSlistHeadFreeNodes);
	DNASSERT(pQueueNode != NULL);


	//
	// Initialize the queue node next pointer and value.
	//
	pQueueNode->Next.Data	= 0;
	pQueueNode->Value		= Value;

	//
	// The following loop is executed until the specified entry can be safely
	// inserted at the tail of the specified non-blocking queue.
	//
	do
	{
		//
		// Read the tail queue pointer and the next queue pointer of the tail
		// queue pointer making sure the two pointers are coherent.
		//
		Tail.Data = *((volatile LONG64 *)(&pQueueHeader->Tail.Data));
		pTailNode = UnpackNBQPointer(&Tail);
		Next.Data = *((volatile LONG64 *)(&pTailNode->Next.Data));
		pQueueNode->Next.Count = Tail.Count + 1;
		if (Tail.Data == *((volatile LONG64 *)(&pQueueHeader->Tail.Data)))
		{
			//
			// If the tail is pointing to the last node in the list, then
			// attempt to insert the new node at the end of the list.
			// Otherwise, the tail is not pointing to the last node in the list
			// and an attempt is made to move the tail pointer to the next
			// node.
			//

			pNextNode = UnpackNBQPointer(&Next);
			if (pNextNode == NULL)
			{
				PackNBQPointer(&Insert, pQueueNode);
				Insert.Count = Next.Count + 1;
				if (DNInterlockedCompareExchange64(&pTailNode->Next.Data,
													Insert.Data,
													Next.Data) == Next.Data)
				{
					break;
				}
			}
			else
			{
				PackNBQPointer(&Insert, pNextNode);
				Insert.Count = Tail.Count + 1;
				DNInterlockedCompareExchange64(&pQueueHeader->Tail.Data,
												Insert.Data,
												Tail.Data);
			}
		}
	}
	while (TRUE);


	//
	// Attempt to move the tail to the new tail node.
	//
	PackNBQPointer(&Insert, pQueueNode);
	Insert.Count = Tail.Count + 1;
	DNInterlockedCompareExchange64(&pQueueHeader->Tail.Data,
									Insert.Data,
									Tail.Data);
} // DNInsertTailNBQueue




#undef DPF_MODNAME
#define DPF_MODNAME "DNRemoveHeadNBQueue"
//=============================================================================
// DNRemoveHeadNBQueue
//-----------------------------------------------------------------------------
//
// Description:	  This function removes a queue entry from the head of the
//				specified non-blocking queue and returns its value.
//
// Arguments:
//	PVOID pvQueueHeader		- Pointer to queue header.
//
// Returns: First value retrieved, or 0 if none.
//=============================================================================
ULONG64 WINAPI DNRemoveHeadNBQueue(PVOID const pvQueueHeader)
{
	DNNBQUEUE_HEADER *	pQueueHeader;
	ULONG64				ReturnValue;
	DNNBQUEUE_POINTER	Head;
	PDNNBQUEUE_NODE		pHeadNode;
	DNNBQUEUE_POINTER	Insert;
	DNNBQUEUE_POINTER	Next;
	PDNNBQUEUE_NODE		pNextNode;
	DNNBQUEUE_POINTER	Tail;
	PDNNBQUEUE_NODE		pTailNode;


	DNASSERT(pvQueueHeader != NULL);
	pQueueHeader = (DNNBQUEUE_HEADER*) pvQueueHeader;

	//
	// The following loop is executed until an entry can be removed from
	// the specified non-blocking queue or until it can be determined that
	// the queue is empty.
	//
	do
	{
		//
		// Read the head queue pointer, the tail queue pointer, and the
		// next queue pointer of the head queue pointer making sure the
		// three pointers are coherent.
		//
		Head.Data = *((volatile LONG64 *)(&pQueueHeader->Head.Data));
		Tail.Data = *((volatile LONG64 *)(&pQueueHeader->Tail.Data));
		pHeadNode = UnpackNBQPointer(&Head);
		Next.Data = *((volatile LONG64 *)(&pHeadNode->Next.Data));
		if (Head.Data == *((volatile LONG64 *)(&pQueueHeader->Head.Data)))
		{
			//
			// If the queue header node is equal to the queue tail node,
			// then either the queue is empty or the tail pointer is falling
			// behind. Otherwise, there is an entry in the queue that can
			// be removed.
			//
			pNextNode = UnpackNBQPointer(&Next);
			pTailNode = UnpackNBQPointer(&Tail);
			if (pHeadNode == pTailNode)
			{
				//
				// If the next node of head pointer is NULL, then the queue
				// is empty. Otherwise, attempt to move the tail forward.
				//
				if (pNextNode == NULL)
				{
					ReturnValue = 0;
					break;
				}
				else
				{
					PackNBQPointer(&Insert, pNextNode);
					Insert.Count = Tail.Count + 1;
					DNInterlockedCompareExchange64(&pQueueHeader->Tail.Data,
													Insert.Data,
													Tail.Data);
				}
			}
			else
			{
				//
				// There is an entry in the queue that can be removed.
				//
				ReturnValue = pNextNode->Value;
				PackNBQPointer(&Insert, pNextNode);
				Insert.Count = Head.Count + 1;
				if (DNInterlockedCompareExchange64(&pQueueHeader->Head.Data,
													Insert.Data,
													Head.Data) == Head.Data)
				{
					//
					// Return the node that was removed for the list by
					// inserting the node in the associated SLIST.
					//
					DNInterlockedPushEntrySList(pQueueHeader->pSlistHeadFreeNodes,
												(DNSLIST_ENTRY*) pHeadNode);

					break;
				}
			}
		}
	}
	while (TRUE);

	return ReturnValue;
} // DNRemoveHeadNBQueue




#undef DPF_MODNAME
#define DPF_MODNAME "DNIsNBQueueEmpty"
//=============================================================================
// DNIsNBQueueEmpty
//-----------------------------------------------------------------------------
//
// Description:	  This function returns TRUE if the queue contains no items at
//				this instant, FALSE if there are items.
//
// Arguments:
//	PVOID pvQueueHeader		- Pointer to queue header.
//
// Returns: TRUE if queue is empty, FALSE otherwise.
//=============================================================================
BOOL WINAPI DNIsNBQueueEmpty(PVOID const pvQueueHeader)
{
	DNNBQUEUE_HEADER *	pQueueHeader;
	BOOL				fReturn;
	DNNBQUEUE_POINTER	Head;
	PDNNBQUEUE_NODE		pHeadNode;
	DNNBQUEUE_POINTER	Insert;
	DNNBQUEUE_POINTER	Next;
	PDNNBQUEUE_NODE		pNextNode;
	DNNBQUEUE_POINTER	Tail;
	PDNNBQUEUE_NODE		pTailNode;


	DNASSERT(pvQueueHeader != NULL);
	pQueueHeader = (DNNBQUEUE_HEADER*) pvQueueHeader;

	//
	// The following loop is executed until it can be determined that the queue
	// is empty or contains at least one item.
	//
	do
	{
		//
		// Read the head queue pointer, the tail queue pointer, and the
		// next queue pointer of the head queue pointer making sure the
		// three pointers are coherent.
		//
		Head.Data = *((volatile LONG64 *)(&pQueueHeader->Head.Data));
		Tail.Data = *((volatile LONG64 *)(&pQueueHeader->Tail.Data));
		pHeadNode = UnpackNBQPointer(&Head);
		Next.Data = *((volatile LONG64 *)(&pHeadNode->Next.Data));
		if (Head.Data == *((volatile LONG64 *)(&pQueueHeader->Head.Data)))
		{
			//
			// If the queue header node is equal to the queue tail node,
			// then either the queue is empty or the tail pointer is falling
			// behind. Otherwise, there is an entry in the queue that can
			// be removed.
			//
			pNextNode = UnpackNBQPointer(&Next);
			pTailNode = UnpackNBQPointer(&Tail);
			if (pHeadNode == pTailNode)
			{
				//
				// If the next node of head pointer is NULL, then the queue
				// is empty. Otherwise, attempt to move the tail forward.
				//
				if (pNextNode == NULL)
				{
					fReturn = TRUE;
					break;
				}
				else
				{
					PackNBQPointer(&Insert, pNextNode);
					Insert.Count = Tail.Count + 1;
					DNInterlockedCompareExchange64(&pQueueHeader->Tail.Data,
													Insert.Data,
													Tail.Data);
				}
			}
			else
			{
				//
				// There is an entry in the queue.
				//
				fReturn = FALSE;
				break;
			}
		}
	}
	while (TRUE);

	return fReturn;
} // DNIsNBQueueEmpty




#undef DPF_MODNAME
#define DPF_MODNAME "DNAppendListNBQueue"
//=============================================================================
// DNAppendListNBQueue
//-----------------------------------------------------------------------------
//
// Description:	   This function appends a queue of items to the tail of the
//				specified non-blocking queue.  The queue of items to be added
//				must be linked in the form of an SLIST, where the actual
//				ULONG64 value to be queued is the DNSLIST_ENTRY pointer minus
//				iValueOffset.
//
// Arguments:
//	PVOID pvQueueHeader					- Pointer to queue header.
//	DNSLIST_ENTRY * pSlistEntryAppend	- Pointer to first item to append.
//	INT_PTR iValueOffset				- How far DNSLIST_ENTRY field is offset
//											from start of value.
//
// Returns: None.
//=============================================================================
void WINAPI DNAppendListNBQueue(PVOID const pvQueueHeader,
								DNSLIST_ENTRY * const pSlistEntryAppend,
								INT_PTR iValueOffset)
{
	DNNBQUEUE_HEADER *	pQueueHeader;
	DNSLIST_ENTRY *		pCurrent;
	DNNBQUEUE_POINTER	Insert;
	DNNBQUEUE_POINTER	Next;
	DNNBQUEUE_NODE *	pNextNode;
	DNNBQUEUE_NODE *	pFirstQueueNode;
	DNNBQUEUE_NODE *	pLastQueueNode;
	DNNBQUEUE_NODE *	pCurrentQueueNode;
	DNNBQUEUE_POINTER	Tail;
	DNNBQUEUE_NODE *	pTailNode;


	DNASSERT(pvQueueHeader != NULL);
	pQueueHeader = (DNNBQUEUE_HEADER*) pvQueueHeader;

	DNASSERT(pSlistEntryAppend != NULL);

	//
	// Retrieve queue nodes for each value to add from the SLIST owned by the
	// specified non-blocking queue.  If this fails, we will assert or crash.
	//
	pFirstQueueNode = NULL;
	pCurrent = pSlistEntryAppend;
	do
	{
		DBG_CASSERT(sizeof(DNNBQUEUE_NODE) >= sizeof(DNSLIST_ENTRY));
		pCurrentQueueNode = (DNNBQUEUE_NODE*) DNInterlockedPopEntrySList(pQueueHeader->pSlistHeadFreeNodes);
		DNASSERT(pCurrentQueueNode != NULL);

		//
		// Initialize the queue node next pointer and value.
		//
		pCurrentQueueNode->Next.Data	= 0;
		pCurrentQueueNode->Value		= (ULONG64) (pCurrent - iValueOffset);

		//
		// Link the item as appropriate.
		//
		if (pFirstQueueNode == NULL)
		{
			pFirstQueueNode = pCurrentQueueNode;
			pLastQueueNode = pCurrentQueueNode;
		}
		else
		{
			PackNBQPointer(&pLastQueueNode->Next, pCurrentQueueNode);
			pLastQueueNode = pCurrentQueueNode;
		}

		pCurrent = pCurrent->Next;
	}
	while (pCurrent != NULL);


	//
	// The following loop is executed until the specified entries can be safely
	// inserted at the tail of the specified non-blocking queue.
	//
	do
	{
		//
		// Read the tail queue pointer and the next queue pointer of the tail
		// queue pointer making sure the two pointers are coherent.
		//
		Tail.Data = *((volatile LONG64 *)(&pQueueHeader->Tail.Data));
		pTailNode = UnpackNBQPointer(&Tail);
		Next.Data = *((volatile LONG64 *)(&pTailNode->Next.Data));
		pFirstQueueNode->Next.Count = Tail.Count + 1;
		if (Tail.Data == *((volatile LONG64 *)(&pQueueHeader->Tail.Data)))
		{
			//
			// If the tail is pointing to the last node in the list, then
			// attempt to insert the new nodes at the end of the list.
			// Otherwise, the tail is not pointing to the last node in the list
			// and an attempt is made to move the tail pointer to the next
			// node.
			//

			pNextNode = UnpackNBQPointer(&Next);
			if (pNextNode == NULL)
			{
				PackNBQPointer(&Insert, pFirstQueueNode);
				Insert.Count = Next.Count + 1;
				if (DNInterlockedCompareExchange64(&pTailNode->Next.Data,
													Insert.Data,
													Next.Data) == Next.Data)
				{
					break;
				}
			}
			else
			{
				PackNBQPointer(&Insert, pNextNode);
				Insert.Count = Tail.Count + 1;
				DNInterlockedCompareExchange64(&pQueueHeader->Tail.Data,
												Insert.Data,
												Tail.Data);
			}
		}
	}
	while (TRUE);


	//
	// Attempt to move the tail to the new tail node.
	//
	PackNBQPointer(&Insert, pLastQueueNode);
	Insert.Count = Tail.Count + 1;
	DNInterlockedCompareExchange64(&pQueueHeader->Tail.Data,
									Insert.Data,
									Tail.Data);
} // DNAppendListNBQueue



//=============================================================================
#endif // ! WINCE and ! DPNBUILD_ONLYONETHREAD
//=============================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\dnslist.h ===
/*==========================================================================
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dnslist.h
 *  Content:    DirectPlay implementations of OS SLIST functions
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  10/30/2001	masonb	Created
 *  11/07/2001	vanceo	Added InterlockedPushListSList and made DNInitializeSListHead return value on Win64
 *
 ***************************************************************************/

#ifndef __DNSLIST_H__
#define __DNSLIST_H__

// We build separate NT and 9x binaries, but even in the NT binary we can't be sure the system has the
// SLIST functions available since they weren't on Win2k.  The only place we can be sure that the SLIST
// functions are available is on 64-bit NT platforms.
// We don't supply a DNQueryDepthSList method because not all platforms can support it.

// SINGLE_LIST_ENTRY is defined in winnt.h and contains only a Next pointer 
// to another SINGLE_LIST_ENTRY
#if defined(WINCE) || defined(DPNBUILD_ONLYONETHREAD)
#define SLIST_ENTRY SINGLE_LIST_ENTRY
#endif // WINCE or DPNBUILD_ONLYONETHREAD

#define DNSLIST_ENTRY SLIST_ENTRY

#ifdef DPNBUILD_ONLYONETHREAD
#ifndef XBOX_ON_DESKTOP
typedef struct _SLIST_HEADER 
{
	DNSLIST_ENTRY	Next;
} SLIST_HEADER;
#endif // ! XBOX_ON_DESKTOP
#else // ! DPNBUILD_ONLYONETHREAD
#ifdef WINCE
#ifdef _X86_
typedef union _SLIST_HEADER {
    ULONGLONG Alignment;
    struct {
        DNSLIST_ENTRY Next;
        WORD   Depth;
        WORD   Sequence;
    };
} SLIST_HEADER;
#elif _ARM_
typedef struct _SLIST_HEADER 
{
	DNSLIST_ENTRY	Next;
} SLIST_HEADER;
#endif // _X86_ or _ARM_
#endif // WINCE
#endif // ! DPNBUILD_ONLYONETHREAD

#define DNSLIST_HEADER SLIST_HEADER



#ifdef DPNBUILD_ONLYONETHREAD

// Single thread builds don't need the operations to be interlocked.

#define DNInitializeSListHead(head) (head)->Next.Next = NULL

inline DNSLIST_ENTRY* DNInterlockedPopEntrySList(DNSLIST_HEADER * ListHead)
{
	DNSLIST_ENTRY* pslEntryReturn;

	
	pslEntryReturn = ListHead->Next.Next;
	if (pslEntryReturn != NULL)
	{
		ListHead->Next.Next = pslEntryReturn->Next;
	}

	return pslEntryReturn;
}

inline DNSLIST_ENTRY* DNInterlockedPushEntrySList(DNSLIST_HEADER * ListHead, DNSLIST_ENTRY * ListEntry)
{
	DNSLIST_ENTRY* pslEntryReturn;


	pslEntryReturn = ListHead->Next.Next;
	ListEntry->Next = pslEntryReturn;
	ListHead->Next.Next = ListEntry;

	return pslEntryReturn;
}

inline DNSLIST_ENTRY* DNInterlockedFlushSList(DNSLIST_HEADER * ListHead)
{
	DNSLIST_ENTRY* pslEntryReturn;


	pslEntryReturn = ListHead->Next.Next;
	ListHead->Next.Next = NULL;

	return pslEntryReturn;
}

inline DNSLIST_ENTRY* DNInterlockedPushListSList(DNSLIST_HEADER * ListHead, DNSLIST_ENTRY * List, DNSLIST_ENTRY * ListEnd, USHORT Count)
{
	DNSLIST_ENTRY* pslEntryReturn;


	pslEntryReturn = ListHead->Next.Next;
	ListEnd->Next = pslEntryReturn;
	ListHead->Next.Next = List;

	return pslEntryReturn;
}

#else // ! DPNBUILD_ONLYONETHREAD


#if defined(_WIN64)

// _WIN64 has always had these available, so just use them directly
#define DNInitializeSListHead				InitializeSListHead
#define DNInterlockedPopEntrySList			InterlockedPopEntrySList
#define DNInterlockedPushEntrySList			InterlockedPushEntrySList
#define DNInterlockedFlushSList				InterlockedFlushSList

#elif defined(WINCE) && defined(_ARM_)

#define InterlockedPushList \
        ((void *(*)(void *pHead, void *pItem))(PUserKData+0x398))
#define InterlockedPopList \
        ((void *(*)(void *pHead))(PUserKData+0x380))

#define DNInitializeSListHead(head) (head)->Next.Next = NULL
#define DNInterlockedPopEntrySList (DNSLIST_ENTRY*)InterlockedPopList
#define DNInterlockedPushEntrySList (DNSLIST_ENTRY*)InterlockedPushList
#define DNInterlockedFlushSList(head) (DNSLIST_ENTRY*)DNInterlockedExchange((LONG*)(head), 0)

#elif defined(_X86_)

#define DNInitializeSListHead(ListHead) (ListHead)->Alignment = 0
DNSLIST_ENTRY* WINAPI DNInterlockedPopEntrySList(DNSLIST_HEADER * ListHead);
DNSLIST_ENTRY* WINAPI DNInterlockedPushEntrySList(DNSLIST_HEADER * ListHead, DNSLIST_ENTRY * ListEntry);
DNSLIST_ENTRY* WINAPI DNInterlockedFlushSList(DNSLIST_HEADER * ListHead);

#else
#error("Unknown platform")
#endif // Platform


// Unfortunately no platform has this exposed to user-mode.
//
// For now, ARM, IA64 and AMD64 do not have assembly versions of these, and it's important to
// note that while our custom implementation *is* interlocked on those platforms, it is *not* atomic.
// This means that the list won't get corrupted, but the items will not be transferred from the
// source list to the target list in a single interlocked operation.  Additionally, the items from the
// source list will be added in reverse order.
DNSLIST_ENTRY* WINAPI DNInterlockedPushListSList(DNSLIST_HEADER * ListHead, DNSLIST_ENTRY * List, DNSLIST_ENTRY * ListEnd, USHORT Count);


#endif // ! DPNBUILD_ONLYONETHREAD


#endif // __DNSLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\fixedpool.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       fixedpool.h
 *  Content:	fixed size pool manager
 *
 *  History:
 *   Date		By		Reason
 *   ======		==		======
 *  07-21-2001	masonb	Created
 ***************************************************************************/

#ifndef _FIXEDPOOL_H_
#define _FIXEDPOOL_H_

#include "CallStack.h"
#include "dnslist.h"

/***************************************************************************
 *
 * USAGE NOTES:
 * 
 * - This is a generic fixed pool.  It allows to reuse items once you have 
 *   allocated them so that you can save the time normally used allocating
 *   and freeing.  
 * - This pool may be used with classes, but you should be aware that the
 *   class' constructor and destructor will not be called.  This pool also
 *   will not work on classes that inherit from a class that has virtual 
 *   functions that are not pure virtuals (ie interfaces are okay).
 *
 * IMPLEMENTATION NOTES:
 *
 * - This pool is non-invasive.  In other words it does not utilize any of 
 *   the memory space alloted to the item itself to maintain its state.
 * - The pool can hold a maximum of sizeof(WORD) = 65535 items due to its
 *   reliance on SLISTs.
 * - An element will be on either the Available or InUse queue.  The InUse
 *   queue is used only in debug for reporting memory leaks.
 *
 ***************************************************************************/

typedef BOOL (*FN_BLOCKALLOC)(void * pvItem, void * pvContext);
typedef VOID (*FN_BLOCKGET)(void * pvItem, void * pvContext);
typedef VOID (*FN_BLOCKRELEASE)(void * pvItem);
typedef VOID (*FN_BLOCKDEALLOC)(void *pvItem);

class CFixedPool
{
public:


	struct FIXED_POOL_ITEM
	{
		DNSLIST_ENTRY	slist;		// Link to other elements
#ifdef DBG
		CFixedPool* 	pThisPool;	// This is used to ensure that items are returned to the correct pool (debug builds only)
		CCallStack		callstack;  // size=12 pointers
#else // !DBG
		VOID*			pAlignPad;	// To stay heap aligned we need an even number of pointers (SLIST is one)
#endif // DBG
	};

	BOOL Initialize(DWORD				dwElementSize,		// size of blocks in pool
					FN_BLOCKALLOC		pfnBlockAlloc,		// fn called for each new alloc
					FN_BLOCKGET			pfnBlockGet,		// fn called each time block used
					FN_BLOCKRELEASE		pfnBlockRelease,	// fn called each time block released
					FN_BLOCKDEALLOC		pfnBlockDeAlloc		// fn called before releasing mem
					);

	VOID DeInitialize();

#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
	DWORD Preallocate( DWORD dwCount, PVOID pvContext );
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL

	VOID* Get( PVOID pvContext = NULL );
	VOID Release(VOID* pvItem);

	DWORD GetInUseCount();

private:
	FN_BLOCKALLOC		m_pfnBlockAlloc;
	FN_BLOCKGET     	m_pfnBlockGet;
	FN_BLOCKRELEASE		m_pfnBlockRelease;
	FN_BLOCKDEALLOC 	m_pfnBlockDeAlloc;

	DWORD				m_dwItemSize;
	DNSLIST_HEADER		m_slAvailableElements;

	BOOL				m_fInitialized;

#ifdef DBG
	void 			DumpLeaks();
	DNSLIST_ENTRY*		m_pInUseElements;
#ifndef DPNBUILD_ONLYONETHREAD
	DNCRITICAL_SECTION	m_csInUse;
#endif // !DPNBUILD_ONLYONETHREAD
	LONG				m_lAllocated;
#endif // DBG

	LONG				m_lInUse;
};


#endif	// _FIXEDPOOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\fixedpool.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       fixedpool.cpp
 *  Content:	fixed size pool manager
 *
 *  History:
 *   Date		By		Reason
 *   ======		==		======
 *  07-21-2001	masonb	Created
 *  10-16-2001	vanceo	Tweaked release locking and freed memory if Alloc function fails
 *  02-22-2002	simonpow Removed c'tor and d'tor, which weren't consistently being called
 ***************************************************************************/

#include "dncmni.h"


#undef DPF_MODNAME
#define	DPF_MODNAME	"CFixedPool::Initialize"
BOOL CFixedPool::Initialize(DWORD dwElementSize, 
							FN_BLOCKALLOC	pfnBlockAlloc, 
							FN_BLOCKGET		pfnBlockGet, 
							FN_BLOCKRELEASE pfnBlockRelease, 
							FN_BLOCKDEALLOC pfnBlockDeAlloc)
{

	// Ensure that we stay heap aligned for SLISTs
#ifdef _WIN64
	DBG_CASSERT(sizeof(FIXED_POOL_ITEM) % 16 == 0);
#else // !_WIN64
	DBG_CASSERT(sizeof(FIXED_POOL_ITEM) % 8 == 0);
#endif // _WIN64

#ifdef DBG
	if (!DNInitializeCriticalSection(&m_csInUse))
	{
		DPFERR("Failed initializing pool critical section");
		m_fInitialized = FALSE;
		return FALSE;
	}
	m_pInUseElements = NULL;
#endif // DBG

	DNInitializeSListHead(&m_slAvailableElements);

	m_pfnBlockAlloc = pfnBlockAlloc;
	m_pfnBlockGet = pfnBlockGet;
	m_pfnBlockRelease = pfnBlockRelease;
	m_pfnBlockDeAlloc = pfnBlockDeAlloc;
	m_dwItemSize = dwElementSize;

#ifdef DBG
	m_lAllocated = 0;
#endif // DBG
	m_lInUse = 0;
	m_fInitialized = TRUE;

	return TRUE;
}

#undef DPF_MODNAME
#define	DPF_MODNAME	"CFixedPool::DeInitialize"
VOID CFixedPool::DeInitialize()
{
	FIXED_POOL_ITEM* pItem;
	DNSLIST_ENTRY* pslEntry;

	if (m_fInitialized == FALSE)
	{
		return;
	}

	// Clean up entries sitting in the pool
	pslEntry = DNInterlockedPopEntrySList(&m_slAvailableElements);
	while(pslEntry != NULL)
	{
		pItem = CONTAINING_RECORD(pslEntry, FIXED_POOL_ITEM, slist);

		if (m_pfnBlockDeAlloc != NULL)
		{
			(*m_pfnBlockDeAlloc)(pItem + 1);
		}
		DNFree(pItem);

#ifdef DBG
		DNInterlockedDecrement(&m_lAllocated);
		DNASSERT(m_lAllocated >=0);
#endif // DBG

		pslEntry = DNInterlockedPopEntrySList(&m_slAvailableElements);
	}

#ifdef DBG
	DumpLeaks();
	DNDeleteCriticalSection(&m_csInUse);
#endif // DBG

	m_fInitialized = FALSE;
}


#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL

#undef DPF_MODNAME
#define	DPF_MODNAME	"CFixedPool::Preallocate"
DWORD CFixedPool::Preallocate( DWORD dwCount, PVOID pvContext )
{
	DWORD dwAllocated;
	FIXED_POOL_ITEM* pItem;

	DNASSERT(m_fInitialized == TRUE);

	for(dwAllocated = 0; dwAllocated < dwCount; dwAllocated++)
	{
		pItem = (FIXED_POOL_ITEM*)DNMalloc(sizeof(FIXED_POOL_ITEM) + m_dwItemSize);
		if (pItem == NULL)
		{
			DPFERR("Out of memory allocating new item for pool");
			return NULL;
		}

		if ((m_pfnBlockAlloc != NULL) && !(*m_pfnBlockAlloc)(pItem + 1, pvContext))
		{
			DPFERR("Alloc function returned FALSE allocating new item for pool");

			// Can't stick the new item as available in the pool since pool assumes Alloc has
			// succeeded when it's in the pool.
			DNFree(pItem);
			break;
		}

#ifdef DBG
		DNInterlockedIncrement(&m_lAllocated);
#endif // DBG

		DNInterlockedPushEntrySList(&m_slAvailableElements, &pItem->slist);
	}

	return dwAllocated;
}

#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL


#undef DPF_MODNAME
#define	DPF_MODNAME	"CFixedPool::Get"
VOID* CFixedPool::Get( PVOID pvContext )
{
	FIXED_POOL_ITEM* pItem;
	DNSLIST_ENTRY* pslEntry;

	DNASSERT(m_fInitialized == TRUE);

	pslEntry = DNInterlockedPopEntrySList(&m_slAvailableElements);
	if (pslEntry == NULL)
	{
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
		DPFX(DPFPREP, 0, "No more items in pool!");
		DNASSERTX(! "No more items in pool!", 2);
		return NULL;
#else // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
		pItem = (FIXED_POOL_ITEM*)DNMalloc(sizeof(FIXED_POOL_ITEM) + m_dwItemSize);
		if (pItem == NULL)
		{
			DPFERR("Out of memory allocating new item for pool!");
			return NULL;
		}

		if ((m_pfnBlockAlloc != NULL) && !(*m_pfnBlockAlloc)(pItem + 1, pvContext))
		{
			DPFERR("Alloc function returned FALSE allocating new item for pool!");

			// Can't stick the new item as available in the pool since pool assumes Alloc has
			// succeeded when it's in the pool.
			DNFree(pItem);
			return NULL;
		}

#ifdef DBG
		DNInterlockedIncrement(&m_lAllocated);
#endif // DBG
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
	}
	else
	{
		pItem = CONTAINING_RECORD(pslEntry, FIXED_POOL_ITEM, slist);
	}

	// At this point we have an item whether it was newly created or pulled from the pool.

	InterlockedIncrement(&m_lInUse);
	DNASSERT(m_lInUse > 0);
#ifdef DBG
	// Note the callstack and add the item to the in use list.
	pItem->callstack.NoteCurrentCallStack();

	DNEnterCriticalSection(&m_csInUse);
	pItem->slist.Next = m_pInUseElements;
	m_pInUseElements = &pItem->slist;
	DNLeaveCriticalSection(&m_csInUse);

	// In debug only, store the pool the item belongs to on the item for checking upon release
	pItem->pThisPool = this;
#endif // DBG
	
	if (m_pfnBlockGet != NULL)
	{
		(*m_pfnBlockGet)(pItem + 1, pvContext);
	}

	return (pItem + 1);
}

#undef DPF_MODNAME
#define	DPF_MODNAME	"CFixedPool::Release"
VOID CFixedPool::Release(VOID* pvItem)
{
	FIXED_POOL_ITEM* pItem;

	DNASSERT(m_fInitialized == TRUE);
	DNASSERT(pvItem != NULL);

	pItem = (FIXED_POOL_ITEM*)pvItem - 1;

#ifdef DBG
	// Make sure the item comes from this pool.
	// If the item has already been released, pThisPool will be NULL.
	DNASSERT(pItem->pThisPool == this);
#endif // DBG

	if (m_pfnBlockRelease != NULL)
	{
		(*m_pfnBlockRelease)(pvItem);
	}

#ifdef DBG
	// Remove the item from the in use list.
	DNEnterCriticalSection(&m_csInUse);
	if (m_pInUseElements == &pItem->slist)
	{
		// Easy case, just reset m_pInUseElements to the next item in the list.
		m_pInUseElements = pItem->slist.Next;
	}
	else
	{
		DNSLIST_ENTRY* pslEntry;

		// We need to run the list and look for it
		pslEntry = m_pInUseElements;
		while (pslEntry != NULL)
		{
			if (pslEntry->Next == &pItem->slist)
			{
				// Found it, pull it out.
				pslEntry->Next = pItem->slist.Next;
				break;
			}
			pslEntry = pslEntry->Next;
		}
	}

	DNLeaveCriticalSection(&m_csInUse);
#endif // DBG
	DNASSERT(m_lInUse != 0);
	InterlockedDecrement(&m_lInUse);

	DNInterlockedPushEntrySList(&m_slAvailableElements, &pItem->slist);
}

#undef DPF_MODNAME
#define	DPF_MODNAME	"CFixedPool::GetInUseCount"
DWORD CFixedPool::GetInUseCount( void )
{
	DNASSERT(m_fInitialized == TRUE);

	return m_lInUse;
}

#ifdef DBG

#undef DPF_MODNAME
#define	DPF_MODNAME "CFixedPool::DumpLeaks"
VOID CFixedPool::DumpLeaks()
{
	// NOTE: It is important that this be a separate function because it consumes so much stack space.
	FIXED_POOL_ITEM* pItem;
	DNSLIST_ENTRY* pslEntry;
	TCHAR szCallStackBuffer[ CALLSTACK_BUFFER_SIZE ];

	// Report any leaked items
	if(m_lAllocated)
	{
		DNASSERT(m_lInUse == m_lAllocated);
		DNASSERT(m_pInUseElements != NULL);

		DPFX(DPFPREP, 0, "(%p) Pool leaking %d items", this, m_lAllocated);

		pslEntry = m_pInUseElements;
		while(pslEntry != NULL)
		{
			pItem = CONTAINING_RECORD(pslEntry, FIXED_POOL_ITEM, slist);

			pItem->callstack.GetCallStackString( szCallStackBuffer );

			DPFX(DPFPREP, 0, "(%p) Pool item leaked at address %p (user pointer: %p)\n%s", this, pItem, pItem + 1, szCallStackBuffer );

			pslEntry = pslEntry->Next;
		}

		DNASSERT(0);
	}
	else
	{
		DNASSERT(m_pInUseElements == NULL);
		DNASSERT(m_lInUse == 0);
	}


}
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\handletable.h ===
/*==========================================================================
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       HandleTable.h
 *  Content:    Handle Table Header File
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/21/2001	masonb	Created
 *
 ***************************************************************************/

#ifndef	__HANDLETABLE_H__
#define	__HANDLETABLE_H__

/***************************************************************************
 *
 * USAGE NOTES:
 * 
 * - This is a generic handle table.  It allows you to pass in a piece of
 *   data and get a random handle back that can later be used to refer to 
 *   that data.  
 * - The handle values of 0 and 0xFFFFFFFF (INVALID_HANDLE_VALUE) are 
 *   guaranteed never to be returned and therefore always represent an 
 *   invalid value. 
 * - The associated data is returned by Destroy so it is rarely necessary to
 *   do a Find immediately followed by a Destroy.  
 * - Using Find without first calling Lock can be un-safe.  Consider the 
 *   situation where you call Find without having called Lock and some
 *   other thread comes behind and calls Destroy.  You now are holding
 *   data from the call to Find that the other thread may have freed.  It
 *   is best to call Lock, then Find, place your own reference on the data
 *   and then call Unlock.
 *
 * IMPLEMENTATION NOTES:
 *
 * - Each slot in the handle table is guaranteed uniqueness for 256 uses.
 * - The handle table can hold a maximum of 16,777,214 (0xFFFFFE) entries. 
 *
 ***************************************************************************/

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for Handle Table

class CHandleTable
{
public:
	CHandleTable();
	~CHandleTable();

	void Lock( void );
	void Unlock( void );

	HRESULT Initialize( void );
	void Deinitialize( void );

	HRESULT Create( PVOID const pvData, DPNHANDLE *const pHandle );
	HRESULT Destroy( const DPNHANDLE handle, PVOID *const ppvData );
	HRESULT Find( const DPNHANDLE handle, PVOID *const ppvData );
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
	HRESULT SetTableSize( const DWORD dwNumEntries );
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL

private:

	struct _HANDLETABLE_ENTRY
	{
		BYTE		bVersion;	// This is incremented on each usage of a particular slot
		union 
		{
			PVOID	pvData;		// This will contain the data associated with a handle
			DWORD	dwIndex;	// For a free slot, this points to the next free slot
		} Entry;
	};

#ifndef DPNBUILD_PREALLOCATEDMEMORYMODEL
	HRESULT GrowTable( void );
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL

	DWORD			m_dwNumEntries;
	DWORD			m_dwNumFreeEntries;
	DWORD			m_dwFirstFreeEntry;
	DWORD			m_dwLastFreeEntry;

	_HANDLETABLE_ENTRY*	m_pTable;

#ifndef DPNBUILD_ONLYONETHREAD
	DNCRITICAL_SECTION	m_cs;
#endif // !DPNBUILD_ONLYONETHREAD

	DEBUG_ONLY(BOOL		m_fInitialized);
};

#endif	// __HANDLETABLE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\handletable.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       HandleTable.cpp
 *  Content:    HandleTable Object
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/21/2001	masonb	Created
 *
 *
 ***************************************************************************/

#include "dncmni.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

// Our handle table will have a maximum of 0xFFFFFF slots, and will keep
// uniqueness for 256 uses of a particular slot.
#define HANDLETABLE_INDEX_MASK				0x00FFFFFF
#define HANDLETABLE_VERSION_MASK			0xFF000000
#define HANDLETABLE_VERSION_SHIFT			24

//**********************************************************************
// Macro definitions
//**********************************************************************

#define	CONSTRUCT_DPNHANDLE(i,v)		((i & HANDLETABLE_INDEX_MASK) | (((DWORD)v << HANDLETABLE_VERSION_SHIFT) & HANDLETABLE_VERSION_MASK))
#define	DECODE_HANDLETABLE_INDEX(h)		(h & HANDLETABLE_INDEX_MASK)
#define	VERIFY_HANDLETABLE_VERSION(h,v)		((h & HANDLETABLE_VERSION_MASK) == ((DWORD)v << HANDLETABLE_VERSION_SHIFT))
#define INVALID_INDEX(i)			((i == 0) || (i >= m_dwNumEntries))

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::CHandleTable"
CHandleTable::CHandleTable() 
{
	DEBUG_ONLY(m_fInitialized = FALSE);
};

#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::~CHandleTable"
CHandleTable::~CHandleTable()
{ 
#ifdef DBG
	DNASSERT(!m_fInitialized);
#endif // DBG
};	


#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::Lock"
void CHandleTable::Lock( void )
{
#ifdef DBG
	DNASSERT(m_fInitialized);
#endif // DBG
	DNEnterCriticalSection(&m_cs);
};

#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::Unlock"
void CHandleTable::Unlock( void )
{
#ifdef DBG
	DNASSERT(m_fInitialized);
#endif // DBG
	DNLeaveCriticalSection(&m_cs);
};

#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::Initialize"
HRESULT CHandleTable::Initialize( void )
{
	memset(this, 0, sizeof(CHandleTable));

	if (!DNInitializeCriticalSection(&m_cs))
	{
		DPFERR("Failed to initialize Critical Section");
		return DPNERR_OUTOFMEMORY;
	}

	DEBUG_ONLY(m_fInitialized = TRUE);

	DPFX(DPFPREP, 5,"[%p] Handle table initialized", this);

	return DPN_OK;
};


#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::Deinitialize"
void CHandleTable::Deinitialize( void )
{
#ifdef DBG
	DNASSERT(m_fInitialized);
	m_fInitialized = FALSE;
#endif // DBG

	if (m_pTable)
	{
		DNFree(m_pTable);
		m_pTable = NULL;
	}

	DNDeleteCriticalSection(&m_cs);

	DPFX(DPFPREP, 5,"[%p] Handle table deinitialized", this);
};


#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::GrowTable"
HRESULT CHandleTable::SetTableSize( const DWORD dwNumEntries )
#else // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::GrowTable"
HRESULT CHandleTable::GrowTable( void )
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
{
	_HANDLETABLE_ENTRY	*pNewArray;
	DWORD				dwNewSize;
	DWORD				dw;

#ifdef DBG
	DNASSERT(m_fInitialized);
#endif // DBG

#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
	DNASSERT(m_dwNumEntries == 0);
	DNASSERT( dwNumEntries < (HANDLETABLE_INDEX_MASK - 1) );
	dwNewSize = dwNumEntries + 1; // + 1 because we never hand out entry 0
#else // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
	// The caller should have taken the lock
	AssertCriticalSectionIsTakenByThisThread(&m_cs, TRUE);

	//
	//	Double table size or seed with 2 entries
	//
	if (m_dwNumEntries == 0)
	{
		dwNewSize = 2;
	}
	else
	{
		// Ensure that we stay below our max size and that
		// we don't use all F's as a handle value.
		if (m_dwNumEntries == (HANDLETABLE_INDEX_MASK - 1))
		{
			DPFERR("Handle Table is full!");
			DNASSERT(FALSE);
			return DPNERR_GENERIC;
		}
		DNASSERT( m_dwNumEntries < (HANDLETABLE_INDEX_MASK - 1) );

		dwNewSize = _MIN(m_dwNumEntries * 2, HANDLETABLE_INDEX_MASK - 1);
	}
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL

	//
	//	Allocate new array
	//
	pNewArray = (_HANDLETABLE_ENTRY*)DNMalloc(sizeof(_HANDLETABLE_ENTRY) * dwNewSize);
	if (pNewArray == NULL)
	{
		DPFERR("Out of memory growing handle table");
		return DPNERR_OUTOFMEMORY;
	}

#ifndef DPNBUILD_PREALLOCATEDMEMORYMODEL
	//
	//	Copy old array to new array
	//
	if (m_pTable)
	{
		// NOTE: On the first Grow this will be memcpy'ing size 0 and then free'ing size 0.
		memcpy(pNewArray, m_pTable, m_dwNumEntries * sizeof(_HANDLETABLE_ENTRY));
		DNFree(m_pTable);
	}
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
	m_pTable = pNewArray;

	//
	//	Free entries at end of new array
	//
	for (dw = m_dwNumEntries ; dw < dwNewSize - 1 ; dw++ )
	{
		// Each slot points to the free slot following it
		m_pTable[dw].Entry.dwIndex = dw + 1;
		m_pTable[dw].bVersion = 0;
	}
	// The final slot has no slot following it to point to
	m_pTable[dwNewSize-1].Entry.dwIndex = 0;
	m_pTable[dwNewSize-1].bVersion = 0;

	m_dwFirstFreeEntry = m_dwNumEntries;
	m_dwNumFreeEntries = dwNewSize - m_dwNumEntries;
	m_dwNumEntries = dwNewSize;
	m_dwLastFreeEntry = dwNewSize - 1;

#ifndef DPNBUILD_PREALLOCATEDMEMORYMODEL
	if (m_dwFirstFreeEntry == 0)
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
	{
		// Don't allow 0 as a handle value, so we will waste the first slot
		m_dwFirstFreeEntry++;
		m_dwNumFreeEntries--;
	}

	DPFX(DPFPREP, 5,"[%p] Grew handle table to [%d] entries", this, m_dwNumEntries);

	return DPN_OK;
};


#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::Create"
HRESULT CHandleTable::Create( PVOID const pvData, DPNHANDLE *const pHandle )
{
	HRESULT		hr;
	DWORD		dwIndex;
	DPNHANDLE	handle;

#ifdef DBG
	// Data is not allowed to be NULL.
	DNASSERT(pvData != NULL);
	DNASSERT(pHandle != NULL);
	DNASSERT(m_fInitialized);
#endif // DBG

	Lock();

	// Ensure that we have free entries
	if (m_dwNumFreeEntries == 0)
	{
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
		DPFX(DPFPREP, 0, "No room in handle table!");
		DNASSERTX(! "No room in handle table!", 2);
		hr = DPNERR_OUTOFMEMORY;
#else // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
		hr = GrowTable();
		if (hr != DPN_OK)
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
		{
			// NOTE: It is important that we not touch *pHandle in the fail case.
			// Different layers will initialize this to what they want (0 or 
			// INVALID_HANDLE_VALUE) and will expect to be able to test against
			// that in their fail code.
			Unlock();
			return hr;
		}
	}
	DNASSERT(m_dwNumFreeEntries != 0);
	DNASSERT(m_dwFirstFreeEntry != 0);

	dwIndex = m_dwFirstFreeEntry;

	handle = CONSTRUCT_DPNHANDLE(dwIndex, m_pTable[dwIndex].bVersion);

	// The slot's dwIndex member points to the next free slot.  Grab the value of the
	// next free entry before overwriting it with pvData.
	m_dwFirstFreeEntry = m_pTable[dwIndex].Entry.dwIndex;

	m_pTable[dwIndex].Entry.pvData = pvData;

	m_dwNumFreeEntries--;

	Unlock();

	DPFX(DPFPREP, 5,"[%p] Created handle [0x%lx], data [%p]", this, handle, pvData);

	DNASSERT(handle != 0);
	*pHandle = handle;

	return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::Destroy"
HRESULT CHandleTable::Destroy( const DPNHANDLE handle, PVOID *const ppvData )
{
	DWORD	dwIndex;

#ifdef DBG
	DNASSERT(m_fInitialized);
#endif // DBG

	dwIndex = DECODE_HANDLETABLE_INDEX( handle );

	Lock();

	if (INVALID_INDEX(dwIndex))
	{
		Unlock();
		DPFX(DPFPREP, 1, "Attempt to destroy handle with invalid index (0x%x).", handle);
		return DPNERR_INVALIDHANDLE;
	}

	if (!VERIFY_HANDLETABLE_VERSION(handle, m_pTable[dwIndex].bVersion))
	{
		Unlock();
		DPFERR("Attempt to destroy handle with non-matching version");
		return DPNERR_INVALIDHANDLE;
	}

	DPFX(DPFPREP, 5,"[%p] Destroy handle [0x%lx], data[%p]", this, handle, m_pTable[dwIndex].Entry.pvData);

	DNASSERT(m_pTable[dwIndex].Entry.pvData != NULL);
	if (ppvData)
	{
		*ppvData = m_pTable[dwIndex].Entry.pvData;
	}
	m_pTable[dwIndex].Entry.pvData = NULL;
	m_pTable[dwIndex].bVersion++;

	if (m_dwNumFreeEntries == 0)
	{
		DNASSERT(m_dwFirstFreeEntry == 0);
		m_dwFirstFreeEntry = dwIndex;
	}
	else
	{
		m_pTable[m_dwLastFreeEntry].Entry.dwIndex = dwIndex;
	}
	m_dwLastFreeEntry = dwIndex;
	m_dwNumFreeEntries++;

	Unlock();

	return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::Find"
HRESULT CHandleTable::Find( const DPNHANDLE handle, PVOID *const ppvData )
{
	DWORD	dwIndex;

#ifdef DBG
	DNASSERT(ppvData != NULL);
	DNASSERT(m_fInitialized);
#endif // DBG

	*ppvData = NULL;

	dwIndex = DECODE_HANDLETABLE_INDEX( handle );

	Lock();

	if (INVALID_INDEX(dwIndex))
	{
		Unlock();
		DPFERR("Attempt to lookup handle with invalid index");
		return DPNERR_INVALIDHANDLE;
	}

	if (!VERIFY_HANDLETABLE_VERSION(handle, m_pTable[dwIndex].bVersion))
	{
		Unlock();
		DPFERR("Attempt to lookup handle with non-matching version");
		return DPNERR_INVALIDHANDLE;
	}

	DPFX(DPFPREP, 5,"[%p] Find data for handle [0x%lx], data[%p]", this, handle, m_pTable[dwIndex].Entry.pvData);

	DNASSERT(m_pTable[dwIndex].Entry.pvData != NULL);
	*ppvData = m_pTable[dwIndex].Entry.pvData;

	Unlock();

	return DPN_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\handletracking.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       HandleTracking.cpp
 *  Content:    Handle Tracking debug logic
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  10/31/2001	masonb	Created
 *
 *
 ***************************************************************************/

#include "dncmni.h"


#ifdef DBG

CBilink g_blHandles;
#ifndef DPNBUILD_ONLYONETHREAD
DNCRITICAL_SECTION g_HandleLock;
#endif // !DPNBUILD_ONLYONETHREAD

#define IsValidHandle(x) \
	(x != NULL && x != INVALID_HANDLE_VALUE && \
	(x->type == TypeEvent || \
	 x->type == TypeMutex || \
	 x->type == TypeSemaphore || \
	 x->type == TypeFile || \
	 x->type == TypeFileMap || \
	 x->type == TypeThread || \
	 x->type == TypeProcess || \
	 x->type == TypeSpecial))

BOOL DNHandleTrackInitialize()
{
	g_blHandles.Initialize();
	return DNInitializeCriticalSection(&g_HandleLock);
}

VOID DNHandleTrackDeinitialize()
{
	DNDeleteCriticalSection(&g_HandleLock);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DNHandleTrackDumpLeaks"
BOOL DNHandleTrackDumpLeaks()
{
	BOOL fLeaked = FALSE;

	DNEnterCriticalSection(&g_HandleLock);
	while(!g_blHandles.IsEmpty())
	{
		DNHANDLE dnh = CONTAINING_RECORD(g_blHandles.GetNext(), TRACKED_HANDLE, blHandle);
		dnh->blHandle.RemoveFromList();

		fLeaked = TRUE;

		// Dump dnh details
		switch(dnh->type)
		{
		case TypeEvent:
			DPFX(DPFPREP, 0, "Event leaked %p", dnh->handle);
			break;
		case TypeMutex:
			DPFX(DPFPREP, 0, "Mutex leaked %p", dnh->handle);
			break;
		case TypeSemaphore:
			DPFX(DPFPREP, 0, "Semaphore leaked %p", dnh->handle);
			break;
		case TypeFile:
			DPFX(DPFPREP, 0, "File leaked %p", dnh->handle);
			break;
#ifndef DPNBUILD_SINGLEPROCESS
		case TypeFileMap:
			DPFX(DPFPREP, 0, "FileMapping leaked %p", dnh->handle);
			break;
#endif // ! DPNBUILD_SINGLEPROCESS
		case TypeThread:
			DPFX(DPFPREP, 0, "Thread leaked %p", dnh->handle);
			break;
#ifndef DPNBUILD_SINGLEPROCESS
		case TypeProcess:
			DPFX(DPFPREP, 0, "Process leaked %p", dnh->handle);
			break;
#endif // ! DPNBUILD_SINGLEPROCESS
		case TypeSpecial:
			DPFX(DPFPREP, 0, "Special handle leaked %p", dnh->handle);
			break;

		default:
			DPFX(DPFPREP, 0, "Unknown handle leaked %p", dnh->handle);
			DNASSERT(0);
			break;
		}

		// Show the callstack of the place the handle was allocated.
		TCHAR		CallStackBuffer[ CALLSTACK_BUFFER_SIZE ];
		dnh->AllocCallStack.GetCallStackString( CallStackBuffer );
		DPFX(DPFPREP,  0, "%s\n", CallStackBuffer );

		DNFree(dnh);		
	}
	DNLeaveCriticalSection(&g_HandleLock);

	return fLeaked;
}

DNHANDLE DNHandleTrackMakeDNHANDLE(HANDLE h)
{
	if (h == 0 || h == INVALID_HANDLE_VALUE)
	{
		return (DNHANDLE)h;
	}

	DNHANDLE dnh = (DNHANDLE)DNMalloc(sizeof(TRACKED_HANDLE));
	if (!dnh)
	{
		CloseHandle(h);
		return 0;
	}

	dnh->AllocCallStack.NoteCurrentCallStack();
	dnh->handle = h;
	dnh->type = TypeSpecial;
	dnh->blHandle.Initialize();
	
	DNEnterCriticalSection(&g_HandleLock);
	dnh->blHandle.InsertBefore(&g_blHandles);
	DNLeaveCriticalSection(&g_HandleLock);

	return dnh;
}

VOID DNHandleTrackRemoveDNHANDLE(DNHANDLE dnh)
{
	DNASSERT(IsValidHandle(dnh));

	DNEnterCriticalSection(&g_HandleLock);
	dnh->blHandle.RemoveFromList();
	DNLeaveCriticalSection(&g_HandleLock);

	DNFree(dnh);
}

HANDLE 	 DNHandleTrackHandleFromDNHANDLE(DNHANDLE h)
{
	if (h == 0 || h == INVALID_HANDLE_VALUE)
	{
		return (HANDLE)h;
	}

	DNASSERT(IsValidHandle(h));
	return h->handle;
}

#ifndef DPNBUILD_SINGLEPROCESS
// NOTE: pCurrentDirectory is const on the desktop, but non-const on WinCE
BOOL DNHandleTrackCreateProcess(LPCTSTR lpApplicationName, LPTSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCTSTR lpCurrentDirectory, LPSTARTUPINFO lpStartupInfo, DNPROCESS_INFORMATION* lpProcessInformation)
{
	PROCESS_INFORMATION pi;
	DWORD dwLastError;

	DNHANDLE dnhProcess = (DNHANDLE)DNMalloc(sizeof(TRACKED_HANDLE));
	if (!dnhProcess)
	{
		return FALSE;
	}

	DNHANDLE dnhThread = (DNHANDLE)DNMalloc(sizeof(TRACKED_HANDLE));
	if (!dnhThread)
	{
		DNFree(dnhProcess);
		return FALSE;
	}

	// NOTE: On CE only the current directory is declared non-const so cast it off
#ifdef WINCE
	if (!CreateProcess(lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, (LPTSTR)lpCurrentDirectory, lpStartupInfo, &pi))
#else // !WINCE
	if (!CreateProcess(lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, &pi))
#endif // WINCE
	{
		dwLastError = GetLastError();
		DNFree(dnhProcess);
		DNFree(dnhThread);
		SetLastError(dwLastError);
		return FALSE;
	}
	dwLastError = GetLastError();
	
	dnhProcess->AllocCallStack.NoteCurrentCallStack();
	dnhProcess->handle = pi.hProcess;
	dnhProcess->type = TypeProcess;
	dnhProcess->blHandle.Initialize();
	
	dnhThread->AllocCallStack.NoteCurrentCallStack();
	dnhThread->handle = pi.hThread;
	dnhThread->type = TypeThread;
	dnhThread->blHandle.Initialize();

	DNEnterCriticalSection(&g_HandleLock);
	dnhProcess->blHandle.InsertBefore(&g_blHandles);
	dnhThread->blHandle.InsertBefore(&g_blHandles);
	DNLeaveCriticalSection(&g_HandleLock);

	lpProcessInformation->hProcess = dnhProcess;
	lpProcessInformation->hThread = dnhThread;
	lpProcessInformation->dwProcessId = pi.dwProcessId;
	lpProcessInformation->dwThreadId = pi.dwThreadId;

	SetLastError(dwLastError);
	return TRUE;
}

DNHANDLE DNHandleTrackOpenProcess(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId)
{
	DWORD dwLastError;

	HANDLE h = OpenProcess(dwDesiredAccess, bInheritHandle, dwProcessId);
	if (!h)
	{
		return 0;
	}
	dwLastError = GetLastError();
	
	DNHANDLE dnh = (DNHANDLE)DNMalloc(sizeof(TRACKED_HANDLE));
	if (!dnh)
	{
		CloseHandle(h);
		SetLastError(dwLastError);
		return 0;
	}

	dnh->AllocCallStack.NoteCurrentCallStack();
	dnh->handle = h;
	dnh->type = TypeProcess;
	dnh->blHandle.Initialize();
	
	DNEnterCriticalSection(&g_HandleLock);
	dnh->blHandle.InsertBefore(&g_blHandles);
	DNLeaveCriticalSection(&g_HandleLock);

	SetLastError(dwLastError);
	return dnh;
}
#endif // ! DPNBUILD_SINGLEPROCESS

DNHANDLE DNHandleTrackCreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, DWORD dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId)
{
	DWORD dwLastError;

	HANDLE h = CreateThread(lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpThreadId);
	if (!h)
	{
		return 0;
	}
	dwLastError = GetLastError();
	
	DNHANDLE dnh = (DNHANDLE)DNMalloc(sizeof(TRACKED_HANDLE));
	if (!dnh)
	{
		CloseHandle(h);
		SetLastError(dwLastError);
		return 0;
	}

	dnh->AllocCallStack.NoteCurrentCallStack();
	dnh->handle = h;
	dnh->type = TypeThread;
	dnh->blHandle.Initialize();
	
	DNEnterCriticalSection(&g_HandleLock);
	dnh->blHandle.InsertBefore(&g_blHandles);
	DNLeaveCriticalSection(&g_HandleLock);

	SetLastError(dwLastError);
	return dnh;
}

DNHANDLE DNHandleTrackCreateEvent(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCTSTR lpName)
{
	DWORD dwLastError;

	HANDLE h = CreateEvent(lpEventAttributes, bManualReset, bInitialState, lpName);
	if (!h)
	{
		return 0;
	}
	dwLastError = GetLastError();
	
	DNHANDLE dnh = (DNHANDLE)DNMalloc(sizeof(TRACKED_HANDLE));
	if (!dnh)
	{
		CloseHandle(h);
		SetLastError(dwLastError);
		return 0;
	}

	dnh->AllocCallStack.NoteCurrentCallStack();
	dnh->handle = h;
	dnh->type = TypeEvent;
	dnh->blHandle.Initialize();
	
	DNEnterCriticalSection(&g_HandleLock);
	dnh->blHandle.InsertBefore(&g_blHandles);
	DNLeaveCriticalSection(&g_HandleLock);

	SetLastError(dwLastError);
	return dnh;
}

DNHANDLE DNHandleTrackOpenEvent(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCTSTR lpName)
{
	DWORD dwLastError;

	HANDLE h = OpenEvent(dwDesiredAccess, bInheritHandle, lpName);
	if (!h)
	{
		return 0;
	}
	dwLastError = GetLastError();
	
	DNHANDLE dnh = (DNHANDLE)DNMalloc(sizeof(TRACKED_HANDLE));
	if (!dnh)
	{
		CloseHandle(h);
		SetLastError(dwLastError);
		return 0;
	}

	dnh->AllocCallStack.NoteCurrentCallStack();
	dnh->handle = h;
	dnh->type = TypeEvent;
	dnh->blHandle.Initialize();
	
	DNEnterCriticalSection(&g_HandleLock);
	dnh->blHandle.InsertBefore(&g_blHandles);
	DNLeaveCriticalSection(&g_HandleLock);

	SetLastError(dwLastError);
	return dnh;
}

BOOL DNHandleTrackSetEvent(DNHANDLE hHandle)
{
	DNASSERT(IsValidHandle(hHandle));
	DNASSERT(hHandle->type == TypeEvent);
	return SetEvent(hHandle->handle);
}

BOOL DNHandleTrackResetEvent(DNHANDLE hHandle)
{
	DNASSERT(IsValidHandle(hHandle));
	DNASSERT(hHandle->type == TypeEvent);
	return ResetEvent(hHandle->handle);
}

DNHANDLE DNHandleTrackCreateMutex(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCTSTR lpName)
{
	DWORD dwLastError;

	HANDLE h = CreateMutex(lpMutexAttributes, bInitialOwner, lpName);
	if (!h)
	{
		return 0;
	}
	dwLastError = GetLastError();
	
	DNHANDLE dnh = (DNHANDLE)DNMalloc(sizeof(TRACKED_HANDLE));
	if (!dnh)
	{
		CloseHandle(h);
		SetLastError(dwLastError);
		return 0;
	}

	dnh->AllocCallStack.NoteCurrentCallStack();
	dnh->handle = h;
	dnh->type = TypeMutex;
	dnh->blHandle.Initialize();
	
	DNEnterCriticalSection(&g_HandleLock);
	dnh->blHandle.InsertBefore(&g_blHandles);
	DNLeaveCriticalSection(&g_HandleLock);

	SetLastError(dwLastError);
	return dnh;
}

DNHANDLE DNHandleTrackOpenMutex(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCTSTR lpName)
{
	DWORD dwLastError;

	HANDLE h = OpenMutex(dwDesiredAccess, bInheritHandle, lpName);
	if (!h)
	{
		return 0;
	}
	dwLastError = GetLastError();
	
	DNHANDLE dnh = (DNHANDLE)DNMalloc(sizeof(TRACKED_HANDLE));
	if (!dnh)
	{
		CloseHandle(h);
		SetLastError(dwLastError);
		return 0;
	}

	dnh->AllocCallStack.NoteCurrentCallStack();
	dnh->handle = h;
	dnh->type = TypeMutex;
	dnh->blHandle.Initialize();
	
	DNEnterCriticalSection(&g_HandleLock);
	dnh->blHandle.InsertBefore(&g_blHandles);
	DNLeaveCriticalSection(&g_HandleLock);

	SetLastError(dwLastError);
	return dnh;
}

BOOL DNHandleTrackReleaseMutex(DNHANDLE hHandle)
{
	DNASSERT(IsValidHandle(hHandle));
	DNASSERT(hHandle->type == TypeMutex);
	return ReleaseMutex(hHandle->handle);
}

DNHANDLE DNHandleTrackCreateSemaphore(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCTSTR lpName)
{
	DWORD dwLastError;

	HANDLE h = CreateSemaphore(lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName);
	if (!h)
	{
		return 0;
	}
	dwLastError = GetLastError();
	
	DNHANDLE dnh = (DNHANDLE)DNMalloc(sizeof(TRACKED_HANDLE));
	if (!dnh)
	{
		CloseHandle(h);
		SetLastError(dwLastError);
		return 0;
	}

	dnh->AllocCallStack.NoteCurrentCallStack();
	dnh->handle = h;
	dnh->type = TypeSemaphore;
	dnh->blHandle.Initialize();
	
	DNEnterCriticalSection(&g_HandleLock);
	dnh->blHandle.InsertBefore(&g_blHandles);
	DNLeaveCriticalSection(&g_HandleLock);

	SetLastError(dwLastError);
	return dnh;
}

BOOL DNHandleTrackReleaseSemaphore(DNHANDLE hHandle, LONG lReleaseCount, LPLONG lpPreviousCount)
{
	DNASSERT(IsValidHandle(hHandle));
	DNASSERT(hHandle->type == TypeSemaphore);
	return ReleaseSemaphore(hHandle->handle, lReleaseCount, lpPreviousCount);
}

DNHANDLE DNHandleTrackCreateFile(LPCTSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
{
	DWORD dwLastError;

	HANDLE h = CreateFile(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
	if (h == INVALID_HANDLE_VALUE)
	{
		return DNINVALID_HANDLE_VALUE;
	}
	dwLastError = GetLastError();
	
	DNHANDLE dnh = (DNHANDLE)DNMalloc(sizeof(TRACKED_HANDLE));
	if (!dnh)
	{
		CloseHandle(h);
		SetLastError(dwLastError);
		return 0;
	}

	dnh->AllocCallStack.NoteCurrentCallStack();
	dnh->handle = h;
	dnh->type = TypeFile;
	dnh->blHandle.Initialize();
	
	DNEnterCriticalSection(&g_HandleLock);
	dnh->blHandle.InsertBefore(&g_blHandles);
	DNLeaveCriticalSection(&g_HandleLock);

	SetLastError(dwLastError);
	return dnh;
}

#ifndef DPNBUILD_SINGLEPROCESS
DNHANDLE DNHandleTrackCreateFileMapping(HANDLE hFile, LPSECURITY_ATTRIBUTES lpAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCTSTR lpName)
{
	DWORD dwLastError;

	// If someone wants to actually map a file, we need to make param 1 a DNHANDLE and do the appropriate work here.
	DNASSERT(hFile == INVALID_HANDLE_VALUE);

	HANDLE h = CreateFileMapping(hFile, lpAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpName);
	if (!h)
	{
		return 0;
	}
	dwLastError = GetLastError();
	
	DNHANDLE dnh = (DNHANDLE)DNMalloc(sizeof(TRACKED_HANDLE));
	if (!dnh)
	{
		CloseHandle(h);
		SetLastError(dwLastError);
		return 0;
	}

	dnh->AllocCallStack.NoteCurrentCallStack();
	dnh->handle = h;
	dnh->type = TypeFileMap;
	dnh->blHandle.Initialize();
	
	DNEnterCriticalSection(&g_HandleLock);
	dnh->blHandle.InsertBefore(&g_blHandles);
	DNLeaveCriticalSection(&g_HandleLock);

	SetLastError(dwLastError);
	return dnh;
}

DNHANDLE DNHandleTrackOpenFileMapping(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCTSTR lpName)
{
	DWORD dwLastError;

	HANDLE h = OpenFileMapping(dwDesiredAccess, bInheritHandle, lpName);
	if (!h)
	{
		return 0;
	}
	dwLastError = GetLastError();
	
	DNHANDLE dnh = (DNHANDLE)DNMalloc(sizeof(TRACKED_HANDLE));
	if (!dnh)
	{
		CloseHandle(h);
		SetLastError(dwLastError);
		return 0;
	}

	dnh->AllocCallStack.NoteCurrentCallStack();
	dnh->handle = h;
	dnh->type = TypeFileMap;
	dnh->blHandle.Initialize();
	
	DNEnterCriticalSection(&g_HandleLock);
	dnh->blHandle.InsertBefore(&g_blHandles);
	DNLeaveCriticalSection(&g_HandleLock);

	SetLastError(dwLastError);
	return dnh;
}

BOOL DNHandleTrackGetExitCodeProcess(DNHANDLE hHandle, LPDWORD lpExitCode)
{
	DNASSERT(IsValidHandle(hHandle));
	return GetExitCodeProcess(hHandle->handle, lpExitCode);
}
#endif // ! DPNBUILD_SINGLEPROCESS

DWORD DNHandleTrackWaitForSingleObject(DNHANDLE hHandle, DWORD dwMilliseconds)
{
	DNASSERT(IsValidHandle(hHandle));
	return WaitForSingleObject(hHandle->handle, dwMilliseconds);
}

DWORD DNHandleTrackWaitForSingleObjectEx(DNHANDLE hHandle, DWORD dwMilliseconds, BOOL bAlertable)
{
	DNASSERT(IsValidHandle(hHandle));
	return WaitForSingleObjectEx(hHandle->handle, dwMilliseconds, bAlertable);
}

DWORD DNHandleTrackWaitForMultipleObjects(DWORD nCount, CONST DNHANDLE *lpHandles, BOOL fWaitAll, DWORD dwMilliseconds)
{
	DNASSERT(nCount <= MAXIMUM_WAIT_OBJECTS);
	HANDLE rgh[MAXIMUM_WAIT_OBJECTS];
	DWORD iHandle;

	for (iHandle = 0; iHandle < nCount; iHandle++)
	{
		DNASSERT(IsValidHandle(lpHandles[iHandle]));
		rgh[iHandle] = lpHandles[iHandle]->handle;
	}
	for (;iHandle < MAXIMUM_WAIT_OBJECTS; iHandle++)
	{
		rgh[iHandle] = 0;
	}
	return WaitForMultipleObjects(nCount, rgh, fWaitAll, dwMilliseconds);
}

DWORD DNHandleTrackWaitForMultipleObjectsEx(DWORD nCount, CONST DNHANDLE *lpHandles, BOOL fWaitAll, DWORD dwMilliseconds, BOOL bAlertable)
{
	DNASSERT(nCount <= MAXIMUM_WAIT_OBJECTS);
	HANDLE rgh[MAXIMUM_WAIT_OBJECTS];
	DWORD iHandle;

	for (iHandle = 0; iHandle < nCount; iHandle++)
	{
		DNASSERT(IsValidHandle(lpHandles[iHandle]));
		rgh[iHandle] = lpHandles[iHandle]->handle;
	}
	for (;iHandle < MAXIMUM_WAIT_OBJECTS; iHandle++)
	{
		rgh[iHandle] = 0;
	}
	return WaitForMultipleObjectsEx(nCount, rgh, fWaitAll, dwMilliseconds, bAlertable);
}

DWORD DNHandleTrackSignalObjectAndWait(DNHANDLE hObjectToSignal, DNHANDLE hObjectToWaitOn, DWORD dwMilliseconds, BOOL bAlertable)
{
	DNASSERT(IsValidHandle(hObjectToSignal));
	DNASSERT(IsValidHandle(hObjectToWaitOn));
	DNASSERT(hObjectToSignal->handle != hObjectToWaitOn->handle);

#ifdef WINNT
	return SignalObjectAndWait(hObjectToSignal->handle, hObjectToWaitOn->handle, dwMilliseconds, bAlertable);
#else // ! WINNT
	BOOL	fResult;

	fResult = SetEvent(hObjectToSignal->handle);
	DNASSERT(fResult);
	return WaitForSingleObjectEx(hObjectToWaitOn->handle, dwMilliseconds, bAlertable);
#endif // ! WINNT
}

BOOL DNHandleTrackCloseHandle(DNHANDLE hHandle)
{
	DNASSERT(IsValidHandle(hHandle));

	DNEnterCriticalSection(&g_HandleLock);
	hHandle->blHandle.RemoveFromList();
	DNLeaveCriticalSection(&g_HandleLock);

	HANDLE h = hHandle->handle;

	DNFree(hHandle);

	return CloseHandle(h);
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\handletracking.h ===
/*==========================================================================
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       HandleTracking.h
 *  Content:    Handle Tracking Header File
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  10/31/2001	masonb	Created
 *
 ***************************************************************************/

#ifndef __HANDLETRACKING_H__
#define __HANDLETRACKING_H__

#ifdef DBG

BOOL DNHandleTrackInitialize();
VOID DNHandleTrackDeinitialize();
BOOL DNHandleTrackDumpLeaks();

enum HandleType
{
	TypeEvent,
	TypeMutex,
	TypeSemaphore,
	TypeFile,
	TypeFileMap,		// not used when DPNBUILD_SINGLEPROCESS defined
	TypeThread,
	TypeProcess,		// not used when DPNBUILD_SINGLEPROCESS defined
	TypeSpecial
};

struct TRACKED_HANDLE
{
	HANDLE handle;
	HandleType type;
	CBilink blHandle;
	CCallStack AllocCallStack;
};

typedef TRACKED_HANDLE* DNHANDLE;
#define DNINVALID_HANDLE_VALUE ((DNHANDLE)INVALID_HANDLE_VALUE)

#ifndef DPNBUILD_SINGLEPROCESS
struct DNPROCESS_INFORMATION
{
	DNHANDLE hProcess; 
    DNHANDLE hThread; 
    DWORD dwProcessId; 
    DWORD dwThreadId; 
};
#endif // ! DPNBUILD_SINGLEPROCESS

DNHANDLE DNHandleTrackMakeDNHANDLE(HANDLE h);
VOID	 DNHandleTrackRemoveDNHANDLE(DNHANDLE dnh);
HANDLE 	 DNHandleTrackHandleFromDNHANDLE(DNHANDLE h);

#ifndef DPNBUILD_SINGLEPROCESS
BOOL	 DNHandleTrackCreateProcess(LPCTSTR lpApplicationName, LPTSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCTSTR lpCurrentDirectory, LPSTARTUPINFO lpStartupInfo, DNPROCESS_INFORMATION* lpProcessInformation);
DNHANDLE DNHandleTrackOpenProcess(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);
#endif // ! DPNBUILD_SINGLEPROCESS

DNHANDLE DNHandleTrackCreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, DWORD dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);

DNHANDLE DNHandleTrackCreateEvent(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCTSTR lpName);
DNHANDLE DNHandleTrackOpenEvent(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCTSTR lpName);
BOOL	 DNHandleTrackSetEvent(DNHANDLE hHandle);
BOOL	 DNHandleTrackResetEvent(DNHANDLE hHandle);

DNHANDLE DNHandleTrackCreateMutex(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCTSTR lpName);
DNHANDLE DNHandleTrackOpenMutex(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCTSTR lpName);
BOOL	 DNHandleTrackReleaseMutex(DNHANDLE hHandle);

DNHANDLE DNHandleTrackCreateSemaphore(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCTSTR lpName);
BOOL	 DNHandleTrackReleaseSemaphore(DNHANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount);

DNHANDLE DNHandleTrackCreateFile(LPCTSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
#ifndef DPNBUILD_SINGLEPROCESS
DNHANDLE DNHandleTrackCreateFileMapping(HANDLE hFile, LPSECURITY_ATTRIBUTES lpAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCTSTR lpName);
DNHANDLE DNHandleTrackOpenFileMapping(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCTSTR lpName);

BOOL DNHandleTrackGetExitCodeProcess(DNHANDLE hHandle, LPDWORD lpExitCode);
#endif // ! DPNBUILD_SINGLEPROCESS

DWORD	 DNHandleTrackWaitForSingleObject(DNHANDLE hHandle, DWORD dwMilliseconds);
DWORD	 DNHandleTrackWaitForSingleObjectEx(DNHANDLE hHandle, DWORD dwMilliseconds, BOOL bAlertable);
DWORD	 DNHandleTrackWaitForMultipleObjects(DWORD nCount, CONST DNHANDLE *lpHandles, BOOL fWaitAll, DWORD dwMilliseconds);
DWORD	 DNHandleTrackWaitForMultipleObjectsEx(DWORD nCount, CONST DNHANDLE *lpHandles, BOOL fWaitAll, DWORD dwMilliseconds, BOOL bAlertable);
DWORD	 DNHandleTrackSignalObjectAndWait(DNHANDLE hObjectToSignal, DNHANDLE hObjectToWaitOn, DWORD dwMilliseconds, BOOL bAlertable);

BOOL	 DNHandleTrackCloseHandle(DNHANDLE hHandle);


#define MAKE_DNHANDLE(x) DNHandleTrackMakeDNHANDLE(x)
#define REMOVE_DNHANDLE(x) DNHandleTrackRemoveDNHANDLE(x)
#define HANDLE_FROM_DNHANDLE(x) DNHandleTrackHandleFromDNHANDLE(x)

#define DNCreateProcess DNHandleTrackCreateProcess
#define DNOpenProcess DNHandleTrackOpenProcess

#define DNCreateThread DNHandleTrackCreateThread

#define DNCreateEvent DNHandleTrackCreateEvent
#define DNOpenEvent DNHandleTrackOpenEvent
#define DNSetEvent DNHandleTrackSetEvent
#define DNResetEvent DNHandleTrackResetEvent

#define DNCreateMutex DNHandleTrackCreateMutex
#define DNOpenMutex DNHandleTrackOpenMutex
#define DNReleaseMutex DNHandleTrackReleaseMutex

#define DNCreateSemaphore DNHandleTrackCreateSemaphore
#define DNReleaseSemaphore DNHandleTrackReleaseSemaphore

#define DNGetExitCodeProcess DNHandleTrackGetExitCodeProcess

#define DNCreateFile DNHandleTrackCreateFile
#define DNCreateFileMapping DNHandleTrackCreateFileMapping
#define DNOpenFileMapping DNHandleTrackOpenFileMapping

#define DNWaitForSingleObject DNHandleTrackWaitForSingleObject
#define DNWaitForSingleObjectEx DNHandleTrackWaitForSingleObjectEx
#define DNWaitForMultipleObjects DNHandleTrackWaitForMultipleObjects
#define DNWaitForMultipleObjectsEx DNHandleTrackWaitForMultipleObjectsEx
#define DNSignalObjectAndWait DNHandleTrackSignalObjectAndWait

#define DNCloseHandle DNHandleTrackCloseHandle

#else // !DBG

#define DNInitializeHandleTracking() TRUE
#define DNDeinitializeHandleTracking()
#define DNDumpLeakedHandles() FALSE

#define DNHANDLE HANDLE
#define DNINVALID_HANDLE_VALUE INVALID_HANDLE_VALUE
#define MAKE_DNHANDLE(x) x
#define REMOVE_DNHANDLE(x) 
#define HANDLE_FROM_DNHANDLE(x) x

#ifndef DPNBUILD_SINGLEPROCESS
#define DNPROCESS_INFORMATION PROCESS_INFORMATION
#define DNCreateProcess CreateProcess
#define DNOpenProcess OpenProcess
#endif // ! DPNBUILD_SINGLEPROCESS

#define DNCreateThread CreateThread

#define DNCreateEvent CreateEvent
#define DNOpenEvent OpenEvent
#define DNSetEvent SetEvent
#define DNResetEvent ResetEvent

#define DNCreateMutex CreateMutex
#define DNOpenMutex OpenMutex
#define DNReleaseMutex ReleaseMutex

#define DNCreateSemaphore CreateSemaphore
#define DNReleaseSemaphore ReleaseSemaphore

#define DNCreateFile CreateFile
#ifndef DPNBUILD_SINGLEPROCESS
#define DNCreateFileMapping CreateFileMapping
#define DNOpenFileMapping OpenFileMapping

#define DNGetExitCodeProcess GetExitCodeProcess
#endif // ! DPNBUILD_SINGLEPROCESS

#define DNWaitForSingleObject WaitForSingleObject

#define DNWaitForSingleObjectEx WaitForSingleObjectEx
#define DNWaitForMultipleObjects WaitForMultipleObjects
#define DNWaitForMultipleObjectsEx WaitForMultipleObjectsEx
#ifdef WINNT
#define DNSignalObjectAndWait SignalObjectAndWait
#else // ! WINNT
#define DNSignalObjectAndWait(hObjectToSignal, hObjectToWaitOn, dwMilliseconds, bAlertable) SetEvent(hObjectToSignal),WaitForSingleObjectEx(hObjectToWaitOn, dwMilliseconds, bAlertable)
#endif // ! WINNT

#define DNCloseHandle CloseHandle

#endif // DBG

#endif // __HANDLETRACKING_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\hashtable.h ===
/*==========================================================================
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       HashTable.h
 *  Content:    Hash Table Header File
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  08/13/2001	masonb	Created
 *
 ***************************************************************************/

#ifndef	__HASHTABLE_H__
#define	__HASHTABLE_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

typedef BOOL (*PFNHASHTABLECOMPARE)(void* pvKey1, void* pvKey2);
typedef DWORD (*PFNHASHTABLEHASH)(void* pvKey, BYTE bBitDepth);

//**********************************************************************
// Class prototypes
//**********************************************************************

class CHashTable
{
public:
	CHashTable();
	~CHashTable();

	BOOL Initialize( BYTE bBitDepth,
#ifndef DPNBUILD_PREALLOCATEDMEMORYMODEL
					BYTE bGrowBits,
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
					PFNHASHTABLECOMPARE pfnCompare,
					PFNHASHTABLEHASH pfnHash );
	void Deinitialize( void );

	BOOL Insert( PVOID pvKey, PVOID pvData );
	BOOL Remove( PVOID pvKey );
#ifndef DPNBUILD_NOREGISTRY
	void RemoveAll( void );
#endif // ! DPNBUILD_NOREGISTRY
	BOOL Find( PVOID pvKey, PVOID* ppvData );

	DWORD GetEntryCount() const
	{
		return m_dwEntriesInUse;
	}


private:

	struct _HASHTABLE_ENTRY
	{
		PVOID	pvKey;
		PVOID	pvData;		// This will contain the data associated with a handle
		CBilink blLinkage;
	};
	static BOOL HashEntry_Alloc(void* pItem, void* pvContext);
#ifdef DBG
	static void HashEntry_Init(void* pItem, void* pvContext);
	static void HashEntry_Release(void* pItem);
	static void HashEntry_Dealloc(void* pItem);
#endif // DBG

#ifndef DPNBUILD_PREALLOCATEDMEMORYMODEL
	void				GrowTable( void );
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
	BOOL				LocalFind( PVOID pvKey, CBilink** ppLinkage );

	DWORD				m_dwAllocatedEntries;
	DWORD				m_dwEntriesInUse;

#ifndef DPNBUILD_PREALLOCATEDMEMORYMODEL
	BYTE				m_bGrowBits;
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
	BYTE				m_bBitDepth;

	PFNHASHTABLECOMPARE	m_pfnCompareFunction;
	PFNHASHTABLEHASH	m_pfnHashFunction;

	CBilink*			m_pblEntries;
	CFixedPool			m_EntryPool;

	DEBUG_ONLY(BOOL		m_fInitialized);
};

#endif	// __HASHTABLE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\memlog.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 - 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       memlog.h
 *  Content:	format of the memory log for DPlay debugging
 *				
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  08-24-00		masonb		Created
 *
 ***************************************************************************/

#ifndef _DPLAY_SHARED_MEMLOG_
#define _DPLAY_SHARED_MEMLOG_

	// Max string length (in bytes) for MEM logging
#define DPLOG_MAX_STRING (512 * sizeof(TCHAR))	
	// Default number of entries for mem log. Adjustable from win.ini
#define DPLOG_DEFAULT_ENTRIES	40000		

#define DPLOG_HEADERSIZE (sizeof(SHARED_LOG_FILE))
#define DPLOG_ENTRYSIZE (sizeof(MEMLOG_ENTRY) + DPLOG_MAX_STRING)

#define BASE_LOG_MEMFILENAME  	"DPLAY8MEMLOG-0"
#define BASE_LOG_MUTEXNAME 	"DPLAY8MEMLOGMUTEX-0"

#pragma warning(disable:4200) // 0 length array
typedef struct _MEM_LOG_ENTRY 
{
	DWORD	tLogged;
	TCHAR	str[0];
} MEMLOG_ENTRY, *PMEMLOG_ENTRY;

typedef struct _SHARED_LOG_FILE
{
	DWORD   	nEntries;
	DWORD		cbLine;
	DWORD 		iWrite;
} SHARED_LOG_FILE, *PSHARED_LOG_FILE;
#pragma warning(default:4200)


#ifdef DPNBUILD_LIBINTERFACE
extern PSHARED_LOG_FILE		g_pMemLog;
#endif // DPNBUILD_LIBINTERFACE


#endif // _DPLAY_SHARED_MEMLOG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\hashtable.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       HashTable.cpp
 *  Content:    Hash Table Object
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  08/13/2001	masonb	Created
 *
 *
 ***************************************************************************/

#include "dncmni.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

//
// pool management functions
//
#undef DPF_MODNAME
#define DPF_MODNAME "CHashTable::HashEntry_Alloc"
BOOL CHashTable::HashEntry_Alloc( void *pItem, void* pvContext )
{
	DNASSERT( pItem != NULL );

	_HASHTABLE_ENTRY* pEntry = (_HASHTABLE_ENTRY*)pItem;

	pEntry->blLinkage.Initialize();

	return	TRUE;
}

#ifdef DBG

#undef DPF_MODNAME
#define DPF_MODNAME "CHashTable::HashEntry_Init"
void CHashTable::HashEntry_Init( void *pItem, void* pvContext )
{
	DNASSERT( pItem != NULL );

	const _HASHTABLE_ENTRY* pEntry = (_HASHTABLE_ENTRY*)pItem;

	DNASSERT( pEntry->blLinkage.IsEmpty() );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CHashTable::HashEntry_Release"
void CHashTable::HashEntry_Release( void *pItem )
{
	DNASSERT( pItem != NULL );

	const _HASHTABLE_ENTRY* pEntry = (_HASHTABLE_ENTRY*)pItem;

	DNASSERT( pEntry->blLinkage.IsEmpty() );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CHashTable::HashEntry_Dealloc"
void CHashTable::HashEntry_Dealloc( void *pItem )
{
	DNASSERT( pItem != NULL );

	const _HASHTABLE_ENTRY* pEntry = (_HASHTABLE_ENTRY*)pItem;

	DNASSERT( pEntry->blLinkage.IsEmpty() );
}

#endif // DBG


#undef DPF_MODNAME
#define DPF_MODNAME "CHashTable::CHashTable"
CHashTable::CHashTable() 
{
	DEBUG_ONLY(m_fInitialized = FALSE);
};

#undef DPF_MODNAME
#define DPF_MODNAME "CHashTable::~CHashTable"
CHashTable::~CHashTable()
{ 
#ifdef DBG
	DNASSERT(!m_fInitialized);
#endif // DBG
};	

#undef DPF_MODNAME
#define DPF_MODNAME "CHashTable::Initialize"
BOOL CHashTable::Initialize( BYTE bBitDepth,
#ifndef DPNBUILD_PREALLOCATEDMEMORYMODEL
						BYTE bGrowBits,
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
						PFNHASHTABLECOMPARE pfnCompare,
						PFNHASHTABLEHASH pfnHash )
{
	DNASSERT(bBitDepth != 0);

	memset(this, 0, sizeof(CHashTable));

	m_dwAllocatedEntries = 1 << bBitDepth;
	m_pfnCompareFunction = pfnCompare;
	m_pfnHashFunction = pfnHash;

	m_pblEntries = (CBilink*)DNMalloc(sizeof(CBilink) * m_dwAllocatedEntries);
	if (m_pblEntries == NULL)
	{
		DPFERR("Failed to allocate hash entries array");
		return FALSE;
	}

#ifdef DBG
	if (!m_EntryPool.Initialize(sizeof(_HASHTABLE_ENTRY), HashEntry_Alloc, HashEntry_Init, HashEntry_Release, HashEntry_Dealloc))
#else
	if (!m_EntryPool.Initialize(sizeof(_HASHTABLE_ENTRY), HashEntry_Alloc, NULL, NULL, NULL))
#endif // DBG
	{
		DPFERR("Failed to initialize hash entries pool");
		DNFree(m_pblEntries);
		m_pblEntries = NULL;
		return FALSE;
	}

	for (DWORD dwEntry = 0; dwEntry < m_dwAllocatedEntries; dwEntry++)
	{
		m_pblEntries[dwEntry].Initialize();
	}

	m_bBitDepth = bBitDepth;
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
	//
	// Pre-allocate all hash entries now.
	//
	if (m_EntryPool.Preallocate(m_dwAllocatedEntries, NULL) != m_dwAllocatedEntries)
	{
		DPFERR("Failed to preallocate hash entries");
		m_EntryPool.DeInitialize();
		DNFree(m_pblEntries);
		m_pblEntries = NULL;
		return FALSE;
	}
#else // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
	m_bGrowBits = bGrowBits;
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL

	DEBUG_ONLY(m_fInitialized = TRUE);

	DPFX(DPFPREP, 5,"[%p] Hash table initialized", this);

	return TRUE;
};


#undef DPF_MODNAME
#define DPF_MODNAME "CHashTable::Deinitialize"
void CHashTable::Deinitialize( void )
{
#ifdef DBG
	DNASSERT(m_fInitialized);
	m_fInitialized = FALSE;
#endif // DBG

	DNASSERT( m_dwEntriesInUse == 0 );

	if (m_pblEntries)
	{
		DNFree(m_pblEntries);
		m_pblEntries = NULL;
	}

	m_EntryPool.DeInitialize();

	DPFX(DPFPREP, 5,"[%p] Hash table deinitialized", this);
};


#ifndef DPNBUILD_PREALLOCATEDMEMORYMODEL

#undef DPF_MODNAME
#define DPF_MODNAME "CHashTable::GrowTable"
void CHashTable::GrowTable( void )
{
#ifdef DBG
	DNASSERT( m_fInitialized != FALSE);
	DNASSERT( m_bGrowBits != 0 );
#endif // DBG

	CBilink* pblOldEntries;
	BYTE bNewHashBitDepth;
	DWORD dwNewHashSize;
	DWORD dwOldHashSize;
#ifdef DBG
	DWORD dwOldEntryCount;
#endif // DBG

	// We're more than 50% full, find a new has table size that will accomodate
	// all of the current entries, and keep a pointer to the old data in case
	// the memory allocation fails.
	pblOldEntries = m_pblEntries;
	bNewHashBitDepth = m_bBitDepth;

	do
	{
		bNewHashBitDepth += m_bGrowBits;
	} while (m_dwEntriesInUse >= (DWORD)((1 << bNewHashBitDepth) / 2));

	//
	// assert that we don't pull up half of the machine's address space!
	//
	DNASSERT( bNewHashBitDepth <= ( sizeof( UINT_PTR ) * 8 / 2 ) );

	dwNewHashSize = 1 << bNewHashBitDepth;

	m_pblEntries = (CBilink*)DNMalloc(sizeof(CBilink) * dwNewHashSize);
	if ( m_pblEntries == NULL )
	{
		// Allocation failed, restore the old data pointer and insert the item
		// into the hash table.  This will probably result in adding to a bucket.
		m_pblEntries = pblOldEntries;
		DPFX(DPFPREP,  0, "Warning: Failed to grow hash table when 50% full!" );
		return;
	}

	// we have more memory, reorient the hash table and re-add all of
	// the old items
	DEBUG_ONLY( dwOldEntryCount = m_dwEntriesInUse );

	dwOldHashSize = 1 << m_bBitDepth;
	m_bBitDepth = bNewHashBitDepth;

	m_dwAllocatedEntries = dwNewHashSize;
	m_dwEntriesInUse = 0;

	for (DWORD dwEntry = 0; dwEntry < dwNewHashSize; dwEntry++)
	{
		m_pblEntries[dwEntry].Initialize();
	}

	DNASSERT( dwOldHashSize > 0 );
	while ( dwOldHashSize > 0 )
	{
		dwOldHashSize--;
		while (pblOldEntries[dwOldHashSize].GetNext() != &pblOldEntries[dwOldHashSize])
		{
			BOOL	fTempReturn;
			PVOID	pvKey;
			PVOID	pvData;
			_HASHTABLE_ENTRY* pTempEntry;

			pTempEntry = CONTAINING_OBJECT(pblOldEntries[dwOldHashSize ].GetNext(), _HASHTABLE_ENTRY, blLinkage);

			pTempEntry->blLinkage.RemoveFromList();

			pvKey = pTempEntry->pvKey;
			pvData = pTempEntry->pvData;
			m_EntryPool.Release( pTempEntry );

			// Since we're returning the current hash table entry to the pool
			// it will be immediately reused in the new table.  We should never
			// have a problem adding to the new list.
			fTempReturn = Insert( pvKey, pvData );
			DNASSERT( fTempReturn != FALSE );
			DEBUG_ONLY( dwOldEntryCount-- );
		}
	}
#ifdef DBG
	DNASSERT(dwOldEntryCount == 0);
#endif // DBG

	DNFree(pblOldEntries);
	pblOldEntries = NULL;
};

#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL


#undef DPF_MODNAME
#define DPF_MODNAME "CHashTable::Insert"
BOOL CHashTable::Insert( PVOID pvKey, PVOID pvData )
{
	BOOL				fFound;
	CBilink*			pLink;
	_HASHTABLE_ENTRY*	pNewEntry;

	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );

	pNewEntry = NULL;

#ifndef DPNBUILD_PREALLOCATEDMEMORYMODEL
	// grow the map if applicable
	if ( ( m_dwEntriesInUse >= ( m_dwAllocatedEntries / 2 ) ) &&
		 ( m_bGrowBits != 0 ) )
	{
		GrowTable();
	}
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL

	// get a new table entry before trying the lookup
	pNewEntry = (_HASHTABLE_ENTRY*)m_EntryPool.Get();
	if ( pNewEntry == NULL )
	{
		DPFX(DPFPREP,  0, "Problem allocating new hash table entry" );
		return FALSE;
	}

	// scan for this item in the list, since we're only supposed to have
	// unique items in the list, ASSERT if a duplicate is found
	fFound = LocalFind( pvKey, &pLink );
	DNASSERT( pLink != NULL );
	DNASSERT( fFound == FALSE );
	DNASSERT( pLink != NULL );

	// officially add entry to the hash table
	m_dwEntriesInUse++;
	pNewEntry->pvKey = pvKey;
	pNewEntry->pvData = pvData;
	pNewEntry->blLinkage.InsertAfter(pLink);

	return TRUE;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CHashTable::Remove"
BOOL CHashTable::Remove( PVOID pvKey )
{
#ifdef DBG
	DNASSERT( m_fInitialized != FALSE );
#endif // DBG

	CBilink* pLink;
	_HASHTABLE_ENTRY* pEntry;

	if ( !LocalFind( pvKey, &pLink ) )
	{
		return FALSE;
	}
	DNASSERT( pLink != NULL );

	pEntry = CONTAINING_OBJECT(pLink, _HASHTABLE_ENTRY, blLinkage);

	pEntry->blLinkage.RemoveFromList();

	m_EntryPool.Release( pEntry );

	DNASSERT( m_dwEntriesInUse != 0 );
	m_dwEntriesInUse--;

	return TRUE;
}


#ifndef DPNBUILD_NOREGISTRY

#undef DPF_MODNAME
#define DPF_MODNAME "CHashTable::RemoveAll"
void CHashTable::RemoveAll( void )
{
	DWORD dwHashSize;
	DWORD dwTemp;
	CBilink* pLink;
	_HASHTABLE_ENTRY* pEntry;
	
#ifdef DBG
	DNASSERT( m_fInitialized != FALSE );
#endif // DBG

	dwHashSize = 1 << m_bBitDepth;
	for(dwTemp = 0; dwTemp < dwHashSize; dwTemp++)
	{
		pLink = m_pblEntries[dwTemp].GetNext();
		while (pLink != &m_pblEntries[dwTemp])
		{
			pEntry = CONTAINING_OBJECT(pLink, _HASHTABLE_ENTRY, blLinkage);
			pLink = pLink->GetNext();
			pEntry->blLinkage.RemoveFromList();
			m_EntryPool.Release( pEntry );
			DNASSERT( m_dwEntriesInUse != 0 );
			m_dwEntriesInUse--;
		}
	}

	DNASSERT( m_dwEntriesInUse == 0 );
}

#endif // ! DPNBUILD_NOREGISTRY


#undef DPF_MODNAME
#define DPF_MODNAME "CHashTable::Find"
BOOL CHashTable::Find( PVOID pvKey, PVOID* ppvData )
{
#ifdef DBG
	DNASSERT( m_fInitialized != FALSE );
#endif // DBG

	CBilink* pLink;
	_HASHTABLE_ENTRY* pEntry;

	if (!LocalFind(pvKey, &pLink))
	{
		return FALSE;
	}
	DNASSERT(pLink != NULL);

	pEntry = CONTAINING_OBJECT(pLink, _HASHTABLE_ENTRY, blLinkage);

	*ppvData = pEntry->pvData;

	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CHashTable::LocalFind"
BOOL CHashTable::LocalFind( PVOID pvKey, CBilink** ppLinkage )
{
#ifdef DBG
	DNASSERT( m_fInitialized != FALSE);
#endif // DBG

	DWORD		dwHashResult;
	CBilink*	pLink;
	_HASHTABLE_ENTRY* pEntry;

	dwHashResult = (*m_pfnHashFunction)(pvKey, m_bBitDepth );
	DNASSERT(dwHashResult < (DWORD)(1 << m_bBitDepth));

	pLink = m_pblEntries[dwHashResult].GetNext();
	while (pLink != &m_pblEntries[dwHashResult])
	{
		pEntry = CONTAINING_OBJECT(pLink, _HASHTABLE_ENTRY, blLinkage);

		if ( (*m_pfnCompareFunction)( pvKey, pEntry->pvKey ) )
		{
			*ppLinkage = pLink;
			return TRUE;
		}
		pLink = pLink->GetNext();
	}

	// entry was not found, return pointer to linkage to insert after if a new
	// entry is being added to the table
	*ppLinkage = pLink;

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\orderedarray.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       OrderedArray.h
 *  Content:	COrderedArray / COrderedPtrArray Declarations
 *
 *  History:
 *   Date		By			Reason
 *   ======		==			======
 *  12-12-2001	simonpow	Created
 ***************************************************************************/


#ifndef __ORDEREDARRAY_H__
#define __ORDEREDARRAY_H__

#include "AutoArray.h"

/*
 * COrderedArray
 * Maintains an array of elements that can be inserted into and removed
 * from whilst maintaining element order. i.e. List like semantics
 * This class is useful when you want to maintain a list of items in
 * order and scan the data far more often than you modify the list.
 * If you perform lots of insert/remove operations, then a linked
 * list is probably more efficient. 
 * Memory management is handled through CAutoArray so see comments
 * in that header for more information
 *
 * If you need an array of pointers use the specialisation COrderedPtrArray
 * declared below the COrderedArray class.
 */
 

template <class T > class COrderedArray
{
public:

		//provides the type of entries held
	typedef T Entry;

		//array starts 0 zero and by default grows in multiples
		//of 16 elements at a time
	COrderedArray(DWORD dwSizeMultiple=16) : m_data(dwSizeMultiple), m_dwTopFreeSlot(0)
		{ };

		//standard d'tor
	~COrderedArray()
		{};

	/*
	 * Memory Management
	 */

		//Delete existing contents and reset the size multiplier
		//Pass 0 for size multiplier to retain the existing value
	void Reset(DWORD dwSizeMultiple=16)
		{ m_data.Reset(dwSizeMultiple); m_dwTopFreeSlot=0; };
	
		//ensure that there is enough space in the array to hold at least 
		//'numElements' without needing to re-create and copy the data
		//returns FALSE if fails due to memory allocation failure
	BOOL AllocAtLeast(DWORD dwNumElements)
		{	return m_data.AllocAtLeast(dwNumElements);	};

		//ensure there is enough space in the array to hold at least an 
		//extra 'numElements' without needing to re-create and copy the data
		//returns FALSE if fails due to memory allocation failure
	BOOL AllocExtra(DWORD dwNumElements)
		{	return m_data.AllocAtLeast(dwNumElements+m_dwTopFreeSlot);	};


	/*
	 * Adding/Modifying Elements
	 */

		//add an entry to end of array
		//returns FALSE if fails due to memory allocation failure
	BOOL AddElement(const T& elem)
		{	return m_data.SetElement(m_dwTopFreeSlot++, elem);	};

		//add a number of elements to the end of the array
		//N.B. Don't pass pointers into data in this array as 'pElem'!
		//e.g. Don't do array.AddElements(array.GetAllElements, array.GetNumElements());
		//returns FALSE if fails due to memory allocation failure
	BOOL AddElements(const T * pElem, DWORD dwNumElem);

		//add the entries from another ordered array to the end of this one
		//N.B. Don't pass array to itself (e.g. Don't do array.AddElements(array); )
		//returns FALSE if fails due to memory allocation failure
	BOOL AddElements(const COrderedArray<T>& array);
		
		//set the element at 'dwIndex' to 'elem. Upto caller to
		//ensure this doesn't create a hole in array (i.e. dwIndex must be<=Num Entries)
		//returns FALSE if fails due to memory allocation failure
	inline BOOL SetElement(DWORD dwIndex, const T& elem);
	
		//set 'dwNumElem' from 'dwIndex' to values specified by 'pElem'
		//Upto caller to ensure this doesn't create a hole in array
		//(i.e. dwIndex must be<=Num Entries)
		//N.B. Don't pass pointers into data in this array as 'pElem'!
		//e.g. Don't do array.SetElements(x, array.GetAllElements, array.GetNumElements());
		//returns FALSE if fails due to memory allocation failure
	inline BOOL SetElements(DWORD dwIndex, const T * pElem, DWORD dwNumElem);

		//insert element 'elem' at index 'dwIndex, shifting up
		//elements after 'dwIndex' if necessary
		//Upto caller to ensure this doesn't create a hole in the array
		//i.e. dwIndex is within the current range
		//returns FALSE if fails due to memory allocation failure
	BOOL InsertElement(DWORD dwIndex, const T& elem);

		//insert 'dwNumElem' elements pointed to be 'pElems' into array
		//at index 'dwIndex', shifting up any existing elements if necessary
		//Upto caller to ensure this doesn't create a hole in the array
		//i.e. dwIndex is within the current range
		//N.B. Don't pass pointers into data in this array as 'pElem'!
		//e.g. Don't do array.InsertElements(x, array.GetAllElements, array.GetNumElements());
		//returns FALSE if fails due to memory allocation failure
	BOOL InsertElements(DWORD dwIndex, const T * pElems, DWORD dwNumElem);


	/*
	 * Removing Entries
	 */

		//remove the single entry at 'dwIndex', shifting all the entries
		//between 'index'+1 and the last entry down by one.
		//Upto caller to ensure dwIndex falls within the current array range
	inline void RemoveElementByIndex(DWORD dwIndex);

		//remove a block of 'dwNumElem' elements starting at 'dwIndex', moving
		//down all entries between 'index'+1 and the last entry by 'dwNumElem'.
		//Upto caller to ensure specified block falls within the current array range
	inline void RemoveElementsByIndex(DWORD dwIndex, DWORD dwNumElem);

		//remove first entry in array that matches 'elem'
		//returns TRUE if a match is found and FALSE otherwise
	BOOL RemoveElementByValue(const T& elem);

		//remove all the current entries in the array
	void RemoveAll()
		{	m_dwTopFreeSlot=0;	};
	

	/*
	 * Accessing the array data
	 * N.B. Treat any pointers into array contents very carefully.
	 * Adding new elements to the array or using the Alloc* methods
	 * can cause them to become invalid
	 */

		//returns the number of entries
	DWORD GetNumElements() const
		{	return m_dwTopFreeSlot;	};

		//returns TRUE if array is empty
	BOOL IsEmpty() const
		{	return (m_dwTopFreeSlot==0);	};

		//return value at a specific index
	T GetElementValue(DWORD dwIndex) const
		{	return m_data.GetElementValue(dwIndex);	};

		//return reference to an element at specific index
	T& GetElementRef(DWORD dwIndex)
		{	return m_data.GetElementRef(dwIndex);	};

		//return constant reference to an element at specific index
	const T& GetElementRef(DWORD dwIndex) const
		{	return m_data.GetElementRef(dwIndex);	};

		//return a pointer to an element
	T * GetElementPtr(DWORD dwIndex)
		{	return m_data.GetElementPtr(dwIndex);	};

		//returns pointer to array of all elements
	T * GetAllElements()
		{	return m_data.GetAllElements();	};

	/*
	 * Searching Array
	 */

		//find an instance of 'elem' in array. If found returns TRUE
		//and sets 'pdwIndex' to index of element
	BOOL FindElement(const T& elem, DWORD * pdwIndex) const;

		//returns TRUE if 'elem' is present in bag
	BOOL IsElementPresent(const T& elem) const
		{	DWORD dwIndex; return (FindElement(elem, &dwIndex));	};

protected:


	CAutoArray<T> m_data;
	DWORD m_dwTopFreeSlot;

};

/*
 * Specialisation of COrderedArray for handling pointers
 * If you ever need to declare an ordered array of pointers (e.g. char *)
 * declare it as an COrderedPtrArray (e.g. COrderedPtrArray<char *>).
 * This specilisation uses a COrderedArray<void *> underneath and hence
 * re-uses the same code between all types of COrderedPtrArray.
 */ 

template <class T> class COrderedPtrArray : public COrderedArray<void * >
{
public:
	
	typedef T Entry;

	typedef COrderedArray<void * > Base;

	COrderedPtrArray(DWORD dwSizeMultiple=16) : COrderedArray<void*>(dwSizeMultiple)
		{ };
	
	BOOL AddElement(T elem)
		{	return Base::AddElement((void * ) elem);	};

	BOOL AddElements(const T * pElem, DWORD dwNumElem)
		{	return Base::AddElements((void **) pElem, dwNumElem);	};

	BOOL AddElements(const COrderedArray<T>& array)
		{	return Base::AddElements((COrderedArray<void*>&) array);	};

	BOOL SetElement(DWORD dwIndex, T elem)
		{	return Base::SetElement(dwIndex, (void * ) elem);	};
	
	BOOL SetElements(DWORD dwIndex, T * pElem, DWORD dwNumElem)
		{	return Base::SetElements(dwIndex, (void**) pElem, dwNumElem);	};

	BOOL InsertElement(DWORD dwIndex, T elem)
		{	return Base::InsertElement(dwIndex, (void * ) elem);	};

	BOOL InsertElements(DWORD dwIndex, const T * pElems, DWORD dwNumElem)
		{	return Base::InsertElements(dwIndex, (void **) pElems, dwNumElem);	};

	BOOL RemoveElementByValue(T elem)
		{	return Base::RemoveElementByValue((void *) elem);	};

	T GetElementValue(DWORD dwIndex) const
		{	return (T) m_data.GetElementValue(dwIndex);	};

	T& GetElementRef(DWORD dwIndex)
		{	return (T&) m_data.GetElementRef(dwIndex);	};
	const T& GetElementRef(DWORD dwIndex) const
		{	return (const T&) m_data.GetElementRef(dwIndex);	};

	T * GetElementPtr(DWORD dwIndex)
		{	return (T*) m_data.GetElementPtr(dwIndex);	};

	T * GetAllElements()
		{	return (T*) m_data.GetAllElements();	};

	BOOL FindElement(T elem, DWORD * pdwIndex) const
		{	return Base::FindElement((void * ) elem, pdwIndex);	};

	BOOL IsElementPresent(T elem) const
		{	DWORD dwIndex; return (Base::FindElement((void * ) elem, &dwIndex));	};
};

/* 
 * COrderedArray inline methods
 */

template <class T>
BOOL COrderedArray<T>::AddElements(const T * pElem, DWORD dwNumElem)
{
		//ensure pointer passed isn't into this arrays contents
	DNASSERT(!(pElem>=m_data.GetAllElements() && pElem<m_data.GetAllElements()+m_data.GetCurrentSize()));
	if (!m_data.AllocAtLeast(m_dwTopFreeSlot+dwNumElem))
		return FALSE;
	m_data.SetExistingElements(m_dwTopFreeSlot, pElem, dwNumElem);
	m_dwTopFreeSlot+=dwNumElem;
	return TRUE;
}

template <class T>
BOOL COrderedArray<T>::SetElement(DWORD dwIndex, const T& elem)
{
	DNASSERT(dwIndex<=m_dwTopFreeSlot);
	if (dwIndex==m_dwTopFreeSlot)
		return m_data.SetElement(m_dwTopFreeSlot++, elem);
	m_data.SetExistingElement(dwIndex, elem);
	return TRUE;
}

template <class T>
BOOL COrderedArray<T>::SetElements(DWORD dwIndex, const T * pElem, DWORD dwNumElem)
{
		//ensure pointer passed isn't into this arrays contents
	DNASSERT(!(pElem>=m_data.GetAllElements() && pElem<m_data.GetAllElements()+m_data.GetCurrentSize()));
		//ensure hole isn't created
	DNASSERT(dwIndex<=m_dwTopFreeSlot);
	if (!m_data.SetElements(dwIndex, pElem, dwNumElem))
		return FALSE;
	dwIndex+=dwNumElem;
	m_dwTopFreeSlot = dwIndex>m_dwTopFreeSlot ? dwIndex : m_dwTopFreeSlot;
	return TRUE;
}

template <class T>
void COrderedArray<T>::RemoveElementByIndex(DWORD dwIndex)
{
	DNASSERT(dwIndex<m_dwTopFreeSlot);
	m_data.MoveElements(dwIndex+1, m_dwTopFreeSlot-dwIndex-1, dwIndex, FALSE);
	m_dwTopFreeSlot--;
};

template <class T>
void COrderedArray<T>::RemoveElementsByIndex(DWORD dwIndex, DWORD dwNumElem)
{
	DNASSERT(dwIndex+dwNumElem<=m_dwTopFreeSlot);
	m_data.MoveElements(dwIndex+dwNumElem, m_dwTopFreeSlot-dwIndex-dwNumElem, dwIndex, FALSE);
	m_dwTopFreeSlot-=dwNumElem;
}



/*
 * If not building with explicit template instantiation then also
 * include all other methods for COrderedArray
 */

#ifndef DPNBUILD_EXPLICIT_TEMPLATES
#include "OrderedArray.inl"
#endif


#endif	//#ifndef __ORDEREDARRAY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\memorytracking.h ===
/*==========================================================================
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       MemoryTracking.h
 *  Content:	Debug memory tracking for detecting leaks, overruns, etc.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/14/2001	masonb	Created
 *
 ***************************************************************************/

#ifndef	__MEMORYTRACKING_H__
#define	__MEMORYTRACKING_H__



#ifdef DBG

BOOL DNMemoryTrackInitialize(DWORD_PTR dwpMaxMemUsage);
void DNMemoryTrackDeinitialize();

BOOL DNMemoryTrackDumpLeaks();


void* DNMemoryTrackHeapAlloc(DWORD_PTR MemorySize);
void DNMemoryTrackHeapFree(void* pMemory);
void DNMemoryTrackValidateMemory();

#define DNMalloc( size )							DNMemoryTrackHeapAlloc( size )
#define DNFree( pData )								DNMemoryTrackHeapFree( pData )
#define DNValidateMemory()							DNMemoryTrackValidateMemory()

#else // !DBG

#ifdef DPNBUILD_FIXEDMEMORYMODEL

BOOL DNMemoryTrackInitialize(DWORD_PTR dwpMaxMemUsage);
void DNMemoryTrackDeinitialize();
extern HANDLE		g_hMemoryHeap;
#define DNMemoryTrackGetHeap()						(g_hMemoryHeap)

#else // ! DPNBUILD_FIXEDMEMORYMODEL

#define DNMemoryTrackInitialize(dwMaxMemUsage)		(TRUE)
#define DNMemoryTrackDeinitialize()
#define DNMemoryTrackGetHeap						GetProcessHeap

#endif // ! DPNBUILD_FIXEDMEMORYMODEL

#define DNMalloc( size )							HeapAlloc( DNMemoryTrackGetHeap(), 0, size )
#define DNFree( pData )								HeapFree( DNMemoryTrackGetHeap(), 0, pData )
#define DNValidateMemory()

#endif // DBG


#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL

void DNMemoryTrackAllowAllocations(BOOL fAllow);
extern BOOL		g_fAllocationsAllowed;
#define DNMemoryTrackAreAllocationsAllowed()		(g_fAllocationsAllowed)

#else // ! DPNBUILD_PREALLOCATEDMEMORYMODEL

#define DNMemoryTrackAllowAllocations( fAllow )
#define DNMemoryTrackAreAllocationsAllowed()		(TRUE)

#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL



#endif	// __MEMORYTRACKING_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\osind.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       OSInd.h
 *  Content:	OS indirection functions to abstract OS specific items.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	07/12/1999	jtk		Created
 *	10/16/2001	vanceo		Added AssertNoCriticalSectionsTakenByThisThread capability
 *
 ***************************************************************************/

#ifndef	__OSIND_H__
#define	__OSIND_H__

#include "CallStack.h"
#include "ClassBilink.h"
#include "HandleTracking.h"
#include "CritsecTracking.h"
#include "MemoryTracking.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

#define GUID_STRING_LEN 39

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifndef	OFFSETOF
#define OFFSETOF(s,m)				( ( INT_PTR ) ( ( PVOID ) &( ( (s*) 0 )->m ) ) )
#endif // OFFSETOF

//returns a pointer to a container structure given an internal member
//con_type is the container type, mem_name is the member name and mem_ptr is the
//pointer to the member

#ifndef CONTAINEROF
#define CONTAINEROF(con_type,mem_name,mem_ptr)	((con_type * ) (((char * ) mem_ptr)-\
						( ( int ) ( ( void * ) &( ( (con_type*) 0 )->mem_name ) ) )));
#endif // CONTAINEROF

#ifndef	LENGTHOF
#define	LENGTHOF( arg )				( sizeof( arg ) / sizeof( arg[ 0 ] ) )
#endif // OFFSETOF

#ifndef _MIN
#define _MIN(a, b) ((a) < (b) ? (a) : (b))
#endif // _MIN

#ifndef _MAX
#define _MAX(a, b) ((a) > (b) ? (a) : (b))
#endif // _MAX

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//
// initialization functions
//
BOOL	DNOSIndirectionInit( DWORD_PTR dwpMaxMemUsage );
void	DNOSIndirectionDeinit( void );

#ifndef DPNBUILD_NOPARAMVAL

extern BOOL IsValidStringA( const CHAR * const swzString );
#define DNVALID_STRING_A(a)		IsValidStringA(a)

extern BOOL IsValidStringW( const WCHAR * const szString );
#define DNVALID_STRING_W(a)		IsValidStringW(a)

#define DNVALID_WRITEPTR(a,b)	(!IsBadWritePtr(a,b))
#define DNVALID_READPTR(a,b)	(!IsBadReadPtr(a,b))

#endif // ! DPNBUILD_NOPARAMVAL

//
// Function to get OS version.  Supported returns:
//	VER_PLATFORM_WIN32_WINDOWS - Win9x
//	VER_PLATFORM_WIN32_NT - WinNT
//	VER_PLATFORM_WIN32s - Win32s on Win3.1
//	VER_PLATFORM_WIN32_CE - WinCE
//	
#if ((! defined(WINCE)) && (! defined(_XBOX)))
UINT_PTR	DNGetOSType( void );
#endif // ! WINCE and ! _XBOX

struct in_addr;
typedef struct in_addr IN_ADDR;
void DNinet_ntow( IN_ADDR sin, WCHAR* pwsz );

#ifdef WINNT
BOOL		DNOSIsXPOrGreater( void );
#endif // WINNT

#ifndef DPNBUILD_NOSERIALSP
// Used only by serial provider
HINSTANCE	DNGetApplicationInstance( void );
#endif // ! DPNBUILD_NOSERIALSP

#ifdef WINNT
PSECURITY_ATTRIBUTES DNGetNullDacl();
#else
#define DNGetNullDacl() 0
#endif // WINNT

#ifndef VER_PLATFORM_WIN32_CE
#define VER_PLATFORM_WIN32_CE           3
#endif // VER_PLATFORM_WIN32_CE

#if ((defined(WINCE)) || (defined(_XBOX)))
#define	IsUnicodePlatform TRUE
#else // ! WINCE and ! _XBOX
#define	IsUnicodePlatform (DNGetOSType() == VER_PLATFORM_WIN32_NT || DNGetOSType() == VER_PLATFORM_WIN32_CE)
#endif // ! WINCE and ! _XBOX


#ifdef WINCE
#define GETTIMESTAMP() GetTickCount()
#else
#define GETTIMESTAMP() timeGetTime()
#endif // WINCE

	//return a quick to generate but not particularly random number
inline DWORD DNGetFastRandomNumber()
{
	return (rand() | (rand() << 16));
}

#ifndef _XBOX

extern HCRYPTPROV  g_hCryptProv;

	//fill out an arbitary length buffer with good quality random data
inline void DNGetGoodRandomData(void * pvData, DWORD dwNumBytes)
{
	CryptGenRandom(g_hCryptProv, dwNumBytes, (BYTE * ) pvData);
}

#else

	//fill out an arbitary length buffer with good quality random data
inline void DNGetGoodRandomData(void * pvData, DWORD dwNumBytes)
{
	XNetRandom((BYTE * ) pvData, dwNumBytes);
}

#endif //!_XBOX

	//return a highly random number (suitable for crypto and key protocols)
inline DWORD DNGetGoodRandomNumber()
{
	DWORD dwRetVal;
	DNGetGoodRandomData(&dwRetVal, sizeof(dwRetVal));
	return dwRetVal;
}		


//
// Interlocked functions (not actually interlocked when DPNBUILD_ONLYONETHREAD)
//
#ifdef DPNBUILD_ONLYONETHREAD
inline LONG DNInterlockedIncrement( IN OUT LONG volatile *Addend )
{
	return ++(*Addend);
}
inline LONG DNInterlockedDecrement( IN OUT LONG volatile *Addend )
{
	return --(*Addend);
}
inline LONG DNInterlockedExchange( IN OUT LONG volatile *Target, IN LONG Value )
{
	LONG	Previous;


	Previous = *Target;
	*Target = Value;
	return Previous;
}
inline LONG DNInterlockedExchangeAdd( IN OUT LONG volatile *Addend, IN LONG Value )
{
	LONG	Previous;


	Previous = *Addend;
	*Addend = Previous + Value;
	return Previous;
}
inline LONG DNInterlockedCompareExchange( IN OUT LONG volatile *Destination, IN LONG Exchange, IN LONG Comperand )
{
	LONG	Previous;


	Previous = *Destination;
	if (Previous == Comperand)
	{
		*Destination = Exchange;
	}
	return Previous;
}
inline PVOID DNInterlockedCompareExchangePointer( IN OUT PVOID volatile *Destination, IN PVOID Exchange, IN PVOID Comperand )
{
	PVOID	Previous;


	Previous = *Destination;
	if (Previous == Comperand)
	{
		*Destination = Exchange;
	}
	return Previous;
}
inline PVOID DNInterlockedExchangePointer( IN OUT PVOID volatile *Target, IN PVOID Value )
{
	PVOID	Previous;


	Previous = *Target;
	*Target = Value;
	return Previous;
}
#else // ! DPNBUILD_ONLYONETHREAD
/*
#ifdef WINCE
#if defined(_ARM_)
#define InterlockedExchangeAdd \
        ((long (*)(long *target, long increment))(PUserKData+0x3C0))
#elif defined(_X86_)
LONG WINAPI InterlockedExchangeAdd( LPLONG Addend, LONG Increment );
#else
#error("Unknown platform")
#endif // Platform
#endif // WINCE
*/
#define DNInterlockedIncrement( Addend )											InterlockedIncrement( Addend )
#define DNInterlockedDecrement( Addend )											InterlockedDecrement( Addend )
#define DNInterlockedExchange( Target, Value )										InterlockedExchange( Target, Value )
#define DNInterlockedExchangeAdd( Target, Value )									InterlockedExchangeAdd( Target, Value )
#ifdef WINCE
// NOTE: InterlockedTestExchange params 2 and 3 reversed intentionally, CE is that way
#define DNInterlockedCompareExchange( Destination, Exchange, Comperand )			InterlockedTestExchange( Destination, Comperand, Exchange )
#define DNInterlockedCompareExchangePointer( Destination, Exchange, Comperand )		(PVOID) (DNInterlockedCompareExchange( (LPLONG) Destination, (LONG) Exchange, (LONG) Comperand ))
#define DNInterlockedExchangePointer( Target, Value )								(PVOID) (DNInterlockedExchange( (LPLONG) (Target), (LPLONG) (Value) ))
#else // ! WINCE
#define DNInterlockedCompareExchange( Destination, Exchange, Comperand )			InterlockedCompareExchange( Destination, Exchange, Comperand )
#define DNInterlockedCompareExchangePointer( Destination, Exchange, Comperand )		InterlockedCompareExchangePointer( Destination, Exchange, Comperand )
#define DNInterlockedExchangePointer( Target, Value )								InterlockedExchangePointer( Target, Value )
#endif // WINCE
#endif // ! DPNBUILD_ONLYONETHREAD

// Special initialize to set spin count, avoid out-of-memory exceptions at Enter/Leave
BOOL DNOSInitializeCriticalSection( CRITICAL_SECTION* pCriticalSection );

#ifdef WINNT
#define GLOBALIZE_STR _T("Global\\")
#else
#define GLOBALIZE_STR _T("")
#endif // WINNT

#if defined(WINCE) && !defined(WINCE_ON_DESKTOP)
#define _TWINCE(x) __T(x)
#else
#define _TWINCE(x) x
#endif // WINCE

//
// Memory functions
//

#ifdef DPNBUILD_LIBINTERFACE

#define new		__wont_compile_dont_use_new_operator__
#define delete	__wont_compile_dont_use_delete_operator__

#else // ! DPNBUILD_LIBINTERFACE

//**********************************************************************
// ------------------------------
// operator new - allocate memory for a C++ class
//
// Entry:		Size of memory to allocate
//
// Exit:		Pointer to memory
//				NULL = no memory available
//
// Notes:	This function is for classes only and will ASSERT on zero sized
//			allocations!  This function also doesn't do the whole proper class
//			thing of checking for replacement 'new handlers' and will not throw
//			an exception if allocation fails.
// ------------------------------
inline	void*	__cdecl operator new( size_t size )
{
	return DNMalloc( size );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// operator delete - deallocate memory for a C++ class
//
// Entry:		Pointer to memory
//
// Exit:		Nothing
//
// Notes:	This function is for classes only and will ASSERT on NULL frees!
// ------------------------------
inline	void	__cdecl operator delete( void *pData )
{
	//
	// Voice and lobby currently try allocating 0 byte buffers, can't disable this check yet.
	//
	if( pData == NULL )
		return;
	
	DNFree( pData );
}
//**********************************************************************

#endif // ! DPNBUILD_LIBINTERFACE


#ifdef WINCE
#ifdef DBG
UINT DNGetProfileInt(LPCTSTR lpszSection, LPCTSTR lpszEntry, int nDefault);
#endif // DBG

#ifndef WINCE_ON_DESKTOP
HANDLE WINAPI OpenEvent(IN DWORD dwDesiredAccess, IN BOOL bInheritHandle, IN LPCWSTR lpName);
HANDLE WINAPI OpenFileMapping(IN DWORD dwDesiredAccess, IN BOOL bInheritHandle, IN LPCWSTR lpName);
HANDLE WINAPI OpenMutex(IN DWORD dwDesiredAccess, IN BOOL bInheritHandle, IN LPCWSTR lpName);
#endif // !WINCE_ON_DESKTOP

#define WaitForSingleObjectEx(handle, time, fAlertable) WaitForSingleObject(handle, time)
#define WaitForMultipleObjectsEx(count, handles, waitall, time, fAlertable) WaitForMultipleObjects(count, handles, waitall, time)
#ifndef WINCE_ON_DESKTOP
#define GetWindowLongPtr(a, b) GetWindowLong(a, b)
#define GWLP_USERDATA GWL_USERDATA
#define SetWindowLongPtr(a, b, c) SetWindowLong(a, b, c)
#endif // WINCE_ON_DESKTOP
#define SleepEx(a, b) Sleep(a)

#ifndef MUTEX_ALL_ACCESS
#define MUTEX_ALL_ACCESS 0
#endif // MUTEX_ALL_ACCESS
#ifndef NORMAL_PRIORITY_CLASS
#define NORMAL_PRIORITY_CLASS 0
#endif // NORMAL_PRIORITY_CLASS

#else // ! WINCE
#ifdef DBG
#if ((defined(_XBOX)) && (! defined(XBOX_ON_DESKTOP)))
UINT DNGetProfileInt(LPCTSTR lpszSection, LPCTSTR lpszEntry, int nDefault);
#else // ! _XBOX or XBOX_ON_DESKTOP
#define DNGetProfileInt(lpszSection, lpszEntry, nDefault)	GetProfileInt(lpszSection, lpszEntry, nDefault)
#endif// ! _XBOX or XBOX_ON_DESKTOP
#endif // DBG
#endif // ! WINCE

#if ((defined(WINCE)) || (defined(DPNBUILD_LIBINTERFACE)))
HRESULT DNCoCreateGuid(GUID* pguid);
#else // ! WINCE and ! DPNBUILD_LIBINTERFACE
#define DNCoCreateGuid CoCreateGuid
#endif // ! WINCE and ! DPNBUILD_LIBINTERFACE


#ifdef _XBOX

#define swprintf	wsprintfW

#else // ! _XBOX

#ifdef WINCE
static inline FARPROC DNGetProcAddress(HMODULE hModule, LPCSTR lpProcName)
	{	return GetProcAddressA(hModule, lpProcName);	};
#else
static inline FARPROC DNGetProcAddress(HMODULE hModule, LPCSTR lpProcName)
	{	return GetProcAddress(hModule, lpProcName);	};
#endif

#endif // _XBOX

#endif	// __OSIND_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\orderedarray.inl ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       OrderedArray.inl
 *  Content:	COrderedArray methods
 *
 *  History:
 *   Date		By			Reason
 *   ======		==			======
 *  12-12-2001	simonpow	Created
 ***************************************************************************/


template <class T>
BOOL COrderedArray<T>::AddElements(const COrderedArray<T>& array)
{
		//ensure array isn't passed to itself
	DNASSERT(this!=&array);
	if (!m_data.AllocAtLeast(m_dwTopFreeSlot+array.GetNumElements()))
		return FALSE;
	m_data.SetExistingElements(m_dwTopFreeSlot, 
				const_cast<COrderedArray<T>&>(array).GetAllElements(), array.GetNumElements());
	m_dwTopFreeSlot+=array.GetNumElements();
	return TRUE;
}


template <class T>
BOOL COrderedArray<T>::InsertElement(DWORD dwIndex, const T& elem)
{
	DNASSERT(dwIndex<=m_dwTopFreeSlot);
	if (dwIndex==m_dwTopFreeSlot)
		return m_data.SetElement(m_dwTopFreeSlot++, elem);
		//move all the elements above index up one and insert the new element
	if (!m_data.MoveElements(dwIndex, m_dwTopFreeSlot-dwIndex, dwIndex+1, FALSE))
		return FALSE;
	m_data.SetExistingElement(dwIndex, elem);
	m_dwTopFreeSlot++;
	return true;
}

template <class T>
BOOL COrderedArray<T>::InsertElements(DWORD dwIndex, const T * pElems, DWORD dwNumElem)
{
		//ensure hole isn't created
	DNASSERT(dwIndex<=m_dwTopFreeSlot);
		//ensure pointer passed isn't into this arrays contents
	DNASSERT(!(pElems>=m_data.GetAllElements() && pElems<m_data.GetAllElements()+m_data.GetCurrentSize()));
	if (dwIndex!=m_dwTopFreeSlot)
	{
		if (!m_data.MoveElements(dwIndex, m_dwTopFreeSlot-dwIndex, dwIndex+dwNumElem, FALSE))
			return FALSE;
		m_data.SetExistingElements(dwIndex, pElems, dwNumElem);
	}
	else if (!m_data.SetElements(dwIndex, pElems, dwNumElem))
		return FALSE;
	m_dwTopFreeSlot+=dwNumElem;
	return TRUE;
}

template <class T>
BOOL COrderedArray<T>::RemoveElementByValue(const T& elem)
{
	for (DWORD dwLoop=0; dwLoop<m_dwTopFreeSlot; dwLoop++)
	{
		if (m_data.GetElementRef(dwLoop)==elem)
		{
			m_data.MoveElements(dwLoop+1, m_dwTopFreeSlot-dwLoop-1, dwLoop, FALSE);
			m_dwTopFreeSlot--;
			return TRUE;
		}
	}
	return FALSE;
}

template <class T>
BOOL COrderedArray<T>::FindElement(const T& elem, DWORD * pdwIndex) const
{
	for (DWORD dwLoop=0; dwLoop<m_dwTopFreeSlot; dwLoop++)
	{
		if (m_data.GetElementRef(dwLoop)==elem)
		{
			*pdwIndex=dwLoop;
			return TRUE;
		}
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\memorytracking.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       MemoryTracking.cpp
 *  Content:	Debug memory tracking for detecting leaks, overruns, etc.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/14/2001	masonb	Created
 *
 ***************************************************************************/

#include "dncmni.h"



#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
BOOL				g_fAllocationsAllowed = TRUE;
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL

#ifdef DBG

#ifdef _WIN64
#define	GUARD_SIGNATURE	0xABABABABABABABAB
#else // !_WIN64
#define	GUARD_SIGNATURE	0xABABABAB
#endif // _WIN64

// Structure prepended to memory allocations to check for leaks.
struct MEMORY_HEADER
{
	CBilink			blLinkage;				 // size = two pointers
	DWORD_PTR		dwpSize;				 // size = pointer
	CCallStack		AllocCallStack;			 // size = 12 pointers
	DWORD_PTR		dwpPreGuard;			 // size = pointer
	// We want what follows to always be 16-byte aligned and #pragma pack doesn't seem to ensure that
};

CRITICAL_SECTION	g_AllocatedMemoryLock;
CBilink				g_blAllocatedMemory;
DWORD_PTR			g_dwpCurrentNumMemAllocations = 0;
DWORD_PTR			g_dwpCurrentMemAllocated = 0;
DWORD_PTR			g_dwpTotalNumMemAllocations = 0;
DWORD_PTR			g_dwpTotalMemAllocated = 0;
DWORD_PTR			g_dwpPeakNumMemAllocations = 0;
DWORD_PTR			g_dwpPeakMemAllocated = 0;

#endif // DBG



#if ((defined(DBG)) || (defined(DPNBUILD_FIXEDMEMORYMODEL)))

HANDLE				g_hMemoryHeap = NULL;




#undef DPF_MODNAME
#define DPF_MODNAME "DNMemoryTrackInitialize"
BOOL DNMemoryTrackInitialize(DWORD_PTR dwpMaxMemUsage)
{
	// Ensure that we stay heap aligned for SLISTs
#ifdef _WIN64
	DBG_CASSERT(sizeof(MEMORY_HEADER) % 16 == 0);
#else // !_WIN64
	DBG_CASSERT(sizeof(MEMORY_HEADER) % 8 == 0);
#endif // _WIN64

	// Check for double init
	DNASSERT(g_hMemoryHeap == NULL);
#ifndef DPNBUILD_FIXEDMEMORYMODEL
	DNASSERT(dwpMaxMemUsage == 0);
#endif // ! DPNBUILD_FIXEDMEMORYMODEL

	DPFX(DPFPREP, 5, "Initializing Memory Tracking");

	// In debug we always maintain a separate heap and track allocations.  In retail, 
	// we don't track allocations, and will use the process heap except for
	// DPNBUILD_FIXEDMEMORYMODEL builds, where we use a separate heap so we
	// can cap the total allocation size.
#ifdef DPNBUILD_ONLYONETHREAD
	g_hMemoryHeap = HeapCreate(HEAP_NO_SERIALIZE,	// flags
#else // ! DPNBUILD_ONLYONETHREAD
	g_hMemoryHeap = HeapCreate(0,					// flags
#endif // ! DPNBUILD_ONLYONETHREAD
								dwpMaxMemUsage,		// initial size
								dwpMaxMemUsage		// maximum heap size (if 0, it can grow)
								);

	if (g_hMemoryHeap == NULL)
	{
		DPFX(DPFPREP,  0, "Failed to create memory heap!");
		return FALSE;
	}

#ifdef DBG
#pragma TODO(masonb, "Handle possibility of failure")
	InitializeCriticalSection(&g_AllocatedMemoryLock);

	g_blAllocatedMemory.Initialize();

	g_dwpCurrentNumMemAllocations = 0;
	g_dwpCurrentMemAllocated = 0;
	g_dwpTotalNumMemAllocations = 0;
	g_dwpTotalMemAllocated = 0;
	g_dwpPeakNumMemAllocations = 0;
	g_dwpPeakMemAllocated = 0;
#endif // DBG

	return TRUE;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNMemoryTrackDeinitialize"
void DNMemoryTrackDeinitialize()
{
	// Validate the heap if we're on NT and a debug build, and then destroy the heap.
	if (g_hMemoryHeap != NULL)
	{
		BOOL	fResult;
#ifdef DBG
		DWORD	dwError;


		DPFX(DPFPREP, 5, "Deinitializing Memory Tracking");
		DPFX(DPFPREP, 5, "Total num mem allocations = %u", g_dwpTotalNumMemAllocations);
		DPFX(DPFPREP, 5, "Total mem allocated       = %u", g_dwpTotalMemAllocated);
		DPFX(DPFPREP, 5, "Peak num mem allocations  = %u", g_dwpPeakNumMemAllocations);
		DPFX(DPFPREP, 5, "Peak mem allocated        = %u", g_dwpPeakMemAllocated);

		DeleteCriticalSection(&g_AllocatedMemoryLock);

#ifdef WINNT
		// Validate heap contents before shutdown.  This code only works on NT.
		fResult = HeapValidate(g_hMemoryHeap, 0, NULL);
		if (! fResult)
		{
			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Problem validating heap on destroy %d!", dwError );
			DNASSERT(! "Problem validating heap on destroy!");
		}
#endif // WINNT
#endif // DBG

		fResult = HeapDestroy(g_hMemoryHeap);
		if (! fResult)
		{
#ifdef DBG
			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Problem destroying heap %d!", dwError );
			DNASSERT(! "Problem destroying heap!");
#endif // DBG
		}

		g_hMemoryHeap = NULL;
	}
}

#endif // DBG or DPNBUILD_FIXEDMEMORYMODEL



#ifdef DBG

#undef DPF_MODNAME
#define DPF_MODNAME "DNMemoryTrackHeapAlloc"
void* DNMemoryTrackHeapAlloc(DWORD_PTR dwpSize)
{
	MEMORY_HEADER* pMemory;
	void* pReturn;

	DNASSERT(g_hMemoryHeap != NULL);

	// Voice and lobby currently try allocating 0 byte buffers, can't enable this check yet.
	//DNASSERT( Size > 0 );

	DNMemoryTrackValidateMemory();

	if (DNMemoryTrackAreAllocationsAllowed())
	{
		// We need enough room for our header plus what the user wants plus the guard signature at the end
		pMemory = (MEMORY_HEADER*)HeapAlloc(g_hMemoryHeap, 0, sizeof(MEMORY_HEADER) + dwpSize + sizeof(DWORD_PTR));
#if ((! defined(WINCE)) && (! defined(WIN95)))
		if (pMemory == NULL)
		{
			DWORD_PTR	dwpLargestFreeBlock;


			// Compact the heap to see how much size is available, and possibly try allocating again.
			dwpLargestFreeBlock = HeapCompact(g_hMemoryHeap, 0);
			if (dwpLargestFreeBlock >= (sizeof(MEMORY_HEADER) + dwpSize + sizeof(DWORD_PTR)))
			{
				DPFX(DPFPREP, 1, "Largest free block after compacting is %u bytes, allocating %u bytes again.", dwpLargestFreeBlock, dwpSize);
				pMemory = (MEMORY_HEADER*)HeapAlloc(g_hMemoryHeap, 0, sizeof(MEMORY_HEADER) + dwpSize + sizeof(DWORD_PTR));
			}
			else
			{
				DPFX(DPFPREP, 1, "Largest free block after compacting is %u bytes, cannot allocate %u bytes.", dwpLargestFreeBlock, dwpSize);
			}
		}
#endif // ! WINCE and ! WIN95
		if (pMemory != NULL)
		{
			pMemory->blLinkage.Initialize();
			pMemory->dwpSize = dwpSize;
			pMemory->AllocCallStack.NoteCurrentCallStack();
			pMemory->dwpPreGuard = GUARD_SIGNATURE;
			*(DWORD_PTR UNALIGNED *)((BYTE*)(pMemory + 1) + dwpSize) = GUARD_SIGNATURE;

			EnterCriticalSection(&g_AllocatedMemoryLock);
			pMemory->blLinkage.InsertAfter(&g_blAllocatedMemory);
			g_dwpCurrentNumMemAllocations++;
			g_dwpCurrentMemAllocated += dwpSize;
			g_dwpTotalNumMemAllocations++;
			g_dwpTotalMemAllocated += dwpSize;
			if (g_dwpCurrentNumMemAllocations > g_dwpPeakNumMemAllocations)
			{
				g_dwpPeakNumMemAllocations = g_dwpCurrentNumMemAllocations;
			}
			if (g_dwpCurrentMemAllocated > g_dwpPeakMemAllocated)
			{
				g_dwpPeakMemAllocated = g_dwpCurrentMemAllocated;
			}
			LeaveCriticalSection(&g_AllocatedMemoryLock);

			pReturn = pMemory + 1;

			// We require that the pointers we pass back are heap aligned
			DNASSERT(((DWORD_PTR)pReturn & 0xF) == 0 || // IA64
				     (((DWORD_PTR)pReturn & 0x7) == 0 && ((DWORD_PTR)pMemory & 0xF) == 0x8) || // NT32
					 (((DWORD_PTR)pReturn & 0x3) == 0 && ((DWORD_PTR)pMemory & 0xF) == 0x4) || // WIN9X
					 (((DWORD_PTR)pReturn & 0x3) == 0 && ((DWORD_PTR)pMemory & 0xF) == 0xC) // WIN9X
					 );

			DPFX(DPFPREP, 5, "Memory Allocated, pData[%p], Size[%d]", pReturn, dwpSize);
		}
		else
		{
			DPFX(DPFPREP, 0, "Failed allocating %u bytes of memory.", dwpSize);
			pReturn = NULL;
		}
	}
	else
	{
		DPFX(DPFPREP, 0, "Memory allocations are not currently allowed!");
		DNASSERT(! "Memory allocations are not currently allowed!");
		pReturn = NULL;
	}

	return pReturn;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNMemoryTrackHeapFree"
void DNMemoryTrackHeapFree(void* pvData)
{
	CBilink* pbl;
	MEMORY_HEADER* pMemory;

	DNASSERT(g_hMemoryHeap != NULL);

	DNMemoryTrackValidateMemory();

	if (pvData == NULL)
	{
		return;
	}

	EnterCriticalSection( &g_AllocatedMemoryLock );

	// Verify that we know of this pointer
	pbl = g_blAllocatedMemory.GetNext();
	while (pbl != &g_blAllocatedMemory)
	{
		pMemory = CONTAINING_RECORD(pbl, MEMORY_HEADER, blLinkage);
		if ((pMemory + 1) == pvData)
		{
			break;
		}
		pbl = pbl->GetNext();
	}
	DNASSERT(pbl != &g_blAllocatedMemory);

	pMemory->blLinkage.RemoveFromList();
	g_dwpCurrentNumMemAllocations--;
	g_dwpCurrentMemAllocated -= pMemory->dwpSize;

	LeaveCriticalSection(&g_AllocatedMemoryLock);

	DPFX(DPFPREP, 5, "Memory Freed, pData[%p], Size[%d]", pMemory + 1, pMemory->dwpSize);

	// Zero it in case someone is still trying to use it
	memset(pMemory, 0, sizeof(MEMORY_HEADER) + pMemory->dwpSize + sizeof(DWORD_PTR));

	HeapFree(g_hMemoryHeap, 0, pMemory);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNMemoryTrackValidateMemory"
void DNMemoryTrackValidateMemory()
{
	CBilink* pbl;
	MEMORY_HEADER* pMemory;
	LPCTSTR pszCause;
	DWORD_PTR dwpNumAllocations = 0;
	DWORD_PTR dwpTotalAllocated = 0;
	TCHAR CallStackBuffer[CALLSTACK_BUFFER_SIZE];

	DNASSERT(g_hMemoryHeap != NULL);

	// validate all of the allocated memory
	EnterCriticalSection( &g_AllocatedMemoryLock );

	pbl = g_blAllocatedMemory.GetNext();
	while (pbl != &g_blAllocatedMemory)
	{
		pMemory = CONTAINING_RECORD(pbl, MEMORY_HEADER, blLinkage);

		if (pMemory->dwpPreGuard != GUARD_SIGNATURE)
		{
			pszCause = _T("UNDERRUN DETECTED");
		}
		else if (*(DWORD_PTR UNALIGNED *)((BYTE*)(pMemory + 1) + pMemory->dwpSize) != GUARD_SIGNATURE)
		{
			pszCause = _T("OVERRUN DETECTED");
		}
		else
		{
			pszCause = NULL;
			dwpNumAllocations++;
			dwpTotalAllocated += pMemory->dwpSize;
		}

		if (pszCause)
		{
			pMemory->AllocCallStack.GetCallStackString(CallStackBuffer);

			DPFX(DPFPREP, 0, "Memory corruption[%s], pData[%p], Size[%d]\n%s", pszCause, pMemory + 1, pMemory->dwpSize, CallStackBuffer);

			DNASSERT(FALSE);
		}

		pbl = pbl->GetNext();
	}

	DNASSERT(dwpNumAllocations == g_dwpCurrentNumMemAllocations);
	DNASSERT(dwpTotalAllocated == g_dwpCurrentMemAllocated);

	LeaveCriticalSection(&g_AllocatedMemoryLock);

#ifdef WINNT
	// Ask the OS to validate the heap
	if (HeapValidate(g_hMemoryHeap, 0, NULL) == FALSE)
	{
		DNASSERT(FALSE);
	}
#endif // WINNT
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNMemoryTrackDumpLeaks"
BOOL DNMemoryTrackDumpLeaks()
{
	MEMORY_HEADER* pMemory;
	TCHAR CallStackBuffer[CALLSTACK_BUFFER_SIZE];
	BOOL fLeaked = FALSE;

	DNASSERT(g_hMemoryHeap != NULL);

	EnterCriticalSection( &g_AllocatedMemoryLock );

	while (!g_blAllocatedMemory.IsEmpty())
	{
		pMemory = CONTAINING_RECORD(g_blAllocatedMemory.GetNext(), MEMORY_HEADER, blLinkage);

		pMemory->AllocCallStack.GetCallStackString(CallStackBuffer);

		DPFX(DPFPREP, 0, "Memory leaked, pData[%p], Size[%d]\n%s", pMemory + 1, pMemory->dwpSize, CallStackBuffer);

		pMemory->blLinkage.RemoveFromList();

		HeapFree(g_hMemoryHeap, 0, pMemory);

		fLeaked = TRUE;
	}

	LeaveCriticalSection(&g_AllocatedMemoryLock);

	return fLeaked;
}

#endif // DBG


#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL

#undef DPF_MODNAME
#define DPF_MODNAME "DNMemoryTrackAllowAllocations"
void DNMemoryTrackAllowAllocations(BOOL fAllow)
{
	DPFX(DPFPREP, 1, "Memory allocations allowed = %i.", fAllow);
	DNInterlockedExchange((LONG*) (&g_fAllocationsAllowed), fAllow);
}

#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\osind.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       OSInd.cpp
 *  Content:	OS indirection functions to abstract OS specific items.
 *
 *  History:
 *   Date		By	Reason
 *   ====		==	======
 *	07/12/99	jtk		Created
 *	09/21/99	rodtoll	Fixed for retail builds
 *	09/22/99	jtk		Added callstacks to memory allocations
 *	08/28/2000	masonb	Voice Merge: Allow new and delete with size of 0
 *  11/28/2000  rodtoll	WinBug #206257 - Retail DPNET.DLL links to DebugBreak()
 *  12/22/2000  aarono	ManBug # 190380 use process heap for retail
 *  10/16/2001  vanceo	Add AssertNoCriticalSectionsTakenByThisThread capability
 ***************************************************************************/

#include "dncmni.h"


#define PROF_SECT		_T("DirectPlay8")

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// debug variable to make sure we're initialized before having any functions
// called
//
DEBUG_ONLY( static	BOOL		g_fOSIndirectionLayerInitialized = FALSE );

//
// OS items
//
#if ((! defined(WINCE)) && (! defined(_XBOX)))
static OSVERSIONINFO g_OSVersionInfo;
#endif // ! WINCE and ! _XBOX

#ifndef DPNBUILD_NOSERIALSP
static HINSTANCE g_hApplicationInstance;
#endif // ! DPNBUILD_NOSERIALSP

//
// Global Pools
//
#if ((! defined(DPNBUILD_LIBINTERFACE)) && (! defined(DPNBUILD_NOCLASSFACTORY)))
CFixedPool g_fpClassFactories;
CFixedPool g_fpObjectDatas;
CFixedPool g_fpInterfaceLists;
#endif // ! DPNBUILD_LIBINTERFACE and ! DPNBUILD_NOCLASSFACTORY

#ifdef WINNT
PSECURITY_ATTRIBUTES g_psa = NULL;
SECURITY_ATTRIBUTES g_sa;
BYTE g_pSD[SECURITY_DESCRIPTOR_MIN_LENGTH];
BOOL g_fDaclInited = FALSE;
PACL g_pEveryoneACL = NULL;
#endif // WINNT

	//if we're not on xbox we use the crypto api to generate good random numbers
#ifndef _XBOX
HCRYPTPROV  g_hCryptProv=NULL;
#endif

#ifndef DPNBUILD_LIBINTERFACE
#define CLASSFAC_POOL_INITED 	0x00000001
#define OBJDATA_POOL_INITED 	0x00000002
#define INTLIST_POOL_INITED 	0x00000004
#endif // ! DPNBUILD_LIBINTERFACE
#ifdef DBG
#define HANDLE_TRACKING_INITED	0x00000008
#endif // DBG
#if ((defined(DBG)) || (defined(DPNBUILD_FIXEDMEMORYMODEL)))
#define MEMORY_TRACKING_INITED	0x00000010
#endif // DBG or DPNBUILD_FIXEDMEMORYMODEL
#if ((defined(DBG)) && (! defined(DPNBUILD_ONLYONETHREAD)))
#define CRITSEC_TRACKING_INITED	0x00000020
#endif // DBG and ! DPNBUILD_ONLYONETHREAD

#if !defined(DPNBUILD_LIBINTERFACE) || defined(DBG) || defined(DPNBUILD_FIXEDMEMORYMODEL)
DWORD g_dwCommonInitFlags = 0;
#endif // !defined(DPNBUILD_LIBINTERFACE) || defined(DBG) || defined(DPNBUILD_FIXEDMEMORYMODEL)

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

//**********************************************************************
// ------------------------------
// DNOSIndirectionInit - initialize the OS indirection layer
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
//				TRUE = initialization successful
//				FALSE = initialization unsuccessful
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNOSIndirectionInit"

BOOL	DNOSIndirectionInit( DWORD_PTR dwpMaxMemUsage )
{
	BOOL			fReturn;

#ifdef DBG
	DNASSERT( g_fOSIndirectionLayerInitialized == FALSE );
#endif // DBG

	//
	// initialize
	//
	fReturn = TRUE;

#if ((! defined(WINCE)) && (! defined(_XBOX)))
	//
	// note OS version
	//
	memset( &g_OSVersionInfo, 0x00, sizeof( g_OSVersionInfo ) );
	g_OSVersionInfo.dwOSVersionInfoSize = sizeof( g_OSVersionInfo );
	if ( GetVersionEx( &g_OSVersionInfo ) == FALSE )
	{
		goto Failure;
	}
#endif // ! WINCE and ! _XBOX

#ifndef DPNBUILD_NOSERIALSP
	//
	// note application instance
	//
	g_hApplicationInstance = GetModuleHandle( NULL );
	if ( g_hApplicationInstance == NULL )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Failed to GetModuleHandle: 0x%x", dwError );
		goto Failure;
	}
#endif // ! DPNBUILD_NOSERIALSP

#if ((defined(DBG)) && (! defined(DPNBUILD_ONLYONETHREAD)))
	//
	// initialize critical section tracking code before anything else!
	//
	if ( DNCSTrackInitialize() == FALSE )
	{
		DPFX(DPFPREP,  0, "Failed to initialize critsec tracking code!" );
		DNASSERT( FALSE );
		goto Failure;
	}
	g_dwCommonInitFlags |= CRITSEC_TRACKING_INITED;
#endif // DBG and ! DPNBUILD_ONLYONETHREAD

#if ((defined(DBG)) || (defined(DPNBUILD_FIXEDMEMORYMODEL)))
	//
	// initialize memory tracking before creating new memory heap
	//
	if ( DNMemoryTrackInitialize(dwpMaxMemUsage) == FALSE )
	{
		DPFX(DPFPREP,  0, "Failed to initialize memory tracking code!" );
		DNASSERT( FALSE );
		goto Failure;
	}
	g_dwCommonInitFlags |= MEMORY_TRACKING_INITED;
#endif // DBG or DPNBUILD_FIXEDMEMORYMODEL

#ifdef DBG
	//
	// initialize handle tracking
	//
	if ( DNHandleTrackInitialize() == FALSE )
	{
		DPFX(DPFPREP,  0, "Failed to initialize handle tracking code!" );
		DNASSERT( FALSE );
		goto Failure;
	}
	g_dwCommonInitFlags |= HANDLE_TRACKING_INITED;
#endif // DBG

#if ((! defined(DPNBUILD_LIBINTERFACE)) && (! defined(DPNBUILD_NOCLASSFACTORY)))
	//
	// Initialize global pools
	//
	if (!g_fpClassFactories.Initialize( sizeof( _IDirectPlayClassFactory ), NULL, NULL, NULL, NULL))
	{
		DPFX(DPFPREP,  0, "Failed to initialize class factory pool!" );
		goto Failure;
	}
	g_dwCommonInitFlags |= CLASSFAC_POOL_INITED;

	if (!g_fpObjectDatas.Initialize( sizeof( _OBJECT_DATA ), NULL, NULL, NULL, NULL))
	{
		DPFX(DPFPREP,  0, "Failed to initialize object data pool!" );
		goto Failure;
	}
	g_dwCommonInitFlags |= OBJDATA_POOL_INITED;

	if (!g_fpInterfaceLists.Initialize( sizeof( _INTERFACE_LIST ), NULL, NULL, NULL, NULL))
	{
		DPFX(DPFPREP,  0, "Failed to initialize interface list pool!" );
		goto Failure;
	}
	g_dwCommonInitFlags |= INTLIST_POOL_INITED;
#endif // ! DPNBUILD_LIBINTERFACE and ! DPNBUILD_NOCLASSFACTORY

	srand(GETTIMESTAMP());
	
#ifndef _XBOX
	if(CryptAcquireContext( &g_hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)==FALSE) 
	{    
		DPFX(DPFPREP,  0, "Failed to aquire context to cryptography API. Last Error %u", GetLastError());
		goto Failure;
	}
#endif	//!_XBOX

#if (((! defined(WINCE)) && (! defined(_XBOX))) || (! defined(DPNBUILD_NOSERIALSP)) || (defined(DBG)) || (defined(DPNBUILD_FIXEDMEMORYMODEL)) || ((! defined(DPNBUILD_LIBINTERFACE)) && (! defined(DPNBUILD_NOCLASSFACTORY))) )
Exit:
#endif // (! WINCE and ! _XBOX) or ! DPNBUILD_NOSERIALSP or DBG or DPNBUILD_FIXEDMEMORYMODEL or (! DPNBUILD_LIBINTERFACE and ! DPNBUILD_NOCLASSFACTORY)
	if ( fReturn != FALSE )
	{
		DEBUG_ONLY( g_fOSIndirectionLayerInitialized = TRUE );
	}

	return fReturn;

#if (((! defined(WINCE)) && (! defined(_XBOX))) || (! defined(DPNBUILD_NOSERIALSP)) || (defined(DBG)) || (defined(DPNBUILD_FIXEDMEMORYMODEL)) || ((! defined(DPNBUILD_LIBINTERFACE)) && (! defined(DPNBUILD_NOCLASSFACTORY))) )
Failure:
	fReturn = FALSE;

	DNOSIndirectionDeinit();

	goto Exit;
#endif // (! WINCE and ! _XBOX) or ! DPNBUILD_NOSERIALSP or DBG or DPNBUILD_FIXEDMEMORYMODEL or (! DPNBUILD_LIBINTERFACE and ! DPNBUILD_NOCLASSFACTORY)
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNOSIndirectionDeinit - deinitialize OS indirection layer
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNOSIndirectionDeinit"

void	DNOSIndirectionDeinit( void )
{
#if ((! defined(DPNBUILD_LIBINTERFACE)) && (! defined(DPNBUILD_NOCLASSFACTORY)))
	//
	// DeInitialize global pools
	//
	if (g_dwCommonInitFlags & CLASSFAC_POOL_INITED)
	{
		g_fpClassFactories.DeInitialize();
	}
	if (g_dwCommonInitFlags & OBJDATA_POOL_INITED)
	{
		g_fpObjectDatas.DeInitialize();
	}
	if (g_dwCommonInitFlags & INTLIST_POOL_INITED)
	{
		g_fpInterfaceLists.DeInitialize();
	}
#endif // ! DPNBUILD_LIBINTERFACE and ! DPNBUILD_NOCLASSFACTORY

#ifdef DBG
	if (g_dwCommonInitFlags & HANDLE_TRACKING_INITED)
	{
		if (DNHandleTrackDumpLeaks())
		{
			// There were leaks, break so we can look at the log
			DNASSERT(0);
		}
		DNHandleTrackDeinitialize();
	}
#endif // DBG

#if ((defined(DBG)) && (! defined(DPNBUILD_ONLYONETHREAD)))
	//
	// Display CritSec leaks before displaying memory leaks, because displaying memory leaks
	// may free the memory for the CritSec and corrupt the CritSec bilink
	//
	if (g_dwCommonInitFlags & CRITSEC_TRACKING_INITED)
	{
		if (DNCSTrackDumpLeaks())
		{
			// There were leaks, break so we can look at the log
			DNASSERT(0);
		}
		DNCSTrackDeinitialize();
	}
#endif // DBG and ! DPNBUILD_ONLYONETHREAD

#if ((defined(DBG)) || (defined(DPNBUILD_FIXEDMEMORYMODEL)))
	if (g_dwCommonInitFlags & MEMORY_TRACKING_INITED)
	{
#ifdef DBG
		if (DNMemoryTrackDumpLeaks())
		{
			// There were leaks, break so we can look at the log
			DNASSERT(0);
		}
#endif // DBG
		DNMemoryTrackDeinitialize();
	}
#endif // DBG or DPNBUILD_FIXEDMEMORYMODEL


#ifndef _XBOX
	if (g_hCryptProv)
	{
		CryptReleaseContext(g_hCryptProv, 0);
		g_hCryptProv=NULL;
	}
#endif	//!_XBOX

#ifdef WINNT
	// This should be done after functions that use a Dacl will no longer be
	// called (CreateMutex, CreateFile, etc).
	if (g_pEveryoneACL)
	{
		HeapFree(GetProcessHeap(), 0, g_pEveryoneACL);
		g_pEveryoneACL = NULL;
	}
#endif // WINNT

	DEBUG_ONLY( g_fOSIndirectionLayerInitialized = FALSE );

#if !defined(DPNBUILD_LIBINTERFACE) || defined(DBG)
	g_dwCommonInitFlags = 0;
#endif // !defined(DPNBUILD_LIBINTERFACE) || defined(DBG)
}
//**********************************************************************


#undef DPF_MODNAME
#define DPF_MODNAME "DNinet_ntow"
void DNinet_ntow( IN_ADDR in, WCHAR* pwsz )
{
	// NOTE: pwsz should be 16 characters (4 3-digit numbers + 3 '.' + \0)
	swprintf(pwsz, L"%d.%d.%d.%d", in.s_net, in.s_host, in.s_lh, in.s_impno);
}


#if ((! defined(WINCE)) && (! defined(_XBOX)))
//**********************************************************************
// ------------------------------
// DNGetOSType - get OS type
//
// Entry:		Nothing
//
// Exit:		OS type
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNGetOSType"

UINT_PTR	DNGetOSType( void )
{
#ifdef DBG
	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );
#endif // DBG
	return	g_OSVersionInfo.dwPlatformId;
}
#endif // ! WINCE and ! _XBOX


#ifdef WINNT

//**********************************************************************
// ------------------------------
// DNOSIsXPOrGreater - return TRUE if OS is WindowsXP or later or NT flavor
//
// Entry:		Nothing
//
// Exit:		BOOL
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNOSIsXPOrGreater"

BOOL DNOSIsXPOrGreater( void )
{
#ifdef DBG
	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );
#endif // DBG

	return ((g_OSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) && 
		    ((g_OSVersionInfo.dwMajorVersion > 5) || ((g_OSVersionInfo.dwMajorVersion == 5) && (g_OSVersionInfo.dwMinorVersion >= 1))) 
		    );
}

//**********************************************************************

//**********************************************************************
// ------------------------------
// DNGetNullDacl - get a SECURITY_ATTRIBUTE structure that specifies a 
//					NULL DACL which is accesible by all users.
//
// Entry:		Nothing
//
// Exit:		PSECURITY_ATTRIBUTES
// ------------------------------
#undef DPF_MODNAME 
#define DPF_MODNAME "DNGetNullDacl"
PSECURITY_ATTRIBUTES DNGetNullDacl()
{
	PSID                     psidEveryone      = NULL;
	SID_IDENTIFIER_AUTHORITY siaWorld = SECURITY_WORLD_SID_AUTHORITY;
	DWORD					 dwAclSize;

	// This is done to make this function independent of DNOSIndirectionInit so that the debug
	// layer can call it before the indirection layer is initialized.
	if (!g_fDaclInited)
	{
		if (!InitializeSecurityDescriptor((SECURITY_DESCRIPTOR*)g_pSD, SECURITY_DESCRIPTOR_REVISION))
		{
			DPFX(DPFPREP,  0, "Failed to initialize security descriptor" );
			goto Error;
		}

		// Create SID for the Everyone group.
		if (!AllocateAndInitializeSid(&siaWorld, 1, SECURITY_WORLD_RID, 0,
                                      0, 0, 0, 0, 0, 0, &psidEveryone))
		{
			DPFX(DPFPREP,  0, "Failed to allocate Everyone SID" );
			goto Error;
		}

		dwAclSize = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(psidEveryone) - sizeof(DWORD);

		// Allocate the ACL, this won't be a tracked allocation and we will let process cleanup destroy it
		g_pEveryoneACL = (PACL)HeapAlloc(GetProcessHeap(), 0, dwAclSize);
		if (g_pEveryoneACL == NULL)
		{
			DPFX(DPFPREP,  0, "Failed to allocate ACL buffer" );
			goto Error;
		}

		// Intialize the ACL.
		if (!InitializeAcl(g_pEveryoneACL, dwAclSize, ACL_REVISION))
		{
			DPFX(DPFPREP,  0, "Failed to initialize ACL" );
			goto Error;
		}

		// Add the ACE.
		if (!AddAccessAllowedAce(g_pEveryoneACL, ACL_REVISION, GENERIC_ALL, psidEveryone))
		{
			DPFX(DPFPREP,  0, "Failed to add ACE to ACL" );
			goto Error;
		}

		// We no longer need the SID that was allocated.
		FreeSid(psidEveryone);
		psidEveryone = NULL;

		// Add the ACL to the security descriptor..
		if (!SetSecurityDescriptorDacl((SECURITY_DESCRIPTOR*)g_pSD, TRUE, g_pEveryoneACL, FALSE))
		{
			DPFX(DPFPREP,  0, "Failed to add ACL to security descriptor" );
			goto Error;
		}

		g_sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		g_sa.lpSecurityDescriptor = g_pSD;
		g_sa.bInheritHandle = FALSE;

		g_psa = &g_sa;

		g_fDaclInited = TRUE;
	}
Error:
	if (psidEveryone)
	{
		FreeSid(psidEveryone);
		psidEveryone = NULL;
	}
	return g_psa;
}
//**********************************************************************
#endif // WINNT

#ifndef DPNBUILD_NOSERIALSP
//**********************************************************************
// ------------------------------
// DNGetApplicationInstance - application instance
//
// Entry:		Nothing
//
// Exit:		Application instance
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNGetApplicationInstance"

HINSTANCE	DNGetApplicationInstance( void )
{
#ifdef DBG
	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );
#endif // DBG
	return	g_hApplicationInstance;
}
//**********************************************************************
#endif // ! DPNBUILD_NOSERIALSP


#ifndef DPNBUILD_ONLYONETHREAD
//**********************************************************************
// ------------------------------
// DNOSInitializeCriticalSection - initialize a critical section
//
// Entry:		Pointer to critical section
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failue
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNOSInitializeCriticalSection"

BOOL DNOSInitializeCriticalSection( CRITICAL_SECTION* pCriticalSection )
{
	BOOL	fReturn;

	DNASSERT( pCriticalSection != NULL );
	fReturn = TRUE;

	//
	// attempt to enter the critical section once
	//
	_try
	{
#ifdef WINNT
			// Pre-allocate the critsec event by setting the high bit of the spin count and set spin to 1000
			// NT converts the spin to 0 for single proc machines.
			fReturn = InitializeCriticalSectionAndSpinCount( pCriticalSection , 0x80000000 | 1000);
#else
			InitializeCriticalSection( pCriticalSection );
#endif // WINNT
	}
	_except( EXCEPTION_EXECUTE_HANDLER )
	{
		fReturn = FALSE;
	}

	_try
	{
		if (fReturn)
		{
			EnterCriticalSection( pCriticalSection );
		}
	}
	_except( EXCEPTION_EXECUTE_HANDLER )
	{
		DeleteCriticalSection(pCriticalSection);
		fReturn = FALSE;
	}

	//
	// if we didn't fail on entering the critical section, make sure
	// we release it
	//
	if ( fReturn != FALSE )
	{
		LeaveCriticalSection( pCriticalSection );
	}

	return	fReturn;
}
//**********************************************************************
#endif // !DPNBUILD_ONLYONETHREAD


#ifdef DBG

#ifdef WINCE

#undef DPF_MODNAME
#define DPF_MODNAME "DNGetProfileInt"

UINT DNGetProfileInt(LPCTSTR lpszSection, LPCTSTR lpszEntry, int nDefault)
{
	DWORD		dwResult;
	CRegistry	reg;


	DNASSERT(_tcscmp(lpszSection, _T("DirectPlay8")) == 0);

	if (!reg.Open(HKEY_LOCAL_MACHINE, _T("Software\\Microsoft\\DirectPlay8")))
	{
		// NOTE: This will occur during DllRegisterServer for the first time
		return nDefault;
	}

	if (!reg.ReadDWORD(lpszEntry, &dwResult))
	{
		return nDefault;
	}

	return dwResult;
}

#else // ! WINCE
#if ((defined(_XBOX)) && (! defined(XBOX_ON_DESKTOP)))


#undef DPF_MODNAME
#define DPF_MODNAME "DNGetProfileInt"

UINT DNGetProfileInt(LPCTSTR lpszSection, LPCTSTR lpszEntry, int nDefault)
{
	DWORD		dwResult;
	FILE *		pFile = NULL;
	TCHAR		tszLine[256];
	TCHAR *		ptszTrimStart;
	TCHAR *		ptszTrimEnd;
	BOOL		fInSection = FALSE;


	DNASSERT(_tcscmp(lpszSection, _T("DirectPlay8")) == 0);

	//
	// Populate the default return value.
	//
	dwResult = nDefault;

	//
	// Open a "win.ini" file in the root of the title's launch directory.
	//
	pFile = fopen(_T("D:\\win.ini"), "r");
	if (pFile == NULL)
	{
		goto Exit;
	}

	//
	// Look for the section and entry.
	//
	while (_fgetts(tszLine, (sizeof(tszLine) - sizeof(TCHAR)), pFile) != NULL)
	{
		//
		// Trim whitespace from the beginning of the line.
		//
		ptszTrimStart = tszLine;
		while (((*ptszTrimStart) == _T('\n')) ||
				((*ptszTrimStart) == _T('\r')) ||
				((*ptszTrimStart) == _T(' ')) ||
				((*ptszTrimStart) == _T('\t')))
		{
			if ((*ptszTrimStart) == 0)
			{
				break;
			}

			ptszTrimStart++;
		}

		//
		// Trim whitespace off the end of the line.
		//
		ptszTrimEnd = ptszTrimStart + _tcslen(ptszTrimStart) - 1;
		while (((*ptszTrimEnd) == _T('\n')) ||
				((*ptszTrimEnd) == _T('\r')) ||
				((*ptszTrimEnd) == _T(' ')) ||
				((*ptszTrimEnd) == _T('\t')))
		{
			if (ptszTrimEnd <= ptszTrimStart)
			{
				break;
			}

			ptszTrimEnd--;
		}


		//
		// Ignore commented lines (starts with semicolon).
		//
		if ((*ptszTrimStart) != _T(';'))
		{
			//
			// If it starts and ends with brackets, it's a section header.
			//
			if (((*ptszTrimStart) == _T('[')) && ((*ptszTrimEnd) == _T(']')))
			{
				//
				// If we were in the section, then we've left it and we're
				// done.
				//
				if (fInSection)
				{
					break;
				}


				//
				// Trim whitespace from inside the start of the brackets.
				//

				*ptszTrimEnd = 0;
				ptszTrimEnd--;
				ptszTrimStart++;

				while (((*ptszTrimStart) == _T('\n')) ||
						((*ptszTrimStart) == _T('\r')) ||
						((*ptszTrimStart) == _T(' ')) ||
						((*ptszTrimStart) == _T('\t')))
				{
					if ((*ptszTrimStart) == 0)
					{
						break;
					}

					ptszTrimStart++;
				}

				while (((*ptszTrimEnd) == _T('\n')) ||
						((*ptszTrimEnd) == _T('\r')) ||
						((*ptszTrimEnd) == _T(' ')) ||
						((*ptszTrimEnd) == _T('\t')))
				{
					if (ptszTrimEnd <= ptszTrimStart)
					{
						break;
					}

					ptszTrimEnd--;
				}

				*(ptszTrimEnd + 1) = 0;


				//
				// Is this the right section?
				//
				if (_tcsicmp(ptszTrimStart, lpszSection) == 0)
				{
					fInSection = TRUE;
				}
			}
			else
			{
				//
				// If we're in the section, determine the key
				// name.
				//
				if (fInSection)
				{
					TCHAR *		ptszKeyEnd;
					TCHAR *		ptszValue;


					*(ptszTrimEnd + 1) = 0;
					ptszKeyEnd = ptszTrimStart;
					while ((ptszKeyEnd < ptszTrimEnd) &&
							((*ptszKeyEnd) != _T('=')))
					{
						ptszKeyEnd++;
					}

					if ((*ptszKeyEnd) == _T('='))
					{
						ptszValue = ptszKeyEnd + 1;
						ptszKeyEnd--;
						while (((*ptszKeyEnd) == _T('\n')) ||
								((*ptszKeyEnd) == _T('\r')) ||
								((*ptszKeyEnd) == _T(' ')) ||
								((*ptszKeyEnd) == _T('\t')))
						{
							if (ptszKeyEnd <= ptszTrimStart)
							{
								break;
							}

							ptszKeyEnd--;
						}

						*(ptszKeyEnd + 1) = 0;

						//
						// If we matched the key name, convert the
						// value and bail.
						//
						if (_tcsicmp(ptszTrimStart, lpszEntry) == 0)
						{
							dwResult = _ttoi(ptszValue);
							goto Exit;
						}
					}
				}
				else
				{
					//
					// Not in section.
					//
				}
			}
		}
		else
		{
			//
			// Line is commented, ignore.
			//
		}
	}


Exit:

	if (pFile != NULL)
	{
		fclose(pFile);
		pFile = NULL;
	}

	return dwResult;
}

#endif // _XBOX and ! XBOX_ON_DESKTOP
#endif // ! WINCE

#endif // DBG



#if defined(WINCE) && !defined(WINCE_ON_DESKTOP)

//**********************************************************************
//**
//** Begin CE layer.  Here we implement functions we need that aren't on CE.
//**
//**********************************************************************

#undef DPF_MODNAME
#define DPF_MODNAME "OpenEvent"

HANDLE WINAPI OpenEvent(IN DWORD dwDesiredAccess, IN BOOL bInheritHandle, IN LPCWSTR lpName)
{
	HANDLE h;

	h = CreateEvent(0, 1, 0, lpName);
	if (!h)
	{
		return NULL;
	}
	if (GetLastError() != ERROR_ALREADY_EXISTS)
	{
		CloseHandle(h);
		return NULL;
	}
	return h;
}

#undef DPF_MODNAME
#define DPF_MODNAME "OpenFileMapping"

HANDLE WINAPI OpenFileMapping(IN DWORD dwDesiredAccess, IN BOOL bInheritHandle, IN LPCWSTR lpName)
{
	HANDLE h;
	DWORD dwFlags = 0;

	if (dwDesiredAccess & FILE_MAP_WRITE)
	{
		// If they ask for FILE_MAP_ALL_ACCESS or FILE_MAP_WRITE, they get read and write
		dwFlags = PAGE_READWRITE;
	}
	else
	{
		// If they only ask for FILE_MAP_READ, they get read only
		dwFlags = PAGE_READONLY;
	}

	h = CreateFileMapping(INVALID_HANDLE_VALUE, 0, dwFlags, 0, 1, lpName);
	if (!h)
	{
		return NULL;
	}
	if (GetLastError() != ERROR_ALREADY_EXISTS)
	{
		CloseHandle(h);
		return NULL;
	}
	return h;
}

#undef DPF_MODNAME
#define DPF_MODNAME "OpenMutex"

HANDLE WINAPI OpenMutex(IN DWORD dwDesiredAccess, IN BOOL bInheritHandle, IN LPCWSTR lpName)
{
	HANDLE h;

	h = CreateMutex(0, 0, lpName);
	if (!h)
	{
		return NULL;
	}
	if (GetLastError() != ERROR_ALREADY_EXISTS)
	{
		CloseHandle(h);
		return NULL;
	}
	return h;
}

/*
#ifdef _X86_
__declspec(naked)
LONG WINAPI InterlockedExchangeAdd( LPLONG Addend, LONG Increment )
{
	__asm 
	{
		mov			ecx, [esp + 4]	; get addend address
		mov			eax, [esp + 8]	; get increment value
		lock xadd	[ecx], eax	; exchange add}
		ret
	}
}
#endif // _X86
*/
#endif // WINCE
//**********************************************************************
//**
//** End CE layer.  Here we implement functions we need that aren't on CE.
//**
//**********************************************************************


#if ((defined(WINCE)) || (defined(DPNBUILD_LIBINTERFACE)))

#undef DPF_MODNAME
#define DPF_MODNAME "DNCoCreateGuid"

HRESULT DNCoCreateGuid(GUID* pguid)
{
	pguid->Data1 = (rand() << 16) | rand();
	pguid->Data2 = (WORD)rand();
	pguid->Data3 = (WORD)rand();
	pguid->Data4[0] = (BYTE)rand();
	pguid->Data4[1] = (BYTE)rand();
	pguid->Data4[2] = (BYTE)rand();
	pguid->Data4[3] = (BYTE)rand();
	pguid->Data4[4] = (BYTE)rand();
	pguid->Data4[5] = (BYTE)rand();
	pguid->Data4[6] = (BYTE)rand();
	pguid->Data4[7] = (BYTE)rand();

	return S_OK;
}

#endif // WINCE or DPNBUILD_LIBINTERFACE



#ifndef DPNBUILD_NOPARAMVAL

BOOL IsValidStringA( const CHAR * const lpsz )
{
#ifndef WINCE
	return (!IsBadStringPtrA( lpsz, 0xFFFF ) );
#else
	const char* szTmpLoc = lpsz;

	//
	// If it is a NULL pointer just return FALSE, they are always bad
	//
	if (szTmpLoc == NULL) 
	{
		return FALSE;
	}

	_try 
	{
		for( ; *szTmpLoc ; szTmpLoc++ );
	}
	_except(EXCEPTION_EXECUTE_HANDLER) 
	{
		return FALSE;
	}
    
	return TRUE;

#endif // WINCE
}

BOOL IsValidStringW( const WCHAR * const  lpwsz )
{
#ifdef WINNT
	//
	//	This function is only valid on NT.
	//	It exists for WIN9x, but only via the MS Layer for Unicode which requires us to jump through hoops when linking
	//
	return (!IsBadStringPtrW( lpwsz, 0xFFFF ) );
#else
	const wchar_t *szTmpLoc = lpwsz;
	
	//
	// If it is a NULL pointer just return FALSE, they are always bad
	//
	if( szTmpLoc == NULL )
	{
		return FALSE;
	}
	
	_try
	{
		for( ; *szTmpLoc ; szTmpLoc++ );
	}
	_except( EXCEPTION_EXECUTE_HANDLER )
	{
		return FALSE;
	}

	return TRUE;
#endif // WINNT
}

#endif // !DPNBUILD_NOPARAMVAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\packbuff.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       PackBuff.h
 *  Content:	Packed Buffers
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/11/00	mjn		Created
 *  06/15/2000  rmt     Added func to add string to packbuffer
 *  02/06/2001	rodtoll	WINBUG #293871: DPLOBBY8: [IA64] Lobby launching a 64-bit 
 * 						app from 64-bit lobby launcher crashes with unaligned memory error.
 *
 ***************************************************************************/

#ifndef __PACK_BUFF_H__
#define __PACK_BUFF_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for packed buffer

class CPackedBuffer
{
public:
	CPackedBuffer() { };	// Constructor

//	~CPackedBuffer() { };	// Destructor

	void	Initialize(	void *const pvBuffer,
						const DWORD dwBufferSize, 
						const BOOL fAlignedRequired = FALSE );

	HRESULT AddToFront( const void *const pvBuffer,
						const DWORD dwBufferSize, const BOOL fAlignedRequired = FALSE );

	HRESULT AddToBack( const void *const pvBuffer,
						const DWORD dwBufferSize, 
						const BOOL fAlignedRequired = FALSE );

	PVOID GetStartAddress( void ) { return m_pStart; };

    HRESULT AddWCHARStringToBack( const wchar_t * const pwszString, const BOOL fAlignedRequired  = FALSE );					

	PVOID GetHeadAddress( void ) const { return( m_pHead ); }

	PVOID GetTailAddress( void ) const { return( m_pTail ); }

	DWORD GetHeadOffset( void ) const
	{
		return( (DWORD)(m_pHead - m_pStart) );
	}

	DWORD GetTailOffset( void ) const
	{
		return( (DWORD)(m_pTail - m_pStart) );
	}

	DWORD GetSpaceRemaining( void ) const { return( m_dwRemaining ); }

	DWORD GetSizeRequired( void ) const { return( m_dwRequired ); }

private:
	BYTE	*m_pStart;			// Start of the buffer
	BYTE	*m_pHead;			// Pointer to head of free buffer
	BYTE	*m_pTail;			// Pointer to tail of free buffer
	DWORD	m_dwRemaining;		// bytes remaining in buffer
	DWORD	m_dwRequired;		// bytes required so far
	BOOL	m_bBufferTooSmall;	// buffer has run out of space
};



#endif	// __PACK_BUFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\packbuff.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       PackBuff.cpp
 *  Content:	Packed Buffers
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/01/00	mjn		Created
 *  06/15/2000  rmt     Added func to add string to packbuffer
 *  02/06/2001	rodtoll	WINBUG #293871: DPLOBBY8: [IA64] Lobby launching a 64-bit 
 * 						app from 64-bit lobby launcher crashes with unaligned memory error. 
 ***************************************************************************/

#include "dncmni.h"
#include "PackBuff.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CPackedBuffer::Initialize
//
// Entry:		void *const	pvBuffer		- Buffer to fill up (may be NULL)
//				const DWORD	dwBufferSize	- Size of buffer (may be 0)
//
// Exit:		Nothing
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "CPackedBuffer::Initialize"
void CPackedBuffer::Initialize(void *const pvBuffer,
								  const DWORD dwBufferSize, const BOOL fAlignRequired)
{
	if (pvBuffer == NULL || dwBufferSize == 0)
	{
		m_pStart = NULL;
		m_pHead = NULL;
		m_pTail = NULL;
		m_dwRemaining = 0;
		m_bBufferTooSmall = TRUE;
	}
	else
	{
		m_pStart = reinterpret_cast<BYTE*>(pvBuffer);
		m_pHead = m_pStart;
		m_pTail = m_pStart + dwBufferSize;
		m_dwRemaining = dwBufferSize;

		if( fAlignRequired )
		{
			DWORD dwExtra = m_dwRemaining % sizeof( void * );

			m_dwRemaining -= dwExtra;
			m_pTail -= dwExtra;
		}
		
		m_bBufferTooSmall = FALSE;
	}
	m_dwRequired = 0;
}


//**********************************************************************
// ------------------------------
// CPackedBuffer::AddToFront
//
// Entry:		void *const	pvBuffer		- Buffer to add (may be NULL)
//				const DWORD	dwBufferSize	- Size of buffer (may be 0)
//
// Exit:		Error Code:	DPN_OK					if able to add
//							DPNERR_BUFFERTOOSMALL	if buffer is full
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "CPackedBuffer::AddToFront"
HRESULT CPackedBuffer::AddToFront(const void *const pvBuffer,
								  const DWORD dwBufferSize, 
								  const BOOL fAlignedRequired )
{
	DWORD dwBytesToAdd = dwBufferSize;

	if( fAlignedRequired )
	{
		DWORD dwNumBytesFromAligned = dwBufferSize % sizeof( void *);

		if( dwNumBytesFromAligned )
		{
			dwBytesToAdd += sizeof( void * ) - dwNumBytesFromAligned;
		}

	}

	DPFX( DPFPREP, 9, "Adding to front: %d bytes --> %d bytes aligned, pointer %p new pointer %p", dwBufferSize, dwBytesToAdd, m_pHead, m_pHead + dwBytesToAdd	 );	

	m_dwRequired += dwBytesToAdd;
	if (!m_bBufferTooSmall)
	{
		if (m_dwRemaining >= dwBytesToAdd)
		{
			if (pvBuffer)
			{
				memcpy(m_pHead,pvBuffer,dwBufferSize);
			}
			m_pHead += dwBytesToAdd;
			
			m_dwRemaining -= dwBytesToAdd;
		}
		else
		{
			m_bBufferTooSmall = TRUE;
		}
	}

	if (m_bBufferTooSmall)
		return(DPNERR_BUFFERTOOSMALL);

	return(DPN_OK);
}

//**********************************************************************
// ------------------------------
// CPackedBuffer::AddWCHARStringToBack
//
// Entry:		const wchar_t * const pwszString - String to add (may be NULL)
//
// Exit:		Error Code:	DPN_OK					if able to add
//							DPNERR_BUFFERTOOSMALL	if buffer is full
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "CPackedBuffer::AddWCHARStringToBack"
HRESULT CPackedBuffer::AddWCHARStringToBack( const wchar_t * const pwszString, const BOOL fAlignedRequired )
{
    return AddToBack( pwszString, sizeof( wchar_t ) * (wcslen( pwszString )+1), fAlignedRequired );
}

//**********************************************************************
// ------------------------------
// CPackedBuffer::AddToBack
//
// Entry:		void *const	pvBuffer		- Buffer to add (may be NULL)
//				const DWORD	dwBufferSize	- Size of buffer (may be 0)
//
// Exit:		Error Code:	DPN_OK					if able to add
//							DPNERR_BUFFERTOOSMALL	if buffer is full
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "CPackedBuffer::AddToBack"
HRESULT CPackedBuffer::AddToBack(const void *const pvBuffer,
								 const DWORD dwBufferSize, 
								 const BOOL fAlignedRequired )
{
	DWORD dwBytesToAdd = dwBufferSize;

	if( fAlignedRequired )
	{
		DWORD dwNumBytesFromAligned = dwBufferSize % sizeof( void * );

		if( dwNumBytesFromAligned )
		{
			dwBytesToAdd += sizeof( void * ) - dwNumBytesFromAligned;
		}
	}

	DPFX( DPFPREP, 9, "Adding to back: %d bytes --> %d bytes aligned, pointer %p new pointer %p", dwBufferSize, dwBytesToAdd, m_pTail, m_pTail -dwBytesToAdd	 );
	
	m_dwRequired += dwBytesToAdd;
	if (!m_bBufferTooSmall)
	{
		if (m_dwRemaining >= dwBytesToAdd)
		{
			m_pTail -= dwBytesToAdd;

			m_dwRemaining -= dwBytesToAdd;
			if (pvBuffer)
			{
				memcpy(m_pTail,pvBuffer,dwBufferSize);
			}
		}
		else
		{
			m_bBufferTooSmall = TRUE;
		}
	}

	if (m_bBufferTooSmall)
		return(DPNERR_BUFFERTOOSMALL);

	return(DPN_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\readwritelock.h ===
// ReadWriteLock.h: interface for the CReadWriteLock class.
//
//////////////////////////////////////////////////////////////////////

#pragma once

class CReadWriteLock  
{
public:
	BOOL Initialize();
	void Deinitialize();

	void EnterWriteLock();
	void EnterReadLock();

	void LeaveLock();

private:
	BOOL				m_fCritSecInited;
#ifdef DPNBUILD_ONLYONETHREAD
#ifdef DBG
	// Used to ensure that no one re-enters
	DWORD				m_dwThreadID;
#endif // DBG
#else // ! DPNBUILD_ONLYONETHREAD
	LONG				m_lWriterCount;
	LONG				m_lReaderCount;
	BOOL				m_fWriterMode;
	DNCRITICAL_SECTION	m_csWrite;

#ifdef DBG
	// Used to ensure that no one re-enters
	DWORD				m_dwWriteThread;
#endif // DBG
#endif // ! DPNBUILD_ONLYONETHREAD
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\readwritelock.cpp ===
// ReadWriteLock.cpp: implementation of the CReadWriteLock class.
//
//////////////////////////////////////////////////////////////////////

#include "dncmni.h"


#undef DPF_MODNAME
#define DPF_MODNAME "CReadWriteLock::Initialize"
BOOL CReadWriteLock::Initialize()
{
	DPF_ENTER();

#ifdef DPNBUILD_ONLYONETHREAD
	m_fCritSecInited = TRUE;
#ifdef DBG
	m_dwThreadID = 0;
#endif // DBG
#else // ! DPNBUILD_ONLYONETHREAD
	m_lReaderCount = 0;
	m_lWriterCount = 0;
	m_fWriterMode = FALSE;
#ifdef DBG
	m_dwWriteThread = 0;
#endif // DBG

	if (DNInitializeCriticalSection(&m_csWrite))
	{
		m_fCritSecInited = TRUE;
	}
	else
	{
		// This is necessary in case the user calls Deinitialize.
		m_fCritSecInited = FALSE; 
	}
#endif // ! DPNBUILD_ONLYONETHREAD

	DPF_EXIT();

	return m_fCritSecInited;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CReadWriteLock::Deinitialize"
VOID CReadWriteLock::Deinitialize()
{
#ifndef DPNBUILD_ONLYONETHREAD
#ifdef DBG
	DWORD	dwCount;
#endif // DBG
#endif // ! DPNBUILD_ONLYONETHREAD

	DPF_ENTER();

#ifdef DPNBUILD_ONLYONETHREAD
	if (m_fCritSecInited)
	{
#ifdef DBG
		DNASSERT(m_dwThreadID == 0);
#endif // DBG
		m_fCritSecInited = FALSE;
	}
#else // ! DPNBUILD_ONLYONETHREAD
#ifdef DBG
	DNASSERT(FALSE == m_fWriterMode);
	DNASSERT(0 == m_dwWriteThread);
#endif // DBG

	// The counts are decremented after leaving the cs, so these should be
	// or going to 0.
#ifdef DBG
	dwCount = 0;
#endif // DBG
	while (m_lReaderCount) 
	{
		Sleep(0);
#ifdef DBG
		dwCount++;
		DNASSERT(dwCount < 500);
#endif // DBG
	}

#ifdef DBG
	dwCount = 0;
#endif // DBG
	while (m_lWriterCount) 
	{
		Sleep(0);
#ifdef DBG
		dwCount++;
		DNASSERT(dwCount < 500);
#endif // DBG
	}

	if (m_fCritSecInited)
	{
		DNDeleteCriticalSection(&m_csWrite);
	}
#endif // ! DPNBUILD_ONLYONETHREAD

	DPF_EXIT();
}

#undef DPF_MODNAME
#define DPF_MODNAME "CReadWriteLock::EnterReadLock"
void CReadWriteLock::EnterReadLock()
{
	DPF_ENTER();

	DNASSERT(m_fCritSecInited == TRUE);

#ifdef DPNBUILD_ONLYONETHREAD
#ifdef DBG
	DNASSERT(m_dwThreadID == 0);
	m_dwThreadID = GetCurrentThreadId();
#endif // DBG
#else // ! DPNBUILD_ONLYONETHREAD
	// Increment the reader count
	DNInterlockedIncrement(&m_lReaderCount);

	// Is there a writer waiting?
	// As long as there is even one writer waiting,
	// Everybody waits on the critical section
	if (m_lWriterCount)
	{
		// Rollback.
		DNInterlockedDecrement(&m_lReaderCount);

		// We are assured that if every reader is waiting
		// on the crit-sec, then readercount will be 0.
		DNEnterCriticalSection(&m_csWrite);

		DNInterlockedIncrement(&m_lReaderCount);
		
		DNLeaveCriticalSection(&m_csWrite);
	}

#ifdef DBG
	DNASSERT(GetCurrentThreadId() != m_dwWriteThread);
	DNASSERT(FALSE == m_fWriterMode);
#endif // DBG
#endif // ! DPNBUILD_ONLYONETHREAD

	DPF_EXIT();
}

#undef DPF_MODNAME
#define DPF_MODNAME "CReadWriteLock::LeaveLock"
void CReadWriteLock::LeaveLock()
{
	DPF_ENTER();

	DNASSERT(m_fCritSecInited == TRUE);

#ifdef DPNBUILD_ONLYONETHREAD
#ifdef DBG
	DNASSERT(m_dwThreadID == GetCurrentThreadId());
	m_dwThreadID = 0;
#endif // DBG
#else // ! DPNBUILD_ONLYONETHREAD
	if (m_fWriterMode) 
	{
#ifdef DBG
		DNASSERT(GetCurrentThreadId() == m_dwWriteThread);
		m_dwWriteThread = 0;
#endif // DBG

		m_fWriterMode = FALSE;
		DNLeaveCriticalSection(&m_csWrite);
		DNInterlockedDecrement(&m_lWriterCount);
	} 
	else 
	{
		DNInterlockedDecrement(&m_lReaderCount);
	}
#endif // ! DPNBUILD_ONLYONETHREAD

	DPF_EXIT();
}

#undef DPF_MODNAME
#define DPF_MODNAME "CReadWriteLock::EnterWriteLock"
void CReadWriteLock::EnterWriteLock()
{
	DPF_ENTER();

	DNASSERT(m_fCritSecInited == TRUE);

#ifdef DPNBUILD_ONLYONETHREAD
#ifdef DBG
	DNASSERT(m_dwThreadID == 0);
	m_dwThreadID = GetCurrentThreadId();
#endif // DBG
#else // ! DPNBUILD_ONLYONETHREAD
	// No re-entrance allowed!
#ifdef DBG
	DNASSERT(GetCurrentThreadId() != m_dwWriteThread);
#endif // DBG

	DNInterlockedIncrement(&m_lWriterCount);
	DNEnterCriticalSection(&m_csWrite);

	while (m_lReaderCount) 
	{
		Sleep(0);
	}

	DNASSERT(FALSE == m_fWriterMode);
	m_fWriterMode = TRUE;

#ifdef DBG
	m_dwWriteThread = GetCurrentThreadId();
#endif // DBG
#endif // ! DPNBUILD_ONLYONETHREAD

	DPF_EXIT();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\rcbuffer.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       RCBuffer.cpp
 *  Content:	RefCount Buffers
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/12/00	mjn		Created
 *	01/31/00	mjn		Allow user defined Alloc and Free
 ***************************************************************************/

#include "dncmni.h"
#include "RCBuffer.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_COMMON


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


#undef DPF_MODNAME
#define DPF_MODNAME "CRefCountBuffer::Initialize"
HRESULT CRefCountBuffer::Initialize(CFixedPool* pFPRefCountBuffer,
									PFNALLOC_REFCOUNT_BUFFER pfnAlloc,
									PFNFREE_REFCOUNT_BUFFER pfnFree,
									const DWORD dwBufferSize)
{
	DNASSERT(pFPRefCountBuffer != NULL);
	DNASSERT((pfnAlloc == NULL && pfnFree == NULL && dwBufferSize == 0) || (pfnAlloc != NULL && pfnFree != NULL && dwBufferSize != 0));

	m_pFPOOLRefCountBuffer = pFPRefCountBuffer;

	if (dwBufferSize)
	{
		DNASSERT(pfnAlloc);
		DNASSERT(pfnFree);

		m_pfnAlloc = pfnAlloc;
		m_pfnFree = pfnFree;

		m_dnBufferDesc.pBufferData = static_cast<BYTE*>((pfnAlloc)(m_pvContext,dwBufferSize));
		if (m_dnBufferDesc.pBufferData == NULL)
		{
			return(DPNERR_OUTOFMEMORY);
		}
		m_dnBufferDesc.dwBufferSize = dwBufferSize;
	}

	DPFX(DPFPREP, 5,"[%p] Initialize RefCountBuffer pPool[%p], pfnAlloc[%p], pfnFree[%p], m_pvContext[%p], dwSize[%d], pBufferData[%p]", this, pFPRefCountBuffer, pfnAlloc, pfnFree, m_pvContext, dwBufferSize, m_dnBufferDesc.pBufferData);

	return(DPN_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRefCountBuffer::SetBufferDesc"
HRESULT CRefCountBuffer::SetBufferDesc(	BYTE *const pBufferData, const DWORD dwBufferSize, PFNFREE_REFCOUNT_BUFFER pfnFree, void *const pvSpecialFree)
{
	DPFX(DPFPREP, 5,"[%p] Set BufferDesc refcount[%d], pPool[%p], pfnAlloc[%p], pfnFree[%p], m_pvContext[%p], dwSize[%d], pBufferData[%p], pvSpecialFree[%p]", this, m_lRefCount, m_pFPOOLRefCountBuffer, m_pfnAlloc, pfnFree, m_pvContext, dwBufferSize, pBufferData, pvSpecialFree);

	DNASSERT(m_lRefCount > 0);

	// Don't allow overwriting a previous bufferdesc
	DNASSERT(m_dnBufferDesc.dwBufferSize == 0);
	DNASSERT(m_dnBufferDesc.pBufferData == 0);

	DNASSERT(pfnFree);

	m_dnBufferDesc.dwBufferSize = dwBufferSize;
	m_dnBufferDesc.pBufferData = pBufferData;
	m_pfnFree = pfnFree;
	m_pvSpecialFree = pvSpecialFree;

	return(DPN_OK);
};

#undef DPF_MODNAME
#define DPF_MODNAME "CRefCountBuffer::FPMInitialize"
void CRefCountBuffer::FPMInitialize( void* pvItem, void* pvContext )
{
	DPFX(DPFPREP, 5,"[%p] Get RefCountBuffer from pool", pvItem);

	CRefCountBuffer* pRCBuffer = (CRefCountBuffer*)pvItem;

	pRCBuffer->m_lRefCount = 1;
	pRCBuffer->m_pvContext = pvContext;
	pRCBuffer->m_pvSpecialFree = NULL;
	pRCBuffer->m_dnBufferDesc.dwBufferSize = 0;
	pRCBuffer->m_dnBufferDesc.pBufferData = NULL;
};

#undef DPF_MODNAME
#define DPF_MODNAME "CRefCountBuffer::AddRef"
void CRefCountBuffer::AddRef()
{
	DPFX(DPFPREP, 5,"[%p] AddRef RefCountBuffer refcount[%d], pPool[%p], pfnAlloc[%p], pfnFree[%p], pvContext[%p], dwSize[%d], pBufferData[%p]", this, m_lRefCount + 1, m_pFPOOLRefCountBuffer, m_pfnAlloc, m_pfnFree, m_pvContext, m_dnBufferDesc.dwBufferSize, m_dnBufferDesc.pBufferData);

	DNASSERT(m_lRefCount >= 0);
	DNInterlockedIncrement( &m_lRefCount );
};

#undef DPF_MODNAME
#define DPF_MODNAME "CRefCountBuffer::Release"
void CRefCountBuffer::Release( void )
{
	DPFX(DPFPREP, 5,"[%p] Release RefCountBuffer refcount[%d], pPool[%p], pfnAlloc[%p], pfnFree[%p], pvContext[%p], dwSize[%d], pBufferData[%p]", this, m_lRefCount - 1, m_pFPOOLRefCountBuffer, m_pfnAlloc, m_pfnFree, m_pvContext, m_dnBufferDesc.dwBufferSize, m_dnBufferDesc.pBufferData);

	DNASSERT(m_lRefCount > 0);
	if ( DNInterlockedDecrement( &m_lRefCount ) == 0 )
	{
		if (m_dnBufferDesc.pBufferData)
		{
			if (m_pvSpecialFree)
			{
				(*m_pfnFree)(m_pvContext,m_pvSpecialFree);
			}
			else
			{
				(*m_pfnFree)(m_pvContext,m_dnBufferDesc.pBufferData);
			}
			m_dnBufferDesc.pBufferData = NULL;
			m_dnBufferDesc.dwBufferSize = 0;
			m_pvSpecialFree = NULL;
		}

		m_pFPOOLRefCountBuffer->Release( this );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\sources.inc ===
TARGETNAME=common
TARGETTYPE=LIBRARY

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\dncmni.h
PRECOMPILED_PCH=dncmni.pch
PRECOMPILED_OBJ=dncmni.obj

INCLUDES=..\;..\..\inc;$(DXROOT)\inc;$(SDK_INC_PATH)

SOURCES= \
	CallStack.cpp \
	ClassFactory.cpp \
	comutil.cpp \
        creg.cpp \
	CritsecTracking.cpp \
	dndbg.cpp \
	dneterrors.cpp \
	dnnbqueue.cpp \
	dnslist.cpp \
	FixedPool.cpp \
	HandleTable.cpp \
	HandleTracking.cpp \
	HashTable.cpp \
	MemoryTracking.cpp \
	osind.cpp \
	packbuff.cpp \
	rcbuffer.cpp \
	readwritelock.cpp \
	strutils.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\rcbuffer.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       RCBuff.h
 *  Content:	RefCount Buffers
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/12/00	mjn		Created
 *	01/15/00	mjn		Added GetBufferAddress and GetBufferSize
 *	01/31/00	mjn		Allow user defined Alloc and Free
 ***************************************************************************/

#ifndef __RCBUFF_H__
#define __RCBUFF_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_COMMON

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef PVOID (*PFNALLOC_REFCOUNT_BUFFER)(void *const,const DWORD);
typedef void (*PFNFREE_REFCOUNT_BUFFER)(void *const,void *const);

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for RefCount buffer

class CRefCountBuffer
{
public:
	HRESULT Initialize(	CFixedPool* pFPOOLRefCountBuffer, PFNALLOC_REFCOUNT_BUFFER pfnAlloc, PFNFREE_REFCOUNT_BUFFER pfnFree, const DWORD dwBufferSize);
	HRESULT SetBufferDesc(	BYTE *const pBufferData, const DWORD dwBufferSize, PFNFREE_REFCOUNT_BUFFER pfnFree, void *const pvSpecialFree);

	static void FPMInitialize( void* pvItem, void* pvContext );

	void AddRef();
	void Release();

	#undef DPF_MODNAME
	#define DPF_MODNAME "BufferDescAddress"
	DPN_BUFFER_DESC *BufferDescAddress()
		{
			return(&m_dnBufferDesc);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "GetBufferAddress"
	BYTE *GetBufferAddress()
		{
			return(m_dnBufferDesc.pBufferData);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "GetBufferSize"
	DWORD GetBufferSize() const
		{
			return(m_dnBufferDesc.dwBufferSize);
		};


private:
	LONG						m_lRefCount;
	DPN_BUFFER_DESC				m_dnBufferDesc;			// Buffer
	CFixedPool*					m_pFPOOLRefCountBuffer;	// source FP of RefCountBuffers
	PFNFREE_REFCOUNT_BUFFER		m_pfnFree;				// Function to free buffer when released
	PFNALLOC_REFCOUNT_BUFFER	m_pfnAlloc;
	PVOID						m_pvContext;			// Context provided to free buffer call
	PVOID				m_pvSpecialFree;
};

#undef DPF_SUBCOMP
#undef DPF_MODNAME

#endif	// __RCBUFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\strutils.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       StrUtils.h
 *  Content:    Defines the string utils
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   02/12/2000	rmt		Created
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __STRUTILS_H
#define __STRUTILS_H

HRESULT STR_jkWideToAnsi(LPSTR lpStr,LPCWSTR lpWStr,int cchStr);
HRESULT STR_jkAnsiToWide(LPWSTR lpWStr,LPCSTR lpStr,int cchWStr);

#ifndef WINCE

HRESULT STR_AllocAndConvertToANSI(LPSTR * ppszAnsi,LPCWSTR lpszWide);

HRESULT	STR_WideToAnsi( const WCHAR *const pWCHARString,
						const DWORD dwWCHARStringLength,
						char *const pString,
						DWORD *const pdwStringLength );

HRESULT	STR_AnsiToWide( const char *const pString,
						const DWORD dwStringLength,
						WCHAR *const pWCHARString,
						DWORD *const pdwWCHARStringLength );

#endif // !WINCE

#endif // __STRUTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\templatepools.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       templatepools.h
 *  Content:	Templated based pool objects derived from CFixedPool
 *
 *  History:
 *   Date		By			Reason
 *   ======		==			======
 *  12-10-2001	simonpow	Created
 ***************************************************************************/


#ifndef __TEMPLATEPOOLS_H__
#define __TEMPLATEPOOLS_H__

/*
 * Usage Notes
 * There are three different pool types - 
 * CObjectFixedPool, CDataBlockFixedPool, CMemBlockFixedPool
 * They all basically do the same thing, which is to provide a very thin wrapper
 * on CFixedPool, a wrapper which in turn imposes a certain usage policy.
 * 
 * CObjectFixedPool ensures the templated object type is correctly constructed and
 * destructed on a pool alloc/dealloc. It forwards pool Init/Release calls
 * to FPMInitialize and FPMRelease methods on the templated object
 * 
 * CDataBlockFixedPool doesn't provide any construction/destruction support, it
 * simply forwards the pool Init/Release calls to FPMInitialize and FPMRelease methods
 * 
 * CMemBlockFixedPool doesn't provide any alloc/dealloc/init/release methods. It assumes
 * the user simply wants raw memory chunks
 */

#include "fixedpool.h"

	//placement new operator. Used to construct objects at location provided
	//from CFixedPool base class
inline void * operator new(size_t sz, void * v)
	{ return v;	};

/*
 * CObjectFixedPool
 * Object allocated through this must provide a default constructor, a destructor,
 * a FPMInitialize method and an FPMRelease method
 */

template <class T>
class CObjectFixedPool : protected CFixedPool
{
public:

	CObjectFixedPool() : CFixedPool() {};
	~CObjectFixedPool() {};

	BOOL Initialize()
		{	return CFixedPool::Initialize(sizeof(T), FPMAlloc, FPMInitialize, FPMRelease, FPMDealloc);	};
	void DeInitialize()
		{	CFixedPool::DeInitialize();	};

	T * Get()
		{	return (T* ) CFixedPool::Get();	};
	void Release(T * pItem)
		{	CFixedPool::Release(pItem);	};

	DWORD GetInUseCount()
		{	return FixedPool::GetInUseCount();	};

protected:

	static BOOL FPMAlloc(void * pvItem, void * pvContext)
		{	new (pvItem) T(); return TRUE; };
	static void FPMInitialize(void * pvItem, void * pvContext)
		{	((T * ) pvItem)->FPMInitialize();	};
	static void FPMRelease(void * pvItem)
		{	((T * ) pvItem)->FPMRelease();	};
	static void FPMDealloc(void * pvItem)
		{	((T * ) pvItem)->~T();	};

};

/*
 * CDataBlockFixedPool
 * Object allocated through this must provide a FPMInitialize method and an
 * FPMRelease method. Their constructor/destructor will not be called
 */

template <class T>
class CDataBlockFixedPool : protected CFixedPool
{
public:

	CDataBlockFixedPool() : CFixedPool() {};
	~CDataBlockFixedPool() {};

	BOOL Initialize()
		{	return CFixedPool::Initialize(sizeof(T), NULL, FPMInitialize, FPMRelease, NULL);	};
	void DeInitialize()
		{	CFixedPool::DeInitialize();	};

	T * Get()
		{	return (T* ) CFixedPool::Get();	};
	void Release(T * pItem)
		{	CFixedPool::Release(pItem);	};

	DWORD GetInUseCount()
		{	return FixedPool::GetInUseCount();	};

protected:

	static void FPMInitialize(void * pvItem, void * pvContext)
		{	((T * ) pvItem)->FPMInitialize();	};
	static void FPMRelease(void * pvItem)
		{	((T * ) pvItem)->FPMRelease();	};

};

/*
 * CMemBlockFixedPool
 * Object allocated through this will have no initialisation done
 */

template <class T>
class CMemBlockFixedPool : protected CFixedPool
{
public:

	CMemBlockFixedPool() : CFixedPool() {};
	~CMemBlockFixedPool() {};

	BOOL Initialize()
		{	return CFixedPool::Initialize(sizeof(T), NULL, NULL, NULL, NULL);	};
	void DeInitialize()
		{	CFixedPool::DeInitialize();	};

	T * Get()
		{	return (T* ) CFixedPool::Get();	};
	void Release(T * pItem)
		{	CFixedPool::Release(pItem);	};

	DWORD GetInUseCount()
		{	return FixedPool::GetInUseCount();	};
};


#endif //#ifndef __TEMPLATEPOOLS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\threadlocalptrs.h ===
/*==========================================================================
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       threadlocalptrs.h
 *  Content:	Thread local pointer macros
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	03/21/2001	vanceo	Created.
 ***************************************************************************/

#ifndef __THREADLOCALPTRS_H__
#define __THREADLOCALPTRS_H__




//**********************************************************************
// Structure definitions
//**********************************************************************

typedef struct _THREADLOCAL_HEADER	THREADLOCAL_HEADER, * PTHREADLOCAL_HEADER;

struct _THREADLOCAL_HEADER
{
	PTHREADLOCAL_HEADER		pNext;		// pointer to next allocated threadlocal structure header
	PTHREADLOCAL_HEADER		pPrev;		// pointer to previous allocated threadlocal structure header
	DWORD					dwThreadID;	// ID of thread that owns this header
	
	//
	// The actual thread local pointer structure follows this.
	//
};





//**********************************************************************
// Macro definitions
//**********************************************************************

//
// Global thread local pointer declarations.
//

#define DECLARE_THREADLOCALPTRS(pointers)	extern DWORD				g_dw##pointers##TlsIndex;\
											extern DNCRITICAL_SECTION	g_csAllocated##pointers;\
											extern PTHREADLOCAL_HEADER	g_pAllocated##pointers;\
											\
											struct pointers





//
// Thread local pointer storage, define in only one location.
//
#define IMPL_THREADLOCALPTRS(pointers)		DWORD					g_dw##pointers##TlsIndex = -1;\
											DNCRITICAL_SECTION		g_csAllocated##pointers;\
											PTHREADLOCAL_HEADER		g_pAllocated##pointers = NULL




//
// Thread local pointer initialization, call only once (DLL_PROCESS_ATTACH),
// returns TRUE if successful, FALSE otherwise.
//
#define INIT_THREADLOCALPTRS(pointers)								g_pAllocated##pointers = NULL, g_dw##pointers##TlsIndex = TlsAlloc(), ((g_dw##pointers##TlsIndex != -1) ? DNInitializeCriticalSection(&g_csAllocated##pointers) : FALSE)


//
// Total thread local pointer cleanup, call only once (DLL_PROCESS_DETACH).
//
#define DEINIT_THREADLOCALPTRS(pointers, pfnCleanup)				{\
																		PTHREADLOCAL_HEADER		pNext;\
																		\
																		\
																		if (g_dw##pointers##TlsIndex != -1)\
																		{\
																			DNDeleteCriticalSection(&g_csAllocated##pointers);\
																			\
																			TlsFree(g_dw##pointers##TlsIndex);\
																			g_dw##pointers##TlsIndex = -1;\
																		}\
																		\
																		while (g_pAllocated##pointers != NULL)\
																		{\
																			pNext = g_pAllocated##pointers->pNext;\
																			pfnCleanup((pointers *) (g_pAllocated##pointers + 1), g_pAllocated##pointers->dwThreadID);\
																			DNFree(g_pAllocated##pointers);\
																			g_pAllocated##pointers = pNext;\
																		}\
																	}


//
// Cleanup only current thread's local pointers (DLL_THREAD_DETACH).
//
#define RELEASE_CURRENTTHREAD_LOCALPTRS(pointers, pfnCleanup)		{\
																		PTHREADLOCAL_HEADER		pHeader;\
																		PTHREADLOCAL_HEADER		pNext;\
																		\
																		\
																		pHeader = (PTHREADLOCAL_HEADER) TlsGetValue(g_dw##pointers##TlsIndex);\
																		if (pHeader != NULL)\
																		{\
																			DNEnterCriticalSection(&g_csAllocated##pointers);\
																			\
																			pNext = pHeader->pNext;\
																			if (pHeader->pPrev != NULL)\
																			{\
																				pHeader->pPrev->pNext = pNext;\
																			}\
																			if (pNext != NULL)\
																			{\
																				pNext->pPrev = pHeader->pPrev;\
																			}\
																			\
																			if (pHeader == g_pAllocated##pointers)\
																			{\
																				g_pAllocated##pointers = pNext;\
																			}\
																			\
																			DNLeaveCriticalSection(&g_csAllocated##pointers);\
																			\
																			DNASSERT(pHeader->dwThreadID == GetCurrentThreadId());\
																			pfnCleanup((pointers *) (pHeader + 1), pHeader->dwThreadID);\
																			DNFree(pHeader);\
																		}\
																	}

//
// Thread local pointer retrieval function.
//
#define GET_THREADLOCALPTR(pointers, name, pptr)			{\
																PTHREADLOCAL_HEADER		pHeader;\
																\
																\
																pHeader = (PTHREADLOCAL_HEADER) TlsGetValue(g_dw##pointers##TlsIndex);\
																if (pHeader == NULL)\
																{\
																	DPFX(DPFPREP, 9, "No header for " #name ".");\
																	(*pptr) = NULL;\
																}\
																else\
																{\
																	DPFX(DPFPREP, 9, "Found header 0x%p, returning " #name " 0x%p.", pHeader, ((pointers *) (pHeader + 1))->name);\
																	(*pptr) = ((pointers *) (pHeader + 1))->name;\
																}\
															}

//
// Thread local pointer storage function.
//
#define SET_THREADLOCALPTR(pointers, name, ptr, pfResult)	{\
																PTHREADLOCAL_HEADER		pHeader;\
																\
																\
																pHeader = (PTHREADLOCAL_HEADER) TlsGetValue(g_dw##pointers##TlsIndex);\
																if (pHeader == NULL)\
																{\
																	pHeader = (PTHREADLOCAL_HEADER) DNMalloc(sizeof(THREADLOCAL_HEADER) + sizeof(pointers));\
																	if (pHeader == NULL)\
																	{\
																		(*pfResult) = FALSE;\
																	}\
																	else\
																	{\
																		memset(pHeader, 0, (sizeof(THREADLOCAL_HEADER) + sizeof(pointers)));\
																		pHeader->dwThreadID = GetCurrentThreadId();\
																		((pointers *) (pHeader + 1))->name = ptr;\
																		\
																		if (! TlsSetValue(g_dw##pointers##TlsIndex, pHeader))\
																		{\
																			DPFX(DPFPREP, 9, "Couldn't set thread local storage 0x%p!", pHeader);\
																			DNFree(pHeader);\
																			(*pfResult) = FALSE;\
																		}\
																		else\
																		{\
																			DPFX(DPFPREP, 9, "Setting 0x%p " #name " to 0x%p (create).", pHeader, ptr);\
																			\
																			DNEnterCriticalSection(&g_csAllocated##pointers);\
																			pHeader->pNext = g_pAllocated##pointers;\
																			if (g_pAllocated##pointers != NULL)\
																			{\
																				DNASSERT(g_pAllocated##pointers##->pPrev == NULL);\
																				g_pAllocated##pointers##->pPrev = pHeader;\
																			}\
																			g_pAllocated##pointers = pHeader;\
																			DNLeaveCriticalSection(&g_csAllocated##pointers);\
																			\
																			(*pfResult) = TRUE;\
																		}\
																	}\
																}\
																else\
																{\
																	DPFX(DPFPREP, 9, "Setting 0x%p " #name " to 0x%p (existing).", pHeader, ptr);\
																	DNASSERT(((pointers *) (pHeader + 1))->name == NULL);\
																	((pointers *) (pHeader + 1))->name = ptr;\
																	(*pfResult) = TRUE;\
																}\
															}



#endif	// __THREADLOCALPTRS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\common\strutils.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       StrUtils.cpp
 *  Content:    Implements the string utils
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   02/12/2000	rmt		Created
 *   08/28/2000	masonb	Voice Merge: Added check of return code of MultiByteToWideChar in STR_jkAnsiToWide
 *   09/16/2000 aarono  fix STR_AllocAndConvertToANSI, ANSI doesn't mean 1 byte per DBCS character so we
 *                       must allow up to 2 bytes per char when allocating buffer (B#43286)
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncmni.h"

/*
 ** WideToAnsi
 *
 *  CALLED BY:	everywhere
 *
 *  PARAMETERS: lpStr - destination string
 *				lpWStr - string to convert
 *				cchStr - size of dest buffer
 *
 *  DESCRIPTION:
 *				converts unicode lpWStr to ansi lpStr.
 *				fills in unconvertable chars w/ DPLAY_DEFAULT_CHAR "-"
 *				
 *
 *  RETURNS:  if cchStr is 0, returns the size required to hold the string
 *				otherwise, returns the number of chars converted
 *
 */
#undef DPF_MODNAME
#define DPF_MODNAME "STR_jkWideToAnsi"
HRESULT STR_jkWideToAnsi(LPSTR lpStr,LPCWSTR lpWStr,int cchStr)
{
	int rval;
	BOOL fDefault = FALSE;

	// can't call us w/ null pointer & non-zero cch
	DNASSERT(lpWStr || !cchStr);

	// use the default code page (CP_ACP)
	// -1 indicates WStr must be null terminated
	rval = WideCharToMultiByte(CP_ACP,0,lpWStr,-1,lpStr,cchStr,NULL,&fDefault);

	DNASSERT(!fDefault);
	
	if(rval == 0)
	{
		return E_FAIL;
	}
	else
	{
		return S_OK;
	}

} // WideToAnsi

#undef DPF_MODNAME
#define DPF_MODNAME "STR_jkAnsiToWide"
/*
 ** AnsiToWide
 *
 *  CALLED BY: everywhere
 *
 *  PARAMETERS: lpWStr - dest string
 *				lpStr  - string to convert
 *				cchWstr - size of dest buffer
 *
 *  DESCRIPTION: converts Ansi lpStr to Unicode lpWstr
 *
 */
HRESULT STR_jkAnsiToWide(LPWSTR lpWStr,LPCSTR lpStr,int cchWStr)
{
	int rval;

	DNASSERT(lpStr);
	DNASSERT(lpWStr);

	rval =  MultiByteToWideChar(CP_ACP,0,lpStr,-1,lpWStr,cchWStr);
	if (!rval)
	{
		DPFX(DPFPREP,0,"MultiByteToWideChar failed in STR_jkAnsiToWide");
		return E_FAIL;
	}
	else
	{
		return S_OK;
	}
}  // AnsiToWide

#ifndef WINCE

#undef DPF_MODNAME
#define DPF_MODNAME "STR_WideToAnsi"

//**********************************************************************
// ------------------------------
// WideToANSI - convert a wide string to an ANSI string
//
// Entry:		Pointer to source wide string
//				Size of source string (in WCHAR units, -1 implies NULL-terminated)
//				Pointer to ANSI string destination
//				Pointer to size of ANSI destination
//
// Exit:		Error code:
//				E_FAIL = operation failed
//				S_OK = operation succeded
//				E_OUTOFMEMORY = destination buffer too small
// ------------------------------
HRESULT	STR_WideToAnsi( const WCHAR *const pWCHARString,
						const DWORD dwWCHARStringLength,
						char *const pString,
						DWORD *const pdwStringLength )
{
	HRESULT	hr;
	int		iReturn;
	BOOL	fDefault;
	char	cMilleniumHackBuffer;	
	char	*pMilleniumHackBuffer;


	DNASSERT( pWCHARString != NULL );
	DNASSERT( pdwStringLength != NULL );
	DNASSERT( ( pString != NULL ) || ( *pdwStringLength == 0 ) );

	//
	// Initialize.  A hack needs to be implemented for WinME parameter
	// validation, because when you pass zero for a destination size, you
	// MUST have a valid pointer.  Works on Win95, 98, NT4, Win2K, etc.....
	//
	hr = S_OK;

	if ( *pdwStringLength == 0 )
	{
		pMilleniumHackBuffer = &cMilleniumHackBuffer;
	}
	else
	{
		pMilleniumHackBuffer = pString;
	}

	fDefault = FALSE;
	iReturn = WideCharToMultiByte( CP_ACP,					// code page (default ANSI)
								   0,						// flags (none)
								   pWCHARString,			// pointer to WCHAR string
								   dwWCHARStringLength,		// size of WCHAR string
								   pMilleniumHackBuffer,	// pointer to destination ANSI string
								   *pdwStringLength,		// size of destination string
								   NULL,					// pointer to default for unmappable characters (none)
								   &fDefault				// pointer to flag indicating that default was used
								   );
	if ( iReturn == 0 )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX( DPFPREP, 0, "Failed to convert WCHAR to multi-byte! %d", dwError );
		hr = E_FAIL;
	}
	else
	{
		if ( *pdwStringLength == 0 )
		{
			hr = E_OUTOFMEMORY;
		}
		else
		{
			DNASSERT( hr == S_OK );
		}

		*pdwStringLength = iReturn;
	}

	//
	// if you hit this ASSERT it's because you've probably got ASCII text as your
	// input WCHAR string.  Double-check your input!!
	//
	DNASSERT( fDefault == FALSE );

	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// ANSIToWide - convert an ANSI string to a wide string
//
// Entry:		Pointer to source multi-byte (ANSI) string
//				Size of source string (-1 imples NULL-terminated)
//				Pointer to multi-byte string destination
//				Pointer to size of multi-byte destination (in WCHAR units)
//
// Exit:		Error code:
//				E_FAIL = operation failed
//				S_OK = operation succeded
//				E_OUTOFMEMORY = destination buffer too small
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "STR_AnsiToWide"
HRESULT	STR_AnsiToWide( const char *const pString,
						const DWORD dwStringLength,
						WCHAR *const pWCHARString,
						DWORD *const pdwWCHARStringLength )
{
	HRESULT	hr;
	int		iReturn;
	WCHAR	MilleniumHackBuffer;
	WCHAR	*pMilleniumHackBuffer;


	DNASSERT( pString != NULL );
	DNASSERT( pdwWCHARStringLength != NULL );
	DNASSERT( ( pWCHARString != NULL ) || ( *pdwWCHARStringLength == 0 ) );

	//
	// Initialize.  A hack needs to be implemented for WinME parameter
	// validation, because when you pass zero for a destination size, you
	// MUST have a valid pointer.  Works on Win95, 98, NT4, Win2K, etc.....
	//
	hr = S_OK;

	if ( *pdwWCHARStringLength == 0 )
	{
		pMilleniumHackBuffer = &MilleniumHackBuffer;
	}
	else
	{
		pMilleniumHackBuffer = pWCHARString;
	}
	
	iReturn = MultiByteToWideChar( CP_ACP,					// code page (default ANSI)
								   0,						// flags (none)
								   pString,					// pointer to multi-byte string			
								   dwStringLength,			// size of string (assume null-terminated)
								   pMilleniumHackBuffer,	// pointer to destination wide-char string
								   *pdwWCHARStringLength	// size of destination in WCHARs
								   );
	if ( iReturn == 0 )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Failed to convert multi-byte to WCHAR! %d", dwError );
		hr = E_FAIL;
	}
	else
	{
		if ( *pdwWCHARStringLength == 0 )
		{
			hr = E_OUTOFMEMORY;
		}
		else
		{
			DNASSERT( hr == S_OK );
		}

		*pdwWCHARStringLength = iReturn;
	}

	return	hr;
}
//**********************************************************************




//	WideToAnsi
//
//	Convert a WCHAR (Wide) string to a CHAR (ANSI) string
//
//	CHAR	*pStr		CHAR string
//	WCHAR	*pWStr		WCHAR string
//	int		iStrSize	size (in bytes) of buffer pointed to by lpStr
#undef DPF_MODNAME
#define DPF_MODNAME "STR_AllocAndConvertToANSI"
/*
 ** GetAnsiString
 *
 *  CALLED BY: Everywhere
 *
 *  PARAMETERS: *ppszAnsi - pointer to string
 *				lpszWide - string to copy
 *
 *  DESCRIPTION:	  handy utility function
 *				allocs space for and converts lpszWide to ansi
 *
 *  RETURNS: string length
 *
 */
HRESULT STR_AllocAndConvertToANSI(LPSTR * ppszAnsi,LPCWSTR lpszWide)
{
	int iStrLen;
	BOOL bDefault;
	
	DNASSERT(ppszAnsi);

	if (!lpszWide)
	{
		*ppszAnsi = NULL;
		return S_OK;
	}

	*ppszAnsi = (char*) DNMalloc((wcslen(lpszWide)*2+1)*sizeof(char));
	if (!*ppszAnsi)	
	{
		DPFX(DPFPREP,0, "could not get ansi string -- out of memory");
		return E_OUTOFMEMORY;
	}

	iStrLen = WideCharToMultiByte(CP_ACP,0,lpszWide,-1,*ppszAnsi,wcslen(lpszWide)*2+1,
			NULL,&bDefault);

	return S_OK;
} // OSAL_AllocAndConvertToANSI



#endif // !WINCE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\appdesc.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       AppDesc.cpp
 *  Content:    Application Description Object
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  09/02/00	mjn		Created
 *  09/14/2000	rmt		Bug #44625 - CORE: Multihomed machines are not always enumerable (extra spew)
 *	01/25/01	mjn		Fixed 64-bit alignment problem when unpacking AppDesc
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


#undef DPF_MODNAME
#define DPF_MODNAME "CApplicationDesc::Initialize"

HRESULT CApplicationDesc::Initialize( void )
{
	memset(this,0,sizeof(CApplicationDesc));

	m_Sig[0] = 'A';
	m_Sig[1] = 'P';
	m_Sig[2] = 'P';
	m_Sig[3] = 'D';

	if (!DNInitializeCriticalSection(&m_cs))
	{
		return( DPNERR_OUTOFMEMORY );
	}

	return( DPN_OK );
}


#undef DPF_MODNAME
#define DPF_MODNAME "CApplicationDesc::Deinitialize"

void CApplicationDesc::Deinitialize( void )
{
	if (m_pwszSessionName)
	{
		DNFree(m_pwszSessionName);
		m_pwszSessionName = NULL;
		m_dwSessionNameSize = 0;
	}

	if (m_pwszPassword)
	{
		DNFree(m_pwszPassword);
		m_pwszPassword = NULL;
		m_dwPasswordSize = 0;
	}

	if (m_pvReservedData)
	{
		DNFree(m_pvReservedData);
		m_pvReservedData = NULL;
		m_dwReservedDataSize = 0;
	}

	if (m_pvApplicationReservedData)
	{
		DNFree(m_pvApplicationReservedData);
		m_pvApplicationReservedData = NULL;
		m_dwApplicationReservedDataSize = 0;
	}

	DNDeleteCriticalSection(&m_cs);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CApplicationDesc::Pack"

HRESULT	CApplicationDesc::Pack(CPackedBuffer *const pPackedBuffer,
							   const DWORD dwFlags)
{
	HRESULT		hResultCode;
	DPN_APPLICATION_DESC	*pdpnAppDesc;

	DPFX(DPFPREP, 6,"Parameters: pPackedBuffer [0x%p], dwFlags [0x%lx]",pPackedBuffer,dwFlags);

	Lock();

	//
	//	Add structure
	//
	pdpnAppDesc = reinterpret_cast<DPN_APPLICATION_DESC*>(pPackedBuffer->GetHeadAddress());
	hResultCode = pPackedBuffer->AddToFront(NULL,sizeof(DPN_APPLICATION_DESC));

	//
	//	Add session name
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_SESSIONNAME) && (m_dwSessionNameSize > 0))
	{
		hResultCode = pPackedBuffer->AddToBack(m_pwszSessionName,m_dwSessionNameSize);
		if (hResultCode == DPN_OK)
		{
			pdpnAppDesc->pwszSessionName = static_cast<WCHAR*>(pPackedBuffer->GetTailAddress());
		}
	}
	else
	{
		if (hResultCode == DPN_OK)
		{
			pdpnAppDesc->pwszSessionName = NULL;
		}
	}

	//
	//	Add password
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_PASSWORD) && (m_dwPasswordSize > 0))
	{
		hResultCode = pPackedBuffer->AddToBack(m_pwszPassword,m_dwPasswordSize);
		if (hResultCode == DPN_OK)
		{
			pdpnAppDesc->pwszPassword = static_cast<WCHAR*>(pPackedBuffer->GetTailAddress());
		}
	}
	else
	{
		if (hResultCode == DPN_OK)
		{
			pdpnAppDesc->pwszPassword = NULL;
		}
	}

	//
	//	Add reserved data
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_RESERVEDDATA) && (m_dwReservedDataSize > 0))
	{
		PVOID					pvReservedData;
		DWORD					dwReservedDataSize;
		BYTE					AppDescReservedData[DPN_MAX_APPDESC_RESERVEDDATA_SIZE];

		
		//
		//	If we understand the reserved data, we want to pad the buffer so the user doesn't
		//	assume the data is less than DPN_MAX_APPDESC_RESERVEDDATA_SIZE bytes long.
		//
		if ((m_dwReservedDataSize == sizeof(SPSESSIONDATA_XNET)) &&
			(*((DWORD*) m_pvReservedData) == SPSESSIONDATAINFO_XNET))
		{
			SPSESSIONDATA_XNET *	pSessionDataXNet;

			
			pSessionDataXNet = (SPSESSIONDATA_XNET*) AppDescReservedData;
			
			memcpy(pSessionDataXNet, m_pvReservedData, m_dwReservedDataSize);
			memset((pSessionDataXNet + 1),
						(((BYTE*) (&pSessionDataXNet->ullKeyID))[1] ^ ((BYTE*) (&pSessionDataXNet->guidKey))[2]),
						(DPN_MAX_APPDESC_RESERVEDDATA_SIZE - sizeof(SPSESSIONDATA_XNET)));

			pvReservedData = AppDescReservedData;
			dwReservedDataSize = DPN_MAX_APPDESC_RESERVEDDATA_SIZE;
		}
		else
		{
			pvReservedData = m_pvReservedData;
			dwReservedDataSize = m_dwReservedDataSize;
		}
		
		hResultCode = pPackedBuffer->AddToBack(pvReservedData, dwReservedDataSize);
		if (hResultCode == DPN_OK)
		{
			pdpnAppDesc->pvReservedData = pPackedBuffer->GetTailAddress();
			pdpnAppDesc->dwReservedDataSize = dwReservedDataSize;
		}
	}
	else
	{
		if (hResultCode == DPN_OK)
		{
			pdpnAppDesc->pvReservedData = NULL;
			pdpnAppDesc->dwReservedDataSize = 0;
		}
	}

	//
	//	Add app reserved data
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_APPRESERVEDDATA) && (m_dwApplicationReservedDataSize > 0))
	{
		hResultCode = pPackedBuffer->AddToBack(m_pvApplicationReservedData,m_dwApplicationReservedDataSize);
		if (hResultCode == DPN_OK)
		{
			pdpnAppDesc->pvApplicationReservedData = pPackedBuffer->GetTailAddress();
			pdpnAppDesc->dwApplicationReservedDataSize = m_dwApplicationReservedDataSize;
		}
	}
	else
	{
		if (hResultCode == DPN_OK)
		{
			pdpnAppDesc->pvApplicationReservedData = NULL;
			pdpnAppDesc->dwApplicationReservedDataSize = 0;
		}
	}

	//
	//	Fill in remainder of structure (if space)
	//
	if (hResultCode == DPN_OK)
	{
		pdpnAppDesc->dwSize = sizeof(DPN_APPLICATION_DESC);
		pdpnAppDesc->dwFlags = m_dwFlags;
		pdpnAppDesc->dwMaxPlayers = m_dwMaxPlayers;
		pdpnAppDesc->dwCurrentPlayers = m_dwCurrentPlayers;
		memcpy(&pdpnAppDesc->guidInstance,&m_guidInstance,sizeof(GUID));
		memcpy(&pdpnAppDesc->guidApplication,&m_guidApplication,sizeof(GUID));
	}

	Unlock();

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CApplicationDesc::PackInfo"

HRESULT CApplicationDesc::PackInfo(CPackedBuffer *const pPackedBuffer,
								   const DWORD dwFlags)
{
	HRESULT		hResultCode;
	DPN_APPLICATION_DESC_INFO	*pInfo;

	DPFX(DPFPREP, 6,"Parameters: pPackedBuffer [0x%p], dwFlags [0x%lx]",pPackedBuffer,dwFlags);

	//
	//	Add structure
	//
	pInfo = reinterpret_cast<DPN_APPLICATION_DESC_INFO*>(pPackedBuffer->GetHeadAddress());
	hResultCode = pPackedBuffer->AddToFront(NULL,sizeof(DPN_APPLICATION_DESC_INFO));

	Lock();

	//
	//	Add session name
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_SESSIONNAME) && (m_dwSessionNameSize > 0))
	{
		hResultCode = pPackedBuffer->AddToBack(m_pwszSessionName,m_dwSessionNameSize);
		if (hResultCode == DPN_OK)
		{
			pInfo->dwSessionNameOffset = pPackedBuffer->GetTailOffset();
			pInfo->dwSessionNameSize = m_dwSessionNameSize;
		}
	}
	else
	{
		if (hResultCode == DPN_OK)
		{
			pInfo->dwSessionNameOffset = 0;
			pInfo->dwSessionNameSize = 0;
		}
	}

	//
	//	Add password
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_PASSWORD) && (m_dwPasswordSize > 0))
	{
		hResultCode = pPackedBuffer->AddToBack(m_pwszPassword,m_dwPasswordSize);
		if (hResultCode == DPN_OK)
		{
			pInfo->dwPasswordOffset = pPackedBuffer->GetTailOffset();
			pInfo->dwPasswordSize = m_dwPasswordSize;
		}
	}
	else
	{
		if (hResultCode == DPN_OK)
		{
			pInfo->dwPasswordOffset = 0;
			pInfo->dwPasswordSize = 0;
		}
	}

	//
	//	Add reserved data
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_RESERVEDDATA) && (m_dwReservedDataSize > 0))
	{
		hResultCode = pPackedBuffer->AddToBack(m_pvReservedData,m_dwReservedDataSize);
		if (hResultCode == DPN_OK)
		{
			pInfo->dwReservedDataOffset = pPackedBuffer->GetTailOffset();
			pInfo->dwReservedDataSize = m_dwReservedDataSize;
		}
	}
	else
	{
		if (hResultCode == DPN_OK)
		{
			pInfo->dwReservedDataOffset = 0;
			pInfo->dwReservedDataSize = 0;
		}
	}

	//
	//	Add app reserved data
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_APPRESERVEDDATA) && (m_dwApplicationReservedDataSize > 0))
	{
		hResultCode = pPackedBuffer->AddToBack(m_pvApplicationReservedData,m_dwApplicationReservedDataSize);
		if (hResultCode == DPN_OK)
		{
			pInfo->dwApplicationReservedDataOffset = pPackedBuffer->GetTailOffset();
			pInfo->dwApplicationReservedDataSize = m_dwApplicationReservedDataSize;
		}
	}
	else
	{
		if (hResultCode == DPN_OK)
		{
			pInfo->dwApplicationReservedDataOffset = 0;
			pInfo->dwApplicationReservedDataSize = 0;
		}
	}

	//
	//	Fill in remainder of structure (if space)
	//
	if (hResultCode == DPN_OK)
	{
		pInfo->dwFlags = m_dwFlags;
		pInfo->dwMaxPlayers = m_dwMaxPlayers;
		pInfo->dwCurrentPlayers = m_dwCurrentPlayers;
		memcpy(&pInfo->guidInstance,&m_guidInstance,sizeof(GUID));
		memcpy(&pInfo->guidApplication,&m_guidApplication,sizeof(GUID));
	}

	Unlock();

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CApplicationDesc::UnpackInfo"

HRESULT CApplicationDesc::UnpackInfo(UNALIGNED DPN_APPLICATION_DESC_INFO *const pdnAppDescInfo,
									 void *const pBufferStart,
									 const DWORD dwFlags)
{
	HRESULT		hResultCode;
	WCHAR		*pwszSessionName;
	WCHAR		*pwszPassword;
	void		*pvReservedData;
	void		*pvApplicationReservedData;

	DPFX(DPFPREP, 6,"Parameters: pdnAppDescInfo [0x%p], pBufferStart [0x%p], dwFlags [0x%lx]",pdnAppDescInfo,pBufferStart,dwFlags);

	pwszSessionName = NULL;
	pwszPassword = NULL;
	pvReservedData = NULL;
	pvApplicationReservedData = NULL;

	//
	//	We will allocate the required memory for the data fields first.
	//	If everything succeeds, we will update the object
	//

	//
	//	Session Name
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_SESSIONNAME) && (pdnAppDescInfo->dwSessionNameSize))
	{
		if ((pwszSessionName = static_cast<WCHAR*>(DNMalloc(pdnAppDescInfo->dwSessionNameSize))) == NULL)
		{
			DPFERR("Could not allocate application desc session name");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
		memcpy(	pwszSessionName,
				static_cast<BYTE*>(pBufferStart) + pdnAppDescInfo->dwSessionNameOffset,
				pdnAppDescInfo->dwSessionNameSize);
	}

	//
	//	Password
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_PASSWORD) && (pdnAppDescInfo->dwPasswordSize))
	{
		if ((pwszPassword = static_cast<WCHAR*>(DNMalloc(pdnAppDescInfo->dwPasswordSize))) == NULL)
		{
			DPFERR("Could not allocate application desc password");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
		memcpy(	pwszPassword,
				static_cast<BYTE*>(pBufferStart) + pdnAppDescInfo->dwPasswordOffset,
				pdnAppDescInfo->dwPasswordSize);
	}

	//
	//	Reserved Data
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_RESERVEDDATA) && (pdnAppDescInfo->dwReservedDataSize))
	{
		if ((pvReservedData = DNMalloc(pdnAppDescInfo->dwReservedDataSize)) == NULL)
		{
			DPFERR("Could not allocate application desc reserved data");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
		memcpy(	pvReservedData,
				static_cast<BYTE*>(pBufferStart) + pdnAppDescInfo->dwReservedDataOffset,
				pdnAppDescInfo->dwReservedDataSize);
	}

	//
	//	Application Reserved Data
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_APPRESERVEDDATA) && (pdnAppDescInfo->dwApplicationReservedDataSize))
	{
		if ((pvApplicationReservedData = DNMalloc(pdnAppDescInfo->dwApplicationReservedDataSize)) == NULL)
		{
			DPFERR("Could not allocate application desc app reserved data");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
		memcpy(	pvApplicationReservedData,
				static_cast<BYTE*>(pBufferStart) + pdnAppDescInfo->dwApplicationReservedDataOffset,
				pdnAppDescInfo->dwApplicationReservedDataSize);
	}


	//
	//	Replace old values in object
	//

	Lock();

	//
	//	Session Name
	//
	if (dwFlags & DN_APPDESCINFO_FLAG_SESSIONNAME)
	{
		if (m_pwszSessionName)
		{
			DNFree(m_pwszSessionName);
			m_pwszSessionName = NULL;
			m_dwSessionNameSize = 0;
		}
		m_pwszSessionName = pwszSessionName;
		m_dwSessionNameSize = pdnAppDescInfo->dwSessionNameSize;
	}

	//
	//	Password
	//
	if (dwFlags & DN_APPDESCINFO_FLAG_PASSWORD)
	{
		if (m_pwszPassword)
		{
			DNFree(m_pwszPassword);
			m_pwszPassword = NULL;
			m_dwPasswordSize = 0;
		}
		m_pwszPassword = pwszPassword;
		m_dwPasswordSize = pdnAppDescInfo->dwPasswordSize;
	}

	//
	//	Reserved Data
	//
	if (dwFlags & DN_APPDESCINFO_FLAG_RESERVEDDATA)
	{
		if (m_pvReservedData)
		{
			DNFree(m_pvReservedData);
			m_pvReservedData = NULL;
			m_dwReservedDataSize = 0;
		}
		m_pvReservedData = pvReservedData;
		m_dwReservedDataSize = pdnAppDescInfo->dwReservedDataSize;
	}

	//
	//	Application Reserved Data
	//
	if (dwFlags & DN_APPDESCINFO_FLAG_APPRESERVEDDATA)
	{
		if (m_pvApplicationReservedData)
		{
			DNFree(m_pvApplicationReservedData);
			m_pvApplicationReservedData = NULL;
			m_dwApplicationReservedDataSize = 0;
		}
		m_pvApplicationReservedData = pvApplicationReservedData;
		m_dwApplicationReservedDataSize = pdnAppDescInfo->dwApplicationReservedDataSize;
	}

	//
	//	Remaining fields
	//
	m_dwMaxPlayers = pdnAppDescInfo->dwMaxPlayers;
	m_dwFlags = pdnAppDescInfo->dwFlags;
	memcpy(&m_guidInstance,&pdnAppDescInfo->guidInstance,sizeof(GUID));
	memcpy(&m_guidApplication,&pdnAppDescInfo->guidApplication,sizeof(GUID));

	Unlock();

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pwszSessionName)
	{
		DNFree(pwszSessionName);
		pwszSessionName = NULL;
	}
	if (pwszPassword)
	{
		DNFree(pwszPassword);
		pwszPassword = NULL;
	}
	if (pvReservedData)
	{
		DNFree(pvReservedData);
		pvReservedData = NULL;
	}
	if (pvApplicationReservedData)
	{
		DNFree(pvApplicationReservedData);
		pvApplicationReservedData = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CApplicationDesc::Update"

HRESULT CApplicationDesc::Update(const DPN_APPLICATION_DESC *const pdnAppDesc,
								 const DWORD dwFlags)
{
	HRESULT		hResultCode;
	WCHAR		*pwszSessionName;
	DWORD		dwSessionNameSize;
	WCHAR		*pwszPassword;
	DWORD		dwPasswordSize;
	void		*pvReservedData;
	DWORD		dwReservedDataSize;
	void		*pvApplicationReservedData;

	DPFX(DPFPREP, 6,"Parameters: pdnAppDesc [0x%p], dwFlags [0x%lx]",pdnAppDesc,dwFlags);

	pwszSessionName = NULL;
	dwSessionNameSize = 0;
	pwszPassword = NULL;
	dwPasswordSize = 0;
	pvReservedData = NULL;
	dwReservedDataSize = 0;
	pvApplicationReservedData = NULL;

	//
	//	We will allocate the required memory for the data fields first.
	//	If everything succeeds, we will update the object
	//

	//
	//	Session Name
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_SESSIONNAME) && (pdnAppDesc->pwszSessionName))
	{
		dwSessionNameSize = (wcslen(pdnAppDesc->pwszSessionName) + 1) * sizeof(WCHAR);
		if ((pwszSessionName = static_cast<WCHAR*>(DNMalloc(dwSessionNameSize))) == NULL)
		{
			DPFERR("Could not allocate application desc session name");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
		memcpy(	pwszSessionName,
				pdnAppDesc->pwszSessionName,
				dwSessionNameSize);
	}

	//
	//	Password
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_PASSWORD) && (pdnAppDesc->pwszPassword))
	{
		dwPasswordSize = (wcslen(pdnAppDesc->pwszPassword) + 1) * sizeof(WCHAR);
		if ((pwszPassword = static_cast<WCHAR*>(DNMalloc(dwPasswordSize))) == NULL)
		{
			DPFERR("Could not allocate application desc password");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
		memcpy(	pwszPassword,
				pdnAppDesc->pwszPassword,
				dwPasswordSize);
	}

	//
	//	Reserved Data
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_RESERVEDDATA) && (pdnAppDesc->pvReservedData))
	{
		dwReservedDataSize = pdnAppDesc->dwReservedDataSize;

		//
		// We don't need to store all of the reserved data for types we understand.
		//
		if ((dwReservedDataSize == DPN_MAX_APPDESC_RESERVEDDATA_SIZE) &&
			(*((DWORD*) pdnAppDesc->pvReservedData) == SPSESSIONDATAINFO_XNET))
		{
			dwReservedDataSize = sizeof(SPSESSIONDATA_XNET);
		}
		
		if ((pvReservedData = DNMalloc(dwReservedDataSize)) == NULL)
		{
			DPFERR("Could not allocate application desc reserved data");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
		memcpy(	pvReservedData,
				pdnAppDesc->pvReservedData,
				dwReservedDataSize);
	}

	//
	//	Application Reserved Data
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_APPRESERVEDDATA) && (pdnAppDesc->pvApplicationReservedData))
	{
		if ((pvApplicationReservedData = DNMalloc(pdnAppDesc->dwApplicationReservedDataSize)) == NULL)
		{
			DPFERR("Could not allocate application desc app reserved data");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
		memcpy(	pvApplicationReservedData,
				pdnAppDesc->pvApplicationReservedData,
				pdnAppDesc->dwApplicationReservedDataSize);
	}


	//
	//	Replace old values in object
	//

	//
	//	Session Name
	//
	if (dwFlags & DN_APPDESCINFO_FLAG_SESSIONNAME)
	{
		if (m_pwszSessionName)
		{
			DNFree(m_pwszSessionName);
			m_pwszSessionName = NULL;
			m_dwSessionNameSize = 0;
		}
		m_pwszSessionName = pwszSessionName;
		m_dwSessionNameSize = dwSessionNameSize;
	}

	//
	//	Password
	//
	if (dwFlags & DN_APPDESCINFO_FLAG_PASSWORD)
	{
		if (m_pwszPassword)
		{
			DNFree(m_pwszPassword);
			m_pwszPassword = NULL;
			m_dwPasswordSize = 0;
		}
		m_pwszPassword = pwszPassword;
		m_dwPasswordSize = dwPasswordSize;
	}

	//
	//	Reserved Data
	//
	if (dwFlags & DN_APPDESCINFO_FLAG_RESERVEDDATA)
	{
		if (m_pvReservedData)
		{
			DNFree(m_pvReservedData);
			m_pvReservedData = NULL;
			m_dwReservedDataSize = 0;
		}
		m_pvReservedData = pvReservedData;
		m_dwReservedDataSize = dwReservedDataSize;
	}

	//
	//	Application Reserved Data
	//
	if (dwFlags & DN_APPDESCINFO_FLAG_APPRESERVEDDATA)
	{
		if (m_pvApplicationReservedData)
		{
			DNFree(m_pvApplicationReservedData);
			m_pvApplicationReservedData = NULL;
			m_dwApplicationReservedDataSize = 0;
		}
		m_pvApplicationReservedData = pvApplicationReservedData;
		m_dwApplicationReservedDataSize = pdnAppDesc->dwApplicationReservedDataSize;
	}

	//
	//	Remaining fields
	//
	m_dwMaxPlayers = pdnAppDesc->dwMaxPlayers;
	m_dwFlags = pdnAppDesc->dwFlags;
	if (dwFlags & DN_APPDESCINFO_FLAG_GUIDS)
	{
		memcpy(&m_guidInstance,&pdnAppDesc->guidInstance,sizeof(GUID));
		memcpy(&m_guidApplication,&pdnAppDesc->guidApplication,sizeof(GUID));
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pwszSessionName)
	{
		DNFree(pwszSessionName);
		pwszSessionName = NULL;
	}
	if (pwszPassword)
	{
		DNFree(pwszPassword);
		pwszPassword = NULL;
	}
	if (pvReservedData)
	{
		DNFree(pvReservedData);
		pvReservedData = NULL;
	}
	if (pvApplicationReservedData)
	{
		DNFree(pvApplicationReservedData);
		pvApplicationReservedData = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CApplicationDesc::CreateNewInstanceGuid"

HRESULT	CApplicationDesc::CreateNewInstanceGuid( void )
{
	HRESULT		hResultCode;

	hResultCode = DNCoCreateGuid(&m_guidInstance);

	return(hResultCode);
}


#ifndef DPNBUILD_SINGLEPROCESS

#undef DPF_SUBCOMP
#define DPF_SUBCOMP 	DN_SUBCOMP_DPNSVR

#undef DPF_MODNAME
#define DPF_MODNAME "CApplicationDesc::RegisterWithDPNSVR"

HRESULT	CApplicationDesc::RegisterWithDPNSVR( IDirectPlay8Address *const pListenAddr )
{
	HRESULT		hResultCode;

#ifdef DBG
	DPFX(DPFPREP,  8, "Registering w/DPNSVR" );

	TCHAR szTmpAddress[200];
	DWORD dwSize = 200;

	hResultCode = IDirectPlay8Address_GetURL( pListenAddr, szTmpAddress, &dwSize );
	if( FAILED( hResultCode ) )
	{
		DPFX(DPFPREP,  1, "Failed to get URL of listen for debug purposes hr=0x%x", hResultCode );
	}
	else
	{
		DPFX(DPFPREP,  8, "Listen on: [%s]", szTmpAddress );
	}

#endif // DBG
	
	hResultCode = DPNSVR_Register( &m_guidApplication,&m_guidInstance,pListenAddr );

	DPFX(DPFPREP,  8, "Request result hr=0x%x", hResultCode );
	
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CApplicationDesc::UnregisterWithDPNSVR"

HRESULT CApplicationDesc::UnregisterWithDPNSVR( void )
{
	HRESULT		hResultCode;

	hResultCode = DPNSVR_UnRegister( &m_guidApplication,&m_guidInstance );
	return(hResultCode);
}

#endif // ! DPNBUILD_SINGLEPROCESS


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_CORE

#undef DPF_MODNAME
#define DPF_MODNAME "CApplicationDesc::IncPlayerCount"

HRESULT	CApplicationDesc::IncPlayerCount(const BOOL fCheckLimit)
{
	HRESULT		hResultCode;

	Lock();

	if ((fCheckLimit) && (m_dwMaxPlayers) && (m_dwCurrentPlayers >= m_dwMaxPlayers))
	{
		hResultCode = DPNERR_SESSIONFULL;
	}
	else
	{
		m_dwCurrentPlayers++;
		hResultCode = DPN_OK;
	}

	Unlock();

	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CApplicationDesc::DecPlayerCount"

void CApplicationDesc::DecPlayerCount( void )
{
	Lock();
	m_dwCurrentPlayers--;
	Unlock();
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNProcessUpdateAppDesc"

HRESULT	DNProcessUpdateAppDesc(DIRECTNETOBJECT *const pdnObject,
							   DPN_APPLICATION_DESC_INFO *const pv)
{
	HRESULT				hResultCode;

	DPFX(DPFPREP, 6,"Parameters: pv [0x%p]",pv);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pv != NULL);

	hResultCode = pdnObject->ApplicationDesc.UnpackInfo(pv,
														pv,
														DN_APPDESCINFO_FLAG_SESSIONNAME | DN_APPDESCINFO_FLAG_PASSWORD |
														DN_APPDESCINFO_FLAG_RESERVEDDATA | DN_APPDESCINFO_FLAG_APPRESERVEDDATA);

	hResultCode = DNUserUpdateAppDesc(pdnObject);

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\asyncop.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       AsyncOp.cpp
 *  Content:    Async Operation routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  04/08/00	mjn		Created
 *	04/11/00	mjn		Added DIRECTNETOBJECT bilink for CAsyncOps
 *	05/02/00	mjn		Added m_pConnection to track Connection over life of AsyncOp
 *	07/27/00	mjn		Changed locking for parent/child bilinks
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//	CAsyncOp::ReturnSelfToPool
//
//	Return object to FPM

#undef DPF_MODNAME
#define DPF_MODNAME "CAsyncOp::ReturnSelfToPool"

void CAsyncOp::ReturnSelfToPool( void )
{
	g_AsyncOpPool.Release( this );
}



#undef DPF_MODNAME
#define DPF_MODNAME "CAsyncOp::Release"

void CAsyncOp::Release(void)
{
	LONG	lRefCount;

	DNASSERT(m_lRefCount > 0);
	lRefCount = DNInterlockedDecrement(const_cast<LONG*>(&m_lRefCount));

	DPFX(DPFPREP, 3,"[0x%p] RefCount [0x%lx]", this, lRefCount);

	if (lRefCount == 0)
	{
		DNASSERT( m_bilinkActiveList.IsEmpty() );

#ifdef DBG
		//
		//	Remove from the bilink of outstanding AsyncOps
		//
		DNEnterCriticalSection(&m_pdnObject->csAsyncOperations);
		Lock();
		m_bilinkAsyncOps.RemoveFromList();
		DNLeaveCriticalSection(&m_pdnObject->csAsyncOperations);
		Unlock();
#endif // DBG

		if (m_pfnCompletion)
		{
			(m_pfnCompletion)(m_pdnObject,this);
			m_pfnCompletion = NULL;
		}
		if (m_phr)
		{
			*m_phr = m_hr;
		}
		if (m_pSyncEvent)
		{
			m_pSyncEvent->Set();
			m_pSyncEvent = NULL;
		}
		if (m_pRefCountBuffer)
		{
			m_pRefCountBuffer->Release();
			m_pRefCountBuffer = NULL;
		}
		if (m_pConnection)
		{
			m_pConnection->Release();
			m_pConnection = NULL;
		}
		if (m_pSP)
		{
			m_pSP->Release();
			m_pSP = NULL;
		}
		if (m_pParent)
		{
			Orphan();
			m_pParent->Release();
			m_pParent = NULL;
		}
		m_dwFlags = 0;
		m_lRefCount = 0;
		ReturnSelfToPool();
	}
};



#undef DPF_MODNAME
#define DPF_MODNAME "CAsyncOp::Orphan"

void CAsyncOp::Orphan( void )
{
	if (m_pParent)
	{
		m_pParent->Lock();
		m_bilinkChildren.RemoveFromList();
		m_pParent->Unlock();
	}
}



#undef DPF_MODNAME
#define DPF_MODNAME "CAsyncOp::SetConnection"

void CAsyncOp::SetConnection( CConnection *const pConnection )
{
	if (pConnection)
	{
		pConnection->AddRef();
	}
	m_pConnection = pConnection;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CAsyncOp::SetSP"

void CAsyncOp::SetSP( CServiceProvider *const pSP )
{
	if (pSP)
	{
		pSP->AddRef();
	}
	m_pSP = pSP;
}



#undef DPF_MODNAME
#define DPF_MODNAME "CAsyncOp::SetRefCountBuffer"

void CAsyncOp::SetRefCountBuffer( CRefCountBuffer *const pRefCountBuffer )
{
	if (pRefCountBuffer)
	{
		pRefCountBuffer->AddRef();
	}
	m_pRefCountBuffer = pRefCountBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\async.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Async.cpp
 *  Content:    Async operation FPM routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/27/99	mjn		Created
 *  12/23/99	mjn		Added HOST_MIGRATE functionality
 *	12/28/99	mjn		Moved Async Op stuff to Async.h
 *	12/29/99	mjn		Reformed DN_ASYNC_OP to use hParentOp instead of lpvUserContext
 *	01/06/00	mjn		Moved NameTable stuff to NameTable.h
 *	01/07/00	mjn		Handle NULL buffer descriptors during sends
 *	01/09/00	mjn		Transfer Application Description at connect
 *	01/10/00	mjn		Added support for DN_MSG_INTERNAL_UPDATE_APPLICATION_DESC
 *	01/12/00	jtk		Added simple code to handle enum and enum response messages.
 *	01/11/00	mjn		Moved AppDesc stuff to AppDesc.h
 *						Moved connect/disconnect stuff to Connect.h
 *	01/14/00	mjn		Added pvUserContext to DN_PerformListen
 *	01/15/00	mjn		Replaced DN_COUNT_BUFFER with CRefCountBuffer
 *	01/16/00	mjn		Moved User callback stuff to User.h
 *	01/17/00	mjn		Fixed ConnectToPeer function names
 *	01/17/00	mjn		Implemented send time
 *	01/19/00	mjn		Fixed Parent Op refCount bug in MultiSend
 *	01/19/00	mjn		Replaced DN_SYNC_EVENT with CSyncEvent
 *	01/20/00	mjn		Route NameTable operations through NameTable operation list
 *	01/21/00	mjn		Added DNProcessInternalOperation
 *	01/23/00	mjn		Added support for DN_MSG_INTERNAL_HOST_DESTROY_PLAYER
 *	01/24/00	mjn		Added support for DN_MSG_INTERNAL_NAMETABLE_VERSION
 *							and DN_MSG_INTERNAL_RESYNC_VERSION
 *	01/25/00	mjn		Added support for DN_MSG_INTERNAL_HOST_MIGRATE_COMPLETE
 *	01/26/00	mjn		Implemented NameTable re-sync at host migration
 *	01/27/00	mjn		Cleaned up switch/case statements
 *	01/27/00	mjn		Added support for retention of receive buffers
 *	02/09/00	mjn		Implemented DNSEND_COMPLETEONPROCESS
 *	02/18/00	mjn		Converted DNADDRESS to IDirectPlayAddress8
 *	03/23/00	mjn		Added phrSync and pvInternal
 *	03/24/00	mjn		Add guidSP to DN_ASYNC_OP
 *  03/25/00    rmt     Added code to unregister ourselves when listens are terminated
 *  04/04/00	rmt		Added check for DPNSVR disable before attempting to unregister
 *	04/04/00	mjn		Added DNProcessTerminateSession and related code
 *  04/06/00    rmt     Added code to complete nocopy voice sends
 *	04/10/00	mjn		Use CAsyncOp for CONNECTs, LISTENs and DISCONNECTs
 *	04/11/00	mjn		Use CAsyncOp for ENUMs
 *	04/13/00	mjn		Use Protocol Interface VTBL (replaces some functions)
 *	04/14/00	mjn		DNPerformListen performs synchronous LISTENs
 *	04/16/00	mjn		Use CAsyncOp for SENDs
 *	04/17/00	mjn		Replaced BUFFERDESC with DPN_BUFFER_DESC
 *	04/17/00	mjn		Added DNCompleteAsyncHandle
 *	04/20/00	mjn		DNPerformChildSend set's child op flags to the parent's op flags
 *	04/21/00	mjn		Added DNPerformDisconnect
 *	04/23/00	mjn		Optionally return child AsyncOp in DNPerformChildSend()
 *				mjn		Removed DNSendCompleteOnProcess (better implementation)
 *	04/24/00	mjn		Added DNCreateUserHandle()
 *	04/26/00	mjn		Removed DN_ASYNC_OP and related functions
 *	04/28/00	mjn		Clear unused buffer descriptions in DN_SendTo()
 *	05/02/00	mjn		Keep a reference on the Connection during SEND's
 *	05/05/00	mjn		Return DPN_OK from DNReceiveCompleteOnProcess() to prevent holding the buffer
 *	05/08/00	vpo		Removed asserts when protocol returns non PENDING
 *	06/05/00	mjn		Removed assert in DNSendMessage
 *	06/21/00	mjn		Modified DNSendMessage() and DNCreateSendParent() to use protocol voice bit
 *	06/24/00	mjn		Added CONNECT completions and fixed DN_MSG_INTERNAL_CONNECT_FAILED processing
 *				mjn		Added code to process DN_MSG_INTERNAL_INSTRUCTED_CONNECT_FAILED
 *	07/02/00	mjn		Added DNSendGroupMessage() *@@END_MSINTERNAL
 *	07/05/00	mjn		Removed references to DN_MSG_INTERNAL_ENUM_WITH_APPLICATION_GUID,DN_MSG_INTERNAL_ENUM,DN_MSG_INTERNAL_ENUM_RESPONSE
 *	07/06/00	mjn		Only use CONNECTED connections in group sends
 *				mjn		Use SP handle instead of interface
 *	07/10/00	mjn		Added DNPerformEnumQuery()
 *				mjn		Correctly flag parent ops in groups sends and added DPNIDs to async ops for better tracking
 *	07/11/00	mjn		Added fNoLoopBack to DNSendGroupMessage()
 *				mjn		Added DNPerformNextEnumQuery(),DNPerformSPListen(),DNPerformNextListen(),DNEnumAdapterGuids(),DNPerformNextConnect()
 *	07/20/00	mjn		Fixed DN_TerminateAllListens() to better use locks
 *				mjn		Fixed connect completions and added DNCompleteConnectOperation() and DNCompleteSendConnectInfo()
 *				mjn		Changed DNPerformDisconnect() to take a CConnection and hEndPt
 *				mjn		Revamped CONNECT process and associated refcounts
 *	07/21/00	mjn		Process DN_MSG_INTERNAL_CONNECT_ATTEMPT_FAILED
 *	07/25/00	mjn		Save result code on parent only if failure in DNCompleteSendConnectInfo()
 *	07/26/00	mjn		DNPerformSPListen() fails if no valid device adapters
 *	07/26/00	mjn		Fixed locking problem with CAsyncOp::MakeChild()
 *	07/28/00	mjn		Added code to track send queue info on CConnection
 *	07/29/00	mjn		Use DNUserConnectionTerminated() rather than DN_TerminateSession()
 *				mjn		Added HRESULT to DNUserReturnBuffer()
 *				mjn		Added fUseCachedCaps to DN_SPEnsureLoaded()
 *	07/30/00	mjn		Use DNUserTerminateSession() rather than DNUserConnectionTerminated()
 *	07/31/00	mjn		Removed DN_MSG_INTERNAL_HOST_DESTROY_PLAYER
 *	07/31/00	mjn		Change DN_MSG_INTERNAL_DELETE_PLAYER to DN_MSG_INTERNAL_DESTROY_PLAYER
 *	08/02/00	mjn		Added dwFlags to DNReceiveUserData()
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/05/00	mjn		Added pParent to DNSendGroupMessage and DNSendMessage()
 *				mjn		Ensure cancelled operations don't proceed
 *				mjn		Added m_bilinkActiveList to CAsyncOp
 *				mjn		Added fInternal to DNPerformChildSend()
 *				mjn		Removed DN_TerminateAllListens()
 *				mjn		Added DNProcessFailedRequest() 
 *				mjn		Added DNCompleteRequest()
 *	08/07/00	mjn		Added code to handle peer-peer integrity checking
 *	08/08/00	mjn		Perform LISTENs on worker thread in DNPerformNextListen()
 *	08/14/00	mjn		Handle failed LISTENs in DNPerformListen()
 *	08/15/00	mjn		Changed registration with DPNSVR
 *				mjn		Allow NULL CConnection object pointer for DNPerformRequest()
 *	08/20/00	mjn		Removed fUseCachedCaps from DN_SPEnsureLoaded()
 *	08/24/00	mjn		Replace DN_NAMETABLE_OP with CNameTableOp
 *				mjn		DN_MSG_INTERNAL_INSTRUCT_CONNECT gets routed through DNNTAddOperation() in DNProcessInternalOperation()
 *	08/31/00	mjn		Release DirectNetLock for failure cases in DNPerformRequest()
 *	09/04/00	mjn		Added CApplicationDesc
 *	09/06/00	mjn		Fixed register with DPNSVR problem
 *  09/14/2000	rmt		Bug #44625: DPLAY8: CORE: Multihomed machines cannot always be enumerated
 *						Moved registration to after point where listen completes.  
 *	09/14/00	mjn		AddRef Protocol refcount when invoking protocol
 *	09/21/00	mjn		Allow NULL CConnection in DNPerformDisconnect()
 *	09/23/00	mjn		Added CSyncEvent to DN_LISTEN_OP_DATA
 *	09/27/00	mjn		Inform lobby of successfull connects from DNCompleteConnectOperation()
 *	10/11/00	mjn		Save protocol handle on AsyncOp earlier in DNPerformListen()
 *				mjn		Clean up DirectNet object in failure cases in DNCompleteConnectToHost() and DNCompleteSendConnectInfo()
 *	10/17/00	mjn		Fixed clean up for unreachable players
 *	12/11/00	mjn		Added verification of internal messages
 *	01/10/01	mjn		DNCompleteUserConnect() cancels ENUMs with DPNERR_CONNECTING
 *	01/22/01	mjn		Set connection as INVALID in DNPerformDisconnect()
 *	01/25/01	mjn		Fixed 64-bit alignment problem in received messages
 *	01/30/00	mjn		Avoid sending requests during host migration in DNPerformRequest()
 *	02/11/01	mjn		Allow complete on process requests during host migration in DNPerformRequest()
 *				mjn		Fixed CConnection::GetEndPt() to track calling thread
 *	03/30/01	mjn		Changes to prevent multiple loading/unloading of SP's
 *	04/05/01	mjn		Added DPNID parameter to DNProcessHostMigration3()
 *	04/11/01	mjn		Propegate LISTEN flags from listen parents in DNPerformSPListen() and DNPerformListen()
 *	04/13/01	mjn		Add requests to the request list in DNPerformRequest()
 *						Remove requests from request list in DNCompleteSendRequest() and DNReceiveCompleteOnProcessReply()
 *	05/07/01	vpo		Whistler 384350: "DPLAY8: CORE: Messages from server can be indicated before connect completes"
 *	05/11/01	mjn		Ensure sends not canceled before storing protocol handle in DNSendMessage()
 *	05/14/01	mjn		Fix client error handling when completing connect if server not available
 *	05/17/01	mjn		Track number of threads performing NameTable operations
 *	05/22/01	mjn		Properly set DirectNetObject as CONNECTED for successful client connect
 *	05/23/01	mjn		Prevent LISTEN's from being cancelled before completing in DNPerformListen()
 *	06/03/01	mjn		Make DISCONNECT's children of failed connect's in DNPerformDisconnect()
 *	06/08/01	mjn		Disconnect connection to host if connect was rejected in DNConnectToHostFailed()
 *	07/22/01	mjn		Added DPNBUILD_NOHOSTMIGRATE compile flag
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


#undef DPF_MODNAME
#define DPF_MODNAME "DNCreateUserHandle"

HRESULT DNCreateUserHandle(DIRECTNETOBJECT *const pdnObject,
						   CAsyncOp **const ppAsyncOp)
{
	HRESULT		hResultCode;
	CAsyncOp	*pAsyncOp;
	DPNHANDLE	handle;

	DPFX(DPFPREP, 6,"Parameters: ppAsyncOp [0x%p]",ppAsyncOp);

	DNASSERT(pdnObject != NULL);
	DNASSERT(ppAsyncOp != NULL);

	pAsyncOp = NULL;

	if ((hResultCode = AsyncOpNew(pdnObject,&pAsyncOp)) != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pAsyncOp->SetOpType( ASYNC_OP_USER_HANDLE );
	pAsyncOp->MakeParent();

	if ((hResultCode = pdnObject->HandleTable.Create(pAsyncOp, &handle)) != DPN_OK)
	{
		DPFERR("Could not create Handle");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	else
	{
		// Add a reference for the HandleTable
		pAsyncOp->AddRef();
		pAsyncOp->Lock();
		pAsyncOp->SetHandle(handle);
		pAsyncOp->Unlock();
	}

	pAsyncOp->AddRef();
	*ppAsyncOp = pAsyncOp;

	pAsyncOp->Release();
	pAsyncOp = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx] (handle = 0x%p)",hResultCode,*ppAsyncOp);
	return(hResultCode);

Failure:
	if (pAsyncOp)
	{
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	goto Exit;
}


#ifndef DPNBUILD_ONLYONEADAPTER

//	DNEnumAdapterGuids
//
//	Generate a list of adapter GUIDs for multiple ENUMs,LISTENs,CONNECTs

#undef DPF_MODNAME
#define DPF_MODNAME "DNEnumAdapterGuids"

HRESULT DNEnumAdapterGuids(DIRECTNETOBJECT *const pdnObject,
						   GUID *const pguidSP,
						   const DWORD dwMatchFlags,
						   GUID **const ppAdapterList,
						   DWORD *const pdwNumAdapters)
{
	HRESULT	hResultCode;
	GUID	*pguid;
	DWORD	dw;
	DWORD	dwAdapterBufferSize;
	DWORD	dwAdapterBufferCount;
	DWORD	dwNumAdapters;
	void	*pvAdapterBuffer;
	void	*pvBlock;
	DPN_SERVICE_PROVIDER_INFO	*pSPInfo;

	DPFX(DPFPREP, 6,"Parameters: pguidSP [0x%p], dwMatchFlags [0x%x], ppAdapterList [0x%p], pdwNumAdapters [0x%p]",
			pguidSP,dwMatchFlags,ppAdapterList,pdwNumAdapters);

	DNASSERT(pdnObject != NULL);
	DNASSERT(ppAdapterList != NULL);
	DNASSERT(pdwNumAdapters != NULL);

	pvBlock = NULL;
	pvAdapterBuffer = NULL;
	dwAdapterBufferSize = 0;
	dwAdapterBufferCount = 0;
	dwNumAdapters = 0;

	hResultCode = DN_EnumAdapters(	pdnObject,
									0,
									pguidSP,
									NULL,
									reinterpret_cast<DPN_SERVICE_PROVIDER_INFO*>(pvAdapterBuffer),
									&dwAdapterBufferSize,
									&dwAdapterBufferCount);
	if ((hResultCode == DPNERR_BUFFERTOOSMALL) && (dwAdapterBufferSize > 0))
	{
		if ((pvAdapterBuffer = DNMalloc(dwAdapterBufferSize)) == NULL)
		{
			DPFERR("Could not allocate space for adapter list");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto Failure;
		}

		if ((pvBlock = MemoryBlockAlloc(pdnObject,dwAdapterBufferCount * sizeof(GUID))) == NULL)
		{
			DPFERR("Could not allocate MemoryBlock");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto Failure;
		}

		pguid = reinterpret_cast<GUID*>(pvBlock);

		hResultCode = DN_EnumAdapters(	pdnObject,
										0,
										pguidSP,
										NULL,
										reinterpret_cast<DPN_SERVICE_PROVIDER_INFO*>(pvAdapterBuffer),
										&dwAdapterBufferSize,
										&dwAdapterBufferCount);
		if (hResultCode != DPN_OK)
		{
			DPFERR("Could not enumerate adapters");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
		DPFX(DPFPREP, 7,"dwAdapterBufferCount [%ld]",dwAdapterBufferCount);

		pSPInfo = reinterpret_cast<DPN_SERVICE_PROVIDER_INFO*>(pvAdapterBuffer);
		for ( dw = 0 ; dw < dwAdapterBufferCount ; dw++ )
		{
			static const GUID	InvalidGuid = { 0 };

			if (!memcmp(&InvalidGuid,&pSPInfo->guid,sizeof(GUID)))
			{
				DPFX(DPFPREP, 1,"Ignoring invalid adapter GUID %u.",dw);
				pSPInfo++;
				continue;
			}

			if ((dwMatchFlags != 0) && (! (pSPInfo->dwFlags & dwMatchFlags)))
			{
				DPFX(DPFPREP, 1,"Ignoring adapter %u with invalid flags (0x%x doesn't match 0x%x).",dw,pSPInfo->dwFlags,dwMatchFlags);
				pSPInfo++;
				continue;
			}
			
			memcpy(pguid,&pSPInfo->guid,sizeof(GUID));
			pguid++;
			dwNumAdapters++;
			pSPInfo++;
		}
		DNFree(pvAdapterBuffer);
		pvAdapterBuffer = NULL;

		DPFX(DPFPREP, 7,"Number of adapters [%ld]",dwNumAdapters);
	}

	*pdwNumAdapters = dwNumAdapters;
	*ppAdapterList = reinterpret_cast<GUID*>(pvBlock);
	pvBlock = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pvBlock)
	{
		MemoryBlockFree(pdnObject,pvBlock);
		pvBlock = NULL;
	}
	if (pvAdapterBuffer)
	{
		DNFree(pvAdapterBuffer);
		pvAdapterBuffer = NULL;
	}
	goto Exit;
}

#endif // ! DPNBUILD_ONLYONEADAPTER


//	DNPerformSPListen
//
//	LISTEN on a particular SP

#undef DPF_MODNAME
#define DPF_MODNAME "DNPerformSPListen"

HRESULT DNPerformSPListen(DIRECTNETOBJECT *const pdnObject,
						  IDirectPlay8Address *const pDeviceAddr,
						  CAsyncOp *const pListenParent,
						  CAsyncOp **const ppParent)
{
	HRESULT				hResultCode;
	CAsyncOp			*pParent;
#ifndef DPNBUILD_ONLYONESP
	GUID				guidSP;
#endif // ! DPNBUILD_ONLYONESP
#ifndef DPNBUILD_ONLYONEADAPTER
	GUID				guidAdapter;
	BOOL				fEnumAdapters;
	DWORD				dwMatchFlags;
#endif // ! DPNBUILD_ONLYONEADAPTER
	DPN_SP_CAPS			dnSPCaps;
	CServiceProvider	*pSP;
	CSyncEvent			*pSyncEvent;

	DPFX(DPFPREP, 6,"Parameters: pDeviceAddr [0x%p], pListenParent [0x%p], ppParent [0x%p]",
			pDeviceAddr,pListenParent,ppParent);

	DNASSERT(pdnObject != NULL);

	pParent = NULL;
	pSP = NULL;
	pSyncEvent = NULL;

#if ((defined(DPNBUILD_ONLYONESP)) && (defined(DPNBUILD_LIBINTERFACE)))
	DNASSERT(pdnObject->pOnlySP != NULL);
	pdnObject->pOnlySP->AddRef();
	pSP = pdnObject->pOnlySP;
#else // ! DPNBUILD_ONLYONESP or ! DPNBUILD_LIBINTERFACE
#ifndef DPNBUILD_ONLYONESP
	//
	//	Extract SP guid as we will probably need it
	//
	if ((hResultCode = IDirectPlay8Address_GetSP(pDeviceAddr,&guidSP)) != DPN_OK)
	{
		DPFERR("SP not specified in Device address");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
#endif // ! DPNBUILD_ONLYONESP

	//
	//	Ensure SP specified in Device address is loaded
	//
	hResultCode = DN_SPEnsureLoaded(pdnObject,
#ifndef DPNBUILD_ONLYONESP
									&guidSP,
#endif // ! DPNBUILD_ONLYONESP
#ifndef DPNBUILD_LIBINTERFACE
									NULL,
#endif // ! DPNBUILD_LIBINTERFACE
									&pSP);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not ensure SP is loaded!" );
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
#endif // ! DPNBUILD_ONLYONESP or ! DPNBUILD_LIBINTERFACE

	//
	//	Get SP caps (to later see if we can ENUM on all adapters)
	//
	if ((hResultCode = DNGetActualSPCaps(pSP,&dnSPCaps)) != DPN_OK)
	{
		DPFERR("Could not get SP caps");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Create a parent op for LISTENs on this SP
	//
	if ((hResultCode = AsyncOpNew(pdnObject,&pParent)) != DPN_OK)
	{
		DPFERR("Could not create SP parent listen op");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pParent->SetOpType( pListenParent->GetOpType() );
	pParent->SetCompletion( DNCompleteListen );
	pParent->SetOpFlags( pListenParent->GetOpFlags() );
	pParent->MakeParent();

	if (pListenParent)
	{
		pListenParent->Lock();
		if (pListenParent->IsCancelled())
		{
			pListenParent->Unlock();
			pParent->SetResult( DPNERR_USERCANCEL );
			hResultCode = DPNERR_USERCANCEL;
			goto Failure;
		}
		pParent->MakeChild( pListenParent );
		pListenParent->Unlock();
	}

	//
	//	Set SP on parent
	//
	pParent->SetSP( pSP );

#ifndef DPNBUILD_ONLYONEADAPTER
	//
	//	If there is no adapter specified in the device address,
	//	we will attempt to enum on each individual adapter if the SP supports it
	//
	fEnumAdapters = FALSE;
	dwMatchFlags = 0;
	if ((hResultCode = IDirectPlay8Address_GetDevice( pDeviceAddr, &guidAdapter )) != DPN_OK)
	{
		DPFX(DPFPREP,1,"Could not determine adapter");
		DisplayDNError(1,hResultCode);

		if (dnSPCaps.dwFlags & DPNSPCAPS_SUPPORTSALLADAPTERS)
		{
			DPFX(DPFPREP, 3,"SP supports ENUMing on all adapters");
			fEnumAdapters = TRUE;

#ifndef DPNBUILD_NOMULTICAST
			//
			//	For multicast listens where the user did not specify an adapter,
			//	let the SP tell us which of its devices would be the best to use.
			//
			if (pListenParent->GetOpType() == ASYNC_OP_LISTEN_MULTICAST)
			{
				dwMatchFlags = DPNSPINFO_DEFAULTMULTICASTDEVICE;
			}
#endif // ! DPNBUILD_NOMULTICAST
		}
	}
#endif // ! DPNBUILD_ONLYONEADAPTER

	pSP->Release();
	pSP = NULL;

#ifndef DPNBUILD_ONLYONEADAPTER
	if(fEnumAdapters)
	{
		DWORD	dwNumAdapters;
		GUID	*pAdapterList = NULL;;
		DN_LISTEN_OP_DATA	*pListenOpData = NULL;

		if ((hResultCode = DNEnumAdapterGuids(	pdnObject,
												&guidSP,
												dwMatchFlags,
												&pAdapterList,
												&dwNumAdapters)) != DPN_OK)
		{
			DPFERR("Could not enum adapters for this SP");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
		if (dwNumAdapters == 0)
		{
			DPFERR("No adapters were found for this SP");
			hResultCode = DPNERR_INVALIDDEVICEADDRESS;
			goto Failure;
		}

		pListenOpData = pParent->GetLocalListenOpData();
		pListenOpData->dwNumAdapters = dwNumAdapters;
		pListenOpData->dwCurrentAdapter = 0;
		pListenOpData->dwCompleteAdapters = 0;

		//
		//	Choose first adapter for initial LISTEN call
		//
		if ((hResultCode = IDirectPlay8Address_SetDevice(pDeviceAddr,pAdapterList)) != DPN_OK)
		{
			DPFERR("Could not set device adapter");
			DisplayDNError(0,hResultCode);
			MemoryBlockFree(pdnObject,pAdapterList);
			goto Failure;
		}
		pListenOpData->dwCurrentAdapter++;
		pParent->SetOpData( pAdapterList );
		pAdapterList = NULL;

		//
		//	Create a SyncEvent for multiple LISTENs
		//
		if ((hResultCode = SyncEventNew(pdnObject,&pSyncEvent)) != DPN_OK)
		{
			DPFERR("Could not create SyncEvent");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pListenOpData->pSyncEvent = pSyncEvent;
		pListenOpData = NULL;
	}
#endif // ! DPNBUILD_ONLYONEADAPTER


	hResultCode = DNPerformListen(pdnObject,pDeviceAddr,pParent);
	if (hResultCode != DPNERR_PENDING)
	{
		DPFERR("Could not perform LISTEN");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	If there is a SyncEvent, wait for it to be set and then return it
	//
	if (pSyncEvent)
	{
		pSyncEvent->WaitForEvent();
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;
	}

	//
	//	Save enum frame size
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if ((pdnObject->dwMaxFrameSize == 0) || (pdnObject->dwMaxFrameSize > (dnSPCaps.dwMaxEnumPayloadSize + sizeof(DN_ENUM_QUERY_PAYLOAD))))
	{
		pdnObject->dwMaxFrameSize = dnSPCaps.dwMaxEnumPayloadSize + sizeof(DN_ENUM_QUERY_PAYLOAD);
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	if (ppParent)
	{
		pParent->AddRef();
		*ppParent = pParent;
	}

	pParent->Release();
	pParent = NULL;

	hResultCode = DPN_OK;

Exit:
	DNASSERT( pParent == NULL );
	DNASSERT( pSP == NULL );
	DNASSERT( pSyncEvent == NULL );

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pParent)
	{
		pParent->Release();
		pParent = NULL;
	}
	if (pSP)
	{
		pSP->Release();
		pSP = NULL;
	}
	if (pSyncEvent)
	{
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;
	}
	goto Exit;
}


//	DNPerformListen
//
//	IDirectPlayAddress8	*pDeviceInfo
//	CAsyncOp			*pParent

#undef DPF_MODNAME
#define DPF_MODNAME "DNPerformListen"

HRESULT DNPerformListen(DIRECTNETOBJECT *const pdnObject,
						IDirectPlay8Address *const pDeviceInfo,
						CAsyncOp *const pParent)
{
	HANDLE			hProtocol;
	HRESULT			hResultCode;
	CAsyncOp		*pAsyncOp;
	CSyncEvent		*pSyncEvent;
	HRESULT			hrListen;
#ifdef DBG
	TCHAR			DP8ABuffer[512] = {0};
	DWORD			DP8ASize = 512;
#endif // DBG

	DPFX(DPFPREP, 6,"Parameters: pDeviceInfo [0x%p], pParent [0x%p]",pDeviceInfo,pParent);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pParent != NULL);

	hProtocol = NULL;
	pAsyncOp = NULL;
	pSyncEvent = NULL;

	// Try an initial check (might get lucky :)
	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
	{
		DPFERR("Not initialized");
		return(DPNERR_UNINITIALIZED);
	}

#ifdef DBG
	IDirectPlay8Address_GetURL(pDeviceInfo,DP8ABuffer,&DP8ASize);
	DPFX(DPFPREP, 7,"Device Info [%s]",DP8ABuffer);
#endif // DBG
	//
	//	Set up for LISTEN
	//

	// HRESULT
	hrListen = DPNERR_GENERIC;

	// SyncEvent
	if ((hResultCode = SyncEventNew(pdnObject,&pSyncEvent)) != DPN_OK)
	{
		DPFERR("Could not create SyncEvent");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	//
	//	Async op for LISTEN
	//
	if ((hResultCode = AsyncOpNew(pdnObject,&pAsyncOp)) != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pAsyncOp->SetOpType( pParent->GetOpType() );
	pAsyncOp->SetSyncEvent(pSyncEvent);
	pAsyncOp->SetResultPointer( &hrListen );

	//
	//	We will set the LISTEN as not cancellable (part of our contract with the Protocol)
	//	We will set it as cancellable if the LISTEN completes successfully.
	//
	pAsyncOp->SetCannotCancel();

	pParent->Lock();
	if (pParent->IsCancelled())
	{
		pParent->Unlock();
		pAsyncOp->SetResult( DPNERR_USERCANCEL );
		hResultCode = DPNERR_USERCANCEL;
		goto Failure;
	}
	pAsyncOp->MakeChild(pParent);
	pParent->Unlock();

	//
	//	Add to active async op list
	//
	DNEnterCriticalSection(&pdnObject->csActiveList);
	pAsyncOp->m_bilinkActiveList.InsertBefore(&pdnObject->m_bilinkActiveList);
	DNLeaveCriticalSection(&pdnObject->csActiveList);

	//
	//	Perform LISTEN
	//
	pAsyncOp->AddRef();
	hResultCode = DNPListen(pdnObject->pdnProtocolData,
							pDeviceInfo,
							pParent->GetSP()->GetHandle(),
							pParent->GetOpFlags(),
							static_cast<void*>(pAsyncOp),
							pdnObject->ApplicationDesc.GetReservedData(),
							pdnObject->ApplicationDesc.GetReservedDataSize(),
							&hProtocol);
	if (hResultCode != DPNERR_PENDING)
	{
		DPFERR("Could not Listen at Protocol layer !");
		DisplayDNError(0,hResultCode);
		pAsyncOp->Release();
		goto Failure;
	}

	//
	//	Save Protocol handle
	//
	pAsyncOp->Lock();
	if (pAsyncOp->IsCancelled() && !pAsyncOp->IsComplete())
	{
		HRESULT		hrCancel;

		pAsyncOp->Unlock();
		DPFX(DPFPREP, 7,"Operation marked for cancel");
		if ((hrCancel = DNPCancelCommand(pdnObject->pdnProtocolData,hProtocol)) == DPN_OK)
		{
			hResultCode = DPNERR_USERCANCEL;
			goto Failure;
		}
		DPFERR("Could not cancel operation");
		DisplayDNError(0,hrCancel);
		pAsyncOp->Lock();
	}
	pAsyncOp->SetProtocolHandle(hProtocol);
	pAsyncOp->Unlock();

	//
	//	Wait for LISTEN to complete.
	//	DNPICompleteListen() will set pSyncEvent and hrListen.
	//	Clean up.
	//
	pSyncEvent->WaitForEvent();
	pAsyncOp->SetSyncEvent(NULL);
	pAsyncOp->SetResultPointer(NULL);

	if (hrListen != DPN_OK)
	{
		DPFERR("LISTEN did not succeed");
		DisplayDNError(0,hrListen);
		hResultCode = hrListen;
		goto Failure;
	}

	pAsyncOp->Release();
	pAsyncOp = NULL;

	pSyncEvent->ReturnSelfToPool();
	pSyncEvent = NULL;

	//
	//	Flag object as LISTENing
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pdnObject->dwFlags |= DN_OBJECT_FLAG_LISTENING;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	DNASSERT( hResultCode == DPNERR_PENDING );

	hResultCode = DPNERR_PENDING;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pAsyncOp)
	{
		DNEnterCriticalSection(&pdnObject->csActiveList);
		pAsyncOp->m_bilinkActiveList.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csActiveList);
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	if (pSyncEvent)
	{
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;
	}
	goto Exit;
}


#ifndef DPNBUILD_ONLYONEADAPTER

//	DNPerformNextListen
//
//	This will attempt to perform the next LISTEN if multiple adapters were requested

#undef DPF_MODNAME
#define DPF_MODNAME "DNPerformNextListen"

HRESULT DNPerformNextListen(DIRECTNETOBJECT *const pdnObject,
							CAsyncOp *const pAsyncOp,
							IDirectPlay8Address *const pDeviceAddr)
{
	HRESULT		hResultCode;
	CAsyncOp	*pParent;

	DPFX(DPFPREP, 6,"Parameters: pAsyncOp [0x%p], pDeviceAddr [0x%p]",pAsyncOp,pDeviceAddr);

	pParent = NULL;

	pAsyncOp->Lock();
	if (pAsyncOp->GetParent())
	{
		pAsyncOp->GetParent()->AddRef();
		pParent = pAsyncOp->GetParent();
	}
	pAsyncOp->Unlock();

	//
	//	If there are any LISTENs left to perform, we will move on to the next one
	//
	if (pParent)
	{
		DN_LISTEN_OP_DATA	*pListenOpData;

		pListenOpData = pParent->GetLocalListenOpData();
		if ((pListenOpData->dwCurrentAdapter < pListenOpData->dwNumAdapters) && pParent->GetOpData())
		{
			GUID		*pguid;
			CWorkerJob	*pWorkerJob;

			pguid = reinterpret_cast<GUID*>(pParent->GetOpData());
			pguid += pListenOpData->dwCurrentAdapter;
			if ((hResultCode = IDirectPlay8Address_SetDevice(pDeviceAddr,pguid)) != DPN_OK)
			{
				DPFERR("Could not set device for next adapter");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}
			pListenOpData->dwCurrentAdapter++;

			//
			//	Perform LISTEN on worker thread
			//
			if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
			{
				DPFERR("Could not create WorkerJob");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}
			pWorkerJob->SetJobType( WORKER_JOB_PERFORM_LISTEN );
			pWorkerJob->SetAddress( pDeviceAddr );
			pWorkerJob->SetAsyncOp( pParent );
			DNQueueWorkerJob(pdnObject,pWorkerJob);
		}

		pParent->Release();
		pParent = NULL;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pParent)
	{
		pParent->Release();
		pParent = NULL;
	}
	goto Exit;
}

#endif // ! DPNBUILD_ONLYONEADAPTER


#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteListen"

void DNCompleteListen(DIRECTNETOBJECT *const pdnObject,
					  CAsyncOp *const pAsyncOp)
{
	DNASSERT(pdnObject != NULL);
	DNASSERT(pAsyncOp != NULL);

#ifndef DPNBUILD_ONLYONEADAPTER
	memset( pAsyncOp->GetLocalListenOpData(),0x00,sizeof(DN_LISTEN_OP_DATA) );
#endif // ! DPNBUILD_ONLYONEADAPTER
	if (pAsyncOp->GetOpData() != NULL)
	{
		MemoryBlockFree(pdnObject,pAsyncOp->GetOpData());
		pAsyncOp->SetOpData( NULL );
	}

	if (pAsyncOp->IsChild())
	{
		DNASSERT(pAsyncOp->GetParent() != NULL);
		pAsyncOp->Orphan();
	}
	else
	{
		if (pAsyncOp->IsParent())
		{
			DNEnterCriticalSection(&pdnObject->csDirectNetObject);
			pdnObject->dwFlags &= (~DN_OBJECT_FLAG_LISTENING);
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		}
	}
}


//	DNPerformEnumQuery
//
//	Initiate an ENUM and take care of the book keeping

#undef DPF_MODNAME
#define DPF_MODNAME "DNPerformEnumQuery"

HRESULT DNPerformEnumQuery(DIRECTNETOBJECT *const pdnObject,
						   IDirectPlay8Address *const pHost,
						   IDirectPlay8Address *const pDevice,
						   const HANDLE hSPHandle,
						   const DWORD dwFlags,
						   void *const pvContext,
						   CAsyncOp *const pParent)
{
	HRESULT					hResultCode;
	CAsyncOp				*pAsyncOp;
	HANDLE					hProtocol;
	DN_ENUM_QUERY_OP_DATA	*pEnumQueryOpData;

	DPFX(DPFPREP, 6,"Parameters: pHost [0x%p], pDevice [0x%p], hSPHandle [0x%p], dwFlags [0x%x], pvContext [0x%p], pParent [0x%p]",
			pHost,pDevice,hSPHandle,dwFlags,pvContext,pParent);

	DNASSERT(pdnObject != NULL);
	DNASSERT(hSPHandle != NULL);

	pAsyncOp = NULL;

	//
	//	Create AsyncOp for ENUM
	//
	if ((hResultCode = AsyncOpNew(pdnObject,&pAsyncOp)) != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pAsyncOp->SetOpType( ASYNC_OP_ENUM_QUERY );
	pAsyncOp->SetResult( DPNERR_GENERIC );
	pAsyncOp->SetCompletion( DNCompleteEnumQuery );
	pAsyncOp->SetContext( pvContext );

	DNASSERT(pParent != NULL);
	pParent->Lock();
	if (pParent->IsCancelled())
	{
		pParent->Unlock();
		pAsyncOp->SetResult( DPNERR_USERCANCEL );
		hResultCode = DPNERR_USERCANCEL;
		goto Failure;
	}
	pAsyncOp->MakeChild(pParent);
	pParent->Unlock();
	pEnumQueryOpData = pParent->GetLocalEnumQueryOpData();

	//
	//	Add to active AsyncOp list
	//
	DNEnterCriticalSection(&pdnObject->csActiveList);
	pAsyncOp->m_bilinkActiveList.InsertBefore(&pdnObject->m_bilinkActiveList);
	DNLeaveCriticalSection(&pdnObject->csActiveList);

	//
	//	AddRef Protocol so that it won't go away until this completes
	//
	DNProtocolAddRef(pdnObject);

	pAsyncOp->AddRef();
	hResultCode = DNPEnumQuery(pdnObject->pdnProtocolData,
							   pHost,
							   pDevice,
							   hSPHandle,
							   &pEnumQueryOpData->BufferDesc[DN_ENUM_BUFFERDESC_QUERY_DN_PAYLOAD],
							   pEnumQueryOpData->dwBufferCount,
							   pEnumQueryOpData->dwRetryCount,				// count of enumerations to send
							   pEnumQueryOpData->dwRetryInterval,			// interval between enumerations
							   pEnumQueryOpData->dwTimeOut,					// linger time after last enumeration is sent
							   dwFlags,
							   reinterpret_cast<void*>(pAsyncOp),
							   ((pEnumQueryOpData->dwAppDescReservedDataSize > 0) ? pEnumQueryOpData->AppDescReservedData : NULL),
							   pEnumQueryOpData->dwAppDescReservedDataSize,
							   &hProtocol);
	if ( hResultCode != DPNERR_PENDING )
	{
		DPFERR( "Failed to start enuming!" );
		pAsyncOp->Release();
		DNProtocolRelease(pdnObject);
		goto Failure;
	}

	//
	//	Setup for proper clean-up
	//
	pAsyncOp->Lock();
	if (pAsyncOp->IsCancelled() && !pAsyncOp->IsComplete())
	{
		HRESULT		hrCancel;

		pAsyncOp->Unlock();
		DPFX(DPFPREP, 7,"Operation marked for cancel");
		if ((hrCancel = DNPCancelCommand(pdnObject->pdnProtocolData,hProtocol)) == DPN_OK)
		{
			hResultCode = DPNERR_USERCANCEL;
			goto Failure;
		}
		DPFERR("Could not cancel operation");
		DisplayDNError(0,hrCancel);
		pAsyncOp->Lock();
	}
	pAsyncOp->SetProtocolHandle( hProtocol );
	pAsyncOp->Unlock();

	pAsyncOp->Release();
	pAsyncOp = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pAsyncOp)
	{
		DNEnterCriticalSection(&pdnObject->csActiveList);
		pAsyncOp->m_bilinkActiveList.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csActiveList);
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	goto Exit;
}


//	DNPerformNextEnumQuery
//
//	This will attempt to perform the next ENUM if multiple adapters were requested

#undef DPF_MODNAME
#define DPF_MODNAME "DNPerformNextEnumQuery"

HRESULT DNPerformNextEnumQuery(DIRECTNETOBJECT *const pdnObject,
							   CAsyncOp *const pAsyncOp,
							   IDirectPlay8Address *const pHostAddr,
							   IDirectPlay8Address *const pDeviceAddr)
{
	HRESULT		hResultCode;
	CAsyncOp	*pParent;

	DPFX(DPFPREP, 6,"Parameters: pAsyncOp [0x%p], pHostAddr [0x%p], pDeviceAddr [0x%p]",pAsyncOp,pHostAddr,pDeviceAddr);

	pParent = NULL;

	pAsyncOp->Lock();
	if (pAsyncOp->GetParent())
	{
		pAsyncOp->GetParent()->AddRef();
		pParent = pAsyncOp->GetParent();
	}
	pAsyncOp->Unlock();

	//
	//	If there are any ENUMs left to perform, we will move on to the next one
	//
	if (pParent)
	{
#ifndef DPNBUILD_ONLYONEADAPTER
		DN_ENUM_QUERY_OP_DATA	*pEnumQueryOpData;

		pEnumQueryOpData = pParent->GetLocalEnumQueryOpData();
		if ((pEnumQueryOpData->dwCurrentAdapter < pEnumQueryOpData->dwNumAdapters) && pParent->GetOpData())
		{
			GUID	*pguid;
			DWORD	dwMultiplexFlag;

			pguid = reinterpret_cast<GUID*>(pParent->GetOpData());
			pguid += pEnumQueryOpData->dwCurrentAdapter;
			if ((hResultCode = IDirectPlay8Address_SetDevice(pDeviceAddr,pguid)) != DPN_OK)
			{
				DPFERR("Could not set device for next adapter");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}
			pEnumQueryOpData->dwCurrentAdapter++;

			if (pEnumQueryOpData->dwCurrentAdapter < pEnumQueryOpData->dwNumAdapters)
			{
				dwMultiplexFlag = DN_ENUMQUERYFLAGS_ADDITIONALMULTIPLEXADAPTERS;
			}
			else
			{
				dwMultiplexFlag = 0;
			}

			hResultCode = DNPerformEnumQuery(	pdnObject,
												pHostAddr,
												pDeviceAddr,
												pParent->GetSP()->GetHandle(),
												pParent->GetOpFlags() | dwMultiplexFlag,
												pParent->GetContext(),
												pParent );
			if (hResultCode != DPN_OK)
			{
				DPFERR("Could not start ENUM");
				DisplayDNError(0,hResultCode);
				goto Failure;
			}
		}
#endif // ! DPNBUILD_ONLYONEADAPTER

		pParent->Release();
		pParent = NULL;
	}

	hResultCode = DPN_OK;

#ifndef DPNBUILD_ONLYONEADAPTER
Exit:
#endif // ! DPNBUILD_ONLYONEADAPTER
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

#ifndef DPNBUILD_ONLYONEADAPTER
Failure:
	if (pParent)
	{
		pParent->Release();
		pParent = NULL;
	}
	goto Exit;
#endif // ! DPNBUILD_ONLYONEADAPTER
}


//	DNCompleteEnumQuery
//
//	Completion for AsyncOps for EnumQuery.
//	This will:
//		- free up the EnumQuery memory block associated with this AsyncOp

#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteEnumQuery"

void DNCompleteEnumQuery(DIRECTNETOBJECT *const pdnObject,
						 CAsyncOp *const pAsyncOp)
{
	DNASSERT(pdnObject != NULL);
	DNASSERT(pAsyncOp != NULL);

	memset(pAsyncOp->GetLocalEnumQueryOpData(),0x00,sizeof(DN_ENUM_QUERY_OP_DATA));
	if (pAsyncOp->GetOpData())
	{
		MemoryBlockFree(pdnObject,pAsyncOp->GetOpData());
		pAsyncOp->SetOpData( NULL );
	}

	if ( pAsyncOp->IsChild() )
	{
		DNASSERT(pAsyncOp->GetParent() != NULL);

		pAsyncOp->GetParent()->Lock();

		//
		//	Save HRESULT
		//
		if (pAsyncOp->GetParent()->GetResult() != DPN_OK)
		{
			pAsyncOp->GetParent()->SetResult( pAsyncOp->GetResult() );
		}

		//
		//	Release parent Handle if it exists
		//
		if (SUCCEEDED(pdnObject->HandleTable.Destroy( pAsyncOp->GetParent()->GetHandle(), NULL )))
		{
			// Release the HandleTable reference
			pAsyncOp->GetParent()->Release();
		}

		pAsyncOp->GetParent()->Unlock();
	}
}


//	DNCompleteEnumResponse
//
//	Completion for AsyncOps for EnumResponse.
//	This will:
//		- generate a RETURN_BUFFER message if there was a user payload
//		- free up the EnumResponse memory block associated with this AsyncOp

#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteEnumResponse"

void DNCompleteEnumResponse(DIRECTNETOBJECT *const pdnObject,
							CAsyncOp *const pAsyncOp)
{
	DN_ENUM_RESPONSE_OP_DATA	*pEnumResponseOpData;

	DNASSERT(pdnObject != NULL);
	DNASSERT(pAsyncOp != NULL);

	pEnumResponseOpData = pAsyncOp->GetLocalEnumResponseOpData();

	if (pEnumResponseOpData->BufferDesc[DN_ENUM_BUFFERDESC_RESPONSE_USER_PAYLOAD].pBufferData != NULL)
	{
		DNUserReturnBuffer(	pdnObject,
							DPN_OK,
							pEnumResponseOpData->BufferDesc[DN_ENUM_BUFFERDESC_RESPONSE_USER_PAYLOAD].pBufferData,
							pEnumResponseOpData->pvUserContext);
	}

	memset(pEnumResponseOpData,0x00,sizeof(DN_ENUM_RESPONSE_OP_DATA));
}



//	DNPerformConnect
//
//	Initiate a connection and take care of the book keeping (create handle).
//
//	DPNID				dpnid				Target player (for ExistingPlayers connect calls)
//	IDirectPlayAddress8	*pDeviceInfo		(may be NULL - no connect performed)
//	IDirectPlayAddress8	*pRemoteAddr		(may be NULL - no connect performed)
//	DWORD				dwFlags				CONNECT op flags
//	CAsyncOp			*pParent			Parent Async Op (if it exists)

#undef DPF_MODNAME
#define DPF_MODNAME "DNPerformConnect"

HRESULT DNPerformConnect(DIRECTNETOBJECT *const pdnObject,
						 const DPNID dpnid,
						 IDirectPlay8Address *const pDeviceInfo,
						 IDirectPlay8Address *const pRemoteAddr,
						 CServiceProvider *const pSP,
						 const DWORD dwConnectFlags,
						 CAsyncOp *const pParent)
{
	HANDLE			hProtocol;
	HRESULT			hResultCode;
	CAsyncOp		*pAsyncOp;
#ifdef DBG
	TCHAR			DP8ABuffer[512] = {0};
	DWORD			DP8ASize;
#endif // DBG

	DPFX(DPFPREP, 6,"Parameters: dpnid [0x%p], pDeviceInfo [0x%p], pRemoteAddr [0x%p], dwConnectFlags [0x%lx], pParent [0x%p]",
		dpnid,pDeviceInfo,pRemoteAddr,dwConnectFlags,pParent);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pDeviceInfo != NULL);
	DNASSERT(pRemoteAddr != NULL);
	DNASSERT(pSP != NULL);

	pAsyncOp = NULL;

#ifdef DBG
	DP8ASize = 512;
	IDirectPlay8Address_GetURL(pRemoteAddr,DP8ABuffer,&DP8ASize);
	DPFX(DPFPREP, 7,"Remote Address [%s]",DP8ABuffer);

	DP8ASize = 512;
	IDirectPlay8Address_GetURL(pDeviceInfo,DP8ABuffer,&DP8ASize);
	DPFX(DPFPREP, 7,"Device Info [%s]",DP8ABuffer);
#endif // DBG

	//
	//	Create AsyncOp for CONNECT
	//
	if ((hResultCode = AsyncOpNew(pdnObject,&pAsyncOp)) != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pAsyncOp->SetDPNID( dpnid );
	pAsyncOp->SetOpFlags( dwConnectFlags );
	pAsyncOp->SetSP(pSP);
	pAsyncOp->SetResult( DPNERR_NOCONNECTION );
	pAsyncOp->SetCompletion( DNCompleteConnect );

	if (pParent)
	{
		pAsyncOp->SetOpType( pParent->GetOpType() );
		pParent->Lock();
		if (pParent->IsCancelled())
		{
			pParent->Unlock();
			pAsyncOp->SetResult( DPNERR_USERCANCEL );
			hResultCode = DPNERR_USERCANCEL;
			goto Failure;
		}
		pAsyncOp->MakeChild(pParent);
		pParent->Unlock();
	}
	else
	{
		//
		// Assume it's a regular connect.
		//
		pAsyncOp->SetOpType( ASYNC_OP_CONNECT );
	}

	//
	//	Add to active async op list
	//
	DNEnterCriticalSection(&pdnObject->csActiveList);
	pAsyncOp->m_bilinkActiveList.InsertBefore(&pdnObject->m_bilinkActiveList);
	DNLeaveCriticalSection(&pdnObject->csActiveList);

	//
	//	AddRef Protocol so that it won't go away until this completes
	//
	DNProtocolAddRef(pdnObject);

	//
	//	Perform CONNECT
	//
	DPFX(DPFPREP, 7,"Performing connect");
	pAsyncOp->AddRef();
	hResultCode = DNPConnect(	pdnObject->pdnProtocolData,
								pDeviceInfo,
								pRemoteAddr,
								pSP->GetHandle(),
								dwConnectFlags,
								pAsyncOp,
								pdnObject->ApplicationDesc.GetReservedData(),
								pdnObject->ApplicationDesc.GetReservedDataSize(),
								&hProtocol);
	if (hResultCode != DPNERR_PENDING)
	{
		DPFERR("Could not CONNECT");
		DisplayDNError(0,hResultCode);
		pAsyncOp->Release();
		DNProtocolRelease(pdnObject);
		goto Failure;
	}

	pAsyncOp->Lock();
	if (pAsyncOp->IsCancelled() && !pAsyncOp->IsComplete())
	{
		HRESULT		hrCancel;

		pAsyncOp->Unlock();
		DPFX(DPFPREP, 7,"Operation marked for cancel");
		if ((hrCancel = DNPCancelCommand(pdnObject->pdnProtocolData,hProtocol)) == DPN_OK)
		{
			//
			//	If the parent has DPN_OK, then another connect succeeded and we don't want to fail.
			//	This may happen in a dual (or more) adapter case.
			//
			if (pParent && pParent->GetResult() == DPN_OK)
			{
				hResultCode = DPN_OK;
			}
			else
			{
				hResultCode = DPNERR_USERCANCEL;
			}
			goto Failure;
		}
		DPFERR("Could not cancel operation");
		DisplayDNError(0,hrCancel);
		pAsyncOp->Lock();
	}
	pAsyncOp->SetProtocolHandle(hProtocol);
	pAsyncOp->Unlock();

	pAsyncOp->Release();
	pAsyncOp = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pAsyncOp)
	{
		DNEnterCriticalSection(&pdnObject->csActiveList);
		pAsyncOp->m_bilinkActiveList.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csActiveList);
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	goto Exit;
}


//	DNPerformNextConnect
//
//	This will attempt to perform the next CONNECT if multiple adapters were requested

#undef DPF_MODNAME
#define DPF_MODNAME "DNPerformNextConnect"

HRESULT DNPerformNextConnect(DIRECTNETOBJECT *const pdnObject,
							 CAsyncOp *const pAsyncOp,
							 IDirectPlay8Address *const pHostAddr,
							 IDirectPlay8Address *const pDeviceAddr)
{
	HRESULT		hResultCode;
	CAsyncOp	*pParent;

	DPFX(DPFPREP, 6,"Parameters: pAsyncOp [0x%p], pHostAddr [0x%p], pDeviceAddr [0x%p]",pAsyncOp,pHostAddr,pDeviceAddr);

	pParent = NULL;

	pAsyncOp->Lock();
	if (pAsyncOp->GetParent())
	{
		pAsyncOp->GetParent()->AddRef();
		pParent = pAsyncOp->GetParent();
	}
	pAsyncOp->Unlock();

	//
	//	If there are any CONNECTs left to perform, we will move on to the next one
	//
	if (pParent)
	{
#ifndef DPNBUILD_ONLYONEADAPTER
		DN_CONNECT_OP_DATA	*pConnectOpData;

		pConnectOpData = pParent->GetLocalConnectOpData();
		if ((pConnectOpData->dwCurrentAdapter < pConnectOpData->dwNumAdapters) && pParent->GetOpData())
		{
			GUID	*pguid;
			DWORD	dwMultiplexFlag;

			pguid = reinterpret_cast<GUID*>(pParent->GetOpData());
			pguid += pConnectOpData->dwCurrentAdapter;
			if ((hResultCode = IDirectPlay8Address_SetDevice(pDeviceAddr,pguid)) != DPN_OK)
			{
				DPFERR("Could not set device for next adapter");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}
			pConnectOpData->dwCurrentAdapter++;

			if (pConnectOpData->dwCurrentAdapter < pConnectOpData->dwNumAdapters)
			{
				dwMultiplexFlag = DN_CONNECTFLAGS_ADDITIONALMULTIPLEXADAPTERS;
			}
			else
			{
				dwMultiplexFlag = 0;
			}
			
			if ((hResultCode = DNPerformConnect(pdnObject,
												NULL,
												pDeviceAddr,
												pHostAddr,
												pParent->GetSP(),
												pParent->GetOpFlags() | dwMultiplexFlag,
												pParent)) != DPN_OK)
			{
				DPFERR("Could not perform CONNECT");
				DisplayDNError(0,hResultCode);
				goto Failure;
			}
		}
#endif // ! DPNBUILD_ONLYONEADAPTER

		pParent->Release();
		pParent = NULL;
	}

	hResultCode = DPN_OK;

#ifndef DPNBUILD_ONLYONEADAPTER
Exit:
#endif // ! DPNBUILD_ONLYONEADAPTER
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

#ifndef DPNBUILD_ONLYONEADAPTER
Failure:
	if (pParent)
	{
		pParent->Release();
		pParent = NULL;
	}
	goto Exit;
#endif // ! DPNBUILD_ONLYONEADAPTER
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteConnect"

void DNCompleteConnect(DIRECTNETOBJECT *const pdnObject,
					   CAsyncOp *const pAsyncOp)
{
	//
	//	Save the result code on the parent if it hasn't already been set (DPN_OK or DPNERR_HOSTREJECTEDCONNECTION)
	//
	if (pAsyncOp->GetParent() && (pAsyncOp->GetResult() != DPNERR_NOCONNECTION))
	{
		pAsyncOp->GetParent()->Lock();
		if ((pAsyncOp->GetParent()->GetResult() != DPN_OK)
				&& (pAsyncOp->GetParent()->GetResult() != DPNERR_HOSTREJECTEDCONNECTION))
		{
			pAsyncOp->GetParent()->SetResult( pAsyncOp->GetResult() );
		}
		pAsyncOp->GetParent()->Unlock();
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteConnectToHost"

void DNCompleteConnectToHost(DIRECTNETOBJECT *const pdnObject,
							 CAsyncOp *const pAsyncOp)
{
	//
	//	Save the result code on the parent if there was a problem (this should be the connect operation parent)
	//
	if ((pAsyncOp->GetResult() != DPN_OK) && (pAsyncOp->GetResult() != DPNERR_NOCONNECTION))
	{
		if (pAsyncOp->GetParent())
		{
			pAsyncOp->GetParent()->Lock();
			if ((pAsyncOp->GetParent()->GetResult() != DPN_OK) && (pAsyncOp->GetParent()->GetResult() != DPNERR_HOSTREJECTEDCONNECTION))
			{
				pAsyncOp->GetParent()->SetResult( pAsyncOp->GetResult() );
			}
			pAsyncOp->GetParent()->Unlock();
		}
	}

	//
	//	Clean up DirectNet object if this fails
	//
	if (pAsyncOp->GetResult() != DPN_OK)
	{
		CAsyncOp	*pConnectParent;

		pConnectParent = NULL;

		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
		pdnObject->dwFlags &= (~(DN_OBJECT_FLAG_CONNECTED
								| DN_OBJECT_FLAG_CONNECTING
								| DN_OBJECT_FLAG_HOST_CONNECTED));
		if (pdnObject->pConnectParent)
		{
			pConnectParent = pdnObject->pConnectParent;
			pdnObject->pConnectParent = NULL;
		}
		if( pdnObject->pIDP8ADevice )
		{
			IDirectPlay8Address_Release( pdnObject->pIDP8ADevice );
			pdnObject->pIDP8ADevice = NULL;
		}
		if( pdnObject->pConnectAddress )
		{
			IDirectPlay8Address_Release( pdnObject->pConnectAddress );
			pdnObject->pConnectAddress = NULL;
		}
		if( pdnObject->pConnectSP )
		{
			pdnObject->pConnectSP->Release();
			pdnObject->pConnectSP = NULL;
		}
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

		if (pConnectParent)
		{
			pConnectParent->Release();
			pConnectParent = NULL;
		}

		DNASSERT(pConnectParent == NULL);
	}

	//
	//	Clean up CONNECT op data
	//
#ifndef DPNBUILD_ONLYONEADAPTER
	memset( pAsyncOp->GetLocalConnectOpData(),0x00,sizeof(DN_CONNECT_OP_DATA) );
#endif // ! DPNBUILD_ONLYONEADAPTER
	if (pAsyncOp->GetOpData() != NULL)
	{
		MemoryBlockFree(pdnObject,pAsyncOp->GetOpData());
		pAsyncOp->SetOpData( NULL );
	}

	//
	//	Detach from parent
	//	I'm not sure why we need to do this !
	//
	DNASSERT(pAsyncOp->IsChild());
	DNASSERT(pAsyncOp->GetParent());
	pAsyncOp->Orphan();
}


//
//	Completion for connect parent
//
#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteConnectOperation"

void DNCompleteConnectOperation(DIRECTNETOBJECT *const pdnObject,
								CAsyncOp *const pAsyncOp)
{
	//
	//	Save the result code on the parent (if it exists - it will be the CONNECT handle)
	//
	if (pAsyncOp->GetParent())
	{
		pAsyncOp->GetParent()->Lock();
		pAsyncOp->GetParent()->SetResult( pAsyncOp->GetResult() );
		pAsyncOp->GetParent()->SetRefCountBuffer( pAsyncOp->GetRefCountBuffer() );
		pAsyncOp->GetParent()->Unlock();

		if (SUCCEEDED(pdnObject->HandleTable.Destroy( pAsyncOp->GetParent()->GetHandle(), NULL )))
		{
			// Release the HandleTable reference
			pAsyncOp->GetParent()->Release();
		}
	}

	//
	//	If the OpData of this AsyncOp is set it is a pointer to a RefCountBuffer pointer
	//	(sync connect call) and we will fill it in
	//
	if (pAsyncOp->GetOpData())
	{
		if (pAsyncOp->GetRefCountBuffer())
		{
			pAsyncOp->GetRefCountBuffer()->AddRef();
			*(static_cast<CRefCountBuffer**>(pAsyncOp->GetOpData())) = pAsyncOp->GetRefCountBuffer();
		}
		pAsyncOp->SetOpData( NULL );
	}

#ifndef DPNBUILD_NOLOBBY
	//
	//	If this connect succeeded, we will inform the lobby
	//
	if (pAsyncOp->GetResult() == DPN_OK)
	{
		DNUpdateLobbyStatus(pdnObject,DPLSESSION_CONNECTED);
	}
	else
	{
		DNUpdateLobbyStatus(pdnObject,DPLSESSION_COULDNOTCONNECT);
	}
#endif // ! DPNBUILD_NOLOBBY

	//
	//	Clear DISCONNECTING flag (in case this was aborted)
	//
	DPFX(DPFPREP, 8,"Clearing DISCONNECTING flag");
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pdnObject->dwFlags &= (~DN_OBJECT_FLAG_DISCONNECTING);
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
}


//
//	Completion for connect handle given to user if Connect was called asynchronously
//
#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteUserConnect"

void DNCompleteUserConnect(DIRECTNETOBJECT *const pdnObject,
						   CAsyncOp *const pAsyncOp)
{
	CNameTableEntry	*pHostPlayer;

	pHostPlayer = NULL;

	//
	//	No longer connecting
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pdnObject->dwFlags &= (~DN_OBJECT_FLAG_CONNECTING);
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	//
	//	Clients need to release all sends from the server that are
	//	queued once the CONNECT_COMPLETE gets indicated.
	//	We prepare to do that now.
	//
	if ((pAsyncOp->GetResult() == DPN_OK) && (pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT))
	{
		if (pdnObject->NameTable.GetHostPlayerRef( &pHostPlayer ) == DPN_OK)
		{
			pHostPlayer->Lock();
			pHostPlayer->MakeAvailable();
			pHostPlayer->NotifyAddRef();
			pHostPlayer->SetInUse();
			pHostPlayer->Unlock();

			//
			//	We are now connected
			//
			DNEnterCriticalSection(&pdnObject->csDirectNetObject);
			pdnObject->dwFlags |= DN_OBJECT_FLAG_CONNECTED;
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		}
		else
		{
			//
			//	If we couldn't get a reference on the server (host player),
			//	then either the server has disconnected, or we are being shut down.
			//	In either case, we should return an error
			//
			DPFX(DPFPREP, 0, "Couldn't get host player reference, failing CONNECT!");
			pAsyncOp->SetResult( DPNERR_NOCONNECTION );
			if (pAsyncOp->GetRefCountBuffer())
			{
				pAsyncOp->GetRefCountBuffer()->Release();
				pAsyncOp->SetRefCountBuffer( NULL );
			}
		}
	}

	//
	//	Generate connect completion for player
	//
	DNUserConnectComplete(	pdnObject,
							pAsyncOp->GetHandle(),
							pAsyncOp->GetContext(),
							pAsyncOp->GetResult(),
							pAsyncOp->GetRefCountBuffer() );

	//
	//	Cancel ENUMs if the CONNECT succeeded and unload SP's
	//
	if (pAsyncOp->GetResult() == DPN_OK)
	{
		DNCancelActiveCommands(pdnObject,DN_CANCEL_FLAG_ENUM_QUERY,NULL,TRUE,DPNERR_CONNECTING);

#if ((! defined(DPNBUILD_LIBINTERFACE)) || (! defined(DPNBUILD_ONLYONESP)))
		DN_SPReleaseAll(pdnObject);
#endif // ! DPNBUILD_LIBINTERFACE or ! DPNBUILD_ONLYONESP

		
		//
		//	Actually release queued messages if necessary
		//
		if (pHostPlayer != NULL)
		{
			pHostPlayer->PerformQueuedOperations();

			pHostPlayer->Release();
			pHostPlayer = NULL;
		}
	}

	DNASSERT( pHostPlayer == NULL );
}


//
//	Completion for NewPlayer sending connect data to the Host
//

#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteSendConnectInfo"

void DNCompleteSendConnectInfo(DIRECTNETOBJECT *const pdnObject,
							   CAsyncOp *const pAsyncOp)
{
	//
	//	Update result of this send on the CONNECT operation parent
	//
	DNASSERT(pAsyncOp->GetParent() != NULL);
	pAsyncOp->GetParent()->Lock();
	if (pAsyncOp->GetResult() != DPN_OK)
	{
		pAsyncOp->GetParent()->SetResult( pAsyncOp->GetResult() );
		//
		//	Clean up CONNECT response buffer from Host
		//
		if (pAsyncOp->GetParent()->GetRefCountBuffer())
		{
			pAsyncOp->GetParent()->GetRefCountBuffer()->Release();
			pAsyncOp->GetParent()->SetRefCountBuffer( NULL );
		}
	}
	pAsyncOp->GetParent()->Unlock();

	//
	//	Clean up DirectNet object if this fails
	//
	if (pAsyncOp->GetResult() != DPN_OK)
	{
		CAsyncOp	*pConnectParent;

		pConnectParent = NULL;

		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
		pdnObject->dwFlags &= (~(DN_OBJECT_FLAG_CONNECTED
								| DN_OBJECT_FLAG_CONNECTING
								| DN_OBJECT_FLAG_HOST_CONNECTED));
		if (pdnObject->pConnectParent)
		{
			pConnectParent = pdnObject->pConnectParent;
			pdnObject->pConnectParent = NULL;
		}
		if( pdnObject->pIDP8ADevice )
		{
			IDirectPlay8Address_Release( pdnObject->pIDP8ADevice );
			pdnObject->pIDP8ADevice = NULL;
		}
		if( pdnObject->pConnectAddress )
		{
			IDirectPlay8Address_Release( pdnObject->pConnectAddress );
			pdnObject->pConnectAddress = NULL;
		}
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

		if (pConnectParent)
		{
			pConnectParent->Release();
			pConnectParent = NULL;
		}

		DNASSERT(pConnectParent == NULL);
	}

	//
	//	Clean up op data
	//
	if (pAsyncOp->GetOpData())
	{
		MemoryBlockFree(pdnObject,pAsyncOp->GetOpData());
		pAsyncOp->SetOpData( NULL );
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPerformDisconnect"

HRESULT DNPerformDisconnect(DIRECTNETOBJECT *const pdnObject,
							CConnection *const pConnection,
							const HANDLE hEndPt,
							const BOOL fImmediate)
{
	HRESULT		hResultCode;
	HANDLE		hProtocol;
	CAsyncOp	*pAsyncOp;
	CAsyncOp	*pConnectParent;
	DWORD		dwProtocolFlags;

	DPFX(DPFPREP, 6,"Parameters: pConnection [0x%p], hEndPt [0x%lx], fImmediate [%d]",pConnection,hEndPt,fImmediate);

	DNASSERT(pdnObject != NULL);

	pAsyncOp = NULL;
	pConnectParent = NULL;
	dwProtocolFlags = 0;

	if (hEndPt == NULL)
	{
		DPFERR("Ignoring NULL endpoint");
		hResultCode = DPN_OK;
		goto Failure;
	}

	//
	//	Create AsyncOp for this operation
	//
	if ((hResultCode = AsyncOpNew(pdnObject,&pAsyncOp)) != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pAsyncOp->SetOpType( ASYNC_OP_DISCONNECT );
	pAsyncOp->SetConnection( pConnection );
	pAsyncOp->SetCannotCancel();	// Cannot cancel DISCONNECT's

	//
	//	AddRef Protocol so that it won't go away until this completes
	//
	DNProtocolAddRef(pdnObject);

	//
	//	If there is a connect parent op, and it's hResultCode is not DPN_OK,
	//	then a connect is failing for some reason, and to prevent it from
	//	completing before this disconnect is complete, we will set the connect parent
	//	as the parent of this disconnect.
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->pConnectParent && (pdnObject->pConnectParent->GetResult() != DPN_OK))
	{
		pdnObject->pConnectParent->AddRef();
		pConnectParent = pdnObject->pConnectParent;
	}
	if ((pdnObject->dwFlags & DN_OBJECT_FLAG_CLOSING_IMMEDIATE) || (fImmediate))
	{
		//
		//	If Close() was called with DPNCLOSE_IMMEDIATE then DN_OBJET_FLAG_CLOSING_IMMEDIATE will be set
		//	and all disconnects should be done in immediate mode
		//
		dwProtocolFlags |= DN_DISCONNECTFLAGS_IMMEDIATE;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	if (pConnectParent)
	{
		pAsyncOp->MakeChild( pConnectParent );
		pConnectParent->Release();
		pConnectParent = NULL;
	}

	//
	//	Set connection as INVALID so that no other operations may use it anymore
	//
	pConnection->Lock();
	pConnection->SetStatus( INVALID );
	pConnection->Unlock();

	//
	//	Perform DISCONNECT
	//
	pAsyncOp->AddRef();
	hResultCode = DNPDisconnectEndPoint(pdnObject->pdnProtocolData,
										hEndPt,
										static_cast<void*>(pAsyncOp),
										&hProtocol,
										dwProtocolFlags);
	if ((hResultCode != DPN_OK) && (hResultCode != DPNERR_PENDING))
	{
		DPFERR("Could not issue DISCONNECT");
		DisplayDNError(0,hResultCode);
		DNProtocolRelease(pdnObject);
		pAsyncOp->Release();
		goto Failure;
	}

	pAsyncOp->Lock();
	pAsyncOp->SetProtocolHandle( hProtocol );
	pAsyncOp->Unlock();

	pAsyncOp->Release();
	pAsyncOp = NULL;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pAsyncOp)
	{
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	if (pConnectParent)
	{
		pConnectParent->Release();
		pConnectParent = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteAsyncHandle"

void DNCompleteAsyncHandle(DIRECTNETOBJECT *const pdnObject,
						   CAsyncOp *const pAsyncOp)
{
	DNASSERT(pdnObject != NULL);
	DNASSERT(pAsyncOp != NULL);

	DNUserAsyncComplete(pdnObject,
						pAsyncOp->GetHandle(),
						pAsyncOp->GetContext(),
						pAsyncOp->GetResult() );
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteSendHandle"

void DNCompleteSendHandle(DIRECTNETOBJECT *const pdnObject,
						  CAsyncOp *const pAsyncOp)
{
	DNASSERT(pdnObject != NULL);
	DNASSERT(pAsyncOp != NULL);

	DNUserSendComplete(	pdnObject,
						pAsyncOp->GetHandle(),
						pAsyncOp->GetContext(),
						pAsyncOp->GetStartTime(),
						pAsyncOp->GetResult(),
						pAsyncOp->GetFirstFrameRTT(),
						pAsyncOp->GetFirstFrameRetryCount());
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteSendAsyncOp"

void DNCompleteSendAsyncOp(DIRECTNETOBJECT *const pdnObject,
						   CAsyncOp *const pAsyncOp)
{
	DNASSERT(pdnObject != NULL);
	DNASSERT(pAsyncOp != NULL);

	//
	//	Update outstanding queue info - this is only performed on children or stand-alone ops (i.e. no parent)
	//
	if ( !pAsyncOp->IsParent() && (pAsyncOp->GetConnection() != NULL))
	{
		DN_SEND_OP_DATA	*pSendOpData = NULL;

		if (pAsyncOp->IsUseParentOpData())
		{
			if (pAsyncOp->IsChild() && pAsyncOp->GetParent())
			{
				pSendOpData = pAsyncOp->GetParent()->GetLocalSendOpData();
			}
		}
		else
		{
			pSendOpData = pAsyncOp->GetLocalSendOpData();
		}

		if (pSendOpData && pSendOpData->dwMsgId == DN_MSG_USER_SEND)
		{
			DWORD	dw;

			DNASSERT( pAsyncOp->GetConnection() != NULL );

			pAsyncOp->GetConnection()->Lock();
			for ( dw = 0 ; dw < pSendOpData->dwNumBuffers ; dw++ )
			{
				if (pAsyncOp->GetOpFlags() & DN_SENDFLAGS_HIGH_PRIORITY)
				{
					pAsyncOp->GetConnection()->RemoveFromHighQueue( pSendOpData->BufferDesc[dw].dwBufferSize );
				}
				else if (pAsyncOp->GetOpFlags() & DN_SENDFLAGS_LOW_PRIORITY)
				{
					pAsyncOp->GetConnection()->RemoveFromLowQueue( pSendOpData->BufferDesc[dw].dwBufferSize );
				}
				else
				{
					pAsyncOp->GetConnection()->RemoveFromNormalQueue( pSendOpData->BufferDesc[dw].dwBufferSize );
				}
			}
			pAsyncOp->GetConnection()->Unlock();
		}
	}

	//
	//	Clean up
	//
	if (!pAsyncOp->IsUseParentOpData())
	{
		DN_SEND_OP_DATA	*pSendOpData;
		DWORD			dw;

		pSendOpData = pAsyncOp->GetLocalSendOpData();
		for ( dw = 0 ; dw < pSendOpData->dwNumBuffers ; dw++ )
		{
			pSendOpData->BufferDesc[dw].dwBufferSize = 0;
			pSendOpData->BufferDesc[dw].pBufferData = NULL;
		}
		pSendOpData->dwMsgId = 0;
		pSendOpData->dwNumBuffers = 0;
	}

	if ( pAsyncOp->IsChild() )
	{
		DNASSERT(pAsyncOp->GetParent() != NULL);

		pAsyncOp->GetParent()->Lock();

		//
		//	Save HRESULT.  Overwrite the parent's error while it's not DPN_OK.
		//
		if (pAsyncOp->GetParent()->GetResult() != DPN_OK)
		{
			pAsyncOp->GetParent()->SetResult( pAsyncOp->GetResult() );
		}

		//
		//	Release parent Handle if it exists
		//
		if (pAsyncOp->GetParent()->GetOpType() == ASYNC_OP_USER_HANDLE)
		{
			if (SUCCEEDED(pdnObject->HandleTable.Destroy( pAsyncOp->GetParent()->GetHandle(), NULL )))
			{
				// Release the HandleTable reference
				pAsyncOp->GetParent()->Release();
			}
		}

		pAsyncOp->GetParent()->Unlock();
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteRequest"

void DNCompleteRequest(DIRECTNETOBJECT *const pdnObject,
					   CAsyncOp *const pAsyncOp)
{
	DWORD			dw;
	DN_SEND_OP_DATA	*pSendOpData;

	DNASSERT(pdnObject != NULL);
	DNASSERT(pAsyncOp != NULL);

	//
	//	Clean up op data
	//
	pSendOpData = pAsyncOp->GetLocalSendOpData();
	for ( dw = 0 ; dw < pSendOpData->dwNumBuffers ; dw++ )
	{
		pSendOpData->BufferDesc[dw].dwBufferSize = 0;
		pSendOpData->BufferDesc[dw].pBufferData = NULL;
	}
	pSendOpData->dwMsgId = 0;
	pSendOpData->dwNumBuffers = 0;
	pSendOpData = NULL;
	
	//
	//	If the parent exists, copy the result up, and then remove them from the HandleTable
	//
	if (pAsyncOp->GetParent() != NULL)
	{
		pAsyncOp->GetParent()->Lock();
		pAsyncOp->GetParent()->SetResult( pAsyncOp->GetResult() );
		pAsyncOp->GetParent()->Unlock();

		if (SUCCEEDED(pdnObject->HandleTable.Destroy( pAsyncOp->GetParent()->GetHandle(), NULL )))
		{
			// Release the HandleTable reference
			pAsyncOp->GetParent()->Release();
		}
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteSendRequest"

void DNCompleteSendRequest(DIRECTNETOBJECT *const pdnObject,
						   CAsyncOp *const pAsyncOp)
{
	DNASSERT(pdnObject != NULL);
	DNASSERT(pAsyncOp != NULL);

	DNASSERT(pAsyncOp->GetParent() != NULL);
	if (pAsyncOp->GetResult() != DPN_OK)
	{
		//
		//	If this operation was cancelled or was NOT internal (i.e. complete on process send)
		//	remove the parent (RequestChild) AsyncOp from the HandleTable and from the request list
		//
		if ((pAsyncOp->GetResult() == DPNERR_USERCANCEL) || !pAsyncOp->IsInternal())
		{
			DNASSERT(pAsyncOp->GetParent()->GetHandle() != 0);
			DNASSERT(pAsyncOp->GetParent()->GetOpType() == ASYNC_OP_REQUEST);
			DNEnterCriticalSection(&pdnObject->csActiveList);
			pAsyncOp->GetParent()->m_bilinkActiveList.RemoveFromList();
			DNLeaveCriticalSection(&pdnObject->csActiveList);

			if (SUCCEEDED(pdnObject->HandleTable.Destroy( pAsyncOp->GetParent()->GetHandle(), NULL )))
			{
				// Release the HandleTable reference
				pAsyncOp->GetParent()->Release();
			}
		}
	}
	else
	{
		//
		//	Mark this operation as PLAYERLOST. If we do get an operation complete message,
		//	this result will get overwritten.
		//
		pAsyncOp->GetParent()->Lock();
		if (pAsyncOp->GetParent()->GetResult() == DPNERR_GENERIC)
		{
			pAsyncOp->GetParent()->SetResult( DPNERR_PLAYERLOST );
		}
		pAsyncOp->GetParent()->Unlock();
	}
}


//	DNSendMessage
//
//	Send structured message to given endpoint.  Internally generated sends have a header
//	associated with them.  The first few bytes of this header are a signature, indicating
//	an internal message.  User generated sends do not have a header, unless they contain
//	the signature.  In this case, the user message is escaped with a header indicating this.
//
//	For internal sends:
//	- Create message header (dwMsgId,dwParam1,dwParam2)
//	- Send message header and supplied data buffer (lpBuffDesc)
//	- Save Async Operation info to be unwound when send completes
//	- If pdnCountBuffer is specified, pBuffDesc may or may not point to its contents.
//

#undef DPF_MODNAME
#define DPF_MODNAME "DNSendMessage"

HRESULT DNSendMessage(DIRECTNETOBJECT *const pdnObject,
					  CConnection *const pConnection,				//	Connection to send to
					  const DWORD dwMsgId,							//	Message ID
					  const DPNID dpnidTarget,						//	Target of this send (may be NULL)
					  const DPN_BUFFER_DESC *const pdnBufferDesc,	//	Array of buffer desc's
					  const DWORD cBufferDesc,						//	Number of buffer desc's
					  CRefCountBuffer *const pRefCountBuffer,		//	RefCountBuffer (may be NULL)
					  const DWORD dwTimeOut,						//	Time out
					  const DWORD dwSendFlags,						//	Send flags
					  CAsyncOp *const pParent,						//	Parent of this send
					  CAsyncOp **const ppAsyncOp)					//	CAsyncOp created for this send
{
	DWORD			dw;
	HANDLE			hProtocol;
	HRESULT			hResultCode;
	HANDLE			hEndPt;
	CAsyncOp		*pAsyncOp;
	DN_SEND_OP_DATA	*pSendOpData;
	CCallbackThread	CallbackThread;
	DWORD			dwStart;


	DPFX(DPFPREP, 6,"Parameters: pConnection [0x%p], dwMsgId [0x%x], dpnidTarget [0x%x], pdnBufferDesc [0x%p], cBufferDesc [%ld], pRefCountBuffer [0x%p], dwTimeOut [%ld], dwSendFlags [0x%lx], pParent [0x%p], ppAsyncOp [0x%p]",
		pConnection,dwMsgId,dpnidTarget,pdnBufferDesc,cBufferDesc,pRefCountBuffer,dwTimeOut,dwSendFlags,pParent,ppAsyncOp);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pConnection != NULL);

	pAsyncOp = NULL;
	pSendOpData = NULL;
	CallbackThread.Initialize();

	//
	//	Create AsyncOp for SEND
	//
	if ((hResultCode = AsyncOpNew(pdnObject,&pAsyncOp)) != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pAsyncOp->SetOpType( ASYNC_OP_SEND );
	pAsyncOp->SetDPNID( dpnidTarget );
	pAsyncOp->SetRefCountBuffer( pRefCountBuffer );
	pAsyncOp->SetStartTime( GETTIMESTAMP() );
	if (dwMsgId & DN_MSG_INTERNAL)
	{
		//
		//	We have to set this early (before it's in the active list or a child) so that it won't
		//	be prematurely cancelled (before we get a chance to mark it INTERNAL).
		//
		pAsyncOp->SetInternal();
	}

	//
	//	Make child if parent was supplied
	//
	if (pParent)
	{
		pParent->Lock();
		if (pParent->IsCancelled())
		{
			pParent->Unlock();
			pAsyncOp->SetResult( DPNERR_USERCANCEL );
			hResultCode = DPNERR_USERCANCEL;
			goto Failure;
		}
		pAsyncOp->MakeChild( pParent );
		pParent->Unlock();
	}

	//
	//	Add to active async op list
	//
	DNEnterCriticalSection(&pdnObject->csActiveList);
	pAsyncOp->m_bilinkActiveList.InsertBefore(&pdnObject->m_bilinkActiveList);
	DNLeaveCriticalSection(&pdnObject->csActiveList);

	//
	//	Set-up SEND op data block
	//
	pSendOpData = pAsyncOp->GetLocalSendOpData();
	pSendOpData->dwMsgId = dwMsgId;
	if (dwMsgId & DN_MSG_INTERNAL)
	{
#ifndef DPNBUILD_NOVOICE
		if (dwMsgId == DN_MSG_INTERNAL_VOICE_SEND)
		{
			DNASSERT(pdnBufferDesc != NULL);

			dwStart = 0;
			pAsyncOp->SetOpFlags( dwSendFlags | DN_SENDFLAGS_SET_USER_FLAG | DN_SENDFLAGS_SET_USER_FLAG_TWO | DN_SENDFLAGS_COALESCE );
		}
		else
#endif // DPNBUILD_NOVOICE
		{
			pSendOpData->BufferDesc[0].pBufferData = reinterpret_cast<BYTE*>( &(pSendOpData->dwMsgId) );
			pSendOpData->BufferDesc[0].dwBufferSize = sizeof( DWORD );

			dwStart = 1;
			pAsyncOp->SetOpFlags( dwSendFlags | DN_SENDFLAGS_SET_USER_FLAG | DN_SENDFLAGS_COALESCE );
		}
	}
	else
	{
		DNASSERT(pdnBufferDesc != NULL);

		dwStart = 0;
		pAsyncOp->SetOpFlags( dwSendFlags );
	}
	for ( dw = 0 ; dw < cBufferDesc ; dw++ )
	{
		pSendOpData->BufferDesc[dwStart+dw].pBufferData = pdnBufferDesc[dw].pBufferData;
		pSendOpData->BufferDesc[dwStart+dw].dwBufferSize = pdnBufferDesc[dw].dwBufferSize;
	}
	pSendOpData->dwNumBuffers = cBufferDesc + dwStart;

	if ((hResultCode = pConnection->GetEndPt(&hEndPt,&CallbackThread)) != DPN_OK)
	{
		DPFERR("Could not get end point from connection");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_CONNECTIONLOST;	// re-map this
		goto Failure;
	}
	pAsyncOp->SetConnection( pConnection );

	if (hEndPt == NULL)		//	Message for local player - Put on local message queue
	{
		//
		//	INTERNAL Message
		//
		DPFX(DPFPREP, 5,"INTERNAL Message");

		//
		//	AddRef Protocol as SendComplete will release this reference
		//
		DNProtocolAddRef(pdnObject);

		pAsyncOp->AddRef();
		hResultCode = DNWTSendInternal(	pdnObject,
										pAsyncOp );

		pConnection->ReleaseEndPt(&CallbackThread);

		DNASSERT( hResultCode == DPNERR_PENDING );
	}
	else
	{
		//
		//	EXTERNAL Message
		//
		DPFX(DPFPREP, 5,"EXTERNAL Message");

		//
		//	AddRef Protocol so that it won't go away until this completes
		//
		DNProtocolAddRef(pdnObject);

		pAsyncOp->AddRef();
		hResultCode = DNPSendData(		    pdnObject->pdnProtocolData,
											hEndPt,
											pSendOpData->dwNumBuffers,
											&pSendOpData->BufferDesc[0],
											dwTimeOut,
											pAsyncOp->GetOpFlags(),
											reinterpret_cast<void*>(pAsyncOp),
											&hProtocol);

		pConnection->ReleaseEndPt(&CallbackThread);

		if (hResultCode != DPNERR_PENDING)
		{
			if (hResultCode != DPN_OK)
			{
				DPFERR("Could not send data");
				DisplayDNError(0,hResultCode);
			}
			pAsyncOp->Release();
			DNProtocolRelease(pdnObject);
			goto Failure;
		}

		pAsyncOp->Lock();
		if (pAsyncOp->IsCancelled() && !pAsyncOp->IsComplete())
		{
			HRESULT		hrCancel;

			pAsyncOp->Unlock();
			DPFX(DPFPREP, 7,"Operation marked for cancel");
			if ((hrCancel = DNPCancelCommand(pdnObject->pdnProtocolData,hProtocol)) == DPN_OK)
			{
				hResultCode = DPNERR_USERCANCEL;
				goto Failure;
			}
			DPFERR("Could not cancel operation");
			DisplayDNError(0,hrCancel);
			pAsyncOp->Lock();
		}
		pAsyncOp->SetProtocolHandle( hProtocol );
		pAsyncOp->Unlock();
	}

	DNASSERT( hResultCode == DPNERR_PENDING );

	//
	//	Update outstanding queue info for USER sends (now guaranteed to be cleaned up by the completion)
	//	and set completion
	//
	if (!(dwMsgId & DN_MSG_INTERNAL))
	{
		pConnection->Lock();
		for ( dw = 0 ; dw < pSendOpData->dwNumBuffers ; dw++ )
		{
			if (dwSendFlags & DN_SENDFLAGS_HIGH_PRIORITY)
			{
				pConnection->AddToHighQueue( pSendOpData->BufferDesc[dw].dwBufferSize );
			}
			else if (dwSendFlags & DN_SENDFLAGS_LOW_PRIORITY)
			{
				pConnection->AddToLowQueue( pSendOpData->BufferDesc[dw].dwBufferSize );
			}
			else
			{
				pConnection->AddToNormalQueue( pSendOpData->BufferDesc[dw].dwBufferSize );
			}
		}
		pConnection->Unlock();
	}
	pAsyncOp->SetCompletion( DNCompleteSendAsyncOp );
	pSendOpData = NULL;

	if (ppAsyncOp != NULL)
	{
		pAsyncOp->AddRef();
		*ppAsyncOp = pAsyncOp;
	}

	pAsyncOp->Release();
	pAsyncOp = NULL;

Exit:

	CallbackThread.Deinitialize();

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pAsyncOp)
	{
		DNEnterCriticalSection(&pdnObject->csActiveList);
		pAsyncOp->m_bilinkActiveList.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csActiveList);
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	if (pSendOpData)
	{
		for ( dw = 0 ; dw < pSendOpData->dwNumBuffers ; dw++ )
		{
			pSendOpData->BufferDesc[dw].dwBufferSize = 0;
			pSendOpData->BufferDesc[dw].pBufferData = NULL;
		}
		pSendOpData->dwMsgId = 0;
		pSendOpData->dwNumBuffers = 0;
		pSendOpData = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNSendGroupMessage"

HRESULT DNSendGroupMessage(DIRECTNETOBJECT *const pdnObject,
						   CNameTableEntry *const pGroup,
						   const DWORD dwMsgId,
						   const DPN_BUFFER_DESC *const pdnBufferDesc,
						   const DWORD cBufferDesc,
						   CRefCountBuffer *const pRefCountBuffer,
						   const DWORD dwTimeOut,
						   const DWORD dwSendFlags,
						   const BOOL fNoLoopBack,
						   const BOOL fRequest,
						   CAsyncOp *const pParent,
						   CAsyncOp **const ppGroupSendParent)
{
	HRESULT		hResultCode;
	CAsyncOp	*pAsyncOp;
	CAsyncOp	*pGroupSendParent;
	CBilink		*pBilink;
	CConnection	*pConnection;
	CGroupConnection	*pGroupConnection;
	DN_GROUP_SEND_OP	*pSendOp;
	DN_GROUP_SEND_OP	*pTemp;
	DPNID				dpnidLocalPlayer;

	DPFX(DPFPREP, 4,"Parameters: pGroup [0x%p], dwMsgId [0x%lx], pdnBufferDesc [0x%p], pRefCountBuffer [0x%p], dwTimeOut [%ld], dwSendFlags [0x%lx], fNoLoopBack [%ld], fRequest [%ld], pParent [0x%p], ppGroupSendParent [0x%p]",
			pGroup,dwMsgId,pdnBufferDesc,pRefCountBuffer,dwTimeOut,dwSendFlags,fNoLoopBack,fRequest,pParent,ppGroupSendParent);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pGroup != NULL);
	DNASSERT(ppGroupSendParent != NULL);

	pAsyncOp = NULL;
	pGroupSendParent = NULL;
	pConnection = NULL;
	pGroupConnection = NULL;

	if (fNoLoopBack)
	{
		CNameTableEntry		*pLocalPlayer;

		pLocalPlayer = NULL;
		if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
		{
			DPFERR("Could not get local player reference");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
		dpnidLocalPlayer = pLocalPlayer->GetDPNID();
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	else
	{
		dpnidLocalPlayer = 0;
	}

	//
	//	Create group send target list
	//
	pSendOp = NULL;
	pGroup->Lock();
	pBilink = pGroup->m_bilinkConnections.GetNext();
	while (pBilink != &pGroup->m_bilinkConnections)
	{
		pGroupConnection = CONTAINING_OBJECT(pBilink,CGroupConnection,m_bilink);
		if ((hResultCode = pGroupConnection->GetConnectionRef( &pConnection )) == DPN_OK)
		{
			//
			//	We will only use CONNECTED connections (not CONNECTING,DISCONNECTING, or INVALID ones)
			//
			if (pConnection->IsConnected())
			{
				if ((!fNoLoopBack) || (pConnection->GetDPNID() != dpnidLocalPlayer))
				{
					//
					//	Save this connection
					//
					pTemp = static_cast<DN_GROUP_SEND_OP*>(MemoryBlockAlloc(pdnObject,sizeof(DN_GROUP_SEND_OP)));
					if (pTemp == NULL)
					{
						pGroup->Unlock();
						DPFERR("Could not create DN_GROUP_SEND_OP");
						hResultCode = DPNERR_OUTOFMEMORY;
						goto Failure;
					}
					pConnection->AddRef();
					pTemp->pConnection = pConnection;
					pTemp->pNext = pSendOp;
					pSendOp = pTemp;
				}
			}
			pConnection->Release();
			pConnection = NULL;
		}
		pBilink = pBilink->GetNext();
	}
	pGroup->Unlock();

	//
	//	Create group send parent
	//
	if ((hResultCode = DNCreateSendParent(	pdnObject,
											dwMsgId,
											pdnBufferDesc,
											cBufferDesc,
											dwSendFlags,
											&pGroupSendParent)) != DPN_OK)
	{
		DPFERR("Could not create SEND parent");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if (pRefCountBuffer)
	{
		pGroupSendParent->SetRefCountBuffer( pRefCountBuffer );
	}
	pGroupSendParent->SetDPNID( pGroup->GetDPNID() );

	//
	//	Make child if parent specified
	//
	if (pParent)
	{
		pParent->Lock();
		if (pParent->IsCancelled())
		{
			pParent->Unlock();
			pGroupSendParent->SetResult( DPNERR_USERCANCEL );
			hResultCode = DPNERR_USERCANCEL;
			goto Failure;
		}
		pGroupSendParent->MakeChild( pParent );
		pParent->Unlock();
	}

	//
	//	Preset error code on send parent to DPNSUCCESS_NORECEIVERS
	//
	pGroupSendParent->Lock();
	if (pGroupSendParent->GetResult() == DPNERR_GENERIC)
	{
		pGroupSendParent->SetResult( DPNSUCCESS_NOPLAYERSINGROUP );
	}
	pGroupSendParent->Unlock();

	//
	//	Traverse send list and perform sends
	//
	while (pSendOp)
	{
		if (fRequest)
		{
			hResultCode = DNPerformRequest(	pdnObject,
											DN_MSG_INTERNAL_REQ_PROCESS_COMPLETION,
											pdnBufferDesc,
											pSendOp->pConnection,
											pGroupSendParent,
											&pAsyncOp);
		}
		else
		{
			hResultCode = DNPerformChildSend(	pdnObject,
												pGroupSendParent,
												pSendOp->pConnection,
												dwTimeOut,
												&pAsyncOp,
												FALSE);
		}

		if (pAsyncOp != NULL)
		{
			pAsyncOp->SetDPNID( pSendOp->pConnection->GetDPNID() );
			pAsyncOp->Release();
			pAsyncOp = NULL;
		}

		//
		//	Destroy old group send op
		//
		pTemp = pSendOp;
		pSendOp = pSendOp->pNext;
		pTemp->pConnection->Release();
		pTemp->pConnection = NULL;
		MemoryBlockFree(pdnObject,pTemp);
	}

	//
	//	Pass back group send parent
	//
	*ppGroupSendParent = pGroupSendParent;
	pGroupSendParent = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pAsyncOp)
	{
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	if (pGroupSendParent)
	{
		pGroupSendParent->Release();
		pGroupSendParent = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCreateSendParent"

HRESULT DNCreateSendParent(DIRECTNETOBJECT *const pdnObject,
						   const DWORD dwMsgId,
						   const DPN_BUFFER_DESC *const pdnBufferDesc,
						   const DWORD cBufferDesc,
						   const DWORD dwSendFlags,
						   CAsyncOp **const ppParent)
{
	HRESULT			hResultCode;
	CAsyncOp		*pAsyncOp;
	DN_SEND_OP_DATA	*pSendOpData;
	DWORD			dwStart;
	DWORD			dw;

	DPFX(DPFPREP, 4,"Parameters: dwMsgId [0x%lx], pdnBufferDesc [0x%p], cBufferDesc [%ld], dwSendFlags [0x%lx], ppParent [0x%p]",
			dwMsgId,pdnBufferDesc,cBufferDesc,dwSendFlags,ppParent);

	DNASSERT(pdnObject != NULL);
	DNASSERT(ppParent != NULL);

	pAsyncOp = NULL;
	pSendOpData = NULL;

	if ((hResultCode = AsyncOpNew(pdnObject,&pAsyncOp)) != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	pAsyncOp->SetOpType( ASYNC_OP_SEND );
	pAsyncOp->MakeParent();

	pSendOpData = pAsyncOp->GetLocalSendOpData();
	pSendOpData->dwMsgId = dwMsgId;
	
	if (dwMsgId & DN_MSG_INTERNAL)
	{
#ifndef DPNBUILD_NOVOICE
		if (dwMsgId == DN_MSG_INTERNAL_VOICE_SEND)
		{
			DNASSERT(pdnBufferDesc != NULL);

			dwStart = 0;
			pAsyncOp->SetOpFlags( dwSendFlags | DN_SENDFLAGS_SET_USER_FLAG | DN_SENDFLAGS_SET_USER_FLAG_TWO | DN_SENDFLAGS_COALESCE );
		}
		else
#endif // DPNBUILD_NOVOICE
		{
			pSendOpData->BufferDesc[0].pBufferData = reinterpret_cast<BYTE*>( &(pSendOpData->dwMsgId) );
			pSendOpData->BufferDesc[0].dwBufferSize = sizeof( DWORD );

			dwStart = 1;
			pAsyncOp->SetOpFlags( dwSendFlags | DN_SENDFLAGS_SET_USER_FLAG | DN_SENDFLAGS_COALESCE );
		}
	}
	else
	{
		DNASSERT(pdnBufferDesc != NULL);

		dwStart = 0;
		pAsyncOp->SetOpFlags( dwSendFlags );
	}
	for ( dw = 0 ; dw < cBufferDesc ; dw++ )
	{
		pSendOpData->BufferDesc[dwStart+dw].pBufferData = pdnBufferDesc[dw].pBufferData;
		pSendOpData->BufferDesc[dwStart+dw].dwBufferSize = pdnBufferDesc[dw].dwBufferSize;
	}
	pSendOpData->dwNumBuffers = cBufferDesc + dwStart;

	//
	//	Completion
	//
	pAsyncOp->SetCompletion( DNCompleteSendAsyncOp );
	pSendOpData = NULL;

	*ppParent = pAsyncOp;
	pAsyncOp = NULL;

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pAsyncOp)
	{
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	if (pSendOpData)
	{
		for ( dw = 0 ; dw < pSendOpData->dwNumBuffers ; dw++ )
		{
			pSendOpData->BufferDesc[dw].dwBufferSize = 0;
			pSendOpData->BufferDesc[dw].pBufferData = NULL;
		}
		pSendOpData->dwMsgId = 0;
		pSendOpData->dwNumBuffers = 0;
		pSendOpData = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPerformChildSend"

HRESULT DNPerformChildSend(DIRECTNETOBJECT *const pdnObject,
						   CAsyncOp *const pParent,
						   CConnection *const pConnection,
						   const DWORD dwTimeOut,
						   CAsyncOp **const ppChild,
						   const BOOL fInternal)
{
	HRESULT			hResultCode;
	DWORD			dw;
	CAsyncOp		*pAsyncOp;
	DN_SEND_OP_DATA	*pSendOpData;
	HANDLE			hEndPt;
	HANDLE			hProtocol;
	CCallbackThread	CallbackThread;

	DPFX(DPFPREP, 4,"Parameters: pParent [0x%p], pConnection [0x%p], dwTimeOut [%ld]",
			pParent,pConnection,dwTimeOut);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pParent != NULL);
	DNASSERT(pConnection != NULL);

	pAsyncOp = NULL;
	CallbackThread.Initialize();

	if ((hResultCode = AsyncOpNew(pdnObject,&pAsyncOp)) != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pAsyncOp->SetOpType( ASYNC_OP_SEND );
	pAsyncOp->SetCompletion( DNCompleteSendAsyncOp );
	pAsyncOp->SetOpFlags( pParent->GetOpFlags() );
	if (fInternal)
	{
		pAsyncOp->SetInternal();
	}

	pParent->Lock();
	if (pParent->IsCancelled())
	{
		pParent->Unlock();
		pAsyncOp->SetResult( DPNERR_USERCANCEL );
		hResultCode = DPNERR_USERCANCEL;
		goto Failure;
	}
	pAsyncOp->MakeChild( pParent );
	pParent->Unlock();

	//
	//	Add to active async op list
	//
	DNEnterCriticalSection(&pdnObject->csActiveList);
	pAsyncOp->m_bilinkActiveList.InsertBefore(&pdnObject->m_bilinkActiveList);
	DNLeaveCriticalSection(&pdnObject->csActiveList);

	//
	//	Get parent's send op data block
	//
	pSendOpData = pParent->GetLocalSendOpData();

	//
	//	Save connection and get end point
	//
	if ((hResultCode = pConnection->GetEndPt(&hEndPt,&CallbackThread)) != DPN_OK)
	{
		DPFERR("Could not retrieve EndPt");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pAsyncOp->SetConnection( pConnection );

	//
	//	Update outstanding queue info (now guaranteed to be cleaned up by the completion once UseParentOpData is set)
	//
	if (pSendOpData->dwMsgId == DN_MSG_USER_SEND)
	{
		for ( dw = 0 ; dw < pSendOpData->dwNumBuffers ; dw++ )
		{
			pConnection->Lock();
			if (pAsyncOp->GetOpFlags() & DN_SENDFLAGS_HIGH_PRIORITY)
			{
				pConnection->AddToHighQueue( pSendOpData->BufferDesc[dw].dwBufferSize );
			}
			else if (pAsyncOp->GetOpFlags() & DN_SENDFLAGS_LOW_PRIORITY)
			{
				pConnection->AddToLowQueue( pSendOpData->BufferDesc[dw].dwBufferSize );
			}
			else
			{
				pConnection->AddToNormalQueue( pSendOpData->BufferDesc[dw].dwBufferSize );
			}
			pConnection->Unlock();
		}
	}
	pAsyncOp->SetUseParentOpData();

	if (hEndPt == NULL)
	{
		//
		//	INTERNAL Message
		//
		DPFX(DPFPREP, 5,"INTERNAL Message");

		//
		//	AddRef Protocol as SendComplete will release this reference
		//
		DNProtocolAddRef(pdnObject);

		pAsyncOp->AddRef();
		hResultCode = DNWTSendInternal(	pdnObject,
										pAsyncOp );

		pConnection->ReleaseEndPt(&CallbackThread);

#pragma BUGBUG(minara, "Handle out-of-memory case correctly")
		DNASSERT(hResultCode == DPNERR_PENDING);
	}
	else
	{
		//
		//	EXTERNAL Message
		//
		DPFX(DPFPREP, 5,"EXTERNAL Message");

		//
		//	AddRef Protocol so that it won't go away until this completes
		//
		DNProtocolAddRef(pdnObject);

		pAsyncOp->AddRef();
		hResultCode = DNPSendData(	pdnObject->pdnProtocolData,
									hEndPt,
									pSendOpData->dwNumBuffers,
									&pSendOpData->BufferDesc[0],
									dwTimeOut,
									pParent->GetOpFlags(),
									reinterpret_cast<void*>(pAsyncOp),
									&hProtocol);
		pConnection->ReleaseEndPt(&CallbackThread);

		if (hResultCode != DPNERR_PENDING)
		{
			if (hResultCode != DPN_OK)
			{
				DPFERR("SEND failed at Protocol layer");
				DisplayDNError(0,hResultCode);
			}
			pAsyncOp->Release();
			DNProtocolRelease(pdnObject);
			goto Failure;
		}

		pAsyncOp->Lock();
		if (pAsyncOp->IsCancelled() && !pAsyncOp->IsComplete())
		{
			HRESULT		hrCancel;

			pAsyncOp->Unlock();
			DPFX(DPFPREP, 7,"Operation marked for cancel");
			if ((hrCancel = DNPCancelCommand(pdnObject->pdnProtocolData,hProtocol)) == DPN_OK)
			{
				hResultCode = DPNERR_USERCANCEL;
				goto Failure;
			}
			DPFERR("Could not cancel operation");
			DisplayDNError(0,hrCancel);
			pAsyncOp->Lock();
		}
		pAsyncOp->SetProtocolHandle( hProtocol );
		pAsyncOp->Unlock();
	}

	//
	//	If the caller wants a reference on this operation, give it to them
	//
	if (ppChild != NULL)
	{
		pAsyncOp->AddRef();
		*ppChild = pAsyncOp;
	}

	pAsyncOp->Release();
	pAsyncOp = NULL;

Exit:

	CallbackThread.Deinitialize();
	
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pAsyncOp)
	{
		DNEnterCriticalSection(&pdnObject->csActiveList);
		pAsyncOp->m_bilinkActiveList.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csActiveList);
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	goto Exit;
}


//	DN_ProcessInternalOperation
//
//	Process an internal operation
//

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProcessInternalOperation"

HRESULT DNProcessInternalOperation(DIRECTNETOBJECT *const pdnObject,
								   const DWORD dwMsgId,
								   void *const pOpBuffer,
								   const DWORD dwOpBufferSize,
								   CConnection *const pConnection,
								   const HANDLE hProtocol,
								   CRefCountBuffer *const pRefCountBuffer)
{
	HRESULT				hResultCode;
	CRefCountBuffer		*pRCBuffer;
	CWorkerJob			*pWorkerJob;
	BOOL				fDecRunningOpCount;

	DPFX(DPFPREP, 6,"Parameters: dwMsgId [0x%lx], pOpBuffer [0x%p], dwOpBufferSize [%ld], pConnection [0x%p], hProtocol [0x%p], pRefCountBuffer [0x%p]",
			dwMsgId,pOpBuffer,dwOpBufferSize,pConnection,hProtocol,pRefCountBuffer);

	hResultCode = DPN_OK;
	pRCBuffer = NULL;
	pWorkerJob = NULL;
	fDecRunningOpCount = FALSE;

	//
	//	We will track the number of running operations (i.e. threads running through this function).
	//	At the start of host migration, we will need to send the new host the latest name table version,
	//	so we will need to let running operations finish, before sending in the name table version.
	//	If another thread is waiting, we will not perform any operations (other than host migration)
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if ((pdnObject->dwFlags & DN_OBJECT_FLAG_HOST_MIGRATING_WAIT) && (dwMsgId != DN_MSG_INTERNAL_HOST_MIGRATE))
	{
		DPFX(DPFPREP,7,"Already waiting for running operations - ignoring this operation");
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		hResultCode = DPN_OK;
		goto Failure;
	}
	if (dwMsgId != DN_MSG_INTERNAL_HOST_MIGRATE)
	{
		pdnObject->dwRunningOpCount++;
		fDecRunningOpCount = TRUE;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	switch(dwMsgId)
	{
		case DN_MSG_INTERNAL_PLAYER_CONNECT_INFO:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_PLAYER_CONNECT_INFO");

				if (DNVerifyPlayerConnectInfo(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				//
				//	Perform validations and send name table to player
				//
				hResultCode = DNHostConnect1(pdnObject,pOpBuffer,dwOpBufferSize,pConnection);

				hResultCode = DPN_OK;	// Ignore return code

				break;
			}

		case DN_MSG_INTERNAL_SEND_CONNECT_INFO:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_SEND_CONNECT_INFO");

				if (DNVerifyConnectInfo(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				//
				//	We will pass this stage off to the worker thread since there is a threading
				//	issue, and we cannot keep the SP's thread which was passed up to here.
				//

				if ((hResultCode = RefCountBufferNew(pdnObject,dwOpBufferSize,MemoryBlockAlloc,MemoryBlockFree,&pRCBuffer)) != DPN_OK)
				{
					DPFERR("Could not allocate RefCountBuffer");
					DisplayDNError(0,hResultCode);
					DNASSERT(FALSE);
					hResultCode = DPN_OK;
					goto Failure;
				}
				memcpy(pRCBuffer->GetBufferAddress(),pOpBuffer,dwOpBufferSize);

				if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
				{
					DPFERR("Could not create WorkerJob");
					DisplayDNError(0,hResultCode);
					DNASSERT(FALSE);
					hResultCode = DPN_OK;
					goto Failure;
				}
				pWorkerJob->SetJobType( WORKER_JOB_INSTALL_NAMETABLE );
				pWorkerJob->SetConnection( pConnection );
				pWorkerJob->SetRefCountBuffer( pRCBuffer );

				DNQueueWorkerJob(pdnObject,pWorkerJob);
				pWorkerJob = NULL;

				pRCBuffer->Release();
				pRCBuffer = NULL;

				break;
			}

		case DN_MSG_INTERNAL_ACK_CONNECT_INFO:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_ACK_CONNECT_INFO");

				//
				//	No verification as there is no payload with this message
				//

				//
				//	Process connect info acknowledge by host
				//
				hResultCode = DNHostConnect2(pdnObject,pConnection);	// Ignore errors

				break;
			}

		case DN_MSG_INTERNAL_SEND_PLAYER_DNID:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_SEND_PLAYER_DNID");

				if (DNVerifySendPlayerDPNID(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				//
				// Send this player's DNID to the connecting player to enable name table entry
				//
				hResultCode = DNPlayerConnect1(pdnObject,pOpBuffer,pConnection);	// Ignore errors

				break;
			}

		case DN_MSG_INTERNAL_CONNECT_FAILED:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_CONNECT_FAILED");

				if (DNVerifyConnectFailed(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				//
				//	Save reply buffer and clean up
				//
				DNConnectToHostFailed(pdnObject,pOpBuffer,dwOpBufferSize,pConnection);

				hResultCode = DPN_OK;

				break;
			}

		case DN_MSG_INTERNAL_INSTRUCT_CONNECT:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_INSTRUCT_CONNECT");

				if (DNVerifyInstructConnect(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNNTAddOperation(	pdnObject,
												DN_MSG_INTERNAL_INSTRUCT_CONNECT,
												pOpBuffer,
												dwOpBufferSize,
												hProtocol,
												pConnection->GetSP());

				break;
			}

		case DN_MSG_INTERNAL_INSTRUCTED_CONNECT_FAILED:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_INSTRUCTED_CONNECT_FAILED");

				if (DNVerifyInstructedConnectFailed(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNHostDropPlayer(	pdnObject,
												pConnection->GetDPNID(),
												pOpBuffer);	// Ignore errors

				break;
			}

		case DN_MSG_INTERNAL_CONNECT_ATTEMPT_FAILED:
			{
				UNALIGNED DN_INTERNAL_MESSAGE_CONNECT_ATTEMPT_FAILED	*pInfo;

				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_CONNECT_ATTEMPT_FAILED");

				if (DNVerifyConnectAttemptFailed(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				pInfo = static_cast<DN_INTERNAL_MESSAGE_CONNECT_ATTEMPT_FAILED*>(pOpBuffer);
				DPFX(DPFPREP, 7,"Player [0x%lx] could not connect to us",pInfo->dpnid);

				hResultCode = DNAbortConnect(pdnObject,DPNERR_PLAYERNOTREACHABLE);		// Ignore errors
				break;
			}

		case DN_MSG_INTERNAL_NAMETABLE_VERSION:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_NAMETABLE_VERSION");
#ifndef	DPNBUILD_NOHOSTMIGRATE
				if (DNVerifyNameTableVersion(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNNTHostReceiveVersion(pdnObject,pConnection->GetDPNID(),pOpBuffer);
#else
				DNASSERT(!"Should never get here!");
#endif // DPNBUILD_NOHOSTMIGRATE
				break;
			}

		case DN_MSG_INTERNAL_RESYNC_VERSION:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_RESYNC_VERSION");
#ifndef	DPNBUILD_NOHOSTMIGRATE
				if (DNVerifyResyncVersion(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNNTPlayerResyncVersion(pdnObject,pOpBuffer);
#else
				DNASSERT(!"Should never get here!");
#endif // DPNBUILD_NOHOSTMIGRATE
				break;
			}

		case DN_MSG_INTERNAL_REQ_NAMETABLE_OP:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_REQ_NAMETABLE_OP");
#ifndef	DPNBUILD_NOHOSTMIGRATE
				if (DNVerifyReqNameTableOp(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNProcessHostMigration2(pdnObject,pOpBuffer);
#else
				DNASSERT(!"Should never get here!");
#endif // DPNBUILD_NOHOSTMIGRATE
				break;
			}

		case DN_MSG_INTERNAL_ACK_NAMETABLE_OP:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_ACK_NAMETABLE_OP");
#ifndef	DPNBUILD_NOHOSTMIGRATE
				if (DNVerifyAckNameTableOp(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNPerformHostMigration3(pdnObject,pOpBuffer);
#else
				DNASSERT(!"Should never get here!");
#endif // DPNBUILD_NOHOSTMIGRATE
				break;
			}

		case DN_MSG_INTERNAL_HOST_MIGRATE:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_HOST_MIGRATE");
#ifndef	DPNBUILD_NOHOSTMIGRATE
				if (DNVerifyHostMigrate(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNProcessHostMigration1(pdnObject,pOpBuffer);
#else
				DNASSERT(!"Should never get here!");
#endif // DPNBUILD_NOHOSTMIGRATE
				break;
			}

		case DN_MSG_INTERNAL_HOST_MIGRATE_COMPLETE:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_HOST_MIGRATE_COMPLETE");
#ifndef	DPNBUILD_NOHOSTMIGRATE
				//
				//	No verification as there is no payload with this message
				//
				hResultCode = DNProcessHostMigration3(pdnObject,pConnection->GetDPNID());
#else
				DNASSERT(!"Should never get here!");
#endif // DPNBUILD_NOHOSTMIGRATE
				break;
			}

		case DN_MSG_INTERNAL_UPDATE_APPLICATION_DESC:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_UPDATE_APPLICATION_DESC");

				if (DNVerifyApplicationDescInfo(pOpBuffer,dwOpBufferSize,pOpBuffer) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNProcessUpdateAppDesc(pdnObject,static_cast<DPN_APPLICATION_DESC_INFO*>(pOpBuffer));

				break;
			}

		case DN_MSG_INTERNAL_ADD_PLAYER:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_ADD_PLAYER");

				if (DNVerifyNameTableEntryInfo(pOpBuffer,dwOpBufferSize,pOpBuffer) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNNTAddOperation(	pdnObject,
												DN_MSG_INTERNAL_ADD_PLAYER,
												pOpBuffer,
												dwOpBufferSize,
												hProtocol,
												pConnection->GetSP());

				break;
			}

		case DN_MSG_INTERNAL_DESTROY_PLAYER:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_DESTROY_PLAYER");

				if (DNVerifyDestroyPlayer(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNNTAddOperation(	pdnObject,
												DN_MSG_INTERNAL_DESTROY_PLAYER,
												pOpBuffer,
												dwOpBufferSize,
												hProtocol,
												pConnection->GetSP());

				break;
			}

		case DN_MSG_INTERNAL_CREATE_GROUP:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_CREATE_GROUP");

				if (DNVerifyCreateGroup(pOpBuffer,dwOpBufferSize,pOpBuffer) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNNTAddOperation(	pdnObject,
												DN_MSG_INTERNAL_CREATE_GROUP,
												pOpBuffer,
												dwOpBufferSize,
												hProtocol,
												pConnection->GetSP());

				break;
			}

		case DN_MSG_INTERNAL_DESTROY_GROUP:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_DESTROY_GROUP");

				if (DNVerifyDestroyGroup(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNNTAddOperation(	pdnObject,
												DN_MSG_INTERNAL_DESTROY_GROUP,
												pOpBuffer,
												dwOpBufferSize,
												hProtocol,
												pConnection->GetSP());

				break;
			}

		case DN_MSG_INTERNAL_ADD_PLAYER_TO_GROUP:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_ADD_PLAYER_TO_GROUP");

				if (DNVerifyAddPlayerToGroup(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNNTAddOperation(	pdnObject,
												DN_MSG_INTERNAL_ADD_PLAYER_TO_GROUP,
												pOpBuffer,
												dwOpBufferSize,
												hProtocol,
												pConnection->GetSP());

				break;
			}

		case DN_MSG_INTERNAL_DELETE_PLAYER_FROM_GROUP:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_DELETE_PLAYER_FROM_GROUP");

				if (DNVerifyDeletePlayerFromGroup(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNNTAddOperation(	pdnObject,
												DN_MSG_INTERNAL_DELETE_PLAYER_FROM_GROUP,
												pOpBuffer,
												dwOpBufferSize,
												hProtocol,
												pConnection->GetSP());

				break;
			}

		case DN_MSG_INTERNAL_UPDATE_INFO:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_UPDATE_INFO");

				if (DNVerifyUpdateInfo(pOpBuffer,dwOpBufferSize,pOpBuffer) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNNTAddOperation(	pdnObject,
												DN_MSG_INTERNAL_UPDATE_INFO,
												pOpBuffer,
												dwOpBufferSize,
												hProtocol,
												pConnection->GetSP());

				break;
			}

		case DN_MSG_INTERNAL_REQ_CREATE_GROUP:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_REQ_CREATE_GROUP");

				if (DNVerifyReqCreateGroup(pOpBuffer,dwOpBufferSize,pOpBuffer) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNHostProcessRequest(pdnObject,DN_MSG_INTERNAL_REQ_CREATE_GROUP,
						pOpBuffer,pConnection->GetDPNID());

				break;
			}

		case DN_MSG_INTERNAL_REQ_DESTROY_GROUP:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_REQ_DESTROY_GROUP");

				if (DNVerifyReqDestroyGroup(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNHostProcessRequest(pdnObject,DN_MSG_INTERNAL_REQ_DESTROY_GROUP,
						pOpBuffer,pConnection->GetDPNID());

				break;
			}

		case DN_MSG_INTERNAL_REQ_ADD_PLAYER_TO_GROUP:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_REQ_ADD_PLAYER_TO_GROUP");

				if (DNVerifyReqAddPlayerToGroup(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNHostProcessRequest(pdnObject,
						DN_MSG_INTERNAL_REQ_ADD_PLAYER_TO_GROUP,pOpBuffer,pConnection->GetDPNID());

				break;
			}

		case DN_MSG_INTERNAL_REQ_DELETE_PLAYER_FROM_GROUP:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_REQ_DELETE_PLAYER_FROM_GROUP");

				if (DNVerifyReqDeletePlayerFromGroup(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNHostProcessRequest(pdnObject,
						DN_MSG_INTERNAL_REQ_DELETE_PLAYER_FROM_GROUP,pOpBuffer,pConnection->GetDPNID());

				break;
			}

		case DN_MSG_INTERNAL_REQ_UPDATE_INFO:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_REQ_UPDATE_INFO");

				if (DNVerifyReqUpdateInfo(pOpBuffer,dwOpBufferSize,pOpBuffer) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNHostProcessRequest(pdnObject,DN_MSG_INTERNAL_REQ_UPDATE_INFO,
						pOpBuffer,pConnection->GetDPNID());

				break;
			}

#ifndef DPNBUILD_NOVOICE
		case DN_MSG_INTERNAL_VOICE_SEND:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_VOICE_SEND");

				hResultCode = Voice_Receive( pdnObject, pConnection->GetDPNID(), 0, pOpBuffer, dwOpBufferSize );	

				break;
			}
#endif // DPNBUILD_NOVOICE

		case DN_MSG_INTERNAL_BUFFER_IN_USE:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_BUFFER_IN_USE - INVALID !");
				DNASSERT(FALSE);
				break;
			}

		case DN_MSG_INTERNAL_REQUEST_FAILED:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_REQUEST_FAILED - INVALID !");
				
				if (DNVerifyRequestFailed(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNProcessFailedRequest(pdnObject,pOpBuffer);

				break;
			}

		case DN_MSG_INTERNAL_TERMINATE_SESSION:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_TERMINATE_SESSION");

				if (DNVerifyTerminateSession(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNProcessTerminateSession(pdnObject,pOpBuffer,dwOpBufferSize);

				break;
			}

		case DN_MSG_INTERNAL_REQ_PROCESS_COMPLETION:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_REQ_PROCESS_COMPLETION");

				if (DNVerifyReqProcessCompletion(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				//
				//	Ensure requesting player in NameTable
				//
				hResultCode = DNReceiveCompleteOnProcess(pdnObject,pConnection,pOpBuffer,
						dwOpBufferSize,hProtocol,pRefCountBuffer);

				if (hResultCode != DPNERR_PENDING)
				{
					hResultCode = DPN_OK;	// Ignore errors
				}
				break;
			}

		case DN_MSG_INTERNAL_PROCESS_COMPLETION:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_PROCESS_COMPLETION");

				if (DNVerifyProcessCompletion(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNReceiveCompleteOnProcessReply(pdnObject,pOpBuffer,dwOpBufferSize);

				break;
			}

		case DN_MSG_INTERNAL_REQ_INTEGRITY_CHECK:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_REQ_INTEGRITY_CHECK");

				if (DNVerifyReqIntegrityCheck(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNHostProcessRequest(pdnObject,DN_MSG_INTERNAL_REQ_INTEGRITY_CHECK,
						pOpBuffer,pConnection->GetDPNID());

				hResultCode = DPN_OK;

				break;
			}

		case DN_MSG_INTERNAL_INTEGRITY_CHECK:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_INTEGRITY_CHECK");

				if (DNVerifyIntegrityCheck(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNProcessCheckIntegrity(pdnObject,pOpBuffer);

				hResultCode = DPN_OK;	// Ignore errors

				break;
			}

		case DN_MSG_INTERNAL_INTEGRITY_CHECK_RESPONSE:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_INTEGRITY_CHECK_RESPONSE");

				if (DNVerifyIntegrityCheckResponse(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNHostFixIntegrity(pdnObject,pOpBuffer);

				hResultCode = DPN_OK;	// Ignore errors

				break;
			}

		default:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL (UNKNOWN!)");
				DNASSERT(FALSE);
				hResultCode = DPNERR_UNSUPPORTED;
				break;
			}
	}

Exit:
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (fDecRunningOpCount)
	{
		pdnObject->dwRunningOpCount--;
	}
	if ((pdnObject->dwRunningOpCount == 0) && (pdnObject->dwFlags & DN_OBJECT_FLAG_HOST_MIGRATING_WAIT))
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		DNSetEvent(pdnObject->hRunningOpEvent);
	}
	else
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	}

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRCBuffer)
	{
		pRCBuffer->Release();
		pRCBuffer = NULL;
	}
	if (pWorkerJob)
	{
		pWorkerJob->ReturnSelfToPool();
		pWorkerJob = NULL;
	}
	goto Exit;
}



#undef DPF_MODNAME
#define DPF_MODNAME "DNPerformRequest"

HRESULT DNPerformRequest(DIRECTNETOBJECT *const pdnObject,
						 const DWORD dwMsgId,
						 const DPN_BUFFER_DESC *const pBufferDesc,
						 CConnection *const pConnection,
						 CAsyncOp *const pParent,
						 CAsyncOp **const ppRequest)
{
	DWORD			dwFlags;
	HRESULT			hResultCode;
	BOOL			fInternal;
	BOOL			fReleaseLock;
	CAsyncOp		*pRequest;
	CAsyncOp		*pSend;
	CRefCountBuffer	*pRefCountBuffer;
	DN_SEND_OP_DATA	*pSendOpData;
	DPNHANDLE		handle;
	DN_INTERNAL_MESSAGE_REQ_PROCESS_COMPLETION	*pMsg;

	DPFX(DPFPREP, 6,"Parameters: dwMsgId [0x%lx], pBufferDesc [0x%p], pConnection [0x%p], pParent [0x%p], ppRequest [0x%p]",
			dwMsgId,pBufferDesc,pConnection,pParent,ppRequest);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pBufferDesc != NULL);

	pRequest = NULL;
	pSend = NULL;
	pSendOpData = NULL;
	pRefCountBuffer = NULL;
	fReleaseLock = FALSE;

	//
	//	Create RefCountBuffer for this operation
	//
	hResultCode = RefCountBufferNew(pdnObject,
									pBufferDesc->dwBufferSize + sizeof(DN_INTERNAL_MESSAGE_REQ_PROCESS_COMPLETION),
									MemoryBlockAlloc,
									MemoryBlockFree,
									&pRefCountBuffer);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not create RefCountBuffer");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_REQ_PROCESS_COMPLETION*>(pRefCountBuffer->GetBufferAddress());
	memcpy(pMsg + 1,pBufferDesc->pBufferData,pBufferDesc->dwBufferSize);

	//
	//	Keep DirectNetObject from vanishing under us !
	//
	if ((hResultCode = DNAddRefLock(pdnObject)) != DPN_OK)
	{
		DPFERR("Aborting request - object is closing");
		hResultCode = DPN_OK;
		goto Failure;
	}
	fReleaseLock = TRUE;

	//
	//	Create REQUEST
	//
	if ((hResultCode = AsyncOpNew(pdnObject,&pRequest)) != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pRequest->SetOpType( ASYNC_OP_REQUEST );
	if (pParent)
	{
		pParent->Lock();
		if (pParent->IsCancelled())
		{
			pParent->Unlock();
			pRequest->SetResult( DPNERR_USERCANCEL );
			hResultCode = DPNERR_USERCANCEL;
			goto Failure;
		}
		pRequest->MakeChild( pParent );
		pParent->Unlock();
	}
	pRequest->MakeParent();
	pRequest->SetRefCountBuffer( pRefCountBuffer );

	//
	//	Need a handle for this op (to be sent to the other side who will pass it back)
	//
	if ((hResultCode = pdnObject->HandleTable.Create(pRequest,&handle)) != DPN_OK)
	{
		DPFERR("Could not create handle for this operation");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	else
	{
		// Add a reference for the HandleTable
		pRequest->AddRef();
		pRequest->Lock();
		pRequest->SetHandle(handle);
		pRequest->Unlock();
	}
	DNASSERT(pRequest->GetHandle() != 0);

	//
	//	Set up SEND op data
	//
	pSendOpData = pRequest->GetLocalSendOpData();
	pSendOpData->dwMsgId = dwMsgId;
	pSendOpData->BufferDesc[0].pBufferData = reinterpret_cast<BYTE*>(&pSendOpData->dwMsgId);
	pSendOpData->BufferDesc[0].dwBufferSize = sizeof(DWORD);
	pSendOpData->BufferDesc[1].pBufferData = pRefCountBuffer->GetBufferAddress();
	pSendOpData->BufferDesc[1].dwBufferSize = pRefCountBuffer->GetBufferSize();
	pSendOpData->dwNumBuffers = 2;

#pragma TODO(vanceo, "This does not preserve non-sequential & coalesce flags when this is a COMPLETEONPROCESS send request")
	pRequest->SetOpFlags( DN_SENDFLAGS_RELIABLE | DN_SENDFLAGS_SET_USER_FLAG );
	pRequest->SetResult( DPNERR_PLAYERLOST );
	pRequest->SetCompletion( DNCompleteRequest );
	pSendOpData = NULL;

	pMsg->hCompletionOp = pRequest->GetHandle();

	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	//
	//	User messages sent with COMPLETE_ON_SEND should be allowed to be cancelled
	//
	if (dwMsgId == DN_MSG_INTERNAL_REQ_PROCESS_COMPLETION)
	{
		fInternal = FALSE;
	}
	else
	{
		fInternal = TRUE;
	}

	//
	//	We will always hand back the request, even if the send fails
	//
	if (ppRequest)
	{
		pRequest->AddRef();
		*ppRequest = pRequest;
	}

	//
	//	Unlock DirectNetObject
	//
	DNDecRefLock(pdnObject);
	fReleaseLock = FALSE;

	//
	//	Add request to the request list
	//
	DNEnterCriticalSection(&pdnObject->csActiveList);
	pRequest->m_bilinkActiveList.InsertBefore(&pdnObject->m_bilinkRequestList);
	DNLeaveCriticalSection(&pdnObject->csActiveList);

	//
	//	Avoid operations while host migration is taking place.  This will get picked up
	//	after host migration, when completing outstanding operations
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	dwFlags = pdnObject->dwFlags;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	if (!(dwFlags & DN_OBJECT_FLAG_HOST_MIGRATING) || !fInternal)
	{

		//
		//	SEND REQUEST
		//
		if (pConnection)
		{
			hResultCode = DNPerformChildSend(	pdnObject,
												pRequest,
												pConnection,
												0,
												&pSend,
												fInternal );
			if (hResultCode != DPNERR_PENDING)
			{
				DPFERR("Could not perform child SEND");
				DisplayDNError(0,hResultCode);
				DNASSERT(hResultCode != DPN_OK);	// it was sent guaranteed, it should not return immediately
				goto Failure;
			}

			//
			//	Reset SEND AsyncOp to complete apropriately.
			//
			pSend->SetCompletion( DNCompleteSendRequest );

			pSend->Release();
			pSend = NULL;
		}
	}

	pRequest->Release();
	pRequest = NULL;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (fReleaseLock)
	{
		DNDecRefLock(pdnObject);
		fReleaseLock = FALSE;
	}
	if (pRequest)
	{
		pRequest->Release();
		pRequest = NULL;
	}
	if (pSend)
	{
		pSend->Release();
		pSend = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pSendOpData)
	{
		DWORD	dw;

		for ( dw = 0 ; dw < pSendOpData->dwNumBuffers ; dw++ )
		{
			pSendOpData->BufferDesc[dw].dwBufferSize = 0;
			pSendOpData->BufferDesc[dw].pBufferData = NULL;
		}
		pSendOpData->dwMsgId = 0;
		pSendOpData->dwNumBuffers = 0;
		pSendOpData = NULL;
	}
	goto Exit;
}


//	DNReceiveCompleteOnProcess
//
//	Receive a CompleteOnProcess message
//	Pass the message up to the application and then return a special completion message

#undef DPF_MODNAME
#define DPF_MODNAME "DNReceiveCompleteOnProcess"

HRESULT DNReceiveCompleteOnProcess(DIRECTNETOBJECT *const pdnObject,
								   CConnection *const pConnection,
								   void *const pBufferData,
								   const DWORD dwBufferSize,
								   const HANDLE hProtocol,
								   CRefCountBuffer *const pRefCountBuffer)
{
	HRESULT			hResultCode;
	PVOID			pvData;
	DWORD			dwDataSize;
	UNALIGNED DN_INTERNAL_MESSAGE_REQ_PROCESS_COMPLETION	*pReq;

	DPFX(DPFPREP, 4,"Parameters: pConnection [0x%p], pBufferData [0x%p], dwBufferSize [%ld], hProtocol [0x%p], pRefCountBuffer [0x%p]",
			pConnection,pBufferData,dwBufferSize,hProtocol,pRefCountBuffer);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pConnection != NULL);

	//
	//	Extract message
	//
	pReq = static_cast<DN_INTERNAL_MESSAGE_REQ_PROCESS_COMPLETION*>(pBufferData);
	pvData = static_cast<void*>(pReq + 1);
	dwDataSize = dwBufferSize - sizeof(DN_INTERNAL_MESSAGE_REQ_PROCESS_COMPLETION);

	//
	//	Pass data to application
	//
	hResultCode = DNReceiveUserData(pdnObject,
									pConnection,
									static_cast<BYTE*>(pvData),
									dwDataSize,
									hProtocol,
									pRefCountBuffer,
									pReq->hCompletionOp,
									0);

	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DNReceiveCompleteOnProcessReply
//
//	Receive a CompleteOnProcess COMPLETION message
//	Complete the outstanding CompleteOnProcess operation

#undef DPF_MODNAME
#define DPF_MODNAME "DNReceiveCompleteOnProcessReply"

HRESULT DNReceiveCompleteOnProcessReply(DIRECTNETOBJECT *const pdnObject,
										void *const pBufferData,
										const DWORD dwBufferSize)
{
	HRESULT			hResultCode;
	CAsyncOp		*pAsyncOp;
	UNALIGNED DN_INTERNAL_MESSAGE_PROCESS_COMPLETION	*pMsg;

	DPFX(DPFPREP, 4,"Parameters: pBufferData [0x%p], dwBufferSize [%ld]",pBufferData,dwBufferSize);

	DNASSERT(pBufferData != NULL);

	pAsyncOp = NULL;

	pMsg = static_cast<DN_INTERNAL_MESSAGE_PROCESS_COMPLETION*>(pBufferData);

	//
	//	Remove async op from HandleTable and from request list
	//
	DPFX(DPFPREP, 5,"Release completion operation [0x%lx]",pMsg->hCompletionOp);
	if ((hResultCode = pdnObject->HandleTable.Destroy(pMsg->hCompletionOp,(PVOID*)&pAsyncOp)) != DPN_OK)
	{
		DPFERR("Could not find handle in HandleTable");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	DNASSERT(pAsyncOp->GetOpType() == ASYNC_OP_REQUEST);
	DNEnterCriticalSection(&pdnObject->csActiveList);
	pAsyncOp->m_bilinkActiveList.RemoveFromList();
	DNLeaveCriticalSection(&pdnObject->csActiveList);

	//
	//	Mark this operation as completing okay
	//
	pAsyncOp->SetResult( DPN_OK );

	//
	//	This release should be the final release of the Request Child Async Op. and should
	//	DecRef the Request Parent Async Op.
	//
	pAsyncOp->Release();
	pAsyncOp = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pAsyncOp)
	{
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	goto Exit;
}


//	DNProcessTerminateSession
//
//	Process a TERMINATE_SESSION message from the Host player

#undef DPF_MODNAME
#define DPF_MODNAME "DNProcessTerminateSession"

HRESULT DNProcessTerminateSession(DIRECTNETOBJECT *const pdnObject,
								  void *const pvBuffer,
								  const DWORD dwBufferSize)
{
	HRESULT		hResultCode;
	void		*pvTerminateData;
	UNALIGNED DN_INTERNAL_MESSAGE_TERMINATE_SESSION	*pMsg;

	DPFX(DPFPREP, 4,"Parameters: pvBuffer [0x%p], dwBufferSize [%ld]",pvBuffer,dwBufferSize);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pvBuffer != NULL);

	pMsg = static_cast<DN_INTERNAL_MESSAGE_TERMINATE_SESSION*>(pvBuffer);
	if (pMsg->dwTerminateDataOffset)
	{
		pvTerminateData = static_cast<void*>(static_cast<BYTE*>(pvBuffer) + pMsg->dwTerminateDataOffset);
	}
	else
	{
		pvTerminateData = NULL;
	}

	//
	//	Inform user of termination
	//
	hResultCode = DNUserTerminateSession(pdnObject,DPNERR_HOSTTERMINATEDSESSION,pvTerminateData,pMsg->dwTerminateDataSize);

	// Terminate session
	hResultCode = DNTerminateSession(pdnObject,DPNERR_HOSTTERMINATEDSESSION);

	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\asyncop.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       AsyncOp.h
 *  Content:    Async Operation Object Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  04/08/00	mjn		Created
 *	04/11/00	mjn		Added DIRECTNETOBJECT bilink for CAsyncOps
 *	04/16/00	mjn		Added ASYNC_OP_SEND and ASYNC_OP_USER_HANDLE
 *				mjn		Added SetStartTime() and GetStartTime()
 *	04/20/00	mjn		Added ASYNC_OP_RECEIVE_BUFFER
 *	04/22/00	mjn		Added ASYNC_OP_REQUEST
 *	05/02/00	mjn		Added m_pConnection to track Connection over life of AsyncOp
 *	07/08/00	mjn		Added m_bilinkParent
 *	07/17/00	mjn		Added signature to CAsyncOp
 *	07/27/00	mjn		Added m_dwReserved and changed locking for parent/child bilinks
 *	08/05/00	mjn		Added ASYNC_OP_COMPLETE,ASYNC_OP_CANCELLED,ASYNC_OP_INTERNAL flags
 *				mjn		Added m_bilinkActiveList
 *	01/09/01	mjn		Added ASYNC_OP_CANNOT_CANCEL,SetCannotCancel(),IsCannotCancel()
 *	02/08/01	mjn		Added m_pCancelEvent,m_dwCancelThreadID
 *	05/23/01	mjn		Added ClearCannotCancel()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__ASYNC_OP_H__
#define	__ASYNC_OP_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_CORE


//**********************************************************************
// Constant definitions
//**********************************************************************

#define	ASYNC_OP_CHILD				0x0001
#define	ASYNC_OP_PARENT				0x0002
#define	ASYNC_OP_USE_PARENT_OP_DATA	0x0004
#define	ASYNC_OP_CANNOT_CANCEL		0x0010
#define	ASYNC_OP_COMPLETE			0x0100
#define	ASYNC_OP_CANCELLED			0x0200
#define	ASYNC_OP_INTERNAL			0x8000

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef enum
{
	ASYNC_OP_CONNECT,
	ASYNC_OP_DISCONNECT,
	ASYNC_OP_ENUM_QUERY,
	ASYNC_OP_ENUM_RESPONSE,
	ASYNC_OP_LISTEN,
	ASYNC_OP_SEND,
	ASYNC_OP_RECEIVE_BUFFER,
	ASYNC_OP_REQUEST,
	ASYNC_OP_UNKNOWN,
	ASYNC_OP_USER_HANDLE,
#ifndef DPNBUILD_NOMULTICAST
	ASYNC_OP_LISTEN_MULTICAST,
	ASYNC_OP_CONNECT_MULTICAST_SEND,
	ASYNC_OP_CONNECT_MULTICAST_RECEIVE,
#endif // ! DPNBUILD_NOMULTICAST
} ASYNC_OP_TYPE;

class CAsyncOp;

class CConnection;
class CRefCountBuffer;
class CServiceProvider;
class CSyncEvent;

typedef struct _DIRECTNETOBJECT DIRECTNETOBJECT;

typedef void (*PFNASYNCOP_COMPLETE)(DIRECTNETOBJECT *const,CAsyncOp *const);

typedef union
{
	DN_SEND_OP_DATA			SendOpData;
#ifndef DPNBUILD_ONLYONEADAPTER
	DN_LISTEN_OP_DATA		ListenOpData;
	DN_CONNECT_OP_DATA		ConnectOpData;
#endif // ! DPNBUILD_ONLYONEADAPTER
	DN_ENUM_QUERY_OP_DATA	EnumQueryOpData;
	DN_ENUM_RESPONSE_OP_DATA	EnumResponseOpData;
} DN_OP_DATA;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for Async Operations

class CAsyncOp
{
public:
	#undef DPF_MODNAME
	#define DPF_MODNAME "CAsyncOp::FPMAlloc"
	static BOOL FPMAlloc( void* pvItem, void* pvContext )
		{
			CAsyncOp* pAsyncOp = (CAsyncOp*)pvItem;

			pAsyncOp->m_Sig[0] = 'A';
			pAsyncOp->m_Sig[1] = 'S';
			pAsyncOp->m_Sig[2] = 'Y';
			pAsyncOp->m_Sig[3] = 'N';

			pAsyncOp->m_dwReserved = 0;

			if (!DNInitializeCriticalSection(&pAsyncOp->m_cs))
			{
				return(FALSE);
			}

#ifdef DBG
			pAsyncOp->m_bilinkAsyncOps.Initialize();
#endif // DBG
			pAsyncOp->m_bilinkActiveList.Initialize();
			pAsyncOp->m_bilinkParent.Initialize();
			pAsyncOp->m_bilinkChildren.Initialize();

			memset( &pAsyncOp->m_OpData,0x00,sizeof(DN_OP_DATA) );

			return(TRUE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CAsyncOp::FPMInitialize"
	static void FPMInitialize( void* pvItem, void* pvContext )
		{
			CAsyncOp* pAsyncOp = (CAsyncOp*)pvItem;

			pAsyncOp->m_pdnObject = static_cast<DIRECTNETOBJECT*>(pvContext);

			pAsyncOp->m_dwFlags = 0;
			pAsyncOp->m_lRefCount = 1;

			pAsyncOp->m_OpType = ASYNC_OP_UNKNOWN;

			pAsyncOp->m_pParent = NULL;

			pAsyncOp->m_handle = 0;
			pAsyncOp->m_dwOpFlags = 0;
			pAsyncOp->m_pvContext = NULL;
			pAsyncOp->m_hProtocol = NULL;
			pAsyncOp->m_pvOpData = NULL;

			pAsyncOp->m_dwStartTime = 0;
			pAsyncOp->m_dpnid = 0;

			pAsyncOp->m_hr = DPNERR_GENERIC;
			pAsyncOp->m_phr = NULL;

			pAsyncOp->m_pConnection = NULL;
			pAsyncOp->m_pSP = NULL;
			pAsyncOp->m_pRefCountBuffer = NULL;
			pAsyncOp->m_pSyncEvent = NULL;

			pAsyncOp->m_pCancelEvent = NULL;
			pAsyncOp->m_dwCancelThreadID = 0;

			pAsyncOp->m_pfnCompletion = NULL;

			pAsyncOp->m_dwFirstFrameRTT = -1;
			pAsyncOp->m_dwFirstFrameRetryCount = -1;

//			pAsyncOp->m_dwReserved = 0;

#ifdef DBG
			DNASSERT(pAsyncOp->m_bilinkAsyncOps.IsEmpty());
#endif // DBG
			DNASSERT(pAsyncOp->m_bilinkActiveList.IsEmpty());
			DNASSERT(pAsyncOp->m_bilinkParent.IsEmpty());
			DNASSERT(pAsyncOp->m_bilinkChildren.IsEmpty());
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CAsyncOp::FPMRelease"
	static void FPMRelease( void* pvItem )
		{
			CAsyncOp* pAsyncOp = (CAsyncOp*)pvItem;

			pAsyncOp->m_dwFlags |= 0xffff0000;

#ifdef DBG
			DNASSERT(pAsyncOp->m_bilinkAsyncOps.IsEmpty());
#endif // DBG
			DNASSERT(pAsyncOp->m_bilinkActiveList.IsEmpty());
			DNASSERT(pAsyncOp->m_bilinkParent.IsEmpty());
			DNASSERT(pAsyncOp->m_bilinkChildren.IsEmpty());

			DNASSERT(pAsyncOp->m_pvOpData == NULL);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CAsyncOp::FPMDealloc"
	static void FPMDealloc( void* pvItem )
		{
			CAsyncOp* pAsyncOp = (CAsyncOp*)pvItem;

			DNDeleteCriticalSection(&pAsyncOp->m_cs);
		};

	void ReturnSelfToPool( void );

	#undef DPF_MODNAME
	#define DPF_MODNAME "CAsyncOp::AddRef"
	void AddRef(void)
		{
			LONG	lRefCount;

			DNASSERT(m_lRefCount > 0);
			lRefCount = DNInterlockedIncrement(const_cast<LONG*>(&m_lRefCount));
			DPFX(DPFPREP, 3,"CAsyncOp::AddRef [0x%lx] RefCount [0x%lx]",this,lRefCount);
		};

	void CAsyncOp::Release( void );

	void Lock( void )
		{
			DNEnterCriticalSection( &m_cs );
		};

	void Unlock( void )
		{
			DNLeaveCriticalSection( &m_cs );
		};

	void SetOpType( const ASYNC_OP_TYPE OpType )
		{
			m_OpType = OpType;
		};

	ASYNC_OP_TYPE GetOpType( void ) const
		{
			return( m_OpType );
		};

	void MakeParent( void )
		{
			m_dwFlags |= ASYNC_OP_PARENT;
		};

	BOOL IsParent( void ) const
		{
			if (m_dwFlags & ASYNC_OP_PARENT)
				return(TRUE);

			return(FALSE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CAsyncOp::MakeChild"
	void MakeChild( CAsyncOp *const pParent )
		{
			DNASSERT(pParent != NULL);

			pParent->AddRef();
			m_pParent = pParent;

			m_bilinkChildren.InsertBefore(&m_pParent->m_bilinkParent);

			m_dwFlags |= ASYNC_OP_CHILD;
		};

	BOOL IsChild( void ) const
		{
			if (m_dwFlags & ASYNC_OP_CHILD)
				return(TRUE);

			return(FALSE);
		};

	CAsyncOp *GetParent( void ) const
		{
			return( m_pParent );
		};

	void CAsyncOp::Orphan( void );

	void SetHandle( const DPNHANDLE handle )
		{
			m_handle = handle;
		};

	DPNHANDLE GetHandle( void ) const
		{
			return( m_handle );
		};

	void SetOpFlags( const DWORD dwOpFlags )
		{
			m_dwOpFlags = dwOpFlags;
		};

	DWORD GetOpFlags( void ) const
		{
			return( m_dwOpFlags );
		};

	void SetContext( void *const pvContext )
		{
			m_pvContext = pvContext;
		};

	void *GetContext( void ) const
		{
			return( m_pvContext );
		};

	void SetProtocolHandle( const HANDLE hProtocol )
		{
			m_hProtocol = hProtocol;
		};

	HANDLE GetProtocolHandle( void ) const
		{
			return( m_hProtocol );
		};

	void SetOpData( void *const pvOpData )
		{
			m_pvOpData = pvOpData;
		};

	void *GetOpData( void ) const
		{
			return( m_pvOpData );
		};

	void SetStartTime( const DWORD dwStartTime )
		{
			m_dwStartTime = dwStartTime;
		};

	DWORD GetStartTime( void ) const
		{
			return( m_dwStartTime );
		};

	void SetDPNID( const DPNID dpnid )
		{
			m_dpnid = dpnid;
		};

	DPNID GetDPNID( void ) const
		{
			return( m_dpnid );
		};

	void SetResult( const HRESULT hr )
		{
			m_hr = hr;
		};

	HRESULT GetResult( void ) const
		{
			return( m_hr );
		};

	void SetFirstFrameRTT( const DWORD dwFirstFrameRTT )
		{
			m_dwFirstFrameRTT = dwFirstFrameRTT;
		};

	DWORD GetFirstFrameRTT( void ) const
		{
			return ( m_dwFirstFrameRTT );
		};

	void SetFirstFrameRetryCount( const DWORD dwFirstFrameRetryCount )
		{
			m_dwFirstFrameRetryCount = dwFirstFrameRetryCount;
		};

	DWORD GetFirstFrameRetryCount( void ) const
		{
			return ( m_dwFirstFrameRetryCount );
		};

	void SetResultPointer( volatile HRESULT *const phr )
		{
			m_phr = phr;
		};

	volatile HRESULT *GetResultPointer( void ) const
		{
			return( m_phr );
		};

	void CAsyncOp::SetConnection( CConnection *const pConnection );

	CConnection *GetConnection (void ) const
		{
			return( m_pConnection );
		};

	void CAsyncOp::SetSP( CServiceProvider *const pSP );

	CServiceProvider *GetSP( void ) const
		{
			return( m_pSP );
		};

	void CAsyncOp::SetRefCountBuffer( CRefCountBuffer *const pRefCountBuffer );

	CRefCountBuffer *GetRefCountBuffer( void ) const
		{
			return( m_pRefCountBuffer );
		};

	void SetSyncEvent( CSyncEvent *const pSyncEvent )
		{
			m_pSyncEvent = pSyncEvent;
		};

	CSyncEvent *GetSyncEvent( void ) const
		{
			return( m_pSyncEvent );
		};

	void SetCancelEvent( CSyncEvent *const pSyncEvent )
		{
			m_pCancelEvent = pSyncEvent;
		};

	CSyncEvent *GetCancelEvent( void ) const
		{
			return( m_pCancelEvent );
		};

	void SetCancelThreadID( const DWORD dwCancelThreadID )
		{
			m_dwCancelThreadID = dwCancelThreadID;
		};

	DWORD GetCancelThreadID( void ) const
		{
			return( m_dwCancelThreadID );
		};

	void SetCompletion( PFNASYNCOP_COMPLETE pfn )
		{
			m_pfnCompletion = pfn;
		};

	void SetReserved( const DWORD dw )
		{
			m_dwReserved = dw;
		};

	void SetComplete( void )
		{
			m_dwFlags |= ASYNC_OP_COMPLETE;
		};

	BOOL IsComplete( void ) const
		{
			if (m_dwFlags & ASYNC_OP_COMPLETE)
			{
				return( TRUE );
			}
			return( FALSE );
		};

	void SetCancelled( void )
		{
			m_dwFlags |= ASYNC_OP_CANCELLED;
		};

	BOOL IsCancelled( void ) const
		{
			if (m_dwFlags & ASYNC_OP_CANCELLED)
			{
				return( TRUE );
			}
			return( FALSE );
		};

	void SetInternal( void )
		{
			m_dwFlags |= ASYNC_OP_INTERNAL;
		};

	BOOL IsInternal( void ) const
		{
			if (m_dwFlags & ASYNC_OP_INTERNAL)
			{
				return( TRUE );
			}
			return( FALSE );
		};

	void ClearCannotCancel( void )
		{
			m_dwFlags &= (~ASYNC_OP_CANNOT_CANCEL);
		};

	void SetCannotCancel( void )
		{
			m_dwFlags |= ASYNC_OP_CANNOT_CANCEL;
		};

	BOOL IsCannotCancel( void ) const
		{
			if (m_dwFlags & ASYNC_OP_CANNOT_CANCEL)
			{
				return( TRUE );
			}
			return( FALSE );
		};

	void ClearUseParentOpData( void )
		{
			m_dwFlags &= (~ASYNC_OP_USE_PARENT_OP_DATA);
		};

	void SetUseParentOpData( void )
		{
			m_dwFlags |= ASYNC_OP_USE_PARENT_OP_DATA;
		};

	BOOL IsUseParentOpData( void ) const
		{
			if (m_dwFlags & ASYNC_OP_USE_PARENT_OP_DATA)
			{
				return( TRUE );
			}
			return( FALSE );
		};

	DN_SEND_OP_DATA *GetLocalSendOpData( void )
	{
		return( &m_OpData.SendOpData );
	};

#ifndef DPNBUILD_ONLYONEADAPTER
	DN_CONNECT_OP_DATA *GetLocalConnectOpData( void )
	{
		return( &m_OpData.ConnectOpData );
	};

	DN_LISTEN_OP_DATA *GetLocalListenOpData( void )
	{
		return( &m_OpData.ListenOpData );
	};
#endif // ! DPNBUILD_ONLYONEADAPTER

	DN_ENUM_QUERY_OP_DATA *GetLocalEnumQueryOpData( void )
	{
		return( &m_OpData.EnumQueryOpData );
	};

	DN_ENUM_RESPONSE_OP_DATA *GetLocalEnumResponseOpData( void )
	{
		return( &m_OpData.EnumResponseOpData );
	};

#ifdef DBG
	CBilink				m_bilinkAsyncOps;
#endif // DBG
	CBilink				m_bilinkActiveList;	// Active AsyncOps
	CBilink				m_bilinkParent;		// Starting point for children
	CBilink				m_bilinkChildren;	// Other children sharing this parent

private:
	BYTE				m_Sig[4];			// Signature
	DWORD	volatile	m_dwFlags;
	LONG	volatile	m_lRefCount;

	ASYNC_OP_TYPE		m_OpType;			// Operation Type

	CAsyncOp			*m_pParent;			// Parent Async Operation

	DPNHANDLE			m_handle;			// Async Operation Handle
	DWORD				m_dwOpFlags;
	void				*m_pvContext;
	HANDLE				m_hProtocol;		// Protocol Operation Handle
	void				*m_pvOpData;			// Operation specific data

	DWORD				m_dwStartTime;
	DPNID				m_dpnid;

	HRESULT	volatile	m_hr;
	volatile HRESULT	*m_phr;

	CConnection			*m_pConnection;		// Send Target connection - released

	CServiceProvider	*m_pSP;				// Service Provider - released

	CRefCountBuffer		*m_pRefCountBuffer;	// Refernce Count Buffer - released

	CSyncEvent			*m_pSyncEvent;		// Sync Event - set at release

	CSyncEvent			*m_pCancelEvent;	// Cancel event - prevent completion from returning
	DWORD				m_dwCancelThreadID;	// Cancelling thread's ID (prevent deadlocking)

	PFNASYNCOP_COMPLETE	m_pfnCompletion;	// Completion function - called

#ifndef DPNBUILD_ONLYONETHREAD
	DNCRITICAL_SECTION	m_cs;
#endif // !DPNBUILD_ONLYONETHREAD

	DIRECTNETOBJECT		*m_pdnObject;

	DWORD				m_dwFirstFrameRTT;
	DWORD				m_dwFirstFrameRetryCount;

	DN_OP_DATA			m_OpData;

	DWORD				m_dwReserved;		// INTERNAL - RESERVED FOR DEBUG !
};

#undef DPF_MODNAME

#endif	// __ASYNC_OP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\appdesc.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       AppDesc.h
 *  Content:    Application Description Object Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  09/02/00	mjn		Created
 *	09/05/00	mjn		Added GetDPNIDMask()
 *	01/25/01	mjn		Fixed 64-bit alignment problem when unpacking AppDesc
 *	07/22/01	mjn		Added DPNBUILD_NOHOSTMIGRATE compile flag
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__APPDESC_H__
#define	__APPDESC_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_CORE

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	DN_APPDESCINFO_FLAG_SESSIONNAME		0x0001
#define DN_APPDESCINFO_FLAG_PASSWORD		0x0002
#define	DN_APPDESCINFO_FLAG_RESERVEDDATA	0x0004
#define DN_APPDESCINFO_FLAG_APPRESERVEDDATA	0x0008
#define	DN_APPDESCINFO_FLAG_CURRENTPLAYERS	0x0010
#define	DN_APPDESCINFO_FLAG_GUIDS			0x0020	// Only used in Update()

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

class CPackedBuffer;

typedef	struct DPN_APPLICATION_DESC_INFO DPN_APPLICATION_DESC_INFO;

typedef struct _DIRECTNETOBJECT DIRECTNETOBJECT;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

HRESULT	DNProcessUpdateAppDesc(DIRECTNETOBJECT *const pdnObject,
							   DPN_APPLICATION_DESC_INFO *const pv);

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for Application Description

class CApplicationDesc
{
public:

	HRESULT CApplicationDesc::Initialize( void );

	void CApplicationDesc::Deinitialize( void );

	void Lock( void )
		{
			DNEnterCriticalSection( &m_cs );
		};

	void Unlock( void )
		{
			DNLeaveCriticalSection( &m_cs );
		};

	HRESULT	CApplicationDesc::Pack(CPackedBuffer *const pPackedBuffer,
								   const DWORD dwFlags);

	HRESULT CApplicationDesc::PackInfo(CPackedBuffer *const pPackedBuffer,
									   const DWORD dwFlags);

	HRESULT CApplicationDesc::UnpackInfo(UNALIGNED DPN_APPLICATION_DESC_INFO *const pdnAppDescInfo,
										 void *const pBufferStart,
										 const DWORD dwFlags);

	HRESULT CApplicationDesc::Update(const DPN_APPLICATION_DESC *const pdnAppDesc,
									 const DWORD dwFlags);

	HRESULT	CApplicationDesc::CreateNewInstanceGuid( void );

	HRESULT	CApplicationDesc::IncPlayerCount(const BOOL fCheckLimit);

	void CApplicationDesc::DecPlayerCount( void );

#ifndef DPNBUILD_SINGLEPROCESS
	HRESULT	CApplicationDesc::RegisterWithDPNSVR( IDirectPlay8Address *const pListenAddr );

	HRESULT CApplicationDesc::UnregisterWithDPNSVR( void );
#endif // ! DPNBUILD_SINGLEPROCESS

	DWORD GetMaxPlayers( void ) const
		{
			return( m_dwMaxPlayers );
		};

	DWORD GetCurrentPlayers( void ) const
		{
			return( m_dwCurrentPlayers );
		};

	const WCHAR *GetPassword( void ) const
		{
			return( m_pwszPassword );
		};

	const GUID *GetInstanceGuid( void ) const
		{
			return( &m_guidInstance );
		};

	const GUID *GetApplicationGuid( void ) const
		{
			return( &m_guidApplication );
		};

	PVOID GetReservedData( void ) const
		{
			return( m_pvReservedData);
		};

	DWORD GetReservedDataSize( void ) const
		{
			return( m_dwReservedDataSize);
		};

	BOOL IsClientServer( void ) const
		{
			if (m_dwFlags & DPNSESSION_CLIENT_SERVER)
			{
				return( TRUE );
			}
			return( FALSE );
		};

#ifndef	DPNBUILD_NOHOSTMIGRATE
	BOOL AllowHostMigrate( void ) const
		{
			if (m_dwFlags & DPNSESSION_MIGRATE_HOST)
			{
				return( TRUE );
			}
			return( FALSE );
		};
#endif // DPNBUILD_NOHOSTMIGRATE

	BOOL UseDPNSVR( void ) const
		{
			if (m_dwFlags & DPNSESSION_NODPNSVR)
			{
				return( FALSE );
			}
			return( TRUE );
		};

	BOOL RequirePassword( void ) const
		{
			if (m_dwFlags & DPNSESSION_REQUIREPASSWORD)
			{
				return( TRUE );
			}
			return( FALSE );
		};

	BOOL DisallowEnums( void ) const
		{
#ifdef	DIRECTPLAYDIRECTX9
			if (m_dwFlags & DPNSESSION_NOENUMS)
			{
				return( TRUE );
			}
#endif	// DIRECTPLAYDIRECTX9
			return( FALSE );
		};

		//return TRUE if session is fast signed
	BOOL IsFastSigned() const
		{	return (m_dwFlags & DPNSESSION_FAST_SIGNED);	};

		//return TRUE if session is fully signed
	BOOL IsFullSigned() const
		{	return (m_dwFlags & DPNSESSION_FULL_SIGNED);	};

		//return TRUE is session is signed in any way (either fast or full)
	BOOL IsSigned() const
		{	return (m_dwFlags & (DPNSESSION_FAST_SIGNED | DPNSESSION_FULL_SIGNED));	};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CApplicationDesc::IsEqualInstanceGuid"
	BOOL IsEqualInstanceGuid( const GUID *const pguidInstance ) const
		{
			DNASSERT( pguidInstance != NULL );

			if (!memcmp(&m_guidInstance,(UNALIGNED GUID*)pguidInstance,sizeof(GUID)))
			{
				return( TRUE );
			}
			return( FALSE );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CApplicationDesc::IsEqualApplicationGuid"
	BOOL IsEqualApplicationGuid( const GUID *const pguidApplication ) const
		{
			DNASSERT( pguidApplication != NULL );

			if (!memcmp(&m_guidApplication,(UNALIGNED GUID*)pguidApplication,sizeof(GUID)))
			{
				return( TRUE );
			}
			return( FALSE );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CApplicationDesc::IsEqualPassword"
	BOOL IsEqualPassword( UNALIGNED const WCHAR *const pwszPassword ) const
		{
			UNALIGNED const WCHAR *p;
			WCHAR	*q;

			if ((pwszPassword == NULL) && (m_pwszPassword == NULL))
			{
				return(TRUE);
			}
			if ((pwszPassword == NULL) || (m_pwszPassword == NULL))
			{
				return(FALSE);
			}
			DNASSERT( pwszPassword != NULL );
			DNASSERT( m_pwszPassword != NULL);

			p = pwszPassword;
			q = m_pwszPassword;
			while (*p != L'\0' && *q != L'\0')
			{
				if (*p != *q)
				{
					return(FALSE);
				}
				p++;
				q++;
			}
			if (*p != *q)
			{
				return(FALSE);
			}
			return(TRUE);
		};

	DPNID GetDPNIDMask( void )
		{
			DPNID	*pdpnid;

			pdpnid = reinterpret_cast<DPNID*>(&m_guidInstance);
			return( *pdpnid );
		};

private:
	BYTE		m_Sig[4];

	DWORD		m_dwFlags;

	DWORD		m_dwMaxPlayers;
	DWORD		m_dwCurrentPlayers;

	WCHAR		*m_pwszSessionName;
	DWORD		m_dwSessionNameSize;	// in bytes

	WCHAR		*m_pwszPassword;
	DWORD		m_dwPasswordSize;		// in bytes

	void		*m_pvReservedData;
	DWORD		m_dwReservedDataSize;

	void		*m_pvApplicationReservedData;
	DWORD		m_dwApplicationReservedDataSize;

	GUID		m_guidInstance;
	GUID		m_guidApplication;

#ifndef DPNBUILD_ONLYONETHREAD
	DNCRITICAL_SECTION	m_cs;
#endif // !DPNBUILD_ONLYONETHREAD
};

#undef DPF_MODNAME

#endif	// __APPDESC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\callbackthread.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       CallbackThread.h
 *  Content:    Callback Thread Object Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  02/05/01	mjn		Created
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__CALLBACK_THREAD_H__
#define	__CALLBACK_THREAD_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_CORE


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

#define CONTAINING_CALLBACKTHREAD(pBilink)	(CCallbackThread*) (((BYTE*) pBilink) - (BYTE*) (((CCallbackThread*) ((DWORD_PTR) (0x00000000)))->GetCallbackThreadsBilink()))


//**********************************************************************
// Structure definitions
//**********************************************************************

class CCallbackThread;

typedef struct _DIRECTNETOBJECT DIRECTNETOBJECT;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for Callback Thread objects

class CCallbackThread
{
public:
	void Initialize( void )
		{
			m_Sig[0] = 'C';
			m_Sig[1] = 'A';
			m_Sig[2] = 'L';
			m_Sig[3] = 'L';

			GetCallbackThreadsBilink()->Initialize();
			m_dwThreadID = GetCurrentThreadId();
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CCallbackThread::Deinitialize"
	void Deinitialize( void )
		{
			DNASSERT( GetCallbackThreadsBilink()->IsEmpty() );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CCallbackThread::IsCurrentThread"
	BOOL IsCurrentThread( void )
		{
			if ( GetCurrentThreadId() == m_dwThreadID )
			{
				return( TRUE );
			}
			return( FALSE );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CCallbackThread::GetCallbackThreadsBilink"
	CBilink * GetCallbackThreadsBilink( void )
		{
			DBG_CASSERT(sizeof(m_CallbackThreadsBilink) == sizeof(CBilink));
			return( (CBilink*) (&m_CallbackThreadsBilink) );
		};

private:
	BYTE					m_Sig[4];					// Signature
	DWORD					m_dwThreadID;
	struct
	{
		CBilink		*m_pNext;
		CBilink		*m_pPrev;
	} m_CallbackThreadsBilink;
};

#undef DPF_MODNAME

#endif	// __CALLBACK_THREAD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\cancel.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Cancel.cpp
 *  Content:    DirectNet Cancel Operations
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  04/07/00	mjn		Created
 *	04/08/00	mjn		Added DNCancelEnum(), DNCancelSend()
 *	04/11/00	mjn		DNCancelEnum() uses CAsyncOp
 *	04/17/00	mjn		DNCancelSend() uses CAsyncOp
 *	04/25/00	mjn		Added DNCancelConnect()
 *	07/05/00	mjn		Added code to handle invalid async ops
 *	07/08/00	mjn		Fixed CAsyncOp to contain m_bilinkParent
 *	08/05/00	mjn		Added DNCancelChildren(),DNCancelActiveCommands(),DNCanCancelCommand()
 *				mjn		Removed DNCancelEnum(),DNCancelListen(),DNCancelSend(),DNCancelConnect()
 *	08/07/00	mjn		Added DNCancelRequestCommands()
 *	08/22/00	mjn		Remove cancelled receive buffers from the active list in DNDoCancelCommand()
 *	09/02/00	mjn		Cancel active commands in reverse order (to prevent out of order messages at protocol level)
 *	01/10/01	mjn		Allow DNCancelActiveCommands() to set result code of cancelled commands
 *	02/08/01	mjn		Use SyncEvents on AsyncOps to prevent protocol completions from returning before cancels return
 *				mjn		Added DNWaitForCancel()
 *	04/13/01	mjn		DNCancelRequestCommands() uses request bilink
 *	05/23/01	mjn		Only cancel commands that are allowed to be cancelled in DNDoCancelCommand()
 *	06/03/01	mjn		Ignore uncancelable children in DNCancelChildren()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//	DNCanCancelCommand
//
//	This will determine if an operation is cancelable based on the selection flags

#undef DPF_MODNAME
#define DPF_MODNAME "DNCanCancelCommand"

BOOL DNCanCancelCommand(CAsyncOp *const pAsyncOp,
						const DWORD dwFlags,
						CConnection *const pConnection)
{
	BOOL	fReturnVal;

	DPFX(DPFPREP, 8,"Parameters: pAsyncOp [0x%p], dwFlags [0x%lx], pConnection [0x%p]",pAsyncOp,dwFlags,pConnection);

	DNASSERT(pAsyncOp != NULL);

	fReturnVal = FALSE;
	switch(pAsyncOp->GetOpType())
	{
		case ASYNC_OP_CONNECT:
			{
				if (dwFlags & DN_CANCEL_FLAG_CONNECT)
				{
					fReturnVal = TRUE;
				}
				break;
			}
		case ASYNC_OP_DISCONNECT:
			{
				if (dwFlags & DN_CANCEL_FLAG_DISCONNECT)
				{
					fReturnVal = TRUE;
				}
				break;
			}
		case ASYNC_OP_ENUM_QUERY:
			{
				if (dwFlags & DN_CANCEL_FLAG_ENUM_QUERY)
				{
					fReturnVal = TRUE;
				}
				break;
			}
		case ASYNC_OP_ENUM_RESPONSE:
			{
				if (dwFlags & DN_CANCEL_FLAG_ENUM_RESPONSE)
				{
					fReturnVal = TRUE;
				}
				break;
			}
		case ASYNC_OP_LISTEN:
			{
				if (dwFlags & DN_CANCEL_FLAG_LISTEN)
				{
					fReturnVal = TRUE;
				}
				break;
			}
		case ASYNC_OP_SEND:
			{
				if (pAsyncOp->IsInternal())
				{
					if (dwFlags & DN_CANCEL_FLAG_INTERNAL_SEND)
					{
						fReturnVal = TRUE;
					}
				}
				else
				{
					if (dwFlags & DN_CANCEL_FLAG_USER_SEND)
					{
						if ((pConnection == NULL) || (pAsyncOp->GetConnection() == pConnection))
						{
							if (pAsyncOp->GetOpFlags() & DN_SENDFLAGS_HIGH_PRIORITY)
							{
								if (! (dwFlags & DN_CANCEL_FLAG_USER_SEND_NOTHIGHPRI))
								{
									fReturnVal = TRUE;
								}
							}
							else if (pAsyncOp->GetOpFlags() & DN_SENDFLAGS_HIGH_PRIORITY)
							{
								if (! (dwFlags & DN_CANCEL_FLAG_USER_SEND_NOTLOWPRI))
								{
									fReturnVal = TRUE;
								}
							}
							else
							{
								if (! (dwFlags & DN_CANCEL_FLAG_USER_SEND_NOTNORMALPRI))
								{
									fReturnVal = TRUE;
								}
							}
						}
					}
				}
				break;
			}
		case ASYNC_OP_RECEIVE_BUFFER:
			{
				if (dwFlags & DN_CANCEL_FLAG_RECEIVE_BUFFER)
				{
					fReturnVal = TRUE;
				}
				break;
			}
		case ASYNC_OP_REQUEST:
			{
				break;
			}
#ifndef DPNBUILD_NOMULTICAST
		case ASYNC_OP_LISTEN_MULTICAST:
		case ASYNC_OP_CONNECT_MULTICAST_SEND:
			{
				if (dwFlags & DN_CANCEL_FLAG_JOIN)
				{
					fReturnVal = TRUE;
				}
				break;
			}
		case ASYNC_OP_CONNECT_MULTICAST_RECEIVE:
			{
				break;
			}
#endif // ! DPNBUILD_NOMULTICAST
		default:
			{
				break;
			}
	}
	DPFX(DPFPREP, 8,"Returning: [%ld]",fReturnVal);
	return(fReturnVal);
}


//	DNDoCancelCommand
//
//	This will attempt to cancel a given operation based on its OpType

#undef DPF_MODNAME
#define DPF_MODNAME "DNDoCancelCommand"

HRESULT DNDoCancelCommand(DIRECTNETOBJECT *const pdnObject,
						  CAsyncOp *const pAsyncOp)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP, 8,"Parameters: pAsyncOp [0x%p]",pAsyncOp);

	hResultCode = DPNERR_CANNOTCANCEL;

	switch(pAsyncOp->GetOpType())
	{
		case ASYNC_OP_CONNECT:
		case ASYNC_OP_ENUM_QUERY:
		case ASYNC_OP_ENUM_RESPONSE:
		case ASYNC_OP_LISTEN:
		case ASYNC_OP_SEND:
#ifndef DPNBUILD_NOMULTICAST
		case ASYNC_OP_LISTEN_MULTICAST:
		case ASYNC_OP_CONNECT_MULTICAST_SEND:
		case ASYNC_OP_CONNECT_MULTICAST_RECEIVE:
#endif // ! DPNBUILD_NOMULTICAST
			{
				HANDLE	hProtocol;
				BOOL	fCanCancel;

				DNASSERT(pdnObject->pdnProtocolData != NULL );

				//
				//	If this operation has been marked as not cancellable,
				//	we will return an error
				//
				pAsyncOp->Lock();
				hProtocol = pAsyncOp->GetProtocolHandle();
				fCanCancel = !pAsyncOp->IsCannotCancel();
				pAsyncOp->Unlock();

				if (fCanCancel && (hProtocol != NULL))
				{
					DPFX(DPFPREP, 9,"Attempting to cancel AsyncOp [0x%p]",pAsyncOp);
					hResultCode = DNPCancelCommand(pdnObject->pdnProtocolData,hProtocol);
					DPFX(DPFPREP, 9,"Result of cancelling AsyncOp [0x%p] was [0x%lx]",pAsyncOp,hResultCode);
				}
				else
				{
					DPFX(DPFPREP,9,"Not allowed to cancel this operation");
					hResultCode = DPNERR_CANNOTCANCEL;
				}
				break;
			}
		case ASYNC_OP_RECEIVE_BUFFER:
			{
				hResultCode = pdnObject->HandleTable.Destroy( pAsyncOp->GetHandle(), NULL );
				if (hResultCode == DPN_OK)
				{
					//
					//	Remove from active list
					//
					DNEnterCriticalSection(&pdnObject->csActiveList);
					pAsyncOp->m_bilinkActiveList.RemoveFromList();
					DNLeaveCriticalSection(&pdnObject->csActiveList);

					// Remove HandleTable reference
					pAsyncOp->Release();
				}
				else
				{
					hResultCode = DPNERR_CANNOTCANCEL;
				}
				break;
			}
//		case ASYNC_OP_DISCONNECT:
		case ASYNC_OP_REQUEST:
		default:
			{
				DNASSERT(FALSE);
				break;
			}
	}

	DPFX(DPFPREP, 8,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DNCancelChildren
//
//	This will mark an operation as CANCELLED to prevent new children from attaching,
//	build a cancel list of any children, and recursively call itself to cancel those children.
//	At the bottom level, if there is a Protocol handle, we will actually call DNPCancelCommand() 

#undef DPF_MODNAME
#define DPF_MODNAME "DNCancelChildren"

HRESULT DNCancelChildren(DIRECTNETOBJECT *const pdnObject,
						 CAsyncOp *const pParent)
{
	HRESULT		hResultCode;
	CBilink		*pBilink;
	CAsyncOp	*pAsyncOp;
	CAsyncOp	*CancelList[16];
	CSyncEvent	*pSyncEvent;
	DWORD		dwRemainingCount;
	DWORD		dwCurrentCount;
#ifdef DBG
	DWORD		dwInitialCount;
#endif // DBG

	DPFX(DPFPREP, 6,"Parameters: pParent [0x%p]",pParent);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pParent != NULL);

	pAsyncOp = NULL;
	memset(CancelList, 0, sizeof(CancelList));
	pSyncEvent = NULL;

	//
	//	Mark the parent as cancelled so that no new children can attach
	//
	pParent->Lock();
	if (pParent->IsCancelled() || pParent->IsComplete() || pParent->IsCannotCancel())
	{
		pParent->Unlock();
		DPFX(DPFPREP, 7,"Ignoring pParent [0x%p]",pParent);
		hResultCode = DPN_OK;
		goto Exit;
	}
	pParent->SetCancelled();

	//
	//	Determine size of cancel list
	//
	dwRemainingCount = 0;
	pBilink = pParent->m_bilinkParent.GetNext();
	while (pBilink != &pParent->m_bilinkParent)
	{
		pAsyncOp = CONTAINING_OBJECT(pBilink,CAsyncOp,m_bilinkChildren);
		pAsyncOp->Lock();
		if (!pAsyncOp->IsCancelled() && !pAsyncOp->IsComplete())
		{
			dwRemainingCount++;
		}
		pAsyncOp->Unlock();
		pBilink = pBilink->GetNext();
	}
	DPFX(DPFPREP, 7,"Number of cancellable children [%ld]",dwRemainingCount);


	//
	//	Attach a sync event if this is a protocol operation
	//	This event may be cleared by the completion
	//
	if (pParent->GetProtocolHandle() != NULL)
	{
		if ((hResultCode = SyncEventNew(pdnObject,&pSyncEvent)) != DPN_OK)
		{
			DPFERR("Could not get new sync event");
			DisplayDNError(0,hResultCode);
		}
		else
		{
			pSyncEvent->Reset();
			pParent->SetCancelEvent( pSyncEvent );
			pParent->SetCancelThreadID( GetCurrentThreadId() );
			DPFX(DPFPREP,7,"Setting sync event [0x%p]",pSyncEvent);
		}
	}

	pParent->Unlock();

#ifdef DBG
	dwInitialCount = dwRemainingCount;
#endif // DBG

	//
	//	Preset the return
	//
	hResultCode = DPN_OK;


	//
	//	Fill cancel list
	//
	while (dwRemainingCount > 0)
	{
		dwRemainingCount = 0;
		dwCurrentCount = 0;

		pParent->Lock();

		pBilink = pParent->m_bilinkParent.GetNext();
		while (pBilink != &pParent->m_bilinkParent)
		{
			pAsyncOp = CONTAINING_OBJECT(pBilink,CAsyncOp,m_bilinkChildren);
			pAsyncOp->Lock();
			if (!pAsyncOp->IsCancelled() && !pAsyncOp->IsComplete())
			{
				if (dwCurrentCount < (sizeof(CancelList) / sizeof(CAsyncOp*)))
				{
					pAsyncOp->AddRef();
					CancelList[dwCurrentCount] = pAsyncOp;
					dwCurrentCount++;
#ifdef DBG
					DNASSERT(dwCurrentCount <= dwInitialCount);
#endif // DBG
				}
				else
				{
					dwRemainingCount++;

					//
					// The list should never grow.  In fact it should
					// always be smaller because the current cancel list
					// should have taken some.
					//
#ifdef DBG
					DNASSERT(dwRemainingCount < dwInitialCount);
#endif // DBG
				}
			}
			pAsyncOp->Unlock();
			pBilink = pBilink->GetNext();
		}

		//
		// Drop the lock while we attempt to cancel.
		//
		pParent->Unlock();

		DPFX(DPFPREP, 7,"Actual number of cancellable children [%ld], remaining [%ld]",dwCurrentCount,dwRemainingCount);

		//
		//	Call ourselves with each of the children (if there are any)
		//	and clean up (release AsyncOp children)
		//
		if (dwCurrentCount > 0)
		{
			DWORD	dw;
			HRESULT	hr;

			for (dw = 0 ; dw < dwCurrentCount ; dw++ )
			{
				hr = DNCancelChildren(pdnObject,CancelList[dw]);
				if ((hr != DPN_OK) && (hResultCode == DPN_OK))
				{
					hResultCode = hr;
				}
				CancelList[dw]->Release();
				CancelList[dw] = NULL;
			}
		}
		else
		{
			DNASSERT(dwRemainingCount == 0);
		}
	}


	//
	//	Cancel this operation (if we can)
	//	This will only work for CONNECTs,DISCONNECTs,ENUM_QUERYs,ENUM_RESPONSEs,LISTENs,SENDs with a protocol handle
	//
	if (pParent->GetProtocolHandle() != NULL)
	{
		HRESULT	hr;

		hr = DNDoCancelCommand(pdnObject,pParent);
		if ((hr != DPN_OK) && (hResultCode == DPN_OK))
		{
			hResultCode = hr;
		}
	}

	//
	//	Set the cancel event and clear it from the async op if it's still there
	//
	if (pSyncEvent)
	{
		pSyncEvent->Set();

		pParent->Lock();
		pSyncEvent = pParent->GetCancelEvent();
		pParent->SetCancelEvent( NULL );
		pParent->Unlock();

		if (pSyncEvent)
		{
			DPFX(DPFPREP,7,"Returning sync event [0x%p]",pSyncEvent);
			pSyncEvent->ReturnSelfToPool();
			pSyncEvent = NULL;
		}
	}

Exit:
	DNASSERT( pSyncEvent == NULL );

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DNCancelActiveCommands
//
//	This will attempt to cancel ALL operations in the active list.

#undef DPF_MODNAME
#define DPF_MODNAME "DNCancelActiveCommands"

HRESULT DNCancelActiveCommands(DIRECTNETOBJECT *const pdnObject,
							   const DWORD dwFlags,
							   CConnection *const pConnection,
							   const BOOL fSetResult,
							   const HRESULT hrCancel)
{
	HRESULT		hResultCode;
	CAsyncOp	*pAsyncOp;
	CAsyncOp	*CancelList[64];
	CBilink		*pBilink;
	DWORD		dwRemainingCount;
	DWORD		dwCurrentCount;

	DPFX(DPFPREP, 6,"Parameters: dwFlags [0x%lx], pConnection [0x%p], fSetResult [%ld], hrCancel [0x%lx]",dwFlags,pConnection,fSetResult,hrCancel);

	DNASSERT(pdnObject != NULL);
	DNASSERT((pConnection == NULL) || (dwFlags & DN_CANCEL_FLAG_USER_SEND));

	memset(CancelList, 0, sizeof(CancelList));

	//
	//	Preset the return
	//
	hResultCode = DPN_OK;

	//
	//	Create cancel list
	//
	do
	{
		dwRemainingCount = 0;
		dwCurrentCount = 0;

		//
		//	Prevent changes
		//
		DNEnterCriticalSection(&pdnObject->csActiveList);

		pBilink = pdnObject->m_bilinkActiveList.GetPrev();
		while (pBilink != &pdnObject->m_bilinkActiveList)
		{
			pAsyncOp = CONTAINING_OBJECT(pBilink,CAsyncOp,m_bilinkActiveList);
			if (DNCanCancelCommand(pAsyncOp,dwFlags,pConnection))
			{
				pAsyncOp->Lock();
				if (!pAsyncOp->IsCancelled() && !pAsyncOp->IsComplete())
				{
					if (dwCurrentCount < (sizeof(CancelList) / sizeof(CNameTableEntry*)))
					{
						pAsyncOp->AddRef();
						CancelList[dwCurrentCount] = pAsyncOp;
						dwCurrentCount++;
					}
					else
					{
						dwRemainingCount++;
					}
				}
				pAsyncOp->Unlock();
			}
			pBilink = pBilink->GetPrev();
		}

		//
		//	Allow changes, though the list should not grow any more here
		//
		DNLeaveCriticalSection(&pdnObject->csActiveList);

		DPFX(DPFPREP, 7,"Number of cancellable ops [%ld], remaining [%ld]",dwCurrentCount,dwRemainingCount);

		//
		//	Cancel each operation in the cancel list operation (if we can)
		//	This will only work for CONNECTs,DISCONNECTs,ENUM_QUERYs,ENUM_RESPONSEs,LISTENs,SENDs with a protocol handle
		//
		if (dwCurrentCount > 0)
		{
			DWORD	dw;
			HRESULT	hr;
			CSyncEvent	*pSyncEvent;

			pSyncEvent = NULL;

			for (dw = 0 ; dw < dwCurrentCount ; dw++ )
			{
				//
				//	Ensure operation has not already been cancelled
				//	If this is a protocol operation, we will add a sync event to prevent any completions from returning
				//	until we're done
				//
				DNASSERT( CancelList[dw] != NULL );
				CancelList[dw]->Lock();
				if (CancelList[dw]->IsCancelled() || CancelList[dw]->IsComplete())
				{
					CancelList[dw]->Unlock();
					CancelList[dw]->Release();
					CancelList[dw] = NULL;
					continue;
				}
				if (CancelList[dw]->GetProtocolHandle() != NULL)
				{
					if ((hr = SyncEventNew(pdnObject,&pSyncEvent)) != DPN_OK)
					{
						DPFERR("Could not get sync event");
						DisplayDNError(0,hr);
					}
					else
					{
						pSyncEvent->Reset();
						CancelList[dw]->SetCancelEvent( pSyncEvent );
						CancelList[dw]->SetCancelThreadID( GetCurrentThreadId() );
						DPFX(DPFPREP,7,"Setting sync event [0x%p]",pSyncEvent);
					}
				}
							
				CancelList[dw]->SetCancelled();
				CancelList[dw]->Unlock();

				//
				//	Perform the actual cancel
				//
				hr = DNDoCancelCommand(pdnObject,CancelList[dw]);
				if ((hr != DPN_OK) && (hResultCode == DPN_OK))
				{
					hResultCode = hr;
				}

				//
				//	If this operation was cancelled and we need to set the result, we will
				//
				if ((hr == DPN_OK) && fSetResult)
				{
					CancelList[dw]->Lock();
					CancelList[dw]->SetResult( hrCancel );
					CancelList[dw]->Unlock();
				}

				//
				//	Set the cancel event and clear it from the async op if it's still there
				//
				if (pSyncEvent)
				{
					pSyncEvent->Set();

					CancelList[dw]->Lock();
					pSyncEvent = CancelList[dw]->GetCancelEvent();
					CancelList[dw]->SetCancelEvent( NULL );
					CancelList[dw]->Unlock();

					if (pSyncEvent)
					{
						DPFX(DPFPREP,7,"Returning sync event [0x%p]",pSyncEvent);
						pSyncEvent->ReturnSelfToPool();
						pSyncEvent = NULL;
					}
				}

				CancelList[dw]->Release();
				CancelList[dw] = NULL;
			}

			DNASSERT(pSyncEvent == NULL);
		}
	}
	while (dwRemainingCount > 0);

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DNCancelRequestCommands
//
//	This will attempt to cancel REQUEST operations in the HandleTable.
//	Requests have handles which are matched up against responses.  Since these
//	typically have SEND children (which may have completed and thus vanished),
//	there is no guarantee these are not orphaned off in the HandleTable.
//	We will look through the HandleTable for them and cancel them.

#undef DPF_MODNAME
#define DPF_MODNAME "DNCancelRequestCommands"

HRESULT DNCancelRequestCommands(DIRECTNETOBJECT *const pdnObject)
{
	HRESULT		hResultCode;
	CAsyncOp	**RequestList;
	DWORD		dwCount;
	DWORD		dwActual;
	CBilink		*pBilink;

	DPFX(DPFPREP, 6,"Parameters: (none)");

	DNASSERT(pdnObject != NULL);

	RequestList = NULL;

	dwCount = 0;
	dwActual = 0;

	//
	//	Determine outstanding request list size and build it
	//
	DNEnterCriticalSection(&pdnObject->csActiveList);
	pBilink = pdnObject->m_bilinkRequestList.GetNext();
	while (pBilink != &pdnObject->m_bilinkRequestList)
	{
		dwCount++;
		pBilink = pBilink->GetNext();
	}
	if (dwCount > 0)
	{
		CAsyncOp	*pAsyncOp;

		if ((RequestList = static_cast<CAsyncOp**>(MemoryBlockAlloc(pdnObject,dwCount * sizeof(CAsyncOp*)))) == NULL)
		{
			DNLeaveCriticalSection(&pdnObject->csActiveList);
			DPFERR("Could not allocate request list");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
		pBilink = pdnObject->m_bilinkRequestList.GetNext();
		while (pBilink != &pdnObject->m_bilinkRequestList)
		{
			pAsyncOp = CONTAINING_OBJECT(pBilink,CAsyncOp,m_bilinkActiveList);
			DNASSERT(dwActual < dwCount);
			DNASSERT(pAsyncOp->GetOpType() == ASYNC_OP_REQUEST);
			pAsyncOp->AddRef();
			RequestList[dwActual] = pAsyncOp;
			pAsyncOp = NULL;
			dwActual++;
			pBilink = pBilink->GetNext();
		}
	}
	DNLeaveCriticalSection(&pdnObject->csActiveList);

	//
	//	Remove requests from request list and handle table
	//
	for (dwActual = 0 ; dwActual < dwCount ; dwActual++)
	{
		DNEnterCriticalSection(&pdnObject->csActiveList);
		RequestList[dwActual]->m_bilinkActiveList.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csActiveList);

		RequestList[dwActual]->Lock();
		RequestList[dwActual]->SetResult( DPNERR_USERCANCEL );
		RequestList[dwActual]->Unlock();
		if (SUCCEEDED(pdnObject->HandleTable.Destroy(RequestList[dwActual]->GetHandle(), NULL)))
		{
			// Release the HandleTable reference
			RequestList[dwActual]->Release();
		}
		RequestList[dwActual]->Release();
		RequestList[dwActual] = NULL;
	}

	//
	//	Clean up
	//
	if (RequestList)
	{
		MemoryBlockFree(pdnObject,RequestList);
		RequestList = NULL;
	}
	hResultCode = DPN_OK;

Exit:
	DNASSERT(RequestList == NULL);

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (RequestList)
	{
		MemoryBlockFree(pdnObject,RequestList);
		RequestList = NULL;
	}
	goto Exit;
}


//	DNWaitForCancel
//
//	This will strip a cancel event off an async op if it exists, wait on it, and then return it to the pool

#undef DPF_MODNAME
#define DPF_MODNAME "DNWaitForCancel"

void DNWaitForCancel(CAsyncOp *const pAsyncOp)
{
	DPFX(DPFPREP, 6,"Parameters: pAsyncOp [0x%p]",pAsyncOp);

	CSyncEvent	*pSyncEvent;

	DNASSERT(pAsyncOp != NULL);

	pSyncEvent = NULL;

	//
	//	Get (and clear) sync event from async op
	//
	pAsyncOp->Lock();
	pSyncEvent = pAsyncOp->GetCancelEvent();
	if (pSyncEvent)
	{
		// Only pull the SyncEvent out if we are going to wait on it
		if (pAsyncOp->GetCancelThreadID() == GetCurrentThreadId())
		{
			// The other side of this will clean it up
			DPFX(DPFPREP,7,"Cancel called on current thread - ignoring wait and continuing");
			pSyncEvent = NULL;
		}
		else
		{
			// We are pulling it out, so we will clean it up
			pAsyncOp->SetCancelEvent( NULL );
		}
	}
	pAsyncOp->Unlock();

	//
	//	If there was a sync event,
	//		- wait on it
	//		- return it to the pool
	//
	if (pSyncEvent)
	{
		DPFX(DPFPREP,7,"Waiting on sync event [0x%p]",pSyncEvent);
		pSyncEvent->WaitForEvent();

		DPFX(DPFPREP,7,"Returning sync event [0x%p]",pSyncEvent);
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;
	}

	DNASSERT(pSyncEvent == NULL);

	DPFX(DPFPREP, 6,"Returning");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\cancel.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Connect.h
 *  Content:    DirectNet Cancel Operation Header
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	04/07/00	mjn		Created
 *	04/08/00	mjn		Added DNCancelEnum(), DNCancelSend()
 *	04/11/00	mjn		DNCancelEnum() uses CAsyncOp
 *	04/17/00	mjn		DNCancelSend() uses CAsyncOp
 *	04/25/00	mjn		Added DNCancelConnect()
 *	08/05/00	mjn		Added DNCancelChildren(),DNCancelActiveCommands(),DNCanCancelCommand()
 *				mjn		Added DN_CANCEL_FLAG's
 *				mjn		Removed DNCancelEnum(),DNCancelListen(),DNCancelSend(),DNCancelConnect()
 *	08/07/00	mjn		Added DNCancelRequestCommands()
 *	01/10/01	mjn		Allow DNCancelActiveCommands() to set result code of cancelled commands
 *	02/08/01	mjn		Added DNWaitForCancel()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__CANCEL_H__
#define	__CANCEL_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	DN_CANCEL_FLAG_CONNECT					0x0001
#define	DN_CANCEL_FLAG_DISCONNECT				0x0002
#define	DN_CANCEL_FLAG_ENUM_QUERY				0x0004
#define	DN_CANCEL_FLAG_ENUM_RESPONSE			0x0008
#define	DN_CANCEL_FLAG_LISTEN					0x0010
#define	DN_CANCEL_FLAG_USER_SEND				0x0020
#define	DN_CANCEL_FLAG_INTERNAL_SEND			0x0040
#define	DN_CANCEL_FLAG_RECEIVE_BUFFER			0x0080
#define	DN_CANCEL_FLAG_REQUEST					0x0100
#ifndef DPNBUILD_NOMULTICAST
#define	DN_CANCEL_FLAG_JOIN						0x0200
#endif // ! DPNBUILD_NOMULTICAST
#define	DN_CANCEL_FLAG_USER_SEND_NOTHIGHPRI		0x0400
#define	DN_CANCEL_FLAG_USER_SEND_NOTNORMALPRI	0x0800
#define	DN_CANCEL_FLAG_USER_SEND_NOTLOWPRI		0x1000

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

class CAsyncOp;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

BOOL DNCanCancelCommand(CAsyncOp *const pAsyncOp,
						const DWORD dwFlags,
						CConnection *const pConnection);

HRESULT DNDoCancelCommand(DIRECTNETOBJECT *const pdnObject,
						  CAsyncOp *const pAsyncOp);

HRESULT DNCancelChildren(DIRECTNETOBJECT *const pdnObject,
						 CAsyncOp *const pParent);

HRESULT DNCancelActiveCommands(DIRECTNETOBJECT *const pdnObject,
							   const DWORD dwFlags,
							   CConnection *const pConnection,
							   const BOOL fSetResult,
							   const HRESULT hr);

HRESULT DNCancelRequestCommands(DIRECTNETOBJECT *const pdnObject);

void DNWaitForCancel(CAsyncOp *const pAsyncOp);

//**********************************************************************
// Class prototypes
//**********************************************************************

#endif	// __CANCEL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\async.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       async.h
 *  Content:    Asynchronous Operations Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/28/99	mjn		Created
 *	12/29/99	mjn		Reformed DN_ASYNC_OP to use hParentOp instead of lpvUserContext
 *	01/14/00	mjn		Added pvUserContext to DN_PerformListen
 *	01/14/00	mjn		Changed DN_COUNT_BUFFER to CRefCountBuffer
 *	01/17/00	mjn		Added dwStartTime to async op structure
 *	01/19/00	mjn		Replaced DN_SYNC_EVENT with CSyncEvent
 *	01/21/00	mjn		Added DNProcessInternalOperation
 *	01/27/00	mjn		Added support for retention of receive buffers
 *	02/09/00	mjn		Implemented DNSEND_COMPLETEONPROCESS
 *	02/18/00	mjn		Converted DNADDRESS to IDirectPlayAddress8
 *	03/23/00	mjn		Added phrSync and pvInternal
 *	03/24/00	mjn		Add guidSP to DN_ASYNC_OP
 *	04/04/00	mjn		Added DNProcessTerminateSession()
 *	04/10/00	mjn		Use CAsyncOp for CONNECTs, LISTENs and DISCONNECTs
 *	04/17/00	mjn		Replaced BUFFERDESC with DPN_BUFFER_DESC
 *	04/17/00	mjn		Added DNCompleteAsyncHandle
 *	04/21/00	mjn		Added DNPerformDisconnect
 *	04/23/00	mjn		Optionally return child AsyncOp in DNPerformChildSend()
 *	04/24/00	mjn		Added DNCreateUserHandle()
 *	06/24/00	mjn		Added DNCompleteConnectToHost() and DNCompleteUserConnect()
 *	07/02/00	mjn		Added DNSendGroupMessage() and DN_GROUP_SEND_OP
 *	07/10/00	mjn		Added DNPerformEnumQuery()
 *	07/11/00	mjn		Added fNoLoopBack to DNSendGroupMessage()
 *				mjn		Added DNPerformNextEnumQuery(),DNPerformSPListen(),DNPerformNextListen(),DNEnumAdapterGuids(),DNPerformNextConnect
 *				mjn		Added DN_LISTEN_OP_DATA,DN_CONNECT_OP_DATA
 *	07/20/00	mjn		Added DNCompleteConnectOperation() and DNCompleteSendConnectInfo()
 *				mjn		Modified DNPerformDisconnect()
 *	08/05/00	mjn		Added pParent to DNSendGroupMessage and DNSendMessage()
 *				mjn		Added fInternal to DNPerformChildSend()
 *				mjn		Removed DN_TerminateAllListens()
 *				mjn		Added DNCompleteRequest()
 *	09/23/00	mjn		Added CSyncEvent to DN_LISTEN_OP_DATA
 *	10/04/00	mjn		Added dwCompleteAdapters to DN_LISTEN_OP_DATA
 *  12/05/00	RichGr  Changed DN_SEND_OP_DATA packing from 1 to default (4 on 32-bit, 8 on 64bit).
 *	03/30/00	mjn		Added service provider to DNPerformConnect()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__ASYNC_H__
#define	__ASYNC_H__

typedef struct _DIRECTNETOBJECT DIRECTNETOBJECT;


//**********************************************************************
// Constant definitions
//**********************************************************************

#define	DN_ASYNC_OP_SIG							0xdece0003

#define	DN_ASYNC_OP_FLAG_MULTI_OP				0x0001
#define DN_ASYNC_OP_FLAG_MULTI_OP_PARENT		0x0002
#define	DN_ASYNC_OP_FLAG_SYNCHRONOUS_OP			0x0010
#define	DN_ASYNC_OP_FLAG_NO_COMPLETION			0x0100
#define	DN_ASYNC_OP_FLAG_RELEASE_SP				0x1000

//
// Enumerated values for buffer descriptions.  The value DN_ASYNC_BUFFERDESC_COUNT
// must be large enough to contain account for BUFFERDESC structres possibly
// passed with this async operation
//
#define	DN_ASYNC_BUFFERDESC_HEADER				0
#define	DN_ASYNC_BUFFERDESC_DATA				1
#define	DN_ASYNC_BUFFERDESC_COUNT				3

#define	DN_ASYNC_MAX_SEND_BUFFERDESC			8	// Is this value right?

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

class CSyncEvent;
class CRefCountBuffer;
class CServiceProvider;
class CAsyncOp;
class CConnection;
class CNameTableEntry;


typedef struct _DN_SEND_OP_DATA
{
	DWORD			dwNumBuffers;
	DWORD			dwMsgId;
	DPN_BUFFER_DESC	BufferDesc[DN_ASYNC_MAX_SEND_BUFFERDESC+1];
} DN_SEND_OP_DATA;


typedef struct _DN_GROUP_SEND_OP
{
	CConnection					*pConnection;
	struct _DN_GROUP_SEND_OP	*pNext;
} DN_GROUP_SEND_OP;


#ifndef DPNBUILD_ONLYONEADAPTER
typedef struct _DN_LISTEN_OP_DATA
{
	DWORD		dwNumAdapters;
	DWORD		dwCurrentAdapter;
	DWORD		dwCompleteAdapters;
	CSyncEvent	*pSyncEvent;
} DN_LISTEN_OP_DATA;


typedef struct _DN_CONNECT_OP_DATA
{
	DWORD		dwNumAdapters;
	DWORD		dwCurrentAdapter;
} DN_CONNECT_OP_DATA;
#endif // ! DPNBUILD_ONLYONEADAPTER

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

HRESULT DNCreateUserHandle(DIRECTNETOBJECT *const pdnObject,
						   CAsyncOp **const ppAsyncOp);

#ifndef DPNBUILD_ONLYONEADAPTER

HRESULT DNEnumAdapterGuids(DIRECTNETOBJECT *const pdnObject,
						   GUID *const pguidSP,
						   const DWORD dwMatchFlags,
						   GUID **const ppAdapterList,
						   DWORD *const pdwNumAdapters);

#endif // ! DPNBUILD_ONLYONEADAPTER

HRESULT DNPerformSPListen(DIRECTNETOBJECT *const pdnObject,
						  IDirectPlay8Address *const pDeviceAddr,
						  CAsyncOp *const pListenParent,
						  CAsyncOp **const ppParent);

HRESULT DNPerformListen(DIRECTNETOBJECT *const pdnObject,
						IDirectPlay8Address *const pDeviceInfo,
						CAsyncOp *const pParent);

#ifndef DPNBUILD_ONLYONEADAPTER
HRESULT DNPerformNextListen(DIRECTNETOBJECT *const pdnObject,
							CAsyncOp *const pAsyncOp,
							IDirectPlay8Address *const pDeviceAddr);
#endif // ! DPNBUILD_ONLYONEADAPTER

void DNCompleteListen(DIRECTNETOBJECT *const pdnObject,
					  CAsyncOp *const pAsyncOp);
/*	REMOVE
HRESULT DN_TerminateAllListens(DIRECTNETOBJECT *const pdnObject);
*/

HRESULT DNPerformEnumQuery(DIRECTNETOBJECT *const pdnObject,
						   IDirectPlay8Address *const pHost,
						   IDirectPlay8Address *const pDevice,
						   const HANDLE hSPHandle,
						   const DWORD dwFlags,
						   void *const pvContext,
						   CAsyncOp *const pParent);

HRESULT DNPerformNextEnumQuery(DIRECTNETOBJECT *const pdnObject,
							   CAsyncOp *const pAsyncOp,
							   IDirectPlay8Address *const pHostAddr,
							   IDirectPlay8Address *const pDeviceAddr);

void DNCompleteEnumQuery(DIRECTNETOBJECT *const pdnObject,
						 CAsyncOp *const pAsyncOp);

void DNCompleteEnumResponse(DIRECTNETOBJECT *const pdnObject,
							CAsyncOp *const pAsyncOp);

HRESULT DNPerformConnect(DIRECTNETOBJECT *const pdnObject,
						 const DPNID dpnid,
						 IDirectPlay8Address *const pDeviceInfo,
						 IDirectPlay8Address *const pRemoteAddr,
						 CServiceProvider *const pSP,
						 const DWORD dwConnectFlags,
						 CAsyncOp *const pParent);

HRESULT DNPerformNextConnect(DIRECTNETOBJECT *const pdnObject,
							 CAsyncOp *const pAsyncOp,
							 IDirectPlay8Address *const pHostAddr,
							 IDirectPlay8Address *const pDeviceAddr);

void DNCompleteConnect(DIRECTNETOBJECT *const pdnObject,
					   CAsyncOp *const pAsyncOp);

void DNCompleteConnectToHost(DIRECTNETOBJECT *const pdnObject,
							 CAsyncOp *const pAsyncOp);

void DNCompleteConnectOperation(DIRECTNETOBJECT *const pdnObject,
								CAsyncOp *const pAsyncOp);

void DNCompleteUserConnect(DIRECTNETOBJECT *const pdnObject,
						   CAsyncOp *const pAsyncOp);

void DNCompleteSendConnectInfo(DIRECTNETOBJECT *const pdnObject,
							   CAsyncOp *const pAsyncOp);

HRESULT DNPerformDisconnect(DIRECTNETOBJECT *const pdnObject,
							CConnection *const pConnection,
							const HANDLE hEndPt,
							const BOOL fImmediate);

void DNCompleteAsyncHandle(DIRECTNETOBJECT *const pdnObject,
						   CAsyncOp *const pAsyncOp);

void DNCompleteSendHandle(DIRECTNETOBJECT *const pdnObject,
						  CAsyncOp *const pAsyncOp);

void DNCompleteSendAsyncOp(DIRECTNETOBJECT *const pdnObject,
						   CAsyncOp *const pAsyncOp);

void DNCompleteRequest(DIRECTNETOBJECT *const pdnObject,
					   CAsyncOp *const pAsyncOp);

void DNCompleteSendRequest(DIRECTNETOBJECT *const pdnObject,
						   CAsyncOp *const pAsyncOp);

HRESULT DNSendMessage(DIRECTNETOBJECT *const pdnObject,
					  CConnection *const pConnection,				//	Connection to send to
					  const DWORD dwMsgId,							//	Message ID
					  const DPNID dpnidTarget,						//	Target of this send (may be NULL)
					  const DPN_BUFFER_DESC *const pdnBufferDesc,	//	Array of buffer desc's
					  const DWORD cBufferDesc,						//	Number of buffer desc's
					  CRefCountBuffer *const pRefCountBuffer,		//	RefCountBuffer (may be NULL)
					  const DWORD dwTimeOut,						//	Time out
					  const DWORD dwSendFlags,						//	Send flags
					  CAsyncOp *const pParent,						//	Parent of this send
					  CAsyncOp **const ppAsyncOp);					//	CAsyncOp created for this send

HRESULT DNSendGroupMessage(DIRECTNETOBJECT *const pdnObject,
						   CNameTableEntry *const pGroup,
						   const DWORD dwMsgId,
						   const DPN_BUFFER_DESC *const pdnBufferDesc,
						   const DWORD cBufferDesc,
						   CRefCountBuffer *const pRefCountBuffer,
						   const DWORD dwTimeOut,
						   const DWORD dwSendFlags,
						   const BOOL fNoLoopBack,
						   const BOOL fRequest,
						   CAsyncOp *const pParent,
						   CAsyncOp **const ppParent);

HRESULT DNPerformMultiSend(DIRECTNETOBJECT *const pdnObject,
						   const DPNHANDLE hParentOp,
						   CConnection *const pConnection,
						   const DWORD dwTimeOut);

HRESULT DNCreateSendParent(DIRECTNETOBJECT *const pdnObject,
						   const DWORD dwMsgId,
						   const DPN_BUFFER_DESC *const pdnBufferDesc,
						   const DWORD cBufferDesc,
						   const DWORD dwSendFlags,
						   CAsyncOp **const ppParent);

HRESULT DNPerformChildSend(DIRECTNETOBJECT *const pdnObject,
						   CAsyncOp *const pParent,
						   CConnection *const pConnection,
						   const DWORD dwTimeOut,
						   CAsyncOp **const ppChild,
						   const BOOL fInternal);

HRESULT DNFinishMultiOp(DIRECTNETOBJECT *const pdnObject,const DPNHANDLE hRootOp);

HRESULT DNProcessInternalOperation(DIRECTNETOBJECT *const pdnObject,
								   const DWORD dwMsgId,
								   void *const pOpBuffer,
								   const DWORD dwOpBufferSize,
								   CConnection *const pConnection,
								   const HANDLE hProtocol,
								   CRefCountBuffer *const pRefCountBuffer);

HRESULT DNPerformRequest(DIRECTNETOBJECT *const pdnObject,
						 const DWORD dwMsgId,
						 const DPN_BUFFER_DESC *const pBufferDesc,
						 CConnection *const pConnection,
						 CAsyncOp *const pParent,
						 CAsyncOp **const ppRequest);

HRESULT DNReceiveCompleteOnProcess(DIRECTNETOBJECT *const pdnObject,
								   CConnection *const pConnection,
								   void *const pBufferData,
								   const DWORD dwBufferSize,
								   const HANDLE hProtocol,
								   CRefCountBuffer *const pOrigRefCountBuffer);

HRESULT DNReceiveCompleteOnProcessReply(DIRECTNETOBJECT *const pdnObject,
										void *const pBufferData,
										const DWORD dwBufferSize);

HRESULT DNProcessTerminateSession(DIRECTNETOBJECT *const pdnObject,
								  void *const pvBuffer,
								  const DWORD dwBufferSize);

//**********************************************************************
// Class prototypes
//**********************************************************************


#endif	// __ASYNC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\caps.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Caps.cpp
 *  Content:    Dplay8 caps routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/17/00	rmt		Created
 *  03/23/00	rmt		Removed unused local variables
 *  03/25/00    rmt		Updated to make calls into SP's function
 *              rmt		Updated SP calls to Initialize SP (and create if required)
 *  03/31/00    rmt		Hooked up the GetCaps/SetCaps calls to call the protocol
 *  04/17/00    rmt		Strong param validation
 *	04/19/00	mjn		Removed AddRef() for NameTableEntry in DN_GetConnectionInfoHelper()
 *	05/03/00	mjn		Use GetHostPlayerRef() rather than GetHostPlayer()
 *	06/05/00	mjn		Fixed DN_GetConnectionInfoHelper() to use GetConnectionRef
 *  06/09/00    rmt     Updates to split CLSID and allow whistler compat
 *	07/06/00	mjn		Use GetInterfaceRef for SP interface
 *				mjn		Fixed up DN_SetActualSPCaps() and DN_GetActualSPCaps()
 *	07/29/00	mjn		Fixed SetSPCaps() recursion problem
 *	07/31/00	mjn		Renamed dwDefaultEnumRetryCount to dwDefaultEnumCount in DPN_SP_CAPS
 *  08/03/2000	rmt		Bug #41244 - Wrong return codes -- part 2
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/05/00	mjn		Added dwFlags to DN_GetConnectionInfoHelper()
 *	08/20/00	mjn		DNSetActualSPCaps() uses CServiceProvider object instead of GUID
 *	01/22/01	mjn		Fixed debug text in DN_GetConnectionInfoHelper()
 *	02/12/01	mjn		Fixed CConnection::GetEndPt() to track calling thread
 *	03/30/01	mjn		Changes to prevent multiple loading/unloading of SP's
 *				mjn		Removed cached caps functionallity
 *	07/24/01	mjn		Added DPNBUILD_NOPARAMVAL compile flag
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//	DN_SetCaps
//
//	Set caps
#undef DPF_MODNAME
#define DPF_MODNAME "DN_SetCaps"

STDMETHODIMP DN_SetCaps(PVOID pv,
						const DPN_CAPS *const pdnCaps,
						const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
    HRESULT             hResultCode;

	DPFX(DPFPREP, 3,"Parameters: pdnCaps [0x%p] dwFlags [0x%lx]", pdnCaps, dwFlags );

    pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pv));
    DNASSERT(pdnObject != NULL);

#ifndef	DPNBUILD_NOPARAMVAL
    if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    {
    	if( FAILED( hResultCode = DN_ValidateSetCaps( pv, pdnCaps, dwFlags ) ) )
    	{
    	    DPFERR( "Error validating SetCaps params" );
    	    DPF_RETURN( hResultCode );
    	}
    }
#endif	// !DPNBUILD_NOPARAMVAL

	// Check to ensure message handler registered
	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
	{
    	DPFERR( "Object is not initialized" );
    	DPF_RETURN(DPNERR_UNINITIALIZED);
	}

    hResultCode = DNPSetProtocolCaps( pdnObject->pdnProtocolData, (DPN_CAPS*)pdnCaps );

	DPF_RETURN(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetCaps"

STDMETHODIMP DN_GetCaps(PVOID pv,
						DPN_CAPS *const pdnCaps,
						const DWORD dwFlags)
{
	DPFX(DPFPREP, 2,"Parameters: pdnCaps [0x%p], dwFlags [0x%lx]", pdnCaps,dwFlags);

	DIRECTNETOBJECT		*pdnObject;
	HRESULT hResultCode;

    pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pv));
    DNASSERT(pdnObject != NULL);

#ifndef	DPNBUILD_NOPARAMVAL
    if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    {
    	if( FAILED( hResultCode = DN_ValidateGetCaps( pv, pdnCaps, dwFlags ) ) )
    	{
    	    DPFERR( "Error validating GetCaps params" );
    	    DPF_RETURN( hResultCode );
    	}
    }
#endif	// DPNBUILD_NOPARAMVAL

	// Check to ensure message handler registered
    if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    {
    	DPFERR( "Object is not initialized" );
    	DPF_RETURN(DPNERR_UNINITIALIZED);
    }

    hResultCode = DNPGetProtocolCaps( pdnObject->pdnProtocolData, pdnCaps );

	DPF_RETURN(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetSPCaps"

STDMETHODIMP DN_GetSPCaps(PVOID pv,
						  const GUID * const pguidSP,
						  DPN_SP_CAPS *const pdnSPCaps,
						  const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
	HRESULT             hResultCode;
	CServiceProvider	*pSP;

	DPFX(DPFPREP, 2,"Parameters: pdnSPCaps [0x%p], dwFlags [0x%lx]", pdnSPCaps, dwFlags );

    pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pv));
    DNASSERT(pdnObject != NULL);

#ifndef	DPNBUILD_NOPARAMVAL
    if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    {
    	if( FAILED( hResultCode = DN_ValidateGetSPCaps( pv, pguidSP, pdnSPCaps, dwFlags ) ) )
    	{
    	    DPFERR( "Error validating GetSPCaps params" );
    	    DPF_RETURN( hResultCode );
    	}
    }
#endif	// !DPNBUILD_NOPARAMVAL

    // Check to ensure message handler registered
    if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    {
    	DPFERR( "Object is not initialized" );
    	DPF_RETURN(DPNERR_UNINITIALIZED);
    }

	pSP = NULL;

#if ((defined(DPNBUILD_ONLYONESP)) && (defined(DPNBUILD_LIBINTERFACE)))
	DNASSERT(pdnObject->pOnlySP != NULL);
	pdnObject->pOnlySP->AddRef();
	pSP = pdnObject->pOnlySP;
#else // ! DPNBUILD_ONLYONESP or ! DPNBUILD_LIBINTERFACE
	//
	//	Ensure SP is loaded
	//
	hResultCode = DN_SPEnsureLoaded(pdnObject,
#ifndef DPNBUILD_ONLYONESP
									pguidSP,
#endif // ! DPNBUILD_ONLYONESP
#ifndef DPNBUILD_LIBINTERFACE
									NULL,
#endif // ! DPNBUILD_LIBINTERFACE
									&pSP);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not find or load SP");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	DNASSERT( pSP != NULL );
#endif // ! DPNBUILD_ONLYONESP or ! DPNBUILD_LIBINTERFACE

	//
	//	Get actual SP caps
	//
	hResultCode = DNGetActualSPCaps(pSP,pdnSPCaps);

	pSP->Release();
	pSP = NULL;

#if ((! defined(DPNBUILD_ONLYONESP)) || (! defined(DPNBUILD_LIBINTERFACE)))
Exit:
#endif // ! DPNBUILD_ONLYONESP or ! DPNBUILD_LIBINTERFACE
	DNASSERT( pSP == NULL );

	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

#if ((! defined(DPNBUILD_ONLYONESP)) || (! defined(DPNBUILD_LIBINTERFACE)))
Failure:
	if (pSP)
	{
		pSP->Release();
		pSP = NULL;
	}
	goto Exit;
#endif // ! DPNBUILD_ONLYONESP or ! DPNBUILD_LIBINTERFACE
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_SetSPCaps"

STDMETHODIMP DN_SetSPCaps(PVOID pv,
						  const GUID * const pguidSP,
						  const DPN_SP_CAPS *const pdnSPCaps,
						  const DWORD dwFlags)
{
	DPFX(DPFPREP, 2,"Parameters: pdnSPCaps [0x%p]", pdnSPCaps );

	DIRECTNETOBJECT		*pdnObject;
	CServiceProvider	*pSP;
    HRESULT             hResultCode;
    SPSETCAPSDATA		spSetCapsData;
    IDP8ServiceProvider	*pIDP8SP;

    pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pv));
    DNASSERT(pdnObject != NULL);

#ifndef	DPNBUILD_NOPARAMVAL
    if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    {
    	if( FAILED( hResultCode = DN_ValidateSetSPCaps( pv, pguidSP, pdnSPCaps, dwFlags ) ) )
    	{
    	    DPFERR( "Error validating SetSPCaps params" );
    	    DPF_RETURN( hResultCode );
    	}
    }
#endif	// !DPNBUILD_NOPARAMVAL

    // Check to ensure message handler registered
    if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    {
    	DPFERR( "Object is not initialized" );
    	DPF_RETURN(DPNERR_UNINITIALIZED);
    }

	pSP = NULL;
	pIDP8SP = NULL;

#if ((defined(DPNBUILD_ONLYONESP)) && (defined(DPNBUILD_LIBINTERFACE)))
	DNASSERT(pdnObject->pOnlySP != NULL);
	pdnObject->pOnlySP->AddRef();
	pSP = pdnObject->pOnlySP;
#else // ! DPNBUILD_ONLYONESP or ! DPNBUILD_LIBINTERFACE
	//
	//	Ensure the SP is loaded.  If it's not currently loaded, we will load it now.
	//
	hResultCode = DN_SPEnsureLoaded(pdnObject,
#ifndef DPNBUILD_ONLYONESP
									pguidSP,
#endif // ! DPNBUILD_ONLYONESP
#ifndef DPNBUILD_LIBINTERFACE
									NULL,
#endif // ! DPNBUILD_LIBINTERFACE
									&pSP);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not find or load SP");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	DNASSERT(pSP != NULL);
#endif // ! DPNBUILD_ONLYONESP or ! DPNBUILD_LIBINTERFACE

	//
	//	Get the SP interface
	//
	if ((hResultCode = pSP->GetInterfaceRef( &pIDP8SP )) != DPN_OK)
	{
		DPFERR("Could not get SP interface reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Set the SP caps
	//
    memset( &spSetCapsData, 0x00, sizeof( SPSETCAPSDATA ) );
    spSetCapsData.dwSize = sizeof( SPSETCAPSDATA );
    spSetCapsData.dwIOThreadCount = pdnSPCaps->dwNumThreads;
    spSetCapsData.dwBuffersPerThread = pdnSPCaps->dwBuffersPerThread;
	spSetCapsData.dwSystemBufferSize = pdnSPCaps->dwSystemBufferSize;

	if ((hResultCode = IDP8ServiceProvider_SetCaps( pIDP8SP, &spSetCapsData )) != DPN_OK)
	{
		DPFERR("Could not set SP caps");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Clean up
	//
	IDP8ServiceProvider_Release( pIDP8SP );
	pIDP8SP = NULL;

	pSP->Release();
	pSP = NULL;

	hResultCode = DPN_OK;

Exit:
	DNASSERT( pIDP8SP == NULL);
	DNASSERT( pSP == NULL);

	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
    return(hResultCode);

Failure:
	if (pIDP8SP)
	{
		IDP8ServiceProvider_Release( pIDP8SP );
		pIDP8SP = NULL;
	}
	if (pSP)
	{
		pSP->Release();
		pSP = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetConnectionInfoHelper"

STDMETHODIMP DN_GetConnectionInfoHelper(PVOID pv,
										const DPNID dpnid,
										DPN_CONNECTION_INFO *const pdpConnectionInfo,
										BOOL fServerPlayer,
										const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
    HRESULT             hResultCode;
    CNameTableEntry     *pPlayerEntry;
    CConnection         *pConnection;
    HANDLE              hEndPoint;
	CCallbackThread		CallbackThread;

	pPlayerEntry = NULL;
	pConnection = NULL;
	CallbackThread.Initialize();

    pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pv));
    DNASSERT(pdnObject != NULL);

#ifndef	DPNBUILD_NOPARAMVAL
    if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    {
    	if( FAILED( hResultCode = DN_ValidateGetConnectionInfoHelper( pv, dpnid, pdpConnectionInfo, fServerPlayer,dwFlags ) ) )
    	{
    	    DPFERR( "Error validating GetConnectionInfoHelper params" );
    	    DPF_RETURN( hResultCode );
    	}
    }
#endif	// !DPNBUILD_NOPARAMVAL

    // Check to ensure message handler registered
    if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    {
    	DPFERR( "Object is not initialized" );
    	DPF_RETURN(DPNERR_UNINITIALIZED);
    }

    if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    {
    	DPFERR("Object is connecting / starting to host" );
    	DPF_RETURN(DPNERR_CONNECTING);
    }

    if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
    {
    	DPFERR("You must be connected / hosting to get connection info" );
    	DPF_RETURN(DPNERR_NOCONNECTION);
    }    	

	if( fServerPlayer )
    {
		hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pPlayerEntry );
		if ( FAILED( hResultCode ) )
		{
            DPFX(DPFPREP,  0, "No host player present" );
            DPF_RETURN(DPNERR_INVALIDPLAYER);
		}
    }
    else
    {
        hResultCode = pdnObject->NameTable.FindEntry( dpnid, &pPlayerEntry );

        if( FAILED( hResultCode ) )
        {
            DPFX(DPFPREP,  0, "Could not find specified player" );
            DPF_RETURN(DPNERR_INVALIDPLAYER);
        }
    }

    if( pPlayerEntry == NULL )
    {
        DNASSERT(FALSE);
        DPFX(DPFPREP,  0, "Internal error" );
        DPF_RETURN(DPNERR_GENERIC);
    }

    if( pPlayerEntry->IsGroup() )
    {
        DPFX(DPFPREP,  0, "Cannot retrieve connection info on groups" );
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
    }

	if ((hResultCode = pPlayerEntry->GetConnectionRef( &pConnection )) != DPN_OK)
	{
		DPFERR("Could not get connection reference");
		hResultCode = DPNERR_CONNECTIONLOST;
		goto Failure;
	}

    hResultCode = pConnection->GetEndPt(&hEndPoint,&CallbackThread);
    if( FAILED( hResultCode ) )
    {
        DPFX(DPFPREP,  0, "Unable to get endpoint hr=[0x%08x]", hResultCode );
		hResultCode = DPNERR_CONNECTIONLOST;
		goto Failure;
    }

	if (hEndPoint != NULL)
	{
		hResultCode = DNPGetEPCaps( pdnObject->pdnProtocolData, hEndPoint, pdpConnectionInfo );
	}
	else
	{
		hResultCode = DPNERR_INVALIDENDPOINT;
	}

	pConnection->ReleaseEndPt(&CallbackThread);

    if( FAILED( hResultCode ) )
    {
        DPFX(DPFPREP,  0, "Error getting connection info hr=[0x%08x]", hResultCode );
        hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
    }

    pConnection->Release();
    pPlayerEntry->Release();

	hResultCode = DPN_OK;

Exit:
	CallbackThread.Deinitialize();
    DPF_RETURN(hResultCode);

Failure:
	if (pPlayerEntry)
	{
		pPlayerEntry->Release();
		pPlayerEntry = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetConnectionInfo"

STDMETHODIMP DN_GetConnectionInfo(PVOID pv,
								  const DPNID dpnid,
								  DPN_CONNECTION_INFO *const pdpConnectionInfo,
								  const DWORD dwFlags)
{
	DPFX(DPFPREP, 3,"Parameters: dpnid [0x%lx] pdpConnectionInfo [0x%p], dwFlags [0x%lx]", dpnid, pdpConnectionInfo,dwFlags );

    return DN_GetConnectionInfoHelper( pv, dpnid, pdpConnectionInfo, FALSE, dwFlags );
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetConnectionInfo"

STDMETHODIMP DN_GetServerConnectionInfo(PVOID pv,
										DPN_CONNECTION_INFO *const pdpConnectionInfo,
										const DWORD dwFlags)
{
	DPFX(DPFPREP, 2,"Parameters: pdpConnectionInfo [0x%p], dwFlags [0x%lx]", pdpConnectionInfo, dwFlags);

    return DN_GetConnectionInfoHelper( pv, 0, pdpConnectionInfo, TRUE, dwFlags );
}


HRESULT DNCAPS_QueryInterface( IDP8SPCallback *pSP, REFIID riid, LPVOID * ppvObj )
{
    *ppvObj = pSP;
    return DPN_OK;
}


ULONG DNCAPS_AddRef( IDP8SPCallback *pSP )
{
    return 1;
}


ULONG DNCAPS_Release( IDP8SPCallback *pSP )
{
    return 1;
}


HRESULT DNCAPS_IndicateEvent( IDP8SPCallback *pSP, SP_EVENT_TYPE spetEvent,LPVOID pvData )
{
    return DPN_OK;
}


HRESULT DNCAPS_CommandComplete( IDP8SPCallback *pSP,HANDLE hCommand,HRESULT hrResult,LPVOID pvData )
{
    return DPN_OK;
}


LPVOID dncapsspInterface[] =
{
    (LPVOID)DNCAPS_QueryInterface,
    (LPVOID)DNCAPS_AddRef,
    (LPVOID)DNCAPS_Release,
	(LPVOID)DNCAPS_IndicateEvent,
	(LPVOID)DNCAPS_CommandComplete
};


// SP should be loaded
//

#undef DPF_MODNAME
#define DPF_MODNAME "DNGetActualSPCaps"

HRESULT DNGetActualSPCaps(CServiceProvider *const pSP,
						  DPN_SP_CAPS *const pCaps)
{
    HRESULT				hResultCode;
    SPGETCAPSDATA		spGetCapsData;
    IDP8ServiceProvider	*pIDP8SP;

	DPFX(DPFPREP, 4,"Parameters: pSP [0x%p], pCaps [0x%p]",pSP,pCaps);

	DNASSERT(pSP != NULL);

	pIDP8SP = NULL;

	//
	//	Get the SP interface
	//
	if ((hResultCode = pSP->GetInterfaceRef( &pIDP8SP )) != DPN_OK)
	{
		DPFERR("Could not get SP interface reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Get the SP caps
	//
	memset( &spGetCapsData, 0x00, sizeof( SPGETCAPSDATA ) );
	spGetCapsData.dwSize = sizeof( SPGETCAPSDATA );
	spGetCapsData.hEndpoint = INVALID_HANDLE_VALUE;
	if ((hResultCode = IDP8ServiceProvider_GetCaps( pIDP8SP, &spGetCapsData )) != DPN_OK)
	{
		DPFERR("Could not get SP caps");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Clean up
	//
	IDP8ServiceProvider_Release( pIDP8SP );
	pIDP8SP = NULL;

	//
	//	Map from SP structure to our own
	//
	pCaps->dwFlags = spGetCapsData.dwFlags;
	pCaps->dwNumThreads = spGetCapsData.dwIOThreadCount;
	pCaps->dwDefaultEnumCount = spGetCapsData.dwDefaultEnumRetryCount;
	pCaps->dwDefaultEnumRetryInterval = spGetCapsData.dwDefaultEnumRetryInterval;
	pCaps->dwDefaultEnumTimeout = spGetCapsData.dwDefaultEnumTimeout;
	pCaps->dwMaxEnumPayloadSize = spGetCapsData.dwEnumFrameSize - sizeof( DN_ENUM_QUERY_PAYLOAD );
	pCaps->dwBuffersPerThread = spGetCapsData.dwBuffersPerThread;
	pCaps->dwSystemBufferSize = spGetCapsData.dwSystemBufferSize;

	hResultCode = DPN_OK;

Exit:
	DNASSERT( pIDP8SP == NULL );

	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pIDP8SP)
	{
		IDP8ServiceProvider_Release(pIDP8SP);
		pIDP8SP = NULL;
	}
	goto Exit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\classfac.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ClassFac.h
 *  Content:    DirectNet class factory header file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	10/08/99	jtk		Created
 *	05/04/00	mjn		Cleaned up functions
 *  06/09/00    rmt     Updates to split CLSID and allow whistler compat and support external create funcs 
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__CLASSFAC_H__
#define	__CLASSFAC_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

#ifndef DPNBUILD_LIBINTERFACE
//
// VTable for class factory
//
extern IClassFactoryVtbl DNCF_Vtbl;
#endif // ! DPNBUILD_LIBINTERFACE

//**********************************************************************
// Function prototypes
//**********************************************************************

//
//	DirectNet - IUnknown
//
STDMETHODIMP DN_QueryInterface(void *pInterface,
							   DP8REFIID riid,
							   void **ppv);

STDMETHODIMP_(ULONG) DN_AddRef(void *pInterface);

STDMETHODIMP_(ULONG) DN_Release(void *pInterface);

//
//	Class Factory
//
#ifndef DPNBUILD_LIBINTERFACE
STDMETHODIMP	DNCORECF_CreateInstance(IClassFactory* pInterface, LPUNKNOWN lpUnkOuter, REFIID riid, LPVOID *ppv);
#endif // ! DPNBUILD_LIBINTERFACE

// Class Factory - supporting

HRESULT DNCF_CreateObject(
#ifndef DPNBUILD_LIBINTERFACE
							IClassFactory* pInterface,
#endif // ! DPNBUILD_LIBINTERFACE
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
							XDP8CREATE_PARAMS * pDP8CreateParams,
#else // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
							DP8REFIID riid,
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
							LPVOID *lplpv
							);
HRESULT		DNCF_FreeObject(LPVOID lpv);

#ifndef DPNBUILD_LIBINTERFACE
static	HRESULT DN_CreateInterface(OBJECT_DATA *pObject,
								   REFIID riid,
								   INTERFACE_LIST **const ppv);

INTERFACE_LIST *DN_FindInterface(void *pInterface,
								 REFIID riid);
#endif // ! DPNBUILD_LIBINTERFACE


#endif	// __CLASSFAC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\client.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Client.cpp
 *  Content:    DNET client interface routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/21/99	mjn		Created
 *	01/06/99	mjn		Moved NameTable stuff to NameTable.h
 *	01/28/00	mjn		Implemented ReturnBuffer in API
 *	02/01/00	mjn		Implemented GetCaps and SetCaps in API
 *	02/15/00	mjn		Implement INFO flags in SetClientInfo
 *	02/18/00	mjn		Converted DNADDRESS to IDirectPlayAddress8
 *  03/17/00    rmt     Added new caps functions
 *	04/06/00	mjn		Added GetServerAddress to API
 *	04/16/00	mjn		DNSendMessage uses CAsyncOp
 *  04/17/00    rmt     Added more param validation
 *              rmt     Removed required for connection from Get/SetInfo / GetAddress
 *	04/19/00	mjn		Send API call accepts a range of DPN_BUFFER_DESCs and a count
 *	04/20/00	mjn		DN_Send() calls DN_SendTo() with DPNID=0
 *	04/24/00	mjn		Updated Group and Info operations to use CAsyncOp's
 *	04/28/00	mjn		Updated DN_GetHostSendQueueInfo() to use CAsyncOp's
 *	05/03/00	mjn		Use GetHostPlayerRef() rather than GetHostPlayer()
 *	05/31/00	mjn		Added operation specific SYNC flags
 *	06/23/00	mjn		Removed dwPriority from Send() API call
 *	06/27/00	mjn		Allow priorities to be specified to GetSendQueueInfo() API call
 *	06/27/00	mjn		Added DN_ClientConnect() (without pvPlayerContext)
 *				mjn		Allow mix-n-match of priorities in GetSendQueueInfo() API call
 *	07/09/00	mjn		Cleaned up DN_SetClientInfo()
 *  07/09/00	rmt		Bug #38323 - RegisterLobby needs a DPNHANDLE parameter.
 *  07/21/2000  RichGr  IA64: Use %p format specifier for 32/64-bit pointers.
 *	10/11/00	mjn		Take locks for CNameTableEntry::PackInfo()
 *	01/22/01	mjn		Check for closing instead of disconnecting in DN_GetServerInfo()
 *	07/24/01	mjn		Added DPNBUILD_NOPARAMVAL compile flag
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// define appropriate types since these interface functions take 'void*' arguments!!
//
typedef	STDMETHODIMP ClientQueryInterface( IDirectPlay8Client *pInterface, DP8REFIID riid, LPVOID *ppvObj );
typedef	STDMETHODIMP_(ULONG)	ClientAddRef( IDirectPlay8Client *pInterface );
typedef	STDMETHODIMP_(ULONG)	ClientRelease( IDirectPlay8Client *pInterface );
typedef	STDMETHODIMP ClientInitialize( IDirectPlay8Client *pInterface, LPVOID const lpvUserContext, const PFNDPNMESSAGEHANDLER lpfn, const DWORD dwFlags );
typedef STDMETHODIMP ClientEnumServiceProviders( IDirectPlay8Client *pInterface,const GUID *const pguidServiceProvider,const GUID *const pguidApplication,DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer,DWORD *const pcbEnumData,DWORD *const pcReturned,const DWORD dwFlags );
typedef	STDMETHODIMP ClientCancelAsyncOperation( IDirectPlay8Client *pInterface, const DPNHANDLE hAsyncHandle, const DWORD dwFlags );
typedef STDMETHODIMP ClientConnect( IDirectPlay8Client *pInterface,const DPN_APPLICATION_DESC *const pdnAppDesc,IDirectPlay8Address *const pHostAddr,IDirectPlay8Address *const pDeviceInfo,const DPN_SECURITY_DESC *const pdnSecurity,const DPN_SECURITY_CREDENTIALS *const pdnCredentials,const void *const pvUserConnectData,const DWORD dwUserConnectDataSize,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags);
typedef	STDMETHODIMP ClientGetApplicationDesc( IDirectPlay8Client *pInterface,DPN_APPLICATION_DESC *const pAppDescBuffer,DWORD *const lpcbDataSize,const DWORD dwFlags );
typedef	STDMETHODIMP ClientClose(IDirectPlay8Client *pInterface,const DWORD dwFlags);
typedef STDMETHODIMP ClientEnumHosts( IDirectPlay8Client *pInterface,DPN_APPLICATION_DESC *const pApplicationDesc,IDirectPlay8Address *const dnaddrHost,IDirectPlay8Address *const dnaddrDeviceInfo,PVOID const pUserEnumData,const DWORD dwUserEnumDataSize,const DWORD dwRetryCount,const DWORD dwRetryInterval,const DWORD dwTimeOut,PVOID const pvUserContext,DPNHANDLE *const pAsyncHandle,const DWORD dwFlags );
typedef STDMETHODIMP ClientReturnBuffer( IDirectPlay8Client *pInterface, const DPNHANDLE hBufferHandle,const DWORD dwFlags);
typedef STDMETHODIMP ClientGetCaps(IDirectPlay8Client *pInterface,DPN_CAPS *const pdnCaps,const DWORD dwFlags);
typedef STDMETHODIMP ClientSetCaps(IDirectPlay8Client *pInterface,const DPN_CAPS *const pdnCaps,const DWORD dwFlags);
typedef STDMETHODIMP ClientSetSPCaps(IDirectPlay8Client *pInterface,const GUID * const pguidSP, const DPN_SP_CAPS *const pdpspCaps, const DWORD dwFlags );
typedef STDMETHODIMP ClientGetSPCaps(IDirectPlay8Client *pInterface,const GUID * const pguidSP, DPN_SP_CAPS *const pdpspCaps,const DWORD dwFlags);
typedef STDMETHODIMP ClientGetConnectionInfo(IDirectPlay8Client *pInterface,DPN_CONNECTION_INFO *const pdpConnectionInfo,const DWORD dwFlags);
typedef STDMETHODIMP ClientRegisterLobby(IDirectPlay8Client *pInterface,const DPNHANDLE dpnHandle,IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags);

//
// VTable for client interface
//
IDirectPlay8ClientVtbl DN_ClientVtbl =
{
	(ClientQueryInterface*)			DN_QueryInterface,
	(ClientAddRef*)					DN_AddRef,
	(ClientRelease*)				DN_Release,
	(ClientInitialize*)				DN_Initialize,
	(ClientEnumServiceProviders*)	DN_EnumServiceProviders,
	(ClientEnumHosts*)				DN_EnumHosts,
	(ClientCancelAsyncOperation*)	DN_CancelAsyncOperation,
	/*(ClientConnect*)*/			DN_ClientConnect,
									DN_Send,
	/*(ClientGetSendQueueInfo*)*/	DN_GetHostSendQueueInfo,
	(ClientGetApplicationDesc*)		DN_GetApplicationDesc,
									DN_SetClientInfo,
									DN_GetServerInfo,
									DN_GetServerAddress,
	(ClientClose*)					DN_Close,
	(ClientReturnBuffer*)			DN_ReturnBuffer,
	(ClientGetCaps*)				DN_GetCaps,
	(ClientSetCaps*)				DN_SetCaps,
    (ClientSetSPCaps*)              DN_SetSPCaps,
    (ClientGetSPCaps*)              DN_GetSPCaps,
    (ClientGetConnectionInfo*)      DN_GetServerConnectionInfo,
	(ClientRegisterLobby*)			DN_RegisterLobby
};

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


#undef DPF_MODNAME
#define DPF_MODNAME "DN_Send"

STDMETHODIMP DN_Send( IDirectPlay8Client *pInterface,
					  const DPN_BUFFER_DESC *const prgBufferDesc,
					  const DWORD cBufferDesc,
					  const DWORD dwTimeOut,
					  const PVOID pvAsyncContext,
					  DPNHANDLE *const phAsyncHandle,
					  const DWORD dwFlags)
{
	return(	DN_SendTo(	pInterface,
						0,					// DN_SendTo should translate this call to the Host player
						prgBufferDesc,
						cBufferDesc,
						dwTimeOut,
						pvAsyncContext,
						phAsyncHandle,
						dwFlags ) );
}


//	DN_ClientConnect
//
//	Call DN_Connect, but with no PlayerContext

STDMETHODIMP DN_ClientConnect(IDirectPlay8Client *pInterface,
							  const DPN_APPLICATION_DESC *const pdnAppDesc,
							  IDirectPlay8Address *const pHostAddr,
							  IDirectPlay8Address *const pDeviceInfo,
							  const DPN_SECURITY_DESC *const pdnSecurity,
							  const DPN_SECURITY_CREDENTIALS *const pdnCredentials,
							  const void *const pvUserConnectData,
							  const DWORD dwUserConnectDataSize,
							  void *const pvAsyncContext,
							  DPNHANDLE *const phAsyncHandle,
							  const DWORD dwFlags)
{
	return(	DN_Connect(	pInterface,
						pdnAppDesc,
						pHostAddr,
						pDeviceInfo,
						pdnSecurity,
						pdnCredentials,
						pvUserConnectData,
						dwUserConnectDataSize,
						NULL,
						pvAsyncContext,
						phAsyncHandle,
						dwFlags ) );
}


//	DN_SetClientInfo
//
//	Set the info for the client player and propagate to server

#undef DPF_MODNAME
#define DPF_MODNAME "DN_SetClientInfo"

STDMETHODIMP DN_SetClientInfo(IDirectPlay8Client *pInterface,
							  const DPN_PLAYER_INFO *const pdpnPlayerInfo,
							  const PVOID pvAsyncContext,
							  DPNHANDLE *const phAsyncHandle,
							  const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
	HRESULT				hResultCode;
	DPNHANDLE			hAsyncOp;
	PWSTR				pwszName;
	DWORD				dwNameSize;
	PVOID				pvData;
	DWORD				dwDataSize;
	CNameTableEntry		*pLocalPlayer;
	BOOL				fConnected;

	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p], pdpnPlayerInfo [0x%p], pvAsyncContext [0x%p], phAsyncHandle [0x%p], dwFlags [0x%lx]",
			pInterface,pdpnPlayerInfo,pvAsyncContext,phAsyncHandle,dwFlags);

    pdnObject = (DIRECTNETOBJECT*) GET_OBJECT_FROM_INTERFACE(pInterface);
    DNASSERT(pdnObject != NULL);

#ifndef	DPNBUILD_NOPARAMVAL
    if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    {
        if( FAILED( hResultCode = DN_ValidateSetClientInfo( pInterface , pdpnPlayerInfo, pvAsyncContext, phAsyncHandle, dwFlags ) ) )
        {
        	DPFX(DPFPREP,  0, "Error validating setclientinfo params hr=[0x%lx]", hResultCode );
        	DPF_RETURN( hResultCode );
        }
    }
#endif	// !DPNBUILD_NOPARAMVAL

    // Check to ensure message handler registered
    if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    {
    	DPFERR( "Object is not initialized" );
    	DPF_RETURN(DPNERR_UNINITIALIZED);
    }	

	pLocalPlayer = NULL;

	if ((pdpnPlayerInfo->dwInfoFlags & DPNINFO_NAME) && (pdpnPlayerInfo->pwszName))
	{
		pwszName = pdpnPlayerInfo->pwszName;
		dwNameSize = (wcslen(pwszName) + 1) * sizeof(WCHAR);
	}
	else
	{
		pwszName = NULL;
		dwNameSize = 0;
	}
	if ((pdpnPlayerInfo->dwInfoFlags & DPNINFO_DATA) && (pdpnPlayerInfo->pvData) && (pdpnPlayerInfo->dwDataSize))
	{
		pvData = pdpnPlayerInfo->pvData;
		dwDataSize = pdpnPlayerInfo->dwDataSize;
	}
	else
	{
		pvData = NULL;
		dwDataSize = 0;
	}

	//
	//	If we are connected, we will request the Host to update us.
	//	Otherwise, we will just update the DefaultPlayer.
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED)
	{
		fConnected = TRUE;
	}
	else
	{
		fConnected = FALSE;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	if (fConnected)
	{
		if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
		{
			DPFERR( "Could not get local player reference" );
			DisplayDNError(0,hResultCode);
			goto Failure;
		}

		DPFX(DPFPREP, 3,"Request host to update client info");

		hResultCode = DNRequestUpdateInfo(	pdnObject,
											pLocalPlayer->GetDPNID(),
											pwszName,
											dwNameSize,
											pvData,
											dwDataSize,
											pdpnPlayerInfo->dwInfoFlags,
											pvAsyncContext,
											&hAsyncOp,
											dwFlags);
		if (hResultCode != DPN_OK && hResultCode != DPNERR_PENDING)
		{
			DPFERR("Could not request host to update client info");
		}
		else
		{
			if (!(dwFlags & DPNSETCLIENTINFO_SYNC))
			{
				DPFX(DPFPREP, 3,"Async Handle [0x%lx]",hAsyncOp);
				*phAsyncHandle = hAsyncOp;
			}
		}

		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	else
	{
		DNASSERT(pdnObject->NameTable.GetDefaultPlayer() != NULL);

		// This function takes the lock internally
		pdnObject->NameTable.GetDefaultPlayer()->UpdateEntryInfo(pwszName,dwNameSize,pvData,dwDataSize,pdpnPlayerInfo->dwInfoFlags, FALSE);

		hResultCode = DPN_OK;
	}

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	goto Exit;
}


//	DN_GetServerInfo
//
//	Retrieve server info from the local nametable.

#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetServerInfo"

STDMETHODIMP DN_GetServerInfo(IDirectPlay8Client *pInterface,
							  DPN_PLAYER_INFO *const pdpnPlayerInfo,
							  DWORD *const pdwSize,
							  const DWORD dwFlags)
{
	DIRECTNETOBJECT	*pdnObject;
	HRESULT			hResultCode;
	CPackedBuffer	packedBuffer;
	CNameTableEntry	*pHostPlayer;

	DPFX(DPFPREP, 3,"Parameters: pInterface [0x%p], pdpnPlayerInfo [0x%p], pdwSize [%p], dwFlags [0x%lx]",
			pInterface,pdpnPlayerInfo,pdwSize,dwFlags);

    pdnObject = (DIRECTNETOBJECT*) GET_OBJECT_FROM_INTERFACE(pInterface);
    DNASSERT(pdnObject != NULL);

#ifndef	DPNBUILD_NOPARAMVAL
    if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    {
        if( FAILED( hResultCode = DN_ValidateGetServerInfo( pInterface , pdpnPlayerInfo, pdwSize, dwFlags ) ) )
        {
        	DPFX(DPFPREP,  0, "Error validating get server info hr=[0x%lx]", hResultCode );
        	DPF_RETURN( hResultCode );
        }
    }
#endif	// !DPNBUILD_NOPARAMVAL

    // Check to ensure message handler registered
    if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    {
    	DPFERR( "Object is not initialized" );
    	DPF_RETURN(DPNERR_UNINITIALIZED);
    }	

    if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    {
    	DPFERR("Object is connecting / starting to host" );
    	DPF_RETURN(DPNERR_CONNECTING);
    }

    if ( !(pdnObject->dwFlags & (DN_OBJECT_FLAG_CONNECTED | DN_OBJECT_FLAG_CLOSING | DN_OBJECT_FLAG_DISCONNECTING) ) )
    {
    	DPFERR("You must be connected / disconnecting to use this function" );
    	DPF_RETURN(DPNERR_NOCONNECTION);
    }	    	

	pHostPlayer = NULL;

	if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef(&pHostPlayer)) != DPN_OK)
	{
		DPFERR("Could not find Host player");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	packedBuffer.Initialize(pdpnPlayerInfo,*pdwSize);

	pHostPlayer->Lock();
	hResultCode = pHostPlayer->PackInfo(&packedBuffer);
	pHostPlayer->Unlock();

	pHostPlayer->Release();
	pHostPlayer = NULL;

	if ((hResultCode == DPN_OK) || (hResultCode == DPNERR_BUFFERTOOSMALL))
	{
		*pdwSize = packedBuffer.GetSizeRequired();
	}

Exit:
	DPF_RETURN(hResultCode);

Failure:
	if (pHostPlayer)
	{
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetHostSendQueueInfo"

STDMETHODIMP DN_GetHostSendQueueInfo(IDirectPlay8Client *pInterface,
									 DWORD *const pdwNumMsgs,
									 DWORD *const pdwNumBytes,
									 const DWORD dwFlags )
{
	DIRECTNETOBJECT		*pdnObject;
	DWORD				dwQueueFlags;
	DWORD				dwNumMsgs;
	DWORD				dwNumBytes;
	CNameTableEntry     *pNTEntry;
	CConnection			*pConnection;
	HRESULT				hResultCode;

	DPFX(DPFPREP, 3,"Parameters : pInterface [0x%p], pdwNumMsgs [0x%p], pdwNumBytes [0x%p], dwFlags [0x%lx]",
		pInterface,pdwNumMsgs,pdwNumBytes,dwFlags);

    pdnObject = (DIRECTNETOBJECT*) GET_OBJECT_FROM_INTERFACE(pInterface);
    DNASSERT(pdnObject != NULL);

#ifndef	DPNBUILD_NOPARAMVAL
    if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    {
        if( FAILED( hResultCode = DN_ValidateGetHostSendQueueInfo( pInterface , pdwNumMsgs, pdwNumBytes, dwFlags ) ) )
        {
        	DPFX(DPFPREP,  0, "Error validating get server info hr=[0x%lx]", hResultCode );
        	DPF_RETURN( hResultCode );
        }
    }
#endif	// !DPNBUILD_NOPARAMVAL

    // Check to ensure message handler registered
    if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    {
    	DPFERR( "Object is not initialized" );
    	DPF_RETURN(DPNERR_UNINITIALIZED);
    }	

    if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    {
    	DPFERR( "Object has not yet completed connecting / hosting" );
    	DPF_RETURN(DPNERR_CONNECTING);
    }

    if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
    {
    	DPFERR("Object is not connected or hosting" );
    	DPF_RETURN(DPNERR_NOCONNECTION);
    }

	pNTEntry = NULL;
	pConnection = NULL;

	//
	//	Get CConnection object
	//
#ifndef DPNBUILD_NOMULTICAST
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_MULTICAST)
	{
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
		if (pdnObject->pMulticastSend != NULL)
		{
			pdnObject->pMulticastSend->AddRef();
			pConnection = pdnObject->pMulticastSend;
		}
		else
		{
			pConnection = NULL;
		}
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		
		if (pConnection == NULL)
		{
		    DPFERR( "Couldn't retrieve multicast send connection" );
			hResultCode = DPNERR_INVALIDGROUP;
			goto Failure;
		}
	}
	else
#endif // ! DPNBUILD_NOMULTICAST
	{
		if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pNTEntry )) != DPN_OK)
		{
			DPFX(DPFPREP, 0,"Could not find Host Player in NameTable");
			hResultCode = DPNERR_CONNECTIONLOST;
			goto Failure;
		}
		if ((hResultCode = pNTEntry->GetConnectionRef( &pConnection )) != DPN_OK)
		{
			hResultCode = DPNERR_CONNECTIONLOST;
			goto Failure;
		}
		pNTEntry->Release();
		pNTEntry = NULL;
	}

	//
	//	Determine required queues
	//
	dwQueueFlags = dwFlags & (DPNGETSENDQUEUEINFO_PRIORITY_HIGH | DPNGETSENDQUEUEINFO_PRIORITY_NORMAL | DPNGETSENDQUEUEINFO_PRIORITY_LOW);
	if (dwQueueFlags == 0)
	{
		dwQueueFlags = (DPNGETSENDQUEUEINFO_PRIORITY_HIGH | DPNGETSENDQUEUEINFO_PRIORITY_NORMAL | DPNGETSENDQUEUEINFO_PRIORITY_LOW);
	}

	//
	//	Extract required info
	//
	dwNumMsgs = 0;
	dwNumBytes = 0;
	pConnection->Lock();
	if (dwQueueFlags & DPNGETSENDQUEUEINFO_PRIORITY_HIGH)
	{
		dwNumMsgs += pConnection->GetHighQueueNum();
		dwNumBytes += pConnection->GetHighQueueBytes();
	}
	if (dwQueueFlags & DPNGETSENDQUEUEINFO_PRIORITY_NORMAL)
	{
		dwNumMsgs += pConnection->GetNormalQueueNum();
		dwNumBytes += pConnection->GetNormalQueueBytes();
	}
	if (dwQueueFlags & DPNGETSENDQUEUEINFO_PRIORITY_LOW)
	{
		dwNumMsgs += pConnection->GetLowQueueNum();
		dwNumBytes += pConnection->GetLowQueueBytes();
	}
	pConnection->Unlock();
	pConnection->Release();
	pConnection = NULL;

	if (pdwNumMsgs)
	{
		*pdwNumMsgs = dwNumMsgs;
		DPFX(DPFPREP, 3,"Setting: *pdwNumMsgs [%ld]",dwNumMsgs);
	}
	if (pdwNumBytes)
	{
		*pdwNumBytes = dwNumBytes;
		DPFX(DPFPREP, 3,"Setting: *pdwNumBytes [%ld]",dwNumBytes);
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	goto Exit;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetServerAddress"

STDMETHODIMP DN_GetServerAddress(IDirectPlay8Client *pInterface,
								 IDirectPlay8Address **const ppAddress,
								 const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
	IDirectPlay8Address	*pAddress;
	HRESULT				hResultCode;
	CNameTableEntry		*pHostPlayer;

	DPFX(DPFPREP, 3,"Parameters : pInterface [0x%p], ppAddress [0x%p], dwFlags [0x%lx]",
		pInterface,ppAddress,dwFlags);

    pdnObject = (DIRECTNETOBJECT*) GET_OBJECT_FROM_INTERFACE(pInterface);
    DNASSERT(pdnObject != NULL);

#ifndef	DPNBUILD_NOPARAMVAL
    if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    {
        if( FAILED( hResultCode = DN_ValidateGetServerAddress( pInterface,ppAddress,dwFlags ) ) )
        {
        	DPFX(DPFPREP,  0, "Error validating get server info hr=[0x%lx]", hResultCode );
        	DPF_RETURN( hResultCode );
        }
    }
#endif // !DPNBUILD_NOPARAMVAL

    // Check to ensure message handler registered
    if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    {
    	DPFERR( "Object is not initialized" );
    	DPF_RETURN(DPNERR_UNINITIALIZED);
    }	

    if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    {
    	DPFERR("Object is connecting / starting to host" );
    	DPF_RETURN(DPNERR_CONNECTING);
    }

    if ( !(pdnObject->dwFlags & (DN_OBJECT_FLAG_CONNECTED | DN_OBJECT_FLAG_CLOSING | DN_OBJECT_FLAG_DISCONNECTING) ) )
    {
    	DPFERR("You must be connected / disconnecting to use this function" );
    	DPF_RETURN(DPNERR_NOCONNECTION);
    }	    	

	pHostPlayer = NULL;

	if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pHostPlayer )) != DPN_OK)
	{
		DPFERR("Could not find Host player");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pAddress = pHostPlayer->GetAddress();
	DNASSERT(pAddress != NULL);
	hResultCode = IDirectPlay8Address_Duplicate(pAddress,ppAddress);

	pHostPlayer->Release();
	pHostPlayer = NULL;

Exit:
	DPF_RETURN(hResultCode);

Failure:
	if (pHostPlayer)
	{
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	goto Exit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\client.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Client.h
 *  Content:    DirectNet Client interface header file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/21/99	mjn		Created
 *	10/08/99	jtk		Split from DNCore.h
 *	12/03/99	jtk		Moved COM interface definitions to DNet.h
 *	02/15/00	mjn		Implement INFO flags in SetClientInfo
 *	04/06/00	mjn		Added GetServerAddress to API
 *	04/19/00	mjn		Send API call accepts a range of DPN_BUFFER_DESCs and a count
 *	06/23/00	mjn		Removed dwPriority from Send() API call
 *	06/27/00	mjn		Added DN_ClientConnect() (without pvPlayerContext)
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__CLIENT_H__
#define	__CLIENT_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// VTable for client interface
//
extern IDirectPlay8ClientVtbl DN_ClientVtbl;

//**********************************************************************
// Function prototypes
//**********************************************************************

//
// DirectNet - IDirectNetClient
//

STDMETHODIMP DN_ClientConnect(IDirectPlay8Client *pInterface,
							  const DPN_APPLICATION_DESC *const pdnAppDesc,
							  IDirectPlay8Address *const pHostAddr,
							  IDirectPlay8Address *const pDeviceInfo,
							  const DPN_SECURITY_DESC *const pdnSecurity,
							  const DPN_SECURITY_CREDENTIALS *const pdnCredentials,
							  const void *const pvUserConnectData,
							  const DWORD dwUserConnectDataSize,
							  void *const pvAsyncContext,
							  DPNHANDLE *const phAsyncHandle,
							  const DWORD dwFlags);

STDMETHODIMP DN_Send( IDirectPlay8Client *pInterface,
					  const DPN_BUFFER_DESC *const prgBufferDesc,
					  const DWORD cBufferDesc,
					  const DWORD dwTimeOut,
					  void *const pvAsyncContext,
					  DPNHANDLE *const phAsyncHandle,
					  const DWORD dwFlags);

STDMETHODIMP DN_SetClientInfo(IDirectPlay8Client *pInterface,
							  const DPN_PLAYER_INFO *const pdpnPlayerInfo,
							  PVOID const pvAsyncContext,
							  DPNHANDLE *const phAsyncHandle,
							  const DWORD dwFlags);

STDMETHODIMP DN_GetServerInfo(IDirectPlay8Client *pInterface,
							  DPN_PLAYER_INFO *const pdpnPlayerInfo,
							  DWORD *const pdwSize,
							  const DWORD dwFlags);

STDMETHODIMP DN_GetHostSendQueueInfo(IDirectPlay8Client *pInterface,
									 DWORD *const lpdwNumMsgs,
									 DWORD *const lpdwNumBytes,
									 const DWORD dwFlags );

STDMETHODIMP DN_GetServerAddress(IDirectPlay8Client *pInterface,
								 IDirectPlay8Address **const ppAddress,
								 const DWORD dwFlags);


#endif	// __CLIENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\caps.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Caps.h
 *  Content:    DirectPlay8 Caps routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	03/17/00	rmt		Created
 *  03/25/00    rmt     Changed Get/SetActualSPCaps so takes interface instead of obj
 *	08/20/00	mjn		DNSetActualSPCaps() uses CServiceProvider object instead of GUID
 *	03/30/01	mjn		Removed cached caps functionallity
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__CAPS_H__
#define	__CAPS_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

class CServiceProvider;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************


STDMETHODIMP DN_SetCaps(PVOID pv,
						const DPN_CAPS *const pdnCaps,
						const DWORD dwFlags);

STDMETHODIMP DN_GetCaps(PVOID pv,
						DPN_CAPS *const pdnCaps,
						const DWORD dwFlags);

STDMETHODIMP DN_GetSPCaps(PVOID pv,
						  const GUID * const pguidSP,
						  DPN_SP_CAPS *const pdnSPCaps,
						  const DWORD dwFlags);

STDMETHODIMP DN_SetSPCaps(PVOID pv,
						  const GUID * const pguidSP,
						  const DPN_SP_CAPS *const pdnSPCaps,
						  const DWORD dwFlags);

STDMETHODIMP DN_GetConnectionInfo(PVOID pv,
								  const DPNID dpnid,
								  DPN_CONNECTION_INFO *const pdpConnectionInfo,
								  const DWORD dwFlags);

STDMETHODIMP DN_GetServerConnectionInfo(PVOID pv,
										DPN_CONNECTION_INFO *const pdpConnectionInfo,
										const DWORD dwFlags);

HRESULT DNGetActualSPCaps(CServiceProvider *const pSP,
						  DPN_SP_CAPS *const pCaps);


#endif	// __CONNECT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\common.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Common.cpp
 *  Content:    DNET common interface routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/21/99	mjn		Created
 *  12/23/99	mjn		Hand all NameTable update sends from Host to worker thread
 *  12/23/99	mjn		Fixed use of Host and AllPlayers short cut pointers
 *	12/28/99	mjn		Moved Async Op stuff to Async.h
 *	12/29/99	mjn		Reformed DN_ASYNC_OP to use hParentOp instead of lpvUserContext
 *	12/29/99	mjn		Added Instance GUID generation in DN_Host
 *	01/05/00	mjn		Return DPNERR_NOINTERFACE if CoCreateInstance fails
 *	01/06/00	mjn		Moved NameTable stuff to NameTable.h
 *	01/07/00	mjn		Implemented DNSEND_NOCOPY flag in DN_SendTo
 *	01/07/00	mjn		Moved Misc Functions to DNMisc.h
 *	01/08/00	mjn		Implemented GetApplicationDesc
 *	01/09/00	mjn		Application Description stuff
 *	01/10/00	mjn		Implemented SetApplicationDesc
 *	01/11/00	mjn		Use CPackedBuffers instead of DN_ENUM_BUFFER_INFOs
 *	01/13/00	mjn		Removed DIRECTNETOBJECT from Pack/UnpackApplicationDesc
 *	01/14/00	mjn		Added pvUserContext to Host API call
 *	01/14/00	mjn		Removed pvUserContext from DN_NAMETABLE_ENTRY
 *	01/15/00	mjn		Replaced DN_COUNT_BUFFER with CRefCountBuffer
 *	01/16/00	mjn		Moved User callback stuff to User.h
 *	01/18/00	mjn		Implemented DNGROUP_AUTODESTRUCT
 *  01/18/00	rmt		Added calls into voice layer for Close
 *	01/19/00	mjn		Replaced DN_SYNC_EVENT with CSyncEvent
 *	01/20/00	mjn		Clean up NameTable operation list in DN_Close
 *	01/23/00	mjn		Added DN_DestroyPlayer and DNTerminateSession
 *	01/28/00	mjn		Added DN_ReturnBuffer
 *	02/01/00	mjn		Added DN_GetCaps, DN_SetCaps
 *	02/01/00	mjn		Implement Player/Group context values
 *	02/09/00	mjn		Implemented DNSEND_COMPLETEONPROCESS
 *	02/15/00	mjn		Implement INFO flags in SetInfo and return context in GetInfo
 *	02/17/00	mjn		Implemented GetPlayerContext and GetGroupContext
 *	02/17/00	mjn		Reordered parameters in EnumServiceProviders,EnumHosts,Connect,Host
 *	02/18/00	mjn		Converted DNADDRESS to IDirectPlayAddress8
 *  03/17/00    rmt     Moved caps funcs to caps.h/caps.cpp
 *	03/23/00	mjn		Set group context through CreateGroup
 *				mjn		Set player context through Host and Connect
 *				mjn		Implemented RegisterLobby()
 *	03/24/00	mjn		Release SP when EnumHost completes
 *  03/25/00    rmt     Added call into DPNSVR when host begins
 *  04/04/00	rmt		Added flag to disable calls to DPNSVR and flag to disable
 *						parameter validation
 *	04/05/00	mjn		Fixed DestroyClient API call
 *	04/06/00	mjn		Added DN_GetHostAddress()
 *	04/07/00	mjn		Prevent Initialize() API from being called twice
 *				mjn		Ensure Host addresses have SP included
 *				mjn		Fixed DN_GetHostAddress() to get address
 *	04/09/00	mjn		Convert DN_Host() and DN_Connect() to use CAsyncOp
 *	04/10/00	mjn		Fixed DN_Close() to use flags
 *	04/11/00	mjn		Use CAsyncOp for ENUMs
 *				mjn		Moved ProcessEnumQuery and ProcessEnumResponse to EnumHosts.cpp
 *				mjn		DNCancelEnum() uses CAsyncOp
 *	04/12/00	mjn		DNTerminateSession() cancels outstanding ENUMs
 *				mjn		DN_Close() cancels ENUMs instead of DNTerminateSession
 *				mjn		DN_Close() clears DN_OBJECT_FLAG_DISCONNECTING
 *  04/13/00	rmt     More parameter validation
 *	04/14/00	mjn		Default Host SP to Device SP if not specified
 *				mjn		Crack LISTENs in DN_Host for DPNSVR
 *	04/16/00	mjn		DNSendMessage uses CAsyncOp
 *	04/17/00	mjn		DNCancelSend() uses CAsyncOp
 *	04/17/00	mjn		Fixed DN_EnumHosts to use Handle parent and SYNC operation
 *				mjn		DN_Close tries to cancel SENDs and ENUMs
 *	04/18/00	mjn		CConnection tracks connection status better
 *				mjn		Deinitialize HandleTable, and release addresses in DN_Close
 *				mjn		Fixed DN_GetApplicationDesc to return correct size
 *	04/19/00	mjn		Changed DN_SendTo to accept a range of DPN_BUFFER_DESCs and a count
 *				mjn		Shut down LISTENs earlier in Close sequence
 *	04/20/00	mjn		Convert ReceiveBuffers to CAsyncOp and reclaim at Close
 *				mjn		DN_SendTo() may be invoked by IDirectPlay8Client::DN_Send()
 *	04/23/00	mjn		Added parameter to DNPerformChildSend()
 *				mjn		Reimplemented SEND_COMPLETEONPROCESS
 *	04/24/00	mjn		Updated Group and Info operations to use CAsyncOp's
 *	04/25/00	mjn		Added DNCancelConnect to DN_CancelAsyncOperation
 *	04/26/00	mjn		Fixed DN_GetSendQueueInfo to use CAsyncOp's
 *	04/26/00	mjn		Removed DN_ASYNC_OP and related functions
 *	04/27/00	mjn		Cause DN_GetPlayerContext()/DN_GetGroupContext() to fail if disconnecting
 *	04/28/00	mjn		Allow a NULL Device Address in DN_Connect() - steal SP from Host Address
 *				mjn		Save user connect data to be passed during CONNECT sequence
 *				mjn		Prevent infinite loops in group SENDs
 *  05/01/00    rmt     Bug #33403 - Require DPNSESSION_CLIENT_SERVER mode in client/server mode
 *	05/01/00	mjn		Prevent unusable SPs from being enumerated.
 *	05/03/00	mjn		Use GetHostPlayerRef() rather than GetHostPlayer()
 *	05/04/00	mjn		Clean up address list in DN_Host()
 *	05/05/00	mjn		Free pvConnectData in DN_Close()
 *				mjn		Fixed leak in DN_GetHostAddress()
 *	05/16/00	mjn		Force return code from ASYNC DN_SendTo() to return DPNERR_PENDING
 *				mjn		Better locking for User notifications
 *	05/30/00	mjn		Modified logic for group sends to target connected players only
 *				mjn		ASSERT if operations cannot be cancelled in DN_Close()
 *	05/31/00	mjn		Added operation specific SYNC flags
 *	05/31/00	mjn		Prevent ALL_PLAYERS group from being enum'd in DN_EnumClientsAndGroups()
 *				mjn		Skip invalid Host addresses
 *	06/05/00	mjn		Fixed DN_SendTo to handle some errors gracefully
 *	06/19/00	mjn		DN_Connect and DN_Host enumerate adapters if ALL_ADAPTERS specified
 *	06/20/00	mjn		Fixed DN_GetHostAddress() to extract host address from LISTENs
 *				mjn		DOH!  Forgot to change a line in DN_Host() so that LISTENs use enum'd adapter rather than ALL_ADAPTER
 *	06/22/00	mjn		Replace CConnection::MakeConnected() with SetStatus()
 *	06/23/00	mjn		Removed dwPriority from DN_SendTo()
 *	06/24/00	mjn		Added parent CONNECT AsyncOp to DN_Connect()
 *				mjn		Return DPNERR_UNINITIALIZED from DN_Close() if not initialized (called twice)
 *	06/25/00	mjn		Added DNUpdateLobbyStatus(), update status for CONNECTED,DISCONNECTED
 *				mjn		Set DirectNetObject as CONNECTED earlier in DN_Host()
 *	06/26/00	mjn		Replaced DPNADDCLIENTTOGROUP_SYNC DPNADDPLAYERTOGROUP_SYNC
 *				mjn		Replaced DPNREMOVECLIENTFROMGROUP_SYNC with DPNREMOVEPLAYERFROMGROUP_SYNC
 *				mjn		Fixed for() loop counter problem - nested counters used the same variable - DOH !
 *	06/27/00	mjn		Allow priorities to be specified to GetSendQueueInfo() API calls
 *				rmt		Added abstraction for COM_Co(Un)Initialize
 *				mjn		Removed ASSERT player not found in DN_GetPlayerContext()
 *				mjn		Added DPNSEND_NONSEQUENTIAL flag to Send/SendTo
 *				mjn		Allow mix-n-match of priorities in GetSendQueueInfo() API call
 *	07/02/00	mjn		Modified DN_SendTo() to use DNSendGroupMessage()
 *	07/06/00	mjn		Added missing completions for group sends
 *				mjn		Fixed locking problem in CNameTable::MakeLocalPlayer,MakeHostPlayer,MakeAllPlayersGroup
 *				mjn		Turned DPNSEND_NONSEQUENTIAL flag back on in DN_SendTo()
 *				mjn		Use SP handle instead of interface
 *	07/07/00	mjn		Cleanup pNewHost on DirectNetObject at close
 *	07/08/00	mjn		Fixed CAsyncOp to contain m_bilinkParent
 *  07/09/00	rmt		Bug #38323 - RegisterLobby needs a DPNHANDLE parameter.
 *	07/11/00	mjn		Added NOLOOPBACK capability to group sends
 *				mjn		Fixed DN_EnumHosts() to handle multiple adapters
 *	07/12/00	mjn		Copy user data on EnumHosts()
 *	07/17/00	mjn		Removed redundant SyncEvent->Reset() in DN_Initialize
 *				mjn		Clear DN_OBJECT_FLAG_HOST_CONNECTED in DN_Close()
 *				mjn		Check correct return value of DNSendGroupMessage() in DN_SendTo()
 *  07/19/00    aarono	Bug#39751 add CancelAsyncOperation flag support.
 *	07/20/00	mjn		Cleaned up DN_Connect()
 *  07/21/00    RichGr  IA64: Use %p format specifier for 32/64-bit pointers.
 *	07/21/00	mjn		Cleaned up DN_Close() to release connection object reference
 *	07/23/00	mjn		Moved assertion in DN_CanceAsyncOperation
 *	07/25/00	mjn		Fail DN_EnumHosts() if no valid device adapters exist
 *	07/26/00	mjn		Fix error codes returned from DN_Connect(),DN_GetSendQueueInfo(),DN_DestroyGroup()
 *						DN_AddClientToGroup(),DN_RemoveClientFromGroup(),DN_SetGroupInfo()
 *						DN_GetGroupInfo(),DN_EnumGroupMembers()
 *				mjn		Fix DN_GetApplicationDesc() to always return buffer size
 *	07/26/00	mjn		Fixed locking problem with CAsyncOp::MakeChild()
 *	07/28/00	mjn		Revised DN_GetSendQueueInfo() to use queue info on CConnection objects
 *				mjn		Cleaned up DN_GetPlayerContext() and DN_GetGroupContext()
 *	07/29/00	mjn		Better clean up of pending Connect()'s during Close()
 *				mjn		Check user data size in DN_EnumHosts()
 *				mjn		Added fUseCachedCaps to DN_SPEnsureLoaded()
 *	07/30/00	mjn		Replaced DN_NAMETABLE_PENDING_OP with CPendingDeletion
 *	07/31/00	mjn		Added hrReason to DNTerminateSession()
 *				mjn		Added dwDestroyReason to DNHostDisconnect()
 *				mjn		Cleaned up DN_TerminateSession()
 *  08/03/00	rmt		Bug #41244 - Wrong return codes -- part 2 
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/05/00	mjn		Added pParent to DNSendGroupMessage and DNSendMessage()
 *				mjn		Ensure cancelled operations don't proceed
 *				mjn		Prevent hosting players from calling DN_EnumHosts()
 *				mjn		Generate TERMINATE_SESSION notification for host player
 *	08/06/00	mjn		Added CWorkerJob
 *	08/09/00	mjn		Moved no-loop-back test in DN_SendTo()
 *  08/15/00	rmt		Bug #42506 - DPLAY8: LOBBY: Automatic connection settings not being sent
 *	08/15/00	mjn		Remapped DPNERR_INVALIDENDPOINT from DPNERR_INVALIDPLAYER to DPNERR_NOCONNECTION in DN_SendTo()
 *				mjn		Addef hProtocol to DNRegisterWithDPNSVR() and removed registration from DN_Host()
 *	08/16/00	mjn		Return DPNERR_INVALIDHOSTADDRESS from DN_EnumHosts() if host address is invalid
 *	08/20/00	mjn		Removed fUseCachedCaps from DN_SPEnsureLoaded()
 *	08/23/00	mjn		Flag DirectNetObject as registered with DPNSVR
 *	08/24/00	mjn		Replace DN_NAMETABLE_OP with CNameTableOp
 *	08/29/00	mjn		Remap DPNERR_INVALIDPLAYER to DPNERR_CONNECTIONLOST in DN_SendTo()
 *	09/01/00	masonb		Modified DN_Close to call CloseHandle on hWorkerThread
 *	09/04/00	mjn		Added CApplicationDesc
 *	09/05/00	mjn		Set NameTable DPNID mask when hosting
 *	09/06/00	mjn		Fixed register with DPNSVR problem
 *  09/13/00	rmt		Bug #44625 - DPVOICE: Multihomed machines are not always enumerable
 *						Moved registration for DPNSVR into ListenComplete
 *	09/17/00	mjn		Split CNameTable.m_bilinkEntries into m_bilinkPlayers and m_bilinkGroups
 *	10/11/00	mjn		Take locks for CNameTableEntry::PackInfo()
 *	10/12/00	mjn		Set async handle completion after succeeding in DN_EnumHosts()
 *	10/17/00	mjn		Fixed clean up for unreachable players
 *	11/16/00	mjn		Fixed uninitialized variable problem in DN_CancelAsyncOperation()
 *	12/11/00	mjn		Allow API calls after TERMINATE_SESSION without calling Close() first
 *	01/09/01	mjn		CancelAsyncOperations() returns DPNERR_CANNOTCANCEL if operation doesn't allow it
 *	01/10/01	mjn		DN_Connect() cancels ENUMs with DPNERR_CONNECTING
 *	01/22/01	mjn		Check closing instead of disconnecting in getting player/group context and info
 *				mjn		Fixed debug text
 *	02/12/01	mjn		GetPlayerContext() and GetGroupContext() return DPNERR_NOTREADY if context not yet set
 *	03/30/01	mjn		Changes to prevent multiple loading/unloading of SP's
 *				mjn		Use cached enum frame size
 *	04/11/01	mjn		Save hosting flag for query for addressing when listening
 *	05/02/01	vpo		Whistler 380319: "DPLAY8: CORE: Starts listening before creating local nametable entry"
 *	05/07/01	vpo		Whistler 384350: "DPLAY8: CORE: Messages from server can be indicated before connect completes"
 *	05/14/01	mjn		Fix client error handling when completing connect if server not available
 *	05/22/01	mjn		Properly set DirectNetObject as CONNECTED for successful client connect
 *	06/03/01	mjn		Clean up connect parent in DNTerminateSession()
 *	06/12/01	mjn		Ensure DN_Initialize() returns non-DPN_OK value when creating new CSyncEvent or thread fails
 *	06/25/01	mjn		Unregister from DPNSVR in DNTerminateSession()
 *	07/24/01	mjn		Added DPNBUILD_NOPARAMVAL compile flag
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

HRESULT DNGetHostAddressHelper(DIRECTNETOBJECT *pdnObject, 
							   IDirectPlay8Address **const prgpAddress,
							   DWORD *const pcAddress);

//
//	Store the user-supplied message handler and context value for call backs
//

#undef DPF_MODNAME
#define DPF_MODNAME "DN_Initialize"

STDMETHODIMP DN_Initialize(PVOID pInterface,
						   PVOID const pvUserContext,
						   const PFNDPNMESSAGEHANDLER pfn,
						   const DWORD dwFlags)
{
	HRESULT				hResultCode = DPN_OK;
	DIRECTNETOBJECT		*pdnObject;
#ifndef	DPNBUILD_NONSEQUENTIALWORKERQUEUE
	CSyncEvent			*pThreadPoolSyncEvent;
#endif	// DPNBUILD_NONSEQUENTIALWORKERQUEUE
	CSyncEvent			*pProtocolSyncEvent;
	BOOL				fApplicationDesc;
	BOOL				fHandleTable;
	BOOL				fProtocol;

	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p], pvUserContext [0x%p], pfn [0x%p], dwFlags [0x%lx]",
			pInterface,pvUserContext,pfn,dwFlags);

#ifndef	DPNBUILD_NOPARAMVAL
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
    	DPFERR("Invalid object specified" );
    	DPF_RETURN( DPNERR_INVALIDOBJECT );
    }

    if( pfn == NULL )
    {
    	DPFERR("You must specify a callback function" );
    	DPF_RETURN( DPNERR_INVALIDPARAM );
    }

    if( dwFlags & ~(DPNINITIALIZE_DISABLEPARAMVAL
#ifdef	DIRECTPLAYDIRECTX9
		| DPNINITIALIZE_HINT_LANSESSION
#endif	// DIRECTPLAYDIRECTX9
		) )
    {
    	DPFERR("Invalid flags specified" );
    	DPF_RETURN( DPNERR_INVALIDFLAGS );
    }
#endif // !DPNBUILD_NOPARAMVAL

    pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
    DNASSERT(pdnObject != NULL);

    // Ensure not already initialized
    if (pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED)
    {
    	DPFERR("Initialize has already been called" );
    	DPF_RETURN(DPNERR_ALREADYINITIALIZED);
    }

#ifndef DPNBUILD_NOPARAMVAL
	// Disable parameter validation flag if DPNINITIALIZE_DISABLEPARAMVAL
    // is specified
    if( dwFlags & DPNINITIALIZE_DISABLEPARAMVAL )
    {
    	pdnObject->dwFlags &= ~(DN_OBJECT_FLAG_PARAMVALIDATION);
    }
#endif // !DPNBUILD_NOPARAMVAL

	fApplicationDesc = FALSE;
	fHandleTable = FALSE;
	fProtocol = FALSE;
	pProtocolSyncEvent = NULL;
#ifndef	DPNBUILD_NONSEQUENTIALWORKERQUEUE
	pThreadPoolSyncEvent = NULL;
#endif	// DPNBUILD_NONSEQUENTIALWORKERQUEUE
	//
	//	Lock DirectNetObject in case someone's trying something funny
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);

	//
	//	Initialize ApplicationDescription
	//
	if ((hResultCode = pdnObject->ApplicationDesc.Initialize()) != DPN_OK)
	{
		DPFERR("Could not initialize ApplicationDesc");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	fApplicationDesc = TRUE;

	//
	//	Initialize HandleTable
	//
	if ((hResultCode = pdnObject->HandleTable.Initialize()) != DPN_OK)
	{
		DPFERR("Could not initialize HandleTable");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	fHandleTable = TRUE;

	//
	//	The threadpool interface always exists for the life of the object.
	//
	DNASSERT(pdnObject->pIDPThreadPoolWork != NULL);

#ifndef DPNBUILD_ONLYONETHREAD
	//
	//	Have the thread pool object try to start at least one thread.  Other
	//	components may request more, but we just need a single worker.
	//
	//	We'll ignore failure, because we could still operate in DoWork mode even
	//	when starting the thread fails.  It most likely failed because the user
	//	is in that mode already anyway (DPNERR_ALREADYINITIALIZED).
	//
	hResultCode = IDirectPlay8ThreadPoolWork_RequestTotalThreadCount(pdnObject->pIDPThreadPoolWork, 1, 0);
	if (hResultCode != DPN_OK)
	{
		if (hResultCode != DPNERR_ALREADYINITIALIZED)
		{
			DPFX(DPFPREP, 0, "Requesting a single thread failed (err = 0x%lx)!", hResultCode);
		}

		//
		// Continue...
		//
	}
#endif // ! DPNBUILD_ONLYONETHREAD

	//
	//	Initialize protocol and create shut-down event
	//
	DNASSERT(pdnObject->lProtocolRefCount == 0);
#if ((! defined(DPNBUILD_LIBINTERFACE)) || (! defined(DPNBUILD_ONLYONESP)))
	if ((hResultCode = DNPProtocolInitialize( pdnObject->pdnProtocolData, pdnObject, &g_ProtocolVTBL, 
							pdnObject->pIDPThreadPoolWork, (dwFlags
#ifdef	DIRECTPLAYDIRECTX9
							& DPNINITIALIZE_HINT_LANSESSION
#endif	// DIRECTPLAYDIRECTX9
							))) != DPN_OK)
	{
		hResultCode = DPNERR_OUTOFMEMORY;
		DPFERR("DNPProtocolInitialize() failed");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
#endif // ! DPNBUILD_LIBINTERFACE or ! DPNBUILD_ONLYONESP
	pdnObject->lProtocolRefCount = 1;
	fProtocol = TRUE;

	DNASSERT( pdnObject->hProtocolShutdownEvent == NULL );
	if ((hResultCode = SyncEventNew(pdnObject,&pProtocolSyncEvent)) != DPN_OK)
	{
		DPFERR("Could not get protocol shutdown event");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

#ifndef	DPNBUILD_NONSEQUENTIALWORKERQUEUE
	if ((hResultCode = SyncEventNew(pdnObject,&pThreadPoolSyncEvent)) != DPN_OK)
	{
		DPFERR("Could not create threadpool shutdown event");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pdnObject->lThreadPoolRefCount = 1;

	pdnObject->ThreadPoolShutDownEvent = pThreadPoolSyncEvent;
	pThreadPoolSyncEvent = NULL;
#endif	// DPNBUILD_NONSEQUENTIALWORKERQUEUE

	pdnObject->hProtocolShutdownEvent = pProtocolSyncEvent;
	pProtocolSyncEvent = NULL;
	pdnObject->pfnDnUserMessageHandler = pfn;
	pdnObject->pvUserContext = pvUserContext;
	pdnObject->dwFlags |= DN_OBJECT_FLAG_INITIALIZED;
	pdnObject->dwMaxFrameSize = 0;

	hResultCode = DPN_OK;

Exit:
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (fApplicationDesc)
	{
		pdnObject->ApplicationDesc.Deinitialize();
	}
	if (fHandleTable)
	{
		pdnObject->HandleTable.Deinitialize();
	}
	if (pProtocolSyncEvent)
	{
		pProtocolSyncEvent->ReturnSelfToPool();
		pProtocolSyncEvent = NULL;
	}
#ifndef	DPNBUILD_NONSEQUENTIALWORKERQUEUE
	if (pThreadPoolSyncEvent)
	{
		pThreadPoolSyncEvent->ReturnSelfToPool();
		pThreadPoolSyncEvent = NULL;
	}
#endif // DPNBUILD_NONSEQUENTIALWORKERQUEUE
	if (fProtocol)
	{
		DNProtocolRelease(pdnObject);
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_Close"

STDMETHODIMP DN_Close(PVOID pInterface,const DWORD dwFlags)
{
	HRESULT				hResultCode = DPN_OK;
	DIRECTNETOBJECT		*pdnObject;
	CBilink				*pBilink;
	CAsyncOp			*pAsyncOp;
	CConnection			*pConnection;
	CPendingDeletion	*pPending;
	CServiceProvider	*pSP;
	BOOL				fWaitForEvent;

	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p], dwFlags [0x%lx]",pInterface,dwFlags);

    pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
    DNASSERT(pdnObject != NULL);
    	
#ifndef	DPNBUILD_NOPARAMVAL
    if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    {
        if( !IsValidDirectPlay8Object( pInterface ) )
    	{
    	    DPFERR("Invalid object specified " );
        	DPF_RETURN( DPNERR_INVALIDOBJECT );
    	}

#ifdef	DIRECTPLAYDIRECTX9
		if( dwFlags & ~(DPNCLOSE_IMMEDIATE) )
#else
		if (dwFlags != 0)
#endif
		{
			DPFERR("Invalid flags");
			DPF_RETURN( DPNERR_INVALIDFLAGS );
		}
    }
#endif // !DPNBUILD_NOPARAMVAL

	pAsyncOp = NULL;
	pConnection = NULL;
	pSP = NULL;

	//
	//	Ensure this isn't being called on a callback thread
	//
	DNEnterCriticalSection(&pdnObject->csCallbackThreads);
	pBilink = pdnObject->m_bilinkCallbackThreads.GetNext();
	while (pBilink != &pdnObject->m_bilinkCallbackThreads)
	{
		if ((CONTAINING_CALLBACKTHREAD(pBilink))->IsCurrentThread())
		{
			DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
			DPFERR("Cannot call Close on a callback thread");
			hResultCode = DPNERR_NOTALLOWED;
			goto Failure;
		}
		pBilink = pBilink->GetNext();
	}
	DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	
    //
	//	Flag as closing.   Make sure this hasn't already been called.
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);

	// Ensure already initialized
	if ( !(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED) )
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);	
	    DPFX(DPFPREP, 1, "Object is not initialized" );
		DPF_RETURN(DPNERR_UNINITIALIZED);
	}	
	
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CLOSING)
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		DPFERR("Already closing" );
		hResultCode = DPNERR_ALREADYCLOSING;
		goto Failure;
	}
	
	pdnObject->dwFlags |= DN_OBJECT_FLAG_CLOSING;
#ifdef	DIRECTPLAYDIRECTX9
	if (dwFlags & DPNCLOSE_IMMEDIATE)
	{
		//
		//	We will set DN_OBJECT_FLAG_CLOSING_IMMEDIATE so that any disconnects from now on will be immediate
		//
		pdnObject->dwFlags |= DN_OBJECT_FLAG_CLOSING_IMMEDIATE;
	}
#endif

	if (pdnObject->dwLockCount == 0)
	{
		fWaitForEvent = FALSE;
	}
	else
	{
		fWaitForEvent = TRUE;
	}
	pdnObject->dwClosingThreadID = GetCurrentThreadId();

	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

#ifdef DBG
	{
		CNameTableEntry	*pLocalPlayer;

		if (pdnObject->NameTable.GetLocalPlayerRef(&pLocalPlayer) == DPN_OK)
		{
			DPFX(DPFPREP, 0,"Local player was [0x%lx]",pLocalPlayer->GetDPNID());
			pLocalPlayer->Release();
		}
	}
#endif // DBG

	//
	//	If there are operations underway, we will wait for them to complete and release the lock count
	//
	if (fWaitForEvent)
	{
		hResultCode = IDirectPlay8ThreadPoolWork_WaitWhileWorking(pdnObject->pIDPThreadPoolWork,
																	HANDLE_FROM_DNHANDLE(pdnObject->hLockEvent),
																	0);
		DNASSERT(hResultCode == DPN_OK);
	}

	//
	//	Cancel connect
	//
	DPFX(DPFPREP, 3,"Checking CONNECT");
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pAsyncOp = pdnObject->pConnectParent;
	pdnObject->pConnectParent = NULL;
	pSP = pdnObject->pConnectSP;
	pdnObject->pConnectSP = NULL;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	if (pAsyncOp)
	{
		pAsyncOp->Lock();
		pConnection = pAsyncOp->GetConnection();
		pAsyncOp->SetConnection( NULL );
		pAsyncOp->Unlock();

		DPFX(DPFPREP, 3,"Canceling CONNECT");
		hResultCode = DNCancelChildren(pdnObject,pAsyncOp);
		DPFX(DPFPREP, 3,"Canceling CONNECT returned [0x%lx]",hResultCode);

		pAsyncOp->Release();
		pAsyncOp = NULL;

		if (pConnection)
		{
			pConnection->Disconnect();
			pConnection->Release();
			pConnection = NULL;
		}
	}

	if (pSP)
	{
		pSP->Release();
		pSP = NULL;
	}

	//
	//	Remove outstanding ENUMs, SENDs, RECEIVE_BUFFERs
	//
	DPFX(DPFPREP, 3,"Canceling outstanding operations");
	hResultCode = DNCancelActiveCommands(pdnObject,(  DN_CANCEL_FLAG_ENUM_QUERY
													| DN_CANCEL_FLAG_ENUM_RESPONSE
													| DN_CANCEL_FLAG_USER_SEND
													| DN_CANCEL_FLAG_INTERNAL_SEND
													| DN_CANCEL_FLAG_RECEIVE_BUFFER
#ifndef DPNBUILD_NOMULTICAST
													| DN_CANCEL_FLAG_JOIN
#endif // ! DPNBUILD_NOMULTICAST
													),
													NULL,
													FALSE,
													0);
	DPFX(DPFPREP, 3,"Canceling outstanding operations returned [0x%lx]",hResultCode);

	//
	//	Cancel any REQUESTs
	//
	DPFX(DPFPREP, 3,"Canceling requests");
	hResultCode = DNCancelRequestCommands(pdnObject);
	DPFX(DPFPREP, 3,"Canceling requests returned [0x%lx]",hResultCode);

#ifndef DPNBUILD_NOMULTICAST
	//
	//	Disconnect from multicast group
	//
	DPFX(DPFPREP, 3,"Disconnecting from multicast group");
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pBilink = pdnObject->m_bilinkMulticast.GetNext();
	while (pBilink != &pdnObject->m_bilinkMulticast)
	{
		pConnection = CONTAINING_OBJECT(pBilink,CConnection,m_bilinkMulticast);
		pConnection->m_bilinkMulticast.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		pConnection->Disconnect();
		pConnection->Release();
		pConnection = NULL;
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
		pBilink = pdnObject->m_bilinkMulticast.GetNext();
	}

	if (pdnObject->pMulticastSend)
	{
		pConnection = pdnObject->pMulticastSend;
		pdnObject->pMulticastSend = NULL;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	if (pConnection)
	{
		pConnection->Disconnect();
		pConnection->Release();
		pConnection = NULL;
	}
	DNASSERT(pConnection == NULL);
#endif	// DPNBUILD_NOMULTICAST

	//
	//	Terminate session.  This will remove all players from the NameTable
	//
	DPFX(DPFPREP, 3,"Terminate Session");
	if ((hResultCode = DNTerminateSession(pdnObject,DPN_OK)) != DPN_OK)
	{
		DPFERR("Could not terminate session");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
	}

	//
	//	Disconnect any indicated connections
	//
	DNEnterCriticalSection(&pdnObject->csConnectionList);
	while (pdnObject->m_bilinkIndicated.GetNext() != &pdnObject->m_bilinkIndicated)
	{
		pConnection = CONTAINING_OBJECT(pdnObject->m_bilinkIndicated.GetNext(),CConnection,m_bilinkIndicated);
		pConnection->m_bilinkIndicated.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csConnectionList);

		DNASSERT(pConnection->GetDPNID() == 0);

		pConnection->Disconnect();
		pConnection->Release();
		pConnection = NULL;

		DNEnterCriticalSection(&pdnObject->csConnectionList);
	}
	DNLeaveCriticalSection(&pdnObject->csConnectionList);

#if ((! defined(DPNBUILD_LIBINTERFACE)) || (! defined(DPNBUILD_ONLYONESP)))
	//
	//	Release SP's
	//
	DPFX(DPFPREP, 3,"Releasing SPs");
	DN_SPReleaseAll(pdnObject);
#endif // ! DPNBUILD_LIBINTERFACE or ! DPNBUILD_ONLYONESP

	//
	//	Shut down protocol
	//
	DPFX(DPFPREP, 3,"Shutting down Protocol");
	DNProtocolRelease(pdnObject);
	pdnObject->hProtocolShutdownEvent->WaitForEvent();
#if ((! defined(DPNBUILD_LIBINTERFACE)) || (! defined(DPNBUILD_ONLYONESP)))
	if ((hResultCode = DNPProtocolShutdown(pdnObject->pdnProtocolData)) != DPN_OK)
	{
		DPFERR("Could not shut down Protocol Layer !");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
	}
#endif // ! DPNBUILD_LIBINTERFACE or ! DPNBUILD_ONLYONESP
	pdnObject->hProtocolShutdownEvent->ReturnSelfToPool();
	pdnObject->hProtocolShutdownEvent = NULL;


#ifndef	DPNBUILD_NONSEQUENTIALWORKERQUEUE
	//
	//	Wait for thread pool to be done
	//
	DNThreadPoolRelease(pdnObject);
	pdnObject->ThreadPoolShutDownEvent->WaitForEvent();
	pdnObject->ThreadPoolShutDownEvent->ReturnSelfToPool();
	pdnObject->ThreadPoolShutDownEvent = NULL;
#endif	// DPNBUILD_NONSEQUENTIALWORKERQUEUE

	//
	//	The threadpool interface always exists for the life of the object.
	//
	DNASSERT(pdnObject->pIDPThreadPoolWork != NULL);

	//
	//	Deinitialize HandleTable
	//
	DPFX(DPFPREP, 3,"Deinitializing HandleTable");
	pdnObject->HandleTable.Deinitialize();

	//
	//	Reset NameTable
	//
	DPFX(DPFPREP, 3,"Resetting NameTable");
	pdnObject->NameTable.ResetNameTable();
	
	//
	//	Deinitialize ApplicationDescription
	//
	DPFX(DPFPREP, 3,"Deinitializing ApplicationDesc");
	pdnObject->ApplicationDesc.Deinitialize();

	//
	//	Any pending NameTable operations
	//
	pBilink = pdnObject->m_bilinkPendingDeletions.GetNext();
	while (pBilink != &pdnObject->m_bilinkPendingDeletions)
	{
		pPending = CONTAINING_OBJECT(pBilink,CPendingDeletion,m_bilinkPendingDeletions);
		pBilink = pBilink->GetNext();
		pPending->m_bilinkPendingDeletions.RemoveFromList();
		pPending->ReturnSelfToPool();
		pPending = NULL;
	}

	//
	//	Misc Clean Up
	//
	if (pdnObject->pIDP8ADevice)
	{
		IDirectPlay8Address_Release(pdnObject->pIDP8ADevice);
		pdnObject->pIDP8ADevice = NULL;
	}
	if (pdnObject->pvConnectData)
	{
		DNFree(pdnObject->pvConnectData);
		pdnObject->pvConnectData = NULL;
		pdnObject->dwConnectDataSize = 0;
	}

	if( pdnObject->pConnectAddress )
	{
		IDirectPlay8Address_Release( pdnObject->pConnectAddress );
		pdnObject->pConnectAddress = NULL;
	}

#ifndef DPNBUILD_NOVOICE
	if( pdnObject->pTargetList )
	{
		delete [] pdnObject->pTargetList;
		pdnObject->pTargetList = NULL;
	}

	if( pdnObject->pExpandedTargetList )
	{
		delete [] pdnObject->pExpandedTargetList;
		pdnObject->pExpandedTargetList = NULL;
	}	
#endif // !DPNBUILD_NOVOICE

#ifndef DPNBUILD_NOLOBBY
	pdnObject->dpnhLobbyConnection = NULL;

	// Release our hold on the lobbiedapplication
	if( pdnObject->pIDP8LobbiedApplication) 
	{
		IDirectPlay8LobbiedApplication_Release(pdnObject->pIDP8LobbiedApplication);
		pdnObject->pIDP8LobbiedApplication = NULL;
	}
#endif // ! DPNBUILD_NOLOBBY

	//
	//	Reset DirectNet object flag
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pdnObject->dwFlags &= (~( DN_OBJECT_FLAG_INITIALIZED
							| DN_OBJECT_FLAG_CLOSING
//							| DN_OBJECT_FLAG_DISCONNECTING
//							| DN_OBJECT_FLAG_HOST_CONNECTED
							| DN_OBJECT_FLAG_LOCALHOST ));
	pdnObject->dwMaxFrameSize = 0;
	pdnObject->dwClosingThreadID = 0;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

Exit:
	DNASSERT( pAsyncOp == NULL );
	DNASSERT( pConnection == NULL );
	DNASSERT( pSP == NULL );

	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	goto Exit;
}


//
// Enumerate SP's if no SPGUID supplied, or SP Adapters if an SPGUID is supplied
//

#undef DPF_MODNAME
#define DPF_MODNAME "DN_EnumServiceProviders"

STDMETHODIMP DN_EnumServiceProviders( PVOID pInterface,
									  const GUID *const pguidServiceProvider,
									  const GUID *const pguidApplication,
									  DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer,
									  DWORD *const pcbEnumData,
									  DWORD *const pcReturned,
									  const DWORD dwFlags )
{
#if ((defined(DPNBUILD_ONLYONEADAPTER)) || (defined(DPNBUILD_ONLYONESP)))
	DPFX(DPFPREP, 0, "Enumerating service providers or their adapters is not supported!");
	return DPNERR_UNSUPPORTED;
#else // ! DPNBUILD_ONLYONEADAPTER or ! DPNBUILD_ONLYONESP
	HRESULT		        hResultCode;
	PDIRECTNETOBJECT    pdnObject;

	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p], pguidServiceProvider [0x%p], pguidApplication [0x%p], pSPInfoBuffer [0x%p], pcbEnumData [0x%p], pcReturned [0x%p], dwFlags [0x%lx]",
		pInterface,pguidServiceProvider,pguidApplication,pSPInfoBuffer,pcbEnumData,pcReturned,dwFlags);

	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
	DNASSERT(pdnObject != NULL);

#ifndef	DPNBUILD_NOPARAMVAL
    if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    {
        if( FAILED( hResultCode = DN_ValidateEnumServiceProviders( pInterface, pguidServiceProvider, pguidApplication,
                                                                   pSPInfoBuffer, pcbEnumData, pcReturned, dwFlags ) ) )
        {
            DPFERR( "Error validating params" );
            DPF_RETURN(hResultCode);
        }
    }
#endif	// DPNBUILD_NOPARAMVAL

	if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED) )
	{
    	DPFERR( "Object is not initialized" );
    	DPF_RETURN( DPNERR_UNINITIALIZED );
	}  

	if (pguidServiceProvider == NULL)	// Enumerate all service providers
	{
#ifdef DPNBUILD_ONLYONESP
		DPFX(DPFPREP, 0, "Enumerating service providers not supported!");
		hResultCode = DPNERR_UNSUPPORTED;
#else // ! DPNBUILD_ONLYONESP
		hResultCode = DN_EnumSP(	pdnObject,
									dwFlags,
#ifndef DPNBUILD_LIBINTERFACE
									pguidApplication,
#endif // ! DPNBUILD_LIBINTERFACE
									pSPInfoBuffer,
									pcbEnumData,
									pcReturned);
#endif // ! DPNBUILD_ONLYONESP
	}
	else	// Service provider specified - enumerate adaptors
	{
#ifdef DPNBUILD_ONLYONEADAPTER
		DPFX(DPFPREP, 0, "Enumerating devices not supported!");
		hResultCode = DPNERR_UNSUPPORTED;
#else // ! DPNBUILD_ONLYONEADAPTER
		hResultCode = DN_EnumAdapters(	pdnObject,
										dwFlags,
										pguidServiceProvider,
#ifndef DPNBUILD_LIBINTERFACE
										pguidApplication,
#endif // ! DPNBUILD_LIBINTERFACE
										pSPInfoBuffer,
										pcbEnumData,
										pcReturned);
#endif // ! DPNBUILD_ONLYONEADAPTER
	}

	DPFX(DPFPREP, 3,"Set: *pcbEnumData [%ld], *pcReturned [%ld]",*pcbEnumData,*pcReturned);

	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
#endif // ! DPNBUILD_ONLYONEADAPTER or ! DPNBUILD_ONLYONESP
}


//
//	Cancel an outstanding Async Operation.  hAsyncHandle is the operation handle returned when
//	the operation was initiated.
//

#undef DPF_MODNAME
#define DPF_MODNAME "DN_CancelAsyncOperation"

STDMETHODIMP DN_CancelAsyncOperation(PVOID pvInterface,
									 const DPNHANDLE hAsyncOp,
									 const DWORD dwFlags)
{
	HRESULT				hResultCode;
	CNameTableEntry		*pNTEntry;
	CConnection			*pConnection;
	CAsyncOp			*pHandleParent;
	CAsyncOp			*pAsyncOp;
	DIRECTNETOBJECT		*pdnObject;

	DPFX(DPFPREP, 2,"Parameters: pvInterface [0x%p], hAsyncOp [0x%lx], dwFlags [0x%lx]",
			pvInterface,hAsyncOp,dwFlags);

    pdnObject = static_cast<DI