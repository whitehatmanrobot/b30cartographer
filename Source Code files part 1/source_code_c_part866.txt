ner;

        DC_END_FN();
    } /* UI_SetUIContainerWnd */


    /****************************************************************************/
    /* Name:      UI_GetUIContainerWindow                                       */
    /*                                                                          */
    /* Purpose:   Returns the UI Container Window Handle.                       */
    /*                                                                          */
    /* Returns:   UI Container Window Handle.                                   */
    /****************************************************************************/
    HWND DCAPI UI_GetUIContainerWindow()
    {
        HWND rc;

        DC_BEGIN_FN("UI_GetUIContainerWindow");

        TRC_ASSERT((_UI.hwndUIContainer != NULL),
                   (TB, _T("Container Window not set")));
        rc = _UI.hwndUIContainer;
        TRC_DBG((TB, _T("Return %p"), rc));

        DC_END_FN();
        return rc;
    } /* UI_GetUIContainerWnd */


    /****************************************************************************/
    /* Name:      UI_SetUIMainWindow                                            */
    /*                                                                          */
    /* Purpose:   Informs UT of the UI Main Window Handle.                      */
    /****************************************************************************/
    void DCAPI UI_SetUIMainWindow(HWND hwndUIMain)
    {
        DC_BEGIN_FN("UI_SetUIMainWindow");

        TRC_ASSERT((hwndUIMain != NULL),
                   (TB, _T("invalid (zero) Main Window handle")));
        TRC_ASSERT((_UI.hwndUIMain == NULL), (TB, _T("Set Main Window twice!")));

        _UI.hwndUIMain = hwndUIMain;

        DC_END_FN();
    } /* UI_SetUIMainWindow */


    /****************************************************************************/
    /* Name:      UI_GetUIMainWindow                                            */
    /*                                                                          */
    /* Purpose:   Returns the UI Main Window Handle.                            */
    /****************************************************************************/
    HWND DCAPI UI_GetUIMainWindow()
    {
        HWND rc;

        DC_BEGIN_FN("UI_GetUIMainWindow");

        TRC_ASSERT((_UI.hwndUIMain != NULL), (TB, _T("Main Window not set")));
        rc = _UI.hwndUIMain;
        TRC_DBG((TB, _T("return %p"), rc));

        DC_END_FN();
        return rc;
    } /* UI_GetUIMainWindow */


    /****************************************************************************/
    /* Name:      UI_SetClientMCSID                                             */
    /*                                                                          */
    /* Purpose:   Set our MCS User ID                                           */
    /****************************************************************************/
    DCVOID DCAPI UI_SetClientMCSID(DCUINT16 mcsID)
    {
        DC_BEGIN_FN("UI_SetClientMCSID");

        TRC_ASSERT((( mcsID == 0) || (_UI.clientMCSID == 0)),
                   (TB,_T("Attempting to set Client MCSID twice")));

        _UI.clientMCSID = mcsID;
        TRC_NRM((TB, _T("Client MCSID set to %#hx"), _UI.clientMCSID));

        DC_END_FN();
    } /* UI_SetClientMCSID */


    /****************************************************************************/
    /* Name:      UI_GetClientMCSID                                             */
    /*                                                                          */
    /* Purpose:   Return our MCS User ID                                        */
    /****************************************************************************/
    UINT16 DCAPI UI_GetClientMCSID()
    {
        DC_BEGIN_FN("UI_GetClientMCSID");

        TRC_ASSERT((_UI.clientMCSID != 0), (TB, _T("Client MCSID not set")));

        TRC_DBG((TB, _T("Return client MCSID %#hx"), _UI.clientMCSID));

        DC_END_FN();
        return _UI.clientMCSID;
    } /* UI_GetClientMCSID */


    /****************************************************************************/
    /* Name:      UI_SetServerMCSID                                             */
    /*                                                                          */
    /* Purpose:   Notify UT of the sever's MCS user ID                          */
    /****************************************************************************/
    void DCAPI UI_SetServerMCSID(UINT16 mcsID)
    {
        DC_BEGIN_FN("UI_SetServerMCSID");

        TRC_ASSERT(( ( mcsID == 0)
                     || ( _UI.serverMCSID == 0)
                     || ( _UI.serverMCSID == mcsID )),
                   (TB, _T("Attempting to set Server MCSID twice %#hx->%#hx"),
                    _UI.serverMCSID,
                    mcsID));

        _UI.serverMCSID = mcsID;
        TRC_NRM((TB, _T("Server MCSID set to %#hx"), _UI.serverMCSID));

        DC_END_FN();
    } /* UI_SetServerMCSID */


    /****************************************************************************/
    /* Name:      UI_GetServerMCSID                                             */
    /*                                                                          */
    /* Purpose:   Return the server's MCS user ID                               */
    /****************************************************************************/
    UINT16 DCAPI UI_GetServerMCSID()
    {
        DC_BEGIN_FN("UI_GetServerMCSID");

        TRC_ASSERT((_UI.serverMCSID != 0), (TB, _T("Server MCSID not set")));

        TRC_DBG((TB, _T("Return server MCSID %#hx"), _UI.serverMCSID));

        DC_END_FN();
        return _UI.serverMCSID;
    } /* UI_GetServerMCSID */


    /****************************************************************************/
    /* Name:      UI_SetDesktopSize                                             */
    /*                                                                          */
    /* Purpose:   Set the current desktop size                                  */
    /****************************************************************************/
    void DCAPI UI_SetDesktopSize(PDCSIZE pDesktopSize)
    {
        DC_BEGIN_FN("UI_SetDesktopSize");

        TRC_ASSERT((pDesktopSize->width != 0) && (pDesktopSize->height != 0),
                   (TB,_T("Invalid size; width(%u) height(%u)"),
                    pDesktopSize->width, pDesktopSize->height));

        TRC_NRM((TB, _T("New desktop size (%u x %u)"),
                 pDesktopSize->width, pDesktopSize->height));
        _UI.desktopSize = *pDesktopSize;

        DC_END_FN();
    } /* UI_SetDesktopSize */


    /****************************************************************************/
    /* Name:      UI_GetDesktopSize                                             */
    /*                                                                          */
    /* Purpose:   Return the current desktop size                               */
    /****************************************************************************/
    void DCAPI UI_GetDesktopSize(PDCSIZE pDesktopSize)
    {
        DC_BEGIN_FN("UI_GetDesktopSize");

        *pDesktopSize = _UI.desktopSize;

        DC_END_FN();
    } /* UI_GetDesktopSize */


#ifdef SMART_SIZING
    void UI_NotifyOfDesktopSizeChange(LPARAM size);
#endif

    /****************************************************************************/
    /* Name:      UI_SetColorDepth                                              */
    /*                                                                          */
    /* Purpose:   Set the current color depth                                   */
    /*                                                                          */
    /* Params:    colorDepth - new color depth                                  */
    /****************************************************************************/
    BOOL DCAPI UI_SetColorDepth(int colorDepth)
    {
        DC_BEGIN_FN("UI_SetColorDepth");

#ifdef DC_HICOLOR
        TRC_ASSERT(((colorDepth == 4) ||
                    (colorDepth == 8) ||
                    (colorDepth == 15) ||
                    (colorDepth == 16) ||
                    (colorDepth == 24)),
                         (TB,_T("Invalid color depth %d"), colorDepth));
        if(!((colorDepth == 4) ||
            (colorDepth == 8) ||
            (colorDepth == 15) ||
            (colorDepth == 16) ||
            (colorDepth == 24)))
        {
            return FALSE;
        }
#else
        TRC_ASSERT(((colorDepth == 4) || (colorDepth == 8)),
                   (TB,_T("Invalid color depth %d"), colorDepth));
#endif

        TRC_NRM((TB, _T("New color depth %d"), colorDepth));
        _UI.connectedColorDepth = colorDepth;

        DC_END_FN();
        return TRUE;
    } /* UI_SetColorDepth */


    /****************************************************************************/
    /* Name:      UI_GetColorDepth                                              */
    /*                                                                          */
    /* Purpose:   Return the current color depth                                */
    /****************************************************************************/
    int DCAPI UI_GetColorDepth()
    {
        DC_BEGIN_FN("UI_GetColorDepth");

        DC_END_FN();
        return _UI.connectedColorDepth;
    } /* UI_GetColorDepth */


    /****************************************************************************/
    /* Name:      UI_SetCoreInitialized                                         */
    /*                                                                          */
    /* Purpose:   Sets _UI.coreInitialized to TRUE                               */
    /****************************************************************************/
    void DCAPI UI_SetCoreInitialized()
    {
        DC_BEGIN_FN("UI_SetCoreInitialized");

        TRC_NRM((TB, _T("Setting _UI.coreInitialized to TRUE")));
        _UI.coreInitialized = TRUE;

        DC_END_FN();
    } /* UI_SetCoreInitialized */

    /****************************************************************************/
    /* Name:      UI_IsCoreInitialized                                          */
    /*                                                                          */
    /* Purpose:   Informs CO whether the core is initialized                    */
    /****************************************************************************/
    BOOL DCAPI UI_IsCoreInitialized()
    {
        DC_BEGIN_FN("UI_IsCoreInitialized");
        DC_END_FN();
        return _UI.coreInitialized;
    } /* UI_IsCoreInitialized */


    /****************************************************************************/
    /* Name:      UI_SetShareID                                                 */
    /*                                                                          */
    /* Purpose:   Save the share ID                                             */
    /****************************************************************************/
    void DCAPI UI_SetShareID(UINT32 shareID)
    {
        DC_BEGIN_FN("UI_SetShareID");

        TRC_NRM((TB, _T("Setting _UI.shareID to 0x%x"), shareID));
        _UI.shareID = shareID;

        DC_END_FN();
    } /* UI_SetShareID */


    /****************************************************************************/
    /* Name:      UI_GetShareID                                                 */
    /****************************************************************************/
    UINT32 DCAPI UI_GetShareID()
    {
        DC_BEGIN_FN("UI_GetShareID");
        DC_END_FN();
        return _UI.shareID;
    } /* UI_GetShareID */


    /****************************************************************************/
    /* Name:      UI_SetChannelID                                               */
    /*                                                                          */
    /* Purpose:   Save the channel                                              */
    /****************************************************************************/
    void DCAPI UI_SetChannelID(unsigned channelID)
    {
        DC_BEGIN_FN("UI_SetChannelID");

        /************************************************************************/
        /* We should only be setting the shareID if currently it has not        */
        /* been set ( = 0 ) and the new value is valid ( != 0 ) OR              */
        /* the current value is valid ( != 0) and the new value is not valid    */
        /* ( =0 )                                                               */
        /************************************************************************/
        TRC_ASSERT((channelID == 0) || (_UI.channelID == 0),
                   (TB, _T("Already set Channel ID (%#x)"), _UI.channelID));

        TRC_NRM((TB, _T("Setting _UI.channelId to %d"), channelID));
        _UI.channelID = channelID;

        DC_END_FN();
    } /* UI_SetChannelID */


    /****************************************************************************/
    /* Name:      UI_GetChannelID                                               */
    /*                                                                          */
    /* Purpose:   Get the share channel ID                                      */
    /****************************************************************************/
    unsigned DCAPI UI_GetChannelID()
    {
        DC_BEGIN_FN("UI_GetChannelID");

        TRC_ASSERT((_UI.channelID != 0), (TB, _T("Channel ID not set yet")));

        DC_END_FN();
        return _UI.channelID;
    } /* UI_GetChannelID */


    /****************************************************************************/
    /* Name:      UI_GetOsMinorType                                             */
    /*                                                                          */
    /* Purpose:   Get the OS type                                               */
    /*                                                                          */
    /* Returns:   OS type (one of the TS_OSMINORTYPE constants)                 */
    /****************************************************************************/
    unsigned DCAPI UI_GetOsMinorType()
    {
        unsigned rc;

        DC_BEGIN_FN("UI_GetOsMinorType");

        rc = _UI.osMinorType;

        DC_END_FN();
        return rc;
    } /* UI_GetOsMinorType */


    /****************************************************************************/
    /* Name:      UI_SetDisableCtrlAltDel                                       */
    /*                                                                          */
    /* Purpose:   Save the fDisableCtrlAltDel flag                              */
    /*                                                                          */
    /* Params:    IN     fDisableCtrlAltDel                                     */
    /****************************************************************************/
    void DCAPI UI_SetDisableCtrlAltDel(BOOL fDisableCtrlAltDel)
    {
        DC_BEGIN_FN("UI_SetDisableCtrlAltDel");

        TRC_NRM((TB, _T("Setting _UI.fDisableCtrlAltDel to %d"), fDisableCtrlAltDel));
        _UI.fDisableCtrlAltDel = fDisableCtrlAltDel;

        DC_END_FN();
    } /* UI_SetDisableCtrlAltDel */


    /****************************************************************************/
    /* Name:      UI_GetDisableCtrlAltDel                                       */
    /*                                                                          */
    /* Purpose:   Get the fDisableCtrlAltDel flag                               */
    /****************************************************************************/
    BOOL DCAPI UI_GetDisableCtrlAltDel()
    {
        DC_BEGIN_FN("UI_GetDisableCtrlAltDel");
        DC_END_FN();
        return _UI.fDisableCtrlAltDel;
    } /* UI_GetDisableCtrlAltDel */

#ifdef SMART_SIZING
    /****************************************************************************/
    /* Name:      UI_GetSmartSizing
    /*
    /* Purpose:   Get the fSmartSizing flag
    /****************************************************************************/
    BOOL DCAPI UI_GetSmartSizing()
    {
        DC_BEGIN_FN("UI_GetSmartSizing");
        DC_END_FN();
        return _UI.fSmartSizing;
    } /* UI_GetSmartSizing */
#endif // SMART_SIZING

    /****************************************************************************/
    /* Name:      UI_SetEnableWindowsKey                                        */
    /*                                                                          */
    /* Purpose:   Save the fEnableWindowsKey flag                               */
    /****************************************************************************/
    void DCAPI UI_SetEnableWindowsKey(BOOL fEnableWindowsKey)
    {
        DC_BEGIN_FN("UI_SetEnableWindowsKey");

        TRC_NRM((TB, _T("Setting _UI.fEnableWindowsKey to %d"), fEnableWindowsKey));
        _UI.fEnableWindowsKey = fEnableWindowsKey;

        DC_END_FN();
    } /* UI_SetEnableWindowsKey */


    /****************************************************************************/
    /* Name:      UI_GetEnableWindowsKey                                        */
    /*                                                                          */
    /* Purpose:   Get the fEnableWindowsKey flag                                */
    /*                                                                          */
    /* Returns:   Flag state t/f                                                */
    /****************************************************************************/
    BOOL DCAPI UI_GetEnableWindowsKey()
    {
        DC_BEGIN_FN("UI_GetEnableWindowsKey");
        DC_END_FN();
        return _UI.fEnableWindowsKey;
    } /* UI_GetEnableWindowsKey */


    /****************************************************************************/
    /* Name:      UI_SetMouse                                                   */
    /*                                                                          */
    /* Purpose:   Save the fMouse flag                                          */
    /****************************************************************************/
    void DCAPI UI_SetMouse(BOOL fMouse)
    {
        DC_BEGIN_FN("UI_SetMouse");

        TRC_NRM((TB, _T("Setting _UI.fMouse to %d"), fMouse));
        _UI.fMouse = fMouse;

        DC_END_FN();
    } /* UI_SetMouse */


    /****************************************************************************/
    /* Name:      UI_GetMouse                                                   */
    /*                                                                          */
    /* Purpose:   Get the fMouse flag                                           */
    /****************************************************************************/
    BOOL DCAPI UI_GetMouse()
    {
        DC_BEGIN_FN("UI_GetMouse");
        DC_END_FN();
        return _UI.fMouse;
    } /* UI_GetMouse */


    /****************************************************************************/
    /* Name:      UI_SetDoubleClickDetect                                       */
    /*                                                                          */
    /* Purpose:   Save the fDoubleClickDetect flag                              */
    /*                                                                          */
    /* Params:    IN     fDoubleClickDetect                                     */
    /****************************************************************************/
    DCVOID DCAPI UI_SetDoubleClickDetect(DCBOOL fDoubleClickDetect)
    {
        DC_BEGIN_FN("UI_SetDoubleClickDetect");

        TRC_NRM((TB, _T("Setting _UI.fDoubleClickDetect to %d"), fDoubleClickDetect));
        _UI.fDoubleClickDetect = fDoubleClickDetect;

        DC_END_FN();
    } /* UI_SetDoubleClickDetect */


    /****************************************************************************/
    /* Name:      UI_GetDoubleClickDetect                                       */
    /*                                                                          */
    /* Purpose:   Get the fDoubleClickDetect flag                               */
    /****************************************************************************/
    DCBOOL DCAPI UI_GetDoubleClickDetect(DCVOID)
    {
        DCBOOL  fDoubleClickDetect;

        DC_BEGIN_FN("UI_GetDoubleClickDetect");

        fDoubleClickDetect = _UI.fDoubleClickDetect;

        DC_END_FN();
        return(fDoubleClickDetect);
    } /* UI_GetDoubleClickDetect */


    /****************************************************************************/
    /* Name:      UI_SetSessionId                                               */
    /*                                                                          */
    /* Purpose:   Save the SessionId                                            */
    /*                                                                          */
    /* Params:    IN     SessionId                                              */
    /****************************************************************************/
    DCVOID DCAPI UI_SetSessionId(DCUINT32  SessionId)
    {
        DC_BEGIN_FN("UI_SetSessionId");

        _UI.SessionId = SessionId;

        DC_END_FN();
    } /* UI_SetSessionId */


    /****************************************************************************/
    /* Name:      UI_GetSessionId                                               */
    /*                                                                          */
    /* Purpose:   Get the SessionId                                             */
    /*                                                                          */
    /* Returns:   SessionId                                                     */
    /****************************************************************************/
    DCUINT32 DCAPI UI_GetSessionId(DCVOID)
    {
        DC_BEGIN_FN("UI_GetSessionId");

        DC_END_FN();
        return _UI.SessionId;
    } /* UI_GetSessionId */


    /****************************************************************************/
    /* Name:      UI_SetDomain                                                  */
    /*                                                                          */
    /* Purpose:   Save the Domain                                               */
    /*                                                                          */
    /* Params:    IN     Domain                                                 */
    /****************************************************************************/
    HRESULT DCAPI UI_SetDomain(PDCWCHAR Domain)
    {
        HRESULT hr;
        DC_BEGIN_FN("UI_SetDomain");

        hr = StringCchCopyW(_UI.Domain,
                       SIZE_TCHARS(_UI.Domain),
                       Domain);
        if (FAILED(hr)) {
            TRC_ERR((TB,_T("Error copying domain string: 0x%x"),hr));
        }

        DC_END_FN();
        return hr;
    } /* UI_SetDomain */


    /****************************************************************************/
    /* Name:      UI_GetDomain                                                  */
    /*                                                                          */
    /* Purpose:   Get the Domain                                                */
    /*                                                                          */
    /* Returns:   Domain                                                        */
    /*                                                                          */
    /* Params:    OUT   buffer to return Domain into                            */
    /*            IN    size of return buffer                                   */
    /****************************************************************************/
    DCVOID DCAPI UI_GetDomain(PDCUINT8 Domain, DCUINT size)
    {
        DC_BEGIN_FN("UI_GetDomain");

        if (sizeof(_UI.Domain) < size)
            size = sizeof(_UI.Domain);
        DC_MEMCPY(Domain, _UI.Domain, size-1);

        DC_END_FN();
    } /* UI_GetDomain */

    /****************************************************************************/
    /* Name:      UI_SetUseRedirectionUserName                                  */
    /*                                                                          */
    /* Purpose:   Sets the UseRedirectionUserName flag                          */
    /*                                                                          */
    /* Params:    IN     UserName                                               */
    /****************************************************************************/
    _inline DCVOID DCAPI UI_SetUseRedirectionUserName(BOOL bVal)
    {
        _UI.UseRedirectionUserName = bVal;
    }
    
    /****************************************************************************/
    /* Name:      UI_GetUseRedirectionUserName                                  */
    /*                                                                          */
    /* Purpose:   Returns the UseRedirectionUserName flag                       */
    /*                                                                          */
    /****************************************************************************/
    _inline BOOL DCAPI UI_GetUseRedirectionUserName()
    {
        return _UI.UseRedirectionUserName;
    }

    /****************************************************************************/
    /* Name:      UI_SetUseSmartcardLogon                                       */
    /*                                                                          */
    /* Purpose:   Sets the UseSmartcardLogon flag                               */
    /*                                                                          */
    /* Params:    IN     UseSmartcardLogon                                      */
    /****************************************************************************/
    _inline DCVOID DCAPI UI_SetUseSmartcardLogon(BOOL bVal)
    {
        _UI.fUseSmartcardLogon = bVal;
    }

    /****************************************************************************/
    /* Name:      UI_GetUseSmartcardLogon                                       */
    /*                                                                          */
    /* Purpose:   Returns the UseSmartcardLogon flag                            */
    /*                                                                          */
    /****************************************************************************/
    _inline BOOL DCAPI UI_GetUseSmartcardLogon()
    {
        return _UI.fUseSmartcardLogon;
    }

    /****************************************************************************/
    /* Name:      UI_SetUserName                                                */
    /*                                                                          */
    /* Purpose:   Save the UserName                                             */
    /*                                                                          */
    /* Params:    IN     UserName                                               */
    /****************************************************************************/
    DCVOID DCAPI UI_SetUserName(PDCWCHAR UserName)
    {
        HRESULT hr;
        DC_BEGIN_FN("UI_SetUserName");
        
        UI_SetUseRedirectionUserName(FALSE);
        
        hr = StringCchCopyW(_UI.UserName,
                       SIZE_TCHARS(_UI.UserName),
                       UserName);
        if (FAILED(hr)) {
            TRC_ERR((TB,_T("Error copying username string: 0x%x"),hr));
        }

        DC_END_FN();
    } /* UI_SetUserName */


    /****************************************************************************/
    /* Name:      UI_GetUserName                                                */
    /*                                                                          */
    /* Purpose:   Get the UserName                                              */
    /*                                                                          */
    /* Returns:   UserName                                                      */
    /*                                                                          */
    /* Params:    OUT   buffer to return UserName into                          */
    /*            IN    size of return buffer                                   */
    /****************************************************************************/
    DCVOID DCAPI UI_GetUserName(PDCUINT8 UserName, DCUINT size)
    {
        DC_BEGIN_FN("UI_GetUserName");

        if (sizeof(_UI.UserName) < size)
            size = sizeof(_UI.UserName);
        DC_MEMCPY(UserName, _UI.UserName, size-1);

        DC_END_FN();
    } /* UI_GetUserName */

    /****************************************************************************/
    /* Name:      UI_SetRedirectionUserName                                     */
    /*                                                                          */
    /* Purpose:   Save the RedirectionUserName                                  */
    /*                                                                          */
    /* Params:    IN     RedirectionUserName                                    */
    /****************************************************************************/
    DCVOID DCAPI UI_SetRedirectionUserName(PDCWCHAR RedirectionUserName)
    {
        HRESULT hr;
        DC_BEGIN_FN("UI_SetRedirectionUserName");
        
        UI_SetUseRedirectionUserName(TRUE);
        
        hr = StringCchCopyW(_UI.RedirectionUserName,
                       SIZE_TCHARS(_UI.RedirectionUserName),
                       RedirectionUserName);
        if (FAILED(hr)) {
            TRC_ERR((TB,_T("Error copying username string: 0x%x"),hr));
        }

        DC_END_FN();
    } /* UI_SetRedirectionUserName */


    /****************************************************************************/
    /* Name:      UI_GetRedirectionUserName                                     */
    /*                                                                          */
    /* Purpose:   Get the RedirectionUserName                                   */
    /*                                                                          */
    /* Returns:   RedirectionUserName                                           */
    /*                                                                          */
    /* Params:    OUT   buffer to return RedirectionUserName into               */
    /*            IN    size of return buffer                                   */
    /****************************************************************************/
    DCVOID DCAPI UI_GetRedirectionUserName(PDCUINT8 RedirectionUserName, DCUINT size)
    {
        DC_BEGIN_FN("UI_GetRedirectionUserName");

        if (sizeof(_UI.RedirectionUserName) < size)
            size = sizeof(_UI.RedirectionUserName);
        DC_MEMCPY(RedirectionUserName, _UI.RedirectionUserName, size-1);

        DC_END_FN();
    } /* UI_GetRedirectionUserName */

    /****************************************************************************/
    /* Set and get load balance info, check if redirected                       */
    /****************************************************************************/
    BOOL DCAPI UI_SetLBInfo(PBYTE, unsigned);
    BSTR DCAPI UI_GetLBInfo()
    {
        return _UI.bstrScriptedLBInfo;
    }

    BOOL DCAPI UI_IsClientRedirected()
    {
        return _UI.ClientIsRedirected;
    }


    BSTR DCAPI UI_GetRedirectedLBInfo()
    {
        return _UI.bstrRedirectionLBInfo;
    }

    /****************************************************************************/
    /* Set and get to inform activeX control about TS public key                */
    /****************************************************************************/
    DCBOOL DCAPI UI_GetNotifyTSPublicKey()
    {
#ifdef REDIST_CONTROL
        return FALSE;
#else
        return _UI.fNotifyTSPublicKey;
#endif
    }

    VOID DCAPI UI_SetNotifyTSPublicKey(BOOL fNotify)
    {
#ifndef REDIST_CONTROL
        _UI.fNotifyTSPublicKey = fNotify;
#endif
        return;
    }
    
    /****************************************************************************/
    /* Name:      UI_GetUserName                                                */
    /*                                                                          */
    /* Purpose:   Instruct UI to connect with already connected socket          */
    /*            go thru normal connect sequence                               */
    /*                                                                          */
    /* Returns:   TRUE/FALSE                                                    */
    /*                                                                          */
    /* Params:    tdSocket : Valid connected socket or INVALID_SOCKET           */
    /*                                                                          */
    /* NOTE : Salem specific call                                               */
    /****************************************************************************/
    DCBOOL DCAPI SetConnectWithEndpoint( SOCKET tdSocket )
    {

#if REDIST_CONTROL

        return FALSE;

#else

        DCBOOL fStatus = TRUE;
        
        DC_BEGIN_FN("SetConnectWithEndpoint");

        //
        // Salem pass connected socket before actually invoke
        // connect(), at that point connectionStatus is 
        // UI_STATUS_INITIALIZING
        //
        if( _UI.connectionStatus == UI_STATUS_INITIALIZING ||
            _UI.connectionStatus == UI_STATUS_DISCONNECTED )
        {
            if( INVALID_SOCKET == tdSocket )
            {
                // reset back to default.
                UI_SetConnectionMode( CONNECTIONMODE_INITIATE );
            }
            else
            {
                UI_SetConnectionMode( CONNECTIONMODE_CONNECTEDENDPOINT );
                _UI.TDSocket = tdSocket;
            }
        }
        else
        {
            fStatus = FALSE;
        }

        DC_END_FN();
        return fStatus;

#endif
    }

    /****************************************************************************/
    /* Name:      UI_GetConnectionMode                                             */
    /*                                                                          */
    /* Purpose:   Set current connecting mode                                   */
    /****************************************************************************/
    _inline CONNECTIONMODE DCAPI UI_GetConnectionMode()
    {
        CONNECTIONMODE connMode;

        DC_BEGIN_FN("UI_GetConnectMode");
        connMode = _UI.ConnectMode;
        DC_END_FN();
        return connMode;
    } /* UI_SetConnectMode */

    /****************************************************************************/
    /* Name:      UI_SetConnectMode                                             */
    /*                                                                          */
    /* Purpose:   Set current connecting mode                                   */
    /****************************************************************************/
    _inline DCVOID DCAPI UI_SetConnectionMode(CONNECTIONMODE connMode)
    {
        DC_BEGIN_FN("UI_SetConnectionMode");
       _UI.ConnectMode = connMode;
        DC_END_FN();
    } /* UI_SetConnectMode */

    /****************************************************************************/
    /* Name:      UI_SetPassword                                                */
    /*                                                                          */
    /* Purpose:   Save the Password                                             */
    /*                                                                          */
    /* Params:    IN     Password                                               */
    /****************************************************************************/
    DCVOID DCAPI UI_SetPassword(PDCUINT8 Password)
    {
        DC_BEGIN_FN("UI_SetPassword");

        DC_MEMCPY(_UI.Password, Password, sizeof(_UI.Password));

        DC_END_FN();
    } /* UI_SetPassword */


    /****************************************************************************/
    /* Name:      UI_GetPassword                                                */
    /*                                                                          */
    /* Purpose:   Get the Password                                              */
    /*                                                                          */
    /* Returns:   Password                                                      */
    /*                                                                          */
    /* Params:    OUT   buffer to return Password into                          */
    /*            IN    size of return buffer                                   */
    /****************************************************************************/
    DCVOID DCAPI UI_GetPassword(PDCUINT8 Password, DCUINT size)
    {
        DC_BEGIN_FN("UI_GetPassword");

        if (sizeof(_UI.Password) < size)
            size = sizeof(_UI.Password);
        DC_MEMCPY(Password, _UI.Password, size);

        DC_END_FN();
    } /* UI_GetPassword */


    /****************************************************************************/
    /* Name:      UI_SetSalt                                                    */
    /*                                                                          */
    /* Purpose:   Save the Salt                                                 */
    /*                                                                          */
    /* Params:    IN     Salt                                                   */
    /****************************************************************************/
    DCVOID DCAPI UI_SetSalt(PDCUINT8 Salt)
    {
        DC_BEGIN_FN("UI_SetSalt");

        DC_MEMCPY(_UI.Salt, Salt, sizeof(_UI.Salt));

        DC_END_FN();
    } /* UI_SetSalt */


    /****************************************************************************/
    /* Name:      UI_GetSalt                                                    */
    /*                                                                          */
    /* Purpose:   Get the Salt                                                  */
    /*                                                                          */
    /* Returns:   Salt                                                          */
    /*                                                                          */
    /* Params:    OUT   buffer to return Salt into                              */
    /*            IN    size of return buffer                                   */
    /*                                                                          */
    /****************************************************************************/
    DCVOID DCAPI UI_GetSalt(PDCUINT8 Salt, DCUINT size)
    {
        DC_BEGIN_FN("UI_GetSalt");

        if (sizeof(_UI.Salt) < size)
            size = sizeof(_UI.Salt);
        DC_MEMCPY(Salt, _UI.Salt, size);

        DC_END_FN();
    } /* UI_GetSalt */


    /****************************************************************************/
    /* Name:      UI_SetAlternateShell                                          */
    /*                                                                          */
    /* Purpose:   Save the AlternateShell                                       */
    /*                                                                          */
    /* Params:    IN     AlternateShell                                         */
    /****************************************************************************/
    HRESULT DCAPI UI_SetAlternateShell(PDCWCHAR AlternateShell)
    {
        HRESULT hr;
        DC_BEGIN_FN("UI_SetAlternateShell");

        hr = StringCchCopyW(_UI.AlternateShell,
                       SIZE_TCHARS(_UI.AlternateShell),
                       AlternateShell);
        if (FAILED(hr)) {
            TRC_ERR((TB,_T("Error copying alternate shell string: 0x%x"),hr));
        }

        DC_END_FN();
        return hr;
    } /* UI_SetAlternateShell */


    /****************************************************************************/
    /* Name:      UI_GetAlternateShell                                          */
    /*                                                                          */
    /* Purpose:   Get the AlternateShell                                        */
    /*                                                                          */
    /* Returns:   AlternateShell                                                */
    /*                                                                          */
    /* Params:    OUT   buffer to return AlternateShell into                    */
    /*            IN    size of return buffer                                   */
    /****************************************************************************/
    DCVOID DCAPI UI_GetAlternateShell(PDCUINT8 AlternateShell, DCUINT size)
    {
        DC_BEGIN_FN("UI_GetAlternateShell");

        if (sizeof(_UI.AlternateShell) < size)
            size = sizeof(_UI.AlternateShell);
        DC_MEMCPY(AlternateShell, _UI.AlternateShell, size-1);

        DC_END_FN();
    } /* UI_GetAlternateShell */


    /****************************************************************************/
    /* Name:      UI_SetWorkingDir                                              */
    /*                                                                          */
    /* Purpose:   Save the WorkingDir                                           */
    /****************************************************************************/
    HRESULT DCAPI UI_SetWorkingDir(PDCWCHAR WorkingDir)
    {
        HRESULT hr;
        DC_BEGIN_FN("UI_SetWorkingDir");

        hr = StringCchCopyW(_UI.WorkingDir,
                       SIZE_TCHARS(_UI.WorkingDir),
                       WorkingDir);
        if (FAILED(hr)) {
            TRC_ERR((TB,_T("Error copying WorkingDir string: 0x%x"),hr));
        }

        DC_END_FN();
        return hr;
    } /* UI_SetWorkingDir */


    /****************************************************************************/
    /* Name:      UI_GetWorkingDir                                              */
    /*                                                                          */
    /* Purpose:   Get the WorkingDir                                            */
    /*                                                                          */
    /* Returns:   WorkingDir                                                    */
    /*                                                                          */
    /* Params:    OUT   buffer to return WorkingDir into                        */
    /*            IN    size of return buffer                                   */
    /****************************************************************************/
    DCVOID DCAPI UI_GetWorkingDir(PDCUINT8 WorkingDir, DCUINT size)
    {
        DC_BEGIN_FN("UI_GetWorkingDir");

        if (sizeof(_UI.WorkingDir) < size)
            size = sizeof(_UI.WorkingDir);

        DC_MEMCPY(WorkingDir, _UI.WorkingDir, size-1);

        DC_END_FN();
    } /* UI_GetWorkingDir */


    /****************************************************************************/
    /* Name:      UI_SetAutoLogon                                               */
    /*                                                                          */
    /* Purpose:   Save whether we automatically logon                           */
    /****************************************************************************/
    DCVOID DCAPI UI_SetAutoLogon(DCUINT AutoLogon)
    {
        DC_BEGIN_FN("UI_SetAutoLogon");

        TRC_NRM((TB, _T("Setting _UI.AutoLogon to %d"), AutoLogon));
        _UI.fAutoLogon = AutoLogon;

        DC_END_FN();
    } /* UI_SetAutoLogon */


    /****************************************************************************/
    /* Name:      UI_GetAutoLogon                                               */
    /*                                                                          */
    /* Purpose:   Get whether we automatically logon                            */
    /*                                                                          */
    /* Returns:   autlogon flag                                                 */
    /****************************************************************************/
    DCUINT DCAPI UI_GetAutoLogon(DCVOID)
    {
        DCUINT  rc;

        DC_BEGIN_FN("UI_GetAutoLogon");

        rc = _UI.fAutoLogon;

        DC_END_FN();
        return(rc);
    } /* UI_GetAutoLogon */


    /****************************************************************************/
    /* Name:      UI_SetMaximizeShell                                           */
    /*                                                                          */
    /* Purpose:   Save whether we Maximize the shell application                */
    /*                                                                          */
    /* Params:    IN     MaximizeShell                                          */
    /****************************************************************************/
    DCVOID DCAPI UI_SetMaximizeShell(DCUINT MaximizeShell)
    {
        DC_BEGIN_FN("UI_SetMaximizeShell");

        TRC_NRM((TB, _T("Setting _UI.fMaximizeShell to %d"), MaximizeShell));
        _UI.fMaximizeShell = MaximizeShell;

        DC_END_FN();
    } /* UI_SetMaximizeShell */


    /****************************************************************************/
    /* Name:      UI_GetMaximizeShell                                           */
    /*                                                                          */
    /* Purpose:   Get whether we Maximize the shell application                 */
    /*                                                                          */
    /* Returns:   MaximizeShell flag                                            */
    /****************************************************************************/
    DCUINT DCAPI UI_GetMaximizeShell(DCVOID)
    {
        DCUINT  rc;

        DC_BEGIN_FN("UI_GetMaximizeShell");

        rc = _UI.fMaximizeShell;

        DC_END_FN();
        return(rc);
    } /* UI_GetMaximizeShell */

    /****************************************************************************/
    /* Name:      UI_SetBitmapPersistence                                       */
    /*                                                                          */
    /* Purpose:   Save the fBitmapPersistence flag                              */
    /*                                                                          */
    /* Params:    IN     fBitmapPersistence                                     */
    /****************************************************************************/
    DCVOID DCAPI UI_SetBitmapPersistence(DCBOOL fBitmapPersistence)
    {
        DC_BEGIN_FN("UI_SetBitmapPersistence");

        TRC_NRM((TB, _T("Setting _UI.fBitmapPersistence to %d"), fBitmapPersistence));
        _UI.fBitmapPersistence = fBitmapPersistence;

        DC_END_FN();
    } /* UI_SetBitmapPersistence */


    /****************************************************************************/
    /* Name:      UI_GetBitmapPersistence                                       */
    /*                                                                          */
    /* Purpose:   Get the fBitmapPersistence                                    */
    /****************************************************************************/
    DCBOOL DCAPI UI_GetBitmapPersistence(DCVOID)
    {
        DC_BEGIN_FN("UI_GetBitmapPersistence");

        DC_END_FN();
        return _UI.fBitmapPersistence;
    } /* UI_GetBitmapPersistence */


    /****************************************************************************/
    /* Name:      UI_SetMCSPort                                                 */
    /*                                                                          */
    /* Purpose:   Set the MCSPort                                               */
    /*                                                                          */
    /* Params:    IN      MCSPort                                               */
    /****************************************************************************/
    DCVOID DCAPI UI_SetMCSPort(DCUINT16 MCSPort)
    {
        DC_BEGIN_FN("UI_SetMCSPort");

        TRC_NRM((TB, _T("Setting _UI.MCSPort to %d"), MCSPort));

        _UI.MCSPort = MCSPort;

        DC_END_FN();
    } /* UI_SetMCSPort */


    /****************************************************************************/
    /* Name:      UI_GetMCSPort                                                 */
    /*                                                                          */
    /* Purpose:   Get the MCSPort                                               */
    /****************************************************************************/
    UINT16 DCAPI UI_GetMCSPort(void)
    {
        UINT16  MCSPort;

        DC_BEGIN_FN("UI_GetMCSPort");

        MCSPort = _UI.MCSPort;

        DC_END_FN();
        return(MCSPort);
    } /* UI_GetMCSPort */


    /****************************************************************************/
    /* Name:      UI_SetServerName                                              */
    /*                                                                          */
    /* Purpose:   Save name of currently connected Server                       */
    /****************************************************************************/
    HRESULT DCAPI UI_SetServerName(LPTSTR pName)
    {
        HRESULT hr;
        DC_BEGIN_FN("UI_SetServerName");

        hr = StringCchCopy(_UI.strAddress, SIZE_TCHARS(_UI.strAddress),
                           pName);

        if (FAILED(hr)) {
            TRC_ERR((TB,_T("Error copying straddress string: 0x%x"),hr));
        }

        DC_END_FN();
        return hr;
    } /* UI_SetServerName */


    /****************************************************************************/
    /* Name:      UI_GetServerName                                              */
    /*                                                                          */
    /* Purpose:   Return name of currently connected Server                     */
    /*                                                                          */
    /* Params:    pName (returned) - name of Server                             */
    /****************************************************************************/
    HRESULT UI_GetServerName(LPTSTR pszName, UINT cchName)
    {
        HRESULT hr;
        DC_BEGIN_FN("UI_GetServerName");

        hr = StringCchCopy(pszName, cchName, pszName);

        DC_END_FN();
        return hr;
    } /* UI_GetServerName */

    /****************************************************************************/
    /* Name:      UI_SetTDSocket                                                */
    /*                                                                          */
    /* Purpose:   Save the connection socket for this session                   */
    /****************************************************************************/
    _inline DCVOID DCAPI UI_SetTDSocket(SOCKET TDSock)
    {
        DC_BEGIN_FN("UI_SetSocket");

        TRC_NRM((TB, _T("Save TD socket handle %p"), TDSock));
        _UI.TDSocket = TDSock;

        DC_END_FN();
    }

    /****************************************************************************/
    /* Name:      UI_GetTDSocket                                                */
    /*                                                                          */
    /* Purpose:   Return the connection socket for this session                 */
    /****************************************************************************/
    _inline SOCKET DCAPI UI_GetTDSocket(void)
    {
        DC_BEGIN_FN("UI_GetTDSocket");

        DC_END_FN();
        return _UI.TDSocket;
    }

    void UI_SetContainerHandledFullScreen(BOOL fContHandlesFScr)
    {
        _UI.fContainerHandlesFullScreenToggle = fContHandlesFScr;
    }

    BOOL UI_GetContainerHandledFullScreen()
    {
        return _UI.fContainerHandlesFullScreenToggle;
    }
    

    /****************************************************************************/
    // SetServerRedirectionInfo
    //
    // Used on receipt of a TS_SERVER_REDIRECT_PDU to store the info needed to
    // redirect the client to a new server. Sets the DoRedirection flag as well
    // to indicate these data members are set and ready for use.  Also sets the
    // ClientIsRedirected flag, which is longer-lived than the DoRedirection
    // flag and is used to send the correct cookie when redirected.
    /****************************************************************************/
    HRESULT UI_SetServerRedirectionInfo(
                        UINT32 SessionID,
                        LPTSTR pszServerAddress,
                        PBYTE LBInfo,
                        unsigned LBInfoSize,
                        BOOL fNeedRedirect
                        );

    /****************************************************************************/
    // UI_GetDoRedirection
    /****************************************************************************/
    BOOL UI_GetDoRedirection()
    {
        DC_BEGIN_FN("UI_GetDoRedirection");
        DC_END_FN();
        return _UI.DoRedirection;
    }

    /****************************************************************************/
    // UI_ClearDoRedirection
    /****************************************************************************/
    void UI_ClearDoRedirection()
    {
        DC_BEGIN_FN("UI_GetDoRedirection");
        _UI.DoRedirection = FALSE;
        DC_END_FN();
    }

    /****************************************************************************/
    // UI_GetRedirectionSessionID
    /****************************************************************************/
    UINT32 UI_GetRedirectionSessionID()
    {
        DC_BEGIN_FN("UI_GetRedirectionSessionID");
        DC_END_FN();
        return _UI.RedirectionSessionID;
    }

    DCUINT UI_GetAudioRedirectionMode();
    VOID UI_SetAudioRedirectionMode(DCUINT audioMode);


    BOOL UI_GetDriveRedirectionEnabled();
    VOID UI_SetDriveRedirectionEnabled(BOOL fEnable);

    BOOL UI_GetPrinterRedirectionEnabled();
    VOID UI_SetPrinterRedirectionEnabled(BOOL fEnable);

    BOOL UI_GetPortRedirectionEnabled();
    VOID UI_SetPortRedirectionEnabled(BOOL fEnable);

    BOOL UI_GetSCardRedirectionEnabled();
    VOID UI_SetSCardRedirectionEnabled(BOOL fEnable);

    VOID UI_OnDeviceChange(WPARAM wParam, LPARAM lParam);

    PRDPDR_DATA UI_GetRdpDrInitData() {return &_drInitData;}

    VOID UI_SetConnectToServerConsole(BOOL fConnectToServerConsole)
    {
        _UI.fConnectToServerConsole = fConnectToServerConsole;
    }

    BOOL UI_GetConnectToServerConsole()
    {
        return _UI.fConnectToServerConsole;
    }

    VOID UI_SetfUseFIPS(BOOL fUseFIPS)
    {
      _UI.fUseFIPS = fUseFIPS;
    }


    HWND UI_GetInputWndHandle();

    BOOL UI_InjectVKeys(/*[in]*/ LONG  numKeys,
                        /*[in]*/ short* pfArrayKeyUp,
                        /*[in]*/ LONG* plKeyData);

    BOOL UI_SetMinsToIdleTimeout(LONG minsToTimeout);
    LONG UI_GetMinsToIdleTimeout();

    DCVOID DCAPI UI_SetServerErrorInfo(ULONG_PTR errInfo);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CUI, UI_SetServerErrorInfo);

    UINT32 UI_GetServerErrorInfo();

    VOID UI_SetEnableBBar(BOOL b)     {_UI.fBBarEnabled = b;}
    BOOL UI_GetEnableBBar()           {return _UI.fBBarEnabled;}

    VOID UI_SetBBarPinned(BOOL b);
    BOOL UI_GetBBarPinned();

    VOID UI_SetBBarShowMinimize(BOOL b)   {_UI.fBBarShowMinimizeButton = b;}
    BOOL UI_GetBBarShowMinimize()         {return _UI.fBBarShowMinimizeButton;}
    VOID UI_SetBBarShowRestore(BOOL b)    {_UI.fBBarShowRestoreButton = b;}
    BOOL UI_GetBBarShowRestore()          {return _UI.fBBarShowRestoreButton;}

    VOID UI_SetGrabFocusOnConnect(BOOL b)     {_UI.fGrabFocusOnConnect = b;}
    BOOL UI_GetGrabFocusOnConnect()   {return _UI.fGrabFocusOnConnect;}

    BOOL UI_GetLocalSessionId(PDCUINT32 pSessionId);
    HWND UI_GetBmpCacheMonitorHandle();

#ifdef DISABLE_SHADOW_IN_FULLSCREEN
#ifdef USE_BBAR
    DCVOID DCAPI UI_GetBBarState(ULONG_PTR pData)
    {
        int *pstate = (int *)pData;

        if (_pBBar) {
            *pstate =  _pBBar->GetState();
        }
        else {
            *pstate = CBBar::bbarNotInit;
        }
    }
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CUI, UI_GetBBarState);

    DCVOID DCAPI UI_GetBBarLowerAspect(ULONG_PTR pData)
    {
        RECT *prect = (RECT *)pData;

        if (_pBBar) {
            _pBBar->GetBBarLoweredAspect(prect);  
        }
        else {
            prect->left = 0;
            prect->top = 0;
            prect->right = 0;
            prect->bottom = 0;
        }
    }
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CUI, UI_GetBBarLowerAspect);

    DCVOID      UI_OnNotifyBBarRectChange(RECT *prect);
    DCVOID      UI_OnNotifyBBarVisibleChange(int BBarVisible);
#endif
#endif // DISABLE_SHADOW_IN_FULLSCREEN

    BOOL        UI_GetStartFullScreen()      {return _UI.fStartFullScreen;}
    VOID        UI_SetStartFullScreen(BOOL f)   {_UI.fStartFullScreen = f;}

    //
    // Performance flags are currently a disabled feature list
    // that is sent up to the server to selectively enable/disable
    // certain features to optimize bandwidth
    //
    DWORD       UI_GetPerformanceFlags() {return _UI.dwPerformanceFlags;}
    VOID        UI_SetPerformanceFlags(DWORD dw) {_UI.dwPerformanceFlags = dw;}

    VOID        UI_SetControlInstance(IUnknown* pUnkControl);
    IUnknown*   UI_GetControlInstance();

    BOOL        UI_GetEnableAutoReconnect()    {return _UI.fEnableAutoReconnect;}
    VOID        UI_SetEnableAutoReconnect(BOOL b) {_UI.fEnableAutoReconnect = b;}

    ULONG       UI_GetAutoReconnectCookieLen() {return _UI.cbAutoReconnectCookieLen;}
    PBYTE       UI_GetAutoReconnectCookie()    {return _UI.pAutoReconnectCookie;}
    BOOL        UI_SetAutoReconnectCookie(PBYTE pCookie, ULONG cbLen);
    BOOL        UI_CanAutoReconnect();

    LONG        UI_GetMaxArcAttempts()
                    {return _UI.MaxAutoReconnectionAttempts;}
    VOID        UI_SetMaxArcAttempts(LONG l)
                    {_UI.MaxAutoReconnectionAttempts = l;}


    //
    // Built-in ARC UI functions
    //
    BOOL        UI_StartAutoReconnectDlg();
    BOOL        UI_StopAutoReconnectDlg();
    BOOL        UI_IsAutoReconnecting() {return _pArcUI ? TRUE : FALSE;}

    //
    // Received autoreconenct status from the server
    //
    VOID        UI_OnReceivedArcStatus(LONG arcStatus);
    VOID        UI_OnAutoReconnectStopped();

private:
    //
    // Class pointers to callee's
    //
    CCO*  _pCo;
    CCLX* _clx;
    CUT*  _pUt;
    CTD*  _pTd;
    CIH*  _pIh;
    CCD*  _pCd;
    COP*  _pOp;
    CChan* _pCChan;
    CUH*   _pUh;

#ifdef USE_BBAR
    CBBar*  _pBBar;
#endif

    //
    // Struct handed off to winsock
    // for hostname lookup
    //
    PBYTE _pHostData;

#ifdef USE_BBAR
    //
    // Last mouse pos used for bbar hotzone tracking
    //
    BOOL  _fBBarUnhideTimerActive;
    POINT _ptBBarLastMousePos;
#endif

    // Handling recursive WM_SIZE for scrollbars
    BOOL  _fRecursiveScrollBarMsg;

    //RDPDR internal plugin initialization data
    RDPDR_DATA _drInitData;

    BOOL  _fRecursiveSizeMsg;

    BOOL  _fIhHasFocus;

#ifndef OS_WINCE
    ITfLangBarMgr *_pITLBM;
    BOOL  _fLangBarWasHidden;
    DWORD _dwLangBarFlags;
    BOOL  _fLangBarStateSaved;

    //
    // We use the shell taskbar API to ensure the taskbar
    // hides itself when we go fullscreen in control-handled
    // fullscreen
    //

    //Cached interface pointer to shell task bar
    ITaskbarList2*       _pTaskBarList2;
    //Flag indicaticating we already tried to get the TaskBarList2
    //so we shouldn't bother trying again
    BOOL                 _fQueriedForTaskBarList2;
#endif
    BOOL  _fTerminating;

    //
    // Autoreconnect dialog
    //
    CAutoReconnectUI* _pArcUI;

public:
    //
    // Bucket to all the objects for this client instance
    //
    CObjs _Objects;
};
#endif // _H_WUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\wxldata.h ===
/**INC+**********************************************************************/
/* Header:    wxldata.h                                                     */
/*                                                                          */
/* Purpose:   XL component data                                             */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/**INC-**********************************************************************/

#ifndef _H_WXLDATA
#define _H_WXLDATA

#include <wxlint.h>

PDCVOID OrAllTableNarrow[] =
{
    exit_fast_text,
    exit_fast_text,
    exit_fast_text,
    exit_fast_text,
    or_all_1_wide_rotated_need_last,
    or_all_1_wide_unrotated,
    or_all_1_wide_rotated_need_last,
    or_all_1_wide_unrotated,
    or_all_2_wide_rotated_need_last,
    or_all_2_wide_unrotated,
    or_all_2_wide_rotated_no_last,
    or_all_2_wide_unrotated,
    or_all_3_wide_rotated_need_last,
    or_all_3_wide_unrotated,
    or_all_3_wide_rotated_no_last,
    or_all_3_wide_unrotated,
    or_all_4_wide_rotated_need_last,
    or_all_4_wide_unrotated,
    or_all_4_wide_rotated_no_last,
    or_all_4_wide_unrotated
};

PDCVOID OrInitialTableNarrow[] =
{
    exit_fast_text                     ,
    exit_fast_text                     ,
    exit_fast_text                     ,
    exit_fast_text                     ,

    or_all_1_wide_rotated_need_last    ,
    mov_first_1_wide_unrotated         ,
    or_all_1_wide_rotated_need_last    ,
    mov_first_1_wide_unrotated         ,

    or_first_2_wide_rotated_need_last  ,
    mov_first_2_wide_unrotated         ,
    or_first_2_wide_rotated_no_last    ,
    mov_first_2_wide_unrotated         ,

    or_first_3_wide_rotated_need_last  ,
    mov_first_3_wide_unrotated         ,
    or_first_3_wide_rotated_no_last    ,
    mov_first_3_wide_unrotated         ,
    or_first_4_wide_rotated_need_last  ,
    mov_first_4_wide_unrotated         ,
    or_first_4_wide_rotated_no_last    ,
    mov_first_4_wide_unrotated
};

//
// Handles arbitrarily wide glyph drawing, for case where initial byte should be
// ORed if it's not aligned (intended for use in drawing all but the first glyph
// in a string). Table format is:
//  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
//  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
//

PDCVOID OrInitialTableWide[] =
{
    or_first_N_wide_rotated_need_last,
    mov_first_N_wide_unrotated,
    or_first_N_wide_rotated_no_last,
    mov_first_N_wide_unrotated
};

//
// Handles arbitrarily wide glyph drawing, for case where all bytes should
// be ORed (intended for use in drawing potentially overlapping glyphs).
// Table format is:
//  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
//  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
//
//

PDCVOID OrAllTableWide[] =
{
    or_all_N_wide_rotated_need_last,
    or_all_N_wide_unrotated,
    or_all_N_wide_rotated_no_last,
    or_all_N_wide_unrotated
};


#endif // _H_WXLDATA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\wxlint.h ===
/****************************************************************************/
// wxlint.h
//
// Glyph extended drawing logic internal types, constants
//
// Copyright (C) 1997-1999 Microsoft Corporation
/****************************************************************************/
#ifndef _H_WXLINT
#define _H_WXLINT


typedef VOID (*PFN_GLYPHLOOP)(LONG,LONG,LONG,PDCUINT8,PDCUINT8,PDCUINT8,PDCUINT8,LONG);
typedef VOID (*PFN_GLYPHLOOPN)(LONG,LONG,LONG,PDCUINT8,PDCUINT8,PDCUINT8,PDCUINT8,LONG,LONG);

extern  PDCVOID OrAllTableNarrow[20];
extern  PDCVOID OrInitialTableNarrow[20];
extern  PDCVOID OrInitialTableWide[20];
extern  PDCVOID OrAllTableWide[20];


#if defined(OS_WINCE) || defined(OS_WINNT)

extern  const ULONG gTextLeftMask[8][2];
extern  const ULONG gTextRightMask[8][2];
extern  const ULONG TranTable[16];

#endif // defined(OS_WINCE) || defined(OS_WINNT)


VOID exit_fast_text                 (LONG,LONG,LONG,PDCUINT8,PDCUINT8,PDCUINT8,PDCUINT8,LONG);
VOID or_all_1_wide_rotated_need_last(LONG,LONG,LONG,PDCUINT8,PDCUINT8,PDCUINT8,PDCUINT8,LONG);
VOID or_all_1_wide_unrotated        (LONG,LONG,LONG,PDCUINT8,PDCUINT8,PDCUINT8,PDCUINT8,LONG);
VOID or_all_1_wide_unrotated        (LONG,LONG,LONG,PDCUINT8,PDCUINT8,PDCUINT8,PDCUINT8,LONG);
VOID or_all_2_wide_rotated_need_last(LONG,LONG,LONG,PDCUINT8,PDCUINT8,PDCUINT8,PDCUINT8,LONG);
VOID or_all_2_wide_unrotated        (LONG,LONG,LONG,PDCUINT8,PDCUINT8,PDCUINT8,PDCUINT8,LONG);
VOID or_all_2_wide_rotated_no_last  (LONG,LONG,LONG,PDCUINT8,PDCUINT8,PDCUINT8,PDCUINT8,LONG);
VOID or_all_2_wide_unrotated        (LONG,LONG,LONG,PDCUINT8,PDCUINT8,PDCUINT8,PDCUINT8,LONG);
VOID or_all_3_wide_rotated_need_last(LONG,LONG,LONG,PDCUINT8,PDCUINT8,PDCUINT8,PDCUINT8,LONG);
VOID or_all_3_wide_unrotated        (LONG,LONG,LONG,PDCUINT8,PDCUINT8,PDCUINT8,PDCUINT8,LONG);
VOID or_all_3_wide_rotated_no_last  (LONG,LONG,LONG,PDCUINT8,PDCUINT8,PDCUINT8,PDCUINT8,LONG);
VOID or_all_3_wide_unrotated        (LONG,LONG,LONG,PDCUINT8,PDCUINT8,PDCUINT8,PDCUINT8,LONG);
VOID or_all_4_wide_rotated_need_last(LONG,LONG,LONG,PDCUINT8,PDCUINT8,PDCUINT8,PDCUINT8,LONG);
VOID or_all_4_wide_unrotated        (LONG,LONG,LONG,PDCUINT8,PDCUINT8,PDCUINT8,PDCUINT8,LONG);
VOID or_all_4_wide_rotated_no_last  (LONG,LONG,LONG,PDCUINT8,PDCUINT8,PDCUINT8,PDCUINT8,LONG);
VOID or_all_4_wide_unrotated        (LONG,LONG,LONG,PDCUINT8,PDCUINT8,PDCUINT8,PDCUINT8,LONG);

VOID or_first_2_wide_rotated_need_last(LONG,LONG,LONG,PDCUINT8,PDCUINT8,PDCUINT8,PDCUINT8,LONG);
VOID or_first_2_wide_rotated_no_last  (LONG,LONG,LONG,PDCUINT8,PDCUINT8,PDCUINT8,PDCUINT8,LONG);
VOID or_first_3_wide_rotated_need_last(LONG,LONG,LONG,PDCUINT8,PDCUINT8,PDCUINT8,PDCUINT8,LONG);
VOID or_first_3_wide_rotated_no_last  (LONG,LONG,LONG,PDCUINT8,PDCUINT8,PDCUINT8,PDCUINT8,LONG);
VOID or_first_4_wide_rotated_need_last(LONG,LONG,LONG,PDCUINT8,PDCUINT8,PDCUINT8,PDCUINT8,LONG);
VOID or_first_4_wide_rotated_no_last  (LONG,LONG,LONG,PDCUINT8,PDCUINT8,PDCUINT8,PDCUINT8,LONG);
VOID or_first_N_wide_rotated_need_last(LONG,LONG,LONG,PDCUINT8,PDCUINT8,PDCUINT8,PDCUINT8,LONG,LONG);
VOID or_first_N_wide_rotated_no_last  (LONG,LONG,LONG,PDCUINT8,PDCUINT8,PDCUINT8,PDCUINT8,LONG,LONG);

VOID or_all_N_wide_rotated_need_last(LONG,LONG,LONG,PDCUINT8,PDCUINT8,PDCUINT8,PDCUINT8,LONG,LONG);
VOID or_all_N_wide_unrotated        (LONG,LONG,LONG,PDCUINT8,PDCUINT8,PDCUINT8,PDCUINT8,LONG,LONG);
VOID or_all_N_wide_rotated_no_last  (LONG,LONG,LONG,PDCUINT8,PDCUINT8,PDCUINT8,PDCUINT8,LONG,LONG);
VOID or_all_N_wide_unrotated        (LONG,LONG,LONG,PDCUINT8,PDCUINT8,PDCUINT8,PDCUINT8,LONG,LONG);

VOID mov_first_1_wide_unrotated(LONG,LONG,LONG,PDCUINT8,PDCUINT8,PDCUINT8,PDCUINT8,LONG);
VOID mov_first_2_wide_unrotated(LONG,LONG,LONG,PDCUINT8,PDCUINT8,PDCUINT8,PDCUINT8,LONG);
VOID mov_first_3_wide_unrotated(LONG,LONG,LONG,PDCUINT8,PDCUINT8,PDCUINT8,PDCUINT8,LONG);
VOID mov_first_4_wide_unrotated(LONG,LONG,LONG,PDCUINT8,PDCUINT8,PDCUINT8,PDCUINT8,LONG);
VOID mov_first_N_wide_unrotated(LONG,LONG,LONG,PDCUINT8,PDCUINT8,PDCUINT8,PDCUINT8,LONG,LONG);


#endif // _H_WXLINT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\wxlint.cpp ===
/**INC+**********************************************************************/
/* Header:    wxlint.c                                                      */
/*                                                                          */
/* Purpose:   Glyph drawing - internal Windows specific                     */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/

#include <adcg.h>
extern "C" {

#define TRC_GROUP TRC_GROUP_CORE
#define TRC_FILE  "wxlint"
#include <atrcapi.h>
}

#include <wxlint.h>
#include <wxldata.h>

#define CALC_WRITE_SIZE( REPS, R, INC )  (LONG)(((REPS)-1)*(INC) + (R))

#define CHECK_CALC_END( CALC_END, TRUE_END ) \
    if ((CALC_END) > (TRUE_END)) { \
        TRC_ABORT((TB, _T("glyph draw off end of buffer [calcEnd=0x%x trueEnd=0x%x]"), (CALC_END), (TRUE_END))); \
        DC_QUIT; \
    }

//
// debug routine
//

VOID
exit_fast_text(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PDCUINT8  pGlyph,
    PDCUINT8 pEndGlyph,
    PDCUINT8  pBuffer,
    PDCUINT8  pEndBuffer,
    LONG    cxGlyph
    )
{
    DC_IGNORE_PARAMETER(cyGlyph);
    DC_IGNORE_PARAMETER(RightRot);
    DC_IGNORE_PARAMETER(ulBufDelta);
    DC_IGNORE_PARAMETER(pGlyph);
    DC_IGNORE_PARAMETER(pEndGlyph);
    DC_IGNORE_PARAMETER(pBuffer);
    DC_IGNORE_PARAMETER(pEndBuffer);
    DC_IGNORE_PARAMETER(cxGlyph);

    return;
}

//
// or_all_1_wide_rotated_need_last::
// or_all_1_wide_rotated_no_last::
// or_first_1_wide_rotated_need_last
// or_first_1_wide_rotated_no_last::
//

VOID
or_all_1_wide_rotated_need_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PDCUINT8  pGlyph,
    PDCUINT8 pEndGlyph,
    PDCUINT8  pBuffer,
    PDCUINT8  pEndBuffer,
    LONG    cxGlyph
    )
{
    DC_BEGIN_FN("or_all_1_wide_rotated_need_last");
    
    PDCUINT8 pjEnd = pGlyph + cyGlyph;
    DCUINT8  c;

    CHECK_CALC_END( pjEnd, pEndGlyph );

    CHECK_WRITE_N_BYTES_NO_HR(pBuffer, pEndBuffer, CALC_WRITE_SIZE(cyGlyph, 1, ulBufDelta),
        (TB, _T("Write into temp buffer off end")));

    DC_IGNORE_PARAMETER(cxGlyph);

    while (pGlyph != pjEnd) {
        c = *pGlyph++;
        *pBuffer |= c >> RightRot;
        pBuffer += ulBufDelta;
    } 

DC_EXIT_POINT:
    return;
}

//
// mov_first_1_wide_rotated_need_last::
// mov_first_1_wide_rotated_no_last::
//

VOID
mov_first_1_wide_rotated_need_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PDCUINT8  pGlyph,
    PDCUINT8 pEndGlyph,
    PDCUINT8  pBuffer,
    PDCUINT8  pEndBuffer,
    LONG    cxGlyph
    )
{
    DC_BEGIN_FN("mov_first_1_wide_rotated_need_last");
    
    PDCUINT8 pjEnd = pGlyph + cyGlyph;
    DCUINT8  c;

    CHECK_CALC_END( pjEnd, pEndGlyph );

    CHECK_WRITE_N_BYTES_NO_HR(pBuffer, pEndBuffer, CALC_WRITE_SIZE(cyGlyph, 1, ulBufDelta),
        (TB, _T("Write into temp buffer off end")));

    DC_IGNORE_PARAMETER(cxGlyph);

    while (pGlyph != pjEnd) {
        c = *pGlyph++;
        *pBuffer = (DCUINT8)(c >> RightRot);
        pBuffer += ulBufDelta;
    }  

DC_EXIT_POINT:
    return;    
}

//
// mov_first_1_wide_unrotated::
//

VOID
mov_first_1_wide_unrotated(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PDCUINT8  pGlyph,
    PDCUINT8 pEndGlyph,
    PDCUINT8  pBuffer,
    PDCUINT8  pEndBuffer,
    LONG    cxGlyph
    )
{
    DC_BEGIN_FN("mov_first_1_wide_unrotated");
    
    PDCUINT8 pjEnd = pGlyph + cyGlyph;

    CHECK_CALC_END( pjEnd, pEndGlyph );

    CHECK_WRITE_N_BYTES_NO_HR(pBuffer, pEndBuffer, CALC_WRITE_SIZE(cyGlyph, 1, ulBufDelta),
        (TB, _T("Write into temp buffer off end")));

    DC_IGNORE_PARAMETER(cxGlyph);
    DC_IGNORE_PARAMETER(RightRot);

    while (pGlyph != pjEnd) {
        *pBuffer = *pGlyph++;
        pBuffer += ulBufDelta;
    }  
DC_EXIT_POINT:
    return;
}


//
//or_all_1_wide_unrotated::
//or_all_1_wide_unrotated_loop::
//

VOID
or_all_1_wide_unrotated(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PDCUINT8  pGlyph,
    PDCUINT8 pEndGlyph,
    PDCUINT8  pBuffer,
    PDCUINT8  pEndBuffer,
    LONG    cxGlyph
    )
{
    DC_BEGIN_FN("or_all_1_wide_unrotated");
    
    PDCUINT8 pjEnd = pGlyph + cyGlyph;

    CHECK_CALC_END( pjEnd, pEndGlyph );

    CHECK_WRITE_N_BYTES_NO_HR(pBuffer, pEndBuffer, CALC_WRITE_SIZE(cyGlyph, 1, ulBufDelta),
        (TB, _T("Write into temp buffer off end")));

    DC_IGNORE_PARAMETER(cxGlyph);
    DC_IGNORE_PARAMETER(RightRot);

    while (pGlyph != pjEnd) {
        *pBuffer |= *pGlyph++;
        pBuffer += ulBufDelta;
    }  
DC_EXIT_POINT:
    return;
}

//
// or_first_2_wide_rotated_need_last::
//

VOID
or_first_2_wide_rotated_need_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PDCUINT8  pGlyph,
    PDCUINT8 pEndGlyph,
    PDCUINT8  pBuffer,
    PDCUINT8  pEndBuffer,
    LONG    cxGlyph
    )
{
    DC_BEGIN_FN("or_first_2_wide_rotated_need_last");
    
    PDCUINT8 pjEnd = pGlyph + 2*cyGlyph;
    DCUINT32 rl = 8-RightRot;
    DCUINT8 c0,c1;

    CHECK_CALC_END( pjEnd, pEndGlyph );

    CHECK_WRITE_N_BYTES_NO_HR(pBuffer, pEndBuffer, CALC_WRITE_SIZE(cyGlyph, 2, ulBufDelta),
        (TB, _T("Write into temp buffer off end")));

    DC_IGNORE_PARAMETER(cxGlyph);

    while (pGlyph != pjEnd) {
        c0 = *pGlyph;
        c1 = *(pGlyph+1);
        pGlyph+=2;
        *pBuffer |= c0 >> RightRot;
        *(pBuffer+1) = (DCUINT8)((c1 >> RightRot) | (c0 << rl));
        pBuffer += ulBufDelta;
    }  
DC_EXIT_POINT:
    return;
}

//
//or_all_2_wide_rotated_need_last::
//

VOID
or_all_2_wide_rotated_need_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PDCUINT8  pGlyph,
    PDCUINT8 pEndGlyph,
    PDCUINT8  pBuffer,
    PDCUINT8  pEndBuffer,
    LONG    cxGlyph
    )
{
    DC_BEGIN_FN("or_all_2_wide_rotated_need_last");
    
    PDCUINT8 pjEnd = pGlyph + 2*cyGlyph;
    DCUINT32  rl    = 8-RightRot;
    DCUINT16 usTmp;
    DCUINT8  c0,c1;

    CHECK_CALC_END( pjEnd, pEndGlyph );

    CHECK_WRITE_N_BYTES_NO_HR(pBuffer, pEndBuffer, CALC_WRITE_SIZE(cyGlyph, 2, ulBufDelta),
        (TB, _T("Write into temp buffer off end")));

    DC_IGNORE_PARAMETER(cxGlyph);

    while (pGlyph != pjEnd) {
        usTmp = *(PDCUINT16)pGlyph;
        pGlyph += 2;
        c0 = (DCUINT8)usTmp;
        c1 = (DCUINT8)(usTmp >> 8);
        *pBuffer |= (DCUINT8)(c0 >> RightRot);
        *(pBuffer+1) |= (DCUINT8)((c1 >> RightRot) | (c0 << rl));
        pBuffer += ulBufDelta;
    }  
DC_EXIT_POINT:
    return;
}

//
// mov_first_2_wide_rotated_need_last::
//

VOID
mov_first_2_wide_rotated_need_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PDCUINT8  pGlyph,
    PDCUINT8 pEndGlyph,
    PDCUINT8  pBuffer,
    PDCUINT8  pEndBuffer,
    LONG    cxGlyph
    )
{
    DC_BEGIN_FN("mov_first_2_wide_rotated_need_last");
    
    PDCUINT8 pjEnd = pGlyph + 2*cyGlyph;
    DCUINT32 rl = 8-RightRot;
    DCUINT16 us;
    DCUINT8 c0;
    DCUINT8 c1;

    CHECK_CALC_END( pjEnd, pEndGlyph );

    CHECK_WRITE_N_BYTES_NO_HR(pBuffer, pEndBuffer, CALC_WRITE_SIZE(cyGlyph, 2, ulBufDelta),
        (TB, _T("Write into temp buffer off end")));

    DC_IGNORE_PARAMETER(cxGlyph);

    while (pGlyph != pjEnd) {
        us = *(PDCUINT16)pGlyph;
        c0 = (DCUINT8)(us & 0xff);
        c1 = (DCUINT8)(us >> 8);
        pGlyph += 2;
        *pBuffer     = (DCUINT8)(c0 >> RightRot);
        *(pBuffer+1) = (DCUINT8)((c1 >> RightRot) | (c0 << rl));
        pBuffer += ulBufDelta;
    }  
DC_EXIT_POINT:
    return;
}

//
// or_first_2_wide_rotated_no_last
//

VOID
or_first_2_wide_rotated_no_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PDCUINT8  pGlyph,
    PDCUINT8 pEndGlyph,
    PDCUINT8  pBuffer,
    PDCUINT8  pEndBuffer,
    LONG    cxGlyph
    )
{
    DC_BEGIN_FN("or_first_2_wide_rotated_no_last");
    
    PDCUINT8 pjEnd = pGlyph + cyGlyph;
    DCUINT32 rl = 8-RightRot;
    DCUINT8 c0;

    CHECK_CALC_END( pjEnd, pEndGlyph );

    CHECK_WRITE_N_BYTES_NO_HR(pBuffer, pEndBuffer, CALC_WRITE_SIZE(cyGlyph, 2, ulBufDelta),
        (TB, _T("Write into temp buffer off end")));

    DC_IGNORE_PARAMETER(cxGlyph);

    while (pGlyph != pjEnd) {
        c0 = *pGlyph++;
        *pBuffer     |= c0 >> RightRot;
        *(pBuffer+1)  = (DCUINT8)(c0 << rl);
        pBuffer += ulBufDelta;
    }  
DC_EXIT_POINT:
    return;
}


//
//or_all_2_wide_rotated_no_last::
//

VOID
or_all_2_wide_rotated_no_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PDCUINT8  pGlyph,
    PDCUINT8 pEndGlyph,
    PDCUINT8  pBuffer,
    PDCUINT8  pEndBuffer,
    LONG    cxGlyph
    )
{
    DC_BEGIN_FN("or_all_2_wide_rotated_no_last");
    
    PDCUINT8 pjEnd = pGlyph + cyGlyph;
    DCUINT32 rl = 8-RightRot;
    DCUINT8 c;

    CHECK_CALC_END( pjEnd, pEndGlyph );

    CHECK_WRITE_N_BYTES_NO_HR(pBuffer, pEndBuffer, CALC_WRITE_SIZE(cyGlyph, 2, ulBufDelta),
        (TB, _T("Write into temp buffer off end")));

    DC_IGNORE_PARAMETER(cxGlyph);

    while (pGlyph != pjEnd) {
        c = *pGlyph;
        pGlyph ++;
        *pBuffer     |= (DCUINT8)(c >> RightRot);
        *(pBuffer+1) |= (DCUINT8)(c << rl);
        pBuffer += ulBufDelta;
    }  
DC_EXIT_POINT:
    return;
}

//
// or_all_2_wide_unrotated::
//

VOID
or_all_2_wide_unrotated(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PDCUINT8  pGlyph,
    PDCUINT8 pEndGlyph,
    PDCUINT8  pBuffer,
    PDCUINT8  pEndBuffer,
    LONG    cxGlyph
    )
{
    DC_BEGIN_FN("or_all_2_wide_unrotated");
    
    PDCUINT8 pjEnd = pGlyph + 2*cyGlyph;

    DC_IGNORE_PARAMETER(cxGlyph);
    DC_IGNORE_PARAMETER(RightRot);

    CHECK_CALC_END( pjEnd, pEndGlyph );

    CHECK_WRITE_N_BYTES_NO_HR(pBuffer, pEndBuffer, CALC_WRITE_SIZE(cyGlyph, 2, ulBufDelta),
        (TB, _T("Write into temp buffer off end")));

    //
    // aligned?
    //

    if ((ULONG_PTR)pBuffer & 0x01) {

        //
        // not aligned
        //

        DCUINT16 usTmp;

        while (pGlyph != pjEnd) {
            usTmp = *(PDCUINT16)pGlyph;
            pGlyph +=2;
            *pBuffer     |= (DCUINT8)usTmp;
            *(pBuffer+1) |= (DCUINT8)(usTmp >> 8);
            pBuffer += ulBufDelta;
        }  

    } else {

        //
        // aligned
        //

        DCUINT16 usTmp;

        while (pGlyph != pjEnd) {
            usTmp = *(PDCUINT16)pGlyph;
            pGlyph +=2;
            *(PDCUINT16)pBuffer |= usTmp;
            pBuffer += ulBufDelta;
        }  

    }
DC_EXIT_POINT:
    return;
}

//
// mov_first_2_wide_unrotated::
//

VOID
mov_first_2_wide_unrotated(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PDCUINT8  pGlyph,
    PDCUINT8 pEndGlyph,
    PDCUINT8  pBuffer,
    PDCUINT8  pEndBuffer,
    LONG    cxGlyph
    )
{
    DC_BEGIN_FN("mov_first_2_wide_unrotated");
    
    PDCUINT8 pjEnd = pGlyph + 2*cyGlyph;
    DCUINT16     us;

    CHECK_CALC_END( pjEnd, pEndGlyph );

    CHECK_WRITE_N_BYTES_NO_HR(pBuffer, pEndBuffer, CALC_WRITE_SIZE(cyGlyph, 2, ulBufDelta),
        (TB, _T("Write into temp buffer off end")));

    DC_IGNORE_PARAMETER(cxGlyph);
    DC_IGNORE_PARAMETER(RightRot);

    while (pGlyph != pjEnd) {
        us = *(PDCUINT16)pGlyph;
        pGlyph +=2;
        *pBuffer      = (DCUINT8)(us & 0xff);
        *(pBuffer+1)  = (DCUINT8)(us >> 8);
        pBuffer += ulBufDelta;
    }  
DC_EXIT_POINT:
    return;
}

//
// mov_first_2_wide_rotated_no_last::
//

VOID
mov_first_2_wide_rotated_no_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PDCUINT8  pGlyph,
    PDCUINT8 pEndGlyph,
    PDCUINT8  pBuffer,
    PDCUINT8  pEndBuffer,
    LONG    cxGlyph
    )
{
    DC_BEGIN_FN("mov_first_2_wide_rotated_no_last");
    
    PDCUINT8 pjEnd = pGlyph + cyGlyph;
    DCUINT32 rl = 8-RightRot;
    DCUINT8 c0;

    CHECK_CALC_END( pjEnd, pEndGlyph );

    CHECK_WRITE_N_BYTES_NO_HR(pBuffer, pEndBuffer, CALC_WRITE_SIZE(cyGlyph, 2, ulBufDelta),
        (TB, _T("Write into temp buffer off end")));

    DC_IGNORE_PARAMETER(cxGlyph);

    while (pGlyph != pjEnd) {
        c0 = *pGlyph++;
        *pBuffer      = (DCUINT8)(c0 >> RightRot);
        *(pBuffer+1)  = (DCUINT8)(c0 << rl);
        pBuffer += ulBufDelta;
    }  
DC_EXIT_POINT:
    return;
}

//
// or_first_3_wide_rotated_need_last::
//

VOID
or_first_3_wide_rotated_need_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PDCUINT8  pGlyph,
    PDCUINT8 pEndGlyph,
    PDCUINT8  pBuffer,
    PDCUINT8  pEndBuffer,
    LONG    cxGlyph
    )
{
    DC_BEGIN_FN("or_first_3_wide_rotated_need_last");
        
    PDCUINT8 pjEnd = pGlyph + 3*cyGlyph;
    DCUINT32 ul;
    DCUINT8 c0,c1,c2;

    CHECK_CALC_END( pjEnd, pEndGlyph );

    CHECK_WRITE_N_BYTES_NO_HR(pBuffer, pEndBuffer, CALC_WRITE_SIZE(cyGlyph, 3, ulBufDelta),
        (TB, _T("Write into temp buffer off end")));

    DC_IGNORE_PARAMETER(cxGlyph);

    while (pGlyph != pjEnd) {
        c0 = *pGlyph;
        c1 = *(pGlyph+1);
        c2 = *(pGlyph+2);

        //
        // make into big-endian DCUINT32 and shift
        //

        ul = ((DCUINT32)c0 << 16) | ((DCUINT32)c1 << 8) | c2;
        ul >>= RightRot;

        *pBuffer     |= (BYTE)(ul >> 16);
        *(pBuffer+1)  = (BYTE)(ul >> 8);
        *(pBuffer+2)  = (BYTE)(ul);

        pGlyph += 3;
        pBuffer += ulBufDelta;
    } 
DC_EXIT_POINT:
    return;
}


//
// or_all_3_wide_rotated_need_last::
//

VOID
or_all_3_wide_rotated_need_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PDCUINT8  pGlyph,
    PDCUINT8 pEndGlyph,
    PDCUINT8  pBuffer,
    PDCUINT8  pEndBuffer,
    LONG    cxGlyph
    )
{
    DC_BEGIN_FN("or_all_3_wide_rotated_need_last");
    
    PDCUINT8 pjEnd = pGlyph + 3*cyGlyph;
    DCUINT32 ul;
    DCUINT8 c0,c1,c2;

    CHECK_CALC_END( pjEnd, pEndGlyph );

    CHECK_WRITE_N_BYTES_NO_HR(pBuffer, pEndBuffer, CALC_WRITE_SIZE(cyGlyph, 3, ulBufDelta),
        (TB, _T("Write into temp buffer off end")));

    DC_IGNORE_PARAMETER(cxGlyph);

    while (pGlyph != pjEnd) {
        c0 = *pGlyph;
        c1 = *(pGlyph+1);
        c2 = *(pGlyph+2);

        //
        // make into big-endian DCUINT32 and shift
        //

        ul = ((DCUINT32)c0 << 16) | ((DCUINT32)c1 << 8) | c2;
        ul >>= RightRot;

        *pBuffer     |= (BYTE)(ul >> 16);
        *(pBuffer+1) |= (BYTE)(ul >> 8);
        *(pBuffer+2) |= (BYTE)(ul);

        pGlyph += 3;
        pBuffer += ulBufDelta;

    } 
DC_EXIT_POINT:
    return;
}

//
// or_all_3_wide_rotated_no_last::
//

VOID
or_all_3_wide_rotated_no_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PDCUINT8  pGlyph,
    PDCUINT8 pEndGlyph,
    PDCUINT8  pBuffer,
    PDCUINT8  pEndBuffer,
    LONG    cxGlyph
    )
{
    DC_BEGIN_FN("or_all_3_wide_rotated_no_last");
    
    PDCUINT8 pjEnd = pGlyph + 2*cyGlyph;
    DCUINT32  ul;
    DCUINT8  c0,c1;

    CHECK_CALC_END( pjEnd, pEndGlyph );

    CHECK_WRITE_N_BYTES_NO_HR(pBuffer, pEndBuffer, CALC_WRITE_SIZE(cyGlyph, 3, ulBufDelta),
        (TB, _T("Write into temp buffer off end")));

    DC_IGNORE_PARAMETER(cxGlyph);

    while (pGlyph != pjEnd) {

        c0 = *pGlyph;
        c1 = *(pGlyph+1);

        //
        // make big-endian and shift
        //

        ul = ((DCUINT32)c0 << 16) | ((DCUINT32)c1 << 8);
        ul >>= RightRot;

        //
        // store result
        //

        *pBuffer     |= (BYTE)(ul >> 16);
        *(pBuffer+1) |= (BYTE)(ul >> 8);
        *(pBuffer+2) |= (BYTE)ul;


        pGlyph += 2;
        pBuffer += ulBufDelta;

    } 
DC_EXIT_POINT:
    return;
}

//
// or_first_3_wide_rotated_no_last::
//

VOID
or_first_3_wide_rotated_no_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PDCUINT8  pGlyph,
    PDCUINT8 pEndGlyph,
    PDCUINT8  pBuffer,
    PDCUINT8  pEndBuffer,
    LONG    cxGlyph
    )
{
    DC_BEGIN_FN("or_first_3_wide_rotated_no_last");
    
    PDCUINT8 pjEnd = pGlyph + 2*cyGlyph;
    DCUINT32  ul;
    DCUINT8  c0,c1;

    CHECK_CALC_END( pjEnd, pEndGlyph );

    CHECK_WRITE_N_BYTES_NO_HR(pBuffer, pEndBuffer, CALC_WRITE_SIZE(cyGlyph, 3, ulBufDelta),
        (TB, _T("Write into temp buffer off end")));

    DC_IGNORE_PARAMETER(cxGlyph);

    while (pGlyph != pjEnd) {

        c0 = *pGlyph;
        c1 = *(pGlyph+1);

        //
        // make big-endian and shift
        //

        ul = ((DCUINT32)c0 << 16) | ((DCUINT32)c1 << 8);
        ul >>= RightRot;

        //
        // store result, only or in first byte
        //

        *pBuffer     |= (BYTE)(ul >> 16);
        *(pBuffer+1)  = (BYTE)(ul >> 8);
        *(pBuffer+2)  = (BYTE)ul;


        pGlyph += 2;
        pBuffer += ulBufDelta;

    } 
DC_EXIT_POINT:
    return;
}

//
// mov_first_3_wide_unrotated::
//

VOID
mov_first_3_wide_unrotated(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PDCUINT8  pGlyph,
    PDCUINT8 pEndGlyph,
    PDCUINT8  pBuffer,
    PDCUINT8  pEndBuffer,
    LONG    cxGlyph
    )
{
    DC_BEGIN_FN("mov_first_3_wide_unrotated");
    
    PDCUINT8 pjEnd = pGlyph + 3*cyGlyph;
    DCUINT32 rl = 8-RightRot;
    DCUINT8 c0,c1,c2;

    CHECK_CALC_END( pjEnd, pEndGlyph );

    CHECK_WRITE_N_BYTES_NO_HR(pBuffer, pEndBuffer, CALC_WRITE_SIZE(cyGlyph, 3, ulBufDelta),
        (TB, _T("Write into temp buffer off end")));

    DC_IGNORE_PARAMETER(cxGlyph);

    while (pGlyph != pjEnd) {

        c0 = *pGlyph;
        c1 = *(pGlyph+1);
        c2 = *(pGlyph+2);

        *pBuffer     = c0;
        *(pBuffer+1) = c1;
        *(pBuffer+2) = c2;

        pGlyph += 3;
        pBuffer += ulBufDelta;
    } 
DC_EXIT_POINT:
    return;
}


//
//or_all_3_wide_unrotated::
//

VOID
or_all_3_wide_unrotated(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PDCUINT8  pGlyph,
    PDCUINT8 pEndGlyph,
    PDCUINT8  pBuffer,
    PDCUINT8  pEndBuffer,
    LONG    cxGlyph
    )
{
    DC_BEGIN_FN("or_all_3_wide_unrotated");
    
    PDCUINT8 pjEnd = pGlyph + 3*cyGlyph;
    DCUINT32 rl = 8-RightRot;
    DCUINT8 c0,c1,c2;

    CHECK_CALC_END( pjEnd, pEndGlyph );

    CHECK_WRITE_N_BYTES_NO_HR(pBuffer, pEndBuffer, CALC_WRITE_SIZE(cyGlyph, 3, ulBufDelta),
        (TB, _T("Write into temp buffer off end")));

    DC_IGNORE_PARAMETER(cxGlyph);

    while (pGlyph != pjEnd) {
        c0 = *pGlyph;
        c1 = *(pGlyph+1);
        c2 = *(pGlyph+2);

        *pBuffer |= c0;
        *(pBuffer+1) |= c1;
        *(pBuffer+2) |= c2;

        pBuffer += ulBufDelta;
        pGlyph += 3;

    } 
DC_EXIT_POINT:
    return;
}

//
// or_first_4_wide_rotated_need_last::
//

VOID
or_first_4_wide_rotated_need_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PDCUINT8  pGlyph,
    PDCUINT8 pEndGlyph,
    PDCUINT8  pBuffer,
    PDCUINT8  pEndBuffer,
    LONG    cxGlyph
    )
{
    DC_BEGIN_FN("or_first_4_wide_rotated_need_last");
    
    PDCUINT8 pjEnd = pGlyph + 4*cyGlyph;
    DCUINT32  ul;
    DCUINT32  t0,t1,t2;

    CHECK_CALC_END( pjEnd, pEndGlyph );

    CHECK_WRITE_N_BYTES_NO_HR(pBuffer, pEndBuffer, CALC_WRITE_SIZE(cyGlyph, 4, ulBufDelta),
        (TB, _T("Write into temp buffer off end")));

    DC_IGNORE_PARAMETER(cxGlyph);

    while (pGlyph != pjEnd) {

        ul = *(PDCUINT32)pGlyph;

        //
        // endian swap
        //

        t0 = ul << 24;
        t1 = ul >> 24;
        t2 = (ul >> 8) & 0x00ff00;
        ul = (ul << 8) & 0xff0000;

        ul = ul | t0 | t1 | t2;

        ul >>= RightRot;

        *pBuffer     |= (BYTE)(ul >> 24);

        *(pBuffer+1)  = (BYTE)(ul >> 16);

        *(pBuffer+2)  = (BYTE)(ul >> 8);

        *(pBuffer+3)  = (BYTE)(ul);

        pGlyph += 4;
        pBuffer += ulBufDelta;
    } 
DC_EXIT_POINT:
    return;
}

//
// or_all_4_wide_rotated_need_last::
//

VOID
or_all_4_wide_rotated_need_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PDCUINT8  pGlyph,
    PDCUINT8 pEndGlyph,
    PDCUINT8  pBuffer,
    PDCUINT8  pEndBuffer,
    LONG    cxGlyph
    )
{
    DC_BEGIN_FN("or_all_4_wide_rotated_need_last");
    
    PDCUINT8 pjEnd = pGlyph + 4*cyGlyph;
    DCUINT32  ul;
    DCUINT32  t0,t1,t2;

    CHECK_CALC_END( pjEnd, pEndGlyph );

    CHECK_WRITE_N_BYTES_NO_HR(pBuffer, pEndBuffer, CALC_WRITE_SIZE(cyGlyph, 4, ulBufDelta),
        (TB, _T("Write into temp buffer off end")));

    DC_IGNORE_PARAMETER(cxGlyph);

    while (pGlyph != pjEnd) {

        ul = *(PDCUINT32)pGlyph;

        //
        // endian swap
        //

        t0 = ul << 24;
        t1 = ul >> 24;
        t2 = (ul >> 8) & 0x00ff00;
        ul = (ul << 8) & 0xff0000;

        ul = ul | t0 | t1 | t2;

        ul >>= RightRot;

        *pBuffer     |= (BYTE)(ul >> 24);

        *(pBuffer+1) |= (BYTE)(ul >> 16);

        *(pBuffer+2) |= (BYTE)(ul >> 8);

        *(pBuffer+3) |= (BYTE)(ul);

        pGlyph += 4;
        pBuffer += ulBufDelta;

    } 
DC_EXIT_POINT:
    return;
}

//
// or_first_4_wide_rotated_no_last::
//

VOID
or_first_4_wide_rotated_no_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PDCUINT8  pGlyph,
    PDCUINT8 pEndGlyph,
    PDCUINT8  pBuffer,
    PDCUINT8  pEndBuffer,
    LONG    cxGlyph
    )
{
    DC_BEGIN_FN("or_first_4_wide_rotated_no_last");
    
    PDCUINT8 pjEnd = pGlyph + 3*cyGlyph;
    BYTE  c0,c1,c2;
    DCUINT32 ul;

    CHECK_CALC_END( pjEnd, pEndGlyph );

    CHECK_WRITE_N_BYTES_NO_HR(pBuffer, pEndBuffer, CALC_WRITE_SIZE(cyGlyph, 4, ulBufDelta),
        (TB, _T("Write into temp buffer off end")));

    DC_IGNORE_PARAMETER(cxGlyph);

    while (pGlyph != pjEnd) {

        //
        // load src
        //

        c0 = *pGlyph;
        c1 = *(pGlyph+1);
        c2 = *(pGlyph+2);

        //
        // or into big endian DCUINT32 and shift
        //

        ul = ((DCUINT32)c0 << 24) | ((DCUINT32)c1 << 16) | ((DCUINT32)c2 << 8);
        ul >>= RightRot;

        //
        // store result, ony or in fisrt byte
        //

        *pBuffer     |= (BYTE)(ul >> 24);

        *(pBuffer+1) = (BYTE)(ul >> 16);;

        *(pBuffer+2) = (BYTE)(ul >> 8);

        *(pBuffer+3) = (BYTE)(ul);

        //
        // inc scan line
        //

        pGlyph += 3;
        pBuffer += ulBufDelta;
    }
DC_EXIT_POINT:
    return;
}

//
// or_all_4_wide_rotated_no_last::
//

VOID
or_all_4_wide_rotated_no_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PDCUINT8  pGlyph,
    PDCUINT8 pEndGlyph,
    PDCUINT8  pBuffer,
    PDCUINT8  pEndBuffer,
    LONG    cxGlyph
    )
{
    DC_BEGIN_FN("or_all_4_wide_rotated_no_last");
    
    PDCUINT8 pjEnd = pGlyph + 3*cyGlyph;
    BYTE  c0,c1,c2;
    DCUINT32 ul;

    CHECK_CALC_END( pjEnd, pEndGlyph );

    CHECK_WRITE_N_BYTES_NO_HR(pBuffer, pEndBuffer, CALC_WRITE_SIZE(cyGlyph, 4, ulBufDelta),
        (TB, _T("Write into temp buffer off end")));

    DC_IGNORE_PARAMETER(cxGlyph);

    while (pGlyph != pjEnd) {

        //
        // load src
        //

        c0 = *pGlyph;
        c1 = *(pGlyph+1);
        c2 = *(pGlyph+2);

        //
        // or into big endian DCUINT32 and shift
        //

        ul = ((DCUINT32)c0 << 24) | ((DCUINT32)c1 << 16) | ((DCUINT32)c2 << 8);
        ul >>= RightRot;

        //
        // store result
        //

        *pBuffer     |= (BYTE)(ul >> 24);

        *(pBuffer+1) |= (BYTE)(ul >> 16);;

        *(pBuffer+2) |= (BYTE)(ul >> 8);

        *(pBuffer+3) |= (BYTE)(ul);

        //
        // inc scan line
        //

        pGlyph += 3;
        pBuffer += ulBufDelta;
    }
DC_EXIT_POINT:
    return;
}

VOID
mov_first_4_wide_unrotated(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PDCUINT8  pGlyph,
    PDCUINT8 pEndGlyph,
    PDCUINT8  pBuffer,
    PDCUINT8  pEndBuffer,
    LONG    cxGlyph
    )
{
    DC_BEGIN_FN("mov_first_4_wide_unrotated");
    
    PDCUINT8 pjEnd = pGlyph + 4*cyGlyph;

    CHECK_CALC_END( pjEnd, pEndGlyph );

    CHECK_WRITE_N_BYTES_NO_HR(pBuffer, pEndBuffer, CALC_WRITE_SIZE(cyGlyph, 4, ulBufDelta),
        (TB, _T("Write into temp buffer off end")));

    DC_IGNORE_PARAMETER(cxGlyph);
    DC_IGNORE_PARAMETER(RightRot);

    switch ((ULONG_PTR)pBuffer & 0x03 ) {
    case 0:

        while (pGlyph != pjEnd) {
            *(PDCUINT32)pBuffer = *(PDCUINT32)pGlyph;
            pGlyph += 4;
            pBuffer += ulBufDelta;
        }
        break;

    case 1:
    case 3:
        while (pGlyph != pjEnd) {

            *pBuffer              = *pGlyph;
            *(pBuffer+1)          = *(pGlyph+1);
            *(pBuffer+2)          = *(pGlyph+2);
            *(pBuffer+3)          = *(pGlyph+3);

            pGlyph += 4;
            pBuffer += ulBufDelta;
        }
        break;
    case 2:
        while (pGlyph != pjEnd) {

            *(PDCUINT16)(pBuffer)   = *(PDCUINT16)pGlyph;
            *(PDCUINT16)(pBuffer+2) = *(PDCUINT16)(pGlyph+2);

            pBuffer += ulBufDelta;
            pGlyph += 4;
        }
        break;
    }
DC_EXIT_POINT:
    return;
}


//
// or_all_4_wide_unrotated::
//

VOID
or_all_4_wide_unrotated(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PDCUINT8  pGlyph,
    PDCUINT8 pEndGlyph,
    PDCUINT8  pBuffer,
    PDCUINT8  pEndBuffer,
    LONG    cxGlyph
    )
{
    DC_BEGIN_FN("or_all_4_wide_unrotated");
    
    PDCUINT8 pjEnd = pGlyph + 4*cyGlyph;

    CHECK_CALC_END( pjEnd, pEndGlyph );

    CHECK_WRITE_N_BYTES_NO_HR(pBuffer, pEndBuffer, CALC_WRITE_SIZE(cyGlyph, 4, ulBufDelta),
        (TB, _T("Write into temp buffer off end")));

    DC_IGNORE_PARAMETER(cxGlyph);
    DC_IGNORE_PARAMETER(RightRot);

    switch ((ULONG_PTR)pBuffer & 0x03 ) {
    case 0:

        while (pGlyph != pjEnd) {

            *(PDCUINT32)pBuffer |= *(PDCUINT32)pGlyph;

            pGlyph += 4;
            pBuffer += ulBufDelta;
        }
        break;

    case 1:
    case 3:

        while (pGlyph != pjEnd) {

            *pBuffer              |= *pGlyph;
            *(pBuffer+1)          |= *(pGlyph+1);
            *(pBuffer+2)          |= *(pGlyph+2);
            *(pBuffer+3)          |= *(pGlyph+3);

            pGlyph += 4;
            pBuffer += ulBufDelta;
        }
        break;

    case 2:

        while (pGlyph != pjEnd) {

            *(PDCUINT16)pBuffer     |= *(PDCUINT16)pGlyph;
            *(PDCUINT16)(pBuffer+2) |= *(PDCUINT16)(pGlyph+2);

            pGlyph += 4;
            pBuffer += ulBufDelta;
        }
        break;
    }
DC_EXIT_POINT:
    return;
}

/******************************Public*Routine******************************\
*
* Routine Name
*
*   or_first_N_wide_rotated_need_last
*
*
* Routine Description:
*
*   Draw arbitrarily wide glyphs to 1BPP temp buffer
*
*
* Arguments:
*
*   cyGlyph     -   glyph height
*   RightRot    -   alignment
*   ulBufDelta  -   scan line stride of temp buffer
*   pGlyph      -   pointer to glyph bitmap
*   pBuffer     -   pointer to temp buffer
*   cxGlyph     -   glyph width in pixels
*   cxDst       -   Dest width in bytes
*
* Return Value:
*
*   None
*
\**************************************************************************/
VOID
or_first_N_wide_rotated_need_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PDCUINT8  pGlyph,
    PDCUINT8 pEndGlyph,
    PDCUINT8  pBuffer,
    PDCUINT8  pEndBuffer,
    LONG    cxGlyph,
    LONG    cxDst
    )
{
    DC_BEGIN_FN("or_first_N_wide_rotated_need_last");
    
    PDCUINT8 pjDst      = (PDCUINT8)pBuffer;
    PDCUINT8 pjDstEnd;
    PDCUINT8 pjDstEndy  = pBuffer + ulBufDelta * cyGlyph;
    LONG   lStride    = ulBufDelta - cxDst;
    LONG   rl         = 8-RightRot;

    DC_IGNORE_PARAMETER(cxGlyph);

    //
    // source doesn't advance after first byte, and
    // we do the first byte outside the loop
    //

    while (pjDst != pjDstEndy) {
        CHECK_READ_N_BYTES_NO_HR(pGlyph, pEndGlyph, 1 + cxDst, 
            (TB, _T("Read off the end of glyph data")));

        CHECK_WRITE_ONE_BYTE_NO_HR(pjDst, pEndBuffer,  
            (TB, _T("Write off the end of glyph data")));

        DCUINT8 c0 = *pGlyph++;
        DCUINT8 c1;
        pjDstEnd = pjDst + cxDst;

        *pjDst |= c0 >> RightRot;
        pjDst++;
        c1 = (DCUINT8)(c0 << rl);

        CHECK_CALC_END( pjDstEnd, pEndBuffer );

        //
        // know cxDst is at least 4, use do-while
        //
        while (pjDst != pjDstEnd) {
            c0 = *pGlyph;
            *pjDst = (DCUINT8)((c0 >> RightRot) | c1);
            c1 = (DCUINT8)(c0 << rl);
            pjDst++;
            pGlyph++;

        } 

        pjDst += lStride;

    }  
DC_EXIT_POINT:
    return;
}

VOID
or_all_N_wide_rotated_need_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PDCUINT8  pGlyph,
    PDCUINT8 pEndGlyph,
    PDCUINT8  pBuffer,
    PDCUINT8  pEndBuffer,
    LONG    cxGlyph,
    LONG    cxDst
    )
{
    DC_BEGIN_FN("or_all_N_wide_rotated_need_last");
    
    PDCUINT8 pjDst      = (PDCUINT8)pBuffer;
    PDCUINT8 pjDstEnd;
    PDCUINT8 pjDstEndy  = pBuffer + ulBufDelta * cyGlyph;
    LONG   lStride    = ulBufDelta - cxDst;
    LONG   rl         = 8-RightRot;

    DC_IGNORE_PARAMETER(cxGlyph);

    //
    // source doesn't advance after first byte, and
    // we do the first byte outside the loop
    //

    while (pjDst != pjDstEndy) {

        CHECK_READ_N_BYTES_NO_HR(pGlyph, pEndGlyph, 1 + cxDst, 
            (TB, _T("Read off the end of glyph data")));

        DCUINT8 c0 = *pGlyph++;
        DCUINT8 c1;
        pjDstEnd = pjDst + cxDst;

        CHECK_WRITE_ONE_BYTE_NO_HR(pjDst, pEndBuffer,  
            (TB, _T("Write off the end of glyph data")));

        *pjDst |= c0 >> RightRot;
        pjDst++;
        c1 = (DCUINT8)(c0 << rl);

        //
        // know cxDst is at least 4, use do-while
        //
        CHECK_CALC_END( pjDstEnd, pEndBuffer );
        while (pjDst != pjDstEnd) {
            c0 = *pGlyph;
            *pjDst |= ((c0 >> RightRot) | c1);
            c1 = (DCUINT8)(c0 << rl);
            pjDst++;
            pGlyph++;

        } 

        pjDst += lStride;
    }  
DC_EXIT_POINT:
    return;
}

VOID
or_first_N_wide_rotated_no_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PDCUINT8  pGlyph,
    PDCUINT8 pEndGlyph,
    PDCUINT8  pBuffer,
    PDCUINT8  pEndBuffer,
    LONG    cxGlyph,
    LONG    cxDst
    )
{
    DC_BEGIN_FN("or_first_N_wide_rotated_no_last");
    
    PDCUINT8 pjDst      = (PDCUINT8)pBuffer;
    PDCUINT8 pjDstEnd;
    PDCUINT8 pjDstEndy  = pBuffer + ulBufDelta * cyGlyph;
    LONG   lStride    = ulBufDelta - cxDst;
    LONG   rl         = 8-RightRot;

    DC_IGNORE_PARAMETER(cxGlyph);

    //
    // source doesn't advance after first byte, and
    // we do the first byte outside the loop
    //

    while (pjDst != pjDstEndy) {

        DCUINT8 c0;
        DCUINT8 c1;
        pjDstEnd = pjDst + cxDst - 1;

        CHECK_READ_N_BYTES_NO_HR(pGlyph, pEndGlyph, 1 + cxDst, 
            (TB, _T("Read off the end of glyph data")));
        CHECK_WRITE_ONE_BYTE_NO_HR(pjDst, pEndBuffer,  
            (TB, _T("Write off the end of glyph data")));

        //
        // do first dest byte outside loop for OR
        //

        c1 = 0;
        c0 = *pGlyph;
        *pjDst |= ((c0 >> RightRot) | c1);
        pjDst++;
        pGlyph++;


        //
        // know cxDst is at least 4, use do-while
        //
        CHECK_CALC_END( pjDstEnd + 1, pEndBuffer );

        while (pjDst != pjDstEnd) {
            c0 = *pGlyph;
            *pjDst = (DCUINT8)((c0 >> RightRot) | c1);
            c1 = (DCUINT8)(c0 << rl);
            pjDst++;
            pGlyph++;

        } 

        //
        // last dst byte outside loop, no new src needed
        //

        *pjDst = c1;
        pjDst++;

        pjDst += lStride;

    }  
DC_EXIT_POINT:
    return;
}

VOID
or_all_N_wide_rotated_no_last(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PDCUINT8  pGlyph,
    PDCUINT8 pEndGlyph,
    PDCUINT8  pBuffer,
    PDCUINT8  pEndBuffer,
    LONG    cxGlyph,
    LONG    cxDst
    )
{
    DC_BEGIN_FN("or_all_N_wide_rotated_no_last");
    
    PDCUINT8 pjDst      = (PDCUINT8)pBuffer;
    PDCUINT8 pjDstEnd;
    PDCUINT8 pjDstEndy  = pBuffer + ulBufDelta * cyGlyph;
    LONG   lStride    = ulBufDelta - cxDst;
    LONG   rl         = 8-RightRot;

    DC_IGNORE_PARAMETER(cxGlyph);

    //
    // source doesn't advance after first byte, and
    // we do the first byte outside the loop
    //
    while (pjDst != pjDstEndy) {

        DCUINT8 c0;
        DCUINT8 c1;
        pjDstEnd = pjDst + cxDst - 1;

        CHECK_READ_N_BYTES_NO_HR(pGlyph, pEndGlyph, 1 + cxDst, 
            (TB, _T("Read off the end of glyph data")));

        //
        // do first dest byte outside loop for OR
        //

        c1 = 0;

        //
        // know cxDst is at least 4, use do-while
        //
        CHECK_CALC_END( pjDstEnd + 1, pEndBuffer );

        while (pjDst != pjDstEnd) {
            c0 = *pGlyph;
            *pjDst |= ((c0 >> RightRot) | c1);
            c1 = (DCUINT8)(c0 << rl);
            pjDst++;
            pGlyph++;
        } 

        //
        // last dst byte outside loop, no new src needed
        //

        *pjDst |= c1;
        pjDst++;

        pjDst += lStride;

    }  
DC_EXIT_POINT:
    return;
}

//
// The following routines can be significantly sped up by
// breaking them out into DWORD alignment cases.
//

VOID
mov_first_N_wide_unrotated(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PDCUINT8  pGlyph,
    PDCUINT8 pEndGlyph,
    PDCUINT8  pBuffer,
    PDCUINT8  pEndBuffer,
    LONG    cxGlyph,
    LONG    cxDst
    )
{
    DC_BEGIN_FN("mov_first_N_wide_unrotated");
    
    PDCUINT8 pjDst      = (PDCUINT8)pBuffer;
    PDCUINT8 pjDstEnd;
    PDCUINT8 pjDstEndy  = pBuffer + ulBufDelta * cyGlyph;
    LONG   lStride    = ulBufDelta - cxDst;

    DC_IGNORE_PARAMETER(cxGlyph);
    DC_IGNORE_PARAMETER(RightRot);


    // SECURITY: cyGlyph reads in the outerloop + cxDst reads in cyGlyph reps of the
    //  inner loop
    CHECK_READ_N_BYTES_NO_HR(pGlyph, pEndGlyph, cyGlyph * cxDst, 
        (TB, _T("Read off the end of glyph data")));

    //
    // byte aligned copy
    //
    while (pjDst != pjDstEndy) {

        pjDstEnd = pjDst + cxDst;

        //
        // let compiler unroll inner loop
        //

        CHECK_CALC_END( pjDstEnd, pEndBuffer );
        while (pjDst != pjDstEnd ) {

            *pjDst++ = *pGlyph++;

        } 

        pjDst += lStride;

    }  
DC_EXIT_POINT:
    return;
}

VOID
or_all_N_wide_unrotated(
    LONG    cyGlyph,
    LONG    RightRot,
    LONG    ulBufDelta,
    PDCUINT8  pGlyph,
    PDCUINT8 pEndGlyph,
    PDCUINT8  pBuffer,
    PDCUINT8  pEndBuffer,
    LONG    cxGlyph,
    LONG    cxDst
    )
{
    DC_BEGIN_FN("or_all_N_wide_unrotated");
    
    PDCUINT8 pjDst      = (PDCUINT8)pBuffer;
    PDCUINT8 pjDstEnd;
    PDCUINT8 pjDstEndy  = pBuffer + ulBufDelta * cyGlyph;
    LONG   lStride    = ulBufDelta - cxDst;

    DC_IGNORE_PARAMETER(cxGlyph);
    DC_IGNORE_PARAMETER(RightRot);

    // SECURITY: cyGlyph reads in the outerloop + cxDst reads in cyGlyph reps of the
    //  inner loop
    CHECK_READ_N_BYTES_NO_HR(pGlyph, pEndGlyph, cyGlyph * cxDst, 
        (TB, _T("Read off the end of glyph data")));

    //
    // byte aligned copy
    //


    while (pjDst != pjDstEndy) {

        pjDstEnd = pjDst + cxDst;

        //
        // let compiler unroll inner loop
        //

        CHECK_CALC_END( pjDstEnd, pEndBuffer );
        while (pjDst != pjDstEnd ) {

            *pjDst++ |= *pGlyph++;

        } 

        pjDst += lStride;

    }  
DC_EXIT_POINT:
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\xtapi.cpp ===
/****************************************************************************/
// xtapi.cpp
//
// XT layer - portable API
//
// Copyright (C) 1997-1999 Microsoft Corporation
/****************************************************************************/

#include <adcg.h>
extern "C" {
#define TRC_FILE "xtapi"
#define TRC_GROUP TRC_GROUP_NETWORK
#include <atrcapi.h>
}

#include "autil.h"
#include "xt.h"
#include "cd.h"
#include "nl.h"
#include "sl.h"
#include "mcs.h"




CXT::CXT(CObjs* objs)
{
    _pClientObjects = objs;
}

CXT::~CXT()
{
}


/****************************************************************************/
/* Name:      XT_Init                                                       */
/*                                                                          */
/* Purpose:   Initializes _XT.  Since XT is stateless, this just involves    */
/*            initializing TD.                                              */
/****************************************************************************/
DCVOID DCAPI CXT::XT_Init(DCVOID)
{
    DC_BEGIN_FN("XT_Init");

    /************************************************************************/
    /* Initialize our global data.                                          */
    /************************************************************************/
    DC_MEMSET(&_XT, 0, sizeof(_XT));

    _pCd  = _pClientObjects->_pCdObject;
    _pSl  = _pClientObjects->_pSlObject;
    _pTd  = _pClientObjects->_pTDObject;
    _pMcs = _pClientObjects->_pMCSObject;
    _pUt  = _pClientObjects->_pUtObject;
    _pUi  = _pClientObjects->_pUiObject;
    _pClx = _pClientObjects->_pCLXObject;

    TRC_NRM((TB, _T("XT pkt max-size:%u min-size:%u"),
             XT_MAX_HEADER_SIZE,
             XT_MIN_HEADER_SIZE));

    _pTd->TD_Init();

    TRC_NRM((TB, _T("XT successfully initialized")));

    DC_END_FN();
} /* XT_Init */


/****************************************************************************/
/* Name:      XT_SendBuffer                                                 */
/*                                                                          */
/* Purpose:   Adds the XT data packet header and then sends the packet.     */
/*                                                                          */
/* Params:    IN  pData      - pointer to the start of the data.            */
/*            IN  dataLength - amount of the buffer used.                   */
/*            IN  bufHandle  - handle to a buffer.                          */
/****************************************************************************/
DCVOID DCAPI CXT::XT_SendBuffer(PDCUINT8  pData,
                           DCUINT    dataLength,
                           XT_BUFHND bufHandle)
{
    DCUINT packetLength;
    XT_DT xtDT = XT_DT_DATA;

    DC_BEGIN_FN("XT_SendBuffer");

    /************************************************************************/
    /* Check that we're not being asked to send more data than we can.      */
    /************************************************************************/
    TRC_ASSERT((dataLength <= XT_MAX_DATA_SIZE),
               (TB, _T("Data exceeds XT TSDU length of %u"), XT_MAX_DATA_SIZE));

    /************************************************************************/
    /* Add our XT data header.  All the invariant fields are already        */
    /* initialized, so all that remains to be filled in is the packet       */
    /* length.                                                              */
    /************************************************************************/
    packetLength = dataLength + sizeof(XT_DT);
    xtDT.hdr.lengthHighPart = ((DCUINT16)packetLength) >> 8;
    xtDT.hdr.lengthLowPart = ((DCUINT16)packetLength) & 0xFF;
    
    TRC_DBG((TB, _T("XT pkt length:%u"), packetLength));

    /************************************************************************/
    /* Now update the data pointer to point to the include the XT data      */
    /* header.                                                              */
    /************************************************************************/
    TRC_DBG((TB, _T("Move pData back from %p to %p"),
             pData,
             pData - sizeof(XT_DT)));
    pData -= sizeof(XT_DT);

    /************************************************************************/
    /* Copy in the header.                                                  */
    /************************************************************************/
    memcpy(pData, &xtDT, sizeof(XT_DT));

    /************************************************************************/
    /* Trace out the packet.                                                */
    /************************************************************************/
    TRC_DATA_DBG("XT packet:", pData, packetLength);

    /************************************************************************/
    /* Now send the buffer.                                                 */
    /************************************************************************/
    _pTd->TD_SendBuffer(pData, packetLength, (TD_BUFHND)bufHandle);

    DC_END_FN();
} /* XT_SendBuffer */


/****************************************************************************/
/* Name:      XT_Recv                                                       */
/*                                                                          */
/* Purpose:   Attempts to retrieve the requested number of bytes into the   */
/*            buffer pointed to by pBuffer.  This function should only      */
/*            be called in response to an MCS_OnXTDataAvailable callback.   */
/*                                                                          */
/* Returns:   The number of bytes received.                                 */
/*                                                                          */
/* Params:    IN  pData  - pointer to buffer to receive the data.           */
/*            IN  length - number of bytes to receive.                      */
/****************************************************************************/
DCUINT DCAPI CXT::XT_Recv(PDCUINT8 pData, DCUINT length)
{
    DCUINT bytesRead;
    DCUINT numBytes;

    DC_BEGIN_FN("XT_Recv");

    TRC_ASSERT((length != 0), (TB, _T("Data length to receive is 0")));
    TRC_ASSERT((length < 65535),(TB,_T("Data length %u too large"), length));
    TRC_ASSERT((pData != 0), (TB, _T("Data pointer is NULL")));

    // We can only receive the minimum of the number of bytes in XT and
    // the requested length.
    numBytes = DC_MIN(length, _XT.dataBytesLeft);
    TRC_DBG((TB, _T("Receive %u bytes (length:%u dataBytesLeft:%u)"),
            numBytes, length, _XT.dataBytesLeft));

    // Try to read the bytes from TD.
    bytesRead = _pTd->TD_Recv(pData, numBytes);

    // Decrement the count of data bytes left in _XT.
    _XT.dataBytesLeft -= bytesRead;
    TRC_DBG((TB, _T("%u data bytes left in XT frame"), _XT.dataBytesLeft));

    if (!_pTd->TD_QueryDataAvailable() || (0 == _XT.dataBytesLeft)) {
        // TD has no more data or this XT frame is finished - so there is
        // no longer any data left in _XT.
        TRC_DBG((TB, _T("No data left in XT")));
        _XT.dataInXT = FALSE;
    }

    TRC_DATA_DBG("Data received:", pData, bytesRead);

    DC_END_FN();
    return bytesRead;
} /* XT_Recv */


/****************************************************************************/
/* Name:      XT_OnTDConnected                                              */
/*                                                                          */
/* Purpose:   This is called by TD when it has successfully connected.      */
/****************************************************************************/
DCVOID DCCALLBACK CXT::XT_OnTDConnected(DCVOID)
{
    DC_BEGIN_FN("XT_OnTDConnected");

    TRC_NRM((TB, _T("TD connected: init states and decouple CR send")));

    // Initialize our state and count of bytes that we're waiting for.
    // Fast-path server output can send as small as 2 bytes for a header,
    // so we init the header receive size to get 2 bytes, which we'll expand
    // to X.224 or fast-path remainder as needed when receiving.
    //
    // Also reset the count of data bytes left and flag that there is
    // currently no data in _XT.
    XT_ResetDataState();

    // Decouple to the sender thread and send a XT CR.
    
    _pCd->CD_DecoupleSimpleNotification(CD_SND_COMPONENT, this,
                                  CD_NOTIFICATION_FUNC(CXT,XTSendCR),
                                  0);

    DC_END_FN();
} /* XT_OnTDConnected */


/****************************************************************************/
/* Name:      XT_OnTDDisconnected                                           */
/*                                                                          */
/* Purpose:   This callback function is called by TD when it has            */
/*            disconnected.                                                 */
/*                                                                          */
/* Params:    IN  reason - reason for the disconnection.                    */
/****************************************************************************/
DCVOID DCCALLBACK CXT::XT_OnTDDisconnected(DCUINT reason)
{
    DC_BEGIN_FN("XT_OnTDDisconnected");

    TRC_ASSERT((reason != 0), (TB, _T("Disconnect reason from TD is 0")));

    /************************************************************************/
    /* Decide if we want to over-ride the disconnect reason code.           */
    /************************************************************************/
    if (_XT.disconnectErrorCode != 0)
    {
        TRC_ALT((TB, _T("Over-riding disconnection error code (%u->%u)"),
                 reason,
                 _XT.disconnectErrorCode));

        /********************************************************************/
        /* Over-ride the error code and set the global variable to 0.       */
        /********************************************************************/
        reason = _XT.disconnectErrorCode;
        _XT.disconnectErrorCode = 0;
    }

    /************************************************************************/
    /* Just pass this up to MCS.                                            */
    /************************************************************************/
    TRC_NRM((TB, _T("Disconnect reason:%u"), reason));
    _pMcs->MCS_OnXTDisconnected(reason);

    DC_END_FN();
} /* XT_OnTDDisconnected */


/****************************************************************************/
// XTRecvToHdrBuf
//
// Receives data into the header buffer.
// We use a macro to force cutting the function call overhead. Data-receive
// must be as fast as possible, at the expense of a bit of code size.
// Returns TRUE in bytesNeededZero if the receive bytes needed count is zero.
// Returns FALSE in status if an invalid number of bytes is being read
// 
/****************************************************************************/
#define XTRecvToHdrBuf(bytesNeededZero,status) {  \
    unsigned bytesRecv;  \
\
    /* Check that we're being asked to receive some data and that the */  \
    /* header buffer has space for it.                                */  \
    /* We also chech the unsigned overflow here. If we add to a trusted */ \
    /* size (_XT.hdrBytesRead) anything the result should not be smaller */ \
    /* then the trusted size. */ \
    TRC_ASSERT((0 != _XT.hdrBytesNeeded), (TB, _T("No data to receive")));  \
    TRC_ASSERT((_XT.hdrBytesRead + _XT.hdrBytesNeeded <= sizeof(_XT.pHdrBuf)),  \
            (TB, _T("Header buffer size %u too small for %u read + %u needed"),  \
            sizeof(_XT.pHdrBuf),  \
            _XT.hdrBytesRead,  \
            _XT.hdrBytesNeeded));  \
    TRC_ASSERT((_XT.hdrBytesRead + _XT.hdrBytesNeeded >= _XT.hdrBytesRead),  \
            (TB, _T("Header size overflow caused by %u read + %u needed"),  \
            sizeof(_XT.pHdrBuf),  \
            _XT.hdrBytesRead,  \
            _XT.hdrBytesNeeded));  \
    if ((_XT.hdrBytesRead + _XT.hdrBytesNeeded <= sizeof(_XT.pHdrBuf))) \
    { \
        bytesRecv = _pTd->TD_Recv(_XT.pHdrBuf + _XT.hdrBytesRead, _XT.hdrBytesNeeded);  \
        _XT.hdrBytesNeeded -= bytesRecv;  \
        _XT.hdrBytesRead   += bytesRecv;  \
        bytesNeededZero = (0 == _XT.hdrBytesNeeded);  \
		status = TRUE; \
    } \
    else \
    { \
        status = FALSE; \
    } \
\
}


/****************************************************************************/
/* Name:      XT_OnTDDataAvailable                                          */
/*                                                                          */
/* Purpose:   This callback function is called by TD when it has received   */
/*            data from the server.                                         */
/****************************************************************************/
DCVOID DCCALLBACK CXT::XT_OnTDDataAvailable(DCVOID)
{
    PXT_CMNHDR pCmnHdr = (PXT_CMNHDR)_XT.pHdrBuf;
    unsigned pktType;
    unsigned unreadPktBytes;
    DCBOOL fAllBytesRecvd = FALSE;
	DCBOOL rcvOk = TRUE;

    DC_BEGIN_FN("XT_OnTDDataAvailable");

    // Check for recursion.
    if (!_XT.inXTOnTDDataAvail) {
        _XT.inXTOnTDDataAvail = TRUE;

        // Loop round while there is data available in TD.
        while (_pTd->TD_QueryDataAvailable()) {
            TRC_DBG((TB, _T("Data available from TD, state:%u"), _XT.rcvState));

            switch (_XT.rcvState) {
                case XT_RCVST_HEADER:
                    XTRecvToHdrBuf(fAllBytesRecvd, rcvOk);
                    if (fAllBytesRecvd && rcvOk) {
                        // We've read the first two bytes, and can now decide
                        // what type of packet this is.
                        if ((_XT.pHdrBuf[0] & TS_OUTPUT_FASTPATH_ACTION_MASK) ==
                                TS_OUTPUT_FASTPATH_ACTION_FASTPATH) {
                            // This is a fast-path output header. The length
                            // is in the second and, maybe, third byte.
                            if (!(_XT.pHdrBuf[1] & 0x80)) {
                                // Length was in first byte only. Proceed to
                                // the data state.
                                _XT.hdrBytesNeeded =
                                        XT_FASTPATH_OUTPUT_BASE_HEADER_SIZE;
                                _XT.hdrBytesRead = 0;
                                _XT.rcvState =
                                        XT_RCVST_FASTPATH_OUTPUT_BEGIN_DATA;

                                // Before updating the count of data bytes
                                // left, assert that it is currently zero.
                                TRC_ASSERT((0 == _XT.dataBytesLeft),
                                           (TB, _T("Data bytes left non-zero:%u"),
                                            _XT.dataBytesLeft));
                                _XT.dataBytesLeft = _XT.pHdrBuf[1] - 2;

                                if (_XT.dataBytesLeft >= 2) {
                                    TRC_DBG((TB,_T("Fast-path output pkt, ")
                                            _T("size=%u"), _XT.dataBytesLeft));

                                    MCS_SetDataLengthToReceive(_pMcs,
                                            _XT.dataBytesLeft);

                                    /************************************************************/
                                    /* There is a retail check for size in MCS_RecvToDataBuf,   */
                                    /* but this helps us debug it before that point.            */
                                    /************************************************************/
                                    TRC_ASSERT((_pMcs->_MCS.dataBytesNeeded < 65535),
                                            (TB,_T("Data recv size %u too large"), _pMcs->_MCS.dataBytesNeeded));
                                }
                                else {
                                    TRC_ABORT((TB, _T("Fast-path size byte %02X")
                                            _T("contains len < 2"),
                                            _XT.pHdrBuf[1]));

                                    TRC_ASSERT((0 == _XT.disconnectErrorCode),
                                            (TB, _T("Disconnect error code ")
                                            _T("already set!")));
                                    _XT.disconnectErrorCode =
                                            NL_MAKE_DISCONNECT_ERR(
                                            NL_ERR_XTBADHEADER);
                                    _pTd->TD_Disconnect();
                                    goto PostDataRead;
                                }
                            }
                            else {
                                _XT.hdrBytesNeeded = 1;
                                _XT.rcvState = XT_RCVST_FASTPATH_OUTPUT_HEADER;
                            }
                        }
                        else {
                            // The first byte is standard X.224. Reset the
                            // state to read a full X.224 header.
                            _XT.hdrBytesNeeded = sizeof(XT_DT) -
                                    XT_FASTPATH_OUTPUT_BASE_HEADER_SIZE;
                            _XT.rcvState = XT_RCVST_X224_HEADER;
                        }
                    }
                    else if (!rcvOk)
                    {
                        TRC_ERR((TB,_T("Recv to hdrbuf failed bailing out")));
                        _XT.disconnectErrorCode =
                                NL_MAKE_DISCONNECT_ERR(
                                NL_ERR_XTBADHEADER);
                        _pTd->TD_Disconnect();
                        goto PostDataRead;
                    }
                    break;


                case XT_RCVST_FASTPATH_OUTPUT_HEADER:
                    XTRecvToHdrBuf(fAllBytesRecvd, rcvOk);
                    if (fAllBytesRecvd && rcvOk) {
                        // This is a long fast-path output header (3 bytes).
                        // Get the size from the second and third bytes and
                        // change to data state.
                        _XT.hdrBytesNeeded =
                                XT_FASTPATH_OUTPUT_BASE_HEADER_SIZE;
                        _XT.hdrBytesRead = 0;
                        _XT.rcvState = XT_RCVST_FASTPATH_OUTPUT_BEGIN_DATA;

                        // Before updating the count of data bytes left,
                        // assert that it is currently zero.
                        TRC_ASSERT((0 == _XT.dataBytesLeft),
                                (TB, _T("Data bytes left non-zero:%u"),
                                _XT.dataBytesLeft));
                        _XT.dataBytesLeft = (((_XT.pHdrBuf[1] & 0x7F) << 8) |
                                _XT.pHdrBuf[2]) - 3;

                        if (_XT.dataBytesLeft >= 3) {
                            TRC_DBG((TB,_T("Fast-path output pkt, size=%u"),
                                    _XT.dataBytesLeft));

                            MCS_SetDataLengthToReceive(_pMcs, _XT.dataBytesLeft);

                            /************************************************************/
                            /* There is a retail check for size in MCS_RecvToDataBuf,   */
                            /* but this helps us debug it before that point.            */
                            /************************************************************/
                            TRC_ASSERT((_pMcs->_MCS.dataBytesNeeded < 65535),
                                    (TB,_T("Data recv size %u too large"), _pMcs->_MCS.dataBytesNeeded));
                        }
                        else {
                            TRC_ABORT((TB, _T("Fast-path size bytes %02X %02X")
                                    _T("contain len < 3"),
                                    _XT.pHdrBuf[1], _XT.pHdrBuf[2]));

                            TRC_ASSERT((0 == _XT.disconnectErrorCode),
                                    (TB, _T("Disconnect error code ")
                                    _T("already set!")));
                            _XT.disconnectErrorCode =
                                    NL_MAKE_DISCONNECT_ERR(
                                    NL_ERR_XTBADHEADER);
                            _pTd->TD_Disconnect();
                            goto PostDataRead;
                        }
                    }
                    else if (!rcvOk)
                    {
                        TRC_ERR((TB,_T("Recv to hdrbuf failed bailing out")));
                        _XT.disconnectErrorCode =
                                NL_MAKE_DISCONNECT_ERR(
                                NL_ERR_XTBADHEADER);
                        _pTd->TD_Disconnect();
                        goto PostDataRead;
                    }

                    break;


                case XT_RCVST_FASTPATH_OUTPUT_BEGIN_DATA: {
                    BYTE FAR *_pTdData;

                    // If we can, use the fully-recv()'d data straight from
                    // the TD buffer, since fast-path does not need to
                    // copy to an aligned buffer. Since we're at state
                    // BEGIN_DATA we know we've not yet read any post-header
                    // output data. The most common implementation of recv()
                    // copies into the target buffer the entire data for one
                    // TCP sequence (i.e. one server OUTBUF) if the target
                    // buffer is large enough. Which means that most often
                    // we'll be able to use the data directly, since the TD
                    // receive buffer size is tuned to accept an entire large
                    // (~8K) server OUTBUF. If we can't get the full data,
                    // copy into the MCS buffer and move to CONTINUE_DATA.
                    TD_GetDataForLength(_pMcs->_MCS.dataBytesNeeded, &_pTdData, _pTd);
                    if (_pTdData != NULL) {
                        HRESULT hrTemp;
                        // We've gotten all the data. Now we can fast-path
                        // call past all the layering to SL for decryption.
                        hrTemp = _pSl->SL_OnFastPathOutputReceived(_pTdData,
                                _pMcs->_MCS.dataBytesNeeded,
                                _XT.pHdrBuf[0] & TS_OUTPUT_FASTPATH_ENCRYPTED,
                                _XT.pHdrBuf[0] & TS_OUTPUT_FASTPATH_SECURE_CHECKSUM);

                        // Reset for the next header.
                        _pMcs->_MCS.dataBytesRead = 0;
                        _XT.dataBytesLeft = 0;
                        _XT.rcvState = XT_RCVST_HEADER;

                        if (!SUCCEEDED(hrTemp))
                        {
                            XT_IgnoreRestofPacket();
                            goto PostDataRead;
                        }
                    }
                    else {
                        HRESULT hrTemp;

                        // Copy for reassembly directly into the MCS data buffer.
                        MCS_RecvToDataBuf(hrTemp, this, _pMcs);
                        if (!SUCCEEDED(hrTemp))
                        {
                            TRC_ABORT((TB,_T("Recv to databuf failed bailing out")));
                            _XT.disconnectErrorCode =
                                    NL_MAKE_DISCONNECT_ERR(
                                    NL_ERR_XTBADHEADER);
                            _pTd->TD_Disconnect();
                            goto PostDataRead;
                        }

                        fAllBytesRecvd = (S_OK == hrTemp);
                        if (fAllBytesRecvd) {
                            // We've gotten all the data. Now we can fast-path
                            // call past all the layering to SL for decryption.
                            hrTemp = _pSl->SL_OnFastPathOutputReceived(_pMcs->_MCS.pReceivedPacket,
                                    _pMcs->_MCS.dataBytesRead,
                                    _XT.pHdrBuf[0] & TS_OUTPUT_FASTPATH_ENCRYPTED,
                                    _XT.pHdrBuf[0] & TS_OUTPUT_FASTPATH_SECURE_CHECKSUM);

                            // Reset for the next header.
                            _pMcs->_MCS.dataBytesRead = 0;
                            _XT.dataBytesLeft = 0;
                            _XT.rcvState = XT_RCVST_HEADER;

                            if (!SUCCEEDED(hrTemp))
                            {
                                goto PostDataRead;
                            }
                        }
                        else {
                            _XT.rcvState = XT_RCVST_FASTPATH_OUTPUT_CONTINUE_DATA;
                        }
                    }

                    break;
                }


                case XT_RCVST_FASTPATH_OUTPUT_CONTINUE_DATA:
                {
                    HRESULT hrTemp;

                    // Copy for reassembly directly into the MCS data buffer.
                    MCS_RecvToDataBuf(hrTemp, this, _pMcs);
                    if (!SUCCEEDED(hrTemp))
                    {
                        TRC_ABORT((TB,_T("Recv to databuf failed bailing out")));
                        _XT.disconnectErrorCode =
                                NL_MAKE_DISCONNECT_ERR(
                                NL_ERR_XTBADHEADER);
                        _pTd->TD_Disconnect();
                        goto PostDataRead;
                    }

                    fAllBytesRecvd = (S_OK == hrTemp);
                    if (fAllBytesRecvd) {
                        // We've gotten all the data. Now we can fast-path
                        // call past all the layering to SL for decryption.
                        hrTemp = _pSl->SL_OnFastPathOutputReceived(_pMcs->_MCS.pReceivedPacket,
                                _pMcs->_MCS.dataBytesRead,
                                _XT.pHdrBuf[0] & TS_OUTPUT_FASTPATH_ENCRYPTED,
                                _XT.pHdrBuf[0] & TS_OUTPUT_FASTPATH_SECURE_CHECKSUM);

                        // Reset for the next header.
                        _pMcs->_MCS.dataBytesRead = 0;
                        _XT.dataBytesLeft = 0;
                        _XT.rcvState = XT_RCVST_HEADER;

                        if (!SUCCEEDED(hrTemp))
                        {
                            goto PostDataRead;
                        }
                    }
                    else {
                        _XT.rcvState = XT_RCVST_FASTPATH_OUTPUT_CONTINUE_DATA;
                    }

                    break;
                }

                case XT_RCVST_X224_HEADER:
                    XTRecvToHdrBuf(fAllBytesRecvd, rcvOk);
                    if (fAllBytesRecvd && rcvOk) {
                        // We've read a complete X.224 common header, so we
                        // can now attempt to interpret it. First of all check
                        // that the TPKT version is correct.
                        if (pCmnHdr->vrsn != XT_TPKT_VERSION)
                        {
                            TRC_ABORT((TB, _T("Unknown TPKT version:%u"),
                                       (DCUINT)pCmnHdr->vrsn));

                            TRC_ASSERT((0 == _XT.disconnectErrorCode),
                             (TB, _T("Disconnect error code already set!")));
                            _XT.disconnectErrorCode =
                                  NL_MAKE_DISCONNECT_ERR(
                                  NL_ERR_XTBADTPKTVERSION);

                            // Something very bad has happened so just
                            // disconnect.
                            _pTd->TD_Disconnect();
                            goto PostDataRead;
                        }

                        // Get the packet type - this is given by the top four
                        // bits of the crcDt field.
                        pktType = pCmnHdr->typeCredit >> 4;

                        // Calculate the number of unread bytes in the packet.
                        unreadPktBytes = ((pCmnHdr->lengthHighPart << 8) | pCmnHdr->lengthLowPart) -
                                _XT.hdrBytesRead;
                  
                        TRC_DBG((TB, _T("Pkt type:%u read:%u unread:%u"),
                                 pktType,
                                 _XT.hdrBytesRead,
                                 unreadPktBytes));

                        if (XT_PKT_DT == pktType) {
                            // This is a data packet - we don't need to
                            // receive any more header bytes. Update our
                            // state variables.
                            _XT.hdrBytesNeeded =
                                    XT_FASTPATH_OUTPUT_BASE_HEADER_SIZE;
                            _XT.hdrBytesRead = 0;
                            _XT.rcvState = XT_RCVST_X224_DATA;

                            // Before updating the count of data bytes left,
                            // assert that it is currently zero.
                            TRC_ASSERT((0 == _XT.dataBytesLeft),
                                       (TB, _T("Data bytes left non-zero:%u"),
                                        _XT.dataBytesLeft));              

                            _XT.dataBytesLeft = unreadPktBytes;
                            //
                            //    Here we don't have to check the unreadPktBytes
                            //    because this can't cause an overflow. The size
                            //    of the data in an XT packet can be as much as 
                            //    XT_MAX_DATA_SIZE and it should be checked by
                            //    the protocols above. 
                            //
                            TRC_ASSERT((XT_MAX_DATA_SIZE >= _XT.dataBytesLeft),
                                       (TB, _T("Data bytes left too big:%u"),
                                        _XT.dataBytesLeft)); 

                            TRC_DBG((TB, _T("Data pkt(size:%u) state HDR->DATA"),
                                     _XT.dataBytesLeft));
                        }
                        else {
                            // This is a control packet - we need to receive
                            // some more bytes.

                            //    Here we have a real issue if we have an overflow.
                            //    We have to check that what we still have to read
                            //    is not going to overflow the buffer. We check
                            //    the overflow against the hdrBytesRead because
                            //    this is a trusted value.                            
                            if ((_XT.hdrBytesRead + unreadPktBytes > 
                                                     sizeof(_XT.pHdrBuf)) ||
                                (_XT.hdrBytesRead + unreadPktBytes < 
                                                            _XT.hdrBytesRead)) {
                                TRC_ERR((TB,_T("The header length is too big.")));
                                _XT.disconnectErrorCode =
                                        NL_MAKE_DISCONNECT_ERR(
                                        NL_ERR_XTBADHEADER);
                                //    TD_Disconnect doesn't have anything to
                                //    do with the XT state so we have to reset
                                //    the XT state in order to have a successful
                                //    disconnect
                                _pTd->TD_Disconnect();
                                XT_IgnoreRestofPacket();
                                goto PostDataRead;
                            }
                            
                            _XT.hdrBytesNeeded = unreadPktBytes;
                            _XT.rcvState       = XT_RCVST_X224_CONTROL;

                            TRC_NRM((TB, _T("Ctrl pkt state HEADER->CONTROL")));
                        }
                    }
                    else if (!rcvOk)
                    {
                        TRC_ERR((TB,_T("Recv to hdrbuf failed bailing out")));
                        _XT.disconnectErrorCode =
                                NL_MAKE_DISCONNECT_ERR(
                                NL_ERR_XTBADHEADER);
                        _pTd->TD_Disconnect();
                        goto PostDataRead;
                    }
                    break;


                case XT_RCVST_X224_CONTROL:
                    XTRecvToHdrBuf(fAllBytesRecvd, rcvOk);
                    if (fAllBytesRecvd && rcvOk) {
                        // We've now managed to get a whole packet, so try to
                        // interpret it.
                        XTHandleControlPkt();

                        // Update our states.
                        _XT.rcvState = XT_RCVST_HEADER;
                        _XT.hdrBytesNeeded =
                                XT_FASTPATH_OUTPUT_BASE_HEADER_SIZE;
                        _XT.hdrBytesRead = 0;

                        TRC_NRM((TB, _T("Processed ctrl pkt state CONTROL->HEADER")));
                    }
                    else if (!rcvOk)
                    {
                        TRC_ERR((TB,_T("Recv to hdrbuf failed bailing out")));
                        _XT.disconnectErrorCode =
                                NL_MAKE_DISCONNECT_ERR(
                                NL_ERR_XTBADHEADER);
                        _pTd->TD_Disconnect();
                        goto PostDataRead;
                    }
                    break;


                case XT_RCVST_X224_DATA:
                    // We now have some data available, so set our flag and
                    // callback to MCS.
                    _XT.dataInXT = TRUE;
                    if (_pMcs->MCS_OnXTDataAvailable()) {
                        // MCS has finished with this frame.  This frame
                        // should not have any remaining data in it!
                        TRC_ASSERT((_XT.dataBytesLeft == 0),
                                (TB, _T("Unexpected extra %u bytes in the frame"),
                                _XT.dataBytesLeft));
                        if (_XT.dataBytesLeft != 0)
                        {
                            _XT.disconnectErrorCode =
                                    NL_MAKE_DISCONNECT_ERR(
                                    NL_ERR_XTUNEXPECTEDDATA);
                            _pTd->TD_Disconnect();
                            goto PostDataRead;
                        }

                        // No data remaining so zip back to the expecting
                        // header state.
                        _XT.rcvState = XT_RCVST_HEADER;
                        TRC_DBG((TB, _T("Munched data pkt state DATA->HEADER")));
                    }
                    break;

                default:
                    TRC_ABORT((TB, _T("Unrecognized XT recv state:%u"),
                            _XT.rcvState));
                    goto PostDataRead;
            }
        }

PostDataRead:
        _XT.inXTOnTDDataAvail = FALSE;
        if ( _XT.disconnectErrorCode == 0 ) {
            _pClx->CLX_ClxPktDrawn();
        }
    }
    else {
        TRC_ALT((TB, _T("Recursion!")));
        // Note we need to make sure not to reset _XT.inXTOnTDDataAvail.
    }

    DC_END_FN();
} /* XT_OnTDDataAvailable */


/****************************************************************************/
/* Name:      XTSendCR                                                      */
/*                                                                          */
/* Purpose:   Sends an X224 CR TPDU on the sender thread.                   */
/*                                                                          */
/* Operation: This function gets a private buffer from TD, fills it with    */
/*            an X224 CR and then sends it.                                 */
/****************************************************************************/
DCVOID DCINTERNAL CXT::XTSendCR(ULONG_PTR unused)
{
    PDCUINT8  pBuffer;
    TD_BUFHND bufHandle;
    DCBOOL    intRC;
    XT_CR xtCR = XT_CR_DATA;
    PBYTE     pLBInfo;
    BYTE      HashModeCookie[HASHMODE_COOKIE_LENGTH];
    BYTE      TruncatedUserName[USERNAME_TRUNCATED_LENGTH + 1];
    BOOL      HashMode = FALSE;
    DCUINT8   LBInfoLen;
    HRESULT   hr;
    
    DC_BEGIN_FN("XTSendCR");

    DC_IGNORE_PARAMETER(unused);


    // First set up the load balance information.  The algorithm is as follows:
    // 1. If in the middle of a redirection and there is a redirection cookie,
    //    use the redirection cookie.
    // 2. If in the middle of a redirection and there is no redirection cookie,
    //    use no cookie at all.
    // Otherwise, non-redirection rules apply:
    // 3. If no scripted cookie is available, use the default built-in hash mode
    //    cookie.  ("Cookie: mstshash=<truncated username>" + CR + LF)
    //    Only do this if there is something in the username field.
    // 4. If a scripted cookie is available, use it.

    if (_pUi->UI_IsClientRedirected()) {
        // Handles cases 1 and 2, above.
        pLBInfo = (PBYTE)_pUi->UI_GetRedirectedLBInfo();
    }
    else {
        pLBInfo = (PBYTE)_pUi->UI_GetLBInfo();
        // If pLBInfo is NULL then case 3.  Otherwise, fall through--it's 
        // case 4.
        if (pLBInfo == NULL && _pUi->_UI.UserName[0] != NULL) {
            // Take the 1st 10 ASCII bytes of the username.
            // NOT an error for this to fail as we intentionally truncate
            hr = StringCchPrintfA(
                            (char *) TruncatedUserName,
                            USERNAME_TRUNCATED_LENGTH, 
                            "%S", _pUi->_UI.UserName);
            

            TruncatedUserName[USERNAME_TRUNCATED_LENGTH] = '\0';

            // Create the cookie
            hr = StringCchPrintfA(
                            (char *) HashModeCookie,
                            HASHMODE_COOKIE_LENGTH - 1,
                            "Cookie: mstshash=%s\r\n", 
                            TruncatedUserName);
            if (FAILED(hr)) {
                TRC_ERR((TB,_T("Printf hasmodecookie failed: 0x%x"),hr));
            }

            HashModeCookie[HASHMODE_COOKIE_LENGTH - 1] = NULL;

            pLBInfo = HashModeCookie;

            // Set hash mode to true to indicate pLBInfo is not a BSTR.
            HashMode = TRUE;
        }
    }
    
    if (pLBInfo) {
        DCUINT16 xtLen;

        // If HashMode is FALSE then pLBInfo is a BSTR.  Otherwise it points to
        // bytes.
        if (HashMode == FALSE)
            LBInfoLen = (DCUINT8) SysStringByteLen((BSTR)pLBInfo);
        else
            LBInfoLen = strlen((char *) pLBInfo);
        
        xtLen = (xtCR.hdr.lengthHighPart << 8) + xtCR.hdr.lengthLowPart;
        xtLen += LBInfoLen;
        xtCR.hdr.lengthHighPart = xtLen >> 8;
        xtCR.hdr.lengthLowPart = xtLen & 0xFF;
    }
    else {
        LBInfoLen = 0;
    }
    xtCR.hdr.li += (DCUINT8)LBInfoLen;

    /************************************************************************/
    /* TD is now connected.                                                 */
    /************************************************************************/
    TRC_NRM((TB, _T("Send XT CR...")));

    /************************************************************************/
    /* Get a private buffer in which to send the TD connection request.     */
    /************************************************************************/
    intRC = _pTd->TD_GetPrivateBuffer(sizeof(xtCR) + LBInfoLen, 
                                      &pBuffer, &bufHandle);
    if (intRC) {
        // Fill in the buffer with the CR.
        DC_MEMCPY(pBuffer, &xtCR, sizeof(xtCR));
        if (pLBInfo) {
            DC_MEMCPY(pBuffer + sizeof(xtCR), pLBInfo, LBInfoLen);
        }
        TRC_DATA_NRM("CR data:", &xtCR, sizeof(xtCR));

        // Send the XT CR.
        _pTd->TD_SendBuffer(pBuffer, sizeof(xtCR) + LBInfoLen, bufHandle);
        TRC_NRM((TB, _T("Sent XT CR")));
    }
    else {
        TRC_NRM((TB, _T("Failed to get a private buffer - just quit")));
    }

    DC_END_FN();
} /* XTSendCR */


/****************************************************************************/
/* Name:      XTHandleControlPkt                                            */
/*                                                                          */
/* Purpose:   This function is called after XT has received a control       */
/*            packet.  It is responsible for interpreting the control       */
/*            packet and calling the appropriate functions.                 */
/****************************************************************************/
DCVOID DCINTERNAL CXT::XTHandleControlPkt(DCVOID)
{
    PXT_CMNHDR pCmnHdr = (PXT_CMNHDR) _XT.pHdrBuf;
    DCUINT     pktType;

    DC_BEGIN_FN("XTHandleControlPkt");

    /************************************************************************/
    /* Get the packet type - this is given by the top four bits of the      */
    /* crcDt field.                                                         */
    /************************************************************************/
    pktType = pCmnHdr->typeCredit >> 4;

    TRC_NRM((TB, _T("Pkt type:%u"), pktType));

    /************************************************************************/
    /* Now check for the packet type.                                       */
    /************************************************************************/
    switch (pktType)
    {
        case XT_PKT_CR:
        {
            /****************************************************************/
            /* We don't expect to receive one of these, so trace an alert.  */
            /****************************************************************/
            TRC_ERR((TB, _T("Received unexpected XT CR pkt")));

            /****************************************************************/
            /* We could handle this case by sending a X224 ER or DR packet, */
            /* but instead we'll do the absolute minimum and just ignore    */
            /* this packet (the other side should time-out its connection   */
            /* request).                                                    */
            /****************************************************************/
        }
        break;

        case XT_PKT_CC:
        {
            TRC_NRM((TB, _T("XT CC received")));

            /****************************************************************/
            /* This is a connection confirm.  We're not interested in the   */
            /* contents of this packet - all we need to do is to tell MCS   */
            /* that we're now connected.                                    */
            /****************************************************************/
            _pMcs->MCS_OnXTConnected();
        }
        break;

        case XT_PKT_DR:
        case XT_PKT_ER:
        {
            TRC_NRM((TB, _T("XT DR/ER received")));

            /****************************************************************/
            /* This is a disconnect request or an error - we've either      */
            /* failed to establish the connection or the other party is     */
            /* wanting to disconnect from the existing connection.  Note    */
            /* that we don't need to respond to the DR TPDU (Class 0 X224   */
            /* doesn't provide any way to do so).  Call _pTd->TD_Disconnect to    */
            /* disconnect the layer below us.  TD will call us (XT) back    */
            /* when it has disconnected - at that point we'll tell the      */
            /* layers above that we've disconnected.                        */
            /****************************************************************/
            _pTd->TD_Disconnect();
        }
        break;

        default:
        {
            /****************************************************************/
            /* Something very bad has happened so we'd better try to        */
            /* disconnect.                                                  */
            /****************************************************************/
            TRC_ABORT((TB, _T("Unrecognized XT header - %u"), pktType));

            /****************************************************************/
            /* Set the disconnect error code.  This will be used to         */
            /* over-ride/ the reason code in the OnDisconnected callback.   */
            /****************************************************************/
            TRC_ASSERT((0 == _XT.disconnectErrorCode),
                         (TB, _T("Disconnect error code has already been set!")));
            _XT.disconnectErrorCode =
                                   NL_MAKE_DISCONNECT_ERR(NL_ERR_XTBADHEADER);

            /****************************************************************/
            /* Begin the disconnection.                                     */
            /****************************************************************/
            _pTd->TD_Disconnect();
        }
        break;
    }

    DC_END_FN();
} /* XTHandleControlPkt */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\core\xt.h ===
/****************************************************************************/
// xt.h
//
// XT layer - portable API header.
//
// Copyright (C) 1997-1999 Microsoft Corporation
/****************************************************************************/


#ifndef _H_XT
#define _H_XT

extern "C" {
//#include <amcsapi.h>
//#include <atdapi.h>
#include <adcgdata.h>
}

#include "mcs.h"
#include "td.h"
#include "cd.h"

#define TRC_FILE "xtapi"
#define TRC_GROUP TRC_GROUP_NETWORK


/****************************************************************************/
/* Define the XT buffer handle type.                                        */
/****************************************************************************/
typedef ULONG_PTR          XT_BUFHND;
typedef XT_BUFHND   DCPTR PXT_BUFHND;

/****************************************************************************/
/* Maximum and minimum sizes of an XT header.  These are traced out in      */
/* XT_Init for diagnostic purposes.                                         */
/****************************************************************************/
#define XT_MAX_HEADER_SIZE       DC_MAX(sizeof(XT_CR),                       \
                                   DC_MAX(sizeof(XT_CC),                     \
                                     DC_MAX(sizeof(XT_DR),                   \
                                       DC_MAX(sizeof(XT_DT),                 \
                                              sizeof(XT_ER)))))
#define XT_MIN_HEADER_SIZE       DC_MIN(sizeof(XT_CR),                       \
                                   DC_MIN(sizeof(XT_CC),                     \
                                     DC_MIN(sizeof(XT_DR),                   \
                                       DC_MIN(sizeof(XT_DT),                 \
                                              sizeof(XT_ER)))))


//
// Internal
//

/****************************************************************************/
/* XT receive state variables.                                              */
/****************************************************************************/
#define XT_RCVST_HEADER                        1
#define XT_RCVST_FASTPATH_OUTPUT_HEADER        2
#define XT_RCVST_FASTPATH_OUTPUT_BEGIN_DATA    3
#define XT_RCVST_FASTPATH_OUTPUT_CONTINUE_DATA 4
#define XT_RCVST_X224_HEADER                   5
#define XT_RCVST_X224_CONTROL                  6
#define XT_RCVST_X224_DATA                     7


// The base number of bytes needed to parse a fast-path output header.
#define XT_FASTPATH_OUTPUT_BASE_HEADER_SIZE 2


/****************************************************************************/
/* XT packet types.  These values are the same as those used in the X224    */
/* header.                                                                  */
/****************************************************************************/
#define XT_PKT_CR                    14
#define XT_PKT_CC                    13
#define XT_PKT_DR                    8
#define XT_PKT_DT                    15
#define XT_PKT_ER                    7


/****************************************************************************/
/* Maximum data size.  The maximum length of data in an XT packet (the TSDU */
/* length) is 65535 octets less the length of the XT data header (which is  */
/* 7 octets) so the maximum allowable data len is 65528 octets.             */
/****************************************************************************/
#define XT_MAX_DATA_SIZE            (65535 - sizeof(XT_DT))


/****************************************************************************/
/* TPKT version.  This should always be 3.                                  */
/****************************************************************************/
#define XT_TPKT_VERSION             3


/****************************************************************************/
/* Hard-coded data for XT TPDUs.                                            */
/*                                                                          */
/* First up is the data for the Connect-Request TPDU.                       */
/****************************************************************************/
#define XT_CR_DATA                                                           \
                  {0x03,                   /* TPKT version always = 3    */  \
                   0x00,                   /* Reserved always = 0        */  \
                   0x00,                   /* XT packet length high part */  \
                   0x0B,                   /* XT packet length low part  */  \
                   0x06,                   /* Length indicator           */  \
                   0xE0,                   /* TPDU type and credit       */  \
                   0x00,                   /* Destination ref = 0        */  \
                   0x00,                   /* Source ref                 */  \
                   0x00}                   /* Class and options          */  \


/****************************************************************************/
/* Hard-coded data for the Data TPDU.                                       */
/****************************************************************************/
#define XT_DT_DATA                                                           \
                  {0x03,                   /* TPKT version always = 3    */  \
                   0x00,                   /* Reserved always = 0        */  \
                   0x00,                   /* XT packet length unknown   */  \
                   0x00,                   /* XT packet length unknown   */  \
                   0x02,                   /* Length indicator           */  \
                   0xF0,                   /* TPDU type                  */  \
                   0x80}                   /* Send-sequence number       */  \


/****************************************************************************/
/* Constants used in redirection info in XTSendCR                          */
/****************************************************************************/
#define USERNAME_TRUNCATED_LENGTH 10
#define HASHMODE_COOKIE_LENGTH 32


/****************************************************************************/
/* Inline functions to convert between XT byte order and local byte order.  */
/****************************************************************************/
__inline DCUINT16 DCINTERNAL XTWireToLocal16(DCUINT16 val)
{
    return((DCUINT16) (((DCUINT16)(((PDCUINT8)&(val))[0]) << 8) | \
                                    ((DCUINT16)(((PDCUINT8)&(val))[1]))));
}
#define XTLocalToWire16 XTWireToLocal16


/****************************************************************************/
// Turn on single-byte packing for these structures which we use to
// overlay a byte stream from the network.
/****************************************************************************/
#pragma pack(push, XTpack, 1)

/****************************************************************************/
/* Structure: XT_CMNHDR                                                     */
/*                                                                          */
/* Description: This structure represents the common header part of an XT   */
/*              packet - which is the TPKT header, the X224 length          */
/*              indicator and the X224 type/Credit field.                   */
/****************************************************************************/
typedef struct tagXT_CMNHDR
{
    DCUINT8  vrsn;
    DCUINT8  reserved;
    DCUINT8  lengthHighPart;
    DCUINT8  lengthLowPart;
    DCUINT8  li;
    DCUINT8  typeCredit;
} XT_CMNHDR, DCPTR PXT_CMNHDR;


/****************************************************************************/
/* Structure: XT_CR                                                         */
/*                                                                          */
/* Description: Represents a Connect-Request TPDU.                          */
/****************************************************************************/
typedef struct tagXT_CR
{
    XT_CMNHDR hdr;
    DCUINT16  dstRef;
    DCUINT16  srcRef;
    DCUINT8   classOptions;
} XT_CR, DCPTR PXT_CR;


/****************************************************************************/
/* Structure: XT_CC                                                         */
/*                                                                          */
/* Description: Represents a Connect-Confirm TPDU.                          */
/****************************************************************************/
typedef struct tagXT_CC
{
    XT_CMNHDR hdr;
    DCUINT16  dstRef;
    DCUINT16  srcRef;
    DCUINT8   classOptions;
} XT_CC, DCPTR PXT_CC;


/****************************************************************************/
/* Structure: XT_DR                                                         */
/*                                                                          */
/* Description: Represents a Detach-Request TPDU.                           */
/****************************************************************************/
typedef struct tagXT_DR
{
    XT_CMNHDR hdr;
    DCUINT16  dstRef;
    DCUINT16  srcRef;
    DCUINT8   reason;
} XT_DR, DCPTR PXT_DR;


/****************************************************************************/
/* Structure: XT_DT                                                         */
/*                                                                          */
/* Description: Represents a Data TPDU.                                     */
/****************************************************************************/
typedef struct tagXT_DT
{
    XT_CMNHDR hdr;
    DCUINT8   nrEot;
} XT_DT, DCPTR PXT_DT;


/****************************************************************************/
/* Structure: XT_ER                                                         */
/*                                                                          */
/* Description: Represents an Error TPDU.                                   */
/****************************************************************************/
typedef struct tagXT_ER
{
    XT_CMNHDR hdr;
    DCUINT16  dstRef;
    DCUINT8   cause;
} XT_ER, DCPTR PXT_ER;


/****************************************************************************/
/* Reset structure packing to its default.                                  */
/****************************************************************************/
#pragma pack(pop, XTpack)

/****************************************************************************/
/* Structure: XT_GLOBAL_DATA                                                */
/*                                                                          */
/* Description:                                                             */
/****************************************************************************/
typedef struct tagXT_GLOBAL_DATA
{
    DCUINT  rcvState;
    DCUINT  hdrBytesNeeded;
    DCUINT  hdrBytesRead;
    DCUINT  dataBytesLeft;
    DCUINT  disconnectErrorCode;
    DCBOOL  dataInXT;
    DCUINT8 pHdrBuf[XT_MAX_HEADER_SIZE];
    DCBOOL  inXTOnTDDataAvail;
} XT_GLOBAL_DATA;


class CCD;
class CSL;
class CTD;
class CMCS;
class CUT;

#include "objs.h"



class CXT
{
public:
    CXT(CObjs* objs);
    ~CXT();

public:
    //
    // API functions
    //

    /****************************************************************************/
    /* FUNCTIONS                                                                */
    /****************************************************************************/
    DCVOID DCAPI XT_Init(DCVOID);
    
    DCVOID DCAPI XT_SendBuffer(PDCUINT8  pData,
                               DCUINT    dataLength,
                               XT_BUFHND bufHandle);
    
    DCUINT DCAPI XT_Recv(PDCUINT8 pData, DCUINT length);
    
    DCVOID DCINTERNAL XTSendCR(ULONG_PTR unused);
    EXPOSE_CD_SIMPLE_NOTIFICATION_FN(CXT, XTSendCR); 
    
    DCVOID DCINTERNAL XTHandleControlPkt(DCVOID);

    inline XT_ResetDataState(DCVOID)
    {
        _XT.rcvState       = XT_RCVST_HEADER;
        _XT.hdrBytesNeeded = XT_FASTPATH_OUTPUT_BASE_HEADER_SIZE;
        _XT.hdrBytesRead   = 0;
        _XT.dataBytesLeft  = 0;
        _XT.dataInXT       = FALSE;
    }

    inline XT_IgnoreRestofPacket(DCVOID)
    {
        XT_ResetDataState();
        TD_IgnoreRestofPacket(_pTd);
    }

    //
    // Callbacks
    //

    DCVOID DCCALLBACK XT_OnTDConnected(DCVOID);
    
    DCVOID DCCALLBACK XT_OnTDDisconnected(DCUINT reason);
    
    DCVOID DCCALLBACK XT_OnTDDataAvailable(DCVOID);

    //
    // Static versions (delegate to appropriate instance)
    //
    
    inline static DCVOID DCCALLBACK XT_StaticOnTDConnected(CXT* inst)
    {
        inst->XT_OnTDConnected();
    }
    
    inline static DCVOID DCCALLBACK XT_StaticOnTDDisconnected(CXT* inst, DCUINT reason)
    {
        inst->XT_OnTDDisconnected( reason);
    }
    
    inline DCVOID DCCALLBACK XT_StaticOnTDBufferAvailable(CXT* inst)
    {
        inst->XT_OnTDBufferAvailable();
    }


    /****************************************************************************/
    /* Name:      XT_Term                                                       */
    /*                                                                          */
    /* Purpose:   This terminates _XT.  Since XT is stateless and doesn't own    */
    /*            any resources which need to be freed this function just calls */
    /*            _pTd->TD_Term.                                                      */
    /****************************************************************************/
    inline DCVOID DCAPI XT_Term(DCVOID)
    {
        _pTd->TD_Term();
    } /* XT_Term */
    
    
    /****************************************************************************/
    /* Name:      XT_Connect                                                    */
    /*                                                                          */
    /* Purpose:   Initiates the XT connection process.  The first stage is      */
    /*            to connect TD - which will result in an asynchronous          */
    /*            callback.  Upon receiving this callback, XT can continue the  */
    /*            connection process.                                           */
    /*                                                                          */
    /* Params:    IN  bInitiateConnect - TRUE if initate connection, FALSE      */
    /*                                   connect with existing socket           */
    /*            IN  pServerAddress - the address of the server to connect to. */
    /****************************************************************************/
    inline DCVOID DCAPI XT_Connect(BOOL bInitiateConnect, PDCTCHAR pServerAddress)
    {
        //
        // Make sure to reset XT and TD state from any previous connections
        //
        XT_IgnoreRestofPacket();

        /************************************************************************/
        /* Begin the connection process by calling TD_Connect.  TD will call    */
        /* us back once the connection has been established.                    */
        /************************************************************************/
        _pTd->TD_Connect(bInitiateConnect, pServerAddress);
    } /* XT_Connect */
    
    /****************************************************************************/
    /* Name:      XT_Disconnect                                                 */
    /*                                                                          */
    /* Purpose:   This function disconnects from the server.  Since we do not   */
    /*            send an XT DR packet we just need to call TD_Disconnect       */
    /*            directly.                                                     */
    /****************************************************************************/
    inline DCVOID DCAPI XT_Disconnect(DCVOID)
    {
        _pTd->TD_Disconnect();
    } /* XT_Disconnect */
    
    
    /**PROC+*********************************************************************/
    /* Name:      XT_GetBufferHeaderLen                                         */
    /*                                                                          */
    /* Purpose:   Returns the size of the XT header.                            */
    /**PROC-*********************************************************************/
    inline DCUINT XT_GetBufferHeaderLen(DCVOID)
    {
        return(sizeof(XT_DT));
    
    } /* XT_GetBufferHeaderLen */
    
    
    /****************************************************************************/
    /* Name:      XT_GetPublicBuffer                                            */
    /*                                                                          */
    /* Purpose:   Attempts to get a public buffer.  This function gets a        */
    /*            buffer which is big enough to include the XT header and then  */
    /*            updates the buffer pointer obtained from TD past the space    */
    /*            reserved for the XT header.                                   */
    /*                                                                          */
    /* Returns:   TRUE if a buffer is successfully obtained and FALSE           */
    /*            otherwise.                                                    */
    /*                                                                          */
    /* Params:    IN   dataLength - length of the buffer requested.             */
    /*            OUT  ppBuffer   - a pointer to a pointer to the buffer.       */
    /*            OUT  pBufHandle - a pointer to a buffer handle.               */
    /****************************************************************************/
    inline DCBOOL DCAPI XT_GetPublicBuffer(
            DCUINT     dataLength,
            PPDCUINT8  ppBuffer,
            PXT_BUFHND pBufHandle)
    {
        DCBOOL   rc;
        PDCUINT8 pBuf;
    
        DC_BEGIN_FN("XT_GetPublicBuffer");
    
        // Now get a buffer from TD, adding the max XT data header size to the
        // beginning.
        rc = _pTd->TD_GetPublicBuffer(dataLength + sizeof(XT_DT), &pBuf,
                (PTD_BUFHND) pBufHandle);
        if (rc) {
            // Now move the buffer pointer along to make space for our header.
            *ppBuffer = pBuf + sizeof(XT_DT);
        }
        else {
            TRC_NRM((TB, _T("Failed to get a public buffer from TD")));
        }
    
        DC_END_FN();
        return rc;
    } /* XT_GetPublicBuffer */
    
    
    /****************************************************************************/
    /* Name:      XT_GetPrivateBuffer                                           */
    /*                                                                          */
    /* Purpose:   Attempts to get a private buffer.  This function gets a       */
    /*            buffer which is big enough to include the XT header and then  */
    /*            updates the buffer pointer obtained from TD past the space    */
    /*            reserved for the XT header.                                   */
    /*                                                                          */
    /* Returns:   TRUE if a buffer is successfully obtained and FALSE           */
    /*            otherwise.                                                    */
    /*                                                                          */
    /* Params:    IN   dataLength - length of the buffer requested.             */
    /*            OUT  ppBuffer   - a pointer to a pointer to the buffer.       */
    /*            OUT  pBufHandle - a pointer to a buffer handle.               */
    /****************************************************************************/
    inline DCBOOL DCAPI XT_GetPrivateBuffer(
            DCUINT     dataLength,
            PPDCUINT8  ppBuffer,
            PXT_BUFHND pBufHandle)
    {
        DCBOOL   rc;
        PDCUINT8 pBuf;
    
        DC_BEGIN_FN("XT_GetPublicBuffer");
    
        // Now get a buffer from TD, adding the max XT data header size to the
        // beginning.
        rc = _pTd->TD_GetPrivateBuffer(dataLength + sizeof(XT_DT), &pBuf,
                (PTD_BUFHND) pBufHandle);
        if (rc) {
            // Now move the buffer pointer along to make space for our header.
            *ppBuffer = pBuf + sizeof(XT_DT);
        }
        else {
            TRC_NRM((TB, _T("Failed to get a public buffer from TD")));
        }
    
        DC_END_FN();
        return rc;
    } /* XT_GetPrivateBuffer */
    
    
    /****************************************************************************/
    /* Name:      XT_FreeBuffer                                                 */
    /*                                                                          */
    /* Purpose:   Frees a buffer.                                               */
    /****************************************************************************/
    inline DCVOID DCAPI XT_FreeBuffer(XT_BUFHND bufHandle)
    {
        /************************************************************************/
        /* Not much to do here other than call TD.                              */
        /************************************************************************/
        _pTd->TD_FreeBuffer((TD_BUFHND)bufHandle);
    } /* XT_FreeBuffer */
    
    
    /****************************************************************************/
    /* Name:      XT_QueryDataAvailable                                         */
    /*                                                                          */
    /* Purpose:   This function returns whether data is currently available     */
    /*            in _XT.                                                        */
    /*                                                                          */
    /* Returns:   TRUE if data is available and FALSE otherwise.                */
    /****************************************************************************/
    _inline DCBOOL DCAPI XT_QueryDataAvailable(DCVOID)
    {
        DC_BEGIN_FN("XT_QueryDataAvailable");
    
        TRC_DBG((TB, "Data is%s available in XT", _XT.dataInXT ? "" : _T(" NOT")));
    
        DC_END_FN();
        return _XT.dataInXT;
    } /* XT_QueryDataAvailable */
    
    
    /****************************************************************************/
    /* Name:      XT_OnTDBufferAvailable                                        */
    /*                                                                          */
    /* Purpose:   Callback from TD indicating that a back-pressure situation    */
    /*            which caused an earlier TD_GetBuffer call to fail has now     */
    /*            been relieved.                                                */
    /****************************************************************************/
    inline DCVOID DCCALLBACK XT_OnTDBufferAvailable(DCVOID)
    {
        /************************************************************************/
        /* We're not interested in this notification so just pass it up.        */
        /************************************************************************/
        _pMcs->MCS_OnXTBufferAvailable();
    } /* XT_OnTDBufferAvailable */


public:
    //
    // Public data members
    //

    XT_GLOBAL_DATA _XT;

private:
    CCD* _pCd;
    CSL* _pSl;
    CTD* _pTd;
    CMCS* _pMcs;
    CUT* _pUt;
    CUI* _pUi;
    CCLX* _pClx;

private:
    CObjs* _pClientObjects;
};

#undef TRC_FILE
#undef TRC_GROUP

#endif //_H_XT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\inc\acpudata.h ===
/****************************************************************************/
/* Copyright(C) Microsoft Corporation 1998                                  */
/****************************************************************************/
/****************************************************************************/
/*                                                                          */
/* CPU Cycle counter                                                        */
/*                                                                          */
/****************************************************************************/

#include <acpudefs.h>

#if defined(OS_WIN32) && !defined(DC_DEBUG) && defined(_M_IX86) && defined(PERF)
/****************************************************************************/
/*                                                                          */
/* CPU Cycle counter macros                                                 */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* variables used to store the count                                        */
/****************************************************************************/
DC_GL_EXT unsigned long callCount    [MAX_FNS];
DC_GL_EXT unsigned long cycleCountHi [MAX_FNS];
DC_GL_EXT unsigned long cycleCountLo [MAX_FNS];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\inc\adcgdata.h ===
/**INC+**********************************************************************/
/* Header:    adcgdata.h                                                    */
/*                                                                          */
/* Purpose:   Common include file for all data modules                      */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/* Either extern, define or reset the data.  If DC_INCLUDE_DATA is defined  */
/* then they want declarations; if DC_INIT_DATA is defined then they want   */
/* to reset the variables; otherwise they want the definitions.             */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/h/dcl/adcgdata.h_v  $
 * 
 *    Rev 1.4   03 Jul 1997 13:33:20   AK
 * SFR0000: Initial development completed
**/
/**INC-**********************************************************************/

/****************************************************************************/
/* Include the proxy header file                                            */
/****************************************************************************/
#include <wdcgdata.h>

/****************************************************************************/
/* Client global data macros.                                               */
/****************************************************************************/
#ifndef DC_DEFINE_GLOBAL_DATA
#define DC_GL_EXT extern
#else
#define DC_GL_EXT
#endif

#include <acpudata.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\inc\aordprot.h ===
/****************************************************************************/
// aordprot.h
//
// Order transmission protocol structures
//
// Copyright (c) 1997-1999 Microsoft Corp.
// Copyright (c) 1993-1996 Microsoft, PictureTel
/****************************************************************************/
#ifndef _H_ORDPROT
#define _H_ORDPROT

#ifdef DRAW_GDIPLUS
#include <gdiplus.h>
#endif
    
/****************************************************************************/
// All rectangles are inclusive of start and end points.
//
// All points are in screen coordinates, with (0,0) at top left.
//
// Interpretation of individual field values is as in Windows;
// in particular, pens, brushes and font are as defined for Windows 3.1
//
// NUM_XXX_FIELDS includes the number of fields included on the wire.
/****************************************************************************/


/****************************************************************************/
/* DstBlt (Destination only Screen Blt)                                     */
/****************************************************************************/
#define NUM_DSTBLT_FIELDS 5
typedef struct _DSTBLT_ORDER
{
    UINT16 type;
    INT16  pad1;

    INT32  nLeftRect;      /* x upper left */
    INT32  nTopRect;       /* y upper left */
    INT32  nWidth;         /* dest width   */
    INT32  nHeight;        /* dest height  */

    BYTE   bRop;           /* ROP */
    BYTE   pad2[3];
} DSTBLT_ORDER, FAR *LPDSTBLT_ORDER;


/****************************************************************************/
/* PatBlt (Pattern to Screen Blt)                                           */
/****************************************************************************/
#define NUM_PATBLT_FIELDS 12
typedef struct _PATBLT_ORDER
{
    UINT16  type;
    INT16   pad1;

    INT32   nLeftRect;      /* x upper left */
    INT32   nTopRect;       /* y upper left */
    INT32   nWidth;         /* dest width   */
    INT32   nHeight;        /* dest height  */

    UINT32  bRop;           /* ROP */

    DCCOLOR BackColor;
    BYTE    pad2;
    DCCOLOR ForeColor;
    BYTE    pad3;

    INT32   BrushOrgX;
    INT32   BrushOrgY;
    UINT32  BrushStyle;
    UINT32  BrushHatch;
    BYTE    BrushExtra[7];
    BYTE    pad4;
} PATBLT_ORDER, FAR *LPPATBLT_ORDER;


/****************************************************************************/
/* ScrBlt (Screen to Screen Blt)                                            */
/****************************************************************************/
#define NUM_SCRBLT_FIELDS 7
typedef struct _SCRBLT_ORDER
{
    UINT16 type;
    INT16  pad1;

    INT32  nLeftRect;      /* x upper left */
    INT32  nTopRect;       /* y upper left */
    INT32  nWidth;         /* dest width   */
    INT32  nHeight;        /* dest height  */

    UINT32 bRop;           /* ROP */

    INT32  nXSrc;
    INT32  nYSrc;
} SCRBLT_ORDER, FAR *LPSCRBLT_ORDER;


/****************************************************************************/
// Common fields between MemBlt and Mem3Blt - simplifies handling.
/****************************************************************************/
typedef struct _MEMBLT_COMMON
{
    UINT16 cacheId;
    UINT16 cacheIndex;

    INT32  nLeftRect;      /* x upper left */
    INT32  nTopRect;       /* y upper left */
    INT32  nWidth;         /* dest width   */
    INT32  nHeight;        /* dest height  */

    UINT32 bRop;           /* ROP */

    INT32  nXSrc;
    INT32  nYSrc;
} MEMBLT_COMMON, FAR *PMEMBLT_COMMON;


/****************************************************************************/
/* MemBlt (Memory to Screen Blt). "R2" is historical, the rev 1 version was */
/* from an old DCL product, never used in RDP.                              */
/****************************************************************************/
#define NUM_MEMBLT_FIELDS 9
typedef struct _MEMBLT_R2_ORDER
{
    UINT16 type;
    UINT16 pad0;

    // This structure needs to be at the same offset as in Mem3Blt_R2.
    MEMBLT_COMMON Common;
} MEMBLT_R2_ORDER, FAR *LPMEMBLT_R2_ORDER;


/****************************************************************************/
/* Mem3Blt (Memory to Screen Blt with ROP3). "R2" is historical, the rev 1  */
/* version was from an old DCL product, never used in RDP.                  */
/****************************************************************************/
#define NUM_MEM3BLT_FIELDS 16
typedef struct _MEM3BLT_R2_ORDER
{
    UINT16 type;
    UINT16 pad0;

    // This structure needs to be at the same offset as in MemBlt_R2.
    MEMBLT_COMMON Common;

    DCCOLOR BackColor;
    char    pad1;
    DCCOLOR ForeColor;
    char    pad2;

    INT32   BrushOrgX;
    INT32   BrushOrgY;
    UINT32  BrushStyle;
    UINT32  BrushHatch;
    BYTE    BrushExtra[7];
    char    pad3;
} MEM3BLT_R2_ORDER, FAR *LPMEM3BLT_R2_ORDER;


/****************************************************************************/
/* LineTo                                                                   */
/****************************************************************************/
#define NUM_LINETO_FIELDS 10
typedef struct _LINETO_ORDER
{
    UINT16  type;
    INT16   pad1;

    INT32   BackMode;       /* background mix mode                   */

    INT32   nXStart;        /* x line start                          */
    INT32   nYStart;        /* y line start                          */
    INT32   nXEnd;          /* x line end                            */
    INT32   nYEnd;          /* y line end                            */

    DCCOLOR BackColor;      /* background color                      */
    BYTE    pad2;

    UINT32  ROP2;           /* drawing mode                          */

    UINT32  PenStyle;
    UINT32  PenWidth;       /* always 1 - field retained for         */
                                /* backwards compatibility               */
    DCCOLOR PenColor;
    BYTE    pad3;
} LINETO_ORDER, FAR * LPLINETO_ORDER;


/****************************************************************************/
/****************************************************************************/
/* PolyLine - designed to handle sets of connected width-1 cosmetic lines.  */
/****************************************************************************/
/* The maximum number of delta points we encode.                            */
/****************************************************************************/
#define ORD_MAX_POLYLINE_ENCODED_POINTS 32

/****************************************************************************/
/* Max # of bytes needed to encode the max # of points, which is 4 bytes    */
/* each.                                                                    */
/****************************************************************************/
#define ORD_MAX_POLYLINE_CODEDDELTAS_LEN (ORD_MAX_POLYLINE_ENCODED_POINTS * 4)

/****************************************************************************/
/* Max # of bytes used to encode zero flags for the number of entries       */
/* above. Each new point has two bits -- one for each coordinate -- to      */
/* signal that the corresponding entry is absent and zero. Note we must     */
/* round up if max points is not a multiple of 4.                           */
/****************************************************************************/
#define ORD_MAX_POLYLINE_ZERO_FLAGS_BYTES \
                                   ((ORD_MAX_POLYLINE_ENCODED_POINTS + 3) / 4)

// These are the same macro as polyline above except we have 56 encoding
// points instead of 32.
#define ORD_MAX_POLYGON_ENCODED_POINTS 56
#define ORD_MAX_POLYGON_CODEDDELTAS_LEN (ORD_MAX_POLYGON_ENCODED_POINTS * 4)
#define ORD_MAX_POLYGON_ZERO_FLAGS_BYTES \
                                   ((ORD_MAX_POLYGON_ENCODED_POINTS + 3) / 4)

/****************************************************************************/
/* Flags used in encode/decode.                                             */
/****************************************************************************/
#define ORD_POLYLINE_LONG_DELTA  0x80
#define ORD_POLYLINE_XDELTA_ZERO 0x80
#define ORD_POLYLINE_YDELTA_ZERO 0x40

typedef struct _VARIABLE_CODEDDELTALIST
{
    UINT32 len;  // Byte count of encoded deltas.

    /************************************************************************/
    /* Leave enough space for the encoded points and the associated         */
    /* zero-flags.                                                          */
    /************************************************************************/
    BYTE Deltas[ORD_MAX_POLYLINE_CODEDDELTAS_LEN +
                ORD_MAX_POLYLINE_ZERO_FLAGS_BYTES];
} VARIABLE_CODEDDELTALIST, *PVARIABLE_CODEDDELTALIST;

#define NUM_POLYLINE_FIELDS 7

typedef struct _POLYLINE_ORDER
{
    UINT16 type;
    INT16  pad1;

    INT32  XStart;         /* x line start                          */
    INT32  YStart;         /* y line start                          */

    UINT32 ROP2;           /* drawing mode                          */

    UINT32  BrushCacheEntry;
    DCCOLOR PenColor;
    BYTE    pad2;

    UINT32 NumDeltaEntries;  // Sized to contain max num of entries.
    VARIABLE_CODEDDELTALIST CodedDeltaList;  // Filled in with encoded points.
} POLYLINE_ORDER, *PPOLYLINE_ORDER;


/****************************************************************************/
// Polygon/Ellipse orders
/****************************************************************************/

// Fill-mode codes for polygon drawing.
// Alternate fills area between odd-numbered and even-numbered polygon
// sides on each scan line.
// Winding fills any region with a nonzero winding value.
#define ORD_FILLMODE_ALTERNATE 1
#define ORD_FILLMODE_WINDING   2

typedef struct _POLYGON_CODEDDELTALIST
{
    UINT32 len;  // Byte count of encoded deltas.

    // Leave enough space for the encoded points and the associated
    // zero-flags.
    BYTE Deltas[ORD_MAX_POLYGON_CODEDDELTAS_LEN +
            ORD_MAX_POLYGON_ZERO_FLAGS_BYTES];
} POLYGON_CODEDDELTALIST, *PPOLYGON_CODEDDELTALIST;

// Polygon order with color pattern brush
#define NUM_POLYGON_CB_FIELDS 13
typedef struct _POLYGON_CB_ORDER
{
    UINT16 type;           /* holds "BG" - ORD_POLYGON_CB           */
    INT16  pad1;

    INT32  XStart;         /* x start point                         */
    INT32  YStart;         /* y start point                         */

    UINT32 ROP2;           /* drawing mode                          */
    UINT32 FillMode;       /* either winding mode or alternate  mode*/

    DCCOLOR  BackColor;      /* brush info                            */
    char     pad2;
    DCCOLOR  ForeColor;
    char     pad3;

    INT32  BrushOrgX;
    INT32  BrushOrgY;
    UINT32 BrushStyle;
    UINT32 BrushHatch;
    BYTE   BrushExtra[7];
    char   pad4;

    UINT32 NumDeltaEntries;  // Sized to contain max num of entries.
    POLYGON_CODEDDELTALIST CodedDeltaList;  // Filled in with encoded points.
} POLYGON_CB_ORDER, *PPOLYGON_CB_ORDER;

// Polygon order with solid color brush
#define NUM_POLYGON_SC_FIELDS 7
typedef struct _POLYGON_SC_ORDER
{
    UINT16 type;           /* holds "CG" - ORD_POLYGON_SC           */
    INT16  pad1;

    INT32  XStart;         /* x start point                         */
    INT32  YStart;         /* y start point                         */

    UINT32 ROP2;           /* drawing mode                          */
    UINT32 FillMode;       /* either winding mode or alternate  mode */

    DCCOLOR BrushColor;     // brush color
    char    pad2;

    UINT32 NumDeltaEntries;  // Sized to contain max num of entries.
    POLYGON_CODEDDELTALIST CodedDeltaList;  // Filled in with encoded points.
} POLYGON_SC_ORDER, *PPOLYGON_SC_ORDER;

// Ellipse order with color brush.
#define NUM_ELLIPSE_CB_FIELDS 13
typedef struct _ELLIPSE_CB_ORDER
{
    UINT16 type;           /* holds "BG" - ORD_POLYGON_CB           */
    INT16  pad1;

    INT32  LeftRect;         /* x start point                         */
    INT32  TopRect;          /* y start point                         */
    INT32  RightRect;        /* x start point                         */
    INT32  BottomRect;       /* y start point                         */

    UINT32 ROP2;           /* drawing mode                          */
    UINT32 FillMode;       /* either winding mode or alternate  mode */

    DCCOLOR  BackColor;      // brush data
    char     pad2;
    DCCOLOR  ForeColor;
    char     pad3;

    INT32  BrushOrgX;
    INT32  BrushOrgY;
    UINT32 BrushStyle;
    UINT32 BrushHatch;
    BYTE   BrushExtra[7];
    char   pad4;
} ELLIPSE_CB_ORDER, *PELLIPSE_CB_ORDER;

// Ellipse order with solid color brush or pen.
#define NUM_ELLIPSE_SC_FIELDS 7
typedef struct _ELLIPSE_SC_ORDER
{
    UINT16 type;           /* holds "EC" - ORD_ELLIPSE_SC             */
    INT16  pad1;

    INT32  LeftRect;         /* x start point                         */
    INT32  TopRect;          /* y start point                         */
    INT32  RightRect;        /* x start point                         */
    INT32  BottomRect;       /* y start point                         */

    UINT32 ROP2;           /* drawing mode                            */
    UINT32 FillMode;       /* either winding mode or alternate  mode  */

    DCCOLOR  Color;          // brush or pen color
    char     pad2;
} ELLIPSE_SC_ORDER, *PELLIPSE_SC_ORDER;


/****************************************************************************/
/* OpaqueRect                                                               */
/****************************************************************************/
#define NUM_OPAQUERECT_FIELDS 7
typedef struct _OPAQUE_RECT
{
    UINT16  type;
    INT16   pad1;

    INT32   nLeftRect;      /* x upper left                          */
    INT32   nTopRect;       /* y upper left                          */
    INT32   nWidth;         /* dest width                            */
    INT32   nHeight;        /* dest height                           */

    DCCOLOR Color;          /* opaque color                          */
    BYTE    pad2;
} OPAQUERECT_ORDER, FAR * LPOPAQUERECT_ORDER;


/****************************************************************************/
/* SaveBitmap (incorporating RestoreBitmap)                                 */
/****************************************************************************/
#define SV_SAVEBITS      0
#define SV_RESTOREBITS   1

#define NUM_SAVEBITMAP_FIELDS 6

typedef struct _SAVEBITMAP_ORDER
{
    UINT16    type;
    INT16     pad1;

    UINT32    SavedBitmapPosition;

    INT32     nLeftRect;      /* x left   */
    INT32     nTopRect;       /* y top    */
    INT32     nRightRect;     /* x right  */
    INT32     nBottomRect;    /* y bottom */

    UINT32    Operation;      /* SV_xxxxxxxx                              */
} SAVEBITMAP_ORDER, FAR * LPSAVEBITMAP_ORDER;


/****************************************************************************/
/* Glyph index                                                              */
/****************************************************************************/

// Variable length array used by Glyph indexes.
typedef struct tagVARIABLE_INDEXREC
{
    BYTE byte;
} VARIABLE_INDEXREC, FAR * LPVARIABLE_INDEXREC;

// Variable length array used by Glyph indexes.
typedef struct tagVARIABLE_INDEXBYTES
{
    UINT32 len;          /* array count */
    VARIABLE_INDEXREC arecs[255];
} VARIABLE_INDEXBYTES, FAR * LPVARIABLE_INDEXBYTES;

// Index order fragment add/use encoding values.
#define ORD_INDEX_FRAGMENT_ADD 0xff
#define ORD_INDEX_FRAGMENT_USE 0xfe

// Note layout for this order is same as for fast index below in beginning fields.
#define NUM_INDEX_FIELDS 22
typedef struct _INDEX_ORDER
{
    UINT16  type;

    BYTE    cacheId;
    BYTE    fOpRedundant;

    UINT16  pad1;
    BYTE    flAccel;
    BYTE    ulCharInc;

    DCCOLOR BackColor;
    BYTE    pad2;
    DCCOLOR ForeColor;
    BYTE    pad3;

    INT32   BkLeft;
    INT32   BkTop;
    INT32   BkRight;
    INT32   BkBottom;

    INT32   OpLeft;
    INT32   OpTop;
    INT32   OpRight;
    INT32   OpBottom;

    INT32   x;
    INT32   y;

    INT32   BrushOrgX;
    INT32   BrushOrgY;
    UINT32  BrushStyle;
    UINT32  BrushHatch;
    BYTE    BrushExtra[7];
    BYTE    pad4;

    VARIABLE_INDEXBYTES variableBytes;
} INDEX_ORDER, FAR * LPINDEX_ORDER;


// Note layout for this order is same as index order in beginning fields.
#define NUM_FAST_INDEX_FIELDS 15
typedef struct _FAST_INDEX_ORDER
{
    UINT16 type;
    BYTE   cacheId;
    BYTE   pad1;

    UINT16 fDrawing;
    BYTE   pad2;
    BYTE   pad3;

    DCCOLOR BackColor;
    BYTE    pad4;
    DCCOLOR ForeColor;
    BYTE    pad5;

    INT32   BkLeft;
    INT32   BkTop;
    INT32   BkRight;
    INT32   BkBottom;

    INT32   OpLeft;
    INT32   OpTop;
    INT32   OpRight;
    INT32   OpBottom;

    INT32   x;
    INT32   y;

    VARIABLE_INDEXBYTES variableBytes;
} FAST_INDEX_ORDER, FAR *LPFAST_INDEX_ORDER;


// Variable length array used by Glyph data.
typedef struct tagVARIABLE_GLYPHBYTES
{
    UINT32 len;          /* array count */
    BYTE   glyphData[255];
} VARIABLE_GLYPHBYTES, * LPVARIABLE_GLYPHBYTES;

// Note layout for this order is same as index orders above in first fields.
#define NUM_FAST_GLYPH_FIELDS 15
typedef struct _FAST_GLYPH_ORDER
{
    UINT16  type;
    BYTE    cacheId;
    BYTE    pad1;

    UINT16  fDrawing;
    BYTE    pad2;
    BYTE    pad3;

    DCCOLOR BackColor;
    BYTE    pad4;
    DCCOLOR ForeColor;
    BYTE    pad5;

    INT32   BkLeft;
    INT32   BkTop;
    INT32   BkRight;
    INT32   BkBottom;

    INT32   OpLeft;
    INT32   OpTop;
    INT32   OpRight;
    INT32   OpBottom;

    INT32   x;
    INT32   y;

    VARIABLE_GLYPHBYTES variableBytes;
} FAST_GLYPH_ORDER, FAR *LPFAST_GLYPH_ORDER;


/****************************************************************************/
/*                                                                          */
/* Support for Multiple Clipping Rectangles in one Order                    */
/*                                                                          */
/****************************************************************************/
/* The maximum number of clipping rectangles we encode.                     */
/****************************************************************************/
#define ORD_MAX_ENCODED_CLIP_RECTS      45

/****************************************************************************/
/* Max # of bytes needed to encode the max # of points, which is            */
/* - 2 bytes per co-ord                                                     */
/* - 4 coords per rectangle                                                 */
/****************************************************************************/
#define ORD_MAX_CLIP_RECTS_CODEDDELTAS_LEN \
                                          (ORD_MAX_ENCODED_CLIP_RECTS * 2 * 4)

/****************************************************************************/
/* Max # of bytes used to encode zero flags for the number of entries       */
/* above.  In caclulating this number we allow for                          */
/*                                                                          */
/* - one bit for each coordinate to signal that the corresponding entry is  */
/*   absent and zero                                                        */
/*                                                                          */
/* - four coordinates per rectangle                                         */
/*                                                                          */
/* - rounding up to a whole number of bytes                                 */
/****************************************************************************/
#define ORD_MAX_CLIP_RECTS_ZERO_FLAGS_BYTES \
                                  (((ORD_MAX_ENCODED_CLIP_RECTS * 4) + 7) / 8)


/****************************************************************************/
/* Flags used in encode/decode.                                             */
/****************************************************************************/
#define ORD_CLIP_RECTS_LONG_DELTA  0x80

#define ORD_CLIP_RECTS_XLDELTA_ZERO 0x80
#define ORD_CLIP_RECTS_YTDELTA_ZERO 0x40
#define ORD_CLIP_RECTS_XRDELTA_ZERO 0x20
#define ORD_CLIP_RECTS_YBDELTA_ZERO 0x10

typedef struct _CLIP_RECT_VARIABLE_CODEDDELTALIST
{
    UINT32 len;  // Byte count of encoded deltas.

    /************************************************************************/
    /* Leave enough space for the encoded points and the associated         */
    /* zero-flags.                                                          */
    /************************************************************************/
    BYTE Deltas[ORD_MAX_CLIP_RECTS_CODEDDELTAS_LEN +
                    ORD_MAX_CLIP_RECTS_ZERO_FLAGS_BYTES];

} CLIP_RECT_VARIABLE_CODEDDELTALIST, *PCLIP_RECT_VARIABLE_CODEDDELTALIST;

/****************************************************************************/
/* MultiDstBlt (DstBlt with multiple clipping rectangles)                   */
/****************************************************************************/
#define NUM_MULTIDSTBLT_FIELDS 7
typedef struct _MULTI_DSTBLT_ORDER
{
    UINT16 type;
    INT16  pad1;

    INT32  nLeftRect;      /* x upper left */
    INT32  nTopRect;       /* y upper left */
    INT32  nWidth;         /* dest width   */
    INT32  nHeight;        /* dest height  */

    BYTE   bRop;           /* ROP */
    BYTE   pad2[3];

    UINT32 nDeltaEntries;  /* Sized to contain max num of entries */
    CLIP_RECT_VARIABLE_CODEDDELTALIST
            codedDeltaList; /* Contains encoded points */
} MULTI_DSTBLT_ORDER, FAR * LPMULTI_DSTBLT_ORDER;


/****************************************************************************/
/* MultiPatBlt (Pattern to Screen Blt with multiple clipping rectangles)    */
/****************************************************************************/
#define NUM_MULTIPATBLT_FIELDS 14
typedef struct _MULTI_PATBLT_ORDER
{
    UINT16  type;
    INT16   pad1;

    INT32   nLeftRect;      /* x upper left */
    INT32   nTopRect;       /* y upper left */
    INT32   nWidth;         /* dest width   */
    INT32   nHeight;        /* dest height  */

    UINT32  bRop;           /* ROP */

    DCCOLOR BackColor;
    BYTE    pad2;
    DCCOLOR ForeColor;
    BYTE    pad3;

    INT32   BrushOrgX;
    INT32   BrushOrgY;
    UINT32  BrushStyle;
    UINT32  BrushHatch;
    BYTE    BrushExtra[7];
    BYTE    pad4;

    UINT32    nDeltaEntries;  /* Sized to contain max num of entries */
    CLIP_RECT_VARIABLE_CODEDDELTALIST
            codedDeltaList; /* Contains encoded points */
} MULTI_PATBLT_ORDER, FAR * LPMULTI_PATBLT_ORDER;


/****************************************************************************/
/* MultiScrBlt (Screen to Screen Blt with multiple clipping rectangles)     */
/****************************************************************************/
#define NUM_MULTISCRBLT_FIELDS 9
typedef struct _MULTI_SCRBLT_ORDER
{
    UINT16    type;
    INT16     pad1;

    INT32     nLeftRect;      /* x upper left */
    INT32     nTopRect;       /* y upper left */
    INT32     nWidth;         /* dest width   */
    INT32     nHeight;        /* dest height  */

    UINT32    bRop;           /* ROP */

    INT32     nXSrc;
    INT32     nYSrc;

    UINT32    nDeltaEntries;  /* Sized to contain max num of entries */
    CLIP_RECT_VARIABLE_CODEDDELTALIST
                codedDeltaList; /* Contains encoded points */
} MULTI_SCRBLT_ORDER, FAR * LPMULTI_SCRBLT_ORDER;


/****************************************************************************/
/* MultiOpaqueRect with multiple clipping rectangles                        */
/****************************************************************************/
#define NUM_MULTIOPAQUERECT_FIELDS 9
typedef struct _MULTI_OPAQUE_RECT
{
    UINT16  type;
    INT16   pad1;

    INT32   nLeftRect;      /* x upper left                          */
    INT32   nTopRect;       /* y upper left                          */
    INT32   nWidth;         /* dest width                            */
    INT32   nHeight;        /* dest height                           */

    DCCOLOR Color;          /* opaque color                          */
    BYTE    pad2;

    UINT32  nDeltaEntries;  /* Sized to contain max num of entries */
    CLIP_RECT_VARIABLE_CODEDDELTALIST
            codedDeltaList; /* Contains encoded points */
} MULTI_OPAQUERECT_ORDER, FAR * LPMULTI_OPAQUERECT_ORDER;

#ifdef DRAW_GDIPLUS
enum DrawTSClientEnum
{
    DrawTSClientQueryVersion,
    DrawTSClientEnable,
    DrawTSClientDisable,
    DrawTSClientDisplayChange,
    DrawTSClientPaletteChange,
    DrawTSClientRecord,
    DRawTSClientPrivateTest
};


typedef UINT (FNGDIPPLAYTSCLIENTRECORD) (IN HDC, IN DrawTSClientEnum DrawGdiEnum, IN BYTE * data,
                                          IN UINT size, OUT RECT * drawBounds /*= NULL*/);
typedef Gdiplus::Status (FNGDIPLUSSTARTUP) (OUT ULONG_PTR *token, Gdiplus::GdiplusStartupInput *input,
                                   OUT Gdiplus::GdiplusStartupOutput *output);
typedef void (FNGDIPLUSSHUTDOWN) (IN ULONG_PTR token);
#endif



#ifdef DRAW_NINEGRID

typedef BOOL (FNGDI_ALPHABLEND)(IN HDC, IN int, IN int, IN int, IN int, 
                                IN HDC, IN int, IN int, IN int, IN int, 
                                IN BLENDFUNCTION);
typedef BOOL (FNGDI_TRANSPARENTBLT)(IN HDC, IN int, IN int, IN int, IN int,
                                   IN HDC, IN int, IN int, IN int, IN int,
                                   IN UINT);

/****************************************************************************/
// Bitmap object for draw ninegrid
/****************************************************************************/
typedef struct _TS_BITMAPOBJ {
    HDC    hdc;
    SIZEL  sizlBitmap;
    ULONG  cjBits;
    PVOID  pvBits;
    LONG   lDelta;
    ULONG  iBitmapFormat;     
} TS_BITMAPOBJ;

/****************************************************************************/
// DrawNineGrid stream format
/****************************************************************************/
#define DS_MAGIC                'DrwS'
#define DS_SETTARGETID          0
#define DS_SETSOURCEID          1
#define DS_COPYTILEID           2
#define DS_SOLIDFILLID          3
#define DS_TRANSPARENTTILEID    4
#define DS_ALPHATILEID          5
#define DS_STRETCHID            6
#define DS_TRANSPARENTSTRETCHID 7
#define DS_ALPHASTRETCHID       8
#define DS_NINEGRIDID           9
#define DS_BLTID                10
#define DS_SETBLENDID           11
#define DS_SETCOLORKEYID        12

typedef struct _DS_HEADER
{
    ULONG   magic;
} DS_HEADER;

typedef struct _DS_SETTARGET
{
    ULONG   ulCmdID;
    ULONG   hdc;
    RECTL   rclDstClip;
} DS_SETTARGET;

typedef struct _DS_SETSOURCE
{
    ULONG   ulCmdID;
    ULONG   hbm;
} DS_SETSOURCE;

#define DSDNG_STRETCH         0x01
#define DSDNG_TILE            0x02
#define DSDNG_PERPIXELALPHA   0x04
#define DSDNG_TRANSPARENT     0x08
#define DSDNG_MUSTFLIP        0x10
#define DSDNG_TRUESIZE        0x20

typedef struct _DS_NINEGRIDINFO
{
    ULONG            flFlags;
    LONG             ulLeftWidth;
    LONG             ulRightWidth;
    LONG             ulTopHeight;
    LONG             ulBottomHeight;
    COLORREF         crTransparent;
} DS_NINEGRIDINFO;

typedef struct _DS_NINEGRID
{
    ULONG            ulCmdID;
    RECTL            rclDst;
    RECTL            rclSrc;
    DS_NINEGRIDINFO  ngi;
} DS_NINEGRID;

typedef struct _TS_DS_NINEGRID
{
    DS_NINEGRID  dng;
    FNGDI_ALPHABLEND *pfnAlphaBlend;
    FNGDI_TRANSPARENTBLT *pfnTransparentBlt;
} TS_DS_NINEGRID;

typedef struct _TS_DRAW_NINEGRID
{
    DS_HEADER		hdr;
    DS_SETTARGET	cmdSetTarget;
    DS_SETSOURCE	cmdSetSource;  
    DS_NINEGRID   cmdNineGrid;

} TS_DRAW_NINEGRID, * LPTS_DRAW_NINEGRID;

/****************************************************************************/
// DrawNineGrid
/****************************************************************************/
#define NUM_DRAWNINEGRID_FIELDS 5
typedef struct _DRAWNINEGRID
{
    UINT16  type;
    UINT16  pad1;

    INT32   srcLeft;     
    INT32   srcTop;      
    INT32   srcRight;    
    INT32   srcBottom;  
    
    UINT16  bitmapId;
    UINT16  pad2;

} DRAWNINEGRID_ORDER, * LPDRAWNINEGRID_ORDER;

/****************************************************************************/
// MultiDrawNineGrid (DrawNineGrid with multiple clipping rectangles).
/****************************************************************************/
#define NUM_MULTI_DRAWNINEGRID_FIELDS 7
typedef struct _MULTI_DRAWNINEGRID_RECT
{
    UINT16  type;
    INT16   pad1;

    INT32   srcLeft;     
    INT32   srcTop;      
    INT32   srcRight;    
    INT32   srcBottom;  
    
    UINT16  bitmapId;
    UINT16  pad2;

    UINT32  nDeltaEntries;  /* Sized to contain max num of entries */
    CLIP_RECT_VARIABLE_CODEDDELTALIST
            codedDeltaList; /* Contains encoded points */
} MULTI_DRAWNINEGRID_ORDER, * LPMULTI_DRAWNINEGRID_ORDER;

BOOL DrawNineGrid(HDC hdcDst, TS_BITMAPOBJ *psoSrc, TS_DS_NINEGRID *pDNG);

#endif

#endif /* _H_ORDPROT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\inc\adcgfsm.h ===
/**INC+**********************************************************************/
/* Header:    adcgfsm.h                                                     */
/*                                                                          */
/* Purpose:   FSM macros and constants                                      */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/h/dcl/adcgfsm.h_v  $
 *
 *    Rev 1.8   21 Aug 1997 16:40:36   SJ
 * SFR1322: Assert FSM macro should use TRC_FILE not __FILE__
 *
 *    Rev 1.7   18 Aug 1997 14:37:58   AK
 * SFR1184: Complete tidy-up of ASSERT_FSM
 *
 *    Rev 1.6   13 Aug 1997 15:11:08   ENH
 * SFR1182: Changed UT to UI _FATAL_ERR
 *
 *    Rev 1.5   07 Aug 1997 14:56:02   AK
 * SFR1184: FSM errors and Fatal Error tidy-up
 *
 *    Rev 1.4   09 Jul 1997 16:56:52   AK
 * SFR1016: Initial changes to support Unicode
 *
 *    Rev 1.3   04 Jul 1997 17:11:34   AK
 * SFR1007: Improve FSM error handling and trace
 *
 *    Rev 1.2   03 Jul 1997 13:36:58   AK
 * SFR0000: Initial development completed
**/
/**INC-**********************************************************************/

#ifndef _H_ADCGFSM
#define _H_ADCGFSM

/**STRUCT+*******************************************************************/
/* Structure: FSM_ENTRY                                                     */
/*                                                                          */
/* Description: Entry in an FSM Table                                       */
/****************************************************************************/
typedef struct tagFSM_ENTRY
{
  DCUINT8 next_state;
  DCUINT8 action;

  /**************************************************************************/
  /* If FSM coverage required, add a boolean 'touched' field here.          */
  /**************************************************************************/
} FSM_ENTRY;
/**STRUCT-*******************************************************************/

/****************************************************************************/
/* EVENT_TYPE and EVENT_DATA definitions                                    */
/****************************************************************************/
typedef DCUINT8  EVENT_TYPE;
typedef PDCUINT8 EVENT_DATA;

/****************************************************************************/
/* null FSM event                                                           */
/****************************************************************************/
#define NULL_EVENT ((EVENT_TYPE) 0xFF)

/****************************************************************************/
/* Invalid State for FSM                                                    */
/****************************************************************************/
#define STATE_INVALID 0xFF

/****************************************************************************/
/* Actions for FSMs                                                         */
/****************************************************************************/
#define ACT_NO   0

#define ACT_A    1
#define ACT_B    2
#define ACT_C    3
#define ACT_D    4
#define ACT_E    5
#define ACT_F    6
#define ACT_G    7
#define ACT_H    8
#define ACT_I    9
#define ACT_J    10
#define ACT_K    11
#define ACT_L    12
#define ACT_M    13
#define ACT_N    14
#define ACT_O    15
#define ACT_P    16
#define ACT_Q    17
#define ACT_R    18
#define ACT_S    19
#define ACT_T    20
#define ACT_U    21
#define ACT_V    22
#define ACT_W    23
#define ACT_X    24
#define ACT_Y    25
#define ACT_Z    26
#define ACT_CONNECTENDPOINT 27

/****************************************************************************/
/* FSM Direct Calls.                                                        */
/* Add FSM coverage versions if required for Unit Testing                   */
/****************************************************************************/
#define CHECK_FSM(FSM,INPUT,STATE)  \
            (FSM[INPUT][STATE].next_state != STATE_INVALID)
            

#define UI_FATAL_FSM_ERR_4(msg, p1, p2, p3, p4)                             \
    {                                                                       \
        TRC_ERR((TB,                                                        \
         _T("FSM error: %S@%d state:%d input:%d"), (p1), (p2), (p3), (p4)));  \
        _pUi->UI_FatalError(msg);                                           \
    }

/****************************************************************************/
/* ASSERT_FSM: validate the FSM transition                                  */
/* If transition is invalid, assert and display a fatal error message.      */
/* Note that EVT_STR and ST_STR are invalid in the retail build.            */
/****************************************************************************/
#define ASSERT_FSM(FSM, INPUT, STATE, EVT_STR, ST_STR)                      \
    if (!CHECK_FSM(FSM, INPUT, STATE))                                      \
    {                                                                       \
        UI_FATAL_FSM_ERR_4(DC_ERR_FSM_ERROR, TRC_FILE, __LINE__, STATE, INPUT); \
        TRC_ABORT((TB, _T("Invalid Transition from state %s- input %s"),        \
                   ST_STR[STATE], EVT_STR[INPUT]));                         \
    }

/****************************************************************************/
/* EXECUTE_FSM: change the STATE and ACTION; trace out the state change     */
/****************************************************************************/
#define EXECUTE_FSM(FSM,INPUT,STATE,ACTION, EVT_STR, ST_STR)                \
    {                                                                       \
        TRC_DBG((TB, _T("Old state %s Input event %s"),                         \
                 ST_STR[STATE], EVT_STR[INPUT]));                           \
        TRC_DBG((TB, _T("New state %s Action %d"),                              \
                     ST_STR[FSM[INPUT][STATE].next_state],                  \
                     FSM[INPUT][STATE].action));                            \
        ASSERT_FSM(FSM, INPUT, STATE, EVT_STR, ST_STR);                     \
        ACTION = FSM[INPUT][STATE].action;                                  \
        STATE  = FSM[INPUT][STATE].next_state;                              \
    }

#endif  /* _H_ADCGFSM */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\inc\autdata.h ===
/****************************************************************************/
/* autdata.h                                                                */
/*                                                                          */
/* UT global data                                                           */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997-1999                             */
/****************************************************************************/
#ifndef _H_AUTDATA
#define _H_AUTDATA

#include <adcgdata.h>
#include <autint.h>


/****************************************************************************/
/*                                                                          */
/* External DLL                                                             */
/*                                                                          *
/****************************************************************************/

typedef union _FUNCTIONPORT {
#ifndef OS_WINCE
    LPCSTR  pszFunctionName;
#else
    LPCTSTR  pszFunctionName;
#endif
    FARPROC lpfnFunction;
} FUNCTIONPORT, *PFUNCTIONPORT;


#if defined(OS_WIN32)
/****************************************************************************/
/* IMM32 DLL                                                                */
/****************************************************************************/

typedef union _IMM32_FUNCTION {
    FUNCTIONPORT  rgFunctionPort[2];

    struct {
        HIMC (CALLBACK* _ImmAssociateContext)(
            IN  HWND    hWnd,
            IN  HIMC    hImc
            );

        BOOL (CALLBACK* _ImmGetIMEFileName)(
            IN  HKL     hkl,
            OUT LPTSTR  lpszFileName,
            OUT UINT    uBufferLength
            );
    };

} IMM32_FUNCTION, *PIMM32_FUNCTION;

typedef struct _IMM32DLL {
    HINSTANCE         hInst;
    IMM32_FUNCTION    func;
} IMM32DLL, *PIMM32DLL;


#define lpfnImmAssociateContext    UT.Imm32Dll.func._ImmAssociateContext
#define lpfnImmGetIMEFileName      UT.Imm32Dll.func._ImmGetIMEFileName

#endif // OS_WIN32

#if !defined(OS_WINCE)
/****************************************************************************/
/* WINNLS DLL                                                               */
/****************************************************************************/

#if !defined(OS_WINCE)
#include <winnls32.h>
#endif

typedef union _WINNLS_FUNCTION {
    FUNCTIONPORT  rgFunctionPort[2];

    struct {
        BOOL (CALLBACK* _WINNLSEnableIME)(
            IN  HANDLE  hWnd,
            IN  BOOL    fEnable
            );

        BOOL (CALLBACK* _IMPGetIME)(
            IN  HWND      hWnd,
            OUT LPIMEPRO  lpImePro
            );
    };

} WINNLS_FUNCTION, *PWINNLS_FUNCTION;

typedef struct _WINNLSDLL {
    HINSTANCE         hInst;
    WINNLS_FUNCTION   func;
} WINNLSDLL, *PWINNLSDLL;


#define lpfnWINNLSEnableIME        UT.WinnlsDll.func._WINNLSEnableIME
#define lpfnIMPGetIME              UT.WinnlsDll.func._IMPGetIME

#endif  // !defined(OS_WINCE)

#if defined(OS_WINNT)
/****************************************************************************/
/* F3AHVOAS DLL                                                             */
/****************************************************************************/

typedef union _F3AHVOASYS_FUNCTION {
    FUNCTIONPORT  rgFunctionPort[1];

    struct {
        VOID (CALLBACK* _FujitsuOyayubiControl)(
            IN  DWORD   dwImeOpen,
            IN  DWORD   dwImeConversionMode
            );
    };

} F3AHVOASYS_FUNCTION, *PF3AHVOASYS_FUNCTION;

typedef struct _F3AHVOASYSDLL {
    HINSTANCE             hInst;
    F3AHVOASYS_FUNCTION   func;
} F3AHVOASYSDLL, *PF3AHVOASYSDLL;


#define lpfnFujitsuOyayubiControl  UT.F3AHVOasysDll.func._FujitsuOyayubiControl

#endif // OS_WINNT

/****************************************************************************/
/* Prototypes                                                               */
/****************************************************************************/

HINSTANCE
LoadExternalDll(
    LPCTSTR       pszLibraryName,
    PFUNCTIONPORT rgFunction,
    DWORD         dwItem
    );

VOID
InitExternalDll(
    VOID
    );

#endif /* _H_AUTDATA */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\inc\autil.h ===
/****************************************************************************/
/* util.h                                                                   */
/*                                                                          */
/* Utility API header                                                       */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997-1999                             */
/****************************************************************************/
#ifndef _H_UT
#define _H_UT

#define _H_AUTDATA
#define _H_AUTAPI

extern "C" {
#include <autreg.h>
#include <compress.h>
#include <winsock.h>
}

#ifndef OS_WINCE
#include "shlobj.h"
#endif


/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/
#define UT_MAX_DOMAIN_LENGTH            52
#define UT_MAX_USERNAME_LENGTH          512
#define UT_MAX_PASSWORD_LENGTH          32
#define UT_FILENAME_MAX_LENGTH          15
#define UT_MAX_WORKINGDIR_LENGTH        512
#define UT_MAX_ALTERNATESHELL_LENGTH    512
#define UT_MAX_ADDRESS_LENGTH           256
#define UT_REGSESSION_MAX_LENGTH        32
#define UT_MAX_SUBKEY                   265

#define UT_SALT_LENGTH                  20

#define UT_COMPUTERNAME_SECTION    "Network"
#define UT_COMPUTERNAME_KEY        "ComputerName"
#define UT_COMPUTERNAME_FILE       "SYSTEM.INI"

#ifdef DC_DEBUG
/****************************************************************************/
/* Random Failure iemIDs                                                    */
/****************************************************************************/
#define UT_FAILURE_BASE        0x3256
#define UT_FAILURE_ITEM(n)     ((DCUINT) UT_FAILURE_BASE + (n) )
#define UT_FAILURE_MALLOC      UT_FAILURE_ITEM(0)
#define UT_FAILURE_MALLOC_HUGE UT_FAILURE_ITEM(1)
#define UT_FAILURE_MAX_INDEX   1

#endif /* DC_DEBUG */


/****************************************************************************/
/*                                                                          */
/* TYPEDEFS                                                                 */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* Structure passed into thread entry functions created by                  */
/* UT_StartThread().                                                       */
/****************************************************************************/
typedef DCVOID (DCAPI * UTTHREAD_PROC)(PDCVOID);



/****************************************************************************/
/* Structure: UT_THREAD_DATA                                                */
/*                                                                          */
/* Description:                                                             */
/****************************************************************************/
typedef struct tagUT_THREAD_DATA
{
    DWORD     threadID;
    ULONG_PTR threadHnd;
} UT_THREAD_DATA, DCPTR PUT_THREAD_DATA;


// forward declaration
class CUT;


/****************************************************************************/
/* Structure: UT_THREAD_INFO                                                */
/*                                                                          */
/* Description: Passes params to UTThreadEntry                              */
/****************************************************************************/
typedef struct tagUT_THREAD_INFO
{
    UTTHREAD_PROC pFunc;
    ULONG_PTR     sync;
    PDCVOID       threadParam;
} UT_THREAD_INFO, DCPTR PUT_THREAD_INFO;


/****************************************************************************/
/*                                                                          */
/* INLINE FUNCTIONS                                                         */
/*                                                                          */
/****************************************************************************/


/****************************************************************************/
/*                                                                          */
/* FUNCTION MACRO WRAPPERS                                                  */
/*                                                                          */
/****************************************************************************/
#ifdef DC_DEBUG
/****************************************************************************/
/* Use the comma operator because UT_...  return values and so the entire   */
/* macro must also return a value.                                          */
/* Use different macros for non-DEBUG because TRC_NRM macros to nothing and */
/* the comma operator cannot take 'nothing' as its first parameter.         */
/****************************************************************************/
#define UT_Malloc(utinst, X) (utinst)->UT_MallocDbg(X, trc_fn)
#define UT_MallocHuge(utinst, X)                                                     \
        (TRC_NRM((TB, _T("%s calling UT_MallocHuge for %#x bytes"), trc_fn, X)),         \
        (utinst)->UT_MallocHugeReal(X))
#define UT_Free(utinst, X) (TRC_NRM((TB, _T("%s freeing %p"), trc_fn, X)), \
            (utinst)->UT_FreeReal(X))
#else
#define UT_Malloc(utinst,X) LocalAlloc(LPTR, X)
#define UT_MallocHuge(utinst, X) LocalAlloc(LPTR, X)
#define UT_Free(utinst, X) LocalFree(X)
#endif


/****************************************************************************/
/*                                                                          */
/* SIMPLE MACROS FOR BUFFER CHECKS                                          */
/*                                                                          */
/****************************************************************************/

// Check for lenInner<lenOuter is purely to prevent overflow in pointer arithmetic
#define IsContainedMemory(pOuter,lenOuter,pInner,lenInner) \
  (((LPBYTE)(pInner) >= (LPBYTE)(pOuter)) && \
   ((lenInner) <= (lenOuter)) && \
   (((LPBYTE)(pInner)) + (lenInner) >= ((LPBYTE)(pOuter))) && \
   (((LPBYTE)(pInner)) + (lenInner) <= ((LPBYTE)(pOuter)) + (lenOuter)))

#define IsContainedPointer(pOuter,lenOuter,pInner) \
  (((LPBYTE)(pInner) >= (LPBYTE)(pOuter)) && \
   ((LPBYTE)(pInner) < ((LPBYTE)(pOuter)) + (lenOuter)))



/****************************************************************************/
/* Automatic Session Info                                                   */
/****************************************************************************/
#define MAX_SESSIONINFO_NAME            32
#define MAX_SESSIONINFO_SECTIONNAME     MAX_SESSIONINFO_NAME + sizeof(UTREG_SESSIONINFO_ROOT)

#define MAKE_SESSIONINFO_SECTION(BUFF, SESSIONNAME) \
DC_TSTRCPY(BUFF, UTREG_SESSIONINFO_ROOT); \
DC_TSTRCAT(BUFF, SESSIONNAME)

//
// From autdata.h
//

/****************************************************************************/
/*                                                                          */
/* External DLL                                                             */
/*                                                                          *
/****************************************************************************/

typedef union _FUNCTIONPORT {
#ifndef OS_WINCE
    LPCSTR  pszFunctionName;
#else
    LPCTSTR  pszFunctionName;
#endif
    FARPROC lpfnFunction;
} FUNCTIONPORT, *PFUNCTIONPORT;


#if defined(OS_WIN32)
/****************************************************************************/
/* IMM32 DLL                                                                */
/****************************************************************************/

typedef union _IMM32_FUNCTION {
#ifndef OS_WINCE
    FUNCTIONPORT  rgFunctionPort[3];
#else
    FUNCTIONPORT  rgFunctionPort[2];
#endif    

    struct {
        HIMC (CALLBACK* _ImmAssociateContext)(
            IN  HWND    hWnd,
            IN  HIMC    hImc
            );

        BOOL (CALLBACK* _ImmGetIMEFileNameW)(
            IN  HKL     hkl,
            OUT LPWSTR  lpwszFileName,
            OUT UINT    uBufferLength
            );
#ifndef OS_WINCE
        BOOL (CALLBACK* _ImmGetIMEFileNameA)(
            IN  HKL     hkl,
            OUT LPSTR   lpszFileName,
            OUT UINT    uBufferLength
            );
#endif
    };

} IMM32_FUNCTION, *PIMM32_FUNCTION;

typedef struct _IMM32DLL {
    HINSTANCE         hInst;
    IMM32_FUNCTION    func;
} IMM32DLL, *PIMM32DLL;


#define lpfnImmAssociateContext    _UT.Imm32Dll.func._ImmAssociateContext

#endif // OS_WIN32

#if !defined(OS_WINCE)
/****************************************************************************/
/* WINNLS DLL                                                               */
/****************************************************************************/

#if !defined(OS_WINCE)
#include <winnls32.h>
#endif

typedef union _WINNLS_FUNCTION {
    FUNCTIONPORT  rgFunctionPort[3];

    struct {
        BOOL (CALLBACK* _WINNLSEnableIME)(
            IN  HANDLE  hWnd,
            IN  BOOL    fEnable
            );

        BOOL (CALLBACK* _IMPGetIMEW)(
            IN  HWND      hWnd,
            OUT LPIMEPROW  lpImePro
            );

        BOOL (CALLBACK* _IMPGetIMEA)(
            IN  HWND      hWnd,
            OUT LPIMEPROA  lpImePro
            );
    };

} WINNLS_FUNCTION, *PWINNLS_FUNCTION;

typedef struct _WINNLSDLL {
    HINSTANCE         hInst;
    WINNLS_FUNCTION   func;
} WINNLSDLL, *PWINNLSDLL;


#define lpfnWINNLSEnableIME        _UT.WinnlsDll.func._WINNLSEnableIME

#endif  // !defined(OS_WINCE)

#if defined(OS_WINNT)
/****************************************************************************/
/* F3AHVOAS DLL                                                             */
/****************************************************************************/

typedef union _F3AHVOASYS_FUNCTION {
    FUNCTIONPORT  rgFunctionPort[1];

    struct {
        VOID (CALLBACK* _FujitsuOyayubiControl)(
            IN  DWORD   dwImeOpen,
            IN  DWORD   dwImeConversionMode
            );
    };

} F3AHVOASYS_FUNCTION, *PF3AHVOASYS_FUNCTION;

typedef struct _F3AHVOASYSDLL {
    HINSTANCE             hInst;
    F3AHVOASYS_FUNCTION   func;
} F3AHVOASYSDLL, *PF3AHVOASYSDLL;


#define lpfnFujitsuOyayubiControl  _UT.F3AHVOasysDll.func._FujitsuOyayubiControl

#endif // OS_WINNT

/****************************************************************************/
/* Prototypes                                                               */
/****************************************************************************/


/****************************************************************************/
/* Structure: UT_DATA                                                       */
/*                                                                          */
/* Description:                                                             */
/****************************************************************************/
typedef struct tagUT_DATA
{
    HKEY       enumHKey;
    DCTCHAR    sessionName[UT_REGSESSION_MAX_LENGTH];

#if defined(OS_WIN32)
    IMM32DLL   Imm32Dll;
#endif // OS_WIN32

#if !defined(OS_WINCE)
    WINNLSDLL  WinnlsDll;
#endif  // !defined(OS_WINCE)

#if defined(OS_WINNT)
    F3AHVOASYSDLL F3AHVOasysDll;
#endif // OS_WINNT

#ifdef DC_DEBUG
    DCINT      failPercent[UT_FAILURE_MAX_INDEX + 1];
#endif /* DC_DEBUG */
    DCINT      osMinorType;
    HINSTANCE  hInstance;

#ifdef DC_DEBUG
    DWORD       dwDebugThreadWaitTimeout;
#endif

} UT_DATA, DCPTR PUT_DATA;

/****************************************************************************/
/*                                                                          */
/* HOTKEY structure                                                         */
/*                                                                          *
/*                                                                          */
/****************************************************************************/

typedef struct tagDCHOTKEY
{
    DCUINT      fullScreen;
    DCUINT      ctrlEsc;
    DCUINT      altEsc;
    DCUINT      altTab;
    DCUINT      altShifttab;
    DCUINT      altSpace;
    DCUINT      ctlrAltdel;
} DCHOTKEY;

typedef DCHOTKEY DCPTR PDCHOTKEY;

/*Hotkey structure*/

VOID DisableIME(HWND hwnd);
VOID UIGetIMEFileName(PDCTCHAR imeFileName, DCUINT Size);
VOID UIGetIMEFileName16(PDCTCHAR imeFileName, DCUINT Size);

class CUT
{
public:
    CUT();
    ~CUT();

    /****************************************************************************/
    /*                                                                          */
    /* API FUNCTION PROTOTYPES                                                  */
    /*                                                                          */
    /****************************************************************************/

    DCVOID DCAPI UT_Init(DCVOID);
    DCVOID DCAPI UT_Term(DCVOID);

    DCBOOL DCAPI UT_StartThread(UTTHREAD_PROC entryFunction,
                                PUT_THREAD_DATA pThreadData,
                                PDCVOID         pThreadParam);

    DCBOOL DCAPI UT_DestroyThread(UT_THREAD_DATA threadData,
                                  BOOL fPumpMessages = FALSE);

    static DWORD UT_WaitWithMessageLoop(HANDLE hEvent, ULONG Timeout);

    DCUINT DCINTERNAL UT_GetANSICodePage(DCVOID);

    PDCVOID   DCAPI UT_MallocReal(DCUINT length);
    DCVOID    DCAPI UT_FreeReal(PDCVOID pMemory);
    HPDCVOID  DCAPI UT_MallocHugeReal(DCUINT32 length);

    DCVOID    DCAPI UT_ReadRegistryString( PDCTCHAR pSection,
                                           PDCTCHAR pEntry,
                                           PDCTCHAR pDefaultValue,
                                           PDCTCHAR pBuffer,
                                           DCINT    bufferSize );

    DCBOOL    DCAPI UT_ReadRegistryExpandSZ(PDCTCHAR  pSection,
                                           PDCTCHAR   pEntry,
                                           PDCTCHAR*  ppBuffer,
                                           PDCINT     pBufferSize );

    DCINT DCAPI UT_ReadRegistryInt( PDCTCHAR pSection,
                                    PDCTCHAR pEntry,
                                    DCINT    defaultValue );

    DCVOID DCAPI UT_ReadRegistryBinary(PDCTCHAR pSection,
                                       PDCTCHAR pEntry,
                                       PDCTCHAR pBuffer,
                                       DCINT    bufferSize);

    DCBOOL DCAPI UT_EnumRegistry( PDCTCHAR pSection,
                                  DCUINT32 index,
                                  PDCTCHAR pBuffer,
                                  PDCINT   pBufferSize );

    DCUINT DCAPI UT_WriteRegistryString( PDCTCHAR pSection,
                                         PDCTCHAR pEntry,
                                         PDCTCHAR pDefaultValue,
                                         PDCTCHAR pBuffer );

    DCUINT DCAPI UT_WriteRegistryInt( PDCTCHAR pSection,
                                      PDCTCHAR pEntry,
                                      DCINT    defaultValue,
                                      DCINT    value );

    PRNS_UD_HEADER DCAPI UT_ParseUserData(PRNS_UD_HEADER pUserData,
                                          DCUINT         userDataLen,
                                          DCUINT16       typeRequested);

    DCBOOL DCAPI UT_WriteRegistryBinary(PDCTCHAR pSection,
                                        PDCTCHAR pEntry,
                                        PDCTCHAR pBuffer,
                                        DCINT    bufferSize);

    PDCVOID DCINTERNAL UT_GetCapsSet(DCUINT capsLength,
                                     PTS_COMBINED_CAPABILITIES pCaps,
                                     DCUINT capsSet);

    DCUINT DCAPI UT_SetScrollInfo(HWND         hwnd,
                                  DCINT        scrollBarFlag,
                                  LPSCROLLINFO pScrollInfo,
                                  DCBOOL       redraw);

    DCBOOL DCINTERNAL UT_IsNEC98platform(DCVOID);
    DCBOOL DCINTERNAL UT_IsNX98Key(DCVOID);
    DCBOOL DCINTERNAL UT_IsNew106Layout(DCVOID);
    DCBOOL DCINTERNAL UT_IsFujitsuLayout(DCVOID);
    DCBOOL DCINTERNAL UT_IsKorean101LayoutForWin9x(DCVOID);
    DCBOOL DCINTERNAL UT_IsKorean101LayoutForNT351(DCVOID);
    DCBOOL DCAPI UT_GetComputerName(PDCTCHAR szBuff, DCUINT32 len);
    BOOL DCAPI UT_GetComputerAddressW(PDCUINT8 szBuff);
    BOOL DCAPI UT_GetComputerAddressA(PDCUINT8 szBuff);
    BOOL DCAPI UT_GetClientDirW(PDCUINT8 szBuff);

    DCBOOL DCINTERNAL UT_GetRealDriverNameNT(
                            PDCTCHAR lpszRealDriverName,
                            UINT     cchDriverName);


    #ifdef OS_WINNT
    BOOL DCAPI UT_ValidateProductSuite(LPSTR SuiteName);
    BOOL DCAPI UT_IsTerminalServicesEnabled(VOID);
    #endif

    #if !defined(OS_WINCE)
    DCUINT DCINTERNAL UT_GetFullPathName(PDCTCHAR lpFileName,
                                         DCUINT   nBufferLength,
                                         PDCTCHAR lpBuffer,
                                         PDCTCHAR *lpFilePart);
    #endif // !defined(OS_WINCE)
    


#ifdef DC_DEBUG
    DCVOID     DCAPI UT_SetRandomFailureItem(DCUINT itemID, DCINT percent);
    DCINT      DCAPI UT_GetRandomFailureItem(DCUINT itemID);
    DCBOOL     DCAPI UT_TestRandomFailure(DCUINT itemID);
#endif /* DC_DEBUG */

    //
    // Time functions
    //
    
    HANDLE
    UTCreateTimer(
        HWND        hWnd,             // handle of window for timer messages
        DCUINT      nIDEvent,         // timer identifier
        DCUINT      uElapse );        // time-out value
    
    
    DCBOOL
    UTStartTimer(
        HANDLE      hTimer );
    
    
    DCBOOL
    UTStopTimer(
        HANDLE      hTimer );
    
    
    DCBOOL
    UTDeleteTimer(
        HANDLE      hTimer );


    HINSTANCE
    LoadExternalDll(
        LPCTSTR       pszLibraryName,
        PFUNCTIONPORT rgFunction,
        DWORD         dwItem
        );
    
    VOID
    InitExternalDll(
        VOID
        );

public:
    //
    // Data members
    //
    UT_DATA _UT;

public:

    #ifdef DC_DEBUG
    PDCVOID DCAPI UT_MallocDbg(DCUINT length, PDCTCHAR pCaller)
    {
        PDCVOID ptr;
        UNREFERENCED_PARAMETER( pCaller);
        DC_BEGIN_FN("UT_MallocDbg");

        ptr = UT_MallocReal(length);
        TRC_NRM((TB, _T("%s allocated %d bytes at %p"), pCaller, length, ptr));

        DC_END_FN();
        return(ptr);
    }
    #endif /* DC_DEBUG */


    /****************************************************************************/
    /* Name:      UT_GetCurrentTimeMS                                           */
    /*                                                                          */
    /* Purpose:   Returns the current system timer value in milliseconds.       */
    /*                                                                          */
    /* Returns:   Millisecond timestamp.                                        */
    /****************************************************************************/
    DCUINT32 DCAPI UT_GetCurrentTimeMS(DCVOID)
    {
        DCUINT32 rc;

        DC_BEGIN_FN("UT_GetCurrentTimeMS");

        rc = GetTickCount();

        DC_END_FN();
        return(rc);
    }


    /****************************************************************************/
    /* Name:      UT_InterlockedExchange                                        */
    /*                                                                          */
    /* Purpose:   Exchanges a given data value with the value in a given        */
    /*            location.                                                     */
    /*                                                                          */
    /* Returns:   Original data value from given location.                      */
    /*                                                                          */
    /* Params:    pData - pointer to data location                              */
    /*            val   - new data value                                        */
    /****************************************************************************/
    DCUINT32 DCAPI UT_InterlockedExchange(PDCUINT32 pData, DCUINT32 val)
    {
        DCUINT32    rc;

    #ifdef OS_WIN32
        rc = (DCUINT32)InterlockedExchange((LPLONG)pData, (LONG)val);
    #else
        rc = *pData;
        *pData = val;
    #endif

        return(rc);
    }


    /****************************************************************************/
    /* Name:      UT_InterlockedIncrement                                       */
    /*                                                                          */
    /* Purpose:   Increments a 32-bit variable in a thread-safe manner.         */
    /*                                                                          */
    /* Params:    Pointer to the DCINT32 to increment.                          */
    /****************************************************************************/
    DCVOID UT_InterlockedIncrement(PDCINT32 pData)
    {

    #ifdef OS_WIN32
        InterlockedIncrement((LPLONG)pData);
    #else
        *pData++;
    #endif

    } /* UT_InterlockedIncrement */


    /****************************************************************************/
    /* Name:      UT_InterlockedDecrement                                       */
    /*                                                                          */
    /* Purpose:   Decrements a 32-bit variable in a thread-safe manner.         */
    /*                                                                          */
    /* Params:    Pointer to the DCINT32 to decrement.                          */
    /****************************************************************************/
    DCVOID UT_InterlockedDecrement(PDCINT32 pData)
    {

    #ifdef OS_WIN32
        InterlockedDecrement((LPLONG)pData);
    #else
        *pData--;
    #endif

    } /* UT_InterlockedDecrement */

    /****************************************************************************/
    /* Name:      UT_GetSessionName                                             */
    /*                                                                          */
    /* Purpose:   Return name of registry section for this session              */
    /*                                                                          */
    /* Params:    pName (returned) - name of Session                            */
    /****************************************************************************/
    DCVOID UT_GetSessionName(LPTSTR szName, UINT cchName)
    {
        HRESULT hr;
        DC_BEGIN_FN("UT_GetSessionName");

        TRC_NRM((TB, _T("Name found >%s<"), _UT.sessionName));

        hr = StringCchCopy(szName, cchName, _UT.sessionName);
        if (FAILED(hr)) {
            TRC_ERR((TB,_T("StringCchCopy failed: 0x%x"),hr));
        }
        
        DC_END_FN();
    } /* UT_GetSessionName */

    /****************************************************************************/
    /* Name:      UT_GetOsMinorType                                             */
    /*                                                                          */
    /* Purpose:   Get the OS type                                               */
    /*                                                                          */
    /* Returns:   OS type (one of the TS_OSMINORTYPE constants)                 */
    /****************************************************************************/
    DCUINT DCAPI UT_GetOsMinorType(DCVOID)
    {
        DCUINT rc;

        DC_BEGIN_FN("UI_GetOsMinorType");

        rc = _UT.osMinorType;

        DC_END_FN();
        return(rc);
    } /* UI_GetOsMinorType */

    /****************************************************************************/
    /* Name:      UT_GetInstanceHandle                                          */
    /*                                                                          */
    /* Purpose:   Return application hInstance                                  */
    /*                                                                          */
    /* Returns:   hInstance                                                     */
    /****************************************************************************/
    HINSTANCE DCAPI UT_GetInstanceHandle(DCVOID)
    {
        HINSTANCE  rc;

        DC_BEGIN_FN("UT_GetInstanceHandle");

        TRC_ASSERT((_UT.hInstance != 0), (TB, _T("Instance handle not set")));
        rc = _UT.hInstance;
        TRC_DBG((TB, _T("Return %p"), rc));

        DC_END_FN();
        return(rc);
    } /* UT_GetInstanceHandle */

    /****************************************************************************/
    /* Name:      UT_SetInstanceHandle                                          */
    /*                                                                          */
    /* Purpose:   Return application hInstance                                  */
    /*                                                                          */
    /* Returns:   hInstance                                                     */
    /****************************************************************************/
    DCVOID DCAPI UT_SetInstanceHandle(HINSTANCE hInstance)
    {
        DC_BEGIN_FN("UT_SetInstanceHandle");

        TRC_ASSERT((_UT.hInstance == 0), (TB, _T("Set instance handle twice!")));
        TRC_ASSERT((hInstance != 0), (TB, _T("invalid (zero) instance handle")));

        _UT.hInstance = hInstance;

        DC_END_FN();
    } /* UT_SetInstanceHandle */

    static BOOL StringtoBinary(size_t cbInBuffer, PBYTE pbInBuffer,
                               TCHAR *pszOutBuffer, DWORD *pcchOutBuffer);
    static BOOL BinarytoString(size_t cchInBuffer, TCHAR *pszInBuffer,
                               PBYTE pbOutBuffer, DWORD *pcbOutBuffer);

    static BOOL ValidateServerName(LPCTSTR szServerName, BOOL fAllowPortSuffix);
    static INT  GetPortNumberFromServerName(LPTSTR szServer);
    static VOID GetServerNameFromFullAddress(LPCTSTR szFullName,
                                             LPTSTR szServerOnly,
                                             ULONG len);
    static HRESULT
    GetCanonicalServerNameFromConnectString(
                    IN LPCTSTR szConnectString,
                    OUT LPTSTR szCanonicalServerName,
                    ULONG cchLenOut
                    );

    static BOOL IsSCardReaderInstalled();

#ifndef OS_WINCE
    static BOOL NotifyShellOfFullScreen(HWND hwndMarkFullScreen,
                                  BOOL fNowFullScreen,
                                  ITaskbarList2** ppTsbl2,
                                  PBOOL pfQueriedForTaskbar);
#endif

    //
    // Safe wrapper that validates a string length before doing the string copy
    //
    static HRESULT
    StringPropPut(
            LPTSTR szDestString,
            UINT   cchDestLen,
            LPTSTR szSourceString
            );



    //
    // IME Wrapper functions
    //
    // These wrappers manage dynamically loading the IME dlls
    // and the appropriate unicode conversions on 9x where the 
    // Unicode API's may not be available
    //
    UINT UT_ImmGetIMEFileName(IN HKL, OUT LPTSTR, IN UINT uBufLen);
#if ! defined (OS_WINCE)
    BOOL UT_IMPGetIME( IN HWND, OUT LPIMEPRO);
#endif

    static BOOL UT_IsScreen8bpp()
    {
        BOOL fUse8BitDepth = FALSE;
        HDC hdcScreen = GetDC(NULL);
        if (hdcScreen) {
            fUse8BitDepth = (GetDeviceCaps(hdcScreen, BITSPIXEL) <= 8);
            ReleaseDC(NULL, hdcScreen);
        }
        return fUse8BitDepth;
    }

    static HPALETTE UT_GetPaletteForBitmap(HDC hDCSrc, HBITMAP hBitmap);


    //
    // Internal functions
    //

private:
    DCVOID DCINTERNAL UTGetCurrentTime(PDC_TIME pTime);

    DCBOOL DCINTERNAL UTReadEntry(HKEY     topLevelKey,
                                  PDCTCHAR pSection,
                                  PDCTCHAR pEntry,
                                  PDCUINT8 pBuffer,
                                  DCINT    bufferSize,
                                  DCINT32 expectedDataType);

    DCBOOL DCINTERNAL UTEnumRegistry( PDCTCHAR pSection,
                                      DCUINT32 index,
                                      PDCTCHAR pBuffer,
                                      PDCINT   pBufferSize );
    
    DCBOOL DCINTERNAL UTWriteEntry(HKEY     topLevelKey,
                                   PDCTCHAR pSection,
                                   PDCTCHAR pEntry,
                                   PDCUINT8 pData,
                                   DCINT    dataSize,
                                   DCINT32  dataType);
    
    DCBOOL DCINTERNAL UTReadRegistryString(PDCTCHAR pSection,
                                           PDCTCHAR pEntry,
                                           PDCTCHAR pBuffer,
                                           DCINT    bufferSize);

    DCBOOL DCINTERNAL UTReadRegistryExpandString(PDCTCHAR pSection,
                                           PDCTCHAR pEntry,
                                           PDCTCHAR* ppBuffer,
                                           PDCINT    pBufferSize);
    
    DCBOOL DCINTERNAL UTReadRegistryInt(PDCTCHAR pSection,
                                        PDCTCHAR pEntry,
                                        PDCINT   pValue);
    
    DCBOOL DCINTERNAL UTReadRegistryBinary(PDCTCHAR pSection,
                                           PDCTCHAR pEntry,
                                           PDCTCHAR pBuffer,
                                           DCINT    bufferSize);
    
    DCBOOL DCINTERNAL UTWriteRegistryString(PDCTCHAR pSection,
                                            PDCTCHAR pEntry,
                                            PDCTCHAR pBuffer);
    
    DCBOOL DCINTERNAL UTWriteRegistryInt(PDCTCHAR pSection,
                                         PDCTCHAR pEntry,
                                         DCINT    value);
    
    DCBOOL DCINTERNAL UTWriteRegistryBinary(PDCTCHAR pSection,
                                            PDCTCHAR pEntry,
                                            PDCTCHAR pBuffer,
                                            DCINT    bufferSize);
    
    DCBOOL DCINTERNAL UTDeleteEntry(PDCTCHAR pSection,
                                    PDCTCHAR pEntry);
    
    DCUINT DCINTERNAL UTSetScrollInfo(HWND         hwnd,
                                      DCINT        scrollBarFlag,
                                      LPSCROLLINFO pScrollInfo,
                                      DCBOOL       redraw);
    
    DCUINT32 DCAPI UTInterlockedExchange(PDCUINT32 pData, DCUINT32 val);
    #include "wutint.h"
    

};

//Old name
#define SIZECHAR(x) sizeof(x)/sizeof(TCHAR)

#define CHECK_READ_ONE_BYTE(pBuffer, pEnd, hr, trc )     \
{\
    if (((BYTE*)(pBuffer)) >= (BYTE*)(pEnd)) {      \
        TRC_ABORT( trc );        \
        hr = E_TSC_CORE_LENGTH;        \
        DC_QUIT;        \
    } \
}

#define CHECK_READ_ONE_BYTE_2ENDED(pBuffer, pStart, pEnd, hr, trc )     \
{\
    if (((BYTE*)(pBuffer)) >= (BYTE*)(pEnd) || \
        (BYTE*)(pBuffer) < (BYTE*)(pStart)) {      \
        TRC_ABORT( trc );        \
        hr = E_TSC_CORE_LENGTH;        \
        DC_QUIT;        \
    } \
}

#define CHECK_WRITE_ONE_BYTE(pBuffer, pEnd, hr, trc )     \
{\
    if (((BYTE*)(pBuffer)) >= (BYTE*)(pEnd)) {      \
        TRC_ABORT( trc );        \
        hr = E_TSC_CORE_LENGTH;        \
        DC_QUIT;        \
    } \
}

#define CHECK_WRITE_ONE_BYTE_NO_HR(pBuffer, pEnd, trc )     \
{\
    if (((BYTE*)(pBuffer)) >= (BYTE*)(pEnd)) {      \
        TRC_ABORT( trc );        \
        DC_QUIT;        \
    } \
}

#define CHECK_READ_N_BYTES(pBuffer, pEnd, N, hr, trc )     \
{\
    if ((BYTE*)(pBuffer) > (BYTE*)(pEnd) ||    \
        ((ULONG)((BYTE*)(pEnd) - (BYTE*)(pBuffer)) < (ULONG)(N))) { \
        TRC_ABORT( trc );        \
        hr = E_TSC_CORE_LENGTH;        \
        DC_QUIT;        \
    }  \
}

#define CHECK_READ_N_BYTES_NO_HR(pBuffer, pEnd, N, trc )     \
{\
    if ((BYTE*)(pBuffer) > (BYTE*)(pEnd) ||    \
        ((ULONG)((BYTE*)(pEnd) - (BYTE*)(pBuffer)) < (ULONG)(N))) { \
        TRC_ABORT( trc );        \
        DC_QUIT;        \
    }  \
}

#define CHECK_READ_N_BYTES_2ENDED(pBuffer, pStart, pEnd, N, hr, trc )     \
{\
    if ((BYTE*)(pBuffer) > (BYTE*)(pEnd) ||    \
        ((ULONG)((BYTE*)(pEnd) - (BYTE*)(pBuffer)) < (ULONG)(N)) ||    \
        ((BYTE*)(pBuffer) < (BYTE*)(pStart)) ) {      \
        TRC_ABORT( trc );        \
        hr = E_TSC_CORE_LENGTH;        \
        DC_QUIT;        \
    }  \
}

#define CHECK_READ_N_BYTES_2ENDED_NO_HR(pBuffer, pStart, pEnd, N, trc )     \
{\
    if ((BYTE*)(pBuffer) > (BYTE*)(pEnd) ||    \
        ((ULONG)((BYTE*)(pEnd) - (BYTE*)(pBuffer)) < (ULONG)(N)) ||    \
        ((BYTE*)(pBuffer) < (BYTE*)(pStart)) ) {      \
        TRC_ABORT( trc );        \
        DC_QUIT;        \
    }  \
}


#define CHECK_WRITE_N_BYTES(pBuffer, pEnd, N, hr, trc )     \
{\
    if ((BYTE*)(pBuffer) > (BYTE*)(pEnd) ||    \
        ((ULONG)((BYTE*)(pEnd) - (BYTE*)(pBuffer)) < (ULONG)(N))) { \
        TRC_ABORT( trc );        \
        hr = E_TSC_CORE_LENGTH;        \
        DC_QUIT;        \
    }  \
}

#define CHECK_WRITE_N_BYTES_NO_HR(pBuffer, pEnd, N, trc )     \
{\
    if ((BYTE*)(pBuffer) > (BYTE*)(pEnd) ||    \
        ((ULONG)((BYTE*)(pEnd) - (BYTE*)(pBuffer)) < (ULONG)(N))) { \
        TRC_ABORT( trc );        \
        DC_QUIT;        \
    }  \
}

#define CHECK_WRITE_N_BYTES_2ENDED_NO_HR(pBuffer, pStart, pEnd, N, trc )     \
{\
    if ((BYTE*)(pBuffer) > (BYTE*)(pEnd) ||    \
        ((ULONG)((BYTE*)(pEnd) - (BYTE*)(pBuffer)) < (ULONG)(N)) ||    \
        ((BYTE*)(pBuffer) < (BYTE*)(pStart)) ) {      \
        TRC_ABORT( trc );        \
        DC_QUIT;        \
    }  \
}

#endif /* _H_UTIL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\inc\auierr.h ===
/**MOD+**********************************************************************/
/* Module:    auierr.h                                                      */
/*                                                                          */
/* Purpose:   UI error codes                                                */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/client/auierr.h_v  $
 *
 *    Rev 1.1   13 Aug 1997 15:15:10   ENH
 * SFR1182: Changed UT to UI fatal errors
**/
/**MOD-**********************************************************************/
#ifndef _H_AUIERR
#define _H_AUIERR

/****************************************************************************/
/* Return codes.  These are all offset from UT_BASE_RC.                    */
/****************************************************************************/
#define UI_BASE_RC                    0x4132

#define UI_RC(N)                      ((DCUINT16)N + UI_BASE_RC)

#define UI_RC_IO_ERROR                UI_RC(  1)
#define UI_RC_START_THREAD_FAILED     UI_RC(  3)
#define UI_RC_UNSUPPORTED             UI_RC(  4)

/****************************************************************************/
/* Maximum length of resource string used by UI                             */
/****************************************************************************/
#define UI_ERR_MAX_STRLEN     256

/****************************************************************************/
/* Base of IDs in the Resource DLL for Fatal Error strings                  */
/* All UT strings must be in the range 2000-2999.                           */
/****************************************************************************/
#define UI_ERR_STRING_BASE_ID      2000

/****************************************************************************/
/* Get the string ID from the error code.                                   */
/****************************************************************************/
#define UI_ERR_STRING_ID(x)        (UI_ERR_STRING_BASE_ID + (x))

/****************************************************************************/
/* Error codes - must be < 999                                              */
/****************************************************************************/
#define DC_ERR_UNKNOWN_ERR         0
#define DC_ERR_POSTMESSAGEFAILED   1
#define DC_ERR_OUTOFMEMORY         2
#define DC_ERR_WINDOWCREATEFAILED  3
#define DC_ERR_CLASSREGISTERFAILED 4
#define DC_ERR_FSM_ERROR           5
#define DC_ERR_SENDMESSAGEFAILED   6
#define DC_ERR_COREINITFAILED      7

/****************************************************************************/
/* Warning codes                                                            */
/****************************************************************************/
#define DC_WARN_BITMAPCACHE_CORRUPTED   1

/****************************************************************************/
/* TD errors.                                                               */
/****************************************************************************/
#define DC_ERR_WINSOCKINITFAILED   100

#endif /* _H_AUTERR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\inc\autreg.h ===
/****************************************************************************/
/* autreg.h                                                                 */
/*                                                                          */
/* Registry constants and strings                                           */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997-1999                             */
/****************************************************************************/
#ifndef _H_AUTREG
#define _H_AUTREG


#define UTREG_SECTION _T("")
#include "tsperf.h"

// 
// BE VERY CAREFUL ABOUT CHANGING ANY OF THESE NAMES
// They might be used to refer to legacy registry entries
// that cannot (obviously) change
//
//

#define TSC_SETTINGS_REG_ROOT TEXT("Software\\Microsoft\\Terminal Server Client\\")


/****************************************************************************/
/* Ducati registry prefix.                                                  */
/****************************************************************************/
#define DUCATI_REG_PREFIX      _T("SOFTWARE\\Microsoft\\Terminal Server Client\\")
#define DUCATI_REG_PREFIX_FMT  _T("SOFTWARE\\Microsoft\\Terminal Server Client\\%s")

/****************************************************************************/
/* Minimum time between sending mouse events (ms)                           */
/****************************************************************************/
#define UTREG_IH_MIN_SEND_INTERVAL          _T("Min Send Interval")
#define UTREG_IH_MIN_SEND_INTERVAL_DFLT     100

/****************************************************************************/
/* Max size of InputPDU packet (number of events)                           */
/****************************************************************************/
#define UTREG_IH_MAX_EVENT_COUNT            _T("Max Event Count")
#define UTREG_IH_MAX_EVENT_COUNT_DFLT       100

/****************************************************************************/
/* Normal max size of InputPDU packet (number of events)                    */
/****************************************************************************/
#define UTREG_IH_NRM_EVENT_COUNT            _T("Normal Event Count")
#define UTREG_IH_NRM_EVENT_COUNT_DFLT       10

/****************************************************************************/
/* KeepAlive rate in seconds.  IH sends the mouse position at this rate to  */
/* check that the connection is still active.  Zero = no keep-alives.       */
/****************************************************************************/
#define UTREG_IH_KEEPALIVE_INTERVAL         _T("Keep Alive Interval")
#define UTREG_IH_KEEPALIVE_INTERVAL_DFLT    0
#define KEEP_ALIVE_INTERVAL_OFF             0
#define MIN_KEEP_ALIVE_INTERVAL             10  //10 seconds

/****************************************************************************/
/* Indicates whether or not we are allowed to forward any input mesages we  */
/* may receive while we don't have the focus.                               */
/****************************************************************************/
#define UTREG_IH_ALLOWBACKGROUNDINPUT       _T("Allow Background Input")
#define UTREG_IH_ALLOWBACKGROUNDINPUT_DFLT  0

#ifdef OS_WINCE
/****************************************************************************/
/* Max Mouse Move -- Enabled when the application relies on Pen/Stylus input*/
/* zero = disable feature, non-zero = enable feature (send max)             */
/****************************************************************************/
#define UTREG_IH_MAX_MOUSEMOVE             _T("Max Mouse Move")
#define UTREG_IH_MAX_MOUSEMOVE_DFLT        0
#endif

/****************************************************************************/
/* Browse for servers (Default: yes)                                           */
/****************************************************************************/
#define UTREG_UI_EXPAND          _T("Expand")

#ifdef OS_WIN32
#define UTREG_UI_EXPAND_DFLT     1
#else //OS_WIN32
#define UTREG_UI_EXPAND_DFLT     0
#endif //OS_WIN32

/****************************************************************************/
/* Desktop Size (default 800x600)                                           */
/****************************************************************************/
#define UTREG_UI_DESKTOP_SIZEID             _T("Desktop Size ID")
#define UTREG_UI_DESKTOP_SIZEID_DFLT        1

/****************************************************************************/
/* Screen Mode ID                                                           */
/****************************************************************************/
#define UTREG_UI_SCREEN_MODE             _T("Screen Mode ID")
#define UTREG_UI_SCREEN_MODE_DFLT        UI_FULLSCREEN

//
// DesktopWidth,DesktopHeight (replace ScreenModeID)
//
#define UTREG_UI_DESKTOP_WIDTH           _T("DesktopWidth")
#define UTREG_UI_DESKTOP_WIDTH_DFLT      0
#define UTREG_UI_DESKTOP_HEIGHT          _T("DesktopHeight")
#define UTREG_UI_DESKTOP_HEIGHT_DFLT     0


#define UTREG_UI_KEYBOARD_HOOK          _T("KeyboardHook")
#define UTREG_UI_KEYBOARD_HOOK_NEVER      0
#define UTREG_UI_KEYBOARD_HOOK_ALWAYS     1
#define UTREG_UI_KEYBOARD_HOOK_FULLSCREEN 2
#define UTREG_UI_KEYBOARD_HOOK_DFLT       UTREG_UI_KEYBOARD_HOOK_FULLSCREEN

#define UTREG_UI_AUDIO_MODE                 _T("AudioMode")
#define UTREG_UI_AUDIO_MODE_REDIRECT         0
#define UTREG_UI_AUDIO_MODE_PLAY_ON_SERVER   1
#define UTREG_UI_AUDIO_MODE_NONE             2
#define UTREG_UI_AUDIO_MODE_DFLT          UTREG_UI_AUDIO_MODE_REDIRECT


/****************************************************************************/
/* Color Depth ID: must be CO_BITSPERPEL8                                   */
/****************************************************************************/
#define UTREG_UI_COLOR_DEPTH             _T("Color Depth")

#ifdef DC_HICOLOR
/****************************************************************************/
/* Bpp selection - must be 4, 8, 15, 16 or 24                               */
/****************************************************************************/
#define UTREG_UI_SESSION_BPP             _T("Session Bpp")
#endif

/****************************************************************************/
/* Full Address                                                             */
/****************************************************************************/
#define UTREG_UI_FULL_ADDRESS             _T("Full Address")
#define UTREG_UI_FULL_ADDRESS_DFLT        _T("")

/****************************************************************************/
/*Defines for the MRU list. Should later be implemented as a single string! */
/****************************************************************************/
#define UTREG_UI_SERVER_MRU_DFLT          _T("")
#define UTREG_UI_SERVER_MRU0              _T("MRU0")
#define UTREG_UI_SERVER_MRU1              _T("MRU1")
#define UTREG_UI_SERVER_MRU2              _T("MRU2")
#define UTREG_UI_SERVER_MRU3              _T("MRU3")
#define UTREG_UI_SERVER_MRU4              _T("MRU4")
#define UTREG_UI_SERVER_MRU5              _T("MRU5")
#define UTREG_UI_SERVER_MRU6              _T("MRU6")
#define UTREG_UI_SERVER_MRU7              _T("MRU7")
#define UTREG_UI_SERVER_MRU8              _T("MRU8")
#define UTREG_UI_SERVER_MRU9              _T("MRU9")

/****************************************************************************/
/* Auto Connect                                                             */
/****************************************************************************/
#define UTREG_UI_AUTO_CONNECT             _T("Auto Connect")
#define UTREG_UI_AUTO_CONNECT_DFLT        0

/****************************************************************************/
/* Window positioning information - this consists of the following          */
/* parameters to SetWindowPlacement:                                        */
/* flags, showCmd, NormalPosition(rect)                                     */
/*                                                                          */
/****************************************************************************/
#define UTREG_UI_WIN_POS_STR              _T("WinPosStr")
#define UTREG_UI_WIN_POS_STR_DFLT         _T("0,3,0,0,800,600")

/****************************************************************************/
/* Smooth scrolling flag                                                    */
/****************************************************************************/
#define UTREG_UI_SMOOTH_SCROLL            _T("Smooth Scrolling")
#define UTREG_UI_SMOOTH_SCROLL_DFLT       0

/****************************************************************************/
/* Flag denoting whether accelerator passthrough is enabled on startup      */
/****************************************************************************/
#define UTREG_UI_ACCELERATOR_PASSTHROUGH_ENABLED \
                                        _T("Accelerator Passthrough Enabled")
#define UTREG_UI_ACCELERATOR_PASSTHROUGH_ENABLED_DFLT  1

/****************************************************************************/
/* Transport type: must be TCP                                              */
/****************************************************************************/
#define UTREG_UI_TRANSPORT_TYPE            _T("Transport Type")
#define UTREG_UI_TRANSPORT_TYPE_DFLT       CO_TRANSPORT_TCP
#define UI_TRANSPORT_TYPE_TCP              1  //CO_TRANSPORT_TCP



/****************************************************************************/
/* Dedicated Terminal 0:FALSE 1:TRUE                                        */
/* For Windows CE, enable this so that we have SaveScreenBits even when the */
/* shadow bitmap is disabled.  The Client is the shell on WinCE.            */
/* EXCEPT for the WINCE_HPC case...  In that case, the Client is just       */
/* another application that can be underneath the taskbar.  When that       */
/* happens, the ScrBlt call that ends-up being made will scroll the taskbar */
/* bits along with everything else.  To avoid that behavior, specify that   */
/* the WINCE_HPC client is NOT a dedicated terminal.                        */
/* On WinCE, we have one binary for both WBT and HPC builds now, so we have */
/* to make this an extern and determine it's value at runtime               */
/****************************************************************************/


#define UTREG_UI_DEDICATED_TERMINAL        _T("Dedicated Terminal")

#ifdef OS_WINCE
extern BOOL UTREG_UI_DEDICATED_TERMINAL_DFLT;
#else
#ifndef DISABLE_SHADOW_IN_FULLSCREEN
#define UTREG_UI_DEDICATED_TERMINAL_DFLT   TRUE
#else 
#define UTREG_UI_DEDICATED_TERMINAL_DFLT   FALSE
#endif // DISABLE_SHADOW_IN_FULLSCREEN
#endif

#ifdef OS_WINCE  
/****************************************************************************/
/* Used to override the TSC's default palette-usage.                        */
/* This is used on non-WBT configs only.                                    */
/****************************************************************************/
#define UTREG_UI_PALETTE_IS_FIXED          _T("PaletteIsFixed")
#endif 

/****************************************************************************/
/* SAS sequence: must be RNS_US_SAS_DEL                                     */
/****************************************************************************/
#define UTREG_UI_SAS_SEQUENCE              _T("SAS Sequence")
#define UTREG_UI_SAS_SEQUENCE_DFLT         RNS_UD_SAS_DEL

/****************************************************************************/
/* Encryption 0:off 1:on                                                    */
/****************************************************************************/
#define UTREG_UI_ENCRYPTION_ENABLED        _T("Encryption enabled")
#define UTREG_UI_ENCRYPTION_ENABLED_DFLT   1

/****************************************************************************/
/* Hatch bitmap PDU data flag                                               */
/****************************************************************************/
#define UTREG_UI_HATCH_BITMAP_PDU_DATA        _T("Hatch BitmapPDU Data")
#define UTREG_UI_HATCH_BITMAP_PDU_DATA_DFLT   0

/****************************************************************************/
/* Hatch index PDU data flag                                                */
/****************************************************************************/
#define UTREG_UI_HATCH_INDEX_PDU_DATA         _T("Hatch IndexPDU Data")
#define UTREG_UI_HATCH_INDEX_PDU_DATA_DFLT    0

/****************************************************************************/
/* Hatch SSB data flag                                                      */
/****************************************************************************/
#define UTREG_UI_HATCH_SSB_ORDER_DATA         _T("Hatch SSB Order Data")
#define UTREG_UI_HATCH_SSB_ORDER_DATA_DFLT    0

/****************************************************************************/
/* Hatch MemBlt orders flag                                                 */
/****************************************************************************/
#define UTREG_UI_HATCH_MEMBLT_ORDER_DATA      _T("Hatch MemBlt Order Data")
#define UTREG_UI_HATCH_MEMBLT_ORDER_DATA_DFLT 0

/****************************************************************************/
/* Label MemBlt orders flag                                                 */
/****************************************************************************/
#define UTREG_UI_LABEL_MEMBLT_ORDERS          _T("Label MemBlt Orders")
#define UTREG_UI_LABEL_MEMBLT_ORDERS_DFLT     0

/****************************************************************************/
/* Bitmap Cache Monitor flag                                                */
/****************************************************************************/
#define UTREG_UI_BITMAP_CACHE_MONITOR         _T("Bitmap Cache Monitor")
#define UTREG_UI_BITMAP_CACHE_MONITOR_DFLT    0

/****************************************************************************/
/* Shadow bitmap flag                                                       */
/****************************************************************************/
#define UTREG_UI_SHADOW_BITMAP                _T("Shadow Bitmap Enabled")
#define UTREG_UI_SHADOW_BITMAP_DFLT           1

/****************************************************************************/
/* Define the ms-wbt-server reserved port.                                  */
/****************************************************************************/
#define UTREG_UI_MCS_PORT                     _T("Server Port")
#define UTREG_UI_MCS_PORT_DFLT                0xD3D

/****************************************************************************/
// Compression flag
/****************************************************************************/
#define UTREG_UI_COMPRESS                     _T("Compression")
#define UTREG_UI_COMPRESS_DFLT                1

#define UTREG_UI_BITMAP_PERSISTENCE           _T("BitmapCachePersistEnable")
#define UTREG_UI_BITMAP_PERSISTENCE_DFLT      1

/****************************************************************************/
/* Timeout (in seconds) for connection to a single IP address.  Note that   */
/* the UI may attempt to connect to multiple IP addresses during a single   */
/* connection attempt.                                                      */
/****************************************************************************/
#define UTREG_UI_SINGLE_CONN_TIMEOUT          _T("Single Connection Timeout")
#define UTREG_UI_SINGLE_CONN_TIMEOUT_DFLT     30

/****************************************************************************/
/* Overall connection timeout (seconds).  This timeout limits the total     */
/* time the UI spends attempting to connect to multiple IP addresses.       */
/****************************************************************************/
#define UTREG_UI_OVERALL_CONN_TIMEOUT        _T("Overall Connection Timeout")
#define UTREG_UI_OVERALL_CONN_TIMEOUT_DFLT   120

#define UTREG_UI_SHUTDOWN_TIMEOUT            _T("Shutdown Timeout")
#define UTREG_UI_SHUTDOWN_TIMEOUT_DFLT       10

/****************************************************************************/
/* Keyboard Layout                                                          */
/****************************************************************************/
#define UTREG_UI_KEYBOARD_LAYOUT              _T("Keyboard Layout")
#define UTREG_UI_KEYBOARD_LAYOUT_DFLT         _T("0xffffffff")
#define UTREG_UI_KEYBOARD_LAYOUT_LEN 12

/****************************************************************************/
/* Keyboard Type/Sub Type/Function Key                                      */
/****************************************************************************/
#define UTREG_UI_KEYBOARD_TYPE                _T("Keyboard Type")
#define UTREG_UI_KEYBOARD_TYPE_DFLT           4
#define UTREG_UI_KEYBOARD_SUBTYPE             _T("Keyboard SubType")
#define UTREG_UI_KEYBOARD_SUBTYPE_DFLT        0
#define UTREG_UI_KEYBOARD_FUNCTIONKEY         _T("Keyboard FunctionKeys")
#define UTREG_UI_KEYBOARD_FUNCTIONKEY_DFLT    12

/****************************************************************************/
/* UH registry access parameters/defaults.                                  */
/****************************************************************************/
// Bitmap cache overall params - cache size to alloc, number of cell caches.
/****************************************************************************/
#define UTREG_UH_TOTAL_BM_CACHE _T("BitmapCacheSize") // RAM cache space 
#define UTREG_UH_TOTAL_BM_CACHE_DFLT 1500             // 1500 KB

// Whether to scale the RAM and persistent cache sizes by the bit depth of
// the protocol.
#define UTREG_UH_SCALE_BM_CACHE _T("ScaleBitmapCacheForBPP")
#define UTREG_UH_SCALE_BM_CACHE_DFLT 1

#define UTREG_UH_TOTAL_BM_PERSIST_CACHE _T("BitmapPersistCacheSize")
#define UTREG_UH_TOTAL_BM_PERSIST_CACHE_DFLT 10      // 10 MB disk cache

#define TSC_BITMAPCACHE_8BPP_PROPNAME    _T("BitmapPersistCacheSize")
#define TSC_BITMAPCACHE_16BPP_PROPNAME   _T("BitmapPersistCache16Size")
#define TSC_BITMAPCACHE_24BPP_PROPNAME   _T("BitmapPersistCache24Size")

#define TSC_BITMAPCACHEVIRTUALSIZE_8BPP           10
#define TSC_BITMAPCACHEVIRTUALSIZE_16BPP          20
#define TSC_BITMAPCACHEVIRTUALSIZE_24BPP          30

//
// Maximum BMP cache size in MB
//
#define TSC_MAX_BITMAPCACHESIZE 32


#define UTREG_UH_BM_PERSIST_CACHE_LOCATION _T("BitmapPersistCacheLocation")

#define UTREG_UH_BM_NUM_CELL_CACHES _T("BitmapCacheNumCellCaches")
#define UTREG_UH_BM_NUM_CELL_CACHES_DFLT 3

/****************************************************************************/
// Cell cache parameter registry entry templates.
/****************************************************************************/
#define UTREG_UH_BM_CACHE_PROPORTION_TEMPLATE _T("BitmapCache%cProp")
#define UTREG_UH_BM_CACHE_PERSISTENCE_TEMPLATE _T("BitmapCache%cPersistence")
#define UTREG_UH_BM_CACHE_MAXENTRIES_TEMPLATE _T("BitmapCache%cMaxEntries")

/****************************************************************************/
// Cell cache defaults - proportion of cache, persistence, cell entries.
/****************************************************************************/
#define UTREG_UH_BM_CACHE1_PROPORTION_DFLT    2
#define UTREG_UH_BM_CACHE1_PERSISTENCE_DFLT   0
#define UTREG_UH_BM_CACHE1_MAXENTRIES_DFLT    120

#define UTREG_UH_BM_CACHE2_PROPORTION_DFLT    8
#define UTREG_UH_BM_CACHE2_PERSISTENCE_DFLT   0
#define UTREG_UH_BM_CACHE2_MAXENTRIES_DFLT    120

#define UTREG_UH_BM_CACHE3_PROPORTION_DFLT    90
#define UTREG_UH_BM_CACHE3_PERSISTENCE_DFLT   1
#define UTREG_UH_BM_CACHE3_MAXENTRIES_DFLT    65535

#define UTREG_UH_BM_CACHE4_PROPORTION_DFLT    0
#define UTREG_UH_BM_CACHE4_PERSISTENCE_DFLT   0
#define UTREG_UH_BM_CACHE4_MAXENTRIES_DFLT    65535

#define UTREG_UH_BM_CACHE5_PROPORTION_DFLT    0
#define UTREG_UH_BM_CACHE5_PERSISTENCE_DFLT   0
#define UTREG_UH_BM_CACHE5_MAXENTRIES_DFLT    65535

/****************************************************************************/
/* Frequency with which to display output                                   */
/****************************************************************************/
#define UTREG_UH_DRAW_THRESHOLD      _T("Order Draw Threshold")
#define UTREG_UH_DRAW_THRESHOLD_DFLT 25

#define UH_GLC_CACHE_MAXIMUMCELLSIZE  2048

/****************************************************************************/
/* GlyphOutput support level                                                */
/****************************************************************************/
#define UTREG_UH_GL_SUPPORT                 _T("GlyphSupportLevel")
#define UTREG_UH_GL_SUPPORT_DFLT            3

/****************************************************************************/
/* Glyph cache1 cell size                                                   */
/****************************************************************************/
#define UTREG_UH_GL_CACHE1_CELLSIZE         _T("GlyphCache1CellSize")
#define UTREG_UH_GL_CACHE1_CELLSIZE_DFLT    4

/****************************************************************************/
/* Glyph cache1 cell size                                                   */
/****************************************************************************/
#define UTREG_UH_GL_CACHE2_CELLSIZE         _T("GlyphCache2CellSize")
#define UTREG_UH_GL_CACHE2_CELLSIZE_DFLT    4

/****************************************************************************/
/* Glyph cache1 cell size                                                   */
/****************************************************************************/
#define UTREG_UH_GL_CACHE3_CELLSIZE         _T("GlyphCache3CellSize")
#define UTREG_UH_GL_CACHE3_CELLSIZE_DFLT    8

/****************************************************************************/
/* Glyph cache1 cell size                                                   */
/****************************************************************************/
#define UTREG_UH_GL_CACHE4_CELLSIZE         _T("GlyphCache4CellSize")
#define UTREG_UH_GL_CACHE4_CELLSIZE_DFLT    8

/****************************************************************************/
/* Glyph cache1 cell size                                                   */
/****************************************************************************/
#define UTREG_UH_GL_CACHE5_CELLSIZE         _T("GlyphCache5CellSize")
#define UTREG_UH_GL_CACHE5_CELLSIZE_DFLT    16

/****************************************************************************/
/* Glyph cache1 cell size                                                   */
/****************************************************************************/
#define UTREG_UH_GL_CACHE6_CELLSIZE         _T("GlyphCache6CellSize")
#define UTREG_UH_GL_CACHE6_CELLSIZE_DFLT    32

/****************************************************************************/
/* Glyph cache1 cell size                                                   */
/****************************************************************************/
#define UTREG_UH_GL_CACHE7_CELLSIZE         _T("GlyphCache7CellSize")
#define UTREG_UH_GL_CACHE7_CELLSIZE_DFLT    64

/****************************************************************************/
/* Glyph cache1 cell size                                                   */
/****************************************************************************/
#define UTREG_UH_GL_CACHE8_CELLSIZE         _T("GlyphCache8CellSize")
#define UTREG_UH_GL_CACHE8_CELLSIZE_DFLT    128

/****************************************************************************/
/* Glyph cache1 cell size                                                   */
/****************************************************************************/
#define UTREG_UH_GL_CACHE9_CELLSIZE         _T("GlyphCache9CellSize")
#define UTREG_UH_GL_CACHE9_CELLSIZE_DFLT    256

/****************************************************************************/
/* Glyph cache1 cell size                                                   */
/****************************************************************************/
#define UTREG_UH_GL_CACHE10_CELLSIZE        _T("GlyphCache10CellSize")
#define UTREG_UH_GL_CACHE10_CELLSIZE_DFLT   2048

/****************************************************************************/
/* Text fragment cache cell size                                            */
/****************************************************************************/
#define UTREG_UH_FG_CELLSIZE            _T("TextFragmentCellSize")
#define UTREG_UH_FG_CELLSIZE_DFLT       256

/****************************************************************************/
/* Brush support level                                                      */
/****************************************************************************/
#define UTREG_UH_BRUSH_SUPPORT                 _T("BrushSupportLevel")
#define UTREG_UH_BRUSH_SUPPORT_DFLT            TS_BRUSH_COLOR8x8

/****************************************************************************/
// Offscreen support level                                                      
/****************************************************************************/
#define UTREG_UH_OFFSCREEN_SUPPORT                 _T("OffscreenSupportLevel")
#define UTREG_UH_OFFSCREEN_SUPPORT_DFLT            TS_OFFSCREEN_SUPPORTED

#define UTREG_UH_OFFSCREEN_CACHESIZE               _T("OffscreenCacheSize")
#define UTREG_UH_OFFSCREEN_CACHESIZE_DFLT          TS_OFFSCREEN_CACHE_SIZE_CLIENT_DEFAULT

#define UTREG_UH_OFFSCREEN_CACHEENTRIES            _T("OffscreenCacheEntries")
#define UTREG_UH_OFFSCREEN_CACHEENTRIES_DFLT       TS_OFFSCREEN_CACHE_ENTRIES_DEFAULT

#ifdef DRAW_NINEGRID
/****************************************************************************/
// DrawNineGrid support level                                                      
/****************************************************************************/
#define UTREG_UH_DRAW_NINEGRID_SUPPORT             _T("DrawNineGridSupportLevel")
#define UTREG_UH_DRAW_NINEGRID_SUPPORT_DFLT        TS_DRAW_NINEGRID_SUPPORTED_REV2

#define UTREG_UH_DRAW_NINEGRID_EMULATE             _T("DrawNineGridEmulate")
#define UTREG_UH_DRAW_NINEGRID_EMULATE_DFLT        0

#define UTREG_UH_DRAW_NINEGRID_CACHESIZE           _T("DrawNineGridCacheSize")
#define UTREG_UH_DRAW_NINEGRID_CACHESIZE_DFLT      TS_DRAW_NINEGRID_CACHE_SIZE_DEFAULT

#define UTREG_UH_DRAW_NINEGRID_CACHEENTRIES        _T("DrawNineGridCacheEntries")
#define UTREG_UH_DRAW_NINEGRID_CACHEENTRIES_DFLT   TS_DRAW_NINEGRID_CACHE_ENTRIES_DEFAULT

#endif

#ifdef DRAW_GDIPLUS
/****************************************************************************/
// DrawGdiplus support level                                                      
/****************************************************************************/
#define UTREG_UH_DRAW_GDIPLUS_SUPPORT             _T("DrawGdiplusSupportLevel")
#define UTREG_UH_DRAW_GDIPLUS_SUPPORT_DFLT        TS_DRAW_GDIPLUS_SUPPORTED

#define UTREG_UH_DRAW_GDIPLUS_CACHE_LEVEL             _T("DrawGdiplusCacheLevel")
#define UTREG_UH_DRAW_GDIPLUS_CACHE_LEVEL_DFLT        TS_DRAW_GDIPLUS_CACHE_LEVEL_ONE

#define UTREG_UH__GDIPLUS_GRAPHICS_CACHEENTRIES        _T("DrawGdiplusGraphicsCacheEntries")
#define UTREG_UH_DRAW_GDIP_GRAPHICS_CACHEENTRIES_DFLT   TS_GDIP_GRAPHICS_CACHE_ENTRIES_DEFAULT

#define UTREG_UH__GDIPLUS_BRUSH_CACHEENTRIES        _T("DrawGdiplusBrushCacheEntries")
#define UTREG_UH_DRAW_GDIP_BRUSH_CACHEENTRIES_DFLT   TS_GDIP_BRUSH_CACHE_ENTRIES_DEFAULT

#define UTREG_UH__GDIPLUS_PEN_CACHEENTRIES        _T("DrawGdiplusPenCacheEntries")
#define UTREG_UH_DRAW_GDIP_PEN_CACHEENTRIES_DFLT   TS_GDIP_PEN_CACHE_ENTRIES_DEFAULT

#define UTREG_UH__GDIPLUS_IMAGE_CACHEENTRIES        _T("DrawGdiplusImageCacheEntries")
#define UTREG_UH_DRAW_GDIP_IMAGE_CACHEENTRIES_DFLT   TS_GDIP_IMAGE_CACHE_ENTRIES_DEFAULT

#define UTREG_UH__GDIPLUS_GRAPHICS_CACHE_CHUNKSIZE        _T("DrawGdiplusGraphicsCacheChunkSize")
#define UTREG_UH_DRAW_GDIP_GRAPHICS_CACHE_CHUNKSIZE_DFLT   TS_GDIP_GRAPHICS_CACHE_CHUNK_SIZE_DEFAULT

#define UTREG_UH__GDIPLUS_BRUSH_CACHE_CHUNKSIZE        _T("DrawGdiplusBrushCacheChunkSize")
#define UTREG_UH_DRAW_GDIP_BRUSH_CACHE_CHUNKSIZE_DFLT   TS_GDIP_BRUSH_CACHE_CHUNK_SIZE_DEFAULT

#define UTREG_UH__GDIPLUS_PEN_CACHE_CHUNKSIZE        _T("DrawGdiplusPenCacheChunkSize")
#define UTREG_UH_DRAW_GDIP_PEN_CACHE_CHUNKSIZE_DFLT   TS_GDIP_PEN_CACHE_CHUNK_SIZE_DEFAULT

#define UTREG_UH__GDIPLUS_IMAGEATTRIBUTES_CACHE_CHUNKSIZE        _T("DrawGdiplusImageAttributesCacheChunkSize")
#define UTREG_UH_DRAW_GDIP_IMAGEATTRIBUTES_CACHE_CHUNKSIZE_DFLT   TS_GDIP_IMAGEATTRIBUTES_CACHE_CHUNK_SIZE_DEFAULT

#define UTREG_UH__GDIPLUS_IMAGE_CACHE_CHUNKSIZE        _T("DrawGdiplusImageCacheChunkSize")
#define UTREG_UH_DRAW_GDIP_IMAGE_CACHE_CHUNKSIZE_DFLT   TS_GDIP_IMAGE_CACHE_CHUNK_SIZE_DEFAULT

#define UTREG_UH__GDIPLUS_IMAGE_CACHE_TOTALSIZE        _T("DrawGdiplusImageCacheTotalSize")
#define UTREG_UH_DRAW_GDIP_IMAGE_CACHE_TOTALSIZE_DFLT   TS_GDIP_IMAGE_CACHE_TOTAL_SIZE_DEFAULT

#define UTREG_UH__GDIPLUS_IMAGE_CACHE_MAXSIZE        _T("DrawGdiplusImageCacheMaxSize")
#define UTREG_UH_DRAW_GDIP_IMAGE_CACHE_MAXSIZE_DFLT   TS_GDIP_IMAGE_CACHE_MAX_SIZE_DEFAULT

#define UTREG_UH__GDIPLUS_IMAGEATTRIBUTES_CACHEENTRIES        _T("DrawGdiplusImageattributesCacheEntries")
#define UTREG_UH_DRAW_GDIP_IMAGEATTRIBUTES_CACHEENTRIES_DFLT   TS_GDIP_IMAGEATTRIBUTES_CACHE_ENTRIES_DEFAULT
#endif // DRAW_GDIPLUS


/****************************************************************************/
/* Disable ctrl-alt-del flag                                                */
/****************************************************************************/
#define UTREG_UI_DISABLE_CTRLALTDEL         _T("Disable CTRL+ALT+DEL")
#define UTREG_UI_DISABLE_CTRLALTDEL_DFLT    1

#ifdef SMART_SIZING
/****************************************************************************/
/* Smart Sizing flag
/****************************************************************************/
#define UTREG_UI_SMARTSIZING                _T("Smart Sizing")
#define UTREG_UI_SMARTSIZING_DFLT           0
#endif // SMART_SIZING

/****************************************************************************/
/* Connect to console flag
/****************************************************************************/
#define UTREG_UI_CONNECTTOCONSOLE           _T("Connect to Console")
#define UTREG_UI_CONNECTTOCONSOLE_DFLT      0

/****************************************************************************/
/* Enable Windows key flag                                                  */
/****************************************************************************/
#define UTREG_UI_ENABLE_WINDOWSKEY          _T("Enable WindowsKey")
#define UTREG_UI_ENABLE_WINDOWSKEY_DFLT     1

/****************************************************************************/
/* Enable mouse flag                                                        */
/****************************************************************************/
#define UTREG_UI_ENABLE_MOUSE               _T("Enable Mouse")
#define UTREG_UI_ENABLE_MOUSE_DFLT          1

/****************************************************************************/
/* DoubleDoubleclickclick detect flag                                       */
/****************************************************************************/
#define UTREG_UI_DOUBLECLICK_DETECT         _T("DoubleClick Detect")
#define UTREG_UI_DOUBLECLICK_DETECT_DFLT    0

/****************************************************************************/
/* Auto logon flag                                                          */
/****************************************************************************/
#define UTREG_UI_AUTOLOGON                  _T("AutoLogon")
#define UTREG_UI_AUTOLOGON_DFLT             0
#define UTREG_UI_AUTOLOGON50                _T("AutoLogon 50")
#define UTREG_UI_AUTOLOGON50_DFLT           0

/****************************************************************************/
/* Maximize shell flag                                                      */
/****************************************************************************/
#define UTREG_UI_MAXIMIZESHELL              _T("MaximizeShell")
#define UTREG_UI_MAXIMIZESHELL_DFLT         1
#define UTREG_UI_MAXIMIZESHELL50            _T("MaximizeShell 50")
#define UTREG_UI_MAXIMIZESHELL50_DFLT       1

/****************************************************************************/
/* Domain                                                                   */
/****************************************************************************/
#define UTREG_UI_DOMAIN                     _T("Domain")
#define UTREG_UI_DOMAIN_DFLT                _T("")
#define UTREG_UI_DOMAIN50                   _T("Domain 50")
#define UTREG_UI_DOMAIN50_DFLT              _T("")

/****************************************************************************/
/* UserName                                                                 */
/****************************************************************************/
#define UTREG_UI_USERNAME                   _T("UserName")
#define UTREG_UI_USERNAME_DFLT              _T("")
#define UTREG_UI_USERNAME50                 _T("UserName 50")
#define UTREG_UI_USERNAME50_DFLT            _T("")

/****************************************************************************/
/* Password                                                                 */
/****************************************************************************/
#define UTREG_UI_PASSWORD                   _T("Password")
#define UTREG_UI_PASSWORD_DFLT              _T("")
#define UTREG_UI_PASSWORD50                 _T("Password 50")
#define UTREG_UI_PASSWORD50_DFLT            _T("")
#define UI_SETTING_PASSWORD51               _T("Password 51")
#define UI_SETTING_PASSWORD_CLEAR           _T("Clear Password")

/****************************************************************************/
/* Salt                                                                     */
/****************************************************************************/
#define UTREG_UI_SALT50                     _T("Salt 50")
#define UTREG_UI_SALT50_DFLT                _T("")
#define UI_SETTING_SALT51                   _T("Salt 51")

/****************************************************************************/
/* AlternateShell                                                           */
/****************************************************************************/
#define UTREG_UI_ALTERNATESHELL             _T("Alternate Shell")
#define UTREG_UI_ALTERNATESHELL_DFLT        _T("")
#define UTREG_UI_ALTERNATESHELL50           _T("Alternate Shell 50")
#define UTREG_UI_ALTERNATESHELL50_DFLT      _T("")

/****************************************************************************/
/* WorkingDir                                                               */
/****************************************************************************/
#define UTREG_UI_WORKINGDIR                 _T("Shell Working Directory")
#define UTREG_UI_WORKINGDIR_DFLT            _T("")
#define UTREG_UI_WORKINGDIR50               _T("Shell Working Directory 50")
#define UTREG_UI_WORKINGDIR50_DFLT          _T("")

/****************************************************************************/
/* Subkey for hotkeys                                                       */
/****************************************************************************/

#define UTREG_SUB_HOTKEY                    _T("\\Hotkey")

/****************************************************************************/
/* Hotkey names                                                             */
/****************************************************************************/
// Full screen VK code
#define UTREG_UI_FULL_SCREEN_VK_CODE        _T("Full Screen Hotkey")
#define UTREG_UI_FULL_SCREEN_VK_CODE_DFLT   VK_CANCEL
#define UTREG_UI_FULL_SCREEN_VK_CODE_NEC98_DFLT  VK_F12

#define UTREG_UI_CTRL_ESC_VK_CODE           _T("CtrlEsc")
#define UTREG_UI_CTRL_ESC_VK_CODE_DFLT      VK_HOME

#define UTREG_UI_ALT_ESC_VK_CODE            _T("AltEsc")
#define UTREG_UI_ALT_ESC_VK_CODE_DFLT       VK_INSERT

#define UTREG_UI_ALT_TAB_VK_CODE            _T("AltTab")
#define UTREG_UI_ALT_TAB_VK_CODE_DFLT       VK_PRIOR

#define UTREG_UI_ALT_SHFTAB_VK_CODE         _T("AltShiftTab")
#define UTREG_UI_ALT_SHFTAB_VK_CODE_DFLT    VK_NEXT

#define UTREG_UI_ALT_SPACE_VK_CODE          _T("AltSpace")
#define UTREG_UI_ALT_SPACE_VK_CODE_DFLT     VK_DELETE

#define UTREG_UI_CTRL_ALTDELETE_VK_CODE      _T("CtrlAltDelete")
#define UTREG_UI_CTRL_ALTDELETE_VK_CODE_DFLT VK_END
#define UTREG_UI_CTRL_ALTDELETE_VK_CODE_NEC98_DFLT  VK_F11

/****************************************************************************/
/* IME                                                                      */
/****************************************************************************/
#define UTREG_IME_MAPPING_TABLE_JPN      _T("IME Mapping Table\\JPN")
#define UTREG_IME_MAPPING_TABLE_KOR      _T("IME Mapping Table\\KOR")
#define UTREG_IME_MAPPING_TABLE_CHT      _T("IME Mapping Table\\CHT")
#define UTREG_IME_MAPPING_TABLE_CHS      _T("IME Mapping Table\\CHS")

/****************************************************************************/
/* Browse DNS Domain Name                                                   */
/****************************************************************************/
#define UTREG_UI_BROWSE_DOMAIN_NAME         _T("BrowseDnsDomain")
#define UTREG_UI_BROWSE_DOMAIN_NAME_DFLT    _T("")

//
// Drive mapping
//
#define TSCSETTING_REDIRECTDRIVES        _T("RedirectDrives")
#define TSCSETTING_REDIRECTDRIVES_DFLT   0

#define TSCSETTING_REDIRECTPRINTERS      _T("RedirectPrinters")
#define TSCSETTING_REDIRECTPRINTERS_DFLT 1

#define TSCSETTING_REDIRECTCOMPORTS      _T("RedirectCOMPorts")
#define TSCSETTING_REDIRECTCOMPORTS_DFLT 0

#define TSCSETTING_REDIRECTSCARDS        _T("RedirectSmartCards")
#define TSCSETTING_REDIRECTSCARDS_DFLT   1

#define TSCSETTING_DISPLAYCONNECTIONBAR  _T("DisplayConnectionBar")
#define TSCSETTING_DISPLAYCONNECTIONBAR_DFLT  1

#define TSCSETTING_PINCONNECTIONBAR  _T("PinConnectionBar")
#define TSCSETTING_PINCONNECTIONBAR_DFLT  1

#define TSCSETTING_ENABLEAUTORECONNECT _T("AutoReconnection Enabled")
#define TSCSETTING_ENABLEAUTORECONNECT_DFLT  1

#define TSCSETTING_ARC_RETRIES         _T("AutoReconnect Max Retries")
#define TSCSETTING_ARC_RETRIES_DFLT     20

#define UTREG_DEBUG_THREADTIMEOUT      _T("DebugThreadTimeout")
#define UTREG_THREADTIMEOUT_DFLT       -1

#define UTREG_DEBUG_ALLOWDEBUGIFACE    _T("AllowDebugInterface")
#define UTREG_DEBUG_ALLOWDEBUGIFACE_DFLT 0

#ifdef PROXY_SERVER
#define UTREG_UI_PROXY_SERVER_NAME       _T("ProxyServer")
#define UTREG_UI_PROXY_SERVER_DFLT       _T("")

#define UTREG_UI_PROXY_USEHTTPS          _T("ProxyUseHttps")
#define UTREG_UI_PROXY_USEHTTPS_DFLT     1

#define UTREG_UI_PROXY_URL               _T("ProxyUrl")
#define UTREG_UI_PROXY_URL_DFLT          _T("/tsproxy/tsproxy.dll")
#endif //PROXY_SERVER

//
// Redirection security flags
//
#define REG_SECURITY_FILTER_SECTION      _T("LocalDevices")
#define REDIRSEC_PROMPT_EVERYTHING       0x0000
#define REDIRSEC_DRIVES                  0x0001
#define REDIRSEC_PORTS                   0x0002

#define REG_KEYNAME_SECURITYLEVEL        _T("SecurityLevel")
#define TSC_SECLEVEL_LOW                 0x0000
#define TSC_SECLEVEL_MEDIUM              0x0001
#define TSC_SECLEVEL_HIGH                0x0002


#endif /* _H_AUTREG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\inc\aver.h ===
/**MOD+**********************************************************************/
/* Module:    aver.h                                                        */
/*                                                                          */
/* Purpose:   Version information                                           */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/hydra/tshrclnt/inc/aver.h_v  $
 *
 *    Rev 1.4   30 Sep 1997 14:10:18   KH
 * SFR1471: y:\logs\hydra\tshrclnt\inc
 *
 *    Rev 1.3   27 Aug 1997 10:43:06   ENH
 * SFR1030: Changed build number
 *
 *    Rev 1.2   18 Jul 1997 17:20:40   ENH
 * SFR1030: Fixed octal bug
 *
 *    Rev 1.1   18 Jul 1997 15:56:22   ENH
 * SFR1030: Added version information
**/
/**MOD-**********************************************************************/
#ifndef OS_WINCE
#include <ntverp.h>
#else
#include "bldver.h"
#define VER_PRODUCTBUILD           CE_BUILD_VER
#endif

#define DCVER_PRODUCTNAME_STR      VER_PRODUCTNAME_STR
#define DCVER_COMPANYNAME_STR      VER_COMPANYNAME_STR
#define DCVER_LEGALTRADEMARKS_STR  VER_LEGALTRADEMARKS_STR
#define DCVER_LEGALCOPYRIGHT_STR   VER_COPYRIGHT_STR
#define DCVER_EXEFILETYPE          VFT_APP
#define DCVER_DLLFILETYPE          VFT_DLL
#define DCVER_FILESUBTYPE          0
#define DCVER_FILEFLAGSMASK        VS_FFI_FILEFLAGSMASK
#define DCVER_FILEFLAGS            0L
#define DCVER_FILEOS               VOS_NT_WINDOWS32

/****************************************************************************/
/* Th build number has the following format:                                */
/* -  the first 2 numbers are 4.0 which is the Win NT version targetted     */
/* -  the third number is DCL build number, which is actually the date mmdd */
/* -  the fourth number is the Microsoft build number.                      */
/*                                                                          */
/* Define the DCL build number - for convenience define as a number and as  */
/* a string.                                                                */
/****************************************************************************/
#define DCVER_BUILD_NUMBER  VER_PRODUCTBUILD
#define stringize(x) #x
#define DCVER_BUILD_NUM_STR stringize(DCVER_BUILD_NUMBER)

/****************************************************************************/
/* Define the NT version, both numeric and string form.                     */
/****************************************************************************/
#define DCVER_NT_VERSION      4
#define DCVER_NT_SUB_VERSION    0
#define DCVER_NT_VERSION_STR "4.0"

/****************************************************************************/
/* The following section defines the version strings used throughout the    */
/* product.  For convenience four different version strings are defined and */
/* used throughout the product.                                             */
/****************************************************************************/
#ifndef DCVER_VERSION
#define DCVER_VERSION DCVER_NT_VERSION,     \
                      DCVER_NT_SUB_VERSION, \
                      DCVER_BUILD_NUMBER,   \
                      VERSIONBUILD
#endif

#ifndef DCVER_VERSION_STR
#define DCVER_VERSION_STR  DCVER_NT_VERSION_STR "." DCVER_BUILD_NUM_STR "." \
                                                             VERSIONBUILD_STR
#endif

#ifndef DCVER_PRODUCTVERSION_STR
#define DCVER_PRODUCTVERSION_STR  VER_PRODUCTRELEASE_STR
#endif

#ifdef DCVER_VERNUM
#undef  DCVER_VERSION
#define DCVER_VERSION              DCVER_VERNUM
#endif

/****************************************************************************/
/* DCVER_BUILD_STR is a string containing the same information as           */
/* DCVER_VERSION.                                                           */
/****************************************************************************/
#define DCVER_BUILD_STR DCVER_NT_VERSION_STR "." DCVER_BUILD_NUM_STR "." \
                                                             VERSIONBUILD_STR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\inc\axresrc.h ===
/**INC+**********************************************************************/
/* Header: axresrc.h                                                        */
/*                                                                          */
/* Purpose: resource defines specific to ax control                         */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1999-2000                             */
/*                                                                          */
/****************************************************************************/
#ifndef _axresrc_h_
#define _axresrc_h_

#define TIMEBOMB_EXPIRED_STR 100

#define IDB_BBAR_TOOLBAR_LEFT  101
#define IDB_BBAR_TOOLBAR_RIGHT 102
#define IDBAR_BBAR_TOOLBAR1    103
#define IDB_ARC_BACKGROUND24   104
#define IDB_ARC_BACKGROUND8    105
#define IDB_ARC_WINFLAG24      106
#define IDB_ARC_WINFLAG8       107
#define IDB_ARC_DISCON24       108
#define IDB_ARC_DISCON8        109

#define IDB_ARC_BAND24         110
#define IDB_ARC_BAND8          111

#define IDI_ARC_DISCON         112

//
// Dialogs
//
#define IDD_ARCDLG             200


//
// ARC dlg items
//

#define IDC_TITLE_FLAG         201
#define IDC_TITLE_ARCING       202
#define IDC_ARC_STATIC_DISCBMP 203
#define IDC_ARC_STATIC_INFO    204
#define IDC_ARC_STATIC_DESC    205


//
// Strings
//
#define IDS_ARC_TITLE_FACESIZE  300
#define IDS_ARC_TITLE_FACENAME  301
#define IDS_ARC_CONATTEMPTS     304

#define IDS_RDPDR_PRINT_LOCALDOCNAME     305
#define IDS_RDPDR_CLIP_CLEANTEMPDIR      306
#define IDS_RDPDR_CLIP_PASTEINFO         307



#ifdef OS_WINCE
#define RDPDR_DEVICENAME 104

#define TRC_IDD_ASSERT   1000
#define TRC_ID_TEXT      1001

#endif

#endif //_axresrc_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\inc\browsesrv.h ===
//
// browsesrv.h: browse for servers list box
//

#ifndef _BROWSESRV_H_
#define _BROWSESRV_H_

#define BROWSE_MAX_ADDRESS_LENGTH           256
#define BROWSE_MAX_DOMAIN_LENGTH            52


#ifdef OS_WIN32
    #define NET_API_STATUS          DWORD
    #define NET_API_FUNCTION    __stdcall
#ifndef OS_WINCE
    #include <lmaccess.h>
    #include <lmserver.h>
    #include <lmwksta.h>
    #include <lmerr.h>
    #include <lmapibuf.h>
    #include <dsgetdc.h>
#else
    #include <winnetwk.h>
#endif // OS_WINCE
    #include <commctrl.h>
#endif //OS_WIN32

#ifndef OS_WINCE
#include  <serverenum.h>
#endif // OS_WINCE

#define SV_TYPE_APPSERVER      0x10000000
#define SV_TYPE_TERMINALSERVER 0x02000000

// BUBBUG - Need to fix this for Beta 2 by removing the APPSERVER bit.
#define HYDRA_SERVER_LANMAN_BITS    (SV_TYPE_TERMINALSERVER | SV_TYPE_APPSERVER)

#define XBMPOFFSET 2
#define DISPLAY_MAP_TRANS_COLOR     RGB(0x00, 0xFF, 0x00 )

#ifndef OS_WINCE
static TCHAR DOMAIN_KEY[] = _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon");
static TCHAR PRIMARY_VAL[] = _T("CachePrimaryDomain");
#else
static TCHAR DOMAIN_KEY[] = _T("Comm\\Redir");
static TCHAR PRIMARY_VAL[] = _T("DefaultDomain");
#endif
static TCHAR CACHE_VAL[] =  _T("DCache");
static TCHAR CACHE_VAL_NT351[] =  _T("CacheTrustedDomains");

#define MAX_COMMENT_LENGTH 64

#define SRV_TREE_DOMAINLEVEL 1
#define SRV_TREE_SERVERLEVEL 2

typedef struct tagServerListItem
{
    DCTCHAR ContainerName[BROWSE_MAX_ADDRESS_LENGTH];
    DCTCHAR Comment[MAX_COMMENT_LENGTH];
    DCBOOL bContainsServers;
    DCBOOL bServersExpandedOnce;
    DCBOOL bDNSDomain;
    DWORD nServerCount;
    struct tagServerListItem *ServerItems;
    HTREEITEM hTreeParentItem;
    HTREEITEM hTreeItem;
} ServerListItem;

class CBrowseServersCtl
{
public:
    //
    // Public member functions
    //
    CBrowseServersCtl(HINSTANCE hResInstance);
    ~CBrowseServersCtl();

    BOOL Init(HWND hwndDlg);
    BOOL Cleanup();

    DCINT AddRef();
    DCINT Release();

    #ifdef OS_WIN32
    void LoadLibraries(void);
    #endif //OS_WIN32
    
    ServerListItem* PopulateListBox(HWND hwndDlg, DCUINT *pDomainCount);
    ServerListItem* PopulateListBoxNT(HWND hwndDlg, DCUINT *pDomainCount);
#ifndef OS_WINCE
    ServerListItem* PopulateListBox95(HWND hwndDlg, DCUINT *pDomainCount);
#endif
    DCVOID UIDrawListBox(LPDRAWITEMSTRUCT pDIS);

    int ExpandDomain(HWND hwndDlg, TCHAR *pDomainName,
                          ServerListItem *plbi, DWORD *pdwIndex);

    DCVOID SetEventHandle(HANDLE hEvent)       {_hEvent = hEvent;}
    DCVOID SetDialogHandle(HWND hwndDialog)    {_hwndDialog = hwndDialog;}

    static DWORD WINAPI UIStaticPopListBoxThread(LPVOID lpvThreadParm);
    DWORD WINAPI UIPopListBoxThread(LPVOID lpvThreadParm);

    
    //
    // Handle tree view notifications (WM_NOTIFY) from parent
    //
    BOOL  OnNotify( HWND hwndDlg, WPARAM wParam, LPARAM lParam);
    //Handle TVN_ITEMEXPANDING
    BOOL  OnItemExpanding(HWND hwndDlg, LPNMTREEVIEW nmTv);

    BOOL  GetServer(LPTSTR szServer, int cchLen);

private:
    //
    // Private member functions
    //
    static DWORD near RGB2BGR(DWORD rgb)
    {
        return RGB(GetBValue(rgb),GetGValue(rgb),GetRValue(rgb));
    }

    

    #ifdef OS_WIN32
    PDCTCHAR UIGetTrustedDomains();
    #endif
    
    int UIExpandDNSDomain(HWND hwndDlg, TCHAR *pDomainName,
                          ServerListItem *plbi, DWORD *pdwIndex);
    
    #ifdef OS_WIN32
    #ifndef OS_WINCE
    int ExpandDomainNT(HWND hwndDlg, TCHAR *pDomainName,
                          ServerListItem *plbi, DWORD *pdwIndex);
    int ExpandDomain95(HWND hwndDlg, TCHAR *pDomainName,
                          ServerListItem *plbi, DWORD *pdwIndex);
    #else
    int ExpandDomainCE(HWND hwndDlg, TCHAR *pDomainName, ServerListItem *plbi, DWORD *pdwIndex);
    #endif
    #else
    int ExpandDomain16(HWND hwndDlg, TCHAR *pDomainName,
                          ServerListItem *plbi, DWORD *pdwIndex);
    #endif
    
    HTREEITEM AddItemToTree( HWND hwndTV, LPTSTR lpszItem,
                             HTREEITEM hParent, ServerListItem* pItem,
                             int nLevel);
    
private:
    //
    // Private member data
    //
    DCINT        _refCount;
    HINSTANCE    _hInst;
    DCBOOL       _fbrowseDNSDomain;
    DCUINT8      _browseDNSDomainName[BROWSE_MAX_DOMAIN_LENGTH];
    HWND         _hwndDialog;
    HANDLE       _hEvent;

    //
    // Function pointers for network functions.
    //
    BOOL bIsWin95;
    HINSTANCE hLibrary;
#ifndef OS_WINCE
    typedef NET_API_STATUS (NET_API_FUNCTION *LPFNNETSERVERENUM)(LPTSTR,DWORD,LPBYTE *,DWORD,LPDWORD,LPDWORD,DWORD,
                            LPTSTR,LPDWORD);
    LPFNNETSERVERENUM lpfnNetServerEnum;

    typedef NET_API_STATUS (NET_API_FUNCTION *LPFNNETAPIBUFFERFREE)(LPVOID);
    LPFNNETAPIBUFFERFREE lpfnNetApiBufferFree;

    typedef unsigned (far pascal *LPFNNETSERVERENUM2)(const char far *,short,char far *,
                                                      unsigned short,unsigned short far *,unsigned short far *,
                                                      unsigned long ,char far *);
    LPFNNETSERVERENUM2 lpfnNetServerEnum2;

    typedef unsigned (far pascal *LPFNNETWKSTAGETINFO)(const char far * pszServer,
                                                       short sLevel,char far *pbBuffer,unsigned short cbBuffer,
                                                       unsigned short far * pcbTotalAvail);

    LPFNNETWKSTAGETINFO lpfnNetWkStaGetInfo;

    typedef DWORD (far pascal *LPFNNETWKSTAGETINFO_NT)(const unsigned char far * pszServer,
                                                       DWORD dwLevel, unsigned char far ** pBuffer);
    LPFNNETWKSTAGETINFO_NT lpfnNetWkStaGetInfo_NT;

    typedef DWORD (far pascal *LPFNDSGETDCNAME)(LPCTSTR ComputerName, LPCTSTR DomainName, GUID *DomainGuid,
                                                LPCTSTR SiteName, ULONG Flags,
                                                PDOMAIN_CONTROLLER_INFO *DomainControllerInfo);
    LPFNDSGETDCNAME lpfnDsGetDcName;

    typedef NET_API_STATUS (NET_API_FUNCTION *LPFNNETENUMERATETRUSTEDDOMAINS)(LPWSTR ServerName, LPWSTR* domainNames );
    LPFNNETENUMERATETRUSTEDDOMAINS lpfnNetEnumerateTrustedDomains;
#else
    typedef DWORD (far pascal *LPFNWNETOPENENUM)(DWORD, DWORD, DWORD, LPNETRESOURCEW, LPHANDLE);
    LPFNWNETOPENENUM lpfnWNetOpenEnum;

    typedef DWORD (far pascal *LPFNWNETENUMRESOURCE)(HANDLE, LPDWORD, LPVOID, LPDWORD);
    LPFNWNETENUMRESOURCE lpfnWNetEnumResource;

    typedef DWORD (far pascal *LPFNWNETCLOSEENUM)(HANDLE);
    LPFNWNETCLOSEENUM lpfnWNetCloseEnum;
#endif

    int       _nServerImage;
    int       _nDomainImage;
    int       _nDomainSelectedImage;
    HTREEITEM _hPrev ; 
    HTREEITEM _hPrevRootItem; 
    HTREEITEM _hPrevLev2Item; 
};

#endif //_BROWSESRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\inc\msrdprc.h ===
// msrdprc.h
// Copyright Microsoft Corportation 2001
//
// mlang resource include for msrdp.ocx


//
// Set the ID base at 7000
//
#define IDD_SECURITY_POPUP              7101
#define IDI_ICON_WARN                   7103
#define IDC_CHECK_ENABLE_DRIVES         7000
#define IDC_CHECK_ENABLE_PORTS          7001
#define IDC_CHECK_ENABLE_SMARTCARDS     7002
#define IDC_STATIC                      -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\inc\ceconfig.h ===
#ifndef _H_CECONFIG
#define _H_CECONFIG


#ifndef OS_WINCE
#error The header ceconfig.h was intended for use on CE platforms only!
#endif


//CE control build no
#define CE_TSC_BUILDNO 1000


#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */


// Included in Windows CE builds only, this allows TS to determine at runtime
// what platform it's running on.

// WBT is basically a dumb terminal.  Maxall is the fullblown OS with
// all standard configurations included.  Minshell is the OS with bare
// bones UI support (including no auto-hide of the taskbar by default.)
// Rapier is a palmsized device that lacks a keyboard.

// Note: You want to run the following in your build windows on CE:
// SET BUILD_OPTIONS=~win16 ~win32 wince

typedef enum 
{
	CE_CONFIG_WBT,
	CE_CONFIG_MAXALL,
	CE_CONFIG_MINSHELL,
	CE_CONFIG_PALMSIZED   // For CE 3.0, aka Rapier.  For 2.11, wyvern.
}
CE_CONFIG;

typedef HCURSOR (WINAPI *PFN_CREATECURSOR)(
  HINSTANCE hInst,         // handle to application instance
  int xHotSpot,            // x coordinate of hot spot
  int yHotSpot,            // y coordinate of hot spot
  int nWidth,              // cursor width
  int nHeight,             // cursor height
  CONST VOID *pvANDPlane,  // AND mask array
  CONST VOID *pvXORPlane   // XOR mask array
);


extern CE_CONFIG g_CEConfig;
extern BOOL      g_CEUseScanCodes;
extern PFN_CREATECURSOR g_pCreateCursor;

#define UTREG_CE_LOCAL_PRINTERS      TEXT("WBT\\Printers\\DevConfig")
#define UTREG_CE_CACHED_PRINTERS     TEXT("Software\\Microsoft\\Terminal Server Client\\Default\\AddIns\\RDPDR\\")
#define UTREG_CE_NAME                TEXT("Name")
#define UTREG_CE_PRINTER_CACHE_DATA  TEXT("PrinterCacheData0")
#define UTREG_CE_CONFIG_KEY          TEXT("Software\\Microsoft\\Terminal Server Client")
#define UTREG_CE_CONFIG_NAME         TEXT("CEConfig")
#define UTREG_CE_USE_SCAN_CODES      TEXT("CEUseScanCodes")
#define UTREG_CE_CONFIG_TYPE_DFLT    CE_CONFIG_WBT 
#define UTREG_CE_USE_SCAN_CODES_DFLT 1

void CEUpdateCachedPrinters();
CE_CONFIG CEGetConfigType(BOOL *CEUseScanCodes);
void CEInitialize(void);
BOOL OEMGetUUID(GUID* pGuid);

extern BOOL gbFlushHKLM;

//To AutoHide taskbar on CE
void AutoHideCE(HWND hwnd, WPARAM wParam);

//The English name for the CE root dir (used instead of drive letters for drive redirection)
#define CEROOTDIR                      L"\\"
#define CEROOTDIRNAME                  L"Files:"

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif // _H_CECONFIG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\inc\drapi.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    drapi.h

Abstract:

    This module defines the rdpdr interface to the core
    rdpdr is implemented as an internal plugin

Author:

    Nadim Abdo (nadima) 23-Apr-2000

Revision History:

--*/

#ifndef __DRAPI_H__
#define __DRAPI_H__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


#ifdef OS_WIN32
BOOL DCAPI
#else //OS_WIN32
BOOL __loadds DCAPI
#endif //OS_WIN32
RDPDR_VirtualChannelEntryEx(
    IN PCHANNEL_ENTRY_POINTS_EX pEntryPoints,
    IN PVOID                    pInitHandle
    );
#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

class IRDPDR_INTERFACE_OBJ
{
public:
    virtual void OnDeviceChange(WPARAM wParam, LPARAM lParam) = 0;
}; 

//RDPDR Settings passed in from the core
typedef struct tagRDPDR_DATA
{
    BOOL fEnableRedirectedAudio;
    BOOL fEnableRedirectDrives;
    BOOL fEnableRedirectPorts;
    BOOL fEnableRedirectPrinters;
    BOOL fEnableSCardRedirection;
    IRDPDR_INTERFACE_OBJ *pUpdateDeviceObj;
    //
    // Name of the local printing doc, passed
    // in from container so that we don't need
    // a localizable string in the control.
    //
    TCHAR szLocalPrintingDocName[MAX_PATH];
    TCHAR szClipCleanTempDirString[128];
    TCHAR szClipPasteInfoString[128];
} RDPDR_DATA, *PRDPDR_DATA;

#endif // __DRAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\inc\clicense.h ===
/**INC+**********************************************************************/
/* Header:    CLicense.h                                                    */
/*                                                                          */
/* Purpose:   Client License Manager functions                              */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log$
**/
/**INC-**********************************************************************/
#ifndef _CLICENSE_H
#define _CLICENSE_H
/****************************************************************************/
/* Define the calling convention                                            */
/****************************************************************************/
#define CALL_TYPE _stdcall


/**PROC+*********************************************************************/
/* Name:      CLicenseInit                                                  */
/*                                                                          */
/* Purpose:   Initialize ClientLicense Manager                              */
/*                                                                          */
/* Returns:   Handle to be passed to subsequent License Manager functions   */
/*                                                                          */
/* Params:    None                                                          */
/*                                                                          */
/* Operation: LicenseInit is called during Client initialization.  Its      */
/*            purpose is to allow one-time initialization.  It returns a    */
/*            handle which is subsequently passed to all License Manager    */
/*            functions.  A typical use for this handle is as a pointer to  */
/*            memory containing per-instance data.                          */
/*                                                                          */
/**PROC-*********************************************************************/

int CALL_TYPE CLicenseInit(
						   HANDLE FAR * phContext
						   );


/**PROC+*********************************************************************/
/* Name:      CLicenseData                                                  */
/*                                                                          */
/* Purpose:   Handle license data received from the Server                  */
/*                                                                          */
/* Returns:   LICENSE_OK       - License negotiation is complete            */
/*            LICENSE_CONTINUE - License negotiation will continue          */
/*                                                                          */
/* Params:    pHandle   - handle returned by LicenseInit                    */
/*            pData     - data received from Server                         */
/*            dataLen   - length of data received                           */
/*                                                                          */
/* Operation: This function is passed all license packets received from the */
/*            Server.  It should parse the packet and respond (by calling   */
/*            suitable SL functions - see aslapi.h) as required.            */
/*                                                                          */
/*            If license negotiation is complete, this function must return */
/*            LICENSE_OK                                                    */
/*            If license negotiation is not yet complete, return            */
/*            LICENSE_CONTINUE                                              */
/*                                                                          */
/*            Incoming packets from the Client will continue to be          */
/*            interpreted as license packets until this function returns    */
/*            LICENSE_OK.                                                   */
/*                                                                          */
/**PROC-*********************************************************************/
int CALL_TYPE CLicenseData(
						   HANDLE hContext,
						   LPVOID pData, 
						   DWORD dataLen
						   );

#define LICENSE_OK          0
#define LICENSE_CONTINUE    2
#define LICENSE_ERROR		4

/**PROC+*********************************************************************/
/* Name:      CLicenseTerm                                                  */
/*                                                                          */
/* Purpose:   Terminate Client License Manager                              */
/*                                                                          */
/* Returns:   None                                                          */
/*                                                                          */
/* Params:    pHandle - handle returned from LicenseInit                    */
/*                                                                          */
/* Operation: This function is provided to do one-time termination of the   */
/*            License Manager.  For example, if pHandle points to per-      */
/*            instance memory, this would be a good place to free it.       */
/*                                                                          */
/**PROC-*********************************************************************/
int CALL_TYPE CLicenseTerm(
						   HANDLE hContext
						   );

#endif /* _CLICENSE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\inc\ndcgver.h ===
/**INC+**********************************************************************/
/* ndcgver.h                                                                */
/*                                                                          */
/* DC-Groupware global version header                                       */
/*                                                                          */
/* Copyright(c) Microsoft 1996-1997                                         */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
// $Log:   Y:/logs/h/dcl/NDCGVER.H_v  $
// 
//    Rev 1.2   23 Jul 1997 10:48:02   mr
// SFR1079: Merged \server\h duplicates to \h\dcl
//
//    Rev 1.1   19 Jun 1997 21:56:20   OBK
// SFR0000: Start of RNS codebase
/*                                                                          */
/**INC-**********************************************************************/

#ifdef RC_INVOKED

#include <version.h>

/****************************************************************************/
/* The following defines are fixed for DC-Groupware.                        */
/****************************************************************************/
#ifndef OS_WINCE

#define DCS_PRODUCTNAME_STR      VER_PRODUCTNAME_STR
#define DCS_COMPANYNAME_STR      VER_COMPANYNAME_STR
#define DCS_LEGALTRADEMARKS_STR  VER_LEGALTRADEMARKS_STR
#define DCS_LEGALCOPYRIGHT_STR   VER_COPYRIGHT_STR
#define DCS_EXEFILETYPE          VFT_APP
#define DCS_DLLFILETYPE          VFT_DLL
#define DCS_FILESUBTYPE          0
#define DCS_FILEFLAGSMASK        VS_FFI_FILEFLAGSMASK
#define DCS_FILEOS               VOS_NT_WINDOWS32
#define DCS_FILEFLAGS            0L

#else // OS_WINCE
#define DCS_PRODUCTNAME_STR      VER_PRODUCTNAME_STR
#define DCS_COMPANYNAME_STR      VER_COMPANYNAME_STR
#define DCS_LEGALTRADEMARKS_STR  VER_LEGALTRADEMARKS_STR
#define DCS_LEGALCOPYRIGHT_STR   VER_COPYRIGHT_STR
#define DCS_EXEFILETYPE          0
#define DCS_DLLFILETYPE          0
#define DCS_FILESUBTYPE          0
#define DCS_FILEFLAGSMASK        0
#define DCS_FILEOS               0
#define DCS_FILEFLAGS            0L

#endif // OS_WINCE

/****************************************************************************/
/* For DC-Groupware NT                                                      */
/*                                                                          */
/* The following section defines the version strings used throughout the    */
/* product.  For convenience four different version strings are defined and */
/* used throughout the product.  Each of these has a similar format (except */
/* for DCS_CAPTION_STR) of four numbers separated by periods.               */
/*                                                                          */
/* - the first 2 numbers are 4.0 which is the Win NT version targetted      */
/* - the third number is DCL build number - which is actually the date      */
/* - the fourth number is the Microsoft build number                        */
/*                                                                          */
/* Of these the build number is automatically updated overnight by the      */
/* translation program and is based on a combination of the date and the    */
/* month. Thus for a build on the 1st of March 1996 the build number is     */
/* 0301. Note that the year is ignored.                                     */
/****************************************************************************/
#ifndef DCS_VERSION
#define DCS_VERSION 4,0,~DCS_DATE_FMT_MMDD,VERSIONBUILD
#endif

#ifndef DCS_VERSION_STR
#define DCS_VERSION_STR  "4.0.~DCS_DATE_FMT_MMDD." VERSIONBUILD_STR
#endif

#ifndef DCS_PRODUCTVERSION_STR
#define DCS_PRODUCTVERSION_STR  VER_PRODUCTRELEASE_STR
#endif

#ifndef DCS_CAPTION_STR
#define DCS_CAPTION_STR  "~RNS - build ~DCS_DATE_FMT_MMDD"
#endif

#ifdef DCS_VERNUM
#undef  DCS_VERSION
#define DCS_VERSION              DCS_VERNUM
#endif

#endif /* RC_INVOKED */

/****************************************************************************/
/* DCS_BUILD_STR is a string containing the same information as             */
/* DCS_VERSION.  It is excluded from the RC section to allow NDCGVER.H to   */
/* be included from C files.                                                */
/****************************************************************************/
#define DCS_BUILD_STR "4.0.~DCS_DATE_FMT_MMDD."VERSIONBUILD_STR

#define DCS_BUILD_NUMBER    ~DCS_DATE_FMT_MMDD


/****************************************************************************/
/* This allows the ring 3 code and ring 0 code to check each other, make    */
/* sure they are the same version.  We're changing setup and getting close  */
/* to shipping version 2.0, we want to prevent weird faults and blue        */
/* screens caused by mismatched components.  This is not something we will  */
/* do forever.  When NT 5 is here, we'll dyna load and init our driver at   */
/* startup and terminate it at shutdown.  But for now, since installing     */
/* one of these beasts is messsy, an extra sanity check is a good thing.    */
/****************************************************************************/
#define DCS_PRODUCT_NUMBER  2               /* Version 2.0 of NM */
#define DCS_MAKE_VERSION()  MAKELONG(VERSIONBUILD, DCS_PRODUCT_NUMBER)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\inc\ndcgdata.h ===
/**INC+**********************************************************************/
/* ndcgdata.h                                                               */
/*                                                                          */
/* Common include file for all data.c modules (Windows NT specific)         */
/*                                                                          */
/* Copyright(c) Microsoft 1996-1997.                                        */
/*                                                                          */
/* The macros in this file allow all aspects of data declaration to be kept */
/* together.  The behaviour of this file is controlled by #defines that can */
/* be set prior to inclusion of this.                                       */
/*                                                                          */
/* - DC_INIT_DATA     Set in XX_Init routines to do inline initialisation if*/
/*                    required.                                             */
/* - DC_INCLUDE_DATA  Set where a header file is included in order to get   */
/*                    external declarations.                                */
/* - DC_DEFINE_DATA   Set where a header file is included in order to get   */
/*                    definition without initialisation.                    */
/* - DC_CONSTANT_DATA Set to get global initialisation of const data items  */
/* - (default)        Gets data definition with initialisation.             */
/*                                                                          */
/****************************************************************************/
/*                                                                          */
/* In order to allow for the flexibility required in different environments */
/* (be that different OSs, C vs C++, or whatever) the structure of the file */
/* is as follows.                                                           */
/*                                                                          */
/* First there is an environment-specific mapping from the macros used in   */
/* the code to internal macros.  This mapping also takes the above #defines */
/* into consideration in performing this expansion.                         */
/*                                                                          */
/* Secondly, the low-level macros that actually perform the expansion are   */
/* defined.  These should be platform-independent.                          */
/*                                                                          */
/* The intention of this structure is to avoid the confusions caused by the */
/* old version where, for example, code compiled with DC_INIT_DATA          */
/* explicitly did NOT initialise the data.                                  */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
// $Log:   Y:/logs/h/dcl/ndcgdata.h_v  $
// 
//    Rev 1.4   14 Aug 1997 15:28:32   TH
// SFR1133: Added STRUCT25
//
//    Rev 1.3   29 Jul 1997 14:43:26   AK
// SFR1033: Add DC_STRUCT30
//
//    Rev 1.2   23 Jul 1997 10:48:00   mr
// SFR1079: Merged \server\h duplicates to \h\dcl
//
//    Rev 1.1   19 Jun 1997 21:53:00   OBK
// SFR0000: Start of RNS codebase
/*                                                                          */
/**INC-**********************************************************************/

/****************************************************************************/
/* Clear any previous definitions of the macros.                            */
/****************************************************************************/
#undef DC_DATA
#undef DC_DATA_NULL
#undef DC_DATA_ARRAY
#undef DC_DATA_ARRAY_NULL
#undef DC_DATA_ARRAY_UNINIT
#undef DC_DATA_ARRAY_SET
#undef DC_DATA_2D_ARRAY
#undef DC_CONST_DATA
#undef DC_CONST_DATA_ARRAY
#undef DC_CONST_DATA_2D_ARRAY
#undef DCI_DATA
#undef DCI_DATA_NULL
#undef DCI_DATA_ARRAY
#undef DCI_DATA_ARRAY_NULL
#undef DCI_DATA_ARRAY_UNINIT
#undef DCI_DATA_ARRAY_SET
#undef DCI_DATA_2D_ARRAY
#undef DCI_CONST_DATA
#undef DCI_CONST_DATA_ARRAY
#undef DCI_CONST_DATA_2D_ARRAY

/****************************************************************************/
/* Now define the main (external) macros.                                   */
/****************************************************************************/
#define DC_DATA(A,B,C)                    DCI_DATA(A,B,C)
#define DC_DATA_NULL(A,B,C)               DCI_DATA_NULL(A,B,C)

#define DC_DATA_ARRAY(A,B,C,D)            DCI_DATA_ARRAY(A,B,C,D)
#define DC_DATA_ARRAY_NULL(A,B,C,D)       DCI_DATA_ARRAY_NULL(A,B,C,D)
#define DC_DATA_ARRAY_UNINIT(A,B,C)       DCI_DATA_ARRAY_UNINIT(A,B,C)
#define DC_DATA_ARRAY_SET(A,B,C,D)        DCI_DATA_ARRAY_SET(A,B,C,D)
#define DC_DATA_2D_ARRAY(A,B,C,D,E)       DCI_DATA_2D_ARRAY(A,B,C,D,E)

#define DC_CONST_DATA(A,B,C)              DCI_CONST_DATA(A,B,C)
#define DC_CONST_DATA_ARRAY(A,B,C,D)      DCI_CONST_DATA_ARRAY(A,B,C,D)
#define DC_CONST_DATA_2D_ARRAY(A,B,C,D,E) DCI_CONST_DATA_2D_ARRAY(A,B,C,D,E)

/****************************************************************************/
/****************************************************************************/
/* Now map to the target macros                                             */
/****************************************************************************/
/****************************************************************************/

#if defined(DC_INCLUDE_DATA)
/****************************************************************************/
/* External declarations                                                    */
/****************************************************************************/
#define DCI_DATA(TYPE, Name, VAL)                                        \
                      DCI_EXTERN_DATA(TYPE, Name, VAL)
#define DCI_DATA_NULL(TYPE, Name, VAL)                                   \
                      DCI_EXTERN_DATA_NULL(TYPE, Name, VAL)
#define DCI_DATA_ARRAY(TYPE, Name, Size, VAL)                            \
                      DCI_EXTERN_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_ARRAY_NULL(TYPE, Name, Size, VAL)                       \
                      DCI_EXTERN_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_ARRAY_UNINIT(TYPE, Name, Size)                          \
                      DCI_EXTERN_DATA_ARRAY(TYPE, Name, Size, 0)
#define DCI_DATA_ARRAY_SET(TYPE, Name, Size, VAL)                        \
                      DCI_EXTERN_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)                 \
                      DCI_EXTERN_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)
#define DCI_CONST_DATA(TYPE, Name, VAL)                                  \
                      DCI_EXTERN_CONST_DATA(TYPE, Name, VAL)
#define DCI_CONST_DATA_ARRAY(TYPE, Name, Size, VAL)                      \
                      DCI_EXTERN_CONST_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)           \
                 DCI_EXTERN_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)

#elif defined(DC_INIT_DATA)

/****************************************************************************/
/* Inline initialisation                                                    */
/****************************************************************************/
#if defined(VER_CPP) && defined(DC_IN_CLASS)
#define DCI_DATA(TYPE, Name, VAL)                                        \
                      DCI_ASSIGN_DATA(TYPE, Name, VAL)
#define DCI_DATA_NULL(TYPE, Name, VAL)                                   \
                      DCI_SET_DATA_NULL(TYPE, Name, VAL)
#define DCI_DATA_ARRAY(TYPE, Name, Size, VAL)                            \
                      DCI_ASSIGN_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_ARRAY_NULL(TYPE, Name, Size, VAL)                       \
                      DCI_SET_DATA_ARRAY_NULL(TYPE, Name, Size, VAL)
#define DCI_DATA_ARRAY_UNINIT(TYPE, Name, Size)                          \
                      DCI_SET_DATA_ARRAY_NULL(TYPE, Name, Size, 0)
#define DCI_DATA_ARRAY_SET(TYPE, Name, Size, VAL)                        \
                      DCI_SET_DATA_ARRAY_VAL(TYPE, Name, Size, VAL)
#define DCI_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)                 \
                      DCI_ASSIGN_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)
#define DCI_CONST_DATA(TYPE, Name, VAL)                                  \
                      DCI_NO_DATA(TYPE, Name, VAL)
#define DCI_CONST_DATA_ARRAY(TYPE, Name, Size, VAL)                      \
                      DCI_NO_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)           \
                      DCI_NO_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)
#else
#define DCI_DATA(TYPE, Name, VAL)                                        \
                      DCI_NO_DATA(TYPE, Name, VAL)
#define DCI_DATA_NULL(TYPE, Name, VAL)                                   \
                      DCI_NO_DATA_NULL(TYPE, Name, VAL)
#define DCI_DATA_ARRAY(TYPE, Name, Size, VAL)                            \
                      DCI_NO_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_ARRAY_NULL(TYPE, Name, Size, VAL)                       \
                      DCI_NO_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_ARRAY_UNINIT(TYPE, Name, Size)                          \
                      DCI_NO_DATA_ARRAY(TYPE, Name, Size, 0)
#define DCI_DATA_ARRAY_SET(TYPE, Name, Size, VAL)                        \
                      DCI_NO_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)                 \
                      DCI_NO_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)
#define DCI_CONST_DATA(TYPE, Name, VAL)                                  \
                      DCI_NO_DATA(TYPE, Name, VAL)
#define DCI_CONST_DATA_ARRAY(TYPE, Name, Size, VAL)                      \
                      DCI_NO_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)           \
                      DCI_NO_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)

#endif

#elif defined(DC_DEFINE_DATA)

/****************************************************************************/
/* Definition but no initialisation                                         */
/****************************************************************************/
#define DCI_DATA(TYPE, Name, VAL)                                        \
                      DCI_DEFINE_DATA(TYPE, Name, VAL)
#define DCI_DATA_NULL(TYPE, Name, VAL)                                   \
                      DCI_DEFINE_DATA_NULL(TYPE, Name, VAL)
#define DCI_DATA_ARRAY(TYPE, Name, Size, VAL)                            \
                      DCI_DEFINE_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_ARRAY_NULL(TYPE, Name, Size, VAL)                       \
                      DCI_DEFINE_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_ARRAY_UNINIT(TYPE, Name, Size)                          \
                      DCI_DEFINE_DATA_ARRAY(TYPE, Name, Size, NULL)
#define DCI_DATA_ARRAY_SET(TYPE, Name, Size, VAL)                        \
                      DCI_DEFINE_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)                 \
                      DCI_DEFINE_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)
#define DCI_CONST_DATA(TYPE, Name, VAL)                                  \
                      DCI_DEFINE_CONST_DATA(TYPE, Name, VAL)
#define DCI_CONST_DATA_ARRAY(TYPE, Name, Size, VAL)                      \
                      DCI_DEFINE_CONST_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)           \
                DCI_DEFINE_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)

#elif defined(DC_CONSTANT_DATA)

/****************************************************************************/
/* Definition but no initialisation                                         */
/****************************************************************************/
#define DCI_DATA(TYPE, Name, VAL)                                        \
                      DCI_NO_DATA(TYPE, Name, VAL)
#define DCI_DATA_NULL(TYPE, Name, VAL)                                   \
                      DCI_NO_DATA_NULL(TYPE, Name, VAL)
#define DCI_DATA_ARRAY(TYPE, Name, Size, VAL)                            \
                      DCI_NO_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_ARRAY_NULL(TYPE, Name, Size, VAL)                       \
                      DCI_NO_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_ARRAY_UNINIT(TYPE, Name, Size)                          \
                      DCI_NO_DATA_ARRAY(TYPE, Name, Size, NULL)
#define DCI_DATA_ARRAY_SET(TYPE, Name, Size, VAL)                        \
                      DCI_NO_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)                 \
                      DCI_NO_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)
#define DCI_CONST_DATA(TYPE, Name, VAL)                                  \
                      DCI_INIT_CONST_DATA(TYPE, Name, VAL)
#define DCI_CONST_DATA_ARRAY(TYPE, Name, Size, VAL)                      \
                      DCI_INIT_CONST_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)           \
                  DCI_INIT_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)

#else
/****************************************************************************/
/* Data definition and initialisation                                       */
/****************************************************************************/
#define DCI_DATA(TYPE, Name, VAL)                                        \
                      DCI_INIT_DATA(TYPE, Name, VAL)
#define DCI_DATA_NULL(TYPE, Name, VAL)                                   \
                      DCI_INIT_DATA_NULL(TYPE, Name, VAL)
#define DCI_DATA_ARRAY(TYPE, Name, Size, VAL)                            \
                      DCI_INIT_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_ARRAY_NULL(TYPE, Name, Size, VAL)                       \
                      DCI_INIT_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_ARRAY_UNINIT(TYPE, Name, Size)                          \
                      DCI_DEFINE_DATA_ARRAY(TYPE, Name, Size, NULL)
#define DCI_DATA_ARRAY_SET(TYPE, Name, Size, VAL)                        \
                      DCI_INIT_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)                 \
                      DCI_INIT_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)
#define DCI_CONST_DATA(TYPE, Name, VAL)                                  \
                      DCI_INIT_CONST_DATA(TYPE, Name, VAL)
#define DCI_CONST_DATA_ARRAY(TYPE, Name, Size, VAL)                      \
                      DCI_INIT_CONST_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)           \
                  DCI_INIT_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)

#endif

/****************************************************************************/
/****************************************************************************/
/* Finally, the low-level macros required to do the real work.              */
/*                                                                          */
/* Avoid multiple inclusion of these.                                       */
/****************************************************************************/
/****************************************************************************/

#ifndef _H_NDCGDATA
#define _H_NDCGDATA

/****************************************************************************/
/* Some utilities...                                                        */
/****************************************************************************/
#define DC_STRUCT1(a)                                              {a}
#define DC_STRUCT2(a,b)                                          {a,b}
#define DC_STRUCT3(a,b,c)                                      {a,b,c}
#define DC_STRUCT4(a,b,c,d)                                  {a,b,c,d}
#define DC_STRUCT5(a,b,c,d,e)                              {a,b,c,d,e}
#define DC_STRUCT6(a,b,c,d,e,f)                          {a,b,c,d,e,f}
#define DC_STRUCT7(a,b,c,d,e,f,g)                      {a,b,c,d,e,f,g}
#define DC_STRUCT8(a,b,c,d,e,f,g,h)                  {a,b,c,d,e,f,g,h}
#define DC_STRUCT9(a,b,c,d,e,f,g,h,i)              {a,b,c,d,e,f,g,h,i}
#define DC_STRUCT10(a,b,c,d,e,f,g,h,i,j)         {a,b,c,d,e,f,g,h,i,j}
#define DC_STRUCT11(a,b,c,d,e,f,g,h,i,j,k)     {a,b,c,d,e,f,g,h,i,j,k}
#define DC_STRUCT12(a,b,c,d,e,f,g,h,i,j,k,l) {a,b,c,d,e,f,g,h,i,j,k,l}
#define DC_STRUCT13(a,b,c,d,e,f,g,h,i,j,k,l,m)                       \
                                           {a,b,c,d,e,f,g,h,i,j,k,l,m}
#define DC_STRUCT14(a,b,c,d,e,f,g,h,i,j,k,l,m,n)                     \
                                         {a,b,c,d,e,f,g,h,i,j,k,l,m,n}
#define DC_STRUCT15(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o)                   \
                                       {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o}
#define DC_STRUCT16(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p)                 \
                                     {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p}
#define DC_STRUCT17(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q)               \
                                   {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q}
#define DC_STRUCT18(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r)             \
                                 {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r}
#define DC_STRUCT19(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s)           \
                               {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s}
#define DC_STRUCT20(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t)         \
                             {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t}
#define DC_STRUCT21(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u)       \
                           {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u}
#define DC_STRUCT22(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v)     \
                           {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v}
#define DC_STRUCT23(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w)   \
                           {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w}
#define DC_STRUCT24(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x) \
                           {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x}
#define DC_STRUCT25(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y) \
                           {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y}
#define DC_STRUCT27(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,aa) \
                      {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,aa}
#define DC_STRUCT30(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z, \
                              aa,bb,cc,dd) \
                      {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z, \
                              aa,bb,cc,dd}
#define DC_STRUCT31(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z, \
                              aa,bb,cc,dd,ee) \
                      {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z, \
                              aa,bb,cc,dd,ee}
#define DC_STRUCT32(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z, \
                              aa,bb,cc,dd,ee,ff)                         \
                      {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z, \
                              aa,bb,cc,dd,ee,ff}
#define DC_STRUCT35(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,aa, \
                              bb,cc,dd,ee,ff,gg,hh,ii)                   \
                      {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z, \
                              aa,bb,cc,dd,ee,ff,gg,hh,ii}
#define DC_STRUCT46(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,aa, \
                  bb,cc,dd,ee,ff,gg,hh,ii,jj,kk,ll,mm,nn,oo,PP,QQ,RR,SS,TT) \
                      {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z, \
                 aa,bb,cc,dd,ee,ff,gg,hh,ii,jj,kk,ll,mm,nn,oo,PP,QQ,RR,SS,TT}
#define DC_STRUCT64(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,aa, \
                              bb,cc,dd,ee,ff,gg,hh,ii,jj,kk,ll,mm,nn,oo,    \
                              pp,qq,rr,ss,tt,uu,vv,ww,xx,yy,zz,ab,ac,ad,ae, \
                              af,ag,ah,ai,aj,ak,al,am)                      \
                      {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z, \
                              aa,bb,cc,dd,ee,ff,gg,hh,ii,jj,kk,ll,mm,nn,oo, \
                              pp,qq,rr,ss,tt,uu,vv,ww,xx,yy,zz,ab,ac,ad,ae, \
                              af,ag,ah,ai,aj,ak,al,am}

/****************************************************************************/
/* The extern declarations macros...                                        */
/****************************************************************************/
#define DCI_EXTERN_DATA(TYPE, Name, VAL)              extern TYPE Name
#define DCI_EXTERN_DATA_NULL(TYPE, Name, VAL)         extern TYPE Name
#define DCI_EXTERN_DATA_ARRAY(TYPE, Name, Size, VAL)  extern TYPE Name[Size]
#define DCI_EXTERN_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)             \
                                                extern TYPE Name[Size1][Size2]
#define DCI_EXTERN_CONST_DATA_ARRAY(TYPE, Name, Size, VAL)                  \
                                                extern const TYPE Name[Size]
#define DCI_EXTERN_CONST_DATA(TYPE, Name, VAL)  extern const TYPE Name
#define DCI_EXTERN_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)       \
                                         extern const TYPE Name[Size1][Size2]

/****************************************************************************/
/* The no-op macros...                                                      */
/****************************************************************************/
#define DCI_NO_DATA(TYPE, Name, VAL)
#define DCI_NO_DATA_NULL(TYPE, Name, VAL)
#define DCI_NO_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_NO_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)

/****************************************************************************/
/* The declaration macros...                                                */
/****************************************************************************/
#define DCI_DEFINE_DATA(TYPE, Name, VAL)              TYPE Name
#define DCI_DEFINE_DATA_NULL(TYPE, Name, VAL)         TYPE Name
#define DCI_DEFINE_DATA_ARRAY(TYPE, Name, Size, VAL)  TYPE Name[Size]
#define DCI_DEFINE_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)            \
                                                       TYPE Name[Size1][Size2]
#define DCI_DEFINE_CONST_DATA(TYPE, Name, VAL)        static const TYPE Name
#define DCI_DEFINE_CONST_DATA_ARRAY(TYPE, Name, Size, VAL)      \
                                                  static const TYPE Name[Size]
#define DCI_DEFINE_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)      \
                                          static const TYPE Name[Size1][Size2]

/****************************************************************************/
/* The define-and-assign macros...                                          */
/****************************************************************************/
#define DCI_INIT_DATA(TYPE, Name, VAL)              TYPE  Name = VAL
#define DCI_INIT_DATA_NULL(TYPE, Name, VAL)         TYPE  Name = VAL
#define DCI_INIT_DATA_ARRAY(TYPE, Name, Size, VAL)  TYPE  Name[Size] = { VAL }
#define DCI_INIT_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL) \
                                            TYPE  Name[Size1][Size2] = { VAL }

#if defined(VER_CPP) && !defined(DC_IN_CLASS)
/****************************************************************************/
/* The version for App Serving files outside of the class.                  */
/****************************************************************************/
#define DCI_INIT_CONST_DATA(TYPE, Name, VAL)  \
                                       extern const TYPE SHCLASS Name = VAL
#define DCI_INIT_CONST_DATA_ARRAY(TYPE, Name, Size, VAL) \
                                 extern const TYPE SHCLASS Name[Size] = VAL
#define DCI_INIT_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL) \
                         extern const TYPE SHCLASS Name[Size1][Size2] = VAL

#else /* ! VER_CPP     */
/****************************************************************************/
/* The vanilla C version                                                    */
/****************************************************************************/
#define DCI_INIT_CONST_DATA(TYPE, Name, VAL)  const TYPE SHCLASS Name = VAL
#define DCI_INIT_CONST_DATA_ARRAY(TYPE, Name, Size, VAL) \
                                        const TYPE SHCLASS Name[Size] = VAL
#define DCI_INIT_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL) \
                                const TYPE SHCLASS Name[Size1][Size2] = VAL

#endif /* VER_CPP     */

/****************************************************************************/
/* The procedural code initialisation macros...                             */
/****************************************************************************/
#define DCI_ASSIGN_DATA(TYPE, Name, VAL)     Name = VAL
#define DCI_ASSIGN_DATA_NULL(TYPE, Name, VAL)                   Error!
#define DCI_ASSIGN_DATA_ARRAY_NULL(TYPE, Name, Size, VAL)       Error!
#define DCI_ASSIGN_DATA_ARRAY(TYPE, Name, Size, VAL)            Error!
#define DCI_ASSIGN_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL) Error!

/****************************************************************************/
/* The mem-cpy and -set initialisation macros...                            */
/****************************************************************************/
#define DCI_SET_DATA_NULL(TYPE, Name, VAL)  DC_MEMSET(&Name, 0, sizeof(TYPE))
#define DCI_SET_DATA_ARRAY_NULL(TYPE, Name, Size, VAL)       \
                                     DC_MEMSET(&Name, 0, Size*sizeof(TYPE))
#define DCI_SET_DATA_ARRAY_VAL(TYPE, Name, Size, VAL)        \
                                     DC_MEMSET(&Name, VAL, Size*sizeof(TYPE))

#endif /*H_NDCGDATA*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\inc\uttime.h ===
/*++

    Copyright(C) Microsoft Corporation 1997 - 1999

File:

    uttime.h

Abstract:

    Timer management utility API

History:

    02/22/99    FredCh      Created

--*/

#ifndef _UT_TIMER_H_
#define _UT_TIMER_H_

#ifdef __cplusplus
extern "C"
{
#endif

HANDLE
UTCreateTimer(
    HWND        hWnd,             // handle of window for timer messages
    DCUINT      nIDEvent,         // timer identifier
    DCUINT      uElapse );        // time-out value


DCBOOL
UTStartTimer(
    HANDLE      hTimer );


DCBOOL
UTStopTimer(
    HANDLE      hTimer );


DCBOOL
UTDeleteTimer(
    HANDLE      hTimer );



#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\inc\reglic.h ===
/**INC+**********************************************************************/
/* Header: reglic.h                                                         */
/*                                                                          */
/* Creates and installs Licensing regkey + ACLs..(During register server)   */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1998-2000                             */
/*                                                                          */
/****************************************************************************/

#ifndef _REGLIC_H_
#define _REGLIC_H_

#ifndef OS_WINCE

#include <aclapi.h>
#include <seopaque.h>

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

BOOL    SetupMSLicensingKey();
BOOL    CreateRegAddAcl(VOID);
BOOL    CreateAndWriteHWID(VOID);

BOOL
AddUsersGroupToObjectsSecurityDescriptor(
    HANDLE hObject,
    SE_OBJECT_TYPE ObjectType,
    ACCESS_MASK AccessMask,
    ACCESS_MODE AccessMode,
    DWORD Inheritance,
    BOOL fKeepExistingAcl
    );

BOOL
AddTSUsersGroupToObjectsSecurityDescriptor(
    HANDLE hObject,
    SE_OBJECT_TYPE ObjectType,
    ACCESS_MASK AccessMask,
    ACCESS_MODE AccessMode,
    DWORD Inheritance,
    BOOL fKeepExistingAcl
    );

BOOL
DeleteAceFromObjectsSecurityDescriptor(
    HANDLE hObject,
    SE_OBJECT_TYPE ObjectType,
    PSID pSid,
    DWORD dwAccess,
    ACCESS_MODE AccessMode,
    DWORD dwInheritance
    );

BOOL
DeleteUsersGroupAceFromObjectsSecurityDescriptor(
    HANDLE hObject,
    SE_OBJECT_TYPE ObjectType,
    ACCESS_MASK AccessMask,
    ACCESS_MODE AccessMode,
    DWORD Inheritance
    );

#define MSLICENSING_REG_KEY             _T("SOFTWARE\\Microsoft\\MSLicensing")
#define MSLICENSING_STORE_SUBKEY        _T("Store")
#define MSLICENSING_HWID_KEY            _T("SOFTWARE\\Microsoft\\MSLicensing\\HardwareID")
#define MSLICENSING_HWID_VALUE          _T("ClientHWID")

#define ADVAPI_32_DLL _T("advapi32.dll")
#define GET_SECURITY_INFO "GetSecurityInfo"

#define GET_ACL_INFORMATION "GetAclInformation"

#define ADD_ACE "AddAce"
#define GET_ACE "GetAce"
#define DELETE_ACE "DeleteAce"
#define GET_LENGTH_SID "GetLengthSid"
#define COPY_SID "CopySid"
#define FREE_SID "FreeSid"
#define EQUAL_SID "EqualSid"
#define IS_VALID_SID "IsValidSid"

#define SET_SECURITY_INFO "SetSecurityInfo"
#define ALLOCATE_AND_INITITIALIZE_SID "AllocateAndInitializeSid"

typedef BOOL (*PALLOCATEANDINITIALIZESID_FN)(PSID_IDENTIFIER_AUTHORITY,BYTE,
                                                DWORD,DWORD,DWORD,DWORD,
                                                DWORD,DWORD,DWORD,DWORD,
                                                PSID*);

typedef DWORD (*PGETSECURITYINFO_FN)(HANDLE, SE_OBJECT_TYPE, SECURITY_INFORMATION,
                                     PSID*,PSID*,PACL*,PACL*,PSECURITY_DESCRIPTOR*);

typedef BOOL (*PGETACLINFORMATION_FN)(PACL, LPVOID, DWORD, ACL_INFORMATION_CLASS);

typedef BOOL (*PADDACE_FN)(PACL, DWORD, DWORD, LPVOID, DWORD);

typedef BOOL (*PGETACE_FN)(PACL, DWORD, LPVOID *);

typedef BOOL (*PDELETEACE_FN)(PACL, DWORD);

typedef DWORD (*PGETLENGTHSID_FN)(PSID);

typedef BOOL (*PCOPYSID_FN)(DWORD, PSID, PSID);

typedef BOOL (*PEQUALSID_FN)(PSID, PSID);

typedef DWORD (*PSETSECURITYINFO_FN)(HANDLE, SE_OBJECT_TYPE, SECURITY_INFORMATION,
                                     PSID, PSID, PACL, PACL);
typedef DWORD (*PISVALIDSID_FN)(PSID);

typedef PVOID (*PFREESID_FN)(PSID);

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif //OS_WINCE
#endif //_REGLIC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\inc\nutint.h ===
/**INC+**********************************************************************/
/* Header:    nutint.h                                                      */
/*                                                                          */
/* Purpose:   Utilities internal defintions - Windows NT specific           */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 *  $Log:   Y:/logs/client/nutint.h_v  $
 *
 *    Rev 1.8   22 Sep 1997 14:47:04   KH
 * SFR1368: Keep the Win16 INI file in Windows, not Ducati, directory
 *
 *    Rev 1.7   22 Aug 1997 10:22:34   SJ
 * SFR1316: Trace options in wrong place in the registry.
 *
 *    Rev 1.6   01 Aug 1997 17:33:02   KH
 * SFR1137: Dynamically allocate the bitmap cache
 *
 *    Rev 1.5   09 Jul 1997 17:35:08   AK
 * SFR1016: Initial changes to support Unicode
 *
 *    Rev 1.4   04 Jul 1997 10:59:02   AK
 * SFR0000: Initial development completed
 *
 *    Rev 1.3   04 Jul 1997 10:50:42   KH
 * SFR1022: Fix 16-bit compiler warnings
 *
 *    Rev 1.1   25 Jun 1997 13:35:54   KH
 * Win16Port: 32-bit utilities header
**/
/**INC-**********************************************************************/
#ifndef _H_NUTINT
#define _H_NUTINT

/****************************************************************************/
/*                                                                          */
/* FUNCTION PROTOTYPES                                                      */
/*                                                                          */
/****************************************************************************/

DCVOID DCINTERNAL UTGetCurrentDate(PDC_DATE pDate);

DCBOOL DCINTERNAL UTStartThread(UTTHREAD_PROC   entryFunction,
                                PUT_THREAD_DATA pThreadID,
                                PDCVOID         threadParam);


//
// static member needs access so make threadentry public
//
static DCUINT WINAPI UTStaticThreadEntry(UT_THREAD_INFO * pInfo);


DCBOOL DCINTERNAL UTStopThread(UT_THREAD_DATA threadID, BOOL fPumpMessages);

/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* Timeout in milliseconds when waiting for thread to terminate.            */
/****************************************************************************/
#define UT_THREAD_TIMEOUT     (30*60000)  //thirty minutes

/****************************************************************************/
/*                                                                          */
/* MACROS                                                                   */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/*                                                                          */
/* INLINE FUNCTIONS                                                         */
/*                                                                          */
/****************************************************************************/

#if !defined(OS_WINCE)
__inline DCVOID DCINTERNAL UtMakeSubKey(PDCTCHAR pBuffer,
                                        UINT cchBuffer,
                                        PDCTCHAR pSubkey)
{
    DWORD i;
    HRESULT hr;

    hr = StringCchPrintf(pBuffer,
                         cchBuffer,
                         DUCATI_REG_PREFIX_FMT,
                         pSubkey);

    i = DC_TSTRLEN(pBuffer);
    if (i > 0 && pBuffer[i-1] == _T('\\')) {
        pBuffer[i-1] = _T('\0');
    }
}
#endif // !defined(OS_WINCE)


/**PROC+*********************************************************************/
/* Name:      UTMalloc                                                      */
/*                                                                          */
/* Purpose:   Attempts to dynamically allocate memory of a given size.      */
/*                                                                          */
/* Returns:   pointer to allocated memory, or NULL if the function fails.   */
/*                                                                          */
/* Params:    length - length in bytes of the memory to allocate.           */
/*                                                                          */
/**PROC-*********************************************************************/
__inline PDCVOID DCINTERNAL UTMalloc(DCUINT length)
{
    return((PDCVOID)LocalAlloc(LMEM_FIXED, length));
}

/**PROC+*********************************************************************/
/* Name:      UTMallocHuge                                                  */
/*                                                                          */
/* Purpose:   Same as UTMalloc for Win32.                                   */
/*                                                                          */
/* Returns:   pointer to allocated memory, or NULL if the function fails.   */
/*                                                                          */
/* Params:    length - length in bytes of the memory to allocate.           */
/*                                                                          */
/**PROC-*********************************************************************/
__inline HPDCVOID DCINTERNAL UTMallocHuge(DCUINT32 length)
{
    return(UTMalloc(length));
}

/**PROC+*********************************************************************/
/* Name:      UTFree                                                        */
/*                                                                          */
/* Purpose:   Frees dynamically allocated memory obtained using UT_Malloc   */
/*                                                                          */
/* Returns:   Nothing                                                       */
/*                                                                          */
/* Params:    pMemory - pointer to memory to free                           */
/*                                                                          */
/**PROC-*********************************************************************/
__inline DCVOID DCAPI UTFree(PDCVOID pMemory)
{
    LocalFree((HLOCAL)pMemory);
    return;
}

#if defined(OS_WINCE)
/**PROC+*********************************************************************/
/* Name:      UT_MAKE_SUBKEY                                                */
/*                                                                          */
/* Purpose:   Make registry subkey for WinCE.                               */
/*            WinCE doesn't handle '\\' at end of key string.               */
/*                                                                          */
/* Returns:   Nothing                                                       */
/*                                                                          */
/* Params:    pBuffer - pointer to output buffer                            */
/*            pSubkey - pointer to subkey buffer                            */
/*                                                                          */
/**PROC-*********************************************************************/
__inline DCVOID DCINTERNAL UT_MAKE_SUBKEY(PDCTCHAR pBuffer, PDCTCHAR pSubkey)
{
    DWORD i;

    DC_TSTRCPY(pBuffer, DUCATI_REG_PREFIX);
    DC_TSTRCAT(pBuffer, pSubkey);

    i = DC_TSTRLEN(pBuffer);
    if (i > 0 && pBuffer[i-1] == _T('\\')) {
        pBuffer[i-1] = _T('\0');
    }
}
#endif // !defined(OS_WINCE)

#endif /* _H_NUTINT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\inc\objs.h ===
/**MOD+**********************************************************************/
/* Module:    objs.h                                                        */
/*                                                                          */
/* Purpose:   Object Pointer Container class                                */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997-1999                             */
/*                                                                          */
/****************************************************************************/

#ifndef _H_OBJS_
#define _H_OBJS_

#define NEW_TD

//
// Forward declarations
//
class CUI;
class CCO;
class CUT;
class CCD;
class CSND;
class CRCV;
class CCC;
class CIH;
class COR;
class CFS;
class CSL;
class CNL;
class CNC;
class CMCS;
class CLic;
class CChan;

class CXT;
class CTD;
class CRCV;
class CCM;
class CUH;
class CGH;

class CBD;
class COD;
class COP;
class CSP;
class CCLX;

//
// Object name flags used to mark
// which objects still have active
// reverences to the object collection
//
#define UI_OBJECT_FLAG  0x00000001
#define CO_OBJECT_FLAG  0x00000002
#define UT_OBJECT_FLAG  0x00000004
#define CD_OBJECT_FLAG  0x00000008
#define SND_OBJECT_FLAG 0x00000010
#define RCV_OBJECT_FLAG 0x00000020
#define CLX_OBJECT_FLAG 0x00000040
#define UH_OBJECT_FLAG  0x00000080
                                  

class CObjs
{
public:
    CObjs();
    ~CObjs();
    BOOL CheckPointers();
    LONG AddObjReference(DWORD dwFlag);
    LONG ReleaseObjReference(DWORD dwFlag);
    LONG AddRef();
    LONG Release();
    BOOL CheckActiveReferences();

    //
    // Data members
    //
    
    CUI* _pUiObject;

    CCO*  _pCoObject;
    CUT*  _pUtObject;

    CCD*  _pCdObject;
    CSND* _pSndObject;
    CRCV* _pRcvObject;


    CCC*  _pCcObject;
    CIH*  _pIhObject;

    COR*  _pOrObject;
    CFS*  _pFsObject;
    CSL*  _pSlObject;
    CNL*  _pNlObject;
    CNC*  _pNcObject;

    CMCS*  _pMCSObject;
    CChan* _pChanObject;
    CLic*  _pLicObject;
    
    CXT*   _pXTObject;
    CTD*   _pTDObject;
    CCM*   _pCMObject;
    CUH*   _pUHObject;
    CGH*   _pGHObject;

    COD*   _pODObject;
    COP*   _pOPObject;
    CSP*   _pSPObject;
    CCLX*  _pCLXObject;

private:
    DWORD      _dwActiveObjects;
    LONG       _cRefCount;
};
#endif  _H_OBJS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\inc\progband.h ===
//
// progband.h  Progress band code
//
// Copyright Microsoft Corportation 2001
// (nadima)
//

#ifndef _progband_h_
#define _progband_h_

//
// Timer ID
//
#define TIMER_PROGRESSBAND_ANIM_ID 137

//
// x increment per anim iteration
//
#define PROGRESSBAND_ANIM_INCR  5
//
// Animation delay
//
#define ANIM_DELAY_MSECS        20


class CProgressBand
{
public:
    CProgressBand(HWND hwndOwner,
                  HINSTANCE hInst,
                  INT nYindex,
                  INT nResID,
                  INT nResID8bpp,
                  HPALETTE hPal);
    ~CProgressBand();

    BOOL Initialize();
    BOOL StartSpinning();
    BOOL StopSpinning();
    BOOL ReLoadBmps();
    VOID ResetBandOffset()  {_nBandOffset = 0;}
    INT  GetBandHeight()    {return _rcBand.bottom - _rcBand.top;}

    //
    // Events that must be called by parent
    //
    BOOL OnEraseParentBackground(HDC hdc);
    BOOL OnTimer(INT nTimerID);


private:
    //
    // Private member functions
    //
    BOOL InitBitmaps();
    BOOL PaintBand(HDC hdc);

private:
    //
    // Private members
    //
    BOOL        _fInitialized;

    HWND        _hwndOwner;
    HINSTANCE   _hInstance;
    INT         _nYIndex;
    INT         _nResID;
    INT         _nResID8bpp;
    HBITMAP     _hbmpProgBand;
    RECT        _rcBand;
    INT         _nBandOffset;
    HPALETTE    _hPal;

    INT         _nTimerID;
};

#endif // _progband_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\inc\tscerrs.h ===
//
// tserrors.h: figure out what disconnection errors mean
//

#ifndef _tscerrs_h_
#define _tscerrs_h_

//protocol error codes
#include "tserrs.h"


// ~*~*~*~*~*~*~*~*~*~*~*~~*~*~*~*~*~*~*~*~*~*~*~~*~*~*~*~*~*~*~*~*~*~*~~*~*~*~
// !!!!!!!!!!!READ THIS!!!!  READ THIS !!!!! READ THIS !!! READ THIS !!!!!!!!!!
//
// The ActiveX control IDL defines an enum (DisconnectReasonCode) that
// is dependent on the values these codes expand to.
//
// However, we only document a subset of the possible error codes if necessary
// you may need to updat mstsax.idl to publicly expose any new codes.
//
// Currently mstsax.idl does not include this header and that's by design
// because this is an internal only header file.
//
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// ~*~*~*~*~*~*~*~*~*~*~*~~*~*~*~*~*~*~*~*~*~*~*~~*~*~*~*~*~*~*~*~*~*~*~~*~*~*~



///////////////////////////////////////////////////////////////////////////////
// NL errors
//


/****************************************************************************/
/* Macro to make an error return code.                                      */
/****************************************************************************/
#define NL_MAKE_DISCONNECT_ERR(x)                                            \
        ((DCUINT)(NL_DISCONNECT_ERROR + ((x) << 8)))

#define NL_GET_MAIN_REASON_CODE(x)    ((DCUINT)(0x00FF & (x)))
#define NL_GET_ERR_CODE(x)            ((DCUINT)((0xFF00 & (x)) >> 8))

/****************************************************************************/
/* Disconnection reason codes.                                              */
/****************************************************************************/
#define NL_DISCONNECT_BASE(x)                  (x)
#define NL_DISCONNECT_LOCAL                    NL_DISCONNECT_BASE(0x1)
#define NL_DISCONNECT_REMOTE_BY_USER           NL_DISCONNECT_BASE(0x2)
#define NL_DISCONNECT_REMOTE_BY_SERVER         NL_DISCONNECT_BASE(0x3)
#define NL_DISCONNECT_ERROR                    NL_DISCONNECT_BASE(0x4)
#define NL_DISCONNECT_MAX                      NL_DISCONNECT_BASE(0x4)

/****************************************************************************/
/* Additional information is conveyed when the disconnection is due to an   */
/* error condition.  Define the bases for these extra errors.               */
/****************************************************************************/
#define NL_ERR_BASE(x)                         (x)
#define NL_ERR_TDBASE(x)                       (NL_ERR_BASE(x))
#define NL_ERR_XTBASE(x)                       (NL_ERR_BASE((x) + 0x10))
#define NL_ERR_MCSBASE(x)                      (NL_ERR_BASE((x) + 0x20))
#define NL_ERR_NCBASE(x)                       (NL_ERR_BASE((x) + 0x30))

/****************************************************************************/
/* Define the TD error disconnection reason codes.                          */
/****************************************************************************/
#define NL_ERR_TDDNSLOOKUPFAILED               NL_ERR_TDBASE(0x1)
#define NL_ERR_TDSKTCONNECTFAILED              NL_ERR_TDBASE(0x2)
#define NL_ERR_TDONCALLTOSEND                  NL_ERR_TDBASE(0x3)
#define NL_ERR_TDONCALLTORECV                  NL_ERR_TDBASE(0x4)
#define NL_ERR_TDGHBNFAILED                    NL_ERR_TDBASE(0x6)
#define NL_ERR_TDTIMEOUT                       NL_ERR_TDBASE(0x7)
#define NL_ERR_TDBADIPADDRESS                  NL_ERR_TDBASE(0x8)
#define NL_ERR_TDFDCLOSE                       NL_ERR_TDBASE(0x9)
#define NL_ERR_TDANSICONVERT                   NL_ERR_TDBASE(0xA)

/****************************************************************************/
/* Now the XT error disconnection reason codes.                             */
/****************************************************************************/
#define NL_ERR_XTBADTPKTVERSION                NL_ERR_XTBASE(0x1)
#define NL_ERR_XTBADHEADER                     NL_ERR_XTBASE(0x2)
#define NL_ERR_XTUNEXPECTEDDATA                NL_ERR_XTBASE(0x3)

/****************************************************************************/
/* And the MCS error disconnection reason codes.                            */
/****************************************************************************/
#define NL_ERR_MCSUNEXPECTEDPDU                NL_ERR_MCSBASE(0x1)
#define NL_ERR_MCSNOTCRPDU                     NL_ERR_MCSBASE(0x2)
#define NL_ERR_MCSBADCRLENGTH                  NL_ERR_MCSBASE(0x3)
#define NL_ERR_MCSBADCRFIELDS                  NL_ERR_MCSBASE(0x4)
#define NL_ERR_MCSBADMCSREASON                 NL_ERR_MCSBASE(0x6)
#define NL_ERR_MCSNOUSERIDINAUC                NL_ERR_MCSBASE(0x7)
#define NL_ERR_MCSNOCHANNELIDINCJC             NL_ERR_MCSBASE(0x8)
#define NL_ERR_MCSINVALIDPACKETFORMAT          NL_ERR_MCSBASE(0x9)

/****************************************************************************/
/* NC disconnection reason codes.                                           */
/****************************************************************************/
#define NL_ERR_NCBADMCSRESULT                  NL_ERR_NCBASE(0x1)
#define NL_ERR_NCNOUSERDATA                    NL_ERR_NCBASE(0x3)
#define NL_ERR_NCINVALIDH221KEY                NL_ERR_NCBASE(0x4)
#define NL_ERR_NCNONETDATA                     NL_ERR_NCBASE(0x5)
#define NL_ERR_NCATTACHUSERFAILED              NL_ERR_NCBASE(0x6)
#define NL_ERR_NCCHANNELJOINFAILED             NL_ERR_NCBASE(0x7)
#define NL_ERR_NCJOINBADCHANNEL                NL_ERR_NCBASE(0x8)
#define NL_ERR_NCNOCOREDATA                    NL_ERR_NCBASE(0x9)
#define NL_ERR_NCVERSIONMISMATCH               NL_ERR_NCBASE(0xa)


///////////////////////////////////////////////////////////////////////////////
// UI errors
//

/****************************************************************************/
/* UI error code constants - Make sure these do not overlap with            */
/* SL/NL_DISCONNECT_*                                                       */
/****************************************************************************/
#define UI_DISCONNECT_BASE      (NL_DISCONNECT_MAX + 3)
#define UI_DISCONNECT_ERROR     (UI_DISCONNECT_BASE + 1)
#define UI_DISCONNECT_MAX       (UI_DISCONNECT_BASE + 2)

#define UI_MAKE_DISCONNECT_ERR(x)                                           \
        ((DCUINT)(UI_DISCONNECT_ERROR + ((x) << 8)))

#define UI_ERR_DISCONNECT_TIMEOUT           1
#define UI_ERR_GHBNFAILED                   2
#define UI_ERR_BADIPADDRESS                 3
#define UI_ERR_ANSICONVERT                  4
#define UI_ERR_DNSLOOKUPFAILED              5
#define UI_ERR_NOTIMER                      6
#define UI_ERR_LOOPBACK_CONSOLE_CONNECT     7
#define UI_ERR_LICENSING_NEGOTIATION_FAIL   8
#define UI_ERR_LICENSING_TIMEOUT            9

#define UI_ERR_UNEXPECTED_DISCONNECT        10
#define UI_ERR_NORMAL_DISCONNECT            11

#define UI_ERR_DECOMPRESSION_FAILURE        12

////////////////////////////////////////////////////////////////////////////////
// SL errors
//

/****************************************************************************/
/* Reason codes for OnDisconnected callback                                 */
/* Make sure these do not overlap with NL_DISCONNECT_*                      */
/****************************************************************************/
#define SL_DISCONNECT_BASE              (NL_DISCONNECT_MAX + 0x1)
#define SL_DISCONNECT_ERROR             (SL_DISCONNECT_BASE + 0x1)
#define SL_DISCONNECT_MAX               (NL_DISCONNECT_MAX + 0x2)


/****************************************************************************/
/* Additional information is conveyed when the disconnection is due to an   */
/* error condition.  Define the base for these extra errors.                */
/****************************************************************************/
#define SL_ERR_BASE(x)                         (x)

#define SL_ERR_NOMEMFORSENDUD                  SL_ERR_BASE(0x1)
#define SL_ERR_NOMEMFORRECVUD                  SL_ERR_BASE(0x2)
#define SL_ERR_NOMEMFORSECPACKET               SL_ERR_BASE(0x3)
#define SL_ERR_NOSECURITYUSERDATA              SL_ERR_BASE(0x4)
#define SL_ERR_INVALIDENCMETHOD                SL_ERR_BASE(0x5)
#define SL_ERR_INVALIDSRVRAND                  SL_ERR_BASE(0x6)
#define SL_ERR_INVALIDSRVCERT                  SL_ERR_BASE(0x7)
#define SL_ERR_GENSRVRANDFAILED                SL_ERR_BASE(0x8)
#define SL_ERR_MKSESSKEYFAILED                 SL_ERR_BASE(0x9)
#define SL_ERR_ENCCLNTRANDFAILED               SL_ERR_BASE(0xA)
#define SL_ERR_ENCRYPTFAILED                   SL_ERR_BASE(0xB)
#define SL_ERR_DECRYPTFAILED                   SL_ERR_BASE(0xC)
#define SL_ERR_INVALIDPACKETFORMAT             SL_ERR_BASE(0xD)
#define SL_ERR_INITFIPSFAILED                  SL_ERR_BASE(0xE)


/****************************************************************************/
/* Macro to make an error return code.                                      */
/****************************************************************************/
#define SL_MAKE_DISCONNECT_ERR(x)                                            \
        ((DCUINT)(SL_DISCONNECT_ERROR + ((x) << 8)))


/*****************************************************************************/
/* TSC CORE                                                                  */
/*                                                                           */
/* All the below are used only internally.  Any file wishing to use these HR */
/* must add an entry to the TSC_CORE_FILE enum below.  The file must #define */
/* TSC_HR_FILEID to the value from the enum for that file.                   */
/* When the TSC_CORE layer calls CO_DropLinkImmediate, it will write the HR  */
/* that caused the link to drop into the CCO::m_disconnectHRs array where it */
/* can be retrieved by a debuggee.                                           */
/*****************************************************************************/
#define TSC_FAC 0x1F00

#define TSC_LINE_MASK  0x1FFF


// 14 bits - line
//  4 bits - err
//  6 bits - file
#define MAKE_TSC_CORE_EHR(err) \
    MAKE_HRESULT(SEVERITY_ERROR, \
        TSC_FAC | ((TSC_HR_FILEID) << 2) | ((err)>>2), \
        (((err)&3)<<14) | __LINE__ ) 

#define E_TSC_CORE_LENGTH          MAKE_TSC_CORE_EHR(1)
#define E_TSC_CORE_CACHEVALUE      MAKE_TSC_CORE_EHR(2)
#define E_TSC_CORE_DECODETYPE      MAKE_TSC_CORE_EHR(3)
#define E_TSC_CORE_PALETTE         MAKE_TSC_CORE_EHR(4)
#define E_TSC_CORE_GDIPLUS         MAKE_TSC_CORE_EHR(5)
#define E_TSC_CORE_UNEXPECTEDCOMP  MAKE_TSC_CORE_EHR(6)
#define E_TSC_UI_GLYPH             MAKE_TSC_CORE_EHR(7)
#define E_TSC_UI_DECOMPRESSION     MAKE_TSC_CORE_EHR(8) 

#define IMMEDIATE_DISSCONNECT_ON_HR(hr) \
    ((HRESULT_FACILITY(hr) & TSC_FAC) == TSC_FAC)

typedef enum _TSC_CORE_FILE
{
    TSC_HR_UH_H = 1,
    TSC_HR_CM_H = 2,
    TSC_HR_ABDAPI_CPP = 3,
    TSC_HR_ACO_CPP = 4,
    TSC_HR_WCMINT_CPP = 5,
    TSC_HR_ODAPI_CPP = 6,
    TSC_HR_ODINT_CPP = 7,
    TSC_HR_GHAPI_CPP = 8,
    TSC_HR_GHINT_CPP = 9,
    TRC_HR_UINT_CPP = 10,
} TSC_CORE_FILE;

#endif // _tscerrs_h_


#ifdef DC_DEBUG
/****************************************************************************/
/* NL/SL error translation code tables (debug build only).                  */
/****************************************************************************/
extern const PDCTCHAR uiNLErrorText[4][20]
#ifdef DC_DEFINE_GLOBAL_ERROR_STRINGS
    =
  {
   {
    _T("NL_ERR_TDDNSLOOKUPFAILED (0x104)\nTD: DNS lookup failed"),
    _T("NL_ERR_TDSKTCONNECTFAILED (0x204)\nTD: WinSock socket connect failed"),
    _T("NL_ERR_TDONCALLTOSEND (0x304)\nTD: WinSock send call failed"),
    _T("NL_ERR_TDONCALLTORECV (0x404)\nTD: WinSock recv call failed"),
    _T("***Retired***"),
    _T("NL_ERR_TDGHBNFAILED (0x604)\nTD: GetHostByName call failed"),
    _T("NL_ERR_TDTIMEOUT (0x704)\nTD: Timer has popped"),
    _T("NL_ERR_TDBADIPADDRESS (0x804)\nTD: A bad IP address was specified"),
    _T("NL_ERR_TDFDCLOSE (0x904)\nTD: FD_CLOSE received from WinSock"),
    _T("NL_ERR_TDANSICONVERT (0xA04)\nTD: AnsiConvert call failed"),
   },

   {
    _T("NL_ERR_XTBADPKTVERSION (0x1104)\nXT: The TPKT version number is bad"),
    _T("NL_ERR_XTBADHEADER (0x1204)\nXT: The XT header was not recognized"),
    _T("NL_ERR_XTUNEXPECTEDDATA (0x1304)\nXT: Unexpected data following XT_RCVST_X224_DATA payload"),
   },

   {
    _T("NL_ERR_MCSUNEXPECTEDPDU (0x2104)\nMCS: Unexpected MCS PDU was received"),
    _T("NL_ERR_MCSNOTCRPDU (0x2204)\nMCS: Bad PDU - expecting a Cnct-Response"),
    _T("NL_ERR_MCSBADCRLENGTH (0x2304)\nMCS: Bad Cnct-Response PDU total length"),
    _T("NL_ERR_MCSBADCRFIELDS (0x2404)\nMCS: Bad Cnct-Response fields"),
    _T("***Retired***"),
    _T("NL_ERR_MCSBADMCSREASON (0x2604)\nMCS: Bad MCS reason code received"),
    _T("NL_ERR_MCSNOUSERIDINAUC (0x2704)\nMCS: No user-ID in AUC"),
    _T("NL_ERR_MCSNOCHANNELIDINCJC (0x2804)\nMCS: No channel-ID in CJC"),
    _T("NL_ERR_MCSINVALIDPACKETFORMAT (0x2904)\nMCS: Invalid packet format"),
   },

   {
    _T("NL_ERR_NCBADMCSRESULT (0x3104)\nNC: Bad MCS result code received"),
    _T("***Retired***"),
    _T("NL_ERR_NCNOUSERDATA (0x3304)\nNC: No user data in CreateConfConfirm"),
    _T("NL_ERR_NCINVALIDH221KEY (0x3404)\nNC: Bad H221 key in CreateConfConfirm"),
    _T("NL_ERR_NCNONETDATA (0x3504)\nNC: No NET data in user-data"),
    _T("NL_ERR_NCATTACHUSERFAILED (0x3604)\nNC: Failed to attach a MCS user"),
    _T("NL_ERR_NCCHANNELJOINFAILED (0x3704)\nNC: Failed to join a MCS channel"),
    _T("NL_ERR_NCJOINBADCHANNEL (0x3804)\nNC: Joined an unexpected MCS channel"),
    _T("NL_ERR_NCNOCOREDATA (0x3904)\nNC: Bad or missing user data"),
    _T("NL_ERR_NCVERSIONMISMATCH (0x3a04)\nNC: Server/client version mismatch"),
   }
  }
#endif /* DC_DEFINE_GLOBAL_ERROR_STRINGS */
;

extern const PDCTCHAR uiSLErrorText[13]
#ifdef DC_DEFINE_GLOBAL_ERROR_STRINGS
    = {
    _T("SL_ERR_NOMEMFORSENDUD (0x106)\nSL: No memory for send user-data"),
    _T("SL_ERR_NOMEMFORRECVUD (0x206)\nSL: No memory for recv user-data"),
    _T("SL_ERR_NOMEMFORSECPACKET (0x306)\nSL: No memory for recv user-data"),
    _T("SL_ERR_NOSECURITYUSERDATA (0x406)\nSL: No security user data received"),
    _T("SL_ERR_INVALIDENCMETHOD (0x506)\nSL: Invalid encryption method received"),
    _T("SL_ERR_INVALIDSRVRAND (0x606)\nSL: Invalid server random received"),
    _T("SL_ERR_INVALIDSRVCERT (0x706)\nSL: Failed to unpack server certificate"),
    _T("SL_ERR_GENSRVRANDFAILED (0x806)\nSL: Failed create client random"),
    _T("SL_ERR_ENCCLNTRANDFAILED (0x906)\nSL: Failed to encrypt client random"),
    _T("SL_ERR_MKSESSKEYFAILED (0xA06)\nSL: MakeSessionKeys failed"),
    _T("SL_ERR_ENCRYPTFAILED (0xB06)\nSL: Failed to encrypt"),
    _T("SL_ERR_DECRYPTFAILED (0xC06)\nSL: Failed to decrypt"),
    _T("SL_ERR_INVALIDPACKETFORMAT (0xD06)\nSL: Invalid packet format"),
      }
#endif /* DC_DEFINE_GLOBAL_ERROR_STRINGS */
;

extern const PDCTCHAR uiUIErrorText[12]
#ifdef DC_DEFINE_GLOBAL_ERROR_STRINGS
    = {
    _T("UI_ERR_DISCONNECT_TIMEOUT (0x108)\nUI: Connection Timeout"),
    _T("UI_ERR_GHBNFAILED (0x208)\nUI: GetHostByName call failed"),
    _T("UI_ERR_BADIPADDRESS (0x308)\nUI: A bad IP address was specified"),
    _T("UI_ERR_ANSICONVERT (0x408)\nUI: AnsiConvert call failed"),
    _T("UI_ERR_DNSLOOKUPFAILED  (0x508)\nUI: DNS lookup failed"),
    _T("UI_ERR_NOTIMER  (0x608)\nUI: SetTimer call failed"),
    _T("UI_ERR_LOOPBACK_CONSOLE_CONNECT (0x708)\nUI: Loopback console connect"),
    _T("UI_ERR_LICENSING_NEGOTIATION_FAIL (0x808)\nUI: Licensing negotiation failed"),
    _T("UI_ERR_LICENSING_TIMEOUT          (0x908)\nUI: Licensing timeout"),
    _T("UI_ERR_UNEXPECTED_DISCONNECT (0xa08)"),
    _T("UI_ERR_NORMAL_DISCONNECT (0xb08)"),
    _T("UI_ERR_DECOMPRESSION_FAILURE (0xc08)\nUI: Client decompression failure"),
      }
#endif /* DC_DEFINE_GLOBAL_ERROR_STRINGS */
;

#endif /* DC_DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\inc\vchandle.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vchandle.h

Abstract:

    Exposes structure of channel init handle to internal plugins
    external plugins see this as an opaque pointer

Author:

    Nadim Abdo (nadima) 23-Apr-2000

Revision History:

--*/

#ifndef __VCHANDLE_H__
#define __VCHANDLE_H__

class CChan;

typedef struct tagCHANNEL_INIT_HANDLE
{
    DCUINT32                signature;
#define CHANNEL_INIT_SIGNATURE 0x4368496e  /* "ChIn" */
    PCHANNEL_INIT_EVENT_FN  pInitEventFn;
    PCHANNEL_INIT_EVENT_EX_FN pInitEventExFn;
    DCUINT                  channelCount;
    HMODULE                 hMod;
    CChan*                  pInst;         /*client instance*/
    LPVOID                  lpParam;       /*user defined value*/
    DCBOOL                  fUsingExApi;   /*Is Extended Api used?*/
    LPVOID                  lpInternalAddinParam; /*Internal addin's get a param from the core*/
    DWORD                   dwFlags;
    struct tagCHANNEL_INIT_HANDLE * pPrev;
    struct tagCHANNEL_INIT_HANDLE * pNext;
} CHANNEL_INIT_HANDLE, *PCHANNEL_INIT_HANDLE;


#endif // __VCHANDLE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\inc\wdcgdata.h ===
/****************************************************************************/
/* wdcgdata.h                                                               */
/*                                                                          */
/* Common include file for all data.c modules (Windows specific)            */
/*                                                                          */
/* Copyright(c) Microsoft 1996-1997.                                        */
/*                                                                          */
/* The macros in this file allow all aspects of data declaration to be kept */
/* together.  The behaviour of this file is controlled by #defines that can */
/* be set prior to inclusion of this.                                       */
/*                                                                          */
/* - DC_INIT_DATA     Set in XX_Init routines to do inline initialisation if*/
/*                    required.                                             */
/* - DC_INCLUDE_DATA  Set where a header file is included in order to get   */
/*                    external declarations.                                */
/* - DC_DEFINE_DATA   Set where a header file is included in order to get   */
/*                    definition without initialisation.                    */
/* - DC_CONSTANT_DATA Set to get global initialisation of const data items  */
/* - (default)        Gets data definition with initialisation.             */
/*                                                                          */
/****************************************************************************/
/*                                                                          */
/* In order to allow for the flexibility required in different environments */
/* (be that different OSs, C vs C++, or whatever) the structure of the file */
/* is as follows.                                                           */
/*                                                                          */
/* First there is an environment-specific mapping from the macros used in   */
/* the code to internal macros.  This mapping also takes the above #defines */
/* into consideration in performing this expansion.                         */
/*                                                                          */
/* Secondly, the low-level macros that actually perform the expansion are   */
/* defined.  These should be platform-independent.                          */
/*                                                                          */
/* The intention of this structure is to avoid the confusions caused by the */
/* old version where, for example, code compiled with DC_INIT_DATA          */
/* explicitly did NOT initialise the data.                                  */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/*  $Log:   Y:/logs/h/dcl/wdcgdata.h_v  $                                                                   */
// 
//    Rev 1.1   19 Jun 1997 14:36:04   ENH
// Win16Port: Make compatible with 16 bit build
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* Clear any previous definitions of the macros.                            */
/****************************************************************************/
#undef DC_DATA
#undef DC_DATA_NULL
#undef DC_DATA_ARRAY
#undef DC_DATA_ARRAY_NULL
#undef DC_DATA_ARRAY_UNINIT
#undef DC_DATA_ARRAY_SET
#undef DC_DATA_2D_ARRAY
#undef DC_CONST_DATA
#undef DC_CONST_DATA_ARRAY
#undef DC_CONST_DATA_2D_ARRAY
#undef DCI_DATA
#undef DCI_DATA_NULL
#undef DCI_DATA_ARRAY
#undef DCI_DATA_ARRAY_NULL
#undef DCI_DATA_ARRAY_UNINIT
#undef DCI_DATA_ARRAY_SET
#undef DCI_DATA_2D_ARRAY
#undef DCI_CONST_DATA
#undef DCI_CONST_DATA_ARRAY
#undef DCI_CONST_DATA_2D_ARRAY


/****************************************************************************/
/* Now define the main (external) macros.                                   */
/****************************************************************************/
#define DC_DATA(A,B,C)                    DCI_DATA(A,B,C)
#define DC_DATA_NULL(A,B,C)               DCI_DATA_NULL(A,B,C)

#define DC_DATA_ARRAY(A,B,C,D)            DCI_DATA_ARRAY(A,B,C,D)
#define DC_DATA_ARRAY_NULL(A,B,C,D)       DCI_DATA_ARRAY_NULL(A,B,C,D)
#define DC_DATA_ARRAY_UNINIT(A,B,C)       DCI_DATA_ARRAY_UNINIT(A,B,C)
#define DC_DATA_ARRAY_SET(A,B,C,D)        DCI_DATA_ARRAY_SET(A,B,C,D)
#define DC_DATA_2D_ARRAY(A,B,C,D,E)       DCI_DATA_2D_ARRAY(A,B,C,D,E)

#define DC_CONST_DATA(A,B,C)              DCI_CONST_DATA(A,B,C)
#define DC_CONST_DATA_ARRAY(A,B,C,D)      DCI_CONST_DATA_ARRAY(A,B,C,D)
#define DC_CONST_DATA_2D_ARRAY(A,B,C,D,E) DCI_CONST_DATA_2D_ARRAY(A,B,C,D,E)


/****************************************************************************/
/****************************************************************************/
/* Now map to the target macros                                             */
/****************************************************************************/
/****************************************************************************/

#if defined(DC_INCLUDE_DATA)
/****************************************************************************/
/* External declarations                                                    */
/****************************************************************************/
#define DCI_DATA(TYPE, Name, VAL)                                        \
                      DCI_EXTERN_DATA(TYPE, Name, VAL)
#define DCI_DATA_NULL(TYPE, Name, VAL)                                   \
                      DCI_EXTERN_DATA_NULL(TYPE, Name, VAL)
#define DCI_DATA_ARRAY(TYPE, Name, Size, VAL)                            \
                      DCI_EXTERN_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_ARRAY_NULL(TYPE, Name, Size, VAL)                       \
                      DCI_EXTERN_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_ARRAY_UNINIT(TYPE, Name, Size)                          \
                      DCI_EXTERN_DATA_ARRAY(TYPE, Name, Size, 0)
#define DCI_DATA_ARRAY_SET(TYPE, Name, Size, VAL)                        \
                      DCI_EXTERN_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)                 \
                      DCI_EXTERN_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)
#define DCI_CONST_DATA(TYPE, Name, VAL)                                  \
                      DCI_EXTERN_CONST_DATA(TYPE, Name, VAL)
#define DCI_CONST_DATA_ARRAY(TYPE, Name, Size, VAL)                      \
                      DCI_EXTERN_CONST_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)           \
                 DCI_EXTERN_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)

#elif defined(DC_INIT_DATA)
/****************************************************************************/
/* Inline initialisation                                                    */
/****************************************************************************/
#if defined(VER_CPP) && defined(DC_IN_CLASS)
#define DCI_DATA(TYPE, Name, VAL)                                        \
                      DCI_ASSIGN_DATA(TYPE, Name, VAL)
#define DCI_DATA_NULL(TYPE, Name, VAL)                                   \
                      DCI_SET_DATA_NULL(TYPE, Name, VAL)
#define DCI_DATA_ARRAY(TYPE, Name, Size, VAL)                            \
                      DCI_ASSIGN_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_ARRAY_NULL(TYPE, Name, Size, VAL)                       \
                      DCI_SET_DATA_ARRAY_NULL(TYPE, Name, Size, VAL)
#define DCI_DATA_ARRAY_UNINIT(TYPE, Name, Size)                          \
                      DCI_SET_DATA_ARRAY_NULL(TYPE, Name, Size, 0)
#define DCI_DATA_ARRAY_SET(TYPE, Name, Size, VAL)                        \
                      DCI_SET_DATA_ARRAY_VAL(TYPE, Name, Size, VAL)
#define DCI_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)                 \
                      DCI_ASSIGN_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)
#define DCI_CONST_DATA(TYPE, Name, VAL)                                  \
                      DCI_NO_DATA(TYPE, Name, VAL)
#define DCI_CONST_DATA_ARRAY(TYPE, Name, Size, VAL)                      \
                      DCI_NO_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)           \
                      DCI_NO_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)
#else
#define DCI_DATA(TYPE, Name, VAL)                                        \
                      DCI_NO_DATA(TYPE, Name, VAL)
#define DCI_DATA_NULL(TYPE, Name, VAL)                                   \
                      DCI_NO_DATA_NULL(TYPE, Name, VAL)
#define DCI_DATA_ARRAY(TYPE, Name, Size, VAL)                            \
                      DCI_NO_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_ARRAY_NULL(TYPE, Name, Size, VAL)                       \
                      DCI_NO_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_ARRAY_UNINIT(TYPE, Name, Size)                          \
                      DCI_NO_DATA_ARRAY(TYPE, Name, Size, 0)
#define DCI_DATA_ARRAY_SET(TYPE, Name, Size, VAL)                        \
                      DCI_NO_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)                 \
                      DCI_NO_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)
#define DCI_CONST_DATA(TYPE, Name, VAL)                                  \
                      DCI_NO_DATA(TYPE, Name, VAL)
#define DCI_CONST_DATA_ARRAY(TYPE, Name, Size, VAL)                      \
                      DCI_NO_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)           \
                      DCI_NO_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)

#endif

#elif defined(DC_DEFINE_DATA)
/****************************************************************************/
/* Definition but no initialisation                                         */
/****************************************************************************/
#define DCI_DATA(TYPE, Name, VAL)                                        \
                      DCI_DEFINE_DATA(TYPE, Name, VAL)
#define DCI_DATA_NULL(TYPE, Name, VAL)                                   \
                      DCI_DEFINE_DATA_NULL(TYPE, Name, VAL)
#define DCI_DATA_ARRAY(TYPE, Name, Size, VAL)                            \
                      DCI_DEFINE_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_ARRAY_NULL(TYPE, Name, Size, VAL)                       \
                      DCI_DEFINE_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_ARRAY_UNINIT(TYPE, Name, Size)                          \
                      DCI_DEFINE_DATA_ARRAY(TYPE, Name, Size, NULL)
#define DCI_DATA_ARRAY_SET(TYPE, Name, Size, VAL)                        \
                      DCI_DEFINE_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)                 \
                      DCI_DEFINE_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)
#define DCI_CONST_DATA(TYPE, Name, VAL)                                  \
                      DCI_DEFINE_CONST_DATA(TYPE, Name, VAL)
#define DCI_CONST_DATA_ARRAY(TYPE, Name, Size, VAL)                      \
                      DCI_DEFINE_CONST_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)           \
                DCI_DEFINE_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)

#elif defined(DC_CONSTANT_DATA)
/****************************************************************************/
/* Definition but no initialisation                                         */
/****************************************************************************/
#define DCI_DATA(TYPE, Name, VAL)                                        \
                      DCI_NO_DATA(TYPE, Name, VAL)
#define DCI_DATA_NULL(TYPE, Name, VAL)                                   \
                      DCI_NO_DATA_NULL(TYPE, Name, VAL)
#define DCI_DATA_ARRAY(TYPE, Name, Size, VAL)                            \
                      DCI_NO_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_ARRAY_NULL(TYPE, Name, Size, VAL)                       \
                      DCI_NO_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_ARRAY_UNINIT(TYPE, Name, Size)                          \
                      DCI_NO_DATA_ARRAY(TYPE, Name, Size, NULL)
#define DCI_DATA_ARRAY_SET(TYPE, Name, Size, VAL)                        \
                      DCI_NO_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)                 \
                      DCI_NO_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)
#define DCI_CONST_DATA(TYPE, Name, VAL)                                  \
                      DCI_INIT_CONST_DATA(TYPE, Name, VAL)
#define DCI_CONST_DATA_ARRAY(TYPE, Name, Size, VAL)                      \
                      DCI_INIT_CONST_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)           \
                  DCI_INIT_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)

#else
/****************************************************************************/
/* Data definition and initialisation                                       */
/****************************************************************************/
#define DCI_DATA(TYPE, Name, VAL)                                        \
                      DCI_INIT_DATA(TYPE, Name, VAL)
#define DCI_DATA_NULL(TYPE, Name, VAL)                                   \
                      DCI_INIT_DATA_NULL(TYPE, Name, VAL)
#define DCI_DATA_ARRAY(TYPE, Name, Size, VAL)                            \
                      DCI_INIT_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_ARRAY_NULL(TYPE, Name, Size, VAL)                       \
                      DCI_INIT_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_ARRAY_UNINIT(TYPE, Name, Size)                          \
                      DCI_DEFINE_DATA_ARRAY(TYPE, Name, Size, NULL)
#define DCI_DATA_ARRAY_SET(TYPE, Name, Size, VAL)                        \
                      DCI_INIT_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)                 \
                      DCI_INIT_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)
#define DCI_CONST_DATA(TYPE, Name, VAL)                                  \
                      DCI_INIT_CONST_DATA(TYPE, Name, VAL)
#define DCI_CONST_DATA_ARRAY(TYPE, Name, Size, VAL)                      \
                      DCI_INIT_CONST_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)           \
                  DCI_INIT_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)

#endif


/****************************************************************************/
/****************************************************************************/
/* Finally, the low-level macros required to do the real work.              */
/*                                                                          */
/* Avoid multiple inclusion of these.                                       */
/****************************************************************************/
/****************************************************************************/

#ifndef _H_WDCGDATA
#define _H_WDCGDATA

/****************************************************************************/
/* Some utilities...                                                        */
/****************************************************************************/
#define DC_STRUCT1(a)                                              {a}
#define DC_STRUCT2(a,b)                                          {a,b}
#define DC_STRUCT3(a,b,c)                                      {a,b,c}
#define DC_STRUCT4(a,b,c,d)                                  {a,b,c,d}
#define DC_STRUCT5(a,b,c,d,e)                              {a,b,c,d,e}
#define DC_STRUCT6(a,b,c,d,e,f)                          {a,b,c,d,e,f}
#define DC_STRUCT7(a,b,c,d,e,f,g)                      {a,b,c,d,e,f,g}
#define DC_STRUCT8(a,b,c,d,e,f,g,h)                  {a,b,c,d,e,f,g,h}
#define DC_STRUCT9(a,b,c,d,e,f,g,h,i)              {a,b,c,d,e,f,g,h,i}
#define DC_STRUCT10(a,b,c,d,e,f,g,h,i,j)         {a,b,c,d,e,f,g,h,i,j}
#define DC_STRUCT11(a,b,c,d,e,f,g,h,i,j,k)     {a,b,c,d,e,f,g,h,i,j,k}
#define DC_STRUCT12(a,b,c,d,e,f,g,h,i,j,k,l) {a,b,c,d,e,f,g,h,i,j,k,l}
#define DC_STRUCT13(a,b,c,d,e,f,g,h,i,j,k,l,m)                       \
                                           {a,b,c,d,e,f,g,h,i,j,k,l,m}
#define DC_STRUCT14(a,b,c,d,e,f,g,h,i,j,k,l,m,n)                     \
                                         {a,b,c,d,e,f,g,h,i,j,k,l,m,n}
#define DC_STRUCT15(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o)                   \
                                       {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o}
#define DC_STRUCT16(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p)                 \
                                     {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p}
#define DC_STRUCT17(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q)               \
                                   {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q}
#define DC_STRUCT18(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r)             \
                                 {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r}
#define DC_STRUCT19(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s)           \
                               {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s}
#define DC_STRUCT20(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t)         \
                             {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t}
#define DC_STRUCT21(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u)       \
                           {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u}
#define DC_STRUCT22(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v)     \
                           {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v}
#define DC_STRUCT23(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w)   \
                           {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w}
#define DC_STRUCT24(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x) \
                           {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x}
#define DC_STRUCT27(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,aa) \
                      {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,aa}
#define DC_STRUCT31(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z, \
                              aa,bb,cc,dd,ee) \
                      {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z, \
                              aa,bb,cc,dd,ee}
#define DC_STRUCT35(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,aa, \
                              bb,cc,dd,ee,ff,gg,hh,ii)                   \
                      {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z, \
                              aa,bb,cc,dd,ee,ff,gg,hh,ii}
#define DC_STRUCT64(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,aa, \
                              bb,cc,dd,ee,ff,gg,hh,ii,jj,kk,ll,mm,nn,oo,    \
                              pp,qq,rr,ss,tt,uu,vv,ww,xx,yy,zz,ab,ac,ad,ae, \
                              af,ag,ah,ai,aj,ak,al,am)                      \
                      {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z, \
                              aa,bb,cc,dd,ee,ff,gg,hh,ii,jj,kk,ll,mm,nn,oo, \
                              pp,qq,rr,ss,tt,uu,vv,ww,xx,yy,zz,ab,ac,ad,ae, \
                              af,ag,ah,ai,aj,ak,al,am}


/****************************************************************************/
/* The extern declarations macros...                                        */
/****************************************************************************/
#define DCI_EXTERN_DATA(TYPE, Name, VAL)              extern TYPE Name
#define DCI_EXTERN_DATA_NULL(TYPE, Name, VAL)         extern TYPE Name
#define DCI_EXTERN_DATA_ARRAY(TYPE, Name, Size, VAL)  extern TYPE Name[Size]
#define DCI_EXTERN_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)             \
                                                extern TYPE Name[Size1][Size2]
#define DCI_EXTERN_CONST_DATA_ARRAY(TYPE, Name, Size, VAL)                  \
                                                extern const TYPE Name[Size]
#define DCI_EXTERN_CONST_DATA(TYPE, Name, VAL)  extern const TYPE Name
#define DCI_EXTERN_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)       \
                                         extern const TYPE Name[Size1][Size2]

/****************************************************************************/
/* The no-op macros...                                                      */
/****************************************************************************/
#define DCI_NO_DATA(TYPE, Name, VAL)
#define DCI_NO_DATA_NULL(TYPE, Name, VAL)
#define DCI_NO_DATA_ARRAY(TYPE, Name, Size, VAL)
#define DCI_NO_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)

/****************************************************************************/
/* The declaration macros...                                                */
/****************************************************************************/
#define DCI_DEFINE_DATA(TYPE, Name, VAL)              TYPE Name
#define DCI_DEFINE_DATA_NULL(TYPE, Name, VAL)         TYPE Name
#define DCI_DEFINE_DATA_ARRAY(TYPE, Name, Size, VAL)  TYPE Name[Size]
#define DCI_DEFINE_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)            \
                                                       TYPE Name[Size1][Size2]
#define DCI_DEFINE_CONST_DATA(TYPE, Name, VAL)        static const TYPE Name
#define DCI_DEFINE_CONST_DATA_ARRAY(TYPE, Name, Size, VAL)      \
                                                  static const TYPE Name[Size]
#define DCI_DEFINE_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL)      \
                                          static const TYPE Name[Size1][Size2]


/****************************************************************************/
/* The define-and-assign macros...                                          */
/****************************************************************************/
#define DCI_INIT_DATA(TYPE, Name, VAL)              TYPE  Name = VAL
#define DCI_INIT_DATA_NULL(TYPE, Name, VAL)         TYPE  Name = VAL
#define DCI_INIT_DATA_ARRAY(TYPE, Name, Size, VAL)  TYPE  Name[Size] = { VAL }
#define DCI_INIT_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL) \
                                            TYPE  Name[Size1][Size2] = { VAL }

#if defined(VER_CPP) && !defined(DC_IN_CLASS)
/****************************************************************************/
/* The version for App Serving files outside of the class.                  */
/****************************************************************************/
#define DCI_INIT_CONST_DATA(TYPE, Name, VAL)  \
                                       extern const TYPE SHCLASS Name = VAL
#define DCI_INIT_CONST_DATA_ARRAY(TYPE, Name, Size, VAL) \
                                 extern const TYPE SHCLASS Name[Size] = VAL
#define DCI_INIT_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL) \
                         extern const TYPE SHCLASS Name[Size1][Size2] = VAL

#else /* ! VER_CPP     */
/****************************************************************************/
/* The vanilla C version                                                    */
/****************************************************************************/
#define DCI_INIT_CONST_DATA(TYPE, Name, VAL)  const TYPE SHCLASS Name = VAL
#define DCI_INIT_CONST_DATA_ARRAY(TYPE, Name, Size, VAL) \
                                        const TYPE SHCLASS Name[Size] = VAL
#define DCI_INIT_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL) \
                                const TYPE SHCLASS Name[Size1][Size2] = VAL

#endif /* VER_CPP     */

/****************************************************************************/
/* The procedural code initialisation macros...                             */
/****************************************************************************/
#define DCI_ASSIGN_DATA(TYPE, Name, VAL)     Name = VAL
#define DCI_ASSIGN_DATA_NULL(TYPE, Name, VAL)                   Error!
#define DCI_ASSIGN_DATA_ARRAY_NULL(TYPE, Name, Size, VAL)       Error!
#define DCI_ASSIGN_DATA_ARRAY(TYPE, Name, Size, VAL)            Error!
#define DCI_ASSIGN_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, VAL) Error!

/****************************************************************************/
/* The memcpy and memset initialisation macros...                           */
/****************************************************************************/
#define DCI_SET_DATA_NULL(TYPE, Name, VAL)  DC_MEMSET(&Name, 0, sizeof(TYPE))
#define DCI_SET_DATA_ARRAY_NULL(TYPE, Name, Size, VAL)       \
                                     DC_MEMSET(&Name, 0, Size*sizeof(TYPE))
#define DCI_SET_DATA_ARRAY_VAL(TYPE, Name, Size, VAL)        \
                                     DC_MEMSET(&Name, VAL, Size*sizeof(TYPE))

#endif /*H_WDCGDATA*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\inc\wutint.h ===
/**INC+**********************************************************************/
/* Header:    wutint.h                                                      */
/*                                                                          */
/* Purpose:   Utilities internal defintions - Windows specific              */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 *  $Log:   Y:/logs/client/wutint.h_v  $
 * 
 *    Rev 1.3   03 Jul 1997 11:57:42   AK
 * SFR0000: Initial development completed
 * 
 *    Rev 1.1   25 Jun 1997 14:22:42   KH
 * Win16Port: Generic windows utilities header
/*                                                                          */
/**INC-**********************************************************************/
#ifndef _H_WUTINT
#define _H_WUTINT

/****************************************************************************/
/* Include platform specific stuff.                                         */
/****************************************************************************/
#include <nutint.h>

#endif /* _H_WUTINT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\msrdprc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by msrdprcdev.rc
//
#define IDC_CHECK_ENABLE_DRIVES2        7002

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\inc\wuiids.h ===
/****************************************************************************/
// wuiids.h
//
// UI identifiers
//
// Copyright(C) Microsoft Corporation 1997-1998
/****************************************************************************/

/****************************************************************************/
/* Menu Ids                                                                 */
/****************************************************************************/

#define UI_IDM_UIMENU                        100

#define UI_IDM_CONNECT                       101
#define UI_IDM_DISCONNECT                    102
#define UI_IDM_EXIT                          103

#define UI_IDM_ACCELERATOR_PASSTHROUGH       104

#define UI_IDM_HELP_CONTENTS                 106
#define UI_IDM_HELP_SEARCH                   107
#define UI_IDM_HELP_ON_HELP                  108
#define UI_IDM_ABOUT                         109

#define UI_IDM_SMOOTHSCROLLING               110
#define UI_IDM_SHADOWBITMAPENABLED           111
#define UI_IDM_HELP_ON_CLIENT                112

/****************************************************************************/
/* Debug menu items.  (e.g.  random malloc failure and network throughput   */
/* menu items.)                                                             */
/****************************************************************************/

#define UI_IDM_HATCHBITMAPPDUDATA            130
#define UI_IDM_HATCHSSBORDERDATA             131
#define UI_IDM_HATCHMEMBLTORDERDATA          132
#define UI_IDM_HATCHINDEXPDUDATA             133

#ifdef DC_DEBUG

    #define UI_IDM_LABELMEMBLTORDERS             134
    #define UI_IDM_BITMAPCACHEMONITOR            135
    #define UI_IDM_MALLOCFAILURE                 136
    #define UI_IDM_MALLOCHUGEFAILURE             137
    #define UI_IDM_NETWORKTHROUGHPUT             138
    #define UI_IDM_DUCATI_WSB                    139
    #define UI_IDM_WSB                           140
    #define UI_IDM_SVENSKA                       141
    #define UI_IDM_NOISEFUND                     142
    #define UI_IDM_SOUNDS                        143
    #define UI_IDM_ITALIAN                       144

#endif /* DC_DEBUG */

#ifdef SMART_SIZING
#define UI_IDM_SMARTSIZING                  145
#endif // SMART_SIZING

/****************************************************************************/
/* Dialog boxes                                                             */
/****************************************************************************/
#define UI_IDD_CONNECT                       400
#define UI_IDD_ABOUT                         401
#define UI_IDD_DISCONNECTING                 402
#define UI_IDD_DISCONNECTED                  403
#define UI_IDD_SHUTTING_DOWN                 404
#define UI_IDD_RDC_SECURITY_WARN             405

#ifdef DC_DEBUG
#define UI_IDD_MALLOCFAILURE                 406
#define UI_IDD_MALLOCHUGEFAILURE             407
#define UI_IDD_NETWORKTHROUGHPUT             408
#endif /* DC_DEBUG */

#define UI_IDD_CONNECTING                    410
#define UI_IDD_CONNECTION                    411
//Settings Dialog
#define UI_IDD_SETTINGS                      412
#define UI_IDD_HELP                          413
#define UI_IDD_BITMAPCACHEERROR              414

// Wince Dialog Box (non-WBT)
#define UI_IDD_CONNECTION_WINCE2             415

//
// Initial logon dialog
//
#define UI_IDD_TS_LOGON                      416
//
// More version
//
#define UI_IDD_PROPPAGE_GENERAL              417
#define UI_IDD_PROPPAGE_DISPLAY              418
#define UI_IDD_PROPPAGE_LOCALRESOURCES       419
#define UI_IDD_PROPPAGE_RUN                  420
#define UI_IDD_PROPPAGE_PERF                 421
#define IDD_DIALOG_BROWSESERVERS             422

#ifdef OS_WINCE
#define UI_IDD_TS_LOGON_VGA                  425
#define UI_IDD_PROPPAGE_GENERAL_VGA          426
#define UI_IDD_PROPPAGE_DISPLAY_VGA          427
#define UI_IDD_PROPPAGE_LOCALRESOURCES_VGA   428
#define UI_IDD_PROPPAGE_RUN_VGA              429
#define UI_IDD_PROPPAGE_PERF_VGA             430
#define IDD_DIALOG_BROWSESERVERS_VGA         431
#endif
/****************************************************************************/
/* Dialog info                                                              */
/****************************************************************************/

#define UI_ID_NEWSESSION_CANCEL              601
#define UI_ID_NEWSESSION_OK                  602

#define UI_ID_DISCONNECT_NO                  603
#define UI_ID_DISCONNECT_YES                 604

#define UI_ID_SHUTDOWN_YES                   605

#define UI_ID_ABOUT_OK                       606
#define UI_ID_HELP                           607
#define UI_ID_ABOUT                          608
#define UI_ID_HELP_CONNECT                   609
#define UI_ID_HELP_DISCONNECTED              610
#define UI_ID_HELP_DISCONNECTING             611


#define UI_ID_DISCONNECTED_OK                612
#define UI_ID_DISCONNECTED_STRING            613
#define UI_ID_DISCONNECTED_ERROR_STRING      614

#ifdef DC_DEBUG
#define UI_IDB_MALLOCFAILURE_OK              615
#define UI_IDB_MALLOCHUGEFAILURE_OK          616
#define UI_IDB_NETWORKTHROUGHPUT_OK          617
#endif /* DC_DEBUG */
#define UI_ID_CANCELCONNECT                  618
#define UI_IDB_BRANDIMAGE                    619
#define UI_IDB_COLOR24                       620
#define UI_IDB_COLOR16                       621
#define UI_IDB_COLOR8                        622
#define UI_IDB_COLOR8_DITHER                 623
#define UI_IDB_BRANDIMAGE_16                 624
#define UI_IDB_PROGRESS_BAND8                625
#define UI_IDB_PROGRESS_BAND4                626


#define UI_ID_BUILDNUMBER_STRING             630
#define UI_ID_VERSIONBUILD_STRING            631

#define UI_IDC_ADDRESS                       650
#define UI_IDC_SHADOW_BITMAP                 651

#ifdef DC_DEBUG
#define UI_IDC_RANDOMFAILURE_EDIT            652
#define UI_IDC_NETWORKTHROUGHPUT_EDIT        653
#endif /* DC_DEBUG */

#define UI_IDC_SERVER                        654
#define UI_IDC_RESOLUTION                    655
#define UI_IDC_CONNECT                       656
#define UI_IDC_SETTINGS                      659
#define UI_IDC_SERVERS_LIST                  660
#define UI_IDD_VALIDATE                      661
#define UI_IDC_CONN_STATIC                   662
#define UI_IDC_SERVERS_TREE                  663
#define UI_IDC_COMPUTER_NAME_STATIC          670
#define UI_IDC_MAIN_OPTIMIZE_STATIC          672

#ifdef OS_WIN32
#define UI_LB_POPULATE_START WM_APP+0x100 //message used only by the browse for srv tree
#define UI_LB_POPULATE_END   WM_APP+0x101 //message used only by the browse for srv tree
#endif //OS_WIN32
#define UI_SHOW_DISC_ERR_DLG WM_APP+0x102


//Settings Dialog Box
#define UI_ID_SETTINGS_OK                               680
#define UI_ID_SETTINGS_CANCEL                           681
#define UI_IDC_SETTINGS_DESKTOPSIZE                     682
#define UI_IDC_SETTINGS_600x480                         683
#define UI_IDC_SETTINGS_800x600                         684
#define UI_IDC_SETTINGS_STATIC_ENCRYPTION               685
#define UI_IDC_SETTINGS_ENABLE                          686
#define UI_IDC_SETTINGS_DISABLE                         687
#define UI_IDC_SETTINGS_1024x768                        688
#define UI_IDC_SETTINGS_1280x1024                       689
#define UI_IDC_SETTINGS_ADVANCED                        690
#define UI_IDC_SETTINGS_SCROLLING                       691
#define UI_IDC_SETTINGS_KEYPASSTHROUGH                  692
#define UI_IDC_SETTINGS_SHADOW                          693
#define UI_IDC_SETTINGS_HOTKEY                          694
#define UI_IDC_STATIC_SETTINGS_HOTKEY                   695

#define UI_ID_CIPHER_STRENGTH                           696
#define UI_ID_CONTROL_VERSION                           697
/****************************************************************************/
/* Screen Size info.  These must be in order, and contiguous.               */
/* 700-710 reserved for this purpose.                                       */
/****************************************************************************/
#define UI_IDC_SMALLEST_DESKTOP_SIZE      700
#define UI_SIZE_ID_FROM_INDEX(x)          (UI_IDC_SMALLEST_DESKTOP_SIZE + (x))
#define UI_INDEX_FROM_SIZE_ID(x)          ((x) - UI_IDC_SMALLEST_DESKTOP_SIZE)
#define UI_IDC_640x480                    UI_SIZE_ID_FROM_INDEX(0)
#define UI_IDC_800x600                    UI_SIZE_ID_FROM_INDEX(1)
#define UI_IDC_1024x768                   UI_SIZE_ID_FROM_INDEX(2)
#define UI_IDC_1280x1024                  UI_SIZE_ID_FROM_INDEX(3)
#define UI_IDC_1600x1200                  UI_SIZE_ID_FROM_INDEX(4)
#define UI_NUMBER_DESKTOP_SIZE_IDS        5
#define UI_DESKTOP_ID_ILLEGAL             -1

#define UI_IDC_STATIC                     -1
#define UI_IDC_HELPTEXT                   730


//
// Minimal Connect dialog box
//
#define IDC_COMBO_SERVERS                    901
#define ID_BUTTON_LOGON_HELP                 902
#define ID_BUTTON_OPTIONS                    903
#define IDC_COMBO_MAIN_OPTIMIZE              904

//
// Advanced connection options
//
#define IDC_TABS                             1005
#define ID_BUTTON_LOGON_OPTIONS_HELP         1006

//
// General prop page
//
#define IDC_GENERAL_COMBO_SERVERS            1007

#define IDC_GENERAL_EDIT_USERNAME            1009
#define IDC_GENERAL_EDIT_PASSWORD            1010
#define IDC_GENERAL_EDIT_DOMAIN              1011
#define IDC_GENERAL_CHECK_SAVE_PASSWORD      1012
#define IDC_BUTTON_OPEN                      1013
#define IDC_BUTTON_SAVE                      1014
#define IDC_STATIC_PASSWORD                  1015

//
// Local resources prop page
//

#define IDC_RES_SLIDER                       1113
#define IDC_COMBO_COLOR_DEPTH                1114
#define IDC_CHECK_LOCAL_DRIVES               1115
#define IDC_LABEL_SCREENRES                  1116
#define IDC_COLORPREVIEW                     1117
#define IDC_COMBO_SEND_KEYS                  1118
#define IDC_COMBO_SOUND_OPTIONS              1119
#define IDC_CHECK_REDIRECT_DRIVES            1120
#define IDC_CHECK_REDIRECT_PRINTERS          1121
#define IDC_CHECK_REDIRECT_COM               1122
#define IDC_CHECK_REDIRECT_SMARTCARD         1123
#define IDC_CHECK_DISPLAY_BBAR               1124


#define IDC_STATIC_LOGO_BMP                  1125

#define IDC_SETUP_PRINTER                    1126
//
// Run prop page
//
#define IDC_CHECK_START_PROGRAM              1130
#define IDC_EDIT_STARTPROGRAM                1131
#define IDC_EDIT_WORKDIR                     1132
#define IDC_STATIC_STARTPROGRAM              1133
#define IDC_STATIC_WORKDIR                   1134


//
// Advanced prop page
//
#define UI_IDC_STATIC_CHOOSE_SPEED           1140
#define IDC_COMBO_PERF_OPTIMIZE              1141
#define UI_IDC_STATIC_OPTIMIZE_PERF          1142
#define IDC_CHECK_DESKTOP_BKND               1143
#define IDC_CHECK_SHOW_FWD                   1144
#define IDC_CHECK_MENU_ANIMATIONS            1145
#define IDC_CHECK_THEMES                     1146
#define IDC_CHECK_BITMAP_CACHING             1147
#define IDC_CHECK_ENABLE_ARC                 1148

#ifdef PROXY_SERVER
#define IDC_GENERAL_EDIT_PROXYSERVER         1150
#endif //PROXY_SERVER

//
// Security redirection warning dialog
//
#define UI_IDC_STATIC_DEVICES                1200
#define UI_IDC_CHECK_NOPROMPT                1201

/****************************************************************************/
/* Icon                                                                     */
/****************************************************************************/
#define UI_IDI_MSTSC_ICON                        100
#define UI_IDI_ICON                              101
#define UI_IDI_PORT_ICON                         403
#define UI_IDI_COMPUTER                          402
#define UI_IDI_INFO_ICON                         401
#define UI_IDI_ERROR_ICON                        400
#define UI_IDI_WARN_ICON                         399
#define UI_IDB_BIKE1                             398
#define UI_IDB_BIKE2                             397
#define UI_IDB_FOGGY                             396
#define UI_IDB_SERVER                            393
#define UI_IDC_WARNING_ICON_HOLDER               392
#define UI_IDI_COOLPC_ICON                       391
#define UI_IDI_FOLDER_ICON                       390
#define UI_IDI_SOUND_ICON                        389
#define UI_IDI_KEYBOARD_ICON                     388
#define UI_IDI_DRIVE_ICON                        387
#define UI_IDI_MONITOR_ICON                      386
#define UI_CONNECT_ANIM                          385


//
// Icons for browse for servers UI
//
#define UI_IDI_DOMAIN                            380
#define UI_IDI_SERVER                            381




/****************************************************************************/
/* UI String IDs                                                            */
/****************************************************************************/

#define UI_IDS_INITIALIZING                      1000
#define UI_IDS_PRESS_ENTER                       1001
#define UI_IDS_CONNECTING                        1002
#define UI_IDS_FRAME_TITLE_DISCONNECTED          1003
#define UI_IDS_APP_NAME                          1004
#define UI_IDS_FRAME_TITLE_CONNECTED             1005
#define UI_IDS_FRAME_TITLE_CONNECTED_DEFAULT     1006

#define UI_IDS_BUILDNUMBER                       1007
#define UI_IDS_SHELL_VERSION                     1008
#define UI_IDS_CONTROL_VERSION                   1009

#define UI_IDS_DISCONNECT_REMOTE_BY_SERVER       1010
#define UI_IDS_LOW_MEMORY                        1011
#define UI_IDS_SECURITY_ERROR                    1012
#define UI_IDS_BAD_SERVER_NAME                   1013
#define UI_IDS_CONNECT_FAILED_PROTOCOL           1014
#define UI_IDS_NETWORK_ERROR                     1015
#define UI_IDS_INTERNAL_ERROR                    1016
#define UI_IDS_NOT_RESPONDING                    1017
#define UI_IDS_VERSION_MISMATCH                  1018
#define UI_IDS_ENCRYPTION_ERROR                  1019
#define UI_IDS_PROTOCOL_ERROR                    1020
#define UI_IDS_ILLEGAL_SERVER_NAME               1021
#define UI_IDS_HELP_TEXT                         1022
#define UI_IDS_CIPHER_STRENGTH                   1023
#define UI_IDS_ERR_LOADINGCONTROL                1024
#define UI_IDS_ERR_DLLNOTFOUND                   1025
#define UI_IDS_ERR_DLLBADVERSION                 1026
#define UI_IDS_CMD_LINE_USAGE                    1027
#define UI_IDS_ERR_FILEDOESNOTEXIST              1028
#define UI_IDS_ERR_CREATE_REMDESKS_FOLDER        1029
#define UI_IDS_ERR_OPEN_FILE                     1030
#define UI_IDS_ERR_SAVE                          1031
#define UI_IDS_ERR_LOAD                          1032
#define UI_IDS_ERR_CONNECTCALLFAILED             1033
#define UI_IDS_ERR_GETPATH_TO_DEFAULT_FILE       1034
#define UI_IDS_ERR_INITDEFAULT                   1035
#define UI_IDS_MYDOCUMENTS                       1036
#define UI_IDS_USAGE_TITLE                       1037
#define UI_IDS_CANNOT_LOOPBACK_CONNECT           1038
#define UI_IDS_PATHTOLONG                        1039
#define UI_IDS_LOCALPRINTDOCNAME                 1040
#define UI_IDS_NOHTMLHELP                        1041
#define UI_IDS_MSG_PASSNOTSAVED                  1042
#define UI_IDS_ERR_INVALID_CONNECTION_FILE       1043
#define UI_IDS_FIPS_ERROR                        1044   


#define UI_IDS_CONNECTION_TIMEOUT                1051
#define UI_IDC_CHECKBOX                          1052
#define UI_IDC_CONNECTION                        1053
#define UI_IDS_CONNECTING_TO_SERVER              1054
#define UI_IDS_NO_TERMINAL_SERVER                1055
#define UI_IDC_BITMAP_PERSISTENCE                1056
#define UI_IDS_CONNECTION_BROKEN                 1057
#define UI_IDS_DISCONNECT_REMOTE_BY_SERVER_TOOL  1058
#define UI_IDS_DISCONNECT_BYOTHERCONNECTION      1059
#define UI_IDS_LOGOFF_REMOTE_BY_SERVER           1060

#define UI_IDS_IME_NAME_JPN                      1065
#define UI_IDS_IME_NAME_KOR                      1066
#define UI_IDS_IME_NAME_CHT                      1067
#define UI_IDS_IME_NAME_CHS                      1068

#define UI_IDS_OPTIONS_MORE                      1070
#define UI_IDS_OPTIONS_LESS                      1071

#define UI_IDS_COLOR_4bpp                        1073
#define UI_IDS_COLOR_256                         1074
#define UI_IDS_COLOR_15bpp                       1075
#define UI_IDS_COLOR_16bpp                       1076
#define UI_IDS_COLOR_24bpp                       1077

#define UI_IDS_SUPPORTED_RES                     1078
#define UI_IDS_FULLSCREEN                        1079
#define UI_IDS_SENDKEYS_FSCREEN                  1080
#define UI_IDS_SENDKEYS_ALWAYS                   1081
#define UI_IDS_SENDKEYS_NEVER                    1082

#define UI_IDS_PLAYSOUND_LOCAL                   1083
#define UI_IDS_PLAYSOUND_REMOTE                  1084
#define UI_IDS_PLAYSOUND_NOSOUND                 1085

#define UI_IDS_BROWSE_FOR_COMPUTERS              1086

#define UI_IDS_GENERAL_TAB_NAME                  1087
#define UI_IDS_DISPLAY_TAB_NAME                  1088
#define UI_IDS_LOCAL_RESOURCES_TAB_NAME          1089
#define UI_IDS_RUN_TAB_NAME                      1090
#define UI_IDS_PERF_TAB_NAME                     1091

#define UI_IDS_REMOTE_DESKTOP_FILES              1092

#define UI_IDS_CLOSE_TEXT                        1094

#define UI_IDS_DISCONNECT_IDLE_TIMEOUT           1095
#define UI_IDS_DISCONNECT_LOGON_TIMEOUT          1096
#define UI_IDS_DISCONNECTED_CAPTION              1097
//Informative protcol error with additional status
#define UI_IDS_PROTOCOL_ERROR_WITH_CODE          1098
#define UI_IDS_LICENSING_TIMEDOUT                1099
#define UI_IDS_LICENSING_NEGOT_FAILED            1100
#define UI_IDS_SERVER_OUT_OF_MEMORY              1101

// Server licensing errors
#define UI_IDS_LICENSE_INTERNAL                  1102
#define UI_IDS_LICENSE_NO_LICENSE_SERVER         1103
#define UI_IDS_LICENSE_NO_LICENSE                1104
#define UI_IDS_LICENSE_BAD_CLIENT_MSG            1105
#define UI_IDS_LICENSE_HWID_DOESNT_MATCH_LICENSE 1106
#define UI_IDS_LICENSE_BAD_CLIENT_LICENSE        1107
#define UI_IDS_LICENSE_CANT_FINISH_PROTOCOL      1108
#define UI_IDS_LICENSE_CLIENT_ENDED_PROTOCOL     1109
#define UI_IDS_LICENSE_BAD_CLIENT_ENCRYPTION     1110
#define UI_IDS_LICENSE_CANT_UPGRADE_LICENSE      1111
#define UI_IDS_LICENSE_NO_REMOTE_CONNECTIONS     1112

// More disconnection messages
#define UI_IDS_SERVER_DENIED_CONNECTION          1113
#define UI_IDS_CLIENTSIDE_PROTOCOL_ERROR         1114
#define UI_IDS_CLIENT_DECOMPRESSION_FAILED       1115
#define UI_IDS_SERVER_DECRYPTION_ERROR           1116
#define UI_IDS_SERVER_DENIED_CONNECTION_FIPS     1117


#define UI_IDS_CANCEL_TEXT                       1200
#define UI_IDS_BRANDING_LINE1                    1201
#define UI_IDS_BRANDING_LINE2                    1202
#define UI_IDS_BRANDING_LN1FONT                  1203
#define UI_IDS_BRANDING_LN1SIZE                  1204
#define UI_IDS_BRANDING_LN2FONT                  1205
#define UI_IDS_BRANDING_LN2SIZE                  1206
#define UI_IDS_LINESPACING_DELTA                 1207

#define UI_IDS_OPTIMIZE_28K                      1220
#define UI_IDS_OPTIMIZE_56K                      1221
#define UI_IDS_OPTIMIZE_BROADBAND                1222
#define UI_IDS_OPTIMIZE_LAN                      1223
#define UI_IDS_OPTIMIZE_MAIN_CUSTOM              1224
#define UI_IDS_OPTIMIZE_CUSTOM                   1225

#define UI_IDS_CLIPCLEANTEMPDIR_STRING           1300
#define UI_IDS_CLIPPASTEINFO_STRING              1301

#define UI_IDS_REDIRPROMPT_DRIVES                1302
#define UI_IDS_REDIRPROMPT_PORTS                 1303

#define UI_IDS_CONNECTIONATTEMPT_STRING          1304

//
// 2000-2999 range is reserved for fatal error strings
//
//
#define UI_FATAL_ERROR_MESSAGE                   2998
#define UI_FATAL_ERR_TITLE_ID                    2999


/****************************************************************************/
/* Mstsc menu id's                                                          */
/****************************************************************************/

#define UI_MENU_MAINHELP                         3000
#define UI_MENU_CLIENTHELP                       3001
#define UI_MENU_ABOUT                            3002
#define UI_MENU_DEBUG                            3003
#define UI_MENU_BITMAPPDU                        3004
#define UI_MENU_SSBORDER                         3005
#define UI_MENU_HATCHMEMBIT                      3006
#define UI_MENU_INDEXPDU                         3007
#define UI_MENU_LABELMEMBIT                      3008
#define UI_MENU_CACHE                            3009
#define UI_MENU_MALLOC                           3010
#define UI_MENU_MALLOCHUGE                       3011
#define UI_MENU_NETWORK                          3012
#define UI_MENU_APPCLOSE                         3013

#ifdef SMART_SIZING
#define UI_MENU_SMARTSIZING                      3017
#endif // SMART_SIZING

//Acceleratrors
#define IDR_ACCELERATORS                         3014
#define IDC_NEXTTAB                              3015
#define IDC_PREVTAB                              3016

//
// MUI localized strings for
// start menu, etc. DO NOT CHANGE THESE VALUES
// without updating tsoc.inx
//
#define UI_IDS_RDC_STARTMENU_NAME                4000
#define UI_IDS_RDC_STARTMENU_TIP                 4001
#define UI_IDS_RDC_VERB_CONNECT                  4002
#define UI_IDS_RDC_VERB_EDIT                     4003
#define UI_IDS_RDC_FILETYPE                      4004
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\inc\wince.h ===
/****************************************************************************/
/* Copyright(C) Microsoft Corporation 1998                                  */
/****************************************************************************/
#ifndef _WINCE_H_
#define _WINCE_H_
#ifdef OS_WINCE
#include <windows.h>
#include <windowsx.h>
#include <stdlib.h>
#include <bldver.h>

#if defined (WIN32_PLATFORM_PSPC) || defined (WIN32_PLATFORM_HPCPRO) || defined (WIN32_PLATFORM_HPC2000)
#define WINCE_SDKBUILD
#endif

#ifndef WINCE_SDKBUILD
#include "memleak.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */


// This should work via OS
#define _stprintf   swprintf
#define sprintf     swprintf
#define _stscanf	swscanf
#define _itot       _itow
#define _ttoi       _wtoi


#if ((defined(_WCEATL_H_)) || (_WIN32_WCE >= 300))
#ifndef WINCE_GLOBAL_ALLOC_DEFINED
#define WINCE_GLOBAL_ALLOC_DEFINED
#endif
#endif

#ifndef WINCE_GLOBAL_ALLOC_DEFINED
// These are required on 2.11 builds, but not for 3.0.  All 3.0 sources should set 
// WINCE_GLOBAL_ALLOC_DEFINED to avoid obnoxious build warnings.
#define GlobalAlloc		(HGLOBAL)LocalAlloc
#define GlobalFree		(HGLOBAL)LocalFree
#define GlobalReAlloc   (HGLOBAL)LocalReAlloc
#define GlobalSize      LocalSize
#define GlobalLock(x)	(LPVOID)(x)
#define GlobalUnlock(x)	(TRUE)
#define GlobalHandle (void*)
#define	GMEM_MOVEABLE	LMEM_FIXED
#define GMEM_DDESHARE	0
#define GMEM_DISCARDABLE 0
#define GHND			0
#define GPTR			0
#endif


_CRTIMP int __cdecl swprintf(wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl swscanf(const wchar_t *, const wchar_t *, ...);
#define KF_REPEAT           0x4000

// This is here because it's easy, and I'm not sure it matters
#define KF_EXTENDED         0x0100

// May not need this if WinCE is always full screen
typedef struct tagWINDOWPLACEMENT {
    UINT  length;
    UINT  flags;
    UINT  showCmd;
    POINT ptMinPosition;
    POINT ptMaxPosition;
    RECT  rcNormalPosition;
} WINDOWPLACEMENT;
typedef WINDOWPLACEMENT *PWINDOWPLACEMENT, *LPWINDOWPLACEMENT;

_CRTIMP int __cdecl vswprintf(wchar_t *, const wchar_t *, va_list);

#define KEYEVENTF_EXTENDEDKEY 0x0001
#define MakeProcInstance(lpProc,hInstance) (lpProc)

#ifndef HandleToUlong
#define HandleToUlong( h ) ((ULONG) (h) )
#endif

#ifndef PtrToUlong
#define PtrToUlong( p ) ((ULONG) (p) )
#endif

#ifndef PtrToLong
#define PtrToLong( p ) ((LONG) (p) )
#endif

#ifndef PtrToUshort
#define PtrToUshort( p ) ((unsigned short) (p) )
#endif

#ifndef PtrToShort
#define PtrToShort( p ) ((short) (p) )
#endif


// CE isn't going to be going 64 bit anytime soon, so we'll be safe
// using the original functions for now.
#define GetWindowLongPtr(x,y) GetWindowLong(x,y)
#define SetWindowLongPtr(x,y,z) SetWindowLong(x,y,z)

#ifndef GWLP_USERDATA
#define GWLP_USERDATA GWL_USERDATA
#endif

#ifndef DWLP_USER
#define DWLP_USER DWP_USER
#endif


#define VER_PRODUCTVERSION_STR1(x,y)     L#x L"." L#y
#ifdef  VER_PRODUCTVERSION_STR
#undef  VER_PRODUCTVERSION_STR
#endif
#define VER_PRODUCTVERSION_STR           VER_PRODUCTVERSION_STR1(CE_MAJOR_VER,CE_MINOR_VER)

#define VK_PACKET         0xE7

#define WM_DRAWCLIPBOARD                0x0308

void AutoHideCE(HWND hwnd, WPARAM wParam);

#ifdef WINCE_SDKBUILD
#include "sdkbuild.h"
#endif

#ifdef WINCE_USEBRUSHCACHE
#include "brcache.h"
#else
#define BrushCacheInitialize()
#define BrushCacheUninitialize()
#define CECreateSolidBrush          CreateSolidBrush
#define CEDeleteBrush(x)            DeleteObject((HGDIOBJ )(x))
#endif

#define ETDT_DISABLE        0x00000001
#define ETDT_ENABLE         0x00000002
#define ETDT_USETABTEXTURE  0x00000004
#define ETDT_ENABLETAB      (ETDT_ENABLE  | ETDT_USETABTEXTURE)

#ifdef __cplusplus
}
#endif /* __cplusplus */
#endif // OS_WINCE
#endif // _WINCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\mstscax\actx.inc ===
!IF 0

Copyright (c) Microsoft Corporation

Module Name:

    actx.inc

!ENDIF

#
# TSACTIVEX control Defines
#

TSACTIVEX_DEFINES =\
    -D_USRDLL\
    -DTSACTIVEXCTRL\
    -DAXCTRL\
    -DUSE_BBAR

C_DEFINES = \
    $(C_DEFINES) \
    $(CLIENT_DLL_CDEFS)\
    $(TSACTIVEX_DEFINES)\
    -DVER_FULLVIEWER\
    -DDC_HICOLOR\
    -DAXCORE\
    -DDRAW_NINEGRID
    
!IFNDEF OS_WINCE
SMART_SIZING=1
!ENDIF

!IFDEF SMART_SIZING
C_DEFINES = $(C_DEFINES) -DSMART_SIZING
!ENDIF

#
# include directories
#

INCLUDES = \
    $(INCLUDES);\
    $(SDK_INC_PATH)\atl30; \
    $(TSHRCLNT_ROOT)\core; \
    $(TERMSRV_ROOT)\common\inc; \
    $(TERMSRV_ROOT)\common\license\inc; \
    $(TSHRCLNT_ROOT)\inc; \
    $(SDK_INC_PATH); \
    $(SDK_INC_PATH)\hydra; \
    $(INCLUDES)

#
# List of sources
#


TSACTIVEX_CLIENT_SOURCES_RC = \
    ..\mstscax.rc

TSACTIVEX_CLIENT_SOURCES = \
    ..\tsaxmod.cpp \
    ..\cleanup.cpp \
    ..\mstscax.cpp  \
    ..\password.cpp \
    ..\advset.cpp\
    ..\tsdbg.cpp\
    ..\securedset.cpp\
    ..\dlgbase.cpp\
    ..\securdlg.cpp\
    ..\arcmgr.cpp\
    ..\vchannel.cpp

TSACTIVEX_CLIENT_SOURCES_LAST = \
    ..\tsaxmain.cpp

SOURCES = \
    $(TSACTIVEX_CLIENT_SOURCES_RC)\
    $(TSACTIVEX_CLIENT_SOURCES)\
    $(TSACTIVEX_CLIENT_SOURCES_LAST)

SXS_ASSEMBLY_NAME=Microsoft.Windows.TerminalServer.Mstscax
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=1
SXS_MANIFEST=mstscax.dll.manifest
SXS_MANIFEST_IN_RESOURCES=1
SXS_NO_BINPLACE=1

# the resource ID here must be 2
SXS_MANIFEST_RESOURCE_ID=2

# ISOLATION_AWARE_ENABLED ==> use gdiplus
C_DEFINES=$(C_DEFINES) -DISOLATION_AWARE_ENABLED


#
# Precompiled specs
#
PRECOMPILED_INCLUDE = ..\stdafx.h
PRECOMPILED_SOURCEFILE = ..\stdafx.cpp
PRECOMPILED_CXX=1

# Additional libraries
CLIENT_LIB_DLL = \
    $(CLIENT_LIB_DLL) \
    $(SDK_LIB_PATH)\winmm.lib \
    $(WINDOWS_LIB_PATH)\cicsthkl.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\mstscax\advset.h ===
/**INC+**********************************************************************/
/* Header: advset.h                                                         */
/*                                                                          */
/* Purpose: CMstscAdvSettings class declaration                             */
/*          implements IMsRdpClientAdvancedSettings2                        */
/*            and IMsRdpClientAdvancedSettings                              */
/*            and IMsTscAdvancedSettings (for backwards compat)             */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1999-2000                             */
/*                                                                          */
/****************************************************************************/

#ifndef _ADVSET_H_
#define _ADVSET_H_


#include "atlwarn.h"
#include "wui.h"

//Header generated from IDL
#include "mstsax.h"
#include "mstscax.h"

//
// Limit timeout properties to 10 minutes
//
#define MAX_TIMEOUT_SECONDS (10*60)

/////////////////////////////////////////////////////////////////////////////
// CMsTscAx
class ATL_NO_VTABLE CMstscAdvSettings :
    public CComObjectRootEx<CComSingleThreadModel>,
    public IDispatchImpl<IMsRdpClientAdvancedSettings3,
           &IID_IMsRdpClientAdvancedSettings3, &LIBID_MSTSCLib>
{
public:
/****************************************************************************/
/* Constructor / Destructor.                                                */
/****************************************************************************/
    CMstscAdvSettings();
    ~CMstscAdvSettings();

DECLARE_PROTECT_FINAL_CONSTRUCT();
BEGIN_COM_MAP(CMstscAdvSettings)
    COM_INTERFACE_ENTRY(IMsRdpClientAdvancedSettings3)
    COM_INTERFACE_ENTRY(IMsRdpClientAdvancedSettings2)
    COM_INTERFACE_ENTRY(IMsRdpClientAdvancedSettings)
    COM_INTERFACE_ENTRY(IMsTscAdvancedSettings)
    COM_INTERFACE_ENTRY2(IDispatch,IMsRdpClientAdvancedSettings3)
END_COM_MAP()

public:
    //
    // Advanced properties
    //

    //
    // IMsTscAdvancedSettings methods
    //
    STDMETHOD(put_Compress)                   (LONG compress);
    STDMETHOD(get_Compress)                   (LONG* pcompress);
    // Incorrect spelling, shipped in TSAC
    STDMETHOD(put_BitmapPeristence)           (LONG bitmapPeristence);     
    STDMETHOD(get_BitmapPeristence)           (LONG* pbitmapPeristence);
    // End incorrect spelling
    STDMETHOD(put_allowBackgroundInput)       (LONG allowBackgroundInput);
    STDMETHOD(get_allowBackgroundInput)       (LONG* pallowBackgroundInput);
    STDMETHOD(put_KeyBoardLayoutStr)          (BSTR KeyBoardLayoutStr);
    STDMETHOD(put_PluginDlls)                 (BSTR  PluginDlls);
    STDMETHOD(put_IconFile)                   (BSTR  IconFile);
    STDMETHOD(put_IconIndex)                  (LONG  IconIndex);
    STDMETHOD(put_ContainerHandledFullScreen) (BOOL ContainerHandledFullScreen);
    STDMETHOD(get_ContainerHandledFullScreen) (BOOL* pContainerHandledFullScreen);
    STDMETHOD(put_DisableRdpdr)               (BOOL DisableRdpdr);
    STDMETHOD(get_DisableRdpdr)               (BOOL* pDisableRdpdr);


    //
    // IMsRdpClientAdvancedSettings methods
    //
    STDMETHOD(put_SmoothScroll)    (LONG smoothScroll);
    STDMETHOD(get_SmoothScroll)    (LONG* psmoothScroll);
    STDMETHOD(put_AcceleratorPassthrough)    (LONG acceleratorPassthrough);
    STDMETHOD(get_AcceleratorPassthrough)    (LONG* pacceleratorPassthrough);
    STDMETHOD(put_ShadowBitmap)    (LONG shadowBitmap);
    STDMETHOD(get_ShadowBitmap)    (LONG* pshadowBitmap);
    STDMETHOD(put_TransportType)    (LONG transportType);
    STDMETHOD(get_TransportType)    (LONG* ptransportType);
    STDMETHOD(put_SasSequence)    (LONG sasSequence);
    STDMETHOD(get_SasSequence)    (LONG* psasSequence);
    STDMETHOD(put_EncryptionEnabled)    (LONG encryptionEnabled);
    STDMETHOD(get_EncryptionEnabled)    (LONG* pencryptionEnabled);
    STDMETHOD(put_DedicatedTerminal)    (LONG dedicatedTerminal);
    STDMETHOD(get_DedicatedTerminal)    (LONG* pdedicatedTerminal);
    STDMETHOD(put_RDPPort)    (LONG RDPPort);
    STDMETHOD(get_RDPPort)    (LONG* pRDPPort);
    STDMETHOD(put_EnableMouse)    (LONG enableMouse);
    STDMETHOD(get_EnableMouse)    (LONG* penableMouse);
    STDMETHOD(put_DisableCtrlAltDel)    (LONG disableCtrlAltDel);
    STDMETHOD(get_DisableCtrlAltDel)    (LONG* pdisableCtrlAltDel);
    STDMETHOD(put_EnableWindowsKey)    (LONG enableWindowsKey);
    STDMETHOD(get_EnableWindowsKey)    (LONG* penableWindowsKey);
    STDMETHOD(put_DoubleClickDetect)    (LONG doubleClickDetect);
    STDMETHOD(get_DoubleClickDetect)    (LONG* pdoubleClickDetect);
    STDMETHOD(put_MaximizeShell)    (LONG maximizeShell);
    STDMETHOD(get_MaximizeShell)    (LONG* pmaximizeShell);
    STDMETHOD(put_HotKeyFullScreen)    (LONG hotKeyFullScreen);
    STDMETHOD(get_HotKeyFullScreen)    (LONG* photKeyFullScreen);
    STDMETHOD(put_HotKeyCtrlEsc)    (LONG hotKeyCtrlEsc);
    STDMETHOD(get_HotKeyCtrlEsc)    (LONG* photKeyCtrlEsc);
    STDMETHOD(put_HotKeyAltEsc)    (LONG hotKeyAltEsc);
    STDMETHOD(get_HotKeyAltEsc)    (LONG* photKeyAltEsc);
    STDMETHOD(put_HotKeyAltTab)    (LONG hotKeyAltTab);
    STDMETHOD(get_HotKeyAltTab)    (LONG* photKeyAltTab);
    STDMETHOD(put_HotKeyAltShiftTab)    (LONG hotKeyAltShiftTab);
    STDMETHOD(get_HotKeyAltShiftTab)    (LONG* photKeyAltShiftTab);
    STDMETHOD(put_HotKeyAltSpace)    (LONG hotKeyAltSpace);
    STDMETHOD(get_HotKeyAltSpace)    (LONG* photKeyAltSpace);
    STDMETHOD(put_HotKeyCtrlAltDel)    (LONG hotKeyCtrlAltDel);
    STDMETHOD(get_HotKeyCtrlAltDel)    (LONG* photKeyCtrlAltDel);
    STDMETHOD(put_orderDrawThreshold)    (LONG orderDrawThreshold);
    STDMETHOD(get_orderDrawThreshold)    (LONG* porderDrawThreshold);
    STDMETHOD(put_BitmapCacheSize)    (LONG bitmapCacheSize);
    STDMETHOD(get_BitmapCacheSize)    (LONG* pbitmapCacheSize);
    STDMETHOD(put_BitmapVirtualCacheSize)    (LONG bitmapVirtualCacheSize);
    STDMETHOD(get_BitmapVirtualCacheSize)    (LONG* pbitmapVirtualCacheSize);
    STDMETHOD(put_ScaleBitmapCachesByBPP) (LONG);
    STDMETHOD(get_ScaleBitmapCachesByBPP) (LONG *);
    STDMETHOD(put_NumBitmapCaches)    (LONG numBitmapCaches);
    STDMETHOD(get_NumBitmapCaches)    (LONG* pnumBitmapCaches);
    STDMETHOD(put_CachePersistenceActive)    (LONG cachePersistenceActive);
    STDMETHOD(get_CachePersistenceActive)    (LONG* pcachePersistenceActive);
    
    STDMETHOD(put_brushSupportLevel)    (LONG brushSupportLevel);
    STDMETHOD(get_brushSupportLevel)    (LONG* pbrushSupportLevel);
    STDMETHOD(put_PersistCacheDirectory)      (BSTR PersistCacheDirectory);
    STDMETHOD(put_minInputSendInterval)    (LONG minInputSendInterval);
    STDMETHOD(get_minInputSendInterval)    (LONG* pminInputSendInterval);
    STDMETHOD(put_InputEventsAtOnce)    (LONG inputEventsAtOnce);
    STDMETHOD(get_InputEventsAtOnce)    (LONG* pinputEventsAtOnce);
    STDMETHOD(put_maxEventCount)    (LONG maxEventCount);
    STDMETHOD(get_maxEventCount)    (LONG* pmaxEventCount);
    STDMETHOD(put_keepAliveInterval)    (LONG keepAliveInterval);
    STDMETHOD(get_keepAliveInterval)    (LONG* pkeepAliveInterval);
    STDMETHOD(put_shutdownTimeout)    (LONG shutdownTimeout);
    STDMETHOD(get_shutdownTimeout)    (LONG* pshutdownTimeout);
    STDMETHOD(put_overallConnectionTimeout)    (LONG overallConnectionTimeout);
    STDMETHOD(get_overallConnectionTimeout)    (LONG* poverallConnectionTimeout);
    STDMETHOD(put_singleConnectionTimeout)    (LONG singleConnectionTimeout);
    STDMETHOD(get_singleConnectionTimeout)    (LONG* psingleConnectionTimeout);
    STDMETHOD(put_KeyboardType)               (LONG keyboardType);
    STDMETHOD(get_KeyboardType)               (LONG* pkeyboardType);
    STDMETHOD(put_KeyboardSubType)            (LONG keyboardSubType);
    STDMETHOD(get_KeyboardSubType)            (LONG* pkeyboardSubType);
    STDMETHOD(put_KeyboardFunctionKey)        (LONG keyboardFunctionKey);
    STDMETHOD(get_KeyboardFunctionKey)        (LONG* pkeyboardFunctionKey);
    STDMETHOD(put_WinceFixedPalette)          (LONG winceFixedPalette);
    STDMETHOD(get_WinceFixedPalette)          (LONG* pwinceFixedPalette);
    STDMETHOD(put_ConnectToServerConsole)     (VARIANT_BOOL  connectToServerConsole);
    STDMETHOD(get_ConnectToServerConsole)     (VARIANT_BOOL* pConnectToServerConsole);
    // Correct spelling version of bitmap persistence prop (see above)
    STDMETHOD(put_BitmapPersistence)          (LONG bitmapPersistence);     
    STDMETHOD(get_BitmapPersistence)          (LONG* pbitmapPersistence);
    
    STDMETHOD(put_MinutesToIdleTimeout)       (LONG minutesToIdleTimeout);     
    STDMETHOD(get_MinutesToIdleTimeout)       (LONG* pminutesToIdleTimeout);

#ifdef SMART_SIZING
    STDMETHOD(put_SmartSizing)                (VARIANT_BOOL fSmartSize);
    STDMETHOD(get_SmartSizing)                (VARIANT_BOOL *pfSmartSize);
#endif // SMART_SIZING

    STDMETHOD(put_RdpdrLocalPrintingDocName)(BSTR RdpdrLocalPrintingDocName);
    STDMETHOD(get_RdpdrLocalPrintingDocName)(BSTR *pRdpdrLocalPrintingDocName);

    STDMETHOD(put_RdpdrClipCleanTempDirString)(BSTR RdpdrClipCleanTempDirString);
    STDMETHOD(get_RdpdrClipCleanTempDirString)(BSTR *pRdpdrClipCleanTempDirString);

    STDMETHOD(put_RdpdrClipPasteInfoString)(BSTR RdpdrClipPasteInfoString);
    STDMETHOD(get_RdpdrClipPasteInfoString)(BSTR *pRdpdrClipPasteInfoString);

    STDMETHOD(put_ClearTextPassword)          (BSTR clearTextPassword);
    STDMETHOD(put_DisplayConnectionBar)       (VARIANT_BOOL fDisplayConnectionBar);
    STDMETHOD(get_DisplayConnectionBar)       (VARIANT_BOOL *pfDisplayConnectionBar);
    STDMETHOD(put_PinConnectionBar)           (VARIANT_BOOL fPinConnectionBar);
    STDMETHOD(get_PinConnectionBar)           (VARIANT_BOOL *pfPinConnectionBar);

    STDMETHOD(put_GrabFocusOnConnect)         (VARIANT_BOOL fGrabFocusOnConnect);
    STDMETHOD(get_GrabFocusOnConnect)         (VARIANT_BOOL *pfGrabFocusOnConnect);
    STDMETHOD(put_LoadBalanceInfo)            (/*[in]*/ BSTR  newLBInfo);
    STDMETHOD(get_LoadBalanceInfo)            (/*[out,retval]*/BSTR* pLBInfo);

    //
    // Device redirection
    //
    STDMETHOD(put_RedirectDrives)             (VARIANT_BOOL  redirectDrives);
    STDMETHOD(get_RedirectDrives)             (VARIANT_BOOL* pRedirectDrives);
    STDMETHOD(put_RedirectPrinters)           (VARIANT_BOOL  redirectPrinters);
    STDMETHOD(get_RedirectPrinters)           (VARIANT_BOOL* pRedirectPrinters);
    STDMETHOD(put_RedirectPorts)              (VARIANT_BOOL  redirectPorts);
    STDMETHOD(get_RedirectPorts)              (VARIANT_BOOL* pRedirectPorts);
    STDMETHOD(put_RedirectSmartCards)         (VARIANT_BOOL  redirectScard);
    STDMETHOD(get_RedirectSmartCards)         (VARIANT_BOOL* pRedirectScard);

    //
    // Hi-Color bitmap cache sizes
    //
    STDMETHOD(put_BitmapVirtualCache16BppSize)(LONG bitmapVirtualCache16BppSize);
    STDMETHOD(get_BitmapVirtualCache16BppSize)(LONG* pBitmapVirtualCache16BppSize);
    STDMETHOD(put_BitmapVirtualCache24BppSize)(LONG bitmapVirtualCache24BppSize);
    STDMETHOD(get_BitmapVirtualCache24BppSize)(LONG* pBitmapVirtualCache24BppSize);

    STDMETHOD(put_PerformanceFlags)           (LONG DisableFeatList);
    STDMETHOD(get_PerformanceFlags)           (LONG* pDisableFeatList);
    STDMETHOD(put_ConnectWithEndpoint)        (VARIANT* ConnectionEndpoint);
    STDMETHOD(put_NotifyTSPublicKey)          (VARIANT_BOOL fNotify);
    STDMETHOD(get_NotifyTSPublicKey)          (VARIANT_BOOL* pfNotify);



    //
    // IMsRdpClientAdvancedSettings2 methods
    //

    //Autoreconnection properties
    STDMETHOD(get_CanAutoReconnect)           (VARIANT_BOOL* pfCanAutoReconnect);
    STDMETHOD(put_EnableAutoReconnect)        (VARIANT_BOOL  fEnableAutoReconnect);
    STDMETHOD(get_EnableAutoReconnect)        (VARIANT_BOOL* pfEnableAutoReconnect);

    STDMETHOD(put_MaxReconnectAttempts)       (LONG ReconnectAttempts);
    STDMETHOD(get_MaxReconnectAttempts)       (LONG* pReconnectAttempts);

    //
    // IMsRdpClientAdvancedSettings3 methods
    //
    STDMETHOD(put_ConnectionBarShowMinimizeButton)  (VARIANT_BOOL fShow);
    STDMETHOD(get_ConnectionBarShowMinimizeButton)  (VARIANT_BOOL* pfShow);

    STDMETHOD(put_ConnectionBarShowRestoreButton)   (VARIANT_BOOL fShow);
    STDMETHOD(get_ConnectionBarShowRestoreButton)   (VARIANT_BOOL* pfShow);

public:
    BOOL SetUI(CUI* pUI);
    VOID SetSafeForScripting(BOOL bSafe)            {m_bMakeSafeForScripting = bSafe;}
    BOOL GetSafeForScripting()                      {return m_bMakeSafeForScripting;}
    VOID SetInterfaceLockedForWrite(BOOL bLocked)   {m_bLockedForWrite=bLocked;}
    BOOL GetLockedForWrite()            {return m_bLockedForWrite;}

    //
    // This object is a child of the Ax control. Don't increment
    // a ref count for this reference to prevent a circular dependency
    // the reference to the parent (pAxControl) is implicit because
    // the object is a child.
    //
    VOID SetAxCtl(CMsTscAx* pAxCtl)                 {_pAxControl = pAxCtl;}


private:
    BOOL IsSecureDllList(LPCTSTR szDllList);
    LPTSTR CreateExplicitPathList(LPCTSTR szDllList);

private:
    CUI* m_pUI;
    CMsTscAx* _pAxControl;
    //
    // Flag is set by the control when these properties can not be modified
    // e.g while connected. Any calls on these properties while locked
    // result in an E_FAIL being returned.
    //
    BOOL m_bLockedForWrite;

    //
    // Flag set by control to indicate that the object must
    // be safe for scripting
    //
    BOOL m_bMakeSafeForScripting;
};

#endif //_ADVSET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\mstscax\advset.cpp ===
/**MOD+**********************************************************************/
/* Module:    advset.cpp                                                    */
/*                                                                          */
/* Class  :   CMstscAdvSettings                                             */
/*                                                                          */
/* Purpose:   Implements advanced settings for RDP ActiveX control          */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1999-2000                             */
/*                                                                          */
/* Author :  Nadim Abdo (nadima)                                            */
/****************************************************************************/

#include "stdafx.h"

#include "advset.h"
#include "atlwarn.h"
#include "securedset.h"

BEGIN_EXTERN_C
#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "advset"
#include <atrcapi.h>
END_EXTERN_C

CMstscAdvSettings::CMstscAdvSettings()
{
    m_pUI=NULL;
    m_bLockedForWrite=FALSE;
    _pAxControl = NULL;
    //
    // Default is to make self safe for scripting
    //
    m_bMakeSafeForScripting = TRUE;
}

CMstscAdvSettings::~CMstscAdvSettings()
{
}

BOOL CMstscAdvSettings::SetUI(CUI* pUI)
{
    ATLASSERT(pUI);
    if(!pUI)
    {
        return FALSE;
    }
    m_pUI = pUI;
    return TRUE;
}

//
// SmoothScroll property
//
STDMETHODIMP CMstscAdvSettings::put_SmoothScroll(LONG smoothScroll)
{
    if(GetLockedForWrite())
    {
        return E_FAIL;
    }

    m_pUI->_UI.smoothScrolling = smoothScroll != 0;
    return S_OK;
}

STDMETHODIMP CMstscAdvSettings::get_SmoothScroll(LONG* psmoothScroll)
{
    ATLASSERT(m_pUI);
    if(!psmoothScroll)
    {
        return E_POINTER;
    }

    *psmoothScroll = m_pUI->_UI.smoothScrolling;
    return S_OK;
}

//
// AcceleratorPassthrough property
//
STDMETHODIMP CMstscAdvSettings::put_AcceleratorPassthrough(LONG acceleratorPassthrough)
{
    if(GetLockedForWrite())
    {
        return E_FAIL;
    }

    m_pUI->_UI.acceleratorCheckState = acceleratorPassthrough != 0;
    return S_OK;
}

STDMETHODIMP CMstscAdvSettings::get_AcceleratorPassthrough(LONG* pacceleratorPassthrough)
{
    ATLASSERT(m_pUI);
    if(!pacceleratorPassthrough)
    {
        return E_POINTER;
    }

    *pacceleratorPassthrough = m_pUI->_UI.acceleratorCheckState;
    return S_OK;
}

//
// ShadowBitmap property
//
STDMETHODIMP CMstscAdvSettings::put_ShadowBitmap(LONG shadowBitmap)
{
    if(GetLockedForWrite())
    {
        return E_FAIL;
    }

    m_pUI->_UI.shadowBitmapEnabled = shadowBitmap != 0;
    return S_OK;
}

STDMETHODIMP CMstscAdvSettings::get_ShadowBitmap(LONG* pshadowBitmap)
{
    ATLASSERT(m_pUI);
    if(!pshadowBitmap)
    {
        return E_POINTER;
    }

    *pshadowBitmap = m_pUI->_UI.shadowBitmapEnabled;
    return S_OK;
}

//
// TransportType property
//
STDMETHODIMP CMstscAdvSettings::put_TransportType(LONG transportType)
{
    HRESULT hr = E_FAIL;
    if(GetLockedForWrite())
    {
        return E_FAIL;
    }

    //
    // Validate - property is redundant today because we only have
    // one allowed transport but we keep it for future extensibility
    //
    if (transportType == UI_TRANSPORT_TYPE_TCP) {
        m_pUI->_UI.transportType = (DCUINT16)transportType;
        hr = S_OK;
    }
    else {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDMETHODIMP CMstscAdvSettings::get_TransportType(LONG* ptransportType)
{
    ATLASSERT(m_pUI);
    if(!ptransportType)
    {
        return E_POINTER;
    }

    *ptransportType = m_pUI->_UI.transportType;
    return S_OK;
}

//
// SasSequence property
//
STDMETHODIMP CMstscAdvSettings::put_SasSequence(LONG sasSequence)
{
    if(GetLockedForWrite())
    {
        return E_FAIL;
    }

    m_pUI->_UI.sasSequence = (DCUINT16)sasSequence;
    return S_OK;
}

STDMETHODIMP CMstscAdvSettings::get_SasSequence(LONG* psasSequence)
{
    ATLASSERT(m_pUI);
    if(!psasSequence)
    {
        return E_POINTER;
    }

    *psasSequence = m_pUI->_UI.sasSequence;
    return S_OK;
}

//
// EncryptionEnabled property
//
STDMETHODIMP CMstscAdvSettings::put_EncryptionEnabled(LONG encryptionEnabled)
{
    if(GetLockedForWrite())
    {
        return E_FAIL;
    }

    m_pUI->_UI.encryptionEnabled = encryptionEnabled != 0;
    return S_OK;
}

STDMETHODIMP CMstscAdvSettings::get_EncryptionEnabled(LONG* pencryptionEnabled)
{
    ATLASSERT(m_pUI);
    if(!pencryptionEnabled)
    {
        return E_POINTER;
    }

    *pencryptionEnabled = m_pUI->_UI.encryptionEnabled;
    return S_OK;
}

//
// DedicatedTerminal property
//
STDMETHODIMP CMstscAdvSettings::put_DedicatedTerminal(LONG dedicatedTerminal)
{
    if(GetLockedForWrite())
    {
        return E_FAIL;
    }

    m_pUI->_UI.dedicatedTerminal = dedicatedTerminal != 0;
    return S_OK;
}

STDMETHODIMP CMstscAdvSettings::get_DedicatedTerminal(LONG* pdedicatedTerminal)
{
    ATLASSERT(m_pUI);
    if(!pdedicatedTerminal)
    {
        return E_POINTER;
    }

    *pdedicatedTerminal = m_pUI->_UI.dedicatedTerminal;
    return S_OK;
}

//
// MCSPort property
//
STDMETHODIMP CMstscAdvSettings::put_RDPPort(LONG RDPPort)
{
    if(GetLockedForWrite())
    {
        return E_FAIL;
    }

    if(RDPPort < 0 || RDPPort > 65535)
    {
        return E_INVALIDARG;
    }

    m_pUI->_UI.MCSPort = (DCUINT16)RDPPort;
    return S_OK;
}

STDMETHODIMP CMstscAdvSettings::get_RDPPort(LONG* pRDPPort)
{
    if(!pRDPPort)
    {
        return E_POINTER;
    }

    *pRDPPort = m_pUI->_UI.MCSPort;
    return S_OK;
}

//
// EnableMouse property
//
STDMETHODIMP CMstscAdvSettings::put_EnableMouse(LONG enableMouse)
{
    //
    // Deprecated
    //
    return S_FALSE;
}

STDMETHODIMP CMstscAdvSettings::get_EnableMouse(LONG* penableMouse)
{
    //
    // Deprecated
    //
    return S_FALSE;
}

//
// DisableCtrlAltDel property
//
STDMETHODIMP CMstscAdvSettings::put_DisableCtrlAltDel(LONG disableCtrlAltDel)
{
    if(GetLockedForWrite())
    {
        return E_FAIL;
    }

    m_pUI->_UI.fDisableCtrlAltDel = disableCtrlAltDel != 0;
    return S_OK;
}

STDMETHODIMP CMstscAdvSettings::get_DisableCtrlAltDel(LONG* pdisableCtrlAltDel)
{
    ATLASSERT(m_pUI);
    if(!pdisableCtrlAltDel)
    {
        return E_POINTER;
    }

    *pdisableCtrlAltDel = m_pUI->_UI.fDisableCtrlAltDel;
    return S_OK;
}

//
// EnableWindowsKey property
//
STDMETHODIMP CMstscAdvSettings::put_EnableWindowsKey(LONG enableWindowsKey)
{
    if(GetLockedForWrite())
    {
        return E_FAIL;
    }

    m_pUI->_UI.fEnableWindowsKey = enableWindowsKey != 0;
    return S_OK;
}

STDMETHODIMP CMstscAdvSettings::get_EnableWindowsKey(LONG* penableWindowsKey)
{
    ATLASSERT(m_pUI);
    if(!penableWindowsKey)
    {
        return E_POINTER;
    }

    *penableWindowsKey = m_pUI->_UI.fEnableWindowsKey;
    return S_OK;
}

//
// DoubleClickDetect property
//
STDMETHODIMP CMstscAdvSettings::put_DoubleClickDetect(LONG doubleClickDetect)
{
    if(GetLockedForWrite())
    {
        return E_FAIL;
    }
    m_pUI->_UI.fDoubleClickDetect = doubleClickDetect != 0;
    return S_OK;
}

STDMETHODIMP CMstscAdvSettings::get_DoubleClickDetect(LONG* pdoubleClickDetect)
{
    ATLASSERT(m_pUI);
    if(!pdoubleClickDetect)
    {
        return E_POINTER;
    }

    *pdoubleClickDetect = m_pUI->_UI.fDoubleClickDetect;
    return S_OK;
}

//
// MaximizeShell property
//
STDMETHODIMP CMstscAdvSettings::put_MaximizeShell(LONG maximizeShell)
{
    if(GetLockedForWrite())
    {
        return E_FAIL;
    }
    m_pUI->_UI.fMaximizeShell = maximizeShell != 0;
    return S_OK;
}

STDMETHODIMP CMstscAdvSettings::get_MaximizeShell(LONG* pmaximizeShell)
{
    ATLASSERT(m_pUI);
    if(!pmaximizeShell)
    {
        return E_POINTER;
    }

    *pmaximizeShell = m_pUI->_UI.fMaximizeShell;
    return S_OK;
}

//
// HotKeyFullScreen property
//
STDMETHODIMP CMstscAdvSettings::put_HotKeyFullScreen(LONG hotKeyFullScreen)
{
    if(GetLockedForWrite())
    {
        return E_FAIL;
    }
    m_pUI->_UI.hotKey.fullScreen = hotKeyFullScreen;
    return S_OK;
}

STDMETHODIMP CMstscAdvSettings::get_HotKeyFullScreen(LONG* photKeyFullScreen)
{
    ATLASSERT(m_pUI);
    if(!photKeyFullScreen)
    {
        return E_POINTER;
    }

    *photKeyFullScreen = m_pUI->_UI.hotKey.fullScreen;
    return S_OK;
}

//
// HotKeyCtrlEsc property
//
STDMETHODIMP CMstscAdvSettings::put_HotKeyCtrlEsc(LONG hotKeyCtrlEsc)
{
    if(GetLockedForWrite())
    {
        return E_FAIL;
    }
    m_pUI->_UI.hotKey.ctrlEsc = hotKeyCtrlEsc;
    return S_OK;
}

STDMETHODIMP CMstscAdvSettings::get_HotKeyCtrlEsc(LONG* photKeyCtrlEsc)
{
    ATLASSERT(m_pUI);
    if(!photKeyCtrlEsc)
    {
        return E_POINTER;
    }

    *photKeyCtrlEsc = m_pUI->_UI.hotKey.ctrlEsc;
    return S_OK;
}

//
// HotKeyAltEsc property
//
STDMETHODIMP CMstscAdvSettings::put_HotKeyAltEsc(LONG hotKeyAltEsc)
{
    if(GetLockedForWrite())
    {
        return E_FAIL;
    }
    m_pUI->_UI.hotKey.altEsc = hotKeyAltEsc;
    return S_OK;
}

STDMETHODIMP CMstscAdvSettings::get_HotKeyAltEsc(LONG* photKeyAltEsc)
{
    ATLASSERT(m_pUI);
    if(!photKeyAltEsc)
    {
        return E_POINTER;
    }

    *photKeyAltEsc = m_pUI->_UI.hotKey.altEsc;
    return S_OK;
}

//
// HotKeyAltTab property
//
STDMETHODIMP CMstscAdvSettings::put_HotKeyAltTab(LONG hotKeyAltTab)
{
    if(GetLockedForWrite())
    {
        return E_FAIL;
    }
    m_pUI->_UI.hotKey.altTab = hotKeyAltTab;
    return S_OK;
}

STDMETHODIMP CMstscAdvSettings::get_HotKeyAltTab(LONG* photKeyAltTab)
{
    ATLASSERT(m_pUI);
    if(!photKeyAltTab)
    {
        return E_POINTER;
    }

    *photKeyAltTab = m_pUI->_UI.hotKey.altTab;
    return S_OK;
}

//
// HotKeyAltShiftTab property
//
STDMETHODIMP CMstscAdvSettings::put_HotKeyAltShiftTab(LONG hotKeyAltShiftTab)
{
    if(GetLockedForWrite())
    {
        return E_FAIL;
    }                
    m_pUI->_UI.hotKey.altShifttab = hotKeyAltShiftTab;
    return S_OK;
}

STDMETHODIMP CMstscAdvSettings::get_HotKeyAltShiftTab(LONG* photKeyAltShiftTab)
{
    ATLASSERT(m_pUI);
    if(!photKeyAltShiftTab)
    {
        return E_POINTER;
    }

    *photKeyAltShiftTab = m_pUI->_UI.hotKey.altShifttab;
    return S_OK;
}

//
// HotKeyAltSpace property
//
STDMETHODIMP CMstscAdvSettings::put_HotKeyAltSpace(LONG hotKeyAltSpace)
{
    if(GetLockedForWrite())
    {
        return E_FAIL;
    }
    m_pUI->_UI.hotKey.altSpace = hotKeyAltSpace;
    return S_OK;
}

STDMETHODIMP CMstscAdvSettings::get_HotKeyAltSpace(LONG* photKeyAltSpace)
{
    ATLASSERT(m_pUI);
    if(!photKeyAltSpace)
    {
        return E_POINTER;
    }

    *photKeyAltSpace = m_pUI->_UI.hotKey.altSpace;
    return S_OK;
}

//
// HotKeyCtrlAltDel property
//
STDMETHODIMP CMstscAdvSettings::put_HotKeyCtrlAltDel(LONG hotKeyCtrlAltDel)
{
    if(GetLockedForWrite())
    {
        return E_FAIL;
    }
    m_pUI->_UI.hotKey.ctlrAltdel = hotKeyCtrlAltDel;
    return S_OK;
}

STDMETHODIMP CMstscAdvSettings::get_HotKeyCtrlAltDel(LONG* photKeyCtrlAltDel)
{
    ATLASSERT(m_pUI);
    if(!photKeyCtrlAltDel)
    {
        return E_POINTER;
    }

    *photKeyCtrlAltDel = m_pUI->_UI.hotKey.ctlrAltdel;
    return S_OK;
}

//
// Compress property
//
STDMETHODIMP CMstscAdvSettings::put_Compress(LONG compress)
{
    if(GetLockedForWrite())
    {
        return E_FAIL;
    }
    m_pUI->UI_SetCompress(compress != 0);
    return S_OK;
}

STDMETHODIMP CMstscAdvSettings::get_Compress(LONG* pcompress)
{
    ATLASSERT(m_pUI);
    if(!pcompress)
    {
        return E_POINTER;
    }

    *pcompress = m_pUI->UI_GetCompress();
    return S_OK;
}

//
// BitmapPeristence property
//
STDMETHODIMP CMstscAdvSettings::put_BitmapPeristence(LONG bitmapPeristence)
{
    if(GetLockedForWrite())
    {
        return E_FAIL;
    }
    m_pUI->_UI.fBitmapPersistence = (bitmapPeristence != 0);
    return S_OK;
}

STDMETHODIMP CMstscAdvSettings::get_BitmapPeristence(LONG* pbitmapPeristence)
{
    ATLASSERT(m_pUI);
    if(!pbitmapPeristence)
    {
        return E_POINTER;
    }

    *pbitmapPeristence = m_pUI->_UI.fBitmapPersistence;
    return S_OK;
}

//
// BitmapPersistence property
//
STDMETHODIMP CMstscAdvSettings::put_BitmapPersistence(LONG bitmapPersistence)
{
    //Call on older incorrectly spelled property
    return put_BitmapPeristence(bitmapPersistence);
}

STDMETHODIMP CMstscAdvSettings::get_BitmapPersistence(LONG* pbitmapPersistence)
{
    //Call on older incorrectly spelled property
    return get_BitmapPeristence(pbitmapPersistence);
}


//
////////////////////////////////////////////////////////////////////////////////////

//
// orderDrawThreshold property
//
STDMETHODIMP CMstscAdvSettings::put_orderDrawThreshold(LONG orderDrawThreshold)
{
    //
    // Deprecated
    //
    return S_FALSE;
}

STDMETHODIMP CMstscAdvSettings::get_orderDrawThreshold(LONG* porderDrawThreshold)
{
    //
    // Deprecated
    //
    return S_FALSE;
}

//
// BitmapCacheSize property
//
STDMETHODIMP CMstscAdvSettings::put_BitmapCacheSize(LONG bitmapCacheSize)
{
    if(GetLockedForWrite())
    {
        return E_FAIL;
    }

#ifndef OS_WINCE
    if (bitmapCacheSize > 0 && bitmapCacheSize <= TSC_MAX_BITMAPCACHESIZE)
#else	//bitmap cache size is measured in KB and TSC_MAX_BITMAPCACHESIZE is in MB
    if (bitmapCacheSize > 0 && bitmapCacheSize <= TSC_MAX_BITMAPCACHESIZE*1024)	
#endif
    {
        m_pUI->_UI.RegBitmapCacheSize = bitmapCacheSize;
        return S_OK;
    }
    else
    {
        return E_INVALIDARG;
    }
}

STDMETHODIMP CMstscAdvSettings::get_BitmapCacheSize(LONG* pbitmapCacheSize)
{
    ATLASSERT(m_pUI);
    if(!pbitmapCacheSize)
    {
        return E_POINTER;
    }

    *pbitmapCacheSize = m_pUI->_UI.RegBitmapCacheSize;
    return S_OK;
}

//
// BitmapVirtualCacheSize property
//
// TSAC's v1.0 only property for cache file size.
// In whistler applies to 8bpp cache file
// See BitmapVirtualCache16BppSize/24BppSize methods
//
STDMETHODIMP CMstscAdvSettings::put_BitmapVirtualCacheSize(
                                    LONG bitmapVirtualCacheSize)
{
    if(GetLockedForWrite())
    {
        return E_FAIL;
    }

    if (bitmapVirtualCacheSize > 0 &&
        bitmapVirtualCacheSize <= TSC_MAX_BITMAPCACHESIZE)
    {
        m_pUI->_UI.RegBitmapVirtualCache8BppSize = bitmapVirtualCacheSize;
    }
    else
    {
        return E_INVALIDARG;
    }
    
    return S_OK;
}

STDMETHODIMP CMstscAdvSettings::get_BitmapVirtualCacheSize(
                                    LONG* pbitmapVirtualCacheSize)
{
    if(!pbitmapVirtualCacheSize)
    {
        return E_POINTER;
    }

    *pbitmapVirtualCacheSize = m_pUI->_UI.RegBitmapVirtualCache8BppSize;
    return S_OK;
}


//
// ScaleBitmapCachesByBPP property
//
STDMETHODIMP CMstscAdvSettings::put_ScaleBitmapCachesByBPP(LONG bScale)
{
    //
    // Deprecated
    //
    return S_FALSE;
}

STDMETHODIMP CMstscAdvSettings::get_ScaleBitmapCachesByBPP(LONG *pbScale)
{
    //
    // Deprecated
    //
    return S_FALSE;
}


//
// NumBitmapCaches property
//
STDMETHODIMP CMstscAdvSettings::put_NumBitmapCaches(LONG numBitmapCaches)
{
    //
    // Deprecated
    //
    return S_FALSE;
}

STDMETHODIMP CMstscAdvSettings::get_NumBitmapCaches(LONG* pnumBitmapCaches)
{
    //
    // Deprecated
    //
    return S_FALSE;
}

//
// CachePersistenceActive property
//
STDMETHODIMP CMstscAdvSettings::put_CachePersistenceActive(LONG cachePersistenceActive)
{
    if(GetLockedForWrite())
    {
        return E_FAIL;
    }
    m_pUI->_UI.RegPersistenceActive = cachePersistenceActive != 0;
    return S_OK;
}

STDMETHODIMP CMstscAdvSettings::get_CachePersistenceActive(LONG* pcachePersistenceActive)
{
    ATLASSERT(m_pUI);
    if(!pcachePersistenceActive)
    {
        return E_POINTER;
    }

    *pcachePersistenceActive = m_pUI->_UI.RegPersistenceActive;
    return S_OK;
}

//
// brushSupportLevel property
//
STDMETHODIMP CMstscAdvSettings::put_brushSupportLevel(LONG brushSupportLevel)
{
    //
    // Deprecated
    //
    return S_FALSE;
}

STDMETHODIMP CMstscAdvSettings::get_brushSupportLevel(LONG* pbrushSupportLevel)
{
    //
    // Deprecated
    //
    return S_FALSE;
}


//
// put_PersistCacheDirectory property (Set only)
//
STDMETHODIMP CMstscAdvSettings::put_PersistCacheDirectory(BSTR PersistCacheDirectory)
{
    //
    // Deprecated
    //
    return S_FALSE;
}


//
// minInputSendInterval property
//
STDMETHODIMP CMstscAdvSettings::put_minInputSendInterval(LONG minInputSendInterval)
{
    //
    // Deprecated
    //
    return S_FALSE;
}

STDMETHODIMP CMstscAdvSettings::get_minInputSendInterval(LONG* pminInputSendInterval)
{
    //
    // Deprecated
    //
    return S_FALSE;
}

//
// InputEventsAtOnce property
//
STDMETHODIMP CMstscAdvSettings::put_InputEventsAtOnce(LONG inputEventsAtOnce)
{
    //
    // Deprecated
    //
    return S_FALSE;
}

STDMETHODIMP CMstscAdvSettings::get_InputEventsAtOnce(LONG* pinputEventsAtOnce)
{
    //
    // Deprecated
    //
    return S_FALSE;
}

//
// maxEventCount property
//
STDMETHODIMP CMstscAdvSettings::put_maxEventCount(LONG maxEventCount)
{
    //
    // Deprecated
    //
    return S_FALSE;
}

STDMETHODIMP CMstscAdvSettings::get_maxEventCount(LONG* pmaxEventCount)
{
    //
    // Deprecated
    //
    return S_FALSE;
}

//
// keepAliveInterval property
//
STDMETHODIMP CMstscAdvSettings::put_keepAliveInterval(LONG keepAliveInterval)
{
    HRESULT hr;
    if(GetLockedForWrite()) {
        return E_FAIL;
    }
    
    if (keepAliveInterval >= MIN_KEEP_ALIVE_INTERVAL ||
        KEEP_ALIVE_INTERVAL_OFF == keepAliveInterval) {

        m_pUI->_UI.keepAliveInterval = keepAliveInterval;
        hr = S_OK;

    }
    else {
        hr = E_INVALIDARG;
    }
    
    return hr;
}

STDMETHODIMP CMstscAdvSettings::get_keepAliveInterval(LONG* pkeepAliveInterval)
{
    ATLASSERT(m_pUI);
    if(!pkeepAliveInterval)
    {
        return E_POINTER;
    }

    *pkeepAliveInterval = m_pUI->_UI.keepAliveInterval;
    return S_OK;
}

//
// allowBackgroundInput property
//
STDMETHODIMP CMstscAdvSettings::put_allowBackgroundInput(LONG allowBackgroundInput)
{
    if (!m_bMakeSafeForScripting) {
        if(GetLockedForWrite()) {
            return E_FAIL;
        }
        m_pUI->_UI.allowBackgroundInput = allowBackgroundInput != 0;
        return S_OK;
    }
    else {
        //
        // Deprecated when SFS
        //
        return S_FALSE;
    }
}

STDMETHODIMP CMstscAdvSettings::get_allowBackgroundInput(LONG* pallowBackgroundInput)
{
    if (!m_bMakeSafeForScripting) {
        if(!pallowBackgroundInput) {
            return E_POINTER;
        }
        
        *pallowBackgroundInput = m_pUI->_UI.allowBackgroundInput;
        return S_OK;
    }
    else {
        //
        // Deprecated when SFS
        //
        return S_FALSE;
    }
}

//
// KeyBoardLayoutStr property (put only)
//

STDMETHODIMP CMstscAdvSettings::put_KeyBoardLayoutStr(BSTR KeyBoardLayoutStr)
{
    HRESULT hr = E_FAIL;
    if(GetLockedForWrite())
    {
        return E_FAIL;
    }

    if (KeyBoardLayoutStr) {
        hr = CUT::StringPropPut(m_pUI->_UI.szKeyBoardLayoutStr,
                           SIZE_TCHARS(m_pUI->_UI.szKeyBoardLayoutStr),
                           KeyBoardLayoutStr);
    }
    else {
        m_pUI->_UI.szKeyBoardLayoutStr[0] = NULL;
        hr = S_OK;
    }

    return hr;
}

//
// shutdownTimeout property
//
STDMETHODIMP CMstscAdvSettings::put_shutdownTimeout(LONG shutdownTimeout)
{
    HRESULT hr;
    if(GetLockedForWrite()) {
        return E_FAIL;
    }

    if (shutdownTimeout < MAX_TIMEOUT_SECONDS) {
        m_pUI->_UI.shutdownTimeout = shutdownTimeout;
        hr = S_OK;
    }
    else {
        hr = E_INVALIDARG;
    }
    return hr;
}

STDMETHODIMP CMstscAdvSettings::get_shutdownTimeout(LONG* pshutdownTimeout)
{
    ATLASSERT(m_pUI);
    if(!pshutdownTimeout)
    {
        return E_POINTER;
    }

    *pshutdownTimeout = m_pUI->_UI.shutdownTimeout;
    return S_OK;
}

//
// overallConnectionTimeout property
//
STDMETHODIMP CMstscAdvSettings::put_overallConnectionTimeout(LONG overallConnectionTimeout)
{
    HRESULT hr;
    if(GetLockedForWrite()) {
        return E_FAIL;
    }

    if (overallConnectionTimeout < MAX_TIMEOUT_SECONDS) {
        m_pUI->_UI.connectionTimeOut = overallConnectionTimeout;
        hr = S_OK;
    }
    else {
        hr = E_INVALIDARG;
    }
    return hr;
}

STDMETHODIMP CMstscAdvSettings::get_overallConnectionTimeout(LONG* poverallConnectionTimeout)
{
    ATLASSERT(m_pUI);
    if(!poverallConnectionTimeout)
    {
        return E_POINTER;
    }

    *poverallConnectionTimeout = m_pUI->_UI.connectionTimeOut;
    return S_OK;
}

//
// singleConnectionTimeout property
//
STDMETHODIMP CMstscAdvSettings::put_singleConnectionTimeout(LONG singleConnectionTimeout)
{
    HRESULT hr;
    if(GetLockedForWrite()) {
        return E_FAIL;
    }

    if (singleConnectionTimeout < MAX_TIMEOUT_SECONDS) {
        m_pUI->_UI.singleTimeout = singleConnectionTimeout;
        hr = S_OK;
    }
    else {
        hr = E_INVALIDARG;
    }
    return hr;

}

STDMETHODIMP CMstscAdvSettings::get_singleConnectionTimeout(LONG* psingleConnectionTimeout)
{
    ATLASSERT(m_pUI);
    if(!psingleConnectionTimeout)
    {
        return E_POINTER;
    }

    *psingleConnectionTimeout = m_pUI->_UI.singleTimeout;
    return S_OK;
}

//
// KeyboardType property
//
STDMETHODIMP CMstscAdvSettings::put_KeyboardType(LONG keyboardType)
{
    #ifndef OS_WINCE
        UNREFERENCED_PARAMETER(keyboardType);
        return E_NOTIMPL;
    #else
    if(GetLockedForWrite())
    {
        return E_FAIL;
    }
    m_pUI->_UI.winceKeyboardType = keyboardType;
	return S_OK;
    #endif
}

STDMETHODIMP CMstscAdvSettings::get_KeyboardType(LONG* pkeyboardType)
{
    #ifndef OS_WINCE
        UNREFERENCED_PARAMETER(pkeyboardType);
        return E_NOTIMPL;
    #else
    if(!pkeyboardType)
    {
        return E_POINTER;
    }
    *pkeyboardType = m_pUI->_UI.winceKeyboardType;
    return S_OK;
    #endif
}

//
// KeyboardSubType property
//
STDMETHODIMP CMstscAdvSettings::put_KeyboardSubType(LONG keyboardSubType)
{
    #ifndef OS_WINCE
        UNREFERENCED_PARAMETER(keyboardSubType);
        return E_NOTIMPL;
    #else
    if(GetLockedForWrite())
    {
        return E_FAIL;
    }
    m_pUI->_UI.winceKeyboardSubType = keyboardSubType;
	return S_OK;
    #endif
}

STDMETHODIMP CMstscAdvSettings::get_KeyboardSubType(LONG* pkeyboardSubType)
{
    #ifndef OS_WINCE
        UNREFERENCED_PARAMETER(pkeyboardSubType);
        return E_NOTIMPL;
    #else
    if(!pkeyboardSubType)
    {
        return E_POINTER;
    }
    *pkeyboardSubType = m_pUI->_UI.winceKeyboardSubType;
	return S_OK;
    #endif
}

//
// KeyboardFunctionKey property
//
STDMETHODIMP CMstscAdvSettings::put_KeyboardFunctionKey(LONG keyboardFunctionKey)
{
    #ifndef OS_WINCE
        UNREFERENCED_PARAMETER(keyboardFunctionKey);
        return E_NOTIMPL;
    #else
    if(GetLockedForWrite())
    {
        return E_FAIL;
    }
    m_pUI->_UI.winceKeyboardFunctionKey = keyboardFunctionKey;
	return S_OK;
    #endif
}

STDMETHODIMP CMstscAdvSettings::get_KeyboardFunctionKey(LONG* pkeyboardFunctionKey)
{
    #ifndef OS_WINCE
        UNREFERENCED_PARAMETER(pkeyboardFunctionKey);
        return E_NOTIMPL;
    #else
    if(!pkeyboardFunctionKey)
    {
        return E_POINTER;
    }
    *pkeyboardFunctionKey = m_pUI->_UI.winceKeyboardFunctionKey;
	return S_OK;
    #endif
}

//
// WinceFixedPalette property
//
STDMETHODIMP CMstscAdvSettings::put_WinceFixedPalette(LONG WinceFixedPalette)
{
    #ifndef OS_WINCE
        UNREFERENCED_PARAMETER(WinceFixedPalette);
        return E_NOTIMPL;
    #else
        //
        // Fix for WINCE
        //
        return E_NOTIMPL;
    #endif
}

STDMETHODIMP CMstscAdvSettings::get_WinceFixedPalette(LONG* pWinceFixedPalette)
{
    #ifndef OS_WINCE
        UNREFERENCED_PARAMETER(pWinceFixedPalette);
        return E_NOTIMPL;
    #else
        //
        // Fix for WINCE
        //
        return E_NOTIMPL;
    #endif
}

//
// PluginDlls
//
STDMETHODIMP CMstscAdvSettings::put_PluginDlls(BSTR PluginDlls)
{
    DC_BEGIN_FN("put_PluginDlls");

    if(GetLockedForWrite())
    {
        return E_FAIL;
    }


    if (PluginDlls)
    {
        LPTSTR szPlugins = (LPTSTR)(PluginDlls);
        //
        //SECURITY!!!
        //If we are safe for scripting, the plugin list
        //must be verified to ensure it contains just dll names (no paths)
        //Then a system defined base path is prepended to each dll name
        //
        if(m_bMakeSafeForScripting)
        {
            BOOL bIsSecureDllList = IsSecureDllList(szPlugins);
            if(bIsSecureDllList)
            {
                LPTSTR szExplicitPathDllList = 
                    CreateExplicitPathList(szPlugins);
                if(szExplicitPathDllList)
                {
                    m_pUI->UI_SetVChanAddinList(szExplicitPathDllList);
                    LocalFree(szExplicitPathDllList);
                }
                else
                {
                    //
                    // Unable to create an explicit path list
                    //
                    TRC_ERR((TB,_T("CreateExplicitPathList failed for %s"),
                             szPlugins));
                    return E_FAIL;
                }
            }
            else
            {
                TRC_ERR((TB,_T("IsSecureDllList failed for %s"), szPlugins));
                return E_FAIL;
            }
        }
        else
        {
            //
            // Don't need to be safe for an untrusted caller
            // just pass in the vcahn plugin list directly to the core
            //
            m_pUI->UI_SetVChanAddinList( szPlugins);
        }
    }
    else
    {
        m_pUI->UI_SetVChanAddinList(NULL);
    }

    DC_END_FN();

    return S_OK;
}

//
// IsSecureDllList
// determines if the CSV list of dlls in szDllList is secure
// the criteria we use are
// only dll names can be specified. NO PATHS, NO NETWORK SHARES.
//
BOOL CMstscAdvSettings::IsSecureDllList(LPCTSTR szDllList)
{
    ATLASSERT(szDllList);
    if(szDllList)
    {
        //
        // The only allowed values are alphanumeric characters
        // '.' and ','.
        //
        LPCTSTR psz = szDllList;
        while (*psz) {
            if (!(iswalnum(*psz) || *psz == _T(',') || *psz == _T('.'))) {
                return FALSE;
            }
            psz++;
        }

        //
        // Check for evil characters '/\%'
        //

        if(_tcspbrk( szDllList, TEXT("/\\%")))
        {
            return FALSE;
        }

        //
        // Now check for '..'
        //
        if(_tcsstr( szDllList, TEXT("..")))
        {
            return FALSE;
        }

        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

#define TS_VDLLPATH_KEYNAME TEXT("SOFTWARE\\Microsoft\\Terminal Server Client")
#define TS_VDLLPATH         TEXT("vdllpath")

//
// CreateExplicitPathList
// params:
//     szDllList - CSV list of dll names
// returns:
//     CSV list of Dlls with explicit paths. Or NULL on error.
//     ******CALLER MUST FREE RETURN STRING****
//
// Path prefix is taken from registry, or default value of system32
// if no registry setting is specified
//
//
LPTSTR CMstscAdvSettings::CreateExplicitPathList(LPCTSTR szDllList)
{
    HKEY hKey;
    LONG retVal;
    BOOL bGotPathPrefix = FALSE;
    int  i;
    LPTSTR szExplicitPathList = NULL;
    LPTSTR szDllListTmp = NULL;
    HRESULT hr;
    TCHAR szPathPrefix[MAX_PATH];

    if(!szDllList || !*szDllList)
    {
        return NULL;
    }

    //
    // Try to get a path prefix from the registry
    //
    retVal = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          TS_VDLLPATH_KEYNAME,
                          0,
                          KEY_READ,
                          &hKey);
    if(ERROR_SUCCESS == retVal)
    {
        DWORD cbData = sizeof(szPathPrefix);
        DWORD dwType;
        retVal = RegQueryValueEx(hKey, TS_VDLLPATH, NULL, &dwType,
                               (PBYTE)&szPathPrefix,
                               &cbData);
        if(ERROR_SUCCESS == retVal && REG_SZ == dwType)
        {
            //
            // validate that the vdllpath does not contain any '\\'
            // we don't just check the first char because someone
            // could just pad with whitespace.
            // This is done because network shares are not allowed
            // for the dll path prefix
            //
            if((cbData >= 2 * sizeof(TCHAR)) &&
               (_tcsstr( szPathPrefix, TEXT("\\\\"))))
            {
                //security violation, return failure
                return NULL;
            }
            else
            {
                bGotPathPrefix = TRUE;
            }
        }
        RegCloseKey(hKey);
    }

    if(!bGotPathPrefix)
    {
        #ifndef OS_WINCE
        //Use default value of the system32 directory
        if(!GetSystemDirectory( szPathPrefix, sizeof(szPathPrefix)/sizeof(TCHAR)))
        {
            return NULL;
        }
        else
        {
            bGotPathPrefix = TRUE;
        }
        #else
        //CE doesn't have a GetSystemDirectory directory
        return NULL;
        #endif

    }

    int cbDllListLen = _tcslen(szDllList) * sizeof(TCHAR) + sizeof(TCHAR);
    szDllListTmp = (LPTSTR) LocalAlloc(LPTR, cbDllListLen);
    if(NULL == szDllListTmp)
    {
        return NULL;
    }
    //
    // szDllListTmp is allocated large enough to hold
    // the szDllList so no need to length validate the copy
    //
    hr = StringCbCopy(szDllListTmp, cbDllListLen, szDllList);
    if (FAILED(hr)) {
        LocalFree(szDllListTmp);
        return NULL;
    }

    int countDlls = 0;
    LPTSTR DllNames[CHANNEL_MAX_COUNT];
    for(i=0; i<CHANNEL_MAX_COUNT; i++)
    {
        DllNames[i] = NULL;
    }

    //
    // Create an array of dllnames
    // pointers in DllNames point inplace to substrings in szDllListTmp
    //
    BOOL bCurCharIsStart = FALSE;
    DllNames[0] = szDllListTmp;
    countDlls = 1;

    LPTSTR sz = szDllListTmp; 
    while(*sz)
    {
        if(bCurCharIsStart)
        {
            DllNames[countDlls++] = sz;
            if(countDlls > CHANNEL_MAX_COUNT)
            {
                //ABORT
                LocalFree(szDllListTmp);
                return NULL;
            }
            //Reset
            bCurCharIsStart = FALSE;
        }

        if(TCHAR(',') == *sz)
        {
            *sz = NULL;
            bCurCharIsStart = TRUE;
        }
        sz++;
    }

    //
    // bytes needed for the explicit path version
    // is at most MAX_PATH * number of dlls (20 is added to give us extra space)
    //
    int cbExplicitPath = countDlls * (MAX_PATH + 20) * sizeof(TCHAR);
    szExplicitPathList = (LPTSTR) LocalAlloc(LPTR,
                                             cbExplicitPath);
    if(NULL == szExplicitPathList)
    {
        LocalFree(szDllListTmp);
        return NULL;
    }
    memset(szExplicitPathList, 0 , cbExplicitPath);
    //
    // Construct the explicit path list
    // by splatting in the prefix followed by '\' followed by the dll name
    // ensure that none of the dll paths exceed MAX_PATH..If any do, return FAILURE
    //
    int lenPrefix = _tcslen(szPathPrefix);
    for(i=0; i<countDlls;i++)
    {
        int lenPath = lenPrefix;
        lenPath += _tcslen(DllNames[i]);
        lenPath += 1; // for '\'
        if(lenPath >= MAX_PATH - 1)
        {
            LocalFree(szExplicitPathList);
            LocalFree(szDllListTmp);
            return NULL;
        }

        hr = StringCbCat(szExplicitPathList,
                         cbExplicitPath,
                         szPathPrefix);
        if (SUCCEEDED(hr)) {
            hr = StringCbCat(szExplicitPathList,
                             cbExplicitPath,
                             _T("\\"));
            if (SUCCEEDED(hr)) {
                hr = StringCbCat(szExplicitPathList,
                                 cbExplicitPath,
                                 DllNames[i]);
                if (SUCCEEDED(hr)) {
                    if (i != (countDlls -1)) {
                        //Last DLL, no trailing ","
                        hr = StringCbCat(szExplicitPathList,
                                         cbExplicitPath,
                                         _T(","));

                    }
                }
            }
        }

        if (FAILED(hr)) {
            LocalFree(szExplicitPathList);
            LocalFree(szDllListTmp);
            return NULL;
        }
    }

    LocalFree(szDllListTmp);

    //caller must free
    return szExplicitPathList;
}


//
// IconFile
//
STDMETHODIMP CMstscAdvSettings::put_IconFile(BSTR IconFile)
{
    HRESULT hr = E_FAIL;
    //
    // Don't allow this property to be set in the web control case
    // for attack surface reduction as we don't want to allow a script
    // caller access to the local file system.
    //
    #if (defined(OS_WINCE) || defined(REDIST_CONTROL))
    return S_FALSE;
    #else
    if(GetLockedForWrite())
    {
        return E_FAIL;
    }

    if (IconFile) {
        hr = CUT::StringPropPut(m_pUI->_UI.szIconFile,
                           SIZE_TCHARS(m_pUI->_UI.szIconFile),
                           (LPTSTR)IconFile);
    }
    else {
        m_pUI->_UI.szIconFile[0] = NULL;
        hr = S_OK;
    }
    return hr;
    #endif
}

//
// Icon Index
//
STDMETHODIMP CMstscAdvSettings::put_IconIndex(LONG IconIndex)
{
    //
    // Don't allow this property to be set in the web control case
    // for attack surface reduction as we don't want to allow a script
    // caller access to the local file system.
    //
    #if (defined(OS_WINCE) || defined(REDIST_CONTROL))
    return S_FALSE;
    #else
    if(GetLockedForWrite())
    {
        return E_FAIL;
    }

    m_pUI->_UI.iconIndex = IconIndex;
    return S_OK;
    #endif
}

//
// Container handled full screen mode
//
STDMETHODIMP CMstscAdvSettings::put_ContainerHandledFullScreen(BOOL ContainerHandledFullScreen)
{
    HRESULT hr = E_FAIL;

    DC_BEGIN_FN("put_ContainerHandledFullScreen");

    if(GetLockedForWrite()) {
        return E_FAIL;
    }

    if (!m_bMakeSafeForScripting) {
        m_pUI->_UI.fContainerHandlesFullScreenToggle =
            (ContainerHandledFullScreen != 0);
        hr = S_OK;
    }
    else {
        hr = S_FALSE;
    }

    DC_END_FN();
    
    return hr;
}

STDMETHODIMP CMstscAdvSettings::get_ContainerHandledFullScreen(BOOL* pContainerHandledFullScreen)
{
    HRESULT hr = E_FAIL;

    DC_BEGIN_FN("get_ContainerHandledFullScreen");

    if(!pContainerHandledFullScreen) {
        return E_INVALIDARG;
    }

    if (!m_bMakeSafeForScripting) {
        *pContainerHandledFullScreen = m_pUI->_UI.fContainerHandlesFullScreenToggle ?
                                       VB_TRUE : VB_FALSE;
        hr = S_OK;
    }
    else {
        hr = S_FALSE;
    }

    DC_END_FN();
    return hr;
}

//
// Disable loading RDPDR on first initialization
//
STDMETHODIMP CMstscAdvSettings::put_DisableRdpdr(BOOL DisableRdpdr)
{
    if(!GetLockedForWrite())
    {
        if(!m_pUI->UI_IsCoreInitialized())
        {
            m_pUI->_UI.fDisableInternalRdpDr =  (DisableRdpdr != 0);
            return S_OK;
        }
        else
        {
            return E_FAIL;
        }
    }
    else
    {
        return E_FAIL;
    }
}

STDMETHODIMP CMstscAdvSettings::get_DisableRdpdr(BOOL* pDisableRdpdr)
{
    if( pDisableRdpdr )
    {
        *pDisableRdpdr = m_pUI->_UI.fDisableInternalRdpDr ? VB_TRUE : VB_FALSE;
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

STDMETHODIMP CMstscAdvSettings::put_ConnectToServerConsole(VARIANT_BOOL connectToConsole)
{
    if(!GetLockedForWrite())
    {
        m_pUI->UI_SetConnectToServerConsole(connectToConsole != 0);
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

STDMETHODIMP CMstscAdvSettings::get_ConnectToServerConsole(VARIANT_BOOL* pConnectToConsole)
{
    if(pConnectToConsole)
    {
        *pConnectToConsole = (m_pUI->UI_GetConnectToServerConsole() ? VB_TRUE : VB_FALSE);
        return S_OK;
    }
    else
    {
        return E_INVALIDARG;
    }
}

STDMETHODIMP CMstscAdvSettings::put_MinutesToIdleTimeout(
                                LONG minutesToIdleTimeout)
{
    DC_BEGIN_FN("put_MinutesToIdleTimeout");
    if(!GetLockedForWrite())
    {
        if(minutesToIdleTimeout > MAX_MINS_TOIDLETIMEOUT)
        {
            TRC_ERR((TB,_T("idle timeout out of range: %d"),
                     minutesToIdleTimeout));
            return E_INVALIDARG;
        }

        if(m_pUI->UI_SetMinsToIdleTimeout( minutesToIdleTimeout ))
        {
            return S_OK;
        }
        else
        {
            return E_FAIL;
        }
    }
    else
    {
        return E_FAIL;
    }
    DC_END_FN();
}

STDMETHODIMP CMstscAdvSettings::get_MinutesToIdleTimeout(
                                LONG* pminutesToIdleTimeout)
{
    DC_BEGIN_FN("get_MinutesToIdleTimeout");
    if(pminutesToIdleTimeout)
    {
        *pminutesToIdleTimeout = m_pUI->UI_GetMinsToIdleTimeout();
        return S_OK;
    }
    else
    {
        return E_INVALIDARG;
    }
    DC_END_FN();
}

#ifdef SMART_SIZING
/**PROC+*********************************************************************/
/* Name:      get_SmartSize        	        
/*                                              
/* Purpose:   get smart sizing property
/*                                              
/**PROC-*********************************************************************/
STDMETHODIMP CMstscAdvSettings::get_SmartSizing(VARIANT_BOOL* pfSmartSize)
{
    ATLASSERT(m_pUI);

    if(!pfSmartSize)
    {
        return E_INVALIDARG;
    }

    *pfSmartSize = m_pUI->UI_GetSmartSizing() ? VB_TRUE : VB_FALSE;
    
    return S_OK;
}

/**PROC+*********************************************************************/
/* Name:      put_SmartSize        	        
/*                                              
/* Purpose:   put smart sizing property
/*                                              
/**PROC-*********************************************************************/
STDMETHODIMP CMstscAdvSettings::put_SmartSizing(VARIANT_BOOL fSmartSize)
{
    OSVERSIONINFOA OsVer;
    memset(&OsVer, 0x0, sizeof(OSVERSIONINFOA));
    OsVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
    GetVersionExA(&OsVer);
    HRESULT hr = S_OK;

    if ((VER_PLATFORM_WIN32_NT != OsVer.dwPlatformId) && fSmartSize) {

        //
        // Win9x doesn't support halftoning, so no smart sizing for them!
        //

        return E_NOTIMPL;
    }

    //no, these lines of code are not as bad as they look
    //vb's true is 0xFFFFFFF so don't just blindy assign
    hr = m_pUI->UI_SetSmartSizing( fSmartSize != 0);
    
    return hr;
}
#endif // SMART_SIZING


//
// Pass in the local printing doc name string to RDPDR
// this method's main purpose is so we don't need to add
// a localizable string to the control. There is a default
// english string built into the control, a container can
// pass in any replacement (i.e localized) string it pleases
//
STDMETHODIMP CMstscAdvSettings::put_RdpdrLocalPrintingDocName(
                                    BSTR RdpdrLocalPrintingDocName)
{
    DC_BEGIN_FN("put_RdpdrLocalPrintingDocName");

    DC_END_FN();
    return S_FALSE; //deprecated
}

//
// Return the currently selected string
// for the local printing doc name. This is just a string
// RDPDR uses but we want to avoid localizing the control
// so the string is passed in from the container.
//
STDMETHODIMP CMstscAdvSettings::get_RdpdrLocalPrintingDocName(
                                    BSTR *pRdpdrLocalPrintingDocName)
{
    DC_BEGIN_FN("get_RdpdrLocalPrintingDocName");

    DC_END_FN();
    return S_FALSE; //deprecated
}

STDMETHODIMP CMstscAdvSettings::put_RdpdrClipCleanTempDirString(
                                    BSTR RdpdrClipCleanTempDirString)
{
    DC_BEGIN_FN("put_RdpdrClipCleanTempDirString");

    DC_END_FN();
    return S_FALSE; //deprecated
}

STDMETHODIMP CMstscAdvSettings::get_RdpdrClipCleanTempDirString(
                                    BSTR *pRdpdrClipCleanTempDirString)
{
    DC_BEGIN_FN("get_RdpdrClipCleanTempDirString");

    DC_END_FN();
    return S_FALSE; //deprecated
}

STDMETHODIMP CMstscAdvSettings::put_RdpdrClipPasteInfoString(
                                    BSTR RdpdrClipPasteInfoString)
{
    DC_BEGIN_FN("put_RdpdrClipPasteInfoString");

    DC_END_FN();
    return S_FALSE; //deprecated
}

STDMETHODIMP CMstscAdvSettings::get_RdpdrClipPasteInfoString(
                                    BSTR *pRdpdrClipPasteInfoString)
{
    DC_BEGIN_FN("get_RdpdrClipPasteInfoString");

    DC_END_FN();
    return S_FALSE; //deprecated
}


//
// New Whistler scriptable access to password API
// this just delegates to the non-scriptable API from TSAC
//
STDMETHODIMP CMstscAdvSettings::put_ClearTextPassword(BSTR clearTextPassword)
{
    DC_BEGIN_FN("put_ClearTextPassword");

    TRC_ASSERT(_pAxControl,
               (TB,_T("_pAxControl is NULL")));

    if(!GetLockedForWrite() && _pAxControl)
    {
        if(clearTextPassword)
        {
            return _pAxControl->put_ClearTextPassword( clearTextPassword );
        }
        else
        {
            return E_INVALIDARG;
        }
    }
    else
    {
        return E_FAIL;
    }

    DC_END_FN();
}

/**PROC+*********************************************************************/
/* Name:      put_DisplayConnectionBar        	        
/*                                              
/* Purpose:   Set display connection bar prop
/*            cannot be set in web control (it is always true there)
/*                                              
/**PROC-*********************************************************************/
STDMETHODIMP CMstscAdvSettings::put_DisplayConnectionBar(
    VARIANT_BOOL fDisplayConnectionBar)
{
    ATLASSERT(m_pUI);

#if (!defined (OS_WINCE)) || (!defined (WINCE_SDKBUILD))
    if(!m_bMakeSafeForScripting && !GetLockedForWrite())
    {
        m_pUI->UI_SetEnableBBar( fDisplayConnectionBar != 0);
    }
    else
    {
        //
        // Not allowed to toggle this
        // if need to be safe for scripting as the bbar
        // prevents spoofing attacks because people
        // can always realize this is a TS session.
        //
        return E_FAIL;
    }

    return S_OK;
#else
    return E_NOTIMPL;
#endif

}

/**PROC+*********************************************************************/
/* Name:      get_DisplayConnectionBar        	        
/*                                              
/* Purpose:   put start connected property
/*                                              
/**PROC-*********************************************************************/
STDMETHODIMP CMstscAdvSettings::get_DisplayConnectionBar(
    VARIANT_BOOL* pfDisplayConnectionBar)
{
#if (!defined (OS_WINCE)) || (!defined (WINCE_SDKBUILD))
    if(pfDisplayConnectionBar)
    {
        *pfDisplayConnectionBar =
            m_pUI->UI_GetEnableBBar() ? VB_TRUE : VB_FALSE;
        return S_OK;
    }
    else
    {
        return E_INVALIDARG;
    }
#else
    return E_NOTIMPL;
#endif
}

/**PROC+*********************************************************************/
/* Name:      put_PinConnectionBar        	        
/*                                              
/* Purpose:   Set Pin connection bar prop
/*            cannot be set in web control (it is always true there)
/*                                              
/**PROC-*********************************************************************/
STDMETHODIMP CMstscAdvSettings::put_PinConnectionBar(
    VARIANT_BOOL fPinConnectionBar)
{
#if (!defined (OS_WINCE)) || (!defined (WINCE_SDKBUILD))
    if (!m_bMakeSafeForScripting) {
        if (!GetLockedForWrite())
        {
            m_pUI->UI_SetBBarPinned( fPinConnectionBar != 0);
        }
        else
        {
            //
            // Not allowed to toggle this
            // if need to be safe for scripting as the bbar
            // prevents spoofing attacks because people
            // can always realize this is a TS session.
            //
            return E_FAIL;
        }
        return S_OK;
    }
    else {
        return E_NOTIMPL;
    }
#else
    return E_NOTIMPL;
#endif
}

/**PROC+*********************************************************************/
/* Name:      get_PinConnectionBar        	        
/*                                              
/* Purpose:   put start connected property
/*                                              
/**PROC-*********************************************************************/
STDMETHODIMP CMstscAdvSettings::get_PinConnectionBar(
    VARIANT_BOOL* pfPinConnectionBar)
{
#if (!defined (OS_WINCE)) || (!defined (WINCE_SDKBUILD))
    if (!m_bMakeSafeForScripting) {
        if(pfPinConnectionBar)
        {
            *pfPinConnectionBar =
                m_pUI->UI_GetBBarPinned() ? VB_TRUE : VB_FALSE;
            return S_OK;
        }
        else
        {
            return E_INVALIDARG;
        }
    }
    else {
        return E_NOTIMPL;
    }
#else
    return E_NOTIMPL;
#endif
}



//
// GrabFocusOnConnect (defaults to true)
// can turn this off to allow containers to control
// when the client gets the focus (e.g the MMC snapin)
// needs to manage this for multiple instances
//
STDMETHODIMP CMstscAdvSettings::put_GrabFocusOnConnect(
    VARIANT_BOOL fGrabFocusOnConnect)
{
    DC_BEGIN_FN("put_GrabFocusOnConnect");

    ATLASSERT(m_pUI);

    if(!GetLockedForWrite())
    {
        m_pUI->UI_SetGrabFocusOnConnect( fGrabFocusOnConnect != 0);
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }

    DC_END_FN();
}

STDMETHODIMP CMstscAdvSettings::get_GrabFocusOnConnect(
    VARIANT_BOOL* pfGrabFocusOnConnect)
{
    DC_BEGIN_FN("get_GrabFocusOnConnect");

    if(pfGrabFocusOnConnect)
    {
        *pfGrabFocusOnConnect =
            m_pUI->UI_GetGrabFocusOnConnect() ? VB_TRUE : VB_FALSE;
        return S_OK;
    }
    else
    {
        return E_INVALIDARG;
    }

    DC_END_FN();
}

//
// Name:      put_LoadBalanceInfo                                                    
//                                                                          
// Purpose:   LoadBalance info property input function.                               
//          
#define LBINFO_MAX_LENGTH 256
STDMETHODIMP CMstscAdvSettings::put_LoadBalanceInfo(BSTR newLBInfo)
{
    DC_BEGIN_FN("put_LoadBalanceInfo");
    
    if(!GetLockedForWrite()) 
    {
        if (newLBInfo)
        {
            if (SysStringByteLen(newLBInfo) <= LBINFO_MAX_LENGTH)
                m_pUI->UI_SetLBInfo((PBYTE)newLBInfo, SysStringByteLen(newLBInfo));  
            else 
                return E_INVALIDARG;
        }
        else
        {
            m_pUI->UI_SetLBInfo(NULL, 0);
        }
    }
    else {
        return E_FAIL;
    }

    DC_END_FN();

    return S_OK;
}

//
// Name:      get_LoadBalanceInfo
//                                                                          
// Purpose:   LoadBalance info property get function.                                 
//                                                                          
STDMETHODIMP CMstscAdvSettings::get_LoadBalanceInfo(BSTR* pLBInfo)
{
    DC_BEGIN_FN("get_LoadBalanceInfo");
    
    if(!pLBInfo)
    {
        return E_INVALIDARG;
    }

    *pLBInfo = SysAllocStringByteLen((LPCSTR)(m_pUI->_UI.bstrScriptedLBInfo), 
            SysStringByteLen(m_pUI->_UI.bstrScriptedLBInfo));

    if(!*pLBInfo)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

STDMETHODIMP CMstscAdvSettings::put_RedirectDrives(VARIANT_BOOL redirectDrives)
{
    DC_BEGIN_FN("put_RedirectDrives");

    if(!GetLockedForWrite())
    {
        if (CMsTscSecuredSettings::IsDriveRedirGloballyDisabled())
        {
            m_pUI->UI_SetDriveRedirectionEnabled(FALSE);
            return S_FALSE;
        }
        else
        {
            m_pUI->UI_SetDriveRedirectionEnabled( (redirectDrives != 0));
            return S_OK;
        }
    }
    else
    {
        return E_FAIL;
    }

    DC_END_FN();
}

STDMETHODIMP CMstscAdvSettings::get_RedirectDrives(VARIANT_BOOL *pRedirectDrives)
{
    if(pRedirectDrives)
    {
        *pRedirectDrives = m_pUI->UI_GetDriveRedirectionEnabled() ?
                           VB_TRUE : VB_FALSE;
        return S_OK;
    }
    else
    {
        return E_INVALIDARG;
    }
}

STDMETHODIMP CMstscAdvSettings::put_RedirectPrinters(VARIANT_BOOL redirectPrinters)
{
    if(!GetLockedForWrite())
    {
        m_pUI->UI_SetPrinterRedirectionEnabled( (redirectPrinters != 0));
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

STDMETHODIMP CMstscAdvSettings::get_RedirectPrinters(VARIANT_BOOL *pRedirectPrinters)
{
    if(pRedirectPrinters)
    {
        *pRedirectPrinters = m_pUI->UI_GetPrinterRedirectionEnabled() ?
                             VB_TRUE : VB_FALSE;
        return S_OK;
    }
    else
    {
        return E_INVALIDARG;
    }
}

STDMETHODIMP CMstscAdvSettings::put_RedirectPorts(VARIANT_BOOL redirectPorts)
{
    if(!GetLockedForWrite())
    {
        m_pUI->UI_SetPortRedirectionEnabled( (redirectPorts != 0));
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

STDMETHODIMP CMstscAdvSettings::get_RedirectPorts(VARIANT_BOOL *pRedirectPorts)
{
    if(pRedirectPorts)
    {
        *pRedirectPorts = m_pUI->UI_GetPortRedirectionEnabled() ? 
                          VB_TRUE : VB_FALSE;
        return S_OK;
    }
    else
    {
        return E_INVALIDARG;
    }
}

STDMETHODIMP CMstscAdvSettings::put_RedirectSmartCards(VARIANT_BOOL redirectScard)
{
    if(!GetLockedForWrite())
    {
        m_pUI->UI_SetSCardRedirectionEnabled(redirectScard != 0);
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

STDMETHODIMP CMstscAdvSettings::get_RedirectSmartCards(VARIANT_BOOL *pRedirectScard)
{
    if(pRedirectScard)
    {
        *pRedirectScard = m_pUI->UI_GetSCardRedirectionEnabled() ?
                          VB_TRUE : VB_FALSE;
        return S_OK;
    }
    else
    {
        return E_INVALIDARG;
    }
}

//
// BitmapVirtualCache16BppSize property
//
// Applies to 15/16Bpp cache file size
//
STDMETHODIMP CMstscAdvSettings::put_BitmapVirtualCache16BppSize(
                                    LONG bitmapVirtualCache16BppSize)
{
    if(GetLockedForWrite())
    {
        return E_FAIL;
    }

    if (bitmapVirtualCache16BppSize > 0 &&
        bitmapVirtualCache16BppSize <= TSC_MAX_BITMAPCACHESIZE)
    {
        m_pUI->_UI.RegBitmapVirtualCache16BppSize = 
            bitmapVirtualCache16BppSize;
    }
    else
    {
        return E_INVALIDARG;
    }
    
    return S_OK;
}

STDMETHODIMP CMstscAdvSettings::get_BitmapVirtualCache16BppSize(
                                    LONG* pbitmapVirtualCache16BppSize)
{
    if(!pbitmapVirtualCache16BppSize)
    {
        return E_POINTER;
    }

    *pbitmapVirtualCache16BppSize =
        m_pUI->_UI.RegBitmapVirtualCache16BppSize;
    return S_OK;
}

//
// BitmapVirtualCache24BppSize property
//
// Applies to 24Bpp cache file size
//
STDMETHODIMP CMstscAdvSettings::put_BitmapVirtualCache24BppSize(
                                    LONG bitmapVirtualCache24BppSize)
{
    if(GetLockedForWrite())
    {
        return E_FAIL;
    }

    if (bitmapVirtualCache24BppSize > 0 &&
        bitmapVirtualCache24BppSize <= TSC_MAX_BITMAPCACHESIZE)
    {
        m_pUI->_UI.RegBitmapVirtualCache24BppSize = 
            bitmapVirtualCache24BppSize;
    }
    else
    {
        return E_INVALIDARG;
    }
    
    return S_OK;
}

STDMETHODIMP CMstscAdvSettings::get_BitmapVirtualCache24BppSize(
                                    LONG* pbitmapVirtualCache24BppSize)
{
    if(!pbitmapVirtualCache24BppSize)
    {
        return E_POINTER;
    }

    *pbitmapVirtualCache24BppSize =
        m_pUI->_UI.RegBitmapVirtualCache24BppSize;
    return S_OK;
}

//
// Sets the disabled feature list (for perf reasons can disable
// certain features at the server e.g wallpaper)
//
STDMETHODIMP CMstscAdvSettings::put_PerformanceFlags(
    LONG DisableFeatList)
{
    DC_BEGIN_FN("put_PerformanceFlags");

    if(GetLockedForWrite())
    {
        return E_FAIL;
    }

    m_pUI->UI_SetPerformanceFlags((DWORD)DisableFeatList);
    
    DC_END_FN();
    return S_OK;
}

STDMETHODIMP CMstscAdvSettings::get_PerformanceFlags(
    LONG* pDisableFeatList)
{
    DC_BEGIN_FN("get_PerformanceFlags");

    if(!pDisableFeatList)
    {
        return E_POINTER;
    }

    *pDisableFeatList = (LONG)
        m_pUI->UI_GetPerformanceFlags();


    DC_END_FN();
    return S_OK;
}

/*****************************************************************************/
/* Purpose : This is Remote Assistance specific call to support reverse      */
/*           connection pcHealth must have invoke necessary routine in Salem *
/*           to connection with TermSrv and then instruct Salem to pass this */
/*           connection to ActiveX control to begin login sequence           */
/*                                                                           */
/* Param : IN pConnectionEndPoint - Connected socket                         */
/*****************************************************************************/
STDMETHODIMP 
CMstscAdvSettings::put_ConnectWithEndpoint(
    VARIANT* pConnectionEndpoint
    )
{
#if REDIST_CONTROL
    
    return E_NOTIMPL;

#else

    HRESULT hr = S_OK;

    DC_BEGIN_FN( "ConnectionEndpoint" );

    if( pConnectionEndpoint->vt != VT_BYREF )
    {
        hr = E_HANDLE;
    }
    else
    {
        hr = _pAxControl->SetConnectWithEndpoint( 
                            (SOCKET)pConnectionEndpoint->byref );
    }

    DC_END_FN();

    return hr;

#endif
}

/*****************************************************************************/
/* Purpose : This is Remote Assistance specific call to notify TS public     */
/*           key uses in  generate session encryption key.                   */
/*                                                                           */
/* Param : IN fNotify - TRUE to notify public key, FALSE otherwise           */
/*****************************************************************************/
STDMETHODIMP 
CMstscAdvSettings::put_NotifyTSPublicKey(
    VARIANT_BOOL fNotify
    )
{
#if REDIST_CONTROL

    return E_NOTIMPL;

#else
#ifndef OS_WINCE
    HRESULT hr;
#endif

    if(GetLockedForWrite())
    {
        return E_FAIL;
    }
 
    m_pUI->UI_SetNotifyTSPublicKey( fNotify );

    return S_OK;

#endif
}

/*****************************************************************************/
/* Purpose : Get current setting on whether ActiveX control will notify      */
/*           container when it received TS public key                        */
/*                                                                           */
/* Returns : TRUE to notify public key, FALSE otherwise                      */
/*****************************************************************************/
STDMETHODIMP
CMstscAdvSettings::get_NotifyTSPublicKey(
    VARIANT_BOOL* pfNotifyTSPublicKey
    )
{
#if REDIST_CONTROL

    return E_NOTIMPL;

#else

    BOOL fNotify;

    if(!pfNotifyTSPublicKey)
    {
        return E_POINTER;
    }

    fNotify = m_pUI->UI_GetNotifyTSPublicKey();
    
    return S_OK;

#endif
}

//
// Retrieves VARIANT_TRUE if we can autoreconnect
// i.e. the core has received an autoreconnect cookie
// from the server from a previous connection and the
// server has not been changed
//
STDMETHODIMP
CMstscAdvSettings::get_CanAutoReconnect(
    VARIANT_BOOL* pfCanAutoReconnect
    )
{
    HRESULT hr;
    DC_BEGIN_FN("get_CanAutoReconnect");

    if (pfCanAutoReconnect)
    {
        *pfCanAutoReconnect = 
            m_pUI->UI_CanAutoReconnect() ? VB_TRUE : VB_FALSE;
        hr = S_OK;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    DC_END_FN();
    return hr;
}


//
// Sets w/not any autoreconnection information
// will be used for the next connection. Also specifies
// if we should store any autoreconnection information
// the server sends down.
//
STDMETHODIMP
CMstscAdvSettings::put_EnableAutoReconnect(
    VARIANT_BOOL fEnableAutoReconnect
    )
{
    HRESULT hr;
    DC_BEGIN_FN("put_EnableAutoReconnect");

    if (!GetLockedForWrite() && m_pUI)
    {
        m_pUI->UI_SetEnableAutoReconnect(fEnableAutoReconnect != 0);
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }

    DC_END_FN();
    return hr;
}

//
// Retrieves state of w/not we should use autoreconnection
// 
//
STDMETHODIMP
CMstscAdvSettings::get_EnableAutoReconnect(
    VARIANT_BOOL* pfEnableAutoReconnect
    )
{
    HRESULT hr;
    DC_BEGIN_FN("get_EnableAutoReconnect");

    if (pfEnableAutoReconnect)
    {
        *pfEnableAutoReconnect = 
            m_pUI->UI_GetEnableAutoReconnect() ? VB_TRUE : VB_FALSE;
        hr = S_OK;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    DC_END_FN();
    return hr;
}


//
// Specify the max number of ARC retries
//
STDMETHODIMP
CMstscAdvSettings::put_MaxReconnectAttempts(
    LONG MaxReconnectAttempts
    )
{
    HRESULT hr;
    DC_BEGIN_FN("put_MaxReconnectAttempts");

    if (!GetLockedForWrite() && m_pUI)
    {
        if (MaxReconnectAttempts > 200) {
            MaxReconnectAttempts = 200;
        }
        else if (MaxReconnectAttempts < 0) {
            MaxReconnectAttempts = 0;
        }
        m_pUI->UI_SetMaxArcAttempts(MaxReconnectAttempts);
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }

    DC_END_FN();
    return hr;
}

//
// Retrieves state of w/not we should use autoreconnection
// 
//
STDMETHODIMP
CMstscAdvSettings::get_MaxReconnectAttempts(
    LONG* pMaxReconnectAttempts
    )
{
    HRESULT hr;
    DC_BEGIN_FN("get_MaxReconnectAttempts");

    if (pMaxReconnectAttempts)
    {
        *pMaxReconnectAttempts = 
            m_pUI->UI_GetMaxArcAttempts();
        hr = S_OK;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    DC_END_FN();
    return hr;
}

//
// Display BBar minimize button
//
STDMETHODIMP
CMstscAdvSettings::put_ConnectionBarShowMinimizeButton(
    VARIANT_BOOL fShowMinimizeButton
    )
{
    HRESULT hr;
    DC_BEGIN_FN("put_EnableAutoReconnect");

    if (!GetLockedForWrite() && m_pUI)
    {
        m_pUI->UI_SetBBarShowMinimize(fShowMinimizeButton != 0);
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }

    DC_END_FN();
    return hr;
}

//
// get display bbar minimize button
//
STDMETHODIMP
CMstscAdvSettings::get_ConnectionBarShowMinimizeButton(
    VARIANT_BOOL* pfShowMinimizeButton
    )
{
    HRESULT hr;
    DC_BEGIN_FN("get_ConnectionBarShowMinimizeButton");

    if (pfShowMinimizeButton)
    {
        *pfShowMinimizeButton = 
            m_pUI->UI_GetBBarShowMinimize() ? VB_TRUE : VB_FALSE;
        hr = S_OK;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    DC_END_FN();
    return hr;
}


//
// set bbar restore button
//
STDMETHODIMP
CMstscAdvSettings::put_ConnectionBarShowRestoreButton(
    VARIANT_BOOL fShowRestoreButton
    )
{
    HRESULT hr;
    DC_BEGIN_FN("put_EnableAutoReconnect");

    if (!GetLockedForWrite() && m_pUI)
    {
        m_pUI->UI_SetBBarShowRestore(fShowRestoreButton != 0);
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }

    DC_END_FN();
    return hr;
}

//
// get bbar restore button
//
STDMETHODIMP
CMstscAdvSettings::get_ConnectionBarShowRestoreButton(
    VARIANT_BOOL* pfShowRestoreButton
    )
{
    HRESULT hr;
    DC_BEGIN_FN("get_ConnectionBarShowRestoreButton");

    if (pfShowRestoreButton)
    {
        *pfShowRestoreButton = 
            m_pUI->UI_GetBBarShowRestore() ? VB_TRUE : VB_FALSE;
        hr = S_OK;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    DC_END_FN();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\mstscax\arcmgr.cpp ===
//
// Module :  arcmgr.cpp
//
// Class  : CArcMgr
//
// Purpose: AutoReconnection mananger class - drives policy for
//          ts client autoreconnection
//
// Copyright(C) Microsoft Corporation 2001
//
// Author :  Nadim Abdo (nadima)
//

#include "stdafx.h"
#include "atlwarn.h"

BEGIN_EXTERN_C
#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "arcmgr"
#include <atrcapi.h>
END_EXTERN_C

//Header generated from IDL
#include "mstsax.h"
#include "mstscax.h"
#include "arcmgr.h"
#include "tscerrs.h"

//
// Total time to wait between ARC attempts
//
#define ARC_RECONNECTION_DELAY   (3000)


CArcMgr::CArcMgr()  :
        _pMsTscAx(NULL),
        _nArcAttempts(0),
        _fAutomaticArc(TRUE),
        _fContinueArc(FALSE)
{
    DC_BEGIN_FN("CArcMgr");

    DC_END_FN();
}

CArcMgr::~CArcMgr()
{
    DC_BEGIN_FN("~CArcMgr");

    DC_END_FN();
}

//
// Static timer callback procedure
// see platform SDK for params
//
VOID CALLBACK
CArcMgr::sArcTimerCallBackProc(
    HWND hwnd,
    UINT uMsg,
    UINT_PTR idEvent,
    DWORD dwTime
    )
{
    CArcMgr* pThis = NULL;
    DC_BEGIN_FN("sArcTimerCallBackProc");

    //
    // We pass the instance pointer around as the event id.
    //
    pThis = (CArcMgr*)idEvent;
    TRC_ASSERT(pThis,(TB,_T("sArcTimerCallBackProc got NULL idEvent")));
    if (pThis) {
        pThis->ArcTimerCallBackProc(hwnd, uMsg, idEvent, dwTime);
    }

    DC_END_FN();
}

//
// Timer callback procedure
// see platform SDK for params
//
VOID
CArcMgr::ArcTimerCallBackProc(
    HWND hwnd,
    UINT uMsg,
    UINT_PTR idEvent,
    DWORD dwTime
    )
{
    HRESULT hr = E_FAIL;
    DC_BEGIN_FN("ArcTimerCallBackProc");

    //
    // Kill the timers to make them one shot
    //
    if (!KillTimer(hwnd, idEvent)) {
        TRC_ERR((TB,_T("KillTimer for 0x%x failed with code 0x%x"),
                idEvent, GetLastError()));
    }


    if (_fContinueArc) {
        //
        // Attempt to kick off a reconnection attempt
        //
        hr = _pMsTscAx->Connect();
        if (FAILED(hr)) {
            TRC_ERR((TB,_T("Arc connect() failed with: 0x%x"),hr));

            //
            // Failed to initiate a connection so trigger a disconnect
            //
            _pMsTscAx->Disconnect();
        }
    }


    DC_END_FN();
}




//
// Arc manager's notification that disconnection has occurred
// This is the main entry point for driving autoreconnection
// 
// Params:
//  [IN] disconnectReason - disconnection reason code
//  [IN] exReasonCode - extended disconnect reason code
//  [OUT] pfContinueDisconnect - returns TRUE if disconnect processing
//                               shoud continue
//
// Returns:
//  Nothing
//
VOID
CArcMgr::OnNotifyDisconnected(
    LONG disconnectReason,
    ExtendedDisconnectReasonCode exReasonCode,
    PBOOL pfContinueDisconnect
    )
{
    BOOL fShouldAutoReconnect = FALSE;
    AutoReconnectContinueState arcContinue;
    HRESULT hr = E_FAIL;
    BOOL fContinueDisconnect = TRUE;
    CUI* pUI = NULL;
    BOOL fCoreAllowsArcContinue = FALSE;
    LONG maxArcConAttempts = MAX_ARC_CONNECTION_ATTEMPTS;

    DC_BEGIN_FN("OnNotifyDisconnected");

    TRC_ASSERT(_pMsTscAx,(TB,_T("_pMsTscAx is not set")));

    if (_pMsTscAx) {

        pUI = _pMsTscAx->GetCoreUI();
        TRC_ASSERT(pUI,(TB,_T("pUI is not set")));

        if (!(pUI->UI_IsCoreInitialized() &&
              pUI->UI_CanAutoReconnect()  &&
              pUI->UI_GetEnableAutoReconnect())) {

            TRC_NRM((TB,_T("Skipping ARC core:%d canarc:%d arcenabled:%d"),
                     pUI->UI_IsCoreInitialized(),
                     pUI->UI_CanAutoReconnect(),
                     pUI->UI_GetEnableAutoReconnect()));
            DC_QUIT;

        }

        maxArcConAttempts = pUI->UI_GetMaxArcAttempts();

        //
        // 1. Make a policy decision based on the disconnect reason
        //    as to whether or not we should try to autoreconnect
        //

        //
        // If this is a network error then try to autoreconnect
        //
        if (IsNetworkError(disconnectReason, exReasonCode)) {
            fShouldAutoReconnect = TRUE;
        }

        if (fShouldAutoReconnect) {

            TRC_NRM((TB,_T("Proceeding with autoreconnect")));

            //
            // Reset continue flag on first attempt
            //
            if (0 == _nArcAttempts) {
                _fContinueArc = TRUE;
            }
            _nArcAttempts++;

            //
            // Default to automatic processing
            //
            arcContinue = autoReconnectContinueAutomatic;
            _fAutomaticArc = TRUE;

            //
            // 2.a) Fire the autoreconnection event to notify the core
            //
            pUI->UI_OnAutoReconnecting(disconnectReason,
                                      _nArcAttempts,
                                      maxArcConAttempts,
                                      &fCoreAllowsArcContinue);

            if (fCoreAllowsArcContinue) {
                //
                // 2.b) Fire the autoreconnection event to notify the container
                //
                hr = ((CProxy_IMsTscAxEvents<CMsTscAx>*)
                      _pMsTscAx)->Fire_AutoReconnecting(
                            disconnectReason,
                            _nArcAttempts,
                            &arcContinue
                            );
            }
            else {
                //
                // Core said stop arc
                //
                TRC_NRM((TB,_T("Stopping arc in response to core request")));
                hr = S_OK;
                arcContinue = autoReconnectContinueStop;
            }

            //
            // If the event processing succeeded or if the caller did nothing
            // with it as in E_NOTIMPL then carry on
            //
            if (SUCCEEDED(hr) || E_NOTIMPL == hr) {

                //
                // 3. Take action depending on what the container requested
                //
                switch (arcContinue)
                {
                    case autoReconnectContinueAutomatic:
                    {
                        //
                        // 1) wait Ns then try to connect
                        // 2) if get disconnected and land back in here
                        //    allow increment and retry up to n attemps
                        //

                        if (_nArcAttempts <= maxArcConAttempts) {
                            //
                            // For first try don't do any waiting
                            // but still dispatch thru the same deferred
                            // message code path. The timercallback will
                            // kick off a connection attempt
                            //
                            UINT nDelay = (1 == _nArcAttempts) ?
                                0 : ARC_RECONNECTION_DELAY;
                            if (SetTimer(_pMsTscAx->GetHwnd(),
                                          (UINT_PTR)(this),
                                          nDelay,
                                          sArcTimerCallBackProc)) {
                                fContinueDisconnect = FALSE;
                            }
                            else {
                                fContinueDisconnect = TRUE;
                                TRC_ERR((TB,_T("Arc settimer failed: 0x%x"),
                                         GetLastError()));
                            }

                        }
                        else {
                            TRC_NRM((TB,
                             _T("Arc exceed con attempts: %d of %d"),
                             _nArcAttempts, maxArcConAttempts)); 
                            fContinueDisconnect = TRUE;
                        }
                    }
                    break;
    
                    case autoReconnectContinueStop:
                    {
                        TRC_NRM((TB,
                            _T("Container requested ARC continue stop")));
                    }
                    break;
    
                    case autoReconnectContinueManual:
                    {
                        //
                        // Flag that this is no longer automatic
                        //
                        _fAutomaticArc = FALSE;

                        //
                        // Just return, the container will drive
                        // the process by calling AutoReconnect
                        //
                        fContinueDisconnect = FALSE;
                    }
                    break;
    
                    default:
                    {
                        TRC_ERR((TB,_T("Unknown arcContinue code: 0x%x"),
                                 arcContinue));
                    }
                    break;
                }
            }
            else {
                TRC_ERR((TB,_T("Not arcing event ret hr: 0x%x"), hr));
            }
        }
    }

DC_EXIT_POINT:
    *pfContinueDisconnect = fContinueDisconnect;

    DC_END_FN();
}


//
// IsUserInitiatedDisconnect
// Returns TRUE if the disconnection was initiated by the user
//
// Params:
//  disconnectReason - disconnection reason code
//  exReason - exteneded disconnection reason
//
BOOL
CArcMgr::IsUserInitiatedDisconnect(
    LONG disconnectReason,
    ExtendedDisconnectReasonCode exReason
    )
{
    ULONG mainDiscReason;
    BOOL fIsUserInitiated = FALSE;

    DC_BEGIN_FN("IsUserInitiatedDisconnect");

    //
    // REVIEW (nadima): mechanism to ensure new errors still work?
    //

    //
    // If this is a user-initiated disconnect, don't do a popup.
    //
    mainDiscReason = NL_GET_MAIN_REASON_CODE(disconnectReason);

    if (((disconnectReason !=
          UI_MAKE_DISCONNECT_ERR(UI_ERR_NORMAL_DISCONNECT)) &&
         (mainDiscReason != NL_DISCONNECT_REMOTE_BY_USER)   &&
         (mainDiscReason != NL_DISCONNECT_LOCAL))           ||
         (exDiscReasonReplacedByOtherConnection == exReason)) {

        fIsUserInitiated = TRUE;

    }

    DC_END_FN();
    return fIsUserInitiated;
}

BOOL
CArcMgr::IsNetworkError(
    LONG disconnectReason,
    ExtendedDisconnectReasonCode exReason
    )
{
    BOOL fIsNetworkError = FALSE;
    ULONG mainReasonCode;

    DC_BEGIN_FN("IsNetworkError");

    mainReasonCode = NL_GET_MAIN_REASON_CODE(disconnectReason);

    if (((mainReasonCode == NL_DISCONNECT_ERROR) ||
         (UI_MAKE_DISCONNECT_ERR(UI_ERR_GHBNFAILED) == disconnectReason) ||
         (UI_MAKE_DISCONNECT_ERR(UI_ERR_DNSLOOKUPFAILED) == disconnectReason)) &&
        (exDiscReasonNoInfo == exReason)) {

        fIsNetworkError = TRUE;

    }

    DC_END_FN();
    return fIsNetworkError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\mstscax\arcmgr.h ===
//
// arcmgr.h: AutoReconnect manager class
// Copyright (C) Microsoft Corporation 1999-2001
// (nadima)
//

#ifndef _arcmgr_h_
#define _arcmgr_h_

#include "atlwarn.h"

class CMsTscAx;

class CArcMgr
{
public:
    CArcMgr();
    ~CArcMgr();

    VOID
    SetParent(
        CMsTscAx* pParent
        ) {_pMsTscAx = pParent;}
    VOID
    OnNotifyDisconnected(
        LONG disconnectReason,
        ExtendedDisconnectReasonCode exReasonCode,
        PBOOL pfContinueDisconnect
        );

    VOID
    ResetArcAttempts()  {_nArcAttempts = 0;}

    BOOL
    IsAutomaticArc()    {return _fAutomaticArc;}
    BOOL
    IsAutoReconnecting()
    {
        return (_nArcAttempts > 0);
    }

private:
    static BOOL
    IsUserInitiatedDisconnect(
        LONG disconnectReason,
        ExtendedDisconnectReasonCode exReason
        );

    static BOOL
    IsNetworkError(
        LONG disconnectReason,
        ExtendedDisconnectReasonCode exReason
        );

    static VOID CALLBACK
    sArcTimerCallBackProc(
        HWND hwnd,
        UINT uMsg,
        UINT_PTR idEvent,
        DWORD dwTime
        );

    VOID
    ArcTimerCallBackProc(
        HWND hwnd,
        UINT uMsg,
        UINT_PTR idEvent,
        DWORD dwTime
        );


private:
    CMsTscAx* _pMsTscAx;
    LONG _nArcAttempts;
    BOOL _fAutomaticArc;
    BOOL _fContinueArc;
};


#endif //_arcmgr_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\mstscax\cleanup.h ===
/**INC+**********************************************************************/
/* Header: cleanup.h                                                        */
/*                                                                          */
/* Purpose: CCleanUp class declartion                                       */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1998                                  */
/*                                                                          */
/****************************************************************************/
#ifndef __CLEANUP_H_
#define __CLEANUP_H_

/**CLASS+********************************************************************/
/* Name:      CCleanUp                                                      */
/*                                                                          */
/* Purpose:   When user closes / press previous page in the browser ActiveX */
/*            or Plugin main window will be destroyed immediately. But core */
/*            will take some time clean up all the resources. Once the core */
/*            clean up is over we can start the UI clean up. This class     */
/*            encapsulates the clean up process, if ActiveX or Plugin main  */
/*            is destroyed before a proper cleanup.                         */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1998                                  */
/*                                                                          */
/****************************************************************************/
/**CLASS+********************************************************************/
class CCleanUp
{
public:
    CCleanUp();
    CCleanUp(CCleanUp& );

/****************************************************************************/
/* Cleanup window class.                                                    */
/****************************************************************************/
    static LPCTSTR CLEANUP_WND_CLS;
/****************************************************************************/
/* Window to recieve the messages from core.                                */
/****************************************************************************/
    HWND    m_hWnd;
/****************************************************************************/
/* Flag to note whether cleanup is completed or not.                        */
/****************************************************************************/
    BOOL    m_bCleaned;

public:
/****************************************************************************/
/* Cleanup window procedure.                                                */
/****************************************************************************/
    static LRESULT CALLBACK StaticWindowProc(HWND hWnd, UINT Msg,
                                               WPARAM wParam, LPARAM lParam);
    LRESULT CALLBACK        WindowProc(HWND hWnd, UINT Msg,
                                               WPARAM wParam, LPARAM lParam);
    HWND   Start();
    void   End();
};
#endif //__CLEANUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\mstscax\atlwarn.h ===
/**MOD+**********************************************************************/
/* Module:    atlwarn.h                                                     */
/*                                                                          */
/* Purpose:   ATL warnings fix                                              */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1999                                  */
/*                                                                          */
/****************************************************************************/

#ifndef _ATLWARN_H
#define _ATLWARN_H

//
// fix ATL internal warnings. These pragmas
// are defined in the ATL files, but they get overriden
// so re-include them here.
//             

#pragma warning(disable: 4201) // nameless unions are part of C++
#pragma warning(disable: 4127) // constant expression
#pragma warning(disable: 4505) // unreferenced local function has been removed
#pragma warning(disable: 4512) // can't generate assignment operator (so what?)
#pragma warning(disable: 4514) // unreferenced inlines are common
#pragma warning(disable: 4103) // pragma pack
#pragma warning(disable: 4702) // unreachable code
#pragma warning(disable: 4237) // bool
#pragma warning(disable: 4710) // function couldn't be inlined
#pragma warning(disable: 4355) // 'this' : used in base member initializer list
#pragma warning(disable: 4097) // typedef name used as synonym for class-name
#pragma warning(disable: 4786) // identifier was truncated in the debug information
#pragma warning(disable: 4268) // const static/global data initialized to zeros
#pragma warning(disable: 4291) // allow placement new

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\mstscax\cleanup.cpp ===
/**MOD+**********************************************************************/
/* Module:    cleanup.cpp                                                   */
/*                                                                          */
/* Class  :   CCleanUp                                                      */
/*                                                                          */
/* Purpose:   When user closes / press previous page in the browser ActiveX */
/*            or Plugin main window will be destroyed immediately. But core */
/*            will take some time clean up all the resources. Once the core */
/*            clean up is over we can start the UI clean up. This class     */
/*            encapsulates the clean up process, if ActiveX or Plugin main  */
/*            is destroyed before a proper cleanup.                         */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1998                                  */
/*                                                                          */
/****************************************************************************/
#include "stdafx.h"
#include "atlwarn.h"
#include "cleanup.h"

#include "autil.h"
#include "wui.h"

#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "cleanup"
#include <atrcapi.h>

/****************************************************************************/
/* Cleanup window class.                                                    */
/****************************************************************************/
LPCTSTR CCleanUp::CLEANUP_WND_CLS = _T("CleanUpWindowClass");


CCleanUp::CCleanUp()
{
    /****************************************************************************/
    /* Window to recieve the messages from core.                                */
    /****************************************************************************/
    m_hWnd = NULL;
    
    /****************************************************************************/
    /* Flag to note whether cleanup is completed or not.                        */
    /****************************************************************************/
    m_bCleaned = TRUE;
}


/**PROC+*********************************************************************/
/* Name:      CCleanUp::Start                                               */
/*                                                                          */
/* Purpose:   Notes the request for cleanup. Returns the window handle that */
/*            need to be informed with a message WM_TERMTSC after the clean */
/*            up completed          .                                       */
/**PROC-*********************************************************************/
HWND CCleanUp::Start()
{
    DC_BEGIN_FN("CleanUp::Start");

    HINSTANCE hInstance;
    

#ifdef PLUGIN
      extern HINSTANCE hPluginInstance;
      hInstance     = hPluginInstance;
#else
      hInstance     = _Module.GetModuleInstance();
#endif

    /************************************************************************/
    /* if window is not yet created, create the window after registering the*/
    /* class.                                                               */
    /************************************************************************/
    if(m_hWnd == NULL)
    {
        WNDCLASS    finalWindowClass;
        ATOM        registerClassRc;
        WNDCLASS    tmpWndClass;

        if(!GetClassInfo( hInstance, CLEANUP_WND_CLS, &tmpWndClass))
        {
            finalWindowClass.style         = 0;
            finalWindowClass.lpfnWndProc   = StaticWindowProc;
            finalWindowClass.cbClsExtra    = 0;
            finalWindowClass.cbWndExtra    = sizeof(void*);
            finalWindowClass.hInstance     = hInstance;
            finalWindowClass.hIcon         = NULL;
            finalWindowClass.hCursor       = NULL;
            finalWindowClass.hbrBackground = NULL;
            finalWindowClass.lpszMenuName  = NULL;
            finalWindowClass.lpszClassName = CLEANUP_WND_CLS;
    
            registerClassRc = ::RegisterClass (&finalWindowClass);
            
            /********************************************************************/
            /* Failed to register final window class.                           */
            /********************************************************************/
            if (registerClassRc == 0)
            {
                TRC_ERR((TB, _T("Failed to register final window class")));
                ATLASSERT(registerClassRc);
                return NULL;
            }
        }

        m_hWnd = ::CreateWindow(CLEANUP_WND_CLS, NULL, WS_OVERLAPPEDWINDOW,
                                 CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, NULL,
                                  NULL, hInstance, this);

        if (m_hWnd == NULL)
        {
            TRC_ERR((TB, _T("Failed to create final window.")));
            ATLASSERT(m_hWnd);
            return NULL;
        }
    }

    /************************************************************************/
    /* Set m_bCleaned to TRUE to note that Cleanup was requested            */
    /************************************************************************/
    m_bCleaned = FALSE;

    DC_END_FN();

    return m_hWnd;
}

/**PROC+*********************************************************************/
/* Name:      CCleanUp::End                                                */
/*                                                                          */
/* Purpose:   Process the messages of the application till the mmessage     */
/*            WM_TERMTSC is recived.                                        */
/**PROC-*********************************************************************/
void CCleanUp::End()
{
    DC_BEGIN_FN("CleanUp::End");

    HINSTANCE hInstance;
    hInstance     = _Module.GetModuleInstance();

    /************************************************************************/
    /* Browsers are unloading the plugin DLL, even before the clean up msgs */
    /* posted by core are processed. Do a message loop before unloading the */
    /* plugin DLL, till all the clean up messages are processed.            */
    /************************************************************************/
    MSG msg; 
    while(!m_bCleaned && GetMessage(&msg, NULL, 0, 0))
    { 
        TranslateMessage(&msg);
        DispatchMessage(&msg); 
    }

    //
    // If this assert fires the most likely cause
    // is that the container app exited (posted WM_QUIT or called PostQuitMessage)
    // without waiting for it's child windows to be destroyed. This is _evil_
    // bad parent app, bad.
    //
    // Anyway, the end result is that cleanup is not done properly..Not a huge
    // deal, but it's a good assert because it helps us catch badly behaved
    // containers.
    //
    // In case you're wondering. The WM_NCDESTORY message is sent to an APP
    // _after_ WM_DESTROY and _after_ the child windows have been destroyed.
    // that's the right time to call PostQuitMessage.
    //

    TRC_ASSERT(m_bCleaned,
               (TB, _T("m_bCleaned is FALSE and we exited cleanup!!!\n")));

    /************************************************************************/
    /* Clean up the final window class and window.                          */
    /************************************************************************/
    DestroyWindow(m_hWnd);
    m_hWnd = NULL;

    if(!UnregisterClass(CLEANUP_WND_CLS, hInstance))
    {
        TRC_ERR((TB, _T("Failed to unregister final window class")));
    }

    DC_END_FN();
    return;
}

/**PROC+*********************************************************************/
/* Name: CCleanUp::WindowProc                                               */
/*                                                                          */
/* Signals after recieving the message WM_TERMTSC by setting m_bCleaned to  */
/* to TRUE.                                                                 */
/**PROC+*********************************************************************/
LRESULT CALLBACK CCleanUp::StaticWindowProc(HWND hWnd, UINT message,
                                                WPARAM wParam, LPARAM lParam)
{
    CCleanUp* pCleanUp = (CCleanUp*)GetWindowLongPtr(hWnd, GWLP_USERDATA);
    if(WM_CREATE == message)
    {
        //pull out the this pointer and stuff it in the window class
        LPCREATESTRUCT lpcs = (LPCREATESTRUCT) lParam;
        pCleanUp = (CCleanUp*)lpcs->lpCreateParams;

        SetWindowLongPtr( hWnd, GWLP_USERDATA, (LONG_PTR)pCleanUp);
    }
    
    //
    // Delegate the message to the appropriate instance
    //

    if(pCleanUp)
    {
        return pCleanUp->WindowProc(hWnd, message, wParam, lParam);
    }
    else
    {
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
}


LRESULT CALLBACK CCleanUp::WindowProc(HWND hWnd, UINT message,
                                                WPARAM wParam, LPARAM lParam)
{
    switch( message )
    {
        case WM_TERMTSC:
              m_bCleaned= TRUE;
              return 0;

        default:
              break;
    }

    return ::DefWindowProc(hWnd, message, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\mstscax\dlgbase.cpp ===
//
// dlgbase.cpp: base class for dialogs
//

#include "stdafx.h"
#include "dlgbase.h"

#include "atlwarn.h"

BEGIN_EXTERN_C
#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "dlgbase"
#include <atrcapi.h>
END_EXTERN_C

#define DLG_WND_CLASSNAME _T("axtscdlg")

#ifndef OS_WINCE //CE_FIXNOTE: Needs to be ported to CE

CDlgBase::CDlgBase(HWND hwndOwner, HINSTANCE hInst, INT dlgResId) :
                         _hwndOwner(hwndOwner), _hInstance(hInst), _dlgResId(dlgResId)
{
    _hwndDlg = NULL;
    _startupLeft = _startupTop = 0;
}

CDlgBase::~CDlgBase()
{
}

//
// Name:      DialogBoxProc
//                                                                          
// Purpose:   Provides message handling for basic operation
//                                                                          
// Returns:   TRUE - if message dealt with
//            FALSE otherwise
//                                                                          
// Params:    See windows documentation
//                                                                          
//
INT_PTR CALLBACK CDlgBase::DialogBoxProc(HWND hwndDlg,
                                         UINT uMsg,
                                         WPARAM wParam,
                                         LPARAM lParam)
{
    INT_PTR rc = FALSE;

    DC_BEGIN_FN("DialogBoxProc");

    DC_IGNORE_PARAMETER(lParam);

    //
    // Handle dialog messages
    //
    switch(uMsg)
    {
        case WM_INITDIALOG:
        {
            SetDialogAppIcon(hwndDlg);
            rc = TRUE;
        }
        break;

        case WM_COMMAND:
        {
            switch(DC_GET_WM_COMMAND_ID(wParam))
            {
                case IDCANCEL:
                {
                    //
                    // Closes the dialog
                    //
                    TRC_NRM((TB, _T("Close dialog")));

                    if(hwndDlg)
                    {
                        EndDialog(hwndDlg, IDCANCEL);
                    }

                    rc = TRUE;
                }
                break;

                default:
                {
                    //
                    // Do Nothing
                    //
                }
                break;
            }
        }
        break;

        case WM_CLOSE:
        {
            //
            // Closes the dialog
            //
            TRC_NRM((TB, _T("Close dialog")));
            if(IsWindow(hwndDlg))
            {
                EndDialog(hwndDlg, IDCANCEL);
            }
            rc = 0;
        }
        break;

        default:
        {
            //
            // Do Nothing
            //
        }
        break;
    }

    DC_END_FN();

    return(rc);

} // DialogBoxProc


//
// Name:      SetDialogAppIcon
//                                                                          
// Purpose:   Sets the icon for the dialog to the application icon
//                                                                          
// Returns:   Yes, it does
//                                                                          
// Params:    IN   HWND   the dialog for which we want to set the icon
//                                                                          
//                                                                          
//
void CDlgBase::SetDialogAppIcon(HWND hwndDlg)
{
#ifdef OS_WINCE
    DC_IGNORE_PARAMETER(hwndDlg);
#else // !OS_WINCE
    HICON hIcon = NULL;

    hIcon = LoadIcon(_hInstance, MAKEINTRESOURCE(UI_IDI_ICON));
    if(hIcon)
    {
#ifdef OS_WIN32
        SendMessage(hwndDlg, WM_SETICON, ICON_BIG, (LPARAM)hIcon);
#else //OS_WIN32
        SetClassWord(hwndDlg, GCW_HICON, (WORD)hIcon);
#endif //OS_WIN32
    }
#endif // OS_WINCE
} // UISetDialogAppIcon


//
// Name:      EnableDlgItem
//                                                                          
// Purpose:   Enables or disables a specified dialog control
//                                                                          
// Returns:   Nothing.
//                                                                          
// Params:
//            dlgItemId - dialog control id
//            enabled   - TRUE enables the control, FALSE disables it
//                                                                          
//
DCVOID CDlgBase::EnableDlgItem(UINT  dlgItemId,
                               BOOL  enabled )
{
    HWND hwndDlgItem = NULL;
    DC_BEGIN_FN("EnableDlgItem");

    if(_hwndDlg)
    {
        hwndDlgItem = GetDlgItem(_hwndDlg, dlgItemId);
    }

    if(hwndDlgItem)
    {
        EnableWindow(hwndDlgItem, enabled);
    }

    DC_END_FN();
    return;
}

//
// Name:      CenterWindowOnParent
//                                                                          
// Purpose:   Center a window inside another
//                                                                          
// Returns:   None
//                                                                          
// Params:    HWND hwndCenterOn (window to center on)
//            xRatio - horizontal centering factor e.g 2 for (1/2)
//            yRatio - vertical   centering factor e.g 3 for (1/3)
//                                                                          
//                                                                          
//
VOID CDlgBase::CenterWindow(HWND hwndCenterOn,
                              INT xRatio,
                              INT yRatio)
{
    RECT  childRect;
    RECT  parentRect;
    INT xPos;
    INT yPos;

    LONG  desktopX = GetSystemMetrics(SM_CXSCREEN);
    LONG  desktopY = GetSystemMetrics(SM_CYSCREEN);

    BOOL center = TRUE;

    DC_BEGIN_FN("CenterWindowOnParent");

    TRC_ASSERT(_hwndDlg, (TB, _T("_hwndDlg is NULL...was it set in WM_INITDIALOG?\n")));
    if (!_hwndDlg)
    {
        TRC_ALT((TB, _T("Window doesn't exist")));
        DC_QUIT;
    }
    if (!xRatio)
    {
        xRatio = 2;
    }
    if (!yRatio)
    {
        yRatio = 2;
    }

#ifndef OS_WINCE

    if(!hwndCenterOn)
    {
        hwndCenterOn = GetDesktopWindow();
    }

    GetWindowRect(hwndCenterOn, &parentRect);

#else //OS_WINCE

    if(!hwndCenterOn)
    {
        //
        // WinCE doesn't have GetDesktopWindow()
        //

        /* CE_FIXNOTE: fix this for CE, pickup g_CEConfig
           but do it without the use of globals (since the control)
           can run multi-instance.
        
        if (g_CEConfig != CE_CONFIG_WBT)
        {
            SystemParametersInfo(SPI_GETWORKAREA, 0, (PVOID)&parentRect, 0);
        }
        else
        {
            parentRect.left   = 0;
            parentRect.top    = 0;
            parentRect.right  = desktopX;
            parentRect.bottom = desktopY;
        }
        */
    }
    else
    {
        GetWindowRect(hwndCenterOn, &parentRect);
    }

#endif//OS_WINCE

    GetWindowRect(_hwndDlg, &childRect);

    //
    // Calculate the top left - centered in the parent window.
    //
    xPos = ( (parentRect.right + parentRect.left) -
             (childRect.right - childRect.left)) / xRatio;
    yPos = ( (parentRect.bottom + parentRect.top) -
             (childRect.bottom - childRect.top)) / yRatio;

    //
    // Constrain to the desktop
    //
    if (xPos < 0)
    {
        xPos = 0;
    }
    else if (xPos > (desktopX - (childRect.right - childRect.left)))
    {
        xPos = desktopX - (childRect.right - childRect.left);
    }
    if (yPos < 0)
    {
        yPos = 0;
    }
    else if (yPos > (desktopY - (childRect.bottom - childRect.top)))
    {
        yPos = desktopY - (childRect.bottom - childRect.top);
    }

    TRC_DBG((TB, _T("Set dialog position to %u %u"), xPos, yPos));
    SetWindowPos(_hwndDlg,
                 NULL,
                 xPos, yPos,
                 0, 0,
                 SWP_NOSIZE | SWP_NOACTIVATE);

DC_EXIT_POINT:
    DC_END_FN();

    return;

} // CenterWindowOnParent

//
// Retreive current dialog position
//
BOOL CDlgBase::GetPosition(int* pLeft, int* pTop)
{
    if(!pLeft || !pTop)
    {
        return FALSE;
    }

    if(!_hwndDlg)
    {
        return FALSE;
    }

    WINDOWPLACEMENT wndPlc;
    wndPlc.length = sizeof(WINDOWPLACEMENT);
    if(GetWindowPlacement(_hwndDlg, &wndPlc))
    {
        *pLeft = wndPlc.rcNormalPosition.left;
        *pTop  = wndPlc.rcNormalPosition.top;
        return TRUE;
    }
    return FALSE;
}

BOOL CDlgBase::SetPosition(int left, int top)
{
    if(!_hwndDlg)
    {
        return FALSE;
    }
    if(!::SetWindowPos(_hwndDlg,
                       NULL,
                       left,
                       top,
                       0,
                       0,
                       SWP_NOZORDER | SWP_NOSIZE))
    {
        return FALSE;
    }
    return TRUE;
}

INT_PTR CALLBACK CDlgBase::StaticDialogBoxProc(HWND hwndDlg,
                                               UINT uMsg,
                                               WPARAM wParam,
                                               LPARAM lParam)
{
    CDlgBase* pDlg = NULL;
    DC_BEGIN_FN("StaticDialogBoxProc");
    
    if(WM_INITDIALOG == uMsg)
    {
        //
        // lParam contains this pointer (passed in DialogBoxParam)
        //
        pDlg = (CDlgBase*) lParam;
        TRC_ASSERT(pDlg,(TB,_T("Got null instance pointer (lParam) in WM_INITDIALOG")));
        if(!pDlg)
        {
            return 0;
        }
        //
        // Store the dialog pointer in the windowclass
        //
        SetLastError(0);
        if(!SetWindowLongPtr( hwndDlg, GWLP_USERDATA, (LONG_PTR)pDlg))
        {
            if(GetLastError())
            {
                TRC_ERR((TB,_T("SetWindowLongPtr failed 0x%x"),
                         GetLastError()));
                return 0;
            }
        }
        if (pDlg)
        {
            pDlg->_hwndDlg = hwndDlg;
        }
    }
    else
    {
        //
        // Need to retreive the instance pointer from the window class
        //
        pDlg = (CDlgBase*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    }

    //
    // Some early messages e.g WM_SETFONT
    // come in before the WM_INITDIALOG those
    // will just be discarded because we won't have an instance
    // pointer yet.
    //
    if(pDlg)
    {
        return pDlg->DialogBoxProc( hwndDlg, uMsg, wParam, lParam);
    }

    DC_END_FN();
    return 0;
}

INT CDlgBase::CreateModalDialog(LPCTSTR lpTemplateName)
{
    INT retVal;
    DC_BEGIN_FN("CreateModalDialog");
    TRC_ASSERT(lpTemplateName,(TB,_T("lpTemplateName is NULL")));

    //
    // Dialogs derived from CDlgBase use a window class with extra space
    // for an instance pointer...register it if it is not already registered
    //

    WNDCLASS wc;
    if(!GetClassInfo(_hInstance, DLG_WND_CLASSNAME, &wc))
    {
        wc.style = CS_DBLCLKS | CS_SAVEBITS | CS_BYTEALIGNWINDOW;
        wc.lpfnWndProc = DefDlgProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = DLGWINDOWEXTRA + sizeof(void*);
        wc.hInstance  = _hInstance;
        wc.hIcon      = LoadIcon(_hInstance, MAKEINTRESOURCE(UI_IDI_ICON));
        wc.hCursor    = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
        wc.lpszMenuName = NULL;
        wc.lpszClassName = DLG_WND_CLASSNAME;

        retVal = RegisterClass(&wc);
        if(!retVal)
        {
            //
            // It is ok if the call failed because the class already
            // exists (it may have been created on some other thread
            // after the GetClassInfo call
            //
            if(ERROR_CLASS_ALREADY_EXISTS != GetLastError())
            {
                return 0;
            }
            else
            {
                TRC_ABORT((TB,_T("Unable to register wndclass for dialog")));
            }
        }
    }


    retVal = DialogBoxParam(_hInstance, lpTemplateName, _hwndOwner,
                            StaticDialogBoxProc, (LPARAM) this);
    TRC_ASSERT((retVal != 0 && retVal != -1), (TB, _T("DialogBoxParam failed\n")));

    //
    // FixFix free the wnd class
    //

    DC_END_FN();
    return retVal;
}

//
// Move the dialog controls
//
void CDlgBase::RepositionControls(int moveDeltaX, int moveDeltaY, UINT* ctlIDs, int numID)
{
    if(_hwndDlg)
    {
        for(int i=0; i< numID; i++)
        {
            HWND hwndCtrl = GetDlgItem(_hwndDlg, ctlIDs[i]);
            if( hwndCtrl)
            {
                RECT rc;
                GetWindowRect( hwndCtrl, &rc);
                MapWindowPoints( NULL, _hwndDlg, (LPPOINT)&rc, 2);
                OffsetRect( &rc, moveDeltaX, moveDeltaY);
                SetWindowPos( hwndCtrl, NULL, rc.left, rc.top, 0, 0, 
                              SWP_NOZORDER | SWP_NOSIZE);
            }
        }
    }
}

//
// Shows+enable or Hide+disable controls
//
void CDlgBase::EnableControls(UINT* ctlIDs, int numID, BOOL bEnable)
{
    if(_hwndDlg)
    {
        for(int i=0; i< numID; i++)
        {
            HWND hwndCtrl = GetDlgItem(_hwndDlg, ctlIDs[i]);
            if( hwndCtrl)
            {
                EnableWindow( hwndCtrl, bEnable);
                ShowWindow(hwndCtrl, bEnable ? SW_SHOW : SW_HIDE);
            }
        }
    }
}

//
// DoLockDlgRes - loads and locks a dialog template
// returns address of locked resource
// lpszResName - name of resource
//
DLGTEMPLATE* CDlgBase::DoLockDlgRes(LPCTSTR lpszResName)
{
    HRSRC hrsrc = FindResource(NULL, lpszResName, RT_DIALOG);
    if(!hrsrc)
    {
        return NULL;
    }
    HGLOBAL hglb = LoadResource( _hInstance, hrsrc);
    return (DLGTEMPLATE*) LockResource(hglb);
}

#endif //OS_WINCE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\mstscax\dlgbase.h ===
//
// dlgbase.h: base class for dialogs
//            (modal and modeless)
//
// Copyright (C) Microsoft Corporation 1999-2001
// (nadima)
//

#ifndef _dlgbase_h_
#define _dlgbase_h_

class CDlgBase
{
public:
    CDlgBase(HWND hwndOwner, HINSTANCE hInst, INT dlgResId);
    virtual ~CDlgBase();

    virtual INT_PTR CALLBACK DialogBoxProc (HWND hwndDlg, UINT uMsg,WPARAM wParam, LPARAM lParam);

    BOOL   GetPosition(int* pLeft, int* pTop);
    BOOL   SetPosition(int left, int top);
    void   SetStartupPosLeft(int left) {_startupLeft = left;}
    void   SetStartupPosTop(int top)   {_startupTop = top;}
    int    GetStartupPosLeft()         {return _startupLeft;}
    int    GetStartupPosTop()          {return _startupTop;}

protected:
    //
    // Protected dialog utility functions
    //

    INT    CreateModalDialog(LPCTSTR lpTemplateName);
    static INT_PTR CALLBACK StaticDialogBoxProc(HWND _hwndDlgDlg,
                                                UINT uMsg,
                                                WPARAM wParam,
                                                LPARAM lParam);

    void SetDialogAppIcon(HWND hwndDlg);
    void EnableDlgItem(UINT  dlgItemId,
                       BOOL  enabled);
    void CenterWindow(HWND hwndCenterOn, INT xRatio=2, INT yRatio=2);

protected:
    void    RepositionControls(int moveDeltaX, int moveDeltaY, UINT* ctlIDs, int numID);
    void    EnableControls(UINT* ctlIDs, int numID, BOOL bEnable);
    DLGTEMPLATE* DoLockDlgRes(LPCTSTR lpszResName);
    HWND        _hwndDlg;
    HWND        _hwndOwner;
    HINSTANCE   _hInstance;
    INT       _dlgResId;

    //
    // Start position
    //
    int         _startupLeft;
    int         _startupTop;

    //
    // End positon on exit
    //
    int         _Left;
    int         _Top;
};


#endif //_dlgbase_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\mstscax\msteventcp.h ===
/**INC+**********************************************************************/
/* Header: msteventcp.h                                                     */
/*                                                                          */
/* Purpose: CProxy_IMsTscAxEvents class declartion                          */
/*                                                                          */
/* Implements control events                                                */
/* Copyright(C) Microsoft Corporation 1999                                  */
/*                                                                          */
/****************************************************************************/

#ifndef _MSTEVENTCP_H_
#define _MSTEVENTCP_H_

//Event proxies..
//this is based on ATL wizard generated code
template <class T>
class CProxy_IMsTscAxEvents :
    public IConnectionPointImpl<T, &DIID_IMsTscAxEvents, CComDynamicUnkArray>
{

public:
    VOID Fire_Connecting()
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0;
             nConnectionIndex < nConnections;
             nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				HRESULT hr = pDispatch->Invoke(DISPID_CONNECTING,
                                               IID_NULL,
                                               LOCALE_USER_DEFAULT,
                                               DISPATCH_METHOD,
                                               &disp, NULL, NULL, NULL);
			}
		}
	}

    VOID Fire_Connected()
    {
        T* pT = static_cast<T*>(this);
        int nConnectionIndex;
        int nConnections = m_vec.GetSize();
    
        for (nConnectionIndex = 0;
             nConnectionIndex < nConnections;
             nConnectionIndex++)
        {
            pT->Lock();
            CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
            pT->Unlock();
            IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
            if (pDispatch != NULL)
            {
    
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                HRESULT hr = pDispatch->Invoke(DISPID_CONNECTED,
                                               IID_NULL,
                                               LOCALE_USER_DEFAULT,
                                               DISPATCH_METHOD,
                                               &disp, NULL, NULL, NULL);
            }
        }
    }

    VOID Fire_LoginComplete()
    {
        T* pT = static_cast<T*>(this);
        int nConnectionIndex;
        int nConnections = m_vec.GetSize();
    
        for (nConnectionIndex = 0;
             nConnectionIndex < nConnections;
             nConnectionIndex++)
        {
            pT->Lock();
            CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
            pT->Unlock();
            IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
            if (pDispatch != NULL)
            {
    
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                HRESULT hr = pDispatch->Invoke(DISPID_LOGINCOMPLETE,
                                               IID_NULL,
                                               LOCALE_USER_DEFAULT,
                                               DISPATCH_METHOD,
                                               &disp, NULL, NULL, NULL);
            }
        }
    }
    
    VOID Fire_Disconnected(long disconnectReason)
    {
        T* pT = static_cast<T*>(this);
        int nConnectionIndex;
        CComVariant* pvars = new CComVariant[1];
        if (pvars)
        {
            int nConnections = m_vec.GetSize();
            
            for (nConnectionIndex = 0;
                 nConnectionIndex < nConnections;
                 nConnectionIndex++)
            {
                pT->Lock();
                CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
                pT->Unlock();
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
                if (pDispatch != NULL)
                {
                    pvars[0] = disconnectReason;
                    DISPPARAMS disp = { pvars, NULL, 1, 0 };
                    HRESULT hr = pDispatch->Invoke(DISPID_DISCONNECTED,
                                                   IID_NULL,
                                                   LOCALE_USER_DEFAULT,
                                                   DISPATCH_METHOD,
                                                   &disp, NULL, NULL, NULL);
                }
            }
            delete[] pvars;
        }
    }

	VOID Fire_ChannelReceivedData(BSTR chanName, BSTR data)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		VARIANT vars[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0;
             nConnectionIndex < nConnections;
             nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
                vars[0].vt = VT_BSTR;
                vars[0].bstrVal = data;
                vars[1].vt = VT_BSTR;
                vars[1].bstrVal = chanName;
				DISPPARAMS disp = { (VARIANT*)&vars, NULL, 2, 0 };
				HRESULT hr = pDispatch->Invoke(DISPID_CHANNELRECEIVEDDATA,
                                               IID_NULL,
                                               LOCALE_USER_DEFAULT,
                                               DISPATCH_METHOD,
                                               &disp, NULL, NULL, NULL);
			}
		}
	}

    VOID Fire_EnterFullScreenMode()
    {
        T* pT = static_cast<T*>(this);
        int nConnectionIndex;
        int nConnections = m_vec.GetSize();
    
        for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
        {
            pT->Lock();
            CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
            pT->Unlock();
            IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
            if (pDispatch != NULL)
            {
    
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                HRESULT hr = pDispatch->Invoke(DISPID_ENTERFULLSCREENMODE,
                                               IID_NULL,
                                               LOCALE_USER_DEFAULT,
                                               DISPATCH_METHOD,
                                               &disp, NULL, NULL, NULL);
            }
        }
    }

    VOID Fire_LeaveFullScreenMode()
    {
        T* pT = static_cast<T*>(this);
        int nConnectionIndex;
        int nConnections = m_vec.GetSize();
    
        for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
        {
            pT->Lock();
            CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
            pT->Unlock();
            IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
            if (pDispatch != NULL)
            {
    
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                HRESULT hr = pDispatch->Invoke(DISPID_LEAVEFULLSCREENMODE,
                                               IID_NULL,
                                               LOCALE_USER_DEFAULT,
                                               DISPATCH_METHOD,
                                               &disp, NULL, NULL, NULL);
            }
        }
    }

    VOID Fire_RequestGoFullScreen()
    {
        T* pT = static_cast<T*>(this);
        int nConnectionIndex;
        int nConnections = m_vec.GetSize();
    
        for (nConnectionIndex = 0;
             nConnectionIndex < nConnections;
             nConnectionIndex++)
        {
            pT->Lock();
            CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
            pT->Unlock();
            IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
            if (pDispatch != NULL)
            {
    
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                HRESULT hr = pDispatch->Invoke(DISPID_REQUESTGOFULLSCREEN,
                                               IID_NULL,
                                               LOCALE_USER_DEFAULT,
                                               DISPATCH_METHOD,
                                               &disp,
                                               NULL, NULL, NULL);
            }
        }
    }

    VOID Fire_RequestLeaveFullScreen()
    {
        T* pT = static_cast<T*>(this);
        int nConnectionIndex;
        int nConnections = m_vec.GetSize();
    
        for (nConnectionIndex = 0;
             nConnectionIndex < nConnections;
             nConnectionIndex++)
        {
            pT->Lock();
            CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
            pT->Unlock();
            IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
            if (pDispatch != NULL)
            {
    
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                HRESULT hr = pDispatch->Invoke(DISPID_REQUESTLEAVEFULLSCREEN,
                                               IID_NULL,
                                               LOCALE_USER_DEFAULT,
                                               DISPATCH_METHOD,
                                               &disp,
                                               NULL, NULL, NULL);
            }
        }
    }

    VOID Fire_FatalError(LONG errorCode)
    {
        T* pT = static_cast<T*>(this);
        int nConnectionIndex;
        CComVariant* pvars = new CComVariant[1];
        if (pvars)
        {
            int nConnections = m_vec.GetSize();
            
            for (nConnectionIndex = 0;
                 nConnectionIndex < nConnections;
                 nConnectionIndex++)
            {
                pT->Lock();
                CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
                pT->Unlock();
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
                if (pDispatch != NULL)
                {
                    pvars[0] = errorCode;
                    DISPPARAMS disp = { pvars, NULL, 1, 0 };
                    HRESULT hr = pDispatch->Invoke(DISPID_FATALERROR,
                                                   IID_NULL,
                                                   LOCALE_USER_DEFAULT,
                                                   DISPATCH_METHOD,
                                                   &disp,
                                                   NULL, NULL, NULL);
                }
            }
            delete[] pvars;
        }
    }

    VOID Fire_Warning(LONG warnCode)
    {
        T* pT = static_cast<T*>(this);
        int nConnectionIndex;
        CComVariant* pvars = new CComVariant[1];
        if (pvars)
        {
            int nConnections = m_vec.GetSize();
            
            for (nConnectionIndex = 0;
                 nConnectionIndex < nConnections;
                 nConnectionIndex++)
            {
                pT->Lock();
                CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
                pT->Unlock();
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
                if (pDispatch != NULL)
                {
                    pvars[0] = warnCode;
                    DISPPARAMS disp = { pvars, NULL, 1, 0 };
                    HRESULT hr = pDispatch->Invoke(DISPID_WARNING,
                                                   IID_NULL,
                                                   LOCALE_USER_DEFAULT,
                                                   DISPATCH_METHOD,
                                                   &disp, NULL, NULL, NULL);
                }
            }
            delete[] pvars;
        }
    }

    VOID Fire_RemoteDesktopSizeChange(LONG width, LONG height)
    {
        T* pT = static_cast<T*>(this);
        int nConnectionIndex;
        CComVariant* pvars = new CComVariant[2];
        if (pvars)
        {
            int nConnections = m_vec.GetSize();
            
            for (nConnectionIndex = 0;
                 nConnectionIndex < nConnections;
                 nConnectionIndex++)
            {
                pT->Lock();
                CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
                pT->Unlock();
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
                if (pDispatch != NULL)
                {
                    //Note these are 'reversed' in reverse order in the variant
                    //array to give the right order 
                    pvars[0] = height;
                    pvars[1] = width;
                    DISPPARAMS disp = { pvars, NULL, 2, 0 };
                    HRESULT hr = pDispatch->Invoke(
                        DISPID_REMOTEDESKTOPSIZECHANGE,
                        IID_NULL,
                        LOCALE_USER_DEFAULT,
                        DISPATCH_METHOD,
                        &disp, NULL, NULL, NULL);
                }
            }
            delete[] pvars;
        }
    }

    VOID Fire_IdleTimeout()
    {
        T* pT = static_cast<T*>(this);
        int nConnectionIndex;
        int nConnections = m_vec.GetSize();
    
        for (nConnectionIndex = 0;
            nConnectionIndex < nConnections;
            nConnectionIndex++) {
            pT->Lock();
            CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
            pT->Unlock();
            IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
            if (pDispatch != NULL) {
    
                DISPPARAMS disp = { NULL, NULL, 0, 0};
                HRESULT hr = pDispatch->Invoke(DISPID_IDLETIMEOUTNOTIFICATION,
                                               IID_NULL,
                                               LOCALE_USER_DEFAULT,
                                               DISPATCH_METHOD, &disp,
                                               NULL, NULL, NULL);
            }
        }
    }

    VOID Fire_RequestContainerMinimize()
    {
        T* pT = static_cast<T*>(this);
        int nConnectionIndex;
        int nConnections = m_vec.GetSize();
    
        for (nConnectionIndex = 0;
            nConnectionIndex < nConnections;
            nConnectionIndex++) {
            pT->Lock();
            CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
            pT->Unlock();
            IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
            if (pDispatch != NULL) {
    
                DISPPARAMS disp = { NULL, NULL, 0, 0};
                HRESULT hr = pDispatch->Invoke(DISPID_REQUESTCONTAINERMINIMIZE,
                                               IID_NULL,
                                               LOCALE_USER_DEFAULT,
                                               DISPATCH_METHOD, &disp,
                                               NULL, NULL, NULL);
            }
        }
    }

    //
    // Fire an event requesting the user
    // to confirm that it is OK to close the session
    // 
    // Params:
    // fAllowCloseToProceed - value the event passes to the container
    //                        if it wished to cancel the close (e.g in
    //                        response to user UI then it must change
    //                        this value to false
    //
    HRESULT Fire_OnConfirmClose(BOOL* pfAllowCloseToProceed)
    {
        HRESULT hr = E_FAIL;
        T* pT = static_cast<T*>(this);
        int nConnectionIndex;
        int nConnections = m_vec.GetSize();
        VARIANT var;

        if(!pfAllowCloseToProceed)
        {
            return E_INVALIDARG;
        }
    
        for (nConnectionIndex = 0;
            nConnectionIndex < nConnections;
            nConnectionIndex++) {
            pT->Lock();
            CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
            pT->Unlock();
            IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);

            var.vt = VT_BYREF | VT_BOOL;
            //
            // default to TRUE (i.e allow close)
            // If container decides to override then they
            // should change this to FALSE
            //
            VARIANT_BOOL bAllowCloseToProceed =
                (*pfAllowCloseToProceed) ? VARIANT_TRUE : VARIANT_FALSE;
            var.pboolVal = &bAllowCloseToProceed;

            if (pDispatch != NULL) {

                DISPPARAMS disp = { &var, NULL, 1, 0};
                hr = pDispatch->Invoke(DISPID_CONFIRMCLOSE,
                                               IID_NULL,
                                               LOCALE_USER_DEFAULT,
                                               DISPATCH_METHOD, &disp,
                                               NULL, NULL, NULL);
                if(SUCCEEDED(hr))
                {
                    *pfAllowCloseToProceed = bAllowCloseToProceed;
                }
            }
        }
        return hr;
    }

    //
    // Fire an event to notify caller of receving TS public key
    // and wait for return whether to continue logon process
    // 
    // Params:
    // bstrTSPublicKey - Public key received from TS.
    // pfContinueLogon - Return TRUE to continue logon, FALSE to terminate 
    //                   connection.
    //
    HRESULT Fire_OnReceivedPublicKey(BSTR bstrTSPublicKey, VARIANT_BOOL* pfContinueLogon)
    {
        HRESULT hr = E_FAIL;
        T* pT = static_cast<T*>(this);
        int nConnectionIndex;
        int nConnections = m_vec.GetSize();
        VARIANT vars[2];

        if(!pfContinueLogon)
        {
            return E_INVALIDARG;
        }

        //
        // Default to TRUE to continue logon process, if no container
        // register with this event, ActiveX control will continue
        // logon process.
        //
        *pfContinueLogon = VARIANT_TRUE;

        for (nConnectionIndex = 0;
            nConnectionIndex < nConnections;
            nConnectionIndex++) {
            pT->Lock();
            CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
            pT->Unlock();
            IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);

            if (pDispatch != NULL) {

                //
                // Set to TRUE (i.e continue logon process) if container wants
                // to stop logon process, it need to change it to FALSE
                //
                VARIANT_BOOL fContinueLogon = VARIANT_TRUE;

                vars[0].vt = VT_BYREF | VT_BOOL;
                vars[0].pboolVal = &fContinueLogon;

                vars[1].vt = VT_BSTR;
                vars[1].bstrVal = bstrTSPublicKey;

                DISPPARAMS disp = { (VARIANT *)&vars, NULL, 2, 0};
                hr = pDispatch->Invoke(DISPID_RECEVIEDTSPUBLICKEY,
                                               IID_NULL,
                                               LOCALE_USER_DEFAULT,
                                               DISPATCH_METHOD, &disp,
                                               NULL, NULL, NULL);

                if( FAILED(hr) || VARIANT_FALSE == fContinueLogon )
                {
                    // Stop logon process if any failure or first one
                    // return FALSE, *pfContinueLogon is set to TRUE
                    // before getting into loop so we only need need 
                    // to set it to FALSE if any failure or container
                    // return FALSE
                    *pfContinueLogon = VARIANT_FALSE;
                    break;
                }
            }
        }
        return hr;
    }

    //
    // Fire the autoreconnect event
    // 
    // Params:
    //  disconnectReason - disconnection reason code that triggered this ARC
    //  attemptCount     - current ARC attempt #
    //  [OUT] pArcContinue - container sets to indicate next state
    //                      (auto,stop or manual)
    //
    HRESULT Fire_AutoReconnecting(
        LONG disconnectReason,
        LONG attemptCount,
        AutoReconnectContinueState* pArcContinue
        )
    {
        HRESULT hr = S_OK;
        T* pT = static_cast<T*>(this);
        int nConnectionIndex;
        int nConnections = m_vec.GetSize();
        CComVariant vars[3];

        if(!pArcContinue)
        {
            return E_INVALIDARG;
        }

        for (nConnectionIndex = 0;
            nConnectionIndex < nConnections;
            nConnectionIndex++) {
            pT->Lock();
            CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
            pT->Unlock();
            IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);

            AutoReconnectContinueState arcContinue = *pArcContinue;

            vars[2].vt = VT_BYREF | VT_I4;
            vars[2].plVal = (PLONG)pArcContinue;
            vars[1] = attemptCount;
            vars[0] = disconnectReason;

            if (pDispatch != NULL) {

                DISPPARAMS disp = { (VARIANT*)&vars, NULL, 3, 0};
                hr = pDispatch->Invoke(
                    DISPID_AUTORECONNECTING,
                    IID_NULL,
                    LOCALE_USER_DEFAULT,
                    DISPATCH_METHOD, &disp,
                    NULL, NULL, NULL
                    );
            }
        }
    
        return hr;
    }
};
#endif //_MSTEVENTCP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\mstscax\securdlg.h ===
//
// securdlg.h: security popup dialog class
// Copyright (C) Microsoft Corporation 1999-2001
// (nadima)

#ifndef _securdlg_h_
#define _securdlg_h_

#include "dlgbase.h"
#include "atlwarn.h"

class CSecurDlg : public CDlgBase
{
public:
    CSecurDlg(HWND hwndOwner, HINSTANCE hInst);
    ~CSecurDlg();

    virtual INT   DoModal();
    virtual INT_PTR CALLBACK DialogBoxProc(HWND hwndDlg, UINT uMsg,WPARAM wParam, LPARAM lParam);

    BOOL    GetRedirDrives() {return _fRedirDrives;}
    VOID    SetRedirDrives(BOOL f) {_fRedirDrives=f;}

    BOOL    GetRedirPorts() {return _fRedirPorts;}
    VOID    SetRedirPorts(BOOL f) {_fRedirPorts=f;}

    BOOL    GetRedirSCard() {return _fRedirSCard;}
    VOID    SetRedirSCard(BOOL f) {_fRedirSCard=f;}

private:
    VOID    SaveDlgSettings();
    BOOL    _fRedirDrives;
    BOOL    _fRedirPorts;
    BOOL    _fRedirSCard;
};


#endif //_securdlg_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\mstscax\password.cpp ===
/**MOD+**********************************************************************/
/* Module:    password.cpp                                                  */
/*                                                                          */
/* Class  :   CMsTscAx                                                      */
/*                                                                          */
/* Purpose:   Implements password related interfaces of the control         */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1999                                  */
/*                                                                          */
/* Author :  Nadim Abdo (nadima)                                            */
/****************************************************************************/

#include "stdafx.h"
#include "atlwarn.h"

BEGIN_EXTERN_C
#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "password"
#include <atrcapi.h>
END_EXTERN_C

//Header generated from IDL
#include "mstsax.h"

#include "mstscax.h"

/**PROC+*********************************************************************/
/* Name:      ResetNonPortablePassword                                      */
/*                                                                          */
/* Purpose:   Resets the password/salt.                                     */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID CMsTscAx::ResetNonPortablePassword()
{
    SecureZeroMemory(m_NonPortablePassword, sizeof(m_NonPortablePassword));
    SecureZeroMemory(m_NonPortableSalt, sizeof(m_NonPortableSalt));

    SetNonPortablePassFlag(FALSE);
    SetNonPortableSaltFlag(FALSE);
}

/**PROC+*********************************************************************/
/* Name:      ResetPortablePassword                                         */
/*                                                                          */
/* Purpose:   Resets the password/salt.                                     */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID CMsTscAx::ResetPortablePassword()
{
    SecureZeroMemory(m_PortablePassword, sizeof(m_PortablePassword));
    SecureZeroMemory(m_PortableSalt, sizeof(m_PortableSalt));

    SetPortablePassFlag(FALSE);
    SetPortableSaltFlag(FALSE);
}


/**PROC+*********************************************************************/
/* Name:      put_ClearTextPassword                                         */
/*                                                                          */
/* Purpose:   set password from clear text (stored in non-portable          */
/*            encrypted form).                                              */
/*                                                                          */
/**PROC-*********************************************************************/
STDMETHODIMP CMsTscAx::put_ClearTextPassword(BSTR newClearTextPassVal)
{
    USES_CONVERSION;

    if(!newClearTextPassVal) {
        return E_INVALIDARG;
    }
    
    //Reset both forms of the password
    ResetNonPortablePassword();
    ResetPortablePassword();
    
    //Password has to be encrypted in widestring format
    LPWSTR wszClearPass = (LPWSTR)(newClearTextPassVal);

    UINT cbClearTextPass = lstrlenW(wszClearPass) * sizeof(WCHAR);
    ATLASSERT( cbClearTextPass <  sizeof(m_NonPortablePassword));
    if(cbClearTextPass >= sizeof(m_NonPortablePassword))
    {
        return E_INVALIDARG;
    }

    //
    // Determine if this is a new longer format password
    //
    if (cbClearTextPass >= UI_MAX_PASSWORD_LENGTH_OLD/sizeof(WCHAR))
    {
        m_IsLongPassword = TRUE;
    }
    else
    {
        m_IsLongPassword = FALSE;
    }


    DC_MEMCPY(m_NonPortablePassword, wszClearPass, cbClearTextPass);

    if(!TSRNG_GenerateRandomBits( m_NonPortableSalt, sizeof(m_NonPortableSalt)))
    {
        ATLASSERT(0);
        ResetNonPortablePassword();
        return E_FAIL;
    }
    
    //Encrypt the password
    if(!EncryptDecryptLocalData50( m_NonPortablePassword, sizeof(m_NonPortablePassword),
                                   m_NonPortableSalt, sizeof(m_NonPortableSalt)))
    {
        ATLASSERT(0);
        ResetNonPortablePassword();
        return E_FAIL;
    }

    //Mark that the non-portable password has been set
    SetNonPortablePassFlag(TRUE);
    SetNonPortableSaltFlag(TRUE);
    
    return S_OK;
}

//
// Portable password put/get
//
STDMETHODIMP CMsTscAx::put_PortablePassword(BSTR newPortablePassVal)
{
    //
    // Deprecated
    //
    return E_NOTIMPL;
}

STDMETHODIMP CMsTscAx::get_PortablePassword(BSTR* pPortablePass)
{
    //
    // Deprecated
    //
    return E_NOTIMPL;
}

//
// Portable salt put/get
//
STDMETHODIMP CMsTscAx::put_PortableSalt(BSTR newPortableSalt)
{
    //
    // Deprecated
    //
    return E_NOTIMPL;
}

STDMETHODIMP CMsTscAx::get_PortableSalt(BSTR* pPortableSalt)
{
    //
    // Deprecated
    //
    return E_NOTIMPL;
}

//
// Non-portable (binary) password put_get
//
STDMETHODIMP CMsTscAx::put_BinaryPassword(BSTR newPassword)
{
    //
    // Deprecated
    //
    return E_NOTIMPL;
}

STDMETHODIMP CMsTscAx::get_BinaryPassword(BSTR* pPass)
{
    //
    // Deprecated
    //
    return E_NOTIMPL;
}

//
// Non-portable salt (binary) password put_get
//
STDMETHODIMP CMsTscAx::put_BinarySalt(BSTR newSalt)
{
    //
    // Deprecated
    //
    return E_NOTIMPL;
}

STDMETHODIMP CMsTscAx::get_BinarySalt(BSTR* pSalt)
{
    //
    // Deprecated
    //
    return E_NOTIMPL;
}

/**PROC+*********************************************************************/
/* Name:      ConvertNonPortableToPortablePass                              */
/*                                                                          */
/* Purpose:   Takes the non portable pass/salt pair...generates a new salt  */
/*            and re-encrypts and stores as portable                        */
/*                                                                          */
/*                                                                          */
/**PROC-*********************************************************************/
DCBOOL CMsTscAx::ConvertNonPortableToPortablePass()
{
    //
    // Deprecated
    //
    return E_NOTIMPL;
}

/**PROC+*********************************************************************/
/* Name:      ConvertPortableToNonPortablePass                              */
/*                                                                          */
/* Purpose:   Takes the portable pass/salt pair...generates a new salt      */
/*            and re-encrypts and stores as non-portable                    */
/*                                                                          */
/*                                                                          */
/**PROC-*********************************************************************/
DCBOOL CMsTscAx::ConvertPortableToNonPortablePass()
{
    //
    // Deprecated
    //
    return E_NOTIMPL;
}

/**PROC+*********************************************************************/
/* Name:      ResetPassword                                                 */
/*                                                                          */
/* Purpose:   Method to reset passwords                                     */
/*                                                                          */
/*                                                                          */
/*                                                                          */
/**PROC-*********************************************************************/
STDMETHODIMP CMsTscAx::ResetPassword()
{
    //Reset both portable and non-portable passwords
    //need to have this method because setting a password to ""
    //might be a valid password so we can't interpret that as a reset
    ResetNonPortablePassword();
    ResetPortablePassword();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\mstscax\securdlg.cpp ===
//
// securdlg.cpp: secur dialog box
//

#include "stdafx.h"

#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "securdlg"
#include <atrcapi.h>

#include "securdlg.h"

#include "msrdprc.h"

#ifndef OS_WINCE //CE_FIXNOTE: Not ported for CE yet

CSecurDlg::CSecurDlg( HWND hwndOwner, HINSTANCE hInst):
           CDlgBase( hwndOwner, hInst, IDD_SECURITY_POPUP)
{
    DC_BEGIN_FN("CSecurDlg");

    SetRedirDrives(FALSE);
    SetRedirPorts(FALSE);
    SetRedirSCard(FALSE);

    DC_END_FN();
}

CSecurDlg::~CSecurDlg()
{
}

INT CSecurDlg::DoModal()
{
    INT retVal = 0;
    DC_BEGIN_FN("DoModal");

    retVal = CreateModalDialog(MAKEINTRESOURCE(_dlgResId));
    TRC_ASSERT((retVal != 0 && retVal != -1),
               (TB, _T("DialogBoxParam failed - make sure mlang resources are appened\n")));

    DC_END_FN();
    return retVal;
}

//
// Name: DialogBoxProc
//
// Purpose: Handles Secur Box dialog
//
// Returns: TRUE if message dealt with
//          FALSE otherwise
//
// Params: See window documentation
//
//
INT_PTR CALLBACK CSecurDlg::DialogBoxProc (HWND hwndDlg,
                                           UINT uMsg,
                                           WPARAM wParam,
                                           LPARAM lParam)
{
    DC_BEGIN_FN("DialogBoxProc");
    INT_PTR rc;

    TRC_DBG((TB, _T("SecurBox dialog")));

    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            //Center the secur dialog on the screen
            CenterWindow(NULL);
            SetDialogAppIcon(hwndDlg);

            //
            // Set settings to UI settings and but don't allow
            // user to turn on props that have been initially off
            //
            CheckDlgButton(hwndDlg, IDC_CHECK_ENABLE_DRIVES,
                (GetRedirDrives() ? BST_CHECKED : BST_UNCHECKED));
            EnableDlgItem(IDC_CHECK_ENABLE_DRIVES, GetRedirDrives());

            CheckDlgButton(hwndDlg, IDC_CHECK_ENABLE_PORTS,
                (GetRedirPorts() ? BST_CHECKED : BST_UNCHECKED));
            EnableDlgItem(IDC_CHECK_ENABLE_PORTS, GetRedirPorts());

            CheckDlgButton(hwndDlg, IDC_CHECK_ENABLE_SMARTCARDS,
                (GetRedirSCard() ? BST_CHECKED : BST_UNCHECKED));
            EnableDlgItem(IDC_CHECK_ENABLE_SMARTCARDS, GetRedirSCard());

            #ifndef OS_WINCE
            if(!CUT::IsSCardReaderInstalled())
            {
            #endif //OS_WINCE
                //
                // Hide the SCard checkbox (always hidden on CE since
                // we don't support scards on CE yet).
                //
                ShowWindow(GetDlgItem(hwndDlg, IDC_CHECK_ENABLE_SMARTCARDS),
                           SW_HIDE);
            #ifndef OS_WINCE
            }
            #endif

            rc = TRUE;
        }
        break;

        case WM_DESTROY:
        {
            SaveDlgSettings();
            rc = TRUE;
        }
        break; //WM_DESTROY

        case WM_COMMAND:
        {
            switch(DC_GET_WM_COMMAND_ID(wParam))
            {
                case IDOK:
                {
                    SaveDlgSettings();
                    EndDialog(hwndDlg, IDOK);
                    rc = TRUE;
                }
                break;

                case IDCANCEL:
                {
                    EndDialog(hwndDlg, IDCANCEL);
                    rc = TRUE;
                }
                break;
            }
        }
        break;


        default:
        {
            rc = CDlgBase::DialogBoxProc(hwndDlg,
                                      uMsg,
                                      wParam,
                                      lParam);
        }
        break;
    }

    DC_END_FN();

    return(rc);
}

VOID CSecurDlg::SaveDlgSettings()
{
    //
    // Save fields
    //
    DC_BEGIN_FN("SaveDlgSettings");

    TRC_ASSERT(_hwndDlg,
               (TB,_T("_hwndDlg not set")));

    BOOL fDriveRedir = IsDlgButtonChecked(_hwndDlg, 
       IDC_CHECK_ENABLE_DRIVES);
    SetRedirDrives(fDriveRedir);

    BOOL fPortRedir = IsDlgButtonChecked(_hwndDlg, 
       IDC_CHECK_ENABLE_PORTS);
    SetRedirPorts(fPortRedir);

    BOOL fSCardRedir = IsDlgButtonChecked(_hwndDlg, 
       IDC_CHECK_ENABLE_SMARTCARDS);
    SetRedirSCard(fSCardRedir);

    DC_END_FN();
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\mstscax\mstscax.cpp ===
/**MOD+**********************************************************************/
/* Module:    mstscax.cpp                                                   */
/*                                                                          */
/* Class  :   CMsTscAx                                                      */
/*                                                                          */
/* Purpose:   RDP ActiveX control                                           */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1999-2001                             */
/*                                                                          */
/* Author :  Nadim Abdo (nadima)                                            */
/****************************************************************************/
#include "stdafx.h"
#include "atlwarn.h"

//Header generated from IDL
#include "mstsax.h"

#include "mstscax.h"
#include "vchannel.h"
#include "cleanup.h"

//
// TS Disconnection errors
//
#include "tscerrs.h"

//Advanced settings object
#include "advset.h"
//Debugger object
#include "tsdbg.h"
//Secured settings object
#include "securedset.h"

#include "securdlg.h"
#include "arcmgr.h"

//
// Version number (property returns this)
//
#ifndef OS_WINCE
#include "ntverp.h"
#endif

#ifdef OS_WINCE
extern "C" HWND          ghwndClip;
#endif

#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "mstscax"
#include <atrcapi.h>

//5 min timeout (it's this long mainly for stress)
#define CORE_INIT_TIMEOUT 300000

int   g_lockCount = 0;
DWORD g_dwControlDbgStatus = 0;

#define CONTROL_DBG_COREINIT_TIMEOUT 0x1
#define CONTROL_DBG_COREINIT_ERROR   0x2

//
// Global pointer exposed to make debugging easier
// DO NOT USE for anything else
//
CMsTscAx* g_pMsTscAx = NULL;

/**PROC+*********************************************************************/
/* Name:      CMsTscAx::CMsTscAx                                            */
/*                                                                          */
/* Purpose:   Constructor                                                   */
/*                                                                          */
/**PROC-*********************************************************************/
CMsTscAx::CMsTscAx()
{
    g_pMsTscAx = this;

    m_bWindowOnly     = TRUE;
    m_bPendConReq = FALSE;
    _ConnectionState = tscNotConnected;

    m_bStartConnected = FALSE;
    ResetNonPortablePassword();
    ResetPortablePassword();

    //
    // Client width and height default to 0 which means get the size
    // from the control container.
    //
    m_DesktopWidth = 0;
    m_DesktopHeight = 0;

    m_fRequestFullScreen = FALSE;
    
    //
    // This allocation is checked in FinalConstruct
    //
    m_pUI = new CUI();
    if(m_pUI) {
        m_pUI->UI_ResetState();
    }
    else {
        ATLTRACE("Mem alloc for m_pUI failed");
    }

    memset(m_szDisconnectedText,0,sizeof(m_szDisconnectedText));
    memset(m_szConnectingText,0,sizeof(m_szConnectingText));
    memset(m_szConnectedText,0,sizeof(m_szConnectedText));

    #ifdef DC_DEBUG
    //
    // Initial value of status messages ONLY used in debug
    // builds. Don't need to localize
    //
    StringCchCopy(m_szDisconnectedText, SIZE_TCHARS(m_szDisconnectedText),
                  _T("Server Disconnected...."));
    StringCchCopy(m_szConnectingText, SIZE_TCHARS(m_szConnectingText),
                  _T("Connecting to Server...."));
    StringCchCopy(m_szConnectedText, SIZE_TCHARS(m_szConnectedText),
                  _T("Connected to Server."));
    #endif
    
    m_lpStatusDisplay = m_szDisconnectedText;
    
    _arcManager.SetParent(this);
    
    m_pAdvancedSettingsObj = NULL;
    m_pDebuggerObj         = NULL;
    m_pSecuredSettingsObj = NULL;
    m_bCoreInit            = FALSE;
    m_fInControlLock       = FALSE;
    m_iDestroyCount        = 0;
    m_IsLongPassword       = FALSE;

    m_ConnectionMode = CONNECTIONMODE_INITIATE;
    m_SalemConnectedSocket = INVALID_SOCKET;
}

/**PROC+*********************************************************************/
/* Name:      Destructor                                                    */
/*                                                                          */
/* Purpose:   Close the active session, if any , is existing.               */
/* being activated.                                                         */
/*                                                                          */
/**PROC-*********************************************************************/
CMsTscAx::~CMsTscAx()
{
    //Lifetime of the Advanced settings object is coupled to the control
    if(m_pAdvancedSettingsObj)
    {
        m_pAdvancedSettingsObj->Release();
    }

    if(m_pDebuggerObj)
    {
        m_pDebuggerObj->Release();
    }

    if(m_pSecuredSettingsObj)
    {
        m_pSecuredSettingsObj->Release();
    }

    _arcManager.SetParent(NULL);

    m_pAdvancedSettingsObj = NULL;
    m_pDebuggerObj = NULL;
    m_pSecuredSettingsObj = NULL;
    delete m_pUI;
}

//
// Final construct handler
//
// Called just before control is fully constructed.
// 
// Do error checking here that we can't do in the ctor
//
HRESULT
CMsTscAx::FinalConstruct()
{
    HRESULT hr = S_OK;
    DC_BEGIN_FN("FinalConstruct");

    if (NULL == m_pUI) {
        TRC_ERR((TB,_T("m_pUI allocation failed, fail finalconstruct")));
        hr = E_OUTOFMEMORY;
    }

    DC_END_FN();
    return hr;
}

/**PROC+*********************************************************************/
/* Name:      put_Server                                                    */
/*                                                                          */
/* Purpose:   Server property input function.                               */
/*                                                                          */
/**PROC-*********************************************************************/
STDMETHODIMP CMsTscAx::put_Server(BSTR newVal)
{
    USES_CONVERSION;

    BOOL fServerNameChanged = FALSE;
    HRESULT hr;
    DC_BEGIN_FN("put_Server");
    
    if (!IsControlDisconnected())
    {
        TRC_ERR((TB,_T("Error, property call while connected\n")));
        return E_FAIL;
    }

    #ifdef ECP_TIMEBOMB
    if(!CheckTimeBomb())
    {
        //
        // Timebomb failed, bail out with an error message
        //
        return E_OUTOFMEMORY;
    }
    #endif

    if (newVal)
    {
        //
        // Server name is always ansi
        //
        LPTSTR serverName = (LPTSTR)(newVal);

        //
        // Allow null server names to be set
        // because environments like VB will initialise
        // the property to NULL at load time from the
        // peristence info. We validate again at connect time
        // and that ensures that the user doesn't connect
        // with a null server name.
        //
        if (*serverName)
        {
            //
            // Validate server name
            //
            if(!CUT::ValidateServerName(serverName,
                                        FALSE)) //don't accept [:port]
            {
                TRC_ERR((TB,_T("Invalid server name")));
                return E_INVALIDARG;
            }
        }

        if(_tcslen(serverName) < UT_MAX_ADDRESS_LENGTH)
        {
            //
            // If the server we are setting is different
            // than the previous one then nuke any autoreconnect
            // information.
            //
            TCHAR szPrevServer[UT_MAX_ADDRESS_LENGTH];
            hr = m_pUI->UI_GetServerName(szPrevServer,
                                         SIZE_TCHARS(szPrevServer));

            if (SUCCEEDED(hr)) {
                if (_tcscmp(serverName, szPrevServer)) {
                    fServerNameChanged = TRUE;
                }
                hr = m_pUI->UI_SetServerName(serverName);
                if (FAILED(hr)) {
                    return hr;
                }
            }
            else {
                return hr;
            }
        }
        else
        {
            return E_INVALIDARG;
        }
    }
    else
    {
        m_pUI->UI_SetServerName( _T(""));
        fServerNameChanged = TRUE;
    }

    if (fServerNameChanged) {
        //We are setting a new server name
        //clear and free autoreconnect cookies
        m_pUI->UI_SetAutoReconnectCookie(NULL, 0);
    }

    DC_END_FN();

    return S_OK;
}

/**PROC+*********************************************************************/
/* Name:      get_Server                                                    */
/*                                                                          */
/* Purpose:   Server property get function.                                 */
/*                                                                          */
/**PROC-*********************************************************************/
STDMETHODIMP CMsTscAx::get_Server(BSTR* pServer)
{
    USES_CONVERSION;
    ATLASSERT(pServer);
    if(!pServer)
    {
        return E_INVALIDARG;
    }

    OLECHAR* wszServer = (OLECHAR*)m_pUI->_UI.strAddress;
    *pServer = SysAllocString(wszServer);
    if(!*pServer) {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

/**PROC+*********************************************************************/
/* Name:      put_Domain                                                    */
/*                                                                          */
/* Purpose:   Domain property input function.                               */
/*                                                                          */
/**PROC-*********************************************************************/
STDMETHODIMP CMsTscAx::put_Domain(BSTR newVal)
{
    HRESULT hr = E_FAIL;
    USES_CONVERSION;
    DC_BEGIN_FN("put_Domain");

    if(!IsControlDisconnected())
    {
        TRC_ERR((TB,_T("Error, property call while connected\n")));
        return E_FAIL;
    }

    if (newVal)
    {
        PDCWCHAR wszDomain = (PDCWCHAR)(newVal);
        if (wcslen(wszDomain) < UI_MAX_DOMAIN_LENGTH) {
            hr = m_pUI->UI_SetDomain(wszDomain);
            DC_QUIT;
        }
        else {
            hr = E_INVALIDARG;
            DC_QUIT;
        }
    }
    else
    {
        m_pUI->UI_SetDomain(L"");
        hr = S_OK;
    }

    DC_END_FN();

DC_EXIT_POINT:
    return hr;
}

/**PROC+*********************************************************************/
/* Name:      get_Domain                                                    */
/*                                                                          */
/* Purpose:   Domain property get function.                                 */
/*                                                                          */
/**PROC-*********************************************************************/
STDMETHODIMP CMsTscAx::get_Domain(BSTR* pDomain)
{
    USES_CONVERSION;
    ATLASSERT(pDomain);
    if(!pDomain)
    {
        return E_INVALIDARG;
    }

    *pDomain = SysAllocString(m_pUI->_UI.Domain);
    if(!*pDomain)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

/**PROC+*********************************************************************/
/* Name:      put_UserName                                                  */
/*                                                                          */
/* Purpose:   UserName property input function.                             */
/*                                                                          */
/**PROC-*********************************************************************/
STDMETHODIMP CMsTscAx::put_UserName(BSTR newVal)
{
    USES_CONVERSION;
    DC_BEGIN_FN("put_UserName");

    if (!IsControlDisconnected())
    {
        TRC_ERR((TB,_T("Error, property call while connected\n")));
        return E_FAIL;
    }


    if (newVal)
    {
        PDCWCHAR szUserName = OLE2W(newVal);
        if(!szUserName)
        {
            return E_OUTOFMEMORY;
        }
        if(wcslen(szUserName) < UI_MAX_USERNAME_LENGTH)
        {
            m_pUI->UI_SetUserName(szUserName);
        }
        else
        {
            return E_INVALIDARG;
        }
    }
    else
    {
        m_pUI->UI_SetUserName(L"");
    }

    DC_END_FN();

    return S_OK;
}

/**PROC+*********************************************************************/
/* Name:      get_UserName                                                  */
/*                                                                          */
/* Purpose:   UserName property get function.                               */
/*                                                                          */
/**PROC-*********************************************************************/
STDMETHODIMP CMsTscAx::get_UserName(BSTR* pUserName)
{
    USES_CONVERSION;
    ATLASSERT(pUserName);
    if(!pUserName)
    {
        return E_INVALIDARG;
    }

    *pUserName = SysAllocString(m_pUI->_UI.UserName);
    if(!*pUserName)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

//
// Properties for disconnected status text
//
STDMETHODIMP CMsTscAx::put_DisconnectedText(/*[in]*/ BSTR  newVal)
{
    USES_CONVERSION;
    HRESULT hr;
    if (newVal) {
        LPTSTR szDisc = OLE2T(newVal);

        if (szDisc) {

            hr = CUT::StringPropPut(
                            m_szDisconnectedText,
                            SIZE_TCHARS(m_szDisconnectedText),
                            szDisc);

            if (SUCCEEDED(hr)) {
                UpdateStatusText(m_lpStatusDisplay);
                return S_OK;
            }
            else {
                return hr;
            }
        }
        else {
            return E_OUTOFMEMORY;
        }

    }
    else {
        m_szDisconnectedText[0] = NULL;
    }
    return S_OK;
}

STDMETHODIMP CMsTscAx::get_DisconnectedText(/*[out]*/BSTR* pDisconnectedText)
{
    USES_CONVERSION;
    if(pDisconnectedText)
    {
        OLECHAR* wszDiscon = (OLECHAR*)m_szDisconnectedText;
        if (wszDiscon)
        {
            *pDisconnectedText = SysAllocString(wszDiscon);
            if (*pDisconnectedText) {
                return S_OK;
            }
            else {
                return E_OUTOFMEMORY;
            }
        }
        else {
            return E_OUTOFMEMORY;
        }
    }
    else {
        return E_INVALIDARG;
    }
}

//
// Properties for connecting status text
//

STDMETHODIMP CMsTscAx::put_ConnectingText(/*[in]*/ BSTR  newVal)
{
    USES_CONVERSION;
    HRESULT hr;
    if (newVal) {
        LPTSTR szConnecting = OLE2T(newVal);
        if(szConnecting) {
            hr = CUT::StringPropPut(
                            m_szConnectingText,
                            SIZE_TCHARS(m_szConnectingText),
                            szConnecting);
            if (SUCCEEDED(hr)) {
                UpdateStatusText(m_lpStatusDisplay);
                return S_OK;
            }
            else {
                return hr;
            }
        }
        else {
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        m_szConnectingText[0] = NULL;
    }
    return S_OK;
}

STDMETHODIMP CMsTscAx::get_ConnectingText(/*[out]*/BSTR* pConnectingText)
{
    USES_CONVERSION;
    ATLASSERT(pConnectingText);
    if(pConnectingText)
    {
        OLECHAR* wszCon = (OLECHAR*)m_szConnectingText;
        if(wszCon)
        {
            *pConnectingText = SysAllocString(wszCon);
            if(*pConnectingText)
            {
                return S_OK;
            }
            else
            {
                return E_OUTOFMEMORY;
            }
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        return E_INVALIDARG;
    }
}

//
// put_ConnectedStatusText - set text for connected display
//
STDMETHODIMP CMsTscAx::put_ConnectedStatusText(/*[in]*/ BSTR  newVal)
{
    USES_CONVERSION;
    HRESULT hr;
    if(newVal)
    {
        LPTSTR szText = OLE2T(newVal);
        if(szText) {
            hr = CUT::StringPropPut(
                            m_szConnectedText,
                            SIZE_TCHARS(m_szConnectedText),
                            szText);
            if (SUCCEEDED(hr)) {
                UpdateStatusText(m_lpStatusDisplay);
                return S_OK;
            }
            else {
                return hr;
            }
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        m_szConnectedText[0] = NULL;
    }
    return S_OK;
}

//
// get_ConnectedStatusText - get text for connected display
//
STDMETHODIMP CMsTscAx::get_ConnectedStatusText(/*[out]*/BSTR* pConnectedText)
{
    USES_CONVERSION;
    ATLASSERT(pConnectedText);
    if(pConnectedText)
    {
        OLECHAR* wszCon = (OLECHAR*)m_szConnectedText;
        if(wszCon)
        {
            *pConnectedText = SysAllocString(wszCon);
            if(*pConnectedText)
            {
                return S_OK;
            }
            else
            {
                return E_OUTOFMEMORY;
            }
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        return E_INVALIDARG;
    }
}


/**PROC+*********************************************************************/
/* Name:      internal_PutStartProgram                                      */
/*                                                                          */
/* Purpose:   Alternate shell property input function.                      */
/*                                                                          */
/**PROC-*********************************************************************/
STDMETHODIMP CMsTscAx::internal_PutStartProgram(BSTR newVal)
{
    USES_CONVERSION;
    HRESULT hr;
    DC_BEGIN_FN("internal_PutStartProgram");

    if(!IsControlDisconnected())
    {
        TRC_ERR((TB,_T("Error, property call while connected\n")));
        return E_FAIL;
    }

    if (newVal) {
        PDCWCHAR szStartProg = OLE2W(newVal);
        if(!szStartProg) {
            return E_OUTOFMEMORY;
        }
        if (wcslen(szStartProg) < MAX_PATH) {
            hr = m_pUI->UI_SetAlternateShell(szStartProg);
            if (FAILED(hr)) {
                return hr;
            }
        }
        else {
            return E_INVALIDARG;
        }
    }
    else {
        m_pUI->UI_SetAlternateShell(L"");
    }

    DC_END_FN();

    return S_OK;
}

/**PROC+*********************************************************************/
/* Name:      internal_GetStartProgram                                      */
/*                                                                          */
/* Purpose:   StartProgram property get function.                           */
/*                                                                          */
/**PROC-*********************************************************************/
STDMETHODIMP CMsTscAx::internal_GetStartProgram(BSTR* pStartProgram)
{
    USES_CONVERSION;
    ATLASSERT(pStartProgram);
    if(!pStartProgram)
    {
        return E_INVALIDARG;
    }

    *pStartProgram = SysAllocString(m_pUI->_UI.AlternateShell);
    if(!*pStartProgram)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

/**PROC+*********************************************************************/
/* Name:      internal_PutWorkDir                                           */
/*                                                                          */
/* Purpose:   Working Directory property input function.                    */
/*                                                                          */
/**PROC-*********************************************************************/
STDMETHODIMP CMsTscAx::internal_PutWorkDir(BSTR newVal)
{
    HRESULT hr;
    USES_CONVERSION;
    DC_BEGIN_FN("internal_PutWorkDir");

    if(!IsControlDisconnected())
    {
        TRC_ERR((TB,_T("Error, property call while connected\n")));
        return E_FAIL;
    }

    if (newVal)
    {
        PDCWCHAR szWorkDir = OLE2W(newVal);
        if(!szWorkDir)
        {
            return E_OUTOFMEMORY;
        }
        if(wcslen(szWorkDir) < MAX_PATH)
        {
            hr = m_pUI->UI_SetWorkingDir(szWorkDir);
            if (FAILED(hr)) {
                return hr;
            }
        }
        else
        {
            return E_INVALIDARG;
        }
    }
    else
    {
        m_pUI->UI_SetWorkingDir(L"");
    }

    DC_END_FN();

    return S_OK;
}

/**PROC+*********************************************************************/
/* Name:      internal_GetWorkDir                                           */
/*                                                                          */
/* Purpose:   Working Directory property get function.                      */
/*                                                                          */
/**PROC-*********************************************************************/
STDMETHODIMP CMsTscAx::internal_GetWorkDir(BSTR* pWorkDir)
{
    USES_CONVERSION;
    ATLASSERT(pWorkDir);
    if(!pWorkDir)
    {
        return E_INVALIDARG;
    }

    *pWorkDir = SysAllocString(m_pUI->_UI.WorkingDir);
    if(!*pWorkDir)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}


/**PROC+*********************************************************************/
/* Name:      CreateVirtualChannels                                         */
/*                                                                          */
/* Purpose:   Define virtual channels that will be created given a CSV list */
/*                                                                          */
/**PROC-*********************************************************************/
#define MAX_CHANNEL_LIST_LEN (30*10)
STDMETHODIMP CMsTscAx::CreateVirtualChannels(/*[in]*/ BSTR newChanList)
{
    DC_BEGIN_FN("CreateVirtualChannels");

    USES_CONVERSION;
    char*       pszaChannelNames = NULL;
    char*       pszaChannelNamesCopy= NULL;
    PDCACHAR    token;
    DCUINT      uChanCount = 0;
    HRESULT     hr = E_FAIL;
    UINT        cbChannelNames;

    if (!IsControlDisconnected()) {
        TRC_ERR((TB,_T("Can't call while connected\n")));
        return E_FAIL;
    }

    if(m_pUI->_UI.hwndMain || !newChanList)
    {
        //
        // Error, can only Setup virtual channels before UI is initialised
        //
        return E_FAIL;
    }

    if (_VChans._ChanCount) {
        //
        // Error can only setup channels once
        //
        TRC_ERR((TB,_T("Error channels already setup: 0x%x"),
                 _VChans._ChanCount));
        return E_FAIL;
    }

    //
    // Protect ourselves by refusing to process channel lists that
    // are too long
    //
    if (_tcslen(newChanList) >= MAX_CHANNEL_LIST_LEN) {
        TRC_ERR((TB,_T("Channel list too long")));
        return E_INVALIDARG;
    }

    //
    // Channel names have to be ANSI. Do the conversion safely guarded
    // by a try/except block.
    //
    __try {
        pszaChannelNames = OLE2A(newChanList);
    }
    __except ((EXCEPTION_STACK_OVERFLOW == GetExceptionCode()) ?
                   EXCEPTION_EXECUTE_HANDLER :
                   EXCEPTION_CONTINUE_SEARCH) {
        _resetstkoflw();
        pszaChannelNames = NULL;
    }

    if(!pszaChannelNames)
    {
        return E_FAIL;
    }

    cbChannelNames = DC_ASTRLEN(pszaChannelNames) + 1;
    pszaChannelNamesCopy = new DCACHAR[cbChannelNames];
    if (!pszaChannelNamesCopy)
    {
        return E_OUTOFMEMORY;
    }

    
    hr = StringCbCopyA(pszaChannelNamesCopy, cbChannelNames, pszaChannelNames);
    if (FAILED(hr)) {
        TRC_ERR((TB,_T("StringCchCopyA for chan names failed: 0x%x"), hr));
        DC_QUIT;
    }


    //
    // Two passes through the channel names
    // 1) to validate and count the number of channels
    // 2) to create a CHANINFO data structure for each channel
    //

    token = DC_ASTRTOK( pszaChannelNamesCopy, ",");
    //
    // Get comma separated channel names
    //
    while (token)
    {
        uChanCount++;
        token = DC_ASTRTOK(NULL, ",");
        if(token && (strlen(token) > CHANNEL_NAME_LEN))
        {
            #ifdef UNICODE
            TRC_ERR((TB,_T("Channel name too long: %S"),token));
            #else
            TRC_ERR((TB,_T("Channel name too long: %s"),token));
            #endif
            DC_QUIT;
        }
    }

    if(!uChanCount)
    {
        //
        // No channels specified
        //
        hr = E_INVALIDARG;
        DC_QUIT;
    }

    _VChans._pChanInfo = (PCHANINFO) LocalAlloc(LPTR,
                        sizeof(CHANINFO) * uChanCount);
    if (_VChans._pChanInfo == NULL) {
        TRC_DBG((TB,_T("mstscax: LocalAlloc failed\n")));
        hr = E_OUTOFMEMORY;
        DC_QUIT;
    }
    _VChans._ChanCount = uChanCount;
    
    //
    // Initialize the chan info data structures
    //
    int i = 0;
    token = DC_ASTRTOK( pszaChannelNames, ",");
    while (token)
    {
        hr = StringCbCopyA(_VChans._pChanInfo[i].chanName,
                      sizeof(_VChans._pChanInfo[i].chanName),
                      token);
        if (SUCCEEDED(hr)) {
            _VChans._pChanInfo[i].dwOpenHandle = 0;        

            _VChans._pChanInfo[i].CurrentlyReceivingData.chanDataState =
                 dataIncompleteAssemblingChunks;
            _VChans._pChanInfo[i].CurrentlyReceivingData.dwDataLen = 0;
            _VChans._pChanInfo[i].CurrentlyReceivingData.pData = NULL;
            _VChans._pChanInfo[i].fIsValidChannel = FALSE;
            _VChans._pChanInfo[i].channelOptions = 0;

            _VChans._pChanInfo[i].fIsOpen = FALSE;
            token = DC_ASTRTOK(NULL, ",");
            i++;
        }
        else {
            DC_QUIT;
        }
    }

    hr = S_OK;

DC_EXIT_POINT:

    if (FAILED(hr)) {
        if (_VChans._pChanInfo) {
            LocalFree(_VChans._pChanInfo);
            _VChans._pChanInfo = NULL;
        }
        _VChans._ChanCount = 0;
    }

    if (pszaChannelNamesCopy) {
        delete [] pszaChannelNamesCopy;
    }

    DC_END_FN();
    return hr;
}


/**PROC+*********************************************************************/
/* Name:      SendOnVirtualChannel                                          */
/*                                                                          */
/* Purpose:   SendData on a virtual channel                                 */
/*                                                                          */
/**PROC-*********************************************************************/
STDMETHODIMP CMsTscAx::SendOnVirtualChannel(/*[in]*/ BSTR ChanName,/*[in]*/ BSTR sendData)
{
    USES_CONVERSION;
    DCUINT   chanIndex = -1;
    HRESULT hr = S_OK;
    LPVOID  pData;
    DWORD   dataLength;
    LPSTR   pszaChanName = NULL;

    DC_BEGIN_FN("SendOnVirtualChannel");

    if(!ChanName || !sendData)
    {
        return E_INVALIDARG;
    }

    //
    // Validate against channel names that are too long
    //
    if (_tcslen(ChanName) > CHANNEL_NAME_LEN) {
        return E_INVALIDARG;
    }
    
    
    //
    // Channel names have to be ANSI. Do the conversion safely guarded
    // by a try/except block.
    //
    __try {
        pszaChanName = OLE2A(ChanName);
    }
    __except ((EXCEPTION_STACK_OVERFLOW == GetExceptionCode()) ?
                   EXCEPTION_EXECUTE_HANDLER :
                   EXCEPTION_CONTINUE_SEARCH) {
        _resetstkoflw();
        pszaChanName = NULL;
    }

    TRC_ASSERT((pszaChanName), (TB,_T("pszaChanName is NULL")));
    if (!pszaChanName)
    {
        return E_INVALIDARG;
    }
    
    chanIndex = _VChans.ChannelIndexFromName(pszaChanName);

    if (chanIndex >= _VChans._ChanCount)
    {
        TRC_DBG((TB,_T("chanIndex out of range\n")));
        return E_FAIL;
    }


    // Allocate send data buffer.  Send buffer will be freed by SendDataOnChannel
    dataLength = SysStringByteLen(sendData);
    pData = LocalAlloc(LPTR, dataLength);

    if(!pData)
    {
        return E_OUTOFMEMORY;
    }
    DC_MEMCPY(pData, sendData, dataLength);
    
    //
    // Send the data on of the web control's virtual channels
    //
    if(!_VChans.SendDataOnChannel( chanIndex, pData, dataLength))
    {
        return E_FAIL;
    }

    DC_END_FN();
    return S_OK;
}

/**PROC+*********************************************************************/
/* Name:      SetVirtualChannelOptions                                      */
/*                                                                          */
/* Purpose:   Sets virtual channel options                                  */
/*            Should be called after the CreateVirtualChannels call and     */
/*            before a connection is established                            */
/*                                                                          */
/**PROC-*********************************************************************/
STDMETHODIMP CMsTscAx::SetVirtualChannelOptions(/*[in]*/ BSTR ChanName,
                                                /*[in]*/ LONG chanOptions)
{
    USES_CONVERSION;
    UINT chanIndex = -1;
    LPSTR pszaChanName = NULL;
    
    DC_BEGIN_FN("SetVirtualChannelOptions");


    if(!ChanName)
    {
        return E_INVALIDARG;
    }

    if(!IsControlDisconnected())
    {
        //Can't call while connected
        return E_FAIL;
    }

    if(_VChans.HasEntryBeenCalled())
    {
        TRC_ERR((TB,_T("Can't set VC options after VC's have been initialized")));
        return E_FAIL;
    }

    //
    // Validate against channel names that are too long
    //
    if (_tcslen(ChanName) > CHANNEL_NAME_LEN) {
        return E_INVALIDARG;
    }
    
    //
    // Channel names have to be ANSI. Do the conversion safely guarded
    // by a try/except block.
    //
    __try {
        pszaChanName = OLE2A(ChanName);
    }
    __except ((EXCEPTION_STACK_OVERFLOW == GetExceptionCode()) ?
                   EXCEPTION_EXECUTE_HANDLER :
                   EXCEPTION_CONTINUE_SEARCH) {
        _resetstkoflw();
        pszaChanName = NULL;
    }


    TRC_ASSERT((pszaChanName), (TB,_T("pszaChanName is NULL")));
    if(!pszaChanName)
    {
        return E_INVALIDARG;
    }
    
    chanIndex = _VChans.ChannelIndexFromName(pszaChanName);
    if (chanIndex >= _VChans._ChanCount)
    {
        TRC_DBG((TB,_T("chanIndex out of range %d\n"), chanIndex));
        return E_FAIL;
    }

    _VChans._pChanInfo[chanIndex].channelOptions = chanOptions;
    TRC_NRM((TB,_T("Set VC options to %d"),
             _VChans._pChanInfo[chanIndex].channelOptions));

    DC_END_FN();
    return S_OK;
}

/**PROC+*********************************************************************/
/* Name:      GetVirtualChannelOptions                                      */
/*                                                                          */
/* Purpose:   retreives virtual channel options                             */
/*            Should be called after the CreateVirtualChannels call for     */
/*            the channel in question.                                      */
/*                                                                          */
/**PROC-*********************************************************************/
STDMETHODIMP CMsTscAx::GetVirtualChannelOptions(/*[in]*/ BSTR ChanName,
                                                /*[out]*/LONG* pChanOptions)
{
    USES_CONVERSION;
    UINT chanIndex = -1;
    LPSTR pszaChanName = NULL;
    
    DC_BEGIN_FN("SetVirtualChannelOptions");


    if(!ChanName || !pChanOptions)
    {
        return E_INVALIDARG;
    }

    //
    // Validate against channel names that are too long
    //
    if (_tcslen(ChanName) > CHANNEL_NAME_LEN) {
        return E_INVALIDARG;
    }
    
    //
    // Channel names have to be ANSI. Do the conversion safely guarded
    // by a try/except block.
    //
    __try {
        pszaChanName = OLE2A(ChanName);
    }
    __except ((EXCEPTION_STACK_OVERFLOW == GetExceptionCode()) ?
                   EXCEPTION_EXECUTE_HANDLER :
                   EXCEPTION_CONTINUE_SEARCH) {
        _resetstkoflw();
        pszaChanName = NULL;
    }

    TRC_ASSERT((pszaChanName), (TB,_T("pszaChanName is NULL")));
    if(!pszaChanName)
    {
        return E_INVALIDARG;
    }
    
    chanIndex = _VChans.ChannelIndexFromName(pszaChanName);
    if (chanIndex >= _VChans._ChanCount)
    {
        TRC_DBG((TB,_T("chanIndex out of range %d\n"), chanIndex));
        return E_FAIL;
    }

    *pChanOptions = _VChans._pChanInfo[chanIndex].channelOptions;

    TRC_NRM((TB,_T("Retreived VC options for chan %S = %d"),
             pszaChanName,
             _VChans._pChanInfo[chanIndex].channelOptions));

    DC_END_FN();
    return S_OK;
}

//
// Request a graceful shutdown of the control and correspondingly
// the user's session (this does _NOT_ shutdown the server).
//
// Params: pCloseStatus (OUT parameter)
//
//  controlCloseCanProceed   - container can go ahead with close immediately
//                             happens if we're not connected
//  controlCloseWaitForEvents- container should wait for events as described
//                             below
//
//  OnDisconnected:
//  App can proceed with the close by destroying all windows (DestroyWindow)
//
//  OnConfirmClose:
//  In the case where the user has a logged in session the
//  control will fire OnConfirmClose in which case the container
//  can pop UI asking the user if they really want to close the application
//  if they say the app can then DestoryAllWindows
//
//  NOTE: this method exists so a shell can present the same behaviour as
//       the 2195 client (because internally the client sends a
//       shutdownrequest PDU in this case).
//
// Returns success hr flag if the close request was successfully
// dispatched
//
//
STDMETHODIMP CMsTscAx::RequestClose(ControlCloseStatus* pCloseStatus)
{
    DC_BEGIN_FN("RequestClose");

    if(pCloseStatus)
    {
        if(m_bCoreInit && !IsControlDisconnected() && m_pUI)
        {
            //
            // Dispatch a close request to the core
            //
            if(m_pUI->UI_UserRequestedClose())
            {
                *pCloseStatus = controlCloseWaitForEvents;
            }
            else
            {
                *pCloseStatus = controlCloseCanProceed;
            }
            
            return S_OK;
        }
        else
        {
            TRC_NRM((TB,
             _T("Immediate close OK:%d Connected:%d, pUI:%p hwnd:%p"),
                     m_bCoreInit, _ConnectionState, m_pUI,
                     m_pUI ? m_pUI->_UI.hwndMain : (HWND)-1));
            *pCloseStatus = controlCloseCanProceed;
            return S_OK;
        }
    }
    else
    {
        return E_INVALIDARG;
    }

    DC_END_FN();
}

/****************************************************************************/
// Name:      NotifyRedirectDeviceChange
//                                                                          
// Purpose:   Send the WM_DEVICECHANGE notification to the control                             
//            The control can then notify the server for the device change
//                                                                          
/****************************************************************************/
STDMETHODIMP CMsTscAx::NotifyRedirectDeviceChange(/*[in]*/ WPARAM wParam,
                                                  /*[in]*/LPARAM lParam)
{
    DC_BEGIN_FN("NotifyRedirectDeviceChange");

    m_pUI->UI_OnDeviceChange(wParam, lParam);

    DC_END_FN();
    return S_OK;
}

/**PROC+*********************************************************************/
/* Name:      put_DesktopWidth	                                            */
/*                                                                          */
/* Purpose:   client width property input function.	                        */
/*                                                                          */
/**PROC-*********************************************************************/
STDMETHODIMP CMsTscAx::put_DesktopWidth(LONG  newVal)
{
    DC_BEGIN_FN("put_DesktopWidth");

    if(!IsControlDisconnected())
    {
        TRC_ERR((TB,_T("Can't call while connected\n")));
        return E_FAIL;
    }

    //
    // 0 is valid and means size to container
    //
    if(newVal && (newVal < MIN_DESKTOP_WIDTH || newVal > MAX_DESKTOP_WIDTH))
    {
        return E_INVALIDARG;
    }

    m_DesktopWidth = (DCUINT)newVal;

    DC_END_FN();

    return S_OK;
}

/**PROC+*********************************************************************/
/* Name:      get_DesktopWidth	                                            */
/*                                                                          */
/* Purpose:   client width property get function.	                        */
/*                                                                          */
/**PROC-*********************************************************************/
STDMETHODIMP CMsTscAx::get_DesktopWidth(LONG* pVal)
{
    if(!pVal)
    {
        return E_INVALIDARG;
    }
    *pVal = m_DesktopWidth;
    return S_OK;
}


/**PROC+*********************************************************************/
/* Name:      put_DesktopHeight	                                            */
/*                                                                          */
/* Purpose:   client Height property input function.	                    */
/*                                                                          */
/**PROC-*********************************************************************/
STDMETHODIMP CMsTscAx::put_DesktopHeight(LONG  newVal)
{
    DC_BEGIN_FN("put_DesktopHeight");
    
    if(!IsControlDisconnected())
    {
        TRC_ERR((TB,_T("Can't call while connected\n")));
        return E_FAIL;
    }

    //
    // 0 is valid and means size to container
    //
    if(newVal && (newVal < MIN_DESKTOP_HEIGHT || newVal > MAX_DESKTOP_HEIGHT))
    {
        return E_INVALIDARG;
    }

    m_DesktopHeight = (DCUINT)newVal;
    DC_END_FN();
    return S_OK;
}

/**PROC+*********************************************************************/
/* Name:      get_DesktopHeight	                                            */
/*                                                                          */
/* Purpose:   client Height property get function.  	                    */
/*                                                                          */
/**PROC-*********************************************************************/
STDMETHODIMP CMsTscAx::get_DesktopHeight(LONG*  pVal)
{
    if(!pVal)
    {
        return E_INVALIDARG;
    }
    *pVal = m_DesktopHeight;
    return S_OK;
}

/**PROC+*********************************************************************/
/* Name:      internal_PutFullScreen
/*                                              
/* Purpose:   Set fullscreen (and switches mode)
/*            This function is NOT exposed directly to the interface
/*
/* Params:
/*            fFullScreen - TRUE to go fullscreen, FALSE to leave
/*            fForceToggle - do an immediate toggle of the state
/*                           regardless of w/not we are disconnected.
/*                           default is FALSE for this param
/*
/* Remarks:
/*            Normal behaviour is to not toggle the window state when
/*            disconnected. Instead a flag is set that will take effect
/*            at the next connection. There are of course cases where
/*            that needs to be overriden and that's what fForceTogle is for.
/*            Example, on disconnected we need to leave fullscreen immediately
/*            in containers that don't handle fullscreen mode themselves
/*            otherwise they would be stuck with a toplevel fullscreen wnd.
/*                                              
/**PROC-*********************************************************************/
STDMETHODIMP CMsTscAx::internal_PutFullScreen(BOOL fFullScreen,
                                              BOOL fForceToggle)
{
    ATLASSERT(m_pUI);
    if(!m_pUI)
    {
        return E_FAIL;
    }
    DCBOOL fPrevFullScreen = m_pUI->UI_IsFullScreen();

    //no, these lines of code are not as bad as they look
    //vb's true is 0xFFFFFFF so don't just blindy assign
    if (!IsControlDisconnected() || fForceToggle)
    {
        if(fPrevFullScreen == (DCBOOL)(fFullScreen != 0))
        {
            //we are already in the requested state
            return S_OK;
        }

        if(fFullScreen)
        {
            m_pUI->UI_GoFullScreen();
        }
        else
        {
            m_pUI->UI_LeaveFullScreen();
        }
    }
    else
    {
        //
        // Save the request to go fullscreen
        // it will take effect on connection as we can't
        // ask the core to take us fullscreen until the
        // first time UI_Init is called
        //
        m_pUI->UI_SetStartFullScreen( fFullScreen != 0 );
    }
    
    return S_OK;
}

/**PROC+*********************************************************************/
/* Name:      internal_GetFullScreen        	        
/*                                              
/* Purpose:   get FullScreen mode
/*            This function is NOT exposed directly to the interface
/*                                              
/**PROC-*********************************************************************/
STDMETHODIMP CMsTscAx::internal_GetFullScreen(BOOL* pfFullScreen)
{
    ATLASSERT(pfFullScreen);
    ATLASSERT(m_pUI);
    if(!m_pUI || !pfFullScreen)
    {
        return E_FAIL;
    }

    if(!pfFullScreen)
    {
        return E_INVALIDARG;
    }

    *pfFullScreen = (m_pUI->UI_IsFullScreen() ? VB_TRUE : VB_FALSE);
    
    return S_OK;
}

/**PROC+*********************************************************************/
/* Name:      put_StartConnected        	        
/*                                              
/* Purpose:   property that indicates if the client should autoconnect
/*            on startup with the current set of connection params
/*                                              
/**PROC-*********************************************************************/
STDMETHODIMP CMsTscAx::put_StartConnected(BOOL fStartConnected)
{
    DC_BEGIN_FN("put_StartConnected");
    ATLASSERT(m_pUI);
    if(!m_pUI)
    {
        return E_FAIL;
    }

    if(!IsControlDisconnected())
    {
        TRC_ERR((TB,_T("Can't call while connected\n")));
        return E_FAIL;
    }

    //no, these lines of code are not as bad as they look
    //vb's true is 0xFFFFFFF so don't just blindy assign
    if(fStartConnected != 0)
    {
        m_bStartConnected = TRUE;
    }
    else
    {
        m_bStartConnected = FALSE;        
    }

    //m_bPendConReq gets reset which is why we keep
    //the property in  m_bStartConnected
    m_bPendConReq = m_bStartConnected;
    DC_END_FN();
    return S_OK;
}

/**PROC+*********************************************************************/
/* Name:      get_StartConnected        	        
/*                                              
/* Purpose:   get start connected property
/*                                              
/**PROC-*********************************************************************/
STDMETHODIMP CMsTscAx::get_StartConnected(BOOL* pfStartConnected)
{
    ATLASSERT(pfStartConnected);

    if(!pfStartConnected)
    {
        return E_INVALIDARG;
    }

    *pfStartConnected = m_bStartConnected;
    
    return S_OK;
}

/**PROC+*********************************************************************/
/* Name:      get_Connected
/*                         
/* Purpose:   Property, returns connection state
/*                                     
/**PROC-*********************************************************************/
STDMETHODIMP CMsTscAx::get_Connected(short* pIsConnected)
{
    ATLASSERT(pIsConnected);
    if(!pIsConnected)
    {
        return E_INVALIDARG;
    }

    *pIsConnected = (short)_ConnectionState;

    return S_OK;
}

/**PROC+*********************************************************************/
/* Name:      get_CipherStrength
/*                         
/* Purpose:   Property, returns cipher strength in bits
/*                                     
/**PROC-*********************************************************************/
STDMETHODIMP CMsTscAx::get_CipherStrength(LONG* pCipherStrength)
{
    ATLASSERT(pCipherStrength);
    if(!pCipherStrength)
    {
        return E_INVALIDARG;
    }

    //
    // Return cipher strength of the control
    //
    
    //Always 128-bit capable
    *pCipherStrength = 128;
    
    return S_OK;
}

/**PROC+*********************************************************************/
/* Name:      get_Version
/*                         
/* Purpose:   Property, returns version number as string form
/*                                     
/**PROC-*********************************************************************/
STDMETHODIMP CMsTscAx::get_Version(BSTR* pVersion)
{
    USES_CONVERSION;
    ATLASSERT(pVersion);
    OLECHAR* pVer = NULL;
    if(!pVersion)
    {
        return E_INVALIDARG;
    }

    #ifndef OS_WINCE
    __try {
        pVer = A2OLE(VER_PRODUCTVERSION_STR);
    }
    __except ((EXCEPTION_STACK_OVERFLOW == GetExceptionCode()) ?
                   EXCEPTION_EXECUTE_HANDLER :
                   EXCEPTION_CONTINUE_SEARCH) {
        _resetstkoflw();
        pVer = NULL;
    }
    #else
    pVer = (OLECHAR*)(VER_PRODUCTVERSION_STR);
    #endif
    
    if (!pVer)
    {
        return E_OUTOFMEMORY;
    }

    *pVersion = SysAllocString(pVer);
    if(!*pVersion)
    {
        return E_OUTOFMEMORY;
    }
    
    return S_OK;
}

/**PROC+*********************************************************************/
/* Name:      GetControlHostUrl
/*                         
/* Purpose:   returns the URL of the hosting page in ppszHostUrl
/*            CALLER MUST CoTaskMemFree the returned string
/*                                     
/**PROC-*********************************************************************/
HRESULT CMsTscAx::GetControlHostUrl(LPOLESTR* ppszHostUrl)
{
    DC_BEGIN_FN("GetControlHostUrl");

    if (m_spClientSite && ppszHostUrl)
    {
        // Obtain URL from container moniker.
        CComPtr<IMoniker> spmk;

        if (SUCCEEDED(m_spClientSite->GetMoniker(
                                                OLEGETMONIKER_TEMPFORUSER,
                                                OLEWHICHMK_CONTAINER,
                                                &spmk)))
        {
            if (SUCCEEDED(spmk->GetDisplayName(
                                              NULL, NULL, ppszHostUrl)))
            {
                if (*ppszHostUrl)
                {
                    USES_CONVERSION;
                    TRC_NRM((TB,_T("The current URL is %s\n"),
                             OLE2T(*ppszHostUrl)));
                    return S_OK;
                }
            }
        }
    }

    TRC_ERR((TB,(_T("GetControlHostUrl failed\n"))));
    
    DC_END_FN();

    *ppszHostUrl = NULL;
    return E_FAIL;
}

/**PROC+*********************************************************************/
/* Name:      get_SecuredSettingsEnabled
/*                         
/* Purpose:   Property, returns TRUE if we are in an IE zone where
/*            we enable the SecuredSettings interface
/*            return FALSE otherwise.
/*            
/*            Function returns failure HRESULT if we can't make the determination
/*            e.g if we are not hosted in IE.
/*                                     
/**PROC-*********************************************************************/
STDMETHODIMP CMsTscAx::get_SecuredSettingsEnabled(BOOL* pSecuredSettingsEnabled)
{
    //
    // This function uses the IE security manager
    // to query the zone for the URL that is hosting this control
    //
    DC_BEGIN_FN("get_SecuredSettingsEnabled");

    if(pSecuredSettingsEnabled)
    {
#if ((!defined (OS_WINCE)) || (!defined(WINCE_SDKBUILD)) )
        if((INTERFACESAFE_FOR_UNTRUSTED_CALLER & m_dwCurrentSafety) == 0)
#endif
        {
            //
            // We're don't need to be safe for an untrusted caller (script)
            // so enable the secured settings object
            //
            *pSecuredSettingsEnabled = VB_TRUE;
            return S_OK;
        }
#if ((!defined (OS_WINCE)) || (!defined(WINCE_SDKBUILD)) )

        HRESULT hr = E_FAIL;
        CComPtr<IInternetSecurityManager> spSecurityManager;
        hr = CoCreateInstance(CLSID_InternetSecurityManager, 
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IInternetSecurityManager,
                              (void**)&spSecurityManager);
        if(SUCCEEDED(hr))
        {
            LPOLESTR pszHostUrl;
            hr = GetControlHostUrl(&pszHostUrl);
            if(SUCCEEDED(hr) && *pszHostUrl)
            {
                DWORD dwZone; // IE zone index for this URL
                hr = spSecurityManager->MapUrlToZone( pszHostUrl, &dwZone, 0);

                //We're done with the URL string, free it
                CoTaskMemFree(pszHostUrl);
                pszHostUrl = NULL;

                if(SUCCEEDED(hr))
                {
                    TRC_NRM((TB,
                        _T("get_SecuredSettingsEnabled retreived zone: %d\n"),
                         dwZone));
                    *pSecuredSettingsEnabled = 
                        (dwZone <= MAX_TRUSTED_ZONE_INDEX) ?
                         VB_TRUE : VB_FALSE;
                    return S_OK;
                }
                else
                {
                    return hr;
                }
            }
            else
            {
                return hr;
            }
        }
        else
        {
            TRC_ERR((TB,
              (_T("CoCreateInstance for IID_IInternetSecurityManager failed\n"))));
            return hr;
        }
#endif
    }
    else
    {
        return E_FAIL;
    }
    DC_END_FN();
}

/**PROC+*********************************************************************/
/* Name:      get_SecuredSettings
/*                         
/* Purpose:   Property,
/*            Checks the security zone in IE and returns (and on-demand
/*            creates if needed) the secured settings object.
/*            Returns an E_FAIL if the security settings do not allow
/*            the operation.
/*                                     
/**PROC-*********************************************************************/
STDMETHODIMP CMsTscAx::get_SecuredSettings(/*out*/
     IMsTscSecuredSettings** ppSecuredSettings)
{
    HRESULT hr;

    DC_BEGIN_FN("get_SecuredSettings");

    if(!ppSecuredSettings)
    {
        return E_POINTER;
    }
    BOOL bSecurityAllowsSecuredSettings;
    hr = get_SecuredSettingsEnabled(&bSecurityAllowsSecuredSettings);
    if(SUCCEEDED(hr))
    {
        if(VB_FALSE == bSecurityAllowsSecuredSettings)
        {
            TRC_ERR((TB,_T("IE zone cant retreive IMsTscSecuredSettings\n")));
            return E_FAIL;
        }
    }
    else
    {
        return hr;
    }


    if(!m_pSecuredSettingsObj) {
        //On demand creation of the secured settings COM object
        hr = CComObject<CMsTscSecuredSettings>::CreateInstance(
            &m_pSecuredSettingsObj);
        
        if (FAILED(hr)) {
            TRC_ERR((TB,_T("Failed to CreateInstance SecuredSettings: 0x%x"),hr));
            return hr;
        }

        if (!((CMsTscSecuredSettings*)m_pSecuredSettingsObj)->SetParent(this)) {
            return E_FAIL;
        }

        if (!((CMsTscSecuredSettings*)m_pSecuredSettingsObj)->SetUI(m_pUI)) {
            return E_FAIL;
        }
        
        //We want to use this thru script clients
        //so we will manage the lifetime of the advanced settings object
        m_pSecuredSettingsObj->AddRef();
    }
        
    //Object should be created by this point
    ATLASSERT( m_pSecuredSettingsObj);
    if(!m_pSecuredSettingsObj) {
        return E_FAIL;
    }

    //Object was previously created just return an interface
    hr =  m_pSecuredSettingsObj->QueryInterface( IID_IMsTscSecuredSettings,
                                                  (void**)ppSecuredSettings);

    DC_END_FN();
    
    return hr;
}


//
// Return v2 Secured settings interface
// delegate the work to the v1 interface accessor
// it does all the security checking
//
STDMETHODIMP CMsTscAx::get_SecuredSettings2(/*out*/
    IMsRdpClientSecuredSettings** ppSecuredSettings2)
{
    DC_BEGIN_FN("get_SecuredSettings2");

    HRESULT hr = E_FAIL;
    if (!ppSecuredSettings2)
    {
        return E_POINTER;
    }

    IMsTscSecuredSettings* pOldSecSettings = NULL;
    hr = get_SecuredSettings( &pOldSecSettings);
    if (SUCCEEDED(hr))
    {
        hr = pOldSecSettings->QueryInterface(
                                            IID_IMsRdpClientSecuredSettings,
                                            (void**)ppSecuredSettings2);
        pOldSecSettings->Release();
        return hr;
    }
    else
    {
        return hr;
    }

    DC_END_FN();
    return hr;
}


/**PROC+*********************************************************************/
/* Name:      get_AdvancedSettings
/*                         
/* Purpose:   Property, returns (and on-demand creates if needed) the advanced
/*            settings object
/*                                     
/**PROC-*********************************************************************/
STDMETHODIMP CMsTscAx::get_AdvancedSettings(IMsTscAdvancedSettings** ppAdvSettings)
{
    HRESULT hr;

    DC_BEGIN_FN("get_AdvancedSettings");

    if(!ppAdvSettings)
    {
        return E_POINTER;
    }

    if (!m_pAdvancedSettingsObj)
    {
        //On demand creation of the advanced settings COM object
        hr = CComObject<CMstscAdvSettings>::CreateInstance(&m_pAdvancedSettingsObj);
        
        if(FAILED(hr)) {
            TRC_ERR((TB,_T("Failed to create advsettings obj: 0x%x"),hr));
            return hr;
        }
        if(!m_pAdvancedSettingsObj) {
            return E_OUTOFMEMORY;
        }

        if(!((CMstscAdvSettings*)m_pAdvancedSettingsObj)->SetUI(m_pUI)) {
            return E_FAIL;
        }

        //
        // Give the child object a backreference
        //
        ((CMstscAdvSettings*)m_pAdvancedSettingsObj)->SetAxCtl( this );

        //Tell the advanced setting object if it should be safe for scripting
        //or not (default is safe). m_dwCurrentSafety is set by ATL's
        //IObjectSafetyImpl 
#if ((!defined (OS_WINCE)) || (!defined(WINCE_SDKBUILD)) )
        m_pAdvancedSettingsObj->SetSafeForScripting( 
            INTERFACESAFE_FOR_UNTRUSTED_CALLER & m_dwCurrentSafety);
#else
        m_pAdvancedSettingsObj->SetSafeForScripting(FALSE);
#endif
        
        //We want to use this thru script clients
        //so we will manage the lifetime of the advanced settings object
        m_pAdvancedSettingsObj->AddRef();
    }
        
    //Object should be created by this point
    ATLASSERT( m_pAdvancedSettingsObj);
    if(!m_pAdvancedSettingsObj)
    {
        return E_FAIL;
    }

    //Object was previously created just return an interface
    hr =  m_pAdvancedSettingsObj->QueryInterface( IID_IMsTscAdvancedSettings,
                                                  (void**) ppAdvSettings);
    
    DC_END_FN();
    return hr;
}

/**PROC+*********************************************************************/
/* Name:      internal_GetDebugger
/*                         
/* Purpose:   Property, returns (and on-demand creates if needed) the debugger
/*            object
/*
/*            Does no security access checks
/*                                     
/**PROC-*********************************************************************/
STDMETHODIMP CMsTscAx::internal_GetDebugger(IMsTscDebug** ppDebugger)
{
    HRESULT hr;
    
    DC_BEGIN_FN("get_Debugger");

    if(!ppDebugger)
    {
        return E_POINTER;
    }

    if(!m_pDebuggerObj)
    {
        //On demand creation of the advanced settings COM object
        hr = CComObject<CMsTscDebugger>::CreateInstance(&m_pDebuggerObj);
        
        if(FAILED(hr)) {
            TRC_ERR((TB,_T("Failed to create debugger obj: 0x%x"),hr));
            return hr;
        }

        if(!((CMsTscDebugger*)m_pDebuggerObj)->SetUI(m_pUI)) {
            return E_FAIL;
        }
        
        //We want to use this thru script clients
        //so we will manage the lifetime of the debugger object
        m_pDebuggerObj->AddRef();
    }
        
    //Object should be created by this point
    ATLASSERT( m_pDebuggerObj);
    if(!m_pDebuggerObj) {
        return E_FAIL;
    }

    //Object was previously created just return an interface
    hr =  m_pDebuggerObj->QueryInterface( IID_IMsTscDebug, (void**) ppDebugger);

    DC_END_FN();
    return hr;
}

//
// get_Debugger  (IMsTscAx::get_Debugger)
// 
// Purpose:
//  Scriptable access to the debugger interface. For security reasons, 
//  only allows access if the AllowDebugInterface reg key is set.
// Params:
//  OUT ppDebugger - receives debugger interface
// Returns:
//  HRESULT
//
STDMETHODIMP CMsTscAx::get_Debugger(IMsTscDebug** ppDebugger)
{
    HRESULT hr;
    DWORD   dwAllowDebugInterface = 0;
    CUT     ut;

    //
    // Security! If we're SFS then only return this interface if a 
    // special reg key is set
    //
    if (INTERFACESAFE_FOR_UNTRUSTED_CALLER & m_dwCurrentSafety) {
        //
        // ONLY allow this interface to be returned if the debugging reg
        // key is set
        //
        dwAllowDebugInterface =
            ut.UT_ReadRegistryInt(
                UTREG_SECTION,
                UTREG_DEBUG_ALLOWDEBUGIFACE,
                UTREG_DEBUG_ALLOWDEBUGIFACE_DFLT
                );

        if (!dwAllowDebugInterface) {
            return E_ACCESSDENIED;
        }
    }

    hr = internal_GetDebugger(ppDebugger);
    return hr;
}

/**PROC+*********************************************************************/
/* Name:      get_HorizontalScrollBarVisible
/*                         
/* Purpose:   Property, returns true if HScroll visible
/*                                     
/**PROC-*********************************************************************/
STDMETHODIMP CMsTscAx::get_HorizontalScrollBarVisible(BOOL* pfHScrollVisible)
{
    if (!pfHScrollVisible) {
        return E_POINTER;
    }

    ATLASSERT(m_pUI);
    if (!m_pUI) {
        return E_FAIL;
    }

    *pfHScrollVisible = m_pUI->_UI.fHorizontalScrollBarVisible;
    return S_OK;
}

/**PROC+*********************************************************************/
/* Name:      get_VerticalScrollBarVisible
/*                         
/* Purpose:   Property, returns true if VScroll visible
/*                                     
/**PROC-*********************************************************************/
STDMETHODIMP CMsTscAx::get_VerticalScrollBarVisible(BOOL* pfVScrollVisible)
{
    if(!pfVScrollVisible)
    {
        return E_POINTER;
    }

    ATLASSERT(m_pUI);
    if(!m_pUI)
    {
        return E_FAIL;
    }

    *pfVScrollVisible = m_pUI->_UI.fVerticalScrollBarVisible;
    return S_OK;
}

/**PROC+*********************************************************************/
/* Name:      put_FullScreenTitle
/*                         
/* Purpose:   Set's title of the main window (used when the control goes
/*            full screen as that becomes the window title you see)
/*                                     
/**PROC-*********************************************************************/
STDMETHODIMP CMsTscAx::put_FullScreenTitle(BSTR fullScreenTitle)
{
    USES_CONVERSION;
    HRESULT hr;
    if(!fullScreenTitle)
    {
        return E_INVALIDARG;
    }

    LPTSTR pszTitle = OLE2T(fullScreenTitle);
    if(!pszTitle)
    {
        return E_FAIL;
    }

    if(::IsWindow(m_pUI->_UI.hwndMain))
    {
        if(!::SetWindowText( m_pUI->_UI.hwndMain, pszTitle))
        {
            return E_FAIL;
        }
    }
    else
    {
        //Window not created yet, set text for later creation
        hr = StringCchCopy(m_pUI->_UI.szFullScreenTitle,
                           SIZE_TCHARS(m_pUI->_UI.szFullScreenTitle),
                           pszTitle);
        return hr;
    }

    return S_OK;
}

/**PROC+*********************************************************************/
/* Name:      Connect                                                       */
/*                                                                          */
/* Purpose:   Connects to Hydra Server.                                     */
/*            This call is asynchronous, only the initial portion of        */
/*            connecting is blocking                                        */
/*                                                                          */
/**PROC-*********************************************************************/
STDMETHODIMP CMsTscAx::Connect()
{
    HRESULT hr = E_FAIL;

    #ifdef ECP_TIMEBOMB
    if(!CheckTimeBomb())
    {
        //
        // Timebomb failed, bail out with an error message
        //
        return E_OUTOFMEMORY;
    }
    #endif

    if (IsControlDisconnected())
    {
        if (::IsWindow(m_hWnd))
        {
            hr = StartConnect();
        }
        else
        {
            // Connection requested even before control window creation.
            // mark it as pending and process it after control created.
            m_bPendConReq = TRUE;
            hr = S_OK;
        }
    }

    return hr;
}

/**PROC+*********************************************************************/
/* Name:      Disconnect                                                    */
/*                                                                          */
/* Purpose:   Disconnects from server (asynchronous).                       */
/*                                                                          */
/**PROC-*********************************************************************/
STDMETHODIMP CMsTscAx::Disconnect()
{
    HRESULT hr = E_FAIL;
    DC_BEGIN_FN("Disconnect");
    if (m_bCoreInit && !IsControlDisconnected() && m_pUI)
    {
        m_pUI->UI_UserInitiatedDisconnect(NL_DISCONNECT_LOCAL);
        hr = S_OK;
    }
    else
    {
        //
        // Fail to disconnect can happen if the core
        // has been destroyed without a disconnection
        //
        TRC_ERR((TB,
         _T("Not disconnecting. CoreInit:%d Connected:%d, pUI:%p hwnd:%p"),
                 m_bCoreInit, _ConnectionState, m_pUI,
                 m_pUI ? m_pUI->_UI.hwndMain : (HWND)-1));
        hr = E_FAIL;
    }

    DC_END_FN();
    return hr;
}

/**PROC+*********************************************************************/
/* Name:      OnDraw                                                        */
/*                                                                          */
/* Purpose:   Handler for WM_PAINT                                          */
/*                                                                          */
/**PROC-*********************************************************************/
HRESULT CMsTscAx::OnDraw(ATL_DRAWINFO& di)
{
#ifndef OS_WINCE
    HFONT    hOldFont;
#endif
    RECT& rc = *(RECT*)di.prcBounds;
    Rectangle(di.hdcDraw, rc.left, rc.top, rc.right, rc.bottom);

#ifndef OS_WINCE
    hOldFont = (HFONT)SelectObject(di.hdcDraw,
                                   GetStockObject(DEFAULT_GUI_FONT));
#endif

    DrawText(di.hdcDraw, m_lpStatusDisplay, -1, &rc,
             DT_CENTER | DT_VCENTER | DT_SINGLELINE);

#ifndef OS_WINCE
    SelectObject( di.hdcDraw, hOldFont);
#endif
    return S_OK;
}

/**PROC+*********************************************************************/
/* Name:      OnFrameWindowActivate                                         */
/*                                                                          */
/* Purpose:  Override IOleInPlaceActiveObject::OnFrameWindowActivate        */
/*           to set the focus on the core container window when the control */
/*           gets activated                                                 */
/*                                                                          */
/**PROC-*********************************************************************/

STDMETHODIMP CMsTscAx::OnFrameWindowActivate(BOOL fActivate )
{
    DC_BEGIN_FN("OnFrameWindowActivate");

    if(fActivate && IsWindow())
    {
        if(m_pUI && m_pUI->_UI.hwndContainer)
        {
            ::SetFocus( m_pUI->_UI.hwndContainer);
        }
    }
    
    DC_END_FN();

    return S_OK;
}


/**PROC+*********************************************************************/
/* Name:      UpdateStatusText                                              */
/*                                                                          */
/* Purpose:   Updates the status message for control.                       */
/*                                                                          */
/**PROC-*********************************************************************/
DCBOOL CMsTscAx::UpdateStatusText(const PDCTCHAR lpStatus)
{
    m_lpStatusDisplay = lpStatus;

    //
    // Make sure the window contents are updated
    //
    if(::IsWindow(m_hWnd))
    {
        Invalidate(TRUE);
        UpdateWindow();
    }
    
    return TRUE;
}

/**PROC+*********************************************************************/
/* Name:      SetConnectedStatus                                            */
/*                                                                          */
/* Purpose:   Updates the connected status of the control.                  */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID CMsTscAx::SetConnectedStatus(TSCConnectState conState)
{
    DC_BEGIN_FN("SetConnectedStatus");
    TRC_NRM((TB,_T("Connection status from %d to %d"),
             _ConnectionState, conState)); 

    _ConnectionState = conState;

    //
    // while connected lock the Advanced settings/Debugger IFace's
    // for writing...can't modify props the core is relying on
    //
    BOOL fLockInterfaces = (_ConnectionState != tscNotConnected);

    if( (CMstscAdvSettings*)m_pAdvancedSettingsObj )
    {
        ((CMstscAdvSettings*)m_pAdvancedSettingsObj)->SetInterfaceLockedForWrite(fLockInterfaces);
    }

    if( (CMsTscDebugger*)m_pDebuggerObj )
    {
        ((CMsTscDebugger*)m_pDebuggerObj)->SetInterfaceLockedForWrite(fLockInterfaces);
    }

    if( (CMsTscSecuredSettings*)m_pSecuredSettingsObj )
    {
        ((CMsTscSecuredSettings*)m_pSecuredSettingsObj)->SetInterfaceLockedForWrite(fLockInterfaces);
    }

    DC_END_FN();
}

/**PROC+*********************************************************************/
/* Name:      OnCreate                                                      */
/*                                                                          */
/* Purpose:   Handler for WM_CREATE.                                        */
/*                                                                          */
/**PROC-*********************************************************************/
LRESULT CMsTscAx::OnCreate(UINT uMsg, WPARAM wParam,
                           LPARAM lParam, BOOL& bHandled)
{
    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(bHandled);

    //
    // If the memory allocation failed for the core root object
    // bail out now by returning -1 and failing the create
    //
    if (NULL == m_pUI) {
        return -1;
    }

    //
    // Reset the destroy counter (we only allow one destroy per create)
    //
    m_iDestroyCount = 0;

    ::SetWindowLong(m_hWnd, GWL_STYLE,
                    ::GetWindowLong(m_hWnd, GWL_STYLE) | WS_CLIPCHILDREN);

    UpdateStatusText(m_szDisconnectedText);

    if (m_bPendConReq)
    {
        m_bPendConReq = FALSE;
        Connect();
    }

    return 0;
}

/**PROC+*********************************************************************/
/* Name:      OnSize                                                        */
/*                                                                          */
/* Purpose:   Handler for WM_SIZE .                                         */
/*                                                                          */
/**PROC-*********************************************************************/
LRESULT CMsTscAx::OnSize(UINT uMsg, WPARAM wParam,
                         LPARAM lParam, BOOL& bHandled)
{
    UNREFERENCED_PARAMETER(bHandled);
    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(wParam);
    //
    // Resize the TS client window to match the resize of the active control
    // container window.
    //
    // Do not do this if we are running fullscreen while the core is handling
    // fullscreen mode as in that case the hwndMain is no longer a child of
    // the ActiveX control and so it's sizing should not be coupled to it.
    //
    if(m_pUI &&
       !(m_pUI->UI_IsFullScreen() && 
        !m_pUI->UI_GetContainerHandledFullScreen())) {

        int width = LOWORD(lParam);
        int height = HIWORD(lParam);
        ::MoveWindow( m_pUI->_UI.hwndMain,0, 0, width, height, TRUE);
    }
    return 0;
}

/**PROC+*********************************************************************/
/* Name:      OnPaletteChanged                                              */
/*                                                                          */
/* Purpose:   Handler for WM_PALETTECHANGED.                                */
/*                                                                          */
/**PROC-*********************************************************************/
LRESULT CMsTscAx::OnPaletteChanged(UINT  uMsg, WPARAM wParam,
                                   LPARAM lParam, BOOL& bHandled)
{
    UNREFERENCED_PARAMETER(bHandled);
    //Propagate the change notification to the core (only if core is initialised)
    if(m_bCoreInit && m_pUI)
    {
        ::SendMessage( m_pUI->_UI.hwndMain, uMsg, wParam, lParam);
    }
    return 0;
}

/**PROC+*********************************************************************/
/* Name:      OnQueryNewPalette                                             */
/*                                                                          */
/* Purpose:   Handler for WM_QUERYNEWPALETTE.                               */
/*                                                                          */
/**PROC-*********************************************************************/
LRESULT CMsTscAx::OnQueryNewPalette(UINT  uMsg, WPARAM wParam,
                                    LPARAM lParam, BOOL& bHandled)
{
    UNREFERENCED_PARAMETER(bHandled);
    //Propagate the change notification to the core
    if(m_bCoreInit && m_pUI)
    {
        return ::SendMessage( m_pUI->_UI.hwndMain, uMsg, wParam, lParam);
    }
    else
    {
        return 0;
    }
}

//
// OnSysColorChange
// Handler for WM_SYSCOLORCHANGE
//
LRESULT CMsTscAx::OnSysColorChange(UINT uMsg, WPARAM wParam,
                                   LPARAM lParam, BOOL& bHandled)
{
    UNREFERENCED_PARAMETER(bHandled);
    //Propagate the change notification to the core
    if (m_bCoreInit && m_pUI)
    {
        return ::SendMessage( m_pUI->_UI.hwndMain, uMsg, wParam, lParam);
    }
    else
    {
        return 0;
    }
}


/**PROC+*********************************************************************/
/* Name:      OnGotFocus                                                    */
/*                                                                          */
/* Purpose:   Handler for WM_SETFOCUS .                                     */
/*                                                                          */
/**PROC-*********************************************************************/
LRESULT CMsTscAx::OnGotFocus( UINT uMsg, WPARAM wParam,
                              LPARAM lParam, BOOL& bHandled )
{
    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(bHandled);

#ifdef OS_WINCE
    if (CountClipboardFormats() > 0)
    ::PostMessage(ghwndClip, WM_DRAWCLIPBOARD, 0, 0L);	
#endif

    if(m_pUI && m_pUI->_UI.hwndContainer)
    {
        ::SetFocus( m_pUI->_UI.hwndContainer);
    }
    return 0;
}

/**PROC+*********************************************************************/
/* Name:      StartConnect                                                  */
/*                                                                          */
/*            Initiate a connection with the current params                 */
/*            Do a blocking defered INIT of the core (UI_Init)              */
/*                                                                          */
/*                                                                          */
/**PROC-*********************************************************************/
HRESULT CMsTscAx::StartConnect()
{
    DC_BEGIN_FN("StartConnect");

    HRESULT hr;

    if( CONNECTIONMODE_CONNECTEDENDPOINT == m_ConnectionMode )
    {
        _ASSERTE( m_SalemConnectedSocket != INVALID_SOCKET );

        if( m_SalemConnectedSocket == INVALID_SOCKET )
        {
            hr = E_HANDLE;
            return hr;
        }
    }

    hr = StartEstablishConnection( m_ConnectionMode );

    DC_END_FN();
    return hr;
}


/**PROC+*********************************************************************/
/* Name:      StartEstablishConnection                                      */
/*                                                                          */
/*            Initiate a connection with the current params                 */
/*            Do a blocking defered INIT of the core (UI_Init)              */
/*                                                                          */
/*                                                                          */
/**PROC-*********************************************************************/
HRESULT CMsTscAx::StartEstablishConnection( CONNECTIONMODE connectMode )
{
    HRESULT hr = E_FAIL;
    IUnknown* pUnk;

    DC_BEGIN_FN("StartEstablishConnection");

    _ASSERTE(IsControlDisconnected());
    ATLASSERT(m_pUI);
    if(!m_pUI)
    {
        return E_FAIL;
    }

    UpdateStatusText(m_szConnectingText);

    //Save control instance (used by virtual channel addins)
    hr = QueryInterface(IID_IUnknown, (VOID**)&pUnk);

    if (SUCCEEDED(hr)) {
        m_pUI->UI_SetControlInstance(pUnk);
        pUnk->Release();
        pUnk = NULL;
    }
    else {
        return hr;
    }

    m_pUI->_UI.hWndCntrl = m_hWnd;
    //
    // Expose window handle so vchannel can notify when data arrives
    //
    _VChans._hwndControl = m_hWnd;

    if( CONNECTIONMODE_INITIATE == connectMode )
    {
        if(!CUT::ValidateServerName(m_pUI->_UI.strAddress,
                                    FALSE)) //don't accept [:port]
        {
            TRC_ERR((TB,_T("Invalid server name at connect time")));
            return E_INVALIDARG;
        }
    }

    //
    // Set control size so that client can position the main window at an
    // appropriate position.
    
    //
    // If the client width/height properties were set then use those.
    // Otherwise get the width/height from the container size
    // The client/width height are specifically set in the MMC control
    //

    if (m_DesktopWidth && m_DesktopHeight)
    {
        m_pUI->_UI.controlSize.width  = m_DesktopWidth;
        m_pUI->_UI.controlSize.height =  m_DesktopHeight;
    }
    else
    {
        //
        // size properties were not set so go with the size
        // of the control (this is what is usually used in the
        // web case
        //

        RECT rc;
        GetClientRect(&rc);

        m_pUI->_UI.controlSize.width  = rc.right - rc.left;
        m_pUI->_UI.controlSize.height = rc.bottom - rc.top;
    }
    
    //
    // client width MUST be a multiple of four pixels so snap down to nearest
    // multiple of 4. This really comes up when the control is asked to size
    // itself as a percentage of page width in IE, or to size itself to mmc
    //  result pane
    //

    if(m_pUI->_UI.controlSize.width % 4)
    {
        m_pUI->_UI.controlSize.width -= (m_pUI->_UI.controlSize.width % 4);
    }

    ATLASSERT(!(m_pUI->_UI.controlSize.width % 4));



    // Now validate the control width/height
    // this is done in put_Desktop* but if it
    // was left unchanged we get the sizes from the
    // container
    // clamp to MIN/MAX
    //
    if(m_pUI->_UI.controlSize.width < MIN_DESKTOP_WIDTH) 
    { 
        m_pUI->_UI.controlSize.width = MIN_DESKTOP_WIDTH;
    }
    else if(m_pUI->_UI.controlSize.width > MAX_DESKTOP_WIDTH)
    {
        m_pUI->_UI.controlSize.width = MAX_DESKTOP_WIDTH;
    }

    if(m_pUI->_UI.controlSize.height < MIN_DESKTOP_HEIGHT) 
    { 
        m_pUI->_UI.controlSize.height = MIN_DESKTOP_HEIGHT;
    }
    else if(m_pUI->_UI.controlSize.height > MAX_DESKTOP_HEIGHT)
    {
        m_pUI->_UI.controlSize.height = MAX_DESKTOP_HEIGHT;
    }

    //
    // Set window placement.
    //
    m_pUI->_UI.windowPlacement.flags                   = 0;
    m_pUI->_UI.windowPlacement.showCmd                 = SW_SHOW;
    m_pUI->_UI.windowPlacement.rcNormalPosition.left   = 0;
    m_pUI->_UI.windowPlacement.rcNormalPosition.top    = 0;
    m_pUI->_UI.windowPlacement.rcNormalPosition.right  = 
                                    m_pUI->_UI.controlSize.width;
    m_pUI->_UI.windowPlacement.rcNormalPosition.bottom = 
                                    m_pUI->_UI.controlSize.height;

    //
    // Set desktop size.
    //
    m_pUI->_UI.uiSizeTable[0] = m_pUI->_UI.controlSize.width;
    m_pUI->_UI.uiSizeTable[1] = m_pUI->_UI.controlSize.height;

    //
    // Set autoconnect parameters.
    //
    if (DC_TSTRCMP(m_pUI->_UI.strAddress,_T("")))
    {
        m_pUI->_UI.autoConnectEnabled = TRUE;
    }
    else
    {
        m_pUI->_UI.autoConnectEnabled = FALSE;
    }

    //
    // Set autologon parameters.
    //

    //
    // If a username/password is specified use autologon (don't need a
    // domain since some people logon to home machines etc...with no domain)
    //
    if (DC_WSTRCMP(m_pUI->_UI.UserName,L"") &&
        IsNonPortablePassSet() &&
        IsNonPortableSaltSet())
    {
        m_pUI->_UI.fAutoLogon = TRUE;
    }
    else
    {
        m_pUI->_UI.fAutoLogon = FALSE;
    }

    m_pUI->UI_SetPassword(m_NonPortablePassword);
    m_pUI->UI_SetSalt(m_NonPortableSalt);

#ifdef REDIST_CONTROL

    //
    // Security popup UI to allow user to opt-in redirecting
    // of drives and smart cards.
    // Only appears if object needs to be safe for an untrusted caller.
    //
    // Only do this if we're not autoreconnecting.
    //
    if (!_arcManager.IsAutoReconnecting() &&
        (INTERFACESAFE_FOR_UNTRUSTED_CALLER & m_dwCurrentSafety) &&
        (m_pUI->UI_GetDriveRedirectionEnabled() ||
         m_pUI->UI_GetPortRedirectionEnabled()  ||
         (m_pUI->UI_GetSCardRedirectionEnabled() && CUT::IsSCardReaderInstalled())))
    {
        INT retVal = 0;
        //
        // Need to pop security UI in web control case
        //
        HMODULE hModRc = _Module.GetResourceInstance();
        
        CSecurDlg securDlg( m_hWnd, hModRc);
        securDlg.SetRedirDrives(m_pUI->UI_GetDriveRedirectionEnabled());
        securDlg.SetRedirPorts(m_pUI->UI_GetPortRedirectionEnabled());
        securDlg.SetRedirSCard(m_pUI->UI_GetSCardRedirectionEnabled());
        retVal = securDlg.DoModal();
        if (IDOK == retVal)
        {
            TRC_NRM((TB,_T("Changing drive,scard based on UI")));
            m_pUI->UI_SetDriveRedirectionEnabled( securDlg.GetRedirDrives() );
            m_pUI->UI_SetPortRedirectionEnabled( securDlg.GetRedirPorts() );
            m_pUI->UI_SetSCardRedirectionEnabled( securDlg.GetRedirSCard() );
        }
        else if(IDCANCEL == retVal)
        {
            TRC_NRM((TB,_T("User canceld out of security dialog")));
            //
            // Abort connection
            //
            BOOL bHandled=FALSE;
            OnNotifyDisconnected( 0, (LONG)disconnectReasonLocalNotError,
                                  0L, bHandled );
            return S_OK;
        }
        else
        {
            //
            // Security dialog failed to initialize abort connection
            //
            TRC_ERR((TB,_T("Security dialog returned an error")));
            return E_FAIL;
        }
    }
#endif

    if (m_bCoreInit) {
        // Core has initialized just ask for a connect
        hr = m_pUI->SetConnectWithEndpoint( m_SalemConnectedSocket );
        if( FAILED(hr) )
        {
            TRC_ERR((TB,_T("SetConnectWithEndpoint (init) failed: %x"), hr));
            return hr;
        }

        hr = m_pUI->UI_Connect( connectMode );
        if(FAILED(hr))
        {
            TRC_ERR((TB,_T("UI_Connect (init precomplete) failed: %d"), hr));
            return hr;
        }
    }
    else
    {
        HINSTANCE hres = _Module.GetResourceInstance();
        HINSTANCE hinst = _Module.GetModuleInstance();

        //
        // Core hasn't been initialized
        // initialize the core (synchronously)
        //
        HANDLE hEvtCoreInit = CreateEvent(NULL, FALSE, FALSE, NULL);
        if(hEvtCoreInit)
        {
            TRC_NRM((TB,_T("Initializing core...")));
            hr = m_pUI->UI_Init( hinst, NULL, hres,
                                 hEvtCoreInit);
            if(SUCCEEDED(hr))
            {
                //
                // Async core init has begun. Block and wait for it to complete
                // this will usually be very quick. It is crucial
                // not to allow other core operations to happen until either
                // the core has completed INIT or has failed to initialize.
                //
                TRC_NRM((TB,_T("Block waiting for core init to complete...")));
                
                DWORD dwWaitResult = WaitForSingleObject(hEvtCoreInit,
                                                         CORE_INIT_TIMEOUT);
                if(WAIT_TIMEOUT == dwWaitResult)
                {
                    g_dwControlDbgStatus |= CONTROL_DBG_COREINIT_TIMEOUT;
                    TRC_ERR((TB,_T("Core init has timed out")));
                    BOOL fb;
                    OnNotifyFatalError(0,
                                       DC_ERR_COREINITFAILED,
                                       0,fb);
                    CloseHandle(hEvtCoreInit);
                    return E_FAIL;
                }
                else if (WAIT_OBJECT_0 != dwWaitResult)
                {
                    TRC_ERR((TB,_T("Wait for core init event failed: %d"),
                             dwWaitResult));
                    g_dwControlDbgStatus |= CONTROL_DBG_COREINIT_ERROR;

                    BOOL fb;
                    CloseHandle(hEvtCoreInit);
                    OnNotifyFatalError(0,
                                       DC_ERR_COREINITFAILED,
                                       0,fb);
                    return E_FAIL;
                }

                CloseHandle(hEvtCoreInit);

                TRC_NRM((TB,_T("Core init complete...")));
            }
            else
            {
                TRC_ERR((TB,_T("Core init has failed with code %d"), hr));
                return hr;
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            TRC_ERR((TB,_T("Failed to create core notify event %d"), hr));
            return hr;
        }

        //
        // Core init is only done once on initialization
        //
        m_bCoreInit = TRUE;

        hr = m_pUI->SetConnectWithEndpoint( m_SalemConnectedSocket );
        if( FAILED(hr) )
        {
            TRC_ERR((TB,_T("SetConnectWithEndpoint failed: %x"), hr));
            return hr;
        }

        //Kick off the connection
        hr = m_pUI->UI_Connect( connectMode );
        if(FAILED(hr))
        {
            TRC_ERR((TB, _T("UI_Connect failed: %d"), hr));
            return hr;
        }
    }
    
    SetConnectedStatus(tscConnecting);

    DC_END_FN();
    return S_OK;
}

/**PROC+*********************************************************************/
/* Name:      OnTerminateTsc                                                */
/*                                                                          */
/* Purpose:   Handler for WM_TERMTSC user defined Message. Terminates a     */
/* connection with Terminal server.                                         */
/*                                                                          */
/**PROC-*********************************************************************/
LRESULT CMsTscAx::OnTerminateTsc(UINT uMsg, WPARAM wParam,
                                 LPARAM lParam, BOOL& bHandled)
{
    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(bHandled);

    //
    // Notify of a user initiated disconnection
    //
    OnNotifyDisconnected( 0, (LONG)disconnectReasonLocalNotError,
                          0L, bHandled );

    return 0;
}

/**PROC+*********************************************************************/
/* Name:      OnDestroy                                                     */
/*                                                                          */
/* Purpose:   Handler for WM_DESTROY. Disconnect active connections, if any.*/
/* being activated.                                                         */
/*                                                                          */
/**PROC-*********************************************************************/
LRESULT CMsTscAx::OnDestroy(UINT uMsg, WPARAM wParam,
                            LPARAM lParam, BOOL& bHandled)
{
    DC_BEGIN_FN("OnDestroy");
    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
#ifndef OS_WINCE
    UNREFERENCED_PARAMETER(bHandled);
#else
	bHandled = FALSE;
#endif

    g_lockCount++;

    //
    // Don't allow multiple closes
    //
    if(m_iDestroyCount != 0)
    {
#ifndef OS_WINCE
        bHandled = TRUE;
#endif
        return FALSE;
    }
    m_iDestroyCount++;

    //
    // If the UI object was not allocated, e.g on
    // memory allocation failure in the ctor then
    // bail out now.
    //
    if(!m_pUI)
    {
        return FALSE;
    }

    if (m_pUI && ::IsWindow(m_pUI->_UI.hwndMain))
    {
        CCleanUp cleanup;
        HWND hwndCleanup = cleanup.Start();
        if(!hwndCleanup)
        {
            return FALSE;
        }
    
        m_pUI->_UI.hWndCntrl = hwndCleanup;

        m_pUI->UI_UserRequestedClose();
        // Wait for the close to complete
        // This blocks (pumps msgs) until the appropriate messages
        // are received from the core
        //
        cleanup.End();
        
        UpdateStatusText(m_szDisconnectedText);
    
        //
        // The disconnect has completed, hide the main and container
        // windows, the core only hides them for a server initiated
        // disconnection
        //
    
        // We do ShowWindow twice for the main window because the first
        // call can be ignored if the main window was maximized.
        ::ShowWindow(m_pUI->_UI.hwndContainer, SW_HIDE);
        ::ShowWindow(m_pUI->_UI.hwndMain, SW_HIDE);
        ::ShowWindow(m_pUI->_UI.hwndMain, SW_HIDE);
    }

    if(m_pUI->UI_IsCoreInitialized())
    {
        m_pUI->UI_Term();
        m_bCoreInit = FALSE;
    }

    g_lockCount--;

    DC_END_FN();

    return 0;
}

/**PROC+*********************************************************************/
/* Name:      OnNotifyConnecting                                                  
/*                                                                          
/* Purpose:   Handler for WM_TS_CONNECTING                                  
/*            Notifys container that core has started connection process    
/*            
/*                                                                          
/**PROC-*********************************************************************/
LRESULT CMsTscAx::OnNotifyConnecting(UINT uMsg, WPARAM wParam,
                                     LPARAM lParam, BOOL& bHandled)
{
    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(bHandled);

    SetInControlLock(TRUE);
    //Fire the event
    AddRef();
    Fire_Connecting();
    Release();
    SetInControlLock(FALSE);
    return 0;
}

/**PROC+*********************************************************************/
/* Name:      OnNotifyConnected                                                  
/*                                                                          
/* Purpose:   Handler for WM_TS_CONNECTED                                  
/*            Notifys container that core has connected    
/*            
/*                                                                          
/**PROC-*********************************************************************/
LRESULT CMsTscAx::OnNotifyConnected(UINT uMsg, WPARAM wParam,
                                    LPARAM lParam, BOOL& bHandled)
{
    BOOL fWasAutoreconnect = FALSE;
    DC_BEGIN_FN("OnNotifyConnected");

    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(bHandled);

    UpdateStatusText(m_szConnectedText);

    fWasAutoreconnect = _arcManager.IsAutoReconnecting();
    _arcManager.ResetArcAttempts();

    SetConnectedStatus(tscConnected);

    //
    // Don't fire the notification if it' an automatic autoreconnect
    // as the container should not receive any disconnected/connected
    // notifications.
    //
    if (!(fWasAutoreconnect && _arcManager.IsAutomaticArc())) {
        SetInControlLock(TRUE);
        AddRef();
        Fire_Connected();
        Release();
        SetInControlLock(FALSE);
    }


    DC_END_FN();
    return 0;
}


/**PROC+*********************************************************************/
/* Name:      OnNotifyLoginComplete                                                  
/*                                                                          
/* Purpose:   Handler for WM_TS_LOGINCOMPLETE                                  
/*            Notifys container that login was successful
/*            
/*                                                                          
/**PROC-*********************************************************************/
LRESULT	CMsTscAx::OnNotifyLoginComplete(UINT uMsg, WPARAM wParam,
                                        LPARAM lParam, BOOL& bHandled)
{
    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(bHandled);

    SetInControlLock(TRUE);
    AddRef();
    Fire_LoginComplete();
    Release();
    SetInControlLock(FALSE);

    return 0;
}

/**PROC+*********************************************************************/
/* Name:      OnNotifyDisconnected                                                  
/*                                                                          
/* Purpose:   Handler for WM_TS_DISCONNECTED                                  
/*            Notifys container that core has disconnected
/*            wParam contains the disconnect reason
/*            
/*                                                                          
/*            Returns TRUE if caller should continue processing
/*                    FALSE to bail out immediately
/**PROC-*********************************************************************/
LRESULT CMsTscAx::OnNotifyDisconnected(UINT uMsg, WPARAM wParam,
                                       LPARAM lParam, BOOL& bHandled)
{
    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(bHandled);

    HRESULT hr;
    LRESULT rc = FALSE;
    ExtendedDisconnectReasonCode exReason;
    LONG disconnectReason = (long) wParam;
    BOOL fContinue = FALSE;

    DC_BEGIN_FN("OnNotifyDisconnected");

    UpdateStatusText(m_szDisconnectedText);
    SetConnectedStatus(tscNotConnected);


    //
    // Remember the fullscreen setting for the next connection
    //
    m_pUI->UI_SetStartFullScreen(m_pUI->UI_IsFullScreen());


    hr = get_ExtendedDisconnectReason(&exReason);
    if (FAILED(hr)) {
        exReason = exDiscReasonNoInfo;
    }

    //
    // Give autoreconnection a chance
    //
    _arcManager.OnNotifyDisconnected(disconnectReason,
                                     exReason,
                                     &fContinue);

    if (!fContinue) {
        TRC_NRM((TB,_T("OnNotifyDisconnected bailing out due to arc")));
        rc = TRUE;
        goto bail_out;
    }

    //
    // This is a real disconnection and we've passed all attempts
    // to autoreconnect so clear the autoreconnect cookie
    //
    m_pUI->UI_SetAutoReconnectCookie(NULL, 0);

    //
    // Notify the core that autoreconnect has ended
    //
    m_pUI->UI_OnAutoReconnectStopped();

    //
    // Ensure the attempt count is reset for next time
    //
    _arcManager.ResetArcAttempts();


    SetInControlLock(TRUE);
    AddRef();
    Fire_Disconnected( disconnectReason);

    if (0 == Release()) {

        //
        // We got deleted on return from the event
        // i.e. the container released it's last ref to us
        // in the event handler. Bail out now
        //

        //
        // Return code set to 0 indicates caller should not
        // touch any instance data
        //
        rc = FALSE;
        goto bail_out;
    }

    if (!m_pUI->UI_GetContainerHandledFullScreen())
    {
        //
        // If it's not a container handled fullscreen
        // then leave fullscreen mode on disconected
        //
        // The reasoning is that containers like the web pages
        // and the MMC snapin, won't have to reimplement this code
        // as a listen for the event followed by leave fullscreen.
        //
        // More sophisticated containers like clshell will want
        // fine grained control over this
        //

        internal_PutFullScreen(FALSE, //leave fullscreen
                               TRUE   //Force a toggle
                               );
    }

    m_ConnectionMode = CONNECTIONMODE_INITIATE;
    m_SalemConnectedSocket = INVALID_SOCKET; // let core close this handle

    SetInControlLock(FALSE);

    rc = TRUE;

bail_out:
    DC_END_FN();
    return rc;
}

/**PROC+*********************************************************************/
/* Name:      OnNotifyGoneFullScreen                                                  
/*                                                                          
/* Purpose:   Handler for WM_TS_DISCONNECTED                                  
/*            Notifys container that core has disconnected
/*            wParam contains the disconnect reason
/*            
/*                                                                          
/**PROC-*********************************************************************/
LRESULT CMsTscAx::OnNotifyGoneFullScreen(UINT uMsg, WPARAM wParam,
                                         LPARAM lParam, BOOL& bHandled)
{
    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(bHandled);

    SetInControlLock(TRUE);
    AddRef();
    Fire_EnterFullScreenMode();
    Release();
    SetInControlLock(FALSE);

    return 0;
}

/**PROC+*********************************************************************/
/* Name:      OnNotifyLeftFullScreen                                                  
/*                                                                          
/* Purpose:   Handler for WM_TS_DISCONNECTED                                  
/*            Notifys container that core has disconnected
/*            wParam contains the disconnect reason
/*            
/*                                                                          
/**PROC-*********************************************************************/
LRESULT CMsTscAx::OnNotifyLeftFullScreen(UINT uMsg, WPARAM wParam,
                                         LPARAM lParam, BOOL& bHandled)
{
    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(bHandled);

    SetInControlLock(TRUE);
    AddRef();
    Fire_LeaveFullScreenMode();
    Release();
    SetInControlLock(FALSE);

    return 0;
}

/**PROC+*********************************************************************/
/* Name:      OnNotifyRequestFullScreen                                                  
/*                                                                          
/* Purpose:   Handler for WM_TS_REQUESTFULLSCREEN                                  
/*            Notifys container that core has requested to go to/from
/*            fullscreen.
/*            Only sent if user set ContainerHandledFullScreen in 
/*            the advanced settings
/*
/*            wParam is 1 if GO full screen is requested
/*            
/*                                                                          
/**PROC-*********************************************************************/
LRESULT	CMsTscAx::OnNotifyRequestFullScreen(UINT uMsg, WPARAM wParam,
                                            LPARAM lParam, BOOL& bHandled)
{
    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(bHandled);

    SetInControlLock(TRUE);
    if (wParam)
    {
        AddRef();
        Fire_RequestGoFullScreen();
        Release();
    }
    else
    {
        AddRef();
        Fire_RequestLeaveFullScreen();
        Release();
    }
    SetInControlLock(FALSE);

    return 0;
}

/**PROC+*********************************************************************/
/* Name:      OnNotifyFatalError                                                  
/*                                                                          
/* Purpose:   Handler for WM_TS_FATALERROR                                  
/*            Notifys container that fatal error has occured
/*
/*            wParam is contains the error code
/*            
/*                                                                          
/**PROC-*********************************************************************/
LRESULT	CMsTscAx::OnNotifyFatalError(UINT uMsg, WPARAM wParam,
                                     LPARAM lParam, BOOL& bHandled)
{
    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(bHandled);

    SetInControlLock(TRUE);
    AddRef();
    Fire_FatalError((LONG)wParam);
    Release();
    SetInControlLock(FALSE);

    return 0;
}

/**PROC+*********************************************************************/
/* Name:      OnNotifyWarning                                                  
/*                                                                          
/* Purpose:   Handler for WM_TS_WARNING                                  
/*            Notifys container that a warning has been issued from core
/*            e.g if bitmap cache on disk becomes corrupted...these are
/*            non-fatal errors
/*
/*            wParam is contains the warning code
/*            
/*                                                                          
/**PROC-*********************************************************************/
LRESULT	CMsTscAx::OnNotifyWarning(UINT uMsg, WPARAM wParam,
                                  LPARAM lParam, BOOL& bHandled)
{
    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(bHandled);

    SetInControlLock(TRUE);
    AddRef();
    Fire_Warning((LONG)wParam);
    Release();
    SetInControlLock(FALSE);

    return 0;
}

/**PROC+*********************************************************************/
/* Name:      OnNotifyDesktopSizeChange                                                  
/*                                                                          
/* Purpose:   Handler for WM_TS_DESKTOPSIZECHANGE                                  
/*            Notifys container that desktop size has changed due to a shadow
/*
/*            wParam - new width
//            lParam - new height
/*            
/*                                                                          
/**PROC-*********************************************************************/
LRESULT CMsTscAx::OnNotifyDesktopSizeChange(UINT uMsg, WPARAM wParam,
                                            LPARAM lParam, BOOL& bHandled)
{
    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(bHandled);

    SetInControlLock(TRUE);
    AddRef();
    Fire_RemoteDesktopSizeChange((LONG)wParam, (LONG)lParam);
    Release();
    SetInControlLock(FALSE);

    return 0;
}

/**PROC+*********************************************************************/
/* Name:      OnNotifyIdleTimeout
/*
/* Purpose:   Handler for WM_TS_IDLETIMEOUTNOTIFICATION                                  
/*            Notifys container that idle timeout has elapsed with no input
/*
/*            
/*                                                                          
/**PROC-*********************************************************************/
LRESULT CMsTscAx::OnNotifyIdleTimeout(UINT uMsg, WPARAM wParam,
                            LPARAM lParam, BOOL& bHandled)
{
    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(bHandled);

    SetInControlLock(TRUE);
    AddRef();
    Fire_IdleTimeout();
    Release();
    SetInControlLock(FALSE);
    return 0;
}

/**PROC+*********************************************************************/
/* Name:      OnNotifyRequestMinimize                                                  
/*                                                                          
/* Purpose:   Handler for WM_TS_REQUESTMINIMIZE                                  
/*            Notifys container that a minimize is requested
/*            (e.g. from the BBar)
/*                                                                          
/**PROC-*********************************************************************/
LRESULT CMsTscAx::OnNotifyRequestMinimize(UINT uMsg, WPARAM wParam,
                                          LPARAM lParam, BOOL& bHandled)
{
    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(bHandled);

    if(m_pUI && m_pUI->UI_IsFullScreen())
    {
        SetInControlLock(TRUE);
        AddRef();

        Fire_RequestContainerMinimize();

        Release();
        SetInControlLock(FALSE);
    }
    return 0;
}

//
// Handler for WM_TS_ASKCONFIRMCLOSE
//
// Fire an event to the container requesting if it's ok to proceed
// with an end session or not (typically the container will pop UI
// for this to the user).
//
// Params:
//  [IN/OUT] wParam - pointer to bool that TRUE == close ok
//
//
LRESULT CMsTscAx::OnAskConfirmClose(UINT uMsg, WPARAM wParam,
                                    LPARAM lParam, BOOL& bHandled)
{
    BOOL fAllowCloseToProceed = VB_TRUE;
    HRESULT hr = E_FAIL;
    PBOOL pfClose = (PBOOL)wParam;

    hr = Fire_OnConfirmClose( &fAllowCloseToProceed ); 
    if (FAILED(hr))
    {
        // On fail always assume it's ok to close
        // to prevent app hanging (E.g container may not
        // handle this event)
        fAllowCloseToProceed = TRUE;
    }

    if(pfClose)
    {
        *pfClose = (fAllowCloseToProceed != 0);
    }
    return 0L;
}

/**PROC+*********************************************************************/
/* Name:      OnNotifyReceivedPublicKey                                                  
/*                                                                          
/* Purpose:   Handler for WM_TS_RECEIVEDPUBLICKEY                                  
/*            
/* Parameter: wParam : Length of TS public key.
/*            lParam : Pointer to TS public key.                                                                       
/**PROC-*********************************************************************/
LRESULT	CMsTscAx::OnNotifyReceivedPublicKey(UINT uMsg, WPARAM wParam,
                                        LPARAM lParam, BOOL& bHandled)
{
    VARIANT_BOOL fContinueLogon = VARIANT_TRUE;
    BSTR bstrTSPublicKey = NULL;

    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(bHandled);

    //
    // Do not fire this notification in the redist control as it is not
    // needed
    //
#ifndef REDIST_CONTROL
    SetInControlLock(TRUE);
    AddRef();

    bstrTSPublicKey = ::SysAllocStringByteLen( (LPCSTR)lParam,
                                               wParam);
    //
    // If we failed to allocate memory, return FALSE to stop
    // logon process so we don't have a security issue.
    //    
    if( bstrTSPublicKey )
    {
        Fire_OnReceivedPublicKey(bstrTSPublicKey, &fContinueLogon);
        SysFreeString( bstrTSPublicKey );
    }

    Release();
    SetInControlLock(FALSE);
#endif


    // Return 1 for continue logon, return 0 for stop logon
    return (fContinueLogon != 0) ? 1 : 0;
}
    
/**PROC+*********************************************************************/
/* Name:      OnNotifyChanDataReceived                                      */
/*                                                                          */
/* Purpose:   Handler for WM_VCHANNEL_DATARECEIVED.                         */
/*            Notifys container that virtual channel data was received      */
/*            wParam contains chanel index                                  */
/*            lParam contains received data in BSTR form                    */
/*                                                                          */
/**PROC-*********************************************************************/
LRESULT CMsTscAx::OnNotifyChanDataReceived(UINT uMsg, WPARAM wParam,
                                           LPARAM lParam, BOOL& bHandled)
{
    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(bHandled);

    USES_CONVERSION;

    OLECHAR* pOleName = NULL;
    DC_BEGIN_FN("OnNotifyChanDataReceived");
    DCUINT chanIndex = (DCINT) wParam;
    TRC_ASSERT((chanIndex < _VChans._ChanCount),
           (TB,_T("chanIndex out of range!!!")));

    if (chanIndex >= _VChans._ChanCount)
    {
        TRC_DBG((TB,_T("chanIndex out of range\n")));
        return 0;
    }

    __try {
        pOleName = A2OLE(_VChans._pChanInfo[chanIndex].chanName);
    }
    __except ((EXCEPTION_STACK_OVERFLOW == GetExceptionCode()) ?
                   EXCEPTION_EXECUTE_HANDLER :
                   EXCEPTION_CONTINUE_SEARCH) {
        _resetstkoflw();
        pOleName = NULL;
    }

    if (!pOleName) {
        TRC_DBG((TB,_T("Out of memory on A2OLE")));
        return 0;
    }
    BSTR chanName = SysAllocString(pOleName);
    BSTR chanData = (BSTR) lParam;
    ATLASSERT(chanData && chanName);
    if(chanData && chanName)
    {
        //
        // Notify the container
        //
        SetInControlLock(TRUE);
        AddRef();
        Fire_ChannelReceivedData(chanName, chanData);
        Release();
        SetInControlLock(FALSE);

        SysFreeString(chanData);
        SysFreeString(chanName);
    }
    else
    {
        return FALSE;
    }


    DC_END_FN();
    return 0;
}

//
// Checks that the rentry lock is not held
// making it ok to enter this function
//
BOOL CMsTscAx::CheckReentryLock()
{
    BOOL fReentryLockHeld = GetInControlLock();

    //
    // Assert that the lock is NOT held
    // note, the lock does not need to be thread safe
    // as the interface is only ever accessed from the STA thread.
    //
    // The main purpose of this lock is to ensure we don't reenter
    // certain critical methods while the lock is held.
    //
    ATLASSERT(!fReentryLockHeld);
    return fReentryLockHeld;
}


//-----------------------------------------------------------------------------
// Implementation of IMsRdpClient methods
// (this extends IMsTscAx for new functionality)
// it is the new default interface for the control
//

//
// ColorDepth property
// Sets the colordepth in bpp
//
STDMETHODIMP CMsTscAx::put_ColorDepth(LONG colorDepth)
{
    DC_BEGIN_FN("put_ColorDepth");
    if(!IsControlDisconnected())
    {
        return E_FAIL;
    }
    
    LONG colorDepthID = CO_BITSPERPEL8 ;
    // Convert bpp colordepth to colordepthID
    //
    switch (colorDepth)
    {
        case 8:
        {
            colorDepthID = CO_BITSPERPEL8;
        }
        break;

        case 15:
        {
            colorDepthID = CO_BITSPERPEL15;
        }
        break;

        case 16:
        {
            colorDepthID = CO_BITSPERPEL16;
        }
        break;

        case 24:
        case 32:
        {
            colorDepthID = CO_BITSPERPEL24;
        }
        break;

        case 4:
        default:
        {
            TRC_ERR((TB,_T("color depth %d unsupported\n"), colorDepthID));
            return E_INVALIDARG;
        }
        break;
    }

    m_pUI->_UI.colorDepthID = colorDepthID;
    DC_END_FN();
    return S_OK;
}

//
// ColorDepth property
// retrieves the colordepth
//
STDMETHODIMP CMsTscAx::get_ColorDepth(LONG* pcolorDepth)
{
    LONG colorDepthBpp = 8;
    if(!m_pUI)
    {
        return E_FAIL;
    }
    if(!pcolorDepth)
    {
        return E_POINTER;
    }

    switch(m_pUI->_UI.colorDepthID)
    {
    case CO_BITSPERPEL4:
        colorDepthBpp = 4;
        break;
    case CO_BITSPERPEL8:
        colorDepthBpp = 8;
        break;
    case CO_BITSPERPEL15:
        colorDepthBpp = 15;
        break;
    case CO_BITSPERPEL16:
        colorDepthBpp = 16;
        break;
    case CO_BITSPERPEL24:
        colorDepthBpp = 24;
        break;
    }

    *pcolorDepth = colorDepthBpp;
    return S_OK;
}


//
// SendKeys control method (non scriptable)
// atomically injects keys to the control window
//
// Params: (three parallel arrays)
//      numKeys           - number of keys to inject
//      pbArrayKeyUp      - boolean true for key is up
//      plKeyData         - long key data (lParam of WM_KEYDOWN msg)
//                          i.e this is the scancode
//
//
//
// Restrict the max number of keys that can be sent
// in one atomic opperation (to prevent this method blocking for too long).
//
// This method is non scriptable as a security measure to prevent
// web pages injecting keys to launch programs without the user's
// knowledge.
//
#define MAX_SENDVIRTUAL_KEYS 20

STDMETHODIMP CMsTscAx::SendKeys(/*[in]*/ LONG  numKeys,
                                /*[in]*/ VARIANT_BOOL* pbArrayKeyUp,
                                /*[in]*/ LONG* plKeyData)
{
    DC_BEGIN_FN("SendVirtualKeys");
    HWND hwndInput;

    if(!IsControlConnected() || !m_pUI)
    {
        return E_FAIL;
    }

    hwndInput = m_pUI->UI_GetInputWndHandle();
    if(!hwndInput)
    {
        return E_FAIL;
    }
    
    if(numKeys > MAX_SENDVIRTUAL_KEYS)
    {
        return E_INVALIDARG;
    }

    if(pbArrayKeyUp && plKeyData)
    {
        //Decouple the call to the IH to do the work
        if (m_pUI->UI_InjectVKeys(numKeys,
                                  pbArrayKeyUp,
                                  plKeyData))
        {
            return S_OK;
        }
        else
        {
            TRC_ERR((TB,_T("UI_InjectVKeys returned failure")));
            return E_FAIL;
        }
    }
    else
    {
        TRC_ERR((TB,_T("Invalid arguments (one of more null arrays)")));
        return E_INVALIDARG;
    }

    DC_END_FN();
    return S_OK;
}

//
// get_AdvancedSettings2
// Retrieves the v2 advanced settings interface (IMsRdpClientAdvancedSettings)
//
//
STDMETHODIMP CMsTscAx::get_AdvancedSettings2(
                                IMsRdpClientAdvancedSettings** ppAdvSettings)
{
    DC_BEGIN_FN("get_AdvancedSettings2");

    HRESULT hr = E_FAIL;
    if (!ppAdvSettings)
    {
        return E_POINTER;
    }

    IMsTscAdvancedSettings* pOldAdvSettings = NULL;
    hr = get_AdvancedSettings( &pOldAdvSettings);
    TRC_ASSERT(pOldAdvSettings,(TB,_T("get_AdvancedSettings ret null iface")));
    if (SUCCEEDED(hr))
    {
        hr = pOldAdvSettings->QueryInterface(
                                            IID_IMsRdpClientAdvancedSettings,
                                            (void**)ppAdvSettings);
        pOldAdvSettings->Release();
        return hr;
    }
    else
    {
        return hr;
    }

    DC_END_FN();
    return hr;
}

//
// get_AdvancedSettings3
// Retrieves the v3 advanced settings interface (IMsRdpClientAdvancedSettings)
//
//
STDMETHODIMP CMsTscAx::get_AdvancedSettings3(
                                IMsRdpClientAdvancedSettings2** ppAdvSettings)
{
    DC_BEGIN_FN("get_AdvancedSettings2");

    HRESULT hr = E_FAIL;
    if (!ppAdvSettings)
    {
        return E_POINTER;
    }

    IMsTscAdvancedSettings* pOldAdvSettings = NULL;
    hr = get_AdvancedSettings( &pOldAdvSettings);
    TRC_ASSERT(pOldAdvSettings,(TB,_T("get_AdvancedSettings2 ret null iface")));
    if (SUCCEEDED(hr))
    {
        hr = pOldAdvSettings->QueryInterface(
                                            IID_IMsRdpClientAdvancedSettings2,
                                            (void**)ppAdvSettings);
        pOldAdvSettings->Release();
    }

    DC_END_FN();
    return hr;
}

//
// get_AdvancedSettings4
// Retrieves the v4 advanced settings interface (IMsRdpClientAdvancedSettings3)
//
//
STDMETHODIMP CMsTscAx::get_AdvancedSettings4(
                                IMsRdpClientAdvancedSettings3** ppAdvSettings)
{
    DC_BEGIN_FN("get_AdvancedSettings2");

    HRESULT hr = E_FAIL;
    if (!ppAdvSettings)
    {
        return E_POINTER;
    }

    IMsTscAdvancedSettings* pOldAdvSettings = NULL;
    hr = get_AdvancedSettings( &pOldAdvSettings);
    TRC_ASSERT(pOldAdvSettings,(TB,_T("get_AdvancedSettings ret null iface")));
    if (SUCCEEDED(hr))
    {
        hr = pOldAdvSettings->QueryInterface(
                                            IID_IMsRdpClientAdvancedSettings3,
                                            (void**)ppAdvSettings);
        pOldAdvSettings->Release();
    }

    DC_END_FN();
    return hr;
}



STDMETHODIMP CMsTscAx::get_ExtendedDisconnectReason(/*[out]*/
                       ExtendedDisconnectReasonCode* pExtendedDisconnectReason)
{
    DC_BEGIN_FN("get_ExtendedDisconnectReason");
    if(pExtendedDisconnectReason)
    {
        *pExtendedDisconnectReason = (ExtendedDisconnectReasonCode)
                                        m_pUI->UI_GetServerErrorInfo();
        return S_OK;
    }
    else
    {
        return E_INVALIDARG;
    }

    DC_END_FN();
}

//
// put/get FullScreen fully scriptable versions for Whistler
//
STDMETHODIMP CMsTscAx::put_FullScreen(/*[in]*/ VARIANT_BOOL fFullScreen)
{
    return internal_PutFullScreen(fFullScreen);
}

STDMETHODIMP CMsTscAx::get_FullScreen(/*[in]*/ VARIANT_BOOL* pfFullScreen)
{
    HRESULT hr;
    BOOL fFscreen;
    if (pfFullScreen)
    {
        hr = internal_GetFullScreen(&fFscreen);
        *pfFullScreen = (VARIANT_BOOL)fFscreen;
        return hr;
    }
    else
    {
        return E_INVALIDARG;
    }
}

//
// Override IOleObjectImpl::DoVerbInPlaceActivate to workaround
// ATL bugs (VisualStudio7 #5786 & #181708)
//
// Basically without this FireViewChange can crash in stress if
// the window allocation fails. The symptom will be a jump thru
// a bogus vtable in stress.
//
HRESULT CMsTscAx::DoVerbInPlaceActivate(LPCRECT prcPosRect,
                                        HWND /* hwndParent */)
{
    HRESULT hr;
    hr = OnPreVerbInPlaceActivate();
    if (SUCCEEDED(hr))
    {
        hr = InPlaceActivate(OLEIVERB_INPLACEACTIVATE, prcPosRect);

        //
        // Added these lines to check for hWnd creation success
        //
        if (!m_bWndLess && !m_hWndCD)
        {
            return E_FAIL;
        }

        if (SUCCEEDED(hr))
            hr = OnPostVerbInPlaceActivate();
        if (SUCCEEDED(hr))
            FireViewChange();
    }
    return hr;
}


/*****************************************************************************/
/* Purpose : This is Salem specific call to support reverse connection       */
/*           pcHealth must have invoke necessary routine in Salem to         */
/*           connection with TermSrv and then instruct Salem to pass this    */
/*           connection to ActiveX control to begin login sequence           */
/*                                                                           */
/* Param : IN hConnectedSocket - Connected socket or INVALID_SOCKET          */
/*               to reset back to initate connection mode.                   */
/*****************************************************************************/
HRESULT CMsTscAx::SetConnectWithEndpoint( SOCKET hConnectedSocket )
{
#if defined(REDIST_CONTROL) || defined(OS_WINCE)

    return E_NOTIMPL;

#else

    HRESULT hr;

    if( _ConnectionState == tscNotConnected )
    {
        hr = S_OK;
        if( INVALID_SOCKET == hConnectedSocket )
        {
            m_ConnectionMode = CONNECTIONMODE_INITIATE;
        }
        else
        {
            m_ConnectionMode = CONNECTIONMODE_CONNECTEDENDPOINT;
            m_SalemConnectedSocket = hConnectedSocket;
        }
    }
    else
    {
        hr = E_ABORT;
    }

    return hr;

#endif
}

#ifdef OS_WINCE
// Builds of the WinCE don't have to include URLMON component and hence wouldn't
// have these set in uuid.lib. Name resolution is handled by keeping mstscax 
// as a SOURCESLIB and uuid.lib as a TARGETLIB.
                                             
EXTERN_C const IID CLSID_InternetSecurityManager = {0x7b8a2d94,0x0ac9,0x11d1,{0x89,0x6c,0x00,0xc0,0x4F,0xb6,0xbf,0xc4}};
EXTERN_C const IID IID_IInternetSecurityManager  = {0x79eac9ee,0xbaf9,0x11ce,{0x8c,0x82,0x00,0xaa,0x00,0x4b,0xa9,0x0b}};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\mstscax\mstscax.h ===
/**INC+**********************************************************************/
/* Header: mstscax.h                                                        */
/*                                                                          */
/* Purpose: CMsTscAx class declaration                                      */
/*         Implementation of TS ActiveX control root interface (IMsTscAx)   */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1999-2000                             */
/* Author: nadima                                                           */
/*                                                                          */
/****************************************************************************/

#ifndef __MSTSCAX_H_
#define __MSTSCAX_H_

#include "atlwarn.h"
#include "tsaxiids.h" 

#include "autil.h"
#include "wui.h"
#include "vchannel.h"

//Header generated from IDL
#include "mstsax.h"
#include "arcmgr.h"

#define MAX_DESKTOP_WIDTH 1600
#define MIN_DESKTOP_WIDTH 200

#define MAX_DESKTOP_HEIGHT 1200
#define MIN_DESKTOP_HEIGHT 200


//Maximum supported IE security zone for the secured
//settings interface
//IE zones are as follows (see URLZONE enum)
// 0 MyComputer
// 1 LocalIntranet
// 2 TrustedSites
// 3 Internet
// 4 Restricted Sites
#define MAX_TRUSTED_ZONE_INDEX (DWORD)URLZONE_TRUSTED


//
// ATL connection point proxy for notification events
//

#include "msteventcp.h"

//
// For sending back notifications to the web control
//
#define WM_VCHANNEL_DATARECEIVED   WM_APP + 1001

class CMstscAdvSettings;
class CMsTscDebugger;
class CMsTscSecuredSettings;


/////////////////////////////////////////////////////////////////////////////
// CMsTscAx
class ATL_NO_VTABLE CMsTscAx :
    public CComObjectRootEx<CComSingleThreadModel>,
    public IDispatchImpl<IMsRdpClient3, &IID_IMsRdpClient3, &LIBID_MSTSCLib>,
    public CComCoClass<CMsTscAx,&CLSID_MsRdpClient3>,
    public CComControl<CMsTscAx>,
    public IPersistStreamInitImpl<CMsTscAx>,
    public IPersistPropertyBagImpl<CMsTscAx>,
    public IOleControlImpl<CMsTscAx>,
    public IOleObjectImpl<CMsTscAx>,
    public IOleInPlaceActiveObjectImpl<CMsTscAx>,
    public IViewObjectExImpl<CMsTscAx>,
    public IOleInPlaceObjectWindowlessImpl<CMsTscAx>,
    public IConnectionPointContainerImpl<CMsTscAx>,
    public IPersistStorageImpl<CMsTscAx>,
    public ISpecifyPropertyPagesImpl<CMsTscAx>,
    public IQuickActivateImpl<CMsTscAx>,
    public IDataObjectImpl<CMsTscAx>,
#if ((!defined (OS_WINCE)) || (!defined(WINCE_SDKBUILD)) )
    #ifdef REDIST_CONTROL
    //Only redist control is safe for scripting
    public IObjectSafetyImpl<CMsTscAx, INTERFACESAFE_FOR_UNTRUSTED_CALLER>,
    #else
    public IObjectSafetyImpl<CMsTscAx, 0>,
    #endif
#endif
    public IProvideClassInfo2Impl<&CLSID_MsRdpClient3,&DIID_IMsTscAxEvents,&LIBID_MSTSCLib>,
    public IPropertyNotifySinkCP<CMsTscAx>,
    public CProxy_IMsTscAxEvents<CMsTscAx>,
    public IMsRdpClientNonScriptable
{
public:
    //
    // Ctor/dtor
    //
    CMsTscAx();
    ~CMsTscAx();

private:

    //
    // Displayed status string
    //
    PDCTCHAR m_lpStatusDisplay;

    //pending connection request, will be serviced when
    //window is created
    DCBOOL m_bPendConReq;
    //control property to indicate autoconnect
    //
    DCBOOL m_bStartConnected;

    
    //
    // IMPORTANT: Do not change the value of the 'connected' state away from '1'
    //            in order to remain compatible with TSAC 1.0
    //
    typedef enum {
        tscNotConnected = 0x0,
        tscConnected    = 0x1,  //VERY IMPORTANT: Fixed to '1' for compat w/TSAC
        tscConnecting   = 0x2
    } TSCConnectState;

    //
    //current connection state
    //
    TSCConnectState _ConnectionState;

    //
    // Core init is defered to first connect, only done once
    //
    DCBOOL m_bCoreInit;

    //
    // Check that we don't re-enter the control
    // during an event. Lock is set to true when
    // we are in an event
    //
    BOOL   m_fInControlLock;

    //
    // Handle getting multiple WM_DESTROY messages
    //
    INT    m_iDestroyCount;

    //
    // Properties
    //
    DCUINT8    m_NonPortablePassword[UI_MAX_PASSWORD_LENGTH];
    DCBOOL     m_bNonPortablePassSet;
    DCUINT8    m_NonPortableSalt[UT_SALT_LENGTH];
    DCBOOL     m_NonPortableSaltSet;
    BOOL       m_IsLongPassword; 

    DCUINT8    m_PortablePassword[UI_MAX_PASSWORD_LENGTH];
    DCBOOL     m_bPortablePassSet;
    DCUINT8    m_PortableSalt[UT_SALT_LENGTH];
    DCBOOL     m_bPortableSaltSet;

    DCBOOL     m_fRequestFullScreen;
    DCUINT     m_DesktopWidth;
    DCUINT     m_DesktopHeight;

    TCHAR      m_szDisconnectedText[MAX_PATH];
    TCHAR      m_szConnectingText[MAX_PATH];
    TCHAR      m_szConnectedText[MAX_PATH];

    //
    // Private helper methods
    //
    DCVOID  ResetNonPortablePassword();
    DCVOID  ResetPortablePassword();

    DCBOOL  IsNonPortablePassSet()   {return m_bNonPortablePassSet;}
    DCBOOL  IsNonPortableSaltSet()   {return m_NonPortableSaltSet;}
    DCBOOL  IsPortablePassSet()      {return m_bPortablePassSet;}
    DCBOOL  IsPortableSaltSet()      {return m_bPortableSaltSet;}

    DCVOID  SetNonPortablePassFlag(DCBOOL bVal)  {m_bNonPortablePassSet = bVal;}
    DCVOID  SetNonPortableSaltFlag(DCBOOL bVal)  {m_NonPortableSaltSet  = bVal;}
    DCVOID  SetPortablePassFlag(DCBOOL bVal)     {m_bPortablePassSet    = bVal;}
    DCVOID  SetPortableSaltFlag(DCBOOL bVal)     {m_bPortableSaltSet    = bVal;}
    DCBOOL  ConvertPortableToNonPortablePass();
    DCBOOL  ConvertNonPortableToPortablePass();

    DCBOOL  UpdateStatusText(const PDCTCHAR szStatus);
    DCVOID  SetConnectedStatus(TSCConnectState conState);

    HRESULT GetControlHostUrl(LPOLESTR* ppHostUrl);
    HRESULT StartConnect();
    HRESULT StartEstablishConnection( CONNECTIONMODE mode );
    STDMETHOD(OnFrameWindowActivate)(BOOL fActivate );

    //
    // Private Members.
    //
private:

    CUI*   m_pUI;

    CComObject<CMstscAdvSettings>*      m_pAdvancedSettingsObj;
    CComObject<CMsTscDebugger>*         m_pDebuggerObj;
    CComObject<CMsTscSecuredSettings>*  m_pSecuredSettingsObj;


    // Connection mode for this instance.
    CONNECTIONMODE m_ConnectionMode;

    // Salem specific connected socket to be used by core to 
    // continue on protocol.
    SOCKET  m_SalemConnectedSocket;

    //
    // AutoReconnection manager component
    //
    CArcMgr _arcManager;

public:
    CVChannels _VChans;

    DECLARE_REGISTRY_RESOURCEID(IDR_MSTSCAX)

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CMsTscAx)
        COM_INTERFACE_ENTRY(IMsRdpClient3)
        COM_INTERFACE_ENTRY(IMsRdpClient2)
        COM_INTERFACE_ENTRY(IMsRdpClient)
        COM_INTERFACE_ENTRY(IMsTscAx)
        COM_INTERFACE_ENTRY2(IDispatch, IMsRdpClient3)
        COM_INTERFACE_ENTRY(IViewObjectEx)
        COM_INTERFACE_ENTRY(IViewObject2)
        COM_INTERFACE_ENTRY(IViewObject)
        COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
        COM_INTERFACE_ENTRY(IOleInPlaceObject)
        COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
        COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
        COM_INTERFACE_ENTRY(IOleControl)
        COM_INTERFACE_ENTRY(IOleObject)
        COM_INTERFACE_ENTRY(IPersistStreamInit)
        COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
        COM_INTERFACE_ENTRY(IPersistPropertyBag)
        COM_INTERFACE_ENTRY(IConnectionPointContainer)
        COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY(IQuickActivate)
        COM_INTERFACE_ENTRY(IPersistStorage)
        COM_INTERFACE_ENTRY(IDataObject)
#if ((!defined (OS_WINCE)) || (!defined(WINCE_SDKBUILD)) )
        COM_INTERFACE_ENTRY(IObjectSafety)
#endif
        COM_INTERFACE_ENTRY(IProvideClassInfo)
        COM_INTERFACE_ENTRY(IProvideClassInfo2)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
        COM_INTERFACE_ENTRY(IMsTscNonScriptable)
        COM_INTERFACE_ENTRY(IMsRdpClientNonScriptable)
    END_COM_MAP()

    BEGIN_PROP_MAP(CMsTscAx)
    PROP_ENTRY("Server",            DISPID_PROP_SERVER,             CLSID_MsRdpClient3)
/*
    PROP_ENTRY("Domain",            DISPID_PROP_DOMAIN,             CLSID_MsRdpClient3)
    PROP_ENTRY("UserName",          DISPID_PROP_USERNAME,           CLSID_MsRdpClient3)
    PROP_ENTRY("StartProgram",      DISPID_PROP_STARTPROGRAM,       CLSID_MsRdpClient3)
    PROP_ENTRY("WorkDir",           DISPID_PROP_WORKDIR,            CLSID_MsRdpClient3)
    PROP_ENTRY("Connected",         DISPID_PROP_CONNECTED,          CLSID_MsRdpClient3)
    PROP_ENTRY("ClearTextPassword", DISPID_PROP_CLEARTEXTPASSWORD,  CLSID_MsRdpClient3)
    PROP_ENTRY("PortablePassword",  DISPID_PROP_PORTABLEPASSWORD,   CLSID_MsRdpClient3)
    PROP_ENTRY("PortableSalt",      DISPID_PROP_PORTABLESALT,       CLSID_MsRdpClient3)
    PROP_ENTRY("BinaryPassword",    DISPID_PROP_BINARYPASSWORD,     CLSID_MsRdpClient3)
    PROP_ENTRY("BinarySalt",        DISPID_PROP_BINARYSALT,         CLSID_MsRdpClient3)
    PROP_ENTRY("ClientWidth",       DISPID_PROP_CLIENTWIDTH,        CLSID_MsRdpClient3)
    PROP_ENTRY("ClientHeight",      DISPID_PROP_CLIENTHEIGHT,       CLSID_MsRdpClient3)
*/
    PROP_ENTRY("FullScreen",        DISPID_PROP_FULLSCREEN,         CLSID_MsRdpClient3)
    PROP_ENTRY("StartConnected",    DISPID_PROP_STARTCONNECTED,     CLSID_MsRdpClient3)
    END_PROP_MAP()

    BEGIN_CONNECTION_POINT_MAP(CMsTscAx)
    CONNECTION_POINT_ENTRY(DIID_IMsTscAxEvents)
    CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
    END_CONNECTION_POINT_MAP()


    BEGIN_MSG_MAP(CMsTscAx)
    CHAIN_MSG_MAP(CComControl<CMsTscAx>)
    DEFAULT_REFLECTION_HANDLER()
        MESSAGE_HANDLER(WM_PAINT,                   OnPaint)
        MESSAGE_HANDLER(WM_CREATE,                  OnCreate)
        MESSAGE_HANDLER(WM_TERMTSC,                 OnTerminateTsc)
        MESSAGE_HANDLER(WM_DESTROY,                 OnDestroy)
        MESSAGE_HANDLER(WM_SIZE,                    OnSize)
        MESSAGE_HANDLER(WM_SETFOCUS,                OnGotFocus)
        MESSAGE_HANDLER(WM_PALETTECHANGED,          OnPaletteChanged)
        MESSAGE_HANDLER(WM_QUERYNEWPALETTE,         OnQueryNewPalette)
        MESSAGE_HANDLER(WM_SYSCOLORCHANGE,          OnSysColorChange)

        //
        // Message handlers for internal TS events that are exposed
        // by firing events to the container
        //
        MESSAGE_HANDLER(WM_TS_CONNECTING,           OnNotifyConnecting)
        MESSAGE_HANDLER(WM_TS_CONNECTED,            OnNotifyConnected)
        MESSAGE_HANDLER(WM_TS_LOGINCOMPLETE,        OnNotifyLoginComplete)
        MESSAGE_HANDLER(WM_TS_DISCONNECTED,         OnNotifyDisconnected)
        MESSAGE_HANDLER(WM_TS_GONEFULLSCREEN,       OnNotifyGoneFullScreen)
        MESSAGE_HANDLER(WM_TS_LEFTFULLSCREEN,       OnNotifyLeftFullScreen)
        MESSAGE_HANDLER(WM_VCHANNEL_DATARECEIVED,   OnNotifyChanDataReceived)
        MESSAGE_HANDLER(WM_TS_REQUESTFULLSCREEN,    OnNotifyRequestFullScreen)
        MESSAGE_HANDLER(WM_TS_FATALERROR,           OnNotifyFatalError)
        MESSAGE_HANDLER(WM_TS_WARNING,              OnNotifyWarning)
        MESSAGE_HANDLER(WM_TS_DESKTOPSIZECHANGE,    OnNotifyDesktopSizeChange)
        MESSAGE_HANDLER(WM_TS_IDLETIMEOUTNOTIFICATION, OnNotifyIdleTimeout)
        MESSAGE_HANDLER(WM_TS_REQUESTMINIMIZE,      OnNotifyRequestMinimize)
        MESSAGE_HANDLER(WM_TS_ASKCONFIRMCLOSE,      OnAskConfirmClose)
        MESSAGE_HANDLER(WM_TS_RECEIVEDPUBLICKEY,    OnNotifyReceivedPublicKey)
    END_MSG_MAP()

    // IViewObjectEx
    DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

    public:
    //
    // IMsTscAx properties
    //
    STDMETHOD(put_Server)                   (/*[in]*/ BSTR  newVal);
    STDMETHOD(get_Server)                   (/*[out]*/BSTR* pServer);
    STDMETHOD(put_Domain)                   (/*[in]*/ BSTR  newVal);
    STDMETHOD(get_Domain)                   (/*[out]*/BSTR* pDomain);
    STDMETHOD(put_UserName)                 (/*[in]*/ BSTR  newVal);
    STDMETHOD(get_UserName)                 (/*[out]*/BSTR* pUserName);

    STDMETHOD(put_DisconnectedText)         (/*[in]*/ BSTR  newVal);
    STDMETHOD(get_DisconnectedText)         (/*[out]*/BSTR* pDisconnectedText);
    STDMETHOD(put_ConnectingText)           (/*[in]*/ BSTR  newVal);
    STDMETHOD(get_ConnectingText)           (/*[out]*/BSTR* pConnectingText);

    //Password/salt properties
    STDMETHOD(put_ClearTextPassword)        (/*[in]*/ BSTR newClearTextPassVal);
    STDMETHOD(put_PortablePassword)         (/*[in]*/ BSTR newPortablePassVal);
    STDMETHOD(get_PortablePassword)         (/*[out,retval]*/ BSTR* pPortablePass);
    STDMETHOD(put_PortableSalt)             (/*[in]*/ BSTR newPortableSalt);
    STDMETHOD(get_PortableSalt)             (/*[out,retval]*/ BSTR* pPortableSalt);
    STDMETHOD(put_BinaryPassword)           (/*[in]*/ BSTR newPassword);
    STDMETHOD(get_BinaryPassword)           (/*[out,retval]*/ BSTR* pPass);
    STDMETHOD(put_BinarySalt)               (/*[in]*/ BSTR newSalt);
    STDMETHOD(get_BinarySalt)               (/*[out,retval]*/ BSTR* pSalt);

    STDMETHOD(get_Connected)                (/*[out]*/short* pIsConnected);
    STDMETHOD(put_DesktopWidth)             (/*[in]*/ LONG newVal);
    STDMETHOD(get_DesktopWidth)             (/*[in]*/ LONG* pVal);
    STDMETHOD(put_DesktopHeight)            (/*[in]*/ LONG newVal);
    STDMETHOD(get_DesktopHeight)            (/*[in]*/ LONG* pVal);
    STDMETHOD(put_StartConnected)           (/*[in]*/ BOOL fStartConnected);
    STDMETHOD(get_StartConnected)           (/*[out]*/BOOL* pfStartConnected);
    STDMETHOD(get_HorizontalScrollBarVisible)  (/*[out]*/BOOL* pfHScrollVisible);
    STDMETHOD(get_VerticalScrollBarVisible)    (/*[out]*/BOOL* pfVScrollVisible);
    STDMETHOD(put_FullScreenTitle)          (/*[in]*/ BSTR fullScreenTitle);

    STDMETHOD(get_CipherStrength)           (/*out*/ LONG* pCipherStrength);
    STDMETHOD(get_Version)                  (/*out*/ BSTR* pVersion);
    
    STDMETHOD(get_SecuredSettingsEnabled)   (/*out*/ BOOL* pSecuredSettingsEnabled);
    STDMETHOD(get_SecuredSettings)          (/*out*/ IMsTscSecuredSettings** ppSecuredSettings);
    STDMETHOD(get_Debugger)                 (/*[out]*/IMsTscDebug** ppDebugger);
    STDMETHOD(get_AdvancedSettings)         (/*[out]*/IMsTscAdvancedSettings** ppAdvSettings);


    //
    // Control methods.
    //

    //
    // IMsRdpClient properties
    //
    STDMETHOD(put_ColorDepth)          (/*[in]*/LONG colorDepth);
    STDMETHOD(get_ColorDepth)          (/*[in]*/LONG* pcolorDepth);
    STDMETHOD(get_AdvancedSettings2)(
            OUT IMsRdpClientAdvancedSettings** ppAdvSettings
            );
    STDMETHOD(get_SecuredSettings2)(/*out*/ IMsRdpClientSecuredSettings**
                                     ppSecuredSettings2);
    STDMETHOD(get_ExtendedDisconnectReason) (/*[out]*/
                                             ExtendedDisconnectReasonCode*
                                             pExtendedDisconnectReason);

    STDMETHOD(put_FullScreen)	       (/*[in]*/ VARIANT_BOOL fFullScreen);
    STDMETHOD(get_FullScreen)	       (/*[out]*/VARIANT_BOOL* pfFullScreen);

    //
    // IMsTscAx methods
    //
    STDMETHOD(Connect)();
    STDMETHOD(Disconnect)();
    STDMETHOD(ResetPassword)();

    STDMETHOD(CreateVirtualChannels)(/*[in]*/ BSTR newChanList);
    STDMETHOD(SendOnVirtualChannel)(/*[in]*/ BSTR ChanName,/*[in]*/ BSTR sendData);

    //
    // IMsRdpClient methods
    //
    STDMETHOD(SetVirtualChannelOptions)(/*[in]*/ BSTR ChanName,
                                        /*[in]*/ LONG chanOptions);
    STDMETHOD(GetVirtualChannelOptions)(/*[in]*/ BSTR ChanName,
                                        /*[out]*/LONG* pChanOptions);
    STDMETHOD(RequestClose)(ControlCloseStatus* pCloseStatus);

    //
    // IMsRdpClientNonScriptable methods
    //
    STDMETHOD(NotifyRedirectDeviceChange)(/*[in]*/ WPARAM wParam,
                                          /*[in]*/ LPARAM lParam);
    STDMETHOD(SendKeys)(/*[in]*/ LONG  numKeys,
                        /*[in]*/ VARIANT_BOOL* pbArrayKeyUp,
                        /*[in]*/ LONG* plKeyData);

    //
    // IMsRdpClient2 properties
    //
    STDMETHOD(get_AdvancedSettings3)(
            OUT IMsRdpClientAdvancedSettings2** ppAdvSettings2
            );

    STDMETHOD(put_ConnectedStatusText)     (/*[in]*/ BSTR  newVal);
    STDMETHOD(get_ConnectedStatusText)     (/*[out]*/BSTR* pConnectedText);

    //
    // IMsRdpClient3 properties
    //
    STDMETHOD(get_AdvancedSettings4)(
            OUT IMsRdpClientAdvancedSettings3** ppAdvSettings3
            );

    //
    // Properties that are not exposed directly on the IMsTscAx interace
    //
    STDMETHOD(internal_PutFullScreen)(BOOL fScreen, BOOL fForceToggle = FALSE);
    STDMETHOD(internal_GetFullScreen)(BOOL* pfScreen);
    STDMETHOD(internal_PutStartProgram)(/*[in]*/ BSTR  newVal);
    STDMETHOD(internal_GetStartProgram)(/*[out]*/BSTR* pStartProgram);
    STDMETHOD(internal_PutWorkDir)(/*[in]*/ BSTR  newVal);
    STDMETHOD(internal_GetWorkDir)(/*[out]*/BSTR* pWorkDir);
    STDMETHOD(internal_GetDebugger)(/*[out]*/IMsTscDebug** ppDebugger);


    //
    // Override IOleObjectImpl::DoVerbInPlaceActivate to workaround
    // ATL bug
    //
    virtual HRESULT DoVerbInPlaceActivate(LPCRECT prcPosRect, HWND /* hwndParent */);
    virtual HRESULT FinalConstruct();

    //
    // Msg handlers
    //
    HRESULT OnDraw(ATL_DRAWINFO& di);
    LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnInitTsc(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnTerminateTsc(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnGotFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnPaletteChanged(UINT  uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnQueryNewPalette(UINT  uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSysColorChange(UINT  uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnNotifyConnecting(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnNotifyConnected(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnNotifyLoginComplete(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnNotifyDisconnected(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnNotifyGoneFullScreen(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnNotifyLeftFullScreen(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnNotifyChanDataReceived(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnNotifyRequestFullScreen(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnNotifyFatalError(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnNotifyWarning(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnNotifyDesktopSizeChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnNotifyIdleTimeout(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnNotifyRequestMinimize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnAskConfirmClose(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnNotifyReceivedPublicKey(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    HRESULT SetConnectWithEndpoint( SOCKET hSocket );

    //
    // Private methods
    //
private:
    VOID    SetInControlLock(BOOL flag)        {m_fInControlLock = flag;}
    BOOL    GetInControlLock()                 {return m_fInControlLock;}
    BOOL    CheckReentryLock();

    BOOL    IsControlDisconnected() {return tscNotConnected == _ConnectionState;}
    BOOL    IsControlConnected()    {return tscConnected == _ConnectionState;}

public:
    CUI*    GetCoreUI()                        {return m_pUI;}
    HWND    GetHwnd()                          {return m_hWnd;}


};

#endif //__MSTSCAX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\mstscax\securedset.cpp ===
/**MOD+**********************************************************************/
/* Module:    securedset.cpp                                                */
/*                                                                          */
/* Class  :   CMsTscSecuredSettings                                         */
/*                                                                          */
/* Purpose:   Implements secured scriptable settings interface              */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1999-2000                             */
/*                                                                          */
/* Author :  Nadim Abdo (nadima)                                            */
/****************************************************************************/

#include "stdafx.h"

#include "securedset.h"
#include "atlwarn.h"

BEGIN_EXTERN_C
#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "tsdbg"
#include <atrcapi.h>
END_EXTERN_C


CMsTscSecuredSettings::CMsTscSecuredSettings()
{
    m_pMsTsc=NULL;
    m_pUI=NULL;
    m_bLockedForWrite=FALSE;
}

CMsTscSecuredSettings::~CMsTscSecuredSettings()
{
}

BOOL CMsTscSecuredSettings::SetParent(CMsTscAx* pMsTsc)
{
    ATLASSERT(pMsTsc);
    m_pMsTsc = pMsTsc;
    return TRUE;
}

BOOL CMsTscSecuredSettings::SetUI(CUI* pUI)
{
    ATLASSERT(pUI);
    if(!pUI)
    {
        return FALSE;
    }
    m_pUI = pUI;
    return TRUE;
}



/**PROC+*********************************************************************/
/* Name:      put_StartProgram                                              */
/*                                                                          */
/* Purpose:   Alternate shell property input function.                      */
/*                                                                          */
/**PROC-*********************************************************************/
STDMETHODIMP CMsTscSecuredSettings::put_StartProgram(BSTR newVal)
{
    //Delegate to parent's vtable interface for this setting
    if(m_pMsTsc && !GetLockedForWrite())
    {
        return m_pMsTsc->internal_PutStartProgram(newVal);
    }

    return E_FAIL;
}

/**PROC+*********************************************************************/
/* Name:      get_StartProgram                                              */
/*                                                                          */
/* Purpose:   StartProgram property get function.                           */
/*                                                                          */
/**PROC-*********************************************************************/
STDMETHODIMP CMsTscSecuredSettings::get_StartProgram(BSTR* pStartProgram)
{
    //Delegate to parent's vtable interface for this setting
    if(m_pMsTsc)
    {
        return m_pMsTsc->internal_GetStartProgram(pStartProgram);
    }

    return E_FAIL;
}

/**PROC+*********************************************************************/
/* Name:      put_WorkDir                                                   */
/*                                                                          */
/* Purpose:   Working Directory property input function.                    */
/*                                                                          */
/**PROC-*********************************************************************/
STDMETHODIMP CMsTscSecuredSettings::put_WorkDir(BSTR newVal)
{
    //Delegate to parent's vtable interface for this setting
    if(m_pMsTsc && !GetLockedForWrite())
    {
        return m_pMsTsc->internal_PutWorkDir(newVal);
    }

    return E_FAIL;
}

/**PROC+*********************************************************************/
/* Name:      get_WorkDir                                                   */
/*                                                                          */
/* Purpose:   Working Directory property get function.                      */
/*                                                                          */
/**PROC-*********************************************************************/
STDMETHODIMP CMsTscSecuredSettings::get_WorkDir(BSTR* pWorkDir)
{
    //Delegate to parent's vtable interface for this setting
    if(m_pMsTsc)
    {
        return m_pMsTsc->internal_GetWorkDir(pWorkDir);
    }

    return E_FAIL;
}

/**PROC+*********************************************************************/
/* Name:      put_FullScreen
/*                                              
/* Purpose:   Set fullscreen (and switches mode)
/*                                              
/**PROC-*********************************************************************/
STDMETHODIMP CMsTscSecuredSettings::put_FullScreen(BOOL fFullScreen)
{
    //Delegate to parent's vtable interface for this setting
    if(m_pMsTsc)
    {
        return m_pMsTsc->internal_PutFullScreen(fFullScreen);
    }
    return E_FAIL;
}

/**PROC+*********************************************************************/
/* Name:      internal_GetFullScreen        	        
/*                                              
/* Purpose:   get FullScreen mode
/*                                              
/**PROC-*********************************************************************/
STDMETHODIMP CMsTscSecuredSettings::get_FullScreen(BOOL* pfFullScreen)
{
    if(m_pMsTsc)
    {
        return m_pMsTsc->internal_GetFullScreen(pfFullScreen);
    }
    
    return S_OK;
}

//
// Check if reg key for drive redir is set to globally disable it
//
#define TS_DISABLEDRIVES_KEYNAME TEXT("SOFTWARE\\Microsoft\\Terminal Server Client")
#define TS_DISABLEDRIVES         TEXT("DisableDriveRedirection")

BOOL CMsTscSecuredSettings::IsDriveRedirGloballyDisabled()
{
    HKEY hKey = NULL;
    INT retVal = 0;
    BOOL fDriveRedirDisabled = FALSE;
    DC_BEGIN_FN("IsDriveRedirGloballyDisabled");

    //
    // Check if the security override reg key disables
    // drive redirection
    //
    retVal = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            TS_DISABLEDRIVES_KEYNAME,
                            0,
                            KEY_READ,
                            &hKey);
    if(ERROR_SUCCESS == retVal)
    {
        DWORD cbData = sizeof(DWORD);
        DWORD dwType,dwVal;
        retVal = RegQueryValueEx(hKey, TS_DISABLEDRIVES,
                                    NULL, &dwType,
                                    (PBYTE)&dwVal,
                                    &cbData);
        if(ERROR_SUCCESS == retVal && REG_DWORD == dwType)
        {
            fDriveRedirDisabled = (dwVal != 0);
        }

        RegCloseKey(hKey);
    }

    TRC_NRM((TB,_T("REG Security for drive redir is %d"),
             fDriveRedirDisabled));

    DC_END_FN();

    return fDriveRedirDisabled;
}

STDMETHODIMP CMsTscSecuredSettings::put_KeyboardHookMode(LONG  KeyboardHookMode)
{
    if(!GetLockedForWrite())
    {
        if(KeyboardHookMode == UTREG_UI_KEYBOARD_HOOK_NEVER      ||
           KeyboardHookMode == UTREG_UI_KEYBOARD_HOOK_ALWAYS     ||
           KeyboardHookMode == UTREG_UI_KEYBOARD_HOOK_FULLSCREEN)
        {
            m_pUI->_UI.keyboardHookMode = KeyboardHookMode;
            return S_OK;
        }
        else
        {
            return E_INVALIDARG;
        }
    }
    else
    {
        return E_FAIL;
    }
}

STDMETHODIMP CMsTscSecuredSettings::get_KeyboardHookMode(LONG* pKeyboardHookMode)
{
    if(pKeyboardHookMode)
    {
        *pKeyboardHookMode = m_pUI->_UI.keyboardHookMode;
        return S_OK;
    }
    else
    {
        return E_INVALIDARG;
    }
}

STDMETHODIMP CMsTscSecuredSettings::put_AudioRedirectionMode(LONG audioRedirectionMode)
{
    if(!GetLockedForWrite())
    {
        if(audioRedirectionMode == AUDIOREDIRECT_TO_CLIENT      ||
           audioRedirectionMode == AUDIOREDIRECT_ON_SERVER      ||
           audioRedirectionMode == AUDIOREDIRECT_NOAUDIO)
        {
            m_pUI->UI_SetAudioRedirectionMode(audioRedirectionMode);
            return S_OK;
        }
        else
        {
            return E_INVALIDARG;
        }
    }
    else
    {
        return E_FAIL;
    }
}

STDMETHODIMP CMsTscSecuredSettings::get_AudioRedirectionMode(LONG* pAudioRedirectionMode)
{
    if(pAudioRedirectionMode)
    {
        *pAudioRedirectionMode = m_pUI->UI_GetAudioRedirectionMode();
        return S_OK;
    }
    else
    {
        return E_INVALIDARG;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\mstscax\tsaxiids.h ===
/**INC+**********************************************************************/
/* Header:    wbuiids.h                                                     */
/*                                                                          */
/* Purpose:   UI identifiers for Terminal Server Active Client              */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/

#define IDR_MSTSCAX                     101
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\mstscax\stdafx.cpp ===
/**MOD+**********************************************************************/
/* Module:    stdafx.cpp                                                    */
/*                                                                          */
/* Purpose:   ATL implementation includes                                   */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1999                                  */
/*                                                                          */
/****************************************************************************/

#include "stdafx.h"
#include "atlwarn.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\mstscax\stdafx.h ===
/**INC+**********************************************************************/
/* Header: stdafx.h                                                         */    
/*                                                                          */
/* Purpose : Include file for standard system include files, or project     */
/*           specific include files that are used frequently, but are       */
/*           changed infrequently                                           */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1999                                  */
/*                                                                          */
/****************************************************************************/
#if !defined(_STDAFX_H)
#define _STDAFX_H

//These are necessary to disable warnings in the ATL headers
//see <atlbase.h>

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifdef OS_WINCE
//CE doesn't support StretchDiBits
#undef SMART_SIZING
#endif

#define SIZEOF_WCHARBUFFER( x )  (sizeof( x ) / sizeof( WCHAR ))
#define SIZEOF_TCHARBUFFER( x )  (sizeof( x ) / sizeof( TCHAR ))
#define BEGIN_EXTERN_C extern "C" {
#define END_EXTERN_C              }

#define VB_TRUE  -1
#define VB_FALSE 0

#include <windows.h>
//
// BETA2
// Timebomb expires on Jan 1, 2002
//
#define ECP_TIMEBOMB_YEAR  2002
#define ECP_TIMEBOMB_MONTH 1
#define ECP_TIMEBOMB_DAY   15


#ifdef UNIWRAP
//Certain ATL headers have conflicts with wrapped
//functions so wrap those after we've been through ATL
#define DONOT_INCLUDE_SECONDPHASE_WRAPS
#include "uwrap.h"
#endif

#ifdef _DEBUG
//
// WARNING THIS MAKES THE BINARY GROW BY LIKE 60K
//IT IS ALSO CURRENLTY BROKEN ON IA64 (ATL bugs)
//
//#define _ATL_DEBUG_INTERFACES
//#define ATL_TRACE_LEVEL 4

#endif

#if defined (OS_WINCE) && (_WIN32_WCE <= 300)
#define RDW_INVALIDATE          0x0001
#define RDW_ERASE               0x0004
#define RDW_UPDATENOW           0x0100
#endif

#include <atlbase.h>
#include "tsaxmod.h"
extern CMsTscAxModule _Module;

#include <atlcom.h>
#include <atlctl.h>

#include <strsafe.h>

#ifdef UNIWRAP
//Second phase wrap functions
//Must be included AFTER ATL headers
#include "uwrap2.h"
#endif

#include <adcgbase.h>

#define TRC_DBG(string)
#define TRC_NRM(string)
#define TRC_ALT(string)
#define TRC_ERR(string)
#define TRC_ASSERT(condition, string)
#define TRC_ABORT(string)
#define TRC_SYSTEM_ERROR(string)
#define TRC_FN(string)
#define TRC_ENTRY
#define TRC_EXIT
#define TRC_DATA_DBG


#include "autil.h"
#include "wui.h"

#undef TRC_DBG
#undef TRC_NRM
#undef TRC_ALT
#undef TRC_ERR
#undef TRC_ASSERT
#undef TRC_ABORT
#undef TRC_SYSTEM_ERROR
#undef TRC_FN
#undef TRC_ENTRY
#undef TRC_EXIT
#undef TRC_DATA_DBG

#define SIZECHAR(x) sizeof(x)/sizeof(TCHAR)

#ifdef ECP_TIMEBOMB
BOOL CheckTimeBomb();
#endif

#include "axresrc.h"
#include "autreg.h"

#endif // !defined(_STDAFX_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\mstscax\securedset.h ===
/**INC+**********************************************************************/
/* Header: securedset.h                                                     */
/*                                                                          */
/* Purpose: CMsTscSecuredSettings class declaration                         */
/*          implements IMsTscSecuredSettings                                */
/*                                                                          */
/* The secured settings object allows scriptable access to less secure      */
/* properties in a controlled manner (only in a valid browser security zone)*/
/*                                                                          */
/* The security checks are made before returning this object. So the        */
/* individual properties do not need to make any checks                     */
/*                                                                          */
/*                                                                          */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1999-2000                             */
/*                                                                          */
/****************************************************************************/

#ifndef _SECUREDSET_H_
#define _SECUREDSET_H_


#include "atlwarn.h"

//Header generated from IDL
#include "mstsax.h"
#include "mstscax.h"

/////////////////////////////////////////////////////////////////////////////
// CMsTscAx
class ATL_NO_VTABLE CMsTscSecuredSettings :
    public CComObjectRootEx<CComSingleThreadModel>,
    public IDispatchImpl<IMsRdpClientSecuredSettings,
                         &IID_IMsRdpClientSecuredSettings, &LIBID_MSTSCLib>
{
public:
/****************************************************************************/
/* Constructor / Destructor.                                                */
/****************************************************************************/
    CMsTscSecuredSettings();
    ~CMsTscSecuredSettings();

DECLARE_PROTECT_FINAL_CONSTRUCT();
BEGIN_COM_MAP(CMsTscSecuredSettings)
    COM_INTERFACE_ENTRY(IMsRdpClientSecuredSettings)
    COM_INTERFACE_ENTRY(IMsTscSecuredSettings)
    COM_INTERFACE_ENTRY2(IDispatch,IMsRdpClientSecuredSettings)
END_COM_MAP()

public:
    //
    // Secured scriptable properties
    //

    //
    // IMsTscSecuredSettings methods
    //
    STDMETHOD(put_StartProgram)             (/*[in]*/ BSTR  newVal);
    STDMETHOD(get_StartProgram)             (/*[out]*/BSTR* pStartProgram);
    STDMETHOD(put_WorkDir)                  (/*[in]*/ BSTR  newVal);
    STDMETHOD(get_WorkDir)                  (/*[out]*/BSTR* pWorkDir);
    STDMETHOD(put_FullScreen)	            (/*[in]*/ BOOL fFullScreen);
    STDMETHOD(get_FullScreen)	            (/*[out]*/BOOL* pfFullScreen);

    //
    // IMsRdpClientSecuredSettings methods (v2 interface)
    //
    STDMETHOD(put_KeyboardHookMode)           (LONG  KeyboardHookMode);
    STDMETHOD(get_KeyboardHookMode)           (LONG* pKeyboardHookMode);
    STDMETHOD(put_AudioRedirectionMode)       (LONG  audioRedirectionMode);
    STDMETHOD(get_AudioRedirectionMode)       (LONG* paudioRedirectionMode);

public:
    BOOL SetParent(CMsTscAx* pMsTsc);
    BOOL SetUI(CUI* pUI);
    VOID SetInterfaceLockedForWrite(BOOL bLocked)   {m_bLockedForWrite=bLocked;}
    BOOL GetLockedForWrite()            {return m_bLockedForWrite;}
    static BOOL IsDriveRedirGloballyDisabled();

private:
    CMsTscAx* m_pMsTsc;
    CUI* m_pUI;
    //
    // Flag is set by the control when these properties can not be modified
    // e.g while connected. Any calls on these properties while locked
    // result in an E_FAIL being returned.
    //
    BOOL m_bLockedForWrite;
};

#endif //_SECUREDSET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\mstscax\tsaxmod.h ===
/**INC+**********************************************************************/
/* Header: wbuimod.h                                                        */
/*                                                                          */
/* Purpose: CMSTsWClModule class declartion                                 */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1998                                  */
/*                                                                          */
/****************************************************************************/
#ifndef __WBUIMOD_H_
#define __WBUIMOD_H_

/**CLASS+********************************************************************/
/* Name:      CMsTscAxModule                                                */
/*                                                                          */
/* Purpose:   Overrides CComModule                                          */
/*                                                                          */
/**CLASS+********************************************************************/
class CMsTscAxModule : public CComModule
{
public:
    HRESULT RegisterServer(BOOL bRegTypeLib = FALSE, const CLSID* pCLSID = NULL );
#ifdef DEBUG
#if DEBUG_REGISTER_SERVER
    static void ShowLastError();
#endif //DEBUG_REGISTER_SERVER
#endif //DEBUG
};
#endif //__WBUIMOD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\mstscax\tsaxmain.cpp ===
/**MOD+**********************************************************************/
/* Module:    tsaxmain.cpp                                                  */
/*                                                                          */
/* Purpose:   Implementation of DLL Exports. Header for this module will    */
/*            be generated in the respective build directory.               */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1998                                  */
/*                                                                          */
/****************************************************************************/
#include "stdafx.h"
#include "atlwarn.h"

BEGIN_EXTERN_C
#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "tsaxmain"
#include <atrcapi.h>
END_EXTERN_C

#include "tsaxiids.h"
#include "initguid.h"
#include "mstsax.h"
#ifndef OS_WINCE
#include "mstsax_i.c"
#endif

#include "mstscax.h"
#include "tsaxmod.h"

//
// Version number (property returns this)
//
#ifndef OS_WINCE
#include "ntverp.h"
#else
#include "ceconfig.h" //get build #
#endif

//Unicode wrapper
#include "wraputl.h"


/****************************************************************************/
/* Module object                                                            */
/****************************************************************************/
CMsTscAxModule _Module;

/****************************************************************************/
/* Object map                                                               */
/****************************************************************************/
BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_MsRdpClient3, CMsTscAx)
    OBJECT_ENTRY(CLSID_MsRdpClient2, CMsTscAx)
    OBJECT_ENTRY(CLSID_MsRdpClient, CMsTscAx)
    OBJECT_ENTRY(CLSID_MsTscAx,     CMsTscAx)
END_OBJECT_MAP()

#ifdef ECP_TIMEBOMB
//
// Return's true if timebomb test passed otherwise puts up warning
// UI and return's FALSE
//
BOOL CheckTimeBomb()
{
    SYSTEMTIME lclTime;
    FILETIME   lclFileTime;
    GetLocalTime(&lclTime);

    DCBOOL bTimeBombOk = TRUE;

    //
    // Simply check that the local date is less than June 30, 2000
    //
    if(lclTime.wYear < ECP_TIMEBOMB_YEAR)
    {
        return TRUE;
    }
    else if (lclTime.wYear == ECP_TIMEBOMB_YEAR)
    {
        if(lclTime.wMonth < ECP_TIMEBOMB_MONTH)
        {
            return TRUE;
        }
        else if(lclTime.wMonth == ECP_TIMEBOMB_MONTH)
        {
            if(lclTime.wDay < ECP_TIMEBOMB_DAY)
            {
                return TRUE;
            }
        }

    }

    DCTCHAR timeBombStr[256];
    if (LoadString(_Module.GetModuleInstance(),
                    TIMEBOMB_EXPIRED_STR,
                    timeBombStr,
                    SIZEOF_TCHARBUFFER(timeBombStr)) != 0)
    {
        MessageBox(NULL, timeBombStr, NULL, 
                   MB_ICONERROR | MB_OK);
    }


    //
    // If we reach this point the timebomb should trigger
    // so put up a messagebox and return FALSE
    // so the calling code can disable functionality
    //
    return FALSE;
}
#endif


#ifdef UNIWRAP
//It's ok to have a global unicode wrapper
//class. All it does is sets up the g_bRunningOnNT
//flag so it can be shared by multiple instances
//also it is only used from DllMain so there
//are no problems with re-entrancy
CUnicodeWrapper g_uwrp;
#endif

#ifdef OS_WINCE
DECLARE_TRACKER_VARS();
#endif


/**PROC+*********************************************************************/
/* Name:      DllMain                                                       */
/*                                                                          */
/* Purpose:   DLL entry point                                               */
/*                                                                          */
/**PROC-*********************************************************************/
extern "C"
#ifndef OS_WINCE
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
#else
BOOL WINAPI DllMain(HANDLE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
#endif

{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        #ifdef UNIWRAP
        //UNICODE Wrapper intialization has to happen first,
        //before anything ELSE. Even DC_BEGIN_FN, which does tracing
        g_uwrp.InitializeWrappers();
        #endif
        
        TSRNG_Initialize();

        CO_StaticInit((HINSTANCE)hInstance);

        _Module.Init(ObjectMap, (HINSTANCE)hInstance);
#if ((!defined (OS_WINCE)) || (_WIN32_WCE >= 300) )
        DisableThreadLibraryCalls((HINSTANCE)hInstance);
#endif
#ifdef OS_WINCE
        CEInitialize();
        g_CEConfig = CEGetConfigType(&g_CEUseScanCodes);
#endif

    }
    else if (dwReason == DLL_PROCESS_DETACH) {
        _Module.Term();
        CO_StaticTerm();

        TSRNG_Shutdown();

        #ifdef UNIWRAP
        g_uwrp.CleanupWrappers();
        #endif
    }

    return TRUE;    // ok
}

/**PROC+*********************************************************************/
/* Name:      DllCanUnloadNow                                               */
/*                                                                          */
/* Purpose:   Used to determine whether the DLL can be unloaded by OLE      */
/*                                                                          */
/**PROC-*********************************************************************/
STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/**PROC+*********************************************************************/
/* Name:      DllGetClassObject                                             */
/*                                                                          */
/* Purpose:   Returns a class factory to create an object of the requested  */
/*            type                                                          */
/*                                                                          */
/**PROC-*********************************************************************/
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    #ifdef ECP_TIMEBOMB
    if(!CheckTimeBomb())
    {
        //
        // Timebomb failed, bail out with an error message
        //
        return E_OUTOFMEMORY;
    }
    #endif

     return _Module.GetClassObject(rclsid, riid, ppv);
}

/**PROC+*********************************************************************/
/* Name:      DllRegisterServer                                             */
/*                                                                          */
/* Purpose:   DllRegisterServer - Adds entries to the system registry       */
/*                                                                          */
/**PROC-*********************************************************************/
STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
     return _Module.RegisterServer(TRUE);
}

/**PROC+*********************************************************************/
/* Name:      DllUnregisterServer                                           */
/*                                                                          */
/* Purpose:   DllUnregisterServer - Removes entries from the system registry*/
/*                                                                          */
/**PROC-*********************************************************************/
STDAPI DllUnregisterServer(void)
{
     return _Module.UnregisterServer();
}

/**PROC+*********************************************************************/
/* Name:      DllGetTscCtlVer                                               */
/*                                                                          */
/* Purpose:   Returns version of the tsc control                            */
/*                                                                          */
/**PROC-*********************************************************************/
STDAPI_(DWORD) DllGetTscCtlVer(void)
{
    #ifndef OS_WINCE
    return VER_PRODUCTVERSION_DW;
    #else
    return CE_TSC_BUILDNO;
    #endif
}

#ifndef OS_WINCE
#ifdef CRTREPORT_DEBUG_HACK
/**PROC+*********************************************************************/
/* Name:      _CrtDbgReport                                                 */
/*                                                                          */
/* Purpose:   Redirect all debug reporting to our tracing functions         */
/*                                                                          */
/**PROC-*********************************************************************/
extern "C"
_CRTIMP int __cdecl _CrtDbgReport(int nRptType, 
                                  const char * szFile, 
                                  int nLine,
                                  const char * szModule,
                                  const char * szFormat, 
                                  ...)
{
    static CHAR bigBuf[2048];
    va_list vargs;
    HRESULT hr;

    DC_BEGIN_FN("AtlTraceXXX");
    
    va_start(vargs, szFormat);

    hr = StringCchVPrintfA(bigBuf, sizeof(bigBuf), szFormat, vargs);
    
    va_end( vargs );

#ifdef OS_WINCE
#ifndef _CRT_ASSERT
#define _CRT_ASSERT 2
#endif
#endif
    if (_CRT_ASSERT == nRptType)
    {
        #ifdef UNICODE
        TRC_ABORT((TB,_T("AtlAssert. File:%S line:%d - %S"), szFile,
                      nLine, bigBuf));
        #else
        TRC_ABORT((TB,_T("AtlAssert. File:%s line:%d - %s"), szFile,
                      nLine, bigBuf));
        #endif
    }
    else
    {
        #ifdef UNICODE
        TRC_ERR((TB,_T("AtlTrace. File:%S line:%d - %S"), szFile,
                      nLine, bigBuf));
        #else
        TRC_ERR((TB,_T("AtlTrace. File:%s line:%d - %s"), szFile,
                      nLine, bigBuf));
        #endif
    }

    DC_END_FN();

    return 0;
}
#endif
#endif //OS_WINCE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\mstscax\tsaxmod.cpp ===
/**MOD+**********************************************************************/
/* Module:    tsaxmod.cpp                                                   */
/*                                                                          */
/* Class  :   CMsTscAxModule                                                */
/*                                                                          */
/* Purpose:   Initializes ts activex client ui module                       */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1998                                  */
/*                                                                          */
/****************************************************************************/
#include "stdafx.h"
#include "atlwarn.h"
#include "tsaxmod.h"

#include "aver.h"
//
// global defined to aid debugging
//
DWORD dwMstscControlBuild = VER_PRODUCTBUILD;

#include "reglic.h"

#ifndef OS_WINCE
#ifdef REDIST_CONTROL
LPCSTR g_szTscControlName = "msrdp.ocx";
#else
LPCSTR g_szTscControlName = "mstscax.dll";
#endif
#else
#ifdef REDIST_CONTROL
LPCWSTR g_szTscControlName = L"msrdp.ocx";
#else
LPCWSTR g_szTscControlName = L"mstscax.dll";
#endif
#endif

/**PROC+*********************************************************************/
/* Name:      CMsTscAxModule::RegisterServer                                */
/*                                                                          */
/* Purpose:   Displays reason for registry failure.                         */
/*                                                                          */
/**PROC-*********************************************************************/
HRESULT CMsTscAxModule::RegisterServer(BOOL bRegTypeLib, const CLSID* pCLSID)
{
    HRESULT hr;

    #if DEBUG_REGISTER_SERVER
    const char* lpMsgBuf = "I am in Register Server";
    ::MessageBox(NULL,lpMsgBuf, "RegisterServer", MB_OK|MB_ICONINFORMATION);
    #endif

    hr = CComModule::RegisterServer(bRegTypeLib,pCLSID);
    if(FAILED(hr))
    {
#if DEBUG_REGISTER_SERVER
        ShowLastError();
#endif
    }

#ifndef OS_WINCE
    //
    // Add the MSLicensing key here..this function might fail
    // e.g insufficient rights (e.g if you're not an admin)
    // this function only adds the key under NT5 or above...
    // on other platforms the client can write to HKLM licensing
    // and add the key at will.
    //
    // On NT5 however, we add the key and set ACL's here because
    // only an Admin/PowerUser can complete a registerserver anyway.
    // We Do silently ignore this if it fails.
    //
    if(!SetupMSLicensingKey())
    {
        ATLTRACE("SetupMSLicensingKey failed..( this is OK on <NT5 )");
    }
#endif

    return hr;
}

#ifdef DEBUG
#if DEBUG_REGISTER_SERVER
/**PROC+*********************************************************************/
/* Name:      CMsTscAxModule::ShowLastError()                               */
/*                                                                          */
/* Purpose:   Displays windows last error. Debug only procedure.            */
/*                                                                          */
/**PROC-*********************************************************************/
void CMsTscAxModule::ShowLastError()
{
    LPVOID lpMsgBuf;
    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                  NULL,
                  GetLastError(),
                  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                  (LPTSTR) &lpMsgBuf,
                  0,
                  NULL );

    ::MessageBox( NULL, (const char*) lpMsgBuf, "GetLastError", MB_OK|MB_ICONINFORMATION );
    LocalFree(lpMsgBuf);
}
#endif // DEBUG_REGISTER_SERVER
#endif //DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\mstscax\tsdbg.cpp ===
/**MOD+**********************************************************************/
/* Module:    tsdbg.cpp                                                     */
/*                                                                          */
/* Class  :   CMsTscDebugger                                                */
/*                                                                          */
/* Purpose:   Implements debugger interface for RDP ActiveX control         */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1999                                  */
/*                                                                          */
/* Author :  Nadim Abdo (nadima)                                            */
/****************************************************************************/

#include "stdafx.h"

#include "tsdbg.h"
#include "atlwarn.h"

BEGIN_EXTERN_C
#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "tsdbg"
#include <atrcapi.h>
END_EXTERN_C


CMsTscDebugger::CMsTscDebugger()
{
    m_pUI=NULL;
    m_bLockedForWrite = FALSE;
}

CMsTscDebugger::~CMsTscDebugger()
{
}

BOOL CMsTscDebugger::SetUI(CUI* pUI)
{
    ATLASSERT(pUI);
    if(!pUI)
    {
        return FALSE;
    }
    m_pUI = pUI;
    return TRUE;
}


//
// HatchBitmapPDU property
//
STDMETHODIMP CMsTscDebugger::put_HatchBitmapPDU(BOOL hatchBitmapPDU)
{
    #ifdef DC_DEBUG
    m_pUI->_UI.hatchBitmapPDUData  = hatchBitmapPDU != 0;
    m_pUI->UI_CoreDebugSettingChanged();
    return S_OK;
    #else
    UNREFERENCED_PARAMETER(hatchBitmapPDU);
    return E_NOTIMPL;
    #endif
}

STDMETHODIMP CMsTscDebugger::get_HatchBitmapPDU(BOOL* phatchBitmapPDU)
{
    #ifdef DC_DEBUG
    ATLASSERT(phatchBitmapPDU);
    if(!phatchBitmapPDU)
    {
        return E_POINTER;
    }

    *phatchBitmapPDU = m_pUI->_UI.hatchBitmapPDUData ? VB_TRUE : VB_FALSE;
    return S_OK;
    #else
    UNREFERENCED_PARAMETER(phatchBitmapPDU);
    return E_NOTIMPL;
    #endif
}

//
// HatchSSBOrder property
//
STDMETHODIMP CMsTscDebugger::put_HatchSSBOrder(BOOL hatchSSBOrder)
{
    #ifdef DC_DEBUG
    m_pUI->_UI.hatchSSBOrderData  = hatchSSBOrder != 0;
    m_pUI->UI_CoreDebugSettingChanged();
    return S_OK;
    #else
    UNREFERENCED_PARAMETER(hatchSSBOrder);
    return E_NOTIMPL;
    #endif
}

STDMETHODIMP CMsTscDebugger::get_HatchSSBOrder(BOOL* phatchSSBOrder)
{
    #ifdef DC_DEBUG
    ATLASSERT(phatchSSBOrder);
    if(!phatchSSBOrder)
    {
        return E_POINTER;
    }

    *phatchSSBOrder = m_pUI->_UI.hatchSSBOrderData ? VB_TRUE : VB_FALSE;
    return S_OK;
    #else
    UNREFERENCED_PARAMETER(phatchSSBOrder);
    return E_NOTIMPL;
    #endif
}

//
// HatchMembltOrder property
//
STDMETHODIMP CMsTscDebugger::put_HatchMembltOrder(BOOL hatchMembltOrder)
{
    #ifdef DC_DEBUG
    m_pUI->_UI.hatchMemBltOrderData  = hatchMembltOrder != 0;
    m_pUI->UI_CoreDebugSettingChanged();
    return S_OK;
    #else
    UNREFERENCED_PARAMETER(hatchMembltOrder);
    return E_NOTIMPL;
    #endif
}

STDMETHODIMP CMsTscDebugger::get_HatchMembltOrder(BOOL* phatchMembltOrder)
{
    #ifdef DC_DEBUG
    ATLASSERT(phatchMembltOrder);
    if(!phatchMembltOrder)
    {
        return E_POINTER;
    }

    *phatchMembltOrder = m_pUI->_UI.hatchMemBltOrderData ? VB_TRUE : VB_FALSE;
    return S_OK;
    #else
    UNREFERENCED_PARAMETER(phatchMembltOrder);
    return E_NOTIMPL;
    #endif
}

//
// HatchIndexPDU property
//
STDMETHODIMP CMsTscDebugger::put_HatchIndexPDU(BOOL hatchIndexPDU)
{
    #ifdef DC_DEBUG
    m_pUI->_UI.hatchIndexPDUData  = hatchIndexPDU != 0;
    m_pUI->UI_CoreDebugSettingChanged();

    return S_OK;
    #else
    UNREFERENCED_PARAMETER(hatchIndexPDU);
    return E_NOTIMPL;
    #endif
}

STDMETHODIMP CMsTscDebugger::get_HatchIndexPDU(BOOL* phatchIndexPDU)
{
    #ifdef DC_DEBUG
    ATLASSERT(phatchIndexPDU);
    if(!phatchIndexPDU)
    {
        return E_POINTER;
    }

    *phatchIndexPDU = m_pUI->_UI.hatchIndexPDUData ? VB_TRUE : VB_FALSE;
    return S_OK;
    #else
    UNREFERENCED_PARAMETER(phatchIndexPDU);
    return E_NOTIMPL;
    #endif
}

//
// LabelMemblt property
//
STDMETHODIMP CMsTscDebugger::put_LabelMemblt(BOOL labelMemblt)
{
    #ifdef DC_DEBUG
    m_pUI->_UI.labelMemBltOrders  = labelMemblt != 0;
    m_pUI->UI_CoreDebugSettingChanged();

    return S_OK;
    #else
    UNREFERENCED_PARAMETER(labelMemblt);
    return E_NOTIMPL;
    #endif
}

STDMETHODIMP CMsTscDebugger::get_LabelMemblt(BOOL* plabelMemblt)
{
    #ifdef DC_DEBUG
    ATLASSERT(plabelMemblt);
    if(!plabelMemblt)
    {
        return E_POINTER;
    }

    *plabelMemblt = m_pUI->_UI.labelMemBltOrders ? VB_TRUE : VB_FALSE;
    return S_OK;
    #else
    UNREFERENCED_PARAMETER(plabelMemblt);
    return E_NOTIMPL;
    #endif
}

//
// BitmapCacheMonitor property
//
STDMETHODIMP CMsTscDebugger::put_BitmapCacheMonitor(BOOL bitmapCacheMonitor)
{
    #ifdef DC_DEBUG
    m_pUI->_UI.bitmapCacheMonitor = bitmapCacheMonitor != 0;
    m_pUI->UI_CoreDebugSettingChanged();

    return S_OK;
    #else
    UNREFERENCED_PARAMETER(bitmapCacheMonitor);
    return E_NOTIMPL;
    #endif
}

STDMETHODIMP CMsTscDebugger::get_BitmapCacheMonitor(BOOL* pbitmapCacheMonitor)
{
    #ifdef DC_DEBUG
    ATLASSERT(pbitmapCacheMonitor);
    if(!pbitmapCacheMonitor)
    {
        return E_POINTER;
    }
    *pbitmapCacheMonitor = m_pUI->_UI.bitmapCacheMonitor ? VB_TRUE : VB_FALSE;
    return S_OK;
    #else
    UNREFERENCED_PARAMETER(pbitmapCacheMonitor);
    return E_NOTIMPL;
    #endif
}

//
// MallocFailures property
//
STDMETHODIMP CMsTscDebugger::put_MallocFailuresPercent(LONG mallocFailures)
{
#ifdef DC_DEBUG
    if(mallocFailures < 0 || mallocFailures > 100)
    {
        return E_INVALIDARG;
    }
    m_pUI->UI_SetRandomFailureItem(UT_FAILURE_MALLOC, mallocFailures);

    return S_OK;
#else
    UNREFERENCED_PARAMETER(mallocFailures);
    return E_NOTIMPL;
#endif
}

STDMETHODIMP CMsTscDebugger::get_MallocFailuresPercent(LONG* pmallocFailures)
{
    #ifdef DC_DEBUG
    ATLASSERT(pmallocFailures);
    if(!pmallocFailures)
    {
        return E_POINTER;
    }

    *pmallocFailures = (LONG)m_pUI->UI_GetRandomFailureItem(UT_FAILURE_MALLOC);

    return S_OK;
    #else
    UNREFERENCED_PARAMETER(pmallocFailures);
    return E_NOTIMPL;
    #endif
}

//
// MallocHugeFailures property
//
STDMETHODIMP CMsTscDebugger::put_MallocHugeFailuresPercent(LONG mallocHugeFailures)
{
#ifdef DC_DEBUG
    if(mallocHugeFailures < 0 || mallocHugeFailures > 100)
    {
        return E_INVALIDARG;
    }
    m_pUI->UI_SetRandomFailureItem(UT_FAILURE_MALLOC_HUGE, mallocHugeFailures);

    return S_OK;
#else
    UNREFERENCED_PARAMETER(mallocHugeFailures);
    return E_NOTIMPL;
#endif
}

STDMETHODIMP CMsTscDebugger::get_MallocHugeFailuresPercent(LONG* pmallocHugeFailures)
{
    #ifdef DC_DEBUG
    ATLASSERT(pmallocHugeFailures);
    if(!pmallocHugeFailures)
    {
        return E_POINTER;
    }

    *pmallocHugeFailures = (LONG)m_pUI->UI_GetRandomFailureItem(UT_FAILURE_MALLOC_HUGE);

    return S_OK;
    #else
    UNREFERENCED_PARAMETER(pmallocHugeFailures);
    return E_NOTIMPL;
    #endif
}


//
// NetThroughput property
//
STDMETHODIMP CMsTscDebugger::put_NetThroughput(LONG netThroughput)
{
    #ifdef DC_DEBUG
    //    m_NetThroughput = netThroughput;
    if(netThroughput < 0 || netThroughput > 50000)
    {
        return E_INVALIDARG;
    }
    m_pUI->UI_SetNetworkThroughput((DCUINT)netThroughput);
    return S_OK;
    #else
    UNREFERENCED_PARAMETER(netThroughput);
    return E_NOTIMPL;
    #endif
}

STDMETHODIMP CMsTscDebugger::get_NetThroughput(LONG* pnetThroughput)
{
    #ifdef DC_DEBUG
    ATLASSERT(pnetThroughput);
    if(!pnetThroughput)
    {
        return E_POINTER;
    }
    *pnetThroughput = (LONG)m_pUI->UI_GetNetworkThroughput();

    return S_OK;
    #else
    UNREFERENCED_PARAMETER(pnetThroughput);
    return E_NOTIMPL;
    #endif
}

//
// CLXCommand Line
// this property is valid in both checked and free builds
//
STDMETHODIMP CMsTscDebugger::put_CLXCmdLine(BSTR CLXCmdLine)
{
    HRESULT hr = E_FAIL;
    if(GetLockedForWrite())
    {
        return E_FAIL;
    }

    if (CLXCmdLine)
    {
        hr = CUT::StringPropPut(
            m_pUI->_UI.CLXCmdLine,
            SIZE_TCHARS(m_pUI->_UI.CLXCmdLine),
            (LPTSTR)CLXCmdLine);
    }
    else
    {
        m_pUI->_UI.CLXCmdLine[0] = 0;
        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP CMsTscDebugger::get_CLXCmdLine(BSTR* pCLXCmdLine)
{
    ATLASSERT(pCLXCmdLine);
    if(!pCLXCmdLine)
    {
        return E_INVALIDARG;
    }

    OLECHAR* oleClxCmdLine = (OLECHAR*)(m_pUI->_UI.CLXCmdLine);
    ATLASSERT(oleClxCmdLine);
    if (!oleClxCmdLine)
    {
        return E_OUTOFMEMORY;
    }

    *pCLXCmdLine = SysAllocString(oleClxCmdLine);
    if(!*pCLXCmdLine)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

//
// CLXDll
// this property is deprecated for security reasons
// see #533846
//
STDMETHODIMP CMsTscDebugger::put_CLXDll(BSTR CLXDll)
{
    return E_NOTIMPL;
}

//
// CLXDll
// Deprecated for security reasons: bug#533846
//
STDMETHODIMP CMsTscDebugger::get_CLXDll(BSTR* pCLXDll)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\mstscax\tsdbg.h ===
/**INC+**********************************************************************/
/* Header: tsdbg.h                                                          */
/*                                                                          */
/* Purpose: CMsTscDebugger class declaration                                */
/*          implements IMsTscDebug                                          */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1999                                  */
/*                                                                          */
/****************************************************************************/

#ifndef _TSDBG_H_
#define _TSDBG_H_


#include "atlwarn.h"
#include "wui.h"

//Header generated from IDL
#include "mstsax.h"
#include "mstscax.h"

/////////////////////////////////////////////////////////////////////////////
// CMsTscAx
class ATL_NO_VTABLE CMsTscDebugger :
    public CComObjectRootEx<CComSingleThreadModel>,
    public IDispatchImpl<IMsTscDebug, &IID_IMsTscDebug, &LIBID_MSTSCLib>,
    public CComCoClass<CMsTscAx,&CLSID_MsRdpClient3>
{
public:
/****************************************************************************/
/* Constructor / Destructor.                                                */
/****************************************************************************/
    CMsTscDebugger();
    ~CMsTscDebugger();

DECLARE_PROTECT_FINAL_CONSTRUCT();
BEGIN_COM_MAP(CMsTscDebugger)
    COM_INTERFACE_ENTRY(IMsTscDebug)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

public:
    //
    // Debugger properties
    //
    STDMETHOD(put_HatchBitmapPDU)    (BOOL hatchBitmapPDU);
    STDMETHOD(get_HatchBitmapPDU)    (BOOL* phatchBitmapPDU);
    STDMETHOD(put_HatchSSBOrder)    (BOOL hatchSSBOrder);
    STDMETHOD(get_HatchSSBOrder)    (BOOL* phatchSSBOrder);
    STDMETHOD(put_HatchMembltOrder)    (BOOL hatchMembltOrder);
    STDMETHOD(get_HatchMembltOrder)    (BOOL* phatchMembltOrder);
    STDMETHOD(put_HatchIndexPDU)    (BOOL hatchIndexPDU);
    STDMETHOD(get_HatchIndexPDU)    (BOOL* phatchIndexPDU);
    STDMETHOD(put_LabelMemblt)    (BOOL labelMemblt);
    STDMETHOD(get_LabelMemblt)    (BOOL* plabelMemblt);
    STDMETHOD(put_BitmapCacheMonitor)    (BOOL bitmapCacheMonitor);
    STDMETHOD(get_BitmapCacheMonitor)    (BOOL* pbitmapCacheMonitor);
    STDMETHOD(put_MallocFailuresPercent)    (LONG mallocFailures);
    STDMETHOD(get_MallocFailuresPercent)    (LONG* pmallocFailures);
    STDMETHOD(put_MallocHugeFailuresPercent)    (LONG mallocHugeFailures);
    STDMETHOD(get_MallocHugeFailuresPercent)    (LONG* pmallocHugeFailures);
    STDMETHOD(put_NetThroughput)    (LONG netThroughput);
    STDMETHOD(get_NetThroughput)    (LONG* pnetThroughput);
    STDMETHOD(put_CLXCmdLine)       (BSTR CLXCmdLine);
    STDMETHOD(get_CLXCmdLine)       (BSTR* pCLXCmdLine);
    STDMETHOD(put_CLXDll)           (BSTR CLXDll);
    STDMETHOD(get_CLXDll)           (BSTR* pCLXDll);

public:
    BOOL SetUI(CUI* pUI);
    VOID SetInterfaceLockedForWrite(BOOL bLocked)   {m_bLockedForWrite=bLocked;}
    BOOL GetLockedForWrite()            {return m_bLockedForWrite;}

private:
    CUI* m_pUI;

    //
    // Flag is set by the control when these properties can not be modified
    // e.g while connected. Any calls on these properties while locked
    // result in an E_FAIL being returned.
    //
    BOOL m_bLockedForWrite;
};

#endif //_TSDBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\mstscax\vchannel.cpp ===
/**MOD+**********************************************************************/
/* Module:    vchannel.cpp                                                  */
/*                                                                          */
/* Purpose:   internal handling of the exposed virtual channel interfaces   */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1999                                  */
/*                                                                          */
/****************************************************************************/
#include "stdafx.h"
#include "atlwarn.h"

//IDL generated header
#include "mstsax.h"

#include "mstscax.h"
#include "vchannel.h"

#include "cleanup.h"

#define TRC_GROUP TRC_GROUP_UI
#define TRC_FILE  "vchannel"
#include <atrcapi.h>

CVChannels::CVChannels()
{
    DC_BEGIN_FN("~CVChannels");
    _pChanInfo = NULL;
    _pEntryPoints = NULL;
    _dwConnectState = NOTHING;
    _phInitHandle = NULL;
    _ChanCount = NULL;
    _hwndControl = NULL;
    DC_END_FN();
}

CVChannels::~CVChannels()
{
    UINT i;
    DC_BEGIN_FN("~CVChannels");

    if (_pChanInfo) {

        //
        // Free any incomplete channel receive buffers
        //
        for (i=0; i<_ChanCount; i++) {
            if (_pChanInfo[i].CurrentlyReceivingData.pData) {
                SysFreeString((BSTR)_pChanInfo[i].CurrentlyReceivingData.pData);
                _pChanInfo[i].CurrentlyReceivingData.pData = NULL;
            }
        }

        LocalFree(_pChanInfo);
        _pChanInfo = NULL;
    }

    DC_END_FN();
}


/*****************************************************************************
*
*    Routine Description:
*        Return the channel index for a given open channel handle 
*
*    Arguments:
*        dwHandle - handle to the channel
*
*    Return Value:
*        index to the channel in the _pChanInfo array or -1 if not found
*
*****************************************************************************/

DCINT CVChannels::ChannelIndexFromOpenHandle(DWORD dwHandle)
{
    DCUINT i;

    DC_BEGIN_FN("ChannelIndexFromOpenHandle");

    TRC_ASSERT((_pChanInfo), (TB,_T("_pChanInfo is NULL")));

    if (!_pChanInfo)
    {
        DC_QUIT;
    }


    for (i=0;i<_ChanCount;i++)
    {
        if (_pChanInfo[i].dwOpenHandle == dwHandle)
        {
            return i;
        }
    }
    DC_END_FN();

    DC_EXIT_POINT:
    return -1;
}


/*****************************************************************************
*
*    Routine Description:
*        Return the channel index for a given channel name 
*
*    Arguments:
*        szChanName - name of channel
*
*    Return Value:
*        index to the channel in the _pChanInfo array or -1 if not found
*
*****************************************************************************/

DCINT CVChannels::ChannelIndexFromName(PDCACHAR szChanName)
{
    DCUINT i;

    DC_BEGIN_FN("ChannelIndexFromName");

    TRC_ASSERT((_pChanInfo), (TB,_T("_pChanInfo is NULL")));
    TRC_ASSERT((szChanName), (TB,_T("szChanName is NULL")));

    if (!_pChanInfo || !szChanName)
    {
        DC_QUIT;
    }


    for (i=0;i<_ChanCount;i++)
    {
        if (!DC_ASTRNCMP(_pChanInfo[i].chanName,szChanName,
                        sizeof(_pChanInfo[i].chanName)))
        {
            return i;
        }
    }
    DC_END_FN();

    DC_EXIT_POINT:
    return -1;
}



/*****************************************************************************
*
*    Routine Description:
*        Sends data on a given virtual channel 
*
*    Arguments:
*        chanIndex     :    index of the channel to send on
*        pdata         :    pointer to the data
*        datalength    :    length of data
*
*    Return Value:
*        nothing. write is asynchronous so no notification at this point
*
*****************************************************************************/
DCBOOL  CVChannels::SendDataOnChannel(DCUINT chanIndex, LPVOID pdata, DWORD datalength)
{
    DC_BEGIN_FN("SendDataOnNamedChannel");

    DCBOOL bRetVal = TRUE;

    if (_dwConnectState  != NON_V1_CONNECT)
    {
        TRC_DBG((TB,_T("MsTscAx Vchannel: Error: SendDataOnNamedChannel when not connected\n")));
        return FALSE;
    }

    TRC_ASSERT((_pEntryPoints), (TB,_T("_pEntryPoints is NULL")));
    if (!_pEntryPoints)
    {
        bRetVal =  FALSE;
        DC_QUIT;
    }

    TRC_ASSERT((chanIndex < _ChanCount),
                (TB,_T("chanIndex out of range!!!")));

    if (chanIndex >= _ChanCount)
    {
        TRC_DBG((TB,_T("MsTscAx Vchannel: chanIndex out of range\n")));
        bRetVal =  FALSE;        
        DC_QUIT;
    }

    if (!_pChanInfo[chanIndex].fIsOpen || !_pChanInfo[chanIndex].fIsValidChannel)
    {
        TRC_DBG((TB,_T("MsTscAx Vchannel: channel not open or invalid channel\n")));
        bRetVal = FALSE;
        DC_QUIT;
    }

    if (CHANNEL_RC_OK != 
        _pEntryPoints->pVirtualChannelWriteEx(_phInitHandle,
                                              _pChanInfo[chanIndex].dwOpenHandle,
                                              pdata,
                                              datalength,
                                              pdata))
    {
        bRetVal = FALSE;
        DC_QUIT;
    }

    //
    // pdata will be freed when a write complete notification is received
    //

    DC_EXIT_POINT:
    DC_END_FN();
    return bRetVal;
}




/*****************************************************************************
*
*    Routine Description:
*        Handle a data received notification 
*
*    Arguments:
*        chanIndex     :    index to the channel
*        pdata         :    if the event was data received, then this is the pointer
*                           to data
*        datalength    :    length of data available
*        totalLength   :    totallength sent by server at a time.
*        dataFlags     :    Not Used
*
*    Return Value:
*        TRUE if data was successfully received
*
*****************************************************************************/
DCBOOL CVChannels::HandleReceiveData(IN DCUINT chanIndex, 
                         IN LPVOID pdata, 
                         IN UINT32 dataLength, 
                         IN UINT32 totalLength, 
                         IN UINT32 dataFlags)
{
    DCBOOL bRetVal = TRUE;
    DC_BEGIN_FN("HandleReceiveData");

    TRC_ASSERT((chanIndex < _ChanCount),
            (TB,_T("chanIndex out of range!!!")));

    if (chanIndex >= _ChanCount)
    {
        TRC_DBG((TB,_T("MsTscAx Vchannel: chanIndex out of range\n")));
        DC_QUIT;
    }

    //
    // Server request has been received by DLL. Read it and store it
    // for later use.
    //
    if (dataFlags & CHANNEL_FLAG_FIRST)
    {
        TRC_DBG((TB,_T("MsTscAx Vchannel: Data Received first chunk\n")));

        PCHANDATA pReceivedData = &_pChanInfo[chanIndex].CurrentlyReceivingData;

        pReceivedData->chanDataState = dataIncompleteAssemblingChunks;
        pReceivedData->dwDataLen = totalLength;

        //
        // The data buffer is stored in a BSTR
        // because it eventually gets handed out to the caller
        // in an out parameter (the caller frees)
        //
        TRC_ASSERT((NULL == _pChanInfo[chanIndex].CurrentlyReceivingData.pData),
                   (TB,_T("_pChanInfo[chanIndex].CurrentlyReceivingData.pData is NOT NULL.") \
                    _T("Are we losing received data?")));

        pReceivedData->pData = (LPVOID) SysAllocStringByteLen(NULL, totalLength);
        if(!pReceivedData->pData)
        {
            LocalFree(pReceivedData);
            TRC_ERR((TB,_T("Failed to allocate BSTR for received data in HandleReceiveData\n")));
            DC_QUIT;
        }
        DC_MEMCPY( pReceivedData->pData, pdata, dataLength);

        pReceivedData->pCurWritePointer = (LPBYTE)pReceivedData->pData + dataLength;

        if (dataFlags & CHANNEL_FLAG_LAST)
        {
            //
            // chunk is both first and last, we're done
            //
            pReceivedData->chanDataState = dataReceivedComplete;
        }
    }
    else // middle or last block
    {
        
        TRC_ASSERT((_pChanInfo[chanIndex].CurrentlyReceivingData.pData),
                   (TB,_T("_pChanInfo[chanIndex].CurrentlyReceivingData.pData is NULL.") \
                    _T("While receiving CHANNEL_FLAG_MIDDLE data!!!!")));

        PCHANDATA pReceivedData =  &_pChanInfo[chanIndex].CurrentlyReceivingData;
        TRC_ASSERT((pReceivedData->pData && pReceivedData->pCurWritePointer),
                   (TB,_T("_pChanInfo[chanIndex].pCurrentlyReceivingData write pointer(s) are NULL.")));
        if (!pReceivedData->pData || !pReceivedData->pCurWritePointer)
        {
            bRetVal = FALSE;
            DC_QUIT;
        }

        //
        // Sanity check that the write pointer is within the data buffer
        //

        LPBYTE pEnd = (LPBYTE)pReceivedData->pData + pReceivedData->dwDataLen;

        if (pReceivedData->pCurWritePointer < (LPBYTE)pReceivedData->pData ||
            pReceivedData->pCurWritePointer + dataLength > pEnd) {
            TRC_ASSERT(0,(TB,_T("pCurWritePointer is outside valid range")));
            bRetVal = FALSE;
            DC_QUIT;
        }


        DC_MEMCPY( pReceivedData->pCurWritePointer, pdata, dataLength);
        pReceivedData->pCurWritePointer += dataLength;


        if (dataFlags & CHANNEL_FLAG_LAST)
        {
            //
            // chunk is both first and last, we're done
            //
            pReceivedData->chanDataState = dataReceivedComplete;
        }
    }

    //
    // If a complete chunk was received add it to the receive list
    //
    if (dataReceivedComplete == _pChanInfo[chanIndex].CurrentlyReceivingData.chanDataState )
    {
        //Non blocking read, notify the window so it can
        //fire an event to the container
        if (_hwndControl)
        {
            PostMessage( _hwndControl,
                          WM_VCHANNEL_DATARECEIVED, (WPARAM)chanIndex,
                         (LPARAM)_pChanInfo[chanIndex].CurrentlyReceivingData.pData);
        }
        _pChanInfo[chanIndex].CurrentlyReceivingData.chanDataState = dataIncompleteAssemblingChunks;
        _pChanInfo[chanIndex].CurrentlyReceivingData.dwDataLen = 0;
        _pChanInfo[chanIndex].CurrentlyReceivingData.pData = NULL;
    }

    DC_EXIT_POINT:
    DC_END_FN();
    return bRetVal;
}

VOID WINAPI CVChannels::IntVirtualChannelOpenEventEx(
                                       IN DWORD openHandle, 
                                       IN UINT event, 
                                       IN LPVOID pdata, 
                                       IN UINT32 dataLength, 
                                       IN UINT32 totalLength, 
                                       IN UINT32 dataFlags)
{
    DC_BEGIN_FN("IntVirtualChannelOpenEventEx");
    DCUINT chanIndex = -1;

    TRC_ASSERT((_pChanInfo), (TB,_T("_pChanInfo is NULL")));
    if (!_pChanInfo)
    {
        DC_QUIT;
    }

    chanIndex = ChannelIndexFromOpenHandle(openHandle);

    if (-1 == chanIndex)
    {
        TRC_DBG((TB,_T("MsTscAx Vchannel: openHandle does not map to any known channel structure\n")));
        DC_QUIT;
    }

    TRC_ASSERT((chanIndex < _ChanCount), (TB,_T("chanIndex out of range!!!")));
    if (chanIndex >= _ChanCount)
    {
        TRC_DBG((TB,_T("MsTscAx Vchannel: chanIndex out of range\n")));
        DC_QUIT;
    }

    switch (event)
    {
    case CHANNEL_EVENT_DATA_RECEIVED:

        //
        // Receive and re-assemble data if necessary
        //
        HandleReceiveData(chanIndex, pdata, dataLength, totalLength, dataFlags);
        break;

    case CHANNEL_EVENT_WRITE_CANCELLED:
        TRC_DBG((TB,_T("MsTscAx Vchannel: Write cancelled\n")));

        // No BREAK HERE.

    case CHANNEL_EVENT_WRITE_COMPLETE:

        //
        // A write has completed.
        // All we have to do is free the data buffer
        // pdata is the send buffer
        //
        TRC_ASSERT((pdata), (TB,_T("pdata is NULL on WRITE_COMPLETE/CANCELED")));
        if (pdata)
        {
            LocalFree((HLOCAL) pdata);
        }

        break;

    default:
        TRC_DBG((TB,_T("MsTscAx Vchannel: unrecognized open event\n")));
        break;
    }

    DC_EXIT_POINT:
    DC_END_FN();
}



VOID
VCAPITYPE CVChannels::IntVirtualChannelInitEventProcEx(
                                      IN LPVOID pInitHandle, 
                                      IN UINT event, 
                                      IN LPVOID pData, 
                                      IN UINT dataLength)
{
    UINT            ui;
    UINT            i;

    UNREFERENCED_PARAMETER(pInitHandle);
    UNREFERENCED_PARAMETER(pData);
    UNREFERENCED_PARAMETER(dataLength);

    DC_BEGIN_FN("IntVirtualChannelInitEventProc");

    TRC_ASSERT((_pChanInfo), (TB,_T("_pChanInfo is NULL")));
    if (!_pChanInfo)
    {
        DC_QUIT;
    }

    TRC_ASSERT((_pEntryPoints), (TB,_T("_pEntryPoints is NULL")));
    if (!_pEntryPoints)
    {
        DC_QUIT;
    }

    switch (event)
    {
    case CHANNEL_EVENT_INITIALIZED:
        TRC_DBG((TB,_T("MsTscAx Vchannel: channel initialized\n")));
        break;

    case CHANNEL_EVENT_CONNECTED:

        //
        // We have been connected to a server
        //

        _dwConnectState=NON_V1_CONNECT;

        TRC_DBG((TB,_T("MsTscAx Vchannel: channel connected\n")));

        for (i=0; i< _ChanCount; i++)
        {
            //
            // open channel
            //
            if(_pChanInfo[i].fIsValidChannel)
            {
                ui = _pEntryPoints->pVirtualChannelOpenEx(_phInitHandle,
                                                         &_pChanInfo[i].dwOpenHandle,
                                                         _pChanInfo[i].chanName,
                                                         (PCHANNEL_OPEN_EVENT_EX_FN)
                                                          VirtualChannelOpenEventEx);
                if (ui != CHANNEL_RC_OK)
                {
                    TRC_DBG((TB,_T("MsTscAx Vchannel: virtual channel open failed\n")));
                    continue;
                }
                _pChanInfo[i].fIsOpen = TRUE;
            }
        }
        break;

    case CHANNEL_EVENT_V1_CONNECTED:

        //
        // So nothing can be done in this case.
        //
        _dwConnectState=V1_CONNECT;

        TRC_DBG((TB,_T("MsTscAx Vchannel: v1 connected\n")));
        break;

    case CHANNEL_EVENT_DISCONNECTED:

        //
        // Disconnected from the Server so cleanup
        //

        TRC_DBG((TB,_T("MsTscAx Vchannel: disconnected\n")));

        if (_dwConnectState==NON_V1_CONNECT)
        {
            for (i=0; i< _ChanCount; i++)
            {
                //
                // Close the channel
                //
                if(_pChanInfo[i].fIsValidChannel)
                {
                    _pEntryPoints->pVirtualChannelCloseEx(_phInitHandle,    
                                                          _pChanInfo[i].dwOpenHandle);
                    _pChanInfo[i].fIsOpen = FALSE;
                }
            }
        }

        _dwConnectState=NOTHING;
        break;

    case CHANNEL_EVENT_TERMINATED:

        //
        // This means that process is exiting. So cleanup the memory
        //

        TRC_DBG((TB,_T("MsTscAx Vchannel: Terminated\n")));
        if (_pEntryPoints!=NULL)
        {
            LocalFree((HLOCAL)_pEntryPoints);
            _pEntryPoints=NULL;
        }
        break;

    default:
        TRC_DBG((TB,_T("MsTscAx Vchannel: unrecognized init event\n")));
        break;
    }
    DC_EXIT_POINT:
    DC_END_FN();
}

BEGIN_EXTERN_C
/*****************************************************************************
*
*    Routine Description:
*        Virtual Channel Entry function. This is the first function called to 
*        start a virtual channel
*
*    Arguments:    
*        pEntryPoDCINTs    :    pointer to a PCHANNEL_ENTRY_POINT which contains
*                             information about this virtual channel
*
*    Return Value:
*        TRUE/FALSE      :    Depending on success of function.
*
*****************************************************************************/

BOOL 
VCAPITYPE MSTSCAX_VirtualChannelEntryEx(IN PCHANNEL_ENTRY_POINTS_EX pEntryPoints,
                                        PVOID                       pInitHandle)
{
    CHANNEL_DEF        cd[CHANNEL_MAX_COUNT];
    UINT               uRet;
    UINT               i = 0;
    HRESULT            hr;

    DC_BEGIN_FN("MSTSCAX_virtualchannelentryEx");

    if(!pInitHandle)
    {
        return FALSE;
    }

    PCHANNEL_INIT_HANDLE pChanInitHandle = (PCHANNEL_INIT_HANDLE)pInitHandle; 
    CMsTscAx* pAxCtl = (CMsTscAx*)pChanInitHandle->lpInternalAddinParam;
    if(!pAxCtl)
    {
        return FALSE;
    }

    CVChannels* pVChans = &pAxCtl->_VChans;

    pVChans->_phInitHandle = pInitHandle;
    //
    // allocate memory
    //

    //
    // Check if the CHANINFO structures have been set up by the web control
    // if not then it means virtual channels are not requested
    //
    if (!pVChans->_pChanInfo || !pVChans->_ChanCount)
    {
        TRC_ALT((TB,_T("Returning FALSE. No channels requested\n")));
        return FALSE;
    }

    pVChans->_pEntryPoints = (PCHANNEL_ENTRY_POINTS_EX)
     LocalAlloc(LPTR, pEntryPoints->cbSize);

    if (pVChans->_pEntryPoints == NULL)
    {
        TRC_ERR((TB,_T("MsTscAx: LocalAlloc failed\n")));
        DC_END_FN();
        return FALSE;
    }

    memcpy(pVChans->_pEntryPoints, pEntryPoints, pEntryPoints->cbSize);

    //
    // initialize CHANNEL_DEF structures
    //

    ZeroMemory(&cd, sizeof(cd));

    //
    // Get comma separated channel names
    //
    for (i=0; i< pVChans->_ChanCount;i++)
    {
        hr = StringCchCopyA(cd[i].name,
                           sizeof(cd[i].name), //ANSI buffer
                           pVChans->_pChanInfo[i].chanName);

        if (SUCCEEDED(hr)) {
            cd[i].options = pVChans->_pChanInfo[i].channelOptions;
        }
        else {
            TRC_ERR((TB,_T("StringCchCopy error: 0x%x"), hr));
            return FALSE;
        }
    }

    //
    // register channels
    //
    uRet = pVChans->_pEntryPoints->pVirtualChannelInitEx(
                                               (LPVOID) pVChans,
                                               pVChans->_phInitHandle,
                                               (PCHANNEL_DEF)&cd,
                                               pVChans->_ChanCount,
                                               VIRTUAL_CHANNEL_VERSION_WIN2000,
                                               (PCHANNEL_INIT_EVENT_EX_FN)
                                               VirtualChannelInitEventProcEx);

    //
    // make sure channel(s) were initialized
    //

    if (CHANNEL_RC_OK == uRet)
    {
        for(i=0;i<pVChans->_ChanCount;i++)
        {
            pVChans->_pChanInfo[i].fIsValidChannel =
                ((cd[i].options & CHANNEL_OPTION_INITIALIZED) ? TRUE : FALSE);

            //Update the vc options so they can be retreived from script
            pVChans->_pChanInfo[i].channelOptions = cd[i].options;
        }
    }
    else
    {
        LocalFree((HLOCAL)pVChans->_pEntryPoints);
        pVChans->_pEntryPoints=NULL;
        DC_END_FN();
        return FALSE;
    }

    pVChans->_dwConnectState=NOTHING;
    DC_END_FN();
    return TRUE;
}

/*****************************************************************************
*
*    Routine Description:
*        Virtual Channel Open callback function. 
*
*    Arguments:
*        openHandle    :    specifies which of the channels was opened
*        event         :    Kind of event that has occured
*        pdata         :    if the event was data received, then this is the pointer
*                           to data
*        datalength    :    length of data available
*        totalLength   :    totallength sent by server at a time.
*        dataFlags     :    Not Used
*
*    Return Value:
*        None
*
*****************************************************************************/

VOID WINAPI VirtualChannelOpenEventEx(IN LPVOID lpParam,
                                    IN DWORD openHandle, 
                                    IN UINT event, 
                                    IN LPVOID pdata, 
                                    IN UINT32 dataLength, 
                                    IN UINT32 totalLength, 
                                    IN UINT32 dataFlags)
{
    DC_BEGIN_FN("IntVirtualChannelOpenEvent");
    TRC_ASSERT((lpParam), (TB,_T("lpParam is NULL")));
    if(lpParam)
    {
        CVChannels* pVChan = (CVChannels*)lpParam;
        pVChan->IntVirtualChannelOpenEventEx( openHandle, event ,pdata,
                                              dataLength, totalLength, dataFlags);
    }
    DC_END_FN();

}

/*****************************************************************************
*
*    Routine Description:
*        Virtual Channel Init callback function. 
*
*    Arguments:
*        pInitHandle    :    Not Used
*        event          :    Kind of event that has occured
*        pdata          :    Not Used
*        datalength     :    Not Used
*
*    Return Value:
*        None
*
*****************************************************************************/

VOID 
VCAPITYPE VirtualChannelInitEventProcEx(
                                      IN LPVOID lpParam,
                                      IN LPVOID pInitHandle, 
                                      IN UINT event, 
                                      IN LPVOID pData, 
                                      IN UINT dataLength)
{
    UNREFERENCED_PARAMETER(pInitHandle);
    UNREFERENCED_PARAMETER(pData);
    UNREFERENCED_PARAMETER(dataLength);

    DC_BEGIN_FN("VirtualChannelInitEventProc");

    TRC_ASSERT((lpParam), (TB,_T("lpParam is NULL")));
    if(!lpParam)
    {
        return;
    }

    CVChannels* pVChan = (CVChannels*)lpParam;
    pVChan->IntVirtualChannelInitEventProcEx( pInitHandle, event, pData, dataLength);

    DC_END_FN();
}


END_EXTERN_C
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\cclip.h ===
/**INC+**********************************************************************/
/* Header:    cclip.h                                                       */
/*                                                                          */
/* Purpose:   Clip Client Addin header                                      */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1998-1999                             */
/*                                                                          */
/**INC-**********************************************************************/

#ifndef _H_CCLIP
#define _H_CCLIP

#ifndef INITGUID
#define INITGUID
#include <initguid.h>
#else
#include <initguid.h>
#endif

#ifndef PPVOID
typedef LPVOID * PPVOID;
#endif  //PPVOID

class CImpIDataObject;
typedef class CImpIDataObject *PIMPIDATAOBJECT;

#ifdef OS_WINCE
extern "C" HWND          ghwndClip;
#endif

#ifdef DC_DEBUG
#define CLIP_TRANSITION_RECORDING
#endif // DC_DEBUG

#ifdef CLIP_TRANSITION_RECORDING

#define DBG_RECORD_SIZE 128

extern UINT g_rguiDbgLastClipState[DBG_RECORD_SIZE];
extern UINT g_rguiDbgLastClipEvent[DBG_RECORD_SIZE];
extern LONG g_uiDbgPosition;

#endif // CLIP_TRANSITION_RECORDING

// Number of milliseconds before our IDataObject::GetData will timeout/fail

#define CLIP_GETDATA_TIMEOUT 5000

/****************************************************************************/
/* Format mapping structure                                                 */
/****************************************************************************/
typedef struct tagCB_FORMAT_MAP
{
    DCUINT  clientID;
    DCUINT  serverID;
} CB_FORMAT_MAP, FAR * PCB_FORMAT_MAP;

/****************************************************************************/
/* Maximum number of formats we support                                     */
/****************************************************************************/
#define CB_MAX_FORMATS  100

/****************************************************************************/
/* CB window class                                                          */
/****************************************************************************/
#define CB_VIEWER_CLASS       _T("CBViewerClass")

/****************************************************************************/
// Our user event 
/****************************************************************************/
#define WM_USER_CHANGE_THREAD     (WM_USER + 42)
#define WM_USER_CLEANUP_ON_TERM   (WM_USER + 43)

/****************************************************************************/
/*                                                                          */
/* CB states                                                                */
/*                                                                          */
/****************************************************************************/
#define CB_STATE_NOT_INIT                   0
#define CB_STATE_INITIALIZED                1
#define CB_STATE_ENABLED                    2
#define CB_STATE_LOCAL_CB_OWNER             3
#define CB_STATE_SHARED_CB_OWNER            4
#define CB_STATE_PENDING_FORMAT_LIST_RSP    5
#define CB_STATE_SENDING_FORMAT_DATA        6
#define CB_STATE_PENDING_FORMAT_DATA_RSP    7

#define CB_NUMSTATES                        8

/****************************************************************************/
/*                                                                          */
/* CB events                                                                */
/*                                                                          */
/****************************************************************************/
#define CB_EVENT_CB_INIT                  0
#define CB_EVENT_CB_ENABLE                1
#define CB_EVENT_CB_DISABLE               2
#define CB_EVENT_CB_TERM                  3

#define CB_EVENT_WM_CREATE                4
#define CB_EVENT_WM_DESTROY               5
#define CB_EVENT_WM_CHANGECBCHAIN         6
#define CB_EVENT_WM_DRAWCLIPBOARD         7
#define CB_EVENT_WM_RENDERFORMAT          8

#define CB_EVENT_FORMAT_LIST              9
#define CB_EVENT_FORMAT_LIST_RSP          10
#define CB_EVENT_FORMAT_DATA_RQ           11
#define CB_EVENT_FORMAT_DATA_RSP          12

#define CB_TRACE_EVENT_CB_CLIPMAIN        13
#define CB_TRACE_EVENT_CB_MONITOR_READY   14
#define CB_TRACE_EVENT_CB_DISCONNECT      15
#define CB_TRACE_EVENT_WM_EMPTY_CLIPBOARD 16

#define CB_NUMEVENTS                      13

/****************************************************************************/
/* Values in the state table                                                */
/****************************************************************************/
#define CB_TABLE_OK                         0
#define CB_TABLE_WARN                       1
#define CB_TABLE_ERROR                      2

/****************************************************************************/
/* Clipboard Viewer Window Messages                                         */
/****************************************************************************/
#define WM_EMPTY_CLIPBOARD                WM_APP+1
#define WM_CLOSE_CLIPBOARD                WM_APP+2

/****************************************************************************/
/* Macros                                                                   */
/****************************************************************************/

/****************************************************************************/
/* CB_CHECK_STATE - macro version with DC_QUIT                              */
/****************************************************************************/
#define CB_CHECK_STATE(event)                                               \
    {                                                                       \
        if (ClipCheckState(event) == CB_TABLE_ERROR)                        \
        {                                                                   \
            DC_QUIT;                                                        \
        }                                                                   \
    }                                                                       \


/****************************************************************************/
/* CB_SET_STATE - set the CB state                                          */
/****************************************************************************/
#ifndef CLIP_TRANSITION_RECORDING

#define CB_SET_STATE(newstate, event)                                       \
{                                                                           \
    TRC_NRM((TB, _T("Set state from %s to %s"),                             \
            cbState[_CB.state], cbState[newstate]));                        \
    _CB.state = newstate;                                                   \
}

#else

#define CB_SET_STATE(newstate, event)                                       \
{                                                                           \
    LONG lIncIndex;                                                         \
                                                                            \
    _CB.state = newstate;                                                   \
                                                                            \
    lIncIndex = InterlockedIncrement(&g_uiDbgPosition);                     \
    g_rguiDbgLastClipState[lIncIndex % DBG_RECORD_SIZE] = newstate;         \
    g_rguiDbgLastClipEvent[lIncIndex % DBG_RECORD_SIZE] = event;            \
}

#endif // CLIP_TRANSITION_RECORDING

// GetDataSync EVENTS
#define TS_RECEIVE_COMPLETED 0
#define TS_RESET_EVENT 1
#define TS_NUM_EVENTS 2

#include <atrcapi.h>
#include <autil.h>
#include "cclipdat.h"

//
// Clip Class Definitions
//

class CClip
{
friend CClipData ;

public:
    CClip(VCManager *virtualChannelMgr);
    ~CClip()    {;}

    DCUINT DCINTERNAL ClipCheckState(DCUINT event);
    PTS_CLIP_PDU DCINTERNAL ClipGetPermBuf(DCVOID);
    DCVOID DCINTERNAL ClipFreeBuf(PDCUINT8 pBuf);
    DCBOOL DCINTERNAL ClipDrawClipboard(DCBOOL mustSend);
#ifndef OS_WINCE
    HANDLE DCINTERNAL ClipGetMFData(HANDLE            hData,
                                PDCUINT32         pDataLen);
    HANDLE DCINTERNAL ClipSetMFData(DCUINT32   dataLen,
                                PDCVOID    pData);
#endif
    HANDLE DCINTERNAL ClipBitmapToDIB(HANDLE hData, PDCUINT32 pDataLen);
    DCBOOL DCINTERNAL ClipIsExcludedFormat(PDCTCHAR formatName) ;
    DCVOID DCINTERNAL ClipOnFormatList(PTS_CLIP_PDU pClipPDU);
    DCVOID DCINTERNAL ClipOnFormatListResponse(PTS_CLIP_PDU pClipPDU);
    DCVOID DCINTERNAL ClipOnFormatRequest(PTS_CLIP_PDU pClipPDU);
    DCVOID DCINTERNAL ClipOnFormatDataComplete(PTS_CLIP_PDU pClipPDU);
    DCUINT DCINTERNAL ClipRemoteFormatFromLocalID(DCUINT id);
    DCVOID DCINTERNAL ClipOnWriteComplete(LPVOID pData);
    DCVOID DCAPI ClipMain(DCVOID) ;
    DCINT DCAPI ClipOnInit(DCVOID);
    DCINT32 DCAPI ClipOnInitialized(DCVOID);
    DCBOOL DCAPI ClipOnTerm(LPVOID pInitHandle);
    VOID DCINTERNAL ClipOnConnected(LPVOID pInitHandle);
    VOID DCINTERNAL ClipOnMonitorReady(VOID);
    VOID DCINTERNAL ClipOnDisconnected(LPVOID pInitHandle);
    DCVOID DCAPI ClipOnDataReceived(LPVOID pData,
                                UINT32 dataLength,
                                UINT32 totalLength,
                                UINT32 dataFlags);

    DCVOID DCINTERNAL ClipOnFormatListWrapper(LPVOID pData, UINT32 dataLength) ;

    DCVOID DCAPI ClipDecoupleToClip (PTS_CLIP_PDU pData) ;

    DCINT DCAPI ClipGetData (DCUINT cfFormat) ;
    LRESULT CALLBACK DCEXPORT DCLOADDS ClipViewerWndProc(HWND   hwnd,
                                   UINT   message,
                                   WPARAM wParam,
                                   LPARAM lParam);


    static LRESULT CALLBACK DCEXPORT DCLOADDS StaticClipViewerWndProc(HWND   hwnd,
                               UINT   message,
                               WPARAM wParam,
                               LPARAM lParam);
    
    VOID VCAPITYPE VCEXPORT ClipInitEventFn(LPVOID pInitHandle,
                                        UINT   event,
                                        LPVOID pData,
                                        UINT   dataLength);

    static VOID VCAPITYPE VCEXPORT DCLOADDS ClipOpenEventFnEx(LPVOID lpUserParam,
                                        DWORD  openHandle,
                                        UINT   event,
                                        LPVOID pData,
                                        UINT32 dataLength,
                                        UINT32 totalLength,
                                        UINT32 dataFlags);

    VOID VCAPITYPE VCEXPORT DCLOADDS ClipInternalOpenEventFn(DWORD  openHandle,
                                        UINT   event,
                                        LPVOID pData,
                                        UINT32 dataLength,
                                        UINT32 totalLength,
                                        UINT32 dataFlags);

    BOOL VCAPITYPE VCEXPORT ClipChannelEntry(PCHANNEL_ENTRY_POINTS_EX pEntryPoints);

    VOID SetVCInitHandle(LPVOID pHandle)    {_CB.initHandle = pHandle;}

    HRESULT ClipCreateDataSyncEvents() ;
    DCUINT GetOsMinorType() ;
    int ClipCleanTempPath() ;
    BOOL ClipSetAndSendTempDirectory(void) ;
    int ClipCopyToTempDirectory(PVOID pSrcFiles, BOOL wide) ;
    int ClipCopyToTempDirectoryW(PVOID pSrcFiles) ;
    int ClipCopyToTempDirectoryA(PVOID pSrcFiles) ;
    UINT ClipGetNewFilePathLength(PVOID pData, BOOL fWide) ;
    UINT ClipGetNewFilePathLengthW(WCHAR* wszOldFilepath) ;
    UINT ClipGetNewFilePathLengthA(char* szOldFilepath) ;
    HRESULT ClipConvertToTempPathW(PVOID pOldData, PVOID pData, ULONG cchData) ;
    HRESULT ClipConvertToTempPathA(PVOID pOldData, PVOID pData, ULONG cchData) ;
    HRESULT ClipConvertToTempPath(PVOID pOldData, PVOID pData, ULONG cbData, BOOL wide) ;
    ULONG ClipGetNewDropfilesSizeW(PVOID pData, ULONG oldSize) ;
    ULONG ClipGetNewDropfilesSizeA(PVOID pData, ULONG oldSize) ;
    ULONG ClipGetNewDropfilesSize(PVOID pData, ULONG oldSize, BOOL wide) ;
    DWORD GetDropEffect() { return _CB.dropEffect ;}
    void SetDropEffect(DWORD dwDropEffect) { _CB.dropEffect = dwDropEffect ;}
#ifdef OS_WINCE
    DCVOID ClipFixupRichTextFormats(UINT uRtf1, UINT uRtf2);
#endif
private:
    CLIP_DATA       _CB;
    PCClipData      _pClipData ;
    CUT*            _pUtObject ;
    VCManager*      _pVCMgr; 
public:
    // _GetDataSync is an array of event handles used to synchronize the
    // transmission of data from the remote and local clipboard via the
    // IDataObject::GetData interface function
	
    // _GetDataSync[TS_RECEIVE_COMPLETED] is signaled when the format data is
    // received in full over the wire
    // _GetDataSync[TS_RESET_EVENT] is signaled when we need to reset the
    // Clipboard thread when its waiting for format data
    HANDLE  _GetDataSync[TS_NUM_EVENTS] ;

    inline BOOL IsDataSyncReady() {
        return _GetDataSync[TS_RECEIVE_COMPLETED] && _GetDataSync[TS_RESET_EVENT];
    }

};

typedef CClip *PCClip ;

/* Thread Proc for Clip */
static DCVOID DCAPI ClipStaticMain(PDCVOID param);

#endif /* _H_CCLIP  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\cclip.cpp ===
/**MOD+**********************************************************************/
/* Module:    cclip.cpp                                                     */
/*                                                                          */
/* Purpose:   Shared Clipboard Client Addin                                 */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1998-1999                             */
/*                                                                          */
/**MOD-**********************************************************************/

/****************************************************************************/
/* Precompiled header                                                       */
/****************************************************************************/
#include <precom.h>

/****************************************************************************/
/* Trace definitions                                                        */
/****************************************************************************/

#define TRC_GROUP TRC_GROUP_NETWORK
#define TRC_FILE  "cclip"
#include <atrcapi.h>

#include "vcint.h"
#include "drapi.h"

/****************************************************************************/
// Headers
/****************************************************************************/
#include <cclip.h>
#ifndef OS_WINCE
#include <shlobj.h>
#endif

#ifdef OS_WINCE
#include "ceclip.h"
#endif

#ifdef CLIP_TRANSITION_RECORDING

UINT g_rguiDbgLastClipState[DBG_RECORD_SIZE];
UINT g_rguiDbgLastClipEvent[DBG_RECORD_SIZE];
LONG g_uiDbgPosition = -1;

#endif // CLIP_TRANSITION_RECORDING

/****************************************************************************/
/* CTor                                                                     */
/****************************************************************************/
CClip::CClip(VCManager *virtualChannelMgr)
{
    PRDPDR_DATA prdpdrData;
    
    DC_BEGIN_FN("CClip::CClip");
    
    /********************************************************************/
    /* Initialize the data                                              */
    /********************************************************************/
    _GetDataSync[TS_RECEIVE_COMPLETED] = NULL;
    _GetDataSync[TS_RESET_EVENT] = NULL;
    
    DC_MEMSET(&_CB, 0, sizeof(_CB));
    
    _pVCMgr = virtualChannelMgr;
    prdpdrData =  _pVCMgr->GetInitData();
    _CB.fDrivesRedirected = prdpdrData->fEnableRedirectDrives;
    _CB.fFileCutCopyOn = _CB.fDrivesRedirected;
    _pClipData = new CClipData(this);
    if (_pClipData)
    {
        _pClipData->AddRef();
    }
    _pUtObject = (CUT*) LocalAlloc(LPTR, sizeof(CUT));
    if (_pUtObject) {
        _pUtObject->UT_Init();
    }
    
    if (prdpdrData->szClipPasteInfoString[0] != 0) {
        if (!WideCharToMultiByte(CP_ACP, 0, prdpdrData->szClipPasteInfoString, 
                -1, _CB.pasteInfoA, sizeof(_CB.pasteInfoA), NULL, NULL)) {
            StringCbCopyA(_CB.pasteInfoA,
                          sizeof(_CB.pasteInfoA),
                          "Preparing paste information...");
        }
    }
    else {
        StringCbCopyA(_CB.pasteInfoA,
                      sizeof(_CB.pasteInfoA),
                      "Preparing paste information...");
    }

    /********************************************************************/
    /* Store the hInstance                                              */
    /********************************************************************/
    _CB.hInst = GetModuleHandle(NULL);
    TRC_NRM((TB, _T("Store hInst %p"), _CB.hInst));
    DC_END_FN();
}
/****************************************************************************/
/* Wrappers for Malloc, Free & Memcpy                                       */
/****************************************************************************/

#ifdef OS_WIN32
#define ClipAlloc(size) LocalAlloc(LMEM_FIXED, size)
#define ClipFree(pData) LocalFree(pData)
#define ClipMemcpy(pTrg, pSrc, len) DC_MEMCPY(pTrg, pSrc, len)
#endif

DCUINT CClip::GetOsMinorType()
{
    DCUINT minorType = 0;
    if (_pUtObject) {
        minorType = _pUtObject->UT_GetOsMinorType();
    }
    return minorType;
}
/****************************************************************************/
// ClipCheckState
/****************************************************************************/
DCUINT DCINTERNAL CClip::ClipCheckState(DCUINT event)
{
    DCUINT tableVal = cbStateTable[event][_CB.state];

    DC_BEGIN_FN("CClip::ClipCheckState");

    TRC_DBG((TB, _T("Test event %s in state %s"),
                cbEvent[event], cbState[_CB.state]));

    if (tableVal != CB_TABLE_OK)
    {
        if (tableVal == CB_TABLE_WARN)
        {
            TRC_ALT((TB, _T("Unusual event %s in state %s"),
                      cbEvent[event], cbState[_CB.state]));
        }
        else
        {
            TRC_ABORT((TB, _T("Invalid event %s in state %s"),
                      cbEvent[event], cbState[_CB.state]));
        }
    }

    DC_END_FN();
    return(tableVal);
}

/****************************************************************************/
// ClipGetPermBuf - get a permanently allocated buffer
/****************************************************************************/
PTS_CLIP_PDU DCINTERNAL CClip::ClipGetPermBuf(DCVOID)
{
    PTS_CLIP_PDU pClipPDU;

    DC_BEGIN_FN("CClip::ClipGetPermBuf");

#ifdef USE_SEMAPHORE
    /************************************************************************/
    // On Win32, access to the permanent buffer is synchronised via a
    // semaphore
    /************************************************************************/
    TRC_NRM((TB, _T("Wait for perm TX buffer")));
    WaitForSingleObject(_CB.txPermBufSem, INFINITE);
    pClipPDU = (PTS_CLIP_PDU)(_CB.txPermBuffer);
#endif

    TRC_DBG((TB, _T("Return buffer at %#p"), pClipPDU));

    DC_END_FN();
    return(pClipPDU);
} /* ClipGetPermBuf */


/****************************************************************************/
/* ClipFreeBuf                                                              */
/****************************************************************************/
DCVOID DCINTERNAL CClip::ClipFreeBuf(PDCUINT8 pBuf)
{
#ifndef OS_WINCE
    INT i;
#endif
    DC_BEGIN_FN("CClip::ClipFreeBuf");

    TRC_DBG((TB, _T("Release buffer at %p"), pBuf));
#ifdef USE_SEMAPHORE
    if (pBuf == _CB.txPermBuffer)
    {
        TRC_DBG((TB, _T("Free Permanent buffer at %p"), pBuf));
        if (!ReleaseSemaphore(_CB.txPermBufSem, 1, NULL))
        {
            TRC_SYSTEM_ERROR("ReleaseSemaphore");
        }
    }
    else
    {
        TRC_DBG((TB, _T("Free Temporary buffer at %p"), pBuf));
        ClipFree(pBuf);
    }
#else
#ifdef OS_WINCE
    INT i;
#endif
    for (i = 0; i < CB_PERM_BUF_COUNT; i++)
    {
        TRC_DBG((TB, _T("Test buf %d, %p vs %p"), i, pBuf, _CB.txPermBuffer[i]));
        if (pBuf == _CB.txPermBuffer[i])
        {
            TRC_NRM((TB, _T("Free perm buffer %d"), i));
            _CB.txPermBufInUse[i] = FALSE;
            break;
        }
    }

    if (i == CB_PERM_BUF_COUNT)
    {
        TRC_DBG((TB, _T("Temporary buffer")));
        ClipFree(pBuf);
    }
#endif

    DC_END_FN();
    return;
} /* ClipFreePermBuf */


/****************************************************************************/
/* ClipDrawClipboard - send the local formats to the remote                 */
/****************************************************************************/
DCBOOL DCINTERNAL CClip::ClipDrawClipboard(DCBOOL mustSend)
{
    DCUINT32        numFormats;
    DCUINT          formatCount;
    DCUINT          formatID;
    //
    // formatlist is extracted from a PDU at a non-word boundary
    // so it causes an alignment fault on WIN64. Marked UNALIGNED.
    //
    PTS_CLIP_FORMAT formatList;
    DCUINT          nameLen;

    PTS_CLIP_PDU    pClipPDU = NULL;
    DCUINT32        pduLen;
    DCUINT32        dataLen;
    DCBOOL          rc = TRUE;
    DCBOOL          fHdrop = FALSE ;

    DC_BEGIN_FN("CClip::ClipDrawClipboard");

    _CB.dropEffect = FO_COPY ;
    _CB.fAlreadyCopied = FALSE ;
#ifndef OS_WINCE
    _CB.dwVersion = GetVersion() ;
#else
    OSVERSIONINFO osv;
    memset(&osv, 0, sizeof(osv));
    osv.dwOSVersionInfoSize = sizeof(osv);
    if (!GetVersionEx(&osv))
    {
        TRC_ERR((TB, _T("GetVersionEx failed!")));
        rc = FALSE;
        DC_QUIT;
    }
    _CB.dwVersion = MAKELPARAM(MAKEWORD(osv.dwMajorVersion, osv.dwMinorVersion), osv.dwBuildNumber);
#endif
    _CB.fAlreadyCopied = FALSE ;
    /************************************************************************/
    /* First we open the clipboard                                          */
    /************************************************************************/

    if (!OpenClipboard(_CB.viewerWindow))
    {
        TRC_ERR((TB, _T("Failed to open CB")));
        rc = FALSE;
        DC_QUIT;
    }

    /************************************************************************/
    /* It was/is open                                                       */
    /************************************************************************/
    TRC_NRM((TB, _T("CB opened")));
    _CB.clipOpen = TRUE;
    /************************************************************************/
    /* Count the formats available, checking we don't blow our limit        */
    /************************************************************************/
    numFormats = CountClipboardFormats();
    if (numFormats > CB_MAX_FORMATS)
    {
        TRC_ALT((TB, _T("Num formats %ld too large - limit to %d"),
                 numFormats, CB_MAX_FORMATS));
        numFormats = CB_MAX_FORMATS;
    }
    TRC_DBG((TB, _T("found %ld formats"), numFormats));

    /************************************************************************/
    /* if there are no formats available, and we don't have to send the     */
    /* info, then don't!                                                    */
    /************************************************************************/
    if ((numFormats == 0) && (mustSend == FALSE))
    {
        TRC_NRM((TB, _T("No formats: skipping send")));
        DC_QUIT;
    }

    /************************************************************************/
    /* Get a send buffer.  First work out how big it needs to be            */
    /************************************************************************/
    dataLen = numFormats * sizeof(TS_CLIP_FORMAT);
    pduLen  = dataLen + sizeof(TS_CLIP_PDU);

    /************************************************************************/
    /* and make sure that's not too big!                                    */
    /************************************************************************/
    if (pduLen > CHANNEL_CHUNK_LENGTH)
    {
        /********************************************************************/
        /* we'll have to limit the number of formats.  How many will fit in */
        /* the max buffer size?                                             */
        /********************************************************************/
        pduLen     = CHANNEL_CHUNK_LENGTH;
        dataLen    = pduLen - sizeof(TS_CLIP_PDU);
        numFormats = dataLen / sizeof(TS_CLIP_FORMAT);

        /********************************************************************/
        /* no point in having empty space for the last fractional format!   */
        /********************************************************************/
        dataLen = numFormats * sizeof(TS_CLIP_FORMAT);
        pduLen  = dataLen + sizeof(TS_CLIP_PDU);

        TRC_ALT((TB, _T("Too many formats!  Limited to %ld"), numFormats));
    }

    pClipPDU = ClipGetPermBuf();

    /************************************************************************/
    /* Fill in the common parts of the PDU                                  */
    /************************************************************************/
    DC_MEMSET(pClipPDU, 0, sizeof(*pClipPDU));

    /************************************************************************/
    /* and now the clip bits                                                */
    /************************************************************************/
    pClipPDU->msgType = TS_CB_FORMAT_LIST;
    pClipPDU->dataLen = dataLen;
#ifndef UNICODE
    pClipPDU->msgFlags = TS_CB_ASCII_NAMES;
#endif

    /************************************************************************/
    /* if there were any formats, list them                                 */
    /************************************************************************/
    if (numFormats)
    {
        /********************************************************************/
        /* set up the format list                                           */
        /********************************************************************/
        formatList = (PTS_CLIP_FORMAT)(pClipPDU->data);

        /********************************************************************/
        /* and enumerate the formats                                        */
        /********************************************************************/
        _CB.DIBFormatExists = FALSE;
        formatCount = 0;
        formatID    = EnumClipboardFormats(0); /* 0 starts the enumeration  */

        while ((formatID != 0) && (formatCount < numFormats))
        {
#ifdef OS_WINCE
            DCUINT dwTempID = formatID;
            if (formatID == gfmtShellPidlArray)
            {
                formatID = CF_HDROP;
            }
#endif
            /****************************************************************/
            /* store the ID                                                 */
            /****************************************************************/
            formatList[formatCount].formatID = formatID;

            /****************************************************************/
            /* find the name for the format                                 */
            /****************************************************************/
            nameLen = GetClipboardFormatName(formatID,
                                           (PDCTCHAR)formatList[formatCount].formatName,
                                           TS_FORMAT_NAME_LEN);

            /****************************************************************/
            /* check for predefined formats - they have no name             */
            /****************************************************************/
            if (nameLen == 0)
            {
                TRC_NRM((TB, _T("no name for format %d - predefined"), formatID));
                *(formatList[formatCount].formatName) = '\0';
            }

            TRC_DBG((TB, _T("found format id %ld, name '%s'"),
                            formatList[formatCount].formatID,
                            formatList[formatCount].formatName));

            /****************************************************************/
            /* look for formats we don't send                               */
            /****************************************************************/

            if ((formatID == CF_DSPBITMAP)      ||
                (formatID == CF_ENHMETAFILE)    ||
                ((!_CB.fFileCutCopyOn || !_CB.fDrivesRedirected) && (formatID == CF_HDROP)) ||
                (formatID == CF_OWNERDISPLAY))
            {
                // We drop enhanced metafile formats, since the local CB 
                // will provide conversion where supported 
                // 
                // Ownerdisplay just isn't going to work since the two 
                // windows are on different machines! 
                //
                // File cut/copy isn't going to work if there is no drive
                // redirection!
                 TRC_ALT((TB, _T("Dropping format ID %d"), formatID));
                formatList[formatCount].formatID = 0;
                *(formatList[formatCount].formatName) = '\0';
            }
            else if (ClipIsExcludedFormat((PDCTCHAR)formatList[formatCount].formatName))
            {
                //
                //  We don't support file cut/paste, so we drop
                //  file related formats.
                //
                TRC_ALT((TB, _T("Dropping format name '%s'"), (PDCTCHAR)formatList[formatCount].formatName));
                formatList[formatCount].formatID = 0;
                *(formatList[formatCount].formatName) = '\0';            
            } 
            else
            {
                /************************************************************/
                /* We support the CF_BITMAP format by converting it to      */
                /* CF_DIB.  If there is already a CF_DIB format, we don't   */
                /* need to do this.                                         */
                /************************************************************/
                if ((formatID == CF_BITMAP) && (_CB.DIBFormatExists))
                {
                    TRC_NRM((TB, _T("Dropping CF_BITMAP - CF_DIB is supported")));
                }
                else
                {
                    /********************************************************/
                    /* It's a supported format                              */
                    /********************************************************/
                    if (formatID == CF_BITMAP)
                    {
                        TRC_NRM((TB, _T("Convert CF_BITMAP to CF_DIB")));
                        formatList[formatCount].formatID = CF_DIB;
                    }
                    else if (formatID == CF_DIB)
                    {
                        TRC_NRM((TB, _T("Really found DIB format")));
                        _CB.DIBFormatExists = TRUE;
                    }
                    if (CF_HDROP == formatID)
                    {
                        fHdrop = TRUE ;
                    }
                    /********************************************************/
                    /* update the count and move on                         */
                    /********************************************************/
                    formatCount++;
                }
            }

#ifdef OS_WINCE
            if (formatID == CF_HDROP)
                formatID = dwTempID; //reset the enumeration index, in case we changed it to accommodate CF_HDROP
#endif
            /****************************************************************/
            /* get the next format                                          */
            /****************************************************************/
            formatID = EnumClipboardFormats(formatID);
        }

        /********************************************************************/
        /* Update the PDU len - we may have dropped some formats along the  */
        /* way                                                              */
        /********************************************************************/
        dataLen = formatCount * sizeof(TS_CLIP_FORMAT);
        pduLen  = dataLen + sizeof(TS_CLIP_PDU);
        TRC_NRM((TB, _T("Final count: %d formats in data len %ld"),
                  formatCount, dataLen));

        pClipPDU->dataLen = dataLen;
    }

    // if we're NT/2000 and we're going to send an HDROP
    if (fHdrop)
    {
        TRC_NRM((TB, _T("Creating new temp directory for file data"))) ;

        // How about handling errors from these fs calls?
#ifndef OS_WINCE
        if (GetOsMinorType() == TS_OSMINORTYPE_WINDOWS_NT)
#endif
        {
#ifndef OS_WINCE
            if (0 == GetTempFileNameW(_CB.baseTempDirW, L"_TS", 0, _CB.tempDirW)) {
#else
            if (0 == GetTempFileNameW(_CB.baseTempDirW, L"_TS", 0, _CB.tempDirW, MAX_PATH)) {
#endif
                TRC_ERR((TB, _T("Getting temp file name failed; GetLastError=%u"),
                    GetLastError()));
                rc = FALSE;
                DC_QUIT;
            }
            
            // GetACP always returns a valid value
            if (0 == WideCharToMultiByte(GetACP(), NULL, _CB.tempDirW, -1, 
              _CB.tempDirA, (MAX_PATH + 1), NULL, NULL)) {
                TRC_ERR((TB, _T("Getting temp file name failed; GetLastError=%u"),
                    GetLastError()));
                rc = FALSE;
                DC_QUIT;                              
            }
            DeleteFileW(_CB.tempDirW) ;
            
            if (0 == CreateDirectoryW(_CB.tempDirW, NULL)) {
                TRC_ERR((TB, _T("Creating temp directory failed; GetLastError=%u"),
                    GetLastError()));
                rc = FALSE;
                DC_QUIT;                              
            }
        }
#ifndef OS_WINCE
        else
        {
            if (0 == GetTempFileNameA(_CB.baseTempDirA, "_TS", 0, _CB.tempDirA)) {
                TRC_ERR((TB, _T("Getting temp file name failed; GetLastError=%u"),
                    GetLastError()));
                rc = FALSE;
                DC_QUIT;
            }
            
            // GetACP always returns a valid value
            if (0 == MultiByteToWideChar(GetACP(), MB_ERR_INVALID_CHARS, 
                _CB.tempDirA, -1, _CB.tempDirW, 
                sizeof(_CB.tempDirW)/(sizeof(_CB.tempDirW[0])) - 1)) {
                TRC_ERR((TB, _T("Failed conversion to wide char; error %d"),
                        GetLastError())) ;
                rc = FALSE ;
                DC_QUIT ;
            }                

            // Do not check return value
            DeleteFileA(_CB.tempDirA) ;
            if (0 == CreateDirectoryA(_CB.tempDirA, NULL)) {
                TRC_ERR((TB, _T("Creating temp directory failed; GetLastError=%u"),
                    GetLastError()));
                rc = FALSE;
                DC_QUIT;                              
            }
        }
#endif
    }

    /************************************************************************/
    /* Update the state                                                     */
    /************************************************************************/
    CB_SET_STATE(CB_STATE_PENDING_FORMAT_LIST_RSP, CB_EVENT_WM_DRAWCLIPBOARD);

    /************************************************************************/
    /* Send the PDU                                                         */
    /************************************************************************/
    TRC_NRM((TB, _T("Sending format list")));
    if (_CB.channelEP.pVirtualChannelWriteEx
            (_CB.initHandle, _CB.channelHandle, pClipPDU, pduLen, (LPVOID)pClipPDU)
            != CHANNEL_RC_OK) {
        ClipFreeBuf((PDCUINT8)pClipPDU);
    }



DC_EXIT_POINT:
    /************************************************************************/
    /* tidy up                                                              */
    /************************************************************************/
    if (_CB.clipOpen)
    {
        TRC_DBG((TB, _T("closing CB")));
        _CB.clipOpen = FALSE;
        if (!CloseClipboard())
        {
            TRC_SYSTEM_ERROR("CloseClipboard");
        }
    }


    DC_END_FN();

    return(rc);

} /* ClipDrawClipboard */

#ifndef OS_WINCE

/****************************************************************************/
/* ClipGetMFData                                                            */
/****************************************************************************/
HANDLE DCINTERNAL CClip::ClipGetMFData(HANDLE            hData,
                                PDCUINT32         pDataLen)
{
    DCUINT32        lenMFBits = 0;
    DCBOOL          rc        = FALSE;
    LPMETAFILEPICT  pMFP      = NULL;
    HDC             hMFDC     = NULL;
    HMETAFILE       hMF       = NULL;
    HGLOBAL         hMFBits   = NULL;
    HANDLE          hNewData  = NULL;
    PDCUINT8        pNewData  = NULL;
    PDCVOID         pBits     = NULL;

    DC_BEGIN_FN("CClip::ClipGetMFData");

    TRC_NRM((TB, _T("Getting MF data")));
    /************************************************************************/
    /* Lock the memory to get a pointer to a METAFILEPICT header structure  */
    /* and create a METAFILEPICT DC.                                        */
    /************************************************************************/
    if (GlobalSize(hData) < sizeof(METAFILEPICT)) {
        TRC_ERR((TB, _T("Unexpected global memory size!")));
        _CB.channelEP.pVirtualChannelCloseEx(_CB.initHandle, _CB.channelHandle);
        DC_QUIT;
    }
    
    pMFP = (LPMETAFILEPICT)GlobalLock(hData);
    if (pMFP == NULL)
    {
        TRC_SYSTEM_ERROR("GlobalLock");
        DC_QUIT;
    }

    hMFDC = CreateMetaFile(NULL);
    if (hMFDC == NULL)
    {
        TRC_SYSTEM_ERROR("CreateMetaFile");
        DC_QUIT;
    }

    /************************************************************************/
    /* Copy the MFP by playing it into the DC and closing it.               */
    /************************************************************************/
    if (!PlayMetaFile(hMFDC, pMFP->hMF))
    {
        TRC_SYSTEM_ERROR("PlayMetaFile");
        CloseMetaFile(hMFDC);
        DC_QUIT;
    }
    hMF = CloseMetaFile(hMFDC);
    if (hMF == NULL)
    {
        TRC_SYSTEM_ERROR("CloseMetaFile");
        DC_QUIT;
    }

    /************************************************************************/
    /* Get the MF bits and determine how long they are.                     */
    /************************************************************************/
    lenMFBits = GetMetaFileBitsEx(hMF, 0, NULL);
    if (lenMFBits == 0)
    {
        TRC_SYSTEM_ERROR("GetMetaFileBitsEx");
        DC_QUIT;
    }
    TRC_DBG((TB, _T("length MF bits %ld"), lenMFBits));

    /************************************************************************/
    /* Work out how much memory we need and get a buffer                    */
    /************************************************************************/
    *pDataLen = sizeof(TS_CLIP_MFPICT) + lenMFBits;
    hNewData = GlobalAlloc(GHND, *pDataLen);
    if (hNewData == NULL)
    {
        TRC_ERR((TB, _T("Failed to get MF buffer")));
        DC_QUIT;
    }
    pNewData = (PDCUINT8)GlobalLock(hNewData);
    if (NULL == pNewData) {
        TRC_ERR((TB,_T("Failed to lock MF buffer")));
        DC_QUIT;
    }
    
    TRC_DBG((TB, _T("Got data to send len %ld"), *pDataLen));

    /************************************************************************/
    /* Copy the MF header and bits into the buffer.                         */
    /************************************************************************/
    ((PTS_CLIP_MFPICT)pNewData)->mm   = pMFP->mm;
    ((PTS_CLIP_MFPICT)pNewData)->xExt = pMFP->xExt;
    ((PTS_CLIP_MFPICT)pNewData)->yExt = pMFP->yExt;

    lenMFBits = GetMetaFileBitsEx(hMF, lenMFBits,
                                  (pNewData + sizeof(TS_CLIP_MFPICT)));
    if (lenMFBits == 0)
    {
        TRC_SYSTEM_ERROR("GetMetaFileBitsEx");
        DC_QUIT;
    }

    /************************************************************************/
    /* all OK                                                               */
    /************************************************************************/
    TRC_NRM((TB, _T("Got %ld bits of MF data"), lenMFBits));
    TRC_DATA_DBG("MF bits",
                 (pNewData + sizeof(TS_CLIP_MFPICT)),
                 (DCUINT)lenMFBits);
    rc = TRUE;

DC_EXIT_POINT:
    /************************************************************************/
    /* Unlock any global mem.                                               */
    /************************************************************************/
    if (pMFP)
    {
        GlobalUnlock(hData);
    }
    if (pNewData)
    {
        GlobalUnlock(hNewData);
    }
    if (hMF)
    {
        DeleteMetaFile(hMF);
    }

    /************************************************************************/
    /* if things went wrong, then free the new data                         */
    /************************************************************************/
    if ((rc == FALSE) && (hNewData != NULL))
    {
        GlobalFree(hNewData);
        hNewData = NULL;
    }

    DC_END_FN();
    return(hNewData);
}  /* ClipGetMFData */


/****************************************************************************/
/* ClipSetMFData                                                            */
/****************************************************************************/
HANDLE DCINTERNAL CClip::ClipSetMFData(DCUINT32   dataLen,
                                PDCVOID    pData)
{
    DCBOOL         rc           = FALSE;
    HGLOBAL        hMFBits      = NULL;
    PDCVOID        pMFMem       = NULL;
    HMETAFILE      hMF          = NULL;
    HGLOBAL        hMFPict      = NULL;
    LPMETAFILEPICT pMFPict      = NULL;

    DC_BEGIN_FN("CClip::ClipSetMFData");

    TRC_DATA_DBG("Received MF data", pData, (DCUINT)dataLen);

    /************************************************************************/
    /* Allocate memory to hold the MF bits (we need the handle to pass to   */
    /* SetMetaFileBits).                                                    */
    /************************************************************************/
    hMFBits = GlobalAlloc(GHND, dataLen - (DCUINT32)sizeof(TS_CLIP_MFPICT));
    if (hMFBits == NULL)
    {
        TRC_SYSTEM_ERROR("GlobalAlloc");
        DC_QUIT;
    }

    /************************************************************************/
    /* Lock the handle and copy in the MF header.                           */
    /************************************************************************/
    pMFMem = GlobalLock(hMFBits);
    if (pMFMem == NULL)
    {
        TRC_ERR((TB, _T("Failed to lock MF mem")));
        DC_QUIT;
    }

    DC_HMEMCPY(pMFMem,
               (PDCVOID)((PDCUINT8)pData + sizeof(TS_CLIP_MFPICT)),
               dataLen - sizeof(TS_CLIP_MFPICT) );

    GlobalUnlock(hMFBits);

    /************************************************************************/
    /* Now use the copied MF bits to create the actual MF bits and get a    */
    /* handle to the MF.                                                    */
    /************************************************************************/
    hMF = SetMetaFileBitsEx(dataLen - sizeof(TS_CLIP_MFPICT), (PDCUINT8)pMFMem);
    if (hMF == NULL)
    {
        TRC_SYSTEM_ERROR("SetMetaFileBits");
        DC_QUIT;
    }

    /************************************************************************/
    /* Allocate a new METAFILEPICT structure, and use the data from the     */
    /* sent header.                                                         */
    /************************************************************************/
    hMFPict = GlobalAlloc(GHND, sizeof(METAFILEPICT));
    pMFPict = (LPMETAFILEPICT)GlobalLock(hMFPict);
    if (!pMFPict)
    {
        TRC_ERR((TB, _T("Couldn't allocate METAFILEPICT")));
        DC_QUIT;
    }

    pMFPict->mm   = (LONG)((PTS_CLIP_MFPICT)pData)->mm;
    pMFPict->xExt = (LONG)((PTS_CLIP_MFPICT)pData)->xExt;
    pMFPict->yExt = (LONG)((PTS_CLIP_MFPICT)pData)->yExt;
    pMFPict->hMF  = hMF;

    GlobalUnlock(hMFPict);

    rc = TRUE;

DC_EXIT_POINT:
    /************************************************************************/
    /* tidy up                                                              */
    /************************************************************************/
    if (!rc)
    {
        if (hMFPict)
        {
            GlobalFree(hMFPict);
        }
    }

    {
        if (hMFBits)
        {
            GlobalFree(hMFBits);
        }
    }

    DC_END_FN();
    return(hMFPict);

} /* ClipSetMFData */
#endif


/****************************************************************************/
/* ClipBitmapToDIB - convert CF_BITMAP format to CF_DIB format              */
/****************************************************************************/
HANDLE DCINTERNAL CClip::ClipBitmapToDIB(HANDLE hData, PDCUINT32 pDataLen)
{
    BITMAP          bmpDetails = {0};
    DWORD           buffSize, buffWidth;
    DWORD           paletteBytes;
    WORD            bpp;
    DWORD           numCols;
    int             rc;
    HANDLE          hDIBitmap = NULL;
    HPDCVOID        pDIBitmap = NULL;
    HPDCVOID        pBits = NULL;
    PBITMAPINFO     pBmpInfo = NULL;
    HDC             hDC = NULL;
    DCBOOL          allOK = FALSE;

    DC_BEGIN_FN("CClip::ClipBitmapToDIB");

    *pDataLen = 0;

    /************************************************************************/
    /* get the details of the bitmap                                        */
    /************************************************************************/
    if (0 == GetObject(hData, sizeof(bmpDetails), &bmpDetails)) {
        TRC_ERR((TB, _T("Failed to get bitmap details")));
        DC_QUIT;
    }
    
    TRC_NRM((TB, _T("Bitmap details: width %d, height %d, #planes %d, bpp %d"),
            bmpDetails.bmWidth, bmpDetails.bmHeight, bmpDetails.bmPlanes,
            bmpDetails.bmBitsPixel));

    /************************************************************************/
    /* Space required for bits is                                           */
    /*                                                                      */
    /*   (width * bpp / 8) rounded up to multiple of 4 bytes                */
    /* * height                                                             */
    /*                                                                      */
    /************************************************************************/
    bpp = (WORD)(bmpDetails.bmBitsPixel * bmpDetails.bmPlanes);
    buffWidth = ((bmpDetails.bmWidth * bpp) + 7) / 8;
    buffWidth = DC_ROUND_UP_4(buffWidth);

    buffSize = buffWidth * bmpDetails.bmHeight;
    TRC_DBG((TB, _T("Buffer size %ld (W %ld, H %d)"),
            buffSize, buffWidth, bmpDetails.bmHeight));

    /************************************************************************/
    /* Now add some space for the bitmapinfo - this includes a color table  */
    /************************************************************************/
    numCols = 1 << bpp;
    if (bpp <= 8)
    {
        paletteBytes = numCols * sizeof(RGBQUAD);
        TRC_NRM((TB, _T("%ld colors => %ld palette bytes"), numCols, paletteBytes));
    }
    else
    {
        if (bpp == 24)
        {
            /****************************************************************/
            /* No bitmasks or palette info (compression==BI_RGB)            */
            /****************************************************************/
            paletteBytes = 0;
            TRC_NRM((TB, _T("%ld colors => 0 bitfield bytes"), numCols));
        }
        else
        {
            /****************************************************************/
            /* 3 DWORD color masks for >8bpp (compression==BI_BITFIELDS)    */
            /****************************************************************/
            paletteBytes = 3 * sizeof(DWORD);
            TRC_NRM((TB, _T("%ld colors => %ld bitfield bytes"), numCols, paletteBytes));
        }
    }
    buffSize += (sizeof(BITMAPINFOHEADER) + paletteBytes);
    TRC_NRM((TB, _T("Buffer size %ld"), buffSize));

    /************************************************************************/
    /* Allocate memory to hold everything                                   */
    /************************************************************************/
    hDIBitmap = GlobalAlloc(GHND, buffSize);
    if (hDIBitmap == NULL)
    {
        TRC_ERR((TB, _T("Failed to alloc %ld bytes"), buffSize));
        DC_QUIT;
    }
    pDIBitmap = GlobalLock(hDIBitmap);
    if (pDIBitmap == NULL)
    {
        TRC_ERR((TB, _T("Failed to lock hDIBitmap")));
        DC_QUIT;
    }

    /************************************************************************/
    /* bmp info is at the start                                             */
    /* space for bits are in the middle somewhere                           */
    /************************************************************************/
    pBmpInfo = (PBITMAPINFO)pDIBitmap;
    pBits    = (HPDCVOID)((HPDCUINT8)pDIBitmap +
                                     sizeof(BITMAPINFOHEADER) + paletteBytes);
    TRC_NRM((TB, _T("pBmpInfo at %p, pBits at %p"), pBmpInfo, pBits));

    /************************************************************************/
    /* set up the desired bitmap info                                       */
    /************************************************************************/
    pBmpInfo->bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
    pBmpInfo->bmiHeader.biWidth         = bmpDetails.bmWidth;
    pBmpInfo->bmiHeader.biHeight        = bmpDetails.bmHeight;
    pBmpInfo->bmiHeader.biPlanes        = 1;
    pBmpInfo->bmiHeader.biBitCount      = bpp;
    if ((bpp <= 8) || (bpp == 24))
    {
        pBmpInfo->bmiHeader.biCompression = BI_RGB;
    }
    else
    {
        pBmpInfo->bmiHeader.biCompression = BI_BITFIELDS;
    }
    pBmpInfo->bmiHeader.biSizeImage     = 0;
    pBmpInfo->bmiHeader.biXPelsPerMeter = 0;
    pBmpInfo->bmiHeader.biYPelsPerMeter = 0;
    pBmpInfo->bmiHeader.biClrUsed       = 0;
    pBmpInfo->bmiHeader.biClrImportant  = 0;

    /************************************************************************/
    /* get a DC                                                             */
    /************************************************************************/
    hDC = GetDC(NULL);
    if (!hDC)
    {
        TRC_SYSTEM_ERROR("GetDC");
        DC_QUIT;
    }

    /************************************************************************/
    /* now get the bits                                                     */
    /************************************************************************/
    TRC_NRM((TB, _T("GetDIBits")));
    rc = GetDIBits(hDC,                   // hdc
                   (HBITMAP)hData,                 // hbm
                   0,                     // nStartScan
                   bmpDetails.bmHeight,   // nNumScans
                   pBits,                 // pBits
                   pBmpInfo,              // pbmi
                   DIB_RGB_COLORS);       // iUsage
    TRC_NRM((TB, _T("GetDIBits returns %d"), rc));
    if (!rc)
    {
        TRC_SYSTEM_ERROR("GetDIBits");
        DC_QUIT;
    }

    /************************************************************************/
    /* All seems to be OK                                                   */
    /************************************************************************/
    *pDataLen = buffSize;
    TRC_NRM((TB, _T("All done: data %p, len %ld"), hDIBitmap, *pDataLen));
    allOK = TRUE;

DC_EXIT_POINT:
    /************************************************************************/
    /* Finished with the DC - free it                                       */
    /************************************************************************/
    if (hDC)
    {
        TRC_DBG((TB, _T("Free the DC")));
        ReleaseDC(NULL, hDC);
    }

    /************************************************************************/
    /* Free the return buffer if this didn't work                           */
    /************************************************************************/
    if (!allOK)
    {
        if (pDIBitmap)
        {
            TRC_DBG((TB, _T("Unlock DIBitmap")));
            GlobalUnlock(hDIBitmap);
        }
        if (hDIBitmap)
        {
            TRC_DBG((TB, _T("Free DIBitmap")));
            GlobalFree(hDIBitmap);
            hDIBitmap = NULL;
        }
    }

    DC_END_FN();
    return(hDIBitmap);

} /* ClipBitmapToDIB */

DCBOOL DCINTERNAL CClip::ClipIsExcludedFormat(PDCTCHAR formatName)
{
    DCBOOL  rc = FALSE;
    DCINT   i;

    DC_BEGIN_FN("CClip::ClipIsExcludedFormat");

    /************************************************************************/
    /* check there is a format name - all banned formats have one!          */
    /************************************************************************/
    if (*formatName == _T('\0'))
    {
        TRC_ALT((TB, _T("No format name supplied!")));
        DC_QUIT;
    }

    /************************************************************************/
    /* search the banned format list for the supplied format name           */
    /************************************************************************/
    TRC_DBG((TB, _T("Looking at format '%s'"), formatName));
    TRC_DATA_DBG("Format name data", formatName, TS_FORMAT_NAME_LEN);

    // if File Cut/Copy is on AND Drive Redirection is on, we can handle
    // more formats
    if (_CB.fFileCutCopyOn && _CB.fDrivesRedirected)
    {
        for (i = 0; i < CB_EXCLUDED_FORMAT_COUNT; i++)
        {
            TRC_DBG((TB, _T("comparing with '%s'"), g_excludedFormatList[i]));
            if (DC_WSTRCMP((PDCWCHAR)formatName,
                                         (PDCWCHAR)g_excludedFormatList[i]) == 0)
            {
                TRC_NRM((TB, _T("Found excluded format '%s'"), formatName));
                rc = TRUE;
                break;
            }
        }
    }
    else
    {
        for (i = 0; i < CB_EXCLUDED_FORMAT_COUNT_NO_RD; i++)
        {
            TRC_DBG((TB, _T("comparing with '%s'"), g_excludedFormatList_NO_RD[i]));
            if (DC_WSTRCMP((PDCWCHAR)formatName,
                                         (PDCWCHAR)g_excludedFormatList_NO_RD[i]) == 0)
            {
                TRC_NRM((TB, _T("Found excluded format '%s'"), formatName));
                rc = TRUE;
                break;
            }
        }
    }
DC_EXIT_POINT:
    DC_END_FN();

    return(rc);
} /* ClipIsExcludedFormat */

#ifndef OS_WINCE
//
// ClipCleanTempPath
// - Returns 0 if successful
//           nonzero if failed
// - Attempts to wipe the temp directory of TS related files
//
int CClip::ClipCleanTempPath()
{
    int result;
    SHFILEOPSTRUCTW fileOpStructW;
    PRDPDR_DATA prdpdrData = _pVCMgr->GetInitData();

#ifndef UNICODE
#error function assumes unicode
#endif
    _CB.baseTempDirW[wcslen(_CB.baseTempDirW)] = L'\0' ;
    fileOpStructW.pFrom = _CB.baseTempDirW ;
    fileOpStructW.pTo = NULL ;
    fileOpStructW.hwnd = NULL ;
    fileOpStructW.wFunc = FO_DELETE ;
    fileOpStructW.fFlags = FOF_NOCONFIRMATION | FOF_NOERRORUI | 
            FOF_SIMPLEPROGRESS;
    fileOpStructW.hNameMappings = NULL ;

    if (prdpdrData->szClipCleanTempDirString[0] != 0) {
        fileOpStructW.lpszProgressTitle = prdpdrData->szClipCleanTempDirString;
    }
    else {
        fileOpStructW.lpszProgressTitle = L"Cleaning temp directory";
    }

    //
    // Use SHFileOperation instead of SHFileOperationW to ensure
    // it goes through the unicode wrapper. Note SHFileOperationW
    // is not available on 95 so the wrapper dynamically binds to
    // the entry point.
    //

    result = SHFileOperation(&fileOpStructW) ;
    return result ;
        
}

#else
//We dont want to use the recycle bin on CE
int CClip::ClipCleanTempPath()
{
    return (_CB.fFileCutCopyOn) ? DeleteDirectory(_CB.baseTempDirW, FALSE) : ERROR_SUCCESS;
}
#endif

//
// ClipCopyToTempDirectory, ClipCopyToTempDirectoryA, ClipCopyToTempDirectoryW
// - Arguments:
//       pSrcFiles = buffer containing the names/path of the files to be copied
// - Returns 0 if successful
//           nonzero if failed
// - Given a list of file names/paths, this function will attempt to copy them
//   to the temp directory
//
int CClip::ClipCopyToTempDirectory(PVOID pSrcFiles, BOOL fWide)
{
    int result ;
    if (fWide)
        result = ClipCopyToTempDirectoryW(pSrcFiles) ;
    else
        result = ClipCopyToTempDirectoryA(pSrcFiles) ;

    return result ;
        
}

#ifndef OS_WINCE
int CClip::ClipCopyToTempDirectoryW(PVOID pSrcFiles)
{
    SHFILEOPSTRUCTW fileOpStructW ;
    HMODULE hmodSH32DLL;
    PRDPDR_DATA prdpdrData = _pVCMgr->GetInitData();
    int result = 1;
    
    typedef HRESULT (STDAPICALLTYPE FNSHFileOperationW)(LPSHFILEOPSTRUCT);
    FNSHFileOperationW *pfnSHFileOperationW;

    // get the handle to shell32.dll library
    hmodSH32DLL = LoadLibrary(TEXT("SHELL32.DLL"));

    if (hmodSH32DLL != NULL) {
        // get the proc address for SHFileOperation
        pfnSHFileOperationW = (FNSHFileOperationW *)GetProcAddress(hmodSH32DLL, "SHFileOperationW");

        if (pfnSHFileOperationW != NULL) {

            _CB.tempDirW[wcslen(_CB.tempDirW)] = L'\0' ;
            fileOpStructW.pFrom = (WCHAR*) pSrcFiles ;
            fileOpStructW.pTo = _CB.tempDirW ;
            fileOpStructW.hwnd = NULL ;
            fileOpStructW.wFunc = _CB.dropEffect ;
            fileOpStructW.fFlags = FOF_NOCONFIRMATION | FOF_NOCONFIRMMKDIR | 
                    FOF_SIMPLEPROGRESS  | FOF_ALLOWUNDO ;
            fileOpStructW.hNameMappings = NULL ;

            if (prdpdrData->szClipPasteInfoString[0] != 0) {
                fileOpStructW.lpszProgressTitle = prdpdrData->szClipPasteInfoString;
            }
            else {
                fileOpStructW.lpszProgressTitle = L"Preparing paste information...";
            }
          
            //result = SHFileOperationW(&fileOpStructW) ;
            result = (*pfnSHFileOperationW) (&fileOpStructW);
        }
        
        FreeLibrary(hmodSH32DLL);
    }

    return result ;
}
#else
//SHFileOperation on CE does not support copying multiple files
int CClip::ClipCopyToTempDirectoryW(PVOID pSrcFiles)
{
    DC_BEGIN_FN("CClip::ClipCopyToTempDirectoryW") ;
    
    TRC_ASSERT((pSrcFiles != NULL), (TB, _T("pSrcFiles is NULL")));

    WCHAR *pFiles = (WCHAR *)pSrcFiles;
    
    WCHAR szDest[MAX_PATH+1];
    wcsncpy(szDest, _CB.tempDirW, MAX_PATH);
    int nTempLen = wcslen(szDest);

    while(*pFiles)
    {
        int nLen = wcslen(pFiles);
        WCHAR *pFile = wcsrchr(pFiles, L'\\');
        if (pFile && nLen < MAX_PATH)
        {
            wcsncat(szDest, pFile, MAX_PATH - nTempLen - 1);

            DWORD dwAttrib = GetFileAttributes(pFiles);
            if ((dwAttrib != 0xffffffff) && (dwAttrib & FILE_ATTRIBUTE_DIRECTORY))
            {
                WIN32_FIND_DATA fd;
                WCHAR szSrc[MAX_PATH];

                wcscpy(szSrc, pFiles);
                if (!CopyDirectory(szSrc, szDest, &fd))
                {
                    TRC_ERR((TB, _T("CopyDirectory from %s to %s failed. GLE=0x%08x"), pFiles, szDest, GetLastError())) ;    
                    return GetLastError();
                }
            }
            else if (!CopyFile(pFiles, szDest, FALSE))
            {
                TRC_ERR((TB, _T("CopyFile from %s to %s failed. GLE=0x%08x"), pFiles, szDest, GetLastError())) ;    
                return GetLastError();
            }
            szDest[nTempLen] = L'\0';
        }
        else
        {
            TRC_ERR((TB, _T("Invalid filename : %s"), pFiles)) ;
        }
        pFiles += nLen + 1;
    }

    DC_END_FN();
    return 0;
}
#endif

int CClip::ClipCopyToTempDirectoryA(PVOID pSrcFiles)
{
#ifndef OS_WINCE
    SHFILEOPSTRUCTA fileOpStructA ;
    int result ;

    _CB.tempDirA[strlen(_CB.tempDirA)] = '\0' ;
    fileOpStructA.pFrom = (char*) pSrcFiles ;
    fileOpStructA.pTo = _CB.tempDirA ;
    fileOpStructA.hwnd = NULL ;
    fileOpStructA.wFunc = _CB.dropEffect ;
    fileOpStructA.fFlags = FOF_NOCONFIRMATION | FOF_NOCONFIRMMKDIR | 
            FOF_SIMPLEPROGRESS  | FOF_ALLOWUNDO ;
    fileOpStructA.hNameMappings = NULL ;
    fileOpStructA.lpszProgressTitle = _CB.pasteInfoA;

    result = SHFileOperationA(&fileOpStructA) ;
    return result ;
#else
    DC_BEGIN_FN("CClip::ClipConvertToTempPathA") ;
    TRC_ASSERT((FALSE), (TB, _T("CE doesnt support ClipConvertToTempPathA")));
    DC_END_FN() ;
    return E_FAIL;
#endif
}

//
// ClipConvertToTempPath, ClipConvertToTempPathA, ClipConvertToTempPathW
// - Arguments:
//       pOldData = Buffer containing the original file path
//       pData    = Buffer receiving the new file path
//       fWide     = Wide or Ansi characters
// - Returns S_OK if pOldData was a network path
//           S_FALSE if pOldData was not a network path
//           E_FAIL if it failed
// - Given a unc file path, this function will strip out the old path, and
//   prepend a path to the client's TS temp directory
//
HRESULT CClip::ClipConvertToTempPath(PVOID pOldData, PVOID pData, ULONG cbData, BOOL fWide)
{
    HRESULT result ;
    DC_BEGIN_FN("CClip::ClipConvertToTempPath") ;
    if (!pOldData)
    {
        TRC_ERR((TB, _T("Original string pointer is NULL"))) ;
        result = E_FAIL ;
        DC_QUIT ;
    }
    if (!pData)
    {
        TRC_ERR((TB, _T("Destination string pointer is NULL"))) ;
        result = E_FAIL ;
        DC_QUIT ;
    }
    if (fWide) {
        result = ClipConvertToTempPathW(pOldData, pData, cbData / sizeof(WCHAR)) ;
    } else {
        result = ClipConvertToTempPathA(pOldData, pData, cbData) ;
    }
DC_EXIT_POINT:
    return result ;
    DC_END_FN() ;    
}

HRESULT CClip::ClipConvertToTempPathW(PVOID pOldData, PVOID pData, ULONG cchData)
{
    WCHAR*         filePath ;
#ifndef OS_WINCE
    WCHAR*         driveLetter ;
    WCHAR*         uncPath ;
    WCHAR*         prependText ;
    DWORD          charSize ;
    DWORD          driveLetterLength ;
#endif
    HRESULT        hr;

    DC_BEGIN_FN("CClip::ClipConvertToTempPathW") ;

    // if this is a UNC path beginning with a "\\"
    if (((WCHAR*)pOldData)[0] == L'\\' &&
        ((WCHAR*)pOldData)[1] == L'\\')
    {
        // prepend the new file path with the temp directory
        hr = StringCchCopyW((WCHAR*) pData, cchData, _CB.tempDirW);
        if (SUCCEEDED(hr)) {
            filePath = wcsrchr((WCHAR*) pOldData, L'\\');
            hr = StringCchCatW((WCHAR*) pData, cchData, filePath);
        }
        if (FAILED(hr)) {
            TRC_ERR((TB,_T("Failed to copy and cat string: 0x%x"),hr));
        }
    }
    else
    {
        TRC_NRM((TB, _T("Not a UNC path"))) ;
        hr = StringCchCopyW((WCHAR*) pData, cchData, (WCHAR*) pOldData);
        if (SUCCEEDED(hr)) {
            hr = S_FALSE;
        }
    }
    
#ifdef OS_WINCE
    //Send it as "Files:" to the server
    if( (((WCHAR*)pData)[0] == L'\\') && ((wcslen((WCHAR *)pData) + sizeof(CEROOTDIRNAME)/sizeof(WCHAR)) < MAX_PATH) )
    {
        WCHAR szFile[MAX_PATH];
        wcscpy(szFile, (WCHAR *)pData);
        wcscpy((WCHAR *)pData, CEROOTDIRNAME);
        wcscat((WCHAR *)pData, szFile);
    }
    else
    {
        DC_END_FN() ;
        return S_FALSE;
    }
#endif
        
    DC_END_FN() ;
    
    return hr;
}

HRESULT CClip::ClipConvertToTempPathA(PVOID pOldData, PVOID pData, ULONG cchData)
{
#ifndef OS_WINCE
    char*         filePath ;
    char*         driveLetter ;
    char*         uncPath ;
    char*         prependText ;
    DWORD         charSize ;
    DWORD         driveLetterLength ;
    HRESULT       hr = E_FAIL;

    DC_BEGIN_FN("CClip::ClipConvertToTempPathA") ;

    charSize = sizeof(char) ;

    // if this is a UNC path beginning with a "\\"
    if (((char*) pOldData)[0] == '\\' &&
        ((char*) pOldData)[1] == '\\')
    {
        // prepend the new file path with the temp directory
        hr = StringCchCopyA((char*) pData, cchData, _CB.tempDirA);
        if (SUCCEEDED(hr)) {
            filePath = strrchr((char*) pOldData, '\\');
            if (filePath) {
                hr = StringCchCatA((char*) pData, cchData, filePath);
            } else {
                hr = E_FAIL;
            }
        }
        if (FAILED(hr)) {
            TRC_ERR((TB,_T("Failed to copy and cat string: 0x%x"),hr));
        }
    }
    else
    {
        TRC_NRM((TB, _T("Not a UNC path"))) ;
        hr = StringCchCopyA((char*) pData, cchData, (char*) pOldData);
        if (SUCCEEDED(hr)) {
            hr = S_FALSE;
        }
    }
    DC_END_FN() ;

    return hr;
#else
    DC_BEGIN_FN("CClip::ClipConvertToTempPathA") ;
    TRC_ASSERT((FALSE), (TB, _T("CE doesnt support ClipConvertToTempPathA")));
    DC_END_FN() ;
    return S_FALSE ;
#endif
}

#ifndef OS_WINCE
//
// ClipGetNewFilePathLength
// - Arguments:
//       pData    = Buffer containing a filepath
//       fWide    = Wide or Ansi (TRUE if wide, FALSE if ansi)
// - Returns new size of the drop file
//           0 if it fails
// - Given a UNC file path, this returns the new size required
//   if the directory structure is removed, and is replaced by
//   the temp directory path
// - Otherwise, if it doesn't explicitly fail, it returns the
//   old length
//
UINT CClip::ClipGetNewFilePathLength(PVOID pData, BOOL fWide)
{
    UINT result ;
    DC_BEGIN_FN("CClip::ClipGetNewFilePathLength") ;
    if (!pData)
    {
        TRC_ERR((TB, _T("Filename is NULL"))) ;
        result = 0 ;
    }
    if (fWide)
        result = ClipGetNewFilePathLengthW((WCHAR*)pData) ;
    else
        result = ClipGetNewFilePathLengthA((char*)pData) ;
DC_EXIT_POINT:
    DC_END_FN() ;

    return result ;
}

UINT CClip::ClipGetNewFilePathLengthW(WCHAR* wszOldFilepath)
{
    UINT oldLength = wcslen(wszOldFilepath) ;
    UINT newLength = oldLength ;
    UINT remainingLength = oldLength ;
    byte charSize = sizeof(WCHAR) ;
    DC_BEGIN_FN("CClip::ClipGetNewFilePathLengthW") ;

    // if the old filename didn't even have space for "c:\" (with NULL),
    // then its probably invalid
    if (4 > oldLength)
    {
        newLength = 0 ;
        DC_QUIT ;
    }
    if ((L'\\' ==wszOldFilepath[0]) && (L'\\' ==wszOldFilepath[1]))
    {
        while ((0 != remainingLength) && (L'\\' != wszOldFilepath[remainingLength]))
        {
            remainingLength-- ;
        }
    
        // Add the length of the temp directory path, and subtract the
        // path preceeding the filename ("path\filename" -> "\filename")
        // (\\server\sharename\path\morepath\filename
        newLength = oldLength - remainingLength + wcslen(_CB.tempDirW) ;
    }
DC_EXIT_POINT:
    DC_END_FN() ;
    return (newLength + 1) * charSize ; // +1 is for the NULL terminator
}

UINT CClip::ClipGetNewFilePathLengthA(char* szOldFilepath)
{
    UINT oldLength = strlen(szOldFilepath) ;
    UINT newLength = oldLength ;
    UINT remainingLength = oldLength ;
    byte charSize = sizeof(char) ;
    DC_BEGIN_FN("CClip::ClipGetNewFilePathLengthA") ;

    // if the old filename didn't even have space for "c:\" (with NULL),
    // then it's probably invalid
    if (4 > oldLength)
    {
        newLength = 0 ;
        DC_QUIT ;
    }
    if (('\\' == szOldFilepath[0]) && ('\\' == szOldFilepath[1]))
    {
        while ((0 != remainingLength) && ('\\' != szOldFilepath[remainingLength]))
        {
            remainingLength-- ;
        }
    
        // Add the length of the temp directory path, and subtract the
        // path preceeding the filename ("path\filename" -> "\filename")
        // (\\server\sharename\path\morepath\filename
        newLength = oldLength - remainingLength + strlen(_CB.tempDirA) ;
    }
DC_EXIT_POINT:
    DC_END_FN() ;
    return (newLength + 1) * charSize ; // +1 is for the NULL terminator
}
#endif

//
// ClipGetNewDropfilesSize
// - Arguments:
//       pData    = Buffer containing a DROPFILES struct 
//       oldSize   = The size of the DROPFILES struct
//       fWide     = Wide or Ansi (TRUE if wide, FALSE if ansi)
// - Returns new size of the drop file
//           0 if it fails
// - Given a set of paths, this function will return the new
//   size required by the DROPFILES struct, if the UNC paths
//   are replaced by the temp directory path
//
ULONG CClip::ClipGetNewDropfilesSize(PVOID pData, ULONG oldSize, BOOL fWide)
{
    DC_BEGIN_FN("CClip::TS_GetNewDropfilesSize") ;
    if (fWide)
        return ClipGetNewDropfilesSizeW(pData, oldSize) ;
    else
        return ClipGetNewDropfilesSizeA(pData, oldSize) ;
    DC_END_FN() ;
}
ULONG CClip::ClipGetNewDropfilesSizeW(PVOID pData, ULONG oldSize)
{
    ULONG            newSize = oldSize ;
#ifndef OS_WINCE
    WCHAR*         filenameW ;
#endif
    WCHAR*         fullFilePathW ;
    byte             charSize ;

    DC_BEGIN_FN("CClip::TS_GetNewDropfilesSizeW") ;
    charSize = sizeof(WCHAR) ;
    if (!pData)
    {
        TRC_ERR((TB,_T("Pointer to dropfile is NULL"))) ;
        return 0 ;
    }

#ifdef OS_WINCE
    newSize = 0;
#endif
    // The start of the first filename
    fullFilePathW = (WCHAR*) ((byte*) pData + ((DROPFILES*) pData)->pFiles) ;
    
    while (L'\0' != fullFilePathW[0])
    {
#ifndef OS_WINCE
        // If it is a UNC path
        if (fullFilePathW[0] == L'\\' &&
            fullFilePathW[1] == L'\\')
        {
            filenameW = wcsrchr(fullFilePathW, L'\\');
        
            // Add the length of the temp directory path, and subtract the
            // path preceeding the filename ("path\filename" -> "\filename")
            // (\\server\sharename\path\morepath\filename
            newSize += (wcslen(_CB.tempDirW) - (filenameW - fullFilePathW) )
                            * charSize ;
        }
#else
        newSize++;
#endif
        fullFilePathW = fullFilePathW + (wcslen(fullFilePathW) + 1) ;
    }
    
#ifdef OS_WINCE
    newSize = oldSize + (newSize*sizeof(CEROOTDIRNAME)); //for the "Files:" (the sizeof operator includes space for the extra null)
#else
    // Add space for extra null character
    newSize += charSize ;
#endif
    DC_END_FN() ;
    return newSize ;
}

ULONG CClip::ClipGetNewDropfilesSizeA(PVOID pData, ULONG oldSize)
{
#ifndef OS_WINCE
    ULONG            newSize = oldSize ;
    char*            filename ;
    char*            fullFilePath ;
    byte             charSize ;

    DC_BEGIN_FN("CClip::TS_GetNewDropfilesSizeW") ;
    charSize = sizeof(char) ;
    if (!pData)
    {
        TRC_ERR((TB,_T("Pointer to dropfile is NULL"))) ;
        return 0 ;
    }

    // The start of the first filename
    fullFilePath = (char*) ((byte*) pData + ((DROPFILES*) pData)->pFiles) ;
    
    while ('\0' !=  fullFilePath[0])
    {
        // If it is a UNC path
        if (fullFilePath[0] == '\\' &&
            fullFilePath[1] == '\\')
        {
            filename = strrchr(fullFilePath, '\\');
        
            // Add the length of the temp directory path, and subtract
            // the path preceeding the filename itself, excluding the backlash
            // (\\server\sharename\path\morepath\filename
            newSize += (strlen(_CB.tempDirA) - (filename - fullFilePath) )
                            * charSize ;
        }
        fullFilePath = fullFilePath + (strlen(fullFilePath) + 1) ;
    }
    
    // Add space for extra null character
    newSize += charSize ;
    DC_END_FN() ;
    return newSize ;
#else
    DC_BEGIN_FN("CClip::TS_GetNewDropfilesSizeA") ;
    TRC_ASSERT((FALSE), (TB, _T("CE doesnt support ClipGetNewDropfilesSizeA")));
    DC_END_FN() ;
    return 0 ;
#endif
}


//
// ClipSetAndSendTempDirectory
// - Returns TRUE if temp directory was successfully set and sent
//           FALSE otherwise (no file redirection, or failed sending path)
// - Sets the Temp paths for the client, and sends the path
//   in wide characters to the Server
//

BOOL CClip::ClipSetAndSendTempDirectory(void)
{
    UINT wResult ;
    BOOL fSuccess ;
    PTS_CLIP_PDU pClipPDU ;
    DCINT32 pduLen ;
    HRESULT hr;
    
    DC_BEGIN_FN("CClip::ClipSetAndSendTempDirectory") ;
    // if we don't have drive redirection, then don't bother sending a path
    if (!_CB.fDrivesRedirected)
    {
        TRC_ALT((TB, _T("File redirection is off; don't set temp path."))) ;
        fSuccess = FALSE ;
        DC_QUIT ;
    }
    
#ifdef OS_WINCE
    if ((fSuccess = InitializeCeShell(_CB.viewerWindow)) == FALSE)
    {
        TRC_ALT((TB, _T("Failed to initialize ceshell. File copy through clipboard disabled."))) ;
        DC_QUIT ;
    }
#endif

#ifndef OS_WINCE    
    if (0 == GetTempPathA(MAX_PATH, _CB.baseTempDirA))
    {
        TRC_ERR((TB, _T("Failed getting path to temp directory."))) ;
        fSuccess = FALSE ;
        DC_QUIT ;
    }

    // Each session gets it own temp directory
    if (0 == GetTempFileNameA(_CB.baseTempDirA, "_TS", 0, _CB.tempDirA)) {
        TRC_ERR((TB, _T("Getting temp file name failed; GetLastError=%u"),
            GetLastError()));
        fSuccess = FALSE;
        DC_QUIT;
    }
    
    DeleteFileA(_CB.tempDirA) ;
    if (0 == CreateDirectoryA(_CB.tempDirA, NULL)) {
        TRC_ERR((TB, _T("Creating temp directory failed; GetLastError=%u"),
            GetLastError()));
        fSuccess = FALSE;
        DC_QUIT;                              
    }        

    hr = StringCbCopyA(_CB.baseTempDirA,
                        sizeof(_CB.baseTempDirA),
                       _CB.tempDirA);
    if (FAILED(hr)) {
        TRC_ERR((TB,_T("Failed to cpy tempdir to basetempdir: 0x%x"),hr));
        fSuccess = FALSE;
        DC_QUIT;
    }


    // We always send MAX_PATH*sizeof(WCHAR) byte for simplicity
    pduLen = MAX_PATH*sizeof(WCHAR) + sizeof(TS_CLIP_PDU);
    // GetACP always returns a valid value
    if (0 == MultiByteToWideChar(GetACP(), MB_ERR_INVALID_CHARS, 
            _CB.baseTempDirA, -1, _CB.baseTempDirW, 
            sizeof(_CB.baseTempDirW)/(sizeof(_CB.baseTempDirW[0])) - 1))
    {
        TRC_ERR((TB, _T("Failed conversion to wide char; error %d"),
                GetLastError())) ;
        fSuccess = FALSE ;
        DC_QUIT ;
    }
#else
    if (0 == GetTempPathW(MAX_PATH, _CB.baseTempDirW))
    {
        TRC_ERR((TB, _T("Failed getting path to temp directory."))) ;
        fSuccess = FALSE ;
        DC_QUIT ;
    }

    // Each session gets it own temp directory
    if (0 == GetTempFileNameW(_CB.baseTempDirW, L"_TS", 0, _CB.tempDirW, MAX_PATH-(sizeof(CEROOTDIRNAME)/sizeof(WCHAR)) ) {
        TRC_ERR((TB, _T("Getting temp file name failed; GetLastError=%u"),
            GetLastError()));
        fSuccess = FALSE;
        DC_QUIT;
    }
    
    DeleteFile(_CB.tempDirW) ;
    if (0 == CreateDirectory(_CB.tempDirW, NULL)) {
        TRC_ERR((TB, _T("Creating temp directory failed; GetLastError=%u"),
            GetLastError()));
        fSuccess = FALSE;
        DC_QUIT;                              
    }        

    wcscpy(_CB.baseTempDirW, _CB.tempDirW) ;
    pduLen = (MAX_PATH*sizeof(WCHAR)) + sizeof(TS_CLIP_PDU);
#endif

    pClipPDU = (PTS_CLIP_PDU) ClipAlloc(pduLen) ;
    if (!pClipPDU)
    {
        TRC_ERR((TB,_T("Unable to allocate %d bytes"), pduLen));
        fSuccess = FALSE;
        DC_QUIT;
    }
    
    // Fill in the PDU ; we send a packet of size MAX_PATH for simplicity
    DC_MEMSET(pClipPDU, 0, sizeof(TS_CLIP_PDU));
    pClipPDU->msgType = TS_CB_TEMP_DIRECTORY;
    pClipPDU->dataLen = MAX_PATH*sizeof(WCHAR) ;

    TRC_DBG((TB, _T("Copying all the data")));
#ifndef OS_WINCE
    ClipMemcpy(pClipPDU->data, _CB.baseTempDirW, pClipPDU->dataLen) ;
#else
    TSUINT8 *pData;
    int nDSize;

    pData = pClipPDU->data;
    nDSize = sizeof(CEROOTDIRNAME) - sizeof(WCHAR);
    ClipMemcpy(pData, CEROOTDIRNAME, nDSize) ;
    pData += nDSize;
    ClipMemcpy(pData, _CB.baseTempDirW, pClipPDU->dataLen - nDSize) ;
#endif
    
    TRC_NRM((TB, _T("Sending temp directory path.")));
    wResult = _CB.channelEP.pVirtualChannelWriteEx
            (_CB.initHandle, _CB.channelHandle, pClipPDU, pduLen, (LPVOID)pClipPDU);
    if (CHANNEL_RC_OK != wResult)
    {
        TRC_ERR((TB, _T("Failed sending temp directory 0x%08x"),
                GetLastError())) ;
        ClipFreeBuf((PDCUINT8)pClipPDU);
        fSuccess = FALSE ;
        DC_QUIT ;
    }
    fSuccess = TRUE ;
    
DC_EXIT_POINT:
    DC_END_FN() ;
    return fSuccess ;
}
/****************************************************************************/
/* ClipOnFormatList - we got a list of formats from the server              */
/****************************************************************************/
DCVOID DCINTERNAL CClip::ClipOnFormatList(PTS_CLIP_PDU pClipPDU)
{
    DCUINT16        response = TS_CB_RESPONSE_OK;
    DCUINT          numFormats;
    TS_CLIP_FORMAT UNALIGNED* fmtList;
    DCUINT          i;
    DCTCHAR         formatName[TS_FORMAT_NAME_LEN + 1] = { 0 };
    PTS_CLIP_PDU     pClipRsp;
#ifndef OS_WINCE
    DCBOOL          fSuccess;
    LPFORMATETC     pFormatEtc ;
#endif
    LPDATAOBJECT    pIDataObject = NULL ;
    HRESULT         hr ;    
    TS_CLIP_PDU UNALIGNED* pUlClipPDU = (TS_CLIP_PDU UNALIGNED*)pClipPDU;    
#ifdef OS_WINCE
    DCUINT          uRtf1 = 0xffffffff, uRtf2 = 0xffffffff;
#endif

    DC_BEGIN_FN("CClip::ClipOnFormatList");

    if (_pClipData == NULL) {
        TRC_ALT((TB, _T("The clipData is NULL, we just bail")));
        DC_QUIT;
    }

    /************************************************************************/
    /* Do state checks                                                      */
    /************************************************************************/
    CB_CHECK_STATE(CB_EVENT_FORMAT_LIST);
    if (_CB.state == CB_STATE_PENDING_FORMAT_LIST_RSP)
    {
        /********************************************************************/
        /* we've just sent a format list to the server.  We always win, so  */
        /* we just ignore this message.                                     */
        /********************************************************************/
        TRC_ALT((TB, _T("Format list race - we win so ignoring")));
        DC_QUIT;
    }

    /************************************************************************/
    /* Sanity check                                                         */
    /************************************************************************/
    if (_CB.clipOpen)
    {
        TRC_ALT((TB, _T("Clipboard is still open")));
    }
               
    /****************************************************************/
    /* empty the client/server mapping table                        */
    /****************************************************************/
    DC_MEMSET(_CB.idMap, 0, sizeof(_CB.idMap));

    /****************************************************************/
    /* work out how many formats we got                             */
    /****************************************************************/
    numFormats = (pUlClipPDU->dataLen) / sizeof(TS_CLIP_FORMAT);
    TRC_NRM((TB, _T("PDU contains %d formats"), numFormats));
    hr = _pClipData->SetNumFormats(numFormats) ;
    if (SUCCEEDED(hr)) {
        hr = _pClipData->QueryInterface(IID_IDataObject, (PPVOID) &pIDataObject) ;
    }
#ifdef OS_WINCE
    if (SUCCEEDED(hr))
    {
        if (OpenClipboard(_CB.dataWindow))
        {
            if (EmptyClipboard())
            {
                hr = S_OK;
            }
            else
            {
                CloseClipboard();
                hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WINDOWS, GetLastError());
                DC_QUIT;
            }
        }
        else
        {
            hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WINDOWS, GetLastError());
            DC_QUIT;
        }
    }
#endif
    if (SUCCEEDED(hr)) {
        TRC_ASSERT((numFormats <= CB_MAX_FORMATS),
                   (TB, _T("Format list contains more than %d formats"),
                       CB_MAX_FORMATS));
    
        /****************************************************************/
        /* and register them                                            */
        /****************************************************************/
        fmtList = (TS_CLIP_FORMAT UNALIGNED*)pUlClipPDU->data;
        for (i = 0; i < numFormats; i++)
        {
            TRC_DBG((TB, _T("format number %d, server id %d"),
                                  i, fmtList[i].formatID));
        
            //
            // If file copy and paste is disabled, we don't accept HDROPs.
            //

            if (fmtList[i].formatID == CF_HDROP && _CB.fFileCutCopyOn == FALSE) {
                continue;
            }
            
            /****************************************************************/
            /* If we got a name...                                          */
            /****************************************************************/
            if (fmtList[i].formatName[0] != 0)
            {
                /************************************************************/
                /* clear out any garbage                                    */
                /************************************************************/
#ifndef OS_WINCE
                DC_MEMSET(formatName, 0, TS_FORMAT_NAME_LEN);
#else
                DC_MEMSET(formatName, 0, sizeof(formatName));
#endif
                //
                // fmtList[i].formatName is not NULL terminated so explicity
                // do a byte count copy
                //
                StringCbCopy(formatName, TS_FORMAT_NAME_LEN + sizeof(TCHAR),
                              (PDCTCHAR)(fmtList[i].formatName));

                if (ClipIsExcludedFormat(formatName))
                {
                    TRC_NRM((TB, _T("Dropped format '%s'"), formatName));
                    continue;
                }
                /************************************************************/
                /* name is sorted                                           */
                /************************************************************/
                TRC_NRM((TB, _T("Got name '%s'"), formatName));

            }
            else
            {
                DC_MEMSET(formatName, 0, TS_FORMAT_NAME_LEN);
            }
            /****************************************************************/
            /* store the server id                                          */
            /****************************************************************/
            _CB.idMap[i].serverID = fmtList[i].formatID;
            TRC_NRM((TB, _T("server id %d"), _CB.idMap[i].serverID));

            /****************************************************************/
            /* get local name (if needed)                                   */
            /****************************************************************/
            if (formatName[0] != 0)
            {
#ifdef OS_WINCE
                //The protocol limits clipboard format names to 16 widechars. Thus it becomes impossible 
                //to distinguish between "Rich Text Format" and "Rich Text Format Without Objects"
                //This should be removed once the protocol is fixed in Longhorn
                if (0 == DC_TSTRNCMP(formatName, CFSTR_RTF, (sizeof(CFSTR_RTF)/sizeof(TCHAR)) - 1))
                {
                    if (uRtf1 == 0xffffffff)
                        uRtf1 = i;
                    else
                        uRtf2 = i;
                    continue;
                }
                else
#endif
                _CB.idMap[i].clientID = RegisterClipboardFormat(formatName);
            }
            else
            {
                /************************************************************/
                /* it's a predefined format so we can just use the ID       */
                /************************************************************/
                _CB.idMap[i].clientID = _CB.idMap[i].serverID;
            }
#ifdef OS_WINCE
            if (_CB.idMap[i].serverID == CF_HDROP)  
				_CB.idMap[i].clientID = gfmtShellPidlArray;
#endif

            /************************************************************/
            /* and add the format to the local CB                       */
            /************************************************************/
            TRC_DBG((TB, _T("Adding format '%s', server ID %d, client ID %d"),
                         fmtList[i].formatName,
                         _CB.idMap[i].serverID,
                         _CB.idMap[i].clientID));
    

            if (0 != _CB.idMap[i].clientID) {
#ifndef OS_WINCE
                pFormatEtc = new FORMATETC ;

                if (pFormatEtc) {

                    pFormatEtc->cfFormat = (CLIPFORMAT) _CB.idMap[i].clientID ;
                    pFormatEtc->dwAspect = DVASPECT_CONTENT ;
                    pFormatEtc->ptd = NULL ;
                    pFormatEtc->lindex = -1 ;
                    pFormatEtc->tymed = TYMED_HGLOBAL ;
                
                    // Need to set the clipboard state before SetData.
                    CB_SET_STATE(CB_STATE_LOCAL_CB_OWNER, CB_EVENT_FORMAT_LIST);
                    pIDataObject->SetData(pFormatEtc, NULL, TRUE) ;
                    delete pFormatEtc;
                }

#else
                CB_SET_STATE(CB_STATE_LOCAL_CB_OWNER, CB_EVENT_FORMAT_LIST);
                SetClipboardData((CLIPFORMAT) _CB.idMap[i].clientID, NULL);
#endif
            }
            else
                TRC_NRM((TB,_T("Invalid format dropped"))) ;                
        }
#ifdef OS_WINCE
        //we will choose the lower format id as belonging to "Rich Text Format"
        //This is our best guess and it seems to work
        ClipFixupRichTextFormats(uRtf1, uRtf2);
#endif

#ifndef OS_WINCE
        hr =  OleSetClipboard(pIDataObject) ;
#else
        EnterCriticalSection(&gcsDataObj);
        
        if (gpDataObj)
            gpDataObj->Release();
        pIDataObject->AddRef();
        gpDataObj = pIDataObject;

        LeaveCriticalSection(&gcsDataObj);
        hr = S_OK;
        CloseClipboard(); 
#endif
        if (pIDataObject)
            pIDataObject->Release();            
        if (SUCCEEDED(hr))
        {
            response = TS_CB_RESPONSE_OK;
            _CB.clipOpen = FALSE ;
        }
        else
        {
            TRC_ERR((TB, _T("OleSetClipboard failed, error = 0x%08x"), hr)) ;
            response = TS_CB_RESPONSE_FAIL;
            _CB.clipOpen = FALSE ;
        }
    }
    else
    {
        if (pIDataObject)
            pIDataObject->Release();            
        TRC_ERR((TB, _T("Error getting pointer to an IDataObject"))) ;
        pIDataObject = NULL ;
        response = TS_CB_RESPONSE_FAIL ;
    }

    /************************************************************************/
    /* Now build the response                                               */
    /************************************************************************/
    TRC_NRM((TB, _T("Get perm TX buffer")));
    pClipRsp = ClipGetPermBuf();

    /************************************************************************/
    /* and now the specific bits                                            */
    /************************************************************************/
    pClipRsp->msgType  = TS_CB_FORMAT_LIST_RESPONSE;
    pClipRsp->msgFlags = response;
    pClipRsp->dataLen  = 0;

    /************************************************************************/
    /* finally we send it                                                   */
    /************************************************************************/
    if (_CB.channelEP.pVirtualChannelWriteEx
          (_CB.initHandle, _CB.channelHandle, pClipRsp, sizeof(TS_CLIP_PDU), (LPVOID)pClipRsp)
          != CHANNEL_RC_OK)
    {
        TRC_ERR((TB, _T("Failed VC write: setting clip data to NULL")));
        ClipFreeBuf((PDCUINT8)pClipRsp);
        response = TS_CB_RESPONSE_FAIL ;
    }
    /************************************************************************/
    /* Update the state according to how we got on                          */
    /************************************************************************/
    if (response == TS_CB_RESPONSE_OK)
    {
        CB_SET_STATE(CB_STATE_LOCAL_CB_OWNER, CB_EVENT_FORMAT_LIST);
    }
    else
    {
        CB_SET_STATE(CB_STATE_ENABLED, CB_EVENT_FORMAT_LIST);
    }
DC_EXIT_POINT:
    
    DC_END_FN();
    return;
} /* ClipOnFormatList */


/****************************************************************************/
/* ClipOnFormatListResponse - got the format list response                  */
/****************************************************************************/
DCVOID DCINTERNAL CClip::ClipOnFormatListResponse(PTS_CLIP_PDU pClipPDU)
{
    DC_BEGIN_FN("CClip::ClipOnFormatListResponse");

    CB_CHECK_STATE(CB_EVENT_FORMAT_LIST_RSP);

    /************************************************************************/
    /* if the response is OK...                                             */
    /************************************************************************/
    if (pClipPDU->msgFlags & TS_CB_RESPONSE_OK)
    {
        /********************************************************************/
        /* we are now the shared CB owner                                   */
        /********************************************************************/
        TRC_NRM((TB, _T("Got OK fmt list rsp")));
        CB_SET_STATE(CB_STATE_SHARED_CB_OWNER, CB_EVENT_FORMAT_LIST_RSP);
    }
    else
    {
        /********************************************************************/
        /* nothing specific to do                                           */
        /********************************************************************/
        TRC_ALT((TB, _T("Got fmt list rsp failed")));
        CB_SET_STATE(CB_STATE_ENABLED, CB_EVENT_FORMAT_LIST_RSP);
    }

    /************************************************************************/
    /* There may have been another update while we were waiting - deal with */
    /* it by faking an update here                                          */
    /************************************************************************/
    if (_CB.moreToDo == TRUE)
    {
        TRC_ALT((TB, _T("More to do on list rsp")));
        _CB.moreToDo = FALSE;
        ClipDrawClipboard(FALSE);
    }

DC_EXIT_POINT:
    DC_END_FN();
    return;
} /* ClipOnFormatListResponse */


/****************************************************************************/
// ClipOnFormatRequest
// - Server wants a format
/****************************************************************************/
DCVOID DCINTERNAL CClip::ClipOnFormatRequest(PTS_CLIP_PDU pClipPDU)
{
    DCUINT32         formatID;
    DCUINT32         dataLen = 0;
    DCUINT           numEntries;
    DCUINT16         dwEntries;

    HANDLE           hData    = NULL;
    HANDLE           hNewData = NULL;
    HPDCVOID         pData    = NULL;
    DROPFILES*       pDropFiles ;
#ifndef OS_WINCE
    DROPFILES        tempDropfile ;
#endif
    HPDCVOID         pNewData    = NULL;
    DCUINT16         response = TS_CB_RESPONSE_OK;
    PTS_CLIP_PDU     pClipRsp = NULL;
    PTS_CLIP_PDU     pClipNew;
    DCUINT32         pduLen;
    BOOL             fDrivePath ;
    BOOL             fWide ;
    byte             charSize ;
    ULONG            newSize, oldSize ;
    HPDCVOID         pOldFilename ;    
    HPDCVOID         pFileList = NULL ;
    HPDCVOID         pTmpFileList = NULL;
    HPDCVOID         pFilename = NULL ;
#ifndef OS_WINCE
    char*            fileList ;
    WCHAR*           fileListW ;
    SHFILEOPSTRUCTA  fileOpStructA ;
    SHFILEOPSTRUCTW  fileOpStructW ;
    HRESULT          result ;
    DCTCHAR          formatName[TS_FORMAT_NAME_LEN] ;
#endif
    HRESULT          hr;

    DC_BEGIN_FN("CClip::ClipOnFormatRequest");

    //
    // Set the response to failure before making the state check
    //
    response = TS_CB_RESPONSE_FAIL;
    CB_CHECK_STATE(CB_EVENT_FORMAT_DATA_RQ);
    response = TS_CB_RESPONSE_OK;

    /************************************************************************/
    /* Make sure the local CB is open                                       */
    /************************************************************************/
    if ((_CB.rcvOpen) || OpenClipboard(_CB.viewerWindow))
    {
        /********************************************************************/
        /* It was/is open                                                   */
        /********************************************************************/
        TRC_NRM((TB, _T("CB opened")));
        _CB.rcvOpen = TRUE;

        /********************************************************************/
        /* Extract the format from the PDU                                  */
        /********************************************************************/
        TRC_DATA_DBG("pdu data", pClipPDU->data, (DCUINT)pClipPDU->dataLen);

        //
        // Verify that we have enough data to extract a format ID.
        //

        if (pClipPDU->dataLen < sizeof(DCUINT32)) {
            TRC_ERR((TB,_T("Not enough data to extract a format ID.")));
            _CB.channelEP.pVirtualChannelCloseEx(_CB.initHandle, _CB.channelHandle);
            response = TS_CB_RESPONSE_FAIL;
            dataLen = 0;
            DC_QUIT ;
        }
        
        formatID = *((PDCUINT32_UA)pClipPDU->data);
        TRC_NRM((TB, _T("Requesting format %ld"), formatID));

        /********************************************************************/
        /* If the Server asked for CF_DIB, we may have to translate from    */
        /* CF_BITMAP                                                        */
        /********************************************************************/
        if ((formatID == CF_DIB) && (!_CB.DIBFormatExists))
        {
            TRC_NRM((TB, _T("Server asked for CF_DIB - get CF_BITMAP")));
            formatID = CF_BITMAP;
        }

        /********************************************************************/
        /* Get a handle to the data                                         */
        /********************************************************************/
#ifdef OS_WINCE
        if (formatID == CF_HDROP)
            formatID = gfmtShellPidlArray;
#endif
        hData = GetClipboardData((UINT)formatID);
        TRC_DBG((TB, _T("Got format %ld at %p"), formatID, hData));
        if (hData == NULL)
        {
            /****************************************************************/
            /* Oops!                                                        */
            /****************************************************************/
            TRC_ERR((TB, _T("Failed to get format %ld"), formatID));
            response = TS_CB_RESPONSE_FAIL;
            dataLen  = 0;
            DC_QUIT ;
        }
        else
        {
            /****************************************************************/
            /* Got handle, now what happens next depends on the flavour of  */
            /* data we're looking at...                                     */
            /****************************************************************/
            if (formatID == CF_PALETTE)
            {
                TRC_DBG((TB, _T("CF_PALETTE requested")));
                /************************************************************/
                /* Find out how many entries there are in the palette and   */
                /* allocate enough memory to hold them all.                 */
                /************************************************************/
                if (GetObject(hData, sizeof(DCUINT16), &dwEntries) == 0)
                {
                    TRC_DBG((TB, _T("Failed to get count of palette entries")));
                    dwEntries = 256;
                }
                numEntries = (DCUINT)dwEntries;
                TRC_DBG((TB, _T("Need mem for %u palette entries"), numEntries));

                dataLen = sizeof(LOGPALETTE) - sizeof(PALETTEENTRY) +
                                          (numEntries * sizeof(PALETTEENTRY));

                hNewData = GlobalAlloc(GHND, dataLen);
                if (hNewData == 0)
                {
                    TRC_ERR((TB, _T("Failed to get %ld bytes for palette"),
                            dataLen));
                    response = TS_CB_RESPONSE_FAIL;
                    dataLen  = 0;
                    DC_QUIT ;
                }
                else
                {
                    /********************************************************/
                    /* now get the palette entries into the new buffer      */
                    /********************************************************/
                    pData = (HPDCUINT8)GlobalLock(hNewData);
                    if (NULL == pData) {
                        TRC_ERR((TB,_T("Failed to lock palette entries")));
                        response = TS_CB_RESPONSE_FAIL;
                        dataLen = 0;
                        DC_QUIT;
                    }
                    
                    numEntries = GetPaletteEntries((HPALETTE)hData,
                                                   0,
                                                   numEntries,
                                                   (PALETTEENTRY*)pData);
                    TRC_DATA_DBG("Palette entries", pData, (DCUINT)dataLen);
                    GlobalUnlock(hNewData);
                    TRC_DBG((TB, _T("Got %u palette entries"), numEntries));
                    if (numEntries == 0)
                    {
                        TRC_ERR((TB, _T("Failed to get any palette entries")));
                        response = TS_CB_RESPONSE_FAIL;
                        dataLen  = 0;
                        DC_QUIT ;
                    }
                    dataLen = numEntries * sizeof(PALETTEENTRY);

                    /********************************************************/
                    /* all ok - set up hData to point to the new data       */
                    /********************************************************/
                    hData = hNewData;
                }

            }
#ifndef OS_WINCE
            else if (formatID == CF_METAFILEPICT)
            {
                TRC_NRM((TB, _T("Metafile data to get")));
                hNewData = ClipGetMFData(hData, &dataLen);
                if (!hNewData)
                {
                    TRC_ERR((TB, _T("Failed to set MF data")));
                    response = TS_CB_RESPONSE_FAIL;
                    dataLen  = 0;
                    DC_QUIT ;
                }
                else
                {
                    /********************************************************/
                    /* all ok - set up hData to point to the new data       */
                    /********************************************************/
                    hData = hNewData;
                }
            }
#endif
            else if (formatID == CF_BITMAP)
            {
                /************************************************************/
                /* We've gt CF_BITMAP data.  This will be because the       */
                /* Server has asked for CF_DIB data - we never send         */
                /* CF_BITMAP to the Server.  Convert it to CF_DIB format.   */
                /************************************************************/
                TRC_NRM((TB, _T("Convert CF_BITMAP to CF_DIB")));
                hNewData = ClipBitmapToDIB(hData, &dataLen);
                if (hNewData)
                {
                    hData = hNewData;
                }
                else
                {
                    response = TS_CB_RESPONSE_FAIL;
                    dataLen = 0;
                    DC_QUIT ;
                }

            }
            // Since we won't even send an HDROP format to the server if the
            // local drives are redirected, and we always send a new formatlist
            // when we reconnect to a server, this does not have to be touched
#ifndef OS_WINCE
            else if (formatID == CF_HDROP)
#else
            else if (formatID == gfmtShellPidlArray)
#endif
            {
                SIZE_T cbDropFiles;
                BYTE *pbLastByte, *pbStartByte, *pbLastPossibleNullStart;
                BOOL fTrailingFileNamesValid;
                ULONG cbRemaining;

                TRC_NRM((TB,_T("HDROP requested"))) ;
#ifdef OS_WINCE
                HANDLE hPidlArray = IDListToHDrop(hData);
                if (!hPidlArray)
                {
                    TRC_ERR((TB,_T("Failed to get file list from clipboard"))) ;
                    response = TS_CB_RESPONSE_FAIL;
                    dataLen = 0;
                    DC_QUIT ;
                }
                hData = hPidlArray;
#endif
                
                //
                // Make sure that we have at least a DROPFILES structure in
                // memory. 

                cbDropFiles = GlobalSize(hData);
                if (cbDropFiles < sizeof(DROPFILES)) {
                    TRC_ERR((TB,_T("Unexpected global memory size!"))) ;
                    _CB.channelEP.pVirtualChannelCloseEx(_CB.initHandle, _CB.channelHandle);
                    response = TS_CB_RESPONSE_FAIL;
                    dataLen = 0;
                    DC_QUIT ;
                }
                
                pDropFiles = (DROPFILES*) GlobalLock(hData) ;
                if (!pDropFiles)
                {
                    TRC_ERR((TB,_T("Failed to lock %p"), hData)) ;
                    response = TS_CB_RESPONSE_FAIL;
                    dataLen = 0;
                    DC_QUIT ;

                }
                fWide = ((DROPFILES*) pDropFiles)->fWide ;
                charSize = fWide ? sizeof(WCHAR) : sizeof(char) ;

                //
                // Check that the data behind the DROPFILES data structure
                // pointed to by pDropFiles is valid. Every drop file list
                // is terminated by two NULL characters. So, simply scan 
                // through the memory after the DROPFILES structure and make 
                // sure that there is a double NULL before the last byte.
                //

                if (pDropFiles->pFiles < sizeof(DROPFILES) 
                    || pDropFiles->pFiles > cbDropFiles) {
                    TRC_ERR((TB,_T("File name offset invalid!"))) ;
                    _CB.channelEP.pVirtualChannelCloseEx(_CB.initHandle, _CB.channelHandle);
                    response = TS_CB_RESPONSE_FAIL;
                    dataLen = 0;
                    DC_QUIT ;
                }

                pbStartByte = (BYTE*) pDropFiles + pDropFiles->pFiles;
                pbLastByte = (BYTE*) pDropFiles + cbDropFiles - 1;
                fTrailingFileNamesValid = FALSE;

                //
                // Make pbLastPossibleNullStart point to the last place where a 
                // double NULL could possibly start.
                //
                // Examples: Assume pbLastByte = 9
                // Then for ASCII: pbLastPossibleNullStart = 8 (9 - 2 * 1 + 1)
                // And for UNICODE: pbLastPossibleNullStart = 6 (9 - 2 * 2 + 1)
                // 

                pbLastPossibleNullStart = pbLastByte - (2 * charSize) + 1;
                
                if (fWide) {
                    for (WCHAR* pwch = (WCHAR*) pbStartByte; (BYTE*) pwch <= pbLastPossibleNullStart; pwch++) {
                        if (*pwch == NULL && *(pwch + 1) == NULL) {
                            fTrailingFileNamesValid = TRUE;
                        }
                    }
                } else {
                    for (BYTE* pch = pbStartByte; pch <= pbLastPossibleNullStart; pch++) {
                        if (*pch == NULL && *(pch + 1) == NULL) {
                            fTrailingFileNamesValid = TRUE;
                        }
                    }
                }

                if (!fTrailingFileNamesValid) {
                    TRC_ERR((TB,_T("DROPFILES structure invalid!"))) ;
                    _CB.channelEP.pVirtualChannelCloseEx(_CB.initHandle, _CB.channelHandle);
                    response = TS_CB_RESPONSE_FAIL;
                    dataLen = 0;
                    DC_QUIT;
                }

                //
                // DROPFILES are valid so we can continue.
                //

                if (!_CB.fAlreadyCopied)
                {
                    // if it's not a drive path, then copy to a temp directory
                    pFileList = (byte*)pDropFiles + pDropFiles->pFiles ;
#ifndef OS_WINCE
                    fDrivePath =  fWide ? (0 != wcschr((WCHAR*) pFileList, L':'))
                                       : (0 != strchr((char*) pFileList, ':')) ;
#else				//copy to temp dir if it is a network path
                    fDrivePath = fWide ? (! ( (((WCHAR *)pFileList)[0] == L'\\') && (((WCHAR *)pFileList)[1] == L'\\')) ) 
                        : (! ( (((CHAR *)pFileList)[0] == '\\') && (((CHAR *)pFileList)[1] == '\\')) ) ;
#endif
                    if (!fDrivePath)
                    {
                        // ClipCopyToTempDirectory returns 0 if successful
                        if (0 != ClipCopyToTempDirectory(pFileList, fWide))
                        {
                            TRC_ERR((TB,_T("Copy to tmp directory failed"))) ;
                            response = TS_CB_RESPONSE_FAIL;
                            dataLen  = 0;
                            _CB.fAlreadyCopied = TRUE ;
                            DC_QUIT ;
                        }
                    }
                    _CB.fAlreadyCopied = TRUE ;
                }

                // Now that we copied the files, we want to convert the file
                // paths to something the server will understand

                // Allocate space for new filepaths
                oldSize = (ULONG) GlobalSize(hData) ;
                newSize = ClipGetNewDropfilesSize(pDropFiles, oldSize, fWide) ;
                hNewData = GlobalAlloc(GMEM_DISCARDABLE | GMEM_MOVEABLE, newSize) ;
                if (!hNewData)
                {
                    TRC_ERR((TB, _T("Failed to get %ld bytes for HDROP"),
                            newSize));
                    response = TS_CB_RESPONSE_FAIL;
                    dataLen  = 0;
                    DC_QUIT ;
                }
                pNewData = GlobalLock(hNewData) ;
                if (!pNewData)
                {
                    TRC_ERR((TB, _T("Failed to get lock %p for HDROP"),
                            hNewData));
                    response = TS_CB_RESPONSE_FAIL;
                    dataLen  = 0;
                    DC_QUIT ;
                }
                // Just copy the old DROPFILES data members (unchanged)
                ((DROPFILES*) pNewData)->pFiles = pDropFiles->pFiles ;
                ((DROPFILES*) pNewData)->pt     = pDropFiles->pt ;
                ((DROPFILES*) pNewData)->fNC    = pDropFiles->fNC ;
                ((DROPFILES*) pNewData)->fWide  = pDropFiles->fWide ;

                // The first filename in a DROPFILES data structure begins
                // DROPFILES.pFiles bytes away from the head of the DROPFILES
                pOldFilename = (byte*) pDropFiles + ((DROPFILES*) pDropFiles)->pFiles ;
                pFilename = (byte*) pNewData + ((DROPFILES*) pNewData)->pFiles ;        
                
                pbLastByte = (BYTE*) pNewData + newSize - 1;
                cbRemaining = (ULONG) (pbLastByte - (BYTE*) pFilename + 1);
                
                while (fWide ? (L'\0' != ((WCHAR*) pOldFilename)[0]) : ('\0' != ((char*) pOldFilename)[0]))
                {
                    if (FAILED(ClipConvertToTempPath(pOldFilename, pFilename, cbRemaining, fWide)))
                    {
                        TRC_ERR((TB, _T("Failed conversion"))) ;
                        response = TS_CB_RESPONSE_FAIL;
                        dataLen = 0 ;
                        DC_QUIT ;
                    }
                    if (fWide)
                    {
                        pOldFilename = (byte*) pOldFilename + (wcslen((WCHAR*)pOldFilename) + 1) * sizeof(WCHAR) ;
                        pFilename = (byte*) pFilename + (wcslen((WCHAR*)pFilename) + 1) * sizeof(WCHAR) ;                
                    }
                    else
                    {
                        pOldFilename = (byte*) pOldFilename + (strlen((char*)pOldFilename) + 1) * sizeof(char) ;
                        pFilename = (byte*) pFilename + (strlen((char*)pFilename) + 1) * sizeof(char) ;
                    }                        
                    cbRemaining = (ULONG) (pbLastByte - (BYTE*) pFilename + 1);
                }
                if (fWide)
                {
                    ((WCHAR*) pFilename)[0] = L'\0' ;
                }
                else
                {
                    ((char*) pFilename)[0] = '\0' ;
                }
                GlobalUnlock(hNewData) ;
                hData = hNewData ;
                response = TS_CB_RESPONSE_OK ;
                dataLen = (ULONG) GlobalSize(hData) ;
#ifdef OS_WINCE
                GlobalFree(hPidlArray);
#endif
            }
            else
            {
#ifndef OS_WINCE
                // Check to see if we are processing the FileName/FileNameW
                // OLE 1 formats; if so, we convert th
                if (0 != GetClipboardFormatName(formatID, formatName, TS_FORMAT_NAME_LEN))
                {
                    if ((0 == _tcscmp(formatName, TEXT("FileName"))) ||
                        (0 == _tcscmp(formatName, TEXT("FileNameW"))))
                    {
                        size_t cbOldFileName;

                        if (!_tcscmp(formatName, TEXT("FileNameW")))
                        {
                           fWide = TRUE ;
                           charSize = sizeof(WCHAR) ;
                        }
                        else
                        {
                           fWide = FALSE ;
                           charSize = 1 ;
                        }
                        
                        //
                        // Extract the file name, but ensure that it is properly
                        // NULL terminated.
                        //
                        
                        pOldFilename = GlobalLock(hData);

                        if (!pOldFilename)
                        {
                            TRC_ERR((TB, _T("No filename/Unable to lock %p"),
                                    hData));
                            response = TS_CB_RESPONSE_FAIL;
                            dataLen = 0;
                            DC_QUIT ;
                        }

                        oldSize = (ULONG) GlobalSize(hData) ;
                        
                        if (fWide) {
                            hr = StringCbLengthW((WCHAR*) pOldFilename, 
                                                 oldSize, 
                                                 &cbOldFileName);
                        } else {
                            hr = StringCbLengthA((CHAR*) pOldFilename, 
                                                 oldSize, 
                                                 &cbOldFileName);
                        }
                        
                        if (FAILED(hr)) {
                            TRC_ERR((TB, _T("File name not NULL terminated!")));
                            _CB.channelEP.pVirtualChannelCloseEx(_CB.initHandle, _CB.channelHandle);
                            response = TS_CB_RESPONSE_FAIL;
                            dataLen = 0;
                            DC_QUIT ;
                        }
                        
                        if (!_CB.fAlreadyCopied)
                        {
                            // if its not a drive path, then copy to a temp
                            // directory.  We have to copy over the filename to
                            // string that is one character larger, because we
                            // need to add an extra NULL for the SHFileOperation
                            UINT cbSize=  oldSize + charSize;
                            pTmpFileList = LocalAlloc(LPTR, cbSize);
                            if (NULL == pTmpFileList) {
                                TRC_ERR((TB,_T("pTmpFileList alloc failed")));
                                response = TS_CB_RESPONSE_FAIL;
                                dataLen  = 0;
                                _CB.fAlreadyCopied = TRUE;
                                DC_QUIT ;
                            }
                            if (fWide)
                            {
                                hr = StringCbCopyW((WCHAR*)pTmpFileList, cbSize,
                                                   (WCHAR*)pOldFilename) ;
                                fDrivePath = (0 != wcschr((WCHAR*) pTmpFileList, L':')) ;
                            }
                            else
                            {
                                hr = StringCbCopyA((char*)pTmpFileList, cbSize,
                                                   (char*)pOldFilename) ;
                                fDrivePath = (0 != strchr((char*) pTmpFileList, ':')) ;
                            }
                            
                            if (FAILED(hr)) {
                                TRC_ERR((TB,_T("Failed to cpy filelist string: 0x%x"),hr));
                                response = TS_CB_RESPONSE_FAIL;
                                dataLen  = 0;
                                _CB.fAlreadyCopied = TRUE;
                                DC_QUIT ;
                            }
               
                            if (fDrivePath)
                            {
                                // ClipCopyToTempDirectory returns 0 if successful
                                if (0 != ClipCopyToTempDirectory(pTmpFileList, fWide))
                                {
                                    TRC_ERR((TB,_T("Copy to tmp directory failed"))) ;
                                    response = TS_CB_RESPONSE_FAIL;
                                    dataLen  = 0;
                                    _CB.fAlreadyCopied = TRUE ;
                                    DC_QUIT ;
                                }
                            }
                            _CB.fAlreadyCopied = TRUE ;
                            LocalFree(pTmpFileList);
                            pTmpFileList = NULL;
                        }
                        newSize = ClipGetNewFilePathLength(pOldFilename, fWide) ;
                        hNewData = GlobalAlloc(GMEM_DISCARDABLE | GMEM_MOVEABLE, newSize) ;
                        if (!hNewData)
                        {
                            TRC_ERR((TB, _T("Failed to get %ld bytes for HDROP"),
                                    newSize));
                            response = TS_CB_RESPONSE_FAIL;
                            dataLen  = 0;
                            DC_QUIT ;
                        }
                        pFilename = GlobalLock(hNewData) ;
                        if (!pFilename)
                        {
                            TRC_ERR((TB, _T("Failed to get lock %p for HDROP"),
                                    hNewData));
                            response = TS_CB_RESPONSE_FAIL;
                            dataLen  = 0;
                            DC_QUIT ;
                        }
                        if (FAILED(ClipConvertToTempPath(pOldFilename, pFilename, newSize, fWide)))
                        {
                            TRC_ERR((TB, _T("Failed conversion"))) ;
                            response = TS_CB_RESPONSE_FAIL;
                            dataLen  = 0;                            
                            DC_QUIT ;
                        }
                        GlobalUnlock(hNewData) ;
                        hData = hNewData ;
                        response = TS_CB_RESPONSE_OK ;
                        dataLen = newSize ;
                        DC_QUIT ;
                    }
                }
#endif
                /************************************************************/
                /* just get the length of the block                         */
                /************************************************************/
                dataLen = (DCUINT32)GlobalSize(hData);
                TRC_DBG((TB, _T("Got data len %ld"), dataLen));
            }
        }
    }
    else
    {
        /********************************************************************/
        /* Failed to open CB - send a failure response                      */
        /********************************************************************/
        TRC_ERR((TB, _T("Failed to open CB")));
        response = TS_CB_RESPONSE_FAIL;
        dataLen = 0;
        DC_QUIT ;
    }

DC_EXIT_POINT:

    /************************************************************************/
    /* By default, we'll use the permanent send buffer                      */
    /************************************************************************/
    TRC_NRM((TB, _T("Get perm TX buffer")));

    pduLen = dataLen + sizeof(TS_CLIP_PDU);
    pClipNew = (PTS_CLIP_PDU)ClipAlloc(pduLen);

    if (pClipNew != NULL)
    {
        /****************************************************************/
        /* Use the new buffer                                           */
        /****************************************************************/
        TRC_NRM((TB, _T("Free perm TX buffer")));
        pClipRsp = pClipNew;
    }
    else
    {
        /****************************************************************/
        /* Fail the request                                             */
        /****************************************************************/
        TRC_ERR((TB, _T("Failed to alloc %ld bytes"), pduLen));
        pClipRsp = ClipGetPermBuf();
        response = TS_CB_RESPONSE_FAIL;
        dataLen = 0;
        pduLen  = sizeof(TS_CLIP_PDU);
    }

    DC_MEMSET(pClipRsp, 0, sizeof(*pClipRsp));
    pClipRsp->msgType  = TS_CB_FORMAT_DATA_RESPONSE;
    pClipRsp->msgFlags = response;
    pClipRsp->dataLen = dataLen;

    if (pTmpFileList) {
        LocalFree(pTmpFileList);
        pTmpFileList = NULL;
    }
    

    // Copy data, if any
    if (dataLen != 0)
    {
        TRC_DBG((TB, _T("Copying all the data")));
        pData = (HPDCUINT8)GlobalLock(hData);
        if (NULL != pData) {       
            ClipMemcpy(pClipRsp->data, pData, dataLen);
            GlobalUnlock(hData);
        }
        else {
            TRC_ERR(( TB, _T("Failed to lock data")));
            pClipRsp->msgFlags = TS_CB_RESPONSE_FAIL;
            pClipRsp->dataLen = 0;            
            pduLen  = sizeof(TS_CLIP_PDU);            
        }
    }

    // Send the PDU
    TRC_NRM((TB, _T("Sending format data rsp")));
    if (_CB.channelEP.pVirtualChannelWriteEx
            (_CB.initHandle, _CB.channelHandle, (LPVOID)pClipRsp, pduLen, pClipRsp) 
            != CHANNEL_RC_OK)
    {
        ClipFreeBuf((PDCUINT8)pClipRsp);
    }

    // close the clipboard if we need to
    if (_CB.rcvOpen)
    {
        TRC_DBG((TB, _T("Closing CB")));
        _CB.rcvOpen = FALSE;
        if (!CloseClipboard())
        {
            TRC_SYSTEM_ERROR("CloseClipboard");
        }
    }
    
    // if we got any new data, we need to free it
    if (hNewData)
    {
        TRC_DBG((TB, _T("Freeing new data")));
        GlobalFree(hNewData);
    }

    DC_END_FN();
    return;
} /* ClipOnFormatRequest */

/****************************************************************************/
// ClipOnFormatDataComplete
// - Server response to our request for data
/****************************************************************************/ 
DCVOID DCINTERNAL CClip::ClipOnFormatDataComplete(PTS_CLIP_PDU pClipPDU)
{
    HANDLE          hData = NULL;
    HPDCVOID        pData;
    LOGPALETTE    * pLogPalette = NULL;
    DCUINT32        numEntries;
    DCUINT32        memLen;
#ifndef OS_WINCE

    HRESULT       hr ;
#endif

    DC_BEGIN_FN("CClip::ClipOnFormatDataComplete");

    /************************************************************************/
    /* check the response                                                   */
    /************************************************************************/
    if (_pClipData == NULL) {
        TRC_ALT((TB, _T("The clipData is NULL, we just bail")));
        DC_QUIT;
    }

    if (!(pClipPDU->msgFlags & TS_CB_RESPONSE_OK))
    {
        TRC_ALT((TB, _T("Got fmt data rsp failed for %d"), _CB.pendingClientID));
        DC_QUIT;
    }

    /************************************************************************/
    /* Got the data                                                         */
    /************************************************************************/
    TRC_NRM((TB, _T("Got OK fmt data rsp for %d"), _CB.pendingClientID));

#ifndef OS_WINCE
    /************************************************************************/
    /* For some formats we still need to do some work                       */
    /************************************************************************/
    if (_CB.pendingClientID == CF_METAFILEPICT)
    {
        /********************************************************************/
        /* Metafile format - create a metafile from the data                */
        /********************************************************************/
        TRC_NRM((TB, _T("Rx data is for metafile")));
        hData = ClipSetMFData(pClipPDU->dataLen, pClipPDU->data);
        if (hData == NULL)
        {
            TRC_ERR((TB, _T("Failed to set MF data")));
        }
    }
    else 
#endif
        if (_CB.pendingClientID == CF_PALETTE)
    {
        /********************************************************************/
        /* Palette format - create a palette from the data                  */
        /********************************************************************/

        /********************************************************************/
        /* Allocate memory for a LOGPALETTE structure large enough to hold  */
        /* all the PALETTE ENTRY structures, and fill it in.                */
        /********************************************************************/
        TRC_NRM((TB, _T("Rx data is for palette")));
        numEntries = (pClipPDU->dataLen / sizeof(PALETTEENTRY));
        memLen     = (sizeof(LOGPALETTE) +
                                   ((numEntries - 1) * sizeof(PALETTEENTRY)));
        TRC_DBG((TB, _T("%ld palette entries, allocate %ld bytes"),
                                                         numEntries, memLen));
        pLogPalette = (LOGPALETTE*)ClipAlloc(memLen);
        if (pLogPalette != NULL)
        {
            pLogPalette->palVersion    = 0x300;
            pLogPalette->palNumEntries = (WORD)numEntries;

            ClipMemcpy(pLogPalette->palPalEntry,
                       pClipPDU->data,
                       pClipPDU->dataLen);

            /****************************************************************/
            /* now create a palette                                         */
            /****************************************************************/
            hData = CreatePalette(pLogPalette);
            if (hData == NULL)
            {
                TRC_SYSTEM_ERROR("CreatePalette");
            }
        }
        else
        {
            TRC_ERR((TB, _T("Failed to get %ld bytes"), memLen));
        }
    }
    else
    {
        TRC_NRM((TB, _T("Rx data can just go on CB")));
        /********************************************************************/
        /* We need to copy the data, as the receive buffer will be freed on */
        /* return from this function.                                       */
        /********************************************************************/
        hData = GlobalAlloc(GMEM_DISCARDABLE | GMEM_MOVEABLE,
                            pClipPDU->dataLen);
        if (hData != NULL)
        {
            pData = GlobalLock(hData);
            if (pData != NULL)
            {
                TRC_NRM((TB, _T("Copy %ld bytes from %p to %p"),
                        pClipPDU->dataLen, pClipPDU->data, pData));
                ClipMemcpy(pData, pClipPDU->data, pClipPDU->dataLen);
                GlobalUnlock(hData);
            }
            else
            {
                TRC_ERR((TB, _T("Failed to lock %p (%ld bytes)"),
                        hData, pClipPDU->dataLen));
                GlobalFree(hData);
                hData = NULL;
            }
        }
        else
        {
            TRC_ERR((TB, _T("Failed to alloc %ld bytes"), pClipPDU->dataLen));
        }
    }

DC_EXIT_POINT:

    /************************************************************************/
    /* tidy up                                                              */
    /************************************************************************/
    if (pLogPalette != NULL)
    {
        ClipFree(pLogPalette);
    }

    /************************************************************************/
    /* Set the state, and we're done.  Note that this is done when we get a */
    /* failure response too.                                                */
    /************************************************************************/
    CB_SET_STATE(CB_STATE_LOCAL_CB_OWNER, CB_EVENT_FORMAT_DATA_RSP);
    _pClipData->SetClipData(hData, _CB.pendingClientID ) ;

    TRC_ASSERT( NULL != _GetDataSync[TS_RECEIVE_COMPLETED],
        (TB,_T("data sync is NULL")));
    SetEvent(_GetDataSync[TS_RECEIVE_COMPLETED]) ;

    DC_END_FN();
    return;
} /* ClipOnFormatDataComplete */


/****************************************************************************/
/* ClipRemoteFormatFromLocalID                                              */
/****************************************************************************/
DCUINT DCINTERNAL CClip::ClipRemoteFormatFromLocalID(DCUINT id)
{
    DCUINT i;
    DCUINT retID = 0;

    for (i = 0; i < CB_MAX_FORMATS; i++)
    {
        if (_CB.idMap[i].clientID == id)
        {
            retID = _CB.idMap[i].serverID;
            break;
        }
    }

    return(retID);
}


/****************************************************************************/
/* ClipOnWriteComplete                                                      */
/****************************************************************************/
DCVOID DCINTERNAL CClip::ClipOnWriteComplete(LPVOID pData)
{
    PTS_CLIP_PDU pClipPDU;

    DC_BEGIN_FN("CClip::ClipOnWriteComplete");

    TRC_NRM((TB, _T("Free buffer at %p"), pData));
    pClipPDU = (PTS_CLIP_PDU)pData;
    TRC_DBG((TB, _T("Message type %hx, flags %hx"),
            pClipPDU->msgType, pClipPDU->msgFlags));

    /************************************************************************/
    /* Free the buffer                                                      */
    /************************************************************************/
    TRC_DBG((TB, _T("Write from buffer %p complete"), pData));
    ClipFreeBuf((PDCUINT8)pData);

    DC_END_FN();
    return;
}

HRESULT CClip::ClipCreateDataSyncEvents()
{
    HRESULT hr = E_FAIL ;

    DC_BEGIN_FN("CClip::ClipCreateDataSyncEvents") ;
    // Create events for controlling the Clipboard thread
    _GetDataSync[TS_RECEIVE_COMPLETED] = CreateEvent(NULL, FALSE, FALSE, NULL) ;
    _GetDataSync[TS_RESET_EVENT] = CreateEvent(NULL, FALSE, FALSE, NULL) ;

    if (!_GetDataSync[TS_RECEIVE_COMPLETED])
    {
        TRC_ERR((TB, _T("Failed CreateEvent RECEIVE_COMPLETED; Error = %d"),
                GetLastError())) ;
        hr = E_FAIL ;
        DC_QUIT ;
    }
    if (!_GetDataSync[TS_RESET_EVENT])
    {
        TRC_ERR((TB, _T("Failed CreateEvent RESET_EVENT; Error = %d"),
                GetLastError())) ;
        hr = E_FAIL ;
        DC_QUIT ;
    }
    hr = S_OK ;
DC_EXIT_POINT:
    DC_END_FN() ;
    return hr ;
}

/****************************************************************************/
/* ClipOnInitialized                                                        */
/****************************************************************************/
DCINT32 DCAPI CClip::ClipOnInitialized(DCVOID)
{
    DC_BEGIN_FN("CClip::ClipOnInitialized") ;
    HRESULT  hr = E_FAIL ;
    BOOL     fthreadStarted = FALSE ;

    hr = ClipCreateDataSyncEvents() ;
    DC_QUIT_ON_FAIL(hr);
    
    /************************************************************************/
    /* Register a message for communication between the two threads         */
    /************************************************************************/
    _CB.regMsg = WM_USER_CHANGE_THREAD;
    
    TRC_NRM((TB, _T("Registered window message %x"), _CB.regMsg));
    
    _CB.pClipThreadData = (PUT_THREAD_DATA) LocalAlloc(LPTR, sizeof(UT_THREAD_DATA)) ;
    if (NULL == _CB.pClipThreadData)
    {
        TRC_ERR((TB, _T("Unable to allocate %d bytes for thread data"),
                sizeof(UT_THREAD_DATA))) ;
        hr = E_FAIL ;
        DC_QUIT ;
    }
    
    if (_pUtObject) {
        fthreadStarted = _pUtObject->UT_StartThread(ClipStaticMain, 
                _CB.pClipThreadData, this);
    }

    if (!fthreadStarted)
    {
        hr = E_FAIL ;
        DC_QUIT ;
    }

    // If we got to this point, then we succeeded initialized everything
    hr = S_OK ;
    
DC_EXIT_POINT:

    // On failure be sure to clear out the data syncs.  
    // we will not connect the virtual channel if the 
    // data sync are NULL
    if (FAILED(hr)) {
        _GetDataSync[TS_RECEIVE_COMPLETED] = NULL;
        _GetDataSync[TS_RESET_EVENT] = NULL;
    }
    
    return hr ;
}
/****************************************************************************/
/* ClipStaticMain                                                           */
/****************************************************************************/
DCVOID DCAPI ClipStaticMain(PDCVOID param)
{
    ((CClip*) param)->ClipMain() ;
}

/****************************************************************************/
/* ClipOnInit                                                               */
/****************************************************************************/
DCINT DCAPI CClip::ClipOnInit(DCVOID)
{
    ATOM        registerClassRc;
    WNDCLASS    viewerWindowClass;
    WNDCLASS    tmpWndClass;
    DCINT allOk = FALSE ;

    DC_BEGIN_FN("CClip::ClipOnInit");

    /************************************************************************/
    /* Create an invisible window which we will register as a clipboard     */
    /* viewer                                                               */
    /* Only register if prev instance did not already register the class    */
    /************************************************************************/
    if(!GetClassInfo(_CB.hInst, CB_VIEWER_CLASS, &tmpWndClass))
    {
        TRC_NRM((TB, _T("Register Main Window class, data %p, hInst %p"),
                &viewerWindowClass, _CB.hInst));
        viewerWindowClass.style         = 0;
        viewerWindowClass.lpfnWndProc   = StaticClipViewerWndProc;
        viewerWindowClass.cbClsExtra    = 0;
        viewerWindowClass.cbWndExtra    = sizeof(void*);        
        viewerWindowClass.hInstance     = _CB.hInst ;
        viewerWindowClass.hIcon         = NULL;
        viewerWindowClass.hCursor       = NULL;
        viewerWindowClass.hbrBackground = (HBRUSH)GetStockObject(HOLLOW_BRUSH);
        viewerWindowClass.lpszMenuName  = NULL;
        viewerWindowClass.lpszClassName = CB_VIEWER_CLASS;
    
        TRC_DATA_NRM("Register class data", &viewerWindowClass, sizeof(WNDCLASS));
        registerClassRc = RegisterClass (&viewerWindowClass);
    
        if (registerClassRc == 0)
        {
            /****************************************************************/
            /* Failed to register CB viewer class                           */
            /****************************************************************/
            TRC_ERR((TB, _T("Failed to register Cb Viewer class")));
        }
        TRC_NRM((TB, _T("Registered class")));
    }

    _CB.viewerWindow =
       CreateWindowEx(
#ifndef OS_WINCE
                    WS_EX_NOPARENTNOTIFY,
#else
                    0,
#endif
                    CB_VIEWER_CLASS,            /* window class name    */
                    _T("CB Viewer Window"),     /* window caption       */
#ifndef OS_WINCE
                    WS_OVERLAPPEDWINDOW,        /* window style         */
#else
                    WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX | WS_MAXIMIZEBOX,
#endif
                    0,                          /* initial x position   */
                    0,                          /* initial y position   */
                    100,                        /* initial x size       */
                    100,                        /* initial y size       */
                    NULL,                       /* parent window        */
                    NULL,                       /* window menu handle   */
                    _CB.hInst,                  /* program inst handle  */
                    this);                      /* creation parameters  */

    /************************************************************************/
    /* Check we created the window OK                                       */
    /************************************************************************/
    if (_CB.viewerWindow == NULL)
    {
        TRC_ERR((TB, _T("Failed to create CB Viewer Window")));
        DC_QUIT ;
    }
    TRC_DBG((TB, _T("Viewer Window handle %p"), _CB.viewerWindow)); 

#ifdef OS_WINCE
    if ((_CB.dataWindow = CECreateCBDataWindow(_CB.hInst)) == NULL)
    {
        TRC_ERR((TB, _T("Failed to create CB Data Window")));
        DC_QUIT ;
    }
#endif

#ifdef USE_SEMAPHORE
    /************************************************************************/
    /* Create the permanent TX buffer semaphore                             */
    /************************************************************************/
    _CB.txPermBufSem = CreateSemaphore(NULL, 1, 1, NULL);
    if (_CB.txPermBufSem == NULL)
    {
        TRC_ERR((TB, _T("Failed to create semaphore")));
        DC_QUIT;
    }
    TRC_NRM((TB, _T("Create perm TX buffer sem %p"), _CB.txPermBufSem));
#endif

#ifdef OS_WINCE
    gfmtShellPidlArray = RegisterClipboardFormat(CFSTR_SHELLPIDLARRAY);
#endif
    /************************************************************************/
    /* Update the state                                                     */
    /************************************************************************/
    CB_SET_STATE(CB_STATE_INITIALIZED, CB_TRACE_EVENT_CB_CLIPMAIN);

allOk = TRUE ;
DC_EXIT_POINT:
    DC_END_FN();

    return allOk;

} /* ClipOnInit */


/****************************************************************************/
/* ClipOnTerm                                                               */
/****************************************************************************/
DCBOOL DCAPI CClip::ClipOnTerm(LPVOID pInitHandle)
{
    BOOL fSuccess = FALSE ;
    BOOL fThreadEnded = FALSE ;
    DC_BEGIN_FN("CClip::ClipOnTerm");

    /************************************************************************/
    /* Check the state - if we're still connected, we should disconnect     */
    /* before shutting down                                                 */
    /************************************************************************/
    ClipCheckState(CB_EVENT_CB_TERM);
    if (_CB.state != CB_STATE_INITIALIZED)
    {
        TRC_ALT((TB, _T("Terminated when not disconnected")));
        ClipOnDisconnected(pInitHandle);
    }

    // If we had file cut/copy on, we should clean up after ourselves
    if (_CB.fFileCutCopyOn)
    {
        SendMessage(_CB.viewerWindow, WM_USER_CLEANUP_ON_TERM, 0, 0);        
    }


    /************************************************************************/
    /* Destroy the window and unregister the class (the WM_DESTROY handling */
    /* will deal with removing the window from the viewer chain)            */
    /************************************************************************/
    TRC_NRM((TB, _T("Destroying CB window...")));
    if (!PostMessage(_CB.viewerWindow, WM_CLOSE, 0, 0))
    {
        TRC_SYSTEM_ERROR("DestroyWindow");
    }

    if (!UnregisterClass(CB_VIEWER_CLASS, _CB.hInst))
    {
        TRC_SYSTEM_ERROR("UnregisterClass");
    }

#ifdef OS_WINCE
    TRC_NRM((TB, _T("Destroying CB data window...")));
    if (!PostMessage(_CB.dataWindow, WM_CLOSE, 0, 0))
    {
        TRC_SYSTEM_ERROR("DestroyWindow");
    }

    if (!UnregisterClass(CB_DATAWINDOW_CLASS, _CB.hInst))
    {
        TRC_SYSTEM_ERROR("UnregisterClass");
    }
#endif
    if (_pClipData)
    {
        // Decrement the reference count of the IDataObject object. At this stage,
        // this should cause the reference count to drop to zero and the IDataObject
        // object's destructor should be called. This destructor will release the
        // reference to this CClipData object, resulting in a reference count of 1.
        // Hence the call to Release() below will result in the CClipData destructor
        // being called.

        _pClipData->TearDown();
        _pClipData->Release() ;
        _pClipData = NULL;
    }
    if (_CB.pClipThreadData)
    {
        fThreadEnded = _pUtObject->UT_DestroyThread(*_CB.pClipThreadData);
        if (!fThreadEnded)
        {
            TRC_ERR((TB, _T("Error while ending thread"))) ;
            fSuccess = FALSE;
            DC_QUIT ;
        }
        LocalFree( _CB.pClipThreadData );
        _CB.pClipThreadData = NULL;
    }

    if (_pUtObject)
    {
        LocalFree(_pUtObject);
        _pUtObject = NULL;
    }
    fSuccess = TRUE ;
DC_EXIT_POINT:
    /************************************************************************/
    /* Update our state                                                     */
    /************************************************************************/
    CB_SET_STATE(CB_STATE_NOT_INIT, CB_EVENT_CB_TERM);

    DC_END_FN();
    return fSuccess ;

} /* ClipOnTerm */

DCVOID DCAPI CClip::ClipMain(DCVOID)
{
    DC_BEGIN_FN("CClip::ClipMain");
    MSG msg ;

#ifndef OS_WINCE
    HRESULT result = OleInitialize(NULL) ;
#else
    HRESULT result = CoInitializeEx(NULL, COINIT_MULTITHREADED) ;
#endif
    if (SUCCEEDED(result))
    {
        if (0 != ClipOnInit())
        {
            TRC_NRM((TB, _T("Start Clip Thread message loop"))) ;
            while (GetMessage (&msg, NULL, 0, 0))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
        else
        {
            TRC_ERR((TB, _T("Failed initialized clipboard thread"))) ;
        }

#ifndef OS_WINCE
        // We assume OleUninitialize works, as it has no return value
        OleUninitialize() ;
#else
        CoUninitialize() ;
#endif
    }
    else
    {
        TRC_ERR((TB, _T("OleInitialize Failed"))) ;
    }

DC_EXIT_POINT:
    TRC_NRM((TB, _T("Exit Clip Thread message loop"))) ;
    DC_END_FN();    
}
/****************************************************************************/
/* ClipOnConnected                                                          */
/****************************************************************************/
VOID DCINTERNAL CClip::ClipOnConnected(LPVOID pInitHandle)
{
    UINT rc;

    DC_BEGIN_FN("CClip::ClipOnConnected");

    if (!IsDataSyncReady()) {
        TRC_ERR((TB, _T("Data Sync not ready")));
        DC_QUIT;
    }
    
    _CB.fDrivesRedirected = _pVCMgr->GetInitData()->fEnableRedirectDrives;
    _CB.fFileCutCopyOn = _CB.fDrivesRedirected;
    /************************************************************************/
    /* Open our channel                                                     */
    /************************************************************************/
    TRC_NRM((TB, _T("Entry points are at %p"), &(_CB.channelEP)));
    TRC_NRM((TB, _T("Call ChannelOpen at %p"), _CB.channelEP.pVirtualChannelOpenEx));
    rc = _CB.channelEP.pVirtualChannelOpenEx(pInitHandle,
                                            &_CB.channelHandle,
                                            CLIP_CHANNEL,
                                            (PCHANNEL_OPEN_EVENT_EX_FN)MakeProcInstance(
                                                (FARPROC)ClipOpenEventFnEx, _CB.hInst)
                                            );

    TRC_NRM((TB, _T("Opened %s: %ld, rc %d"), CLIP_CHANNEL,_CB.channelHandle, rc));

DC_EXIT_POINT:
    DC_END_FN();
    return;
}


/****************************************************************************/
/* ClipOnConnected                                                          */
/****************************************************************************/
VOID DCINTERNAL CClip::ClipOnMonitorReady(VOID)
{
    DC_BEGIN_FN("CClip::ClipOnMonitorReady");

    /************************************************************************/
    /* The monitor has woken up.  Check the state                           */
    /************************************************************************/
    CB_CHECK_STATE(CB_EVENT_CB_ENABLE);

    // Update the state 

    CB_SET_STATE(CB_STATE_ENABLED, CB_TRACE_EVENT_CB_MONITOR_READY);

    // Get the temp directory, and send it off to the server
    // if it fails, then we turn off File Cut/Copy
    _CB.fFileCutCopyOn = ClipSetAndSendTempDirectory() ;
    
    // We now send the list of clipboard formats we have at this end to the 
    // server by faking a draw of the local clipboard.  We pass TRUE to 
    // force a send because the server needs to have the value of our 
    // TS_CB_ASCII_NAMES flag (RAID #313251). 
     ClipDrawClipboard(TRUE);

DC_EXIT_POINT:
    DC_END_FN();
    return;
}


/****************************************************************************/
/* ClipOnDisconnected                                                       */
/****************************************************************************/
VOID DCINTERNAL CClip::ClipOnDisconnected(LPVOID pInitHandle)
{
    DC_BEGIN_FN("CClip::ClipOnDisconnected");

    DC_IGNORE_PARAMETER(pInitHandle);

    //
    //  Reset the clipboard thread
    //  if it waits for data
    //
    if ( NULL != _GetDataSync[TS_RESET_EVENT] )
    {
        SetEvent( _GetDataSync[TS_RESET_EVENT] );
    }
    /************************************************************************/
    /* Check the state                                                      */
    /************************************************************************/
    ClipCheckState(CB_EVENT_CB_DISABLE);

    /************************************************************************/
    /* If we are the local clipboard owner, then we must empty it - once    */
    /* disconnected, we won't be able to satisfy any further format         */
    /* requests.  Note that we are still the local CB owner even if we are  */
    /* waiting on some data from the server                                 */
    /************************************************************************/
    if (_CB.state == CB_STATE_LOCAL_CB_OWNER)
    {
        TRC_NRM((TB, _T("Disable received while local CB owner")));

        /********************************************************************/
        /* Open the clipboard if needed                                     */
        /********************************************************************/
        if ((!_CB.rcvOpen) && !OpenClipboard(NULL))
        {
            TRC_ERR((TB, _T("Failed to open CB when emptying required")));
        }
        else
        {
            /****************************************************************/
            /* It was/is open                                               */
            /****************************************************************/
            TRC_NRM((TB, _T("CB opened")));
            _CB.rcvOpen = TRUE;

            /****************************************************************/
            /* Empty it                                                     */
            /****************************************************************/
            if (!EmptyClipboard())
            {
                TRC_SYSTEM_ERROR("EmptyClipboard");
            }
        }
    }
    /************************************************************************/
    /* If there is pending format data, we should SetClipboardData to NULL  */
    /* so that app can close the clipboard                                  */
    /************************************************************************/
    else if (_CB.state == CB_STATE_PENDING_FORMAT_DATA_RSP) {
        TRC_NRM((TB, _T("Pending format data: setting clipboard data to NULL")));
        SetClipboardData(_CB.pendingClientID, NULL);
    }

    /************************************************************************/
    /* Ensure that we close the local CB                                    */
    /************************************************************************/
    if (_CB.rcvOpen)
    {
        _CB.rcvOpen = FALSE;
        if (!CloseClipboard())
        {
            TRC_SYSTEM_ERROR("CloseClipboard");
        }
        TRC_NRM((TB, _T("CB closed")));
    }

    /************************************************************************/
    /* If we were sending or receiving data, unlock and free the buffers as */
    /* required                                                             */
    /************************************************************************/
    if (_CB.rxpBuffer)
    {
        TRC_NRM((TB, _T("Freeing recieve buffer %p"), _CB.rxpBuffer));
        ClipFree(_CB.rxpBuffer);
        _CB.rxpBuffer = NULL;
    }

DC_EXIT_POINT:
    /************************************************************************/
    /* Update our state                                                     */
    /************************************************************************/
    CB_SET_STATE(CB_STATE_INITIALIZED, CB_TRACE_EVENT_CB_DISCONNECT);

    DC_END_FN();
    return;
} /* ClipOnDisconnected */

/****************************************************************************/
// ClipOnDataReceived
/****************************************************************************/
DCVOID DCAPI CClip::ClipOnDataReceived(LPVOID pData,
                                UINT32 dataLength,
                                UINT32 totalLength,
                                UINT32 dataFlags)
{
    PTS_CLIP_PDU pClipPDU;
    DCBOOL freeTheBuffer = TRUE;
    DC_BEGIN_FN("CClip::ClipOnDataReceived");

    //
    // Verify that there is enough data to make up or create a clip PDU header.
    //

    if (totalLength < sizeof(TS_CLIP_PDU)) {
        TRC_ERR((TB, _T("Not enough data to form a clip header.")));
        _CB.channelEP.pVirtualChannelCloseEx(_CB.initHandle, _CB.channelHandle);
        DC_QUIT;
    }

    /************************************************************************/
    /* Check we're all up and running                                       */
    /************************************************************************/
    if (_CB.state == CB_STATE_NOT_INIT)
    {
        pClipPDU = (PTS_CLIP_PDU)pData;
        TRC_ERR((TB, _T("Clip message type %hd received when not init"),
                                                          pClipPDU->msgType));
        DC_QUIT;
    }

    /************************************************************************/
    /* Special case: if the entire message fits in one chunk, there's no    */
    /* need to copy it                                                      */
    /************************************************************************/
    if (CHANNEL_FLAG_ONLY == (dataFlags & CHANNEL_FLAG_ONLY))
    {
        TRC_DBG((TB, _T("Single chunk message")));
        pClipPDU = (PTS_CLIP_PDU)pData;
    }
    else
    {

        /********************************************************************/
        /* It's a segmented message - rebuild it                            */
        /********************************************************************/
        if (dataFlags & CHANNEL_FLAG_FIRST)
        {
            /****************************************************************/
            /* If it's the first segment, allocate a buffer to rebuild the  */
            /* message in.                                                  */
            /****************************************************************/
            TRC_DBG((TB, _T("Alloc %ld-byte buffer"), totalLength));
            _CB.rxpBuffer = (HPDCUINT8)ClipAlloc(totalLength);
            if (_CB.rxpBuffer == NULL)
            {
                /************************************************************/
                /* Failed to alloc a buffer.  We have to do something,      */
                /* otherwise the Client app can hang waiting for data.      */
                /* Fake a failure response.                                 */
                /************************************************************/
                TRC_ERR((TB, _T("Failed to alloc %ld-byte buffer"), totalLength));
                pClipPDU = (PTS_CLIP_PDU)pData;
                pClipPDU->msgFlags = TS_CB_RESPONSE_FAIL;
                pClipPDU->dataLen = 0;
                dataFlags |= CHANNEL_FLAG_LAST;

                /************************************************************/
                /* Now handle it as if it were complete.  Subsequent chunks */
                /* will be discarded.                                       */
                /************************************************************/
                goto MESSAGE_COMPLETE;
            }

            _CB.rxpBufferCurrent = _CB.rxpBuffer;
            _CB.rxBufferLen = totalLength;
            _CB.rxBufferLeft = totalLength;
        }

        /********************************************************************/
        /* Check that we have a buffer to copy into                         */
        /********************************************************************/
        if (_CB.rxpBuffer == NULL)
        {
            TRC_NRM((TB, _T("Previous buffer alloc failure - discard data")));
            DC_QUIT;
        }

        /********************************************************************/
        /* Check that there is enough room                                  */
        /********************************************************************/
        if (dataLength > _CB.rxBufferLeft)
        {
            TRC_ERR((TB, _T("Not enough room in rx buffer: need/got %ld/%ld"),
                    dataLength, _CB.rxBufferLeft));
            DC_QUIT;
        }

        /********************************************************************/
        /* Copy the data                                                    */
        /********************************************************************/
        TRC_DBG((TB, _T("Copy %ld bytes from %p to %p"),
                dataLength, pData, _CB.rxpBufferCurrent));
        ClipMemcpy(_CB.rxpBufferCurrent, pData, dataLength);
        _CB.rxpBufferCurrent += dataLength;
        _CB.rxBufferLeft -= dataLength;
        TRC_DBG((TB, _T("Next copy to %p, left %ld"),
                _CB.rxpBufferCurrent, _CB.rxBufferLeft));

        /********************************************************************/
        /* If this wasn't the last chunk, there's nothing more to do        */
        /********************************************************************/
        if (!(dataFlags & CHANNEL_FLAG_LAST))
        {
            TRC_DBG((TB, _T("Not last chunk")));
            freeTheBuffer = FALSE;
            DC_QUIT;
        }

        /********************************************************************/
        /* Check we got the entire message                                  */
        /********************************************************************/
        if (_CB.rxBufferLeft != 0)
        {
            TRC_ERR((TB, _T("Incomplete data, expected/got %ld/%ld"),
                    _CB.rxBufferLen, _CB.rxBufferLen - _CB.rxBufferLeft));
            DC_QUIT;
        }

        pClipPDU = (PTS_CLIP_PDU)(_CB.rxpBuffer);
    }

    /************************************************************************/
    /* We allow monitor ready thru because that's what put us in the call!  */
    /************************************************************************/
    if ((_CB.state == CB_STATE_INITIALIZED)
                                && (pClipPDU->msgType != TS_CB_MONITOR_READY))
    {
        TRC_ERR((TB, _T("Clip message type %hd received when not in call"),
                                                          pClipPDU->msgType));
        DC_QUIT;
    }

    /************************************************************************/
    /* now switch on the packet type                                        */
    /************************************************************************/
MESSAGE_COMPLETE:
    TRC_NRM((TB, _T("Processing msg type %hd when in state %d"),
                                                pClipPDU->msgType, _CB.state));
    TRC_DATA_DBG("pdu", pClipPDU,
                (DCUINT)pClipPDU->dataLen + sizeof(TS_CLIP_PDU));

    //
    // Verify that the data in the dataLen in pClipPDU is consistent with the
    // length given in the dataLength parameter.
    //

    if (pClipPDU->dataLen > totalLength - sizeof(TS_CLIP_PDU)) {
        TRC_ERR((TB, _T("Length from network differs from published length.")));
        _CB.channelEP.pVirtualChannelCloseEx(_CB.initHandle, _CB.channelHandle);
        DC_QUIT;
    }

    switch (pClipPDU->msgType)
    {
        case TS_CB_MONITOR_READY:
        {
            /****************************************************************/
            /* The monitor has initialised - we can complete our start up   */
            /* now.                                                         */
            /****************************************************************/
            TRC_NRM((TB, _T("rx monitor ready")));
            TRC_ASSERT( NULL != _GetDataSync[TS_RESET_EVENT],
                    (TB,_T("data sync is NULL")));            
            SetEvent(_GetDataSync[TS_RESET_EVENT]) ;

            ClipOnMonitorReady();
        }
        break;

        case TS_CB_FORMAT_LIST:
        {
            /****************************************************************/
            // The server has some new formats for us.
            /****************************************************************/
            TRC_NRM((TB, _T("Rx Format list")));
            // Free the Clipboard thread, if locked
            TRC_ASSERT( NULL != _GetDataSync[TS_RESET_EVENT],
                    (TB,_T("data sync is NULL")));              
            SetEvent(_GetDataSync[TS_RESET_EVENT]) ;
            ClipDecoupleToClip(pClipPDU) ;
        }
        break;

        case TS_CB_FORMAT_LIST_RESPONSE:
        {
            /****************************************************************/
            // The server has received our new formats.
            /****************************************************************/
            TRC_NRM((TB, _T("Rx Format list Rsp")));
            ClipOnFormatListResponse(pClipPDU);
        }
        break;

        case TS_CB_FORMAT_DATA_REQUEST:
        {
            /****************************************************************/
            // An app on the server wants to paste one of the formats from
            // our clipboard.
            /****************************************************************/
            TRC_NRM((TB, _T("Rx Data Request")));
            ClipOnFormatRequest(pClipPDU);
        }
        break;

        case TS_CB_FORMAT_DATA_RESPONSE:
        {
            /****************************************************************/
            // Here's some format data for us
            /****************************************************************/
            TRC_NRM((TB, _T("Rx Format Data rsp in state %d with flags %02x"),
                                               _CB.state, pClipPDU->msgFlags));
            ClipOnFormatDataComplete(pClipPDU);
        }
        break;

        default:
        {
            /****************************************************************/
            /* Don't know what this one is!                                 */
            /****************************************************************/
            TRC_ERR((TB, _T("Unknown clip message type %hd"), pClipPDU->msgType));
        }
        break;
    }

DC_EXIT_POINT:
    /************************************************************************/
    /* Maybe free the receive buffer                                        */
    /************************************************************************/
    if (freeTheBuffer && _CB.rxpBuffer)
    {
        TRC_NRM((TB, _T("Free receive buffer")));
        ClipFree(_CB.rxpBuffer);
        _CB.rxpBuffer = NULL;
    }
    DC_END_FN();
    return;

} /* CB_OnPacketReceived */

DCVOID DCAPI CClip::ClipDecoupleToClip (PTS_CLIP_PDU pData)
{
    ULONG  cbPDU ;
    DC_BEGIN_FN("CClip::ClipDecoupleToClip");
    // Allocate space for the PDU and its data, and then copy it
    cbPDU = sizeof(TS_CLIP_PDU) + pData->dataLen ;
    PDCVOID newBuffer = LocalAlloc(LPTR, cbPDU) ;

    if (NULL != newBuffer)
        DC_MEMCPY(newBuffer, pData, cbPDU) ;
    else
        return;

    TRC_NRM((TB, _T("Pass %d bytes to clipboard thread"), cbPDU));
    PostMessage(_CB.viewerWindow,
                _CB.regMsg,
                cbPDU,
                (LPARAM) newBuffer);
                          

    DC_END_FN();
}


/****************************************************************************/
/* Open Event callback                                                      */
/****************************************************************************/
VOID VCAPITYPE VCEXPORT DCLOADDS CClip::ClipOpenEventFnEx(LPVOID lpUserParam,
                                        DWORD  openHandle,
                                        UINT   event,
                                        LPVOID pData,
                                        UINT32 dataLength,
                                        UINT32 totalLength,
                                        UINT32 dataFlags)
{
    DC_BEGIN_FN("CClip::ClipOpenEventFnEx");
    
    TRC_ASSERT(((VCManager*)lpUserParam != NULL), (TB, _T("lpUserParam is NULL, no instance data")));
    if(!lpUserParam) 
    {
        return;
    }

    CClip* pClip = ((VCManager*)lpUserParam)->GetClip();
    TRC_ASSERT((pClip != NULL), (TB, _T("pClip is NULL in ClipOpenEventFnEx")));
    if(!pClip)
    {
        return;
    }
    
    pClip->ClipInternalOpenEventFn(openHandle, event, pData, dataLength,
        totalLength, dataFlags);
    
    DC_END_FN();
    return;
}


VOID VCAPITYPE VCEXPORT DCLOADDS CClip::ClipInternalOpenEventFn(DWORD  openHandle,
                                        UINT   event,
                                        LPVOID pData,
                                        UINT32 dataLength,
                                        UINT32 totalLength,
                                        UINT32 dataFlags)
{
    DC_BEGIN_FN("CClip::ClipOpenEventFn");
    
    DC_IGNORE_PARAMETER(openHandle)
  
    switch (event)
    {
        /********************************************************************/
        /* Data received from Server                                        */
        /********************************************************************/
        case CHANNEL_EVENT_DATA_RECEIVED:
        {
            TRC_NRM((TB, _T("Data in: handle %ld, len %ld (of %ld), flags %lx"),
                    openHandle, dataLength, totalLength, dataFlags)) ;
            TRC_DATA_NRM("Data", pData, (DCUINT)dataLength) ;
            ClipOnDataReceived(pData, dataLength, totalLength, dataFlags) ;
        }
        break;

        /********************************************************************/
        /* Write operation completed                                        */
        /********************************************************************/
        case CHANNEL_EVENT_WRITE_COMPLETE:
        case CHANNEL_EVENT_WRITE_CANCELLED:
        {
            TRC_NRM((TB, _T("Write %s %p"),
             event == CHANNEL_EVENT_WRITE_COMPLETE ? "complete" : "cancelled",
             pData));
            ClipOnWriteComplete(pData);
        }
        break;

        /********************************************************************/
        /* Er, that didn't happen, did it?                                  */
        /********************************************************************/
        default:
        {
            TRC_ERR((TB, _T("Unexpected event %d"), event));
        }
        break;
    }

    DC_END_FN();
    return;
}


/****************************************************************************/
/* Init Event callback                                                      */
/****************************************************************************/
VOID VCAPITYPE VCEXPORT CClip::ClipInitEventFn(LPVOID pInitHandle,
                                        UINT   event,
                                        LPVOID pData,
                                        UINT   dataLength)
{
    DC_BEGIN_FN("CClip::ClipInitEventFn");

    DC_IGNORE_PARAMETER(dataLength)
    DC_IGNORE_PARAMETER(pData)

    switch (event)
    {
        /********************************************************************/
        /* Client initialized (no data)                                     */
        /********************************************************************/
        case CHANNEL_EVENT_INITIALIZED:
        {
            TRC_NRM((TB, _T("CHANNEL_EVENT_INITIALIZED: %p"), pInitHandle));
            ClipOnInitialized();
        }
        break;

        /********************************************************************/
        /* Connection established (data = name of Server)                   */
        /********************************************************************/
        case CHANNEL_EVENT_CONNECTED:
        {
            TRC_NRM((TB, _T("CHANNEL_EVENT_CONNECTED: %p, Server %s"),
                    pInitHandle, pData));

            if (IsDataSyncReady()) {
                ClipOnConnected(pInitHandle);
            }
            else {
                TRC_ERR((TB,_T("data sync not ready on CHANNEL_EVENT_CONNECTED")));
            }
        }
        break;

        /********************************************************************/
        /* Connection established with old Server, so no channel support    */
        /********************************************************************/
        case CHANNEL_EVENT_V1_CONNECTED:
        {
            TRC_NRM((TB, _T("CHANNEL_EVENT_V1_CONNECTED: %p, Server %s"),
                    pInitHandle, pData));
        }
        break;

        /********************************************************************/
        /* Connection ended (no data)                                       */
        /********************************************************************/
        case CHANNEL_EVENT_DISCONNECTED:
        {
            TRC_NRM((TB, _T("CHANNEL_EVENT_DISCONNECTED: %p"), pInitHandle));
            ClipOnDisconnected(pInitHandle);
        }
        break;

        /********************************************************************/
        /* Client terminated (no data)                                      */
        /********************************************************************/
        case CHANNEL_EVENT_TERMINATED:
        {
            TRC_NRM((TB, _T("CHANNEL_EVENT_TERMINATED: %p"), pInitHandle));
            ClipOnTerm(pInitHandle);
        }
        break;

        /********************************************************************/
        /* Unknown event                                                    */
        /********************************************************************/
        default:
        {
            TRC_ERR((TB, _T("Unkown channel event %d: %p"), event, pInitHandle));
        }
        break;
    }

    DC_END_FN();
    return;
}


/****************************************************************************/
/* Clip window proc                                                         */
/****************************************************************************/
LRESULT CALLBACK DCEXPORT DCLOADDS CClip::StaticClipViewerWndProc(HWND   hwnd,
                                   UINT   message,
                                   WPARAM wParam,
                                   LPARAM lParam)
{
    CClip* pClip = (CClip*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if(WM_CREATE == message)
    {
        //pull out the this pointer and stuff it in the window class
        LPCREATESTRUCT lpcs = (LPCREATESTRUCT) lParam;
        pClip = (CClip*)lpcs->lpCreateParams;

        SetWindowLongPtr( hwnd, GWLP_USERDATA, (LONG_PTR)pClip);
    }
    
    //
    // Delegate the message to the appropriate instance
    //

    if(pClip)
    {
        return pClip->ClipViewerWndProc(hwnd, message, wParam, lParam);
    }
    else
    {
        return DefWindowProc(hwnd, message, wParam, lParam);
    }
}

LRESULT CALLBACK DCEXPORT DCLOADDS CClip::ClipViewerWndProc(HWND   hwnd,
                                   UINT   message,
                                   WPARAM wParam,
                                   LPARAM lParam)
{
    PTS_CLIP_PDU    pClipPDU = NULL;
#ifndef OS_WINCE
    DCUINT32        pduLen;
    DCUINT32        dataLen;
    PDCUINT32       pFormatID;
    MSG             msg;
#endif
    DCBOOL          drawRc;
    DCBOOL          gotRsp = FALSE;
    LRESULT         rc = 0;
    HRESULT         hr ;

    DC_BEGIN_FN("CClip::ClipViewerWndProc");

    // We first handle messages from the other thread
    if (message == _CB.regMsg) 
    {
        pClipPDU = (PTS_CLIP_PDU)lParam;
        switch (pClipPDU->msgType)
        {
            case TS_CB_FORMAT_LIST:
            {
                TRC_NRM((TB, _T("TS_CB_FORMAT_LIST received")));
                ClipOnFormatList(pClipPDU);
            }
            break;

            default:
            {
                TRC_ERR((TB, _T("Unknown event %d"), pClipPDU->msgType));
            }
            break;
        }

        TRC_NRM((TB, _T("Freeing processed PDU")));
        LocalFree(pClipPDU);

        DC_QUIT;
    }
    else if (message == WM_USER_CLEANUP_ON_TERM) {
        
        TRC_NRM((TB, _T("Cleanup temp directory")));

        if (0 != ClipCleanTempPath())
        {
            TRC_NRM((TB, _T("Failed while trying to clean temp directory"))) ;
        }

        DC_QUIT;
    }
    
    switch (message)
    {
        case WM_CREATE:
        {
            /****************************************************************/
            /* We've been created - check the state                         */
            /****************************************************************/
            CB_CHECK_STATE(CB_EVENT_WM_CREATE);

#ifndef OS_WINCE
            /****************************************************************/
            /* Add the window to the clipboard viewer chain.                */
            /****************************************************************/
            _CB.nextViewer = SetClipboardViewer(hwnd);
#else
            ghwndClip = hwnd; 
            InitializeCriticalSection(&gcsDataObj);
#endif
        }
        break;

        case WM_DESTROY:
        {
            /****************************************************************/
            /* We're being destroyed - check the state                      */
            /****************************************************************/
            CB_CHECK_STATE(CB_EVENT_WM_DESTROY);

#ifndef OS_WINCE
            /****************************************************************/
            /* Remove ourselves from the CB Chain                           */
            /****************************************************************/
            ChangeClipboardChain(hwnd, _CB.nextViewer);
#endif
#ifdef OS_WINCE
            ghwndClip = NULL;
            EnterCriticalSection(&gcsDataObj);
            if (gpDataObj)
            {
                gpDataObj->Release();
                gpDataObj = NULL;
            }
            LeaveCriticalSection(&gcsDataObj);
            DeleteCriticalSection(&gcsDataObj);

            if (ghCeshellDll)
            {
                pfnEDList_Uninitialize();
                FreeLibrary(ghCeshellDll);
            }
#endif
            _CB.nextViewer = NULL;
            PostQuitMessage(0);
        }
        break;

        case WM_CLOSE:
        {
            DestroyWindow(hwnd);
        }
        break;

#ifndef OS_WINCE
        case WM_CHANGECBCHAIN:
        {
            /****************************************************************/
            /* The CB viewer chain is chainging - check the state           */
            /****************************************************************/
            CB_CHECK_STATE(CB_EVENT_WM_CHANGECBCHAIN);

            /****************************************************************/
            /* If the next window is closing, repair the chain.             */
            /****************************************************************/
            if ((HWND)wParam == _CB.nextViewer)
            {
                _CB.nextViewer = (HWND) lParam;
            }
            else if (_CB.nextViewer != NULL)
            {
                /************************************************************/
                /* pass the message to the next link.                       */
                /************************************************************/
                SendMessage(_CB.nextViewer, message, wParam, lParam);
            }

        }
        break;
#endif

        case WM_DRAWCLIPBOARD:
        {
            /****************************************************************/
            /* The local clipboard contents have been changed.  Check the   */
            /* state                                                        */
            /****************************************************************/
            if (ClipCheckState(CB_EVENT_WM_DRAWCLIPBOARD) != CB_TABLE_OK)
            {
                TRC_NRM((TB, _T("dropping drawcb - pass on to next viewer")));
                /************************************************************/
                /* check for state pending format list response             */
                /************************************************************/
                if (_CB.state == CB_STATE_PENDING_FORMAT_LIST_RSP)
                {
                    TRC_ALT((TB, _T("got a draw while processing last")));
                    /********************************************************/
                    /* we were still waiting for the server to acknowledge  */
                    /* the last format list when we got a new one - when it */
                    /* does, we'll have to to send it the new one.          */
                    /********************************************************/
                    _CB.moreToDo = TRUE;
                }

                if (_CB.nextViewer != NULL)
                {
                    /********************************************************/
                    /* But not before we pass the message to the next link. */
                    /********************************************************/
                    SendMessage(_CB.nextViewer, message, wParam, lParam);
                }
                break;
            }

            /****************************************************************/
            /* If it wasn't us that generated this change, then notify the  */
            /* remote                                                       */
            /****************************************************************/
            TRC_NRM((TB, _T("CB contents have changed...")));
            drawRc      = FALSE;
            _CB.moreToDo = FALSE;
#ifndef OS_WINCE
            LPDATAOBJECT pIDataObject = NULL;

            if (_pClipData != NULL) {
                _pClipData->QueryInterface(IID_IDataObject, (PPVOID) &pIDataObject) ;
                hr = OleIsCurrentClipboard(pIDataObject) ;
#else
                hr = S_FALSE;
#endif
    
                if ((S_FALSE == hr))
                {
                    TRC_NRM((TB, _T("...and it wasn't us")));
#ifdef OS_WINCE
                    if (_CB.fFileCutCopyOn)
                        DeleteDirectory(_CB.baseTempDirW);//Temp space is at a premium on CE. So delete any copied files now
#endif
                    drawRc = ClipDrawClipboard(TRUE);
                }
                else
                {
                    TRC_NRM((TB, _T("...and it was us - ignoring")));
                }
#ifndef OS_WINCE
            }

            /****************************************************************/
            /* Maybe pass on the draw clipboard message?                    */
            /****************************************************************/
            if (_CB.nextViewer != NULL)
            {
                TRC_NRM((TB, _T("Notify next viewer")));
                SendMessage(_CB.nextViewer, message, wParam, lParam);
            }
            if (pIDataObject)
            {
                pIDataObject->Release();
            }
#endif
        }
        break;


        case WM_EMPTY_CLIPBOARD:
        {
            /****************************************************************/
            /* Open the clipboard if needed                                 */
            /****************************************************************/
            if ((!_CB.clipOpen) && !OpenClipboard(NULL))
            {
                UINT count = (DCUINT) wParam;

                TRC_ERR((TB, _T("Failed to open CB when emptying required")));

                // Unfortunately, we are in the racing condition with the app that
                // has the clipboard open.  So, we need to keep trying until the app
                // closes the clipboard.
                if (count++ < 10) {

#ifdef OS_WIN32
                    Sleep(0);
#endif
                    PostMessage(_CB.viewerWindow, WM_EMPTY_CLIPBOARD, count, 0);
                }

                break;
            }
            else
            {
                /************************************************************/
                /* It was/is open                                           */
                /************************************************************/
                TRC_NRM((TB, _T("CB opened")));

                _CB.clipOpen = TRUE;

                /************************************************************/
                /* Empty it                                                 */
                /************************************************************/
                if (!EmptyClipboard())
                {
                    TRC_SYSTEM_ERROR("EmptyClipboard");
                }

                /************************************************************/
                /* update the state                                         */
                /************************************************************/
                CB_SET_STATE(CB_STATE_LOCAL_CB_OWNER, CB_TRACE_EVENT_WM_EMPTY_CLIPBOARD);
            }


            /****************************************************************/
            /* Ensure that we close the local CB                            */
            /****************************************************************/
            if (_CB.clipOpen)
            {
                _CB.clipOpen = FALSE;
                if (!CloseClipboard())
                {
                    TRC_SYSTEM_ERROR("CloseClipboard");
                }
                TRC_NRM((TB, _T("CB closed")));
            }
        }
        break;
            
        case WM_CLOSE_CLIPBOARD:
        {
            _CB.pendingClose = FALSE;
            TRC_DBG((TB, _T("Maybe close clipboard on WM_CLOSE_CLIPBOARD")));
            if (_CB.clipOpen)
            {
                TRC_NRM((TB, _T("Closing clipboard on WM_CLOSE_CLIPBOARD")));
                _CB.clipOpen = FALSE;
                if (!CloseClipboard())
                {
                    TRC_SYSTEM_ERROR("CloseClipboard");
                }
                TRC_DBG((TB, _T("CB closed on WM_CLOSE_CLIPBOARD")));
            }
        }
        break;

        default:
        {
            /****************************************************************/
            /* Ignore all other messages.                                   */
            /****************************************************************/
            rc = DefWindowProc(hwnd, message, wParam, lParam);
        }
        break;
    }

DC_EXIT_POINT:
    DC_END_FN();
    return(rc);
} /* ClipViewerWndProc */


/****************************************************************************/
/* ClipChannelEntry - called from VirtualChannelEntry in vcint.cpp          */
/****************************************************************************/
BOOL VCAPITYPE VCEXPORT CClip::ClipChannelEntry(PCHANNEL_ENTRY_POINTS_EX pEntryPoints)
{
    DC_BEGIN_FN("CClip::ClipChannelEntry");

    TRC_NRM((TB, _T("Size %ld, Init %p, Open %p, Close %p, Write %p"),
     pEntryPoints->cbSize,
     pEntryPoints->pVirtualChannelInitEx, pEntryPoints->pVirtualChannelOpenEx,
     pEntryPoints->pVirtualChannelCloseEx, pEntryPoints->pVirtualChannelWriteEx));

    /************************************************************************/
    /* Save the function pointers -- the memory pointed to by pEntryPoints  */
    /* is only valid for the duration of this call.                         */
    /************************************************************************/
    DC_MEMCPY(&(_CB.channelEP), pEntryPoints, sizeof(CHANNEL_ENTRY_POINTS_EX));
    TRC_NRM((TB, _T("Save entry points %p at address %p"),
            pEntryPoints, &(_CB.channelEP)));

    DC_END_FN();
    return TRUE;
}

DCINT DCAPI CClip::ClipGetData (DCUINT cfFormat)
{
    PTS_CLIP_PDU    pClipPDU = NULL;
    DCUINT32        pduLen;
    DCUINT32        dataLen;
    PDCUINT32       pFormatID;    
    BOOL            success = 0 ;
    
    DC_BEGIN_FN("CClip::ClipGetData");
    
    CB_CHECK_STATE(CB_EVENT_WM_RENDERFORMAT);
       
    /****************************************************************/
    /* and record the requested format                              */
    /****************************************************************/
    _CB.pendingClientID = cfFormat ;
    _CB.pendingServerID = ClipRemoteFormatFromLocalID
                                                 (_CB.pendingClientID);
    if (!_CB.pendingServerID)
    {
        TRC_NRM((TB, _T("Client format %d not supported/found.  Failing"), _CB.pendingClientID)) ;
        DC_QUIT ;
    }
    TRC_NRM((TB, _T("Render format received for %d (server ID %d)"),
                             _CB.pendingClientID, _CB.pendingServerID));
    
    dataLen = sizeof(DCUINT32);
    pduLen  = sizeof(TS_CLIP_PDU) + dataLen;
    
    // We can use the permanent send buffer for this
    TRC_NRM((TB, _T("Get perm TX buffer")));
    pClipPDU = ClipGetPermBuf();    

    // Fill in the PDU
    DC_MEMSET(pClipPDU, 0, sizeof(*pClipPDU));
    pClipPDU->msgType  = TS_CB_FORMAT_DATA_REQUEST;
    pClipPDU->dataLen  = dataLen;
    pFormatID = (PDCUINT32)(pClipPDU->data);
    *pFormatID = (DCUINT32)_CB.pendingServerID;
    
    // Send the PDU
    TRC_NRM((TB, _T("Sending format data request")));
    success = (_CB.channelEP.pVirtualChannelWriteEx
                        (_CB.initHandle, _CB.channelHandle, pClipPDU, pduLen, pClipPDU)
            == CHANNEL_RC_OK) ;
    if (!success) {
        TRC_ERR((TB, _T("Failed VC write: setting clip data to NULL")));
        ClipFreeBuf((PDCUINT8)pClipPDU);
        SetClipboardData(_CB.pendingClientID, NULL);
        // Yes, the exit point is just below, but it may not be always be
        DC_QUIT ;
    }
    
DC_EXIT_POINT:
    // Update the state
    if (success)
        CB_SET_STATE(CB_STATE_PENDING_FORMAT_DATA_RSP, CB_EVENT_WM_RENDERFORMAT);

    DC_END_FN();
    return success ;
}

#ifdef OS_WINCE
DCVOID CClip::ClipFixupRichTextFormats(UINT uRtf1, UINT uRtf2)
{
    DC_BEGIN_FN("CClip::ClipFixupRichTextFormats");
    if (uRtf1 == 0xffffffff)
    {
        TRC_ASSERT((uRtf2 == 0xffffffff), (TB, _T("uRtf2 is invalid")));
        return;
    }

    if (uRtf2 == 0xffffffff)
    {
        _CB.idMap[uRtf1].clientID = RegisterClipboardFormat(CFSTR_RTF);
        SetClipboardData(_CB.idMap[uRtf1].clientID, NULL);
        TRC_DBG((TB, _T("Adding format '%s', server ID %d, client ID %d"), CFSTR_RTF, _CB.idMap[uRtf1].serverID, _CB.idMap[uRtf1].clientID));
        return;
    }

    DCTCHAR *pFormat1 = CFSTR_RTF, *pFormat2 = CFSTR_RTFNOOBJECTS;
    if (_CB.idMap[uRtf1].serverID > _CB.idMap[uRtf2].serverID)
    {
        pFormat1 = CFSTR_RTFNOOBJECTS;
        pFormat2 = CFSTR_RTF;
    }

    _CB.idMap[uRtf1].clientID = RegisterClipboardFormat(pFormat1);
    _CB.idMap[uRtf2].clientID = RegisterClipboardFormat(pFormat2);

    TRC_DBG((TB, _T("Adding format '%s', server ID %d, client ID %d"), CFSTR_RTF, _CB.idMap[uRtf1].serverID, _CB.idMap[uRtf1].clientID));
    SetClipboardData(_CB.idMap[uRtf1].clientID, NULL);

    TRC_DBG((TB, _T("Adding format '%s', server ID %d, client ID %d"), CFSTR_RTFNOOBJECTS, _CB.idMap[uRtf2].serverID, _CB.idMap[uRtf2].clientID));
    SetClipboardData(_CB.idMap[uRtf2].clientID, NULL);

    DC_END_FN();
}
#endif  //OS_WINCE

CClipData::CClipData(PCClip pClip)
{
    DWORD status = ERROR_SUCCESS;

    DC_BEGIN_FN("CClipData::CClipData") ;

    _pClip = pClip ;
    _cRef = 0 ;
    _pImpIDataObject = NULL ;

    //
    // Initialize the single instance critical
    // section lock. This is used to ensure only one
    // thread is accessing _pImpIDataObject at the time
    //
    //
    __try
    {
        InitializeCriticalSection(&_csLock);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        status = GetExceptionCode();
    }

    if(ERROR_SUCCESS == status)
    {
        _fLockInitialized = TRUE;
    }
    else
    {
        _fLockInitialized = FALSE;
        TRC_ERR((TB,_T("InitializeCriticalSection failed 0x%x."),status));
    }

    DC_END_FN();
}

//
// Call Release() on the contained IDataObject implementation. This is necessary because
// SetNumFormats() calls AddRef() and if we are terminating, then there must be a way
// to balance this AddRef() so that the circular reference between CClipData and
// CImpIDataObject will be broken.
//

void CClipData::TearDown()
{
    if (_pImpIDataObject != NULL)
    {
        _pImpIDataObject->Release();
        _pImpIDataObject = NULL;
    }
}

CClipData::~CClipData(void)
{
    DC_BEGIN_FN("CClipData::~CClipData");

    if(_fLockInitialized)
    {
        DeleteCriticalSection(&_csLock);
    }

    DC_END_FN();
}

HRESULT DCINTERNAL CClipData::SetNumFormats(ULONG numFormats)
{
    HRESULT hr = S_OK;

    DC_BEGIN_FN("CClipData::SetNumFormats");

    if (_fLockInitialized) {
        EnterCriticalSection(&_csLock);
        if (_pImpIDataObject)
        {
            _pImpIDataObject->Release();
            _pImpIDataObject = NULL;
        }
        _pImpIDataObject = new CImpIDataObject(this) ;
        if (_pImpIDataObject == NULL)
        {
            TRC_ERR((TB, _T("Unable to create IDataObject")));
            hr = E_OUTOFMEMORY;
            DC_QUIT;
        }
        else
        {
            _pImpIDataObject->AddRef() ;    
            hr = _pImpIDataObject->Init(numFormats);
            DC_QUIT_ON_FAIL(hr);
        }
        LeaveCriticalSection(&_csLock);
    }

DC_EXIT_POINT:    
    DC_END_FN();
    return hr;
}

DCVOID CClipData::SetClipData(HGLOBAL hGlobal, DCUINT clipType)
{
    DC_BEGIN_FN("CClipData::SetClipData");

    if (_fLockInitialized) {
        EnterCriticalSection(&_csLock);
        if (_pImpIDataObject != NULL) {
            _pImpIDataObject->SetClipData(hGlobal, clipType) ;
        }
        LeaveCriticalSection(&_csLock);
    }

    DC_END_FN();
}

STDMETHODIMP CClipData::QueryInterface(REFIID riid, PPVOID ppv)
{
    DC_BEGIN_FN("CClipData::QueryInterface");

    //set ppv to NULL just in case the interface isn't found
    *ppv=NULL;

    if (IID_IUnknown==riid) {
        *ppv=this;
        //AddRef any interface we'll return.
        ((LPUNKNOWN)*ppv)->AddRef();
    }
    
    if (IID_IDataObject==riid) {
        if (_fLockInitialized) {
            EnterCriticalSection(&_csLock);
            *ppv=_pImpIDataObject ;

            if (_pImpIDataObject != NULL) {
                //AddRef any interface we'll return.
                ((LPUNKNOWN)*ppv)->AddRef();
            }

            LeaveCriticalSection(&_csLock);
        }
    }
    
    if (NULL==*ppv)
        return ResultFromScode(E_NOINTERFACE);

    DC_END_FN();
    return NOERROR;
}

STDMETHODIMP_(ULONG) CClipData::AddRef(void)
{
    DC_BEGIN_FN("CClipData::AddRef");
    DC_END_FN();
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CClipData::Release(void)
{
    LONG cRef;
    DC_BEGIN_FN("CClipData::Release");

    cRef = InterlockedDecrement(&_cRef);

    if (cRef == 0)
    {
        delete this;
    }

    DC_END_FN();    
    return cRef;
}

CImpIDataObject::CImpIDataObject(LPUNKNOWN lpUnk)
{
#ifndef OS_WINCE
    byte i ;
#endif
    DC_BEGIN_FN("CImpIDataObject::CImplDataObject") ;

    _numFormats = 0 ;
    _maxNumFormats = 0 ;
    _cRef = 0 ;
    _pUnkOuter = lpUnk ;
    if (_pUnkOuter)
    {
        _pUnkOuter->AddRef();
    }
    _pFormats = NULL ;
    _pSTGMEDIUM = NULL ;
    _lastFormatRequested = 0 ;
    _cfDropEffect = (CLIPFORMAT) RegisterClipboardFormat(CFSTR_PREFERREDDROPEFFECT) ;

    DC_END_FN();
}

HRESULT CImpIDataObject::Init(ULONG numFormats)
{
    DC_BEGIN_FN("CImpIDataObject::Init") ;
    HRESULT hr = S_OK;
    
    _maxNumFormats = numFormats ;

    // Allocate space for the formats only
    if (_pFormats) {
        LocalFree(_pFormats);
    }
    _pFormats = (LPFORMATETC) LocalAlloc(LPTR,_maxNumFormats*sizeof(FORMATETC)) ;
    if (NULL == _pFormats) {
        TRC_ERR((TB,_T("failed to allocate _pFormats")));
        hr = E_OUTOFMEMORY;
        DC_QUIT;
    }
    
    if (_pSTGMEDIUM) {
        LocalFree(_pSTGMEDIUM);
    }
    _pSTGMEDIUM = (STGMEDIUM*) LocalAlloc(LPTR, sizeof(STGMEDIUM)) ;
    if (NULL == _pSTGMEDIUM)
    {
        TRC_ERR((TB,_T("Failed to allocate STGMEDIUM")));
        hr = E_OUTOFMEMORY;
        DC_QUIT;
    }
        
    _pSTGMEDIUM->tymed = TYMED_HGLOBAL ;
    _pSTGMEDIUM->pUnkForRelease = NULL ;
    _pSTGMEDIUM->hGlobal = NULL ;

    _uiSTGType = 0;

DC_EXIT_POINT:    
    DC_END_FN();
    return hr;
}
DCVOID CImpIDataObject::SetClipData(HGLOBAL hGlobal, DCUINT clipType)
{
    DC_BEGIN_FN("CImpIDataObject::SetClipData");

    if (!_pSTGMEDIUM)    
        _pSTGMEDIUM = (STGMEDIUM*) LocalAlloc(LPTR, sizeof(STGMEDIUM)) ;
    if (NULL != _pSTGMEDIUM)
    {
        if (CF_PALETTE == clipType) {
            _pSTGMEDIUM->tymed = TYMED_GDI;
        }
        else if (CF_METAFILEPICT == clipType) {
            _pSTGMEDIUM->tymed = TYMED_MFPICT;
        }
        else {
            _pSTGMEDIUM->tymed = TYMED_HGLOBAL;
        }

        _pSTGMEDIUM->pUnkForRelease = NULL ;
        FreeSTGMEDIUM();
       
        _pSTGMEDIUM->hGlobal = hGlobal ;
        _uiSTGType = clipType;
    }

    DC_END_FN();
}

DCVOID
CImpIDataObject::FreeSTGMEDIUM(void)
{
    if ( NULL == _pSTGMEDIUM->hGlobal )
    {
        return;
    }

    switch( _uiSTGType )
    {
    case CF_PALETTE:
        DeleteObject( _pSTGMEDIUM->hGlobal );
    break;
#ifndef OS_WINCE
    case CF_METAFILEPICT:
    {
        LPMETAFILEPICT pMFPict = (LPMETAFILEPICT)GlobalLock( _pSTGMEDIUM->hGlobal );
        if ( NULL != pMFPict )
        {
            if ( NULL != pMFPict->hMF )
            {
                DeleteMetaFile( pMFPict->hMF );
            }
            GlobalUnlock( _pSTGMEDIUM->hGlobal );
        }
        GlobalFree( _pSTGMEDIUM->hGlobal );
    }
    break;
#endif
    default:
        GlobalFree( _pSTGMEDIUM->hGlobal );
    }
    _pSTGMEDIUM->hGlobal = NULL;
}

CImpIDataObject::~CImpIDataObject(void)
{
    DC_BEGIN_FN("CImpIDataObject::~CImplDataObject") ;

    if (_pFormats)
        LocalFree(_pFormats) ;

    if (_pSTGMEDIUM)
    {
        FreeSTGMEDIUM();
        LocalFree(_pSTGMEDIUM) ;
    }

    if (_pUnkOuter)
    {
        _pUnkOuter->Release();
        _pUnkOuter = NULL;
    }
    DC_END_FN();
}

// IUnknown members
// - Delegate to "outer" IUnknown 
STDMETHODIMP CImpIDataObject::QueryInterface(REFIID riid, PPVOID ppv)
{
    DC_BEGIN_FN("CImpIDataObject::QueryInterface");
    DC_END_FN();
    return _pUnkOuter->QueryInterface(riid, ppv);
}

STDMETHODIMP_(ULONG) CImpIDataObject::AddRef(void)
{
    DC_BEGIN_FN("CImpIDataObject::AddRef");

    InterlockedIncrement(&_cRef);

    DC_END_FN();
    return _pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) CImpIDataObject::Release(void)
{
    LONG cRef;

    DC_BEGIN_FN("CImpIDataObject::Release");

    _pUnkOuter->Release();

    cRef = InterlockedDecrement(&_cRef) ;
    if (0 == cRef)
        delete this;

    DC_END_FN() ;
    return cRef;
}

// IDataObject members
// ***************************************************************************
// CImpIDataObject::GetData
// - Here, we have to wait for the data to actually get here before we return.  
// ***************************************************************************
STDMETHODIMP CImpIDataObject::GetData(LPFORMATETC pFE, LPSTGMEDIUM pSTM)
{
    HRESULT          result = E_FAIL; // Assume we fail until we know we haven't
#ifndef OS_WINCE
    TCHAR            formatName[TS_FORMAT_NAME_LEN] ;
    byte             charSize ;
    BOOL             fWide ;
    WCHAR*           fileListW ;
    HPDCVOID         pFilename ;
    HPDCVOID         pOldFilename ;    
#endif
    HGLOBAL          hData = NULL ;    
    HPDCVOID         pData ;
    HPDCVOID         pOldData ;
#ifndef OS_WINCE
    DROPFILES*       pDropFiles ;
    DROPFILES        tempDropfile ;
    ULONG            oldSize ;
    ULONG            newSize ;
#endif
    DWORD            eventSignaled ;
    DWORD*           pDropEffect ;
#ifndef OS_WINCE
    char*            fileList ;
#endif
    PCClip           pClip ;
    
    DC_BEGIN_FN("CImpIDataObject::GetData");

    // Should never occur, but we check for sanity's sake
    if (NULL == (PCClipData)_pUnkOuter)
    {
        TRC_ERR((TB, _T("Ptr to outer unknown is NULL"))) ;
        result = E_FAIL ;
        DC_QUIT ;
    }
    if (NULL == ((PCClipData)_pUnkOuter)->_pClip)
    {
        TRC_ERR((TB, _T("Ptr to clip class is NULL"))) ;
        result = E_FAIL ;
        DC_QUIT ;
    }
    // Since we need to have the CClip class do work for us,
    // we pull out a pointer to it that we stored in the beginning
    pClip = (PCClip) ((PCClipData)_pUnkOuter)->_pClip ;
    
    if (!_pSTGMEDIUM)
    {
        TRC_ERR((TB, _T("Transfer medium (STGMEDIUM) is NULL"))) ;
        result = E_FAIL ;
        DC_QUIT ;
    }

    TRC_ASSERT( pClip->IsDataSyncReady(),
        (TB, _T("Data Sync not ready")));
    
    if (!_pSTGMEDIUM->hGlobal || (pFE->cfFormat != _lastFormatRequested))
    {
        TRC_ASSERT( pClip->IsDataSyncReady(),
            (TB,_T("data sync is NULL")));  
        
        ResetEvent(pClip->_GetDataSync[TS_RESET_EVENT]) ;
        if (!((PCClipData)_pUnkOuter)->_pClip->ClipGetData(pFE->cfFormat))
        {
            result = E_FAIL ;
            DC_QUIT ;
        }
        eventSignaled = WaitForMultipleObjects(
                            TS_NUM_EVENTS, 
                            ((PCClipData)_pUnkOuter)->_pClip->_GetDataSync,
                            FALSE,
                            INFINITE
                        ) ;
        if ((WAIT_OBJECT_0+TS_RESET_EVENT) == eventSignaled)
        {
            TRC_NRM((TB, _T("Other thread told us to reset.  Failing GetData"))) ;
            ResetEvent(((PCClipData)_pUnkOuter)->_pClip->_GetDataSync[TS_RESET_EVENT]) ;
            result = E_FAIL ;
            DC_QUIT ;
        }

        // Make sure that we actually got data from the server.

        if (_pSTGMEDIUM->hGlobal == NULL) {
            TRC_ERR((TB, _T("No format data received from server!")));
            result = E_FAIL;
            DC_QUIT;
        }

#ifndef OS_WINCE
        if (CF_HDROP == pFE->cfFormat)
        {
            // if we got an HDROP and we're not NT/2000, we check to see if we
            // have to convert to ansi; otherwise, we're done
            if (pClip->GetOsMinorType() != TS_OSMINORTYPE_WINDOWS_NT)
            {
                pDropFiles = (DROPFILES*) GlobalLock(_pSTGMEDIUM->hGlobal) ;
                if (!pDropFiles)
                {
                    TRC_ERR((TB, _T("Failed to lock %p"), hData)) ;
                    result = E_FAIL ;
                    DC_QUIT ;
                }
                // if we definitely have wide characters, then convert
                if (pDropFiles->fWide)
                {
                    // temporarily store the original's base dropfile info
                    tempDropfile.pFiles = pDropFiles->pFiles ;
                    tempDropfile.pt     = pDropFiles->pt ;
                    tempDropfile.fNC    = pDropFiles->fNC ;
                    tempDropfile.fWide  = 0 ; // we are converting to ANSI now
        
                    // We divide by the size of wchar_t because we need half as many
                    // bytes with ansi as opposed to fWide character strings
                    oldSize = (ULONG) GlobalSize(_pSTGMEDIUM->hGlobal) - pDropFiles->pFiles ;
                    newSize = oldSize / sizeof(WCHAR) ;
                    fileList = (char*) (LocalAlloc(LPTR,newSize)) ;
                    if ( NULL == fileList )
                    {
                        TRC_ERR((TB, _T("Unable to allocate %d bytes"), newSize ));
                        result = E_FAIL;
                        DC_QUIT;
                    }

                    // This will convert the wide HDROP filelist to ansi, and
                    // put the ansi version into filelist
                    //   11-12
                    // pDropFiles is probably "foo\0bar\0baz\0\0"
                    // I don't believe WC2MB will go past the first \0
                    if (!WideCharToMultiByte(GetACP(), NULL, (wchar_t*) 
                               ((byte*) pDropFiles + pDropFiles->pFiles), 
                               newSize, fileList, 
                               newSize, NULL, NULL))
                    {
                        TRC_ERR((TB, _T("Unable convert wide to ansi"), newSize)) ;
                        LocalFree( fileList );
                        result = E_FAIL ;
                        DC_QUIT ;
                    }
                    // Output the first filename for a sanity check
                    TRC_NRM((TB, _T("Filename 1 = %hs"), fileList)) ;
                    
                    GlobalUnlock(_pSTGMEDIUM->hGlobal) ;
                    // Reallocate the space for the dropfile
                    hData = GlobalAlloc(GMEM_DISCARDABLE | GMEM_MOVEABLE, 
                            newSize + tempDropfile.pFiles) ;
                    if (!hData)
                    {
                        TRC_ERR((TB, _T("Allocate memory; err=%d"), GetLastError())) ;
                        LocalFree( fileList );
                        result = E_FAIL ;
                        DC_QUIT ;
                    }
                    pDropFiles = (DROPFILES*) GlobalLock(hData) ;
                    if (!pDropFiles)
                    {
                        TRC_ERR((TB, _T("Unable to lock %p"), hData)) ;
                        LocalFree( fileList );
                        result = E_FAIL ;
                        DC_QUIT ;
                    }
                    pDropFiles->pFiles = tempDropfile.pFiles ;
                    pDropFiles->pt     = tempDropfile.pt ;
                    pDropFiles->fNC    = tempDropfile.fNC ;
                    pDropFiles->fWide  = tempDropfile.fWide ;
                    DC_MEMCPY((byte*) pDropFiles + pDropFiles->pFiles,
                            fileList, newSize) ;
                    // Output the first filename for another sanity check
                    TRC_NRM((TB, _T("Filename = %s"), (byte*) pDropFiles + pDropFiles->pFiles)) ;
                    LocalFree( fileList );
                }
                GlobalUnlock(hData) ;
                GlobalFree(_pSTGMEDIUM->hGlobal) ;
                _pSTGMEDIUM->hGlobal = hData ;
            }
        }
#else
        if (gfmtShellPidlArray == pFE->cfFormat)
        {
            HANDLE hNewData = HDropToIDList(_pSTGMEDIUM->hGlobal);
            GlobalFree(_pSTGMEDIUM->hGlobal);
            _pSTGMEDIUM->hGlobal = hNewData; 
        }
#endif
        // We check the dropeffect format, because we strip out 
        // shortcuts/links, and store the dropeffects.  The dropeffect is
        // what some apps (explorer) use to decide if they should copy, move
        // or link
        else if (_cfDropEffect == pFE->cfFormat)
        {
            if (GlobalSize(_pSTGMEDIUM->hGlobal) < sizeof(DWORD)) {
                TRC_ERR((TB, _T("Unexpected global memory size!")));
                result = E_FAIL;
                DC_QUIT;
            }

            pDropEffect = (DWORD*) GlobalLock(_pSTGMEDIUM->hGlobal) ;
            if (!pDropEffect)
            {
                TRC_NRM((TB, _T("Unable to lock %p"), _pSTGMEDIUM->hGlobal)) ;
                result = E_FAIL ;
                DC_QUIT ;
            }
            // Strip out shortcuts/links
            *pDropEffect = *pDropEffect ^ DROPEFFECT_LINK ;
            // Strip out moves
            *pDropEffect = *pDropEffect ^ DROPEFFECT_MOVE ;
            pClip->SetDropEffect(*pDropEffect) ;
            if (GlobalUnlock(_pSTGMEDIUM->hGlobal))
            {
                TRC_ASSERT(GetLastError() == NO_ERROR,
                        (TB, _T("Unable to unlock HGLOBAL we just locked"))) ;
            }
        }
        pSTM->tymed = _pSTGMEDIUM->tymed ;
        pSTM->hGlobal = _pSTGMEDIUM->hGlobal ;  
        _pSTGMEDIUM->hGlobal = NULL;
        pSTM->pUnkForRelease = _pSTGMEDIUM->pUnkForRelease ;
        result = S_OK ;
        DC_QUIT ;
    }
    else
    {
        pSTM->tymed = _pSTGMEDIUM->tymed ;
        pSTM->hGlobal = GlobalAlloc(GMEM_DISCARDABLE | GMEM_MOVEABLE,
        GlobalSize(_pSTGMEDIUM->hGlobal)) ;
        pData = GlobalLock(pSTM->hGlobal) ;
        pOldData = GlobalLock(_pSTGMEDIUM->hGlobal) ;
        if (!pData || !pOldData)
            return E_FAIL ;
        DC_MEMCPY(pData, pOldData, GlobalSize(_pSTGMEDIUM->hGlobal)) ;
        GlobalUnlock(pSTM->hGlobal) ;
        GlobalUnlock(_pSTGMEDIUM->hGlobal) ;

        pSTM->pUnkForRelease = _pSTGMEDIUM->pUnkForRelease ;
    }
    
    if (!pSTM->hGlobal)
    {
        TRC_NRM((TB, _T("Clipboard data request failed"))) ;
        return E_FAIL ;
    }
DC_EXIT_POINT:

    DC_END_FN();
    return result ;
}

STDMETHODIMP CImpIDataObject::GetDataHere(LPFORMATETC pFE, LPSTGMEDIUM pSTM)
{
    DC_BEGIN_FN("CImpIDataObject::GetDataHere") ;
    DC_END_FN();
    return ResultFromScode(E_NOTIMPL) ;
}

STDMETHODIMP CImpIDataObject::QueryGetData(LPFORMATETC pFE)
{
    ULONG i = 0 ;
    HRESULT hr = DV_E_CLIPFORMAT ;
    
    DC_BEGIN_FN("CImpIDataObject::QueryGetData") ;

    TRC_NRM((TB, _T("Format ID %d requested"), pFE->cfFormat)) ;
    while (i < _numFormats)
    {
        if (_pFormats[i].cfFormat == pFE->cfFormat) {
            hr = S_OK ;
            break ;
        }
        i++ ;
    }    

    DC_END_FN();
    return hr ;
}

STDMETHODIMP CImpIDataObject::GetCanonicalFormatEtc(LPFORMATETC pFEIn, LPFORMATETC pFEOut)
{
    DC_BEGIN_FN("CImpIDataObject::GetCanonicalFormatEtc") ;
    DC_END_FN();
    return ResultFromScode(E_NOTIMPL) ;
}

// ***************************************************************************
// CImpIDataObject::SetData
// - Due to the fact that the RDP only passes the simple clipboard format, and
//   the fact that we obtain all of our clipboard data from memory later, pSTM
//   is really ignored at this point.  It isn't until GetData is called that
//   the remote clipboard data is received, and a valid global memory handle
//   is generated.
// - Thus, pSTM and fRelease are ignored.
// - So out _pSTGMEDIUM is generated using generic values
// ***************************************************************************

STDMETHODIMP CImpIDataObject::SetData(LPFORMATETC pFE, LPSTGMEDIUM pSTM, BOOL fRelease)
{
    TCHAR   formatName[TS_FORMAT_NAME_LEN] = {0} ;
    byte i ;
    DC_BEGIN_FN("CImpIDataObject::SetData");

    DC_IGNORE_PARAMETER(pSTM) ;
    
    // Reset the the last format requested to 0
    _lastFormatRequested = 0 ;

    TRC_NRM((TB, _T("Adding format %d to IDataObject"), pFE->cfFormat)) ;
    
    if (_numFormats < _maxNumFormats)
    {
        for (i=0; i < _numFormats; i++)
        {
            if (pFE->cfFormat == _pFormats[i].cfFormat)
            {
                TRC_NRM((TB, _T("Duplicate format.  Discarded"))) ;
                return DV_E_FORMATETC ;
            }
        }
        _pFormats[_numFormats] = *pFE ;        
        _numFormats++ ;
    }
    else
    {
        TRC_ERR((TB, _T("Cannot add any more formats"))) ;
        return E_FAIL ;
    }

    DC_END_FN();
    return S_OK ;
}

STDMETHODIMP CImpIDataObject::EnumFormatEtc(DWORD dwDir, LPENUMFORMATETC *ppEnum)
{
    PCEnumFormatEtc     pEnum;

    *ppEnum=NULL;

    /*
     * From an external point of view there are no SET formats,
     * because we want to allow the user of this component object
     * to be able to stuff ANY format in via Set.  Only external
     * users will call EnumFormatEtc and they can only Get.
     */

    switch (dwDir)
    {
        case DATADIR_GET:
             pEnum=new CEnumFormatEtc(_pUnkOuter);
             break;

        case DATADIR_SET:
        default:
             pEnum=new CEnumFormatEtc(_pUnkOuter);
             break;
    }

    if (NULL==pEnum)
        return ResultFromScode(E_FAIL);
    else
    {
        //Let the enumerator copy our format list.
        pEnum->Init(_pFormats, _numFormats) ;

        pEnum->AddRef();
    }

    *ppEnum=pEnum;    
    return NO_ERROR ;
}
STDMETHODIMP CImpIDataObject::DAdvise(LPFORMATETC pFE, DWORD dwFlags, 
                     LPADVISESINK pIAdviseSink, LPDWORD pdwConn)
{
    return ResultFromScode(E_NOTIMPL) ;
}
STDMETHODIMP CImpIDataObject::DUnadvise(DWORD dwConn)
{
    return ResultFromScode(E_NOTIMPL) ;
}
STDMETHODIMP CImpIDataObject::EnumDAdvise(LPENUMSTATDATA *ppEnum)
{
    return ResultFromScode(E_NOTIMPL) ;
}

CEnumFormatEtc::CEnumFormatEtc(LPUNKNOWN pUnkRef)
{
    DC_BEGIN_FN("CEnumFormatEtc::CEnumFormatEtc");

    _cRef = 0 ;
    _pUnkRef = pUnkRef ;
    if (_pUnkRef)
    {
        _pUnkRef->AddRef();
    }
    _iCur = 0;

    DC_END_FN() ;
}

DCVOID CEnumFormatEtc::Init(LPFORMATETC pFormats, ULONG numFormats)
{
    DC_BEGIN_FN("CEnumFormatEtc::Init");

    _cItems = numFormats;
    _pFormats = (LPFORMATETC) LocalAlloc(LPTR,_cItems*sizeof(FORMATETC)) ;
    if (_pFormats)
    {
        memcpy(_pFormats, pFormats, _cItems*sizeof(FORMATETC)) ;
    }
    else
    {
        TRC_ERR((TB, _T("Unable to allocate memory for formats"))) ;
    }

    DC_END_FN() ;
}
CEnumFormatEtc::~CEnumFormatEtc()
{
    DC_BEGIN_FN("CEnumFormatEtc::~CEnumFormatEtc");
    if (_pUnkRef)
    {
        _pUnkRef->Release();
        _pUnkRef = NULL;
    }
    if (NULL !=_pFormats)
        LocalFree(_pFormats) ;
    DC_END_FN() ;
}

STDMETHODIMP CEnumFormatEtc::QueryInterface(REFIID riid, PPVOID ppv)
{
    DC_BEGIN_FN("CEnumFormatEtc::QueryInterface");
    *ppv=NULL;

    /*
     * Enumerators are separate objects, not the data object, so
     * we only need to support out IUnknown and IEnumFORMATETC
     * interfaces here with no concern for aggregation.
     */
    if (IID_IUnknown==riid || IID_IEnumFORMATETC==riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    DC_END_FN() ;
    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CEnumFormatEtc::AddRef(void)
{
    LONG cRef;

    cRef = InterlockedIncrement(&_cRef);

    _pUnkRef->AddRef();

    return cRef;
}

STDMETHODIMP_(ULONG) CEnumFormatEtc::Release(void)
{
    LONG cRef;
    DC_BEGIN_FN("CEnumFormatEtc::Release");

    _pUnkRef->Release();

    cRef = InterlockedDecrement(&_cRef) ;
    if (0 == cRef)
        delete this;

    DC_END_FN() ;
    return cRef;
}

STDMETHODIMP CEnumFormatEtc::Next(ULONG cFE, LPFORMATETC pFE, ULONG *pulFE)
{
    ULONG           cReturn=0L;

    if (NULL==_pFormats)
        return ResultFromScode(S_FALSE);

    if (NULL==pulFE)
    {
        if (1L!=cFE)
            return ResultFromScode(E_POINTER);
    }
    else
        *pulFE=0L;

    if (NULL==pFE || _iCur >= _cItems)
        return ResultFromScode(S_FALSE);

    while (_iCur < _cItems && cFE > 0)
    {
        *pFE=_pFormats[_iCur];
        pFE++;
        _iCur++;
        cReturn++;
        cFE--;
    }

    if (NULL!=pulFE)
        *pulFE=cReturn;

    return NOERROR;
}

STDMETHODIMP CEnumFormatEtc::Skip(ULONG cSkip)
{
    if ((_iCur+cSkip) >= _cItems)
        return ResultFromScode(S_FALSE);

    _iCur+=cSkip;
    return NOERROR;
}


STDMETHODIMP CEnumFormatEtc::Reset(void)
{
    _iCur=0;
    return NOERROR;
}


STDMETHODIMP CEnumFormatEtc::Clone(LPENUMFORMATETC *ppEnum)
{
#ifndef OS_WINCE
    PCEnumFormatEtc     pNew = NULL;
    LPMALLOC            pIMalloc;
    LPFORMATETC         prgfe;
    BOOL                fRet=TRUE;
    ULONG               cb;

    *ppEnum=NULL;
#else
    BOOL                fRet=FALSE;
#endif

#ifndef OS_WINCE
    //Copy the memory for the list.
    if (FAILED(CoGetMalloc(MEMCTX_TASK, &pIMalloc)))
        return ResultFromScode(E_OUTOFMEMORY);

    cb=_cItems*sizeof(FORMATETC);
    prgfe=(LPFORMATETC)pIMalloc->Alloc(cb);

    if (NULL!=prgfe)
    {
        //Copy the formats
        memcpy(prgfe, _pFormats, (int)cb);

        //Create the clone
        pNew=new CEnumFormatEtc(_pUnkRef);

        if (NULL != pNew)
        {
            pNew->_iCur=_iCur;
            pNew->_pFormats=prgfe;
            pNew->AddRef();
            fRet=TRUE;
        }
        else
        {
            fRet = FALSE;
        }
    }

    pIMalloc->Release();

    *ppEnum=pNew;
#endif
    return fRet ? NOERROR : ResultFromScode(E_OUTOFMEMORY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\mstscax\vchannel.h ===
/**INC+**********************************************************************/
/* Header: vchannel.h                                                       */
/*                                                                          */
/* Purpose: virtual channel interaction                                     */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1999                                  */
/*                                                                          */
/****************************************************************************/

#ifndef __VCHANNEL_H_
#define __VCHANNEL_H_

#include <cchannel.h>
//
// Include the core (internal) virtual channel header
// we need access to the structure pointed to by pInitHandle
//
#include "vchandle.h"

#define NOTHING                0
#define NON_V1_CONNECT         1
#define V1_CONNECT             2

BEGIN_EXTERN_C
//
// Virtual channel functions
//
VOID  WINAPI VirtualChannelOpenEventEx(
                                     PVOID lpParam,
                                     DWORD openHandle, 
                                     UINT event, 
                                     LPVOID pdata, 
                                     UINT32 dataLength, 
                                     UINT32 totalLength, 
                                     UINT32 dataFlags);

VOID  VCAPITYPE VirtualChannelInitEventProcEx(PVOID lpParam,
                                            LPVOID pInitHandle, 
                                            UINT event, 
                                            LPVOID pData, 
                                            UINT dataLength);

BOOL  VCAPITYPE MSTSCAX_VirtualChannelEntryEx(PCHANNEL_ENTRY_POINTS_EX pEntryPointsEx,
                                      PVOID                    pAxCtlInstance);
END_EXTERN_C


enum ChanDataState
{
    //
    // For received items
    //
    dataIncompleteAssemblingChunks,
    dataReceivedComplete
};

//
// Holds queued data that is to be sent/received
//
typedef struct tag_ChannelDataItem
{
    //
    // Pointer to the data buffer
    // this buffer is stored in a BSTR
    // so it can be handed directly to the calling script
    // 
    LPVOID pData;
    //
    // size of the buffer in bytes
    //
    DWORD   dwDataLen;

    //
    // Current write pointer used during chunk reassembly
    //
    LPBYTE pCurWritePointer;

    ChanDataState   chanDataState;;
} CHANDATA, *PCHANDATA;

typedef struct tag_chanInfo
{
    DCACHAR  chanName[CHANNEL_NAME_LEN + 1];
    DWORD    dwOpenHandle;
    BOOL     fIsValidChannel;
    LONG     channelOptions;

    DCBOOL   fIsOpen;
    HWND     hNotifyWnd;
    //
    // Info about data item we are in the process of receiving
    //
    CHANDATA CurrentlyReceivingData;

} CHANINFO, *PCHANINFO;

//
// Channel information
//
class CVChannels
{
public:
    CVChannels();
    ~CVChannels();

    DCINT  ChannelIndexFromOpenHandle(DWORD dwHandle);
    DCINT  ChannelIndexFromName(PDCACHAR szChanName);
    DCBOOL SendDataOnChannel(DCUINT chanIndex, LPVOID pdata, DWORD datalength);
    DCBOOL HandleReceiveData(IN DCUINT chanIndex, 
                                  IN LPVOID pdata, 
                                  IN UINT32 dataLength, 
                                  IN UINT32 totalLength, 
                                  IN UINT32 dataFlags);
    VOID  VCAPITYPE IntVirtualChannelInitEventProcEx(LPVOID pInitHandle, 
                                  UINT event, 
                                  LPVOID pData, 
                                  UINT dataLength);
    VOID  WINAPI IntVirtualChannelOpenEventEx(
                                  DWORD openHandle, 
                                  UINT event, 
                                  LPVOID pdata, 
                                  UINT32 dataLength, 
                                  UINT32 totalLength, 
                                  UINT32 dataFlags);

    //Predicate, returns true if the VC entry function
    //has been called
    BOOL  HasEntryBeenCalled()  {return _pEntryPoints ? TRUE : FALSE;}

    PCHANINFO                                _pChanInfo;
    PCHANNEL_ENTRY_POINTS_EX                 _pEntryPoints;
    DWORD                                    _dwConnectState;
    LPVOID                                   _phInitHandle;
    UINT                                     _ChanCount;
    HWND                                     _hwndControl;
};



#endif //__VCHANNEL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\drconfig.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    drconfig.h

Abstract:

    Configurable Parameter Names for RDP Device Redirection

    Use ProcObj::GetDWordParameter() and ProcObj::GetStringParameter()
    to fetch values.

Author:

    Tad Brockway (tadb) 28-June-1999

Revision History:

--*/

#ifndef __DRCONFIG_H__
#define __DRCONFIG_H__


//  Value for disabling device redirection
#define RDPDR_DISABLE_DR_PARAM                  _T("DisableDeviceRedirection")
#define RDPDR_DISABLE_DR_PARAM_DEFAULT          FALSE

//  Log file name.  No file logging is performed if this registry value 
//  is not present or is invalid.
#define RDPDR_LOGFILE_PARAM                     _T("LogFileName")
#define RDPDR_LOGFILE_PARAM_DEFAULT             _T("")

//  Number of MAX COM Port when Scanning for Client COM Ports to Redirect.
#define RDPDR_COM_PORT_MAX_PARAM                _T("COMPortMax")
#define RDPDR_COM_PORT_MAX_PARAM_DEFAULT        32

//  Number of MAX LPT Port when Scanning for Client LPT Ports to Redirect.
#define RDPDR_LPT_PORT_MAX_PARAM                _T("LPTPortMax")
#define RDPDR_LPT_PORT_MAX_PARAM_DEFAULT        10

//  Mask for tracing device-specific transaction information.
#define RDPDR_DEVICE_TRACE_MASK_PARAM           _T("DeviceTraceMask")
#define RDPDR_DEVICE_TRACE_MASK_PARAM_DEFAULT   0x0


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\drdbg.cpp ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    drdbg

Abstract:
    
    Contains Debug Routines for TS Device Redirector Component, 
    RDPDR.DLL.

Author:

    Tad Brockway 8/25/99

Revision History:

--*/

#include "precom.h"

#define TRC_FILE  "drdbg"

#include "atrcapi.h"
#include "drdbg.h"

#if DBG

typedef struct tagRDPDR_MEMHDR
{
    DWORD       magicNo;
    DWORD       tag;
    DWORD       size;
    HGLOBAL     hGlobal;
} RDPDR_MEMHDR, *PRDPDR_MEMHDR;

void *
DrAllocateMem(
    IN size_t size, 
    IN DWORD tag   
    )
/*++

Routine Description:

    Allocate memory.  Similiar to malloc.

Arguments:

    size        -   Number of bytes to allocate.
    tag         -   Tag identifying the allocated block for tracking
                    memory allocations.

Return Value:

    Pointer to allocated memory on success.  Otherwise, NULL is returned.

--*/
{
    PRDPDR_MEMHDR hdr;
    PBYTE p;
    HGLOBAL hGlobal;

    DC_BEGIN_FN("DrAllocateMem");

    hGlobal = GlobalAlloc(LMEM_FIXED, size + sizeof(RDPDR_MEMHDR));
    if (hGlobal == NULL) {
        DC_END_FN();
        return NULL;
    }

    hdr = (PRDPDR_MEMHDR)GlobalLock(hGlobal);
    if (hdr != NULL) {
        hdr->magicNo = GOODMEMMAGICNUMBER;
        hdr->tag  = tag;
        hdr->size = size;
        hdr->hGlobal = hGlobal;

        p = (PBYTE)(hdr + 1);
        memset(p, UNITIALIZEDMEM, size);
        DC_END_FN();
        return (void *)p;
    }
    else {
        DC_END_FN();
        return NULL;
    }
}

void 
DrFreeMem(
    IN void *ptr
    )
/*++

Routine Description:

    Release memory allocated by a call to DrAllocateMem.

Arguments:

    ptr -   Block of memory allocated by a call to DrAllocateMem.

Return Value:

    NA

--*/
{
    PRDPDR_MEMHDR hdr;
    HGLOBAL hGlobal;

    DC_BEGIN_FN("DrFreeMem");

    ASSERT(ptr != NULL);

    //
    //  Get a pointer to the header to the memory block.
    //
    hdr = (PRDPDR_MEMHDR)ptr;
    hdr--;

    //
    //  Make sure the block is valid.
    //
    ASSERT(hdr->magicNo == GOODMEMMAGICNUMBER);

    //
    //  Mark it as freed.
    //
    hdr->magicNo = FREEDMEMMAGICNUMBER;

    //
    //  Scramble and free the memory.
    //
    memset(ptr, DRBADMEM, (size_t)hdr->size);
    hGlobal = hdr->hGlobal;
    GlobalUnlock(hGlobal);
    GlobalFree(hGlobal);

    DC_END_FN();
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\cclipapi.h ===
/****************************************************************************/
/* Header:    cclipapi.h                                                    */
/*                                                                          */
/* Purpose:   Define Clip Client Addin API functions                        */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1998                                  */
/*                                                                          */
/**INC-**********************************************************************/

#ifndef _H_CCLIPAPI
#define _H_CCLIPAPI

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


BOOL VCAPITYPE VCEXPORT ClipChannelEntry(PCHANNEL_ENTRY_POINTS pEntryPoints);

VOID VCAPITYPE VCEXPORT ClipInitEventFn(LPVOID pInitHandle,
                                        UINT   event,
                                        LPVOID pData,
                                        UINT   dataLength);
#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* _H_CCLIPAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\cclipdat.h ===
/**INC+**********************************************************************/
/* Header:    cclipdat.h                                                    */
/*                                                                          */
/* Purpose:   Clip Client Addin data                                        */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1998-1999                             */
/*                                                                          */
/**INC-**********************************************************************/

#ifndef _H_CCLIPDAT
#define _H_CCLIPDAT

#include <adcgdata.h>

/****************************************************************************/
/* Number of excluded formats                                               */
/****************************************************************************/
#ifndef OS_WINCE
#define CB_EXCLUDED_FORMAT_COUNT   8
#define CB_EXCLUDED_FORMAT_COUNT_NO_RD   17
#else
#define CB_EXCLUDED_FORMAT_COUNT   9
#define CB_EXCLUDED_FORMAT_COUNT_NO_RD   18
#endif

class CClip ;
typedef CClip *PCClip ;

class CImpIDataObject ;
typedef CImpIDataObject *PCImpIDataObject ;

class CEnumFormatEtc ;

class CClipData : public IUnknown
{
friend CImpIDataObject ;
friend CEnumFormatEtc ;

private:
    LONG    _cRef ;
    TS_CLIP_PDU     _ClipPDU ;
    PCClip          _pClip ;
    PCImpIDataObject    _pImpIDataObject ;
    CRITICAL_SECTION _csLock;
    BOOL _fLockInitialized;

public:
    CClipData(PCClip);
    ~CClipData(void);

    void TearDown();

    HRESULT DCINTERNAL SetNumFormats(ULONG);
    DCVOID SetClipData(HGLOBAL, DCUINT) ;

    //IUnknown members that delegate to _pUnkOuter.
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
} ;

typedef CClipData *PCClipData ;

class CImpIDataObject : public IDataObject
{
private:
    LONG           _cRef;
    LPUNKNOWN       _pUnkOuter;
    ULONG           _maxNumFormats ;
    ULONG           _numFormats ;      // Current number of formats in IDataObject
    LPFORMATETC     _pFormats ;        // Buffer of [_maxNumFormats] FORMATETC's
    LPSTGMEDIUM     _pSTGMEDIUM ;      // Our fixed STGMEDIUM (always an HGLOBAL)
    DCUINT          _uiSTGType ;       // type of the STGMEDIUM content (clip type CF_*)

    // _lastFormatRequested is used to see if we can avoid re-requesting the
    // same data twice over the wire.
    CLIPFORMAT      _lastFormatRequested ;
    CLIPFORMAT      _cfDropEffect ;

    DCVOID
    FreeSTGMEDIUM(void);
    
public:
    PTS_CLIP_PDU    _pClipPDU ;
    CImpIDataObject(LPUNKNOWN);
    ~CImpIDataObject(void);

    HRESULT Init(ULONG) ;
    DCVOID SetClipData(HGLOBAL, DCUINT) ;
    //IUnknown members that delegate to _pUnkOuter.
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

public:

    //IDataObject members
    STDMETHODIMP GetData(LPFORMATETC, LPSTGMEDIUM);
    STDMETHODIMP GetDataHere(LPFORMATETC, LPSTGMEDIUM);
    STDMETHODIMP QueryGetData(LPFORMATETC);
    STDMETHODIMP GetCanonicalFormatEtc(LPFORMATETC, LPFORMATETC);
    STDMETHODIMP SetData(LPFORMATETC, LPSTGMEDIUM, BOOL);
    STDMETHODIMP EnumFormatEtc(DWORD, LPENUMFORMATETC *);
    STDMETHODIMP DAdvise(LPFORMATETC, DWORD
                 ,  LPADVISESINK, DWORD *);
    STDMETHODIMP DUnadvise(DWORD);
    STDMETHODIMP EnumDAdvise(LPENUMSTATDATA *);
};

class CEnumFormatEtc : public IEnumFORMATETC
{
private:
    LONG           _cRef;
    LPUNKNOWN       _pUnkRef;
    LPFORMATETC     _pFormats;
    ULONG           _iCur;
    ULONG           _cItems;

public:
    CEnumFormatEtc(LPUNKNOWN);
    ~CEnumFormatEtc(void);
    DCVOID Init(LPFORMATETC, ULONG) ;

    //IUnknown members that delegate to _pUnkOuter.
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IEnumFORMATETC members
    STDMETHODIMP Next(ULONG, LPFORMATETC, ULONG *);
    STDMETHODIMP Skip(ULONG);
    STDMETHODIMP Reset(void);
    STDMETHODIMP Clone(IEnumFORMATETC **);
};

typedef CEnumFormatEtc *PCEnumFormatEtc;

#if ((defined (OS_WINNT)) || ((defined (OS_WINCE)) && (_WIN32_WCE >= 300) ))
#define USE_SEMAPHORE
#endif
/**STRUCT+*******************************************************************/
/* Structure: CLIP_DATA                                                     */
/*                                                                          */
/* Description: Shared Clip global data                                     */
/****************************************************************************/
typedef struct tagCLIP_DATA
{
    /************************************************************************/
    /* Clipboard viewer chain information                                   */
    /************************************************************************/
    HWND            viewerWindow;
    HWND            nextViewer;

    /************************************************************************/
    /* Our state information                                                */
    /************************************************************************/
    DCBOOL          moreToDo;
    DCBOOL          pendingClose;
    DCUINT          state;
    DCBOOL          rcvOpen;
    DCBOOL          clipOpen;
    DCUINT16        failType;

    /************************************************************************/
    /* Send and receive buffers                                             */
    /************************************************************************/
#ifdef USE_SEMAPHORE
#define CB_PERM_BUF_COUNT 1
    
    //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    //txPermBuffer buffer must be aligned on a processor
    //word boundary
    //The placement of the HANDLE before
    //the field must NOT be changed.
    HANDLE          txPermBufSem;
    DCUINT8         txPermBuffer[CHANNEL_CHUNK_LENGTH];
#else
#define CB_PERM_BUF_COUNT 2
    DCUINT8         txPermBuffer[CB_PERM_BUF_COUNT][CHANNEL_CHUNK_LENGTH];
    DCBOOL          txPermBufInUse[CB_PERM_BUF_COUNT];
#endif

    HPDCUINT8       rxpBuffer;          /* pointer to start of buffer       */
    HPDCUINT8       rxpBufferCurrent;   /* current location in buffer       */
    DCUINT32        rxBufferLen;        /* size of buffer                   */
    DCUINT32        rxBufferLeft;       /* bytes left to receive            */

    /************************************************************************/
    /* Server/client format ID map                                          */
    /************************************************************************/
    CB_FORMAT_MAP   idMap[CB_MAX_FORMATS];

    /************************************************************************/
    /* other useful data                                                    */
    /************************************************************************/
    DCUINT          pendingClientID;
    DCUINT          pendingServerID;
    DCBOOL          DIBFormatExists;

    /************************************************************************/
    /* Channel API stuff                                                    */
    /************************************************************************/
    ULONG            channelHandle;
    LPVOID           initHandle;
    HINSTANCE        hInst;
    CHANNEL_ENTRY_POINTS_EX channelEP;
    DWORD            dropEffect ; // We currently only support FO_COPY and FO_MOVE
    DWORD            dwVersion ;
    BOOL             fAlreadyCopied ;
    BOOL             fDrivesRedirected ;
    BOOL             fFileCutCopyOn ; // If we can handle file cut/copy
    PUT_THREAD_DATA  pClipThreadData ;

    // locatation where temp files will go; the +1 is for an extra NULL char
    // that may be needed for the SHFileOperation
    char             baseTempDirA[MAX_PATH] ;
    wchar_t          baseTempDirW[MAX_PATH] ;
    char             tempDirA[MAX_PATH+1] ;
    wchar_t          tempDirW[MAX_PATH+1] ;
    char             pasteInfoA[MAX_PATH + 1];

    // Message used to send messages between the threads
    UINT             regMsg ;    
#ifdef OS_WINCE
    HWND             dataWindow;
#endif
} CLIP_DATA;
/**STRUCT-*******************************************************************/
    
const DCTCHAR g_excludedFormatList[CB_EXCLUDED_FORMAT_COUNT]
                                       [TS_FORMAT_NAME_LEN]
    = {
        _T("Link"                  ),
        _T("OwnerLink"             ),
        _T("ObjectLink"            ),
        _T("Ole Private Data"      ),
        _T("Link Source"           ),
        _T("Link Source Descriptor"),
        _T("Embed Source"          ),
#ifdef OS_WINCE
        _T("RTF in UTF8"           ), //Pocketword doesnt correctly support UTF8. 
#endif
        _T("Embedded Object"       )
        
    } ;
// If drive redirection is turned off, we have to exclude mroe things
// because we can't handle them
const DCTCHAR g_excludedFormatList_NO_RD[CB_EXCLUDED_FORMAT_COUNT_NO_RD]
                                       [TS_FORMAT_NAME_LEN]
    = {
        _T("Link"                  ),
        _T("OwnerLink"             ),
        _T("ObjectLink"            ),
        _T("Ole Private Data"      ),
        _T("Link Source"           ),
        _T("Link Source Descriptor"),        
        _T("Embed Source"          ),
#ifdef OS_WINCE
        _T("RTF in UTF8"           ), //Pocketword doesnt correctly support UTF8. 
#endif
        _T("DataObject"            ),
        _T("Object Descriptor"     ),
        _T("Shell IDList Array"    ),
        _T("Shell Object Offsets"  ),
        _T("FileName"              ),
        _T("FileNameW"             ),
        _T("FileContents"          ),
        _T("FileGroupDescriptor"   ),
        _T("FileGroupDescriptorW"  ),
        _T("Embedded Object"       )
        
    } ;

/****************************************************************************/
/* Clip State Table                                                           */
/****************************************************************************/
static DCUINT cbStateTable[CB_NUMEVENTS][CB_NUMSTATES]

    = {

        /********************************************************************/
        /* This is not a state table in the strict sense.  It simply shows  */
        /* which events are valid in which states.  It is not used to drive */
        /* CB.                                                              */
        /*                                                                  */
        /* Values mean                                                      */
        /* - 0 event OK in this state.                                      */
        /* - 1 warning - event may occur in this state, but we should       */
        /*   ignore it (eg we shouldn't send a format list before the       */
        /*   monitor has joined the call!                                   */
        /* - 2 error - event should not occur in ths state at all.          */
        /*                                                                  */
        /* These values are hard-coded here in order to make the table      */
        /* readable.  They correspond to the constants CB_TABLE_OK,         */
        /* CB_TABLE_WARN & CB_TABLE_ERROR.                                  */
        /*                                                                  */
        /*  Terminated                                                      */
        /*  |   Initialized                                                 */
        /*  |   |   Enabled                                                 */
        /*  |   |   |   Local CB owner                                      */
        /*  |   |   |   |   Shared CB owner                                 */
        /*  |   |   |   |   |   Pending format list rsp                     */
        /*  |   |   |   |   |   |   Sending format data                     */
        /*  |   |   |   |   |   |   |   Pending format data rsp             */
        /*  |   |   |   |   |   |   |   |                                   */
        /********************************************************************/
/* init/term */
        {   0,  2,  2,  2,  2,  2,  2,  2},     /* CB_Init                  */
        {   2,  0,  1,  1,  1,  2,  2,  2},     /* CB_Enable                */
        {   1,  1,  0,  0,  0,  0,  0,  0},     /* CB_Disable               */
        {   1,  0,  1,  1,  1,  1,  1,  1},     /* CB_Term                  */

/* local CB messages */
        {   0,  1,  2,  2,  2,  2,  2,  2},     /* WM_CREATE                */
        {   2,  0,  2,  2,  2,  2,  2,  2},     /* WM_DESTROY               */
        {   2,  0,  0,  0,  0,  0,  0,  0},     /* WM_CHANGECBCHAIN         */
        {   1,  1,  0,  0,  0,  1,  0,  0},     /* WM_DRAWCLIPBOARD         */
        {   2,  2,  2,  0,  1,  1,  1,  1},     /* WM_RENDERFORMAT          */

/* shared CB messages */
        {   2,  2,  0,  0,  0,  0,  2,  0},     /* Format list              */
        {   2,  2,  2,  2,  1,  0,  2,  2},     /* Format list rsp          */
        {   2,  2,  2,  2,  0,  0,  2,  2},     /* Format data rq           */
        {   2,  2,  2,  2,  2,  2,  2,  0}      /* Format data rsp          */
    };

#ifdef DC_DEBUG
/****************************************************************************/
/* State and event descriptions (debug build only)                          */
/****************************************************************************/
const DCTCHAR cbState[CB_NUMSTATES][35]
    = {
        _T("CB_STATE_NOT_INIT"),
        _T("CB_STATE_INITIALIZED"),
        _T("CB_STATE_ENABLED"),
        _T("CB_STATE_LOCAL_CB_OWNER"),
        _T("CB_STATE_SHARED_CB_OWNER"),
        _T("CB_STATE_PENDING_FORMAT_LIST_RSP"),
        _T("CB_STATE_SENDING_FORMAT_DATA"),
        _T("CB_STATE_PENDING_FORMAT_DATA_RSP")
    };

const DCTCHAR cbEvent[CB_NUMEVENTS][35]
    = {
        _T("CB_EVENT_CB_INIT"),
        _T("CB_EVENT_CB_ENABLE"),
        _T("CB_EVENT_CB_DISABLE"),
        _T("CB_EVENT_CB_TERM"),
        _T("CB_EVENT_WM_CREATE"),
        _T("CB_EVENT_WM_DESTROY"),
        _T("CB_EVENT_WM_CHANGECBCHAIN"),
        _T("CB_EVENT_WM_DRAWCLIPBOARD"),
        _T("CB_EVENT_WM_RENDERFORMAT"),
        _T("CB_EVENT_FORMAT_LIST"),
        _T("CB_EVENT_FORMAT_LIST_RSP"),
        _T("CB_EVENT_FORMAT_DATA_RQ"),
        _T("CB_EVENT_FORMAT_DATA_RSP")
    };
#endif /* DC_DEBUG */

#endif /* _H_ACBDATA */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\ddkinc.h ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    ddkinc.h

Abstract:

    This module contains DDK constants and macro.  They are 
    cut-and-pasted from various files in the DDK.

Author:

    Madan Appiah (madana) 17-Sep-1998

Revision History:

--*/

#ifndef __DDKINC_H__
#define __DDKINC_H__


////////////////////////////////////////////////////////////
//
//  From wdm.h
//

#define IRP_MJ_CREATE                   0x00
#define IRP_MJ_CLOSE                    0x02
#define IRP_MJ_READ                     0x03
#define IRP_MJ_WRITE                    0x04
#define IRP_MJ_QUERY_INFORMATION        0x05
#define IRP_MJ_SET_INFORMATION          0x06
#define IRP_MJ_FLUSH_BUFFERS            0x09
#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x0A
#define IRP_MJ_SET_VOLUME_INFORMATION   0x0B
#define IRP_MJ_DIRECTORY_CONTROL        0x0C
#define IRP_MJ_FILE_SYSTEM_CONTROL      0x0D
#define IRP_MJ_DEVICE_CONTROL           0x0E
#define IRP_MJ_INTERNAL_DEVICE_CONTROL  0x0F
#define IRP_MJ_SHUTDOWN                 0x10
#define IRP_MJ_LOCK_CONTROL             0x11
#define IRP_MJ_CLEANUP                  0x12
#define IRP_MJ_QUERY_SECURITY           0x14
#define IRP_MJ_SET_SECURITY             0x15

//
// Directory control minor function codes
//
#define IRP_MN_QUERY_DIRECTORY          0x01
#define IRP_MN_NOTIFY_CHANGE_DIRECTORY  0x02


#undef CTL_CODE

#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
        ((ULONG)(DeviceType) << 16) | \
        ((ULONG)(Access) << 14) | \
        ((ULONG)(Function) << 2) | \
        (Method) \
    )


#define FILE_DEVICE_SERIAL_PORT         0x0000001b
#define FILE_DEVICE_PARALLEL_PORT       0x00000016
#define METHOD_BUFFERED                 0
#define FILE_ANY_ACCESS                 0

#define IOCTL_INTERNAL_GET_PARALLEL_PORT_INFO                   CTL_CODE(FILE_DEVICE_PARALLEL_PORT,12,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_PARALLEL_PORT_ALLOCATE                   CTL_CODE(FILE_DEVICE_PARALLEL_PORT,11,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_PARALLEL_CONNECT_INTERRUPT               CTL_CODE(FILE_DEVICE_PARALLEL_PORT,13,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_PARALLEL_DISCONNECT_INTERRUPT  CTL_CODE(FILE_DEVICE_PARALLEL_PORT,14,METHOD_BUFFERED,FILE_ANY_ACCESS)


////////////////////////////////////////////////////////////
//
//  From ntddser.h
//

//
//  Serial IOCTL's.
//

#define IOCTL_SERIAL_SET_BAUD_RATE      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 1,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_QUEUE_SIZE     CTL_CODE(FILE_DEVICE_SERIAL_PORT, 2,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_LINE_CONTROL   CTL_CODE(FILE_DEVICE_SERIAL_PORT, 3,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_BREAK_ON       CTL_CODE(FILE_DEVICE_SERIAL_PORT, 4,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_BREAK_OFF      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 5,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_IMMEDIATE_CHAR     CTL_CODE(FILE_DEVICE_SERIAL_PORT, 6,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_TIMEOUTS       CTL_CODE(FILE_DEVICE_SERIAL_PORT, 7,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_GET_TIMEOUTS       CTL_CODE(FILE_DEVICE_SERIAL_PORT, 8,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_DTR            CTL_CODE(FILE_DEVICE_SERIAL_PORT, 9,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_CLR_DTR            CTL_CODE(FILE_DEVICE_SERIAL_PORT,10,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_RESET_DEVICE       CTL_CODE(FILE_DEVICE_SERIAL_PORT,11,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_RTS            CTL_CODE(FILE_DEVICE_SERIAL_PORT,12,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_CLR_RTS            CTL_CODE(FILE_DEVICE_SERIAL_PORT,13,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_XOFF           CTL_CODE(FILE_DEVICE_SERIAL_PORT,14,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_XON            CTL_CODE(FILE_DEVICE_SERIAL_PORT,15,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_GET_WAIT_MASK      CTL_CODE(FILE_DEVICE_SERIAL_PORT,16,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_WAIT_MASK      CTL_CODE(FILE_DEVICE_SERIAL_PORT,17,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_WAIT_ON_MASK       CTL_CODE(FILE_DEVICE_SERIAL_PORT,18,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_PURGE              CTL_CODE(FILE_DEVICE_SERIAL_PORT,19,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_GET_BAUD_RATE      CTL_CODE(FILE_DEVICE_SERIAL_PORT,20,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_GET_LINE_CONTROL   CTL_CODE(FILE_DEVICE_SERIAL_PORT,21,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_GET_CHARS          CTL_CODE(FILE_DEVICE_SERIAL_PORT,22,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_CHARS          CTL_CODE(FILE_DEVICE_SERIAL_PORT,23,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_GET_HANDFLOW       CTL_CODE(FILE_DEVICE_SERIAL_PORT,24,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_HANDFLOW       CTL_CODE(FILE_DEVICE_SERIAL_PORT,25,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_GET_MODEMSTATUS    CTL_CODE(FILE_DEVICE_SERIAL_PORT,26,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_GET_COMMSTATUS     CTL_CODE(FILE_DEVICE_SERIAL_PORT,27,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_XOFF_COUNTER       CTL_CODE(FILE_DEVICE_SERIAL_PORT,28,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_GET_PROPERTIES     CTL_CODE(FILE_DEVICE_SERIAL_PORT,29,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_GET_DTRRTS         CTL_CODE(FILE_DEVICE_SERIAL_PORT,30,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_LSRMST_INSERT      CTL_CODE(FILE_DEVICE_SERIAL_PORT,31,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_CONFIG_SIZE        CTL_CODE(FILE_DEVICE_SERIAL_PORT,32,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_GET_COMMCONFIG     CTL_CODE(FILE_DEVICE_SERIAL_PORT,33,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_COMMCONFIG     CTL_CODE(FILE_DEVICE_SERIAL_PORT,34,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_GET_STATS          CTL_CODE(FILE_DEVICE_SERIAL_PORT,35,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_CLEAR_STATS        CTL_CODE(FILE_DEVICE_SERIAL_PORT,36,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_GET_MODEM_CONTROL  CTL_CODE(FILE_DEVICE_SERIAL_PORT,37,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_MODEM_CONTROL  CTL_CODE(FILE_DEVICE_SERIAL_PORT,38,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_FIFO_CONTROL   CTL_CODE(FILE_DEVICE_SERIAL_PORT,39,METHOD_BUFFERED,FILE_ANY_ACCESS)


//
// These are the following reasons that the device could be holding.
//
#define SERIAL_TX_WAITING_FOR_CTS      ((ULONG)0x00000001)
#define SERIAL_TX_WAITING_FOR_DSR      ((ULONG)0x00000002)
#define SERIAL_TX_WAITING_FOR_DCD      ((ULONG)0x00000004)
#define SERIAL_TX_WAITING_FOR_XON      ((ULONG)0x00000008)
#define SERIAL_TX_WAITING_XOFF_SENT    ((ULONG)0x00000010)
#define SERIAL_TX_WAITING_ON_BREAK     ((ULONG)0x00000020)
#define SERIAL_RX_WAITING_FOR_DSR      ((ULONG)0x00000040)

//
// These are the error values that can be returned by the
// driver.
//
#define SERIAL_ERROR_BREAK             ((ULONG)0x00000001)
#define SERIAL_ERROR_FRAMING           ((ULONG)0x00000002)
#define SERIAL_ERROR_OVERRUN           ((ULONG)0x00000004)
#define SERIAL_ERROR_QUEUEOVERRUN      ((ULONG)0x00000008)
#define SERIAL_ERROR_PARITY            ((ULONG)0x00000010)

//
// This structure used to set line parameters.
//
typedef struct _SERIAL_LINE_CONTROL {
    UCHAR StopBits;
    UCHAR Parity;
    UCHAR WordLength;
    } SERIAL_LINE_CONTROL,*PSERIAL_LINE_CONTROL;

typedef struct _SERIAL_TIMEOUTS {
    ULONG ReadIntervalTimeout;
    ULONG ReadTotalTimeoutMultiplier;
    ULONG ReadTotalTimeoutConstant;
    ULONG WriteTotalTimeoutMultiplier;
    ULONG WriteTotalTimeoutConstant;
    } SERIAL_TIMEOUTS,*PSERIAL_TIMEOUTS;

//
// This structure used to resize the input/output buffers.
// An error code will be returned if the size exceeds the
// drivers capacity.  The driver reserves the right to
// allocate a larger buffer.
//
typedef struct _SERIAL_QUEUE_SIZE {
    ULONG InSize;
    ULONG OutSize;
    } SERIAL_QUEUE_SIZE,*PSERIAL_QUEUE_SIZE;


//
// This structure used by set baud rate
//
typedef struct _SERIAL_BAUD_RATE {
    ULONG BaudRate;
    } SERIAL_BAUD_RATE,*PSERIAL_BAUD_RATE;

//
// This structure is used to get the current error and
// general status of the driver.
//
typedef struct _SERIAL_STATUS {
    ULONG Errors;
    ULONG HoldReasons;
    ULONG AmountInInQueue;
    ULONG AmountInOutQueue;
    BOOLEAN EofReceived;
    BOOLEAN WaitForImmediate;
    } SERIAL_STATUS,*PSERIAL_STATUS;

//
// This structure is used to set and retrieve the special characters
// used by the nt serial driver.
//
typedef struct _SERIAL_CHARS {
    UCHAR EofChar;
    UCHAR ErrorChar;
    UCHAR BreakChar;
    UCHAR EventChar;
    UCHAR XonChar;
    UCHAR XoffChar;
    } SERIAL_CHARS,*PSERIAL_CHARS;

//
//  Communication Properties
//
typedef struct _SERIAL_COMMPROP {
    USHORT PacketLength;
    USHORT PacketVersion;
    ULONG ServiceMask;
    ULONG Reserved1;
    ULONG MaxTxQueue;
    ULONG MaxRxQueue;
    ULONG MaxBaud;
    ULONG ProvSubType;
    ULONG ProvCapabilities;
    ULONG SettableParams;
    ULONG SettableBaud;
    USHORT SettableData;
    USHORT SettableStopParity;
    ULONG CurrentTxQueue;
    ULONG CurrentRxQueue;
    ULONG ProvSpec1;
    ULONG ProvSpec2;
    WCHAR ProvChar[1];
} SERIAL_COMMPROP,*PSERIAL_COMMPROP;

//
//  Handflow Struct and Related Defines
//
typedef struct _SERIAL_HANDFLOW {
    ULONG ControlHandShake;
    ULONG FlowReplace;
    LONG XonLimit;
    LONG XoffLimit;
    } SERIAL_HANDFLOW,*PSERIAL_HANDFLOW;

#define SERIAL_DTR_MASK           ((ULONG)0x03)
#define SERIAL_DTR_CONTROL        ((ULONG)0x01)
#define SERIAL_DTR_HANDSHAKE      ((ULONG)0x02)
#define SERIAL_CTS_HANDSHAKE      ((ULONG)0x08)
#define SERIAL_DSR_HANDSHAKE      ((ULONG)0x10)
#define SERIAL_DCD_HANDSHAKE      ((ULONG)0x20)
#define SERIAL_OUT_HANDSHAKEMASK  ((ULONG)0x38)
#define SERIAL_DSR_SENSITIVITY    ((ULONG)0x40)
#define SERIAL_ERROR_ABORT        ((ULONG)0x80000000)
#define SERIAL_CONTROL_INVALID    ((ULONG)0x7fffff84)
#define SERIAL_AUTO_TRANSMIT      ((ULONG)0x01)
#define SERIAL_AUTO_RECEIVE       ((ULONG)0x02)
#define SERIAL_ERROR_CHAR         ((ULONG)0x04)
#define SERIAL_NULL_STRIPPING     ((ULONG)0x08)
#define SERIAL_BREAK_CHAR         ((ULONG)0x10)
#define SERIAL_RTS_MASK           ((ULONG)0xc0)
#define SERIAL_RTS_CONTROL        ((ULONG)0x40)
#define SERIAL_RTS_HANDSHAKE      ((ULONG)0x80)
#define SERIAL_TRANSMIT_TOGGLE    ((ULONG)0xc0)
#define SERIAL_XOFF_CONTINUE      ((ULONG)0x80000000)
#define SERIAL_FLOW_INVALID       ((ULONG)0x7fffff20)

//
// The following structure (and defines) are passed back by
// the serial driver in response to the get properties ioctl.
//

#define SERIAL_SP_SERIALCOMM         ((ULONG)0x00000001)

//
// Provider subtypes
//
#define SERIAL_SP_UNSPECIFIED       ((ULONG)0x00000000)
#define SERIAL_SP_RS232             ((ULONG)0x00000001)
#define SERIAL_SP_PARALLEL          ((ULONG)0x00000002)
#define SERIAL_SP_RS422             ((ULONG)0x00000003)
#define SERIAL_SP_RS423             ((ULONG)0x00000004)
#define SERIAL_SP_RS449             ((ULONG)0x00000005)
#define SERIAL_SP_MODEM             ((ULONG)0X00000006)
#define SERIAL_SP_FAX               ((ULONG)0x00000021)
#define SERIAL_SP_SCANNER           ((ULONG)0x00000022)
#define SERIAL_SP_BRIDGE            ((ULONG)0x00000100)
#define SERIAL_SP_LAT               ((ULONG)0x00000101)
#define SERIAL_SP_TELNET            ((ULONG)0x00000102)
#define SERIAL_SP_X25               ((ULONG)0x00000103)

//
// Provider capabilities flags.
//
#define SERIAL_PCF_DTRDSR        ((ULONG)0x0001)
#define SERIAL_PCF_RTSCTS        ((ULONG)0x0002)
#define SERIAL_PCF_CD            ((ULONG)0x0004)
#define SERIAL_PCF_PARITY_CHECK  ((ULONG)0x0008)
#define SERIAL_PCF_XONXOFF       ((ULONG)0x0010)
#define SERIAL_PCF_SETXCHAR      ((ULONG)0x0020)
#define SERIAL_PCF_TOTALTIMEOUTS ((ULONG)0x0040)
#define SERIAL_PCF_INTTIMEOUTS   ((ULONG)0x0080)
#define SERIAL_PCF_SPECIALCHARS  ((ULONG)0x0100)
#define SERIAL_PCF_16BITMODE     ((ULONG)0x0200)

//
// Comm provider settable parameters.
//
#define SERIAL_SP_PARITY         ((ULONG)0x0001)
#define SERIAL_SP_BAUD           ((ULONG)0x0002)
#define SERIAL_SP_DATABITS       ((ULONG)0x0004)
#define SERIAL_SP_STOPBITS       ((ULONG)0x0008)
#define SERIAL_SP_HANDSHAKING    ((ULONG)0x0010)
#define SERIAL_SP_PARITY_CHECK   ((ULONG)0x0020)
#define SERIAL_SP_CARRIER_DETECT ((ULONG)0x0040)

//
// Settable baud rates in the provider.
//
#define SERIAL_BAUD_075          ((ULONG)0x00000001)
#define SERIAL_BAUD_110          ((ULONG)0x00000002)
#define SERIAL_BAUD_134_5        ((ULONG)0x00000004)
#define SERIAL_BAUD_150          ((ULONG)0x00000008)
#define SERIAL_BAUD_300          ((ULONG)0x00000010)
#define SERIAL_BAUD_600          ((ULONG)0x00000020)
#define SERIAL_BAUD_1200         ((ULONG)0x00000040)
#define SERIAL_BAUD_1800         ((ULONG)0x00000080)
#define SERIAL_BAUD_2400         ((ULONG)0x00000100)
#define SERIAL_BAUD_4800         ((ULONG)0x00000200)
#define SERIAL_BAUD_7200         ((ULONG)0x00000400)
#define SERIAL_BAUD_9600         ((ULONG)0x00000800)
#define SERIAL_BAUD_14400        ((ULONG)0x00001000)
#define SERIAL_BAUD_19200        ((ULONG)0x00002000)
#define SERIAL_BAUD_38400        ((ULONG)0x00004000)
#define SERIAL_BAUD_56K          ((ULONG)0x00008000)
#define SERIAL_BAUD_128K         ((ULONG)0x00010000)
#define SERIAL_BAUD_115200       ((ULONG)0x00020000)
#define SERIAL_BAUD_57600        ((ULONG)0x00040000)
#define SERIAL_BAUD_USER         ((ULONG)0x10000000)

//
// Settable Data Bits
//
#define SERIAL_DATABITS_5        ((USHORT)0x0001)
#define SERIAL_DATABITS_6        ((USHORT)0x0002)
#define SERIAL_DATABITS_7        ((USHORT)0x0004)
#define SERIAL_DATABITS_8        ((USHORT)0x0008)
#define SERIAL_DATABITS_16       ((USHORT)0x0010)
#define SERIAL_DATABITS_16X      ((USHORT)0x0020)

//
// Settable Stop and Parity bits.
//
#define SERIAL_STOPBITS_10       ((USHORT)0x0001)
#define SERIAL_STOPBITS_15       ((USHORT)0x0002)
#define SERIAL_STOPBITS_20       ((USHORT)0x0004)
#define SERIAL_PARITY_NONE       ((USHORT)0x0100)
#define SERIAL_PARITY_ODD        ((USHORT)0x0200)
#define SERIAL_PARITY_EVEN       ((USHORT)0x0400)
#define SERIAL_PARITY_MARK       ((USHORT)0x0800)
#define SERIAL_PARITY_SPACE      ((USHORT)0x1000)

#endif // __DDKINC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\drdbg.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    drdbg

Abstract:
    
    Contains Debug Routines for TS Device Redirector Component, 
    RDPDR.DLL.

Author:

    Tad Brockway 8/25/99

Revision History:

--*/

#ifndef __DRDBG_H__
#define __DRDBG_H__

// Disable conditional expression as constant warnings 
#pragma warning (disable: 4127)

//
//  Route ASSERT to TRC_ERR and then abort.  Don't like
//  the DCL assert because it pops up its own dialog and 
//  allows other threads to spin, thereby possibly losing state
//  of the process.
//
#undef ASSERT
#if DBG
#define ASSERT(expr)                      \
    if (!(expr)) {                           \
        TRC_ERR((TB,_T("Failed: %s\nLine %d, %s"), \
                                _T(#expr),       \
                                __LINE__,    \
                                _T(__FILE__) ));  \
        DebugBreak();                        \
    }
#else
#define ASSERT(expr)
#endif

//
//  Object and Memory Tracking Defines
//
#define GOODMEMMAGICNUMBER  0x07052530
#define DRBADMEM            0xDA
#define UNITIALIZEDMEM      0xCC
#define FREEDMEMMAGICNUMBER 0x09362229

//
//  Memory Allocation Tags
//
#define DROBJECT_TAG        ('BORD')
#define DRGLOBAL_TAG        ('BGRD')

////////////////////////////////////////////////////////////
//
//  Memory Allocation Routines
//
//#if DBG
// remove this ... i mean, restore this.
#ifdef NOTUSED

//  
//  The Functions
//
void *DrAllocateMem(size_t size, DWORD tag);
void DrFreeMem(void *ptr);

//
//  The C++ Operators
//
inline void *__cdecl operator new(size_t sz)
{
    void *ptr = DrAllocateMem(sz, DRGLOBAL_TAG);
    return ptr;
}
inline void *__cdecl operator new(size_t sz, DWORD tag)
{
    void *ptr = DrAllocateMem(sz, tag);
    return ptr;
}
inline void __cdecl operator delete(void *ptr)
{
    DrFreeMem(ptr);
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\drdev.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    drdev

Abstract:

    This module defines the parent for the client-side RDP
    device redirection "device" class hierarchy, DrDevice.

Author:

    Tad Brockway 3/23/99

Revision History:

--*/

#ifndef __DRDEV_H__
#define __DRDEV_H__

#include <rdpdr.h>
#include "drobject.h"
#include "drobjmgr.h"


///////////////////////////////////////////////////////////////
//
//  Defines and Macros
//

//
//  Maximum length of a device trace message, not including the
//  NULL terminator.
//
#define RDP_MAX_DEVICE_TRACE_LEN    256


///////////////////////////////////////////////////////////////
//
// Device change state
//      New means it's not sent to server yet
//      Remove means it needs to be removed from server
//      Exist means the server has it
typedef enum tagDEVICECHANGE {
    DEVICENEW = 0,
    DEVICEREMOVE,
    DEVICEANNOUCED
} DEVICECHANGE;

///////////////////////////////////////////////////////////////
//
// DeviceProperty Class Declaration
//
class DrDevice;
class DrDevProperty : public DrObject
{
protected:

    BOOL _bSeekable;
    friend class DrDevice;

public:

    DrDevProperty() {
        _bSeekable = FALSE;
    }

    virtual ~DrDevProperty() { /* do nothing for now. */ }

    //
    //  Setup seekable property
    //
    void SetSeekProperty(BOOL bSeekable) {
        _bSeekable = bSeekable;
    }

    //
    //  Return the class name.
    //
    virtual DRSTRING ClassName()  { return TEXT("DrDevProperty"); }
};


///////////////////////////////////////////////////////////////
//
//	DrDevice Class Declaration
//
//

class ProcObj;

class DrDevice : public DrObject
{
protected:

    ULONG         _deviceID;
    
    DrDevProperty _deviceProperty;

    ProcObj       *_processObject;

    //
    //  List of all opening files associated with the device 
    //  being redirected.
    //
    DrFileMgr     *_FileMgr;

    //
    // Setup device property
    //
    virtual VOID SetDeviceProperty() { /* do nothing, take default */ }

    //
    //  Default IO Request Handling.
    //
    virtual VOID DefaultIORequestMsgHandle(
                        IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                        IN NTSTATUS serverReturnStatus
                        );

    //
    //  IO Processing Functions
    //
    //  These are the functions that need to be implemented
    //  in subclasses.  Here are the args:
    //
    //  pIoRequestPacket    -   Request packet received from server.
    //  packetLen           -   Length of the packet
    //
    virtual VOID MsgIrpCreate(
                        PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                        UINT32 packetLen
                        );
    virtual VOID MsgIrpCleanup(
                        PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                        UINT32 packetLen
                        );
    virtual VOID MsgIrpClose(
                        PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                        UINT32 packetLen
                        );
    virtual VOID MsgIrpRead(
                        PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                        UINT32 packetLen
                        );
    virtual VOID MsgIrpWrite(
                        PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                        UINT32 packetLen
                        );
    virtual VOID MsgIrpFlushBuffers(
                        PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                        UINT32 packetLen
                        );
    virtual VOID MsgIrpShutdown(
                        PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                        UINT32 packetLen
                        );
    virtual VOID MsgIrpDeviceControl(
                        PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                        UINT32 packetLen
                        );
    virtual VOID MsgIrpLockControl(
                        PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                        UINT32 packetLen
                        );
    virtual VOID MsgIrpInternalDeviceControl(
                        PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                        UINT32 packetLen
                        );
    virtual VOID MsgIrpDirectoryControl(
                        PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                        UINT32 packetLen
                        );
    virtual VOID MsgIrpQueryVolumeInfo(
                        PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                        UINT32 packetLen
                        );
    virtual VOID MsgIrpSetVolumeInfo(
                        PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                        UINT32 packetLen
                        );
    virtual VOID MsgIrpQueryFileInfo(
                        PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                        UINT32 packetLen
                        );
    virtual VOID MsgIrpSetFileInfo(
                        PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                        UINT32 packetLen
                        );
    virtual VOID MsgIrpQuerySdInfo(
                        PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                        UINT32 packetLen
                        );
    virtual VOID MsgIrpSetSdInfo(
                        PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                        UINT32 packetLen
                        );

public:

    DEVICECHANGE  _deviceChange;

    //
    //  Constructor/Destructor
    //
    DrDevice(ProcObj *processObject, ULONG deviceID);
    virtual ~DrDevice();

    //
    //  Initialize
    //
    virtual DWORD Initialize();

    //
    //  Get basic information about the device.
    //
    virtual DRSTRING GetName() = 0;
    virtual ULONG    GetID() {
        return _deviceID;
    }
    virtual BOOL IsSeekableDevice() {
        return _deviceProperty._bSeekable;
    }

    //
    //  Get the device type.  See "Device Types" section of rdpdr.h
    //
    virtual ULONG GetDeviceType() = 0;

    //
    //  Device Data Information
    //
    virtual ULONG GetDevAnnounceDataSize() = 0;
    virtual VOID GetDevAnnounceData(IN PRDPDR_DEVICE_ANNOUNCE buf) = 0;

    //
    //  Return the "parent" TS Device Redirection IO processing object.
    //
    virtual ProcObj *ProcessObject() { return _processObject; }
    
    //
    //  Handle an IO request from the server.
    //
    virtual VOID ProcessIORequest(IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket, IN UINT32 packetLen);

    //
    //  Return the class name.
    //
    virtual DRSTRING ClassName()  { return TEXT("DrDevice"); }

    //
    //  Flush outstanding IRPs
    //
    virtual VOID FlushIRPs() { return; };
};


///////////////////////////////////////////////////////////////
//
//	DrDevice Inline Functions
//
//

//
//  IO Processing Functions
//
//  These are the functions that need to be implemented
//  in subclasses.  Here are the args:
//
//  pIoRequestPacket    -   Request packet received from server.
//  packetLen           -   Length of the packet
//
inline VOID DrDevice::MsgIrpCreate(
                    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                    IN UINT32 packetLen
                    ) {
    DC_BEGIN_FN("DrDevice::MsgIrpCreate");
    ASSERT(FALSE);
    DefaultIORequestMsgHandle(pIoRequestPacket, STATUS_UNSUCCESSFUL);
    DC_END_FN();
}

inline VOID DrDevice::MsgIrpCleanup(
                    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                    IN UINT32 packetLen
                    ){
    DC_BEGIN_FN("DrDevice::MsgIrpCleanup");
    ASSERT(FALSE);
    DefaultIORequestMsgHandle(pIoRequestPacket, STATUS_UNSUCCESSFUL);
    DC_END_FN();
}

inline VOID DrDevice::MsgIrpClose(
                    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                    IN UINT32 packetLen
                    ){
    DC_BEGIN_FN("DrDevice::MsgIrpClose");
    ASSERT(FALSE);
    DefaultIORequestMsgHandle(pIoRequestPacket, STATUS_UNSUCCESSFUL);
    DC_END_FN();
}

inline VOID DrDevice::MsgIrpRead(
                    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                    IN UINT32 packetLen
                    ){
    DC_BEGIN_FN("DrDevice::MsgIrpRead");
    ASSERT(FALSE);
    DefaultIORequestMsgHandle(pIoRequestPacket, STATUS_UNSUCCESSFUL);
    DC_END_FN();
}

inline VOID DrDevice::MsgIrpWrite(
                    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                    IN UINT32 packetLen
                    ){
    DC_BEGIN_FN("DrDevice::MsgIrpWrite");
    ASSERT(FALSE);
    DefaultIORequestMsgHandle(pIoRequestPacket, STATUS_UNSUCCESSFUL);
    DC_END_FN();
}

inline VOID DrDevice::MsgIrpFlushBuffers(
                    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                    IN UINT32 packetLen
                        ){
    DC_BEGIN_FN("DrDevice::MsgIrpFlushBuffers");
    ASSERT(FALSE);
    DefaultIORequestMsgHandle(pIoRequestPacket, STATUS_UNSUCCESSFUL);
    DC_END_FN();
}

inline VOID DrDevice::MsgIrpShutdown(
                    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                    IN UINT32 packetLen
                    ){
    DC_BEGIN_FN("DrDevice::MsgIrpShutdown");
    ASSERT(FALSE);
    DefaultIORequestMsgHandle(pIoRequestPacket, STATUS_UNSUCCESSFUL);
    DC_END_FN();
}

inline VOID DrDevice::MsgIrpDeviceControl(
                    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                    IN UINT32 packetLen
                    ){
    DC_BEGIN_FN("DrDevice::MsgIrpDeviceControl");
    ASSERT(FALSE);
    DefaultIORequestMsgHandle(pIoRequestPacket, STATUS_UNSUCCESSFUL);
    DC_END_FN();
};    

inline VOID DrDevice::MsgIrpLockControl(
                    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                    IN UINT32 packetLen
                    ){
    DC_BEGIN_FN("DrDevice::MsgIrpLockControl");
    ASSERT(FALSE);
    DefaultIORequestMsgHandle(pIoRequestPacket, STATUS_UNSUCCESSFUL);
    DC_END_FN();
};

inline VOID DrDevice::MsgIrpInternalDeviceControl(
                    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                    IN UINT32 packetLen
                    ){
    DC_BEGIN_FN("DrDevice::MsgIrpInternalDeviceControl");
    ASSERT(FALSE);
    DefaultIORequestMsgHandle(pIoRequestPacket, STATUS_UNSUCCESSFUL);
    DC_END_FN();
};

inline VOID DrDevice::MsgIrpDirectoryControl(
                    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                    IN UINT32 packetLen
                    ){
    DC_BEGIN_FN("DrDevice::MsgIrpDirectoryControl");
    ASSERT(FALSE);
    DefaultIORequestMsgHandle(pIoRequestPacket, STATUS_UNSUCCESSFUL);
    DC_END_FN();
};

inline VOID DrDevice::MsgIrpQueryVolumeInfo(
                    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                    IN UINT32 packetLen
                    ){
    DC_BEGIN_FN("DrDevice::MsgIrpQueryVolumeInfo");
    ASSERT(FALSE);
    DefaultIORequestMsgHandle(pIoRequestPacket, STATUS_UNSUCCESSFUL);
    DC_END_FN();
};

inline VOID DrDevice::MsgIrpSetVolumeInfo(
                    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                    IN UINT32 packetLen
                    ){
    DC_BEGIN_FN("DrDevice::MsgIrpSetVolumeInfo");
    ASSERT(FALSE);
    DefaultIORequestMsgHandle(pIoRequestPacket, STATUS_UNSUCCESSFUL);
    DC_END_FN();
};

inline VOID DrDevice::MsgIrpQueryFileInfo(
                    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                    IN UINT32 packetLen
                    ){
    DC_BEGIN_FN("DrDevice::MsgIrpQueryFileInfo");
    ASSERT(FALSE);
    DefaultIORequestMsgHandle(pIoRequestPacket, STATUS_UNSUCCESSFUL);
    DC_END_FN();
};

inline VOID DrDevice::MsgIrpSetFileInfo(
                    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                    IN UINT32 packetLen
                    ){
    DC_BEGIN_FN("DrDevice::MsgIrpSetFileInfo");
    ASSERT(FALSE);
    DefaultIORequestMsgHandle(pIoRequestPacket, STATUS_UNSUCCESSFUL);
    DC_END_FN();
};

inline VOID DrDevice::MsgIrpQuerySdInfo(
                    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                    IN UINT32 packetLen
                    ){
    DC_BEGIN_FN("DrDevice::MsgIrpQuerySdInfo");
    ASSERT(FALSE);
    DefaultIORequestMsgHandle(pIoRequestPacket, STATUS_UNSUCCESSFUL);
    DC_END_FN();
};

inline VOID DrDevice::MsgIrpSetSdInfo(
                    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                    IN UINT32 packetLen
                    ){
    DC_BEGIN_FN("DrDevice::MsgIrpSetSdInfo");
    ASSERT(FALSE);
    DefaultIORequestMsgHandle(pIoRequestPacket, STATUS_UNSUCCESSFUL);
    DC_END_FN();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\drdev.cpp ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    drdev

Abstract:

    This module defines the parent for the client-side RDP
    device redirection "device" class hierarchy, DrDevice.

Author:

    Tad Brockway 3/23/99

Revision History:

--*/

#include <precom.h>

#define TRC_FILE  "DrDev"

#include "drdev.h"
#include "proc.h"
#include "drconfig.h"
#include "utl.h"
#include "drfile.h"
#include "drobjmgr.h"

#ifdef OS_WINCE
#include "filemgr.h"
#endif
///////////////////////////////////////////////////////////////
//
//	DrDevice Methods
//
//

DrDevice::DrDevice(ProcObj *processObject, ULONG deviceID) 
/*++

Routine Description:

    Constructor for the DrDevice class. 

Arguments:

    processObject   -   Parent process object.
    id              -   Unique device ID.

Return Value:

    None

 --*/
{
    DC_BEGIN_FN("DrDevice::DrDevice");

    ASSERT(processObject != NULL);

    _deviceID = deviceID;
    _processObject = processObject;
    _deviceChange = DEVICENEW;
    _FileMgr = NULL;

    //
    //  Not valid until initialized.
    //
    SetValid(FALSE);

    DC_END_FN();
}
 
DrDevice::~DrDevice() 
/*++

Routine Description:

    Destructor for the DrDevice class. 

Arguments:

    None
    
Return Value:

    None

 --*/

{
    DrFile *pFileObj;

    DC_BEGIN_FN("DrDevice::~DrDevice");

    //
    //  Clean up the file management list.
    //
    if (_FileMgr != NULL) {
        _FileMgr->Lock();
        while ((pFileObj = _FileMgr->GetFirstObject()) != NULL) {
            pFileObj->Close();
            _FileMgr->RemoveObject(pFileObj->GetID());
            pFileObj->Release();
        }
        _FileMgr->Unlock();
        delete _FileMgr;
    }

    DC_END_FN();
}


DWORD DrDevice::Initialize() 
/*++

Routine Description:

    Initialize.
    
Arguments:

    pIoRequestPacket    -   IO request from server.

Return Value:

    None

 --*/
{
    DWORD result;
    
    DC_BEGIN_FN("DrDevice::Initialize");

    _FileMgr = new DrFileMgr();
    if (_FileMgr == NULL) {
        TRC_ERR((TB, L"Error allocating file mgr."));
        result =  ERROR_NOT_ENOUGH_MEMORY;
        goto CLEANUPANDEXIT;
    }

    result = _FileMgr->Initialize();
    if (result != ERROR_SUCCESS) {
        delete _FileMgr;
        _FileMgr = NULL;
        goto CLEANUPANDEXIT;
    }

    SetValid(TRUE);

CLEANUPANDEXIT:

    DC_END_FN();

    return result;
}

VOID DrDevice::ProcessIORequest(
    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
    IN UINT32 packetLen
    ) 
/*++

Routine Description:

    Handle an IO request from the server.

Arguments:

    pIoRequestPacket    -   IO request from server.
    packetLen           -   length of the packet

Return Value:

    None

 --*/
{
    PRDPDR_DEVICE_IOREQUEST  pIORequest;

    DC_BEGIN_FN("DrDevice::ProcessIORequest");

    //
    //  Make sure we are valid.
    //
    ASSERT(IsValid());
    if (!IsValid()) {
        DefaultIORequestMsgHandle(pIoRequestPacket, STATUS_UNSUCCESSFUL); 
        DC_END_FN();
        return;
    }

    //
    //  Dispatch the request.
    //
    pIORequest = &pIoRequestPacket->IoRequest;
    switch (pIORequest->MajorFunction) {

        case IRP_MJ_CREATE                  :
            MsgIrpCreate(pIoRequestPacket, packetLen);
            break;

        case IRP_MJ_CLEANUP                 :
            MsgIrpCleanup(pIoRequestPacket, packetLen);
            break;

        case IRP_MJ_CLOSE                   :
            MsgIrpClose(pIoRequestPacket, packetLen);
            break;

        case IRP_MJ_READ                    :
            MsgIrpRead(pIoRequestPacket, packetLen);
            break;

        case IRP_MJ_WRITE                   :
            MsgIrpWrite(pIoRequestPacket, packetLen);
            break;

        case IRP_MJ_FLUSH_BUFFERS           :
            MsgIrpFlushBuffers(pIoRequestPacket, packetLen);
            break;

        case IRP_MJ_SHUTDOWN                :
            MsgIrpShutdown(pIoRequestPacket, packetLen);
            break;

        case IRP_MJ_DEVICE_CONTROL          : 
            MsgIrpDeviceControl(pIoRequestPacket, packetLen);
            break;

        case IRP_MJ_LOCK_CONTROL            :
            MsgIrpLockControl(pIoRequestPacket, packetLen);
            break;

        case IRP_MJ_INTERNAL_DEVICE_CONTROL : 
            MsgIrpInternalDeviceControl(pIoRequestPacket, packetLen);
            break;

        case IRP_MJ_DIRECTORY_CONTROL :
            MsgIrpDirectoryControl(pIoRequestPacket, packetLen);
            break;

        case IRP_MJ_QUERY_VOLUME_INFORMATION :
            MsgIrpQueryVolumeInfo(pIoRequestPacket, packetLen);
            break;

        case IRP_MJ_SET_VOLUME_INFORMATION :
            MsgIrpSetVolumeInfo(pIoRequestPacket, packetLen);
            break;

        case IRP_MJ_QUERY_INFORMATION :
            MsgIrpQueryFileInfo(pIoRequestPacket, packetLen);
            break;
        
        case IRP_MJ_SET_INFORMATION :
            MsgIrpSetFileInfo(pIoRequestPacket, packetLen);
            break;

        case IRP_MJ_QUERY_SECURITY :
            MsgIrpQuerySdInfo(pIoRequestPacket, packetLen);
            break;

        case IRP_MJ_SET_SECURITY :
            MsgIrpSetSdInfo(pIoRequestPacket, packetLen);
            break;

        default:
            TRC_ALT((TB, _T("Unknown MajorFunction, %ld."), pIORequest->MajorFunction ));
            DefaultIORequestMsgHandle(pIoRequestPacket, STATUS_UNSUCCESSFUL);
            break;
    }

    DC_END_FN();
}

VOID 
DrDevice::DefaultIORequestMsgHandle(
        IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
        IN NTSTATUS serverReturnStatus
        )
/*++

Routine Description:

    Default IO Request Handling.

Arguments:

    pIoRequestPacket    -   IO request from server.
    serverReturnStatus  -   NT error status to return to server.

Return Value:

    None

 --*/
{
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    PRDPDR_IOCOMPLETION_PACKET pReplyPacket = NULL;
    ULONG ulReplyPacketSize = 0;

    DC_BEGIN_FN("DrDevice::DefaultIORequestMsgHandle entered");

    //
    //  Get IO request pointer.
    //
    pIoRequest = &pIoRequestPacket->IoRequest;

    //
    //  Calculate the size of the reply packet, based on the type
    //  of request.
    //
    if ((serverReturnStatus != STATUS_SUCCESS) && 
        (pIoRequest->MajorFunction != IRP_MJ_DEVICE_CONTROL)) {
        ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET);
    }
    else {
        pIoRequest->Parameters.DeviceIoControl.OutputBufferLength = 0;
        ulReplyPacketSize = DR_IOCTL_REPLYBUFSIZE(pIoRequest);
    }

    //
    //  Allocate reply buffer.
    //
    pReplyPacket = DrUTL_AllocIOCompletePacket(pIoRequestPacket, 
            ulReplyPacketSize) ;

    if (pReplyPacket != NULL) {
        pReplyPacket->IoCompletion.IoStatus = serverReturnStatus;
        ProcessObject()->GetVCMgr().ChannelWrite(
                    (PVOID)pReplyPacket, (UINT)ulReplyPacketSize
                    );
    }
    else {
        TRC_ERR((TB, _T("Failed to alloc %ld bytes."),ulReplyPacketSize));
    }

Cleanup:

    //
    //  Clean up the request packet.
    //
    delete pIoRequestPacket;

    DC_END_FN();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\drfile.cpp ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    drfile

Abstract:

    This module provides generic device/file handle operation
    
Author:

    Joy Chik 11/1/99

Revision History:

--*/

#include <precom.h>

#define TRC_FILE  "DrFile"

#include "drfile.h"
#include "drdev.h"

#ifdef OS_WINCE
#include "filemgr.h"
#endif
///////////////////////////////////////////////////////////////
//
//	DrFile Members
//
DrFile::DrFile(DrDevice *Device, ULONG FileId, DRFILEHANDLE FileHandle) {
    DC_BEGIN_FN("DrFile::DrFile");

    ASSERT(Device != NULL);
    
    _FileId = FileId;
    _FileHandle = FileHandle;
    _Device = Device;   

    DC_END_FN();
}

DrFile::~DrFile() {
    DC_BEGIN_FN("DrFile::~DrFile")

    ASSERT(_FileHandle == INVALID_HANDLE_VALUE);
    DC_END_FN();
}

ULONG DrFile::GetDeviceType() {
    return _Device->GetDeviceType();
        
}

BOOL DrFile::Close() {
    DC_BEGIN_FN("DrFile::Close");

    if (_FileHandle != INVALID_HANDLE_VALUE) {
#ifndef OS_WINCE
        if (CloseHandle(_FileHandle)) {
#else
        if (CECloseHandle(_FileHandle)) {
#endif
            _FileHandle = INVALID_HANDLE_VALUE;
            return TRUE;
        } else {
            TRC_ERR((TB, _T("Close returned %ld."), GetLastError()));
            _FileHandle = INVALID_HANDLE_VALUE;
            return FALSE;
        }
    } else {
        //
        //  No need to close the handle
        //
        return TRUE;
    }

    DC_END_FN();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\drdevol.h ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    drdevol

Abstract:

    This module contains a subclass of W32DrDev that uses overlapped IO 
    implementations of read, write, and IOCTL handlers.  

Author:

    Tad Brockway 3/23/99

Revision History:

--*/

#ifndef __DRDEVOL_H__
#define __DRDEVOL_H__

#include "w32drdev.h"


///////////////////////////////////////////////////////////////
//
//  _W32DRDEV_OVERLAPPEDIO_PARAMS
//
//  Async IO Parameters
//

class W32DrDeviceOverlapped;
class W32DRDEV_OVERLAPPEDIO_PARAMS : public DrObject 
{
public:

#if DBG
    ULONG                        magicNo;
#endif

    W32DrDeviceOverlapped       *pObject;
    PRDPDR_IOREQUEST_PACKET      pIoRequestPacket;
    PRDPDR_IOCOMPLETION_PACKET   pIoReplyPacket;
    ULONG                        IoReplyPacketSize;

    OVERLAPPED                   overlapped;

    //
    //  Constructor/Destructor
    //
    W32DRDEV_OVERLAPPEDIO_PARAMS(W32DrDeviceOverlapped *pObj, 
                                PRDPDR_IOREQUEST_PACKET pIOP) {
        pIoRequestPacket    = pIOP;
        pObject             = pObj;
        pIoReplyPacket      = NULL;
        IoReplyPacketSize   = 0;
#if DBG
        magicNo             = GOODMEMMAGICNUMBER;
#endif
        memset(&overlapped, 0, sizeof(overlapped));

    }
    ~W32DRDEV_OVERLAPPEDIO_PARAMS() {
        DC_BEGIN_FN("~W32DRDEV_OVERLAPPEDIO_PARAMS");
#if DBG
        ASSERT(magicNo == GOODMEMMAGICNUMBER);
#endif
        ASSERT(overlapped.hEvent == NULL);

        ASSERT(pIoRequestPacket == NULL);
        ASSERT(pIoReplyPacket == NULL);
#if DBG
        memset(&magicNo, DRBADMEM, sizeof(magicNo));
#endif
        DC_END_FN();
    }

    //
    //  Return the class name.
    //
    virtual DRSTRING ClassName() { return TEXT("W32DRDEV_OVERLAPPEDIO_PARAMS"); };

};


///////////////////////////////////////////////////////////////
//
//	W32DrDeviceOverlapped
//

class W32DrDeviceOverlapped : public W32DrDevice
{
protected:

    //
    //  IO Processing Functions
    //
    //  This subclass of DrDevice handles the following IO requests.  These
    //  functions may be overridden in a subclass.
    //
    //  pIoRequestPacket    -   Request packet received from server.
    //  packetLen           -   Length of the packet
    //
    //
    virtual VOID MsgIrpCreate(
                        IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                        IN UINT32 packetLen
                        );

    //
    //  Simultaneously Handles Read and Write IO requests.
    //
    VOID MsgIrpReadWrite(PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                        IN UINT32 packetLen);

    //
    //  Read and Writes are handled uniformly.
    //
    virtual VOID MsgIrpRead(
                        IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                        IN UINT32 packetLen
                        ) {
        DC_BEGIN_FN("W32DrDevice::MsgIrpRead");
        MsgIrpReadWrite(pIoRequestPacket, packetLen);
        DC_END_FN();
    }
    virtual VOID MsgIrpWrite(
                        IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                        IN UINT32 packetLen
                        ) {
        DC_BEGIN_FN("W32DrDevice::MsgIrpWrite");
        MsgIrpReadWrite(pIoRequestPacket, packetLen);
        DC_END_FN();
    }

    //
    //  Dispatch an IOCTL directly to the device driver.  This will
    //  likely not work for platforms that don't match the server
    //  platform.
    //
    VOID DispatchIOCTLDirectlyToDriver(
        PRDPDR_IOREQUEST_PACKET pIoRequestPacket
        );

    //
    //  Async IO Management Functions
    //
    virtual HANDLE   StartReadIO(W32DRDEV_OVERLAPPEDIO_PARAMS *params, 
                                DWORD *status);
    virtual HANDLE   StartWriteIO(W32DRDEV_OVERLAPPEDIO_PARAMS *params,
                                DWORD *status);
    virtual HANDLE   StartIOCTL(W32DRDEV_OVERLAPPEDIO_PARAMS *params,
                                OUT DWORD *status);

    static  HANDLE   _StartIOFunc(PVOID params, DWORD *status);

    VOID CompleteIOFunc(W32DRDEV_OVERLAPPEDIO_PARAMS *params,
                        DWORD status);
    static  VOID     _CompleteIOFunc(PVOID params, DWORD status);
    virtual VOID     CancelIOFunc(W32DRDEV_OVERLAPPEDIO_PARAMS *params);
    static  VOID     _CancelIOFunc(W32DRDEV_OVERLAPPEDIO_PARAMS *params);

public:

    //
    //  Public Methods
    //

    //  Constructor/Destructor
    W32DrDeviceOverlapped(
                ProcObj *processObject, ULONG deviceID,
                const TCHAR *devicePath) : 
            W32DrDevice(processObject, deviceID, devicePath) {}

    //  Return the class name.
    virtual DRSTRING ClassName()  { return TEXT("W32DrDeviceOverlapped"); }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\drdevasc.cpp ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    drdevasc

Abstract:

    This module contains an (async) subclass of W32DrDev that uses a
    thread pool for implementations of read, write, and IOCTL handlers.

Author:

    Tad Brockway 3/23/99

Revision History:

--*/

#include <precom.h>

#define TRC_FILE  "DrDeviceAsync"

#include "drdevasc.h"
#include "proc.h"
#include "drdbg.h"
#include "w32utl.h"
#include "utl.h"
#include "w32proc.h"
#include "drfsfile.h"

#ifdef OS_WINCE
#include "filemgr.h"
#include "wceinc.h"
#endif

///////////////////////////////////////////////////////////////
//
//  W32DrDeviceAsync Members
//

W32DrDeviceAsync::W32DrDeviceAsync(
    ProcObj *processObject, ULONG deviceID,
    const TCHAR *devicePath
    ) :
    W32DrDevice(processObject, deviceID, devicePath)
/*++

Routine Description:

    Constructor

Arguments:

    processObject   -   Related process object.
    deviceID        -   Associated device ID
    devicePath      -   Associated device path for device.

Return Value:

    NA

 --*/
{
    //
    //  Get a pointer to the thread pool object.
    //
    _threadPool = &(((W32ProcObj *)processObject)->GetThreadPool());
}

HANDLE
W32DrDeviceAsync::StartIOFunc(
    IN W32DRDEV_ASYNCIO_PARAMS *params,
    OUT DWORD *status
    )
/*++

Routine Description:

    Start a generic asynchronous IO operation.

Arguments:

    params  -   Context for the IO request.
    status  -   Return status for IO request in the form of a windows
                error code.

Return Value:

    Returns a handle to an object that will be signalled when the read
    completes, if it is not completed in this function.  Otherwise, NULL
    is returned.

 --*/
{
    PRDPDR_IOCOMPLETION_PACKET pReplyPacket = NULL;
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    ULONG replyPacketSize = 0;
    ULONG irpMajor;

    DC_BEGIN_FN("W32DrDeviceAsync::StartAsyncIO");

    *status = ERROR_SUCCESS;

    //  Assert the integrity of the IO context
    ASSERT(params->magicNo == GOODMEMMAGICNUMBER);

    //
    //  Get the IO request and the IPR major.
    //
    pIoRequest = &params->pIoRequestPacket->IoRequest;

    irpMajor = pIoRequest->MajorFunction;

    //
    //  Allocate reply buffer.
    //
    if (irpMajor == IRP_MJ_DEVICE_CONTROL) {
        replyPacketSize = DR_IOCTL_REPLYBUFSIZE(pIoRequest);
    }
    else {
        replyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET);
        if (irpMajor == IRP_MJ_READ) {
            replyPacketSize += (pIoRequest->Parameters.Read.Length - 1);
        }
    }
    pReplyPacket = DrUTL_AllocIOCompletePacket(params->pIoRequestPacket,
                                        replyPacketSize) ;
    if (pReplyPacket == NULL) {
        *status = ERROR_NOT_ENOUGH_MEMORY;
        TRC_ERR((TB, _T("Failed to alloc %ld bytes."), replyPacketSize));
        goto Cleanup;
    }

    //
    //  Save the reply packet info to the context for this IO operation.
    //
    params->pIoReplyPacket      = pReplyPacket;
    params->IoReplyPacketSize   = replyPacketSize;

    //
    //  Hand the request off to the thread pool.
    //
    params->completionEvent = CreateEvent(
                                NULL,   // no attribute.
                                TRUE,   // manual reset.
                                FALSE,  // initially not signalled.
                                NULL    // no name.
                                );
    if (params->completionEvent == NULL) {
        *status = GetLastError();
        TRC_ERR((TB, _T("Error in CreateEvent:  %08X."), *status));
    }
    else {

        switch (irpMajor)
        {
        case IRP_MJ_WRITE:
            params->thrPoolReq = _threadPool->SubmitRequest(
                                    _AsyncWriteIOFunc,
                                    params, params->completionEvent
                                    ); break;
        case IRP_MJ_READ:
            params->thrPoolReq = _threadPool->SubmitRequest(
                                    _AsyncReadIOFunc,
                                    params, params->completionEvent
                                    ); break;
        case IRP_MJ_DEVICE_CONTROL:
            params->thrPoolReq = _threadPool->SubmitRequest(
                                    _AsyncIOCTLFunc,
                                    params, params->completionEvent
                                    ); break;
        }

        if (params->thrPoolReq == INVALID_THREADPOOLREQUEST) {
            *status = ERROR_SERVICE_NO_THREAD;
        }
    }

Cleanup:

    //
    //  If IO is pending, return the handle to the pending IO.
    //
    if (params->thrPoolReq != INVALID_THREADPOOLREQUEST) {
        *status = ERROR_IO_PENDING;
        DC_END_FN();
        return params->completionEvent;
    }
    //
    //  Otherwise, clean up the event handle and return NULL so that the
    //  CompleteIOFunc can be called to send the results to the server.
    //
    else {

        if (params->completionEvent != NULL) {
            CloseHandle(params->completionEvent);
            params->completionEvent = NULL;
        }

        DC_END_FN();
        return NULL;
    }
}

HANDLE
W32DrDeviceAsync::_StartIOFunc(
    IN W32DRDEV_ASYNCIO_PARAMS *params,
    OUT DWORD *status
    )
/*++

Routine Description:

    Dispatch an IO operation start to the right instance of this class.

Arguments:

    clientData  -   Context for the IO request.
    status      -   Return status for IO request in the form of a windows
                    error code.

Return Value:

    NA

 --*/
{
    return params->pObject->StartIOFunc(params, status);
}

VOID
W32DrDeviceAsync::CompleteIOFunc(
    IN W32DRDEV_ASYNCIO_PARAMS *params,
    IN DWORD status
    )
/*++

Routine Description:

    Complete an async IO operation.

Arguments:

    params  -   Context for the IO request.
    error   -   Status.

Return Value:

    NA

 --*/
{
    ULONG replyPacketSize;
    PRDPDR_IOCOMPLETION_PACKET   pReplyPacket;
    PRDPDR_IOREQUEST_PACKET      pIoRequestPacket;

    DC_BEGIN_FN("W32DrDeviceAsync::CompleteAsyncIOFunc");

    //
    //  Simplify the params.
    //
    replyPacketSize     = params->IoReplyPacketSize;
    pReplyPacket        = params->pIoReplyPacket;
    pIoRequestPacket    = params->pIoRequestPacket;

    //
    //  If the operation had been pending, then we need to get the async
    //  results.
    //
    if (params->thrPoolReq != INVALID_THREADPOOLREQUEST) {
        status = _threadPool->GetRequestCompletionStatus(params->thrPoolReq);
    }

    if (pReplyPacket != NULL) {
        if (pIoRequestPacket->IoRequest.MajorFunction == IRP_MJ_READ) {
            //
            // Make sure the reply is the minimum size required
            //
            replyPacketSize = (ULONG)FIELD_OFFSET(RDPDR_IOCOMPLETION_PACKET,
                    IoCompletion.Parameters.Read.Buffer) +
                    pReplyPacket->IoCompletion.Parameters.Read.Length;
            TRC_NRM((TB, _T("Read %d bytes"),
                    pReplyPacket->IoCompletion.Parameters.Read.Length));
        }
        else if (pIoRequestPacket->IoRequest.MajorFunction == IRP_MJ_DEVICE_CONTROL) {
            //
            // Make sure the reply is the minimum size required
            //
            replyPacketSize = (ULONG)FIELD_OFFSET(RDPDR_IOCOMPLETION_PACKET,
                    IoCompletion.Parameters.DeviceIoControl.OutputBuffer) +
                    pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBufferLength;
            TRC_NRM((TB, _T("DeviceIoControl %d bytes"),
                    pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBufferLength));
        }

        //
        //  Finish the response and send it.  The VC manager releases the reply
        //  packet on failure and on success.
        //
        TRC_NRM((TB, _T("replyPacketSize %ld."), replyPacketSize));
        pReplyPacket->IoCompletion.IoStatus = TranslateWinError(status);
        ProcessObject()->GetVCMgr().ChannelWriteEx(
                                            pReplyPacket, 
                                            replyPacketSize
                                            );
    }
    else {
        DefaultIORequestMsgHandle(pIoRequestPacket, TranslateWinError(status));
        params->pIoRequestPacket = NULL;
    }

    //
    //  ChannelWrite releases the reply packet for us.
    //
    params->pIoReplyPacket      = NULL;
    params->IoReplyPacketSize   = 0;

    //
    //  Clean up the rest of the request packet and IO parms.
    //
    if (params->thrPoolReq != INVALID_THREADPOOLREQUEST) {
        _threadPool->CloseRequest(params->thrPoolReq);
        params->thrPoolReq = INVALID_THREADPOOLREQUEST;
    }
    if (params->completionEvent != NULL) {
        CloseHandle(params->completionEvent);
        params->completionEvent = NULL;
    }

    if (params->pIoRequestPacket != NULL) {
        delete params->pIoRequestPacket;
        params->pIoRequestPacket = NULL;
    }

    DC_END_FN();
    delete params;
}

VOID
W32DrDeviceAsync::_CompleteIOFunc(
    IN W32DRDEV_ASYNCIO_PARAMS *params,
    IN DWORD status
    )
{
    params->pObject->CompleteIOFunc(params, status);
}

DWORD
W32DrDeviceAsync::AsyncIOCTLFunc(
    IN W32DRDEV_ASYNCIO_PARAMS *params
    )
/*++

Routine Description:

    Asynchrous IOCTL Function

Arguments:

    params  -   Context for the IO request.

Return Value:

    Always returns 0.

 --*/
{
    DWORD status;
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    PRDPDR_IOCOMPLETION_PACKET pReplyPacket;
    DrFile* pFile;
    HANDLE FileHandle;
    PVOID pInputBuffer = NULL;
    PVOID pOutputBuffer = NULL;

    DC_BEGIN_FN("W32DrDeviceAsync::AsyncIOCTLFunc");

    //
    //  Use DeviceIoControl to execute the IO request.
    //
    pIoRequest   = &params->pIoRequestPacket->IoRequest;
    pReplyPacket = params->pIoReplyPacket;

    if (pIoRequest->Parameters.DeviceIoControl.InputBufferLength) {
        pInputBuffer = pIoRequest + 1;
    }

    if (pIoRequest->Parameters.DeviceIoControl.OutputBufferLength) {
        pOutputBuffer = pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBuffer;
    }

    //
    //  Get File Object
    //
    pFile = _FileMgr->GetObject(pIoRequest->FileId);

    if (pFile)
        FileHandle = pFile->GetFileHandle();
    else
        FileHandle = INVALID_HANDLE_VALUE;

    if (FileHandle != INVALID_HANDLE_VALUE) {
#ifndef OS_WINCE
        if (!DeviceIoControl(FileHandle,
#else
        if (!CEDeviceIoControl(FileHandle,
#endif
                pIoRequest->Parameters.DeviceIoControl.IoControlCode,
                pInputBuffer,
                pIoRequest->Parameters.DeviceIoControl.InputBufferLength,
                pOutputBuffer,
                pIoRequest->Parameters.DeviceIoControl.OutputBufferLength,
                &(pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBufferLength),
                NULL)) {
            status = GetLastError();
            TRC_ERR((TB, _T("IOCTL Error %ld."), status));
        }
        else {
            TRC_NRM((TB, _T("IOCTL completed successfully.")));
            status = ERROR_SUCCESS;
        }
    }
    else {
        TRC_NRM((TB, _T("IOCTL completed unsuccessfully.")));
        pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBufferLength = 0;
        status = ERROR_INVALID_FUNCTION;
    }

    DC_END_FN();
    return status;
}

DWORD
W32DrDeviceAsync::_AsyncIOCTLFunc(
    IN PVOID params,
    IN HANDLE cancelEvent
    )
{
    return ((W32DRDEV_ASYNCIO_PARAMS *)params)->pObject->AsyncIOCTLFunc(
            (W32DRDEV_ASYNCIO_PARAMS *)params);
}

DWORD
W32DrDeviceAsync::AsyncReadIOFunc(
    IN W32DRDEV_ASYNCIO_PARAMS *params
    )
/*++

Routine Description:

    Asynchrous IO Read Function

Arguments:

    params  -   Context for the IO request.

Return Value:

    Always returns 0.

 --*/
{
    DWORD status;
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    DrFile* pFile;
    HANDLE FileHandle;

    DC_BEGIN_FN("W32DrDeviceAsync::AsyncReadIOFunc");

    //
    //  Get File Object
    //
    pIoRequest   = &params->pIoRequestPacket->IoRequest;

    pFile = _FileMgr->GetObject(pIoRequest->FileId);
    if (pFile)
        FileHandle = pFile->GetFileHandle();
    else
        FileHandle = INVALID_HANDLE_VALUE;

    //
    //  Use ReadFile to execute the read.
    //
    
    //
    //  Set the file pointer position if this is a seekable device
    //
    if (IsSeekableDevice()) {
        DWORD dwPtr;

        //
        //  The offset we get is from FILE_BEGIN
        //
#ifndef OS_WINCE
        dwPtr = SetFilePointer(FileHandle,
#else
        dwPtr = CESetFilePointer(FileHandle,
#endif
                       pIoRequest->Parameters.Read.OffsetLow,
                       &(pIoRequest->Parameters.Read.OffsetHigh),
                       FILE_BEGIN);

        if (dwPtr == INVALID_SET_FILE_POINTER) {
            status = GetLastError();

            if (status != NO_ERROR) {
                params->pIoReplyPacket->IoCompletion.Parameters.Read.Length = 0;
                TRC_ERR((TB, _T("Error SetFilePointer %ld."), status));
                DC_QUIT;
            }
        }
    }

#ifndef OS_WINCE
    if (!ReadFile(
#else
    if (!CEReadFile(
#endif
            FileHandle,
            params->pIoReplyPacket->IoCompletion.Parameters.Read.Buffer,
            params->pIoRequestPacket->IoRequest.Parameters.Read.Length,
            &(params->pIoReplyPacket->IoCompletion.Parameters.Read.Length),
            NULL)) {
        status = GetLastError();
        TRC_ERR((TB, _T("Error %ld."), status));
    }
    else {
        TRC_NRM((TB, _T("Read completed synchronously.")));
        status = ERROR_SUCCESS;
    }

DC_EXIT_POINT:
    DC_END_FN();
    return status;
}

DWORD
W32DrDeviceAsync::_AsyncReadIOFunc(
    IN PVOID params,
    IN HANDLE cancelEvent
    )
{
    return ((W32DRDEV_ASYNCIO_PARAMS *)params)->pObject->AsyncReadIOFunc(
            (W32DRDEV_ASYNCIO_PARAMS *)params);
}

DWORD
W32DrDeviceAsync::AsyncWriteIOFunc(
    IN W32DRDEV_ASYNCIO_PARAMS *params
    )
/*++

Routine Description:

    Asynchrous IO Write Function

Arguments:

    params  -   Context for the IO request.

Return Value:

    Always returns 0.

 --*/
{
    DC_BEGIN_FN("W32DrDeviceAsync::AsyncWriteIOFunc");

    PBYTE pDataBuffer;
    DWORD status;
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    DrFile* pFile;
    HANDLE FileHandle;

    //
    //  Get the data buffer pointer.
    //
    pIoRequest = &params->pIoRequestPacket->IoRequest;
    pDataBuffer = (PBYTE)(pIoRequest + 1);

    //
    //  Get File Object
    //
    pFile = _FileMgr->GetObject(pIoRequest->FileId);
    if (pFile)
        FileHandle = pFile->GetFileHandle();
    else
        FileHandle = INVALID_HANDLE_VALUE;

    //
    //  Use WriteFile to execute the write operation.
    //
    ASSERT(FileHandle != INVALID_HANDLE_VALUE);

    //
    //  Set the file pointer position if this is a seekable device
    //
    if (IsSeekableDevice()) {
        DWORD dwPtr;

        //
        //  The offset we get is from FILE_BEGIN
        //
#ifndef OS_WINCE
        dwPtr = SetFilePointer(FileHandle,
#else
        dwPtr = CESetFilePointer(FileHandle,
#endif
                       pIoRequest->Parameters.Write.OffsetLow,
                       &(pIoRequest->Parameters.Write.OffsetHigh),
                       FILE_BEGIN);

        if (dwPtr == INVALID_SET_FILE_POINTER) {
            status = GetLastError();

            if (status != NO_ERROR) {
                params->pIoReplyPacket->IoCompletion.Parameters.Write.Length = 0;
                TRC_ERR((TB, _T("Error SetFilePointer %ld."), status));
                return status;
            }
        }
    }

#ifndef OS_WINCE
    if (!WriteFile(
#else
    if (!CEWriteFile(
#endif
            FileHandle,
            pDataBuffer,
            pIoRequest->Parameters.Write.Length,
            &(params->pIoReplyPacket->IoCompletion.Parameters.Write.Length),
            NULL)) {
        status = GetLastError();
        TRC_ERR((TB, _T("Error %ld."), status));
    }
    else {
        TRC_NRM((TB, _T("Read completed synchronously.")));
        status = ERROR_SUCCESS;
    }

    DC_END_FN();
    return status;
}

DWORD
W32DrDeviceAsync::_AsyncWriteIOFunc(
    IN PVOID params,
    IN HANDLE cancelEvent
    )
{

    return ((W32DRDEV_ASYNCIO_PARAMS *)params)->pObject->AsyncWriteIOFunc(
            (W32DRDEV_ASYNCIO_PARAMS *)params);
}

VOID
W32DrDeviceAsync::DispatchIOCTLDirectlyToDriver(
    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket
    )
/*++

Routine Description:

    Dispatch an IOCTL directly to the device driver.  This will
    likely not work for platforms that don't match the server
    platform.

Arguments:

    pIoRequestPacket    -   Request packet received from server.

Return Value:

    The size (in bytes) of a device announce packet for this device.

 --*/
{
    W32DRDEV_ASYNCIO_PARAMS *params;
    DWORD result;

    DC_BEGIN_FN("W32DrDeviceAsync::DispatchIOCTLDirectlyToDriver");

    //
    //  Allocate and dispatch an asynchronous IO request.
    //
    params = new W32DRDEV_ASYNCIO_PARAMS(this, pIoRequestPacket);
    if (params != NULL ) {
        result = ProcessObject()->DispatchAsyncIORequest(
                                (RDPAsyncFunc_StartIO)
                                    W32DrDeviceAsync::_StartIOFunc,
                                (RDPAsyncFunc_IOComplete)
                                    W32DrDeviceAsync::_CompleteIOFunc,
                                (RDPAsyncFunc_IOCancel)
                                    W32DrDeviceAsync::_CancelIOFunc,
                                params
                                );
    }
    else {
        TRC_ERR((TB, _T("Memory alloc failed.")));
        result = ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    //  Clean up on error.
    //
    if (result != ERROR_SUCCESS) {
        if (params != NULL) {
            delete params;
        }
        delete pIoRequestPacket;

        // How can I return an error the server if I cannot allocate
        // the return buffer.  This needs to be fixed.  Otherwise, the server will
        // just hang on to an IO request that never completes.
    }

    DC_END_FN();
}

VOID
W32DrDeviceAsync::MsgIrpCreate(
        IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
        IN UINT32 packetLen
        )
/*++

Routine Description:

    Handle a "Create" IO request from the server by saving the results
    of CreateFile against our device path in our file handle.

Arguments:

    pIoRequestPacket    -   Server IO request packet.
    packetLen           -   Length of the packet

Return Value:

    NA

 --*/
{
    ULONG ulRetCode = ERROR_SUCCESS;
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    PRDPDR_IOCOMPLETION_PACKET pReplyPacket;
    ULONG ulReplyPacketSize = 0;
    DWORD result;
    DWORD flags;
    TCHAR *pFileName = NULL;
    HANDLE FileHandle;
    ULONG Information = 0;
    ULONG FileId = 0;
    DrFile *FileObj;
    DWORD CreateDisposition;
    DWORD DesiredAccess;
    DWORD FileAttributes = -1;
    BOOL  IsDirectory = FALSE;
    BOOL  fSetFileIsADirectoryFlag = FALSE;

    DC_BEGIN_FN("W32DrDeviceAsync::MsgIrpCreate");

    //
    //  This version does not work without a file name.
    //
    ASSERT(_tcslen(_devicePath));

    //
    //  Get IO request pointer.
    //
    pIoRequest = &pIoRequestPacket->IoRequest;

    //
    //  Get the file attributes, but make sure the overlapped bit is not set.
    //
    flags = pIoRequest->Parameters.Create.FileAttributes & ~(FILE_FLAG_OVERLAPPED);

    //
    //  Disable the error box popup, e.g. There is no disk in Drive A
    //
#ifndef OS_WINCE
    SetErrorMode(SEM_NOOPENFILEERRORBOX | SEM_FAILCRITICALERRORS);
#endif
    //
    // Make sure the packet length is right
    //
    if (packetLen < sizeof(RDPDR_IOREQUEST_PACKET) + pIoRequest->Parameters.Create.PathLength) {
        // Call VirtualChannelClose
        ProcessObject()->GetVCMgr().ChannelClose();
        TRC_ASSERT(FALSE, (TB, _T("Packet Length Error")));
        goto Cleanup;
    }

    //
    //  Setup parameters to pass into the createfile
    //

    pFileName = ConstructFileName((PWCHAR)(pIoRequestPacket + 1),
                                  pIoRequest->Parameters.Create.PathLength);

    if (pFileName == NULL) {
        goto Cleanup;
    }

    DesiredAccess = ConstructDesiredAccess(pIoRequest->Parameters.Create.DesiredAccess);
    CreateDisposition = ConstructCreateDisposition(pIoRequest->Parameters.Create.Disposition);
    flags |= ConstructFileFlags(pIoRequest->Parameters.Create.CreateOptions);
    
    if (GetDeviceType() == RDPDR_DTYP_FILESYSTEM) {
        FileAttributes = GetFileAttributes(pFileName);
        IsDirectory = IsDirectoryFile(DesiredAccess, pIoRequest->Parameters.Create.CreateOptions, 
                              FileAttributes, &flags);
    }

    //
    //  If we are requesting a directory and the file is not a directory
    //  We return ERROR_DIRECTORY code back to the server
    //
    if (FileAttributes != -1 && !(FileAttributes & FILE_ATTRIBUTE_DIRECTORY) && IsDirectory) {
        ulRetCode = ERROR_DIRECTORY;
        goto SendPkt;
    }

    //
    //  Check if we are trying to create a directory
    //
    if (!((pIoRequest->Parameters.Create.CreateOptions & FILE_DIRECTORY_FILE) &&
            CreateDisposition == CREATE_NEW)) {

#ifndef OS_WINCE
        FileHandle = CreateFile(pFileName, DesiredAccess,
#else
        FileHandle = CECreateFile(pFileName, DesiredAccess,
#endif
                            pIoRequest->Parameters.Create.ShareAccess & ~(FILE_SHARE_DELETE),
                            NULL,
                            CreateDisposition,
                            flags,
                            NULL
                            );

        TRC_ALT((TB, _T("CreateFile returned 0x%08x :  pFileName=%s, DesiredAccess=0x%x, ShareMode=0x%x, CreateDisposition=0x%x, flags=0x%x, LastErr=0x%x."), 
                    FileHandle, pFileName, DesiredAccess, pIoRequest->Parameters.Create.ShareAccess & ~(FILE_SHARE_DELETE), CreateDisposition, flags, ulRetCode));

        if (FileHandle != INVALID_HANDLE_VALUE || IsDirectory) {
            //
            //  We either get a valid file handle or this is a directory
            //  and we are trying to query directory information, so
            //  we will just by pass the create file
            //
            FileId = _FileMgr->GetUniqueObjectID();

            //
            //  Create the file object
            //
            if (GetDeviceType() == RDPDR_DTYP_FILESYSTEM) {
                FileObj = new DrFSFile(this, FileId, FileHandle, IsDirectory, pFileName);
            }
            else {
                FileObj = new DrFile(this, FileId, FileHandle);
            }

            if (FileObj) {
                //
                // give subclass object a change to initialize.
                //
                if( ERROR_SUCCESS != InitializeDevice( FileObj ) ) {
                    TRC_ERR((TB, _T("Failed to initialize device")));
                    delete FileObj;
                    goto Cleanup;
                }

                if (_FileMgr->AddObject(FileObj) != ERROR_NOT_ENOUGH_MEMORY) {
                    FileObj->AddRef();
                }
                else {
                    TRC_ERR((TB, _T("Failed to add File Object")));
                    delete FileObj;
                    goto Cleanup;
                }
            }
            else {
                TRC_ERR((TB, _T("Failed to alloc File Object")));
                goto Cleanup;
            }
        }
        else {
            ulRetCode = GetLastError();
            if (ulRetCode == ERROR_ACCESS_DENIED) {
                if (FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                    fSetFileIsADirectoryFlag = TRUE;
                }
            }
#ifndef OS_WINCE
            TRC_ERR((TB, _T("CreateFile failed, %ld."), ulRetCode));
#else
            TRC_NRM((TB, _T("CreateFile failed, pFileName=%s, DesiredAccess=0x%x, ShareMode=0x%x, CreateDisposition=0x%x, flags=0x%x, LastErr=0x%x."), 
                        pFileName, DesiredAccess, pIoRequest->Parameters.Create.ShareAccess & ~(FILE_SHARE_DELETE), CreateDisposition, flags, ulRetCode));
#endif
        }
    }
    else {
#ifdef OS_WINCE
      DWORD dwAttrib = 0xffffffff;
      if ( (pIoRequest->Parameters.Create.CreateOptions & FILE_DIRECTORY_FILE) && ( ((CreateDisposition == CREATE_NEW) && (CreateDirectory(pFileName, NULL))) || 
           ( (CreateDisposition == OPEN_EXISTING) && ((dwAttrib = GetFileAttributes(pFileName)) != 0xffffffff)  && 
             (dwAttrib & FILE_ATTRIBUTE_DIRECTORY) ) ) ){
#else
        if (CreateDirectory(pFileName, NULL)) {
#endif

            //
            //  Set the attributes on the directory
            //
#ifndef OS_WINCE
            if (SetFileAttributes(pFileName, pIoRequest->Parameters.Create.FileAttributes)) {
                //
                //  Create a new directory
                //
                FileId = _FileMgr->GetUniqueObjectID();
                IsDirectory = TRUE;
                FileObj = new DrFSFile(this, FileId, INVALID_HANDLE_VALUE, IsDirectory, pFileName);

                if (FileObj) {
                    if (_FileMgr->AddObject(FileObj) != ERROR_NOT_ENOUGH_MEMORY) {
                        FileObj->AddRef();
                    }
                    else {
                        TRC_ERR((TB, _T("Failed to add File Object")));
                        delete FileObj;
                        goto Cleanup;
                    }
                }
                else {
                    TRC_ERR((TB, _T("Failed to alloc File Object")));
                    goto Cleanup;
                }
            }
            else {
                ulRetCode = GetLastError();
                TRC_ERR((TB, _T("SetFileAttribute for CreateDirectory failed, %ld."), ulRetCode));
            }
#else
            //
            //  Create a new directory, for CE, you can't change the directory attributes
            //
            FileId = _FileMgr->GetUniqueObjectID();
            IsDirectory = TRUE;
            FileObj = new DrFSFile(this, FileId, INVALID_HANDLE_VALUE, IsDirectory, pFileName);

            if (FileObj) {
                if (_FileMgr->AddObject(FileObj) != ERROR_NOT_ENOUGH_MEMORY) {
                    FileObj->AddRef();
                }
                else {
                    TRC_ERR((TB, _T("Failed to add File Object")));
                    delete FileObj;
                    goto Cleanup;
                }
            }
            else {
                TRC_ERR((TB, _T("Failed to alloc File Object")));
                goto Cleanup;
            }
#endif
        }
        else {
            ulRetCode = GetLastError();
            TRC_ERR((TB, _T("CreateDirectory failed, %ld."), ulRetCode));
        }
    }

SendPkt:
    //
    //  Setup return information.
    //
    if (CreateDisposition == CREATE_ALWAYS)
        Information = FILE_OVERWRITTEN;
    else if (CreateDisposition == OPEN_ALWAYS)
        Information = FILE_OPENED;

    //
    //  Allocate reply buffer.
    //
    ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET);

    pReplyPacket = DrUTL_AllocIOCompletePacket(pIoRequestPacket, ulReplyPacketSize);

    if (pReplyPacket) {
        //
        //  Setup File Id for create IRP
        //
        pReplyPacket->IoCompletion.Parameters.Create.FileId = (UINT32) FileId;
        pReplyPacket->IoCompletion.Parameters.Create.Information = (UCHAR)Information;

        //
        //  Send the result to the server.
        //

        if (fSetFileIsADirectoryFlag) {
            result = STATUS_FILE_IS_A_DIRECTORY;
        } else {
            result = TranslateWinError(ulRetCode);
        }

        pReplyPacket->IoCompletion.IoStatus = result;
        ProcessObject()->GetVCMgr().ChannelWrite(
                (PVOID)pReplyPacket, (UINT)ulReplyPacketSize);
    }
    else {
        TRC_ERR((TB, _T("Failed to alloc %ld bytes."), ulReplyPacketSize));
    }

Cleanup:

    //
    //  Clean up the request packet and file name.
    //
    if (pFileName != NULL && pIoRequest->Parameters.Create.PathLength != 0) {
        delete pFileName;
    }

    delete pIoRequestPacket;

    DC_END_FN();
}

VOID W32DrDeviceAsync::MsgIrpReadWrite(
    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
    IN UINT32 packetLen
    )
/*++

Routine Description:

    Handles Read and Write IO requests.

Arguments:

    pIoRequestPacket    -   Server IO request packet.
    packetLen           -   Length of the packet
    
Return Value:

    NA

 --*/
{
    W32DRDEV_ASYNCIO_PARAMS *params;
    DWORD result;

    DC_BEGIN_FN("W32DrDeviceAsync::MsgIrpReadWrite");

    TRC_NRM((TB, _T("Request to write %d bytes"),
        pIoRequestPacket->IoRequest.Parameters.Write.Length));

    //
    //  Allocate and dispatch an asynchronous IO request.
    //
    params = new W32DRDEV_ASYNCIO_PARAMS(this, pIoRequestPacket);
    if (params != NULL ) {

        TRC_NRM((TB, _T("Async IO operation")));

        result = ProcessObject()->DispatchAsyncIORequest(
                        (RDPAsyncFunc_StartIO)W32DrDeviceAsync::_StartIOFunc,
                        (RDPAsyncFunc_IOComplete)W32DrDeviceAsync::_CompleteIOFunc,
                        (RDPAsyncFunc_IOCancel)W32DrDeviceAsync::_CancelIOFunc,
                        params
                        );
    }
    else {
        TRC_ERR((TB, _T("Memory alloc failed.")));
        result = ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    //  Clean up on error.
    //
    if (result != ERROR_SUCCESS) {
        if (params != NULL) {
            delete params;
        }
        delete pIoRequestPacket;

        // How can I return an error the server if I cannot allocate
        // the return buffer.  This needs to be fixed.  Otherwise, the server will
        // just hang on to an IO request that never completes.
    }

    DC_END_FN();
}

VOID
W32DrDeviceAsync::CancelIOFunc(
    IN W32DRDEV_ASYNCIO_PARAMS *params
    )
/*++

Routine Description:

    Cancel an IO operation.

Arguments:

    params  -   Context for the IO request.

Return Value:

    NA

 --*/
{
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    PRDPDR_IOCOMPLETION_PACKET pReplyPacket = NULL;
    ULONG replyPacketSize = 0;

    DC_BEGIN_FN("W32DrDeviceAsync::CancelIOFunc");

    //  Assert the integrity of the IO context
    ASSERT(params->magicNo == GOODMEMMAGICNUMBER);

    //
    //  Get the IO request.
    //
    pIoRequest = &params->pIoRequestPacket->IoRequest;

    //
    //  Allocate and send the reply buffer.  VCMgr cleans up the
    //  reply buffer for us.
    //
    replyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET);
    replyPacketSize += (pIoRequest->Parameters.Read.Length - 1);
    pReplyPacket = DrUTL_AllocIOCompletePacket(
                                params->pIoRequestPacket,
                                replyPacketSize
                                );
    if (pReplyPacket != NULL) {
        pReplyPacket->IoCompletion.IoStatus = STATUS_CANCELLED;
        ProcessObject()->GetVCMgr().ChannelWriteEx(pReplyPacket, replyPacketSize);
    }
    else {
        TRC_ERR((TB, _T("CancelIOFunc failed to alloc %ld bytes."), replyPacketSize));
    }

    //
    //  Clean up the IO request parameters.
    //
#if DBG
    memset(params->pIoRequestPacket, DRBADMEM, sizeof(RDPDR_IOREQUEST_PACKET));
#endif
    delete params->pIoRequestPacket;
    params->pIoRequestPacket = NULL;
    delete params;

    DC_END_FN();
}

VOID
W32DrDeviceAsync::_CancelIOFunc(
    IN PVOID clientData
    )
{
    W32DRDEV_ASYNCIO_PARAMS *params = (W32DRDEV_ASYNCIO_PARAMS *)clientData;

    //  Dispatch it.
    params->pObject->CancelIOFunc(params);
}

DWORD
W32DrDeviceAsync::AsyncMsgIrpCloseFunc(
    IN W32DRDEV_ASYNCIO_PARAMS *params
    )
/*++

Routine Description:

    Asynchronous Close IRP router.  

Arguments:

    params  -   Context for the IO request.

Return Value:

    NA

 --*/
{
    DC_BEGIN_FN("W32DrDeviceAsync::AsyncMsgIrpCloseFunc");

    //
    //  This function is a temporary placeholder for this release. (.NET).
    //  We may decide to route all close functionality through this parent
    //  class in a future release. For now, it should never be called.  It
    //  is up to the child class to override this function if async closes
    //  are being dispatched at their level. - TadB
    //
    ASSERT(FALSE);

    DC_END_FN();

    return ERROR_CALL_NOT_IMPLEMENTED;
}
DWORD
W32DrDeviceAsync::_AsyncMsgIrpCloseFunc(
    IN PVOID params,
    IN HANDLE cancelEvent
    )
{
    W32DRDEV_ASYNCIO_PARAMS *p = (W32DRDEV_ASYNCIO_PARAMS *)params;
    return p->pObject->AsyncMsgIrpCloseFunc(p);
}

DWORD
W32DrDeviceAsync::AsyncMsgIrpCreateFunc(
    IN W32DRDEV_ASYNCIO_PARAMS *params
    )
/*++

Routine Description:

    Asynchronous Create IRP router.  

Arguments:

    params  -   Context for the IO request.

Return Value:

    NA

 --*/
{
    DC_BEGIN_FN("W32DrDeviceAsync::AsyncMsgIrpCreateFunc");

    //
    //  This function is a temporary placeholder for this release. (.NET).
    //  We may decide to route all create functionality through this parent
    //  class in a future release. For now, it should never be called.  It
    //  is up to the child class to overide this function if async closes
    //  are being dispatched at their level. - TadB
    //
    ASSERT(FALSE);

    DC_END_FN();

    return ERROR_CALL_NOT_IMPLEMENTED;
}
DWORD
W32DrDeviceAsync::_AsyncMsgIrpCreateFunc(
    IN PVOID params,
    IN HANDLE cancelEvent
    )
{
    W32DRDEV_ASYNCIO_PARAMS *p = (W32DRDEV_ASYNCIO_PARAMS *)params;
    return p->pObject->AsyncMsgIrpCreateFunc(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\drdevasc.h ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    drdevasc

Abstract:

    This module contains an (async) subclass of W32DrDev that uses a 
    thread pool for implementations of read, write, and IOCTL handlers.  

Author:

    Tad Brockway 3/23/99

Revision History:

--*/

#ifndef __DRDEVASC_H__
#define __DRDEVASC_H__

#include "w32drdev.h"
#include "thrpool.h"


///////////////////////////////////////////////////////////////
//
//  _W32DRDEV_ASYNCIO_PARAMS
//
//  Async IO Parameters
//

class W32DrDeviceAsync;
class W32DRDEV_ASYNCIO_PARAMS : public DrObject 
{
public:

#ifdef DC_DEBUG
    ULONG                        magicNo;
#endif

    W32DrDeviceAsync             *pObject;
    PRDPDR_IOREQUEST_PACKET      pIoRequestPacket;
    PRDPDR_IOCOMPLETION_PACKET   pIoReplyPacket;
    ULONG                        IoReplyPacketSize;
    HANDLE                       completionEvent;
    ThreadPoolRequest            thrPoolReq;

    //
    //  Constructor/Destructor
    //
    W32DRDEV_ASYNCIO_PARAMS(W32DrDeviceAsync *pObj, PRDPDR_IOREQUEST_PACKET pIOP) {
        pIoRequestPacket    = pIOP;
        pObject             = pObj;
        pIoReplyPacket      = NULL;
        IoReplyPacketSize   = 0;
#if DBG
        magicNo             = GOODMEMMAGICNUMBER;
#endif
        completionEvent     = NULL;

        thrPoolReq = INVALID_THREADPOOLREQUEST;
    }
    ~W32DRDEV_ASYNCIO_PARAMS() {
        DC_BEGIN_FN("~W32DRDEV_ASYNCIO_PARAMS");
#if DBG
        ASSERT(magicNo == GOODMEMMAGICNUMBER);
#endif
        ASSERT(thrPoolReq == INVALID_THREADPOOLREQUEST);
        ASSERT(completionEvent == NULL);

        ASSERT(pIoRequestPacket == NULL);
        ASSERT(pIoReplyPacket == NULL);
#if DBG
        memset(&magicNo, DRBADMEM, sizeof(magicNo));
#endif
        DC_END_FN();
    }

    //
    //  Return the class name.
    //
    virtual DRSTRING ClassName() { return TEXT("W32DRDEV_ASYNCIO_PARAMS"); };

};


///////////////////////////////////////////////////////////////
//
//	W32DrDeviceAsync
//

class W32DrDeviceAsync : public W32DrDevice
{
protected:

    //
    //  Pointer to the thread pool.
    //
    ThreadPool *_threadPool;

    //
    //  Handles Read and Write IO requests.
    //
    VOID MsgIrpReadWrite(IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                        IN UINT32 packetLen);

    //
    //  IO Processing Functions
    //
    //  This subclass of DrDevice handles the following IO requests.  These
    //  functions may be overridden in a subclass.
    //
    //  pIoRequestPacket    -   Request packet received from server.
    //  packetLen           -   Length of the packet
    //
    //
    virtual VOID MsgIrpCreate(
                        IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                        IN UINT32 packetLen
                        );

    //  Read and Writes are handled uniformly.
    virtual VOID MsgIrpRead(
                        IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                        IN UINT32 packetLen
                        ) {
        DC_BEGIN_FN("W32DrDevice::MsgIrpRead");
        MsgIrpReadWrite(pIoRequestPacket, packetLen);
        DC_END_FN();
    }
    virtual VOID MsgIrpWrite(
                        IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                        IN UINT32 packetLen
                        ) {
        DC_BEGIN_FN("W32DrDevice::MsgIrpWrite");
        MsgIrpReadWrite(pIoRequestPacket, packetLen);
        DC_END_FN();
    }

    //
    //  Async IO Management Functions
    //
    virtual HANDLE   StartIOFunc(W32DRDEV_ASYNCIO_PARAMS *params, 
                                DWORD *status);
    static  HANDLE   _StartIOFunc(W32DRDEV_ASYNCIO_PARAMS *params, 
                                DWORD *status);

    virtual VOID    CancelIOFunc(W32DRDEV_ASYNCIO_PARAMS *params);
    static  VOID    _CancelIOFunc(PVOID params);
    
    virtual VOID    CompleteIOFunc(W32DRDEV_ASYNCIO_PARAMS *params, 
                                DWORD status);
    static VOID     _CompleteIOFunc(W32DRDEV_ASYNCIO_PARAMS *params, 
                                DWORD status);

    virtual DWORD   AsyncIOCTLFunc(W32DRDEV_ASYNCIO_PARAMS *params);
    static _ThreadPoolFunc _AsyncIOCTLFunc;

    virtual DWORD   AsyncReadIOFunc(W32DRDEV_ASYNCIO_PARAMS *params);
    static _ThreadPoolFunc _AsyncReadIOFunc;

    virtual DWORD   AsyncWriteIOFunc(W32DRDEV_ASYNCIO_PARAMS *params);
    static  _ThreadPoolFunc _AsyncWriteIOFunc;

    virtual DWORD   AsyncMsgIrpCloseFunc(W32DRDEV_ASYNCIO_PARAMS *params);
    static  _ThreadPoolFunc _AsyncMsgIrpCloseFunc;

    virtual DWORD   AsyncMsgIrpCreateFunc(W32DRDEV_ASYNCIO_PARAMS *params);
    static  _ThreadPoolFunc _AsyncMsgIrpCreateFunc;

    //
    //  Dispatch an IOCTL directly to the device driver.  This will
    //  likely not work for platforms that don't match the server
    //  platform.
    //
    VOID DispatchIOCTLDirectlyToDriver(
        IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket
        );

public:

    //
    //  Public Methods
    //

    //  Constructor
    W32DrDeviceAsync(ProcObj *processObject, ULONG deviceID,
                    const TCHAR *devicePath);

    //  Return the class name.
    virtual DRSTRING ClassName()  { return TEXT("W32DrDeviceAsync"); }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\drdevol.cpp ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    drdevol

Abstract:

    This module contains a subclass of W32DrDev that uses overlapped IO 
    implementations of read, write, and IOCTL handlers.  

Author:

    Tad Brockway 3/23/99

Revision History:

--*/

#include <precom.h>

#define TRC_FILE  "DrDeviceOverlapped"

#include "drdevol.h"
#include "proc.h"
#include "drdbg.h"
#include "w32utl.h"
#include "utl.h"
#include "w32proc.h"
#include "drfsfile.h"

VOID 
W32DrDeviceOverlapped::CancelIOFunc(
    IN W32DRDEV_OVERLAPPEDIO_PARAMS *params
    )
/*++

Routine Description:

    Start a Read IO operation.

Arguments:

    params  -   Context for the IO request.

Return Value:

    NA

 --*/
{
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    PRDPDR_IOCOMPLETION_PACKET pReplyPacket = NULL;
    ULONG replyPacketSize = 0;

    DC_BEGIN_FN("W32DrDeviceOverlapped::CancelIOFunc");

    //  Assert the integrity of the IO context
    ASSERT(params->magicNo == GOODMEMMAGICNUMBER);

    //
    //  Get the IO request.
    //
    pIoRequest = &params->pIoRequestPacket->IoRequest;

    //
    //  Allocate and send the reply buffer.  VCMgr cleans up the
    //  reply buffer for us.
    //
    replyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET);
    replyPacketSize += (pIoRequest->Parameters.Read.Length - 1);
    pReplyPacket = DrUTL_AllocIOCompletePacket(params->pIoRequestPacket, 
                                        replyPacketSize) ;
    if (pReplyPacket != NULL) {
        pReplyPacket->IoCompletion.IoStatus = STATUS_CANCELLED;
        ProcessObject()->GetVCMgr().ChannelWriteEx(pReplyPacket, replyPacketSize);
    }
    else {
        TRC_ERR((TB, _T("Failed to alloc %ld bytes."), replyPacketSize));
    }

    //
    //  Clean up the IO request parameters.
    //
    if (params->overlapped.hEvent != NULL) {
        CloseHandle(params->overlapped.hEvent);
        params->overlapped.hEvent = NULL;
    }

    delete params->pIoRequestPacket;
    params->pIoRequestPacket = NULL;
    delete params;

    DC_END_FN();
}
VOID 
W32DrDeviceOverlapped::_CancelIOFunc(
    IN W32DRDEV_OVERLAPPEDIO_PARAMS *params
    )
{
    DC_BEGIN_FN("W32DrDeviceOverlapped::_CancelIOFunc");

    //  Assert the integrity of the IO context
    ASSERT(params->magicNo == GOODMEMMAGICNUMBER);

    //  Dispatch it.
    params->pObject->CancelIOFunc(params);
    DC_END_FN();
}

VOID W32DrDeviceOverlapped::_CompleteIOFunc(PVOID clientData, 
                                  DWORD status)
/*++

Routine Description:

    Calls the instance-specific async IO completion function.

Arguments:

    params  -   Context for the IO request.
    error   -   Status.

Return Value:

    NA

 --*/
{
    W32DRDEV_OVERLAPPEDIO_PARAMS *params = (W32DRDEV_OVERLAPPEDIO_PARAMS *)clientData;

    DC_BEGIN_FN("W32DrDeviceOverlapped::_CompleteIOFunc");

    ASSERT(params->magicNo == GOODMEMMAGICNUMBER);

    params->pObject->CompleteIOFunc(params, status);

    DC_END_FN();
}

VOID 
W32DrDeviceOverlapped::MsgIrpCreate(
        IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
        IN UINT32 packetLen
        )
/*++

Routine Description:

    Handle a "Create" IO request from the server.

Arguments:

    pIoRequestPacket    -   Server IO request packet.
    packetLen           -   Length of the packet

Return Value:

    NA

 --*/
{
    ULONG ulRetCode = ERROR_SUCCESS;
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    PRDPDR_IOCOMPLETION_PACKET pReplyPacket;
    ULONG ulReplyPacketSize = 0;
    DWORD result;
    DWORD flags;
    TCHAR FileName[MAX_PATH];
    TCHAR *pFileName;
    HANDLE FileHandle;
    ULONG FileId = 0;
    DrFile *FileObj;
    DWORD CreateDisposition;
    DWORD DesiredAccess;
    DWORD FileAttributes = -1;
    DWORD Information;
    BOOL  IsDirectory = FALSE;

    DC_BEGIN_FN("W32DrDeviceOverlapped::MsgIrpCreate");

    //
    //  This version does not work without a file name.
    //
    ASSERT(_tcslen(_devicePath));

    //
    //  Get IO request pointer.
    //
    pIoRequest = &pIoRequestPacket->IoRequest;

    //
    //  Get the file attributes, but make sure the overlapped bit is set.
    //
    flags = pIoRequest->Parameters.Create.FileAttributes | FILE_FLAG_OVERLAPPED;

    //
    //  Disable the error box popup, e.g. There is no disk in Drive A 
    //
    SetErrorMode(SEM_NOOPENFILEERRORBOX | SEM_FAILCRITICALERRORS);

    //
    //  Setup parameters to pass into the createfile
    //

    pFileName = ConstructFileName((PWCHAR)(pIoRequestPacket + 1), 
                                  pIoRequest->Parameters.Create.PathLength);
    
    if (pFileName == NULL) {
        goto Cleanup;
    }



    DesiredAccess = ConstructDesiredAccess(pIoRequest->Parameters.Create.DesiredAccess);
    CreateDisposition = ConstructCreateDisposition(pIoRequest->Parameters.Create.Disposition);
    flags |= ConstructFileFlags(pIoRequest->Parameters.Create.CreateOptions);

    if (GetDeviceType() == RDPDR_DTYP_FILESYSTEM) {
        FileAttributes = GetFileAttributes(pFileName);
        IsDirectory = IsDirectoryFile(DesiredAccess, 
                                    pIoRequest->Parameters.Create.CreateOptions,
                                    FileAttributes, &flags);
    }

    //
    //  If we are requesting a directory and the file is not a directory
    //  We return ERROR_DIRECTORY code back to the server
    //
    if (FileAttributes != -1 && !(FileAttributes & FILE_ATTRIBUTE_DIRECTORY) && IsDirectory) {
        ulRetCode = ERROR_DIRECTORY;
        goto SendPkt;
    }
                            
    //
    //  Check if we are trying to create a directory
    //
    if (!((pIoRequest->Parameters.Create.CreateOptions & FILE_DIRECTORY_FILE) &&
            CreateDisposition == CREATE_NEW)) {

        FileHandle = CreateFile(pFileName, DesiredAccess,
                            pIoRequest->Parameters.Create.ShareAccess & ~(FILE_SHARE_DELETE),
                            NULL,
                            CreateDisposition,
                            flags, 
                            NULL
                            );
        
        if (FileHandle != INVALID_HANDLE_VALUE || IsDirectory) {
            //
            //  We either get a valid file handle or this is a directory
            //  and we are trying to query directory information, so
            //  we will just by pass the create file
            //
            FileId = _FileMgr->GetUniqueObjectID();

            //
            //  Create the file object
            //
            if (GetDeviceType() == RDPDR_DTYP_FILESYSTEM) {
                FileObj = new DrFSFile(this, FileId, FileHandle, IsDirectory, pFileName);                
            }
            else {
                FileObj = new DrFile(this, FileId, FileHandle);
            }

            if (FileObj) {                
                //
                // give subclass object a change to initialize.
                //
                if( ERROR_SUCCESS != InitializeDevice( FileObj ) ) {
                    TRC_ERR((TB, _T("Failed to initialize device")));
                    delete FileObj;
                    goto Cleanup;
                }

                if (_FileMgr->AddObject(FileObj) != ERROR_NOT_ENOUGH_MEMORY) {
                    FileObj->AddRef();
                }
                else {
                    TRC_ERR((TB, _T("Failed to add File Object")));
                    delete FileObj;
                    goto Cleanup;
                }
            } 
            else {
                TRC_ERR((TB, _T("Failed to alloc File Object")));
                goto Cleanup;
            }            
        }
        else {
            ulRetCode = GetLastError();
            TRC_ERR((TB, _T("CreateFile failed, %ld."), ulRetCode));
        }
    }
    else {
        if (CreateDirectory(pFileName, NULL)) {
            //
            //  Set the attributes on the directory
            //
            if (SetFileAttributes(pFileName, pIoRequest->Parameters.Create.FileAttributes)) {
                //
                //  Create a new directory
                //
                FileId = _FileMgr->GetUniqueObjectID();
                IsDirectory = TRUE;
                FileObj = new DrFSFile(this, FileId, INVALID_HANDLE_VALUE, IsDirectory, pFileName);

                if (FileObj) {
                    if (_FileMgr->AddObject(FileObj) != ERROR_NOT_ENOUGH_MEMORY) {
                        FileObj->AddRef();
                    }
                    else {
                        TRC_ERR((TB, _T("Failed to add File Object")));
                        delete FileObj;
                        goto Cleanup;
                    }
                } 
                else {
                    TRC_ERR((TB, _T("Failed to alloc File Object")));
                    goto Cleanup;
                }
            }
            else {
                ulRetCode = GetLastError();
                TRC_ERR((TB, _T("SetFileAttribute for CreateDirectory failed, %ld."), ulRetCode));
            }
        }
        else {
            ulRetCode = GetLastError();
            TRC_ERR((TB, _T("CreateDirectory failed, %ld."), ulRetCode));
        }
    }

SendPkt:

    //
    //  Setup return information.
    //
    if (CreateDisposition == CREATE_ALWAYS)
        Information = FILE_OVERWRITTEN;
    else if (CreateDisposition == OPEN_ALWAYS) 
        Information = FILE_OPENED;

    //
    //  Allocate reply buffer.
    //
    ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET);

    pReplyPacket = DrUTL_AllocIOCompletePacket(pIoRequestPacket, ulReplyPacketSize);

    if (pReplyPacket) {
        //
        //  Setup File Id for create IRP
        //
        pReplyPacket->IoCompletion.Parameters.Create.FileId = (UINT32) FileId;
        pReplyPacket->IoCompletion.Parameters.Create.Information = (UCHAR)Information;       
        
        //
        //  Send the result to the server.
        //

        result = TranslateWinError(ulRetCode);

        pReplyPacket->IoCompletion.IoStatus = result;
        ProcessObject()->GetVCMgr().ChannelWriteEx(
                (PVOID)pReplyPacket, (UINT)ulReplyPacketSize);
    }
    else {
        TRC_ERR((TB, _T("Failed to alloc %ld bytes."), ulReplyPacketSize));
    }

Cleanup:

    //
    //  Clean up the request packet and file name.
    //
    if (pFileName != NULL && pIoRequest->Parameters.Create.PathLength != 0) {
        delete pFileName;
    }
    delete pIoRequestPacket;

    DC_END_FN();
}

VOID W32DrDeviceOverlapped::MsgIrpReadWrite(
    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
    IN UINT32 packetLen
    )
/*++

Routine Description:

    Handles Read and Write IO requests.

Arguments:

    pIoRequestPacket    -   Server IO request packet.
    packetLen           -   Length of the packet

Return Value:

    NA

 --*/
{
    W32DRDEV_OVERLAPPEDIO_PARAMS *params;
    DWORD result;

    DC_BEGIN_FN("W32DrDeviceOverlapped::MsgIrpReadWrite");

    TRC_NRM((TB, _T("Request to write %d bytes"), 
        pIoRequestPacket->IoRequest.Parameters.Write.Length));

    //
    //  Allocate and dispatch an asynchronous IO request.
    //
    params = new W32DRDEV_OVERLAPPEDIO_PARAMS(this, pIoRequestPacket);
    if (params != NULL ) {

        TRC_NRM((TB, _T("Async IO operation")));
        result = ProcessObject()->DispatchAsyncIORequest(
                                (RDPAsyncFunc_StartIO)
                                    W32DrDeviceOverlapped::_StartIOFunc,
                                (RDPAsyncFunc_IOComplete)
                                    W32DrDeviceOverlapped::_CompleteIOFunc,
                                (RDPAsyncFunc_IOCancel)
                                    W32DrDeviceOverlapped::_CancelIOFunc,
                                params
                                );
    }
    else {
        TRC_ERR((TB, _T("Memory alloc failed.")));
        result = ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    //  Clean up on error.
    //
    if (result != ERROR_SUCCESS) {
        if (params != NULL) {
            delete params;
        }
        delete pIoRequestPacket;

        // How can I return an error the server if I cannot allocate
        // the return buffer.  This needs to be fixed.  Otherwise, the server will
        // just hang on to an IO request that never completes.  
    }

    DC_END_FN();
}

HANDLE 
W32DrDeviceOverlapped::StartReadIO(
    IN W32DRDEV_OVERLAPPEDIO_PARAMS *params,
    OUT DWORD *status
    )
/*++

Routine Description:

    Start an overlapped Read IO operation.

Arguments:

    params  -   Context for the IO request.
    status  -   Return status for IO request in the form of a windows
                error code.

Return Value:

    Returns a handle the pending IO object if the operation did not 
    complete.  Otherwise, NULL is returned.

 --*/
{
    PRDPDR_IOCOMPLETION_PACKET pReplyPacket = NULL;
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    ULONG replyPacketSize = 0;
    DrFile *pFile;
    HANDLE FileHandle;

    DC_BEGIN_FN("W32DrDeviceOverlapped::StartReadIO");

    //  Assert the integrity of the IO context
    ASSERT(params->magicNo == GOODMEMMAGICNUMBER);

    *status = ERROR_SUCCESS;

    //
    //  Get the IO request.
    //
    pIoRequest = &params->pIoRequestPacket->IoRequest;

    //
    //  Get File object and File handle
    //
    pFile = _FileMgr->GetObject(pIoRequest->FileId);
    if (pFile) 
        FileHandle = pFile->GetFileHandle();
    else 
        FileHandle = INVALID_HANDLE_VALUE; 

    //
    //  Allocate reply buffer.
    //
    replyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET);
    replyPacketSize += (pIoRequest->Parameters.Read.Length - 1);
    pReplyPacket = DrUTL_AllocIOCompletePacket(params->pIoRequestPacket, 
                                        replyPacketSize) ;
    if (pReplyPacket == NULL) {
        *status = ERROR_NOT_ENOUGH_MEMORY;
        TRC_ERR((TB, _T("Failed to alloc %ld bytes."), replyPacketSize));
        goto Cleanup;
    }

    //
    //  Save the reply packet info to the context for this IO operation.
    //
    params->pIoReplyPacket      = pReplyPacket;
    params->IoReplyPacketSize   = replyPacketSize;

    //
    //  Create an event for the overlapped IO.
    //
    memset(&params->overlapped, 0, sizeof(params->overlapped));
    params->overlapped.hEvent = CreateEvent(
                                NULL,   // no attribute.
                                TRUE,   // manual reset.
                                FALSE,  // initially not signalled.
                                NULL    // no name.
                                );
    if (params->overlapped.hEvent == NULL) {
        TRC_ERR((TB, _T("Failed to create event")));
        *status = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    //  Use ReadFile to execute the read. 
    //
    
    //
    //  Set the file pointer position if this is a seekable device
    //
    if (IsSeekableDevice()) {
        DWORD dwPtr;

        //
        // The offset is from FILE_BEGIN 
        //
        dwPtr = SetFilePointer(FileHandle, 
                               pIoRequest->Parameters.Read.OffsetLow,
                               &(pIoRequest->Parameters.Read.OffsetHigh),
                               FILE_BEGIN);

        if (dwPtr == INVALID_SET_FILE_POINTER) {
            *status = GetLastError();

            if (*status != NO_ERROR) {
                pReplyPacket->IoCompletion.Parameters.Read.Length = 0;
                TRC_ERR((TB, _T("Error SetFilePointer %x."), *status));
                goto Cleanup;
            }
        }
    }

    if (!ReadFile(
            FileHandle,
            pReplyPacket->IoCompletion.Parameters.Read.Buffer,
            pIoRequest->Parameters.Read.Length,
            &(pReplyPacket->IoCompletion.Parameters.Read.Length),
            &params->overlapped)) {
        //
        //  If IO is pending.
        //
        *status = GetLastError();
        if (*status == ERROR_IO_PENDING) {
            TRC_NRM((TB, _T("Pending read IO.")));
        }
        else {
            TRC_ERR((TB, _T("Error %x."), *status));
            goto Cleanup;
        }
    }
    else {
        TRC_NRM((TB, _T("Read completed synchronously.")));
        *status = ERROR_SUCCESS;
    }

Cleanup:

    //
    //  If IO is pending, return the handle to the pending IO.
    //
    if (*status == ERROR_IO_PENDING) {
        DC_END_FN();
        return params->overlapped.hEvent;
    }
    //
    //  Otherwise, clean up the event handle and return NULL so that the 
    //  CompleteIOFunc can be called to send the results to the server.
    //
    else {
        CloseHandle(params->overlapped.hEvent);
        params->overlapped.hEvent = NULL;

        DC_END_FN();
        return NULL;
    }
}

HANDLE 
W32DrDeviceOverlapped::StartWriteIO(
    IN W32DRDEV_OVERLAPPEDIO_PARAMS *params,
    OUT DWORD *status
    )
/*++

Routine Description:

    Start an overlapped Write IO operation.

Arguments:

    params  -   Context for the IO request.
    status  -   Return status for IO request in the form of a windows
                error code.

Return Value:

    Returns a handle the pending IO object if the operation did not 
    complete.  Otherwise, NULL is returned.

 --*/
{
    PBYTE pDataBuffer;
    PRDPDR_IOCOMPLETION_PACKET pReplyPacket = NULL;
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    ULONG replyPacketSize = 0;
    DrFile *pFile;
    HANDLE FileHandle;

    DC_BEGIN_FN("W32DrDeviceOverlapped::StartWriteIO");

    *status = ERROR_SUCCESS;

    //  Assert the integrity of the IO context
    ASSERT(params->magicNo == GOODMEMMAGICNUMBER);

    //
    //  Get the IO request.
    //
    pIoRequest = &params->pIoRequestPacket->IoRequest;

    //
    //  Get File object and File handle
    //
    pFile = _FileMgr->GetObject(pIoRequest->FileId);
    if (pFile) 
        FileHandle = pFile->GetFileHandle();
    else 
        FileHandle = INVALID_HANDLE_VALUE; 

    //
    //  Allocate reply buffer.
    //
    replyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET);
    pReplyPacket = DrUTL_AllocIOCompletePacket(params->pIoRequestPacket, 
                                        replyPacketSize) ;
    if (pReplyPacket == NULL) {
        *status = ERROR_NOT_ENOUGH_MEMORY;
        TRC_ERR((TB, _T("Failed to alloc %ld bytes."), replyPacketSize));
        goto Cleanup;
    }

    //
    //  Save the reply packet info to the context for this IO operation.
    //
    params->pIoReplyPacket      = pReplyPacket;
    params->IoReplyPacketSize   = replyPacketSize;

    //
    //  Create an event for the overlapped IO.
    //
    memset(&params->overlapped, 0, sizeof(params->overlapped));
    params->overlapped.hEvent = CreateEvent(
                                NULL,   // no attribute.
                                TRUE,   // manual reset.
                                FALSE,  // initially not signalled.
                                NULL    // no name.
                                );
    if (params->overlapped.hEvent == NULL) {
        TRC_ERR((TB, _T("Failed to create event")));
        *status = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    //  Get the data buffer pointer.
    //
    pDataBuffer = (PBYTE)(pIoRequest + 1);

    //
    //  Use WriteFile to execute the write operation. 
    //
    ASSERT(FileHandle != INVALID_HANDLE_VALUE);

    //
    //  Set the file pointer position if this is a seekable device
    //
    if (IsSeekableDevice()) {
        DWORD dwPtr;

        //
        // The offset is from FILE_BEGIN 
        //
        dwPtr = SetFilePointer(FileHandle, 
                               pIoRequest->Parameters.Write.OffsetLow,
                               &(pIoRequest->Parameters.Write.OffsetHigh),
                               FILE_BEGIN);

        if (dwPtr == INVALID_SET_FILE_POINTER) {
            *status = GetLastError();

            if (*status != NO_ERROR) {
                pReplyPacket->IoCompletion.Parameters.Write.Length = 0;
                TRC_ERR((TB, _T("Error SetFilePointer %x."), *status));
                goto Cleanup;
            }
        }
    }

    if (!WriteFile(
            FileHandle,
            pDataBuffer,
            pIoRequest->Parameters.Write.Length,
            &(pReplyPacket->IoCompletion.Parameters.Write.Length),
            &params->overlapped)) {
        //
        //  If IO is pending.
        //
        *status = GetLastError();
        if (*status == ERROR_IO_PENDING) {
            TRC_NRM((TB, _T("Pending IO.")));
        }
        else {
            TRC_NRM((TB, _T("Error %x."), *status));
            goto Cleanup;
        }
    }
    else {
        TRC_NRM((TB, _T("Read completed synchronously.")));
        *status = ERROR_SUCCESS;
    }

Cleanup:

    //
    //  If IO is pending, return the handle to the pending IO.
    //
    if (*status == ERROR_IO_PENDING) {
        DC_END_FN();
        return params->overlapped.hEvent;
    }
    //
    //  Otherwise, clean up the event handle and return NULL so that the 
    //  CompleteIOFunc can be called to send the results to the server.
    //
    else {
        CloseHandle(params->overlapped.hEvent);
        params->overlapped.hEvent = NULL;

        DC_END_FN();
        return NULL;
    }
}

HANDLE 
W32DrDeviceOverlapped::StartIOCTL(
    IN W32DRDEV_OVERLAPPEDIO_PARAMS *params,
    OUT DWORD *status
    )
/*++

Routine Description:

    Start a generic overlapped IOCTL operation.

Arguments:

    params  -   Context for the IO request.
    status      -   Return status for IO request in the form of a windows
                    error code.

Return Value:

    Returns a handle the pending IO object if the operation did not 
    complete.  Otherwise, NULL is returned.

 --*/
{
    PRDPDR_IOCOMPLETION_PACKET pReplyPacket = NULL;
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    ULONG replyPacketSize = 0;
    DrFile *pFile;
    HANDLE FileHandle;
    PVOID pInputBuffer = NULL;
    PVOID pOutputBuffer = NULL;


    DC_BEGIN_FN("W32DrDeviceOverlapped::StartIOCTL");

    *status = ERROR_SUCCESS;

    //  Assert the integrity of the IO context
    ASSERT(params->magicNo == GOODMEMMAGICNUMBER);

    //
    //  Get the IO request.
    //
    pIoRequest = &params->pIoRequestPacket->IoRequest;

    //
    //  Get File object and File handle
    //
    pFile = _FileMgr->GetObject(pIoRequest->FileId);
    if (pFile) 
        FileHandle = pFile->GetFileHandle();
    else 
        FileHandle = INVALID_HANDLE_VALUE; 

    //
    //  Allocate reply buffer.
    //
    replyPacketSize = DR_IOCTL_REPLYBUFSIZE(pIoRequest);
    pReplyPacket = DrUTL_AllocIOCompletePacket(params->pIoRequestPacket, 
                                        replyPacketSize) ;
    if (pReplyPacket == NULL) {
        *status = ERROR_NOT_ENOUGH_MEMORY;
        TRC_ERR((TB, _T("Failed to alloc %ld bytes."), replyPacketSize));
        goto Cleanup;
    }

    if (pIoRequest->Parameters.DeviceIoControl.InputBufferLength) {
        pInputBuffer = pIoRequest + 1;
    }
     
    if (pIoRequest->Parameters.DeviceIoControl.OutputBufferLength) {
        pOutputBuffer = pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBuffer;
    }

    //
    //  Save the reply packet info to the context for this IO operation.
    //
    params->pIoReplyPacket      = pReplyPacket;
    params->IoReplyPacketSize   = replyPacketSize;

    //
    //  Create an event for the overlapped IO.
    //
    memset(&params->overlapped, 0, sizeof(params->overlapped));
    params->overlapped.hEvent = CreateEvent(
                                NULL,   // no attribute.
                                TRUE,   // manual reset.
                                FALSE,  // initially not signalled.
                                NULL    // no name.
                                );
    if (params->overlapped.hEvent == NULL) {
        TRC_NRM((TB, _T("Failed to create event")));
        *status = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    //  Use DeviceIoControl to execute the IO request.
    //
    if (FileHandle != INVALID_HANDLE_VALUE) {
        if (!DeviceIoControl(FileHandle, 
                pIoRequest->Parameters.DeviceIoControl.IoControlCode,
                pInputBuffer, 
                pIoRequest->Parameters.DeviceIoControl.InputBufferLength,
                pOutputBuffer,
                pIoRequest->Parameters.DeviceIoControl.OutputBufferLength,
                &(pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBufferLength),
                &params->overlapped)) {
            //
            //  If IO is pending.
            //
            *status = GetLastError();
            if (*status == ERROR_IO_PENDING) {
                TRC_NRM((TB, _T("Pending IO.")));
            }
            else {
                TRC_NRM((TB, _T("Error %ld."), *status));
                goto Cleanup;
            }
        }
        else {
            *status = ERROR_SUCCESS;
        }
    }
    else {
        TRC_NRM((TB, _T("IOCTL completed unsuccessfully.")));
        pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBufferLength = 0;
        *status = ERROR_INVALID_FUNCTION;
    }

Cleanup:

    //
    //  If IO is pending, return the handle to the pending IO.
    //
    if (*status == ERROR_IO_PENDING) {
        DC_END_FN();
        return params->overlapped.hEvent;
    }
    //
    //  Otherwise, return NULL so that the CompleteIOFunc can be called
    //  to send the results to the server.
    //
    else {
        DC_END_FN();
        if (params->overlapped.hEvent) {
            CloseHandle(params->overlapped.hEvent);
            params->overlapped.hEvent = NULL;
        }
        return NULL;
    }
}

VOID 
W32DrDeviceOverlapped::CompleteIOFunc(
    IN W32DRDEV_OVERLAPPEDIO_PARAMS *params,
    IN DWORD status
    )
/*++

Routine Description:

    Complete an async IO operation.

Arguments:

    params  -   Context for the IO request.
    error   -   Status.

Return Value:

    NA

 --*/
{
    ULONG replyPacketSize;
    PRDPDR_IOCOMPLETION_PACKET   pReplyPacket;
    PRDPDR_IOREQUEST_PACKET      pIoRequestPacket;
    PRDPDR_DEVICE_IOREQUEST      pIoRequest;
    DrFile *pFile;
    HANDLE FileHandle;
    DWORD Temp;

    DC_BEGIN_FN("W32DrDeviceOverlapped::CompleteIOFunc");

    //
    //  Simplify the params.
    //
    replyPacketSize     = params->IoReplyPacketSize;
    pReplyPacket        = params->pIoReplyPacket;
    pIoRequestPacket    = params->pIoRequestPacket;

    pIoRequest = &pIoRequestPacket->IoRequest;
    
    if (pReplyPacket != NULL) {
    
        //
        //  Get File object and File handle
        //
        pFile = _FileMgr->GetObject(pIoRequest->FileId);
        if (pFile) 
            FileHandle = pFile->GetFileHandle();
        else 
            FileHandle = INVALID_HANDLE_VALUE; 
    
        //
        //  If the operation had been pending, then we need to get
        //  the overlapped results.
        //
        if (params->overlapped.hEvent != NULL) {
            LPDWORD bytesTransferred = NULL;
            ULONG irpMajor;
    
            irpMajor = pIoRequestPacket->IoRequest.MajorFunction;
            if (irpMajor == IRP_MJ_READ) {
                bytesTransferred = &pReplyPacket->IoCompletion.Parameters.Read.Length;
            }
            else if (irpMajor == IRP_MJ_WRITE) {
                bytesTransferred = 
                    &pReplyPacket->IoCompletion.Parameters.Write.Length;
            }
            else if (irpMajor == IRP_MJ_DEVICE_CONTROL) {
                bytesTransferred = 
                    &pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBufferLength;

                // IOCTL_SERIAL_WAIT_ON_MASK corresponds to WatiCommEvent(), for this call
                // *bytesTransferred returned from GetOverlappedResult() is undefined,
                // so we manually set OutputBufferLength to sizeof(DWORD) here
                if (params->pIoRequestPacket->IoRequest.Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_WAIT_ON_MASK) {
                    pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBufferLength = sizeof(DWORD);
                    bytesTransferred = &Temp;
                }
            }                         
            else {
                ASSERT(FALSE);
            }
    
            if (!GetOverlappedResult(
                        FileHandle,
                        &params->overlapped,
                        bytesTransferred,
                        TRUE    // wait
                        )) {
                status = GetLastError();
                TRC_ERR((TB, _T("GetOverlappedResult %ld."), status));
            }
    
            CloseHandle(params->overlapped.hEvent);
            params->overlapped.hEvent = NULL;
        }
    
        if (pIoRequestPacket->IoRequest.MajorFunction == IRP_MJ_READ) {
            //
            // Make sure the reply is the minimum size required
            //
            replyPacketSize = (ULONG)FIELD_OFFSET(RDPDR_IOCOMPLETION_PACKET, 
                    IoCompletion.Parameters.Read.Buffer) + 
                    pReplyPacket->IoCompletion.Parameters.Read.Length;
            TRC_NRM((TB, _T("Read %d bytes"), 
                    pReplyPacket->IoCompletion.Parameters.Read.Length));
        }
        else if (pIoRequestPacket->IoRequest.MajorFunction == IRP_MJ_DEVICE_CONTROL) {
            //
            // Make sure the reply is the minimum size required
            //
            replyPacketSize = (ULONG)FIELD_OFFSET(RDPDR_IOCOMPLETION_PACKET, 
                    IoCompletion.Parameters.DeviceIoControl.OutputBuffer) + 
                    pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBufferLength;
            TRC_NRM((TB, _T("DeviceIoControl %d bytes"), 
                    pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBufferLength));
        }
    
        //
        //  Finish the response and send it.
        //
        TRC_NRM((TB, _T("replyPacketSize %ld."), replyPacketSize));
        pReplyPacket->IoCompletion.IoStatus = TranslateWinError(status);
        ProcessObject()->GetVCMgr().ChannelWriteEx(pReplyPacket, replyPacketSize);
    }
    else {
        //
        //  We previously failed allocating reply packet, try again
        //
        DefaultIORequestMsgHandle(pIoRequestPacket, ERROR_NOT_ENOUGH_MEMORY);
        params->pIoRequestPacket = NULL;
    }
    
    //
    //  ChannelWrite releases the reply packet for us.
    //
    params->pIoReplyPacket      = NULL;
    params->IoReplyPacketSize   = 0;

    //
    //  Clean up the rest of the request packet and IO parms.
    //
    if (params->pIoRequestPacket != NULL) {
        delete params->pIoRequestPacket;
        params->pIoRequestPacket = NULL;
    }

    DC_END_FN();
    delete params;
}

VOID
W32DrDeviceOverlapped::DispatchIOCTLDirectlyToDriver(
    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket
    )
/*++

Routine Description:

    Dispatch an IOCTL directly to the device driver.  This will
    likely not work for platforms that don't match the server
    platform.

Arguments:

    pIoRequestPacket    -   Request packet received from server.

Return Value:

    The size (in bytes) of a device announce packet for this device.

 --*/
{
    W32DRDEV_OVERLAPPEDIO_PARAMS *params;
    DWORD result;

    DC_BEGIN_FN("W32DrDeviceOverlapped::DispatchIOCTLDirectlyToDriver");

    //
    //  Allocate and dispatch an asynchronous IO request.
    //
    params = new W32DRDEV_OVERLAPPEDIO_PARAMS(this, pIoRequestPacket);
    if (params != NULL ) {
        result = ProcessObject()->DispatchAsyncIORequest(
                                (RDPAsyncFunc_StartIO)
                                    W32DrDeviceOverlapped::_StartIOFunc,
                                (RDPAsyncFunc_IOComplete)
                                    W32DrDeviceOverlapped::_CompleteIOFunc,
                                (RDPAsyncFunc_IOCancel)
                                    W32DrDeviceOverlapped::_CancelIOFunc,
                                params
                                );
    }
    else {
        TRC_ERR((TB, _T("Memory alloc failed.")));
        result = ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    //  Clean up on error.
    //
    if (result != ERROR_SUCCESS) {
        if (params != NULL) {
            delete params;
        }
        delete pIoRequestPacket;

        // How can I return an error the server if I cannot allocate
        // the return buffer.  This needs to be fixed.  Otherwise, the server will
        // just hang on to an IO request that never completes.  
    }

    DC_END_FN();
}

HANDLE 
W32DrDeviceOverlapped::_StartIOFunc(
    IN PVOID clientData,
    OUT DWORD *status
    )
/*++

Routine Description:

    Dispatch an IO operation start to the right instance of this class.

Arguments:

    clientData  -   Context for the IO request.
    status      -   Return status for IO request in the form of a windows
                    error code.

Return Value:

    NA

 --*/
{
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    W32DRDEV_OVERLAPPEDIO_PARAMS *params = (W32DRDEV_OVERLAPPEDIO_PARAMS *)clientData;

    DC_BEGIN_FN("W32DrDeviceOverlapped::_StartIOFunc");

    //  Assert the integrity of the IO context
    ASSERT(params->magicNo == GOODMEMMAGICNUMBER);

    //
    //  Get the IO request.
    //
    pIoRequest = &params->pIoRequestPacket->IoRequest;

    //
    //  Dispatch it.
    //
    DC_END_FN();
    switch(pIoRequest->MajorFunction) {
        ASSERT(params->pObject != NULL);
        case IRP_MJ_READ:   
            return params->pObject->StartReadIO(params, status);
        case IRP_MJ_WRITE:  
            return params->pObject->StartWriteIO(params, status);
        case IRP_MJ_DEVICE_CONTROL:  
            return params->pObject->StartIOCTL(params, status);
        default:            ASSERT(FALSE);
                            return NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\drfsfile.cpp ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    drfsfile

Abstract:

    This module implements file specific operations for file system redirection.
    
Author:

    JoyC  11/10/1999

Revision History:

--*/


#include <precom.h>
#define TRC_FILE  "drfsfile"
#include "drfsfile.h"


///////////////////////////////////////////////////////////////
//
//	W32File Methods
//
//

DrFSFile::DrFSFile(
    DrDevice      *Drive, 
    ULONG         FileId,
    DRFILEHANDLE  FileHandle,
    BOOL          IsDirectory,
    DRSTRING      FileName) : DrFile(Drive, FileId, FileHandle)
/*++

Routine Description:

    Constructor

Arguments:


Return Value:

    NA

 --*/
{
#ifndef OS_WINCE
    unsigned len;
#endif

    DC_BEGIN_FN("DrFSFile::DrFSFile");

    _SearchHandle = INVALID_TS_FILEHANDLE;
    _NotifyHandle = INVALID_TS_FILEHANDLE;
    _IsDirectory = IsDirectory;
    _bCancel = FALSE;

    //
    //  Record the file name.
    //
    ASSERT(FileName != NULL);

#ifndef OS_WINCE
    len = _tcslen(FileName) + 1;
    _FileName = new TCHAR[len];
    if (_FileName != NULL) {
        //Buffer is allocated large enough for the name
        StringCchCopy(_FileName,len, FileName);
    }
#else
    _tcsncpy(_FileName, FileName, MAX_PATH-1);
#endif
}

DrFSFile::~DrFSFile()
/*++

Routine Description:

    Destructor

Arguments:

Return Value:

    NA

 --*/
{
    DC_BEGIN_FN("DrFSFile::~DrFSFile");

    ASSERT(_SearchHandle == INVALID_TS_FILEHANDLE);
    ASSERT(_NotifyHandle == INVALID_TS_FILEHANDLE);
#ifndef OS_WINCE    
    if (_FileName) {
        delete _FileName;
    }    
#endif
}

DRFILEHANDLE DrFSFile::GetSearchHandle()
{
    return _SearchHandle;
}

DRFILEHANDLE DrFSFile::GetNotifyHandle()
{
    return _NotifyHandle;
}

BOOL DrFSFile::SetSearchHandle(DRFILEHANDLE SearchHandle)
{
    _SearchHandle = SearchHandle;
    
    return TRUE;    
}
 
BOOL DrFSFile::SetNotifyHandle(DRFILEHANDLE NotifyHandle)
{
    BOOL ret = FALSE;

    if (_bCancel == FALSE) {
        _NotifyHandle = NotifyHandle;
        ret = TRUE;
    }
    
    return ret;    
}

BOOL DrFSFile::Close() 
/*++

Routine Description:

    Close the file

Arguments:
    NA
    
Return Value:

    TRUE/FALSE

 --*/
{
    DC_BEGIN_FN("DrFSFile::Close");

    _bCancel = TRUE;

    if (_SearchHandle != INVALID_TS_FILEHANDLE) {
        FindClose(_SearchHandle);
        _SearchHandle = INVALID_TS_FILEHANDLE;
    }
        
#if (!defined(OS_WINCE)) || (!defined(WINCE_SDKBUILD))
    if (_NotifyHandle != INVALID_TS_FILEHANDLE) {
        FindCloseChangeNotification(_NotifyHandle);
        _NotifyHandle = INVALID_TS_FILEHANDLE;
    }
#endif

    return DrFile::Close();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\drfile.h ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    Drfile

Abstract:

    This module provides generic device/file handle operation
    
Author:

    JoyC 11/10/1999

Revision History:

--*/

#ifndef __DRFILE_H__
#define __DRFILE_H__

#include <rdpdr.h>
#include "drobject.h"
#include "smartptr.h"


///////////////////////////////////////////////////////////////
//
//  Defines and Macros
//                      
///////////////////////////////////////////////////////////////

#define DRFILEHANDLE            HANDLE
#define INVALID_TS_FILEHANDLE   INVALID_HANDLE_VALUE

//
//	DrFile Class Declaration
//
//
class DrDevice;

class DrFile: public RefCount
{
protected:

    ULONG          _FileId;
    DRFILEHANDLE   _FileHandle;
    DrDevice*      _Device;
    
public:

    //
    //  Constructor
    //
    DrFile(DrDevice *Device, ULONG FileId, DRFILEHANDLE FileHandle);

    virtual ~DrFile();

    //
    //  Return the class name.
    //
    virtual DRSTRING ClassName()  { return TEXT("DrFile"); }

    ULONG GetID() {
        return _FileId;
    }

    DRFILEHANDLE GetFileHandle() {
        return _FileHandle;
    }

    virtual ULONG GetDeviceType();

    virtual BOOL Close();
};

#endif // DRFILE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\drobject.cpp ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    drobject

Abstract:

    This module defines the common parent for all client-side
	 RDP device redirection classes, DrObject.

Author:

    Tad Brockway 3/23/99

Revision History:

--*/

#include <precom.h>

#define TRC_FILE  "DrObject"

#include "drobject.h"

///////////////////////////////////////////////////////////////
//
//	DrObject Members
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\drobject.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    drobject

Abstract:

    This module defines the common parent for all client-side
	RDP device redirection classes, DrObject.

Author:

    Tad Brockway 3/23/99

Revision History:

--*/

#ifndef __DROBJ_H__
#define __DROBJ_H__

#include "drdbg.h"
#include "atrcapi.h"


///////////////////////////////////////////////////////////////
//
//	DrObject
//
//

class DrObject 
{
private:

    BOOL    _isValid;

protected:

    //
    //  Remember if this instance is valid.
    //
    VOID SetValid(BOOL set)     { _isValid = set;   }  

public:

    //
    //  Mark an instance as allocated or bogus.
    //
#if DBG
    ULONG   _magicNo;
#endif

    //  
    //  Constructor/Destructor
    //
    DrObject() : _isValid(TRUE) 
    {
        DC_BEGIN_FN("DrObject::DrObject");

#if DBG
        _magicNo = GOODMEMMAGICNUMBER;
#endif

        DC_END_FN();
    }

    virtual ~DrObject() 
    {
        DC_BEGIN_FN("DrObject::~DrObject");
#if DBG
        ASSERT(_magicNo == GOODMEMMAGICNUMBER);
        memset(&_magicNo, DRBADMEM, sizeof(_magicNo));
#endif        
        DC_END_FN();
    }

    //
    //  Return whether this class instance is valid.
    //
    virtual BOOL IsValid()           
    {
        DC_BEGIN_FN("DrObject::IsValid");
        ASSERT(_magicNo == GOODMEMMAGICNUMBER);
        DC_END_FN();
        return _isValid; 
    }

    //
    //  Memory Management Operators
    //

    inline void *__cdecl operator new(size_t sz, DWORD tag=DROBJECT_TAG)
    {
        void *ptr = LocalAlloc(LPTR, sz);
        return ptr;
    }

    inline void __cdecl operator delete(void *ptr)
    {
        LocalFree(ptr);
    }

    //
    //  Return the class name.
    //
    virtual DRSTRING ClassName() = 0;

};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\drfsfile.h ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    Drfsfile

Abstract:

    This module provides file specific operations for file system redirection
    
Author:

    JoyC 11/10/1999

Revision History:

--*/

#ifndef __DRFSFILE_H__
#define __DRFSFILE_H__

#include <rdpdr.h>
#include "drobject.h"
#include "drdev.h"
#include "drfile.h"


///////////////////////////////////////////////////////////////
//
//  Defines and Macros
//                      
///////////////////////////////////////////////////////////////
//
//	DrFSFile Class Declaration
//
//
class DrDevice;

class DrFSFile : public DrFile
{
private:

    DRFILEHANDLE _SearchHandle;
    DRFILEHANDLE _NotifyHandle;
    BOOL         _IsDirectory; 
#ifndef OS_WINCE
    DRSTRING     _FileName;
#else
    TCHAR        _FileName[MAX_PATH];
#endif

    BOOL         _bCancel;

public:

    //
    //  Constructor
    //
    DrFSFile(DrDevice *Drive, ULONG FileId, DRFILEHANDLE FileHandle, BOOL IsDirectory, DRSTRING FileName);    

    virtual ~DrFSFile();

    DRSTRING GetFileName() {
        return _FileName;
    }

    DRFILEHANDLE GetSearchHandle(); 
    DRFILEHANDLE GetNotifyHandle();
    BOOL SetSearchHandle(DRFILEHANDLE SearchHandle);
    BOOL SetNotifyHandle(DRFILEHANDLE NotifyHandle);

    BOOL IsDirectory() {
        return _IsDirectory;
    }

    virtual BOOL Close();
};

#endif // DRFSFILE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\drprn.cpp ===
/*++

    Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    drprn.cpp
    
Abstract:

    Platform-Independent Printer Class for TS Device Redirection

Author:

    Tad Brockway 8/99

Revision History:

--*/

#include <precom.h>

#define TRC_FILE  "drprn"

#include "proc.h"
#include "drprn.h"
#include "atrcapi.h"
#include "drdbg.h"

#ifdef OS_WIN32
#include "w32utl.h"
#endif


///////////////////////////////////////////////////////////////
//
//	Defines
//


///////////////////////////////////////////////////////////////
//
//	DrPRN Members
//

DrPRN::DrPRN(
    IN const DRSTRING printerName, 
    IN const DRSTRING driverName, 
    IN const DRSTRING pnpName, 
    IN BOOL isDefaultPrinter 
    )
/*++

Routine Description:

    Constructor

Arguments:

    printerName -   Name of printing device.
    driverName  -   Name of print driver name.
    pnpName     -   PnP ID String
    default     -   Is this the default printer?

Return Value:

    NA

 --*/
{
    BOOL memAllocFailed = FALSE;

    DC_BEGIN_FN("DrPRN::DrPRN");

    //
    //  Remember if we are the default printer.
    //
    _isDefault = isDefaultPrinter;
    _isNetwork = FALSE;
    _isTSqueue = FALSE;

    //
    //  Initialize Cached Data.
    //
    _cachedData     = NULL;
    _cachedDataSize = 0;

    //
    //  Record printer name parameters.
    //
    _printerName = NULL;
    _driverName  = NULL;
    _pnpName     = NULL;
    if (!DrSetStringValue(&_printerName, printerName)) {
        memAllocFailed = TRUE;
    }
    else if (!memAllocFailed && !DrSetStringValue(&_driverName, driverName)) {
        memAllocFailed = TRUE;
    }
    else if (!memAllocFailed && !DrSetStringValue(&_pnpName, pnpName)) {
        memAllocFailed = TRUE;
    }

    //
    //  Check and record our status,
    //
    if (memAllocFailed) {
        TRC_ERR((TB, _T("Memory allocation failed.")));
        SetValid(FALSE);
    }
    else {
        SetValid(TRUE);
    }

    DC_END_FN();
}

DrPRN::~DrPRN()
/*++

Routine Description:

    Destructor

Arguments:

Return Value:

    NA

 --*/
{
    DC_BEGIN_FN("DrPRN::~DrPRN");

    //
    //  Release Cached Data.
    //
    if (_cachedData != NULL) {
        delete _cachedData;
    }

    //
    //  Release local printer parameters.
    //
    DrSetStringValue(&_printerName, NULL);
    DrSetStringValue(&_driverName, NULL);
    DrSetStringValue(&_pnpName, NULL);

    DC_END_FN();
}

DWORD 
DrPRN::SetCachedDataSize(ULONG size)
/*++

Routine Description:

    Set the size of the cached data buffer, in bytes.

Arguments:

    NA

Return Value:

    NA

 --*/
{
    DWORD status;

    DC_BEGIN_FN("DrPRN::SetCachedDataSize");

    //
    //  Reallocate the current cached data buffer.
    //
    if (_cachedData != NULL) {
        delete _cachedData;
        _cachedData = NULL;
    }
    _cachedData = (PRDPDR_PRINTER_UPDATE_CACHEDATA)new BYTE[size];
    if (_cachedData == NULL) {
        TRC_NRM((TB, _T("Can't allocate %ld bytes."), size));
        status = ERROR_INSUFFICIENT_BUFFER;
    }
    else {
        status = ERROR_SUCCESS;
        _cachedDataSize = size;
    }
    DC_END_FN();

    return status;
}

DWORD
DrPRN::UpdatePrinterCacheData(
    PBYTE *ppbPrinterData,
    PULONG pulPrinterDataLen,
    PBYTE pbConfigData,
    ULONG ulConfigDataLen
    )
/*++

Routine Description:

    Updates cached printer data. Creates a new buffer for the new printer 
    data to be cached. Deletes the old buffer.

Arguments:

    ppbPrinterData - pointer to buffer pointer, contains old cache data buffer
        pointer when entering and new buffer pointer when leaving.

    pulPrinterDataLen - pointer to a dword location, contains length of the old
        buffer length when entering and new buffer length when leaving.

    pbConfigData - pointer to the new config data.

    ulConfigDataLen - length of the above config data.

Return Value:

    Windows Error Code.

 --*/
{
    DC_BEGIN_FN("DrPRN::UpdatePrinterCacheData");
    ULONG ulError;

    ULONG ulPrinterDataLen;
    PRDPDR_PRINTER_ADD_CACHEDATA pPrinterData;

    ULONG ulNewPrinterDataLen;
    PRDPDR_PRINTER_ADD_CACHEDATA pNewPrinterData;


    ulPrinterDataLen = *pulPrinterDataLen;
    pPrinterData = (PRDPDR_PRINTER_ADD_CACHEDATA)(*ppbPrinterData);

    ulNewPrinterDataLen =
        (ulPrinterDataLen - pPrinterData->CachedFieldsLen) +
            ulConfigDataLen;

    //
    // allocate new bufffer.
    //
    pNewPrinterData = (PRDPDR_PRINTER_ADD_CACHEDATA)
        new BYTE[ulNewPrinterDataLen];

    if( pNewPrinterData == NULL ) {
        ulError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // copy old data.
    //
    memcpy(
        (PBYTE)pNewPrinterData,
        (PBYTE)pPrinterData,
        (size_t)(ulPrinterDataLen - pPrinterData->CachedFieldsLen));

    //
    // copy new data.
    //
    memcpy(
        (PBYTE)pNewPrinterData +
            (ulPrinterDataLen - pPrinterData->CachedFieldsLen),
        pbConfigData,
        (size_t)ulConfigDataLen );

    //
    // set new cache data length.
    //
    pNewPrinterData->CachedFieldsLen = ulConfigDataLen;

    //
    // set return parameters.
    //
    *ppbPrinterData = (PBYTE)pNewPrinterData;
    *pulPrinterDataLen = ulNewPrinterDataLen;

    //
    // delete old buffer.
    //
    delete (PBYTE)pPrinterData;

    ulError = ERROR_SUCCESS;

Cleanup:

    DC_END_FN();
    return ulError;
}

DWORD
DrPRN::UpdatePrinterNameInCacheData(
    PBYTE *ppbPrinterData,
    PULONG pulPrinterDataLen,
    PBYTE pPrinterName,
    ULONG ulPrinterNameLen
    )
/*++

Routine Description:

    Updates printer data with a new printer name.
    Creates a new buffer for the new printer data to be
    cached. Deletes the old buffer.

Arguments:

    ppbPrinterData - pointer to buffer pointer, contains old cache data buffer
        pointer when entering and new buffer pointer when leaving.

    pulPrinterDataLen - pointer to a dword location, contains length of the old
        buffer length when entering and new buffer length when leaving.

    pPrinterName - new printer name.

Return Value:

    Windows Error Code.

 --*/
{
    DC_BEGIN_FN("DrPRN::UpdatePrinterNameInCacheData");
    ULONG ulError;

    ASSERT(ppbPrinterData != NULL);

    ASSERT(pulPrinterDataLen != NULL);

    ULONG ulPrinterDataLen = *pulPrinterDataLen;
    PRDPDR_PRINTER_ADD_CACHEDATA pPrinterData = (PRDPDR_PRINTER_ADD_CACHEDATA)(*ppbPrinterData);

    //
    // Calculate new length
    //

    ULONG ulNewPrinterDataLen =
        (ulPrinterDataLen - pPrinterData->PrinterNameLen) +
            ulPrinterNameLen;

    //
    // allocate new bufffer.
    //

    PRDPDR_PRINTER_ADD_CACHEDATA pNewPrinterData = (PRDPDR_PRINTER_ADD_CACHEDATA)
        new BYTE[ulNewPrinterDataLen];

    PBYTE pDest = (PBYTE)pNewPrinterData;
    PBYTE pSource = (PBYTE)pPrinterData;

    if( pNewPrinterData == NULL ) {
        ulError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // copy old data.
    //

    // copy everything till printer name

    memcpy(
        pDest,
        pSource,
        (size_t)(ulPrinterDataLen - (pPrinterData->PrinterNameLen + pPrinterData->CachedFieldsLen))
        );

    //
    // copy new printer name
    //

    pDest += (ulPrinterDataLen - (pPrinterData->PrinterNameLen + pPrinterData->CachedFieldsLen));

    memcpy(
        pDest,
        pPrinterName,
        (size_t)ulPrinterNameLen
        );

    //
    // copy the rest of the fields.
    //

    pDest += ulPrinterNameLen;
    pSource += (ulPrinterDataLen - pPrinterData->CachedFieldsLen);

    memcpy(
        pDest,
        pSource,
        (size_t)pPrinterData->CachedFieldsLen );

    //
    // set new printer name length.
    //

    pNewPrinterData->PrinterNameLen = ulPrinterNameLen;

    //
    // set return parameters.
    //


    *ppbPrinterData = (PBYTE)pNewPrinterData;
    *pulPrinterDataLen = ulNewPrinterDataLen;

    //
    // delete old buffer.
    //

    delete [] (PBYTE)pPrinterData;

    ulError = ERROR_SUCCESS;

Cleanup:

    DC_END_FN();
    return ulError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\drobjmgr.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    drobjmgr

Abstract:

    DrObjectMgr manages a list of client-side RDP objects.

Author:

    Joy Chik 11/30/99

Revision History:

--*/

#ifndef __DROBJMGR_H__
#define __DROBJMGR_H__

#include <rdpdr.h>
#include "drobject.h"
#include "drdev.h"
#include "drfile.h"

template <class T>
class DrObjectMgr;
class DrDevice;
class DrFile;


///////////////////////////////////////////////////////////////
//
//  DrObjectMgr
//
//  Locking:    Member functions will implicitly lock the state
//              of the list.  External explicit locking is also
//              available and recommended when iterating through
//              devices.
//
//  GetFirstObject/GetNextObject:
//              Used in conjunction to iterate through the list
//              of objects.  Any changes to the contents of list 
//              resets the current object pointer.
//

template<class T>
class DrObjectMgr : public DrObject
{

private:
    
    ///////////////////////////////////////////////////////////////
    //
    //  Typedefs
    //
    typedef struct _DROBJECTLIST_NODE {
        ULONG              magicNo;
        T                  *object;
        _DROBJECTLIST_NODE *next;
        _DROBJECTLIST_NODE *prev;
    } DROBJECTLIST_NODE, *PDROBJECTLIST_NODE;

    //
    //  Private Data
    //
    BOOL _initialized;

    //  Linked list of object instances.
    PDROBJECTLIST_NODE   _listHead;

    //  Global (to an instance of this class) monotonically
    //  increasing object identifer.
    ULONG                _objectID;

    //  Current object for GetFirst/GetNext routines.
    PDROBJECTLIST_NODE   _currentNode;

    //  The lock.
    CRITICAL_SECTION     _cs;

    //
    //  Monitor the lock count in checked builds.
    //
#if DBG
    LONG    _lockCount;
#endif

    //  Object Count
    ULONG                _count;

    //  Remember if we are in the middle of checking the integrity of an
    //  instance of this class.
#if DBG
    BOOL _integrityCheckInProgress;
#endif

    //
    //  Private Methods
    //
    VOID deleteNode(PDROBJECTLIST_NODE node);

    PDROBJECTLIST_NODE FindNode(DRSTRING name,
                                ULONG objectType);

    PDROBJECTLIST_NODE FindNode(ULONG id);

    //
    //  Periodically, check the integrity of the list in debug builds.
    //
#if DBG
    VOID CheckListIntegrity();
#endif

public:
    //
    //  Public Methods
    //

    //  Constructor/Destructor
    DrObjectMgr();
    virtual ~DrObjectMgr();

    //  Initialize
    DWORD Initialize();    

    //  Lock/unlock the list of objects for multithreaded access.
    //  Member functions that require that the list of objects be locked
    //  will do implicitly.
    VOID    Lock();
    VOID    Unlock();

    //  Add/remove an object.
    DWORD  AddObject(T *object);
    T *RemoveObject(const DRSTRING name, ULONG objectType);
    T *RemoveObject(ULONG id);

    //  Test for existence of an object.
    BOOL ObjectExists(const DRSTRING name);
    BOOL ObjectExists(const DRSTRING name, ULONG deviceType);
    BOOL ObjectExists(ULONG id);

    //  Return an object.
    T *GetObject(const DRSTRING name);
    T *GetObject(const DRSTRING name, ULONG objectType);
    T *GetObject(ULONG id);

    //
    //  Iterate through objects, sequentially.
    //
    ULONG        GetCount() { return _count; }
    T           *GetObjectByOffset(ULONG ofs);
    T           *GetFirstObject();
    T           *GetNextObject();

    //  Return whether this class instance is valid.
#if DBG
    virtual BOOL IsValid()           
    {
        CheckListIntegrity();
        return DrObject::IsValid();
    }
#endif

    //  Get a unique object ID ... assuming that this function is the
    //  clearinghouse for all objects associated with an instance of this
    //  class.
    ULONG GetUniqueObjectID();

    //  Return the class name.
    virtual DRSTRING ClassName()  { return TEXT("DrObjectMgr"); }
};



///////////////////////////////////////////////////////////////
//
//  DrObjectMgr Inline Functions
//
//

//
//  lock
//
template<class T>
inline VOID    DrObjectMgr<T>::Lock() {
    DC_BEGIN_FN("DrObjectMgr::Lock");
    EnterCriticalSection(&_cs);
#if DBG
    InterlockedIncrement(&_lockCount);
#endif
    DC_END_FN();
}

//
//  unlock
//
template<class T>
inline VOID    DrObjectMgr<T>::Unlock() {
    DC_BEGIN_FN("DrObjectMgr::Unlock");
#if DBG
    if (InterlockedDecrement(&_lockCount) < 0) {
        ASSERT(FALSE);
    }
#endif
    LeaveCriticalSection(&_cs);
    DC_END_FN();
}

//
//  GetUniqueObjectID
//
template<class T>
inline ULONG    DrObjectMgr<T>::GetUniqueObjectID() {
    ULONG tmp;

    Lock();
    tmp = ++_objectID;
    Unlock();

    return tmp;
}

//
//  deleteNode
//    
template<class T>
inline 
VOID DrObjectMgr<T>::deleteNode(PDROBJECTLIST_NODE node) {
    if (node == _listHead) {
        _listHead = _listHead->next;

    }
    else {
        node->prev->next = node->next;
        if (node->next != NULL) {
            node->next->prev = node->prev;
        }
    }
    //
    //  Delete the node.
    //
    delete node;
}

//
//  Constructor
//
template<class T>
DrObjectMgr<T>::DrObjectMgr() {

    //
    //  Initialize the lock count for debug builds.
    //
#if DBG
    _lockCount = 0;
#endif

    //
    //  Not valid until initialized.
    //
    _initialized = FALSE;
    SetValid(FALSE);

    //
    //  Initialize the list head.
    //
    _listHead = NULL;


    //
    //  Initialize the unique device ID counter.
    //
    _objectID = 0;

    //
    //  Initialize the device count.
    //
    _count = 0;

    //
    //  Initialize the GetFirst/GetNext device pointer.
    //
    _currentNode = NULL;
}

//
//  Destructor
//
template<class T>
DrObjectMgr<T>::~DrObjectMgr() {

    DC_BEGIN_FN("DrObjectMgr::~DrObjectMgr");

    //
    //  Can't do anything if we are not initialized.
    //
    if (!_initialized) {
        return;
    }

    Lock();

    //
    //  The lock count should be one if we are being cleaned up.
    //
    ASSERT(_lockCount == 1);

    //
    //  Release the object list.
    //
    if (_listHead != NULL) {
        //
        //  Assert that the device list is empty.  All device instances
        //  should have been removed by the time this function is called.
        //
        ASSERT(_listHead->next == NULL);

        delete _listHead;
    }

    Unlock();

    //
    //  Clean up the critical section object.
    //
    DeleteCriticalSection(&_cs);

    DC_END_FN();
}

//
//  Initialize
//
template<class T>
DWORD DrObjectMgr<T>::Initialize() {
    DC_BEGIN_FN("DrObjectMgr::Initialize");

    DWORD result = ERROR_SUCCESS;

    //
    //  Initialize the critical section.
    //
    __try {
        InitializeCriticalSection(&_cs);
        _initialized = TRUE;
        SetValid(TRUE);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        result = GetExceptionCode();
    }

    return result;
}

//
//  FindNode
//
template<class T>
__TYPENAME DrObjectMgr<T>::PDROBJECTLIST_NODE DrObjectMgr<T>::FindNode(DRSTRING name, ULONG objectType) {

    PDROBJECTLIST_NODE cur;

    cur = _listHead;
    while (cur != NULL) {
        T *obj = cur->object;
        if (!STRICMP(name, obj->GetName())
            && (obj->GetDeviceType() == objectType)) {
            break;
        }
        else {
            cur = cur->next;
        }
    }
    return cur;
}

//
//  FindNode
//
template<class T>
__TYPENAME DrObjectMgr<T>::PDROBJECTLIST_NODE DrObjectMgr<T>::FindNode(ULONG id) {
    PDROBJECTLIST_NODE cur;

    DC_BEGIN_FN("DrObjectMgr::FindNode");

    cur = _listHead;
    while (cur != NULL) {
        T *obj = cur->object;
        if (id == obj->GetID()) {
            break;
        }
        else {
            cur = cur->next;
        }
    }

    DC_END_FN();

    return cur;
}
 
//
//  AddObject
//
template<class T>
DWORD  DrObjectMgr<T>::AddObject(T *object) {

    DWORD ret = ERROR_SUCCESS;
    PDROBJECTLIST_NODE newNode;

    DC_BEGIN_FN("DrObjectMgr::AddObject");

    ASSERT(IsValid());

    //
    //  Make sure that the object doesn't already exist in the
    //  list.
    //
    ASSERT(FindNode(object->GetID()) == NULL);

    //
    //  Allocate the node.
    //
    newNode = new DROBJECTLIST_NODE;
    if (newNode != NULL) {

#if DBG
        newNode->magicNo = GOODMEMMAGICNUMBER;
#endif
        newNode->object = object;

        //
        //  Add the node to the list.
        //
        Lock();
        _count++;
        if (_listHead == NULL) {
            _listHead = newNode;
            _listHead->next = NULL;
            _listHead->prev = NULL;
        }
        else {
            _listHead->prev = newNode;
            newNode->prev   = NULL;
            newNode->next   = _listHead;
            _listHead = newNode;
        }
        Unlock();
    }
    else {
        TRC_ERR((TB, _T("Failed to alloc device.")));
        ret = ERROR_NOT_ENOUGH_MEMORY;
    }

    ASSERT(IsValid());

    DC_END_FN();
    return ret;
}

//
//  RemoveObject
//
template<class T>
T *DrObjectMgr<T>::RemoveObject(
                const DRSTRING name, 
                ULONG objectType
                ) {

    PDROBJECTLIST_NODE node;
    T *object;

    DC_BEGIN_FN("DrObjectMgr::RemoveObject");

    ASSERT(IsValid());

    //
    //  Find the object.
    //
    Lock();
    if ((node = FindNode(name, deviceType)) != NULL) {
        object = node->object;
        deleteNode(node);
       
        //
        //  Decrement the count.
        //
        _count--;
    }
    else {
        object = NULL;
    }

    Unlock();

    ASSERT(IsValid());

    DC_END_FN();
    return object;
}

//
//  RemoveObject
//
template<class T>
T *DrObjectMgr<T>::RemoveObject(ULONG id) {
    PDROBJECTLIST_NODE node;
    T *object;

    DC_BEGIN_FN("DrObjectMgr::RemoveObject");

    ASSERT(IsValid());

    //
    //  Find the object.
    //
    Lock();
    if ((node = FindNode(id)) != NULL) {
        object = node->object;
        deleteNode(node);

        //
        //  Decrement the count.
        //
        _count--;
    }
    else {
        object = NULL;
    }

    Unlock();

    ASSERT(IsValid());

    DC_END_FN();
    return object;
}

//
//  ObjectExists
//
template<class T>
BOOL DrObjectMgr<T>::ObjectExists(const DRSTRING name,
                               ULONG objectType) {
    PDROBJECTLIST_NODE node;

    DC_BEGIN_FN("DrObjectMgr::ObjectExists");

    ASSERT(IsValid());

    Lock();
    node = FindNode(name, objectType);
    Unlock();

    ASSERT(IsValid());

    DC_END_FN();
    return node != NULL;
}

//
//  ObjectExists
//
template<class T>
BOOL DrObjectMgr<T>::ObjectExists(ULONG id) {
    PDROBJECTLIST_NODE node;

    DC_BEGIN_FN("DrObjectMgr::ObjectExists");

    ASSERT(IsValid());

    Lock();
    node = FindNode(id);
    Unlock();

    ASSERT(IsValid());

    DC_END_FN();
    return node != NULL;
}

//
//  Return an object.
//
template<class T>
T *DrObjectMgr<T>::GetObject(const DRSTRING name,
                                ULONG objectType) {
    PDROBJECTLIST_NODE node;
    T *object;

    DC_BEGIN_FN("DrObjectMgr::GetObject");

    ASSERT(IsValid());

    Lock();
    if ((node = FindNode(name, objectType)) != NULL) {
        object = node->object;
    }
    else {
        object = NULL;
    }
    Unlock();

    ASSERT(IsValid());

    DC_END_FN();
    return object;
}

//
//  Return an object.
//
template<class T>
T *DrObjectMgr<T>::GetObject(ULONG id) {
    PDROBJECTLIST_NODE node;
    T *object;

    DC_BEGIN_FN("DrObjectMgr::GetObject");

    ASSERT(IsValid());

    Lock();
    if ((node = FindNode(id)) != NULL) {
        object = node->object;
    }
    else {
        object = NULL;
    }
    Unlock();

    ASSERT(IsValid());

    DC_END_FN();
    return object;
}

//
//  Get object at the specified offset. 
//
template<class T>
T *DrObjectMgr<T>::GetObjectByOffset(ULONG ofs) {
    PDROBJECTLIST_NODE cur;
    ULONG cnt = 0;

    DC_BEGIN_FN("DrObjectMgr::GetObjectByOffset");

    ASSERT(IsValid());

    Lock();
    for (cur=_listHead, cnt=0; (cur!=NULL) && (cnt != ofs); cnt++) {
        ASSERT(cur->magicNo == GOODMEMMAGICNUMBER);
        cur = cur->next;
    }
    Unlock();

    ASSERT(IsValid());

    DC_END_FN();
    return cur->object;
}

//
//  Return the first object and set the internal current object 
//  pointer to the beginning of the list.  Returns NULL at the end 
//  of the list.
//
template<class T>
T *DrObjectMgr<T>::GetFirstObject() {
    T *object;

    DC_BEGIN_FN("DrObjectMgr::GetFirstObject");

    ASSERT(IsValid());

    Lock();
    _currentNode = _listHead;
    if (_currentNode != NULL) {
        object = _currentNode->object;
    }
    else {
        object = NULL;
    }
    Unlock();

    ASSERT(IsValid());

    DC_END_FN();
    return object;
}

//
//  Return the next object and update the internal current object
//  pointer.  Returns NULL at the end of the list.
//
template<class T>
T *DrObjectMgr<T>::GetNextObject() {
    T *object;

    DC_BEGIN_FN("DrObjectMgr::GetNextObject");

    ASSERT(IsValid());

    Lock();
    if (_currentNode != NULL) {
        _currentNode = _currentNode->next;
    }
    if (_currentNode != NULL) {
        object = _currentNode->object;
        ASSERT(_currentNode->magicNo == GOODMEMMAGICNUMBER);
    }
    else {
        object = NULL;
    }
    Unlock();

    ASSERT(IsValid());

    DC_END_FN();
    return object;
}

//
//  Check the integrity of the list.
//
#if DBG
template<class T>
VOID DrObjectMgr<T>::CheckListIntegrity() {
    ULONG cnt;
    ULONG i;

    DC_BEGIN_FN("DrObjectMgr::CheckListIntegrity");

    Lock();

    //
    //  Make sure we don't re-enter ourselves.
    //
    if (!_integrityCheckInProgress) {
        _integrityCheckInProgress = TRUE;
    }
    else {
        Unlock();
        DC_END_FN();
        return;
    }

    //
    //  Use offsets to iterate throught the list of objects.
    //
    cnt = GetCount();
    for (i=0; i<cnt; i++) {
        T *object = GetObjectByOffset(i);
        ASSERT(object != NULL);
        ASSERT(object->_magicNo == GOODMEMMAGICNUMBER);
    }

    _integrityCheckInProgress = FALSE;
    Unlock();

    DC_END_FN();
}
#endif

typedef DrObjectMgr<DrDevice> DrDeviceMgr;
typedef DrObjectMgr<DrFile> DrFileMgr;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\drprn.h ===
/*++

    Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    drprn
    
Abstract:

    Platform-Independent Printer Class for TS Device Redirection

Author:

    Tad Brockway 3/23/99

Revision History:

--*/

#ifndef __DRPRN_H__
#define __DRPRN_H__


///////////////////////////////////////////////////////////////
//
//	Defines
//

#define MAX_DEF_PRINTER_ENTRY (MAX_PATH * 3 + 3)


///////////////////////////////////////////////////////////////
//
//	DrPRN
//

class DrPRN
{
protected:

    BOOL        _isValid;

    //
    //  Is this the default printer.
    //
    BOOL        _isDefault:1;
    BOOL        _isNetwork:1;
    BOOL        _isTSqueue:1;

    //
    //  Params for the printer we are redirecting.
    //
    DRSTRING    _printerName;
    DRSTRING    _driverName;
    DRSTRING    _pnpName;

    //
    //  Remember if this instance is valid.
    //
    VOID SetValid(BOOL set)     { _isValid = set;   }  

    //
    //  Cached Configuration Data
    //
    PVOID       _cachedData;
    ULONG       _cachedDataSize;

    //
    //  Functions for setting/getting printer parameters.
    //
    virtual BOOL    SetPrinterName(const DRSTRING name);
    virtual BOOL    SetDriverName(const DRSTRING name);
    virtual BOOL    SetPnPName(const DRSTRING name);

    virtual const DRSTRING GetPrinterName();
    virtual const DRSTRING GetDriverName();
    virtual const DRSTRING GetPnPName();

    //
    //  Creates a new buffer for the new printer data to be
    //  cached. Deletes the old buffer.
    //
    static DWORD UpdatePrinterCacheData(
        PBYTE *ppbPrinterData,
        PULONG pulPrinterDataLen,
        PBYTE pbConfigData,
        ULONG ulConfigDataLen
        );

    //
    //  Updates printer data with a new printer name.
    //
    static DWORD UpdatePrinterNameInCacheData(
        PBYTE *ppbPrinterData,
        PULONG pulPrinterDataLen,
        PBYTE pPrinterName,
        ULONG ulPrinterNameLen
        );

public:

    //
    //  Constructor/Destructor
    //
    DrPRN(const DRSTRING printerName, const DRSTRING driverName, 
         const DRSTRING pnpName, BOOL 
         isDefaultPrinter);
    virtual ~DrPRN();

    //
    //  Set the size of the cached data buffer, in bytes.
    //
    virtual DWORD SetCachedDataSize(ULONG size);

    //
    //  To notify the printer object that the cached data has been restored
    //  in case it needs to read information out of the cached data.
    //
    virtual VOID CachedDataRestored() {
        //  Do nothing by default.
    }

    //
    //  Get a pointer to the cached data buffer.
    //
    virtual PBYTE GetCachedDataPtr() {
        return (PBYTE)_cachedData;
    }

    //
    //  Get the size of cached data.
    //
    virtual ULONG GetCachedDataSize() {
        return _cachedDataSize;
    }

    //
    //  Return whether this class instance is valid.
    //
    virtual BOOL IsValid()           
    {
        return _isValid; 
    }

    //
    //  Set whether this is a network printer.
    //
    virtual void SetNetwork(BOOL fNetwork)           
    {
        _isNetwork = fNetwork; 
    }

    //
    //  Set whether this is a TS redirected printer.
    //
    virtual void SetTSqueue(BOOL fTSqueue)           
    {
        _isTSqueue = fTSqueue; 
    }
};


///////////////////////////////////////////////////////////////
//
//	DrPRN Inline Members
//

inline BOOL DrPRN::SetPrinterName(const DRSTRING name)
{
    return DrSetStringValue(&_printerName, name);
}
inline BOOL DrPRN::SetDriverName(const DRSTRING name)
{
    return DrSetStringValue(&_driverName, name);
}
inline BOOL DrPRN::SetPnPName(const DRSTRING name)
{
    return DrSetStringValue(&_pnpName, name);
}

inline const DRSTRING DrPRN::GetPrinterName()
{
    return _printerName;
}
inline const DRSTRING DrPRN::GetDriverName()
{
    return _driverName;
}
inline const DRSTRING DrPRN::GetPnPName()
{
    return _pnpName;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\drstr.cpp ===
/*++

    Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    drstr.cpp

Abstract:

    Misc. String Utils

Author:

    Tad Brockway

Revision History:

--*/

#include <precom.h>

#define TRC_FILE  "drstr"

#include "drstr.h"
#include "atrcapi.h"
#include "drdbg.h"

BOOL 
DrSetStringValue(
    IN OUT DRSTRING *str, 
    IN const DRSTRING value
    )
/*++

Routine Description:

    Set a string value after resizing the data member.

Arguments:

    string  -   String to set/resize.
    value   -   Value to set string to.

Return Value:

    TRUE on success.  Otherwise, FALSE

 --*/
{
    ULONG len;
    BOOL ret = TRUE;
    HRESULT hr;

    DC_BEGIN_FN("DrSetStringValue");

    //
    //  Release the current name.
    //
    if (*str != NULL) {
        delete *str;
    }

    //
    //  Allocate the new name.
    //
    if (value != NULL) {
        len = (STRLEN(value) + 1);
        *str = new TCHAR[len];
        if (*str != NULL) {
            hr = StringCchCopy(*str, len, value);
            TRC_ASSERT(SUCCEEDED(hr),
                    (TB,_T("Str copy for long string failed: 0x%x"),hr));
        }
        else {
            TRC_ERR((TB, _T("Can't allocate %ld bytes for string."), len));
            ret = FALSE;
        }
    }
    else {
        *str = NULL;
    }

    DC_END_FN();
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\drstatus.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    drstatus.h

Abstract:

    Status Codes from ntstatus.h.  These are what the server expects in
    response to its requests.

Author:

    Tad Brockway 3/23/99

Revision History:

--*/

#ifndef __DRSTATUS_H__
#define __DRSTATUS_H__

#define NTSTATUS long

#ifdef OS_WINCE
#include <wince.h>
#endif

#undef STATUS_SUCCESS     
#undef STATUS_UNSUCCESSFUL             
#undef STATUS_CANCELLED                
#undef STATUS_INSUFFICIENT_RESOURCES   
#undef STATUS_BUFFER_TOO_SMALL         
#undef STATUS_INVALID_PARAMETER        
#undef STATUS_INVALID_PARAMETER        
#undef STATUS_TIMEOUT                  
#undef STATUS_OPEN_FAILED

#undef STATUS_NO_MEMORY

#define STATUS_SUCCESS                  ((NTSTATUS)0x00000000L)
#define STATUS_NO_MORE_FILES            ((NTSTATUS)0x80000006L)
#define STATUS_UNSUCCESSFUL             ((NTSTATUS)0xC0000001L)
#define STATUS_CANCELLED                ((NTSTATUS)0xC0000120L)
#define STATUS_INSUFFICIENT_RESOURCES   ((NTSTATUS)0xC000009AL)
#define STATUS_BUFFER_TOO_SMALL         ((NTSTATUS)0xC0000023L)
#define STATUS_INVALID_PARAMETER        ((NTSTATUS)0xC000000DL)
#define STATUS_TIMEOUT                  ((NTSTATUS)0x00000102L)
#define STATUS_NO_MEMORY                ((NTSTATUS)0xC0000017L)
#define STATUS_UNEXPECTED_IO_ERROR      ((NTSTATUS)0xC00000E9L)
#define STATUS_OPEN_FAILED              ((NTSTATUS)0xC0000136L)
#define STATUS_NOT_A_DIRECTORY          ((NTSTATUS)0xC0000103L)
#define STATUS_NO_SUCH_FILE             ((NTSTATUS)0xC000000FL)
#define STATUS_OBJECT_NAME_EXISTS       ((NTSTATUS)0x40000000L)
#define STATUS_INVALID_DEVICE_REQUEST   ((NTSTATUS)0xC0000010L)
#define STATUS_OBJECT_NAME_COLLISION    ((NTSTATUS)0xC0000035L)
#define STATUS_NOT_SUPPORTED            ((NTSTATUS)0xC00000BBL)
#define STATUS_ACCESS_DENIED            ((NTSTATUS)0xC0000022L)
#define STATUS_INVALID_PARAMETER        ((NTSTATUS)0xC000000DL)
#define STATUS_OBJECT_PATH_NOT_FOUND    ((NTSTATUS)0xC000003AL)
#define STATUS_SHARING_VIOLATION        ((NTSTATUS)0xC0000043L)
#define STATUS_DISK_FULL                ((NTSTATUS)0xC000007FL)
#define STATUS_FILE_IS_A_DIRECTORY      ((NTSTATUS)0xC00000BAL)
#if ((!defined(OS_WINCE)) || (defined(WINCE_SDKBUILD)))
#define STATUS_MEDIA_WRITE_PROTECTED    ((NTSTATUS)0xc00000a2L)
#define STATUS_PRIVILEGE_NOT_HELD       ((NTSTATUS)0xc0000061L)
#define STATUS_DEVICE_NOT_READY         ((NTSTATUS)0xc00000a3L)
#define STATUS_UNRECOGNIZED_MEDIA       ((NTSTATUS)0xc0000014L)
#endif
#define STATUS_UNRECOGNIZED_VOLUME      ((NTSTATUS)0xC000014FL)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\drprt.cpp ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    DrPRT

Abstract:

    This module defines methods for the DrPRT class.  
    
    The job of the DrPRT class is to translate IO requests received 
    from the TS server into communications (serial/parallel) port IO 
    functions and to handle generic IO port functionality in a 
    platform-independent way to promote reuse between the various TS 
    client platforms, with respect to implementing comm port 
    redirection.

    Subclasses of DrPRT will implement the specific comm functions
    for their respective platform.

Author:

    Tad Brockway 5/26/99

Revision History:

--*/

#include <precom.h>

#define TRC_FILE  "DrPRT"

#include <stdarg.h>
#include "drprt.h"
#include "drdbg.h"
#include "utl.h"


///////////////////////////////////////////////////////////////
//
//	DrPRT Methods
//
//

DrPRT::DrPRT(const DRSTRING portName,
             ProcObj *processObject) : _isValid(TRUE) 
/*++

Routine Description:

    Constructor

Arguments:

    processObject   -   Associated Process Object
    portName        -   Name of the port.
    deviceID        -   Device ID for the port.
    devicePath      -   Path that can be opened via CreateFile for port.

Return Value:

    NA

 --*/
{
    ULONG len;
    HRESULT hr;

    DC_BEGIN_FN("DrPRT::DrPRT");

    //
    //  Initialize data members.
    //
    _traceFile = NULL;
    _procObj   = processObject;

    //
    //  Record the port name.
    //
    ASSERT(portName != NULL);
    len = (STRLEN(portName) + 1);
    _portName = new TCHAR[len];
    if (_portName != NULL) {
        hr = StringCchCopy(_portName, len, portName);
        TRC_ASSERT(SUCCEEDED(hr),
            (TB,_T("Pre-checked str copy failed: 0x%x"), hr));
    }

    //
    //  Check and record our status,
    //
    if (_portName == NULL) {
        TRC_ERR((TB, _T("Memory allocation failed.")));
        SetValid(FALSE);
    }

    DC_END_FN();
}

DrPRT::~DrPRT()
/*++

Routine Description:

    Destructor

Arguments:

    NA

Return Value:

    NA

 --*/
{
    DC_BEGIN_FN("DrPRT::~DrPRT");

    //
    //  Release the port name.
    //
    if (_portName != NULL) {
        delete _portName;
    }

    //
    //  Close the trace log.
    //
    if (_traceFile != NULL) {
        fclose(_traceFile);
    }

    DC_END_FN();
}

VOID DrPRT::GetDevAnnounceData(
    IN PRDPDR_DEVICE_ANNOUNCE pDeviceAnnounce,
    IN ULONG deviceID,
    IN ULONG deviceType
    )
/*++

Routine Description:

    Add a device announce packet for this device to the input buffer. 

Arguments:

    pDeviceAnnounce -   Device Announce Buf for this Device
    deviceID        -   ID of port device.  This is a field in the
                        Device Announce Buf.
    deviceType      -   Type of port device.

Return Value:

    NA

 --*/
{
    DC_BEGIN_FN("DrPRT::GetDevAnnounceData");

    ASSERT(IsValid());
    if (!IsValid()) { 
        DC_END_FN();
        return; 
    }

    //
    //  Record the device ID.
    //
    pDeviceAnnounce->DeviceType = deviceType;
    pDeviceAnnounce->DeviceId   = deviceID;

    //
    //  Record the port name in ANSI.
    //
#ifdef UNICODE
    RDPConvertToAnsi(_portName, (LPSTR)pDeviceAnnounce->PreferredDosName,
                  sizeof(pDeviceAnnounce->PreferredDosName)
                  );
#else
    STRCPY((char *)pDeviceAnnounce->PreferredDosName, _portName);
#endif

    DC_END_FN();
}

ULONG DrPRT::GetDevAnnounceDataSize()
/*++

Routine Description:

    Return the size (in bytes) of a device announce packet for
    this device.

Arguments:

    NA

Return Value:

    The size (in bytes) of a device announce packet for this device.

 --*/
{
    ULONG size;

    DC_BEGIN_FN("DrPRT::GetDevAnnounceDataSize");

    ASSERT(IsValid());
    if (!IsValid()) { 
        DC_END_FN();
        return 0; 
    }

    size = 0;

    //
    //  Add the base announce size.
    //
    size += sizeof(RDPDR_DEVICE_ANNOUNCE);

    DC_END_FN();
    return size;
}
BOOL 
DrPRT::MsgIrpDeviceControlTranslate(
                IN PRDPDR_IOREQUEST_PACKET pIoRequest
                )
/*++

Routine Description:

    Handle Port IOCTL IRP's from the server and translate to
    the appropriate subclass-implemented IO function.

Arguments:

    pIoRequestPacket    -   Request packet received from server.

Return Value:

    Returns TRUE if there was a valid translation.  Otherwise,
    FALSE is returned.

 --*/
{
    BOOL result = TRUE;

    DC_BEGIN_FN("DrPRT::MsgIrpDeviceControlTranslate");

    //
    //  Dispatch the IOCTL to a subclass-implemented function.
    //  This would be faster if it were table-driven.
    //
    switch (pIoRequest->IoRequest.Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_SERIAL_SET_BAUD_RATE :
            SerialSetBaudRate(pIoRequest);
            break;

        case IOCTL_SERIAL_GET_BAUD_RATE :
            SerialGetBaudRate(pIoRequest);
            break;

        case IOCTL_SERIAL_SET_LINE_CONTROL :
            SerialSetLineControl(pIoRequest);
            break;

        case IOCTL_SERIAL_GET_LINE_CONTROL :
            SerialGetLineControl(pIoRequest);
            break;

        case IOCTL_SERIAL_SET_TIMEOUTS :
            SerialSetTimeouts(pIoRequest);
            break;

        case IOCTL_SERIAL_GET_TIMEOUTS :
            SerialGetTimeouts(pIoRequest);
            break;

        case IOCTL_SERIAL_SET_CHARS :
            SerialSetChars(pIoRequest);
            break;

        case IOCTL_SERIAL_GET_CHARS :
            SerialGetChars(pIoRequest);
            break;

        case IOCTL_SERIAL_SET_DTR :
            SerialSetDTR(pIoRequest);
            break;

        case IOCTL_SERIAL_CLR_DTR :
            SerialClearDTR(pIoRequest);
            break;

        case IOCTL_SERIAL_RESET_DEVICE :
            SerialResetDevice(pIoRequest);
            break;

        case IOCTL_SERIAL_SET_RTS :
            SerialSetRTS(pIoRequest);
            break;

        case IOCTL_SERIAL_CLR_RTS :
            SerialClearRTS(pIoRequest);
            break;

        case IOCTL_SERIAL_SET_XOFF :
            SerialSetXOff(pIoRequest);
            break;

        case IOCTL_SERIAL_SET_XON :
            SerialSetXon(pIoRequest);
            break;

        case IOCTL_SERIAL_SET_BREAK_ON :
            SerialSetBreakOn(pIoRequest);
            break;

        case IOCTL_SERIAL_SET_BREAK_OFF :
            SerialSetBreakOff(pIoRequest);
            break;

        case IOCTL_SERIAL_SET_QUEUE_SIZE :
            SerialSetQueueSize(pIoRequest);
            break;

        case IOCTL_SERIAL_GET_WAIT_MASK :
            SerialGetWaitMask(pIoRequest);
            break;

        case IOCTL_SERIAL_SET_WAIT_MASK :
            SerialSetWaitMask(pIoRequest);
            break;

        case IOCTL_SERIAL_WAIT_ON_MASK :
            SerialWaitOnMask(pIoRequest);
            break;

        case IOCTL_SERIAL_IMMEDIATE_CHAR :
            SerialImmediateChar(pIoRequest);
            break;

        case IOCTL_SERIAL_PURGE :
            SerialPurge(pIoRequest);
            break;

        case IOCTL_SERIAL_GET_HANDFLOW :
            SerialGetHandflow(pIoRequest);
            break;

        case IOCTL_SERIAL_SET_HANDFLOW :
            SerialSetHandflow(pIoRequest);
            break;

        case IOCTL_SERIAL_GET_MODEMSTATUS :
            SerialGetModemStatus(pIoRequest);
            break;

        case IOCTL_SERIAL_GET_DTRRTS :
            SerialGetDTRRTS(pIoRequest);
            break;

        case IOCTL_SERIAL_GET_COMMSTATUS :
            SerialGetCommStatus(pIoRequest);
            break;

        case IOCTL_SERIAL_GET_PROPERTIES :
            SerialGetProperties(pIoRequest);
            break;

        case IOCTL_SERIAL_XOFF_COUNTER :
            SerialXoffCounter(pIoRequest);
            break;

        case IOCTL_SERIAL_LSRMST_INSERT :
            SerialLSRMSTInsert(pIoRequest);
            break;

        case IOCTL_SERIAL_CONFIG_SIZE :
            SerialConfigSize(pIoRequest);
            break;

        case IOCTL_SERIAL_GET_COMMCONFIG :
            SerialGetConfig(pIoRequest);
            break;

        case IOCTL_SERIAL_GET_STATS :
            SerialGetStats(pIoRequest);
            break;

        case IOCTL_SERIAL_CLEAR_STATS :
            SerialClearStats(pIoRequest);
            break;

        default:
            TRC_DBG((TB, _T("Unknown IOCTL %08X"),
                    pIoRequest->IoRequest.Parameters.DeviceIoControl.IoControlCode));
            result = FALSE;
    }

    DC_END_FN();

    return result;
}

void 
DrPRT::SerialSetBaudRate(
    IN PRDPDR_IOREQUEST_PACKET pIoReq
    )
/*++

Routine Description:

    Handle Serial Port Set Baud Rate Request from Server.

Arguments:

    pIoReq  -   Request packet received from server.

Return Value:

    NA
    
 --*/
{
    PBYTE inputBuf;
    NTSTATUS status = STATUS_SUCCESS;
    DCB dcb;
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    DRPORTHANDLE FileHandle;

    DC_BEGIN_FN("DrPRT::SerialSetBaudRate");

    TRACEREQ(pIoReq);

    //
    //  Get IO request pointer.
    //
    pIoRequest = &pIoReq->IoRequest;

    // 
    //  Get Port Handle
    //
    FileHandle = GetPortHandle(pIoRequest->FileId);

    ASSERT(FileHandle != INVALID_TSPORTHANDLE);

    //
    //  Check the size of the incoming request.
    //
    status = DrUTL_CheckIOBufInputSize(pIoReq, sizeof(SERIAL_BAUD_RATE));   
    
    //
    //  Get a pointer to the input buffer.
    //
    inputBuf = (PBYTE)(pIoReq + 1);

    //
    //  Get the current DCB.
    //
    if (status == STATUS_SUCCESS) {
        if (!GetCommState(FileHandle, &dcb)) {
            DWORD err = GetLastError();
            TRC_ALT((TB, _T("GetCommState failed with %08x"), err));
            status = TranslateWinError(err);
        }
    }

    //
    //  Set the baud rate and update the DCB.
    //
    if (status == STATUS_SUCCESS) {
        dcb.BaudRate = ((PSERIAL_BAUD_RATE)inputBuf)->BaudRate;
        if (!SetCommState(FileHandle, &dcb)) {
            DWORD err = GetLastError();
            TRC_NRM((TB, _T("SetCommState failed with %08x"), err));
            status = TranslateWinError(err);
        }
    }

    TRACERESP_WITHPARAMS(pIoReq, NULL, 0, status);

    //
    //  Send the results to the server.
    //
    DefaultIORequestMsgHandle(pIoReq, status); 
    DC_END_FN();
}

void    
DrPRT::SerialGetBaudRate(
    IN PRDPDR_IOREQUEST_PACKET pIoReq
    )
/*++

Routine Description:

    Handle Serial Port Get Baud Rate Request from Server.

Arguments:

    pIoReq  -   Request packet received from server.

Return Value:

    NA
    
 --*/
{
    PRDPDR_IOCOMPLETION_PACKET pReplyPacket = NULL;
    NTSTATUS status = STATUS_SUCCESS;
    DCB dcb;
    ULONG replyPacketSize;
    PBYTE outputBuf;
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    DRPORTHANDLE FileHandle;

    DC_BEGIN_FN("DrPRT::SerialGetBaudRate");

    TRACEREQ(pIoReq);

    //
    //  Get IO request pointer.
    //
    pIoRequest = &pIoReq->IoRequest;

    // 
    //  Get Port Handle
    //
    FileHandle = GetPortHandle(pIoRequest->FileId);
    ASSERT(FileHandle != INVALID_TSPORTHANDLE);

    //
    //  Check the size of the output buffer.
    //
    status = DrUTL_CheckIOBufOutputSize(pIoReq, sizeof(SERIAL_BAUD_RATE));

    //
    //  Allocate reply buffer.
    //
    if (status == STATUS_SUCCESS) {
        status = DrUTL_AllocateReplyBuf(pIoReq, &pReplyPacket, &replyPacketSize);
    }

    //
    //  Get the current DCB.
    //
    if (status == STATUS_SUCCESS) {
        //
        //  Get a pointer to the output buffer.
        //
        outputBuf = pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBuffer;

        if (GetCommState(FileHandle, &dcb)) {
            ((PSERIAL_BAUD_RATE)outputBuf)->BaudRate = dcb.BaudRate;       
            pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBufferLength 
                    = sizeof(SERIAL_BAUD_RATE); 
        }
        else {
            DWORD err = GetLastError();
            TRC_ALT((TB, _T("GetCommState failed with %08x"), err));
            status = TranslateWinError(err);
            pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBufferLength 
                    = 0; 
            replyPacketSize = (ULONG)FIELD_OFFSET(
                    RDPDR_IOCOMPLETION_PACKET, 
                    IoCompletion.Parameters.DeviceIoControl.OutputBuffer);
        }
    
        //
        //  Finish the response and send it.
        //
        pReplyPacket->IoCompletion.IoStatus = status;
        TRACERESP(pIoReq, pReplyPacket);
        ProcessObject()->GetVCMgr().ChannelWrite(pReplyPacket, replyPacketSize);
    }
    else {
        //
        //  Send the results to the server.
        //
        TRACERESP_WITHPARAMS(pIoReq, NULL, 0, status);
        DefaultIORequestMsgHandle(pIoReq, status); 
    }

    DC_END_FN();
}

void 
DrPRT::SerialSetLineControl(
    IN PRDPDR_IOREQUEST_PACKET pIoReq
    )
/*++

Routine Description:

    Handle Serial Port Set Set Line Control Request from Server.

Arguments:

    pIoReq  -   Request packet received from server.

Return Value:

    NA
    
 --*/
{
    PBYTE inputBuf;
    NTSTATUS status = STATUS_SUCCESS;
    DCB dcb;
    PSERIAL_LINE_CONTROL lineControl;
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    DRPORTHANDLE FileHandle;

    DC_BEGIN_FN("DrPRT::SerialSetLineControl");

    TRACEREQ(pIoReq);

    //
    //  Get IO request pointer.
    //
    pIoRequest = &pIoReq->IoRequest;

    // 
    //  Get Port Handle
    //
    FileHandle = GetPortHandle(pIoRequest->FileId);
    ASSERT(FileHandle != INVALID_TSPORTHANDLE);

    //
    //  Check the size of the incoming request.
    //
    status = DrUTL_CheckIOBufInputSize(pIoReq, sizeof(SERIAL_LINE_CONTROL));   
    
    //
    //  Get a pointer to the input buffer.
    //
    inputBuf = (PBYTE)(pIoReq + 1);

    //
    //  Get the current DCB.
    //
    if (status == STATUS_SUCCESS) {
        if (!GetCommState(FileHandle, &dcb)) {
            DWORD err = GetLastError();
            TRC_ALT((TB, _T("GetCommState failed with %08x"), err));
            status = TranslateWinError(err);
        }
    }

    //
    //  Set the line control and update the DCB.
    //
    if (status == STATUS_SUCCESS) {

        lineControl = (PSERIAL_LINE_CONTROL)inputBuf;
        dcb.StopBits    = lineControl->StopBits;
        dcb.Parity      = lineControl->Parity;          
        dcb.ByteSize    = lineControl->WordLength;

        if (!SetCommState(FileHandle, &dcb)) {
            DWORD err = GetLastError();
            TRC_ALT((TB, _T("SetCommState failed with %08x"), err));
            status = TranslateWinError(err);
        }
    }

    //
    //  Send the results to the server.
    //
    TRACERESP_WITHPARAMS(pIoReq, NULL, 0, status);	
    DefaultIORequestMsgHandle(pIoReq, status); 

    DC_END_FN();
}

void 
DrPRT::SerialGetLineControl(
    IN PRDPDR_IOREQUEST_PACKET pIoReq
    )
/*++

Routine Description:

    Handle Serial Port Get Line Control Rate Request from Server.

Arguments:

    pIoReq  -   Request packet received from server.

Return Value:

    NA
    
 --*/
{
    PRDPDR_IOCOMPLETION_PACKET pReplyPacket = NULL;
    NTSTATUS status = STATUS_SUCCESS;
    DCB dcb;
    ULONG replyPacketSize;
    PBYTE outputBuf;
    PSERIAL_LINE_CONTROL lineControl;
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    DRPORTHANDLE FileHandle;

    DC_BEGIN_FN("DrPRT::SerialGetLineControl");

    TRACEREQ(pIoReq);

    //
    //  Get IO request pointer.
    //
    pIoRequest = &pIoReq->IoRequest;

    // 
    //  Get Port Handle
    //
    FileHandle = GetPortHandle(pIoRequest->FileId);
    ASSERT(FileHandle != INVALID_TSPORTHANDLE);

    //
    //  Check the size of the output buffer.
    //
    status = DrUTL_CheckIOBufOutputSize(pIoReq, sizeof(SERIAL_LINE_CONTROL));

    //
    //  Allocate reply buffer.
    //
    if (status == STATUS_SUCCESS) {
        status = DrUTL_AllocateReplyBuf(pIoReq, &pReplyPacket, &replyPacketSize);
    }
    
    //
    //  Get the current DCB and grab the line control params.
    //
    if (status == STATUS_SUCCESS) {
        //
        //  Get a pointer to the output buffer and line control params.
        //
        outputBuf = pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBuffer;
        lineControl = (PSERIAL_LINE_CONTROL)outputBuf;
        
        if (GetCommState(FileHandle, &dcb)) {
            lineControl->StopBits   =   dcb.StopBits;   
            lineControl->Parity     =   dcb.Parity;       
            lineControl->WordLength =   dcb.ByteSize; 
            pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBufferLength 
                = sizeof(SERIAL_LINE_CONTROL); 
        }
        else {
            DWORD err = GetLastError();
            TRC_ALT((TB, _T("GetCommState failed with %08x"), err));
            status = TranslateWinError(err);
            pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBufferLength
                    = 0;
            replyPacketSize = (ULONG)FIELD_OFFSET(
                    RDPDR_IOCOMPLETION_PACKET, 
                    IoCompletion.Parameters.DeviceIoControl.OutputBuffer);
        }
    
        //
        //  Finish the response and send it.
        //
        pReplyPacket->IoCompletion.IoStatus = status;
        TRACERESP(pIoReq, pReplyPacket);		
        ProcessObject()->GetVCMgr().ChannelWrite(pReplyPacket, replyPacketSize);
    }
    else {
        //
        //  Send the results to the server.
        //
        TRACERESP_WITHPARAMS(pIoReq, NULL, 0, status);	
        DefaultIORequestMsgHandle(pIoReq, status); 
    }

    DC_END_FN();
}

void 
DrPRT::SerialSetDTR(
    IN PRDPDR_IOREQUEST_PACKET pIoReq
    )
/*++

Routine Description:

    Handle Serial Port Set DTR Request from Server.

Arguments:

    pIoReq  -   Request packet received from server.

Return Value:

    NA
    
 --*/
{
    DC_BEGIN_FN("DrPRT::SerialSetDTR");

    TRACEREQ(pIoReq);

    //
    //  Send the escape code to the serial port.
    //
    SerialHandleEscapeCode(pIoReq, SETDTR);

    DC_END_FN();
}

void 
DrPRT::SerialClearDTR(
    IN PRDPDR_IOREQUEST_PACKET pIoReq
    )
/*++

Routine Description:

    Handle Serial Port Clear DTR Request from Server.

Arguments:

    pIoReq  -   Request packet received from server.

Return Value:

    NA
    
 --*/
{
    DC_BEGIN_FN("DrPRT::SerialClearDTR");

    TRACEREQ(pIoReq);

    //
    //  Send the escape code to the serial port.
    //
    SerialHandleEscapeCode(pIoReq, CLRDTR);

    DC_END_FN();
}

void 
DrPRT::SerialSetRTS(
    IN PRDPDR_IOREQUEST_PACKET pIoReq
    )
/*++

Routine Description:

    Handle Serial Port Set RTS Request from Server.

Arguments:

    pIoReq  -   Request packet received from server.

Return Value:

    NA
    
 --*/
{
    DC_BEGIN_FN("DrPRT::SerialResetDevice");

    TRACEREQ(pIoReq);

    //
    //  Send the escape code to the serial port.
    //
    SerialHandleEscapeCode(pIoReq, SETRTS);

    DC_END_FN();
}

void 
DrPRT::SerialClearRTS(
    IN PRDPDR_IOREQUEST_PACKET pIoReq
    )
/*++

Routine Description:

    Handle Serial Port Clear RTS Request from Server.

Arguments:

    pIoReq  -   Request packet received from server.

Return Value:

    NA
    
 --*/
{
    DC_BEGIN_FN("DrPRT::SerialClearRTS");

    TRACEREQ(pIoReq);

    //
    //  Send the escape code to the serial port.
    //
    SerialHandleEscapeCode(pIoReq, CLRRTS);

    DC_END_FN();
}

void 
DrPRT::SerialSetXOff(
    IN PRDPDR_IOREQUEST_PACKET pIoReq
    )
/*++

Routine Description:

    Handle Serial Port Set XOFF Request from Server.

Arguments:

    pIoReq  -   Request packet received from server.

Return Value:

    NA
    
 --*/
{
    DC_BEGIN_FN("DrPRT::SerialSetXOff");

    //
    //  Send the escape code to the serial port.
    //
    SerialHandleEscapeCode(pIoReq, SETXOFF);

    DC_END_FN();
}

void 
DrPRT::SerialSetXon(
    IN PRDPDR_IOREQUEST_PACKET pIoReq
    )
/*++

Routine Description:

    Handle Serial Port Set XON Request from Server.

Arguments:

    pIoReq  -   Request packet received from server.

Return Value:

    NA
    
 --*/
{
    DC_BEGIN_FN("DrPRT::SerialSetXon");

    TRACEREQ(pIoReq);

    //
    //  Send the escape code to the serial port.
    //
    SerialHandleEscapeCode(pIoReq, SETXON);

    DC_END_FN();
}

void 
DrPRT::SerialSetBreakOn(
    IN PRDPDR_IOREQUEST_PACKET pIoReq
    )
/*++

Routine Description:

    Handle Serial Port Set Break On Request from Server.

Arguments:

    pIoReq  -   Request packet received from server.

Return Value:

    NA
    
 --*/
{
    DC_BEGIN_FN("DrPRT::SerialSetBreakOn");

    TRACEREQ(pIoReq);

    //
    //  Send the escape code to the serial port.
    //
    SerialHandleEscapeCode(pIoReq, SETBREAK);

    DC_END_FN();
}

void 
DrPRT::SerialSetBreakOff(
    IN PRDPDR_IOREQUEST_PACKET pIoReq
    )
/*++

Routine Description:

    Handle Serial Port Set Break Off Request from Server.

Arguments:

    pIoReq  -   Request packet received from server.

Return Value:

    NA
    
 --*/
{
    DC_BEGIN_FN("DrPRT::SerialSetBreakOff");

    TRACEREQ(pIoReq);

    //
    //  Send the escape code to the serial port.
    //
    SerialHandleEscapeCode(pIoReq, CLRBREAK);

    DC_END_FN();
}

void 
DrPRT::SerialImmediateChar(
    IN PRDPDR_IOREQUEST_PACKET pIoReq
    )
/*++

Routine Description:

    Handle Serial Port Immediate Char Request from Server.

Arguments:

    pIoReq  -   Request packet received from server.

Return Value:

    NA
    
 --*/
{
    PBYTE inputBuf;
    NTSTATUS status = STATUS_SUCCESS;
    UCHAR *immediateChar;
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    DRPORTHANDLE FileHandle;

    DC_BEGIN_FN("DrPRT::SerialImmediateChar");

    TRACEREQ(pIoReq);

    //
    //  Get IO request pointer.
    //
    pIoRequest = &pIoReq->IoRequest;

    // 
    //  Get Port Handle
    //
    FileHandle = GetPortHandle(pIoRequest->FileId);
    ASSERT(FileHandle != INVALID_TSPORTHANDLE);

    //
    //  Check the size of the incoming request.
    //
    status = DrUTL_CheckIOBufInputSize(pIoReq, sizeof(UCHAR));   

    //
    //  Get a pointer to the input buffer and the immediate character.
    //
    inputBuf = (PBYTE)(pIoReq + 1);
    immediateChar = (UCHAR *)inputBuf;

    //
    //  Transmit the COMM char.
    //
    if (status == STATUS_SUCCESS) {
        if (!TransmitCommChar(FileHandle, *immediateChar)) {
            DWORD err = GetLastError();
            TRC_ALT((TB, _T("TransmitCommChar failed with %08x"), err));
            status = TranslateWinError(err);
        }
    }

    //
    //  Send the results to the server.
    //
    TRACERESP_WITHPARAMS(pIoReq, NULL, 0, status);	
    DefaultIORequestMsgHandle(pIoReq, status);
    
    DC_END_FN();
}

#if DBG
void TraceCOMProtocol(TCHAR *format, ...)
/*++

Routine Description:

    Tracing function required by serial IO tracing module, tracecom.c.

Arguments:

    format  -   printf-style format specifie

Return Value:

    NA
    
 --*/
{
    static TCHAR bigBuf[1024];
    va_list vargs;

    DC_BEGIN_FN("TraceCOMProtocol");

    va_start(vargs, format);

    StringCchVPrintf(bigBuf, SIZE_TCHARS(bigBuf), format, vargs);

    va_end( vargs );

    TRC_DBG((TB, bigBuf));

    DC_END_FN();
}
#else
void TraceCOMProtocol(TCHAR *format, ...)
{
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\drqueue.h ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    drqueue.h

Abstract:

    Generic Queue Template Class

Author:

    Tad Brockway 10/99

Revision History:

--*/

#ifndef __DRQUEUE_H__
#define __DRQUEUE_H__

#include "drobject.h"
#include "atrcapi.h"


///////////////////////////////////////////////////////////////
//
//  DrQueue
//
//  Template Queue Class
//

template <class T> class DrQueue : public DrObject 
{

private:

    typedef struct _QUEUEELEMENT {
        T               data;
        _QUEUEELEMENT   *next;
        _QUEUEELEMENT   *prev;
    } QUEUEELEMENT, *PQUEUEELEMENT;

    //
    //  Queue Pointers
    //
    PQUEUEELEMENT   _head;
    PQUEUEELEMENT   _tail;

    //
    //  Lock
    //
    CRITICAL_SECTION _cs;

    //
    //  Number of elements in the queue.
    //
    ULONG _count;

public:

    //
    //  Constructor/Destructor
    //
    DrQueue();
    ~DrQueue();

    //
    //  Initialize.
    //
    DWORD Initialize();

    //
    //  Peek at the next element in the queue without dequeueing.
    //
    BOOL PeekNextEntry(T &data);

    //
    //  Grab the next element out of the queue.
    //
    BOOL Dequeue(T &data);

    //
    //  Add an element to the queue in FIFO fashion.
    //
    BOOL Enqueue(T &data);

    //
    //  Requeue an element at the tail of the queue in LIFO fashion.
    //  
    BOOL Requeue(T &data);

    //  Returns the number of elements in the queue.
    //
    ULONG   GetCount() {
        return _count;
    }

    //
    //  Lock/Unlock the queue.
    //
    VOID Lock() {
        EnterCriticalSection(&_cs);
    }
    VOID Unlock() {
        LeaveCriticalSection(&_cs);
    }

    //
    //  Return the class name.
    //
    virtual DRSTRING ClassName()  { return TEXT("DrQueue"); }
};



///////////////////////////////////////////////////////////////
//
//  DrQueue Inline Methods
//

template <class T>
inline DrQueue<T>::DrQueue() 
/*++

Routine Description:

    Constructor

Arguments:

    initialSize -   Initial number of elements in the queue.

Return Value:

    NA

 --*/
{
    DC_BEGIN_FN("DrQueue::DrQueue");

    //
    //  Initialize the queue pointers.
    //
    _tail = NULL;
    _head = NULL;

    //
    //  Initialize the queue count.
    //
    _count = 0;

    //
    //  Not valid until initialized.
    //
    SetValid(FALSE);

CleanUp:

    DC_END_FN();
}

template <class T>
inline DrQueue<T>::~DrQueue()
/*++

Routine Description:

    Destructor

Arguments:

    NA

Return Value:

    NA

 --*/
{
    DC_BEGIN_FN("DrQueue::~DrQueue");

    T element;

    //
    //  Clean up the queue nodes.
    //
    while (Dequeue(element));

    //
    //  Clean up the critical section.
    //
    if (IsValid()) {
        DeleteCriticalSection(&_cs);    
    }

    DC_END_FN();
}


template <class T>
inline DWORD DrQueue<T>::Initialize() 
/*++

Routine Description:

    Initialize

Arguments:

Return Value:

    ERROR_SUCCESS on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("DrQueue::Initialize");

    DWORD result;
    
    //
    //  Initialize the critical section.
    //
    __try {
        InitializeCriticalSection(&_cs);
        SetValid(TRUE);
        result = ERROR_SUCCESS;
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        result = GetExceptionCode();
    }

    DC_END_FN();

    return result;
}

template <class T>
inline BOOL DrQueue<T>::PeekNextEntry(T &data)
/*++

Routine Description:

    Peek at the next entry in the queue without dequeueing.

Arguments:
        
    data    -   Data for next entry in the queue

Return Value:

    NA

 --*/
{
    BOOL result;

    DC_BEGIN_FN("DrQueue::PeekNextEntry");

    //
    //  Make sure we are valid.
    //
    ASSERT(IsValid());
    result = IsValid();

    if (result) {
        Lock();

        if (_tail == NULL) {
            ASSERT(_head == NULL);
            ASSERT(_count == 0);
            result = FALSE;
        }
        else {
            data = _tail->data;
            result = TRUE;
        }

        Unlock();
    }

    DC_END_FN();
    return result;
}

template <class T>
inline BOOL DrQueue<T>::Dequeue(T &data)
/*++

Routine Description:

    Grab the next element out of the queue.

Arguments:

    data    -   Data for the next item in the queue.

Return Value:

    TRUE if there was an element in the queue to be dequeued.

 --*/
{
    BOOL result;
    PQUEUEELEMENT element;

    DC_BEGIN_FN("DrQueue::Dequeue");

    //
    //  Make sure we are valid.
    //
    ASSERT(IsValid());
    result = IsValid();

    if (result) {
        Lock();

        if (_tail == NULL) {
        ASSERT(_head == NULL);
        ASSERT(_count == 0);
            result = FALSE;
        }
        else {
            data = _tail->data;

            element = _tail;
            _tail = _tail->prev;

            //
            //  If the list is now empty.
            //
            if (_tail == NULL) {
                ASSERT(_count == 1);
                _head = NULL;
            }
            else {
                _tail->next = NULL;
            }
            delete element;
            _count--;
            result = TRUE;
        }

        Unlock();
    }

    DC_END_FN();
    return result;
}

template <class T>
inline BOOL DrQueue<T>::Enqueue(T &data)
/*++

Routine Description:

    Add an element to the queue in FIFO fashion.

Arguments:

    data    -   Data to be added to the queue.

Return Value:

    TRUE if the new element could be successfully queued.  FALSE,
    otherwise.  If FALSE is returned then GetLastError() can be 
    used to retrieve the exact error code.

 --*/
{
    BOOL result;

    DC_BEGIN_FN("DrQueue::Enqueue");

    //
    //  Make sure we are valid.
    //
    ASSERT(IsValid());
    result = IsValid();

    if (result) {

        PQUEUEELEMENT element = new QUEUEELEMENT;
        Lock();
        if (element != NULL) {
            element->data = data;
            element->next = _head;
            element->prev = NULL;

            //
            //  If the list is empy.
            //
            if (_head == NULL) {
                ASSERT(_count == 0);
                ASSERT(_tail == NULL);
                _head = element;
                _tail = element;
            }
            else {
                _head->prev = element;
                _head = element;
            }
            _count++;
            result = TRUE;
        }
        else {
            TRC_NRM((TB, _T("Alloc failed.")));
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            result = FALSE;
        }
        Unlock();
    }

    DC_END_FN();
    return result;
}

template <class T>
inline BOOL DrQueue<T>::Requeue(T &data)
/*++

Routine Description:

    Requeue an element at the tail of the queue in LIFO fashion.

Arguments:

    data    -   Data to be requeued.

Return Value:

    TRUE if the new element could be successfully queued.  FALSE,
    otherwise.  If FALSE is returned then GetLastError() can be 
    used to retrieve the exact error code.

 --*/
{
    BOOL result;

    DC_BEGIN_FN("DrQueue::Requeue");

    //
    //  Make sure we are valid.
    //
    ASSERT(IsValid());
    result = IsValid();

    if (result) {

        PQUEUEELEMENT element = new QUEUEELEMENT;
        Lock();

        if (element != NULL) {

            element->data   = data;
            element->next   = NULL;
            element->prev   = _tail;

            //
            //  If the queue is empty.
            //
            if (_tail == NULL) {
                ASSERT(_count == 0);
                _head = element;
                _tail = element;
            }
            else {
                _tail->next = element;
                _tail = element;
            }

            _count++;
            result = TRUE;
        }
        else {
            TRC_NRM((TB, _T("Alloc failed.")));
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            result = FALSE;
        }
        Unlock();
    }

    DC_END_FN();

    return result;
}




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\drprt.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    DrPRT

Abstract:

    This module declares the DrPRT class.  
    
    The job of the DrPRT class is to translate IO requests received 
    from the TS server into communications (serial/parallel) port IO 
    functions and to handle generic IO port behavior in a 
    platform-independent way to promote reuse between the various TS 
    client platforms, with respect to implementing comm port 
    redirection.

    Subclasses of DrPRT will implement the specific comm functions
    for their respective platform.

Author:

    Tad Brockway 5/26/99

Revision History:

--*/

#ifndef __DRPRT_H__
#define __DRPRT_H__

#include <rdpdr.h>
#include <stdlib.h>
#include "drobject.h"
#include "proc.h"

#include "w32utl.h"

#if DBG
#include "tracecom.h"
#endif


///////////////////////////////////////////////////////////////
//
//  Defines
//
//
#define DRPORTHANDLE    HANDLE
#define INVALID_TSPORTHANDLE    INVALID_HANDLE_VALUE


#if !defined(MAXULONG)
#define MAXULONG    ((ULONG)((ULONG_PTR)-1))
#endif

//
//  This function is required by the COM IO tracing module, tracecom.c
//  
#if DBG
void TraceCOMProtocol(TCHAR *format, ...);
#endif

//
//  Declare Tracing Macros for COM IO if we are in a DBG build.
//
#if DBG
#define TRACEREQ(req)     \
    TraceSerialIrpRequest(GetID(), req->IoRequest.MajorFunction, \
                req->IoRequest.MinorFunction, (PBYTE)(req + 1), \
                req->IoRequest.Parameters.DeviceIoControl.OutputBufferLength, \
                req->IoRequest.Parameters.DeviceIoControl.InputBufferLength, \
                req->IoRequest.Parameters.DeviceIoControl.IoControlCode)

#define TRACERESP(req, resp)    \
    TraceSerialIrpResponse(GetID(), req->IoRequest.MajorFunction, \
                req->IoRequest.MinorFunction,   \
                resp->IoCompletion.Parameters.DeviceIoControl.OutputBuffer,  \
                resp->IoCompletion.Parameters.DeviceIoControl.OutputBufferLength,    \
                req->IoRequest.Parameters.DeviceIoControl.InputBufferLength, \
                req->IoRequest.Parameters.DeviceIoControl.IoControlCode, \
                resp->IoCompletion.IoStatus)

#define TRACERESP_WITHPARAMS(req, outputBuf, outputBufLen, status)    \
    TraceSerialIrpResponse(GetID(), req->IoRequest.MajorFunction, \
                req->IoRequest.MinorFunction, outputBuf, outputBufLen, \
                req->IoRequest.Parameters.DeviceIoControl.InputBufferLength, \
                req->IoRequest.Parameters.DeviceIoControl.IoControlCode, \
                status)

#else
#define TRACEREQ(req)
#define TRACERESP(req, resp)
#define TRACERESP_WITHPARAMS(req, outputBuf, outputBufLen, status)
#endif


///////////////////////////////////////////////////////////////
//
//  DrPRT
//
//

class DrPRT
{

public:

    //
    //  Platform-Independent Serial Device Control Block
    //
    typedef struct tagRDPDR_DCB
    {
        DWORD   baudRate;   // Actual numeric non-negative
                            //  baud-rate.
    } RDPDR_DCB, *PRDPDR_DCB;

private:

    DRSTRING    _portName;
    FILE       *_traceFile;
    ProcObj    *_procObj;
    BOOL        _isValid;

protected:

    //
    //  Return back the port handle.
    //
    virtual DRPORTHANDLE GetPortHandle(ULONG FileId) = 0;

    //
    //  Return the "parent" TS Device Redirection IO processing object.
    //
    virtual ProcObj *ProcessObject() = 0;

    //
    //  Return the ID for this port.
    //
    virtual ULONG GetID() = 0;

    //
    //  Remember whether this instance is valid.
    //
    VOID SetValid(BOOL set)     { _isValid = set;   }  

    //
    //  Default IO Request Handling.
    //
    virtual VOID DefaultIORequestMsgHandle(
                        IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                        IN NTSTATUS serverReturnStatus
                        ) = 0;

    //
    //  Handle IOCTL IRP's from the server and translate to
    //  the appropriate subclass-implemented COMM function.
    //
    //  Returns TRUE if there was a valid translation.  Otherwise,
    //  FALSE is returned.
    //
    virtual BOOL MsgIrpDeviceControlTranslate(
            PRDPDR_IOREQUEST_PACKET pIoReq
            );

    //
    //  Serial IOCTL Dispatch Functions
    //
    //  These functions handle the platform-specific details of satisfying 
    //  serial IO requests, including sending an appropriate response to the 
    //  server.
    //
    virtual void SerialSetRTS(PRDPDR_IOREQUEST_PACKET pIoReq);
    virtual void SerialClearRTS(PRDPDR_IOREQUEST_PACKET pIoReq);
    virtual void SerialSetXOff(PRDPDR_IOREQUEST_PACKET pIoReq);
    virtual void SerialSetXon(PRDPDR_IOREQUEST_PACKET pIoReq);
    virtual void SerialSetBreakOn(PRDPDR_IOREQUEST_PACKET pIoReq);
    virtual void SerialSetBreakOff(PRDPDR_IOREQUEST_PACKET pIoReq);
    virtual void SerialSetBaudRate(PRDPDR_IOREQUEST_PACKET pIoReq);
    virtual void SerialGetBaudRate(PRDPDR_IOREQUEST_PACKET pIoReq);
    virtual void SerialSetDTR(PRDPDR_IOREQUEST_PACKET pIoReq);
    virtual void SerialClearDTR(PRDPDR_IOREQUEST_PACKET pIoReq);
    virtual void SerialSetLineControl(PRDPDR_IOREQUEST_PACKET pIoReq);
    virtual void SerialGetLineControl(PRDPDR_IOREQUEST_PACKET pIoReq);
    virtual void SerialImmediateChar(PRDPDR_IOREQUEST_PACKET pIoReq);

    virtual void SerialSetTimeouts(PRDPDR_IOREQUEST_PACKET pIoReq) = 0;
    virtual void SerialGetTimeouts(PRDPDR_IOREQUEST_PACKET pIoReq) = 0;
    virtual void SerialSetChars(PRDPDR_IOREQUEST_PACKET pIoReq) = 0;
    virtual void SerialGetChars(PRDPDR_IOREQUEST_PACKET pIoReq) = 0;
    virtual void SerialResetDevice(PRDPDR_IOREQUEST_PACKET pIoReq) = 0;
    virtual void SerialSetQueueSize(PRDPDR_IOREQUEST_PACKET pIoReq) = 0;
    virtual void SerialGetWaitMask(PRDPDR_IOREQUEST_PACKET pIoReq) = 0;
    virtual void SerialSetWaitMask(PRDPDR_IOREQUEST_PACKET pIoReq) = 0;
    virtual void SerialWaitOnMask(PRDPDR_IOREQUEST_PACKET pIoReq) = 0;
    virtual void SerialPurge(PRDPDR_IOREQUEST_PACKET pIoReq) = 0;
    virtual void SerialGetHandflow(PRDPDR_IOREQUEST_PACKET pIoReq) = 0;
    virtual void SerialSetHandflow(PRDPDR_IOREQUEST_PACKET pIoReq) = 0;
    virtual void SerialGetModemStatus(PRDPDR_IOREQUEST_PACKET pIoReq) = 0;
    virtual void SerialGetDTRRTS(PRDPDR_IOREQUEST_PACKET pIoReq) = 0;
    virtual void SerialGetCommStatus(PRDPDR_IOREQUEST_PACKET pIoReq) = 0;
    virtual void SerialGetProperties(PRDPDR_IOREQUEST_PACKET pIoReq) = 0;
    virtual void SerialXoffCounter(PRDPDR_IOREQUEST_PACKET pIoReq) = 0;
    virtual void SerialLSRMSTInsert(PRDPDR_IOREQUEST_PACKET pIoReq) = 0;
    virtual void SerialConfigSize(PRDPDR_IOREQUEST_PACKET pIoReq) = 0;
    virtual void SerialGetConfig(PRDPDR_IOREQUEST_PACKET pIoReq) = 0;
    virtual void SerialGetStats(PRDPDR_IOREQUEST_PACKET pIoReq) = 0;
    virtual void SerialClearStats(PRDPDR_IOREQUEST_PACKET pIoReq) = 0;

    //
    //  Handle Communication Escape Code IO Requests
    //
    void SerialHandleEscapeCode(PRDPDR_IOREQUEST_PACKET pIoReq,
                                DWORD controlCode);

public:

    //
    //  Constructor/Destructor
    //
    DrPRT(const DRSTRING portName, ProcObj *processObject);
    virtual ~DrPRT();

    //
    //  Return the size (in bytes) of a device announce packet for
    //  this device.
    //
    virtual ULONG GetDevAnnounceDataSize();

    //
    //  Add a device announce packet for this device to the input 
    //  buffer. 
    //
    virtual VOID GetDevAnnounceData(
            IN PRDPDR_DEVICE_ANNOUNCE pDeviceAnnounce,
            IN ULONG deviceID,
            IN ULONG deviceType
            );

    //
    //  Return whether this class instance is valid.
    //
    virtual BOOL IsValid()           
    {
        return _isValid; 
    }

    //
    //  Get basic information about the device.
    //
    virtual DRSTRING GetName() {
        return _portName;
    }
};


///////////////////////////////////////////////////////////////
//
//  DrPRT Inline Methods
//
//

inline void DrPRT::SerialHandleEscapeCode(
    IN PRDPDR_IOREQUEST_PACKET pIoReq,
    IN DWORD controlCode
    )
{
    NTSTATUS status;
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    DRPORTHANDLE FileHandle;

    DC_BEGIN_FN("DrPRT::SerialHandleEscapeCode");

    //
    //  Get the IO request.
    //
    pIoRequest = &pIoReq->IoRequest;

    // 
    //  Get Port Handle
    //
    FileHandle = GetPortHandle(pIoRequest->FileId);
    ASSERT(FileHandle != INVALID_TSPORTHANDLE);

    //
    //  Send the escape code to the serial port.
    //
    if (EscapeCommFunction(FileHandle, (int)controlCode)) {
        status = STATUS_SUCCESS;
    }
    else {
        DWORD err = GetLastError();
        TRC_ERR((TB, _T("EscapeCommFunction failed with %08x"), GetLastError()));
        status = TranslateWinError(err);
    }

    //
    //  Send the results to the server.
    //
    TRACERESP_WITHPARAMS(pIoReq, NULL, 0, status);
    DefaultIORequestMsgHandle(pIoReq, status); 
    DC_END_FN();
}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\drstr.h ===
/*++

    Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    drstr.h

Abstract:

    Misc. String Utils and Defines

Author:

    Tad Brockway

Revision History:

--*/

#ifndef __DRSTR_H__
#define __DRSTR_H__

#define DRSTRING        LPTSTR


///////////////////////////////////////////////////////////////
//
//  Macros and Defines
//
//

#define STRNICMP(str1, str2, len)   _tcsnicmp(str1, str2, len)
#define STRICMP(str1, str2)         _tcsicmp(str1, str2)
#define STRNCPY(str1, str2, len)    _tcsncpy(str1, str2, len)
#define STRCPY(str1, str2)          _tcscpy(str1, str2)
#define STRLEN(str)                 _tcslen(str)

//
//  Set a string value after resizing the data member.
//
BOOL DrSetStringValue(DRSTRING *string, const DRSTRING value);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\precom.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    precom.h

Abstract:

    Contains common include header files that are precompiled.

Author:

    Madan Appiah (madana) 16-Sep-1998

Revision History:

--*/

#ifndef _precom_h_
#define _precom_h_

#include <windows.h>

//
// uwrap has to come after the headers for ANY wrapped
// functions
//
#ifdef UNIWRAP
#include "uwrap.h"
#endif

#include "drstatus.h"

#define TRC_GROUP TRC_GROUP_NETWORK
#define DEBUG_MODULE DBG_MOD_ANY

#include <adcgbase.h>
#include <at120ex.h>

#include <cchannel.h>
#include <pclip.h>
#include <ddkinc.h>

#include "drstr.h"

#include <stdio.h>

#if DBG
#define INLINE
#else // DBG
#define INLINE  inline
#endif // DBG

#include <strsafe.h>

#define TRC_FILE  "Precom"

#include "drdev.h"
#include "proc.h"
#include "drconfig.h"
#include "utl.h"
#include "drfile.h"
#include "drobject.h"
#include "drobjmgr.h"

#undef TRC_FILE

#endif //_precom_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\proc.cpp ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    proc.cpp

Abstract:

    This module contains shared code and protocol parsing functionality
    for the port redirector dll in win32/wince environments.

    Don't like the way server message clean up is handled.
    There should be an object that wraps its way around a request packet
    to automatically clean up.  The current mechanism is prone to memory
    leaks and dangling pointers.  I would REALLY like to clean this up
    because it WILL cause problems when we try to implement future 
    devices, but need to get approval from Madan, first.

    See the old client's ProcObj::UpdateDriverName function for 
    how to handle making sure that if the driver name changes for cached
    information, we whack the cached information.

Author:

    madan appiah (madana) 16-Sep-1998

Revision History:

--*/

#include <precom.h>

#define TRC_FILE  "proc"

#include <winsock.h>

//
//  Include the platform-specific classes.
//
#include "w32draut.h"
#include "w32drman.h"
#include "w32drlpt.h"
#include "w32drcom.h"
#include "w32proc.h"
#include "w32drdev.h"
#include "w32drive.h"
#if ((!defined(OS_WINCE)) || (!defined(WINCE_SDKBUILD)))
#include "w32scard.h"
#endif    

#include "drconfig.h"
#include "drdbg.h"

#ifdef OS_WINCE
#include "filemgr.h"
#endif

///////////////////////////////////////////////////////////////
//
//  ProcObj Data Members
//

//
//  Device Enumeration Function Pointer List
//
//  A function should be added for each class of device being
//  redirected.  There should be a separate instance of this
//  array for each client platform.
//
RDPDeviceEnum ProcObj::_DeviceEnumFunctions[] = 
{
#ifndef OS_WINCE
    W32DrAutoPrn::Enumerate,
#endif
    W32DrManualPrn::Enumerate,
    W32DrCOM::Enumerate,
    W32DrLPT::Enumerate,
    W32Drive::Enumerate,
#if ((!defined(OS_WINCE)) || (!defined(WINCE_SDKBUILD)))
    W32SCard::Enumerate
#endif
};


///////////////////////////////////////////////////////////////
//
//  ProcObj Methods
//

ProcObj *ProcObj::Instantiate(VCManager *virtualChannelMgr)
/*++

Routine Description:

    Create the correct instance of this class.

Arguments:

    virtualChannelMgr    -   Associated Virtual Channel IO Manager

Return Value:

    NULL if the object could not be created.

 --*/
{                                 
    DC_BEGIN_FN("ProcObj::Instantiate");

    TRC_NRM((TB, _T("Win9x, CE, or NT detected.")));
    DC_END_FN();
    return new W32ProcObj(virtualChannelMgr);
}
    
ProcObj::ProcObj(
    IN VCManager *pVCM
    ) 
/*++

Routine Description:

    Constructor

Arguments:

    NA

Return Value:

    NA

 --*/
{
    DC_BEGIN_FN("ProcObj::ProcObj");

    //
    //  Initialize Data Members
    //
    _pVCMgr             = pVCM;
    _sServerVersion.Major = 0;
    _sServerVersion.Minor = 0;
    _bDisableDeviceRedirection = FALSE;
    _deviceMgr = NULL;

    //
    //  Initialize the client capability set
    //  This is the capability set that we'll send to server 
    //
    memcpy(&_cCapabilitySet, &CLIENT_CAPABILITY_SET_DEFAULT, 
            sizeof(CLIENT_CAPABILITY_SET_DEFAULT));

    //
    //  Initialize the server capability set
    //  Once we receive the server side capability, we'll combine with our local 
    //  capability and stores it.
    //
    memcpy(&_sCapabilitySet, &SERVER_CAPABILITY_SET_DEFAULT, 
            sizeof(SERVER_CAPABILITY_SET_DEFAULT));

    //
    //
    //  This instance has not yet been initialized.
    //
    _initialized = FALSE;

    DC_END_FN();
}

ProcObj::~ProcObj()
/*++

Routine Description:

    Destructor

Arguments:

    NA

Return Value:

    NA

 --*/
{
    DrDevice *dev;

    DC_BEGIN_FN("ProcObj::~ProcObj");

    //
    //  Clean up the device management list.
    //
    if (_deviceMgr != NULL) {
        _deviceMgr->Lock();
        while ((dev = _deviceMgr->GetFirstObject()) != NULL) {
            _deviceMgr->RemoveObject(dev->GetID());
            delete dev;
        }
        _deviceMgr->Unlock();
        delete _deviceMgr;
    }

#if (defined(OS_WINCE)) && (!defined(WINCE_SDKBUILD))   //delete this after all the devices in the device manager have been removed
    if (gpCEFileMgr)  {
        gpCEFileMgr->Uninitialize();
        delete gpCEFileMgr;
        gpCEFileMgr = NULL;
    }
#endif

    DC_END_FN();
}

ULONG
ProcObj::Initialize()
/*++

Routine Description:

    Initialize an instance of this class.

Arguments:

    NA

Return Value:

    ERROR_SUCCESS on success.  Windows error status, otherwise.

 --*/
{
    DC_BEGIN_FN("ProcObj::Initialize");
    DWORD result = ERROR_SUCCESS;
    
    //
    //  Fetch Configurable Variables.
    //
    GetDWordParameter(RDPDR_DISABLE_DR_PARAM, &_bDisableDeviceRedirection);

    _deviceMgr = new DrDeviceMgr();
    if (_deviceMgr == NULL) {
        TRC_ERR((TB, L"Error allocating device manager."));
        result = ERROR_NOT_ENOUGH_MEMORY;
        goto CLEANUPANDEXIT;
    }

    result = _deviceMgr->Initialize();
    if (result != ERROR_SUCCESS) {
        delete _deviceMgr;
        _deviceMgr = NULL;
        goto CLEANUPANDEXIT;
    }

#if (defined(OS_WINCE)) && (!defined(WINCE_SDKBUILD))
    TRC_ASSERT((gpCEFileMgr == NULL), (TB, _T("gpCEFileMgr is not NULL")));
    gpCEFileMgr = new CEFileMgr();
    if (gpCEFileMgr)  {
        if (!gpCEFileMgr->Initialize())  {
            delete gpCEFileMgr;
            gpCEFileMgr = NULL;
        }
    }

    if (!gpCEFileMgr)  {
        TRC_ERR((TB, _T("Memory allocation failed.")));
        delete _deviceMgr;
        _deviceMgr = NULL;
        result = ERROR_NOT_ENOUGH_MEMORY;
        goto CLEANUPANDEXIT;
    }
#endif

    _initialized = TRUE;

CLEANUPANDEXIT:

    DC_END_FN();
    return result;
}

DWORD 
ProcObj::DeviceEnumFunctionsCount()
/*++

Routine Description:

    Return the number of entries in the device enum function array.

Arguments:

Return Value:

--*/
{
    return(sizeof(_DeviceEnumFunctions) / sizeof(RDPDeviceEnum));
}

VOID
ProcObj::ProcessIORequestPacket(
    PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
    UINT32 packetLen
    )
/*++

Routine Description:

    Process an IO request packet.

Arguments:

    pData - RDPDR packet as received by VC.
    packetLen - length of the packet

Return Value:

    TRUE - if the IO completed.
    FALSE - if the IO pending and asynchronously completes.

 --*/
{
    PRDPDR_DEVICE_IOREQUEST pIoRequest = &pIoRequestPacket->IoRequest;
    ULONG ulSize = 0;

    DC_BEGIN_FN("ProcObj::ProcessIORequestPacket");

    ASSERT(_initialized);
    
    //
    //  Hand it to the proper device object.
    //
    DrDevice *device = _deviceMgr->GetObject(pIoRequest->DeviceId);
    
    //
    //  If we have a device then hand off the object to handle the request.
    //
    if (device != NULL) {
        device->ProcessIORequest(pIoRequestPacket, packetLen);
    }
    //
    //  Otherwise, clean up the server message because the transaction is 
    //  complete.
    //
    //  No response is sent to server.
    //
    else {
        delete pIoRequestPacket;
    }
    DC_END_FN();
}

VOID
ProcObj::ProcessServerPacket(
    PVC_TX_DATA pData
    )
/*++

Routine Description:

    Parses the protocol and delegates functionality to a whole horde of
    overloaded functions.

    This is the main entry point for all device-redirection related
    operations.

Arguments:

    pData -   Data as received from the RDP Virtual Channel interface.

Return Value:

    NA

 --*/
{
    DC_BEGIN_FN("ProcObj::Process");

    PRDPDR_HEADER pRdpdrHeader;

    ASSERT(_initialized);

    //
    //  Get the header.
    //
    pRdpdrHeader = (PRDPDR_HEADER)(pData->pbData);

    //
    //  Assert that it is valid.
    //
    ASSERT(IsValidHeader(pRdpdrHeader));

    TRC_NRM((TB, _T("Processing component[%x], packetId[%x], ")
        _T("component[%c%c], packetid[%c%c]."),
        pRdpdrHeader->Component, pRdpdrHeader->PacketId,
        HIBYTE(pRdpdrHeader->Component), LOBYTE(pRdpdrHeader->Component),
        HIBYTE(pRdpdrHeader->PacketId),LOBYTE(pRdpdrHeader->PacketId))
        );

    //
    //  See if it's a CORE packet.
    //
    if (pRdpdrHeader->Component == RDPDR_CTYP_CORE) {

        ProcessCoreServerPacket(pRdpdrHeader, pData->uiLength);

    }
    //
    //  If it's print-specific, hand it off to a static print-specific
    //  function.  Ideally, this would have been handled transparently by
    //  having the server-side component send the message directly to the
    //  appropriate client-side object.  The current protocol prohibits this,
    //  however.
    //
    else if( pRdpdrHeader->Component == RDPDR_CTYP_PRN ) {

        switch (pRdpdrHeader->PacketId) {

            case DR_PRN_CACHE_DATA : {
                TRC_NRM((TB, _T("DR_CORE_DEVICE_CACHE_DATA")));

                PRDPDR_PRINTER_CACHEDATA_PACKET pCachePacket;
                pCachePacket = (PRDPDR_PRINTER_CACHEDATA_PACKET)pRdpdrHeader;

                W32DrPRN::ProcessPrinterCacheInfo(pCachePacket, pData->uiLength);
                break;
            }
            default: {

                TRC_ALT((TB, _T("Invalid PacketID Issued, %ld."),
                    pRdpdrHeader->PacketId)
                    );
                break;
            }
        }
    }
    else {
            // We don't recognize the packet. Close the channel.
        GetVCMgr().ChannelClose();
        delete pRdpdrHeader;
        TRC_ALT((TB, _T("Unknown Component ID, %ld."), pRdpdrHeader->Component ));
    }

    DC_END_FN();
    return;
}

VOID
ProcObj::ProcessCoreServerPacket(
        PRDPDR_HEADER pRdpdrHeader,    
        UINT32 packetLen
        )
/*++

Routine Description:
    
    Handle a "core" server packet.

Arguments:

    rRdpdrHeader    -   Header for packet.
    packetLen       -   Length of packet.

Return Value:

    NA

 --*/
{
    DC_BEGIN_FN("ProcObj::ProcessCoreServerPacket");

    ASSERT(_initialized);

    //
    //  Switch on the packetID.
    //
    switch (pRdpdrHeader->PacketId) {

        case DR_CORE_SERVER_ANNOUNCE : {

            TRC_NRM((TB, _T("DR_CORE_SERVER_ANNOUNCE")));

            //
            // check to see we have a matching server.
            //
            if (packetLen != sizeof(RDPDR_SERVER_ANNOUNCE_PACKET) ) {

                ASSERT(packetLen < sizeof(RDPDR_SERVER_ANNOUNCE_PACKET));

                //
                // we got a server announcement from an old version
                // server that didn't have have any version info.
                // simply return.
                //

                TRC_ERR((TB, _T("Mismatch server.")));
                break;
            }

            MsgCoreAnnounce( (PRDPDR_SERVER_ANNOUNCE_PACKET)pRdpdrHeader );

            break;
        }

        case DR_CORE_CLIENTID_CONFIRM : {

            TRC_NRM((TB, _T("DR_CORE_CLIENTID_CONFIRM")));

            //
            //  Send the client capability to the server if the server
            //  supports capability exchange
            //
            if (COMPARE_VERSION(_sServerVersion.Minor, _sServerVersion.Major,
                                5, 1) >= 0) {
                AnnounceClientCapability();
            }

            //
            //  Send client computer display name if server supports it
            //
            AnnounceClientDisplayName();

            //  Don't announce devices if device redirection is disabled.
            //
            if (!_bDisableDeviceRedirection) {
                //
                //  Announce redirected devices to the server via the subclass.
                //
                AnnounceDevicesToServer();
            }
            
            //
            //  Clean up the server message because the transaction is
            //  complete.
            //
            delete pRdpdrHeader;
            break;
        }

        case DR_CORE_SERVER_CAPABILITY : {
            TRC_NRM((TB, _T("DR_CORE_SERVER_CAPABILITY")));
            //
            //  Received server capability set
            //
            OnServerCapability(pRdpdrHeader, packetLen);

            // 
            //  Cleanup the message because the transaction is complete
            //
            delete pRdpdrHeader;

            break;
        }

        case DR_CORE_DEVICE_REPLY : {

            TRC_NRM((TB, _T("DR_CORE_DEVICE_REPLY")));

            PRDPDR_DEVICE_REPLY_PACKET pReply =
                (PRDPDR_DEVICE_REPLY_PACKET)pRdpdrHeader;

            TRC_NRM((TB, _T("Reply Device[0x%x], Code[0x%x]"),
                    pReply->DeviceReply.DeviceId,
                    pReply->DeviceReply.ResultCode)
                    );

            //
            //  Clean up the server message because the transaction is
            //  complete.
            //
            delete pRdpdrHeader;

            break;
        }

        case DR_CORE_DEVICELIST_REPLY : {
            TRC_NRM((TB, _T("DR_CORE_DEVICELIST_REPLY")));

            PRDPDR_DEVICE_REPLY_PACKET pReply =
                (PRDPDR_DEVICE_REPLY_PACKET)pRdpdrHeader;

            TRC_NRM((TB, _T("Reply Device[0x%x], Code[0x%x]"),
                        pReply->DeviceReply.DeviceId,
                        pReply->DeviceReply.ResultCode)
                        );

            //
            //  Clean up the server message because the transaction is
            //  complete.
            //
            delete pRdpdrHeader;

            break;
        }

        case DR_CORE_DEVICE_IOREQUEST : {

            TRC_NRM((TB, _T("DR_CORE_DEVICE_IOREQUEST")));

            //  Make sure packetLen is at least sizeof(RDPDR_IOREQUEST_PACKET)
            if (packetLen >= sizeof(RDPDR_IOREQUEST_PACKET)) {
                ProcessIORequestPacket((PRDPDR_IOREQUEST_PACKET)pRdpdrHeader, packetLen);

                TRC_NRM((TB, _T("MajorFunction processing completed.")));
            }
            else {
                // VirtualChannelClose
                GetVCMgr().ChannelClose();
                TRC_ASSERT(FALSE, (TB, _T("Packet Length Error")));
                delete pRdpdrHeader;
            }   

            break; // DR_CORE_DEVICE_IOREQUEST
        }

        default: {

            TRC_ALT((TB, _T("Invalid PacketID Issued, %ld."),
                    pRdpdrHeader->PacketId)
                    );
            // We don't recognize the packet. Close the channel.
            GetVCMgr().ChannelClose();
            //
            //  Clean up the server message because the transaction is
            //  complete.
            //
            delete pRdpdrHeader;

            break;
        }

    }

    DC_END_FN();
}

VOID
ProcObj::MsgCoreAnnounce(
    PRDPDR_SERVER_ANNOUNCE_PACKET pAnnounce
    )

/*++

Routine Description:

    Processing for the Server Announce message.  Generates and exports
    the client confirmation as well as valid the device list.

Arguments:

    pAnnounce - The data from the server minus the unnecessary headers.

Return Value:

    Pointer to static function data containing the filename.

 --*/

{
    DrDevice    *device;

    DC_BEGIN_FN("ProcObj::MsgCoreAnnounce");

    PRDPDR_CLIENT_CONFIRM_PACKET pClientConfirmPacket;
    PRDPDR_CLIENT_NAME_PACKET pClientNamePacket;

    ASSERT(_initialized);

    //
    // check server version info.
    //

    if( (pAnnounce->VersionInfo.Major != RDPDR_MAJOR_VERSION) ||
        (pAnnounce->VersionInfo.Minor < 1) ) {

        TRC_ERR((TB, _T("Server version mismatch.")));
        goto Cleanup;
    }

    //
    // Flush devices to make sure they don't have any outstanding IRPs
    // from a previous connection
    //
    _deviceMgr->Lock();
    
    device = _deviceMgr->GetFirstObject();
    
    while (device != NULL) {

        device->FlushIRPs();
        device = _deviceMgr->GetNextObject();
    }

    _deviceMgr->Unlock();

    //
    // save server version number.
    //

    _sServerVersion = pAnnounce->VersionInfo;

    pClientConfirmPacket = new RDPDR_CLIENT_CONFIRM_PACKET;

    if (pClientConfirmPacket == NULL) {
        TRC_ERR((TB, _T("Failed alloc memory.")));
        goto Cleanup;
    }

    pClientConfirmPacket->Header.Component = RDPDR_CTYP_CORE;
    pClientConfirmPacket->Header.PacketId = DR_CORE_CLIENTID_CONFIRM;

    ULONG ulClientID;
    ulClientID = GetClientID();

    //
    // fill in the client version info.
    //

    pClientConfirmPacket->VersionInfo.Major = RDPDR_MAJOR_VERSION;
    pClientConfirmPacket->VersionInfo.Minor = RDPDR_MINOR_VERSION;

    pClientConfirmPacket->ClientConfirm.ClientId =
        ( ulClientID != 0 ) ?
            ulClientID :
            pAnnounce->ServerAnnounce.ClientId;

    //
    // ulLen has the computer name length in bytes, add
    // RDPDR_CLIENT_CONFIRM_PACKET structure size, to
    // send just sufficient data.
    //

    _pVCMgr->ChannelWrite(pClientConfirmPacket, sizeof(RDPDR_CLIENT_CONFIRM_PACKET));

    //
    // now send the client computer name packet.
    //

    ULONG ulLen;

    ulLen =
        sizeof(RDPDR_CLIENT_NAME_PACKET) +
            ((MAX_COMPUTERNAME_LENGTH + 1) * sizeof(WCHAR));

    pClientNamePacket = (PRDPDR_CLIENT_NAME_PACKET) new BYTE[ulLen];

    if (pClientNamePacket == NULL) {
        TRC_ERR((TB, _T("Failed alloc memory.")));
        goto Cleanup;
    }

    pClientNamePacket->Header.Component = RDPDR_CTYP_CORE;
    pClientNamePacket->Header.PacketId = DR_CORE_CLIENT_NAME;

    ulLen = ((MAX_COMPUTERNAME_LENGTH + 1) * sizeof(WCHAR));
    BOOL bUnicodeFlag;

    GetClientComputerName(
        (PBYTE)(pClientNamePacket + 1),
        &ulLen,
        &bUnicodeFlag,
        &pClientNamePacket->Name.CodePage);

    pClientNamePacket->Name.Unicode = (bUnicodeFlag) ? TRUE : FALSE;
    pClientNamePacket->Name.ComputerNameLen = ulLen;

    ulLen += sizeof(RDPDR_CLIENT_NAME_PACKET);
    _pVCMgr->ChannelWrite(pClientNamePacket, (UINT)ulLen);

    //
    // don't free up the following buffers here, later a callback event from
    // the VC will do so.
    //
    //  - pClientConfirmPacket
    //  - pClientNamePacket
    //

Cleanup:

    //
    //  Release the announce packet since the transaction is now complete.
    //
    delete pAnnounce;

    DC_END_FN();
}

ULONG
ProcObj::GetClientID(
    VOID
    )
/*++

Routine Description:

    Retrive the client ID. Currently we send the IP address of the client machine
    as its ID.

    Assume : Winsock is startup.

Arguments:

    NONE

Return Value:

    0 - if we can't find a unique client ID.

    IP Address of the machine - otherwise.

 --*/
{
    DC_BEGIN_FN("ProcObj::GetClientID");

    CHAR achHostName[MAX_PATH];
    INT iRetVal;
    ULONG ulClientID = 0;
    HOSTENT *pHostent;

    ASSERT(_initialized);

    iRetVal = gethostname( (PCHAR)achHostName, sizeof(achHostName) );

    if( iRetVal != 0 ) {

        iRetVal = WSAGetLastError();

        TRC_ERR((TB, _T("gethostname failed, %ld."), iRetVal));
        goto Cleanup;
    }

    pHostent = gethostbyname( (PCHAR)achHostName );

    if( pHostent == NULL ) {

        iRetVal = WSAGetLastError();

        TRC_ERR((TB, _T("gethostbyname() failed, %ld."), iRetVal));
        goto Cleanup;
    }

    //
    // get the first address from the host ent.
    //

    ULONG *pAddr;

    pAddr = (ULONG *)pHostent->h_addr_list[0];

    if( pAddr != NULL ) {
        ulClientID = *pAddr;
    }

Cleanup:

    DC_END_FN();
    return ulClientID;
}

PRDPDR_HEADER
ProcObj::GenerateAnnouncePacket(
    INT *piSize,
    BOOL bCheckDeviceChange
    )
/*++

Routine Description:

    Generate a device announcement packet.

Arguments:

    piSize - pointer to an integer variables where the size of the list is
             returned.

Return Value:

    pointer to a device announcement package.
    NULL - if the list generation fails.

 --*/
{
    PRDPDR_HEADER               pPacketHeader = NULL;
    PRDPDR_DEVICELIST_ANNOUNCE  pDeviceListAnnounce;
    PRDPDR_DEVICE_ANNOUNCE      pDeviceAnnounce;
    ULONG       ulDeviceCount;
    ULONG       announcePacketSize;
    DrDevice    *device;

    DC_BEGIN_FN("ProcObj::GenerateAnnouncePacket");

    ASSERT(_initialized);

    //
    //  Lock the list of devices.
    //
    _deviceMgr->Lock();

    //
    //  Calculate the number of bytes required for the announce packet.
    //
    announcePacketSize = sizeof(RDPDR_HEADER) + sizeof(RDPDR_DEVICELIST_ANNOUNCE);
    device = _deviceMgr->GetFirstObject();

    if (device == NULL) {
        TRC_NRM((TB, _T("Zero devices found.")));
        goto Cleanup;
    }

    while (device != NULL) {

        if (!bCheckDeviceChange || device->_deviceChange == DEVICENEW) {
            announcePacketSize += device->GetDevAnnounceDataSize();
        }

        device = _deviceMgr->GetNextObject();
    }

    //
    //  Allocate the announcement packet header.
    //
    pPacketHeader = (PRDPDR_HEADER)new BYTE[announcePacketSize];
    if( pPacketHeader == NULL ) {

        TRC_ERR((TB, _T("Memory Allocation failed.")));
        goto Cleanup;
    }
    memset(pPacketHeader, 0, (size_t)announcePacketSize);

    //
    //  Get pointers to the relevant packet header fields.
    //
    pDeviceListAnnounce = (PRDPDR_DEVICELIST_ANNOUNCE)(pPacketHeader + 1);
    pDeviceAnnounce = (PRDPDR_DEVICE_ANNOUNCE)(pDeviceListAnnounce + 1);

    //
    //  Have each device object add its own device announcement information.
    //
    PBYTE pbPacketEnd;

    pbPacketEnd = ((PBYTE)pPacketHeader) + announcePacketSize;

    ulDeviceCount = 0;
    device = _deviceMgr->GetFirstObject();
    while (device != NULL) {

        if (!bCheckDeviceChange || device->_deviceChange == DEVICENEW) {
            //
            //  Increment the device count.
            //
            ulDeviceCount++;
    
            //
            //  Get the current devices data.
            //
            device->GetDevAnnounceData(pDeviceAnnounce);
    
            device->_deviceChange = DEVICEANNOUCED;
    
            //
            //  Move to the next location in the announce packet.
            //
            pDeviceAnnounce = (PRDPDR_DEVICE_ANNOUNCE)(
                                    ((PBYTE)pDeviceAnnounce) + 
                                    device->GetDevAnnounceDataSize()
                                    );
        }

        //
        //  Get the next device.
        //
        device = _deviceMgr->GetNextObject();
    }

    //
    //  Record the device count to the device list announce header.
    //
        pDeviceListAnnounce->DeviceCount = ulDeviceCount;

    //
    //  Return the size of the buffer.
    //
    *piSize = (INT)announcePacketSize;

Cleanup:

    //
    //  Unlock the device list.
    //
    _deviceMgr->Unlock();

    TRC_NRM((TB, _T("Announcing %ld Devices."), ulDeviceCount));

    

    //
    //  Return the buffer.
    //
    DC_END_FN();
    return pPacketHeader;
}

PRDPDR_HEADER
ProcObj::GenerateDeviceRemovePacket(
    INT *piSize
    )
/*++

Routine Description:

    Generate a device remove packet.

Arguments:

    piSize - pointer to an integer variables where the size of the list is
             returned.

Return Value:

    pointer to a device remove package.
    NULL - if the list generation fails.

 --*/
{
    PRDPDR_HEADER               pPacketHeader = NULL;
    PRDPDR_DEVICELIST_REMOVE    pDeviceListRemove;
    PRDPDR_DEVICE_REMOVE        pDeviceRemove;
    ULONG       ulDeviceCount;
    ULONG       removePacketSize;
    DrDevice    *device;

    DC_BEGIN_FN("ProcObj::GenerateDeviceRemovePacket");

    ASSERT(_initialized);

    //
    //  Lock the list of devices.
    //
    _deviceMgr->Lock();

    //
    //  Calculate the number of bytes required for the announce packet.
    //
    removePacketSize = sizeof(RDPDR_HEADER) + sizeof(RDPDR_DEVICELIST_REMOVE);

    device = _deviceMgr->GetFirstObject();

    if (device == NULL) {
        TRC_NRM((TB, _T("Zero devices found.")));
        goto Cleanup;
    }

    ulDeviceCount = 0;
    while (device != NULL) {
        if (device->_deviceChange == DEVICEREMOVE) {
            ulDeviceCount++;
        }
        device = _deviceMgr->GetNextObject();
    }

    //
    //  Didn't find any device to be removed
    //
    if (ulDeviceCount == 0) {
        TRC_NRM((TB, _T("Zero device for removal")));
        goto Cleanup;
    }

    removePacketSize += ulDeviceCount * sizeof(RDPDR_DEVICE_REMOVE);

    //
    //  Allocate the announcement packet header.
    //
    pPacketHeader = (PRDPDR_HEADER)new BYTE[removePacketSize];
    if( pPacketHeader == NULL ) {

        TRC_ERR((TB, _T("Memory Allocation failed.")));
        goto Cleanup;
    }
    memset(pPacketHeader, 0, (size_t)removePacketSize);

    //
    //  Get pointers to the relevant packet header fields.
    //
    pDeviceListRemove = (PRDPDR_DEVICELIST_REMOVE)(pPacketHeader + 1);
    pDeviceRemove = (PRDPDR_DEVICE_REMOVE)(pDeviceListRemove + 1);

    //
    //  Have each device object add its own device remove information.
    //
    ulDeviceCount = 0;
    device = _deviceMgr->GetFirstObject();
    while (device != NULL) {

        if (device->_deviceChange == DEVICEREMOVE) {
            //
            //  Increment the device count.
            //
            ulDeviceCount++;
    
            //
            //  Get the current devices data.
            //
            pDeviceRemove->DeviceId = device->GetID();
    
            //
            //  Move to the next location in the announce packet.
            //
            pDeviceRemove++;
        }
                                
        //
        //  Get the next device.
        //
        device = _deviceMgr->GetNextObject();
    }

    //
    //  Record the device count to the device list announce header.
    //
    pDeviceListRemove->DeviceCount = ulDeviceCount;

    //
    //  Return the size of the buffer.
    //
    *piSize = (INT)removePacketSize;

Cleanup:

    //
    //  Unlock the device list.
    //
    _deviceMgr->Unlock();

    TRC_NRM((TB, _T("Removing %ld Devices."), ulDeviceCount));

    //
    //  Return the buffer.
    //
    DC_END_FN();
    return pPacketHeader;
}

VOID ProcObj::AnnounceClientCapability()
/*++

Routine Description:

    Generate a client capability set announcement packet.

Arguments:
    
    N/A    
Return Value:

    N/A

 --*/

{
    
    OSVERSIONINFO OsVersionInfo;
    PRDPDR_CLIENT_COMBINED_CAPABILITYSET pClientCapSet;

    DC_BEGIN_FN("ProcObj::AnnounceClientCapability");

    //
    //  Setup the client OS version
    //
    OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if (GetVersionEx(&OsVersionInfo)) {
        _cCapabilitySet.GeneralCap.osType = OsVersionInfo.dwPlatformId;

        //
        //  Setup the client OS type
        //
        switch (_cCapabilitySet.GeneralCap.osType) {
        case VER_PLATFORM_WIN32_WINDOWS:
            _cCapabilitySet.GeneralCap.osType = RDPDR_OS_TYPE_WIN9X;
            break;

        case VER_PLATFORM_WIN32_NT:
            _cCapabilitySet.GeneralCap.osType = RDPDR_OS_TYPE_WINNT;
            break;

        case VER_PLATFORM_WIN32s:
            ASSERT(FALSE);
            break;

        default:
            _cCapabilitySet.GeneralCap.osType = RDPDR_OS_TYPE_UNKNOWN;
        }

        //
        //  Setup the client OS version
        //
        _cCapabilitySet.GeneralCap.osVersion = 
                MAKELONG(OsVersionInfo.dwMinorVersion, OsVersionInfo.dwMajorVersion);

        //
        //  Since win9x doesn't support security, we don't adversise these IRPs
        // 
        if (OsVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) {
            _cCapabilitySet.GeneralCap.ioCode1 &= ~RDPDR_IRP_MJ_QUERY_SECURITY;
            _cCapabilitySet.GeneralCap.ioCode1 &= ~RDPDR_IRP_MJ_SET_SECURITY;
        }
    }

    pClientCapSet = (PRDPDR_CLIENT_COMBINED_CAPABILITYSET) new 
            BYTE[sizeof(RDPDR_CLIENT_COMBINED_CAPABILITYSET)];

    if (pClientCapSet != NULL) {
    
        memcpy(pClientCapSet, &_cCapabilitySet, sizeof(_cCapabilitySet));
        // 
        // Send the client capability to the server
        //
        _pVCMgr->ChannelWrite(pClientCapSet, sizeof(_cCapabilitySet));
    }   

    DC_END_FN();
}

void ProcObj::AnnounceClientDisplayName()
{
    PRDPDR_CLIENT_DISPLAY_NAME_PACKET pClientDisplayNamePDU;
    unsigned ClientDisplayNameLen;
    WCHAR ClientDisplayName[RDPDR_MAX_CLIENT_DISPLAY_NAME];

    DC_BEGIN_FN("ProcObj::AnnounceClientDisplayName");

    ClientDisplayNameLen = 0;
    ClientDisplayName[0] = L'\0';

    if (_sCapabilitySet.GeneralCap.extendedPDU & RDPDR_CLIENT_DISPLAY_NAME_PDU) {
    
        // 
        // TODO: Need to use shell API to get client display name
        //
        // ClientDisplayNameLen = (wcslen(ClientDisplayName) + 1) * sizeof(WCHAR);

        if (ClientDisplayNameLen) {
        
            pClientDisplayNamePDU = (PRDPDR_CLIENT_DISPLAY_NAME_PACKET) new 
                    BYTE[sizeof(RDPDR_CLIENT_DISPLAY_NAME_PACKET) + ClientDisplayNameLen];
        
            if (pClientDisplayNamePDU != NULL) {
                pClientDisplayNamePDU->Header.Component = RDPDR_CTYP_CORE;
                pClientDisplayNamePDU->Header.PacketId = DR_CORE_CLIENT_DISPLAY_NAME;
                
                pClientDisplayNamePDU->Name.ComputerDisplayNameLen = (BYTE)ClientDisplayNameLen;
        
                memcpy(pClientDisplayNamePDU + 1, ClientDisplayName, ClientDisplayNameLen);
                
                // 
                // Send the client capability to the server
                //
                _pVCMgr->ChannelWrite(pClientDisplayNamePDU, sizeof(RDPDR_CLIENT_DISPLAY_NAME_PACKET) + 
                                      ClientDisplayNameLen);
            }
        }
    }

    DC_END_FN();
}

BOOL ProcObj::InitServerCapability(PRDPDR_CAPABILITY_HEADER pCapHdr, PBYTE packetLimit)
/*++

Routine Description:

    On receiving server capability set, initialize it with the 
    local default server capability set.

Arguments:
    
    pCapHdr - Capability from the server
    
Return Value:

    TRUE  - if the server capability exists locally
    FALSE - if the local client doesn't support this capability

 --*/

{
    BOOL rc = FALSE;
    //
    // Check the packet for minimum sizes
    //
    if ((PBYTE)(pCapHdr + 1) > packetLimit) {
        return rc;
    }
    
    switch(pCapHdr->capabilityType) {
    
    case RDPDR_GENERAL_CAPABILITY_TYPE:
    {
        PRDPDR_GENERAL_CAPABILITY pGeneralCap = (PRDPDR_GENERAL_CAPABILITY)pCapHdr;
        //
        // Check the packet data size for this type.
        // For the remaining, the above check will suffice.
        //
        if ((PBYTE)(pGeneralCap+1) <= packetLimit) {
            _sCapabilitySet.GeneralCap.version = pGeneralCap->version;
            _sCapabilitySet.GeneralCap.osType = pGeneralCap->osType;
            _sCapabilitySet.GeneralCap.osVersion = pGeneralCap->osVersion;
            _sCapabilitySet.GeneralCap.ioCode1 = pGeneralCap->ioCode1;
            _sCapabilitySet.GeneralCap.extendedPDU = pGeneralCap->extendedPDU;
            _sCapabilitySet.GeneralCap.protocolMajorVersion = pGeneralCap->protocolMajorVersion;
            _sCapabilitySet.GeneralCap.protocolMinorVersion = pGeneralCap->protocolMinorVersion;
            rc = TRUE;
        }
    }
    break;

    case RDPDR_PRINT_CAPABILITY_TYPE:
    {
        PRDPDR_PRINT_CAPABILITY pPrintCap = (PRDPDR_PRINT_CAPABILITY)pCapHdr;
        _sCapabilitySet.PrintCap.version = pPrintCap->version;
        rc = TRUE;
    }
    break;

    case RDPDR_PORT_CAPABILITY_TYPE:
    {
        PRDPDR_PORT_CAPABILITY pPortCap = (PRDPDR_PORT_CAPABILITY)pCapHdr;
        _sCapabilitySet.PortCap.version = pPortCap->version;
        rc = TRUE;
    }
    break;

    case RDPDR_FS_CAPABILITY_TYPE:
    {
        PRDPDR_FS_CAPABILITY pFsCap = (PRDPDR_FS_CAPABILITY)pCapHdr;
        _sCapabilitySet.FileSysCap.version = pFsCap->version;
        rc = TRUE;
    }
    break;

    case RDPDR_SMARTCARD_CAPABILITY_TYPE:
    {
        PRDPDR_SMARTCARD_CAPABILITY pSmartCardCap = (PRDPDR_SMARTCARD_CAPABILITY)pCapHdr;
        _sCapabilitySet.SmartCardCap.version = pSmartCardCap->version;
        rc = TRUE;
    }
    break;

    default:
        rc = FALSE;
    break;
    
    }

    return rc;
}

VOID ProcObj::OnServerCapability(PRDPDR_HEADER pRdpdrHeader, ULONG maxDataLength) 
/*++

Routine Description:

    On receiving server capability set.

Arguments:
    
    pRdpdrHeader - Capability Set from the server
    
Return Value:

    N/A
    
 --*/

{
    DC_BEGIN_FN("ProcObj::OnServerCapability"); 
    //
    // Validate data lengths
    //
    PBYTE packetLimit = ((PBYTE)pRdpdrHeader) + maxDataLength;
    
    if (maxDataLength < sizeof(RDPDR_CAPABILITY_SET_HEADER)) {
        TRC_ASSERT(FALSE, 
                  (TB, _T("Server Capability Header Packet Length Error")));
        TRC_ERR((TB, _T("Invalid Data Length for Server Capability Header")));
        return;
    }
        
    
    PRDPDR_CAPABILITY_SET_HEADER pCapSetHeader = (PRDPDR_CAPABILITY_SET_HEADER)pRdpdrHeader;
    PRDPDR_CAPABILITY_HEADER pCapHdr = (PRDPDR_CAPABILITY_HEADER)(pCapSetHeader + 1);

    //
    //  Grab the supported capability info from server's capability PDU
    //
    for (unsigned i = 0; i < pCapSetHeader->numberCapabilities; i++) {
        if (InitServerCapability(pCapHdr, packetLimit)) {
            pCapHdr = (PRDPDR_CAPABILITY_HEADER)(((PBYTE)pCapHdr) + pCapHdr->capabilityLength);
        }
        else {
            TRC_ASSERT(FALSE, 
                      (TB, _T("Server Capability Packet Length Error")));
            TRC_ERR((TB, _T("Invalid Data Length for Server Capability.")));
            _pVCMgr->ChannelClose();
            break;            
        }
            
    }
    
    DC_END_FN();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\proc.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    proc.h

Abstract:

    Contains the parent of the IO processing class hierarchy
    for TS Device Redirection, ProcObj.

Author:

    Madan Appiah (madana) 17-Sep-1998

Revision History:

--*/

#ifndef __PROC_H__
#define __PROC_H__

#include <rdpdr.h>
#include "drobject.h"
#include "drdev.h"
#include "drobjmgr.h"
#include <vcint.h>


///////////////////////////////////////////////////////////////
//
//  Defines
//

//
//  Macros for returning the size of server reply buffers.  BUGBUG:
//  these defines belong in a header that is accessible from the
//  server.
//
#define DR_IOCTL_REPLYBUFSIZE(pIoRequest)                           \
((ULONG)FIELD_OFFSET(RDPDR_IOCOMPLETION_PACKET,                     \
    IoCompletion.Parameters.DeviceIoControl.OutputBuffer) +         \
    pIoRequest->Parameters.DeviceIoControl.OutputBufferLength)



///////////////////////////////////////////////////////////////
//
//  Typedefs
//

//
//  Predeclare the ProcObj class.
//
class ProcObj;

//
//  Async IO Operation Management Function Types
//
typedef HANDLE (*RDPAsyncFunc_StartIO)(PVOID context, DWORD *status);
typedef VOID (*RDPAsyncFunc_IOComplete)(PVOID context, DWORD status);
typedef VOID (*RDPAsyncFunc_IOCancel)(PVOID context);


//
//  Device Enumeration Function Type
//
//  Enumerate devices of a particular type by creating device instances
//  and and adding them to the device manager.
//
typedef DWORD (*RDPDeviceEnum)(ProcObj *procObj, DrDeviceMgr *deviceMgr);

//
//  Client capability set
//
typedef struct tagRDPDR_CLIENT_COMBINED_CAPABILITYSET
{
     RDPDR_CAPABILITY_SET_HEADER        Header;
#define RDPDR_NUM_CLIENT_CAPABILITIES   5

     RDPDR_GENERAL_CAPABILITY           GeneralCap;
#define RDPDR_CLIENT_IO_CODES           0xFFFF

     RDPDR_PRINT_CAPABILITY             PrintCap;
     RDPDR_PORT_CAPABILITY              PortCap;
     RDPDR_FS_CAPABILITY                FileSysCap; 
     RDPDR_SMARTCARD_CAPABILITY         SmartCardCap; 
} RDPDR_CLIENT_COMBINED_CAPABILITYSET, *PRDPDR_CLIENT_COMBINED_CAPABILITYSET;

//
//  Client default capability set sent to server
//
const RDPDR_CLIENT_COMBINED_CAPABILITYSET CLIENT_CAPABILITY_SET_DEFAULT = {
    // Capability Set Header
    {
        {
            RDPDR_CTYP_CORE,
            DR_CORE_CLIENT_CAPABILITY
        },

        RDPDR_NUM_CLIENT_CAPABILITIES,
        0
    },

    // General Capability
    {
        RDPDR_GENERAL_CAPABILITY_TYPE,
        sizeof(RDPDR_GENERAL_CAPABILITY),
        RDPDR_GENERAL_CAPABILITY_VERSION_01,
        0,  // Need to specify the OS type
        0,  // Need to specify the OS version
        RDPDR_MAJOR_VERSION,
        RDPDR_MINOR_VERSION,
        RDPDR_CLIENT_IO_CODES,
        0,
        RDPDR_DEVICE_REMOVE_PDUS | RDPDR_CLIENT_DISPLAY_NAME_PDU,
        0,
        0
    },

    // Printing Capability
    {
        RDPDR_PRINT_CAPABILITY_TYPE,
        sizeof(RDPDR_PRINT_CAPABILITY),
        RDPDR_PRINT_CAPABILITY_VERSION_01
    },

    // Port Capability
    {
        RDPDR_PORT_CAPABILITY_TYPE,
        sizeof(RDPDR_PORT_CAPABILITY),
        RDPDR_PORT_CAPABILITY_VERSION_01
    },

    // FileSystem Capability
    {
        RDPDR_FS_CAPABILITY_TYPE,
        sizeof(RDPDR_FS_CAPABILITY),
        RDPDR_FS_CAPABILITY_VERSION_01
    },

    // SmartCard Capability
    {
        RDPDR_SMARTCARD_CAPABILITY_TYPE,
        sizeof(RDPDR_SMARTCARD_CAPABILITY),
        RDPDR_SMARTCARD_CAPABILITY_VERSION_01
    }
};

//
//  Default server capability set sent from server
//
const RDPDR_CLIENT_COMBINED_CAPABILITYSET SERVER_CAPABILITY_SET_DEFAULT = {
    // Capability Set Header
    {
        {
            RDPDR_CTYP_CORE,
            DR_CORE_SERVER_CAPABILITY
        },

        RDPDR_NUM_CLIENT_CAPABILITIES,
        0
    },

    // General Capability
    {
        RDPDR_GENERAL_CAPABILITY_TYPE,
        sizeof(RDPDR_GENERAL_CAPABILITY),
        0,
        0,  // Need to specify the OS type
        0,  // Need to specify the OS version
        0,
        0,
        0,
        0,
        0,
        0,
        0
    },

    // Printing Capability
    {
        RDPDR_PRINT_CAPABILITY_TYPE,
        sizeof(RDPDR_PRINT_CAPABILITY),
        0
    },

    // Port Capability
    {
        RDPDR_PORT_CAPABILITY_TYPE,
        sizeof(RDPDR_PORT_CAPABILITY),
        0
    },

    // FileSystem Capability
    {
        RDPDR_FS_CAPABILITY_TYPE,
        sizeof(RDPDR_FS_CAPABILITY),
        0
    },

    // SmartCard Capability
    {
        RDPDR_SMARTCARD_CAPABILITY_TYPE,
        sizeof(RDPDR_SMARTCARD_CAPABILITY),
        0
    }
};

///////////////////////////////////////////////////////////////
//
//  ProcObj
//
//  ProcObj is the parent device IO processing class for TS
//  Device Redirection.
//

class ProcObj : public DrObject {

protected:

    VOID ProcessIORequestPacket(PRDPDR_IOREQUEST_PACKET pIoRequestPacket, UINT32 packetLen);
    ULONG GetClientID();

    //
    //  Device Enumeration List
    //
    static RDPDeviceEnum _DeviceEnumFunctions[];
    DWORD DeviceEnumFunctionsCount();

    //
    //  Remember whether an instance of this class has been 
    //  initialized.
    //
    BOOL _initialized;

    //
    //  User-Configurable Ability to Disable Device Redirection
    //
    ULONG _bDisableDeviceRedirection;

    //
    //  List of all devices being redirected.
    //
    DrDeviceMgr     *_deviceMgr;
    
    //
    //  Local Device Status
    //
    RDPDR_VERSION   _sServerVersion;

    //
    //  Capability sets
    //
    RDPDR_CLIENT_COMBINED_CAPABILITYSET _cCapabilitySet;
    RDPDR_CLIENT_COMBINED_CAPABILITYSET _sCapabilitySet;

    //
    //  Connection manager to route VC requests through
    //
    VCManager *_pVCMgr; 

    VOID MsgCoreAnnounce(
        PRDPDR_SERVER_ANNOUNCE_PACKET pAnnounce
        );

    VOID MsgCoreDevicelistReply(
        PRDPDR_DEVICELIST_REPLY pDeviceReplyList
        );

    VOID AnnounceClientCapability();

    VOID AnnounceClientDisplayName();

    VOID OnServerCapability(PRDPDR_HEADER pRdpdrHeader, ULONG maxDataLength);

    BOOL InitServerCapability(PRDPDR_CAPABILITY_HEADER pCapHdr, PBYTE packetLimit);

    //
    //  Handle a "core" server packet.
    //
    VOID ProcessCoreServerPacket(
            PRDPDR_HEADER pRdpdrHeader,
            UINT32 packetLen
            );

    //
    //  Pure virtual functions.
    //
    virtual VOID GetClientComputerName(
        PBYTE   pbBuffer,
        PULONG  pulBufferLen,
        PBOOL   pbUnicodeFlag,
        PULONG  pulCodePage
        ) = NULL;

    //
    //  Enumerate devices and announce them to the server.
    //
    virtual VOID AnnounceDevicesToServer() = 0;
    
public:

    //
    //  Constructor/Destructor
    //
    ProcObj(VCManager *pVCM);
    virtual ~ProcObj();

    //
    //  Create the correct instance of this class.
    //
    static ProcObj *Instantiate(VCManager *virtualChannelMgr);

    //
    //  Initialize an instance of this class.
    //
    virtual ULONG Initialize();

    //
    //  Return Configurable DWORD parameter.  Windows
    //  error code is returned on error.  Otherwise, ERROR_SUCCESS
    //  should be returned.
    //
    virtual ULONG GetDWordParameter(LPTSTR valueName, PULONG value) = 0;

    //
    //  Return Configurable string parameter.  Windows
    //  error code is returned on error.  Otherwise, ERROR_SUCCESS
    //  should be returned.  maxSize contains the number of bytes
    //  available in the "value" data area.
    //
    virtual ULONG GetStringParameter(LPTSTR valueName,
                                    DRSTRING value,
                                    ULONG maxSize) = 0;

    //
    //  Dispatch an asynchronous IO function.
    //
    //  startFunc points to the function that will be called to initiate the IO.  
    //  finishFunc, optionally, points to the function that will be called once
    //  the IO has completed.  Returns ERROR_SUCCESS or Windows error code.
    //
    virtual DWORD DispatchAsyncIORequest(
                    RDPAsyncFunc_StartIO ioStartFunc,
                    RDPAsyncFunc_IOComplete ioCompleteFunc = NULL,
                    RDPAsyncFunc_IOCancel ioCancelFunc = NULL,
                    PVOID clientContext = NULL
                    ) = 0;
    //
    //  Process a packet from the server.
    //
    VOID ProcessServerPacket(PVC_TX_DATA pData);

    //
    //  Make a device announe message to send to the server.
    //
    PRDPDR_HEADER GenerateAnnouncePacket(INT *piSize, BOOL bCheckDeviceChange);

    //
    //  Make a device remove message to send to the server.
    //
    PRDPDR_HEADER GenerateDeviceRemovePacket(INT *piSize);

    //
    //  Return the Virtual Channel Manager
    //
    VCManager &GetVCMgr() {
        DC_BEGIN_FN("DrObject::DrObject");
        ASSERT(_pVCMgr != NULL);
        return *_pVCMgr;
    }

    //
    //  Return the server capability
    //
    RDPDR_CLIENT_COMBINED_CAPABILITYSET &GetServerCap() {
        return _sCapabilitySet;
    }

    //
    //  Returns whether the proc obj is in the middle of shutting down.
    //
    virtual BOOL IsShuttingDown() = 0;

    //
    //  Return whether the platform is 9x.
    //
    virtual BOOL Is9x() = 0;

    //
    //  Return the class name.
    //
    virtual DRSTRING className()  { return TEXT("ProcObj"); }
    
    //
    //  Return the server protocol version
    //
    RDPDR_VERSION serverVersion() { return _sServerVersion; }

    virtual void OnDeviceChange(WPARAM wParam, LPARAM lParam) = 0;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\rdpdrcom.h ===
/*++

    Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    rdpdrcom.h

Abstract:

    Contains common include header files that are precompiled.

Author:

    Madan Appiah (madana) 16-Sep-1998

Revision History:

--*/

#include "vcint.h"
#include "proc.h"
#include "w32proc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\scredir-c.c ===
#include <windows.h>
#include <scredir_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\rdpll.h ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    rdpll

Abstract:

    Contains cut-and-paste of link list macros from ntsrv.h

Author:

    Tad Brockway (tadb) 9/99

Revision History:

--*/

#ifndef __RDPLL_H__
#define __RDPLL_H__

#undef InitializeListHead
#undef IsListEmpty
#undef RemoveHeadList
#undef RemoveTailList
#undef RemoveEntryList
#undef InsertTailList
#undef InsertHeadList
#undef PopEntryList
#undef PushEntryList

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

//
//
//  PSINGLE_LIST_ENTRY
//  PopEntryList(
//      PSINGLE_LIST_ENTRY ListHead
//      );
//

#define PopEntryList(ListHead) \
    (ListHead)->Next;\
    {\
        PSINGLE_LIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Next;\
        if (FirstEntry != NULL) {     \
            (ListHead)->Next = FirstEntry->Next;\
        }                             \
    }


//
//  VOID
//  PushEntryList(
//      PSINGLE_LIST_ENTRY ListHead,
//      PSINGLE_LIST_ENTRY Entry
//      );
//

#define PushEntryList(ListHead,Entry) \
    (Entry)->Next = (ListHead)->Next; \
    (ListHead)->Next = (Entry)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\scredir-s.c ===
#include <windows.h>
#include <scredir_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\rdpsndc.h ===
/////////////////////////////////////////////////////////////////////
//
//      Module:     rdpsndc.h
//
//      Purpose:    Client-side audio redirection
//
//      Copyright(C) Microsoft Corporation 2000
//
//      History:    4-10-2000  vladimis [created]
//
/////////////////////////////////////////////////////////////////////

#include    <malloc.h>
#include    <winsock.h>
#ifdef  OS_WINCE
#include    "wsasync.h"
#endif  // OS_WINCE

#include    <mmsystem.h>

#include    "vcint.h"
#include    "rdpsndp.h"

#ifndef     INVALID_CHANNELID
#define INVALID_CHANNELID           ((DWORD)(-1))
#endif

#define MAX_UDP_SIZE                0x10000

typedef struct _FRAGSLOT 
{
    DWORD   dwAllocatedSize;
    BOOL    bUsed;
    BYTE    cBlockNo;
    DWORD   dwBlockNo;
    DWORD   dwFragSize;
    DWORD   dwTotalSize;
    DWORD   dwExpectedTotalSize;
    UINT16  wTimeStamp;
    UINT16  wFormatNo;

    PBYTE   pData;

    struct  _FRAGSLOT *pNext;
} FRAGSLOT, *PFRAGSLOT;

class CRDPSound {
public:
    CRDPSound( 
        PCHANNEL_ENTRY_POINTS_EX pEntries,
        PVOID                    pInitHandle
    ) :
        m_pInitHandle( pInitHandle ),
        m_dwChannel( INVALID_CHANNELID ),
        m_hWave( NULL ),
        m_hMsgWindow( NULL ),
        m_hDGramSocket( INVALID_SOCKET ),
        m_dwRemoteDGramPort( 0 ),
        m_ulRemoteDGramAddress( 0 ),
        m_bPrologReceived( FALSE ),
        m_dwBytesInProlog( 0 ),
        m_dwPrologAllocated( 0 ),
        m_pProlog( NULL ),
        m_dwBytesInBody( 0 ),
        m_dwBodyAllocated( 0 ),
        m_pMsgBody( NULL ),
#if DBG
        m_lTimesWaveOutOpened( 0 ),
        m_lPrepdBlocks( 0 ),
#endif
        m_ppFormats( NULL ),
        m_dwNumFormats( 0 ),
        m_dwCurrentFormat( 0 ),
        m_pFirstWave( NULL ),
        m_pLastWave( NULL ),
        m_dwWavesPlaying( 0 ),
        m_wServerVersion( 0 ),
        m_pFragSlots( NULL )
    {
        m_hInst = GetModuleHandle( NULL );
        memcpy( &m_ChannelEntries, pEntries, sizeof( m_ChannelEntries ));
    }

    //
    //  virtual channel members
    //
    VOID
    InitEventFn(
        PVOID   pInitHandle,
        UINT    event,
        PVOID   pData,
        UINT    dataLength
        );

    VOID
    OpenEventFn(
        DWORD   OpenHandle,
        UINT    event,
        PVOID   pData,
        UINT32  dataLength,
        UINT32  totalLength,
        UINT32  dataFlags
        );

    BOOL
    ChannelWriteNCopy(
        LPVOID  pBuffer,
        UINT32  uiSize
        );

    BOOL
    ChannelWrite(
        HANDLE  hGlobMem,
        UINT32  uiBlockSize
        );

    //
    //  UDP (datagram) communication members
    //
    BOOL 
    DGramInit( 
        VOID
    );

    u_short
    DGramGetLocalPort(
        VOID
        );

    BOOL
    DGramSend(
        LPVOID pData,
        DWORD  dwSize
        );

    BOOL
    DGramRecvWave(
        PSNDWAVE pSndWave,
        DWORD    dwSize
        );

    VOID
    DGramSocketMessage(
        WPARAM wParam,
        LPARAM lParam
        );

    VOID
    DGramDone(
        VOID
        );

    //
    //  received message demultiplexer
    //
    VOID
    DataArrived(
        PSNDPROLOG      pProlog,
        LPVOID          pBody
        );


    //
    //  event/notifications demultiplexer members
    //  (i.e. message window)
    //
    BOOL
    CreateMsgWindow(
        HINSTANCE hInstance
        );

    VOID
    DestroyMsgWindow(
        VOID
        );

    //
    // waveOut/waveFormat/dynamic sound resampling members
    //
    VOID
    vcwaveCallback(
        HWAVEOUT hWave,
        UINT     uMsg,
        LPWAVEHDR lpWaveHdr
        );

    VOID
    vcwaveGetDevCaps(
        PSNDFORMATMSG pFmtMsg
        );

    BOOL
    vcwaveChooseSoundFormat(
        DWORD           dwNumberOfFormats,
        PSNDFORMATITEM  pSndFormats,
        PSNDFORMATITEM  *ppSndFormatFound,
        DWORD           *pdwListSize,
        DWORD           *pdwNumFormats
        );

    VOID
    vcwaveCleanSoundFormats(
        VOID
        );

    BOOL
    vcwaveSaveSoundFormats(
        PSNDFORMATITEM  pSndFormats,
        DWORD           dwNumFormats
        );

    VOID
    vcwaveClose(
        VOID
        );

    BOOL
    vcwaveOpen(
        LPWAVEFORMATEX  pFormat
        );

    VOID
    vcwaveFreeAllWaves(
        VOID
        );

    MMRESULT
    vcwaveOutWrite(
        LPWAVEHDR lpWaveHdr
        );

    BOOL
    vcwaveWrite(
        BYTE    cBlockNo,
        DWORD   dwFormatNo,
        DWORD   dwTimeStamp,
        DWORD   dwWaveDataLen,
        LPVOID  pData
        );

    VOID
    vcwaveResample(
        VOID
        );

    VOID
    SL_Signature(
        PBYTE pSig,
        DWORD dwBlockNo
        );

    VOID
    SL_AudioSignature(
        PBYTE pSig,
        DWORD dwBlockNo,
        PBYTE pData,
        DWORD dwDataSize
    );

    BOOL
    SL_Encrypt( 
        PBYTE pBits, 
        DWORD BlockNo, 
        DWORD dwBitsLen 
        );

private:

    BOOL
    ConstructFromDGramFrags(
        PSNDUDPWAVE pWave,
        DWORD       dwSize,
        PSNDWAVE    pReady,
        DWORD       dwReadySize
    );

    BOOL
    ConstructFromDGramLastFrag(
        PSNDUDPWAVELAST pLast,
        DWORD       dwSize,
        PSNDWAVE    pReady,
        DWORD       dwReadySize
    );

    BOOL
    _FragSlotFind(
        PFRAGSLOT *ppFragSlot,
        BYTE      cBlockNo,
        DWORD     dwEstimatedSize
    );

    VOID
    _FragSlotClear(
        PFRAGSLOT pSlot
    );

    BOOL
    _FragSlotToWave(
        PFRAGSLOT pSlot,
        PSNDWAVE  pWave,
        DWORD     dwWaveSize
    );

    VOID _FragSlotFreeAll( VOID );

    CHANNEL_ENTRY_POINTS_EX     m_ChannelEntries;
    PVOID                       m_pInitHandle;
    DWORD                       m_dwChannel;

    HWAVEOUT                    m_hWave;
    BYTE                        m_cLastReceivedBlock;
    HWND                        m_hMsgWindow;

    SOCKET                      m_hDGramSocket;
    DWORD                       m_dwRemoteDGramPort;
    ULONG                       m_ulRemoteDGramAddress;

    DWORD                       m_wServerVersion;

// receive buffers
//
    BOOL                        m_bPrologReceived;
    DWORD                       m_dwBytesInProlog;
    DWORD                       m_dwPrologAllocated;
    LPVOID                      m_pProlog;
    DWORD                       m_dwBytesInBody;
    DWORD                       m_dwBodyAllocated;
    LPVOID                      m_pMsgBody;
#ifdef  DBG
    LONG                        m_lTimesWaveOutOpened;
    LONG                        m_lPrepdBlocks;
#endif

//
//  format cache
//
    PSNDFORMATITEM              *m_ppFormats;
    DWORD                       m_dwNumFormats;
    DWORD                       m_dwCurrentFormat;

//
//  pending play blocks
//
    LPWAVEHDR                   m_pFirstWave;
    LPWAVEHDR                   m_pLastWave;
    DWORD                       m_dwWavesPlaying;
    HINSTANCE                   m_hInst;
    BYTE                        m_EncryptKey[RANDOM_KEY_LENGTH + 4];

    PFRAGSLOT                   m_pFragSlots;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\rdpsndc.cpp ===
/////////////////////////////////////////////////////////////////////
//
//      Module:     rdpsndc.c
//
//      Purpose:    Client-side audio redirection
//
//      Copyright(C) Microsoft Corporation 2000
//
//      History:    4-10-2000  vladimis [created]
//
/////////////////////////////////////////////////////////////////////

#include    "precom.h"
#include    <sha.h>
#include    <rc4.h>
#include    "rdpsndc.h"

#undef  ASSERT
#ifdef  DBG
#undef  TRC
#define TRC             _DbgPrintMessage
#define ASSERT(Cond)    if (!(Cond)) \
    { \
        ::_DbgPrintMessage( \
                FATAL, \
                _T("ASSERT in file: %s, line %d\n"), \
                _T(__FILE__), \
                __LINE__); \
        DebugBreak(); \
    }
#else   // !DBG
#define TRC
#define ASSERT
#endif  // !DBG


#ifdef  UNICODE
#define _NAMEOFCLAS  L"RDPSoundWnd"
#else   // !UNICODE
#define _NAMEOFCLAS  "RDPSoundWnd"
#endif


#define WM_WSOCK        WM_USER
#define WM_RESAMPLE     (WM_USER + 1)

#define WAVE_CLOSE_TIMEOUT  3000

//
//  WMA codec description
//
#define WMAUDIO_DEC_KEY "1A0F78F0-EC8A-11d2-BBBE-006008320064"
#define WAVE_FORMAT_WMAUDIO2    0x161
#ifdef _WIN32
#include <pshpack1.h>
#else
#ifndef RC_INVOKED
#pragma pack(1)
#endif
#endif
typedef struct wmaudio2waveformat_tag {
    WAVEFORMATEX wfx;
    DWORD        dwSamplesPerBlock;
    WORD         wEncodeOptions;
    DWORD        dwSuperBlockAlign;
} WMAUDIO2WAVEFORMAT;
#ifdef _WIN32
#include <poppack.h>
#else
#ifndef RC_INVOKED
#pragma pack()
#endif
#endif

// Trace levels
//
const TCHAR *ALV = _T("TSSNDC - ALV:");
const TCHAR *INF = _T("TSSNDC - INF:");
const TCHAR *WRN = _T("TSSNDC - WRN:");
const TCHAR *ERR = _T("TSSNDC - ERR:");
const TCHAR *FATAL = _T("TSSNDC - !FATAL!:");

/*
 *  Function declarations
 *
 */

VOID
VCAPITYPE
OpenEventFnEx(
    IN PVOID    lpUserParam,
    IN DWORD    OpenHandle,
    IN UINT     event,
    IN PVOID    pData,
    IN UINT32   dataLength,
    IN UINT32   totalLength,
    IN UINT32   dataFlags
    );

INT
WSInit(
    VOID
    );

LRESULT
CALLBACK
MsgWndProc(
    HWND hwnd,
    UINT uiMessage,
    WPARAM wParam,
    LPARAM lParam
    );

VOID
_cdecl
_DbgPrintMessage(
    LPCTSTR level,
    LPCTSTR format, 
    ...
    );

//////////////////////////////////////////////////////////////////////////

/*
 *  Function:
 *      OpenEventFn
 *
 *  Description:
 *      Called by the TS client on channel read/write ready
 *
 *  Parameters:
 *      lpUserParam -   parameter passed from VirtualChannelEntryEx
 *      OpenaHandle -   Channel handle, returned by VirtualChanneOpen
 *      event       -   event type
 *      pData       -   meaning depends on event type
 *      dataLength  -   size of pData
 *      dataFlags   -   information about the received data
 *
 */
VOID
VCAPITYPE
OpenEventFnEx(
    IN PVOID    lpUserParam,
    IN DWORD    OpenHandle,
    IN UINT     event,
    IN PVOID    pData,
    IN UINT32   dataLength,
    IN UINT32   totalLength,
    IN UINT32   dataFlags
    )
{
    CRDPSound *pSnd;

    ASSERT( NULL != lpUserParam );

    if ( NULL != lpUserParam )
    {
        pSnd = ((VCManager*)lpUserParam)->GetSound();
        ASSERT( NULL != pSnd );

        if ( NULL != pSnd )
            pSnd->OpenEventFn(
                OpenHandle,
                event,
                pData,
                dataLength,
                totalLength,
                dataFlags
            );
    }
}

LRESULT
CALLBACK 
MsgWndProc( 
    HWND hwnd,
    UINT uiMessage,
    WPARAM wParam,
    LPARAM lParam
    )
{
    LRESULT rv = 0;
    CRDPSound *pSnd;

    pSnd = (CRDPSound *)
#ifndef OS_WINCE
        GetWindowLongPtr( hwnd, GWLP_USERDATA );
#else   // OS_WINCE
        GetWindowLong( hwnd, GWL_USERDATA );
#endif

    switch (uiMessage)
    {
    case MM_WOM_OPEN:
        ASSERT( NULL != pSnd );
        if ( NULL != pSnd )
            pSnd->vcwaveCallback( (HWAVEOUT)wParam, WOM_OPEN, NULL );
    break;
    case MM_WOM_CLOSE:
        ASSERT( NULL != pSnd );
        if ( NULL != pSnd )
            pSnd->vcwaveCallback( (HWAVEOUT)wParam, WOM_CLOSE, NULL );
    break;

    case MM_WOM_DONE: 
        ASSERT( NULL != pSnd );
        if ( NULL != pSnd )
            pSnd->vcwaveCallback((HWAVEOUT)wParam, WOM_DONE, (LPWAVEHDR)lParam); 
    break;

    case WM_RESAMPLE:
        ASSERT( NULL != pSnd );
        if ( NULL != pSnd )
            pSnd->vcwaveResample();
        break;
    case WM_WSOCK:
        ASSERT( NULL != pSnd );
        pSnd->DGramSocketMessage(wParam, lParam);
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
    break;

    default: 
        rv = DefWindowProc(hwnd, uiMessage, wParam, lParam);
    }

    return rv;
}

/*
 *  Function:
 *      InitEventFn
 *
 *  Description:
 *      Called by InitEventFn
 *
 *  Parameters:
 *      pInitHandle -   connection handle
 *      event       -   Event id
 *      pData       -   Data, meaning depends on event id
 *      dataLength  -   Length of data
 *                      (see MSDN: VirtualChannelInitEvent)
 *
 */
VOID
CRDPSound::InitEventFn(
    PVOID   pInitHandle,
    UINT    event,
    PVOID   pData,
    UINT    dataLength
    )
{
    UINT rc;
    UNREFERENCED_PARAMETER(dataLength);

    ASSERT( pInitHandle == m_pInitHandle );
    switch(event)
    {
    case CHANNEL_EVENT_INITIALIZED:
        TRC(ALV, _T("InitEventFnEx: CHANNEL_EVENT_INITILIZED\n"));
        ::WSInit();
/*
#ifdef  OS_WINCE
#error  create single instance
        ::WSAStartAsyncThread();
#endif  // OS_WINCE
*/
        CreateMsgWindow(m_hInst);
        break;
    case CHANNEL_EVENT_CONNECTED:
        TRC(ALV, _T("InitEventFnEx: CHANNEL_EVENT_CONNECTED to %s\n"), pData);
        ASSERT(m_ChannelEntries.pVirtualChannelOpenEx);

        rc = (m_ChannelEntries.pVirtualChannelOpenEx)(
                pInitHandle,
                &m_dwChannel,
                _SNDVC_NAME,
                OpenEventFnEx
            );

        if (rc != CHANNEL_RC_OK)
        {
            TRC(WRN, _T("InitEventFnEx: VirtualChannelOpen returned %d\n"), rc);
            m_dwChannel = INVALID_CHANNELID;
        } else {
            // All's OK, check the channel handle
            //
            ASSERT(m_dwChannel != INVALID_CHANNELID);
        }

        // Prepare for connectionless data
        //
        DGramInit();

        break;
    case CHANNEL_EVENT_DISCONNECTED:
        TRC(ALV, _T("InitEventFnEx: CHANNEL_EVENT_DISCONNECTED\n"));
        ASSERT(m_ChannelEntries.pVirtualChannelCloseEx);

        if (m_dwChannel != INVALID_CHANNELID)
        {
            rc = m_ChannelEntries.pVirtualChannelCloseEx(
                        m_pInitHandle,
                        m_dwChannel
                    );
            if (rc != CHANNEL_RC_OK)
            {
                TRC(WRN, _T("InitEventFnEx: VirtualChannelClose returned %d\n"), rc);
            }
            m_dwChannel = INVALID_CHANNELID;

            if (NULL != m_hWave)
            {
                waveOutReset(m_hWave);
                vcwaveClose();
            }
        }

        // destroy the UDP socket
        //
        DGramDone();

        m_bPrologReceived = FALSE;
        m_dwBytesInProlog = 0;
        m_dwBytesInBody = 0;

        //
        //  dispose the cache format
        //
        vcwaveCleanSoundFormats();

        vcwaveFreeAllWaves();
        _FragSlotFreeAll();
        break;
    case CHANNEL_EVENT_V1_CONNECTED:
        TRC(ALV, _T("InitEventFnEx: CHANNEL_EVENT_V1_CONNECTED\n"));
        break;
    case CHANNEL_EVENT_TERMINATED:
        TRC(ALV, _T("InitEventFnEx: CHANNEL_EVENT_TERMINATED\n"));
        WSACleanup();
        if (NULL != m_hWave)
        {
            waveOutReset(m_hWave);
            vcwaveClose();
        }

        DGramDone();
/*
#ifdef  OS_WINCE
#error  see previous error
        ::WSACloseAsyncThread();
#endif  // OS_WINCE
*/
        if ( NULL != m_pProlog )
        {
            free( m_pProlog );
            m_pProlog = NULL;
        }

        if ( NULL != m_pMsgBody )
        {
            free( m_pMsgBody );
            m_pMsgBody = NULL;
        }

        vcwaveCleanSoundFormats();
        vcwaveFreeAllWaves();
        _FragSlotFreeAll();

	DestroyMsgWindow();

        break;
    default:
        TRC(ALV, _T("Unhandled event in InitEventFnEx: %d\n"), event);
    }
}

/*
 *  Function:
 *      OpenEventFn
 *
 *  Description:
 *      Called by OpenEventFnEx
 *
 *  Parameters:
 *      OpenaHandle -   Channel handle, returned by VirtualChanneOpen
 *      event       -   event type
 *      pData       -   meaning depends on event type
 *      dataLength  -   size of pData
 *      dataFlags   -   information about the received data
 *
 */
VOID
CRDPSound::OpenEventFn(
    DWORD   OpenHandle,
    UINT    event,
    PVOID   pData,
    UINT32  dataLength,
    UINT32  totalLength,
    UINT32  dataFlags
    )
{
    UNREFERENCED_PARAMETER(OpenHandle);

    switch (event)
    {
    case CHANNEL_EVENT_DATA_RECEIVED:
#if _IO_DBG
        TRC(ALV, 
            "OpenEventFn: CHANNEL_EVENT_DATA_RECEIVED, dataSize=0x%x, total=0x%x\n",
            dataLength,
            totalLength);
#endif

    //
    //  save the data in global buffers
    //
    if (!m_bPrologReceived)
    {
        //
        // receive the prolog (1st message)
        //

        if ( 0 != ( dataFlags & CHANNEL_FLAG_FIRST ))
            m_dwBytesInProlog = 0;

        if ( NULL == m_pProlog )
        {
            ASSERT( 0 != ( dataFlags & CHANNEL_FLAG_FIRST ));

            m_pProlog = malloc( totalLength );

            if ( NULL == m_pProlog )
            {
                TRC( FATAL, _T("OpenEventFn: failed to allocate %d bytes\n"),
                            totalLength);
                break;
            }

            m_dwPrologAllocated = totalLength;
        }

        if ( totalLength > m_dwPrologAllocated )
        {
            PVOID pNewProlog;

            ASSERT( 0 != ( dataFlags & CHANNEL_FLAG_FIRST ));

            pNewProlog = realloc( m_pProlog, totalLength );

            if ( NULL == pNewProlog )
            {
                TRC( FATAL, _T("OpenEventFn: failed to allocate %d bytes\n"),
                            totalLength);
                free ( m_pProlog );
                m_pProlog = NULL;
                m_dwPrologAllocated = 0;
                break;

            }
            m_pProlog = pNewProlog;
            m_dwPrologAllocated = totalLength;
        }

        if ( m_dwBytesInProlog + dataLength > m_dwPrologAllocated )
        {
            TRC( ERR, _T("An invalid VC packet received. Ignoring\n" ));
            break;
        }

        memcpy( ((LPSTR)m_pProlog) + m_dwBytesInProlog, pData, dataLength );
        m_dwBytesInProlog += dataLength;

        ASSERT( m_dwBytesInProlog <= totalLength );

        if ( 0 != ( dataFlags & CHANNEL_FLAG_LAST ))
        {
            m_bPrologReceived = TRUE;

            ASSERT( sizeof(SNDPROLOG) <= m_dwBytesInProlog );

            //
            // check if we expect a body
            //
            ASSERT( m_dwBytesInProlog - sizeof(SNDPROLOG) <=
                    ((PSNDPROLOG)m_pProlog)->BodySize);

            if ( m_dwBytesInProlog - sizeof(SNDPROLOG) ==
                ((PSNDPROLOG)m_pProlog)->BodySize )
            {
                //  no, proceed the message
                //
                DataArrived(
                    (PSNDPROLOG)m_pProlog,
                    ((PSNDPROLOG)m_pProlog) + 1
                );

                m_bPrologReceived = FALSE;
                m_dwBytesInProlog = 0;
                m_dwBytesInBody   = 0;
            }
        }
    } else {
        //
        // receive the body (2nd message)
        //

        if ( 0 != ( dataFlags & CHANNEL_FLAG_FIRST ))
            m_dwBytesInBody = 0;

        if ( NULL == m_pMsgBody )
        {
            ASSERT( 0 != ( dataFlags & CHANNEL_FLAG_FIRST ));

            m_pMsgBody = malloc( totalLength );

            if ( NULL == m_pMsgBody )
            {
                TRC( FATAL, _T("OpenEventFn: failed to allocate %d bytes\n"),
                            totalLength);
                break;
            }

            m_dwBodyAllocated = totalLength;
        }

        if ( totalLength > m_dwBodyAllocated )
        {
            PVOID pNewBody;

            ASSERT( 0 != ( dataFlags & CHANNEL_FLAG_FIRST ));

            pNewBody = realloc( m_pMsgBody, totalLength );

            if ( NULL == pNewBody )
            {
                TRC( FATAL, _T("OpenEventFn: failed to allocate %d bytes\n"),
                            totalLength);
                free ( m_pMsgBody );
                m_pMsgBody = NULL;
                m_dwBodyAllocated = 0;
                break;

            }
            m_pMsgBody = pNewBody;
            m_dwBodyAllocated = totalLength;
        }

        if ( m_dwBytesInBody + dataLength > m_dwBodyAllocated )
        {
            TRC( ERR, _T("An invalid VC packet received. Ignoring\n" ));
            break;
        }

        memcpy( ((LPSTR)m_pMsgBody) + m_dwBytesInBody, pData, dataLength );
        m_dwBytesInBody += dataLength;

        ASSERT( m_dwBytesInBody <= totalLength );

        if ( 0 != ( dataFlags & CHANNEL_FLAG_LAST ))
        {
            UINT32 *pdw;

            //
            //  here comes the magic
            //  the server sends two packets, but it is possible
            //  in case of switching between sessions (or shadowing ?!)
            //  that the client can receive first packet from one session
            //  and the second from another
            //  that's why we have a valid message type for each packet
            //  by replacing the first word of the second message
            //  this word is kept in the end of the first message
            //
            if ( NULL != m_pMsgBody &&
                 SNDC_NONE != *((UINT32 *)m_pMsgBody) )
            {
                LPVOID pSwap;
                DWORD  dwSwap;

                TRC(ERR, _T("OpenEventFn: messages not synchronized. ")
                         _T("Trying to fix it\n"));

                pSwap = m_pProlog;
                m_pProlog = m_pMsgBody;
                m_pMsgBody = pSwap;

                dwSwap = m_dwPrologAllocated;
                m_dwPrologAllocated = m_dwBodyAllocated;
                m_dwBodyAllocated = dwSwap;

                m_dwBytesInProlog = m_dwBytesInBody;
                m_dwBytesInBody = 0;

                // we swapped the body and the prolog
                // now, wait for the actual body
                //
                break;
            }

            //
            // from the end of the prolog message, remove
            // UINT32 word and place it at the begining of the body
            //

            ASSERT( sizeof(SNDPROLOG) + sizeof(UINT32) <= m_dwBytesInProlog);
            if ( sizeof(SNDPROLOG) + sizeof(UINT32) > m_dwBytesInProlog )
            {
                TRC( ERR, _T("An invalid VC packet received. Ignoring\n" ));
                break;
            }

            pdw = (UINT32 *)(((LPSTR)m_pProlog) + 
                        m_dwBytesInProlog - sizeof(UINT32));
            *((UINT32 *)m_pMsgBody) = *pdw;

            //
            //  cut the prolog length by UINT32 size
            //
            m_dwBytesInProlog -= sizeof(UINT32);

            DataArrived( 
                (PSNDPROLOG)m_pProlog,
                m_pMsgBody
            );

            m_bPrologReceived = FALSE;
            m_dwBytesInProlog = 0;
            m_dwBytesInBody   = 0;
        }
    }
    break;

    case CHANNEL_EVENT_WRITE_COMPLETE:
    {
        TRC(ALV, _T("OpenEventFn: CHANNEL_EVENT_WRITE_COMPLETE, ptr=0x%p\n"), 
                 pData);

        free(pData);

    }
        break;
    case CHANNEL_EVENT_WRITE_CANCELLED:
    {
        TRC(WRN, _T("OpenEventFn: CHANNEL_EVENT_WRITE_CANCELED. Cleaning up\n"));
        free(pData);
    }
        break;
    default:
        TRC(ALV, _T("Unhandled event in OpenEventFn: %d\n"), event);
    }
}

/*
 *  Function:
 *      ChannelWriteNCopy
 *
 *  Description:
 *      Allocates a chunk of memory and sends it using ChannelWrite
 *      Allows the caller to free or reuse the buffer
 *
 *  Parameters:
 *      pBuffer -   Chunk pointer
 *      uiSize  -   Chunk size
 *
 *  Returns:
 *      TRUE on success
 *
 */
BOOL
CRDPSound::ChannelWriteNCopy(
    LPVOID  pBuffer,
    UINT32  uiSize
    )
{
    BOOL    rv = FALSE;
    LPVOID  pSendBuffer = NULL;

    if ( INVALID_CHANNELID == m_dwChannel )
    {
        TRC(ERR, _T("ChannelWriteNCopy: invalid handle\n"));
        goto exitpt;
    }

    if (NULL == pBuffer)
    {
        TRC(ERR, _T("ChannelWriteNCopy: buffer is NULL\n"));
        goto exitpt;
    }

    pSendBuffer = malloc(uiSize);

    if (pSendBuffer)
    {
        memcpy(pSendBuffer, pBuffer, uiSize);
        rv = ChannelWrite( pSendBuffer, uiSize );
    }

exitpt:
    if (!rv)
    {
        if (pSendBuffer)
            free(pSendBuffer);
    }

    return rv;
}

/*
 *  Function:
 *      DataArrived
 *
 *  Description:
 *      Processes a message arrived from the channel
 *
 *  Parameters:
 *      pProlog -   the message prolog, type and body size
 *      pBody   -   pointer to the message body
 *
 */
VOID
CRDPSound::DataArrived(
    PSNDPROLOG      pProlog,
    LPVOID          pBody
    )
{
    ASSERT(pProlog);
    ASSERT(pBody);
    switch(pProlog->Type)
    {
        case SNDC_CLOSE:

            TRC(ALV, _T("DataArrived: SNDC_CLOSE\n"));

            if (m_hWave)
            {
                vcwaveClose();
            }
        break;

        case SNDC_SETVOLUME:
        {
            PSNDSETVOLUME pSetVolume;

            TRC(ALV, _T("DataArrived: SNDC_SETVOLUME\n"));

            if ( pProlog->BodySize < sizeof( *pSetVolume ) - sizeof( *pProlog ))
            {
                TRC( ERR, _T("DataArrived: Invalid SNDC_SETVOLUME message\n" ));
                break;
            }

            pSetVolume = (PSNDSETVOLUME)
                                    (((LPSTR)pBody) - sizeof(*pProlog));

            ASSERT(pProlog->BodySize == sizeof(*pSetVolume) - sizeof(*pProlog));

            if (m_hWave)
                waveOutSetVolume(m_hWave, pSetVolume->dwVolume);
        }
        break;

        case SNDC_WAVE:
        {
            PSNDWAVE pWave;

            //
            // disable dgram response
            //
            m_dwRemoteDGramPort = 0;
            m_ulRemoteDGramAddress = 0;

            pWave = (PSNDWAVE)pProlog;

            TRC(ALV, _T("DataArrived: SNDC_WAVE, block no: %d\n"),
                    pWave->cBlockNo);

            if ( pProlog->BodySize < sizeof( *pWave ) - sizeof( *pProlog ))
            {
                TRC( ERR, _T("DataArrived: Invalid SNDC_WAVE message\n" ));
                break;
            }

            vcwaveWrite(pWave->cBlockNo, 
                        pWave->wFormatNo,
                        pWave->wTimeStamp,
                        pWave->Prolog.BodySize - sizeof(SNDWAVE) + sizeof(SNDPROLOG), 
                        pBody);

        }
        break;

        case SNDC_TRAINING:
        {
            SNDTRAINING SndTraining;
            PSNDTRAINING pRecvTraining;

            if ( pProlog->BodySize < sizeof( *pRecvTraining ) - sizeof( *pProlog ))
            {
                TRC( ERR, _T("DataArrived: Invalid SNDC_TRAINING message\n" ));
                break;
            }

            //
            // disable dgram response
            //
            m_dwRemoteDGramPort = 0;
            m_ulRemoteDGramAddress = 0;

            pRecvTraining = (PSNDTRAINING)
                            (((LPSTR)pBody) - sizeof(*pProlog));

            TRC(ALV, _T("DataArrived: training, sending a response\n"));
            SndTraining.Prolog.Type = SNDC_TRAINING;
            SndTraining.Prolog.BodySize = sizeof(SndTraining) -
                                        sizeof(SndTraining.Prolog);
            SndTraining.wTimeStamp = pRecvTraining->wTimeStamp;
            SndTraining.wPackSize = pRecvTraining->wPackSize;

            //
            //  send the response immediatly
            //
            ChannelWriteNCopy( &SndTraining, sizeof(SndTraining) );

        }
        break;

        case SNDC_FORMATS:
        {
            PSNDFORMATMSG   pSndFormats;
            PSNDFORMATMSG   pSndFormatsResp;
            PSNDFORMATITEM  pSndSuppFormats = NULL;
            DWORD           dwRespSize;
            DWORD           dwListSize;
            DWORD           dwNumFormats;
            BOOL            bSuccess;
            DWORD           dwPacketSize;
            DWORD           count;
            PSNDFORMATITEM  pFmt;

            pSndFormats = (PSNDFORMATMSG)
                            (((LPSTR)pBody) - sizeof(*pProlog));

            TRC(ALV, _T("DataArrived: SNDC_FORMATS, number of formats: %d\n"),
                pSndFormats->wNumberOfFormats);

            if ( pProlog->BodySize < sizeof( *pSndFormats ) - sizeof( *pProlog ))
            {
                TRC( ERR, _T("DataArrived: Invalid SNDC_FORMATS message\n" ));
                break;
            }

            //
            //  validate the packet length
            //
            dwPacketSize = pProlog->BodySize - sizeof( *pSndFormats ) + sizeof( *pProlog );
            pFmt = (PSNDFORMATITEM) (pSndFormats + 1);
            for( count = 0; count < pSndFormats->wNumberOfFormats; count ++ )
            {
                DWORD adv = sizeof( *pFmt ) + pFmt->cbSize;
                if ( adv > dwPacketSize )
                {
                    TRC( ERR, _T("DataArrived: Invalid SNDC_FORMATS, invalid format list\n" ));
                    goto break_sndformat;
                }
                pFmt = (PSNDFORMATITEM)((LPSTR)pFmt + adv);
                dwPacketSize -= adv;
            }
            ASSERT( 0 == dwPacketSize );
            

            m_cLastReceivedBlock = pSndFormats->cLastBlockConfirmed;
            vcwaveCleanSoundFormats();

            bSuccess = vcwaveChooseSoundFormat(
                            pSndFormats->wNumberOfFormats,
                            (PSNDFORMATITEM) (pSndFormats + 1),
                            &pSndSuppFormats,
                            &dwListSize,
                            &dwNumFormats
                        );

            if (bSuccess)
            {
                ASSERT( NULL != pSndSuppFormats );
                ASSERT( 0    != dwListSize );
                ASSERT( 0    != dwNumFormats );

                bSuccess = vcwaveSaveSoundFormats(
                                pSndSuppFormats, 
                                dwNumFormats);
                if (!bSuccess)
                {
                    free(pSndSuppFormats);
                    pSndSuppFormats = NULL;
                    dwNumFormats = 0;
                    dwListSize = 0;
                }
            } else {
                ASSERT( NULL == pSndSuppFormats );
                ASSERT( 0    == dwListSize );
                ASSERT( 0    == dwNumFormats );
            }

            dwRespSize = sizeof( *pSndFormatsResp ) + dwListSize;

            __try {
                pSndFormatsResp = (PSNDFORMATMSG)alloca( dwRespSize );
            } 
            __except((EXCEPTION_STACK_OVERFLOW == GetExceptionCode()) ?
                        EXCEPTION_EXECUTE_HANDLER :
                        EXCEPTION_CONTINUE_SEARCH)
            {
                _resetstkoflw();
                pSndFormatsResp = NULL;
                TRC(ERR, _T("alloca threw exception: 0x%x\n"),
                        GetExceptionCode());
            }
            if ( NULL == pSndFormatsResp )
                goto break_sndformat;

            pSndFormatsResp->Prolog.Type = SNDC_FORMATS;
            pSndFormatsResp->Prolog.BodySize = (UINT16)(
                dwRespSize - 
                sizeof( pSndFormatsResp->Prolog ));
            pSndFormatsResp->wNumberOfFormats = (WORD)dwNumFormats;
            vcwaveGetDevCaps( pSndFormatsResp );

            //
            //  Beta 1 compatability, fake we are version 1 if the server is version 1
            //
            m_wServerVersion = pSndFormats->wVersion;
            if ( 1 == pSndFormats->wVersion )
                pSndFormatsResp->wVersion = 1;
            else
                pSndFormatsResp->wVersion = RDPSND_PROTOCOL_VERSION;

            //
            // copy the format list
            //
            memcpy( (PSNDFORMATITEM) ( pSndFormatsResp + 1 ), 
                    pSndSuppFormats, 
                    dwListSize );

            ChannelWriteNCopy( pSndFormatsResp, dwRespSize );
break_sndformat:
            if ( NULL != pSndSuppFormats )
                free ( pSndSuppFormats );
        }
        break;

        case SNDC_CRYPTKEY:
        {
            PSNDCRYPTKEY pKey = (PSNDCRYPTKEY)(((LPSTR)pBody) - sizeof(*pProlog));

            if ( pProlog->BodySize < sizeof( *pKey ) - sizeof( *pProlog ))
            {
                TRC( ERR, _T("DataArrived: Invalid SNDC_CRYPTKEY message\n"));
                break;
            }
            memcpy( m_EncryptKey, pKey->Seed, RANDOM_KEY_LENGTH );
        }
        break;

        default:
            TRC(ERR, _T("DataArrived: Invalid message type received: %d\n"), pProlog->Type);
    }
}

/*
 *  Function:
 *      vcwaveResample
 *
 *  Description:
 *      Reopens the device with new codec
 *
 */
VOID
CRDPSound::vcwaveResample(
    VOID
    )
{
    if ( 0 != m_dwWavesPlaying || NULL == m_pFirstWave )
        goto exitpt;

    if ( NULL == m_hWave || 
         m_dwCurrentFormat != (DWORD)PtrToLong((PVOID)m_pFirstWave->reserved))
    {
        TRC(INF, _T("vcwaveResample: Resampling\n"));
        m_dwCurrentFormat = (DWORD)PtrToLong((PVOID)m_pFirstWave->reserved);

        if ( m_dwCurrentFormat >= m_dwNumFormats )
        {
            TRC(ERR, _T("vcwaveResample: invalid format no\n"));
            vcwaveFreeAllWaves();

            goto exitpt;
        }

        vcwaveOpen( (LPWAVEFORMATEX)m_ppFormats[ m_dwCurrentFormat ] );
    }

    //
    // stuff all pending blocks
    //
    while ( NULL != m_pFirstWave &&
            m_dwCurrentFormat == (DWORD)PtrToLong( (PVOID)m_pFirstWave->reserved ))
    {
        LPWAVEHDR lpNext = m_pFirstWave->lpNext;
        MMRESULT  mmres;

        mmres = vcwaveOutWrite( m_pFirstWave );
        if ( MMSYSERR_NOERROR != mmres )
        {
            vcwaveFreeAllWaves();
        } else {

            m_pFirstWave = lpNext;

            if ( NULL == m_pFirstWave )
                m_pLastWave = NULL;
        }
    }

exitpt:
    ;
}

/*
 *  Function:
 *      DGramSocketMessage
 *
 *  Description:
 *      Callback from UDP
 *
 */
VOID
CRDPSound::DGramSocketMessage(
    WPARAM wParam,
    LPARAM lParam
    )
{
    if (WSAGETSELECTERROR(lParam))
    {
        TRC(ERR, _T("WM_WSOCK: Winsock error: %d\n"),
                    WSAGETSELECTERROR(lParam));
        goto exitpt;
    }

    if (m_hDGramSocket != (SOCKET)wParam)
    {
        TRC(WRN, _T("WM_WSOCK: message for unknown socket\n"));
        goto exitpt;
    }

    if (WSAGETSELECTEVENT(lParam) == FD_CLOSE)
    {
        TRC(ERR, _T("WM_WSOCK: socket closed\n"));
        DGramDone();
        
        goto exitpt;
    }

    if (WSAGETSELECTEVENT(lParam) != FD_READ)
    {
        TRC(WRN, _T("WM_WSOCK: unknown event received\n"));

        goto exitpt;
    }

    TRC(ALV, _T("WM_WSOCK: data available\n"));
    {
        BOOL bSuccess;
        PSNDWAVE    pSndWave;
        UINT        structsize;

        structsize = sizeof(*pSndWave) + TSSND_BLOCKSIZE + RDPSND_SIGNATURE_SIZE;

        __try 
        {
            pSndWave = (PSNDWAVE)alloca(structsize);
        } 
        __except((EXCEPTION_STACK_OVERFLOW == GetExceptionCode()) ?
                    EXCEPTION_EXECUTE_HANDLER :
                    EXCEPTION_CONTINUE_SEARCH)
        {
            _resetstkoflw();
            pSndWave = NULL;
            TRC(ERR, _T("WM_SOCK: alloca threw exception: 0x%x\n"),
                    GetExceptionCode());
        }

        if (NULL == pSndWave)
            goto exitpt;

        bSuccess = DGramRecvWave(
                    pSndWave,
                    structsize
                    );

        if (bSuccess)
        {
            PBYTE pWave = (PBYTE)(pSndWave+1);
            UINT  uiWaveSize = pSndWave->Prolog.BodySize -
                        sizeof(SNDWAVE) + sizeof(SNDPROLOG);

            if ( IsDGramWaveSigned( m_wServerVersion ))
            {
                DWORD dw;
                BYTE Signature[ RDPSND_SIGNATURE_SIZE ];

                //
                //  wave starts with signature
                //
                if ( uiWaveSize < RDPSND_SIGNATURE_SIZE )
                {
                    TRC( ERR, _T("Insufficient data for signature\n" ));
                    goto exitpt;
                }

                if ( !IsDGramWaveAudioSigned( m_wServerVersion ))
                {
                    SL_Signature( Signature, pSndWave->dwBlockNo );
                } else {
                    SL_AudioSignature( Signature, 
                                       pSndWave->dwBlockNo, 
                                       pWave + RDPSND_SIGNATURE_SIZE, 
                                       uiWaveSize - RDPSND_SIGNATURE_SIZE );
                }
                dw = memcmp( pWave, Signature, RDPSND_SIGNATURE_SIZE );
                if ( 0 !=  dw )
                {
                    TRC( ERR, _T("Invalid signature\n" ));
                    goto exitpt;
                }
                pWave += RDPSND_SIGNATURE_SIZE;
                uiWaveSize -= RDPSND_SIGNATURE_SIZE;
            }
            vcwaveWrite(pSndWave->cBlockNo,
                        pSndWave->wFormatNo,
                        pSndWave->wTimeStamp,
                        uiWaveSize,
                        pWave);
        }
    }

exitpt:
    ;
}

/*
 *  Function:
 *      CreateMsgWindow
 *
 *  Description:
 *      Creates a window
 *
 */
BOOL
CRDPSound::CreateMsgWindow(
    HINSTANCE hInstance
    )
{
    WNDCLASS    wc;
    BOOL        rv = FALSE;
    DWORD       dwLastErr;
    LONG_PTR    dwUser;

    memset(&wc, 0, sizeof(wc));

    wc.lpfnWndProc      = MsgWndProc;
    wc.hInstance        = hInstance;
    wc.lpszClassName    = _NAMEOFCLAS;

    if (!RegisterClass (&wc))
    {
        dwLastErr = GetLastError();
        if(dwLastErr != ERROR_CLASS_ALREADY_EXISTS)
        {
            TRC(ERR,
                  _T("CreateMsgWindow: Can't register class. GetLastError=%d\n"),
                  GetLastError());
            goto exitpt;
        }
    }


    m_hMsgWindow = CreateWindow(
                       _NAMEOFCLAS,
                       NULL,         // Window name
                       0,            // dwStyle
                       0,            // x
                       0,            // y
                       0,            // nWidth
                       0,            // nHeight
                       NULL,         // hWndParent
                       NULL,         // hMenu
                       hInstance,
                       NULL);        // lpParam

    if (!m_hMsgWindow)
    {
        TRC(ERR, _T("CreateMsgWindow: Failed to create message window. GetLastError=%d\n"),
                GetLastError());
        goto exitpt;
    }

    //
    //  safe the class pointer in the window structure
    //
#ifndef	OS_WINCE
    dwUser = SetWindowLongPtr(
                m_hMsgWindow,
                GWLP_USERDATA,
                (LONG_PTR)this
        );
#else    
    dwUser = SetWindowLong(
                m_hMsgWindow,
                GWL_USERDATA,
                (LONG)this
        );
#endif

    ASSERT( 0 == dwUser );

    rv = TRUE;
exitpt:
    return rv;
}

/*
 *  Function:
 *      DestroyMsgWindow
 *
 *  Description:
 *      Destroy our window
 *
 */
VOID
CRDPSound::DestroyMsgWindow(
    VOID
    )
{
    if (NULL != m_hMsgWindow)
        DestroyWindow(m_hMsgWindow);

    UnregisterClass(_NAMEOFCLAS, m_hInst);
}


/*
 *  Function:
 *      ChannelWrite
 *
 *  Description:
 *      Sends or queues a chunk of data to the virtual channel
 *
 *  Parameters:
 *      hGlobMem    -   handle to a HGLOBAL
 *      uiBlockSize -   size of the chunk
 *
 *  Returns:
 *      TRUE on success
 *
 */
BOOL
CRDPSound::ChannelWrite(
    LPVOID  pData,
    UINT32  uiBlockSize
    )
{
    BOOL        rv = FALSE;
    DWORD       Handle = m_dwChannel;
    UINT        rc;

    ASSERT(Handle != INVALID_CHANNELID);
    ASSERT(m_ChannelEntries.pVirtualChannelWriteEx);

    // parameters check
    //
    if (INVALID_CHANNELID == Handle)
    {
        TRC(ERR, _T("ChannelWrite: invalid handle\n"));
        goto exitpt;
    }

    TRC(ALV, _T("Sending ptr=%p, Size=%d\n"), pData, uiBlockSize);

    rc = m_ChannelEntries.pVirtualChannelWriteEx(
            m_pInitHandle,
            Handle,
            pData,
            uiBlockSize,
            pData);

    if (rc != CHANNEL_RC_OK)
    {
        TRC(INF, _T("VirtualChannelWrite failed rv=%d"), rc);
        goto exitpt;
    }

    rv = TRUE;

exitpt:

    if (!rv)
    {
        TRC(ERR, _T("ChannelWrite: Failed to send data\n"));
    }
    return rv;
}

/*
 *  Function:
 *      vcwaveCallbacl
 *
 *  Description:
 *      WaveOut callbacks
 *
 */
VOID
CRDPSound::vcwaveCallback(
    HWAVEOUT hWave,
    UINT     uMsg,
    LPWAVEHDR lpWaveHdr
    )
{
    switch (uMsg)
    {
    case WOM_OPEN:
        TRC(ALV, _T("vcwaveCallback: WOM_OPEN\n"));
    break;
    case WOM_CLOSE:
        TRC(ALV, _T("vcwaveCallback: WOM_CLOSE\n"));
    break;

    case WOM_DONE:
    {
        SNDWAVECONFIRM WaveConfirm;

        ASSERT( 0 != ( lpWaveHdr->dwFlags & WHDR_PREPARED ));

        if ( 0 == ( lpWaveHdr->dwFlags & WHDR_PREPARED ))
        {
            TRC( ERR, _T("vcwaveCallback: buffer already unprepared\n") );
        } else if ( m_hWave != hWave )
        {
            TRC( ERR, _T("vcwaveCallback: can't unprepare header, beacuse ")
                      _T("the stream is already closed\n"));
        } else {
            MMRESULT        mmres;

            mmres = waveOutUnprepareHeader(
                hWave,
                lpWaveHdr,
                sizeof(*lpWaveHdr)
            );

            ASSERT( mmres == MMSYSERR_NOERROR );
#if DBG
            m_lPrepdBlocks --;
#endif  // DBG

        }

        if (lpWaveHdr)
        {
            DWORD dw = PtrToLong((PVOID)lpWaveHdr->dwUser);

            WaveConfirm.cConfirmedBlockNo = (BYTE)(dw >> 16);
            //
            //  adjust completly the time stamp
            //  see vcwaveWrite
            //
            WaveConfirm.wTimeStamp        = (WORD)
                ((dw & 0xffff) + GetTickCount());
#if _STAT_DBG
            TRC(INF, _T("blockno=%d, adjusted time stamp=%x\n"),
                WaveConfirm.cConfirmedBlockNo, WaveConfirm.wTimeStamp);
#endif

            TRC(ALV, _T("vcwaveCallback: WOM_DONE, block no %d\n"),
                    WaveConfirm.cConfirmedBlockNo);

            if (lpWaveHdr->lpData)
            {
#ifdef OS_WINCE
                lpWaveHdr->lpData = (char *)UnMapPtr(lpWaveHdr->lpData);
                if (lpWaveHdr->lpData)
#endif
                free(lpWaveHdr->lpData);
            }
            else
                TRC(ERR, _T("vcwaveCallback: WOM_DONE: lpWaveHdr->lpData is NULL\n"));

            free(lpWaveHdr);
        } else
            TRC(ERR, _T("vcwaveCallback: WOM_DONE: lpWaveHdr is NULL\n"));

        //  Send the confirmation
        //
        WaveConfirm.Prolog.Type = SNDC_WAVECONFIRM;
        WaveConfirm.Prolog.BodySize = sizeof(WaveConfirm) -
                                        sizeof(WaveConfirm.Prolog); 

        if ( 0 != m_ulRemoteDGramAddress )
            DGramSend( &WaveConfirm, sizeof(WaveConfirm));
        else
            ChannelWriteNCopy( &WaveConfirm, sizeof( WaveConfirm ));

        m_dwWavesPlaying --;
        ASSERT( -1 != m_dwWavesPlaying );

        if ( 0 == m_dwWavesPlaying && NULL != m_pFirstWave )
        {
            TRC(INF, _T("vcwaveCallback: WOM_DONE: attempt to resample\n"));
            PostMessage( m_hMsgWindow, WM_RESAMPLE, 0, 0 );
        }
    }    
    break;
    }
}

/*
 *  Function:
 *      vcwaveGetDevCaps
 *
 *  Description:
 *      Queries for device capabilities
 *
 */
VOID
CRDPSound::vcwaveGetDevCaps(
    PSNDFORMATMSG pFmtMsg
    )
{
    WAVEFORMATEX Format;
    MMRESULT     mmres;
    DWORD        dw;

    ASSERT( NULL != pFmtMsg );

    pFmtMsg->dwFlags = 0;
    pFmtMsg->dwVolume = 0;
    pFmtMsg->dwPitch = 0;
    pFmtMsg->wDGramPort = 0;

    Format.wFormatTag         = WAVE_FORMAT_PCM;
    Format.nChannels          = TSSND_NATIVE_CHANNELS;
    Format.nSamplesPerSec     = TSSND_NATIVE_SAMPLERATE;
    Format.nAvgBytesPerSec    = TSSND_NATIVE_AVGBYTESPERSEC;
    Format.nBlockAlign        = TSSND_NATIVE_BLOCKALIGN;
    Format.wBitsPerSample     = TSSND_NATIVE_BITSPERSAMPLE;
    Format.cbSize             = 0;

    if (!vcwaveOpen(&Format))
    {
        TRC(ERR, _T("vcwaveGetDevCaps: can't open device\n"));
        goto exitpt;
    }
    ASSERT( NULL != m_hWave );

    pFmtMsg->dwFlags = TSSNDCAPS_ALIVE;
    pFmtMsg->wDGramPort = DGramGetLocalPort();

    mmres = waveOutGetVolume(m_hWave, &dw);
    if (MMSYSERR_NOERROR == mmres)
    {
        pFmtMsg->dwFlags |= TSSNDCAPS_VOLUME;
        pFmtMsg->dwVolume = dw;
    }
    else
        TRC(ERR, _T("vcwaveGetDevCaps: device doesn't support volume control\n"));

    mmres = waveOutGetPitch(m_hWave, &dw);
    if (MMSYSERR_NOERROR == mmres)
    {
        pFmtMsg->dwFlags |= TSSNDCAPS_PITCH;
        pFmtMsg->dwPitch = dw;
    }
    else
        TRC(INF, _T("vcwaveGetDevCaps: device doesn't support pitch control\n"));

    vcwaveClose();

exitpt:
    ;
}

/*
 *  Function:
 *      vcwaveChooseSoundFormat
 *
 *  Description:
 *      Queries the local device for different formats
 *
 */
BOOL
CRDPSound::vcwaveChooseSoundFormat(
    DWORD           dwNumberOfFormats,
    PSNDFORMATITEM  pSndFormats,
    PSNDFORMATITEM  *ppSndFormatFound,
    DWORD           *pdwListSize,
    DWORD           *pdwNumFormats
    )
{
    PSNDFORMATITEM pSndFormat;

    //
    // query the waveout device with different wave formats
    // returns the list of successfull formats in pSndFormatFound
    // FALSE in any other case
    // the caller takes responsibility for freeing the data in
    // *ppSndFormatFound
    //
    BOOL    rv = FALSE;
    DWORD   i;
    PSNDFORMATITEM pSndFormatFound = NULL;
    LPSTR   pFmtCopy;
    DWORD   dwListSize = 0;
    DWORD   dwNumFormats = 0;

    ASSERT( NULL != pSndFormats );
    ASSERT( NULL != ppSndFormatFound );
    ASSERT( NULL != pdwListSize );
    ASSERT( NULL != pdwNumFormats );

    for ( i = 0, pSndFormat = pSndFormats; 
          i < dwNumberOfFormats; 
          i++, pSndFormat = (PSNDFORMATITEM)
            (((LPSTR)pSndFormat) + sizeof( *pSndFormat ) + pSndFormat->cbSize) 
        )
    {
        MMRESULT mmres;
        PSNDFORMATITEM pFmtToOpen = pSndFormat;
        PSNDFORMATITEM pFixedFormat = NULL;

        //
        //  fix the format for WMA audio
        //  copy and modify it in another structure, so we don't disrupt
        //  the original
        //
        if ( WAVE_FORMAT_WMAUDIO2 == pSndFormat->wFormatTag )
        {
            DWORD dwTotalSize = sizeof( WMAUDIO2WAVEFORMAT ) -
                sizeof( WAVEFORMATEX ) + sizeof( WMAUDIO_DEC_KEY );

            ASSERT( pSndFormat->cbSize == dwTotalSize );
            if ( pSndFormat->cbSize == dwTotalSize )
            {
                pFixedFormat = (PSNDFORMATITEM)malloc( sizeof( WMAUDIO2WAVEFORMAT ) +
                                    sizeof( WMAUDIO_DEC_KEY ));
                if ( NULL != pFixedFormat )
                {
                    memcpy( pFixedFormat, pSndFormat, sizeof( pSndFormat ) + pSndFormat->cbSize );
                    strncpy((CHAR *)(((WMAUDIO2WAVEFORMAT *) pFixedFormat) + 1), 
                        WMAUDIO_DEC_KEY, sizeof( WMAUDIO_DEC_KEY ));
                    pFmtToOpen = pFixedFormat;
                }
            }
        }

        mmres = waveOutOpen(
                        NULL,
                        WAVE_MAPPER,
                        (LPWAVEFORMATEX)pFmtToOpen,
                        0,
                        0,
                        WAVE_FORMAT_QUERY
                    );

        if ( NULL != pFixedFormat )
        {
            free( pFixedFormat );
        }

        TRC(ALV, _T("FormatTag - %d\n"),        pSndFormat->wFormatTag);
        TRC(ALV, _T("Channels - %d\n"),         pSndFormat->nChannels);
        TRC(ALV, _T("SamplesPerSec - %d\n"),    pSndFormat->nSamplesPerSec);
        TRC(ALV, _T("AvgBytesPerSec - %d\n"),   pSndFormat->nAvgBytesPerSec);
        TRC(ALV, _T("BlockAlign - %d\n"),       pSndFormat->nBlockAlign);
        TRC(ALV, _T("BitsPerSample - %d\n"),    pSndFormat->wBitsPerSample);
        TRC(ALV, _T("cbSize        - %d\n"),    pSndFormat->cbSize);

        if ( MMSYSERR_NOERROR == mmres )
        {
        //
        //  this format is supported
        //

            TRC(ALV, _T("vcwaveChooseSoundFormat: format found\n"));

            dwListSize += sizeof( *pSndFormat ) + pSndFormat->cbSize;
            dwNumFormats ++;
        } else {
            //
            //  if not supported,
            //  zero it's AvgBytesPerSec member
            //
            TRC(INF, _T("vcwaveChooseSoundFormat: format not supported\n"));
            pSndFormat->nAvgBytesPerSec = 0;
        }
                                
    }

    if ( 0 == dwListSize )
    {
        TRC(WRN, _T("vcwaveChooseSoundFormat: no formats found\n"));
        goto exitpt;
    }

    pSndFormatFound = (PSNDFORMATITEM)malloc( dwListSize );
    if ( NULL == pSndFormatFound )
    {
        TRC( ERR, _T("vcwaveChooseSoundFormat: can't allocate %d bytes\n"),
                dwListSize );

        dwListSize   = 0;
        dwNumFormats = 0;
        goto exitpt;
    }

    //
    //  copy the list of supported formats
    //
    for ( i = 0, pSndFormat = pSndFormats, pFmtCopy = (LPSTR)pSndFormatFound;
          i < dwNumberOfFormats;
          i++, pSndFormat = (PSNDFORMATITEM)
            (((LPSTR)pSndFormat) + sizeof( *pSndFormat ) + pSndFormat->cbSize)
        )
    {
        if ( 0 != pSndFormat->nAvgBytesPerSec )
        {
            memcpy( pFmtCopy, 
                    pSndFormat, 
                    sizeof( *pSndFormat ) + pSndFormat->cbSize);
            pFmtCopy += sizeof( *pSndFormat ) + pSndFormat->cbSize;
        }
    }

    rv = TRUE;

exitpt:
    *ppSndFormatFound = pSndFormatFound;
    *pdwListSize      = dwListSize;
    *pdwNumFormats    = dwNumFormats;

    return rv;
}

/*
 *  Function:
 *      vcwaveCleanSoundForamt
 *
 *  Description:
 *      Cleans the list of negotiated formats
 *
 */
VOID
CRDPSound::vcwaveCleanSoundFormats(
    VOID
    )
{
    DWORD   i;

    if ( NULL == m_ppFormats )
        goto exitpt;
    //
    // dispose the allocated structures
    //
    for (i = 0; i < m_dwNumFormats; i++)
    {
        if ( NULL != m_ppFormats[i] )
            free( m_ppFormats[i] );
    }
    free( m_ppFormats );
    m_ppFormats = NULL;
    m_dwNumFormats = 0;
exitpt:
    ;
}

/*
 *  Function:
 *      vcwaveSafeSoundFormats
 *
 *  Description:
 *      Saves the list of negotiated formats
 *
 */
BOOL
CRDPSound::vcwaveSaveSoundFormats(
    PSNDFORMATITEM  pSndFormats,
    DWORD           dwNumFormats
    )
{
    BOOL            rv = FALSE;
    DWORD           i;
    DWORD           dwAllocSize;
    LPSTR           p;

    ASSERT( NULL != pSndFormats );
    ASSERT( 0 != dwNumFormats );

    if ( NULL != m_ppFormats )
    {
        vcwaveCleanSoundFormats();
    }

    ASSERT( NULL == m_ppFormats );
    ASSERT( 0 == m_dwNumFormats );
     
    dwAllocSize = sizeof( PSNDFORMATITEM ) * dwNumFormats;
    m_ppFormats = (PSNDFORMATITEM *)malloc( dwAllocSize );
    if ( NULL == m_ppFormats )
    {
        TRC(ERR, _T("Failed to allocate %d bytes\n"),
                dwAllocSize );
        goto exitpt;
    }

    memset( m_ppFormats, 0, dwAllocSize );

    for (i = 0, p = (LPSTR)pSndFormats; 
         i < dwNumFormats; 
         i++, p += sizeof(SNDFORMATITEM) + ((PSNDFORMATITEM)p)->cbSize)
    {
        PSNDFORMATITEM  pFmt;

        pFmt = (PSNDFORMATITEM) p;
        dwAllocSize = sizeof(SNDFORMATITEM) + pFmt->cbSize;
        m_ppFormats[i] = (PSNDFORMATITEM)malloc( dwAllocSize );

        if ( NULL == (PVOID)m_ppFormats[i] )
        {
            TRC(ERR, _T("Failed to allocate %d bytes\n"),
                        dwAllocSize );
            goto exitpt;
        }

        //
        //  copy the format
        //
        memcpy( m_ppFormats[i], pFmt, dwAllocSize );
    }

    m_dwNumFormats = dwNumFormats;

    rv = TRUE;

exitpt:

    if (!rv && NULL != m_ppFormats)
    {
        // dispose the allocated structures
        //
        for (i = 0; i < dwNumFormats; i++)
        {
            if ( NULL != m_ppFormats[i] )
                free( m_ppFormats[i] );
        }
        free( m_ppFormats );
        m_ppFormats = NULL;
        m_dwNumFormats = 0;
    }
    return rv;
}

/*
 *  Function:
 *      vcwaveClose
 *
 *  Description:
 *      Closes the local device
 *
 */
VOID
CRDPSound::vcwaveClose(
    VOID
    )
{
    MSG msg;
    UINT_PTR idTimer;

    if ( NULL == m_hWave )
        goto exitpt;

    //
    //  process all MM_WOM_DONE messages
    //
    ASSERT( NULL != m_hMsgWindow );

    //
    //  start a timeout timer
    //
    idTimer = SetTimer( m_hMsgWindow, 1, WAVE_CLOSE_TIMEOUT, NULL );

    while( 0 != m_dwWavesPlaying &&
           GetMessage( &msg, m_hMsgWindow, 0, 0 ))
    {
        if ( WM_TIMER == msg.message && msg.wParam == idTimer )
        {
            //
            //  cancel outstanding io
            //
            TRC( WRN, _T("TIMEDOUT waiting for the playing to complete. Resetting\n" ));
            waveOutReset( m_hWave );
        }
        DispatchMessage(&msg);
    }

    if ( 0 != idTimer )
    {
        KillTimer( m_hMsgWindow, idTimer );
    }

    waveOutClose(m_hWave);

#ifdef DBG
    if ( 0 != InterlockedDecrement(&m_lTimesWaveOutOpened))
    {
        TRC(FATAL, _T("Device was closed too many times\n"));
        ASSERT(0);
    }

    ASSERT( 0 == m_dwWavesPlaying );
    ASSERT( 0 == m_lPrepdBlocks );
#endif
    m_hWave = NULL;

exitpt:
    ;
}

/*
 *  Function:
 *      vcwaveOpen
 *
 *  Description:
 *      Opens the device in given format
 *
 */
BOOL
CRDPSound::vcwaveOpen(
    LPWAVEFORMATEX  pFormat
    )
{
    BOOL            rv = FALSE;
    MMRESULT        mmres;


    if (m_hWave)
    {
        TRC(WRN, _T("vcwaveOpen: device is already opened. Reopening\n"));

        waveOutReset(m_hWave);
        vcwaveClose();
    }

    if (INVALID_SOCKET == m_hDGramSocket)
    {
        TRC(ERR, _T("vcwaveOpen: no datagram connection, falling to VC\n"));
    }

    // 11.025 kHz, 8 bit, mono

    if (NULL == m_hMsgWindow && !CreateMsgWindow(m_hInst))
        goto exitpt;

    //
    //  fix the format for WMA audio
    //
    if ( WAVE_FORMAT_WMAUDIO2 == pFormat->wFormatTag )
    {
        DWORD dwTotalSize = sizeof( WMAUDIO2WAVEFORMAT ) -
            sizeof( WAVEFORMATEX ) + sizeof( WMAUDIO_DEC_KEY );

        ASSERT( pFormat->cbSize == dwTotalSize );
        if ( pFormat->cbSize == dwTotalSize )
        {
            strncpy((CHAR *)(((WMAUDIO2WAVEFORMAT *) pFormat) + 1),
                WMAUDIO_DEC_KEY, sizeof( WMAUDIO_DEC_KEY ));
        }
    }
    mmres = waveOutOpen(
                &m_hWave,
                WAVE_MAPPER,
                pFormat,
                (DWORD_PTR)m_hMsgWindow,
                0,                               // CallbackInstance
                CALLBACK_WINDOW
        );

    if (MMSYSERR_NOERROR != mmres)
    {
        TRC(WRN, _T("vcwaveOpen: failed to open WaveOut device: MMRESULT=%d\n"),
                mmres);
        goto exitpt;
    }

#ifdef OS_WINCE
    TRC(ALV, _T("waveOutOpen succeeded with following format %d\n"),  pFormat->wFormatTag);
    TRC(ALV, _T("FormatTag - %d\n"),        pFormat->wFormatTag);
    TRC(ALV, _T("Channels - %d\n"),         pFormat->nChannels);
    TRC(ALV, _T("SamplesPerSec - %d\n"),    pFormat->nSamplesPerSec);
    TRC(ALV, _T("AvgBytesPerSec - %d\n"),   pFormat->nAvgBytesPerSec);
    TRC(ALV, _T("BlockAlign - %d\n"),       pFormat->nBlockAlign);
    TRC(ALV, _T("BitsPerSample - %d\n"),    pFormat->wBitsPerSample);
    TRC(ALV, _T("cbSize        - %d\n"),    pFormat->cbSize);
#endif

#ifdef DBG
        // Win95 InterlockedIncrement() difference.
        InterlockedIncrement(&m_lTimesWaveOutOpened);

        if ( 1 != m_lTimesWaveOutOpened )
        {
            TRC(FATAL, _T("Device was opened %d times\n"),
                m_lTimesWaveOutOpened);
            ASSERT(0);
        }
#endif

    rv = TRUE;

exitpt:

    return rv;
}

/*
 *  Function:
 *      vcwaveFreeAllWaves
 *
 *  Description:
 *      Frees all queued data
 *
 */
VOID
CRDPSound::vcwaveFreeAllWaves(
    VOID
    )
{
    while ( NULL != m_pFirstWave )
    {
        LPWAVEHDR lpNext = m_pFirstWave->lpNext;

        free( m_pFirstWave->lpData );
        free( m_pFirstWave );

        m_pFirstWave = lpNext;
    }

    m_pFirstWave = m_pLastWave = NULL;
}

/*
 *  Function:
 *      vcwaveOutWrite
 *
 *  Description:
 *      Writes a data to the output sound device
 *
 */
MMRESULT
CRDPSound::vcwaveOutWrite(
    LPWAVEHDR lpWaveHdr 
    )
{
    MMRESULT mmres;

    mmres = waveOutPrepareHeader(
                m_hWave,
                lpWaveHdr,
                sizeof(*lpWaveHdr)
            );

    if (MMSYSERR_NOERROR != mmres)
    {
        TRC(WRN, _T("vcwaveOpen: failed to prepare buffer: MMRESULT=%d\n"),
                mmres);
        goto exitpt;
    }

    m_dwWavesPlaying++;
#if DBG
    m_lPrepdBlocks ++;
#endif

    mmres = waveOutWrite(
                m_hWave,
                lpWaveHdr,
                sizeof(*lpWaveHdr)
            );

    if (MMSYSERR_NOERROR != mmres)
    {
        TRC(WRN, _T("vcwaveOpen: failed to write in WaveOut device: MMRESULT=%d\n"),
                mmres);

        waveOutUnprepareHeader(
            m_hWave,
            lpWaveHdr,
            sizeof(*lpWaveHdr)
        );

        m_dwWavesPlaying --;
#if DBG
        m_lPrepdBlocks --;
#endif

        goto exitpt;
    }

exitpt:
    return mmres;
}

/*
 *  Function:
 *      vcwaveWrite
 *
 *  Description:
 *      If the format id is not changes calls vcwaveOutWrite
 *      otherwise queues the data for later
 *
 */
BOOL
CRDPSound::vcwaveWrite(
    BYTE    cBlockNo, 
    DWORD   dwFormatNo,
    DWORD   dwTimeStamp,
    DWORD   dwWaveDataLen, 
    LPVOID  pData
    )
{
    BOOL        rv = FALSE;
    LPVOID      lpWaveData = NULL;
    LPWAVEHDR   lpWaveHdr = NULL;
    MMRESULT    mmres;
    BOOL        bDontPlay = FALSE;

    //
    //  put the stamp here to remove the delay of opening the device
    //
    DWORD       dwStartStamp = GetTickCount() & 0xffff;

    if ( NULL != m_hWave && 
        m_dwCurrentFormat != dwFormatNo )
    {
        bDontPlay = TRUE;
    }

    if (NULL == m_hWave)
    {
        TRC(ALV, _T("wcwaveWrite: attempting to open the device\n"));
        if (dwFormatNo >= m_dwNumFormats)
        {
            TRC(FATAL, _T("Invalid format no: %d\n"),
                dwFormatNo);
            goto exitpt;
        }
        if ( NULL == m_ppFormats )
        {
            TRC(FATAL, _T("No formats available(NULL)\n"));
            goto exitpt;
        }
        if ( !vcwaveOpen( (LPWAVEFORMATEX)m_ppFormats[dwFormatNo] ))
            TRC(ERR, _T("Can't open the device\n"));

        m_dwCurrentFormat = dwFormatNo;
    }

    if ((BYTE)( m_cLastReceivedBlock - cBlockNo ) < TSSND_BLOCKSONTHENET)
    {
        TRC(WRN, _T("wcwaveWrite: received old block, ")
                 _T("the last one is %d, this one is %d. Discarding\n"),
                 m_cLastReceivedBlock,
                 cBlockNo);
        goto exitpt;
    } else 
        m_cLastReceivedBlock = cBlockNo;

    lpWaveData = malloc(dwWaveDataLen);
    if (!lpWaveData)
    {
        TRC(ERR, _T("vcwaveWrite: malloc failed to allocate %d bytes\n"),
                    dwWaveDataLen);
        goto exitpt;
    }

    lpWaveHdr = (LPWAVEHDR)malloc(sizeof(*lpWaveHdr));
    if (!lpWaveHdr)
    {
        TRC(ERR, _T("vcwaveWrite: malloc failed for %d bytes\n"), 
                sizeof(*lpWaveHdr));
        goto exitpt;
    }

    memset(lpWaveHdr, 0, sizeof(*lpWaveHdr));

    memcpy(lpWaveData, pData, dwWaveDataLen);

    lpWaveHdr->lpData = (LPSTR)lpWaveData;
    lpWaveHdr->dwBufferLength = dwWaveDataLen;
    lpWaveHdr->dwFlags = 0;
    lpWaveHdr->dwLoops = 0;

    //
    //  here, we'll do a little magic with the time stamp
    //  in order to exclude the time when time packet is in the wave queue
    //  we'll subtract the current time now and add the time when
    //  confirmation is to be send
    //
#if _STAT_DBG
    TRC(INF, _T("blockno=%d, time stamp=%x\n"),
        cBlockNo, dwTimeStamp );
#endif 

    lpWaveHdr->dwUser  = (cBlockNo << 16) + 
                         ((dwTimeStamp - dwStartStamp ) & 0xffff);

    if ( bDontPlay )
    {
    //
    //  format change
    //  add this wave to the list
    //
        lpWaveHdr->reserved = dwFormatNo;
        lpWaveHdr->lpNext = NULL;

        if ( NULL != m_pLastWave )
            m_pLastWave->lpNext = lpWaveHdr;
        else
            m_pFirstWave = lpWaveHdr;

        m_pLastWave = lpWaveHdr;

        ASSERT( NULL != lpWaveHdr->lpData );

        TRC(INF, _T("vcwaveWrite: posting WM_RESAMPLE\n"));
        PostMessage( m_hMsgWindow, WM_RESAMPLE, 0, 0 );

        goto leavept;
    }

    mmres = vcwaveOutWrite( lpWaveHdr );

    if (MMSYSERR_NOERROR != mmres)
    {
        TRC(WRN, _T("vcwaveOpen: failed to play a buffer: MMRESULT=%d\n"),
                mmres);
        goto exitpt;
    }

leavept:

    rv = TRUE;

exitpt:

    if (!rv)
    {
        if (lpWaveData)
            free(lpWaveData);

        if (lpWaveHdr)
            free(lpWaveHdr);

    }

    return rv;
}

/*
 *  Function:
 *      DGramInit
 *
 *  Description:
 *      Init our UDP socket
 *
 */
BOOL
CRDPSound::DGramInit(
    VOID
    )
{
    BOOL rv = FALSE;
#ifndef OS_WINCE
    INT  optval;
#endif
    INT  rc;
    struct sockaddr_in sin;

    ASSERT(INVALID_SOCKET == m_hDGramSocket);

    m_hDGramSocket = socket(AF_INET, SOCK_DGRAM, 0);
    if (INVALID_SOCKET == m_hDGramSocket)
    {
        TRC(ERR, _T("DGramInit: can't create dgram socket: %d\n"),
                WSAGetLastError());
        goto exitpt;
    }

    // bind the socket to any port/address
    //
    sin.sin_family = PF_INET;
    sin.sin_port = htons(0);    // any port between 1024 and 50000
    sin.sin_addr.s_addr = INADDR_ANY;

    rc = bind(m_hDGramSocket, (struct sockaddr *)(&sin), sizeof(sin));
    if (SOCKET_ERROR == rc)
    {
        TRC(ERR, _T("DGramInit: can't bind the socket: %d\n"),
            WSAGetLastError());
        goto exitpt;
    }

#ifndef OS_WINCE
    //
    //  assign an appropriate buffer length
    //
    optval = TSSND_BLOCKSONTHENET * (sizeof(SNDWAVE) + TSSND_BLOCKSIZE);
    rc = setsockopt(m_hDGramSocket, 
               SOL_SOCKET,
               SO_RCVBUF, 
               (LPSTR)&optval,
               sizeof(optval));

    if (SOCKET_ERROR == rc)
    {
        TRC(ERR, _T("DGramInit: setsockopt failed: %d\n"),
            WSAGetLastError());
        goto exitpt;
    }
#endif

    // select the socket on the message window
    //
    if (NULL != m_hMsgWindow &&
        SOCKET_ERROR ==
        WSAAsyncSelect(m_hDGramSocket, m_hMsgWindow,
                       WM_WSOCK, FD_READ))
    {
        TRC(ERR, _T("DGramInit: WSAAsyncSelect failed: %d\n"),
                WSAGetLastError());
        goto exitpt;
    }

    rv = TRUE;

exitpt:
    if (!rv && INVALID_SOCKET != m_hDGramSocket)
    {
        closesocket(m_hDGramSocket);
        m_hDGramSocket = INVALID_SOCKET;
    }

    return rv;
}

/*
 *  Function:
 *      DGramDone
 *
 *  Description:
 *      Destroy our UDP socket
 *
 */
VOID
CRDPSound::DGramDone(
    VOID
    )
{
    if (INVALID_SOCKET != m_hDGramSocket)
    {
        closesocket(m_hDGramSocket);
        m_hDGramSocket = INVALID_SOCKET;
    }
}

/*
 *  Function:
 *      DGramGetLocalPort
 *
 *  Description:
 *      Retreives the local UDP port
 *
 */
u_short
CRDPSound::DGramGetLocalPort(
    VOID
    )
{
    u_short rv = 0;
    struct sockaddr_in sin;
    INT rc;
    INT nSinSize;

    if (INVALID_SOCKET == m_hDGramSocket)
    {
        TRC(ERR, _T("DGramGetLocalPort: invalid socket\n"));
        goto exitpt;
    }

    nSinSize = sizeof(sin);
    rc = getsockname(m_hDGramSocket, 
                     (struct sockaddr *)&sin, 
                     &nSinSize);

    if (SOCKET_ERROR == rc)
    {
        TRC(ERR, _T("DGramGetLocalPort: getsockname failed: %d\n"),
                WSAGetLastError());
        goto exitpt;
    }

    ASSERT(PF_INET == sin.sin_family);

    rv = sin.sin_port;
exitpt:
    return rv;
}

/*
 *  Function:
 *      DGramSend
 *
 *  Description:
 *      Send an UDP packet
 *
 */
BOOL
CRDPSound::DGramSend(
    LPVOID pData,
    DWORD  dwSize
    )
{
    INT rc = SOCKET_ERROR;
    struct sockaddr_in sin;

    ASSERT( 0 != m_dwRemoteDGramPort );
    ASSERT( 0 != m_ulRemoteDGramAddress );

    if ( INVALID_SOCKET == m_hDGramSocket )
    {
        TRC(ERR, _T("DGramSend: invalid socket handle\n"));
        goto exitpt;
    }

    sin.sin_family = PF_INET;
    sin.sin_port   = (u_short)m_dwRemoteDGramPort;
    sin.sin_addr.s_addr = m_ulRemoteDGramAddress;
    rc = sendto(
            m_hDGramSocket,
            (LPSTR)pData,
            dwSize,
            0,
            (struct sockaddr *)&sin,
            sizeof( sin )
        );

    if ( SOCKET_ERROR == rc )
    {
        TRC(WRN, _T("DGramSend: sendto failed=%d\n"),
            WSAGetLastError());
    }

exitpt:
    return ( rc != SOCKET_ERROR );
}

/*
 *  Function:
 *      DGramRecvWave
 *
 *  Description:
 *      Recieve data from UDP
 *
 */
BOOL
CRDPSound::DGramRecvWave(
    PSNDWAVE pSndWave,
    DWORD    dwSize
    )
{
    BOOL rv = FALSE;
    INT  recvd;
    struct sockaddr_in  sin_from;
    INT  nSinFrom;

    // parameters check
    //
    if (NULL == pSndWave)
    {
        TRC(ERR, _T("DGramRecvWave: pSndWave is NULL\n"));
        goto exitpt;
    }

    if (dwSize <= sizeof(*pSndWave))
    {
        TRC(ERR, _T("DGramRecvWave: no enough space to get the wave\n"));
        goto exitpt;
    }

    // receive the message
    //
    nSinFrom = sizeof( sin_from );
    recvd = recvfrom(
                     m_hDGramSocket,
                     (LPSTR)pSndWave,
                     dwSize,
                     0, 
                     (struct sockaddr *)&sin_from, 
                     &nSinFrom
            );

    if (recvd < sizeof(pSndWave->Prolog)  || ((DWORD)recvd) > dwSize)
    {
        if (SOCKET_ERROR == recvd)
            TRC(ERR, _T("WM_WSOCK: recvfrom failed: %d\n"),
                WSAGetLastError());
        else
            TRC(WRN,
                _T("WM_WSOCK: received %d bytes instead %d. Discarding\n"),
                recvd, sizeof(pSndWave->Prolog));
        goto exitpt;
    }

    ASSERT( PF_INET == sin_from.sin_family );
    if ( PF_INET != sin_from.sin_family )
    {
        TRC(WRN, _T("WM_WSOCK: message from invalid protocol( %x )\n"),
                sin_from.sin_family );
            goto exitpt;
    }
    if ( sizeof( sin_from ) > nSinFrom )
    {
        TRC(WRN, _T("WM_WSOCK: from address invalid, len=%d\n"),
                nSinFrom );
        goto exitpt;
    }

    m_dwRemoteDGramPort = sin_from.sin_port;
    m_ulRemoteDGramAddress = sin_from.sin_addr.s_addr;

    //
    //  Check for line-training request
    //
    if (SNDC_TRAINING == pSndWave->Prolog.Type)
    {
        SNDTRAINING SndTraining;
        PSNDTRAINING pRecvTraining;

        TRC(ALV, _T("DGramRecvWave: training, sending a response\n"));

        pRecvTraining = (PSNDTRAINING)pSndWave;

        SndTraining.Prolog.Type = SNDC_TRAINING;
        SndTraining.Prolog.BodySize = sizeof(SndTraining) - 
                                        sizeof(SndTraining.Prolog);
        SndTraining.wTimeStamp = pRecvTraining->wTimeStamp;
        SndTraining.wPackSize = pRecvTraining->wPackSize;

        //
        //  send the response immediatly
        //
        DGramSend( &SndTraining, sizeof(SndTraining) );

        goto exitpt;
    }

    if ( SNDC_UDPWAVE == pSndWave->Prolog.Type)
    {
        rv = ConstructFromDGramFrags( 
                (PSNDUDPWAVE)pSndWave, 
                recvd,
                pSndWave, 
                dwSize
            );
        goto exitpt;

    } else if ( SNDC_UDPWAVELAST == pSndWave->Prolog.Type)
    {
        rv = ConstructFromDGramLastFrag( 
                (PSNDUDPWAVELAST)pSndWave, 
                recvd,
                pSndWave, 
                dwSize 
            );
        goto exitpt;
    }

    if (SNDC_WAVEENCRYPT == pSndWave->Prolog.Type)
    {

        if ( !SL_Encrypt( 
                           (PBYTE)(pSndWave + 1), 
                           pSndWave->dwBlockNo,
                           pSndWave->Prolog.BodySize -  sizeof(SNDWAVE) + sizeof(SNDPROLOG) ))
            goto exitpt;

    } 
    else if (SNDC_WAVE != pSndWave->Prolog.Type)
    {
        TRC(ERR, _T("DGramRecvWave: invalid message type: %d\n"),
                    pSndWave->Prolog.Type);
        goto exitpt;
    }

    if ( recvd < sizeof(SNDPROLOG) ||
         pSndWave->Prolog.BodySize + sizeof(SNDPROLOG) != (DWORD)recvd)
    {
        TRC(WRN,
            _T("WM_WSOCK: received %d bytes instead %d. Discarding\n"),
            recvd, pSndWave->Prolog.BodySize + sizeof(SNDPROLOG) );
        goto exitpt;
    }

    TRC(ALV, _T("DGramRecvWave: block no: %d\n"),
            pSndWave->cBlockNo);

    rv = TRUE;

exitpt:
    return rv;
}

BOOL
CRDPSound::ConstructFromDGramFrags(
    PSNDUDPWAVE pWave,
    DWORD       dwSize,
    PSNDWAVE    pReady,
    DWORD       dwReadySize
    )
{
    BOOL rv = FALSE;
    PBYTE pRecvdData;
    DWORD dwFragNo;
    DWORD dwEstimatedSize;
    DWORD dwDataSize;
    PFRAGSLOT pSlot;

    if ( dwSize <= sizeof( *pWave ))
    {
        TRC( ERR, _T("ConstructFromDGramFrags: packet too small %d\n"),
                dwSize );
        goto exitpt;
    }

    pRecvdData = (PBYTE)(pWave + 1);
    dwFragNo = pWave->cFragNo & (~RDPSND_FRAGNO_EXT);
    dwDataSize = dwSize - sizeof( *pWave );

    if ( pWave->cFragNo & RDPSND_FRAGNO_EXT )
    {
        dwFragNo <<= 8;
        dwFragNo += *pRecvdData;
        pRecvdData++;
        dwDataSize--;
    }
    dwEstimatedSize = ( dwFragNo + 1 ) * dwDataSize;
    if ( dwEstimatedSize >= MAX_UDP_SIZE )
    {
        TRC( ERR, _T("ConstructFromDGramFrags: estimated size >=64K (0x%x)\n"),
                dwEstimatedSize );
        goto exitpt;
    }

    if (!_FragSlotFind( &pSlot, pWave->cBlockNo, dwEstimatedSize ))
    {
        goto exitpt;
    }

    if ( 0 != pSlot->dwFragSize && pSlot->dwFragSize != dwDataSize )
    {
        TRC( ERR, _T("ConstructFromDGramFrags: received frag with different size: %d, expect %d\n"),
                dwDataSize, pSlot->dwFragSize );
        _FragSlotClear( pSlot );
        goto exitpt;
    }
    memcpy( pSlot->pData + dwFragNo *  dwDataSize, pRecvdData, dwDataSize );
    pSlot->dwFragSize = dwDataSize;
    pSlot->dwTotalSize += dwDataSize;

    // TRC( INF, _T("Fragment received: block#=0x%x, frag#=0x%x, total=0x%x\n"), 
    //          pWave->cBlockNo, dwFragNo, pSlot->dwTotalSize );
    if ( pSlot->dwTotalSize != pSlot->dwExpectedTotalSize )
    {
        goto exitpt;
    }
    //
    // wave is ready, convert
    //
    if (!_FragSlotToWave( pSlot, pReady, dwReadySize ))
    {
        goto exitpt;
    }
    rv = TRUE;

exitpt:

    return rv;
}

BOOL
CRDPSound::ConstructFromDGramLastFrag(
    PSNDUDPWAVELAST pLast,
    DWORD       dwSize,
    PSNDWAVE    pReady,
    DWORD       dwReadySize
    )
{
    BOOL rv = FALSE;
    DWORD dwDataSize;
    PFRAGSLOT pSlot;

    if ( dwSize < sizeof( *pLast ))
    {
        TRC( ERR, _T("ConstructFromDGramLastFrag: too small packet (%d)\n"), dwSize );
    }

    if (!_FragSlotFind( &pSlot, pLast->cBlockNo, pLast->wTotalSize ))
    {
        TRC( WRN, _T("ConstructFromDGramLastFrag: Failed to find a slot for last fragment\n" ));
        goto exitpt;
    }

    pSlot->dwExpectedTotalSize = pLast->wTotalSize;
    pSlot->wTimeStamp = pLast->wTimeStamp;
    pSlot->wFormatNo = pLast->wFormatNo;
    pSlot->dwBlockNo = pLast->dwBlockNo;
    dwDataSize = dwSize - sizeof( *pLast );
    memcpy( pSlot->pData + pSlot->dwExpectedTotalSize - dwDataSize, pLast + 1, dwDataSize );

    pSlot->dwTotalSize += dwDataSize;

    // TRC( INF, _T("Fragment LAST block#=0x%x, total=0x%x\n"), 
    //          pLast->cBlockNo, pSlot->dwTotalSize );
    if ( pSlot->dwTotalSize != pSlot->dwExpectedTotalSize )
    {
        goto exitpt;
    }
    //
    // ready, set, go
    //
    if (!_FragSlotToWave( pSlot, pReady, dwReadySize ))
    {
        goto exitpt;
    }
    rv = TRUE;

exitpt:
    return rv;
}

BOOL
CRDPSound::_FragSlotFind(
    PFRAGSLOT *ppFragSlot,
    BYTE      cBlockNo,
    DWORD     dwEstimatedSize
    )
{
    BOOL rv = FALSE;
    PFRAGSLOT pIter = m_pFragSlots;
    PFRAGSLOT pLastFree = NULL;
    PFRAGSLOT pFound = NULL;
    DWORD dwNewSize;

    while( pIter )
    {
        //
        //  check if the slot hasn't been used for a while
        //
        if ( pIter->bUsed && 
            (BYTE)( m_cLastReceivedBlock - pIter->cBlockNo ) < TSSND_BLOCKSONTHENET)
        {
            TRC( WRN, _T("Old frag found id %d, last id %d\n"),
                    pIter->cBlockNo, m_cLastReceivedBlock );
            _FragSlotClear( pIter );
        }

        if ( !pIter->bUsed && NULL == pLastFree )
        {
            pLastFree = pIter;

        }
        if ( pIter->bUsed && pIter->cBlockNo == cBlockNo )
        {
            // found a block with same number   
            pFound = pIter;
            break;
        }
        pIter = pIter->pNext;
    }

    if ( NULL == pFound && NULL != pLastFree )    
    {
        //
        //  found a free block
        //
        pLastFree->bUsed = TRUE;
        pLastFree->cBlockNo = cBlockNo;
        pFound = pLastFree;
    }

    if ( NULL != pFound &&
         pFound->dwAllocatedSize < dwEstimatedSize )
    {
        dwNewSize = dwEstimatedSize * 2;

        PBYTE pNewData = (PBYTE)malloc( dwEstimatedSize * 2 );
        if ( NULL == pNewData )
        {
            //
            // we can't use this slot anymore
            //
            _FragSlotClear( pFound );
            pFound = NULL;
            goto exitpt;
        }
        memcpy( pNewData, pFound->pData, pFound->dwAllocatedSize );
        pFound->dwAllocatedSize = dwNewSize;
        free( pFound->pData );
        pFound->pData = pNewData;

    }
    if ( NULL == pFound )
    {
        // allocate a new block
        //
        pFound = (PFRAGSLOT)malloc( sizeof( *pFound ));
        if ( NULL == pFound )
        {
            goto exitpt;
        }

        dwNewSize = ( dwEstimatedSize > TSSND_BLOCKSIZE + RDPSND_SIGNATURE_SIZE )
                        ? dwEstimatedSize : TSSND_BLOCKSIZE + RDPSND_SIGNATURE_SIZE;

        pFound->pData = (PBYTE)malloc( dwNewSize );
        if ( NULL == pFound->pData )
        {
            free( pFound );
            goto exitpt;
        }

        pFound->dwAllocatedSize = dwNewSize;
        _FragSlotClear( pFound );
        pFound->bUsed = TRUE;
        pFound->cBlockNo = cBlockNo;

        //
        //   add it to the list
        //
        pFound->pNext = m_pFragSlots;
        m_pFragSlots = pFound;
    }

    *ppFragSlot = pFound;

    rv = TRUE;

exitpt:

    return rv;
}

VOID
CRDPSound::_FragSlotClear(
    PFRAGSLOT pSlot
    )
{
    DWORD dwAllocated = pSlot->dwAllocatedSize;
    PBYTE pData = pSlot->pData;
    PFRAGSLOT pNext = pSlot->pNext;

    memset( pSlot, 0, sizeof( *pSlot ));
    pSlot->dwAllocatedSize = dwAllocated;
    pSlot->pData = pData;
    pSlot->pNext = pNext;
}

VOID
CRDPSound::_FragSlotFreeAll(
    VOID
    )
{
    //
    //  free the fragment slots too
    //
    while( NULL != m_pFragSlots )
    {
        PFRAGSLOT pNext = m_pFragSlots->pNext;

        free( m_pFragSlots->pData );
        free( m_pFragSlots );

        m_pFragSlots = pNext;
    }
}

BOOL
CRDPSound::_FragSlotToWave(
    PFRAGSLOT pSlot,
    PSNDWAVE  pWave,
    DWORD     dwWaveSize
    )
{
    BOOL rv = FALSE;
    DWORD dwAvailDataSize; 
    DWORD dwBodySize;

    ASSERT( pSlot->dwExpectedTotalSize == pSlot->dwTotalSize );

    dwAvailDataSize = dwWaveSize - sizeof( *pWave );
    if ( dwAvailDataSize < pSlot->dwTotalSize )
    {
        TRC( ERR, _T("_FragSlotToWave insufficient size to move the wave")
                  _T(" need %d, available %d\n"),
                pSlot->dwTotalSize, dwAvailDataSize );
        goto exitpt;
    }

    //
    //  when we support fragments, packets are encrypted
    //
    pWave->Prolog.Type = SNDC_WAVEENCRYPT;  
    dwBodySize = pSlot->dwTotalSize + sizeof( *pWave ) -
                            sizeof( pWave->Prolog );
    ASSERT( dwBodySize < MAX_UDP_SIZE - sizeof( *pWave ));
    pWave->Prolog.BodySize = (UINT16)dwBodySize;
    pWave->wTimeStamp = pSlot->wTimeStamp;
    pWave->wFormatNo  = pSlot->wFormatNo;
    pWave->dwBlockNo  = pSlot->dwBlockNo;
    memcpy( pWave + 1, pSlot->pData, pSlot->dwTotalSize );

    //
    //  release the slot
    //
    _FragSlotClear( pSlot );

    rv = TRUE;

exitpt:
    return rv;
}

INT
WSInit(
    VOID
    )
{
    WORD    versionRequested;
    WSADATA wsaData;
    int     intRC;

    versionRequested = MAKEWORD(1, 1);

    intRC = WSAStartup(versionRequested, &wsaData);

    if (intRC != 0)
    {
        TRC(ERR, _T("Failed to initialize WinSock rc:%d\n"), intRC);
    }
    return intRC;
}

/*
 *  create signature bits
 */
VOID
CRDPSound::SL_Signature(
    PBYTE pSig,
    DWORD dwBlockNo
    )
{
    BYTE  ShaBits[A_SHA_DIGEST_LEN];
    A_SHA_CTX SHACtx;

    ASSERT( A_SHA_DIGEST_LEN > RDPSND_SIGNATURE_SIZE );

    A_SHAInit(&SHACtx);
    *((DWORD *)(m_EncryptKey + RANDOM_KEY_LENGTH)) = dwBlockNo;
    A_SHAUpdate(&SHACtx, (PBYTE)m_EncryptKey, sizeof(m_EncryptKey));    
    A_SHAFinal(&SHACtx, ShaBits);
    memcpy( pSig, ShaBits, RDPSND_SIGNATURE_SIZE );
}

/*
 *  signature which verifies the audio bits
 */
VOID
CRDPSound::SL_AudioSignature(
    PBYTE pSig,
    DWORD dwBlockNo,
    PBYTE pData,
    DWORD dwDataSize
    )
{
    BYTE ShaBits[A_SHA_DIGEST_LEN];
    A_SHA_CTX SHACtx;

    A_SHAInit(&SHACtx);
    *((DWORD *)(m_EncryptKey + RANDOM_KEY_LENGTH)) = dwBlockNo;
    A_SHAUpdate(&SHACtx, (PBYTE)m_EncryptKey, sizeof(m_EncryptKey));
    A_SHAUpdate(&SHACtx, pData, dwDataSize );
    A_SHAFinal(&SHACtx, ShaBits);
    memcpy( pSig, ShaBits, RDPSND_SIGNATURE_SIZE );
}

/*
 *  encrypt/decrypt a block of data
 *
 */
BOOL
CRDPSound::SL_Encrypt( PBYTE pBits, DWORD BlockNo, DWORD dwBitsLen )
{
    BYTE  ShaBits[A_SHA_DIGEST_LEN];
    RC4_KEYSTRUCT rc4key;
#ifndef OS_WINCE
    DWORD i;
#endif
    PBYTE pbBuffer;
    A_SHA_CTX SHACtx;
    DWORD   dw;
    DWORD_PTR   *pdwBits;

    A_SHAInit(&SHACtx);

    // SHA the static bits
    *((DWORD *)(m_EncryptKey + RANDOM_KEY_LENGTH)) = BlockNo;
    A_SHAUpdate(&SHACtx, (PBYTE)m_EncryptKey, sizeof(m_EncryptKey));

    A_SHAFinal(&SHACtx, ShaBits);

    rc4_key(&rc4key, A_SHA_DIGEST_LEN, ShaBits);
    rc4(&rc4key, dwBitsLen, pBits);

    return TRUE;
}

/*
 *  Function:
 *      _DbgPrintMessage
 *
 *  Description:
 *      A tracing function
 *
 *  Parameters:
 *      level   -   current message trace level
 *      format  -   message format
 *      ...     -   parameters
 *
 */
VOID
_cdecl
_DbgPrintMessage(LPCTSTR level, LPCTSTR format, ...)
{
    TCHAR szBuffer[256];
    va_list     arglist;

    if (ALV == level)
        return;

    va_start (arglist, format);
    StringCchVPrintf(szBuffer, SIZE_TCHARS(szBuffer), format, arglist);
    va_end (arglist);

#ifndef OS_WINCE
    OutputDebugString(level);
    OutputDebugString(szBuffer);
#endif  // !OS_WINCE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\smartptr.cpp ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name :

    smartptr.pp

Abstract:

    Smart pointers and reference counting

Revision History:
--*/

#include <precom.h>

#define TRC_FILE  "smartptr"

#include "smartptr.h"

//
//  Stack traces for all references in debug build.
//
#if DBG
DWORD RefCount::_dwReferenceTraceIndex = 0xFFFFFFFF;
ReferenceTraceRecord 
RefCount::_TraceRecordList[kReferenceTraceMask + 1];
#endif

#if DBG
void RefCount::RecordReferenceStack(LONG refs, DRSTRING ClassName)
{
    DWORD index;

    DC_BEGIN_FN("RefCount::RecordReferenceStack");
    
    //
    // The masking does the wrapping automatically, while keeping
    // the operation atomic using InterlockedIncrement
    //
    
    // Win95 InterlockedIncrement() difference.
    InterlockedIncrement((PLONG)&_dwReferenceTraceIndex);
    index = _dwReferenceTraceIndex  & kReferenceTraceMask;

    _TraceRecordList[index].ClassName = ClassName;
    _TraceRecordList[index].pRefCount = this;
    _TraceRecordList[index].refs = refs;


    RtlZeroMemory(_TraceRecordList[index].Stack, 
            sizeof(_TraceRecordList[index].Stack));

    /* TODO: Figure out which lib this is in.  
    GetStackTrace(1,
                  kdwStackSize,
                  _TraceRecordList[index].Stack,
                  &hash);
                  */

    DC_END_FN();
}
#endif // DBG

RefCount::~RefCount() 
{ 
    DC_BEGIN_FN("RefCount::~RefCount");
    ASSERT(_crefs == 0);
    TRC_DBG((TB, _T("RefCount object deleted(%d)"), _crefs)); 
    DC_END_FN()
}

void RefCount::AddRef(void) 
{ 
    LONG crefs = InterlockedIncrement(&_crefs);

    DC_BEGIN_FN("RefCount::AddRef");
    ASSERT(crefs > 0);
    RecordReferenceStack(_crefs, ClassName());
    TRC_DBG((TB, _T("AddRef object type %s to %d"), ClassName(), 
            _crefs));
    DC_END_FN();
}

void RefCount::Release(void)
{
    LONG crefs;
    DRSTRING className = ClassName();

    DC_BEGIN_FN("RefCount::Release");

    ASSERT(_crefs > 0);
    
    crefs = InterlockedDecrement(&_crefs);
    
    //
    //  It's not thread safe here, so we can't reference class name function
    //  we have to save the class name string
    //
    RecordReferenceStack(_crefs, className);

    if (crefs == 0)
    {
        TRC_DBG((TB, _T("Deleting RefCount object type %s"), 
                className));
        delete this;
    } else {
        TRC_DBG((TB, _T("Releasing object type %s to %d"), 
                className, crefs));
    }

    DC_END_FN();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\thrpool.h ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    thrpool.h

Abstract:

    Contains the Win32 Thread Pooling Class, ThreadPool

Author:

    Tad Brockway (tadb) 9/99

Revision History:

--*/

#ifndef __THRPOOL_H__
#define __THRPOOL_H__

#include "drobject.h"
#include "smartptr.h"


///////////////////////////////////////////////////////////////
//
//	Defines
//

#define INVALID_THREADPOOLREQUEST   NULL

#define THRPOOL_DEFAULTMINTHREADS   5
#define THRPOOL_DEFAULTMAXTHREADS   40


///////////////////////////////////////////////////////////////
//
//	Types
//

typedef DWORD (*ThreadPoolFunc)(PVOID clientData, HANDLE cancelEvent);
typedef DWORD (_ThreadPoolFunc)(PVOID clientData, HANDLE cancelEvent);
typedef void *ThreadPoolRequest;


///////////////////////////////////////////////////////////////
//
//	ThreadPoolRequest
//
//  A single request for the pool to service.
//
class ThreadPoolReq : public RefCount
{
public:

    ThreadPoolFunc  _func;
    PVOID           _clientData;
    HANDLE          _completionEvent;
    DWORD           _completionStatus;

    virtual DRSTRING ClassName() { return _T("ThreadPoolReq"); }
};


///////////////////////////////////////////////////////////////
//
//	ThreadPool
//
//  Thread Pooling Class
//
class ThreadPool;
class ThreadPool : public DrObject {

private:

    ULONG   _threadCount;

    BOOL    _initialized;

    //
    //  Thread list.
    //
    LIST_ENTRY  _threadListHead;

    //
    //  How long (in ms) to wait for a thread to exit before 
    //  killing.  INFINITE if we should block indefinitely.
    //
    DWORD   _threadExitTimeout;

    //
    //  Lock
    //
    CRITICAL_SECTION _cs;

#ifdef DC_DEBUG
    LONG   _lockCount;
#endif

    //
    //  Max/Min Number of Threads
    //
    ULONG   _maxThreads;
    ULONG   _minThreads;

    //
    //  Represent a single thread in the pool.
    //
    typedef struct tagTHREADPOOL_THREAD
    {
        DWORD        _tid;
        ThreadPool  *_pool;
        HANDLE       _threadHandle;
        HANDLE       _synchronizationEvent;
        BOOL         _exitFlag;

        SmartPtr<ThreadPoolReq > _pendingRequest;

        LIST_ENTRY   _listEntry;
    } THREADPOOL_THREAD, *PTHREADPOOL_THREAD;

    //
    //  Remove a thread from the pool.
    //
    VOID RemoveThreadFromPool(
        PTHREADPOOL_THREAD thread, 
        DWORD timeOut=INFINITE
        );

    //
    //  Add a new thread to the pool and return it.
    //
    PTHREADPOOL_THREAD AddNewThreadToPool();

    //
    //  Call the function associated with a pending thread request.
    //
    VOID HandlePendingRequest(PTHREADPOOL_THREAD thr);

    //
    //  Locking Functions
    //
    VOID Lock();
    VOID Unlock();

    //
    //  PooledThread Routines
    //
    static DWORD _PooledThread(PTHREADPOOL_THREAD thr);
    DWORD PooledThread(PTHREADPOOL_THREAD thr);

    //
    //  Notify a thread to shut down, wait for it to finish, and clean up.
    //
    VOID CleanUpThread(PTHREADPOOL_THREAD thread, DWORD timeout);

public:

    //
    //  Constructor/Destructor
    //
    ThreadPool(ULONG minThreads=THRPOOL_DEFAULTMINTHREADS, 
               ULONG maxThreads=THRPOOL_DEFAULTMAXTHREADS,
               DWORD threadExitTimeout=60000);
    virtual ~ThreadPool();

    VOID RemoveAllThreads();

    //
    //  Initialize an Instance of this Class.
    //
    DWORD Initialize();

    //
    //  Submit an asynchronous request to a thread in the pool.
    //
    ThreadPoolRequest SubmitRequest(
                        ThreadPoolFunc func, PVOID clientData,
                        HANDLE completionEvent = NULL
                        );

    //
    //  Return the completion status for a request.
    //
    DWORD GetRequestCompletionStatus(ThreadPoolRequest req);

    //
    //  Return a pointer to the client data for a request.
    //
    PVOID GetRequestClientData(ThreadPoolRequest req);

    //
    //  Return the current number of threads in the pool.
    //
    ULONG GetThreadCount() {
        return _threadCount;
    }

    //
    //  Close a request submitted by a call to SubmitRequest.  This 
    //  should be called after the request is finished.
    //
    VOID CloseRequest(ThreadPoolRequest req);

    //
    //  Return the class name.
    //
    virtual DRSTRING ClassName()  { return TEXT("ThreadPool"); }
};


///////////////////////////////////////////////////////////////
//
//	ThreadPool Inline Members
//
inline VOID ThreadPool::Lock()
{
    DC_BEGIN_FN("ThreadPool::Lock");
    ASSERT(_initialized);
    TRC_NRM((TB, _T("Lock count is now %ld."), _lockCount));
    EnterCriticalSection(&_cs);
#if DBG
    _lockCount++;
#endif
    DC_END_FN();
}

inline VOID ThreadPool::Unlock()
{
    DC_BEGIN_FN("ThreadPool::Unlock");
    ASSERT(_initialized);
#if DBG
    _lockCount--;
    TRC_NRM((TB, _T("Lock count is now %ld."), _lockCount));
    ASSERT(_lockCount >= 0);
#endif
    LeaveCriticalSection(&_cs);
    DC_END_FN();
}

//
//  Unit-Test Functions that Tests Thread Pools in the Background
//
#if DBG
void ThreadPoolTestInit();
void ThreadPoolTestShutdown();
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\smartptr.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name :

    smartptr.h

Abstract:

    Smart pointers and reference counting

Revision History:
--*/
#pragma once
#include "drobject.h"
#include <atrcapi.h>

const DWORD kdwStackSize = 10;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#if defined(_X86_)
    USHORT
    GetStackTrace(
        IN ULONG FramesToSkip,
        IN ULONG FramesToCapture,
        OUT PVOID *BackTrace,
        OUT PULONG BackTraceHash);
#else
    USHORT __inline GetStackTrace(
        IN ULONG FramesToSkip,
        IN ULONG FramesToCapture,
        OUT PVOID *BackTrace,
        OUT PULONG BackTraceHash)
    {
        return 0;
        UNREFERENCED_PARAMETER(FramesToSkip);
        UNREFERENCED_PARAMETER(FramesToCapture);
        UNREFERENCED_PARAMETER(BackTrace);
        UNREFERENCED_PARAMETER(BackTraceHash);
    }
#endif // _X86_
#ifdef __cplusplus
}
#endif

#if DBG
typedef struct tagReferenceTraceRecord {
    PVOID   Stack[kdwStackSize];
    class RefCount *pRefCount;
    LPTSTR ClassName;
    LONG refs;
} ReferenceTraceRecord;

const DWORD kReferenceTraceMask = 0x3FF;
#endif

///////////////////////////////////////////////////////////////
//
//	RefCount
//
//  Referenced counted objects must derive themselves from this
//  parent.
//

class RefCount : public DrObject
{
private:

    LONG _crefs;

    //
    //  Track all open references in debug builds.
    //
#if DBG
    static DWORD   _dwReferenceTraceIndex;
    static ReferenceTraceRecord _TraceRecordList[kReferenceTraceMask + 1];

    void RecordReferenceStack(LONG refs, DRSTRING className);
#else
#define RecordReferenceStack(refs, className)
#endif

public:

    //
    //  Constructor/Destructor
    //
    RefCount(void) : _crefs(0) { }
    virtual ~RefCount();

    //
    //  Reference Counting Functions
    //
    void AddRef(void);
    void Release(void);
};


///////////////////////////////////////////////////////////////
//
//	SmartPtr
//
//  Smart pointer template class.
//

template <class T> class SmartPtr {
    T* p;
public:

    SmartPtr()
    { 
        p = NULL;
    }
    SmartPtr(SmartPtr<T> &sp)
    { 
        p = sp;
        if (p != NULL) {
            p->AddRef();
        }
    }
    SmartPtr(T* p_) : p(p_) 
    { 
        if (p != NULL) {
            p->AddRef(); 
        }
    }
    ~SmartPtr(void) 
    { 
        if ( p != NULL) {
            p->Release(); 
        }
    }
    inline T* operator->(void) 
    { 
        DC_BEGIN_FN("SmartPtr::operator->");
        // No referencing needed to access a member
        ASSERT(p != NULL);
        DC_END_FN();
        return p; 
    }
    inline SmartPtr& operator=(SmartPtr<T> &p_)
    {
        // Referencing comes from using the other operator
        return operator=((T *) p_);
    }
    inline T& operator*(void) 
    {
        DC_BEGIN_FN("SmartPtr::operator*");
        // No referencing needed to derefence
        ASSERT(p != NULL);
        DC_END_FN();
        return *p; 
    }
    inline operator T*(void) 
    {
        // The assignee is responsible for doing the AddRef,
        // and in the SmartPtr case, does
        return p; 
    }
    inline int operator==(const SmartPtr<T> &p_) const
    {
        // The cast doesn't reference, so we can just do the compare
        return ((T*)p_ == p);
    }
    inline int operator==(const void *p_) const
    {
        // The cast doesn't reference, so we can just do the compare
        return ((T*)p_ == p);
    }
    inline int operator!=(const SmartPtr<T> &p_) const
    {
        // The cast doesn't reference, so we can just do the compare
        return ((T*)p_ != p);
    }
    inline int operator!=(const void *p_) const
    {
        // The cast doesn't reference, so we can just do the compare
        return ((T*)p_ != p);
    }
    inline int operator!()
    {
        return !p;
    }
    SmartPtr& operator=(T* p_) {
        if (p != NULL) {
            // Remove our reference to the old one
            p->Release(); 
        }
        p = p_; 
        if (p != NULL) {
            // Add our reference to the new one
            p->AddRef();
        }
        return *this;
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\thrpool.cpp ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    thrpool.cpp

Abstract:

    Contains the Win32 Thread Pooling Class, ThreadPool

    There may be a handle leak in this module.

Author:

    Tad Brockway (tadb) 9/99

Revision History:

--*/

#include <precom.h>

#define TRC_FILE  "thrpool"

#include "drobject.h"
#include "rdpll.h"
#include "thrpool.h"

#if DBG
#include <stdlib.h>
#endif


///////////////////////////////////////////////////////////////
//
//	ThreadPool Members
//

ThreadPool::ThreadPool(
    OPTIONAL IN ULONG minThreads,
    OPTIONAL IN ULONG maxThreads, 
    OPTIONAL IN DWORD threadExitTimeout
    )
/*++

Routine Description:

    Constructor

Arguments:

    minThreads          -   Once this number of threads has been created,
                            the number of available threads will not be 
                            reduced below this value.
    maxThreads          -   Number of simultaneous threads in the
                            pool should not exceed this value.
    threadExitTimeout   -   Number of ms to block while waiting for a 
                            thread in the pool to exit.  Should be set
                            to INFINITE if we should block indefinitely 
                            waiting on the thread to exit.

Return Value:

    NA

 --*/
{
    DC_BEGIN_FN("ThreadPool::ThreadPool");

    //
    //  Not valid until initialized.
    //
    SetValid(FALSE);
    _initialized = FALSE;

    //
    //  Sanity check params.
    //
    if (maxThreads < minThreads) {
        TRC_ERR(
            (TB, _T("Max threads value %ld smaller than min threads value %ld."), 
            maxThreads, minThreads));
        ASSERT(FALSE);
        _maxThreads = 0;
        _minThreads = 0;
    }
    else {
        _maxThreads = maxThreads;
        _minThreads = minThreads;
    }

    _threadExitTimeout = threadExitTimeout;

    //
    //  Zero the lock and thread counts.
    //
#if DBG
    _lockCount = 0;
#endif
    _threadCount = 0;

    //
    //  Initialize the thread list pointers.
    //
    InitializeListHead(&_threadListHead);

    DC_END_FN();
}

ThreadPool::~ThreadPool()
/*++

Routine Description:

    Destructor

Arguments:


Return Value:

    NA

 --*/
{

    DC_BEGIN_FN("ThreadPool::~ThreadPool");

    //
    //  Clean up the critical section.
    //
    if (_initialized) {

        //
        //  Remove all pending threads.
        //
        RemoveAllThreads();


        DeleteCriticalSection(&_cs);
    }

    DC_END_FN();
}

VOID
ThreadPool::RemoveAllThreads()
/*++

Routine Description:

    Remove all the outstanding threads

Arguments:


Return Value:

    NA

 --*/
{
    PTHREADPOOL_THREAD thr;
    PLIST_ENTRY listEntry;

    DC_BEGIN_FN("ThreadPool::RemoveAllThreads");

    //
    //  Remove all pending threads.
    //
    Lock();
    listEntry = _threadListHead.Flink;
    while (listEntry != &_threadListHead) {

        thr = CONTAINING_RECORD(listEntry, THREADPOOL_THREAD, _listEntry);
        if ((thr->_listEntry.Blink != NULL) && 
            (thr->_listEntry.Flink != NULL)) {

            RemoveEntryList(&thr->_listEntry);
            thr->_listEntry.Flink = NULL;
            thr->_listEntry.Blink = NULL;
        }
        _threadCount--;
        Unlock();

        CleanUpThread(thr, _threadExitTimeout);

        Lock();
        listEntry = _threadListHead.Flink;
    }
    Unlock();

    DC_END_FN();
}

DWORD 
ThreadPool::Initialize()
/*++

Routine Description:

    Initialize an instance of this class.
    
Arguments:   
   
Return Value:

    ERROR_SUCCEESS on success.  Otherwise, an error status is returned.

 --*/
{
    DWORD result = ERROR_SUCCESS;
    
    DC_BEGIN_FN("ThreadPool::Initialize");

    //
    //  Initialize the critical section.
    //
    __try {
        InitializeCriticalSection(&_cs);
        _initialized = TRUE;
        SetValid(TRUE);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        result = GetExceptionCode();
    }    
   
    DC_END_FN();

    return result;
}
   
ThreadPoolRequest 
ThreadPool::SubmitRequest(
    IN ThreadPoolFunc func, 
    OPTIONAL IN PVOID clientData,
    OPTIONAL IN HANDLE completionEvent
    )
/*++

Routine Description:

    Submit an asynchronous request to a thread in the pool.

Arguments:
    
    func            - Request function to execute.
    clientData      - Associated client data.
    completionEvent - Optional completion event that will
                      be signalled when the operation is complete.
    
Return Value:

    A handle to the request.  Returns INVALID_THREADPOOLREQUEST on
    error.

 --*/
{
    DC_BEGIN_FN("ThreadPool::SubmitRequest");

    PLIST_ENTRY   listEntry;
    PTHREADPOOL_THREAD thr, srchThr;
    SmartPtr<ThreadPoolReq > *ptr = NULL;

    Lock();

    //
    //  Search for an unused thread.
    //
    thr = NULL;
    listEntry = _threadListHead.Flink;
    while (listEntry != &_threadListHead) {

        srchThr = CONTAINING_RECORD(listEntry, THREADPOOL_THREAD, _listEntry);
        if (srchThr->_pendingRequest == NULL) {
            thr = srchThr;
            break;
        }
        listEntry = listEntry->Flink;

    }

    //
    //  Allocate a new thread if necessary.
    //
    if (thr == NULL) {
        thr = AddNewThreadToPool();
    }

    //
    //  If we got a thread, then allocate the request.
    //
    if (thr != NULL) {

        //
        //  Allocate the smart pointer.
        //
        ptr = new SmartPtr<ThreadPoolReq >;
        if (ptr == NULL) {
            TRC_ERR((TB, _T("Error allocating smart pointer.")));
            thr = NULL;
            goto Cleanup;
        }

        //
        //  Point to a new request.
        //
        (*ptr) = new ThreadPoolReq;
        if ((*ptr) != NULL) {
            (*ptr)->_func = func;
            (*ptr)->_clientData = clientData;
            (*ptr)->_completionEvent = completionEvent;
            (*ptr)->_completionStatus = ERROR_IO_PENDING;

            //
            //  Give the thread a reference to the request.
            //
            thr->_pendingRequest = (*ptr);            
        }
        else {
            TRC_ERR((TB, _T("Error allocating request.")));
            delete ptr;
            ptr = NULL;
            thr = NULL;
            goto Cleanup;
        }
    }
    else {
        goto Cleanup;
    }
Cleanup:

    Unlock();

    //
    //  Wake up the thread if we were successful.
    //
    if (thr != NULL) {
        SetEvent(thr->_synchronizationEvent);
    }

    DC_END_FN();

    //
    //  Return the smart pointer to the request.
    //
    return ptr;
}

DWORD
ThreadPool::GetRequestCompletionStatus(
    IN ThreadPoolRequest req
    )
/*++

Routine Description:

    Return the completion status for a request.

Arguments:

    req     -   A handle the request, as returned by ThreadPool::SubmitRequest.    

Return Value:

    Pointer to request-associated client data.

 --*/
{
    SmartPtr<ThreadPoolReq> *ptr;

    DC_BEGIN_FN("ThreadPool::GetRequestCompletionStatus");

    //
    //  Request is really a smart pointer to a request.
    //
    ptr = (SmartPtr<ThreadPoolReq> *)req;
    ASSERT((*ptr)->IsValid());
    DC_END_FN();
    return (*ptr)->_completionStatus;
}

VOID 
ThreadPool::CloseRequest(
    IN ThreadPoolRequest req
    )
/*++

Routine Description:

    Close a request submitted by a call to SubmitRequest.  This should generally
    be called after the request has finished.  Otherwise, the completion event 
    will not be signalled when the request ultimately finishes.

Arguments:

    req     -   A handle the request, as returned by ThreadPool::QueueRequest.    

Return Value:

    Pointer to request-associated client data.

 --*/
{
    SmartPtr<ThreadPoolReq> *ptr;

    DC_BEGIN_FN("ThreadPool::GetRequestClientData");

    //
    //  Request is really a smart pointer to a request.
    //
    ptr = (SmartPtr<ThreadPoolReq> *)req;
    ASSERT((*ptr)->IsValid());

    //
    //  Lock the request and zero its completion event.
    //
    Lock();
    (*ptr)->_completionEvent = NULL;
    Unlock();

    //
    //  Dereference the request.
    //
    (*ptr) = NULL;

    //
    //  Delete the smart pointer.
    //
    delete ptr;

    DC_END_FN();

}

PVOID 
ThreadPool::GetRequestClientData(
    IN ThreadPoolRequest req
    )
/*++

Routine Description:

    Return a pointer to the client data for a request.

Arguments:

    req     -   A handle the request, as returned by ThreadPool::QueueRequest.    

Return Value:

    Pointer to request-associated client data.

 --*/
{
    SmartPtr<ThreadPoolReq> *ptr;

    DC_BEGIN_FN("ThreadPool::GetRequestClientData");

    //
    //  Request is really a smart pointer to a request.
    //
    ptr = (SmartPtr<ThreadPoolReq> *)req;
    ASSERT((*ptr)->IsValid());
    DC_END_FN();
    return (*ptr)->_clientData;
}

VOID 
ThreadPool::RemoveThreadFromPool(
    PTHREADPOOL_THREAD thread, 
    DWORD timeout
    )
/*++

Routine Description:

    Remove a thread from the pool.

Arguments:

    thread  -   The thread to remove from the pool
    timeOut -   Number of MS to wait for the thread to exit before
                killing it.  This should be set to INFINITE if this
                function should block indefinitely waiting for the thread
                to exit.

Return Value:

    NA

 --*/
{

    DC_BEGIN_FN("ThreadPool::RemoveThreadFromPool");

    ASSERT(thread != NULL);

    TRC_NRM((TB, _T("Removing thread %ld from pool."), thread->_tid));

    //
    //  Make sure it's still in the list and unlink it.  If it's not in 
    //  the list, then we have been reentered with the same thread.
    //
    Lock();
    if ((thread->_listEntry.Blink != NULL) && 
        (thread->_listEntry.Flink != NULL)) {

        RemoveEntryList(&thread->_listEntry);
        thread->_listEntry.Flink = NULL;
        thread->_listEntry.Blink = NULL;
    }
    else {
        TRC_ALT((TB, _T("Thread %ld being removed 2x.  This is okay."),
            thread->_tid));
        Unlock();
        return;
    }
    _threadCount--;
    Unlock();

    //
    //  Clean it up.
    //
    CleanUpThread(thread, timeout);
}

VOID 
ThreadPool::CleanUpThread(
    PTHREADPOOL_THREAD thread, 
    DWORD timeout
    )
/*++

Routine Description:

    Notify a thread to shut down, wait for it to finish, and clean up.

Arguments:

    thread  -   The thread to remove from the pool
    timeOut -   Number of MS to wait for the thread to exit before
                killing it.  This should be set to INFINITE if this
                function should block indefinitely waiting for the thread
                to exit.

Return Value:

    NA

 --*/
{
    DWORD waitResult;

    DC_BEGIN_FN("ThreadPool::RemoveThreadFromPool");

    ASSERT(thread != NULL);

    //
    //  Set the exit flag and wait for the thread to finish.
    //
    TRC_NRM((TB, _T("Shutting down thread %ld"), thread->_tid));

    thread->_exitFlag = TRUE;
    SetEvent(thread->_synchronizationEvent);
    ASSERT(thread->_threadHandle != NULL);
    waitResult = WaitForSingleObject(thread->_threadHandle, timeout);
    if (waitResult != WAIT_OBJECT_0) {
#if DBG
        if (waitResult == WAIT_FAILED) {
            TRC_ERR((TB, _T("Wait failed for tid %ld:  %ld."), 
                GetLastError(), thread->_tid));
        }
        else if (waitResult == WAIT_ABANDONED) {
            TRC_ERR((TB, _T("Wait abandoned for tid %ld."), thread->_tid));
        }
        else if (waitResult == WAIT_TIMEOUT) {
            TRC_ERR((TB, _T("Wait timed out for tid %ld."), thread->_tid));
        }
        else {
            TRC_ERR((TB, _T("Unknown wait return status.")));
            ASSERT(FALSE);
        }
#endif
        TRC_ERR((TB, 
            _T("Error waiting for background thread %ld to exit."), 
            thread->_tid));

        //
        //  If we ever hit this, then we have a production level bug that will possibly
        //  corrupt the integrity of this process, so we will 'break' even on free 
        //  builds.
        //
        DebugBreak();
    }
    else {
        TRC_NRM((TB, _T("Background thread %ld shut down on its own."), thread->_tid));
    }

    //
    //  Finish the request if one is pending.
    //
    if (thread->_pendingRequest != NULL) {
        //
        //  Fire the request completion event.  
        //
        Lock();
        if (thread->_pendingRequest->_completionEvent != NULL) {
            SetEvent(thread->_pendingRequest->_completionEvent);
        }
        Unlock();
        thread->_pendingRequest->_completionStatus = ERROR_CANCELLED;

        //
        //  Dereference the request.
        //
        thread->_pendingRequest = NULL;
    }

    //
    //  Delete the thread object.
    //
    delete thread;

    DC_END_FN();
}

ThreadPool::PTHREADPOOL_THREAD 
ThreadPool::AddNewThreadToPool()
/*++

Routine Description:

    Add a new thread to the pool and return it.

Arguments:

    NA

Return Value:

    The new thread.  NULL if unable to create a new thread.

 --*/
{
    PTHREADPOOL_THREAD  newThread = NULL;

    DC_BEGIN_FN("ThreadPool::AddNewThreadToPool");

    Lock();

    //
    //  Make sure we haven't reached the max thread count.
    //
    if (GetThreadCount() < _maxThreads) {
        newThread = new THREADPOOL_THREAD;
        if (newThread == NULL) {
            TRC_ERR((TB, _T("Error allocating new thread.")));
        }
    }
    else {
        TRC_ERR((TB, _T("Max thread count %ld reached."), _maxThreads));
    }

    //
    //  Create the synchronization event.
    //
    if (newThread != NULL) {
        newThread->_synchronizationEvent = 
            CreateEvent(
                NULL,   // no attribute.
                FALSE,  // auto reset.
                FALSE,  // initially not signalled.
                NULL    // no name.
                );
        if (newThread->_synchronizationEvent == NULL) {
            TRC_ERR((TB, _T("Can't create event for new thread:  %08X."),
                GetLastError()));
            delete newThread;
            newThread = NULL;
        }
    }

    //
    //  Initialize remaining fields.
    //
    if (newThread != NULL) {
        newThread->_exitFlag = FALSE;
        newThread->_pendingRequest = NULL;
        newThread->_pool = this;
        memset(&newThread->_listEntry, 0, sizeof(LIST_ENTRY));
    }

    //
    //  Create the unsuspended background thread.
    //
    if (newThread != NULL) {
        newThread->_threadHandle = 
            CreateThread(
                    NULL, 0,
                    (LPTHREAD_START_ROUTINE)ThreadPool::_PooledThread,
                    newThread, 0, &newThread->_tid
                    );
        if (newThread->_threadHandle == NULL) {
            TRC_ERR((TB, _T("Can't create thread:  %08X."), GetLastError()));
            CloseHandle(newThread->_synchronizationEvent);
            delete newThread;
            newThread = NULL;
        }
        else {
            TRC_NRM((TB, _T("Successfully created thread %ld."), newThread->_tid));
        }
    }

    //
    //  If we successfully created a new thread, then add it to the list.
    //
    if (newThread != NULL) {
        InsertHeadList(&_threadListHead, &newThread->_listEntry);
        _threadCount++;
    }

    //
    //  Unlock and return.
    //
    Unlock();

    DC_END_FN();

    return newThread;
}

DWORD 
ThreadPool::_PooledThread(
    IN PTHREADPOOL_THREAD thr
    )
/*++

Routine Description:

    Static Pooled Thread Function

Arguments:

    Windows Error Code

Return Value:

    The new thread.  NULL if unable to create a new thread.

 --*/
{
    DC_BEGIN_FN("ThreadPool::_PooledThread");

    //
    //  Call the instance-specific function.
    //
    DC_END_FN();
    return thr->_pool->PooledThread(thr);
}

DWORD 
ThreadPool::PooledThread(
    IN PTHREADPOOL_THREAD thr
    )
/*++

Routine Description:

    Pooled Thread Function

Arguments:

    Windows Error Code

Return Value:

    The new thread.  NULL if unable to create a new thread.

 --*/
{
    BOOL done;
    DWORD result;
    BOOL cleanUpThread = FALSE;

    DC_BEGIN_FN("ThreadPool::PooledThread");

    done = FALSE;
    while (!done) {

        //
        //  Wait for the synchronization event to fire.
        //
        result = WaitForSingleObject(thr->_synchronizationEvent, INFINITE);

        //
        //  See if the exit flag is set.
        //
        if (thr->_exitFlag) {
            TRC_NRM((TB, _T("Thread %p: exit flag set.  Exiting thread."), thr));
            done = TRUE;
        }
        else if (result == WAIT_OBJECT_0) {
            //
            //  See if there is a request pending.
            //
            if (thr->_pendingRequest != NULL) {
                TRC_NRM((TB, _T("Thread %ld: processing new request."), thr->_tid));
                HandlePendingRequest(thr);

                //
                //  See if the exit flag is set.
                //
                if (thr->_exitFlag) {
                    TRC_NRM((TB, _T("Thread %p: exit flag set.  Exiting thread."), thr));
                    done = TRUE;
                    break;
                }

                //
                //  If we have more threads than the minimum, then remove this
                //  thread from the list and exit.
                //
                if (GetThreadCount() > _minThreads) {

                    TRC_NRM((TB, 
                            _T("Thread %ld: count %ld is greater than min threads %ld."), 
                            thr->_tid, GetThreadCount(), _minThreads)
                            );

                    Lock();
                    if ((thr->_listEntry.Blink != NULL) && 
                        (thr->_listEntry.Flink != NULL)) {

                        RemoveEntryList(&thr->_listEntry);
                        thr->_listEntry.Flink = NULL;
                        thr->_listEntry.Blink = NULL;
                    }
                    cleanUpThread = TRUE;
                    _threadCount--;
                    Unlock();
                    
                    done = TRUE;
                }

                //
                //  Reset the pending request value.    
                //
                thr->_pendingRequest = NULL;
            }
        }
        else {
            TRC_ERR((TB, _T("Thread %ld: WaitForSingleObject:  %08X."), thr->_tid,
                    GetLastError()));
            done = TRUE;
        }
    }

    TRC_NRM((TB, _T("Thread %ld is shutting down."), thr->_tid));

    //
    //  Release the data structure associated with this thread if 
    //  we should.
    //
    if (cleanUpThread) {
        delete thr;
    }

    DC_END_FN();

    return 0;
}

VOID 
ThreadPool::HandlePendingRequest(
    IN PTHREADPOOL_THREAD thr
    )
/*++

Routine Description:

    Call the function associated with a pending thread request.

Arguments:

    thr -   Relevent thread.

Return Value:

    NA

 --*/
{

    DC_BEGIN_FN("ThreadPool::PooledThread");

    thr->_pendingRequest->_completionStatus = 
        thr->_pendingRequest->_func(thr->_pendingRequest->_clientData, thr->_synchronizationEvent);
    Lock();
    if (thr->_pendingRequest->_completionEvent != NULL) {
        SetEvent(thr->_pendingRequest->_completionEvent);
    }
    Unlock();

    DC_END_FN();
}


///////////////////////////////////////////////////////////////
//
//  Unit-Test Functions that Tests Thread Pools in the Background
//

#if DBG

DWORD ThrTstBackgroundThread(PVOID tag);

#define THRTST_MAXSLEEPINTERVAL     2000
#define THRTST_MAXFUNCINTERVAL      1000
#define THRTST_THREADTIMEOUT        60000
#define THRTST_THREADRETURNVALUE    0x565656
#define THRTST_MAXTSTTHREADS        5
#define THRTST_MAXBACKGROUNDTHREADS 5

#define THRTST_MINPOOLTHREADS       3
#define THRTST_MAXPOOLTHREADS       7

#define THRTST_CLIENTDATA           0x787878

ThreadPool *ThrTstPool      = NULL;
HANDLE ThrTstShutdownEvent  = NULL;
HANDLE ThrTstThreadHandles[THRTST_MAXBACKGROUNDTHREADS];

void ThreadPoolTestInit()
{
    DWORD tid;
    ULONG i;

    DC_BEGIN_FN("ThreadPoolTestInit");

    //
    //  Create the pool.
    //
    ThrTstPool = new ThreadPool(THRTST_MINPOOLTHREADS, 
                                THRTST_MAXPOOLTHREADS);
    if (ThrTstPool == NULL) {
        TRC_ERR((TB, _T("Can't allocate thread pool")));
        return;
    }
    ThrTstPool->Initialize();

    //
    //  Create the shutdown event.
    //
    ThrTstShutdownEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (ThrTstShutdownEvent == NULL) {
        TRC_ERR((TB, _T("Can't create shutdown event:  %08X"), 
                GetLastError()));
        return;
    }

    //
    //  Spawn the background threads for this test.
    //
    for (i=0; i<THRTST_MAXBACKGROUNDTHREADS; i++) {
        ThrTstThreadHandles[i] = 
                CreateThread(
                        NULL, 0,
                        (LPTHREAD_START_ROUTINE)ThrTstBackgroundThread,
                        (PVOID)THRTST_CLIENTDATA, 0, &tid
                        );
        if (ThrTstThreadHandles[i] == NULL) {
            TRC_ERR((TB, _T("Can't spin off background thread:  %08X"), 
                    GetLastError()));
            ASSERT(FALSE);
        }
    }
    
    DC_END_FN();
}

void ThreadPoolTestShutdown()
{
    ULONG i;

    DC_BEGIN_FN("ThreadPoolTestShutdown");

    //
    //  Signal the background thread to shut down.
    //
    if (ThrTstShutdownEvent != NULL) {
        SetEvent(ThrTstShutdownEvent);
    }

    TRC_NRM((TB, _T("Waiting for background thread to exit.")));

    //
    //  Wait for the background threads to shut down.
    //
    for (i=0; i<THRTST_MAXBACKGROUNDTHREADS; i++) {
        if (ThrTstThreadHandles[i] != NULL) {

            DWORD result = WaitForSingleObject(
                                ThrTstThreadHandles[i], 
                                THRTST_THREADTIMEOUT
                                );
            if (result != WAIT_OBJECT_0) {
                DebugBreak();
            }
        }
    }
    TRC_NRM((TB, _T("Background threads exited.")));

    //
    //  Close the thread pool.
    //
    if (ThrTstPool != NULL) {
        delete ThrTstPool;
    }

    //
    //  Clean up the shut down event.
    //
    if (ThrTstShutdownEvent != NULL) {
        CloseHandle(ThrTstShutdownEvent);
    }

    ThrTstShutdownEvent = NULL;
    ThrTstPool = NULL;
    
    DC_END_FN();
}

DWORD ThrTstFunction(PVOID clientData, HANDLE cancelEvent)
{
    DC_BEGIN_FN("ThrTstFunction");

    UNREFERENCED_PARAMETER(clientData);
    UNREFERENCED_PARAMETER(cancelEvent);

    //
    //  Do "something" for a random amount of time.
    //
    int interval = (rand() % THRTST_MAXFUNCINTERVAL)+1;
    Sleep(interval);

    return THRTST_THREADRETURNVALUE;
    
    DC_END_FN();
}

DWORD ThrTstBackgroundThread(PVOID tag)
{
    ULONG count, i;
    HANDLE events[THRTST_MAXTSTTHREADS];
    ThreadPoolRequest requests[THRTST_MAXTSTTHREADS];

    DC_BEGIN_FN("ThrTstBackgroundThread");

    ASSERT(tag == (PVOID)THRTST_CLIENTDATA);

    //
    //  Create function completion events.
    //
    for (i=0; i<THRTST_MAXTSTTHREADS; i++) {
        events[i] = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (events[i] == NULL) {
            TRC_ERR((TB, _T("Error creating function complete event.")));
            ASSERT(FALSE);
            return -1;
        }
    }
    
    //
    //  Loop until the shutdown event has been fired.  
    //
    while (WaitForSingleObject(ThrTstShutdownEvent, 
        THRTST_MAXSLEEPINTERVAL) == WAIT_TIMEOUT) {
    
        //
        //  Spin a random number of requests and wait for them 
        //  to finish.
        //
        count = (rand()%THRTST_MAXTSTTHREADS)+1;
        for (i=0; i<count; i++) {

            TRC_NRM((TB, _T("Submitting next request.")));

            ResetEvent(events[i]);

            requests[i] = ThrTstPool->SubmitRequest(
                                        ThrTstFunction, 
                                        (PVOID)THRTST_CLIENTDATA, 
                                        events[i]
                                        );
        }

        //
        //  Make sure the client data looks good.
        //
        for (i=0; i<count; i++) {
            TRC_NRM((TB, _T("Checking client data.")));
            if (requests[i] != INVALID_THREADPOOLREQUEST) {
                ASSERT(
                    ThrTstPool->GetRequestClientData(
                    requests[i]) == (PVOID)THRTST_CLIENTDATA
                    );
            }
        }

        //
        //  Wait for all the requests to finish.
        //
        for (i=0; i<count; i++) {
            TRC_NRM((TB, _T("Waiting for IO to complete.")));
            if (requests[i] != INVALID_THREADPOOLREQUEST) {
                DWORD result = WaitForSingleObject(events[i], INFINITE);
                ASSERT(result == WAIT_OBJECT_0);
            }
        }

        //
        //  Make sure the return status is correct.
        //
        for (i=0; i<count; i++) {
            TRC_NRM((TB, _T("Checking return status.")));
            if (requests[i] != INVALID_THREADPOOLREQUEST) {
                ASSERT(
                    ThrTstPool->GetRequestCompletionStatus(requests[i]) 
                                == THRTST_THREADRETURNVALUE
                    );
            }
        }

        //
        //  Close the requests.
        //
        for (i=0; i<count; i++) {
            TRC_NRM((TB, _T("Closing requests.")));
            if (requests[i] != INVALID_THREADPOOLREQUEST) {
                ThrTstPool->CloseRequest(requests[i]);
            }
        }
    }
    
    TRC_NRM((TB, _T("Shutdown flag detected.")));

    DC_END_FN();

    return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\tracecom.h ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    tracecom.h

Abstract:

    This module traces serial IRP's.

    The following function needs to be linked in with this module:

    void TraceCOMProtocol(TCHAR *format, ...);

Author:

    Tad Brockway (tadb) 28-June-1999

Revision History:

--*/

#ifndef __TRACECOM_H__
#define __TRACECOM_H__

#ifdef __cplusplus
extern "C" {
#endif

//////////////////////////////////////////////////////////////////////
//
//  Tracing Macros for TS Client.
//

//
//  Trace out the specified serial irp request.
//
void TraceSerialIrpRequest(
    ULONG   deviceID,
    ULONG   majorFunction,
    ULONG   minorFunction,
    PBYTE   inputBuf,
    ULONG   outputBufferLength,
    ULONG   inputBufferLength,
    ULONG   ioControlCode                    
    );

//
//  Trace out the specified serial irp response.
//
void TraceSerialIrpResponse(
    ULONG   deviceID,
    ULONG   majorFunction,
    ULONG   minorFunction,
    PBYTE   outputBuf,
    ULONG   outputBufferLength,
    ULONG   inputBufferLength,
    ULONG   ioControlCode,                    
    ULONG   status
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\utl.cpp ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    utl.cpp

Abstract:

    Misc. Shared and Platform-Indepdent Utilities for the RDP Client 
    Device Redirector

Author:

    Tad Brockway

Revision History:

--*/

#include <precom.h>

#define TRC_FILE  "utl"

#include "utl.h"
#include "atrcapi.h"
#include "drdbg.h"

DWORD
GetUserSessionID()
{
    DC_BEGIN_FN("GetUserSessionID");

    //
    // Fetch user TS session ID
    //
    DWORD tsSessionId = INVALID_SESSIONID;
    HMODULE hKernel32 = NULL;
    PROCESSIDTOSESSIONID hGetProcAddress;
    BOOL bSuccess = FALSE;


    hKernel32 = LoadLibrary( TEXT("KERNEL32.DLL") );
    if( hKernel32 ) {
#ifndef OS_WINCE
        hGetProcAddress = (PROCESSIDTOSESSIONID)GetProcAddress( hKernel32, "ProcessIdToSessionId");
#else
        hGetProcAddress = (PROCESSIDTOSESSIONID)GetProcAddress( hKernel32, L"ProcessIdToSessionId");
#endif

        if( NULL != hGetProcAddress ) {
            bSuccess = (hGetProcAddress)( GetCurrentProcessId(), &tsSessionId );

            if (!bSuccess) {
                tsSessionId = INVALID_SESSIONID;
            }
        }
    }

    if( NULL != hKernel32 ) {
        FreeLibrary( hKernel32) ;
    }

    DC_END_FN();
    return tsSessionId;
}

NTSTATUS DrUTL_CheckIOBufInputSize(
    IN PRDPDR_IOREQUEST_PACKET pIoReq,
    IN ULONG requiredSize
    )
/*++

Routine Description:

    Confirm that the IOCTL input buffer matches the expected size.

Arguments:

    pIoReq          -   Request packet from server.
    requiredSize    -   Expected size.

Return Value:

    None

 --*/
{
    DC_BEGIN_FN("DrUTL_CheckIOBufInputSize");
    NTSTATUS status;
    if (pIoReq->IoRequest.Parameters.DeviceIoControl.InputBufferLength <
                requiredSize) {
        status = STATUS_BUFFER_TOO_SMALL;
        ASSERT(FALSE);
    }
    else {
        status = STATUS_SUCCESS;
    }
    DC_END_FN();
    return status;
}

NTSTATUS DrUTL_CheckIOBufOutputSize(
    IN PRDPDR_IOREQUEST_PACKET pIoReq,
    IN ULONG requiredSize
    )
/*++

Routine Description:

    Confirm that the IOCTL output buf matches the expected size.

Arguments:

    pIoReq          -   Request packet from server.
    requiredSize    -   Expected size.

Return Value:

    None

 --*/
{
    DC_BEGIN_FN("DrUTL_CheckIOBufOutputSize");
    NTSTATUS status;
    if (pIoReq->IoRequest.Parameters.DeviceIoControl.OutputBufferLength <
                requiredSize) {
        status = STATUS_BUFFER_TOO_SMALL;
        ASSERT(FALSE);
    }
    else {
        status = STATUS_SUCCESS;
    }
    DC_END_FN();
    return status;
}

NTSTATUS 
DrUTL_AllocateReplyBuf(
    IN PRDPDR_IOREQUEST_PACKET pIoReq, 
    OUT PRDPDR_IOCOMPLETION_PACKET *pReplyPacket,
    OUT ULONG *replyPacketSize
    )
/*++

Routine Description:

    Allocate a reply buffer to be returned in response to a server
    request.

Arguments:

    pIoReq          -   Request packet from server.
    pReplyPacket    -   Reply packet is returned here.
    replyPacketSize -   Size of reply packet is returned here.

Return Value:

    None

 --*/
{
    DC_BEGIN_FN("DrUTL_AllocateReplyBuf");
    NTSTATUS status = STATUS_SUCCESS;
    
    *replyPacketSize = (ULONG)FIELD_OFFSET(
                            RDPDR_IOCOMPLETION_PACKET, 
                            IoCompletion.Parameters.DeviceIoControl.OutputBuffer) +
                            pIoReq->IoRequest.Parameters.DeviceIoControl.OutputBufferLength;
    *pReplyPacket = DrUTL_AllocIOCompletePacket(pIoReq, *replyPacketSize) ;
    if (*pReplyPacket == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
            TRC_ERR((TB, _T("Failed to alloc %ld bytes."),*replyPacketSize));
    }
    else {
        status = STATUS_SUCCESS;
    }
    DC_END_FN();
    return status;
}


PRDPDR_IOCOMPLETION_PACKET 
DrUTL_AllocIOCompletePacket(
    IN const PRDPDR_IOREQUEST_PACKET pIoRequestPacket, 
    IN ULONG sz
    ) 
/*++

Routine Description:

    Allocate/release a IO request completion packet for a specified IO
    request packet.

Arguments:

    pIoRequestPacket    -   IO request from server.

Return Value:

    None

 --*/
{
    PRDPDR_IOCOMPLETION_PACKET ppIoComp;
    PRDPDR_DEVICE_IOREQUEST pIoRequest;

    DC_BEGIN_FN("DrUTL_AllocIOCompletePacket");

    //
    //  Get IO request pointer.
    //
    pIoRequest = &pIoRequestPacket->IoRequest;

    ppIoComp = (PRDPDR_IOCOMPLETION_PACKET)new BYTE[ sz ];
    if( ppIoComp != NULL ) {
        memset(ppIoComp, 0, (size_t)sz);
        ppIoComp->IoCompletion.DeviceId = pIoRequest->DeviceId;
        ppIoComp->IoCompletion.CompletionId = pIoRequest->CompletionId;
        ppIoComp->Header.Component = RDPDR_CTYP_CORE;
        ppIoComp->Header.PacketId = DR_CORE_DEVICE_IOCOMPLETION;
    }
    else {
        TRC_ERR((TB, _T("Alloc failed.")));
    }

    DC_END_FN();
    return ppIoComp;
}

VOID DrUTL_FreeIOCompletePacket(
    IN PRDPDR_IOCOMPLETION_PACKET packet
    ) 
/*++

Routine Description:

    Free an IO complete packet allocated by DrUTL_AllocIOCompletePacket.
Arguments:

    packet  - Packet to free.

Return Value:

    None

 --*/
{
    DC_BEGIN_FN("DrUTL_FreeIOCompletePacket");

    delete []((BYTE *)packet);

    DC_END_FN();
}

#ifdef OS_WINCE
ULONG GetActivePortsList(TCHAR *pszPort)
{
    DC_BEGIN_FN("GetActivePortsList");

    ULONG ulPorts = 0;
    TCHAR szActive[] = _T("Drivers\\Active");
    HKEY hkActive = NULL;

    int nPortLen = _tcslen(pszPort);

    if ((ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szActive, 0, 0, &hkActive)) && (hkActive != NULL))
    {
        TCHAR szName[64];
        DWORD dwCount = sizeof(szName)/sizeof(TCHAR);
        DWORD dwIndex = 0;
        while ((ERROR_SUCCESS == RegEnumKeyEx(hkActive, dwIndex++, szName, &dwCount, NULL, NULL, NULL, NULL)) && 
               (dwCount < (sizeof(szName)/sizeof(TCHAR)) ))
        {
            HKEY hk = NULL;
            TCHAR szValue[MAX_PATH];
            DWORD dwType = 0;
            DWORD dwSize = sizeof(szValue);
            
            if ((ERROR_SUCCESS == RegOpenKeyEx(hkActive, szName, 0, 0, &hk)) && 
                (hk != NULL) && 
                (ERROR_SUCCESS == RegQueryValueEx(hk, _T("Name"), NULL, &dwType, (LPBYTE )szValue, &dwSize)) && 
                (dwType == REG_SZ) && (dwSize < sizeof(szValue)) && (0 == _tcsncmp(pszPort, szValue, nPortLen)) && 
                (_tcslen(szValue) == 5) && (szValue[4] == _T(':')) && ((szValue[3] - _T('0')) < 10) )
            {
                int nPortNum = szValue[3] - _T('0');
                TRC_ASSERT( ((ulPorts & (1 << nPortNum)) == 0), (TB, _T("Duplicate port found!")));
                ulPorts |= (1 << nPortNum);
            }

            if (hk)
                RegCloseKey(hk);

            dwCount = sizeof(szName)/sizeof(TCHAR);
        }
        RegCloseKey(hkActive);
    }
    
    DC_END_FN();
    return ulPorts;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\tracecom.cpp ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    tracecom

Abstract:

    This module traces serial IRP's.

Author:

    Tad Brockway 7/14/99

Revision History:

--*/

#include <precom.h>
#include "tracecom.h"

#define TRC_FILE  "TraceCOM"

//
//  Disable unreferenced formal parameter warning because we have 
//  lots of these for this module.  And, that's okay.
//
#pragma warning (disable: 4100)

//
//  This tracing function must be linkable.
//

extern void TraceCOMProtocol(TCHAR *format, ...);


//////////////////////////////////////////////////////////////////////
//
//  Internal Prototypes
//

//  Trace out the specified serial IOCTL request.
void TraceSerialIOCTLRequest(
    ULONG deviceID, ULONG majorFunction,
    ULONG minorFunction, PBYTE inputBuf,
    ULONG outputBufferLength,
    ULONG inputBufferLength, ULONG ioControlCode                    
    );

//  Trace out the specified serial IOCTL response.
void TraceSerialIOCTLResponse(
    ULONG deviceID, ULONG majorFunction,
    ULONG minorFunction, PBYTE outputBuf, 
    ULONG outputBufferLength,
    ULONG inputBufferLength, ULONG ioControlCode,
    ULONG status
    );

//  Trace out a Set Handflow request.
void TraceSetHandflowRequest(
    ULONG   deviceID,
    ULONG   majorFunction,
    ULONG   minorFunction,
    PBYTE   inputBuf,
    ULONG   outputBufferLength,
    ULONG   inputBufferLength,
    ULONG   ioControlCode                    
    );

//  Trace out a Set Wait Mask request.
void TraceSetWaitMaskRequest(
    ULONG   deviceID,
    ULONG   majorFunction,
    ULONG   minorFunction,
    PBYTE   inputBuf,
    ULONG   outputBufferLength,
    ULONG   inputBufferLength,
    ULONG   ioControlCode                    
    );

//  Trace out a Set Timeouts request.
void TraceSetTimeoutsRequest(
    ULONG   deviceID,
    ULONG   majorFunction,
    ULONG   minorFunction,
    PBYTE   inputBuf,
    ULONG   outputBufferLength,
    ULONG   inputBufferLength,
    ULONG   ioControlCode                    
    );

//  Trace out a Set Chars request.
void TraceSetCharsRequest(
    ULONG   deviceID,
    ULONG   majorFunction,
    ULONG   minorFunction,
    PBYTE   inputBuf,
    ULONG   outputBufferLength,
    ULONG   inputBufferLength,
    ULONG   ioControlCode                    
    );

//  Trace out a Get Timeouts response.
void TraceGetTimeoutsResponse(
    ULONG   deviceID,
    ULONG   majorFunction,
    ULONG   minorFunction,
    PBYTE   outputBuf,
    ULONG   outputBufferLength,
    ULONG   inputBufferLength,
    ULONG   ioControlCode,
    ULONG   status
    );

//  Trace out a Get Chars request.
void TraceGetCharsRequest(
    ULONG   deviceID,
    ULONG   majorFunction,
    ULONG   minorFunction,
    PBYTE   outputBuf,
    ULONG   outputBufferLength,
    ULONG   inputBufferLength,
    ULONG   ioControlCode,
    ULONG   status
    );

//  Trace out a Get Wait Mask response.
void TraceGetWaitMaskResponse(
    ULONG   deviceID,
    ULONG   majorFunction,
    ULONG   minorFunction,
    PBYTE   outputBuf,
    ULONG   outputBufferLength,
    ULONG   inputBufferLength,
    ULONG   ioControlCode,
    ULONG   status
    );

//  Trace out a Set Handflow response.
void TraceGetHandflowResponse(
    ULONG   deviceID,
    ULONG   majorFunction,
    ULONG   minorFunction,
    PBYTE   outputBuf,
    ULONG   outputBufferLength,
    ULONG   inputBufferLength,
    ULONG   ioControlCode,
    ULONG   status
    );

//  Trace out a Get Communication Status response.
void TraceGetCommStatusResponse(
    ULONG   deviceID,
    ULONG   majorFunction,
    ULONG   minorFunction,
    PBYTE   outputBuf,
    ULONG   outputBufferLength,
    ULONG   inputBufferLength,
    ULONG   ioControlCode,
    ULONG   status
    );

//  Trace out a Get Properties response.
void TraceGetProperties(
    ULONG   deviceID,
    ULONG   majorFunction,
    ULONG   minorFunction,
    PBYTE   outputBuf,
    ULONG   outputBufferLength,
    ULONG   inputBufferLength,
    ULONG   ioControlCode,
    ULONG   status
    );

void TraceSerialIrpRequest(
    ULONG   deviceID,
    ULONG   majorFunction,
    ULONG   minorFunction,
    PBYTE   inputBuf,
    ULONG   outputBufferLength,
    ULONG   inputBufferLength,
    ULONG   ioControlCode                    
    )
/*++

Routine Description:

    Trace out the specified serial irp request.

Arguments:

    deviceID            -   Device Identifer.  0 is okay.
    majorFunction       -   IRP Major
    minorFunction       -   IRP Minor
    inputBuf            -   Input Buffer, if Applicable.
    outputBufferLength  -   IRP Output buffer if relevant
    inputBufferLength   -   IRP Input buffer length.
    ioControlCode       -   IOCTL control code if IRP is for an IOCTL.                 

Return Value:

    NA

 --*/
{
    //
    //  Switch on the IRP Type.
    //
    switch (majorFunction) {

    case IRP_MJ_CREATE:

        TraceCOMProtocol(_T("->@@Device  %ld:\tIRP_MJ_CREATE"), deviceID);
        return;

    case IRP_MJ_CLOSE:

        TraceCOMProtocol(_T("->@@Device  %ld:\tIRP_MJ_CLOSE"), deviceID);
        return;

    case IRP_MJ_CLEANUP:

        TraceCOMProtocol(_T("->@@Device  %ld:\tIRP_MJ_CLEANUP"), deviceID);
        return;

    case IRP_MJ_READ:

        TraceCOMProtocol(_T("->@@Device  %ld:\tIRP_MJ_READ"), deviceID);
        return;

    case IRP_MJ_WRITE:

        TraceCOMProtocol(_T("->@@Device  %ld:\tIRP_MJ_WRITE"), deviceID);
        return;

    case IRP_MJ_DEVICE_CONTROL:

        TraceSerialIOCTLRequest(
                    deviceID, majorFunction, minorFunction, inputBuf,
                    outputBufferLength, inputBufferLength,
                    ioControlCode
                    );
        return;

    default:
        TraceCOMProtocol(_T("->@@Device  %ld\tUnrecognized IRP"), deviceID);
    }
}

void TraceSerialIOCTLRequest(
    ULONG   deviceID,
    ULONG   majorFunction,
    ULONG   minorFunction,
    PBYTE   inputBuf,
    ULONG   outputBufferLength,
    ULONG   inputBufferLength,
    ULONG   ioControlCode                    
    )
/*++

Routine Description:

    Trace out the specified serial IOCTL request.

Arguments:

    deviceID            -   Device Identifer.  0 is okay.
    majorFunction       -   IRP Major
    minorFunction       -   IRP Minor
    inputBuf            -   Input Buffer, if Applicable.
    outputBufferLength  -   IRP Output buffer if relevant
    inputBufferLength   -   IRP Input buffer length.
    ioControlCode       -   IOCTL control code if IRP is for an IOCTL.                 

Return Value:

    NA

 --*/
{
    PSERIAL_LINE_CONTROL lineControl;
    PSERIAL_QUEUE_SIZE serialQueueSize;
    UCHAR *immediateChar;

    //
    //  Switch on the IRP Type.
    //
    switch (ioControlCode) 
    {
    case IOCTL_SERIAL_SET_BAUD_RATE :

        TraceCOMProtocol(_T("->@@Device  %ld:\tIOCTL_SERIAL_SET_BAUD_RATE:  %ld baud"), 
            deviceID, ((PSERIAL_BAUD_RATE)inputBuf)->BaudRate);
        break;

    case IOCTL_SERIAL_GET_BAUD_RATE :
        TraceCOMProtocol(_T("->@@Device  %ld:\tIOCTL_SERIAL_GET_BAUD_RATE"), deviceID);
        break;

    case IOCTL_SERIAL_SET_LINE_CONTROL :
        lineControl = (PSERIAL_LINE_CONTROL)inputBuf;
        TraceCOMProtocol(_T("->@@Device  %ld:\tIOCTL_SERIAL_SET_LINE_CONTROL ..."), deviceID);
        TraceCOMProtocol(_T("->@@Device  %ld:\t\tstop bits:%ld"), 
                    deviceID, lineControl->StopBits);
        TraceCOMProtocol(_T("->@@Device  %ld:\t\tparity: %ld"), 
                    deviceID, lineControl->Parity);
        TraceCOMProtocol(_T("->@@Device  %ld:\t\tword len: %ld"), 
                    deviceID, lineControl->WordLength);
        break;

    case IOCTL_SERIAL_GET_LINE_CONTROL :
        TraceCOMProtocol(_T("->@@Device  %ld:\tIOCTL_SERIAL_GET_LINE_CONTROL"), deviceID);
        break;

    case IOCTL_SERIAL_SET_TIMEOUTS :
        TraceSetTimeoutsRequest(
                    deviceID, majorFunction, minorFunction,
                    inputBuf, outputBufferLength, inputBufferLength,
                    ioControlCode
                    );
        break;

    case IOCTL_SERIAL_GET_TIMEOUTS :
        TraceCOMProtocol(_T("->@@Device  %ld:\tIOCTL_SERIAL_GET_TIMEOUTS"), deviceID);
        break;

    case IOCTL_SERIAL_SET_CHARS :
        TraceSetCharsRequest(deviceID, majorFunction, minorFunction, inputBuf,
                            outputBufferLength, inputBufferLength, ioControlCode); 
        break;

    case IOCTL_SERIAL_GET_CHARS :
        TraceCOMProtocol(_T("->@@Device  %ld:\tIOCTL_SERIAL_GET_CHARS"), deviceID);
        break;

    case IOCTL_SERIAL_SET_DTR :
        TraceCOMProtocol(_T("->@@Device  %ld:\tIOCTL_SERIAL_SET_DTR"), deviceID);
        break;

    case IOCTL_SERIAL_CLR_DTR :
        TraceCOMProtocol(_T("->@@Device  %ld:\tIOCTL_SERIAL_CLR_DTR"), deviceID);
        break;

    case IOCTL_SERIAL_RESET_DEVICE :
        TraceCOMProtocol(_T("->@@Device  %ld:\tIOCTL_SERIAL_RESET_DEVICE"), deviceID);
        break;

    case IOCTL_SERIAL_SET_RTS :
        TraceCOMProtocol(_T("->@@Device  %ld:\tIOCTL_SERIAL_SET_RTS"), deviceID);
        break;

    case IOCTL_SERIAL_CLR_RTS :
        TraceCOMProtocol(_T("->@@Device  %ld:\tIOCTL_SERIAL_CLR_RTS"), deviceID);
        break;

    case IOCTL_SERIAL_SET_XOFF :
        TraceCOMProtocol(_T("->@@Device  %ld:\tIOCTL_SERIAL_SET_XOFF"), deviceID);
        break;

    case IOCTL_SERIAL_SET_XON :
        TraceCOMProtocol(_T("->@@Device  %ld:\tIOCTL_SERIAL_SET_XON"), deviceID);
        break;

    case IOCTL_SERIAL_SET_BREAK_ON :
        TraceCOMProtocol(_T("->@@Device  %ld:\tIOCTL_SERIAL_SET_BREAK_ON"), deviceID);
        break;

    case IOCTL_SERIAL_SET_BREAK_OFF :
        TraceCOMProtocol(_T("->@@Device  %ld:\tIOCTL_SERIAL_SET_BREAK_OFF"), deviceID);
        break;

    case IOCTL_SERIAL_SET_QUEUE_SIZE :
        serialQueueSize = (PSERIAL_QUEUE_SIZE)inputBuf;
        TraceCOMProtocol(_T("->@@Device  %ld:\tIOCTL_SERIAL_SET_QUEUE_SIZE ..."), deviceID);
        TraceCOMProtocol(_T("->@@Device  %ld:\t\tInSize:%ld"), 
                        deviceID, serialQueueSize->InSize);
        TraceCOMProtocol(_T("->@@Device  %ld:\t\tOutSize:%ld"), 
                deviceID, serialQueueSize->OutSize);
        break;

    case IOCTL_SERIAL_GET_WAIT_MASK :
        TraceCOMProtocol(_T("->@@Device  %ld:\tIOCTL_SERIAL_GET_WAIT_MASK"), deviceID);
        break;

    case IOCTL_SERIAL_SET_WAIT_MASK :
        TraceSetWaitMaskRequest(deviceID, majorFunction, minorFunction,
                            inputBuf, outputBufferLength, inputBufferLength,
                            ioControlCode);
        break;

    case IOCTL_SERIAL_WAIT_ON_MASK :
        TraceCOMProtocol(_T("->@@Device  %ld:\tIOCTL_SERIAL_WAIT_ON_MASK"), deviceID);
        break;

    case IOCTL_SERIAL_IMMEDIATE_CHAR :
        immediateChar = (UCHAR *)inputBuf;
        TraceCOMProtocol(_T("->@@Device  %ld:\tIOCTL_SERIAL_IMMEDIATE_CHAR:  %ld"), 
                    deviceID, *immediateChar);
        break;

    case IOCTL_SERIAL_PURGE :
        TraceCOMProtocol(_T("->@@Device  %ld:\tIOCTL_SERIAL_PURGE"), deviceID);
        break;

    case IOCTL_SERIAL_GET_HANDFLOW :
        TraceCOMProtocol(_T("->@@Device  %ld:\tIOCTL_SERIAL_GET_HANDFLOW"), deviceID);
        break;

    case IOCTL_SERIAL_SET_HANDFLOW :
        TraceSetHandflowRequest(
                    deviceID, majorFunction, minorFunction,
                    inputBuf, outputBufferLength, inputBufferLength,
                    ioControlCode                    
                    );
        break;

    case IOCTL_SERIAL_GET_MODEMSTATUS :
        TraceCOMProtocol(_T("->@@Device  %ld:\tIOCTL_SERIAL_GET_MODEMSTATUS"), deviceID);
        break;

    case IOCTL_SERIAL_GET_DTRRTS :
        TraceCOMProtocol(_T("->@@Device  %ld:\tIOCTL_SERIAL_GET_DTRRTS"), deviceID);
        break;

    case IOCTL_SERIAL_GET_COMMSTATUS :
        TraceCOMProtocol(_T("->@@Device  %ld:\tIOCTL_SERIAL_GET_COMMSTATUS"), deviceID);
        break;

    case IOCTL_SERIAL_GET_PROPERTIES :
        TraceCOMProtocol(_T("->@@Device  %ld:\tIOCTL_SERIAL_GET_PROPERTIES"), deviceID);
        break;

    case IOCTL_SERIAL_XOFF_COUNTER :
        TraceCOMProtocol(_T("->@@Device  %ld:\tIOCTL_SERIAL_XOFF_COUNTER"), deviceID);
        break;

    case IOCTL_SERIAL_LSRMST_INSERT :
        TraceCOMProtocol(_T("->@@Device  %ld:\tIOCTL_SERIAL_LSRMST_INSERT"), deviceID);
        break;

    case IOCTL_SERIAL_CONFIG_SIZE :
        TraceCOMProtocol(_T("->@@Device  %ld:\tIOCTL_SERIAL_CONFIG_SIZE"), deviceID);
        break;

    case IOCTL_SERIAL_GET_STATS :
        TraceCOMProtocol(_T("->@@Device  %ld:\tIOCTL_SERIAL_GET_STATS"), deviceID);
        break;

    case IOCTL_SERIAL_CLEAR_STATS :
        TraceCOMProtocol(_T("->@@Device  %ld:\tIOCTL_SERIAL_CLEAR_STATS"), deviceID);
        break;

    default:
        TraceCOMProtocol(_T("->@@Device  %ld:\tUnrecognized IOCTL %08X"), 
                    deviceID, ioControlCode);
    }
}

void TraceSerialIrpResponse(
    ULONG   deviceID,
    ULONG   majorFunction,
    ULONG   minorFunction,
    PBYTE   outputBuf,
    ULONG   outputBufferLength,
    ULONG   inputBufferLength,
    ULONG   ioControlCode                    ,
    ULONG   status
    )
/*++

Routine Description:

    Trace out the specified serial irp response.

Arguments:

    deviceID            -   Device Identifer.  0 is okay.
    majorFunction       -   IRP Major
    minorFunction       -   IRP Minor
    outputBuf           -   Output buffer, if applicable
    outputBufferLength  -   IRP Output buffer length.
    inputBufferLength   -   IRP Input buffer length.
    ioControlCode       -   IOCTL control code if IRP is for an IOCTL.                 
    status              -   Status of function call.

Return Value:

    NA

 --*/
{
    //
    //  Switch on the IRP Type.
    //
    switch (majorFunction) {

    case IRP_MJ_CREATE:

        TraceCOMProtocol(_T("<-@@Device  %ld:\tIRP_MJ_CREATE"), deviceID);
        return;

    case IRP_MJ_CLOSE:

        TraceCOMProtocol(_T("<-@@Device  %ld:\tIRP_MJ_CLOSE"), deviceID);
        return;

    case IRP_MJ_CLEANUP:

        TraceCOMProtocol(_T("<-@@Device  %ld:\tIRP_MJ_CLEANUP"), deviceID);
        return;

    case IRP_MJ_READ:

        TraceCOMProtocol(_T("<-@@Device  %ld:\tIRP_MJ_READ"), deviceID);
        return;

    case IRP_MJ_WRITE:

        TraceCOMProtocol(_T("<-@@Device  %ld:\tIRP_MJ_WRITE"), deviceID);
        return;

    case IRP_MJ_DEVICE_CONTROL:

        TraceSerialIOCTLResponse(
                    deviceID, majorFunction, minorFunction,
                    outputBuf, outputBufferLength, inputBufferLength,
                    ioControlCode, status
                    );
        return;

    default:
        TraceCOMProtocol(_T("<-@@Device  %ld:\tUnrecognized IRP"), deviceID);
    }
}

void TraceSerialIOCTLResponse(
    ULONG   deviceID,
    ULONG   majorFunction,
    ULONG   minorFunction,
    PBYTE   outputBuf,
    ULONG   outputBufferLength,
    ULONG   inputBufferLength,
    ULONG   ioControlCode,
    ULONG   status
    )
/*++

Routine Description:

    Trace out the specified serial IOCTL request.

Arguments:

    deviceID            -   Device Identifer.  0 is okay.
    majorFunction       -   IRP Major
    minorFunction       -   IRP Minor
    outputBuf           -   Output buffer, if applicable
    outputBufferLength  -   IRP Output buffer length.
    inputBufferLength   -   IRP Input buffer length.
    ioControlCode       -   IOCTL control code if IRP is for an IOCTL.                 
    status              -   Return status from operation.

Return Value:

    NA

 --*/
{
    PSERIAL_LINE_CONTROL lineControl;
    ULONG *modemStatus;
    ULONG *configSize;
    //
    //  Switch on the IRP Type.
    //
    switch (ioControlCode) 
    {
    case IOCTL_SERIAL_SET_BAUD_RATE :
        TraceCOMProtocol(_T("<-@@Device  %ld:\tIOCTL_SERIAL_SET_BAUD_RATE ret %08X"), 
                      deviceID, status);
        break;

    case IOCTL_SERIAL_GET_BAUD_RATE :
        TraceCOMProtocol(_T("<-@@Device  %ld:\tIOCTL_SERIAL_GET_BAUD_RATE ret %08X ..."), 
                      deviceID, status);
        TraceCOMProtocol(_T("<-@@Device  %ld:\t\tBaud Rate:%ld"), 
                        deviceID, ((PSERIAL_BAUD_RATE)outputBuf)->BaudRate);
        break;

    case IOCTL_SERIAL_SET_LINE_CONTROL :
        TraceCOMProtocol(_T("<-@@Device  %ld:\tIOCTL_SERIAL_SET_LINE_CONTROL ret %08X"), 
                      deviceID, status);
        break;

    case IOCTL_SERIAL_GET_LINE_CONTROL :
        lineControl = (PSERIAL_LINE_CONTROL)outputBuf;
        TraceCOMProtocol(_T("<-@@Device  %ld:\tIOCTL_SERIAL_GET_LINE_CONTROL ret %08X ..."), 
                      deviceID, status);
        TraceCOMProtocol(_T("<-@@Device  %ld:\t\tstop bits:%ld"), 
                    deviceID, lineControl->StopBits);
        TraceCOMProtocol(_T("<-@@Device  %ld:\t\tparity: %ld"), 
                    deviceID, lineControl->Parity);
        TraceCOMProtocol(_T("<-@@Device  %ld:\t\tword len: %ld"), 
                    deviceID, lineControl->WordLength);
        break;

    case IOCTL_SERIAL_SET_TIMEOUTS :
        TraceCOMProtocol(_T("<-@@Device  %ld:\tIOCTL_SERIAL_SET_TIMEOUTS ret %08X"), 
                      deviceID, status);
        break;

    case IOCTL_SERIAL_GET_TIMEOUTS :
        TraceGetTimeoutsResponse(deviceID, majorFunction, minorFunction,
                                outputBuf, outputBufferLength, inputBufferLength,
                                ioControlCode, status);
        break;

    case IOCTL_SERIAL_SET_CHARS :
        TraceCOMProtocol(_T("<-@@Device  %ld:\tIOCTL_SERIAL_SET_CHARS ret %08X"), 
                      deviceID, status);
        break;

    case IOCTL_SERIAL_GET_CHARS :
        TraceCOMProtocol(_T("<-@@Device  %ld:\tIOCTL_SERIAL_GET_CHARS ret %08X"), 
                      deviceID, status);
        break;

    case IOCTL_SERIAL_SET_DTR :
        TraceCOMProtocol(_T("<-@@Device  %ld:\tIOCTL_SERIAL_SET_DTR ret %08X"), 
                      deviceID, status);
        break;

    case IOCTL_SERIAL_CLR_DTR :
        TraceCOMProtocol(_T("<-@@Device  %ld:\tIOCTL_SERIAL_CLR_DTR ret %08X"), 
                      deviceID, status);
        break;

    case IOCTL_SERIAL_RESET_DEVICE :
        TraceCOMProtocol(_T("<-@@Device  %ld:\tIOCTL_SERIAL_RESET_DEVICE ret %08X"), 
                      deviceID, status);
        break;

    case IOCTL_SERIAL_SET_RTS :
        TraceCOMProtocol(_T("<-@@Device  %ld:\tIOCTL_SERIAL_SET_RTS ret %08X"), 
                      deviceID, status);
        break;

    case IOCTL_SERIAL_CLR_RTS :
        TraceCOMProtocol(_T("<-@@Device  %ld:\tIOCTL_SERIAL_CLR_RTS ret %08X"), 
                      deviceID, status);
        break;

    case IOCTL_SERIAL_SET_XOFF :
        TraceCOMProtocol(_T("<-@@Device  %ld:\tIOCTL_SERIAL_SET_XOFF ret %08X"), 
                      deviceID, status);
        break;

    case IOCTL_SERIAL_SET_XON :
        TraceCOMProtocol(_T("<-@@Device  %ld:\tIOCTL_SERIAL_SET_XON ret %08X"), 
                      deviceID, status);
        break;

    case IOCTL_SERIAL_SET_BREAK_ON :
        TraceCOMProtocol(_T("<-@@Device  %ld:\tIOCTL_SERIAL_SET_BREAK_ON ret %08X"), 
                      deviceID, status);
        break;

    case IOCTL_SERIAL_SET_BREAK_OFF :
        TraceCOMProtocol(_T("<-@@Device  %ld:\tIOCTL_SERIAL_SET_BREAK_OFF ret %08X"), 
                      deviceID, status);
        break;

    case IOCTL_SERIAL_SET_QUEUE_SIZE :
        TraceCOMProtocol(_T("<-@@Device  %ld:\tIOCTL_SERIAL_SET_QUEUE_SIZE ret %08X"), 
                      deviceID, status);
        break;

    case IOCTL_SERIAL_GET_WAIT_MASK :
        TraceGetWaitMaskResponse(deviceID, majorFunction, minorFunction,
                            outputBuf, outputBufferLength, inputBufferLength,
                            ioControlCode, status);
        break;

    case IOCTL_SERIAL_SET_WAIT_MASK :
        TraceCOMProtocol(_T("<-@@Device  %ld:\tIOCTL_SERIAL_SET_WAIT_MASK ret %08X"), 
                      deviceID, status);
        break;

    case IOCTL_SERIAL_WAIT_ON_MASK :
        TraceCOMProtocol(_T("<-@@Device  %ld:\tIOCTL_SERIAL_WAIT_ON_MASK ret %08X"), 
                      deviceID, status);
        break;

    case IOCTL_SERIAL_IMMEDIATE_CHAR :
        TraceCOMProtocol(_T("<-@@Device  %ld:\tIOCTL_SERIAL_IMMEDIATE_CHAR ret %08X"), 
                      deviceID, status);
        break;

    case IOCTL_SERIAL_PURGE :
        TraceCOMProtocol(_T("<-@@Device  %ld:\tIOCTL_SERIAL_PURGE ret %08X"), 
                      deviceID, status);
        break;

    case IOCTL_SERIAL_GET_HANDFLOW :
        TraceGetHandflowResponse(deviceID, majorFunction, minorFunction,
                                outputBuf, outputBufferLength, inputBufferLength,
                                ioControlCode, status);
        break;

    case IOCTL_SERIAL_SET_HANDFLOW :
        TraceCOMProtocol(_T("<-@@Device  %ld:\tIOCTL_SERIAL_SET_HANDFLOW ret %08X"), 
                      deviceID, status);
        break;

    case IOCTL_SERIAL_GET_MODEMSTATUS :
        modemStatus = (ULONG *)outputBuf;
        TraceCOMProtocol(_T("<-@@Device  %ld:\tIOCTL_SERIAL_GET_MODEMSTATUS ret %08X ..."), 
                      deviceID, status);
        TraceCOMProtocol(_T("<-@@Device  %ld:\t\tmodem status:%08X"), 
                      deviceID, *modemStatus);

    case IOCTL_SERIAL_GET_DTRRTS :
        TraceCOMProtocol(_T("<-@@Device  %ld:\tIOCTL_SERIAL_GET_DTRRTS ret %08X"), 
                      deviceID, status);
        break;

    case IOCTL_SERIAL_GET_COMMSTATUS :
        TraceGetCommStatusResponse(deviceID, majorFunction, minorFunction,
                                outputBuf, outputBufferLength, inputBufferLength,
                                ioControlCode, status);
        break;

    case IOCTL_SERIAL_GET_PROPERTIES :
        TraceGetProperties(deviceID, majorFunction, minorFunction,
                        outputBuf, outputBufferLength, inputBufferLength,
                        ioControlCode, status);
        break;

    case IOCTL_SERIAL_XOFF_COUNTER :
        TraceCOMProtocol(_T("<-@@Device  %ld:\tIOCTL_SERIAL_XOFF_COUNTER ret %08X"), 
                      deviceID, status);
        break;

    case IOCTL_SERIAL_LSRMST_INSERT :
        TraceCOMProtocol(_T("<-@@Device  %ld:\tIOCTL_SERIAL_LSRMST_INSERT ret %08X"), 
                      deviceID, status);
        break;

    case IOCTL_SERIAL_CONFIG_SIZE :
        TraceCOMProtocol(_T("<-@@Device  %ld:\tIOCTL_SERIAL_CONFIG_SIZE ret %08X ..."), 
                      deviceID, status);
        configSize = (ULONG *)outputBuf;
        TraceCOMProtocol(_T("<-@@Device  %ld:\t\tConfig size: %ld"), deviceID, configSize);
        break;

    case IOCTL_SERIAL_GET_STATS :
        TraceCOMProtocol(_T("<-@@Device  %ld:\tIOCTL_SERIAL_GET_STATS ret %08X"), 
                      deviceID, status);
        break;

    case IOCTL_SERIAL_CLEAR_STATS :
        TraceCOMProtocol(_T("<-@@Device  %ld:\tIOCTL_SERIAL_CLEAR_STATS ret %08X"), 
                      deviceID, status);
        break;

    default:
        TraceCOMProtocol(_T("<-@@Device  %ld:\tUnrecognized IOCTL %08X"), 
                    deviceID, ioControlCode);
    }
}

void TraceSetHandflowRequest(
    ULONG   deviceID,
    ULONG   majorFunction,
    ULONG   minorFunction,
    PBYTE   inputBuf,
    ULONG   outputBufferLength,
    ULONG   inputBufferLength,
    ULONG   ioControlCode                    
    )
/*++

Routine Description:

    Trace out a Set Handflow request.

Arguments:

    deviceID            -   Device Identifer.  0 is okay.
    majorFunction       -   IRP Major
    minorFunction       -   IRP Minor
    outputBuf           -   Output buffer, if applicable
    outputBufferLength  -   IRP Output buffer length.
    inputBufferLength   -   IRP Input buffer length.
    ioControlCode       -   IOCTL control code if IRP is for an IOCTL.                 

Return Value:

    NA

 --*/
{
    PSERIAL_HANDFLOW handFlow;

    TraceCOMProtocol(_T("->@@Device  %ld:\tIOCTL_SERIAL_SET_HANDFLOW ..."), deviceID);

    handFlow = (PSERIAL_HANDFLOW)inputBuf;
    if (handFlow->ControlHandShake & SERIAL_CTS_HANDSHAKE) {
        TraceCOMProtocol(_T("->@@Device  %ld:\t\tCTS enabled."));
    }

    if (handFlow->ControlHandShake & SERIAL_DSR_HANDSHAKE) {
        TraceCOMProtocol(_T("->@@Device  %ld:\t\tDSR enabled."));
    }

    if (handFlow->FlowReplace & SERIAL_AUTO_TRANSMIT) {
        TraceCOMProtocol(_T("->@@Device  %ld:\t\tOUTX enabled."));
    }

    if (handFlow->FlowReplace & SERIAL_AUTO_RECEIVE) {
        TraceCOMProtocol(_T("->@@Device  %ld:\t\tINX enabled."));
    }

    if (handFlow->FlowReplace & SERIAL_NULL_STRIPPING) {
        TraceCOMProtocol(_T("->@@Device  %ld:\t\tNull Stripping enabled."));
    }

    if (handFlow->FlowReplace & SERIAL_ERROR_CHAR) {
        TraceCOMProtocol(_T("->@@Device  %ld:\t\tError Character enabled."));
    }

    if (handFlow->FlowReplace & SERIAL_XOFF_CONTINUE) {
        TraceCOMProtocol(_T("->@@Device  %ld:\t\tXOFF Continue enabled."));
    }

    if (handFlow->ControlHandShake & SERIAL_ERROR_ABORT) {
        TraceCOMProtocol(_T("->@@Device  %ld:\t\tError Abort enabled."));
    }

    switch (handFlow->FlowReplace & SERIAL_RTS_MASK) {
        case 0:
            TraceCOMProtocol(_T("->@@Device  %ld:\t\tRTS Control disable."));
            break;
        case SERIAL_RTS_CONTROL:
            TraceCOMProtocol(_T("->@@Device  %ld:\t\tRTS Control enable."));
            break;
        case SERIAL_RTS_HANDSHAKE:
            TraceCOMProtocol(_T("->@@Device  %ld:\t\tRTS Control Handshake."));
            break;
        case SERIAL_TRANSMIT_TOGGLE:
            TraceCOMProtocol(_T("->@@Device  %ld:\t\tRTS Control Toggle."));
            break;
    }

    switch (handFlow->ControlHandShake & SERIAL_DTR_MASK) {
        case 0:
            TraceCOMProtocol(_T("->@@Device  %ld:\t\tDTR Control disable."));
            break;
        case SERIAL_DTR_CONTROL:
            TraceCOMProtocol(_T("->@@Device  %ld:\t\tDTR Control enable."));
            break;
        case SERIAL_DTR_HANDSHAKE:
            TraceCOMProtocol(_T("->@@Device  %ld:\t\tDTR Control handshake."));
            break;
    }

    if (handFlow->ControlHandShake & SERIAL_DSR_SENSITIVITY) {
        TraceCOMProtocol(_T("->@@Device  %ld:\t\tDSR Sensitivity is TRUE."));
    }

    TraceCOMProtocol(_T("->@@Device  %ld:\t\tXON Limit is %ld."), 
                (WORD)handFlow->XonLimit);
    TraceCOMProtocol(_T("->@@Device  %ld:\t\tXOFF Limit is %ld."), 
                (WORD)handFlow->XoffLimit);
}

void TraceSetWaitMaskRequest(
    ULONG   deviceID,
    ULONG   majorFunction,
    ULONG   minorFunction,
    PBYTE   inputBuf,
    ULONG   outputBufferLength,
    ULONG   inputBufferLength,
    ULONG   ioControlCode                    
    )
/*++

Routine Description:

    Trace out a Set Wait Mask request.

Arguments:

    deviceID            -   Device Identifer.  0 is okay.
    majorFunction       -   IRP Major
    minorFunction       -   IRP Minor
    outputBuf           -   Output buffer, if applicable
    outputBufferLength  -   IRP Output buffer length.
    inputBufferLength   -   IRP Input buffer length.
    ioControlCode       -   IOCTL control code if IRP is for an IOCTL.                 

Return Value:

    NA

 --*/
{
    ULONG *waitMask;

    TraceCOMProtocol(_T("->@@Device  %ld:\tIOCTL_SERIAL_GET_WAIT_MASK ..."), deviceID);

    waitMask = (ULONG *)inputBuf;

    if (*waitMask & EV_BREAK) {
        TraceCOMProtocol(_T("->@@Device  %ld:\t\tWait mask EV_BREAK is set"), deviceID);
    }
    if (*waitMask & EV_CTS) {
        TraceCOMProtocol(_T("->@@Device  %ld:\t\tWait mask EV_CTS is set"), deviceID);
    }
    if (*waitMask & EV_DSR) {
        TraceCOMProtocol(_T("->@@Device  %ld:\t\tWait mask EV_DSR is set"), deviceID);
    }
    if (*waitMask & EV_ERR) {
        TraceCOMProtocol(_T("->@@Device  %ld:\t\tWait mask EV_ERR is set"), deviceID);
    }
    if (*waitMask & EV_RING) {
        TraceCOMProtocol(_T("->@@Device  %ld:\t\tWait mask EV_RING is set"), deviceID);
    }
    if (*waitMask & EV_RLSD) {
        TraceCOMProtocol(_T("->@@Device  %ld:\t\tWait mask EV_RLSD is set"), deviceID);
    }
    if (*waitMask & EV_RXCHAR) {
        TraceCOMProtocol(_T("->@@Device  %ld:\t\tWait mask EV_RXCHAR is set"), deviceID);
    }
    if (*waitMask & EV_RXFLAG) {
        TraceCOMProtocol(_T("->@@Device  %ld:\t\tWait mask EV_RXFLAG is set"), deviceID);
    }
    if (*waitMask & EV_TXEMPTY) {
        TraceCOMProtocol(_T("->@@Device  %ld:\t\tWait mask EV_TXEMPTY is set"), deviceID);
    }
}

void TraceSetTimeoutsRequest(
    ULONG   deviceID,
    ULONG   majorFunction,
    ULONG   minorFunction,
    PBYTE   inputBuf,
    ULONG   outputBufferLength,
    ULONG   inputBufferLength,
    ULONG   ioControlCode                    
    )
/*++

Routine Description:

    Trace out a Set Timeouts request.

Arguments:

    deviceID            -   Device Identifer.  0 is okay.
    majorFunction       -   IRP Major
    minorFunction       -   IRP Minor
    outputBuf           -   Output buffer, if applicable
    outputBufferLength  -   IRP Output buffer length.
    inputBufferLength   -   IRP Input buffer length.
    ioControlCode       -   IOCTL control code if IRP is for an IOCTL.                 

Return Value:

    NA

 --*/
{
    PSERIAL_TIMEOUTS newTimeouts;

    newTimeouts = (PSERIAL_TIMEOUTS)inputBuf;
    TraceCOMProtocol(_T("->@@Device  %ld:\tIOCTL_SERIAL_SET_TIMEOUTS ...."), deviceID);
    TraceCOMProtocol(_T("->@@Device  %ld:\t\tReadIntervalTimeout:%ld"), 
                deviceID, newTimeouts->ReadIntervalTimeout);
    TraceCOMProtocol(_T("->@@Device  %ld:\t\tReadTotalTimeoutMultiplier:%ld"), 
                deviceID, newTimeouts->ReadTotalTimeoutMultiplier);
    TraceCOMProtocol(_T("->@@Device  %ld:\t\tReadTotalTimeoutConstant:%ld"), 
                deviceID, newTimeouts->ReadTotalTimeoutConstant);
    TraceCOMProtocol(_T("->@@Device  %ld:\t\tWriteTotalTimeoutMultiplier:%ld"), 
                deviceID, newTimeouts->WriteTotalTimeoutMultiplier);
    TraceCOMProtocol(_T("->@@Device  %ld:\t\tWriteTotalTimeoutConstant:%ld"), 
                deviceID, newTimeouts->WriteTotalTimeoutConstant);
}

void TraceSetCharsRequest(
    ULONG   deviceID,
    ULONG   majorFunction,
    ULONG   minorFunction,
    PBYTE   inputBuf,
    ULONG   outputBufferLength,
    ULONG   inputBufferLength,
    ULONG   ioControlCode                    
    )
/*++

Routine Description:

    Trace out a Set Chars request.

Arguments:

    deviceID            -   Device Identifer.  0 is okay.
    majorFunction       -   IRP Major
    minorFunction       -   IRP Minor
    outputBuf           -   Output buffer, if applicable
    outputBufferLength  -   IRP Output buffer length.
    inputBufferLength   -   IRP Input buffer length.
    ioControlCode       -   IOCTL control code if IRP is for an IOCTL.                 

Return Value:

    NA

 --*/
{
    PSERIAL_CHARS serialChars;

    serialChars = (PSERIAL_CHARS)inputBuf;

    TraceCOMProtocol(_T("->@@Device  %ld:\tIOCTL_SERIAL_SET_CHARS ...."), deviceID);
    TraceCOMProtocol(_T("->@@Device  %ld:\t\tXonChar:%ld"), 
                deviceID, serialChars->XonChar);
    TraceCOMProtocol(_T("->@@Device  %ld:\t\tXoffChar:%ld"), 
                deviceID, serialChars->XoffChar);
    TraceCOMProtocol(_T("->@@Device  %ld:\t\tErrorChar:%ld"), 
                deviceID, serialChars->ErrorChar);
    TraceCOMProtocol(_T("->@@Device  %ld:\t\tBreakChar:%ld"), 
                deviceID, serialChars->BreakChar);
    TraceCOMProtocol(_T("->@@Device  %ld:\t\tEofChar:%ld"), 
                deviceID, serialChars->EofChar);
    TraceCOMProtocol(_T("->@@Device  %ld:\t\tEventChar:%ld"), 
                deviceID, serialChars->EventChar);
}

void TraceGetTimeoutsResponse(
    ULONG   deviceID,
    ULONG   majorFunction,
    ULONG   minorFunction,
    PBYTE   outputBuf,
    ULONG   outputBufferLength,
    ULONG   inputBufferLength,
    ULONG   ioControlCode,
    ULONG   status
    )
/*++

Routine Description:

    Trace out a Get Timeouts response.

Arguments:

    deviceID            -   Device Identifer.  0 is okay.
    majorFunction       -   IRP Major
    minorFunction       -   IRP Minor
    outputBuf           -   Output buffer, if applicable
    outputBufferLength  -   IRP Output buffer length.
    inputBufferLength   -   IRP Input buffer length.
    ioControlCode       -   IOCTL control code if IRP is for an IOCTL.                 

Return Value:

    NA

 --*/
{
    PSERIAL_TIMEOUTS st;

    st = (PSERIAL_TIMEOUTS)outputBuf;

    TraceCOMProtocol(_T("<-@@Device  %ld:\tIOCTL_SERIAL_GET_TIMEOUTS ret %08X ..."), 
                    deviceID, status);
    TraceCOMProtocol(_T("<-@@Device  %ld:\t\tReadIntervalTimeout:%ld"), 
                deviceID, st->ReadIntervalTimeout);
    TraceCOMProtocol(_T("<-@@Device  %ld:\t\tReadTotalTimeoutMultiplier:%ld"), 
                deviceID, st->ReadTotalTimeoutMultiplier);
    TraceCOMProtocol(_T("<-@@Device  %ld:\t\tReadTotalTimeoutConstant:%ld"), 
                deviceID, st->ReadTotalTimeoutConstant);
    TraceCOMProtocol(_T("<-@@Device  %ld:\t\tWriteTotalTimeoutMultiplier:%ld"), 
                deviceID, st->WriteTotalTimeoutMultiplier);
    TraceCOMProtocol(_T("<-@@Device  %ld:\t\tWriteTotalTimeoutConstant:%ld"), 
                deviceID, st->WriteTotalTimeoutConstant);
}

void TraceGetCharsResponse(
    ULONG   deviceID,
    ULONG   majorFunction,
    ULONG   minorFunction,
    PBYTE   outputBuf,
    ULONG   outputBufferLength,
    ULONG   inputBufferLength,
    ULONG   ioControlCode,
    ULONG   status
    )
/*++

Routine Description:

    Trace out a Get Chars response.

Arguments:

    deviceID            -   Device Identifer.  0 is okay.
    majorFunction       -   IRP Major
    minorFunction       -   IRP Minor
    outputBuf           -   Output buffer, if applicable
    outputBufferLength  -   IRP Output buffer length.
    inputBufferLength   -   IRP Input buffer length.
    ioControlCode       -   IOCTL control code if IRP is for an IOCTL.                 
    status              -   Return status from operation.

Return Value:

    NA

 --*/
{
    PSERIAL_CHARS serialChars;

    serialChars = (PSERIAL_CHARS)outputBuf;

    TraceCOMProtocol(_T("<-@@Device  %ld:\tIOCTL_SERIAL_SET_CHARS ret %08X ..."), 
                deviceID, status);
    TraceCOMProtocol(_T("<-@@Device  %ld:\t\tXonChar:%ld"), 
                deviceID, serialChars->XonChar);
    TraceCOMProtocol(_T("<-@@Device  %ld:\t\tXoffChar:%ld"), 
                deviceID, serialChars->XoffChar);
    TraceCOMProtocol(_T("<-@@Device  %ld:\t\tErrorChar:%ld"), 
                deviceID, serialChars->ErrorChar);
    TraceCOMProtocol(_T("<-@@Device  %ld:\t\tBreakChar:%ld"), 
                deviceID, serialChars->BreakChar);
    TraceCOMProtocol(_T("<-@@Device  %ld:\t\tEofChar:%ld"), 
                deviceID, serialChars->EofChar);
    TraceCOMProtocol(_T("<-@@Device  %ld:\t\tEventChar:%ld"), 
                deviceID, serialChars->EventChar);
}

void TraceGetWaitMaskResponse(
    ULONG   deviceID,
    ULONG   majorFunction,
    ULONG   minorFunction,
    PBYTE   outputBuf,
    ULONG   outputBufferLength,
    ULONG   inputBufferLength,
    ULONG   ioControlCode,
    ULONG   status
    )
/*++

Routine Description:

    Trace out a Get Wait Mask response.

Arguments:

    deviceID            -   Device Identifer.  0 is okay.
    majorFunction       -   IRP Major
    minorFunction       -   IRP Minor
    outputBuf           -   Output buffer, if applicable
    outputBufferLength  -   IRP Output buffer length.
    inputBufferLength   -   IRP Input buffer length.
    ioControlCode       -   IOCTL control code if IRP is for an IOCTL.                 
    status              -   Return status from operation.

Return Value:

    NA

 --*/
{
    ULONG *waitMask;

    TraceCOMProtocol(_T("<-@@Device  %ld:\tIOCTL_SERIAL_GET_WAIT_MASK ret %08X ..."), 
                deviceID, status);

    waitMask = (ULONG *)outputBuf;

    if (*waitMask & EV_BREAK) {
        TraceCOMProtocol(_T("<-@@Device  %ld:\t\tWait mask EV_BREAK is set"), deviceID);
    }
    if (*waitMask & EV_CTS) {
        TraceCOMProtocol(_T("<-@@Device  %ld:\t\tWait mask EV_CTS is set"), deviceID);
    }
    if (*waitMask & EV_DSR) {
        TraceCOMProtocol(_T("<-@@Device  %ld:\t\tWait mask EV_DSR is set"), deviceID);
    }
    if (*waitMask & EV_ERR) {
        TraceCOMProtocol(_T("<-@@Device  %ld:\t\tWait mask EV_ERR is set"), deviceID);
    }
    if (*waitMask & EV_RING) {
        TraceCOMProtocol(_T("<-@@Device  %ld:\t\tWait mask EV_RING is set"), deviceID);
    }
    if (*waitMask & EV_RLSD) {
        TraceCOMProtocol(_T("<-@@Device  %ld:\t\tWait mask EV_RLSD is set"), deviceID);
    }
    if (*waitMask & EV_RXCHAR) {
        TraceCOMProtocol(_T("<-@@Device  %ld:\t\tWait mask EV_RXCHAR is set"), deviceID);
    }
    if (*waitMask & EV_RXFLAG) {
        TraceCOMProtocol(_T("<-@@Device  %ld:\t\tWait mask EV_RXFLAG is set"), deviceID);
    }
    if (*waitMask & EV_TXEMPTY) {
        TraceCOMProtocol(_T("<-@@Device  %ld:\t\tWait mask EV_TXEMPTY is set"), deviceID);
    }
}

void TraceGetHandflowResponse(
    ULONG   deviceID,
    ULONG   majorFunction,
    ULONG   minorFunction,
    PBYTE   outputBuf,
    ULONG   outputBufferLength,
    ULONG   inputBufferLength,
    ULONG   ioControlCode,
    ULONG   status
    )
/*++

Routine Description:

    Trace out a Get Handflow response.

Arguments:

    deviceID            -   Device Identifer.  0 is okay.
    majorFunction       -   IRP Major
    minorFunction       -   IRP Minor
    outputBuf           -   Output buffer, if applicable
    outputBufferLength  -   IRP Output buffer length.
    inputBufferLength   -   IRP Input buffer length.
    ioControlCode       -   IOCTL control code if IRP is for an IOCTL.                 
    status              -   Return status from operation.

Return Value:

    NA

 --*/
{
    PSERIAL_HANDFLOW handFlow;

    TraceCOMProtocol(_T("<-@@Device  %ld:\tIOCTL_SERIAL_SET_HANDFLOW ret %08X ..."), 
                deviceID, status);

    handFlow = (PSERIAL_HANDFLOW)outputBuf;

    if (handFlow->ControlHandShake & SERIAL_CTS_HANDSHAKE) {
        TraceCOMProtocol(_T("<-@@Device  %ld:\t\tCTS enabled."), deviceID);
    }

    if (handFlow->ControlHandShake & SERIAL_DSR_HANDSHAKE) {
        TraceCOMProtocol(_T("<-@@Device  %ld:\t\tDSR enabled."), deviceID);
    }

    if (handFlow->FlowReplace & SERIAL_AUTO_TRANSMIT) {
        TraceCOMProtocol(_T("<-@@Device  %ld:\t\tOUTX enabled."), deviceID);
    }

    if (handFlow->FlowReplace & SERIAL_AUTO_RECEIVE) {
        TraceCOMProtocol(_T("<-@@Device  %ld:\t\tINX enabled."), deviceID);
    }

    if (handFlow->FlowReplace & SERIAL_NULL_STRIPPING) {
        TraceCOMProtocol(_T("<-@@Device  %ld:\t\tNull Stripping enabled."), deviceID);
    }

    if (handFlow->FlowReplace & SERIAL_ERROR_CHAR) {
        TraceCOMProtocol(_T("<-@@Device  %ld:\t\tError Character enabled."), deviceID);
    }

    if (handFlow->FlowReplace & SERIAL_XOFF_CONTINUE) {
        TraceCOMProtocol(_T("<-@@Device  %ld:\t\tXOFF Continue enabled."), deviceID);
    }

    if (handFlow->ControlHandShake & SERIAL_ERROR_ABORT) {
        TraceCOMProtocol(_T("<-@@Device  %ld:\t\tError Abort enabled."), deviceID);
    }

    switch (handFlow->FlowReplace & SERIAL_RTS_MASK) {
        case 0:
            TraceCOMProtocol(_T("<-@@Device  %ld:\t\tRTS Control disable."), deviceID);
            break;
        case SERIAL_RTS_CONTROL:
            TraceCOMProtocol(_T("<-@@Device  %ld:\t\tRTS Control enable."), deviceID);
            break;
        case SERIAL_RTS_HANDSHAKE:
            TraceCOMProtocol(_T("<-@@Device  %ld:\t\tRTS Control Handshake."), deviceID);
            break;
        case SERIAL_TRANSMIT_TOGGLE:
            TraceCOMProtocol(_T("<-@@Device  %ld:\t\tRTS Control Toggle."), deviceID);
            break;
    }

    switch (handFlow->ControlHandShake & SERIAL_DTR_MASK) {
        case 0:
            TraceCOMProtocol(_T("<-@@Device  %ld:\t\tDTR Control disable."), deviceID);
            break;
        case SERIAL_DTR_CONTROL:
            TraceCOMProtocol(_T("<-@@Device  %ld:\t\tDTR Control enable."), deviceID);
            break;
        case SERIAL_DTR_HANDSHAKE:
            TraceCOMProtocol(_T("<-@@Device  %ld:\t\tDTR Control handshake."), deviceID);
            break;
    }

    if (handFlow->ControlHandShake & SERIAL_DSR_SENSITIVITY) {
        TraceCOMProtocol(_T("<-@@Device  %ld:\t\tDSR Sensitivity is TRUE."), deviceID);
    }

    TraceCOMProtocol(_T("<-@@Device  %ld:\t\tXON Limit is %ld."), 
                (WORD)handFlow->XonLimit, deviceID);
    TraceCOMProtocol(_T("<-@@Device  %ld:\t\tXOFF Limit is %ld."), 
                deviceID, (WORD)handFlow->XoffLimit);
}

void TraceGetCommStatusResponse(
    ULONG   deviceID,
    ULONG   majorFunction,
    ULONG   minorFunction,
    PBYTE   outputBuf,
    ULONG   outputBufferLength,
    ULONG   inputBufferLength,
    ULONG   ioControlCode,
    ULONG   status
    )
/*++

Routine Description:

    Trace out a Get Communication Status response.

Arguments:

    deviceID            -   Device Identifer.  0 is okay.
    majorFunction       -   IRP Major
    minorFunction       -   IRP Minor
    outputBuf           -   Output buffer, if applicable
    outputBufferLength  -   IRP Output buffer length.
    inputBufferLength   -   IRP Input buffer length.
    ioControlCode       -   IOCTL control code if IRP is for an IOCTL.                 
    status              -   Return status from operation.

Return Value:

    NA

 --*/
{
    PSERIAL_STATUS serialCommStatus;

    TraceCOMProtocol(_T("<-@@Device  %ld:\tIOCTL_SERIAL_GET_COMMSTATUS ret %08X ..."), 
                deviceID, status);

    serialCommStatus = (PSERIAL_STATUS)outputBuf;

    if (serialCommStatus->HoldReasons & SERIAL_TX_WAITING_FOR_CTS) {
        TraceCOMProtocol(_T("<-@@Device  %ld:\t\tWaiting for CTS."), deviceID);
    }

    if (serialCommStatus->HoldReasons & SERIAL_TX_WAITING_FOR_DSR) {
        TraceCOMProtocol(_T("<-@@Device  %ld:\t\tWaiting for DSR."), deviceID);
    }

    if (serialCommStatus->HoldReasons & SERIAL_TX_WAITING_FOR_DCD) {
        TraceCOMProtocol(_T("<-@@Device  %ld:\t\tWaiting for DCD."), deviceID);
    }

    if (serialCommStatus->HoldReasons & SERIAL_TX_WAITING_FOR_XON) {
        TraceCOMProtocol(_T("<-@@Device  %ld:\t\tWaiting for XON."), deviceID);
    }

    if (serialCommStatus->HoldReasons & SERIAL_TX_WAITING_XOFF_SENT) {
        TraceCOMProtocol(_T("<-@@Device  %ld:\t\tWaiting for XOFF Sent."), deviceID);
    }

    if (serialCommStatus->EofReceived) {
        TraceCOMProtocol(_T("<-@@Device  %ld:\t\tEOF received."), deviceID);
    }

    if (serialCommStatus->WaitForImmediate) {
        TraceCOMProtocol(_T("<-@@Device  %ld:\t\tWait for immediate."), deviceID);
    }

    TraceCOMProtocol(_T("<-@@Device  %ld:\t\t%ld byes in input queue."), 
            deviceID, serialCommStatus->AmountInInQueue);
    TraceCOMProtocol(_T("<-@@Device  %ld:\t\t%ld byes in input queue."), 
            deviceID, serialCommStatus->AmountInOutQueue);

    if (serialCommStatus->Errors & SERIAL_ERROR_BREAK) {
        TraceCOMProtocol(_T("<-@@Device  %ld:\t\tError Break."), deviceID);
    }
    
    if (serialCommStatus->Errors & SERIAL_ERROR_FRAMING) {
        TraceCOMProtocol(_T("<-@@Device  %ld:\t\tFraming Error."), deviceID);
    }

    if (serialCommStatus->Errors & SERIAL_ERROR_OVERRUN) {
        TraceCOMProtocol(_T("<-@@Device  %ld:\t\tOverrun Error."), deviceID);
    }

    if (serialCommStatus->Errors & SERIAL_ERROR_QUEUEOVERRUN) {
        TraceCOMProtocol(_T("<-@@Device  %ld:\t\tQueue Overrun."), deviceID);
    }

    if (serialCommStatus->Errors & SERIAL_ERROR_PARITY) {
        TraceCOMProtocol(_T("<-@@Device  %ld:\t\tParity Error."), deviceID);
    }
}

void TraceGetProperties(
    ULONG   deviceID,
    ULONG   majorFunction,
    ULONG   minorFunction,
    PBYTE   outputBuf,
    ULONG   outputBufferLength,
    ULONG   inputBufferLength,
    ULONG   ioControlCode,
    ULONG   status
    )
/*++

Routine Description:

    Trace out a Get Properties response.

Arguments:

    deviceID            -   Device Identifer.  0 is okay.
    majorFunction       -   IRP Major
    minorFunction       -   IRP Minor
    outputBuf           -   Output buffer, if applicable
    outputBufferLength  -   IRP Output buffer length.
    inputBufferLength   -   IRP Input buffer length.
    ioControlCode       -   IOCTL control code if IRP is for an IOCTL.                 
    status              -   Return status from operation.

Return Value:

    NA

 --*/
{
    PSERIAL_COMMPROP sp;

    TraceCOMProtocol(_T("<-@@Device  %ld:\tIOCTL_SERIAL_GET_PROPERTIES ret %08X ..."), 
                deviceID, status);

    sp = (PSERIAL_COMMPROP)outputBuf;

    TraceCOMProtocol(_T("<-@@Device  %ld:\t\t:  PacketLength     %ld."), deviceID, sp->PacketLength);
    TraceCOMProtocol(_T("<-@@Device  %ld:\t\t:  PacketVersion    %ld."), deviceID, sp->PacketVersion);
    TraceCOMProtocol(_T("<-@@Device  %ld:\t\t:  ServiceMask      %ld."), deviceID, sp->ServiceMask);
    TraceCOMProtocol(_T("<-@@Device  %ld:\t\t:  MaxTxQueue       %ld."), deviceID, sp->MaxTxQueue);
    TraceCOMProtocol(_T("<-@@Device  %ld:\t\t:  MaxRxQueue       %ld."), deviceID, sp->MaxRxQueue);
    TraceCOMProtocol(_T("<-@@Device  %ld:\t\t:  MaxBaud          %ld."), deviceID, sp->MaxBaud);
    TraceCOMProtocol(_T("<-@@Device  %ld:\t\t:  ProvSubType      %ld."), deviceID, sp->ProvSubType);
    TraceCOMProtocol(_T("<-@@Device  %ld:\t\t:  ProvCapabilities %ld."), deviceID, sp->ProvCapabilities);
    TraceCOMProtocol(_T("<-@@Device  %ld:\t\t:  SettableParams   %ld."), deviceID, sp->SettableParams);
    TraceCOMProtocol(_T("<-@@Device  %ld:\t\t:  SettableBaud     %ld."), deviceID, sp->SettableBaud);
    TraceCOMProtocol(_T("<-@@Device  %ld:\t\t:  SettableData     %ld."), deviceID, sp->SettableData);
    TraceCOMProtocol(_T("<-@@Device  %ld:\t\t:  SettableStopParity%ld."),deviceID, sp->SettableStopParity);
    TraceCOMProtocol(_T("<-@@Device  %ld:\t\t:  CurrentTxQueue   %ld."), deviceID, sp->CurrentTxQueue);
    TraceCOMProtocol(_T("<-@@Device  %ld:\t\t:  CurrentRxQueue   %ld."), deviceID, sp->CurrentRxQueue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\utl.h ===
/*++

    Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    utl.h

Abstract:

    Misc. Shared and Platform-Indepdent Utilities for the RDP Client 
    Device Redirector

Author:

    Tad Brockway

Revision History:

--*/

#ifndef __UTL_H__
#define __UTL_H__

#include <rdpdr.h>

#define INVALID_SESSIONID 0xFFFFFFFF
typedef DWORD (WINAPI *PROCESSIDTOSESSIONID)( DWORD, DWORD* );

//
//
//  Allocate a reply packet.
//
NTSTATUS DrUTL_AllocateReplyBuf(PRDPDR_IOREQUEST_PACKET pIoReq, 
                          PRDPDR_IOCOMPLETION_PACKET *pReplyPacket,
                          OUT ULONG *replyPacketSize);

//
//  Check the input/output buffer size for an IO request packet.
//
NTSTATUS DrUTL_CheckIOBufInputSize(PRDPDR_IOREQUEST_PACKET pIoReq,
                             ULONG requiredSize);
NTSTATUS DrUTL_CheckIOBufOutputSize(PRDPDR_IOREQUEST_PACKET pIoReq,
                             ULONG requiredSize);

//
//  Allocate a reply buffer to be returned in response to a server
//  request.
//
NTSTATUS DrUTL_AllocateReplyBuf(
    PRDPDR_IOREQUEST_PACKET pIoReq, 
    PRDPDR_IOCOMPLETION_PACKET *pReplyPacket,
    ULONG *replyPacketSize
    );

//
//  Allocate/release a IO request completion packet for a specified IO
//  request packet.
//
PRDPDR_IOCOMPLETION_PACKET DrUTL_AllocIOCompletePacket(
    const PRDPDR_IOREQUEST_PACKET pIoRequestPacket, 
    ULONG sz
    );
VOID DrUTL_FreeIOCompletePacket(
    PRDPDR_IOCOMPLETION_PACKET packet
    );

//
// Retrieve user session ID, return INVALID_SESSIONID
// on win9x, NT4/TS4 SP3
//
DWORD
GetUserSessionID();


#ifdef OS_WINCE
ULONG GetActivePortsList(TCHAR *pszPort);
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\vcint.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    vcint.h

Abstract:

    This module defines the virtual channel interface class.

Author:

    Madan Appiah (madana) 17-Sep-1998

Revision History:

--*/

#ifndef __PORTMAP_H__
#define __PORTMAP_H__

//include externally exposed API
#include "drapi.h"
//definition of a channel init handle
//this is used only by internal plugins
#include "vchandle.h"

#define STATE_UNKNOWN           0xFF
#define PRDR_VC_CHANNEL_NAME    DR_CHANNEL_NAME

class ProcObj;

class VCManager;


typedef struct _VC_TX_DATA
{
    UINT32 uiLength;
    UINT32 uiAvailLen;
    BYTE *pbData;
} VC_TX_DATA, *PVC_TX_DATA;


class CClip;
class CRDPSound;

class VCManager : public IRDPDR_INTERFACE_OBJ {

public:

    VCManager(CHANNEL_ENTRY_POINTS_EX*);
    VOID ChannelWrite(LPVOID, UINT);

	//	This version returns a status for the write as:  
	//		CHANNEL_RC_OK, CHANNEL_RC_NOT_INITIALIZED, CHANNEL_RC_NOT_CONNECTED,
	//		CHANNEL_RC_BAD_CHANNEL_HANDLE, CHANNEL_RC_NULL_DATA, 
	//		CHANNEL_RC_ZERO_LENGTH
	UINT ChannelWriteEx(LPVOID, UINT);
    UINT ChannelClose();


    VOID ChannelInitEvent(PVOID, UINT, PVOID, UINT);
    VOID ChannelOpenEvent(ULONG, UINT, PVOID, UINT32, UINT32, UINT32);

    VOID SetClip(CClip* pClip) {_pClip = pClip;}
    CClip* GetClip() {return _pClip;}
    VOID SetInitData(PRDPDR_DATA pInitData) {_pRdpDrInitSettings = pInitData;}
    PRDPDR_DATA GetInitData() {return _pRdpDrInitSettings;}

    VOID SetSound(CRDPSound *pSound) { _pSound = pSound; }
    CRDPSound *GetSound() { return _pSound; }

    virtual void OnDeviceChange(WPARAM wParam, LPARAM lParam);

protected:
    PVOID _hVCHandle;       // Virtual Channel Handle.
    ULONG _hVCOpenHandle;   // VC open handle for rdpdr channel.

    VC_TX_DATA _Buffer;     // Data for compiling data recieved by the channel

    BYTE _bState;           // State of the connection/system
    ProcObj *_pProcObj;     // Pointer to the processing unit
    CHANNEL_ENTRY_POINTS_EX _ChannelEntries;
                            // Callback methods

    PRDPDR_DATA             _pRdpDrInitSettings;

    CClip* _pClip;
    CRDPSound *_pSound;
};

#endif // __PORTMAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\w32dispq.h ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    w32dispq.h

Abstract:

    Contains the Win32 Operation Dispatch Object class, 
    W32DispatchQueue.

Author:

    Tad Brockway (tadb) 4/19/99

Revision History:

--*/

#ifndef __W32DISPQ_H__
#define __W32DISPQ_H__

#include "drobject.h"
#include "drqueue.h"

typedef (*W32DispatchQueueFunc)(PVOID clientData, BOOL cancelled);


///////////////////////////////////////////////////////////////
//
//	W32DispatchQueue
//
//  Asynchronously dispatch operations.
//
//

class W32DispatchQueue : public DrObject {

private:


    typedef struct _QUEUEELEMENT {
        W32DispatchQueueFunc    func;
        VOID                    *clientData;
    } QUEUEELEMENT, *PQUEUEELEMENT;

    //
    //  The queue.
    //
    DrQueue<QUEUEELEMENT> *_queue;

    //
    //  Synchronize data-ready in the queue.
    //
    HANDLE          _dataReadyEvent;

public:

    //
    //  Constructor/Destructor
    //
    W32DispatchQueue();
    ~W32DispatchQueue();

    ///
    //  Initialize
    //
    DWORD Initialize();

    //
    //  Peek at the next entry in the queue without dequeueing.
    //
    BOOL PeekNextEntry(W32DispatchQueueFunc *func=NULL, 
                    VOID **clientData=NULL);

    //
    //  Grab the next queued operation out of the queue.
    //
    BOOL Dequeue(W32DispatchQueueFunc *func=NULL, 
                    VOID **clientData=NULL);

    //
    //  Add an element to the queue in FIFO fashion.
    //
    BOOL Enqueue(W32DispatchQueueFunc func, 
                    VOID *clientData=NULL);

    //
    //  Requeue an element at the tail of the queue in LIFO fashion.
    //  
    BOOL Requeue(W32DispatchQueueFunc func, 
                    VOID *clientData=NULL,
                    BOOL signalNewData = FALSE);

    //
    //  Get access to a waitable object that can be waited on for
    //  data-ready in the queue.
    //
    HANDLE GetWaitableObject() {
        return _dataReadyEvent;
    }

    //
    //  Returns the number of elements in the queue.
    //
    ULONG   GetCount() {
        return _queue->GetCount();
    }

    //
    //  Lock/Unlock the queue.
    //
    VOID Lock() {
        _queue->Lock();
    }
    VOID Unlock() {
        _queue->Unlock();
    }

    //
    //  Return the class name.
    //
    virtual DRSTRING ClassName()  { return TEXT("W32DispatchQueue"); }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\w32dispq.cpp ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    w32dispq.cpp

Abstract:

    Contains the Win32 Operation Dispatch Object class, 
    W32DispatchQueue.

    Enqueue at the head.  Dequeue at the tail.
    
Author:

    Tad Brockway (tadb) 4/19/99

Revision History:

--*/

#include <precom.h>

#define TRC_FILE  "W32DispQ"

#include "w32dispq.h"
#include "drdbg.h"


///////////////////////////////////////////////////////////////
//
//  W32DispatchQueue Methods
//
//

W32DispatchQueue::W32DispatchQueue() 
/*++

Routine Description:

    Constructor

Arguments:

    initialSize -   Initial number of elements in the queue.

Return Value:

    NA

 --*/
{
    DC_BEGIN_FN("W32DispatchQueue::W32DispatchQueue");

    //
    //  Not valid until initialized.
    //
    SetValid(FALSE);
    
    DC_END_FN();
}

W32DispatchQueue::~W32DispatchQueue()
/*++

Routine Description:

    Destructor

Arguments:

    NA

Return Value:

    NA

 --*/
{
    DC_BEGIN_FN("W32DispatchQueue::~W32DispatchQueue");

    //
    //  Assert that the queue is empty.
    //
    ASSERT(_queue->GetCount() == 0);

    //
    //  Release the "data ready" event.
    //
    if (_dataReadyEvent != NULL) {
        CloseHandle(_dataReadyEvent);
    }

    //
    //  Release the queue instance.
    //
    if (_queue != NULL) {
        delete _queue;
    }

    DC_END_FN();
}

DWORD W32DispatchQueue::Initialize()
/*++

Routine Description:

    Initialize

Arguments:

Return Value:

    ERROR_SUCCESS on success.  Otherwise, an error code is returned.

 --*/
{
    DWORD result = ERROR_SUCCESS;

    DC_BEGIN_FN("W32DispatchQueue::Initialize");

    //
    //  Create the "data ready" event.
    //
    _dataReadyEvent = CreateEvent(
                            NULL,   // no attribute.
                            FALSE,  // auto reset.
                            FALSE,  // initially not signalled.
                            NULL    // no name.
                            );
    if (_dataReadyEvent == NULL) {
        result = GetLastError();
        TRC_ERR((TB, _T("CreateEvent %ld."), result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Create the queue instance.
    //
    _queue = new DrQueue<QUEUEELEMENT>;
    if (_queue == NULL) {
        TRC_ERR((TB, _T("Can't instantiate DrQueue.")));
        result = ERROR_NOT_ENOUGH_MEMORY;
        goto CLEANUPANDEXIT;
    }
    result = _queue->Initialize();
    if (result != ERROR_SUCCESS) {
        delete _queue;
        _queue = NULL;
        goto CLEANUPANDEXIT;
    }

    SetValid(TRUE);

CLEANUPANDEXIT:

    return result;
}

BOOL W32DispatchQueue::PeekNextEntry(
    OPTIONAL OUT W32DispatchQueueFunc *func, 
    OPTIONAL OUT VOID **clientData
    )
/*++

Routine Description:

    Peek at the next entry in the queue without dequeueing.

Arguments:

    func            -   Function associated with next element.
    clientData      -   Client data associated with next element.

Return Value:

    NA

 --*/
{
    BOOL result;
    QUEUEELEMENT queueElement;

    DC_BEGIN_FN("W32DispatchQueue::PeekNextEntry");

    ASSERT(IsValid());
    result = IsValid() && _queue->PeekNextEntry(queueElement);

    if (result) {
        if (func != NULL) {
            *func = queueElement.func;
        }
        if (clientData != NULL) {
            *clientData = queueElement.clientData;
        }
    }

    DC_END_FN();
    return result;
}

BOOL W32DispatchQueue::Dequeue(
    OPTIONAL OUT W32DispatchQueueFunc *func, 
    OPTIONAL OUT VOID **clientData
    )
/*++

Routine Description:

    Grab the next queued operation out of the queue.

Arguments:

    func            -   Function associated with next element.
    clientData      -   Client data associated with next element.

Return Value:

    TRUE if there was an element in the queue to be dequeued.

 --*/
{
    BOOL result;
    QUEUEELEMENT element;

    DC_BEGIN_FN("W32DispatchQueue::Dequeue");

    ASSERT(IsValid());
    result = IsValid() && _queue->Dequeue(element);
    if (result) {
        if (func != NULL)       *func = element.func;
        if (clientData != NULL) *clientData = element.clientData;
    }

    DC_END_FN();
    return result;
}

BOOL W32DispatchQueue::Enqueue(
    IN W32DispatchQueueFunc func, 
    OPTIONAL IN VOID *clientData
    )
/*++

Routine Description:

    Add an element to the queue in FIFO fashion.

Arguments:

    func            -   Function associated with new element.
    clientData      -   Client data associated with new element.

Return Value:

    TRUE if the new element could be successfully queued.  FALSE,
    otherwise.  If FALSE is returned then GetLastError() can be 
    used to retrieve the exact error code.

 --*/
{
    BOOL result;
    QUEUEELEMENT element;

    DC_BEGIN_FN("W32DispatchQueue::Enqueue");

    ASSERT(IsValid());
    element.func = func;
    element.clientData = clientData;
    result = IsValid() && _queue->Enqueue(element);

    //
    //  Signal the data ready event if the enqueue succeeded.
    //  
    if (result) {
        SetEvent(_dataReadyEvent);
    }
    
    DC_END_FN();
    return result;
}

BOOL W32DispatchQueue::Requeue(
    IN W32DispatchQueueFunc func, 
    OPTIONAL IN VOID *clientData,
    IN BOOL signalNewData
    )
/*++

Routine Description:

    Requeue an element at the tail of the queue in LIFO fashion.

Arguments:

    func            -   Function associated with new element.
    clientData      -   Client data associated with new element.
    signalNewData   -   If TRUE then the waitable object associated
                        with this queue will be signalled.

Return Value:

    TRUE if the new element could be successfully queued.  FALSE,
    otherwise.  If FALSE is returned then GetLastError() can be 
    used to retrieve the exact error code.

 --*/
{
    DC_BEGIN_FN("W32DispatchQueue::Requeue");

    BOOL result;
    QUEUEELEMENT element;

    ASSERT(IsValid());
    element.func = func;
    element.clientData = clientData;
    result = IsValid() && _queue->Requeue(element);

    //
    //  Signal the data ready event if the enqueue succeeded.
    //  
    if (result && signalNewData) {
        SetEvent(_dataReadyEvent);
    }

    DC_END_FN();

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\vcint.cpp ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    vcint.cpp

Abstract:

    This module contains virtual channel interface routines.

Author:

    madan appiah (madana) 16-Sep-1998

Revision History:

--*/

#include "precom.h"

#define TRC_FILE  "vcint"

#include "cclip.h"
#include "vcint.h"
#include "rdpdrcom.h"
#include "drdbg.h"
#include "rdpsndc.h"

VOID
VCAPITYPE
RDPDR_InitEventFnEx(
    IN PVOID lpUserParam,
    IN PVOID pInitHandle,
    IN UINT  event,
    IN PVOID pData,
    IN UINT  dataLength
    )
/*++

Routine Description:

    Handles InitEvent callbacks by delegating to the connection manager.

Arguments:

    - pInitHandle - a handle uniquely identifying this connection
    - event - the event that has occurred - see CHANNEL_EVENT_XXX defines
    - pData - data associated with the event - see CHANNEL_EVENT_XXX defines
    - dataLength - length of the data.

Return Value:

    None

 --*/
{
    CRDPSound   *pSound = NULL;

    DC_BEGIN_FN("InitEventFn");

    ASSERT(lpUserParam != NULL);
    
    if(!lpUserParam) 
    {
        return;
    }

    VCManager*  pVCMgr = (VCManager*)lpUserParam;
    ASSERT(pVCMgr != NULL);
    if(!pVCMgr)
    {
        return;
    }


    CClip*      pClip  = pVCMgr->GetClip();

    ASSERT(pClip != NULL);
    if(!pClip)
    {
        return;
    }

    pVCMgr->ChannelInitEvent(pInitHandle, event, pData, dataLength);

    pClip->ClipInitEventFn(pInitHandle, event, pData, dataLength);

    if ( pVCMgr->GetInitData()->fEnableRedirectedAudio ) 
    { 
        pSound = pVCMgr->GetSound();
        if ( NULL != pSound )
        {
            pSound->InitEventFn( pInitHandle, event, pData, dataLength );
        }
    }

    if(CHANNEL_EVENT_TERMINATED == event)
    {
        //CLEANUP
        pSound = pVCMgr->GetSound();
        if ( NULL != pSound )
            delete pSound;

        delete pVCMgr;
        delete pClip;
    }

    DC_END_FN();
    return;
}

VOID
VCAPITYPE
RDPDR_OpenEventFn(
    IN LPVOID lpUserParam,
    IN ULONG openHandle,
    IN UINT event,
    IN PVOID pData,
    IN UINT32 dataLength,
    IN UINT32 totalLength,
    IN UINT32 dataFlags
    )
/*++

Routine Description:

    Handles OpenEvent callbacks by delegating to the connection manager.

Arguments:

    openHandle - a handle uniquely identifying this channel
    event - event that has occurred - see CHANNEL_EVENT_XXX below
    pData - data received
    dataLength - length of the data
    totalLength - total length of data written by the Server
    dataFlags - flags, zero, one or more of:
    - 0x01 - beginning of data from a single write operation at the Server
    - 0x02 - end of data from a single write operation at the Server.

Return Value:

    None

 --*/

{
    DC_BEGIN_FN("OpenEventFn");

    TRC_NRM((TB, _T("Event %x, handle %lx, datalength %ld, dataFlags %lx"),
        event, openHandle, dataLength, dataFlags));

    ASSERT(lpUserParam != NULL);
    if(!lpUserParam) 
    {
        return;
    }
    
    ((VCManager*)lpUserParam)->ChannelOpenEvent(openHandle, event, pData, dataLength,
        totalLength, dataFlags);

    DC_END_FN();
    return;
}

#ifdef OS_WIN32
BOOL DCAPI
#else //OS_WIN32
BOOL __loadds DCAPI
#endif //OS_WIN32

RDPDR_VirtualChannelEntryEx(
    IN PCHANNEL_ENTRY_POINTS_EX pEntryPoints,
    IN PVOID                       pInitHandle
    )
/*++

Routine Description:

    Exported API called by the Virtual Channels

Arguments:

    pEntryPoints - Entry point structure containing all callback methods.

Return Value:

    None.

 --*/

{
    BOOL       rv = FALSE;
    VCManager* pcmMgr = NULL;
    CClip*     pClip  = NULL;
    CRDPSound  *pSound = NULL;
    CHANNEL_DEF aChannel[3];
    UINT uiRet;
    PCHANNEL_INIT_HANDLE pChanInitHandle;
    PRDPDR_DATA pRdpDrInitSettings;

    DC_BEGIN_FN("VirtualChannelEntry");

    if( pEntryPoints->cbSize < sizeof(CHANNEL_ENTRY_POINTS_EX) ) {

        //
        // we don't have all entry points we need.
        //
        goto exitpt;
    }

    pChanInitHandle = (PCHANNEL_INIT_HANDLE)pInitHandle;
    pRdpDrInitSettings = (PRDPDR_DATA)pChanInitHandle->lpInternalAddinParam;
    ASSERT(pRdpDrInitSettings);

    if(!pRdpDrInitSettings)
    {
        goto exitpt;
    }

    pcmMgr = new VCManager(pEntryPoints);
    pRdpDrInitSettings->pUpdateDeviceObj = pcmMgr;

    if( pcmMgr == NULL ) {
        goto exitpt;
    }

    pcmMgr->SetInitData( pRdpDrInitSettings);
    
    pClip = new CClip(pcmMgr);

    if( pClip == NULL ) {
        goto exitpt;
    }

    pcmMgr->SetClip( pClip);
    pClip->SetVCInitHandle( pInitHandle);

    pSound = new CRDPSound( pEntryPoints, pInitHandle );
    if ( NULL == pSound ) {
        goto exitpt;
    }
    pcmMgr->SetSound( pSound );

    if (!pClip->ClipChannelEntry(pEntryPoints)) {
        TRC_ALT((TB, _T("Clip rejected VirtualChannelEntry")));
        goto exitpt;
    }

    memset(aChannel[0].name, 0, CHANNEL_NAME_LEN);
    memcpy(aChannel[0].name, PRDR_VC_CHANNEL_NAME, strlen(PRDR_VC_CHANNEL_NAME));

    aChannel[0].options = CHANNEL_OPTION_COMPRESS_RDP;

    memset(aChannel[1].name, 0, CHANNEL_NAME_LEN);
    memcpy(aChannel[1].name, CLIP_CHANNEL, sizeof(CLIP_CHANNEL));
    aChannel[1].options = CHANNEL_OPTION_ENCRYPT_RDP |
                          CHANNEL_OPTION_COMPRESS_RDP |
                          CHANNEL_OPTION_SHOW_PROTOCOL;

    memset( aChannel[2].name, 0, CHANNEL_NAME_LEN );
    memcpy( aChannel[2].name, _SNDVC_NAME, sizeof( _SNDVC_NAME ));
    aChannel[2].options = CHANNEL_OPTION_ENCRYPT_RDP;

    uiRet = (pEntryPoints->pVirtualChannelInitEx)(pcmMgr, 
                 pInitHandle,
                 aChannel,
                 3,
                 VIRTUAL_CHANNEL_VERSION_WIN2000,
                 RDPDR_InitEventFnEx);

    TRC_NRM((TB, _T("VirtualChannelInit rc[%d]"), uiRet));

    if( uiRet != CHANNEL_RC_OK ) {
        goto exitpt;
    }

    rv = TRUE;

exitpt:
    if ( !rv )
    {
        if ( NULL != pClip )
            delete pClip;

        if ( NULL != pSound )
            delete pSound;

        if ( NULL != pcmMgr )
            delete pcmMgr;
    }

    DC_END_FN();

    return(rv);
}

/* ----------------------------------------------------------------*/

VCManager::VCManager(
    IN PCHANNEL_ENTRY_POINTS_EX pEntries
    )
/*++

Routine Description:

    Initilizes the system, and determines which processor to load for
    the given operating system.

Arguments:

    Id - Connection Id

Return Value:

    None

 --*/

{
    DC_BEGIN_FN("VCManager::VCManager");

    _bState = STATE_UNKNOWN;
    _ChannelEntries = *pEntries;

    _pProcObj = NULL;
    _hVCHandle = NULL;
    _Buffer.uiLength = _Buffer.uiAvailLen = 0;
    _Buffer.pbData = NULL;
    _hVCOpenHandle = 0;
    
    //_pRdpDrInitSettings receives settings from the core
    _pRdpDrInitSettings = NULL;
    

    DC_END_FN();
}

VOID
VCManager::ChannelWrite(
    IN LPVOID pData,
    IN UINT uiLength
    )
/*++

Routine Description:

    Abstracts writing data to the channel for the processing components

    If the write should fail, this function releases the outgoing buffer.

Arguments:

    pData - Data to be written
    uiLength - Length of data to write

Return Value:

    None

 --*/
{
    DC_BEGIN_FN("VCManager::ChannelWrite");
    TRC_NRM((TB, _T("Data[%p] Length[%d]"), pData, uiLength));

#if DBG
    if( !IsValidHeader(pData) ) {
        TRC_ERR((TB, _T("Sending an invalid dr header")));
    }
#endif // DBG

    UINT uiRet;

    uiRet = (_ChannelEntries.pVirtualChannelWriteEx)( _hVCHandle,
                                                      _hVCOpenHandle,
                                                      pData,
                                                      uiLength,
                                                      (PVOID)pData);

    TRC_NRM((TB, _T("VirtualChannelWrite Ret [%d]"), uiRet));

    switch (uiRet) {
    case CHANNEL_RC_OK:
        break;

    case CHANNEL_RC_NOT_INITIALIZED:
        ASSERT(FALSE);
        break;

    case CHANNEL_RC_NOT_CONNECTED:
        {
            //Valid to receive this because we can be getting
            //disconnected on another thread
            TRC_ALT((TB,_T("Write failed with CHANNEL_RC_NOT_CONNECTED")));
        }
        break;

    case CHANNEL_RC_BAD_CHANNEL_HANDLE:
        ASSERT(FALSE);
        break;

    case CHANNEL_RC_NULL_DATA:
        ASSERT(FALSE);
        break;

    case CHANNEL_RC_ZERO_LENGTH:
        ASSERT(FALSE);
        break;

    default:
        TRC_ALT((TB, _T("Unknown return value for VirtualChannelWrite[%d]\n"), uiRet));
        break;
    }

    //
    //	Release the buffer on failure.
    //
    if (uiRet != CHANNEL_RC_OK) {
	    delete []((BYTE *)pData);	
    }

    DC_END_FN();
    return;
}

UINT
VCManager::ChannelWriteEx(
    IN LPVOID pData,
    IN UINT uiLength
    )
/*++

Routine Description:

    Abstracts writing data to the channel for the processing components.
    This version returns the return value back 

    If this function fails the buffer is released.

Arguments:

    pData - Data to be written
    uiLength - Length of data to write

Return Value:

    CHANNEL_RC_OK
    CHANNEL_RC_NOT_INITIALIZED
    CHANNEL_RC_NOT_CONNECTED
    CHANNEL_RC_BAD_CHANNEL_HANDLE
    CHANNEL_RC_NULL_DATA
    CHANNEL_RC_ZERO_LENGTH

 --*/
{
    DC_BEGIN_FN("VCManager::ChannelWriteEx");
    TRC_NRM((TB, _T("Data[%p] Length[%d]"), pData, uiLength));

#if DBG
    if( !IsValidHeader(pData) ) {
        TRC_ERR((TB, _T("Sending an invalid dr header")));
    }
#endif // DBG

    UINT uiRet;

    uiRet = (_ChannelEntries.pVirtualChannelWriteEx)( _hVCHandle,
                                                      _hVCOpenHandle,
                                                      pData,
                                                      uiLength,
                                                      (PVOID)pData);

    if (uiRet != CHANNEL_RC_OK) {
	TRC_NRM((TB, _T("VirtualChannelWrite Ret [%d]"), uiRet));
	    delete []((BYTE *)pData);	
    }

    return uiRet;
}

/*++

Routine Description:

    Closes the virtual channel

Arguments:

    None

Return Value:

    CHANNEL_RC_OK on Success - see VirtualChannelClose docs in MSDN

 --*/
UINT
VCManager::ChannelClose()
{
    UINT uiRet;

    DC_BEGIN_FN("ChannelClose");

    uiRet = (_ChannelEntries.pVirtualChannelCloseEx)( _hVCHandle,
                                                      _hVCOpenHandle);

    if (uiRet != CHANNEL_RC_OK) {
	    TRC_ERR((TB, _T("VirtualChannelClose Ret [%d]"), uiRet));
    }

    DC_END_FN();
    return uiRet;
}

VOID
VCManager::ChannelInitEvent(
    IN PVOID pInitHandle,
    IN UINT  uiEvent,
    IN PVOID pData,
    IN UINT  uiDataLength
    )
/*++

Routine Description:

    Handles InitEvent callbacks

Arguments:

    pInitHandle - a handle uniquely identifying this connection

    uiEvent - the event that has occurred - see CHANNEL_EVENT_XXX defines

    pData - data associated with the event - see CHANNEL_EVENT_XXX defines

    uiDataLength - length of the data.

Return Value:

    None

 --*/

{
    DC_BEGIN_FN("VCManager::ChannelInitEvent");
    
    UNREFERENCED_PARAMETER( pData );
    UNREFERENCED_PARAMETER( uiDataLength );

    UINT uiRetVal;

    TRC_NRM((TB, _T("Event %d, handle %p"), uiEvent, pInitHandle));

    if (_hVCHandle == NULL)
        _hVCHandle = pInitHandle;

    switch (uiEvent) {
    case CHANNEL_EVENT_INITIALIZED :

        ASSERT(_bState == STATE_UNKNOWN);

        _bState = CHANNEL_EVENT_INITIALIZED;
        break;

    case CHANNEL_EVENT_CONNECTED :

        ASSERT((_bState == CHANNEL_EVENT_INITIALIZED) ||
                    (_bState == CHANNEL_EVENT_DISCONNECTED));

        //
        //  Create the platform-specific Processing instance
        //
        TRC_NRM((TB, _T("VCManager::ChannelnitEvent: Creating processor.")));
        _pProcObj = ProcObj::Instantiate(this);

        if( _pProcObj == NULL ) {
            TRC_NRM((TB, _T("Error creating processor.")));
            return;
        }

        //
        //  Initialize the proc obj instance
        //
        uiRetVal = (UINT) _pProcObj->Initialize();

        if( uiRetVal != ERROR_SUCCESS ) {
            delete _pProcObj;
            _pProcObj = NULL;
            return;
        }

        //
        //  Open the virtual channel interface.
        //
        uiRetVal =
            (_ChannelEntries.pVirtualChannelOpenEx)(
                _hVCHandle,
                &_hVCOpenHandle,
                PRDR_VC_CHANNEL_NAME,
                &RDPDR_OpenEventFn);

        TRC_NRM((TB, _T("VirtualChannelOpen Ret[%d]"), uiRetVal));

        _bState = CHANNEL_EVENT_CONNECTED;

        break;

    case CHANNEL_EVENT_V1_CONNECTED :
        ASSERT((_bState == CHANNEL_EVENT_INITIALIZED) ||
                  (_bState == CHANNEL_EVENT_DISCONNECTED));

        _bState = CHANNEL_EVENT_V1_CONNECTED;
        break;

    case CHANNEL_EVENT_DISCONNECTED :
        //ASSERT((_bState == CHANNEL_EVENT_CONNECTED) ||
        //           (_bState == CHANNEL_EVENT_V1_CONNECTED));

        if (_pProcObj) {
            delete _pProcObj;
            _pProcObj = NULL;
        }

        _bState = CHANNEL_EVENT_DISCONNECTED;
        break;

    case CHANNEL_EVENT_TERMINATED :
        /*
        DbgAssert((_bState == CHANNEL_EVENT_DISCONNECTED) ||
                  (_bState == CHANNEL_EVENT_V1_CONNECTED) ||
                  (_bState == CHANNEL_EVENT_INITIALIZED),
            ("_bState[%d] is in inproper position to be TERMINATED",
             _bState));
        */             

        if (_pProcObj) {
            delete _pProcObj;
            _pProcObj = NULL;
        }

        _bState = CHANNEL_EVENT_TERMINATED;

        break;

    default:

        TRC_ALT((TB, _T("Unknown Event in ChannelInitEvent recieved[%d]\n"),
             uiEvent));

        break;
    }

    DC_END_FN();
    return;
}

VOID
VCManager::ChannelOpenEvent(
    IN ULONG ulOpenHandle,
    IN UINT uiEvent,
    IN PVOID pData,
    IN UINT32 uiDataLength,
    IN UINT32 uiTotalLength,
    IN UINT32 uiDataFlags
    )
/*++

Routine Description:

    Handles OpenEvent callbacks

Arguments:

    ulOpenHandle - a handle uniquely identifying this channel
    uiEvent - event that has occurred - see CHANNEL_EVENT_XXX below
    pData - data received
    uiDataLength - length of the data
    uiTotalLength - total length of data written by the Server
    uiDataFlags - flags, zero, one or more of:
    - 0x01 - beginning of data from a single write operation at the Server
    - 0x02 - end of data from a single write operation at the Server.

Return Value:

    None

 --*/
{
    DC_BEGIN_FN("VCManager::ChannelOpenEvent");

    TRC_NRM((TB, _T("Event[0x%x], uiDataLength[%ld], uiDataFlags[0x%lx]"),
        uiEvent, uiDataLength, uiDataFlags));

    ASSERT(ulOpenHandle == _hVCOpenHandle);

    //
    // not for us, simply return.
    //

    if( ulOpenHandle != _hVCOpenHandle ) {
        return;
    }

    ASSERT(uiDataLength <= uiTotalLength);

    //
    // total length much less, give up.
    //

    if( uiDataLength > uiTotalLength ) {
        return;
    }

    //
    // free data buffer on write complete.
    //

    if ((uiEvent == CHANNEL_EVENT_WRITE_COMPLETE) ||
        (uiEvent == CHANNEL_EVENT_WRITE_CANCELLED)) {

        delete []((BYTE *)pData);
        TRC_NRM((TB, _T("VCManager::ChannelOpenEvent:S:WriteComplete")));
        return;
    }

    ASSERT(uiEvent == CHANNEL_EVENT_DATA_RECEIVED);

    //
    // alocated new buffer for incoming data.
    //

    if( (uiDataFlags == CHANNEL_FLAG_FIRST) ||
        (uiDataFlags == CHANNEL_FLAG_ONLY) ) {

        TRC_NRM((TB, _T("Allocating %ld bytes"), uiTotalLength));

        _Buffer.pbData = new BYTE[uiTotalLength];

        if( _Buffer.pbData == NULL ) {
            TRC_ERR((TB,_T("_Buffer.pbData is NULL")));
            return;
        }

        _Buffer.uiLength = 0;
        _Buffer.uiAvailLen = uiTotalLength;
    }

    if( _Buffer.pbData == NULL ) {
        TRC_ERR((TB,_T("_Buffer.pbData is NULL")));
        return;
    }

    //
    // copy first part of the data in the buffer.
    //

    if (uiDataFlags == CHANNEL_FLAG_FIRST) {

        TRC_NRM((TB, _T("CHANNEL_FLAG_FIRST Creating:[%ld]"), uiTotalLength));

        memcpy(_Buffer.pbData, pData, uiDataLength);
        _Buffer.uiLength = uiDataLength;

        TRC_NRM((TB, _T("VCManager::ChannelOpenEvent[1]")));
        return;
    }

    //
    // add data to the buffer.
    //

    UINT32 uiLen;
    uiLen = _Buffer.uiLength + uiDataLength;
    ASSERT(_Buffer.uiAvailLen >= uiLen);

    //
    // too much data arrived.
    //

    if( _Buffer.uiAvailLen < uiLen ) {
        TRC_ERR((TB,_T("Too much data arrived: avail:0x%x arrived:0x%x"),
                 _Buffer.uiAvailLen, uiLen));

        //
        // Disconnect the channel
        //
        ChannelClose();
        return;
    }

    memcpy( _Buffer.pbData + _Buffer.uiLength, pData, uiDataLength );
    _Buffer.uiLength = uiLen;

    if (uiDataFlags == CHANNEL_FLAG_MIDDLE) {
        TRC_NRM((TB, _T("VCManager::ChannelOpenEvent[2]")));
        return;
    }

    //
    // complete data buffer available, process it.
    //

    _pProcObj->ProcessServerPacket(&_Buffer);

    DC_END_FN();
    return;
}

void
VCManager::OnDeviceChange(WPARAM wParam, LPARAM lParam)
/*++

Routine Description:

    Receive a device change notification from the control.
    Pass it to the proc obj to handle.

Arguments:

Return Value:

    None.

 --*/

{
    if (_pProcObj != NULL) {
        _pProcObj->OnDeviceChange(wParam, lParam);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\w32draut.cpp ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    w32draut

Abstract:

    This module defines a special subclass of the Win32 client-side RDP
    printer redirection "device" class.  The subclass, W32DrAutoPrn manages
    a queue that is automatically discovered by the client via enumerating
    client-side printer queues.

Author:

    Tad Brockway 3/23/99

Revision History:

--*/

#include <precom.h>

#define TRC_FILE  "W32DrAut"

#include "regapi.h"
#include "w32draut.h"
#include "proc.h"
#include "drdbg.h"
#include "w32utl.h"
#include "utl.h"


///////////////////////////////////////////////////////////////
//
//	Defines
//

#define COM_PORT_NAME               _T("COM")
#define COM_PORT_NAMELEN            3
#define LPT_PORT_NAME               _T("LPT")
#define LPT_PORT_NAMELEN            3
#define USB_PORT_NAME               _T("USB")
#define USB_PORT_NAMELEN            3
#define RDP_PORT_NAME               _T("TS")
#define RDP_PORT_NAMELEN            2


///////////////////////////////////////////////////////////////
//
//	W32DrAutoPrn Members
//

W32DrAutoPrn::W32DrAutoPrn(
    IN ProcObj *processObject,
    IN const DRSTRING printerName, 
    IN const DRSTRING driverName,
    IN const DRSTRING portName, 
    IN BOOL  isDefault, 
    IN ULONG deviceID,
    IN const TCHAR *devicePath
    ) : W32DrPRN(processObject, printerName, driverName, 
                portName, NULL, isDefault, deviceID, devicePath)
/*++

Routine Description:

    Constructor

Arguments:

    processObject   -   Associated Process Object.
    printerName     -   Name of automatic printer queue.
    driverName      -   Print Driver Name
    portName        -   Client Port Name
    isDefault       -   Is this the default printer?
    deviceID        -   Unique Device Identifier
    devicePath      -   Path to pass to OpenPrinter when opening the
                        device.

Return Value:

    NA

 --*/
{
    DC_BEGIN_FN("W32DrAutoPrn");
    _jobID = 0;
    _printerHandle = INVALID_HANDLE_VALUE;
    memset(_szLocalPrintingDocName, 0, sizeof(_szLocalPrintingDocName));

    ASSERT(processObject);
    PRDPDR_DATA prdpdrData = processObject->GetVCMgr().GetInitData();
    ASSERT(prdpdrData);

    LPTSTR szDocName = prdpdrData->szLocalPrintingDocName;
    ASSERT(szDocName);
    ASSERT(szDocName[0] != 0);
    _tcsncpy(_szLocalPrintingDocName, szDocName,
             sizeof(_szLocalPrintingDocName)/sizeof(TCHAR));

    OSVERSIONINFO osVersion;
    osVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    _bRunningOn9x = TRUE;
    if (GetVersionEx(&osVersion)) {
        if (osVersion.dwPlatformId == VER_PLATFORM_WIN32_NT) {
            _bRunningOn9x = FALSE;
        }
    }
    else
    {
        TRC_ERR((TB, _T("GetVersionEx:  %08X"), GetLastError()));
    }
    DC_END_FN();
}

W32DrAutoPrn::~W32DrAutoPrn() 
/*++

Routine Description:

    Destructor

Arguments:

    NA

Return Value:

    NA

 --*/
{
    //
    //  Make sure all docs are finished and the printer handle closed.
    //
    ClosePrinter();
}

BOOL 
W32DrAutoPrn::ShouldAddThisPrinter( 
    DWORD queueFilter, 
    DWORD userSessionID,
    PPRINTERINFO pPrinterInfo,
    DWORD printerSessionID
    )
/*++

Routine Description:

    Detemine if we should redirect this printer.

Arguments:

    queueFilter         - redirect printer filter type.
    userSessionID       - current user session ID.
    pPrinterInfo        - printer info
    printerSessionID    - Printer session ID or INVALID_SESSIONID if printers
                          is not a TS printer.

Return Value:

    TRUE to add printer, FALSE otherwise

--*/
{
    BOOL fAddThisPrinter = FALSE;
    DWORD sessionID;

    DC_BEGIN_FN("W32DrAutoPrn::AddThisPrinter");

    //
    //  Check filters.  
    //
    if (queueFilter == FILTER_ALL_QUEUES ) {
        fAddThisPrinter = TRUE;
    }
    else if ((queueFilter & FILTER_NET_QUEUES) && 
        (pPrinterInfo->Attributes & PRINTER_ATTRIBUTE_NETWORK)) {
        fAddThisPrinter = TRUE;
    }

    //
    //  If it's a non-network printer then get the port name.
    //

    else if((queueFilter & FILTER_LPT_QUEUES) &&
        (_tcsnicmp(
            pPrinterInfo->pPortName,
            LPT_PORT_NAME,
            LPT_PORT_NAMELEN) == 0) ) {
        fAddThisPrinter = TRUE;
    }
    else if ((queueFilter & FILTER_COM_QUEUES) &&
        (_tcsnicmp(
            pPrinterInfo->pPortName,
            COM_PORT_NAME,
            COM_PORT_NAMELEN) == 0) ) {
        fAddThisPrinter = TRUE;
    }
    else if ((queueFilter & FILTER_USB_QUEUES) &&
        (_tcsnicmp(
            pPrinterInfo->pPortName,
            USB_PORT_NAME,
            USB_PORT_NAMELEN) == 0) ) {
        fAddThisPrinter = TRUE;
    }
    else if ((queueFilter & FILTER_RDP_QUEUES) &&
        (_tcsnicmp(
            pPrinterInfo->pPortName,
            RDP_PORT_NAME,
            RDP_PORT_NAMELEN) == 0) ) {
        fAddThisPrinter = TRUE;
    }

    if ((TRUE == fAddThisPrinter) && 
        (userSessionID != INVALID_SESSIONID) &&
        (printerSessionID != INVALID_SESSIONID)) {

        //
        // Compare this with our session ID
        //
        if( printerSessionID != userSessionID ) {
        
            // this printer is from different session,
            // don't redirect it.
            fAddThisPrinter = FALSE;
        }
    }

    DC_END_FN();
    return fAddThisPrinter;
}

LPTSTR 
W32DrAutoPrn::GetRDPDefaultPrinter()
/*++

Routine Description:

	Get the printer name of the default printer.

	This function allocates memory and returns a pointer
	to the allocated string, if successful. Otherwise, it returns NULL.

Arguments:

    NA

Return Value:

    The default printer name.  The caller has to free the memory.

 --*/
{
    TCHAR* szIniEntry = NULL;
    LPTSTR pPrinterName = NULL;

    DC_BEGIN_FN("DrPRN::GetRDPDefaultPrinter");

    szIniEntry = new TCHAR[ MAX_DEF_PRINTER_ENTRY ];

    if( NULL == szIniEntry )
    {
      TRC_ERR((TB, _T("Memory allocation failed:%ld."),
                        GetLastError()));
      goto Cleanup;
    }

    szIniEntry[0] = _T('\0');

    //
    //  Get the default printer key from the win.ini file.
    //
    DWORD dwResult = GetProfileString(_T("windows"),
                        _T("device"),
                        _T(""),
                        szIniEntry,
                        MAX_DEF_PRINTER_ENTRY);
    if (dwResult && szIniEntry[0]) {
        //  
        //  Get the printer name.  The device value is of the form
        //  <printer name>,<driver name>,<port>
        //
        TCHAR *pComma = _tcschr( szIniEntry, _T(','));
        if( pComma ) {

            *pComma = _T('\0');
            UINT cchLen = _tcslen( szIniEntry ) + 1;

            pPrinterName = new TCHAR [cchLen];
            if (pPrinterName) {
                StringCchCopy(pPrinterName, cchLen, szIniEntry); 
                TRC_NRM((TB, _T("Def. is: %s"), pPrinterName));
            }
            else {
                TRC_ERR((TB, _T("Memory allocation failed:%ld."),
                        GetLastError()));
            }
        }
        else {
            TRC_ERR((TB, _T("Invalid device entry in win.ini.")));
        }
    }
    else {
        TRC_NRM((TB, _T("Device entry not found in win.ini.")));
    }
Cleanup:
    DC_END_FN();
    delete[] szIniEntry;
    return pPrinterName;
}

DWORD 
W32DrAutoPrn::GetPrinterInfoAndSessionID(
    IN ProcObj *procObj,                                                
    IN LPTSTR printerName, 
    IN DWORD printerAttribs,
    IN OUT BYTE **pPrinterInfoBuf,
    IN OUT DWORD *pPrinterInfoBufSize,
    OUT DWORD *sessionID,
    OUT PPRINTERINFO printerInfo
    )
/*++

Routine Description:

    Get printer info for a printer and its corresponding TS session ID,
    if it exists.

Arguments:

    procObj              -  Active Proc Obj
    printerName          -  Name of printer.
    printerAttribs       -  Printer Attribs      
    pPrinterInfoBuf      -  This function may resize this buffer.
    pPrinterInfoBufsSize -  Current size of the pPrinterInfo2 buf.
    sessionID            -  TS session ID, if applicable.  Otherwise INVALID_SESSIONID.
    printerInfo          -  Printer information is returned here.  We avoid
                            pulling in level 2 info if possible.  Fields in this data
                            structure should not be free'd.

Return Value:

    ERROR_SUCCESS on success.  Otherwise, an error status is returned.

--*/
{
    HANDLE hPrinter = NULL;
    DWORD status = ERROR_SUCCESS;
    DWORD bytesRequired;
    DWORD type;
    DWORD cbNeeded; 
    DWORD ret;

    DC_BEGIN_FN("W32DrAutoPrn::GetPrinterInfoAndSessionID");

    //
    //  No unicode wrappers for GetPrinter on 9x.
    //  
    ASSERT(!procObj->Is9x());

    // 
    //  Get a printer handle
    //
    if (!OpenPrinter(printerName, &hPrinter, NULL)) {
        status = GetLastError();
        TRC_ALT((TB, L"OpenPrinter:  %ld", status));
        goto CLEANUPANDEXIT;
    }

    //
    //  Check the proc obj shutdown state since we just left an RPC call.
    //
    if (procObj->IsShuttingDown()) {
        status = ERROR_SHUTDOWN_IN_PROGRESS;
        TRC_ALT((TB, _T("Bailing out of printer enumeration because of shutdown.")));
        goto CLEANUPANDEXIT;
    }

    //
    //  If the printer is a network printer then we try to avoid hitting the
    //  network for additional info.  For a non-network printer, we need info level 2
    //  for info about the port.
    //  
    if (printerAttribs & PRINTER_ATTRIBUTE_NETWORK) {

        //
        //  Just need the driver name.
        //
        if (!GetPrinterDriver(hPrinter, NULL, 1, *pPrinterInfoBuf, 
                            *pPrinterInfoBufSize, &bytesRequired)) {

            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
    
                *pPrinterInfoBuf = (PBYTE)new BYTE[bytesRequired];
                if (*pPrinterInfoBuf == NULL) {
                    TRC_ERR((TB, L"Failed to allocate printer driver info"));
                    *pPrinterInfoBufSize = 0;
                    status = ERROR_INSUFFICIENT_BUFFER;
                    goto CLEANUPANDEXIT;
                }
                else {
                    *pPrinterInfoBufSize = bytesRequired;
                }
            }

            if (!GetPrinterDriver(hPrinter, NULL, 1, *pPrinterInfoBuf, 
                            *pPrinterInfoBufSize, &bytesRequired)) {
                status = GetLastError();
                TRC_ERR((TB, _T("GetPrinter:  %08X"), status));
                goto CLEANUPANDEXIT;
            }
        }
        PDRIVER_INFO_1 p1 = (PDRIVER_INFO_1)*pPrinterInfoBuf;
        printerInfo->pPrinterName   =   printerName;
        printerInfo->pPortName      =   NULL;   
        printerInfo->pDriverName    =   p1->pName; 
        printerInfo->Attributes     =   printerAttribs;  
    }
    else {

        if (!GetPrinter(hPrinter, 2, *pPrinterInfoBuf, 
                    *pPrinterInfoBufSize, &bytesRequired)) {

            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
    
                *pPrinterInfoBuf = (PBYTE)new BYTE[bytesRequired];
                if (*pPrinterInfoBuf == NULL) {
                    TRC_ERR((TB, L"Failed to allocate printer info 2"));
                    *pPrinterInfoBufSize = 0;
                    status = ERROR_INSUFFICIENT_BUFFER;
                    goto CLEANUPANDEXIT;
                }
                else {
                    *pPrinterInfoBufSize = bytesRequired;
                }

                if (!GetPrinter(hPrinter, 2, *pPrinterInfoBuf,
                    *pPrinterInfoBufSize, &bytesRequired)) {
                    status = GetLastError();
                    TRC_ERR((TB, _T("GetPrinter:  %08X"), status));
                    goto CLEANUPANDEXIT;
                }
            }
            else {
                status = GetLastError();
                TRC_ERR((TB, _T("GetPrinter:  %08X"), status));
                goto CLEANUPANDEXIT;
            }
        }
        PPRINTER_INFO_2 p2 = (PPRINTER_INFO_2)*pPrinterInfoBuf;
        printerInfo->pPrinterName   =   p2->pPrinterName;
        printerInfo->pPortName      =   p2->pPortName;   
        printerInfo->pDriverName    =   p2->pDriverName; 
        printerInfo->Attributes     =   p2->Attributes;  
    }

    //
    //  Check the proc obj shutdown state since we just left an RPC call.
    //
    if (procObj->IsShuttingDown()) {
        status = ERROR_SHUTDOWN_IN_PROGRESS;
        TRC_ALT((TB, _T("Bailing out of printer enumeration because of shutdown.")));
        goto CLEANUPANDEXIT;
    }

    //
    //  Get the session ID, if it exists.
    //
    ret = GetPrinterData(
                        hPrinter, 
                        DEVICERDR_SESSIONID, 
                        &type,
                        (PBYTE)sessionID,
                        sizeof(DWORD),
                        &cbNeeded
                        );
    if (ret != ERROR_SUCCESS || type != REG_DWORD) {
        *sessionID = INVALID_SESSIONID;
    }

CLEANUPANDEXIT:

    if (hPrinter != NULL) {
        ::ClosePrinter(hPrinter);
    }

    DC_END_FN();
    return status;
}


DWORD 
W32DrAutoPrn::Enumerate(
    IN ProcObj *procObj, 
    IN DrDeviceMgr *deviceMgr
    )
{
    ULONG ulBufSizeNeeded;
    ULONG ulNumStructs;
    ULONG i;
    LPTSTR szDefaultPrinter = NULL;
    PRINTER_INFO_4 *pPrinterInfo4Buf = NULL;
    DWORD pPrinterInfo4BufSize = 0;
    PBYTE pPrinterInfoBuf = NULL;
    DWORD pPrinterInfoBufSize = 0;
    W32DrPRN *prnDevice = NULL;
    DWORD result = ERROR_SUCCESS;
    DWORD queueFilter;
    LPTSTR friendlyName = NULL;
    LPTSTR pName;
    DWORD userSessionID;
    DWORD printerSessionID;
    BOOL ret;
    PRINTERINFO currentPrinter;
    HRESULT hr;

    DC_BEGIN_FN("W32DrAutoPrn::Enumerate");

    if(!procObj->GetVCMgr().GetInitData()->fEnableRedirectPrinters)
    {
        TRC_DBG((TB,_T("Printer redirection disabled, bailing out")));
        return ERROR_SUCCESS;
    }

    queueFilter = GetPrinterFilterMask(procObj);

    //
    //  Get the size of the printer buffer required to enumerate.
    //
    if (!procObj->Is9x()) {
        //
        //  Level 2 can hang on NT if a network print server is down.
        //
        ret = EnumPrinters(
                PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS, 
                NULL, 4, NULL, 0, 
                &ulBufSizeNeeded, &ulNumStructs
                );
    }
    else {
        //
        //  Level 4 is not supported on 9x and level 2 doesn't hang anyway.  
        //
        //  !!!!Note!!!!
        //  For 9x the Unicode wrapper function, EnumPrintersWrapW takes over.
        //  Also, note that level 2 is partially supported.
        //
        ret = EnumPrinters(
                PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS, 
                NULL, 2, NULL, 0, 
                &ulBufSizeNeeded, &ulNumStructs
                );
    }
    if (!ret && (result = GetLastError()) != ERROR_INSUFFICIENT_BUFFER) {

        TRC_ERR((TB, _T("EnumPrinter failed:  %ld."), 
                result));
        goto Cleanup;
    }


    //
    //  Check the proc obj shutdown state since we just left an RPC call.
    //
    if (procObj->IsShuttingDown()) {
        TRC_ALT((TB, _T("Bailing out of printer enumeration because of shutdown.")));
        goto Cleanup;
    }

    //
    //  Allocate the printer enumeration buffer.
    //
    if (!procObj->Is9x()) {
        pPrinterInfo4Buf = (PRINTER_INFO_4 *)(new BYTE[ulBufSizeNeeded]);
        if (pPrinterInfo4Buf == NULL) {
            TRC_ERR((TB, _T("Alloc failed.")));
            result = ERROR_INSUFFICIENT_BUFFER;
            goto Cleanup;
        }
        else {
            pPrinterInfo4BufSize = ulBufSizeNeeded;
        }
    }
    else {
        pPrinterInfoBuf = (PBYTE)(new BYTE[ulBufSizeNeeded]);
        if (pPrinterInfoBuf == NULL) {
            TRC_ERR((TB, _T("Alloc failed.")));
            result = ERROR_INSUFFICIENT_BUFFER;
            goto Cleanup;
        }
        else {
            pPrinterInfoBufSize = ulBufSizeNeeded;
        }
    }

    //
    //  Get the printers.
    //
    if (!procObj->Is9x()) {
        ret = EnumPrinters(
                PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS,
                NULL,
                4,
                (PBYTE)pPrinterInfo4Buf,
                pPrinterInfo4BufSize,
                &ulBufSizeNeeded,
                &ulNumStructs);
    }
    else {
        //
        //  !!!!Note!!!!
        //  For 9x the Unicode wrapper function, EnumPrintersWrapW takes over.
        //  Also, note that level 2 is only partially supported.
        //
        ret = EnumPrinters(
                PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS,
                NULL,
                2,
                (PBYTE)pPrinterInfoBuf,
                pPrinterInfoBufSize,
                &ulBufSizeNeeded,
                &ulNumStructs);
    }
    if (!ret) {
        result = GetLastError();
        TRC_ALT((TB, _T("EnumPrinter failed, %ld."), 
            result));
        goto Cleanup;
    }

    //
    //  Check the proc obj shutdown state since we just left an RPC call.
    //
    if (procObj->IsShuttingDown()) {
        TRC_ALT((TB, _T("Bailing out of printer enumeration because of shutdown.")));
        goto Cleanup;
    }

    //
    //  Trace the results of EnumPrinters.
    //
    TRC_NRM((TB, _T("Number of Printers found, %ld."), 
            ulNumStructs));

    //
    //  Get the name of the current default printer.
    //
    szDefaultPrinter = GetRDPDefaultPrinter();

    //
    //  Get User Session ID
    //
    userSessionID = GetUserSessionID();

    //
    //  Iterate through the results of EnumPrinters and add each printer to the
    //  device manager that passes the printer adding filter.
    //
    for (i = 0; i < ulNumStructs; i++) {

        if (friendlyName != NULL) {
            delete friendlyName;
            friendlyName = NULL;
        }

        //
        //  Get info for the printer and its corresponding TS session ID,
        //  if it exists.
        //
        if (!procObj->Is9x()) {

            if (GetPrinterInfoAndSessionID(
                    procObj,
                    pPrinterInfo4Buf[i].pPrinterName,
                    pPrinterInfo4Buf[i].Attributes,
                    &pPrinterInfoBuf,
                    &pPrinterInfoBufSize,
                    &printerSessionID,
                    &currentPrinter
                    ) != ERROR_SUCCESS) {
                continue;
            }
        }
        else {
            PPRINTER_INFO_2 p2;
            p2 = (PPRINTER_INFO_2)pPrinterInfoBuf;

            if (p2 != NULL) {
                currentPrinter.pPrinterName = p2[i].pPrinterName;
                currentPrinter.pPortName    = p2[i].pPortName;
                currentPrinter.pDriverName  = p2[i].pDriverName;
                currentPrinter.Attributes   = p2[i].Attributes;
            }

            printerSessionID = INVALID_SESSIONID;
        }


        //
        //  Check the proc obj shutdown state since we just left an RPC call.
        //
        if (procObj->IsShuttingDown()) {
            TRC_ALT((TB, _T("Bailing out of printer enumeration because of shutdown.")));
            goto Cleanup;
        }

        if( FALSE == ShouldAddThisPrinter( queueFilter, userSessionID, &currentPrinter,
                                            printerSessionID) ) {
            continue;
        }

        TCHAR UniquePortName[MAX_PATH];
        ULONG DeviceId;

        //
        //  Is this one the default queue.
        //
        BOOL fDefault = ((szDefaultPrinter) && (currentPrinter.pPrinterName) &&
                        (_tcsicmp(szDefaultPrinter, currentPrinter.pPrinterName) == 0));

        //
        //  Generate a "friendly" name if this is a network
        //  queue.
        //
        BOOL fNetwork = FALSE, fTSqueue = FALSE;
        RDPDR_VERSION serverVer;

        serverVer = procObj->serverVersion();

        // 4 is minor version of post win2000
        if (COMPARE_VERSION(serverVer.Minor, serverVer.Major, 4, 1) < 0) {
            // the server is Win2000 or lower
            if (currentPrinter.Attributes & PRINTER_ATTRIBUTE_NETWORK) {
                friendlyName = CreateFriendlyNameFromNetworkName(
                                            currentPrinter.pPrinterName,
                                            TRUE
                                            );
                // We don't set the fNetwork flag for Win2K because it can't
                // do anything with it anyway.
            }
        } else {
            // the server is higher than Win2000

            // is it a network printer?
            if (currentPrinter.Attributes & PRINTER_ATTRIBUTE_NETWORK) {
                fNetwork = TRUE;
            }

            // is it a TS queue?
            if ((currentPrinter.pPortName != NULL) && 
                _tcsnicmp(currentPrinter.pPortName,
                          RDP_PORT_NAME,
                          RDP_PORT_NAMELEN) == 0) {
                fTSqueue = TRUE;
                friendlyName = CreateNestedName(currentPrinter.pPrinterName, &fNetwork);
                // should we set fNetwork and fTSqueue only in case of success?
            } else if (fNetwork) {

                friendlyName = CreateFriendlyNameFromNetworkName(
                                            currentPrinter.pPrinterName, FALSE
                                        );
            }
        }

        //
        //  Create a new printer device object.
        //
        pName = (friendlyName != NULL) ? friendlyName : currentPrinter.pPrinterName;
        
        DeviceId = deviceMgr->GetUniqueObjectID();

        // 
        //  The unique port name is going to be passed to the server
        //  as preferred dos name (max 7 characters long).  As we want to
        //  keep a unique dos name for each printer device, we need 
        //  to fake our own port name. e.g.
        //  For network printer, they share same port name if it's 
        //  same printer with different network printer names.  
        //  We use the format of PRN# as our unique port name
        
        hr = StringCchPrintf(UniquePortName,
                        SIZE_TCHARS(UniquePortName),
                        TEXT("PRN%ld"), DeviceId);
        if (FAILED(hr)) {
            TRC_ERR((TB,_T("Error copying portname :0x%x"),hr));
            result = ERROR_INSUFFICIENT_BUFFER;
            goto Cleanup;
        }
        UniquePortName[7] = TEXT('\0');

        prnDevice = new W32DrAutoPrn(
                            procObj,
                            pName,
                            currentPrinter.pDriverName,
                            UniquePortName,
                            fDefault,
                            DeviceId,
                            currentPrinter.pPrinterName
                            );

        //
        //  Add to the device manager if we got a valid object.
        //
        if (prnDevice != NULL) {

            prnDevice->SetNetwork(fNetwork);
            prnDevice->SetTSqueue(fTSqueue);
            prnDevice->Initialize();

            if (!(prnDevice->IsValid() && 
                 (deviceMgr->AddObject(prnDevice) == STATUS_SUCCESS))) {
                delete prnDevice;
            }
        }
        else {
            TRC_ERR((TB, _T("Failed to allocate W32DrPRN.")));
            result = ERROR_INSUFFICIENT_BUFFER;
            goto Cleanup;
        }
    }

Cleanup:

    //
    //  Release the "friendly" printer name.
    //
    if (friendlyName != NULL) {
        delete friendlyName;
    }
    
    //
    //  Release the default printer buffer.
    //
    if (szDefaultPrinter) {
        delete[] szDefaultPrinter;
    }

    //
    //  Release the level 4 printer enumeration buffer.
    //
    if (pPrinterInfo4Buf != NULL) {
        delete pPrinterInfo4Buf;
    }

    //
    //  Release the printer enumeration buffer.
    //
    if (pPrinterInfoBuf != NULL) {
        delete pPrinterInfoBuf;
    }

    DC_END_FN();

    return result;
}

LPTSTR 
W32DrAutoPrn::CreateNestedName(LPTSTR printerName, BOOL* pfNetwork)
/*++

Routine Description:

    Create a printer name from the names stored in the registry.

Arguments:

    printerName -   Name returned by EnumPrinters

Return Value:

    Nested name on success, that should be released by a call to
    delete.  NULL is returned on error.

 --*/
{
    DWORD printerNameLen;
    LPTSTR name = NULL;
    HANDLE hPrinter = NULL;
    DWORD i, cbNeeded, dwError;
    BOOL  fFail = TRUE;

    DC_BEGIN_FN("W32DrAutoPrn::CreateNestedName");


    if (OpenPrinter(printerName, &hPrinter, NULL)) {

        // In all cases the name will begin with "__"
        printerNameLen = 2;

        // try the Server name
        // WARNING: it returns ERROR_SUCCESS under Win9X if nSize = 0
        dwError = GetPrinterData(hPrinter, DEVICERDR_PRINT_SERVER_NAME, NULL, NULL, 0, &cbNeeded);
        if( (dwError == ERROR_MORE_DATA) || (dwError == ERROR_SUCCESS)) {
            printerNameLen += cbNeeded / sizeof(TCHAR);
            *pfNetwork = TRUE;
        } else {
            *pfNetwork = FALSE;
        }

        // try the Client name
        dwError = GetPrinterData(hPrinter, DEVICERDR_CLIENT_NAME, NULL, NULL, 0, &cbNeeded);
        if( (dwError == ERROR_MORE_DATA) || (dwError == ERROR_SUCCESS)) {
            printerNameLen += cbNeeded / sizeof(TCHAR);

            if (*pfNetwork) {
                // if there's already a print server name, add a '\'
                printerNameLen += 1;
            }
        } else if(!*pfNetwork) {
            // no print server, no client name, things are going bad...
            DC_QUIT;
        }

        // try the Printer name
        dwError = GetPrinterData(hPrinter, DEVICERDR_PRINTER_NAME, NULL, NULL, 0, &cbNeeded);
        if( (dwError == ERROR_MORE_DATA) || (dwError == ERROR_SUCCESS)) {
            // add also a '\'
            printerNameLen += 1 + cbNeeded / sizeof(TCHAR);
        } else {
            // no printer name
            DC_QUIT;
        }

        //
        //  Allocate space for the nested name.
        //
        name = new TCHAR[printerNameLen + 1];
        if (name == NULL) {

            TRC_ERR((TB, _T("Can't allocate %ld bytes for printer name."), printerNameLen));

        } else {

            name[0] = _T('!');
            name[1] = _T('!');
            i = 2;

            // try the Server name
            if (*pfNetwork) {
                if (ERROR_SUCCESS == GetPrinterData(hPrinter,
                                            DEVICERDR_PRINT_SERVER_NAME,
                                            NULL,
                                            (LPBYTE)(name + i),
                                            (printerNameLen - i) * sizeof(TCHAR),
                                            &cbNeeded)) {
                    i = _tcslen(name);
                    name[i++] = _T('!');

                } else {
                    // weird...
                    DC_QUIT;
                }
            }

            // try the Client name
            if (ERROR_SUCCESS == GetPrinterData(hPrinter,
                                            DEVICERDR_CLIENT_NAME,
                                            NULL,
                                            (LPBYTE)(name + i),
                                            (printerNameLen - i) * sizeof(TCHAR),
                                            &cbNeeded)) {
                i = _tcslen(name);
                name[i++] = _T('!');

            } else {

                if(!*pfNetwork) {
                    // no print server, no client name, things are going bad...
                    DC_QUIT;
                }            
            }

            // try the Printer name
            if (ERROR_SUCCESS == GetPrinterData(hPrinter,
                                            DEVICERDR_PRINTER_NAME,
                                            NULL,
                                            (LPBYTE)(name + i),
                                            (printerNameLen - i) * sizeof(TCHAR),
                                            &cbNeeded)) {
                fFail = FALSE;
            } else {
                DC_QUIT;
            }
        }

    }

DC_EXIT_POINT:

    if (hPrinter) {
        ::ClosePrinter(hPrinter);
    }

    if (fFail && name) {
        delete[] name;
        name = NULL;
    }

    DC_END_FN();

    return name;
}


LPTSTR 
W32DrAutoPrn::CreateFriendlyNameFromNetworkName(LPTSTR printerName,
                                                BOOL serverIsWin2K)
/*++

Routine Description:

    Create a "friendly" printer name from the printer name of a
    network printer.

Arguments:

    printerName     -   Name returned by EnumPrinters
    serverIsWin2K   -   For Win2K servers, we format the name as it will appear
                        on the server.  Whistler servers and beyond do the
                        formatting for us.

Return Value:

    Friendly name on success, that should be released by a call to
    delete.  NULL is returned on error.

 --*/
{
    DWORD printerNameLen;
    LPTSTR name;
    DWORD i;
    WCHAR replaceChar;

    DC_BEGIN_FN("W32DrAutoPrn::CreateFriendlyNameFromNetworkName");

    //
    //  The \ placeholder is '_' for Win2K because Win2K doesn't reformat
    //  printer names.  The '_' will actually be visible.
    //
    replaceChar = serverIsWin2K ? TEXT('_') : TEXT('!');

    //
    //  Get the length of the printer name.
    //
    printerNameLen = _tcslen(printerName);

    //
    //  Allocate space for ther "friendly" name.
    //
    name = new TCHAR[printerNameLen + 1];
    if (name == NULL) {
        TRC_ERR((TB, _T("Can't allocate %ld bytes for printer name."),
                printerNameLen));
    }

    //
    //  Copy and convert the name.
    //
    if (name != NULL) {
        for (i=0; i<printerNameLen; i++) {
            if (printerName[i] != TEXT('\\')) { 
                name[i] = printerName[i];
            }
            else {
                name[i] = replaceChar; 
            }
        }
        name[i] = TEXT('\0');
    }

    DC_END_FN();

    return name;
}

LPTSTR 
W32DrAutoPrn::GetLocalPrintingDocName()
/*++

Routine Description:

    Read Local printer Doc Name from the passed in struct

Arguments:

    NA

Return Value:

    Local Printer Document Name

 --*/
{
    DC_BEGIN_FN("W32DrAutoPrn::GetLocalPrintingDocName");

    DC_END_FN();
    return _szLocalPrintingDocName;
}

VOID W32DrAutoPrn::MsgIrpCreate(
    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
    IN UINT32 packetLen
    )
/*++

Routine Description:

    Handle a Create IRP from the server.

Arguments:

    params  -   Context for the IO request.

Return Value:

    NA

 --*/
{
    W32DRDEV_ASYNCIO_PARAMS *params = NULL;

    DWORD result = ERROR_SUCCESS;

    DC_BEGIN_FN("W32DrAutoPrn::MsgIrpCreate");

    params = new W32DRDEV_ASYNCIO_PARAMS(this, pIoRequestPacket);
    if (params != NULL) {
        params->thrPoolReq = _threadPool->SubmitRequest(
                                            _AsyncMsgIrpCreateFunc,
                                            params, NULL
                                            ); 
        if (params->thrPoolReq == NULL) {
            result = ERROR_NOT_ENOUGH_MEMORY;
            goto CLEANUPANDEXIT;
        }
    }
    else {
        TRC_ERR((TB, L"Can't allocate parms."));
        result = ERROR_NOT_ENOUGH_MEMORY;
        goto CLEANUPANDEXIT;
    }

CLEANUPANDEXIT:

    if (result != ERROR_SUCCESS) {

        //
        //  Return the failed result back to the server and clean up.
        //
        DefaultIORequestMsgHandle(pIoRequestPacket, result);         
        if (params != NULL) {
            params->pIoRequestPacket = NULL;
            delete params;
        }

    }

    DC_END_FN();
}

DWORD 
W32DrAutoPrn::AsyncMsgIrpCreateFunc(
    IN W32DRDEV_ASYNCIO_PARAMS *params
    ) 
/*++

Routine Description:

    Handle a "Close" IO request from the server, in a background thread.

Arguments:

    params  -   Context for the IO request.

Return Value:

    NA

 --*/
{
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    ULONG ulRetCode;
    DWORD result;
    DOC_INFO_1 sDocInfo1;

    DC_BEGIN_FN("W32DrAutoPrn::AsyncMsgIrpCreateFunc");

    //
    //  This version does not work without a printer name.
    //
    ASSERT(_tcslen(GetPrinterName()));

    //
    //  Get IO request pointer.
    //
    pIoRequest = &params->pIoRequestPacket->IoRequest;
    
    //
    //  Finish/Cancel any Current Jobs and Close, if Open.
    //
    ClosePrinter();

    //
    //  Open the printer.
    //
    if (!W32DrOpenPrinter(_devicePath, &_printerHandle)) {
        ulRetCode = GetLastError();
        TRC_ERR((TB, _T("OpenPrinter  %ld."), ulRetCode));
        goto Cleanup;
    }

    //
    // Start Doc.
    //
    sDocInfo1.pDocName = GetLocalPrintingDocName();
    sDocInfo1.pOutputFile = NULL;
    sDocInfo1.pDatatype = _T("RAW");
    _jobID = StartDocPrinter(_printerHandle, 1, (PBYTE)&sDocInfo1);
    if (_jobID == 0) {
        ulRetCode = GetLastError();
        TRC_ERR((TB, _T("StartDocPrinter  %ld."), ulRetCode));
        ClosePrinter();
        goto Cleanup;
    }

    //
    //  Attempt to disable annoying printer pop up if we have sufficient
    //  privilege.  Not a big deal, if we fail.
    //
    DisablePrinterPopup(_printerHandle, _jobID);

    //
    //  Start the first page.
    //
    if (!StartPagePrinter(_printerHandle)) {
        ulRetCode = GetLastError();
        TRC_ERR((TB, _T("StartPagePrinter  %ld."), ulRetCode));
        ClosePrinter();
        goto Cleanup;
    }

    //
    //  We are done successfully, say so.
    //
    ulRetCode = ERROR_SUCCESS;

Cleanup:

    //
    //  Send the result to the server.
    //
    result = (ulRetCode == ERROR_SUCCESS) ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
    DefaultIORequestMsgHandle(params->pIoRequestPacket, result); 

    //
    //  Clean up the IO request parameters.  DefaultIORequestMsgHandle cleans up
    //  the request packet.
    //
    if (params->thrPoolReq != INVALID_THREADPOOLREQUEST) {
        _threadPool->CloseRequest(params->thrPoolReq);
        params->thrPoolReq = INVALID_THREADPOOLREQUEST;
    }
    params->pIoRequestPacket = NULL;
    delete params;

    DC_END_FN();
    return result;
}

VOID 
W32DrAutoPrn::ClosePrinter()
/*++

Routine Description:

    End any jobs in progress and close the printer.

Arguments:

    NA

Return Value:

    NA

 --*/
{
    DC_BEGIN_FN("W32DrAutoPrn::ClosePrinter");

    if (_printerHandle != INVALID_HANDLE_VALUE) {

        //
        //  Finish the current page for the current print job.
        //
        if (!EndPagePrinter(_printerHandle)) {
            TRC_ERR((TB, _T("EndPagePrinter %ld."), GetLastError()));
        }

        //
        //  End the current print job.
        //
        if (!EndDocPrinter(_printerHandle)) {
            TRC_ERR((TB, _T("EndDocPrinter %ld."), GetLastError()));
        }

        //
        //  Close the printer.
        //
        if (!::ClosePrinter(_printerHandle)) {
            TRC_ERR((TB, _T("ClosePrinter %ld."), GetLastError()));
        }

        //
        //  Negate the handle and the pending job ID.
        //
        _printerHandle = INVALID_HANDLE_VALUE;
        _jobID = 0;

    }

    DC_END_FN();
}

VOID 
W32DrAutoPrn::MsgIrpClose(
    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
    IN UINT32 packetLen
    ) 
/*++

Routine Description:

    Handle a "Close" IO request from the server by dispatching
    the request to the thread pool.  TODO:  move this async
    dispatch to the parent class in a future release.  All closes
    should be handled outside the main thread.-TadB

Arguments:

    pIoRequestPacket    -   Server IO request packet.

Return Value:

    NA

 --*/
{
    W32DRDEV_ASYNCIO_PARAMS *params = NULL;

    DWORD result = ERROR_SUCCESS;

    DC_BEGIN_FN("W32DrAutoPrn::MsgIrpClose");

    params = new W32DRDEV_ASYNCIO_PARAMS(this, pIoRequestPacket);
    if (params != NULL) {
        params->thrPoolReq = _threadPool->SubmitRequest(
                                            _AsyncMsgIrpCloseFunc,
                                            params, NULL
                                            ); 
        if (params->thrPoolReq == NULL) {
            result = ERROR_NOT_ENOUGH_MEMORY;
            goto CLEANUPANDEXIT;
        }
    }
    else {
        TRC_ERR((TB, L"Can't allocate parms."));
        result = ERROR_NOT_ENOUGH_MEMORY;
        goto CLEANUPANDEXIT;
    }

CLEANUPANDEXIT:

    if (result != ERROR_SUCCESS) {

        //
        //  Return the failed result back to the server and clean up.
        //
        DefaultIORequestMsgHandle(pIoRequestPacket, result);         
        if (params != NULL) {
            params->pIoRequestPacket = NULL;
            delete params;
        }

    }

    DC_END_FN();
}

DWORD 
W32DrAutoPrn::AsyncMsgIrpCloseFunc(
    IN W32DRDEV_ASYNCIO_PARAMS *params
    ) 
/*++

Routine Description:

    Handle a "Close" IO request from the server, in a background thread.

Arguments:

    params  -   Context for the IO request.

Return Value:

    NA

 --*/
{
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    DWORD returnValue = STATUS_SUCCESS;

    DC_BEGIN_FN("W32DrAutoPrn::MsgIrpClose");

    //
    //  Close the printer.
    //
    ClosePrinter();

    //
    //  Send the result to the server.
    //
    DefaultIORequestMsgHandle(params->pIoRequestPacket, returnValue); 

    //
    //  Clean up the IO request parameters.  DefaultIORequestMsgHandle cleans up
    //  the request packet.
    //
    if (params->thrPoolReq != INVALID_THREADPOOLREQUEST) {
        _threadPool->CloseRequest(params->thrPoolReq);
        params->thrPoolReq = INVALID_THREADPOOLREQUEST;
    }
    params->pIoRequestPacket = NULL;
    delete params;

    DC_END_FN();

    return returnValue;
}

DWORD 
W32DrAutoPrn::GetPrinterFilterMask(
    IN ProcObj *procObj
    ) 
/*++

Routine Description:

    Returns the configurable print redirection filter mask.

Arguments:

    procObj -   The relevant process object.

Return Value:

    Configurable Filter Mask

 --*/
{
    DWORD filter;

    //
    //  Read FilterQueueType parameters so we know which devices
    //  to redirect.
    //
    if (procObj->GetDWordParameter(
                REG_RDPDR_FILTER_QUEUE_TYPE, 
                &filter) != ERROR_SUCCESS) {
        //
        //  Default.
        //
        filter = FILTER_ALL_QUEUES;
    }
    return filter;
}

BOOL 
W32DrAutoPrn::W32DrOpenPrinter(
    IN LPTSTR pPrinterName,
    IN LPHANDLE phPrinter  
    ) 

/*++

Routine Description:

    Open a printer with highest access possible.

Arguments:

    pPrinterName -  Pointer to printer or server name.
    phPrinter    -  Pointer to printer or server handle.

Return Value:

    TRUE on success.  FALSE, otherwise.

 --*/
{
    PRINTER_DEFAULTS sPrinter;
    BOOL result;

    DC_BEGIN_FN("W32DrAutoPrn::W32DrOpenPrinter");

    //
    //  Open printer.
    //
    sPrinter.pDatatype = NULL;
    sPrinter.pDevMode = NULL;
    sPrinter.DesiredAccess = PRINTER_ACCESS_USE;
    result = OpenPrinter(pPrinterName, phPrinter, &sPrinter);
    if (!result) {
        TRC_ALT((TB, _T("Full-Access OpenPrinter  %ld."), GetLastError()));

        //
        //  Try with default access.
        //
        result = OpenPrinter(pPrinterName, phPrinter, NULL);
        if (!result) {
            TRC_ERR((TB, _T("OpenPrinter  %ld."), GetLastError()));
        }
    }

    DC_END_FN();

    return result;
}

VOID
W32DrAutoPrn::DisablePrinterPopup(
    HANDLE hPrinterHandle,
    ULONG ulJobID
    )
/*++

Routine Description:

    Disable annoying printer pop up for the specified printer 
    and print job.

Arguments:

    hPrinterHandle  - handle to a printer device.

    ulJobID         - ID of the job.

Return Value:

    NA

 --*/
{
    JOB_INFO_2* pJobInfo2 = NULL;
    ULONG ulJobBufSize;

    DC_BEGIN_FN("W32DrAutoPrn::DisablePrinterPopup");

    ulJobBufSize = 2 * 1024;
    pJobInfo2 = (JOB_INFO_2 *)new BYTE[ulJobBufSize];

    //
    // Note we call the ANSI version of the API
    // because we don't have a UNICODE wrapper for Get/SetJob.
    // Main reason is we don't actually use any returned string
    // data directly.
    //

    if(!_bRunningOn9x)
    {
        //Call unicode API's

        if( pJobInfo2 != NULL ) {
            //
            //  Get job info.
            //
            if( GetJob(
                    hPrinterHandle,
                    ulJobID,
                    2,
                    (PBYTE)pJobInfo2,
                    ulJobBufSize,
                    &ulJobBufSize )) {

                //
                //  Disable popup notification by setting pNotifyName 
                //  NULL.
                //
                pJobInfo2->pNotifyName = NULL;
                pJobInfo2->Position = JOB_POSITION_UNSPECIFIED;
                if( !SetJob(
                        hPrinterHandle,
                        ulJobID,
                        2,
                        (PBYTE)pJobInfo2,
                        0 )) {

                    TRC_ERR((TB, _T("SetJob %ld."), GetLastError()));
                }
            }
            else {
                TRC_ERR((TB, _T("GetJob %ld."), GetLastError()));
            }
            delete (PBYTE)pJobInfo2;
        }
        else {
            TRC_ERR((TB, _T("Memory Allocation failed.")));
        }
    }
    else
    {
        //Call ANSI API's
        if( pJobInfo2 != NULL ) {
            //
            //  Get job info.
            //
            if( GetJobA(
                    hPrinterHandle,
                    ulJobID,
                    2,
                    (PBYTE)pJobInfo2,
                    ulJobBufSize,
                    &ulJobBufSize )) {

                //
                //  Disable popup notification by setting pNotifyName 
                //  NULL.
                //
                pJobInfo2->pNotifyName = NULL;
                if( !SetJobA(
                        hPrinterHandle,
                        ulJobID,
                        2,
                        (PBYTE)pJobInfo2,
                        0 )) {

                    TRC_ERR((TB, _T("SetJob %ld."), GetLastError()));
                }
            }
            else {
                TRC_ERR((TB, _T("GetJob %ld."), GetLastError()));
            }
            delete (PBYTE)pJobInfo2;
        }
        else {
            TRC_ERR((TB, _T("Memory Allocation failed.")));
        }
    }
    DC_END_FN();
}

DWORD 
W32DrAutoPrn::AsyncWriteIOFunc(
    IN W32DRDEV_ASYNCIO_PARAMS *params
    )
/*++

Routine Description:

    Asynchronous Write Operation

Arguments:

    params  -   Context for the IO request.

Return Value:

    Returns 0 on success.  Otherwise, a Windows error code is returned.

 --*/
{
    PBYTE pDataBuffer;
    PRDPDR_IOCOMPLETION_PACKET pReplyPacket;
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    ULONG ulReplyPacketSize = 0;
    DWORD status;

    DC_BEGIN_FN("W32DrAutoPrn::AsyncWriteIOFunc");

    //  Assert the integrity of the IO context
    ASSERT(params->magicNo == GOODMEMMAGICNUMBER);

    //
    //  Get the IO request and reply..
    //
    pIoRequest = &params->pIoRequestPacket->IoRequest;
    pReplyPacket = params->pIoReplyPacket;

    //
    //  Get the data buffer pointer.
    //
    pDataBuffer = (PBYTE)(pIoRequest + 1);

    //
    //  Write the data to the print queue with the help of the spooler.
    //
    if (!WritePrinter(
            _printerHandle,
            pDataBuffer,
            pIoRequest->Parameters.Write.Length,
            &(pReplyPacket->IoCompletion.Parameters.Write.Length)) ) {

        status = GetLastError();
        TRC_ERR((TB, _T("WritePrinter %ld."), status));
    }
    else {
        TRC_NRM((TB, _T("WritePrinter completed.")));
        status = ERROR_SUCCESS;
    }

    DC_END_FN();
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\w32draut.h ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    w32draut

Abstract:

    This module defines a special subclass of the Win32 client-side RDP
    printer redirection "device" class.  The subclass, W32DrAutoPrn manages
    a queue that is automatically discovered by the client via enumerating
    client-side printer queues.

Author:

    Tad Brockway 3/23/99

Revision History:

--*/

#ifndef __W32DRAUT_H__
#define __W32DRAUT_H__

#include "w32drprn.h"


///////////////////////////////////////////////////////////////
//
//	Defines
//

#define REG_RDPDR_AUTO_PORT             _T("AutoPrinterPort")
#define REG_RDPDR_FILTER_QUEUE_TYPE     _T("FilterQueueType")

#define FILTER_LPT_QUEUES   0x00000001
#define FILTER_COM_QUEUES   0x00000002
#define FILTER_USB_QUEUES   0x00000004
#define FILTER_NET_QUEUES   0x00000008
#define FILTER_RDP_QUEUES   0x00000010
#define FILTER_ALL_QUEUES   0xFFFFFFFF


///////////////////////////////////////////////////////////////
//
//	W32DrAutoPrn
//
//

#define LOCAL_PRINTING_DOCNAME_LEN  MAX_PATH

class W32DrAutoPrn : public W32DrPRN
{
private:

    typedef struct _PrinterInfo {
        LPTSTR  pPrinterName;
        LPTSTR  pPortName;
        LPTSTR  pDriverName;
        DWORD   Attributes;
    } PRINTERINFO, *PPRINTERINFO;

    HANDLE _printerHandle;

protected:

    ULONG   _jobID;
    BOOL    _bRunningOn9x;
    TCHAR   _szLocalPrintingDocName[LOCAL_PRINTING_DOCNAME_LEN];

    //  Get the name of the printing document to use for server print jobs.
    LPTSTR GetLocalPrintingDocName();

    //  End any jobs in progress and close the printer.
    VOID ClosePrinter();

    //
    //  IO Processing Functions
    //
    //  This subclass of DrDevice handles the following IO requests.  These
    //  functions may be overridden in a subclass.
    //
    //  pIoRequestPacket    -   Request packet received from server.
    //  packetLen           -   Length of the packet
    //
    //
    virtual VOID MsgIrpCreate(
                        IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                        IN UINT32 packetLen
                        );
    virtual VOID MsgIrpCleanup(
                        IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                        IN UINT32 packetLen
                        ) {
        //  Use the default handler.
        DefaultIORequestMsgHandle(pIoRequestPacket, STATUS_SUCCESS);
    }
    virtual VOID MsgIrpClose(
                        IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                        IN UINT32 packetLen
                        );
    virtual VOID MsgIrpRead(
                        IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                        IN UINT32 packetLen
                        ) {
        //  Use the default handler and fail the read.
        DefaultIORequestMsgHandle(pIoRequestPacket, STATUS_UNSUCCESSFUL);
    }
    virtual VOID MsgIrpFlushBuffers(
                        IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                        IN UINT32 packetLen
                        ) {
        //  Use the default handler.
        DefaultIORequestMsgHandle(pIoRequestPacket, STATUS_SUCCESS);
    }

    //
    //  Async IO Management Functions
    //
    DWORD AsyncWriteIOFunc(W32DRDEV_ASYNCIO_PARAMS *params);
    DWORD AsyncMsgIrpCloseFunc(W32DRDEV_ASYNCIO_PARAMS *params);
    DWORD AsyncMsgIrpCreateFunc(W32DRDEV_ASYNCIO_PARAMS *params);


    //
    //  Open a printer with highest access possible.
    //
    BOOL W32DrOpenPrinter(LPTSTR pPrinterName, LPHANDLE phPrinter) ;

    //
    //  Disable annoying printer pop up for the specified printer 
    //  and print job.
    //
    VOID DisablePrinterPopup(HANDLE hPrinterHandle, ULONG ulJobID);

    //
    //  Create a "friendly" printer name from the printer name of a
    //  network printer.
    //
    static LPTSTR CreateFriendlyNameFromNetworkName(LPTSTR printerName, 
                                                    BOOL serverIsWin2K);

    //
    //  Create a printer name from the names stored in the registry.
    //
    static LPTSTR CreateNestedName(LPTSTR printerName, BOOL* pfNetwork);

    //
    //  Get the printer name of the default printer.
    //
    //  This function allocates memory and returns a pointer
    //  to the allocated string, if successful. Otherwise, it returns 
    //  NULL.
    //
    static LPTSTR GetRDPDefaultPrinter();

    //
    // Check if printer is visible in our session
    //
    static BOOL ShouldAddThisPrinter( 
                    DWORD queueFilter, 
                    DWORD userSessionID,
                    PPRINTERINFO pPrinterInfo,
                    DWORD printerSessionID
                    );

    //  Returns the configurable print redirection filter mask.
    static DWORD GetPrinterFilterMask(ProcObj *procObj);

    //
    //  Get printer info for a printer and its corresponding TS session ID, if it 
    //  exists.
    //
    static DWORD GetPrinterInfoAndSessionID(
        IN ProcObj *procObj,   
        IN LPTSTR printerName, 
        IN DWORD printerAttribs,
        IN OUT BYTE **pPrinterInfoBuf,
        IN OUT DWORD *pPrinterInfoBufSize,
        OUT DWORD *sessionID,
        OUT PPRINTERINFO printerInfo
        );

public:

    //  
    //  Constructor/Destructor
    //
    W32DrAutoPrn(ProcObj *processObject,
                 const DRSTRING printerName, const DRSTRING driverName,
                 const DRSTRING portName, BOOL isDefault, ULONG deviceID,
                 const TCHAR *devicePath);
    virtual ~W32DrAutoPrn();

    //
    //  Enumerate devices of this type.
    //
    static DWORD Enumerate(ProcObj *procObj, DrDeviceMgr *deviceMgr);

    //
    //  Get the device type.  See "Device Types" section of rdpdr.h
    //
    virtual ULONG GetDeviceType()   { return RDPDR_DTYP_PRINT; }

    //
    //  Return the class name.
    //
    virtual DRSTRING ClassName()  { return TEXT("W32DrAutoPrn"); }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\w32drcom.h ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    w32drcom

Abstract:

    This module defines the parent for the Win32 client-side RDP
    COM port redirection "device" class hierarchy, W32DrCOM.

Author:

    Tad Brockway 3/23/99

Revision History:

--*/

#ifndef __W32DRCOM_H__
#define __W32DRCOM_H__

#include "w32drprt.h"


///////////////////////////////////////////////////////////////
//
//	W32DrCOM
//
//

class W32DrCOM : public W32DrPRT
{
protected:

    //
    //  Returns the configurable COM port max ID.
    //
    static DWORD GetCOMPortMax(ProcObj *procObj);

public:

    //
    //  Constructor
    //
    W32DrCOM(ProcObj *processObject, const DRSTRING portName, 
             ULONG deviceID, const TCHAR *devicePath);

    //
    //  Enumerate devices of this type.
    //
    static DWORD Enumerate(ProcObj *procObj, DrDeviceMgr *deviceMgr);


    //  Get the device type.  See "Device Types" section of rdpdr.h
    virtual ULONG GetDeviceType()   { return RDPDR_DTYP_SERIAL; }

    //  Return the class name.
    virtual DRSTRING ClassName()  { return TEXT("W32DrCOM"); }

    virtual DWORD InitializeDevice( IN DrFile* fileObj );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\w32drcom.cpp ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    w32drcom

Abstract:

    This module defines the parent for the Win32 client-side RDP
    COM port redirection "device" class hierarchy, W32DrCOM.

Author:

    Tad Brockway 3/23/99

Revision History:

--*/

#include <precom.h>

#define TRC_FILE  "W32DrCOM"

#include "w32drcom.h"
#include "drobjmgr.h"
#include "proc.h"
#include "drconfig.h"
#include "drdbg.h"

///////////////////////////////////////////////////////////////
//
//	W32DrCOM Members
//
//

W32DrCOM::W32DrCOM(
    IN ProcObj *procObj,
    IN const DRSTRING portName, 
    IN ULONG deviceID,
    IN const TCHAR *devicePath
    ) : W32DrPRT(procObj, portName, deviceID, devicePath)
/*++

Routine Description:

    Constructor

Arguments:

    processObject   -   Associated process object.
    portName        -   Name of the port.
    id              -   Device ID for the port.
    devicePath      -   Path that can be opened by CreateFile
                        for port.

Return Value:

    NA

 --*/
{
}

#ifndef OS_WINCE
DWORD 
W32DrCOM::Enumerate(
    IN ProcObj *procObj, 
    IN DrDeviceMgr *deviceMgr
    )
/*++

Routine Description:

    Enumerate devices of this type by adding appropriate device
    instances to the device manager.

Arguments:

    procObj     -   Corresponding process object.
    deviceMgr   -   Device manager to add devices to.

Return Value:

    ERROR_SUCCESS on success.  Otherwise, an error code is returned.

 --*/
{
    ULONG ulPortNum;
    TCHAR path[MAX_PATH];   
    DrDevice *deviceObj;   
    TCHAR portName[64];
    ULONG comPortMax;

    DC_BEGIN_FN("W32DrCOM::Enumerate");

    if(!procObj->GetVCMgr().GetInitData()->fEnableRedirectPorts)
    {
        TRC_DBG((TB,_T("Port redirection disabled, bailing out")));
        return ERROR_SUCCESS;
    }

    comPortMax = GetCOMPortMax(procObj);

    //
    //  Scan COM ports.
    //
    for (ulPortNum=0; ulPortNum<=comPortMax; ulPortNum++) {
        StringCchPrintf(portName,
                      SIZE_TCHARS(portName),
                      _T("COM%ld"), ulPortNum);
#ifndef OS_WINCE
        StringCchPrintf(path,
                        SIZE_TCHARS(path),
                        TEXT("\\\\.\\%s"), portName);
#else
        StringCchPrintf(path,
                        SIZE_TCHARS(path),
                        TEXT("%s:"), portName);
#endif
        HANDLE hndl = CreateFile(
                            path,
                            GENERIC_READ | GENERIC_WRITE,
                            0,                    // exclusive access
                            NULL,                 // no security attrs
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL |
                            FILE_FLAG_OVERLAPPED, // overlapped I/O
                            NULL
                            );
        if ((hndl != INVALID_HANDLE_VALUE) || 
            (GetLastError() != ERROR_FILE_NOT_FOUND)){
#ifndef OS_WINCE
            TCHAR TargetPath[MAX_PATH];
#endif

            CloseHandle(hndl);

#ifndef OS_WINCE
            if (procObj->Is9x() || QueryDosDevice(portName, TargetPath, sizeof(TargetPath) / sizeof(TCHAR))) {
                if (_tcsstr(TargetPath, TEXT("RdpDr")) == NULL) {
#endif
                    //
                    //  Create a new COM port device object.
                    //
                    TRC_NRM((TB, _T("Adding COM Device %s."), path));
                    deviceObj = new W32DrCOM(procObj, portName, 
                                             deviceMgr->GetUniqueObjectID(), path);
        
                    //
                    //  Add to the device manager if we got a valid object.
                    //
                    if (deviceObj != NULL) {
                        deviceObj->Initialize();
                        if (!(deviceObj->IsValid() && 
                             (deviceMgr->AddObject(deviceObj) == STATUS_SUCCESS))) {
                                delete deviceObj;
                        }
                    }
#ifndef OS_WINCE
                }
            }                        
#endif
        }
    }

    DC_END_FN();

    return ERROR_SUCCESS;
}

#else

DWORD 
W32DrCOM::Enumerate(
    IN ProcObj *procObj, 
    IN DrDeviceMgr *deviceMgr
    )
{
    ULONG ulPortNum;
    TCHAR path[MAX_PATH];   
    DrDevice *deviceObj;   
    TCHAR portName[64];
    
    DC_BEGIN_FN("W32DrCOM::Enumerate");

    if(!procObj->GetVCMgr().GetInitData()->fEnableRedirectPorts)
    {
        TRC_DBG((TB,_T("Port redirection disabled, bailing out")));
        return ERROR_SUCCESS;
    }

    ulPortNum = GetActivePortsList(L"COM");
    if (ulPortNum == 0)
    {
        TRC_DBG((TB,_T("No COM ports found.")));
        return ERROR_SUCCESS;
    }

    TRC_ASSERT(((ulPortNum & 0xFFFFFC00) == 0), (TB, _T("COM Port numbers > 9 found!")));

    for (ULONG i=0; i<10; i++)
    {
        if ( (ulPortNum & (1 << i)) == 0)
            continue;

        _stprintf(portName, _T("COM%ld"), i);
        _stprintf(path, TEXT("%s:"), portName);

        //
        //  Create a new COM port device object.
        //
        TRC_NRM((TB, _T("Adding COM Device %s."), path));
        deviceObj = new W32DrCOM(procObj, portName, 
                                 deviceMgr->GetUniqueObjectID(), path);

        //
        //  Add to the device manager if we got a valid object.
        //
        if (deviceObj != NULL) {
            deviceObj->Initialize();
            if (!(deviceObj->IsValid() && 
                 (deviceMgr->AddObject(deviceObj) == STATUS_SUCCESS))) {
                    delete deviceObj;
            }
        }
    }

    DC_END_FN();

    return ERROR_SUCCESS;
}

#endif

DWORD 
W32DrCOM::GetCOMPortMax(
    IN ProcObj *procObj
    ) 
/*++

Routine Description:

    Returns the configurable COM port max ID.

Arguments:

    procObj -   The relevant process object.

Return Value:

    COM Port Max.

 --*/
{
    DWORD returnValue;

    //
    //  Read the COM Port Max out of the Registry
    //
    if (procObj->GetDWordParameter(RDPDR_COM_PORT_MAX_PARAM, &returnValue) 
                        != ERROR_SUCCESS ) {
        //  Default
        returnValue = RDPDR_COM_PORT_MAX_PARAM_DEFAULT;
    }

    return returnValue;
}

DWORD
W32DrCOM::InitializeDevice(IN DrFile* fileObj)
/*++

Routine Description:

    Initialize serial port to default state.

Arguments:

    fileObj - DrFile that has been created by MsgIrpCreate()

Return Value:

    ERROR_SUCCESS or error code.

 --*/
{
    HANDLE FileHandle;
    LPTSTR portName;

    DC_BEGIN_FN("W32DrCOM::InitializeDevice");

    //
    // Our devicePath is formulated as
    // sprintf(_devicePath, TEXT("\\\\.\\%s"), portName);
    //
    portName = _tcsrchr( _devicePath, _T('\\') );

    if( portName == NULL ) {
        // invalid device path
        goto CLEANUPANDEXIT;
    }

    portName++;

    if( !*portName ) {
        //
        // Invalid port name
        //
        goto CLEANUPANDEXIT;
    }

    //
    //  Get the file handle.
    //
    FileHandle = fileObj->GetFileHandle();
    if (!FileHandle || FileHandle == INVALID_HANDLE_VALUE) {
        ASSERT(FALSE);
        TRC_ERR((TB, _T("File Object was not created successfully")));
        goto CLEANUPANDEXIT;    
    }

    W32DrPRT::InitializeSerialPort(portName, FileHandle);

CLEANUPANDEXIT:
    
    DC_END_FN();

    //
    //  This function always returns success.  If the port cannot 
    //  be initialized, then subsequent port commands will fail 
    //  anyway. 
    //

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\w32drdev.cpp ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    w32drdev

Abstract:

    This module defines the parent for the Win32 client-side RDP
    device redirection "device" class hierarchy, W32DrDevice.

Author:

    Tad Brockway 3/23/99

Revision History:

--*/

#include <precom.h>

#define TRC_FILE  "W32DrDevice"

#include "w32drdev.h"
#include "proc.h"
#include "drdbg.h"
#include "w32utl.h"
#include "utl.h"
#include "w32proc.h"

#ifdef OS_WINCE
#include "filemgr.h"
#endif

///////////////////////////////////////////////////////////////
//
//  W32DrDevice Members
//
//

W32DrDevice::W32DrDevice(
    IN ProcObj *processObject, 
    IN ULONG deviceID,
    IN const TCHAR *devicePath
    ) : DrDevice(processObject, deviceID)
/*++

Routine Description:

    Constructor for the W32DrDevice class. 

Arguments:

    processObject   -   Associated Process Object
    deviceID        -   Unique device identifier.
    devicePath      -   Path to device that can be used by
                        CreateFile to open device.

Return Value:

    NA
    
 --*/
{
    DC_BEGIN_FN("W32DrDevice::W32DrDevice");

    //
    //  Record device path.
    //
    ASSERT(STRLEN(devicePath) < MAX_PATH);
    STRNCPY(_devicePath, devicePath, MAX_PATH);       
    _devicePath[MAX_PATH-1] = '\0';

    //
    //  Initialize the handle to the string resource module.
    //
    _hRdpDrModuleHandle = NULL;

    DC_END_FN();
}

W32DrDevice::~W32DrDevice() 
/*++

Routine Description:

    Destructor for the W32DrDevice class. 

Arguments:

    NA

Return Value:

    NA

 --*/
{
    DC_BEGIN_FN("W32DrDevice::~W32DrDevice");
    
    //
    //  Close the string resource module.
    //
    if (_hRdpDrModuleHandle != NULL) {
        FreeLibrary( _hRdpDrModuleHandle );
    }
    DC_END_FN();
}

TCHAR* 
W32DrDevice::ConstructFileName(
    PWCHAR Path, 
    ULONG PathBytes
    )
/*++

Routine Description:

    Setup the file name

 --*/

{
    TCHAR *pFileName;
    HRESULT hr;
    UINT cchFileName;

    //
    // Get the File Name
    //
    if (PathBytes) {
        ULONG PathLen, DeviceLen;
        
        //
        // Open a File
        //

        //
        //  Path is assumed string null terminated
        //
        PathLen = PathBytes / sizeof(WCHAR) - 1;
        Path[PathLen] = L'\0';

#ifndef OS_WINCE
        DeviceLen = _tcslen(_devicePath);
#else
        DeviceLen = 0;
#endif

        //
        //  Append device path and file path together
        //  Assuming we need the \\?\ format, string 
        //  is null terminated
        //
        
#ifndef OS_WINCE
        cchFileName = (DeviceLen + PathLen + 5);
        pFileName = new TCHAR[cchFileName];
#else
        cchFileName = PathLen + 1
        pFileName = new TCHAR[cchFileName];
#endif

        if (pFileName) {
#ifndef OS_WINCE
            if (DeviceLen + PathLen < MAX_PATH) {
                //
                // Buffer is allocated large enough for the string
                //
                StringCchCopy(pFileName, cchFileName, _devicePath);
            } 
            else {
                //
                // Buffer is allocated large enough for the string
                //
                StringCchPrintf(pFileName, cchFileName,
                                TEXT("\\\\?\\%s"),
                                _devicePath);

                DeviceLen += 4;
            }   
#endif
            
        }
        else {
            goto Cleanup;
        }

#ifndef UNICODE
        RDPConvertToAnsi(Path, pFileName + DeviceLen, PathLen + 1);  
#else
        memcpy(pFileName + DeviceLen, Path, PathLen * sizeof(WCHAR));
        pFileName[DeviceLen + PathLen] = _T('\0');
#endif
    }
    else {
        //
        // Open the device itself
        //
        pFileName = _devicePath;
    }

Cleanup:
    return pFileName;
}

DWORD
W32DrDevice::ConstructCreateDisposition(
    DWORD Disposition
    ) 
/*++

Routine Description:

    Construct client create disposition

 --*/
{
    DWORD CreateDisposition;

    //
    // Setup CreateDisposition 
    //
    switch (Disposition) {
        case FILE_CREATE        :
            CreateDisposition = CREATE_NEW;
            break;
        case FILE_OVERWRITE_IF     :
            CreateDisposition = CREATE_ALWAYS;
            break;
        case FILE_OPEN     :
            CreateDisposition = OPEN_EXISTING;
            break;
        case FILE_OPEN_IF       :
            CreateDisposition = OPEN_ALWAYS;
            break;

        default :
            CreateDisposition = 0;
    }

    return CreateDisposition;
}

DWORD 
W32DrDevice::ConstructDesiredAccess(
    DWORD AccessMask
    ) 
/*++

Routine Description:

    Construct client desired access from server's access mask

 --*/
{
    DWORD DesiredAccess;

    //
    // Setup DesiredAccess
    //
    DesiredAccess = 0;

    //
    //  If the user requested WRITE_DATA, return write.
    //

    if (AccessMask & FILE_WRITE_DATA) {
        DesiredAccess |= GENERIC_WRITE;
    }

    //
    //  If the user requested READ_DATA, return read.
    //
    if (AccessMask & FILE_READ_DATA) {
        DesiredAccess |= GENERIC_READ;
    }

    //
    //  If the user requested FILE_EXECUTE, return execute.
    //
    if (AccessMask & FILE_EXECUTE) {
        DesiredAccess |= GENERIC_READ;
    }

    return DesiredAccess;
}

DWORD
W32DrDevice::ConstructFileFlags(
    DWORD CreateOptions
    )
/*++

Routine Description:

    Construct file flags 

 --*/
{
    DWORD CreateFlags;


    CreateFlags = 0;
    CreateFlags |= (CreateOptions & FILE_WRITE_THROUGH ? FILE_FLAG_WRITE_THROUGH : 0);
    CreateFlags |= (CreateOptions & FILE_RANDOM_ACCESS ? FILE_FLAG_RANDOM_ACCESS : 0 );
    //CreateFlags |= (CreateOptions & FILE_SYNCHRONOUS_IO_NONALERT ? 0 : FILE_FLAG_OVERLAPPED);
#ifndef OS_WINCE
    CreateFlags |= (CreateOptions & FILE_NO_INTERMEDIATE_BUFFERING ? FILE_FLAG_NO_BUFFERING : 0);
    CreateFlags |= (CreateOptions & FILE_SEQUENTIAL_ONLY ? FILE_FLAG_SEQUENTIAL_SCAN : 0);
    CreateFlags |= (CreateOptions & FILE_OPEN_FOR_BACKUP_INTENT ? FILE_FLAG_BACKUP_SEMANTICS : 0);
    CreateFlags |= (CreateOptions & FILE_DELETE_ON_CLOSE ? FILE_FLAG_DELETE_ON_CLOSE : 0);
    CreateFlags |= (CreateOptions & FILE_OPEN_REPARSE_POINT ? FILE_FLAG_OPEN_REPARSE_POINT : 0);
    CreateFlags |= (CreateOptions & FILE_OPEN_NO_RECALL ? FILE_FLAG_OPEN_NO_RECALL : 0);
#endif

    return CreateFlags;
}

BOOL 
W32DrDevice::IsDirectoryFile(
    DWORD DesiredAccess, DWORD CreateOptions, DWORD FileAttributes, 
    PDWORD FileFlags
    ) 
/*++

Routine Description:

    Check if the pFileName corresponds to a directory

 --*/
{
    BOOL IsDirectory = FALSE;

    //
    //  Set up the directory check
    //
    if (!(CreateOptions & FILE_DIRECTORY_FILE)) {
        //
        //  File doesn't have the directory flag on
        //  or nondirecotry flag on, so it's not sure 
        //  if the file is a directory request or not
        //
        if (!(CreateOptions & FILE_NON_DIRECTORY_FILE)) {
            if (FileAttributes != -1) {
                //
                //  From file attributes, we know this is an directory file
                //  and we are requesting query access only.  So, we add the 
                //  BACKUP_SEMANTICS for the file and set the directory flag 
                //  to be true. We always set the backup_semantics flag
                //
#ifndef OS_WINCE
                *FileFlags |= FILE_FLAG_BACKUP_SEMANTICS;
#endif

                if ((FileAttributes & FILE_ATTRIBUTE_DIRECTORY) && DesiredAccess == 0) {
                    IsDirectory = TRUE;
                }
            }
        }
        else {
            //
            //  Non directory file flag is on, so we are doing file create/open request
            //
        }
    }
    else {
        //
        //  File has the directory flag on, but we still want to do create file
        //  on the directory
        //
        //  Set the BACKUP_SEMANTICS, add it to the file flags
        //  and remember this is a directory
        //
        if (FileAttributes != -1) {
#ifndef OS_WINCE
            *FileFlags |= FILE_FLAG_BACKUP_SEMANTICS;
#endif
            IsDirectory = TRUE;                    
        }
    }

    return IsDirectory;
}


VOID
W32DrDevice::MsgIrpFlushBuffers(
    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
    IN UINT32 packetLen
    )
/*++

Routine Description:

    Handle a "Cleanup" IO request from the server.

Arguments:

    pIoRequestPacket    -   Server IO request packet.

Return Value:

    NA

 --*/
{
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    BOOL result;
    DWORD returnValue;
    DrFile* pFile;
    HANDLE FileHandle;

    DC_BEGIN_FN("W32DrDevice::MsgIrpFlushBuffers");

    //
    //  Get IO request pointer.
    //
    pIoRequest = &pIoRequestPacket->IoRequest;

    //
    //  Get File Object
    //
    pFile = _FileMgr->GetObject(pIoRequest->FileId);

    if (pFile) 
        FileHandle = pFile->GetFileHandle();
    else 
        FileHandle = INVALID_HANDLE_VALUE;
    
    //
    //  Flush the device handle.
    //
    ASSERT(FileHandle != INVALID_HANDLE_VALUE);
#ifndef OS_WINCE
    result = FlushFileBuffers(FileHandle);
#else
    result = CEFlushFileBuffers(FileHandle);
#endif
    if (!result) {
        TRC_ERR((TB, _T("Flush returned %ld."), GetLastError()));
    }

    //
    //  Send the result to the server.
    //
    returnValue = result ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
    DefaultIORequestMsgHandle(pIoRequestPacket, returnValue); 

    DC_END_FN();
}

VOID
W32DrDevice::MsgIrpClose(
    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
    IN UINT32 packetLen
    )
/*++

Routine Description:

    Handle a "Close" IO request from the server.

Arguments:

    pIoRequestPacket    -   Server IO request packet.

Return Value:

    NA

 --*/
{
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    DWORD returnValue = STATUS_SUCCESS;
    DrFile* pFile;
    
    DC_BEGIN_FN("W32DrDevice::MsgIrpClose");

    //
    //  Get IO request pointer.
    //
    pIoRequest = &pIoRequestPacket->IoRequest;

    if (_FileMgr == NULL) {
        returnValue = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    //
    //  Remove the File Object
    //
    pFile = _FileMgr->RemoveObject(pIoRequest->FileId);
    
    if ( pFile != NULL) {
        if (!pFile->Close()) {
            TRC_ERR((TB, _T("Close returned %ld."), GetLastError()));
            returnValue = STATUS_UNSUCCESSFUL;
        }
        pFile->Release();
    }
    else {
        returnValue = STATUS_UNSUCCESSFUL;
    }
 Cleanup:    
    //
    //  Send the result to the server.
    //
    DefaultIORequestMsgHandle(pIoRequestPacket, returnValue); 

    DC_END_FN();
}

ULONG
W32DrDevice::ReadResources(
    ULONG   ulMessageID,
    LPTSTR  *ppStringBuffer,
    PVOID   pArguments,
    BOOL    bFromSystemModule
    )
/*++

Routine Description:

    Read a string from the resources file.

Arguments:

    lMessageID          -   Message ID.
    ppStringBuffer      -   Buffer pointer where the alloted buffer pointer
                            is returned.
    pArguments          -   Pointer array.
    bFromSystemModule   -   When set TRUE return the message from the system
                            module otherwise from the rdpdr.dll message module.

Return Value:

    Returns ERROR_SUCCESS on success.  Otherwise, a Windows error code is
    returned.

 --*/
{
    ULONG ulError;
    HINSTANCE hModuleHandle;
    ULONG ulModuleFlag;
    ULONG ulLen;

    DC_BEGIN_FN("W32DrDevice::ReadResources");

    if( !bFromSystemModule ) {

        if (_hRdpDrModuleHandle == NULL ) {
            _hRdpDrModuleHandle = LoadLibrary(RDPDR_MODULE_NAME);

            if( _hRdpDrModuleHandle == NULL ) {
                ulError = GetLastError();
                TRC_ERR((TB, _T("LoadLibrary failed for %s: %ld."), 
                    RDPDR_MODULE_NAME, ulError));
                goto Cleanup;
            }
        }
        hModuleHandle = _hRdpDrModuleHandle;
        ulModuleFlag = FORMAT_MESSAGE_FROM_HMODULE;
    }
    else {
        hModuleHandle = NULL;
        ulModuleFlag = FORMAT_MESSAGE_FROM_SYSTEM;
    }

    ulLen =
        FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER |
                ulModuleFlag |
                FORMAT_MESSAGE_ARGUMENT_ARRAY,
            hModuleHandle,
            ulMessageID,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPTSTR)ppStringBuffer,
            0,
            (va_list *)pArguments );

    if( ulLen == 0 ) {
        ulError = GetLastError();
        TRC_ERR((TB, _T("FormatMessage() %ld."), ulError));
        goto Cleanup;
    }

    ASSERT(*ppStringBuffer != NULL);
    ulError = ERROR_SUCCESS;

Cleanup:

    DC_END_FN();
    return ulError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\w32drive.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    w32drive

Abstract:

    This module defines a child of the client-side RDP
    device redirection, the "w32drive" W32Drive to provide
    file system redirection on 32bit windows

Author:

    Joy Chik 11/1/99

Revision History:

--*/

#ifndef __W32DRIVE_H__
#define __W32DRIVE_H__

#include <rdpdr.h>                 

#include "drobject.h"

#include "drdevasc.h"


///////////////////////////////////////////////////////////////
//
//  Defines and Macros
//

// Number of characters in a logical drive, including null
#define LOGICAL_DRIVE_LEN   4

// Maximum number of logical drives
#define MAX_LOGICAL_DRIVES  26

///////////////////////////////////////////////////////////////
//
//	W32Drive Class Declaration
//
//
class W32Drive : public W32DrDeviceAsync
{
private:
    
    DRSTRING    _driveName;
    BOOL        _fFailedInConstructor;

protected:
    
    //
    // Setup device property
    //
    virtual VOID SetDeviceProperty() { _deviceProperty.SetSeekProperty(TRUE); }

    //
    //  Async IO Management Functions
    //
    virtual HANDLE StartFSFunc(W32DRDEV_ASYNCIO_PARAMS *params, 
                               DWORD *status);
    static  HANDLE _StartFSFunc(W32DRDEV_ASYNCIO_PARAMS *params, 
                                DWORD *status);
    virtual DWORD AsyncDirCtrlFunc(W32DRDEV_ASYNCIO_PARAMS *params, HANDLE cancelEvent);
    static _ThreadPoolFunc _AsyncDirCtrlFunc;

#if (!defined (OS_WINCE)) || (!defined (WINCE_SDKBUILD))
    virtual DWORD AsyncNotifyChangeDir(W32DRDEV_ASYNCIO_PARAMS *params, HANDLE cancelEvent);
#endif

#if 0
    //
    //  Currently, leaving the directory enumeration in forward thread
    //  to give users faster results back.  But leave this async version in for now.
    //
    virtual DWORD AsyncQueryDirectory(W32DRDEV_ASYNCIO_PARAMS *params);
#endif

public:
    
    //
    //  Constructor
    //
    W32Drive(ProcObj *processObject, ULONG deviceID,
            const TCHAR *deviceName, const TCHAR *devicePath);

    virtual ~W32Drive();

    //
    //  Add a device announce packet for this device to the input 
    //  buffer. 
    //
    virtual ULONG GetDevAnnounceDataSize();
    virtual VOID GetDevAnnounceData(IN PRDPDR_DEVICE_ANNOUNCE buf);
    
    static DWORD Enumerate(ProcObj *procObj, DrDeviceMgr *deviceMgr);
    
    static DWORD EnumerateDrives(ProcObj *procObj, DrDeviceMgr *deviceMgr, UINT Mask);
    static DWORD RemoveDrives(ProcObj *procObj, DrDeviceMgr *deviceMgr, UINT Mask);

    virtual DRSTRING GetName() 
    {
        return _driveName;
    };

    //  Get the device type.  See "Device Types" section of rdpdr.h
    virtual ULONG GetDeviceType()   { return RDPDR_DTYP_FILESYSTEM; }

    //
    //  Return the class name.
    //
    virtual DRSTRING ClassName()  { return TEXT("W32Drive"); }

    virtual VOID MsgIrpDeviceControl(
                    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                    IN UINT32 packetLen
                    );

    virtual VOID MsgIrpLockControl(
                    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                    IN UINT32 packetLen
                    );

    virtual VOID MsgIrpQueryDirectory(
                    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                    IN UINT32 packetLen
                    );

    virtual VOID MsgIrpDirectoryControl(
                    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                    IN UINT32 packetLen
                    );

    virtual VOID MsgIrpQueryVolumeInfo(
                    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                    IN UINT32 packetLen
                    );

    virtual VOID MsgIrpSetVolumeInfo(
                    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                    IN UINT32 packetLen
                    );

    virtual VOID MsgIrpQueryFileInfo(
                    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                    IN UINT32 packetLen
                    );

    virtual VOID MsgIrpSetFileInfo(
                    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                    IN UINT32 packetLen
                    );
    
    virtual VOID MsgIrpQuerySdInfo(
                    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                    IN UINT32 packetLen
                    );

    virtual VOID MsgIrpSetSdInfo(
                    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                    IN UINT32 packetLen
                    );
    BOOL IfFailedInConstructor(void) {
        return _fFailedInConstructor;
    };
};

#endif // W32DRIVE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\w32drdev.h ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    w32drdev

Abstract:

    This module defines the parent for the Win32 client-side RDP
    device redirection "device" class hierarchy, W32DrDevice.

Author:

    Tad Brockway 3/23/99

Revision History:

--*/

#ifndef __W32DRDEV_H__
#define __W32DRDEV_H__

#include "drdev.h"
#include "thrpool.h"

              
///////////////////////////////////////////////////////////////
//
//	Defines
//

//
//  String Resource Module Name
//
#define RDPDR_MODULE_NAME           _T("rdpdr.dll")


///////////////////////////////////////////////////////////////
//
//	W32DrDevice
//
class W32DrDevice : public DrDevice
{
protected:

    //
    //  Client-Side Device Filename
    //
    TCHAR _devicePath[MAX_PATH];       
    
    //
    //  Handle to the RDPDR module.  This is where string resources
    //  come from.
    //
    HINSTANCE _hRdpDrModuleHandle;

    //
    //  Read a string from the resources file.
    //
    ULONG ReadResources(ULONG ulMessageID, LPTSTR *ppStringBuffer,
                        PVOID pArguments, BOOL bFromSystemModule);

    //
    //  Supporting functions for IO Processing
    //
    virtual TCHAR* ConstructFileName(PWCHAR Path, ULONG PathBytes);
    virtual DWORD ConstructCreateDisposition(DWORD Disposition);
    virtual DWORD ConstructDesiredAccess(DWORD AccessMask);
    virtual DWORD ConstructFileFlags(DWORD CreateOptions);
    virtual BOOL IsDirectoryFile(
                        DWORD DesiredAccess, DWORD CreateOptions, DWORD FileAttributes, 
                        PDWORD FileFlags);
    //
    //  IO Processing Functions
    //
    //  This subclass of DrDevice handles the following IO requests.  These
    //  functions may be overridden in a subclass.
    //
    //  pIoRequestPacket    -   Request packet received from server.
    //  packetLen           -   Length of the packet
    //
    //
    virtual VOID MsgIrpClose(
                        IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                        IN UINT32 packetLen
                        );
    virtual VOID MsgIrpFlushBuffers(
                        IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                        IN UINT32 packetLen
                        );

    //  A cleanup is just a flush.
    virtual VOID MsgIrpCleanup(
                    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                        IN UINT32 packetLen
                    ) {
        DC_BEGIN_FN("W32DrDevice::MsgIrpCleanup");
        MsgIrpFlushBuffers(pIoRequestPacket, packetLen);
        DC_END_FN();
    }

public:

    //
    //  Public Methods
    //

    //  Constructor/Destructor
    W32DrDevice(ProcObj *processObject, ULONG deviceID,
                const TCHAR *devicePath);
    virtual ~W32DrDevice();

    //  Return the class name.
    virtual DRSTRING ClassName()  { return TEXT("W32DrDevice"); }

    virtual DWORD InitializeDevice( DrFile* fileHandle ) { return ERROR_SUCCESS; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\w32drive.cpp ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    w32drive

Abstract:

    This module defines a child of the client-side RDP
    device redirection, the "w32drive" W32Drive to provide
    file system redirection on 32bit windows

Author:

    Joy Chik 11/1/99

Revision History:

--*/


#include <precom.h>
#define TRC_FILE  "w32drive"
#include "drdev.h"
#include "w32drdev.h"
#include "w32drive.h"
#include "proc.h"
#include "drconfig.h"
#include "w32utl.h"
#include "utl.h"
#include "drfsfile.h"

#ifdef OS_WINCE
#include "wceinc.h"
#include "axresrc.h"
#include <lss.h>
#include <ceconfig.h>
#include "filemgr.h"
#endif
           
///////////////////////////////////////////////////////////////
//
//	W32Drive Methods
//
//

W32Drive::W32Drive(
    ProcObj *processObject, 
    ULONG deviceID,
    const TCHAR *deviceName,
    const TCHAR *devicePath) : W32DrDeviceAsync(processObject, deviceID, devicePath)
/*++

Routine Description:

    Constructor

Arguments:

    processObject   -   Associated process object.
    deviceName      -   Name of the drive.
    id              -   Device ID for the drive.
    devicePath      -   Path that can be opened by CreateFile
                        for drive.

Return Value:

    NA

 --*/
{
    unsigned len;

    DC_BEGIN_FN("W32Drive::W32Drive");
    
    SetDeviceProperty();
    
    _fFailedInConstructor = FALSE;
    //
    //  Record the drive name.
    //
    TRC_ASSERT((deviceName != NULL), (TB, _T("deviceName is NULL")));
    len = (STRLEN(deviceName) + 1);
    _driveName = new TCHAR[len];
    if (_driveName != NULL) {
        StringCchCopy(_driveName, len, deviceName);
    }

    //
    //  Check and record our status,
    //
    if (_driveName == NULL) {
        TRC_ERR((TB, _T("Memory allocation failed.")));
        SetValid(FALSE);
        _fFailedInConstructor = TRUE;
    }
}

W32Drive::~W32Drive()
/*++

Routine Description:

    Destructor

Arguments:

    NA
    
Return Value:

    NA

 --*/
{
    if (_driveName != NULL) {
        delete _driveName;
    }
}

DWORD 
W32Drive::Enumerate(
    IN ProcObj *procObj, 
    IN DrDeviceMgr *deviceMgr
    )
{
    // 
    // We enumerate all 26 drive letters
    //
    return W32Drive::EnumerateDrives(procObj, deviceMgr, 0x3FFFFFF);
}

DWORD 
W32Drive::EnumerateDrives(
    IN ProcObj *procObj, 
    IN DrDeviceMgr *deviceMgr,
    IN UINT unitMask
    )
/*++

Routine Description:

    Enumerate devices of this type by adding appropriate device
    instances to the device manager.

Arguments:

    procObj     -   Corresponding process object.
    deviceMgr   -   Device manager to add devices to.

Return Value:

    ERROR_SUCCESS on success.  Otherwise, an error code is returned.

 --*/
{
    TCHAR szBuff[LOGICAL_DRIVE_LEN * MAX_LOGICAL_DRIVES + 1];
    LPTSTR lpszDrive = &szBuff[0];
    TCHAR szDrive[3];
    W32Drive *deviceObj;   
    RDPDR_VERSION serverVer;
    
    DC_BEGIN_FN("W32Drive::Enumerate");

    TRC_DBG((TB, _T("Enumerating drives")));

    serverVer = procObj->serverVersion();

    if(!procObj->GetVCMgr().GetInitData()->fEnableRedirectDrives)
    {
        TRC_DBG((TB,_T("Drive redirection disabled, bailing out")));
        return ERROR_SUCCESS;
    }

    //
    //  If the server doesn't support drive redirection,
    //  then don't bother enumerate the drives, simply
    //  return success
    //
    if (COMPARE_VERSION(serverVer.Minor, serverVer.Major, 
                        4, 1) < 0) {
        TRC_NRM((TB, _T("Skipping drive enumeration")));
        return ERROR_SUCCESS;
    }

    szDrive[2] = TEXT('\0');

#ifndef OS_WINCE
    DWORD dwEnum;

    //
    //  Enumerate all drive letters and find the valid drives
    //
    dwEnum = 0;
    while (unitMask) {
        if (unitMask & 0x1) {
        
            //
            // For each drive find whether it is a local sharable drive 
            //
    
            lpszDrive = &(szBuff[LOGICAL_DRIVE_LEN * dwEnum]);
            lpszDrive[0] = TEXT('A') + (TCHAR)dwEnum;
            lpszDrive[1] = TEXT(':');
            lpszDrive[2] = TEXT('\\');
            lpszDrive[3] = TEXT('\0');
    
            switch (GetDriveType(lpszDrive))
            {
                case DRIVE_REMOVABLE:   // The disk can be removed from the drive. 
                case DRIVE_FIXED:       // The disk cannot be removed from the drive. 
                case DRIVE_CDROM:       // The drive is a CD-ROM drive. 
                case DRIVE_RAMDISK:     // The drive is a RAM disk. 
                case DRIVE_REMOTE:      // The drive is a remote (network) drive. 
                    TRC_NRM((TB, _T("Redirecting drive %s"), lpszDrive));
    
                    // Copy <driveletter>: into drive device path
                    szDrive[0] = lpszDrive[0];
                    szDrive[1] = lpszDrive[1];
    
                    deviceObj = new W32Drive(procObj, deviceMgr->GetUniqueObjectID(), 
                            &szDrive[0], &szDrive[0]);
                    
                    //
                    //  Add to the device manager if we got a valid object.
                    //
                    if (deviceObj != NULL) {
                        if (deviceObj->IfFailedInConstructor() != TRUE) {
                            deviceObj->Initialize();
                            if (!(deviceObj->IsValid() && 
                                (deviceMgr->AddObject(deviceObj) == STATUS_SUCCESS))) {
                                delete deviceObj;
                            }
                        }
                        else {
                            TRC_ERR((TB, _T("Failed in new W32Drive")));
                            delete deviceObj;
                        }
                    }
                    else {
                        TRC_ERR((TB, _T("Failed to allocate drive device.")));
                    }
    
                    break;
    
                case DRIVE_UNKNOWN:     // The drive type cannot be determined. 
                case DRIVE_NO_ROOT_DIR: // The root path is invalid. For example, no volume is mounted at the path. 
                default:
                    TRC_NRM((TB, _T("Skipping drive %s"), lpszDrive));
                    break;
            }
        }

        unitMask = unitMask >> 0x1;
        dwEnum++;
    }
#else

    //
    // JOYC: Need to look into CE way of enumerate drives
    // For now, we just use C drive e.g. \\tsclient\c on the server side
    //

    //CE doesnt have drive letters. So DevicePath='\\', DeviceName="Files". And this string should NOT be localized
    deviceObj = new W32Drive(procObj, deviceMgr->GetUniqueObjectID(), 
            CEROOTDIRNAME, CEROOTDIR);
    
    //
    //  Add to the device manager if we got a valid object.
    //
    if (deviceObj != NULL) {
        deviceObj->Initialize();
        if (!(deviceObj->IsValid() && 
                (deviceMgr->AddObject(deviceObj) == STATUS_SUCCESS))) {
            delete deviceObj;
        }
    }
    else {
        TRC_ERR((TB, _T("Failed to allocate drive device.")));
    }

#endif

    DC_END_FN();

    return ERROR_SUCCESS;
}

DWORD 
W32Drive::RemoveDrives(
    IN ProcObj *procObj, 
    IN DrDeviceMgr *deviceMgr,
    IN UINT unitMask
    )
/*++

Routine Description:

    Enumerate devices of this type by removing appropriate device
    instances from the device manager.

Arguments:

    procObj     -   Corresponding process object.
    deviceMgr   -   Device manager to add devices to.

Return Value:

    ERROR_SUCCESS on success.  Otherwise, an error code is returned.

 --*/
{

    DWORD driveIndex = 0;
    RDPDR_VERSION serverVer;
    TCHAR szDrive[3];    

    DC_BEGIN_FN("W32Drive::RemoveDrives");

    serverVer = procObj->serverVersion();

    if(!procObj->GetVCMgr().GetInitData()->fEnableRedirectDrives)
    {
        TRC_DBG((TB,_T("Drive redirection disabled, bailing out")));
        return ERROR_SUCCESS;
    }

    //
    //  If the server doesn't support drive removal,
    //  then don't bother enumerate the drives, simply
    //  return 
    //
    if (!(procObj->GetServerCap().GeneralCap.extendedPDU & RDPDR_DEVICE_REMOVE_PDUS)) {
        TRC_NRM((TB, _T("Skipping drive enumeration")));
        return ERROR_SUCCESS;
    }

    szDrive[1] = TEXT(':');
    szDrive[2] = TEXT('\0');

    while (unitMask) {
        if (unitMask & 0x1) {
            DrDevice *deviceObj;   
            
            //
            // Find if a device exists
            //
        
            szDrive[0] = TEXT('A') + (TCHAR)driveIndex;
                                            
            deviceObj = (DrDevice*)deviceMgr->GetObject(szDrive, RDPDR_DTYP_FILESYSTEM);

            if ( deviceObj != NULL ) {
                deviceObj->_deviceChange = DEVICEREMOVE;

                // Need to remove this device
                TRC_NRM((TB, _T("Deleting drive %s"), szDrive));
            }                     
        }

        unitMask = unitMask >> 0x1;
        driveIndex++;
    }

    DC_END_FN();
    
    return ERROR_SUCCESS;
}

ULONG 
W32Drive::GetDevAnnounceDataSize()
/*++

Routine Description:

    Return the size (in bytes) of a device announce packet for
    this device.

Arguments:

    NA

Return Value:

    The size (in bytes) of a device announce packet for this device.

 --*/
{
    ULONG size = 0;

    DC_BEGIN_FN("W32Drive::GetDevAnnounceDataSize");

    TRC_ASSERT((IsValid()), (TB, _T("Invalid w32drive object")));
    if (!IsValid()) { return 0; }

    size = 0;

    //
    //  Add the base announce size.
    //
    size += sizeof(RDPDR_DEVICE_ANNOUNCE);

    DC_END_FN();

    return size;
}

VOID W32Drive::GetDevAnnounceData(
    IN PRDPDR_DEVICE_ANNOUNCE pDeviceAnnounce
    )
/*++

Routine Description:

    Add a device announce packet for this device to the input buffer. 

Arguments:

    pDeviceAnnounce -   Device Announce Buf for this Device

Return Value:

    NA

 --*/
{
    DC_BEGIN_FN("W32Drive::GetDevAnnounceData");

    TRC_ASSERT((IsValid()), (TB, _T("Invalid w32drive object")));
    if (!IsValid()) { 
        DC_END_FN();
        return; 
    }

    pDeviceAnnounce->DeviceId = GetID();
    pDeviceAnnounce->DeviceType = GetDeviceType();
    pDeviceAnnounce->DeviceDataLength = 0;

    //
    //  Record the device name in ANSI.
    //

#ifdef UNICODE
    RDPConvertToAnsi(_driveName, (LPSTR)pDeviceAnnounce->PreferredDosName,
                  sizeof(pDeviceAnnounce->PreferredDosName)
                  );
#else
    STRNCPY((char *)pDeviceAnnounce->PreferredDosName, _driveName, PREFERRED_DOS_NAME_SIZE);
    pDeviceAnnounce->PreferredDosName[PREFERRED_DOS_NAME_SIZE - 1] = '\0';
#endif

    DC_END_FN();
}

HANDLE 
W32Drive::StartFSFunc(
    IN W32DRDEV_ASYNCIO_PARAMS *params,
    OUT DWORD *status
    )
/*++

Routine Description:

    Start a generic asynchronous File System IO operation.

Arguments:

    params  -   Context for the IO request.
    status  -   Return status for IO request in the form of a windows
                error code.

Return Value:

    Returns a handle to an object that will be signalled when the read
    completes, if it is not completed in this function.  Otherwise, NULL 
    is returned.

 --*/
{
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    DrFile* pFile;
    ULONG irpMajor;
    
    DC_BEGIN_FN("W32Drive::StartFSFunc");

    *status = ERROR_SUCCESS;

    //  Assert the integrity of the IO context
    TRC_ASSERT((params->magicNo == GOODMEMMAGICNUMBER), 
               (TB, _T("bad params->magicNo: %x"), params->magicNo));

    //
    //  Get the IO request and the IPR major.
    //
    pIoRequest = &params->pIoRequestPacket->IoRequest;

    irpMajor = pIoRequest->MajorFunction;

    //
    //  Hand the request off to the thread pool.
    //
    params->completionEvent = CreateEvent(
                                NULL,   // no attribute.
                                TRUE,   // manual reset.
                                FALSE,  // initially not signalled.
                                NULL    // no name.
                                );
    if (params->completionEvent == NULL) {
        *status = GetLastError();
        TRC_ERR((TB, _T("Error in CreateEvent:  %08X."), *status));
    }
    else {

        switch (irpMajor) 
        {
        
        case IRP_MJ_DIRECTORY_CONTROL:
            params->thrPoolReq = _threadPool->SubmitRequest(
                                    _AsyncDirCtrlFunc, 
                                    params, params->completionEvent
                                    ); 
            break;
        }

        if (params->thrPoolReq == INVALID_THREADPOOLREQUEST) {
            *status = ERROR_SERVICE_NO_THREAD;            
        }
    }

Cleanup:

    //
    //  If IO is pending, return the handle to the pending IO.
    //
    if (params->thrPoolReq != INVALID_THREADPOOLREQUEST) {
        *status = ERROR_IO_PENDING;
        DC_END_FN();
        return params->completionEvent;
    }
    //
    //  Otherwise, clean up the event handle and return NULL so that the 
    //  CompleteIOFunc can be called to send the results to the server.
    //
    else {
        //
        //  Get File Object
        //
        pFile = _FileMgr->GetObject(pIoRequest->FileId);
        if (pFile) {
            pFile->Release();        
        }

        if (params->completionEvent != NULL) {
            CloseHandle(params->completionEvent);
            params->completionEvent = NULL;
        }

        DC_END_FN();
        return NULL;
    }
}

HANDLE 
W32Drive::_StartFSFunc(
    IN W32DRDEV_ASYNCIO_PARAMS *params,
    OUT DWORD *status
    )
{
    return ((W32Drive*)params->pObject)->StartFSFunc(params, status);
}

VOID 
W32Drive::MsgIrpQueryDirectory(
        IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
        IN UINT32 packetLen
        )
/*++     

Routine Description:

    Queries the directory information for this drive device.

Arguments:

    pIoRequestPacket    -   Server IO request packet.
    packetLen           -   length of the packet

Return Value:

    NA

 --*/
{
    ULONG ulRetCode = ERROR_SUCCESS;
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    PRDPDR_IOCOMPLETION_PACKET pReplyPacket;
    ULONG ulReplyPacketSize = 0;
    DWORD result;
    ULONG BufferLength = 0;
    BYTE  Buffer[RDP_FILE_DIRECTORY_INFO_MAXLENGTH + (MAX_PATH + 1) * sizeof(WCHAR)];
    TCHAR *pFileName;
    DrFile *pFile;
    HANDLE FileHandle;
    WIN32_FIND_DATA FileData;
    unsigned DriveLen, PathLen;
    BOOL rc;
    HRESULT hr;

    DC_BEGIN_FN("W32Drive::MsgIrpQueryDirectory");

    ASSERT(_tcslen(_devicePath));

    //
    //  Get IO request pointer.
    //
    pIoRequest = &pIoRequestPacket->IoRequest;

    PathLen = DriveLen = 0;
    pFileName = NULL;
    
    memset(Buffer, 0, sizeof(Buffer));

    //
    //  Map file Id to get the file object
    //
    pFile = _FileMgr->GetObject(pIoRequest->FileId);

    //
    // Query file or directory information
    //
    if (pFile) {
        if (!pIoRequest->Parameters.QueryDir.InitialQuery) {
            ASSERT(((DrFSFile *)pFile)->GetSearchHandle() != INVALID_TS_FILEHANDLE);
            rc = FindNextFile(((DrFSFile *)pFile)->GetSearchHandle(), &FileData);
        }
        else {  
            TCHAR FileName[MAX_PATH];

            //
            // Setup the File Name
            //

            //
            //  Path is assumed string null terminated
            //

            if (packetLen < sizeof(RDPDR_IOREQUEST_PACKET) + pIoRequest->Parameters.QueryDir.PathLength) {
                // call VirtualChannelClose 
                ProcessObject()->GetVCMgr().ChannelClose();
                TRC_ASSERT(FALSE, (TB, _T("Packet Length Error")));
                goto Cleanup;
            }
            PathLen = pIoRequest->Parameters.QueryDir.PathLength / sizeof(WCHAR) - 1;

            if (PathLen) {
                WCHAR *Path;

                //
                // Open a File
                //
                Path = (WCHAR *)(pIoRequestPacket + 1);
                Path[PathLen] = L'\0';

#ifndef OS_WINCE
                DriveLen = _tcslen(_devicePath);
#else
                DriveLen = 0;
#endif

                //
                //  Append device path and file path together
                //
#ifndef OS_WINCE
                if (DriveLen + PathLen < MAX_PATH) {
                    pFileName = &FileName[0];
                    //Length is pre-checked
                    hr = StringCchCopy(pFileName, MAX_PATH, _devicePath);
                    TRC_ASSERT(SUCCEEDED(hr),
                        (TB,_T("Str copy failed for pre-checked len: 0x%x"),hr));
                } else {
                    UINT cchLen = DriveLen + PathLen + 5;
                    pFileName = new TCHAR[cchLen];

                    if (pFileName) {

                        //
                        // The file name needs to be in the \\?\ format.  
                        //
                        // Note: we'll not get UNC path name
                        hr = StringCchPrintf(pFileName,
                                             cchLen,
                                             TEXT("\\\\?\\%s"),
                                             _devicePath);
                        TRC_ASSERT(SUCCEEDED(hr),
                            (TB,_T("Str copy failed for pre-checked len: 0x%x"),hr));
                        DriveLen += 4;

                    } else {
                        TRC_ERR((TB, _T("Failed to alloc File Name")));
                        goto Cleanup;
                    }
                }
#else
                pFileName = &FileName[0];
#endif

#ifndef UNICODE
                RDPConvertToAnsi(Path, pFileName + DriveLen, PathLen + 1);  
#else
                memcpy(pFileName + DriveLen, Path, PathLen * sizeof(WCHAR));
                pFileName[DriveLen + PathLen] = _T('\0');
#endif

            } else {
                //
                // Open the root drive
                //
                hr = StringCchPrintf(FileName, SIZE_TCHARS(FileName),
                                     _T("%s\\"),
                                     _devicePath);
                TRC_ASSERT(SUCCEEDED(hr),
                    (TB,_T("Str printf failed for pre-checked len: 0x%x"),hr));

                pFileName = &FileName[0];                
            }

            FileHandle = FindFirstFile(pFileName, &FileData);
            
            if (FileHandle != INVALID_HANDLE_VALUE) {
                ((DrFSFile *)pFile)->SetSearchHandle(FileHandle);
                rc = TRUE;
            } else {
                rc = FALSE;
            }
        }
    }
    else {
        ulRetCode = ERROR_FILE_NOT_FOUND;
        ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET);
        TRC_ERR((TB, _T("Query directory information failed, %ld."), ulRetCode)); 
        goto SendPacket;
    }

    switch (pIoRequest->Parameters.QueryDir.FileInformationClass) {
        case RdpFileDirectoryInformation:
            if (rc) 
            {
                PRDP_FILE_DIRECTORY_INFORMATION pFileDirInfo = 
                        (PRDP_FILE_DIRECTORY_INFORMATION) Buffer;

                pFileDirInfo->NextEntryOffset = 0;
                pFileDirInfo->FileIndex = 0;
                pFileDirInfo->CreationTime.LowPart = FileData.ftCreationTime.dwLowDateTime;
                pFileDirInfo->CreationTime.HighPart = FileData.ftCreationTime.dwHighDateTime;
                pFileDirInfo->LastAccessTime.LowPart = FileData.ftLastAccessTime.dwLowDateTime;
                pFileDirInfo->LastAccessTime.HighPart = FileData.ftLastAccessTime.dwHighDateTime;
                pFileDirInfo->LastWriteTime.LowPart = FileData.ftLastWriteTime.dwLowDateTime;
                pFileDirInfo->LastWriteTime.HighPart = FileData.ftLastWriteTime.dwHighDateTime;
                pFileDirInfo->ChangeTime.QuadPart = 0;
                pFileDirInfo->EndOfFile.HighPart = FileData.nFileSizeHigh;
                pFileDirInfo->EndOfFile.LowPart = FileData.nFileSizeLow;

                // TODO Do we need to set the allocation size? and what should it be?
                pFileDirInfo->AllocationSize.HighPart = FileData.nFileSizeHigh;
                pFileDirInfo->AllocationSize.LowPart = FileData.nFileSizeLow;
                pFileDirInfo->FileAttributes = FileData.dwFileAttributes;

                pFileDirInfo->FileNameLength = _tcslen(FileData.cFileName) * sizeof(WCHAR);
#ifdef UNICODE
                memcpy(&pFileDirInfo->FileName[0], FileData.cFileName, pFileDirInfo->FileNameLength);
#else
                RDPConvertToUnicode(FileData.cFileName, (LPWSTR)FileNameBuffer, MAX_PATH);
                memcpy(&pFileDirInfo->FileName[0], FileNameBuffer, pFileDirInfo->FileNameLength);

#endif

                ulRetCode = ERROR_SUCCESS;
                
                BufferLength = FIELD_OFFSET(RDP_FILE_DIRECTORY_INFORMATION, FileName) +
                        pFileDirInfo->FileNameLength;
                ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET) +
                        BufferLength - 1;
            }
            else {
                ulRetCode = GetLastError();
                ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET);
                TRC_ERR((TB, _T("Query directory information failed, %ld."), ulRetCode)); 
            }

            break;

        case RdpFileFullDirectoryInformation:
            if (rc)
            {
                PRDP_FILE_FULL_DIR_INFORMATION pFileDirInfo = 
                        (PRDP_FILE_FULL_DIR_INFORMATION) Buffer;

                pFileDirInfo->NextEntryOffset = 0;
                pFileDirInfo->FileIndex = 0;
                pFileDirInfo->CreationTime.LowPart = FileData.ftCreationTime.dwLowDateTime;
                pFileDirInfo->CreationTime.HighPart = FileData.ftCreationTime.dwHighDateTime;
                pFileDirInfo->LastAccessTime.LowPart = FileData.ftLastAccessTime.dwLowDateTime;
                pFileDirInfo->LastAccessTime.HighPart = FileData.ftLastAccessTime.dwHighDateTime;
                pFileDirInfo->LastWriteTime.LowPart = FileData.ftLastWriteTime.dwLowDateTime;
                pFileDirInfo->LastWriteTime.HighPart = FileData.ftLastWriteTime.dwHighDateTime;
                pFileDirInfo->ChangeTime.QuadPart = 0;
                pFileDirInfo->EndOfFile.HighPart = FileData.nFileSizeHigh;
                pFileDirInfo->EndOfFile.LowPart = FileData.nFileSizeLow;
                pFileDirInfo->AllocationSize.HighPart = FileData.nFileSizeHigh;
                pFileDirInfo->AllocationSize.LowPart = FileData.nFileSizeLow;
                pFileDirInfo->FileAttributes = FileData.dwFileAttributes;
                pFileDirInfo->FileNameLength = _tcslen(FileData.cFileName) * sizeof(WCHAR);
                
#ifdef UNICODE
                memcpy(&pFileDirInfo->FileName[0], FileData.cFileName, pFileDirInfo->FileNameLength);
#else
                RDPConvertToUnicode(FileData.cFileName, (LPWSTR)FileNameBuffer, MAX_PATH);
                memcpy(&pFileDirInfo->FileName[0], FileNameBuffer, pFileDirInfo->FileNameLength);

#endif
                pFileDirInfo->EaSize = 0;

                ulRetCode = ERROR_SUCCESS;

                BufferLength = FIELD_OFFSET(RDP_FILE_FULL_DIR_INFORMATION, FileName) +
                        pFileDirInfo->FileNameLength;
                ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET) +
                        BufferLength - 1;
            } 
            else {
                ulRetCode = GetLastError();
                ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET);
                TRC_ERR((TB, _T("Query full directory information failed, %ld."), ulRetCode)); 
            }

            break;

        case RdpFileBothDirectoryInformation:
            if (rc)
            {
                PRDP_FILE_BOTH_DIR_INFORMATION pFileDirInfo = 
                        (PRDP_FILE_BOTH_DIR_INFORMATION) Buffer;

                pFileDirInfo->NextEntryOffset = 0;
                pFileDirInfo->FileIndex = 0;
                pFileDirInfo->CreationTime.LowPart = FileData.ftCreationTime.dwLowDateTime;
                pFileDirInfo->CreationTime.HighPart = FileData.ftCreationTime.dwHighDateTime;
                pFileDirInfo->LastAccessTime.LowPart = FileData.ftLastAccessTime.dwLowDateTime;
                pFileDirInfo->LastAccessTime.HighPart = FileData.ftLastAccessTime.dwHighDateTime;
                pFileDirInfo->LastWriteTime.LowPart = FileData.ftLastWriteTime.dwLowDateTime;
                pFileDirInfo->LastWriteTime.HighPart = FileData.ftLastWriteTime.dwHighDateTime;
                pFileDirInfo->ChangeTime.QuadPart = 0;
                pFileDirInfo->EndOfFile.HighPart = FileData.nFileSizeHigh;
                pFileDirInfo->EndOfFile.LowPart = FileData.nFileSizeLow;
                pFileDirInfo->AllocationSize.HighPart = FileData.nFileSizeHigh;
                pFileDirInfo->AllocationSize.LowPart = FileData.nFileSizeLow;
                pFileDirInfo->FileAttributes = FileData.dwFileAttributes;
                  
                pFileDirInfo->EaSize = 0;
                
#ifndef OS_WINCE
                pFileDirInfo->ShortNameLength = (CCHAR)(_tcslen(FileData.cAlternateFileName) * sizeof(WCHAR));
#else 
                pFileDirInfo->ShortNameLength = sizeof(WCHAR);
#endif           

#ifndef OS_WINCE
#ifdef UNICODE 

                memcpy(&pFileDirInfo->ShortName[0], FileData.cAlternateFileName, pFileDirInfo->ShortNameLength);
#else
                RDPConvertToUnicode(FileData.cAlternateFileName, (LPWSTR)ShortName,
                                    sizeof(ShortName) / sizeof(WCHAR));
                memcpy(&pFileDirInfo->ShortName[0], ShortName, pFileDirInfo->ShortNameLength);
                                    
#endif
#else  
                pFileDirInfo->ShortName[0] = L'\0';
#endif
                
                pFileDirInfo->FileNameLength = _tcslen(FileData.cFileName) * sizeof(WCHAR);
                

#ifdef UNICODE
                memcpy(&pFileDirInfo->FileName[0], FileData.cFileName, pFileDirInfo->FileNameLength);
#else
                RDPConvertToUnicode(FileData.cFileName, FileNameBuffer, MAX_PATH);
                memcpy(&pFileDirInfo->FileName[0], FileNameBuffer, pFileDirInfo->FileNameLength);
#endif  
                ulRetCode = ERROR_SUCCESS;
                BufferLength = FIELD_OFFSET(RDP_FILE_BOTH_DIR_INFORMATION, FileName) + 
                        pFileDirInfo->FileNameLength;
                ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET) +
                        BufferLength - 1;
            } else {
                ulRetCode = GetLastError();
                ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET);
                TRC_ERR((TB, _T("Query both directory info failed, %ld."), ulRetCode)); 
            }
            
            break;

        case RdpFileNamesInformation:
            if (rc) {
                PRDP_FILE_NAMES_INFORMATION pFileDirInfo = 
                        (PRDP_FILE_NAMES_INFORMATION) Buffer;

                pFileDirInfo->NextEntryOffset = 0;
                pFileDirInfo->FileIndex = 0;
                pFileDirInfo->FileNameLength = _tcslen(FileData.cFileName) * sizeof(WCHAR);
                
#ifdef UNICODE
                memcpy(&pFileDirInfo->FileName[0], FileData.cFileName, pFileDirInfo->FileNameLength);
#else
                RDPConvertToUnicode(FileData.cFileName, FileNameBuffer, MAX_PATH);
                memcpy(&pFileDirInfo->FileName[0], FileNameBuffer, pFileDirInfo->FileNameLength);
#endif               
                
                ulRetCode = ERROR_SUCCESS;
                
                BufferLength = sizeof(RDP_FILE_NAMES_INFORMATION) +
                        pFileDirInfo->FileNameLength - sizeof(WCHAR);
                ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET) +
                        BufferLength - 1;
            } else {
                ulRetCode = GetLastError();
                ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET);
                TRC_ERR((TB, _T("Query file names failed, %ld."), ulRetCode)); 
            }

            break;

        default:
            TRC_ERR((TB, _T("Unsupported QueryDirectory class %x"), 
                     pIoRequest->Parameters.QueryDir.FileInformationClass));
            ulRetCode = ERROR_INVALID_FUNCTION;
            ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET);
            break;
    }
    
SendPacket:

    //
    //  Allocate reply buffer.
    //
    pReplyPacket = DrUTL_AllocIOCompletePacket(pIoRequestPacket, ulReplyPacketSize) ;

    if (pReplyPacket) {
        //
        //  Send the result to the server.
        //

        result = TranslateWinError(ulRetCode);

        pReplyPacket->IoCompletion.IoStatus = result;
        pReplyPacket->IoCompletion.Parameters.QueryDir.Length = BufferLength;

        if (BufferLength) 
            memcpy(pReplyPacket->IoCompletion.Parameters.QueryDir.Buffer,
                    Buffer, BufferLength);

        ProcessObject()->GetVCMgr().ChannelWrite(
                (PVOID)pReplyPacket, (UINT)ulReplyPacketSize);
    }
    else {
        TRC_ERR((TB, _T("Failed to alloc %ld bytes."),ulReplyPacketSize));
    }

Cleanup:

    //
    //  Clean up the request packet.
    //
    delete pIoRequestPacket;

    if (pFileName && (DriveLen + PathLen >= MAX_PATH)) {
        delete pFileName;
    }

    DC_END_FN();
}

VOID 
W32Drive::MsgIrpDirectoryControl(
        IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
        IN UINT32 packetLen
        )
/*++     

Routine Description:

    Queries the directory information for this drive device.

Arguments:

    pIoRequestPacket    -   Server IO request packet.
    packetLen           -   length of the packet

Return Value:

    NA

 --*/
{
    W32DRDEV_ASYNCIO_PARAMS *params;
    DrFile* pFile;
    DWORD status;
    
    DC_BEGIN_FN("W32DrDeviceAsync::MsgIrpDirectoryControl");

    TRC_NRM((TB, _T("Request Directory Control")));

    //
    //  Leave the query directory in the forground thread as it is
    //
    if (pIoRequestPacket->IoRequest.MinorFunction == IRP_MN_QUERY_DIRECTORY ||
            pIoRequestPacket->IoRequest.MinorFunction == 0) {
        MsgIrpQueryDirectory(pIoRequestPacket, packetLen);
        return;
    }

    //
    //  Get File Object and reference it
    //
    pFile = _FileMgr->GetObject(pIoRequestPacket->IoRequest.FileId);
    if (pFile) {
        pFile->AddRef();        
    }
    else {
        DefaultIORequestMsgHandle(pIoRequestPacket, STATUS_UNSUCCESSFUL);
        return;
    }

    //  
    //  Allocate and dispatch an asynchronous IO request.
    //
    params = new W32DRDEV_ASYNCIO_PARAMS(this, pIoRequestPacket);
    if (params != NULL ) {

        TRC_NRM((TB, _T("Async IO operation")));

        status = ProcessObject()->DispatchAsyncIORequest(
                        (RDPAsyncFunc_StartIO)W32Drive::_StartFSFunc,
                        (RDPAsyncFunc_IOComplete)W32DrDeviceAsync::_CompleteIOFunc,
                        (RDPAsyncFunc_IOCancel)W32DrDeviceAsync::_CancelIOFunc,
                        params
                        );
    }
    else {
        TRC_ERR((TB, _T("Memory alloc failed.")));
        status = ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    //  Clean up on error.
    //
    if (status != ERROR_SUCCESS) {
        pFile->Release();

        if (params != NULL) {
            delete params;
        }
        delete pIoRequestPacket;        
    }

    DC_END_FN();
}

DWORD 
W32Drive::AsyncDirCtrlFunc(
    IN W32DRDEV_ASYNCIO_PARAMS *params,
    IN HANDLE cancelEvent
    )
/*++

Routine Description:

    Asynchrous Directory Control Function

Arguments:

    params  -   Context for the IO request.

Return Value:

    Always returns 0.

 --*/
{
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
     
    DC_BEGIN_FN("W32Drive::AsyncDirCtrlFunc");

    //
    //  Get the IO request pointer
    //
    pIoRequest = &params->pIoRequestPacket->IoRequest;

    if (pIoRequest->MinorFunction == IRP_MN_NOTIFY_CHANGE_DIRECTORY) {
#if (!defined (OS_WINCE)) || (!defined (WINCE_SDKBUILD))
        return AsyncNotifyChangeDir(params, cancelEvent);
#else
        DrFile* pFile;
	    pFile = _FileMgr->GetObject(pIoRequest->FileId);
        if (pFile)
            pFile->Release();
        return STATUS_NOT_SUPPORTED;
#endif
    }
    else {
        TRC_ASSERT((FALSE), (TB, _T("Invalid Minor Function: %x"), pIoRequest->MinorFunction));
        return ERROR_INVALID_PARAMETER;
    }
}

DWORD 
W32Drive::_AsyncDirCtrlFunc(
    IN  PVOID params,
    IN  HANDLE cancelEvent
    )
{
    return ((W32Drive*)(((W32DRDEV_ASYNCIO_PARAMS *)params)->pObject))->AsyncDirCtrlFunc(
            (W32DRDEV_ASYNCIO_PARAMS *)params, cancelEvent);
}

#if (!defined (OS_WINCE)) || (!defined (WINCE_SDKBUILD))
DWORD 
W32Drive::AsyncNotifyChangeDir(
    IN W32DRDEV_ASYNCIO_PARAMS *params,
    IN HANDLE cancelEvent
    )
/*++

Routine Description:

    Directory change notification Function

Arguments:

    params  -   Context for the IO request.

Return Value:

    Always returns 0.

 --*/
{
    DWORD status;
    ULONG replyPacketSize = 0;
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    PRDPDR_IOCOMPLETION_PACKET pReplyPacket = NULL;
    DrFile* pFile;
    HANDLE FileHandle;
    HANDLE NotifyHandle;
    HANDLE waitableEvents[2];
    HRESULT hr;
    
    DC_BEGIN_FN("W32Drive::AsyncNotifyChangeDir");

    //
    //  Get the IO request pointer
    //
    pIoRequest = &params->pIoRequestPacket->IoRequest;

    //
    //  Get File Object
    //
    pFile = _FileMgr->GetObject(pIoRequest->FileId);
    if (pFile) {
        FileHandle = pFile->GetFileHandle();
        NotifyHandle = ((DrFSFile*)pFile)->GetNotifyHandle();
    }
    else {
        status = ERROR_CANCELLED;
        TRC_ERR((TB, _T("File object already cancelled")));
        goto Cleanup;
    }

    //
    //  Allocate reply buffer.
    //
    replyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET);
    pReplyPacket = DrUTL_AllocIOCompletePacket(params->pIoRequestPacket, 
            replyPacketSize) ;
    if (pReplyPacket == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        TRC_ERR((TB, _T("Failed to alloc %ld bytes."), replyPacketSize));
        goto Cleanup;
    }

    //
    //  Save the reply packet info to the context for this IO operation.
    //
    params->pIoReplyPacket      = pReplyPacket;
    params->IoReplyPacketSize   = replyPacketSize;

    //
    //  If we don't yet have a notification handle.
    //
    if (NotifyHandle == INVALID_HANDLE_VALUE) {
        TRC_ASSERT((((DrFSFile*)pFile)->GetFileName() != NULL), 
                   (TB, _T("FileName is empty")));

        //
        //  Setup the notification handle
        //
        NotifyHandle = FindFirstChangeNotification(((DrFSFile*)pFile)->GetFileName(),
                pIoRequest->Parameters.NotifyChangeDir.WatchTree,
                pIoRequest->Parameters.NotifyChangeDir.CompletionFilter);
        if (NotifyHandle == INVALID_HANDLE_VALUE) {
            status = GetLastError();
            TRC_ERR((TB, _T("FindFirstChangeNotification:  %08X"), status));
            goto Cleanup;
        }

        if (((DrFSFile*)pFile)->SetNotifyHandle(NotifyHandle) == FALSE) {
            FindCloseChangeNotification(NotifyHandle);
            NotifyHandle = INVALID_HANDLE_VALUE;
            status = ERROR_CANCELLED;                
            goto Cleanup;
        }
    }
    else {
        //
        //  Notification handle already setup.  Find next change notification.
        //
        if (!FindNextChangeNotification(NotifyHandle)) {
            status = GetLastError();
            TRC_ERR((TB, _T("FindNextChangeNotification:  %08X"), status));
            goto Cleanup;
        }
    }

    //
    //  Wait for the cancel or notify event to be signaled.
    //
    waitableEvents[0] = NotifyHandle;
    waitableEvents[1] = cancelEvent;
    status = WaitForMultipleObjects(2, waitableEvents, FALSE, INFINITE);
    if (status == WAIT_FAILED) {
        status = GetLastError();
        TRC_ERR((TB, _T("Error %ld."), status));                
    }
    else if (status == WAIT_OBJECT_0){
        status = ERROR_SUCCESS;
    }
    else if (status == WAIT_OBJECT_0 + 1) {
        TRC_ERR((TB, _T("Client got disconnected/logoff")));
        status = ERROR_CANCELLED;                
    }

Cleanup:
    if (pFile)
        pFile->Release();

    DC_END_FN();
    return status;
}
#endif

VOID 
W32Drive::MsgIrpQueryVolumeInfo(
        IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
        IN UINT32 packetLen
        )
/*++

Routine Description:

    This routine handles drive volume level information query
    
Arguments:

    pIoRequestPacket    -   Server IO request packet.
    packetLen           -   Length of the packet

Return Value:

    NA

 --*/
{
    ULONG ulRetCode = ERROR_SUCCESS;
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    PRDPDR_IOCOMPLETION_PACKET pReplyPacket;
    ULONG ulReplyPacketSize = 0;
    DWORD result;
    TCHAR DeviceName[MAX_PATH + 2];
#ifndef OS_WINCE
    TCHAR NameBuffer[MAX_PATH];
    WCHAR TempBuffer[MAX_PATH + 1];
#endif
    ULONG BufferLength = 0;
#ifndef OS_WINCE
    DECLSPEC_ALIGN(8) BYTE  Buffer[RDP_FILE_VOLUME_INFO_MAXLENGTH + MAX_PATH];
#else 
    BYTE Buffer[RDP_FILE_VOLUME_INFO_MAXLENGTH + MAX_PATH];
#endif
    HRESULT hr;

    DC_BEGIN_FN("W32Drive::MsgIrpQueryVolumeInfo");

    TRC_ASSERT((_tcslen(_devicePath) != 0), (TB, _T("Empty devicePath")));

    //
    //  Get IO request pointer.
    //
    pIoRequest = &pIoRequestPacket->IoRequest;

    //
    //  DriveName needs to end with \
    //
#ifndef OS_WINCE
    hr = StringCchPrintf(DeviceName, SIZE_TCHARS(DeviceName),
                         TEXT("%s\\"), _devicePath);
#else
    hr = StringCchPrintf(DeviceName, SIZE_TCHARS(DeviceName),
                         TEXT("\\"));
#endif
    TRC_ASSERT(SUCCEEDED(hr),
        (TB,_T("Str printf failed for pre-checked len: 0x%x"),hr));
    

    memset(Buffer, 0, sizeof(Buffer));

    switch (pIoRequest->Parameters.QueryVolume.FsInformationClass) {
        case RdpFsVolumeInformation:
        {
            RDP_FILE_FS_VOLUME_INFORMATION *pVolumeInfo = 
                    (RDP_FILE_FS_VOLUME_INFORMATION *) Buffer;
            
#ifndef OS_WINCE
            if (GetVolumeInformation(DeviceName, 
                       NameBuffer,
                       MAX_PATH,
                       &pVolumeInfo->VolumeSerialNumber,
                       NULL,
                       NULL, 
                       NULL,
                       0
                       )) 
            {

                pVolumeInfo->VolumeCreationTime.QuadPart = 0;
                pVolumeInfo->SupportsObjects = FALSE;
                pVolumeInfo->VolumeLabelLength = _tcslen(NameBuffer) * sizeof(WCHAR);
                
#ifdef UNICODE
                memcpy(&pVolumeInfo->VolumeLabel[0], NameBuffer, pVolumeInfo->VolumeLabelLength);
#else
                RDPConvertToUnicode(NameBuffer, (LPWSTR)TempBuffer, MAX_PATH);
                memcpy(&pVolumeInfo->VolumeLabel[0], TempBuffer, pVolumeInfo->VolumeLabelLength);
#endif          

                ulRetCode = ERROR_SUCCESS;
                
                BufferLength = FIELD_OFFSET(RDP_FILE_FS_VOLUME_INFORMATION, VolumeLabel) +
                        pVolumeInfo->VolumeLabelLength;
                ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET) +
                        BufferLength - 1;
            }
            else {
                ulRetCode = GetLastError();
                ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET);
                TRC_ERR((TB, _T("Query volume information failed, %ld."), ulRetCode)); 
            }
#else
            pVolumeInfo->VolumeCreationTime.QuadPart = 0;
            pVolumeInfo->SupportsObjects = FALSE;
            pVolumeInfo->VolumeLabelLength = sizeof(WCHAR);
            pVolumeInfo->VolumeLabel[0] = L'\0';
            pVolumeInfo->VolumeSerialNumber = 0;

            ulRetCode = ERROR_SUCCESS;
                
            BufferLength = FIELD_OFFSET(RDP_FILE_FS_VOLUME_INFORMATION, VolumeLabel) +
                    pVolumeInfo->VolumeLabelLength;
            ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET) +
                    BufferLength - 1;

#endif

            break;
        }

        case RdpFsSizeInformation:
        {
            RDP_FILE_FS_SIZE_INFORMATION *pFsSizeInfo = 
                    (RDP_FILE_FS_SIZE_INFORMATION *) Buffer;
            
#ifndef OS_WINCE
            if (GetDiskFreeSpace(DeviceName, 
                                 &pFsSizeInfo->SectorsPerAllocationUnit,
                                 &pFsSizeInfo->BytesPerSector,
                                 &pFsSizeInfo->AvailableAllocationUnits.LowPart,
                                 &pFsSizeInfo->TotalAllocationUnits.LowPart)) 
            {
                ulRetCode = ERROR_SUCCESS;
                BufferLength = sizeof(RDP_FILE_FS_SIZE_INFORMATION);
                ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET) +
                        BufferLength - 1;
            }
            else {
                ulRetCode = GetLastError();
                ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET);
                TRC_ERR((TB, _T("Query volume size failed, %ld."), ulRetCode));
            }
#else
            ULARGE_INTEGER FreeBytesAvailableToCaller;
            if (GetDiskFreeSpaceEx(DeviceName, &FreeBytesAvailableToCaller, 
                                   (PULARGE_INTEGER)&pFsSizeInfo->AvailableAllocationUnits,
                                   (PULARGE_INTEGER)&pFsSizeInfo->TotalAllocationUnits)) {
                pFsSizeInfo->SectorsPerAllocationUnit = 1;
                pFsSizeInfo->BytesPerSector = 1;
                ulRetCode = ERROR_SUCCESS;
                BufferLength = sizeof(RDP_FILE_FS_SIZE_INFORMATION);
                ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET) +
                        BufferLength - 1;
            }
            else {
                ulRetCode = GetLastError();
                ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET);
                TRC_ERR((TB, _T("Query volume size failed, %ld."), ulRetCode));

            }
#endif
            break;
        }

        case RdpFsFullSizeInformation:
        {
            RDP_FILE_FS_FULL_SIZE_INFORMATION *pFsSizeInfo = 
                    (RDP_FILE_FS_FULL_SIZE_INFORMATION *) Buffer;

#ifndef OS_WINCE
            if (GetDiskFreeSpace(DeviceName, 
                                 &pFsSizeInfo->SectorsPerAllocationUnit,
                                 &pFsSizeInfo->BytesPerSector,
                                 &pFsSizeInfo->CallerAvailableAllocationUnits.LowPart,
                                 &pFsSizeInfo->TotalAllocationUnits.LowPart))
            {
                //
                //  TODO what's the difference between actual and caller
                //  available allocation units?
                //
                pFsSizeInfo->ActualAvailableAllocationUnits.QuadPart = 
                        pFsSizeInfo->CallerAvailableAllocationUnits.QuadPart;
                
                ulRetCode = ERROR_SUCCESS;
                BufferLength = sizeof(RDP_FILE_FS_FULL_SIZE_INFORMATION);
                ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET) +
                        BufferLength - 1;
            }
            else {
                ulRetCode = GetLastError();
                ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET);
                TRC_ERR((TB, _T("Query volume full size failed, %ld."), ulRetCode));
            }
#else
            if (GetDiskFreeSpaceEx(DeviceName, 
                                   (PULARGE_INTEGER)&pFsSizeInfo->CallerAvailableAllocationUnits, 
                                   (PULARGE_INTEGER)&pFsSizeInfo->ActualAvailableAllocationUnits,
                                   (PULARGE_INTEGER)&pFsSizeInfo->TotalAllocationUnits)) {
                pFsSizeInfo->SectorsPerAllocationUnit = 1;
                pFsSizeInfo->BytesPerSector = 1;

                ulRetCode = ERROR_SUCCESS;
                BufferLength = sizeof(RDP_FILE_FS_FULL_SIZE_INFORMATION);
                ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET) +
                        BufferLength - 1;
            }
            else {
                ulRetCode = GetLastError();
                ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET);
                TRC_ERR((TB, _T("Query volume size failed, %ld."), ulRetCode));

            }

#endif
            break;
        }

        case RdpFsAttributeInformation:
        {
            RDP_FILE_FS_ATTRIBUTE_INFORMATION *pFsAttribInfo = 
                    (RDP_FILE_FS_ATTRIBUTE_INFORMATION *) Buffer;

#ifndef OS_WINCE
            if (GetVolumeInformation(DeviceName, 
                       NULL,
                       NULL,
                       NULL,
                       (ULONG*)&pFsAttribInfo->MaximumComponentNameLength,
                       &pFsAttribInfo->FileSystemAttributes, 
                       NameBuffer,
                       MAX_PATH
                       )) 
            {
                pFsAttribInfo->FileSystemNameLength =  
                        _tcslen(NameBuffer) * sizeof(WCHAR);
                
#ifdef UNICODE
                memcpy(&pFsAttribInfo->FileSystemName[0], NameBuffer, 
                       pFsAttribInfo->FileSystemNameLength);
#else
                RDPConvertToUnicode(NameBuffer, (LPWSTR)TempBuffer, MAX_PATH);
                memcpy(&pFsAttribInfo->FileSystemName[0], TempBuffer, 
                       pFsAttribInfo->FileSystemNameLength);
#endif          

                ulRetCode = ERROR_SUCCESS;
                BufferLength = FIELD_OFFSET(RDP_FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName) +
                        pFsAttribInfo->FileSystemNameLength;
                ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET) +
                        BufferLength - 1;
            }
            else {
                ulRetCode = GetLastError();
                ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET);
                TRC_ERR((TB, _T("Query file system attributes failed, %ld."), ulRetCode)); 
            }
#else
            
            pFsAttribInfo->MaximumComponentNameLength = MAX_PATH;
            pFsAttribInfo->FileSystemAttributes = FILE_CASE_PRESERVED_NAMES |
                    FILE_UNICODE_ON_DISK; 
            wcscpy(&pFsAttribInfo->FileSystemName[0], L"FAT");
            pFsAttribInfo->FileSystemNameLength =  
                        _tcslen(pFsAttribInfo->FileSystemName) * sizeof(WCHAR);
            
            ulRetCode = ERROR_SUCCESS;
            BufferLength = FIELD_OFFSET(RDP_FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName) +
                    pFsAttribInfo->FileSystemNameLength;
            ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET) +
                    BufferLength - 1;

#endif


            break;
        }
        
        default:
            TRC_ERR((TB, _T("Unsupported QueryVolume class %x"), 
                    pIoRequest->Parameters.QueryVolume.FsInformationClass));
            ulRetCode = ERROR_INVALID_FUNCTION;
            ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET);
            break;
    }

    //
    //  Allocate reply buffer.
    //
    pReplyPacket = DrUTL_AllocIOCompletePacket(pIoRequestPacket, 
                                        ulReplyPacketSize) ;

    if (pReplyPacket) {
        //
        //  Send the result to the server.
        //

        result = TranslateWinError(ulRetCode);

        pReplyPacket->IoCompletion.IoStatus = result;
        pReplyPacket->IoCompletion.Parameters.QueryVolume.Length = BufferLength;

        if (BufferLength) 
            memcpy(pReplyPacket->IoCompletion.Parameters.QueryVolume.Buffer,
                    Buffer, BufferLength);

        ProcessObject()->GetVCMgr().ChannelWrite(
                (PVOID)pReplyPacket, (UINT)ulReplyPacketSize);
    }
    else {
        TRC_ERR((TB, _T("Failed to alloc %ld bytes."),ulReplyPacketSize));
    }

Cleanup:

    //
    //  Clean up the request packet.
    //
    delete pIoRequestPacket;

    DC_END_FN();
}

VOID 
W32Drive::MsgIrpSetVolumeInfo(
        IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
        IN UINT32 packetLen
        )
/*++

Routine Description:

    This routine sets drive volume information.

Arguments:

    pIoRequestPacket    -   Server IO request packet.
    packetLen           -   Length of the packet

Return Value:

    NA

 --*/
{
    ULONG ulRetCode = ERROR_SUCCESS;
    DWORD result;
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    PRDPDR_IOCOMPLETION_PACKET pReplyPacket;
    ULONG ulReplyPacketSize = 0;
    TCHAR DeviceName[MAX_PATH + 2];
    PBYTE pDataBuffer;
    HRESULT hr;

    DC_BEGIN_FN("W32Drive::MsgIrpSetVolumeInfo");

    TRC_ASSERT((_tcslen(_devicePath) != 0), (TB, _T("Empty devicePath")));

    //
    //  Get IO request pointer.
    //
    pIoRequest = &pIoRequestPacket->IoRequest;
    ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET);
    
    //
    //  DriveName needs to end with \
    //
    hr = StringCchPrintf(DeviceName, SIZE_TCHARS(DeviceName),
                         TEXT("%s\\"), _devicePath);
    TRC_ASSERT(SUCCEEDED(hr),
        (TB,_T("Str printf failed for pre-checked len: 0x%x"),hr));

    pDataBuffer = (PBYTE)(pIoRequest + 1);

    switch (pIoRequest->Parameters.SetVolume.FsInformationClass) {
        case RdpFsLabelInformation:
        {
            PRDP_FILE_FS_LABEL_INFORMATION pLabelInfo = 
                    (PRDP_FILE_FS_LABEL_INFORMATION) pDataBuffer;
                
            // To conform with the redirector, we will not allow
            // user to change the volume label info
            ulRetCode = ERROR_ACCESS_DENIED;
            break;

#if 0
            NameBuffer[0] = TEXT('\0');

            RDPConvertToAnsi(pLabelInfo->VolumeLabel, NameBuffer,
                                MAX_PATH);

            if (SetVolumeLabel(DeviceName, NameBuffer)) {
                ulRetCode = ERROR_SUCCESS;
            } else {
                ulRetCode = GetLastError();
                TRC_ERR((TB, _T("Set Volume label failed, %ld."), ulRetCode)); 
            }
#endif
        }
        break;
        
        default:
            TRC_ERR((TB, _T("Unsupported SetVolume class %x"), 
                    pIoRequest->Parameters.SetVolume.FsInformationClass));
            ulRetCode = ERROR_INVALID_FUNCTION;
            break;
    }

    //
    //  Allocate reply buffer.
    //
    pReplyPacket = DrUTL_AllocIOCompletePacket(pIoRequestPacket, 
                                        ulReplyPacketSize) ;

    if (pReplyPacket) {
        //
        //  Send the result to the server.
        //

        result = TranslateWinError(ulRetCode);

        pReplyPacket->IoCompletion.IoStatus = result;
        pReplyPacket->IoCompletion.Parameters.SetVolume.Length = 
                pIoRequest->Parameters.SetVolume.Length;

        ProcessObject()->GetVCMgr().ChannelWrite(
                (PVOID)pReplyPacket, (UINT)ulReplyPacketSize);
    }
    else {
        TRC_ERR((TB, _T("Failed to alloc %ld bytes."),ulReplyPacketSize));
    }

Cleanup:

    //
    //  Clean up the request packet.
    //
    delete pIoRequestPacket;

    DC_END_FN();
}

VOID 
W32Drive::MsgIrpQueryFileInfo(
        IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
        IN UINT32 packetLen
        )
/*++     

Routine Description:

    This routine handles query file information

Arguments:

    pIoRequestPacket    -   Server IO request packet.
    packetLen           -   Length of the packet

Return Value:

    NA

 --*/
{
    ULONG ulRetCode = ERROR_SUCCESS;
    DWORD result;
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    PRDPDR_IOCOMPLETION_PACKET pReplyPacket;
    ULONG ulReplyPacketSize = 0;
    BOOL  rc;
    ULONG BufferLength = 0;
    BYTE  Buffer[RDP_FILE_INFORMATION_MAXLENGTH];
    DrFile* pFile;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    BY_HANDLE_FILE_INFORMATION FileInformation;

    DC_BEGIN_FN("W32Drive::MsgIrpQueryFileInfo");

    TRC_ASSERT((_tcslen(_devicePath) != 0), (TB, _T("Empty device path")));

    //
    //  Get IO request pointer.
    //
    pIoRequest = &pIoRequestPacket->IoRequest;

    memset(Buffer, 0, sizeof(Buffer));

    //
    //  Get file handle
    //
    pFile = _FileMgr->GetObject(pIoRequest->FileId);
    if (pFile) 
        FileHandle = pFile->GetFileHandle();
    
    if (pFile) {

        if (!((DrFSFile *)pFile)->IsDirectory()) {

            TRC_ASSERT((FileHandle != INVALID_TS_FILEHANDLE),
                       (TB, _T("Invalid FileHandle")));
#ifndef OS_WINCE
            rc = GetFileInformationByHandle(FileHandle, &FileInformation);
#else
            rc = CEGetFileInformationByHandle(FileHandle, &FileInformation);
#endif
        }
        else {
            //
            //  This is a directory, we can only get attributes info
            //
            memset(&FileInformation, 0, sizeof(FileInformation));

            FileInformation.dwFileAttributes = 
                    GetFileAttributes(((DrFSFile*)pFile)->GetFileName());

            if (FileInformation.dwFileAttributes != -1) {
                rc = TRUE;
            }
            else {
                rc = FALSE;
            }
        }

        switch (pIoRequest->Parameters.QueryFile.FileInformationClass) {
        
        case RdpFileBasicInformation:
            if (rc)
            {
                PRDP_FILE_BASIC_INFORMATION pFileInfo = 
                        (PRDP_FILE_BASIC_INFORMATION) Buffer;

                pFileInfo->CreationTime.LowPart = FileInformation.ftCreationTime.dwLowDateTime;
                pFileInfo->CreationTime.HighPart = FileInformation.ftCreationTime.dwHighDateTime;
                pFileInfo->LastAccessTime.LowPart = FileInformation.ftLastAccessTime.dwLowDateTime;
                pFileInfo->LastAccessTime.HighPart = FileInformation.ftLastAccessTime.dwHighDateTime;
                pFileInfo->LastWriteTime.LowPart = FileInformation.ftLastWriteTime.dwLowDateTime;
                pFileInfo->LastWriteTime.HighPart = FileInformation.ftLastWriteTime.dwHighDateTime;
                pFileInfo->ChangeTime.QuadPart = 0;
                pFileInfo->FileAttributes = FileInformation.dwFileAttributes;

                ulRetCode = ERROR_SUCCESS;
                BufferLength = sizeof(RDP_FILE_BASIC_INFORMATION);
                ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET) +
                                    BufferLength - 1;
            } else {
                ulRetCode = GetLastError();
                ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET);
                TRC_ERR((TB, _T("Query basic file information failed, %ld."), ulRetCode)); 
            }

            break;

        case RdpFileStandardInformation:
            if (rc)
            {
                PRDP_FILE_STANDARD_INFORMATION pFileInfo = 
                        (PRDP_FILE_STANDARD_INFORMATION) Buffer;

                // TODO: AllocationSize same as EndOfFile Size?
                pFileInfo->AllocationSize.HighPart = FileInformation.nFileSizeHigh;
                pFileInfo->AllocationSize.LowPart = FileInformation.nFileSizeLow;
                pFileInfo->EndOfFile.HighPart = FileInformation.nFileSizeHigh;
                pFileInfo->EndOfFile.LowPart = FileInformation.nFileSizeLow;
                pFileInfo->NumberOfLinks = FileInformation.nNumberOfLinks;
                pFileInfo->DeletePending = 0;
                pFileInfo->Directory = !!(FileInformation.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);

                ulRetCode = ERROR_SUCCESS;
                BufferLength = sizeof(RDP_FILE_STANDARD_INFORMATION);
                ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET) +
                                    BufferLength - 1;
            } else {
                ulRetCode = GetLastError();
                ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET);
                TRC_ERR((TB, _T("Query standard file information failed, %ld."), ulRetCode)); 
            }

            break;

        case RdpFileAttributeTagInformation:
            if (rc)
            {
                PRDP_FILE_ATTRIBUTE_TAG_INFORMATION pFileInfo = 
                        (PRDP_FILE_ATTRIBUTE_TAG_INFORMATION) Buffer;

                // TODO: What's ReparseTag?
                pFileInfo->FileAttributes = FileInformation.dwFileAttributes;
                pFileInfo->ReparseTag = 0;

                ulRetCode = ERROR_SUCCESS;
                BufferLength = sizeof(RDP_FILE_ATTRIBUTE_TAG_INFORMATION);
                ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET) +
                                    BufferLength - 1;
            } else {
                ulRetCode = GetLastError();
                ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET);
                TRC_ERR((TB, _T("Query attribute tag file information failed, %ld."), ulRetCode)); 
            }

            break;

        case RdpFileInternalInformation:
            if (rc)
            {
                PRDP_FILE_INTERNAL_INFORMATION pFileInfo = 
                        (PRDP_FILE_INTERNAL_INFORMATION) Buffer;

                // TODO: should we use this index number?
                pFileInfo->IndexNumber.HighPart = FileInformation.nFileIndexHigh;
                pFileInfo->IndexNumber.LowPart = FileInformation.nFileIndexLow;

                ulRetCode = ERROR_SUCCESS;
                BufferLength = sizeof(RDP_FILE_INTERNAL_INFORMATION);
                ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET) +
                                    BufferLength - 1;
            } else {
                ulRetCode = GetLastError();
                ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET);
                TRC_ERR((TB, _T("CreateFile failed, %ld."), ulRetCode)); 
            }

            break;

        default:
            TRC_ERR((TB, _T("Unsupported QueryFile class %x"), 
                    pIoRequest->Parameters.QueryFile.FileInformationClass));
            ulRetCode = ERROR_INVALID_FUNCTION;
            ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET);
            break;
        }
    }
    else {
        ulRetCode = ERROR_FILE_NOT_FOUND;
        ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET);
    }

    //
    //  Allocate reply buffer.
    //
    pReplyPacket = DrUTL_AllocIOCompletePacket(pIoRequestPacket, 
                                        ulReplyPacketSize) ;
    if (pReplyPacket) {
        //
        //  Send the result to the server.
        //

        result = TranslateWinError(ulRetCode);

        pReplyPacket->IoCompletion.IoStatus = result;
        pReplyPacket->IoCompletion.Parameters.QueryFile.Length = BufferLength;

        if (BufferLength) 
            memcpy(pReplyPacket->IoCompletion.Parameters.QueryFile.Buffer,
                   Buffer, BufferLength);

        ProcessObject()->GetVCMgr().ChannelWrite(
                (PVOID)pReplyPacket, (UINT)ulReplyPacketSize);
    }
    else {
        TRC_ERR((TB, _T("Failed to alloc %ld bytes."),ulReplyPacketSize));
    }

Cleanup:

    //
    //  Clean up the request packet.
    //
    delete pIoRequestPacket;

    DC_END_FN();
}


VOID 
W32Drive::MsgIrpSetFileInfo(
        IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
        IN UINT32 packetLen
        )
/*++

Routine Description:

    This routine handles set file information             
    
Arguments:

    pIoRequestPacket    -   Server IO request packet.
    packetLen           -   Length of the packet

Return Value:

    NA

 --*/
{
    ULONG ulRetCode = ERROR_SUCCESS;
    DWORD result;
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    PRDPDR_IOCOMPLETION_PACKET pReplyPacket;
    ULONG ulReplyPacketSize = 0;
    PBYTE pDataBuffer;
    DrFSFile* pFile;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    HRESULT hr;

    DC_BEGIN_FN("W32Drive::MsgIrpSetFileInfo");

    TRC_ASSERT((_tcslen(_devicePath) != 0), (TB, _T("Empty devicePath")));

    //
    //  Get IO request pointer.
    //
    pIoRequest = &pIoRequestPacket->IoRequest;

    ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET);

    //
    //  Make sure packetLen is right
    //
    if (packetLen < sizeof(RDPDR_IOREQUEST_PACKET) + pIoRequest->Parameters.SetFile.Length) {
        //  VirtualChannelClose
        ProcessObject()->GetVCMgr().ChannelClose();
        TRC_ASSERT(FALSE, (TB, _T("Packet Length Error")));
        goto Cleanup;
    }

    //
    //  Get file handle
    //
    pFile = (DrFSFile *)_FileMgr->GetObject(pIoRequest->FileId);
    if (pFile) 
        FileHandle = pFile->GetFileHandle();
    
    pDataBuffer = (PBYTE)(pIoRequest + 1);

    if (pFile) {
        switch (pIoRequest->Parameters.SetFile.FileInformationClass) {
        
        case RdpFileBasicInformation:
        {
            PRDP_FILE_BASIC_INFORMATION pFileInfo = 
                    (PRDP_FILE_BASIC_INFORMATION) pDataBuffer;
            FILETIME CreationTime, LastAccessTime, LastWriteTime;
            FILETIME *pCreationTime, *pLastAccessTime, *pLastWriteTime;
            
            // 
            //  Set the file attributes if the attributes field is nonzero
            //
            if (pFileInfo->FileAttributes != 0) {
                TRC_ASSERT((pFile->GetFileName() != NULL), (TB, _T("Empty FileName")));

                if (SetFileAttributes(pFile->GetFileName(),
                                      pFileInfo->FileAttributes)) {

                    ulRetCode = ERROR_SUCCESS;
                } else {
                    ulRetCode = GetLastError();
                    TRC_ERR((TB, _T("SetFileAttributes failed, %ld."), ulRetCode));                    
                }
                break;
            }

            //
            //  Set the file time
            //
            
            if (pFileInfo->CreationTime.QuadPart != 0) {
                CreationTime.dwLowDateTime = pFileInfo->CreationTime.LowPart;
                CreationTime.dwHighDateTime = pFileInfo->CreationTime.HighPart;
                pCreationTime = &CreationTime;
            }
            else{ 
                pCreationTime = NULL;
            }

            if (pFileInfo->LastAccessTime.QuadPart != 0) {
                LastAccessTime.dwLowDateTime = pFileInfo->LastAccessTime.LowPart;
                LastAccessTime.dwHighDateTime = pFileInfo->LastAccessTime.HighPart;
                pLastAccessTime = &LastAccessTime;
            }
            else {
                pLastAccessTime = NULL;
            }

            if (pFileInfo->LastWriteTime.QuadPart != 0) {
                LastWriteTime.dwLowDateTime = pFileInfo->LastWriteTime.LowPart;
                LastWriteTime.dwHighDateTime = pFileInfo->LastWriteTime.HighPart;
                pLastWriteTime = &LastWriteTime;
            }
            else {
                pLastWriteTime = NULL;
            }

            if (FileHandle != INVALID_HANDLE_VALUE) {
            
#ifndef OS_WINCE
                if (SetFileTime(FileHandle, pCreationTime, pLastAccessTime, pLastWriteTime)) {
#else
                if (CESetFileTime(FileHandle, pCreationTime, pLastAccessTime, pLastWriteTime)) {
#endif
                    ulRetCode = ERROR_SUCCESS;
                } else {
                    ulRetCode = GetLastError();
                    TRC_ERR((TB, _T("SetFileTime failed, %ld."), ulRetCode)); 
                }
            }
            else {
                ulRetCode = ERROR_SUCCESS;
                TRC_NRM((TB, _T("Can't set filetime for directory")));
            }
        }
        break;

        case RdpFileEndOfFileInformation:
        {
            PRDP_FILE_END_OF_FILE_INFORMATION pFileInfo = 
                    (PRDP_FILE_END_OF_FILE_INFORMATION) pDataBuffer;
            LONG OffsetLow;
            LONG OffsetHigh;

            if (FileHandle != INVALID_HANDLE_VALUE) {
                OffsetLow = pFileInfo->EndOfFile.LowPart;
                OffsetHigh = pFileInfo->EndOfFile.HighPart;

#ifndef OS_WINCE
                if (SetFilePointer(FileHandle, 
#else
                if (CESetFilePointer(FileHandle, 
#endif
                      OffsetLow,
                      &OffsetHigh,
                      FILE_BEGIN) != INVALID_SET_FILE_POINTER) {
                    ulRetCode = NO_ERROR;
                }
                else {
                    ulRetCode = GetLastError();

                    if (ulRetCode != NO_ERROR) {
                        ulRetCode = GetLastError();
                        TRC_ERR((TB, _T("SetFilePointer failed, %ld."), ulRetCode)); 
                    }
                }
                
                if (ulRetCode == NO_ERROR) {
#ifndef OS_WINCE
                    if (SetEndOfFile(FileHandle)) {
#else
                    if (CESetEndOfFile(FileHandle)) {
#endif
                        ulRetCode = ERROR_SUCCESS;
                    } else {
                        ulRetCode = GetLastError();
                        TRC_ERR((TB, _T("SetEndOfFile failed, %ld."), ulRetCode)); 
                    }
                }                
            }
            else {
                ulRetCode = ERROR_FILE_NOT_FOUND;
                TRC_ERR((TB, _T("SetEndOfFile failed, %ld."), ulRetCode)); 
            }
        }
        break;

        case RdpFileDispositionInformation:
        {
            if (pFile->GetFileName()) {
                if (!pFile->IsDirectory()) {
                    pFile->Close();
                    if (DeleteFile(pFile->GetFileName())) {
                        ulRetCode = ERROR_SUCCESS;
                    }
                    else {
                        ulRetCode = GetLastError();
                        TRC_ERR((TB, _T("DeleteFile failed, %ld."), ulRetCode));
                    }
                }
                else {
                    if (RemoveDirectory(pFile->GetFileName())) {
                        ulRetCode = ERROR_SUCCESS;
                    } else {
                        ulRetCode = GetLastError();
                        TRC_ERR((TB, _T("RemoveDirectory failed, %ld."), ulRetCode));
                    }
                }
            }
            else {
                ulRetCode = ERROR_FILE_NOT_FOUND;
                TRC_ERR((TB, _T("DeleteFile/RemoveDirectory failed, %ld."), ulRetCode)); 
            }
        }
        break;

        case RdpFileRenameInformation:
        {
            PRDP_FILE_RENAME_INFORMATION pFileInfo = 
                    (PRDP_FILE_RENAME_INFORMATION) pDataBuffer;
            TCHAR NewFileName[MAX_PATH];

            if (pFile->GetFileName()) {
                pFile->Close();

                if (pFileInfo->RootDirectory == 0) {
                    //
                    //  Copy the devicePath, the filename path
                    //  below is relative to our device path
                    //
#ifndef OS_WINCE
                    hr = StringCchCopy(NewFileName, SIZE_TCHARS(NewFileName),
                                       _devicePath);
                    TRC_ASSERT(SUCCEEDED(hr),
                        (TB,_T("Str copy failed for pre-checked len: 0x%x"),hr));

#else
                    NewFileName[0] = TEXT('\0');
#endif
                }
                else {
                    // The File name passed to us has already contained 
                    // the root directory path
                    NewFileName[0] = TEXT('\0');
                }

#ifdef UNICODE      
                UINT cchLenRemain = SIZE_TCHARS(NewFileName) - (_tcslen(NewFileName) + 1);
                hr =  StringCchCopy(NewFileName + _tcslen(NewFileName),
                                    cchLenRemain,
                                    pFileInfo->FileName);
                if (FAILED(hr)) {
                    TRC_ERR((TB,_T("Fail to copy filename info: 0x%x"),hr));
                    ulRetCode = ERROR_INSUFFICIENT_BUFFER;
                    goto SendPacket;
                }

                
#else                
                RDPConvertToAnsi(pFileInfo->FileName, NewFileName + _tcslen(NewFileName), 
                                 MAX_PATH - _tcslen(NewFileName));
                
#endif
                if (pFileInfo->ReplaceIfExists) {
                    DeleteFile(NewFileName);
                }

                if (MoveFile(pFile->GetFileName(), NewFileName)) {
                    ulRetCode = ERROR_SUCCESS;
                }
                else {
                    ulRetCode = GetLastError();
                    TRC_ERR((TB, _T("MoveFile failed, %ld."), ulRetCode));
                }
            }
            else {
                ulRetCode = ERROR_FILE_NOT_FOUND;
                TRC_ERR((TB, _T("MoveFile failed, %ld."), ulRetCode));
            }
        }
        break;

        case RdpFileAllocationInformation:  
        {
            PRDP_FILE_ALLOCATION_INFORMATION pFileAllocationInfo = 
                    (PRDP_FILE_ALLOCATION_INFORMATION) pDataBuffer;

            ulRetCode = ERROR_SUCCESS;

            TRC_NRM((TB, _T("Get RdpFileAllocationInformation")));

            // If server side call CreateFile with TRUNCATE_EXISTING flag
            // server will send FileAllocationInformation with 
            // AllocationSize.QuadPart is 0, we need to truncate the file
            // Currently we don't support other QuadPart value
            if (0 == pFileAllocationInfo->AllocationSize.QuadPart) {
                        
                if (FileHandle != INVALID_HANDLE_VALUE) {
                    if (INVALID_SET_FILE_POINTER != SetFilePointer(FileHandle, 0, 0, FILE_BEGIN))
                    {
                        if (!SetEndOfFile(FileHandle)) {
                            TRC_ERR((TB, _T("SetEndOfFile failed with %x"), GetLastError()));
                            ulRetCode = GetLastError();
                        } 
                    }
                    else 
                    {
                        TRC_ERR((TB, _T("SetFilePointer failed with %x"), GetLastError()));
                        ulRetCode = GetLastError();
                    }
                }
                else {
                    TRC_ERR((TB, _T("File handle invalid in setting FileAllocationInfo")));
                    ulRetCode = ERROR_FILE_NOT_FOUND;
                }
            }
            else {
                TRC_ASSERT(FALSE, (TB, _T("Get FileAllocationInformation with unsupported %d"),
                                   pFileAllocationInfo->AllocationSize.QuadPart));
                // Still return success here to avoid regression
            }
        }

        break;

        default:
            TRC_ERR((TB, _T("Unsupported SetFile class %x"), 
                     pIoRequest->Parameters.SetFile.FileInformationClass));
            ulRetCode = ERROR_INVALID_FUNCTION;
            break;
        }
    }
    else {
        ulRetCode = ERROR_FILE_NOT_FOUND;        
    }

SendPacket:
    //
    //  Allocate reply buffer.
    //
    pReplyPacket = DrUTL_AllocIOCompletePacket(pIoRequestPacket, 
                                        ulReplyPacketSize) ;

    if (pReplyPacket) {
        //
        //  Send the result to the server.
        //

        result = TranslateWinError(ulRetCode);

        pReplyPacket->IoCompletion.IoStatus = result;
        pReplyPacket->IoCompletion.Parameters.SetFile.Length = 
                pIoRequest->Parameters.SetFile.Length;

        ProcessObject()->GetVCMgr().ChannelWrite(
                (PVOID)pReplyPacket, (UINT)ulReplyPacketSize);
    }
    else {
        TRC_ERR((TB, _T("Failed to alloc %ld bytes."),ulReplyPacketSize));
    }

Cleanup:
    
    //
    //  Clean up the request packet.
    //
    delete pIoRequestPacket;

    DC_END_FN();
}

VOID 
W32Drive::MsgIrpDeviceControl(
        IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
        IN UINT32 packetLen
        )
/*++

Routine Description:

    Handle a file system control request from the server.

Arguments:

    pIoRequestPacket    -   Server IO request packet.
    packetLen           -   Length of the packet

Return Value:

    NA

 --*/
{
    DC_BEGIN_FN("W32Drive::MsgIrpDeviceControl");

    DispatchIOCTLDirectlyToDriver(pIoRequestPacket);

    DC_END_FN();
}

VOID 
W32Drive::MsgIrpLockControl(
        IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
        IN UINT32 packetLen
        )
/*++

Routine Description:

    Handle a file system lock control request from the server.

Arguments:

    pIoRequestPacket    -   Server IO request packet.
    packetLen           -   Length of the packet

Return Value:

    NA

 --*/
{
    ULONG ulRetCode = ERROR_SUCCESS;
    DWORD result;
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    PRDPDR_IOCOMPLETION_PACKET pReplyPacket;
    ULONG ulReplyPacketSize = 0;
    DrFSFile* pFile;
    HANDLE FileHandle;
    PRDP_LOCK_INFO LockInfo;
    
    DC_BEGIN_FN("W32Drive::MsgIrpLockControl");

    //
    //  Get IO request pointer.
    //
    pIoRequest = &pIoRequestPacket->IoRequest;

    //
    //  Make sure the packetlength is right
    //
    if (packetLen < sizeof(RDPDR_IOREQUEST_PACKET) + sizeof(RDP_LOCK_INFO) * pIoRequest->Parameters.Locks.NumLocks) {
        // Call VirtualChannelClose
        ProcessObject()->GetVCMgr().ChannelClose();
        TRC_ASSERT(FALSE, (TB, _T("Packet Length Error")));
        goto Cleanup;
    }

    //
    //  Get file lock info
    //
    LockInfo = (PRDP_LOCK_INFO) (pIoRequest + 1);

    //
    //  Get file handle
    //
    pFile = (DrFSFile *)_FileMgr->GetObject(pIoRequest->FileId);
    if (pFile) 
        FileHandle = pFile->GetFileHandle();
    else 
        FileHandle = INVALID_HANDLE_VALUE;

    TRC_ASSERT((FileHandle != INVALID_HANDLE_VALUE), (TB, _T("Invalid FileHandle")));

    ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET);

    if (FileHandle != INVALID_HANDLE_VALUE) {
        switch (pIoRequest->Parameters.Locks.Operation) {
        
        //
        //  Share lock request
        //
        case RDP_LOWIO_OP_SHAREDLOCK:
        {
            OVERLAPPED Overlapped;

            Overlapped.hEvent = 0;
            Overlapped.Internal = 0;
            Overlapped.InternalHigh = 0;
            Overlapped.Offset = LockInfo->OffsetLow;
            Overlapped.OffsetHigh = LockInfo->OffsetHigh;
#ifndef OS_WINCE
            if (!LockFileEx(FileHandle, 
#else            
            if (!CELockFileEx(FileHandle, 
#endif            
                            (pIoRequest->Parameters.Locks.Flags & SL_FAIL_IMMEDIATELY) ?
                            LOCKFILE_FAIL_IMMEDIATELY : 0,
                            0, 
                            LockInfo->LengthLow,
                            LockInfo->LengthHigh,
                            &Overlapped)) {
                ulRetCode = GetLastError();
                TRC_ERR((TB, _T("Lock File failed, %ld."), ulRetCode));
            }
            break;
        }

        //
        //  Exclusive lock request
        // 
        case RDP_LOWIO_OP_EXCLUSIVELOCK:
#ifndef OS_WINCE        
            if (!LockFile(FileHandle,
#else
            if (!CELockFile(FileHandle,
#endif            
                         LockInfo->OffsetLow,
                         LockInfo->OffsetHigh,
                         LockInfo->LengthLow,
                         LockInfo->LengthHigh)) {
                ulRetCode = GetLastError();
                TRC_ERR((TB, _T("Lock File failed, %ld."), ulRetCode));
            }
            break;

        //
        //  Unlock request
        //
        case RDP_LOWIO_OP_UNLOCK:
        {
            for (unsigned i = 0; i < pIoRequest->Parameters.Locks.NumLocks; i++) {
#ifndef OS_WINCE        
                if (!UnlockFile(FileHandle,
#else
                if (!CEUnlockFile(FileHandle,
#endif
                               LockInfo->OffsetLow,
                               LockInfo->OffsetHigh,
                               LockInfo->LengthLow,
                               LockInfo->LengthHigh)) {
                    ulRetCode = GetLastError();
                    TRC_ERR((TB, _T("Unlock File failed, %ld."), ulRetCode));
                    break;
                }

                LockInfo++;
            }
            break;
        }

        default:
            ulRetCode = ERROR_INVALID_FUNCTION;
            TRC_ERR((TB, _T("Invalid lock operation %x"), pIoRequest->Parameters.Locks.Operation));
        }
    }
    else {
        ulRetCode = ERROR_FILE_NOT_FOUND;
        TRC_ERR((TB, _T("Lock File failed, %ld."), ulRetCode));
    }

    //
    //  Allocate reply buffer.
    //
    pReplyPacket = DrUTL_AllocIOCompletePacket(pIoRequestPacket, 
                                        ulReplyPacketSize) ;

    if (pReplyPacket) {
        //
        //  Send the result to the server.
        //

        result = TranslateWinError(ulRetCode);

        pReplyPacket->IoCompletion.IoStatus = result;

        ProcessObject()->GetVCMgr().ChannelWrite(
                (PVOID)pReplyPacket, (UINT)ulReplyPacketSize);
    }
    else {
        TRC_ERR((TB, _T("Failed to alloc %ld bytes."),ulReplyPacketSize));
    }

Cleanup:

    //
    //  Clean up the request packet.
    //
    delete pIoRequestPacket;

    DC_END_FN();
}

#ifndef OS_WINCE
BOOL SetPrivilege(
    HANDLE hToken,          // token handle
    LPCTSTR Privilege,      // Privilege to enable/disable
    BOOL fEnablePrivilege   // TRUE to enable.  FALSE to disable
    )
{
    BOOL rc = TRUE;
    TOKEN_PRIVILEGES tp;
    LUID luid;
    TOKEN_PRIVILEGES tpPrevious;
    DWORD cbPrevious = sizeof(TOKEN_PRIVILEGES);
    HMODULE hModule = NULL;
            
    typedef BOOL (FNLOOKUP_PRIVILEGE_VALUE)(LPCTSTR, LPCTSTR, PLUID);
    FNLOOKUP_PRIVILEGE_VALUE *pfnLookupPrivilegeValue;
            
    typedef BOOL (FNADJUST_TOKEN_PRIVILEGES)(HANDLE, BOOL, PTOKEN_PRIVILEGES, 
                                             DWORD, PTOKEN_PRIVILEGES, PDWORD);
    FNADJUST_TOKEN_PRIVILEGES *pfnAdjustTokenPrivileges;

    // get the handle to advapi32.dll library
    hModule = LoadLibrary(TEXT("ADVAPI32.DLL"));
            
    if (hModule != NULL) {
        // get the proc address for LookupPrivilegeValue
#ifdef UNICODE
        pfnLookupPrivilegeValue = (FNLOOKUP_PRIVILEGE_VALUE *)GetProcAddress(hModule, "LookupPrivilegeValueW");
#else
        pfnLookupPrivilegeValue = (FNLOOKUP_PRIVILEGE_VALUE *)GetProcAddress(hModule, "LookupPrivilegeValueA");
#endif    
        if (pfnLookupPrivilegeValue) {
            if (!pfnLookupPrivilegeValue(NULL, Privilege, &luid)) {
                rc = FALSE;
                goto EXIT;
            }               
        }
        else {
            // Let it return true.
            goto EXIT;
        }

        pfnAdjustTokenPrivileges = (FNADJUST_TOKEN_PRIVILEGES *)GetProcAddress(hModule, "AdjustTokenPrivileges");

        if (pfnAdjustTokenPrivileges) {
            // 
            // first pass.  get current privilege setting
            // 
            tp.PrivilegeCount           = 1;
            tp.Privileges[0].Luid       = luid;
            tp.Privileges[0].Attributes = 0;
         
            pfnAdjustTokenPrivileges(
                hToken,
                FALSE,
                &tp,
                sizeof(TOKEN_PRIVILEGES),
                &tpPrevious,
                &cbPrevious);
         
            if (GetLastError() != ERROR_SUCCESS) {
                rc = FALSE;
                goto EXIT;
            }
         
            // 
            // second pass.  set privilege based on previous setting
            // 
            tpPrevious.PrivilegeCount       = 1;
            tpPrevious.Privileges[0].Luid   = luid;
         
            if (fEnablePrivilege)
            {
                tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED);
            }
            else
            {
                tpPrevious.Privileges[0].Attributes ^=
                        (SE_PRIVILEGE_ENABLED & tpPrevious.Privileges[0].Attributes);
            }
         
            pfnAdjustTokenPrivileges(
                hToken,
                FALSE,
                &tpPrevious,
                cbPrevious,
                NULL,
                NULL);
         
            if (GetLastError() != ERROR_SUCCESS) {
                rc = FALSE;
                goto EXIT;
            }
        }                
    }

EXIT:
    if (hModule) {
        FreeLibrary(hModule);
    }
    
    return rc;
}
#endif


VOID 
W32Drive::MsgIrpQuerySdInfo(
        IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
        IN UINT32 packetLen
        )
/*++

Routine Description:

    Handle a file system control request from the server.

Arguments:

    pIoRequestPacket    -   Server IO request packet.
    packetLen           -   Length of the packet

Return Value:

    NA

 --*/
{
    ULONG ulRetCode = ERROR_SUCCESS;
    DWORD result;
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    PRDPDR_IOCOMPLETION_PACKET pReplyPacket;
    ULONG ulReplyPacketSize = 0;
    DrFSFile* pFile;
    HANDLE FileHandle;
    BYTE* pSecurityDescriptor = NULL;
    ULONG LengthNeeded = 0;
    ULONG BufferLength = 0;
    HANDLE hProcessToken = NULL;
    HMODULE hModule = NULL;
    
    DC_BEGIN_FN("W32Drive::MsgIrpQuerySd");

    //
    //  Get IO request pointer.
    //
    pIoRequest = &pIoRequestPacket->IoRequest;

    //
    //  Get file handle
    //
    pFile = (DrFSFile *)_FileMgr->GetObject(pIoRequest->FileId);
    if (pFile) 
        FileHandle = pFile->GetFileHandle();
    else 
        FileHandle = INVALID_HANDLE_VALUE;


    if (pFile) {
#ifndef OS_WINCE
        
        if (pIoRequest->Parameters.QuerySd.SecurityInformation & SACL_SECURITY_INFORMATION) {
            
            typedef BOOL (FNOPEN_PROCESS_TOKEN)(HANDLE, DWORD, PHANDLE);
            FNOPEN_PROCESS_TOKEN *pfnOpenProcessToken;
            
            // get the handle to advapi32.dll library
            hModule = LoadLibrary(TEXT("ADVAPI32.DLL"));
            
            if (hModule != NULL) {
                
                // get the proc address for OpenProcessToken
                pfnOpenProcessToken = (FNOPEN_PROCESS_TOKEN *)GetProcAddress(hModule, "OpenProcessToken");
            
                if (pfnOpenProcessToken) {
                    //
                    // Get the process token for this process.  We'll
                    // need it in just a second ....
                    //
                    if (!pfnOpenProcessToken(GetCurrentProcess(),
                           TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                           &hProcessToken))
                    {
                        ulRetCode = GetLastError();
                        TRC_ERR((TB, _T("OpenProcessToken failed, error %d."), ulRetCode));
                        ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET);
                        goto SendPacket;
                    } 
        
                    //
                    // Turn on SeSecurityPrivilege (by name that's SE_SECURITY_NAME).  This allows
                    // us to read SACLs
                    //
                    if (!SetPrivilege(hProcessToken,
                          SE_SECURITY_NAME,
                          TRUE))
                    {
                        ulRetCode = GetLastError();
                        TRC_ERR((TB, _T("SetPrivilege failed. %d."), ulRetCode));
                        ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET);
                        goto SendPacket;              
                    }                            
                }            
            }            
        }

        GetFileSecurity(pFile->GetFileName(),
                            pIoRequest->Parameters.QuerySd.SecurityInformation,
                            NULL,
                            0,
                            &LengthNeeded);

        
        if (LengthNeeded > 0) {
            pSecurityDescriptor = new BYTE[LengthNeeded];
        
            if (pSecurityDescriptor != NULL) {
                if (GetFileSecurity(pFile->GetFileName(),
                     pIoRequest->Parameters.QuerySd.SecurityInformation,
                     pSecurityDescriptor,
                     LengthNeeded,
                     &LengthNeeded)) {
    
                    BufferLength = GetSecurityDescriptorLength(
                            (PSECURITY_DESCRIPTOR)pSecurityDescriptor);
                    ulRetCode = ERROR_SUCCESS;
                    ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET) +
                            BufferLength - 1;
                }
                else {
                    ulRetCode = GetLastError();
                    ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET);
                    TRC_ERR((TB, _T("GetFileSecurity failed, %ld."), ulRetCode));
                }
            }
            else {
                ulRetCode = GetLastError();
                ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET);
                TRC_ERR((TB, _T("Failed to allocate memory for security descriptor")));
            }
        }
        else {
            ulRetCode = GetLastError();
            ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET);
            TRC_ERR((TB, _T("GetFileSecurity failed, %ld."), ulRetCode));
        }        
#else
        BYTE bSecDescr[sizeof(SECURITY_DESCRIPTOR) + (2*sizeof(SID))];
        BufferLength = sizeof(bSecDescr);
        pSecurityDescriptor = bSecDescr;

        SECURITY_DESCRIPTOR sd;
        if (InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION) && 
            SetSecurityDescriptorGroup(&sd, NULL, FALSE) && 
            SetSecurityDescriptorOwner(&sd, NULL, FALSE) && 
            SetSecurityDescriptorDacl(&sd, (pIoRequest->Parameters.QuerySd.SecurityInformation & DACL_SECURITY_INFORMATION), NULL, FALSE) && 
            SetSecurityDescriptorSacl(&sd, (pIoRequest->Parameters.QuerySd.SecurityInformation & SACL_SECURITY_INFORMATION), NULL, FALSE) &&
            MakeSelfRelativeSD(&sd, pSecurityDescriptor, &BufferLength)) {
            ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET) + BufferLength - 1;
            ulRetCode = ERROR_SUCCESS;
        }
        else {
            ulRetCode = ERROR_INVALID_PARAMETER;
            ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET);
            TRC_ERR((TB, _T("Failed to construct a security descriptor, %ld."), ulRetCode));
        }
#endif        
    }
    else {
        ulRetCode = ERROR_FILE_NOT_FOUND;
        ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET);
    }

SendPacket:

    //
    //  Allocate reply buffer.
    //
    pReplyPacket = DrUTL_AllocIOCompletePacket(pIoRequestPacket, 
                                        ulReplyPacketSize) ;

    if (pReplyPacket) {
        //
        //  Send the result to the server.
        //

        result = TranslateWinError(ulRetCode);

        pReplyPacket->IoCompletion.IoStatus = result;

        pReplyPacket->IoCompletion.Parameters.QuerySd.Length = BufferLength;

        if (BufferLength) 
            memcpy(pReplyPacket->IoCompletion.Parameters.QuerySd.Buffer,
                   pSecurityDescriptor, BufferLength);

        ProcessObject()->GetVCMgr().ChannelWrite(
                (PVOID)pReplyPacket, (UINT)ulReplyPacketSize);
    }
    else {
        TRC_ERR((TB, _T("Failed to alloc %ld bytes."),ulReplyPacketSize));
    }

Cleanup:

    //
    //  Clean up the request packet.
    //
    delete pIoRequestPacket;

#ifndef OS_WINCE
    //
    //  Clean up the security descriptor buffer
    //
    if (pSecurityDescriptor != NULL) {
        delete pSecurityDescriptor;
    }
#endif

    if (hModule) {
        FreeLibrary(hModule);
    }

    if (hProcessToken) {
        CloseHandle(hProcessToken);
    }

    DC_END_FN();
}

VOID 
W32Drive::MsgIrpSetSdInfo(
        IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
        IN UINT32 packetLen
        )
/*++

Routine Description:

    Handle a file system set security request from the server.

Arguments:

    pIoRequestPacket    -   Server IO request packet.
    packetLen           -   Length of the packet

Return Value:

    NA

 --*/
{
    ULONG ulRetCode = ERROR_SUCCESS;
    DWORD result;
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    PRDPDR_IOCOMPLETION_PACKET pReplyPacket;
    ULONG ulReplyPacketSize = 0;
    DrFSFile* pFile;
    HANDLE FileHandle;
#ifndef OS_WINCE
    PSECURITY_DESCRIPTOR SecurityDescriptor;
#endif

    DC_BEGIN_FN("W32Drive::MsgIrpQuerySd");

    //
    //  Get IO request pointer.
    //
    pIoRequest = &pIoRequestPacket->IoRequest;

    //
    //  Make sure the packetLen is right
    //
    if (packetLen < sizeof(RDPDR_IOREQUEST_PACKET) + pIoRequest->Parameters.SetSd.Length) {
        //  VirtualChannelClose
        ProcessObject()->GetVCMgr().ChannelClose();
        TRC_ASSERT(FALSE, (TB, _T("Packet Length Error")));
        goto Cleanup;
    }

    //
    //  Get file handle
    //
    pFile = (DrFSFile *)_FileMgr->GetObject(pIoRequest->FileId);
    if (pFile) 
        FileHandle = pFile->GetFileHandle();
    else 
        FileHandle = INVALID_HANDLE_VALUE;

#ifndef OS_WINCE
    //
    // Set the file security
    //
    SecurityDescriptor = (PSECURITY_DESCRIPTOR)(pIoRequest + 1);
#endif
    
    if (pFile) {
#ifndef OS_WINCE
        if (SetFileSecurity(pFile->GetFileName(),
                 pIoRequest->Parameters.SetSd.SecurityInformation,
                 SecurityDescriptor)) {
            ulRetCode = ERROR_SUCCESS;
            ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET) ;
        }
        else {
            ulRetCode = GetLastError();
            ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET);
            TRC_ERR((TB, _T("Lock File failed, %ld."), ulRetCode));
        }
#else
        ulRetCode = ERROR_SUCCESS;
        ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET);
#endif        

    }
    else {
        ulRetCode = ERROR_FILE_NOT_FOUND;
        ulReplyPacketSize = sizeof(RDPDR_IOCOMPLETION_PACKET);
    }

    //
    //  Allocate reply buffer.
    //
    pReplyPacket = DrUTL_AllocIOCompletePacket(pIoRequestPacket, 
                                        ulReplyPacketSize) ;

    if (pReplyPacket) {
        //
        //  Send the result to the server.
        //

        result = TranslateWinError(ulRetCode);

        pReplyPacket->IoCompletion.IoStatus = result;

        ProcessObject()->GetVCMgr().ChannelWrite(
                (PVOID)pReplyPacket, (UINT)ulReplyPacketSize);
    }
    else {
        TRC_ERR((TB, _T("Failed to alloc %ld bytes."),ulReplyPacketSize));
    }

Cleanup:

    //
    //  Clean up the request packet.
    //
    delete pIoRequestPacket;

    DC_END_FN();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\w32drman.h ===
/*++

    Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    w32drman

Abstract:

    This module defines a special subclass of the Win32 client-side RDP
    printer redirection "device" class.  The subclass, W32DrManualPrn 
    manages a queue that is manually installed by a user by attaching
    a server-side queue to a client-side redirected printing port.

Author:

    Tad Brockway 3/23/99

Revision History:

--*/

#ifndef __W32DRMAN_H__
#define __W32DRMAN_H__

#include "w32drprn.h"


///////////////////////////////////////////////////////////////
//
//	W32DrManualPrn
//
//

class W32DrManualPrn : public W32DrPRN
{
private:

    BOOL    _isSerialPort;    

	//
    //  Parse the cached printer information for specific information
    //  about this printer.
    //
    BOOL ParsePrinterCacheInfo();

public:

    //  
    //  Constructor/Destructor
    //
    W32DrManualPrn(ProcObj *processObject, const DRSTRING printerName, 
                const DRSTRING driverName,
                const DRSTRING portName, BOOL defaultPrinter, ULONG id);
    virtual ~W32DrManualPrn();

    //
    //  Post-IRP_MJ_CREATE initialization.
    //
    virtual DWORD InitializeDevice(DrFile* fileObj);

    //
    //  Enumerate devices of this type.
    //
    static DWORD Enumerate(ProcObj *procObj, DrDeviceMgr *deviceMgr);

    //
    //  To notify the printer object that the cached data has been restored
    //  in case it needs to read information out of the cached data.
    //
    virtual VOID CachedDataRestored(); 

    //
    //  Get the device type.  See "Device Types" section of rdpdr.h
    //
    virtual ULONG GetDeviceType()   { return RDPDR_DTYP_PRINT; }

    //
    //  Return the class name.
    //
    virtual DRSTRING ClassName()  { return TEXT("W32DrManualPrn"); }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\w32drlpt.h ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    w32drlpt

Abstract:

    This module defines the parent for the Win32 client-side RDP
    LPT port redirection "device" class hierarchy, W32DrLPT.

Author:

    Tad Brockway 3/23/99

Revision History:

--*/

#ifndef __W32DRLPT_H__
#define __W32DRLPT_H__

#include "w32drprt.h"


///////////////////////////////////////////////////////////////
//
//	W32DrLPT
//

class W32DrLPT : public W32DrPRT
{
private:

public:

    //
    //  Constructor
    //
    W32DrLPT(ProcObj *processObject, const DRSTRING portName, 
            ULONG deviceID, const TCHAR *devicePath);

    //
    //  Returns the configurable LPT port max ID.
    //
    static DWORD GetLPTPortMax(ProcObj *procObj);

    //
    //  Enumerate devices of this type.
    //
    static DWORD Enumerate(ProcObj *procObj, DrDeviceMgr *deviceMgr);

    //
    //  Get the device type.  See "Device Types" section of rdpdr.h
    //
    virtual ULONG GetDeviceType()   { return RDPDR_DTYP_PARALLEL; }

    //
    //  Return the class name.
    //
    virtual DRSTRING ClassName()  { return TEXT("W32DrLPT"); }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\w32drlpt.cpp ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    w32drlpt

Abstract:

    This module defines the parent for the Win32 client-side RDP
    LPT port redirection "device" class hierarchy, W32DrLPT.

Author:

    Tad Brockway 3/23/99

Revision History:

--*/

#include <precom.h>

#define TRC_FILE  "W32DrLPT"

#include "w32drlpt.h"
#include "drobjmgr.h"
#include "w32proc.h"
#include "drconfig.h"
#include "drdbg.h"


///////////////////////////////////////////////////////////////
//
//	W32DrLPT Members
//

W32DrLPT::W32DrLPT(ProcObj *processObject, const DRSTRING portName, 
                   ULONG deviceID, const TCHAR *devicePath) : 
            W32DrPRT(processObject, portName, deviceID, devicePath)

/*++

Routine Description:

    Constructor

Arguments:

    processObject   -   Associated Process Object
    portName        -   Name of the port.
    deviceID        -   Device ID for the port.
    devicePath      -   Path that can be opened via CreateFile for port.

Return Value:

    NA

 --*/
{
    DC_BEGIN_FN("W32DrLPT::W32DrLPT");
    DC_END_FN();
}

#ifndef OS_WINCE
DWORD 
W32DrLPT::Enumerate(
    IN ProcObj *procObj, 
    IN DrDeviceMgr *deviceMgr
    )
/*++

Routine Description:

    Enumerate devices of this type by adding appropriate device
    instances to the device manager.

Arguments:

    procObj     -   Corresponding process object.
    deviceMgr   -   Device manager to add devices to.

Return Value:

    ERROR_SUCCESS on success.  Otherwise, an error code is returned.

 --*/
{
    ULONG ulPortNum;
    TCHAR path[MAX_PATH];
    DrDevice *deviceObj;   
    TCHAR portName[64];
    DWORD lptPortMax;

    DC_BEGIN_FN("W32DrLPT::Enumerate");

    if(!procObj->GetVCMgr().GetInitData()->fEnableRedirectPorts)
    {
        TRC_DBG((TB,_T("Port redirection disabled, bailing out")));
        return ERROR_SUCCESS;
    }

    lptPortMax = GetLPTPortMax(procObj);

    //
    //  Scan LPT ports.
    //
    for (ulPortNum=0; ulPortNum<lptPortMax; ulPortNum++) {
        StringCchPrintf(portName, SIZE_TCHARS(portName),
                        TEXT("LPT%ld"), ulPortNum);
        StringCchPrintf(path, SIZE_TCHARS(path),
                        TEXT("\\\\.\\%s"), portName);

        HANDLE hndl = CreateFile(
                            path,
                            GENERIC_READ | GENERIC_WRITE,
                            0,                    // exclusive access
                            NULL,                 // no security attrs
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL |
                            FILE_FLAG_OVERLAPPED, // overlapped I/O
                            NULL
                            );
        if ((hndl != INVALID_HANDLE_VALUE) || 
            (GetLastError() != ERROR_FILE_NOT_FOUND)){
#ifndef OS_WINCE
            TCHAR TargetPath[MAX_PATH];
#endif

            CloseHandle(hndl);

#ifndef OS_WINCE
            if (procObj->Is9x() || QueryDosDevice(portName, TargetPath, sizeof(TargetPath) / sizeof(TCHAR))) {
                if (_tcsstr(TargetPath, TEXT("RdpDr")) == NULL) {
#endif

                    //
                    //  Create a new LPT port device object.
                    //
                    TRC_NRM((TB, _T("Adding LPT Device %s."), path));
                    deviceObj = new W32DrLPT(procObj, portName, 
                                             deviceMgr->GetUniqueObjectID(), path);
                    //
                    //  Add to the device manager if we got a valid object.
                    //
                    if (deviceObj != NULL) {
                        deviceObj->Initialize();
                        if (!(deviceObj->IsValid() && 
                             (deviceMgr->AddObject(deviceObj) == STATUS_SUCCESS))) {
                                delete deviceObj;
                        }
                    }
#ifndef OS_WINCE
                }
            }
#endif
        }
    }

    DC_END_FN();
    return ERROR_SUCCESS;
}

#else
DWORD 
W32DrLPT::Enumerate(
    IN ProcObj *procObj, 
    IN DrDeviceMgr *deviceMgr
    )
{
    ULONG ulPortNum;
    TCHAR path[MAX_PATH];
    DrDevice *deviceObj;   
    TCHAR portName[64];

    DC_BEGIN_FN("W32DrLPT::Enumerate");

    if(!procObj->GetVCMgr().GetInitData()->fEnableRedirectPorts)
    {
        TRC_DBG((TB,_T("Port redirection disabled, bailing out")));
        return ERROR_SUCCESS;
    }

    ulPortNum = GetActivePortsList(L"LPT");
    if (ulPortNum == 0)
    {
        TRC_DBG((TB,_T("No LPT ports found.")));
        return ERROR_SUCCESS;
    }

    TRC_ASSERT(((ulPortNum & 0xFFFFFC00) == 0), (TB, _T("LPT port numbers > 9 found!")));

    for (ULONG i=0; i<10; i++)
    {
        if ( (ulPortNum & (1 << i)) == 0)
            continue;

        _stprintf(portName, _T("LPT%ld"), i);
        _stprintf(path, TEXT("%s:"), portName);

        //
        //  Create a new LPT port device object.
        //
        TRC_NRM((TB, _T("Adding LPT Device %s."), path));
        deviceObj = new W32DrLPT(procObj, portName, 
                                 deviceMgr->GetUniqueObjectID(), path);
        //
        //  Add to the device manager if we got a valid object.
        //
        if (deviceObj != NULL) {
            deviceObj->Initialize();
            if (!(deviceObj->IsValid() && 
                 (deviceMgr->AddObject(deviceObj) == STATUS_SUCCESS))) {
                    delete deviceObj;
            }
        }
    }

    DC_END_FN();
    return ERROR_SUCCESS;
}
#endif

DWORD 
W32DrLPT::GetLPTPortMax(
    IN ProcObj *procObj
    ) 
/*++

Routine Description:

    Returns the configurable LPT port max ID.

Arguments:

    procObj -   The relevant process object.

Return Value:

    LPT Port Max.

 --*/
{
    DWORD returnValue;

    //
    //  Read the LPT Port Max out of the Registry
    //
    if (procObj->GetDWordParameter(RDPDR_LPT_PORT_MAX_PARAM, &returnValue) 
                        != ERROR_SUCCESS ) {
        //  Default
        returnValue = RDPDR_LPT_PORT_MAX_PARAM_DEFAULT;
    }

    return returnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\w32drman.cpp ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    w32drman

Abstract:

    This module defines a special subclass of the Win32 client-side RDP
    printer redirection "device" class.  The subclass, W32DrManualPrn 
    manages a queue that is manually installed by a user by attaching
    a server-side queue to a client-side redirected printing port.

Author:

    Tad Brockway 3/23/99

Revision History:

--*/

#include <precom.h>

#define TRC_FILE  "W32DrMan"

#include "w32drman.h"
#include "w32proc.h"
#include "w32utl.h"
#include "w32drprt.h"
#include "drdbg.h"
#ifdef OS_WINCE
#include "ceconfig.h"
#endif


///////////////////////////////////////////////////////////////
//
//	W32DrManualPrn Methods
//
//

//
//  W32DrManualPrn
//
W32DrManualPrn::W32DrManualPrn(
    ProcObj *processObject,
    const DRSTRING printerName, const DRSTRING driverName,
    const DRSTRING portName, BOOL defaultPrinter, ULONG deviceID) : 
        W32DrPRN(processObject, printerName, driverName, portName, NULL,
                defaultPrinter, deviceID, portName)

{
}

//
//  ~W32DrManualPrn
//
W32DrManualPrn::~W32DrManualPrn()
{
}

/*++

Routine Description:

    For serial printers, we need to initialize the COM port.
Arguments:

    fileHandle  -   Open file object for the COM port.

Return Value:

    ERROR_SUCCESS on success.  Otherwise, an error code is returned.

 --*/
DWORD 
W32DrManualPrn::InitializeDevice(
    DrFile* fileObj
    ) 
{ 
    HANDLE FileHandle;
    LPTSTR portName;

    DC_BEGIN_FN("W32DrManualPrn::InitializeDevice");

    if (_isSerialPort) {
        //
        // Our devicePath is formulated as
        // sprintf(_devicePath, TEXT("\\\\.\\%s"), portName);
        //
        portName = _tcsrchr( _devicePath, _T('\\') );

        if( portName == NULL ) {
            // invalid device path
            goto CLEANUPANDEXIT;
        }

        portName++;

        if( !*portName ) {
            //
            // Invalid port name
            //
            goto CLEANUPANDEXIT;
        }

        //
        //  Get the file handle.
        //
        FileHandle = fileObj->GetFileHandle();
        if (!FileHandle || FileHandle == INVALID_HANDLE_VALUE) {
            ASSERT(FALSE);
            TRC_ERR((TB, _T("File Object was not created successfully")));
            goto CLEANUPANDEXIT;
        }

        W32DrPRT::InitializeSerialPort(portName, FileHandle);
    }

CLEANUPANDEXIT:
    
    DC_END_FN();

    //
    //  This function always returns success.  If the port cannot 
    //  be initialized, then subsequent port commands will fail 
    //  anyway. 
    //
    return ERROR_SUCCESS;
}

DWORD 
W32DrManualPrn::Enumerate(
    IN ProcObj *procObj, 
    IN DrDeviceMgr *deviceMgr
    )
/*++

Routine Description:

    Enumerate devices of this type by adding appropriate device
    instances to the device manager.

Arguments:

    procObj     -   Corresponding process object.
    deviceMgr   -   Device manager to add devices to.

Return Value:

    ERROR_SUCCESS on success.  Otherwise, an error code is returned.

 --*/
{
    HKEY hKey = NULL;
    W32DrPRN *prnDevice;
    ULONG ulIndex;
    TCHAR achRegSubKey[REGISTRY_KEY_NAME_SIZE];
    ULONG ulRegSubKeySize;
    DWORD result;
    HKEY hTsClientKey = NULL;
    DWORD ulType;

    DC_BEGIN_FN("W32DrManualPrn::Enumerate");

    if(!procObj->GetVCMgr().GetInitData()->fEnableRedirectPrinters)
    {
        TRC_DBG((TB,_T("Printer redirection disabled, bailing out")));
        return ERROR_SUCCESS;
    }

    //
    //  Open cached printers key.
    //
#ifdef OS_WINCE
    //Before opening, make sure the printer list is current. 
    //This is to ensure that local printers deleted from within a TS session, show up 
    //when you log on the next time
    CEUpdateCachedPrinters();
#endif
    result =
        RegCreateKeyEx(HKEY_CURRENT_USER, REG_RDPDR_CACHED_PRINTERS,
                    0L, NULL, REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS, NULL, &hKey,
                    NULL);
    if (result != ERROR_SUCCESS) {
        TRC_ERR((TB, _T("RegCreateKeyEx failed, %ld."), result));
        hKey = NULL;
    }
    //
    // Check for maximum config length specified in the registry
    // by an admin, if any
    //
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     REG_TERMINALSERVERCLIENT, 0L,
                     KEY_READ, &hTsClientKey) 
                     == ERROR_SUCCESS) {

        DWORD maxRegCacheData, sz;
        if (RegQueryValueEx(hTsClientKey, REG_RDPDR_PRINTER_MAXCACHELEN,
                            NULL, &ulType, (LPBYTE)&maxRegCacheData, &sz) == ERROR_SUCCESS) {

            W32DrPRN::_maxCacheDataSize = maxRegCacheData;
        }

        RegCloseKey(hTsClientKey);      
    }
    //
    //  Enumerate cached printers.
    //
    for (ulIndex = 0; result == ERROR_SUCCESS; ulIndex++) {

        //
        //  Try enumerating the ulIndex'th sub key.
        //
        ulRegSubKeySize = sizeof(achRegSubKey) / sizeof(TCHAR);
        result = RegEnumKeyEx(
                        hKey, ulIndex,
                        (LPTSTR)achRegSubKey,
                        &ulRegSubKeySize, //size in TCHARS
                        NULL,NULL,NULL,NULL
                        );
        if (result == ERROR_SUCCESS) {

            //
            //  Resolve the registry key into a printer object.
            //
            //
            //           Don't like the fact that we are scanning for automatic
            //           printer settings here.  I don't know how much value there is
            //           in cleaning this up, however.
            //
            prnDevice = ResolveCachedPrinter(procObj, deviceMgr,
                                            hKey, achRegSubKey);

            //
            //  If we didn't get a printer device object then remove the registry key.
            //
            if (prnDevice == NULL) {
                TRC_ERR((TB, _T("Didn't get a printer for %s."), achRegSubKey)
                    );
                RegDeleteKey(hKey, achRegSubKey);
            }
        }
        else {
            TRC_NRM((TB, _T("RegEnumKeyEx %ld."), result));
        }
    }

    //
    //  Close the parent registry key.
    //
    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    DC_END_FN();

    return result;
}

VOID 
W32DrManualPrn::CachedDataRestored() 
/*++

Routine Description:

    Called once the cached printer data has reached a "steady state."

Arguments:

    NA

Return Value:

    NA

 --*/
{
    WCHAR *portName;

    DC_BEGIN_FN("W32DrManualPrn::CachedDataRestored");

    //
    //  Parse the cached printer information for specific information
    //  about this printer that is generic to all printers.
    //
    if (!ParsePrinterCacheInfo()) {
        if (_cachedData != NULL) {
            delete _cachedData;
            _cachedData = NULL;
            _cachedDataSize = 0;
        }

		//
		//	If we fail here, then we are no longer valid.
		//
		W32DrDeviceAsync::SetValid(FALSE);
    }
    else {

        //
        // Our devicePath is formulated as
        // sprintf(_devicePath, TEXT("\\\\.\\%s"), portName);
        //
#ifndef OS_WINCE
        portName = _tcsrchr(_devicePath, _T('\\'));
        if( portName == NULL ) {
            ASSERT(FALSE);
            _isSerialPort = FALSE;
            goto CLEANUPANDEXIT;
        }
        portName++;
        if( !*portName ) {
            ASSERT(FALSE);
            _isSerialPort = FALSE;
            goto CLEANUPANDEXIT;
        }
#else
        portName = _devicePath;
#endif

        //
        //  Find out of the port is a serial port.
        //
        _isSerialPort = !_wcsnicmp(portName, L"COM", 3);
    }

CLEANUPANDEXIT:

    DC_END_FN();
}

BOOL
W32DrManualPrn::ParsePrinterCacheInfo()
/*++

Routine Description:

    Parse the cached printer information for specific information
    about this printer.
    
Arguments:

    NA

Return Value:

    TRUE    - if valid cache data.
    FALSE   - if not.

 --*/
{
    PRDPDR_PRINTER_ADD_CACHEDATA pAddCacheData;
    ULONG ulSize;
    PBYTE pStringData;
    BOOL valid;
    ULONG len;
    LPSTR ansiPortName;
    LPTSTR portName;

    DC_BEGIN_FN("W32DrManualPrn::ParsePrinterCacheInfo");

    ASSERT(IsValid());

    //
    //  Check to see the cache size is at least the structure size.
    //
    valid =_cachedDataSize >= sizeof(RDPDR_PRINTER_ADD_CACHEDATA);

    //
    //  Make sure the internal sizes match the size of the catched data.
    //
    if (valid) {
        pAddCacheData = (PRDPDR_PRINTER_ADD_CACHEDATA)_cachedData;
        ulSize =
            sizeof(RDPDR_PRINTER_ADD_CACHEDATA) +
            pAddCacheData->PnPNameLen +
            pAddCacheData->DriverLen +
            pAddCacheData->PrinterNameLen +
            pAddCacheData->CachedFieldsLen;
        valid =  _cachedDataSize >= ulSize;
    }

    //
    //  Grab the port name out of the cached data.  We don't yet know our
    //  device path because it's embedded in the cached data.
    //
    if (valid) {
        pAddCacheData = (PRDPDR_PRINTER_ADD_CACHEDATA)_cachedData;
    
        ansiPortName = (LPSTR)pAddCacheData->PortDosName;
        len = strlen(ansiPortName);
    }

	if (valid) {
#if UNICODE
		WCHAR unicodePortName[PREFERRED_DOS_NAME_SIZE];
    
		RDPConvertToUnicode(
				ansiPortName,
				(LPWSTR)unicodePortName,
				sizeof(unicodePortName)/sizeof(WCHAR) );

		portName = (LPWSTR)unicodePortName;

#else 
		portName = ansiPortName;	
#endif

		//
		//  Our device path is the port name.
		//
#ifndef OS_WINCE
        StringCchPrintf(_devicePath,
                SIZE_TCHARS(_devicePath),
                TEXT("\\\\.\\%s"), portName);
#else

		_stprintf(_devicePath, TEXT("\\\\.\\%s"), portName);
#endif
	}

    //
    //  Get the PnP name.
    //
    if (valid) {
        pStringData = (PBYTE)(pAddCacheData + 1);
        valid = (!pAddCacheData->PnPNameLen) || 
                (pAddCacheData->PnPNameLen ==
                ((wcslen((LPWSTR)pStringData) + 1) * sizeof(WCHAR)));
    }

    //
    //  If we got a valid PnP name, get the driver name.
    //
    if (valid && (pAddCacheData->PnPNameLen > 0)) {
        //
        //  Need to convert the name to ANSI if we are non-unicode.
        //
#ifdef UNICODE
        SetPnPName((DRSTRING)pStringData);
#else
        SetPnPName(NULL);
        _pnpName = new char[pAddCacheData->PnPNameLen/sizeof(WCHAR)];
        if (_pnpName != NULL) {
            valid = (RDPConvertToAnsi(
                            (WCHAR *)pStringData, _pnpName, 
                            pAddCacheData->PnPNameLen/sizeof(WCHAR)
                            ) == ERROR_SUCCESS);
        }
        else {
            TRC_ERR((TB, _T("Alloc failed.")));
            valid = FALSE;
        }
#endif
        pStringData += pAddCacheData->PnPNameLen;
        valid = (!pAddCacheData->DriverLen) || 
                 (pAddCacheData->DriverLen ==
                  ((wcslen((LPWSTR)pStringData) + 1) * sizeof(WCHAR)));
    }

    //
    //  If we got a valid driver name
    //
    if (valid && (pAddCacheData->DriverLen > 0)) {
#ifdef UNICODE
        SetDriverName((DRSTRING)pStringData);
#else
        SetDriverName(NULL);
        _driverName = new char[pAddCacheData->DriverLen/sizeof(WCHAR)];
        if (_driverName != NULL) {
            valid = (RDPConvertToAnsi(
                            (WCHAR *)pStringData, _driverName, 
                            pAddCacheData->DriverLen/sizeof(WCHAR)
                            ) == ERROR_SUCCESS);
        }
        else {
            TRC_ERR((TB, _T("Alloc failed.")));
            valid = FALSE;
        }
#endif
        pStringData += pAddCacheData->DriverLen;
    }

    //
    // Our cache contains printer after driver name
    //
    if (valid) {
        pStringData += pAddCacheData->PrinterNameLen;
    }

	//
	//	Need to adjust the cached pointer to point to the actual cached
	//	configuration data.
	//
	if (valid) {
		PVOID oldCachedData;
		oldCachedData = _cachedData;

#ifdef OS_WINCE
		if (pAddCacheData->CachedFieldsLen > 0) {
#endif
		_cachedData = new BYTE[pAddCacheData->CachedFieldsLen];
		if (_cachedData != NULL) {
			memcpy((PBYTE)_cachedData, pStringData, pAddCacheData->CachedFieldsLen);
			_cachedDataSize = pAddCacheData->CachedFieldsLen;
		}
		else {
			TRC_NRM((TB, _T("Can't allocate %ld bytes."), pAddCacheData->CachedFieldsLen));
			_cachedDataSize = 0;
			valid = FALSE;
		}
#ifdef OS_WINCE
		}
		else {
			_cachedData = NULL;
			_cachedDataSize = 0;
		}
	if (oldCachedData)
#endif
		delete oldCachedData;
	}

    DC_END_FN();

    return valid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\w32drprn.h ===
/*++

    Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    w32drprn
    
Abstract:

    This module defines the parent for the Win32 client-side RDP
    printer redirection "device" class hierarchy, W32DrPRN.

Author:

    Tad Brockway 3/23/99

Revision History:

--*/

#ifndef __W32DRPRN_H__
#define __W32DRPRN_H__

#include "drprn.h"
#include "drdevasc.h"


///////////////////////////////////////////////////////////////
//
//	Defines
//

#define REG_RDPDR_PRINTER_CACHE_DATA    _T("PrinterCacheData")
#define REG_RDPDR_AUTO_PRN_CACHE_DATA   _T("AutoPrinterCacheData")
#define REG_RDPDR_CACHED_PRINTERS   \
    _T("Software\\Microsoft\\Terminal Server Client\\Default\\AddIns\\RDPDR")
#define REG_TERMINALSERVERCLIENT \
    _T("Software\\Microsoft\\Terminal Server Client")
#define REG_RDPDR_PRINTER_MAXCACHELEN _T("MaxPrinterCacheLength")

#define DEFAULT_MAXCACHELEN    500 //500K bytes

#ifdef OS_WINCE
#define REG_RDPDR_WINCE_DEFAULT_PRN     _T("WBT\\Printers\\Default")
#endif
///////////////////////////////////////////////////////////////
//
//	W32DrPRN
//
//
class W32DrPRN : public W32DrDeviceAsync, public DrPRN
{
protected:

    //
    //  Port Name
    //
    TCHAR   _portName[MAX_PATH];
    //
    // Maximum cache data length.
    // This will be the same for all printers
    //
	static DWORD _maxCacheDataSize;

    //
    //  IO Processing Functions
    //
    //  This subclass of DrDevice handles the following IO requests.  These
    //  functions may be overridden in a subclass.
    //
    //  pIoRequestPacket    -   Request packet received from server.
    //  packetLen           -   Length of the packet
    //
    virtual VOID MsgIrpDeviceControl(
                        IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                        IN UINT32 packetLen
                        ){
        //  We just fail IOCTL's.  That's okay for now because the 
        //  server-side print drivers don't expect us to succeed them
        //  anyway.
        DefaultIORequestMsgHandle(pIoRequestPacket, STATUS_UNSUCCESSFUL);
    };

    //
    //  Printer Caching Functions.  These are currently static
    //  because printer caching wasn't designed around a device
    //  object in the original design for RDPDR client-side device
    //  redirection.
    //
    static W32DrPRN *ResolveCachedPrinter(
                                    ProcObj *procObj, 
                                    DrDeviceMgr *deviceMgr,
                                    HKEY hParentKey, 
                                    LPTSTR printerName
                                    );

    static ULONG AddPrinterCacheInfo(
        PRDPDR_PRINTER_ADD_CACHEDATA pAddPrinterData,
        UINT32 maxDataLen
        );

    static ULONG DeletePrinterCacheInfo(
        PRDPDR_PRINTER_DELETE_CACHEDATA pDeletePrinterData,
        UINT32 maxDataLen
        );

    static ULONG UpdatePrinterCacheInfo(
        PRDPDR_PRINTER_UPDATE_CACHEDATA pUpdatePrinterData,
        UINT32 maxDataLen
        );

    static ULONG RenamePrinterCacheInfo(
        PRDPDR_PRINTER_RENAME_CACHEDATA pRenamePrinterData,
        UINT32 maxDataLen
        );

    static VOID RenamePrinter(LPTSTR pwszOldname, LPTSTR pwszNewname);

    static DWORD GetMaxCacheDataSize() {return _maxCacheDataSize;}

#ifdef OS_WINCE
	static ULONG GetCachedDataSize(
		HKEY hPrinterKey
		);
	
	static ULONG ReadCachedData(
		HKEY hPrinterKey,
		UCHAR *pBuf, 
		ULONG *pulSize
		);
	
	static ULONG WriteCachedData(
		HKEY hPrinterKey,
		UCHAR *pBuf, 
		ULONG ulSize
		);
#endif

public:

    //
    //  Constructor/Destructor
    //
    W32DrPRN(ProcObj *processObject, const DRSTRING printerName, 
             const DRSTRING driverName, const DRSTRING portName, 
             const DRSTRING pnpName, BOOL isDefaultPrinter, ULONG id,
             const TCHAR *devicePath=TEXT(""));

    //
    //  Process device cache info packet.
    //
    static VOID ProcessPrinterCacheInfo(
        PRDPDR_PRINTER_CACHEDATA_PACKET pCachePacket,
        UINT32 maxDataLen
        );

    //
    //  Return the object name.
    //
    virtual DRSTRING  GetName() {
        DC_BEGIN_FN("W32DrPRN::GetName");
        ASSERT(IsValid());
        DC_END_FN();
        return GetPrinterName();
    }

    //
    //  Return the size (in bytes) of a device announce packet for
    //  this device.
    //
    virtual ULONG GetDevAnnounceDataSize();

    //
    //  Add a device announce packet for this device to the input 
    //  buffer. 
    //
    virtual VOID GetDevAnnounceData(IN PRDPDR_DEVICE_ANNOUNCE buf);

    //
    //  Return whether this class instance is valid.
    //
    virtual BOOL IsValid()           
    {
        return(W32DrDevice::IsValid() && DrPRN::IsValid());
    }

    //
    //  Get/set the printer port name.
    //
    virtual BOOL    SetPortName(const LPTSTR name);
    virtual const LPTSTR GetPortName();

    //
    //  Return the class name.
    //
    virtual DRSTRING ClassName()  { return TEXT("W32DrPRN"); }
};


///////////////////////////////////////////////////////////////
//
//	W32DrPRN Inline Members
//

inline BOOL W32DrPRN::SetPortName(const LPTSTR name)
{
    memset(_portName, 0, sizeof(_portName));
    _tcsncpy(_portName, name, MAX_PATH-1);
    return TRUE;
}

inline const LPTSTR W32DrPRN::GetPortName()
{
    return _portName;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\w32drprt.h ===
/*++

    Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    W32DrPRT

Abstract:

    This module defines the parent for the Win32 client-side RDP
    port redirection "device" class hierarchy, W32DrPRT.

Author:

    Tad Brockway 3/23/99

Revision History:

--*/

#ifndef __W32DRPRT_H__
#define __W32DRPRT_H__

#ifdef OS_WINCE
#include "drdevasc.h"
#else
#include "drdevol.h"
#endif
#include "drprt.h"


///////////////////////////////////////////////////////////////
//
//	W32DrPRT
//
//  Inherits platform-specific device behavior from
//  W32DrDevice.  Platform-independent port device behavior
//  is inherited from DrPRT.
//
//  Subclass off of the async parent device in CE because 
//  overlapped IO is not supported.  Non-overlapped IO doesn't 
//  work right with the NT serial driver, so we need to use
//  overlapped IO in this case.
//
#ifdef OS_WINCE
class W32DrPRT : public W32DrDeviceAsync, DrPRT
#else
class W32DrPRT : public W32DrDeviceOverlapped, DrPRT
#endif
{
protected:
    //
    // Return back the port handle
    //
    virtual DRPORTHANDLE GetPortHandle(ULONG FileId);

    //
    //  Return the ID for this port.
    //
    virtual ULONG GetID() {
        return DrDevice::GetID();
    }

    //
    //  Return the "parent" TS Device Redirection IO processing object.
    //
    virtual ProcObj *ProcessObject() {
        return DrDevice::ProcessObject();
    }

    //
    //  Default IO Request Handler
    //
    virtual VOID DefaultIORequestMsgHandle(
                        IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                        IN NTSTATUS serverReturnStatus
                        ) {
        DrDevice::DefaultIORequestMsgHandle(pIoRequestPacket, 
                serverReturnStatus);
    }

    //
    //  Serial IOCTL Dispatch Functions
    //
    //  These functions are called by DrPRT and handle the platform-
    //  specific details of satisfying serial IO requests, including sending
    //  an appropriate response to the server.
    //
    virtual void SerialSetTimeouts(PRDPDR_IOREQUEST_PACKET pIoReq);
    virtual void SerialGetTimeouts(PRDPDR_IOREQUEST_PACKET pIoReq);
    virtual void SerialSetChars(PRDPDR_IOREQUEST_PACKET pIoReq);
    virtual void SerialGetChars(PRDPDR_IOREQUEST_PACKET pIoReq);
    virtual void SerialResetDevice(PRDPDR_IOREQUEST_PACKET pIoReq);
    virtual void SerialSetQueueSize(PRDPDR_IOREQUEST_PACKET pIoReq);
    virtual void SerialGetWaitMask(PRDPDR_IOREQUEST_PACKET pIoReq);
    virtual void SerialSetWaitMask(PRDPDR_IOREQUEST_PACKET pIoReq);
    virtual void SerialWaitOnMask(PRDPDR_IOREQUEST_PACKET pIoReq);
    virtual void SerialPurge(PRDPDR_IOREQUEST_PACKET pIoReq);
    virtual void SerialGetHandflow(PRDPDR_IOREQUEST_PACKET pIoReq);
    virtual void SerialSetHandflow(PRDPDR_IOREQUEST_PACKET pIoReq);
    virtual void SerialGetModemStatus(PRDPDR_IOREQUEST_PACKET pIoReq);
    virtual void SerialGetDTRRTS(PRDPDR_IOREQUEST_PACKET pIoReq);
    virtual void SerialGetCommStatus(PRDPDR_IOREQUEST_PACKET pIoReq);
    virtual void SerialGetProperties(PRDPDR_IOREQUEST_PACKET pIoReq);
    virtual void SerialXoffCounter(PRDPDR_IOREQUEST_PACKET pIoReq);
    virtual void SerialLSRMSTInsert(PRDPDR_IOREQUEST_PACKET pIoReq);
    virtual void SerialConfigSize(PRDPDR_IOREQUEST_PACKET pIoReq);
    virtual void SerialGetConfig(PRDPDR_IOREQUEST_PACKET pIoReq);

    virtual void SerialGetStats(PRDPDR_IOREQUEST_PACKET pIoReq);
    virtual void SerialClearStats(PRDPDR_IOREQUEST_PACKET pIoReq);

    //
    //  IO Processing Functions
    //
    //  This subclass of DrDevice handles the following IO requests.  These
    //  functions may be overridden in a subclass.
    //
    //  pIoRequestPacket    -   Request packet received from server.
    //  packetLen           -   Length of the packet
    //
    virtual VOID MsgIrpDeviceControl(
                    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                    IN UINT32 packetLen
                    );

    //
    //  Async IO Management Functions
    //
#ifdef OS_WINCE
    static  HANDLE   _StartWaitOnMaskFunc(W32DRDEV_ASYNCIO_PARAMS *params, 
                                        DWORD *status);
    HANDLE   StartWaitOnMaskFunc(W32DRDEV_ASYNCIO_PARAMS *params, 
                                        DWORD *status);
    DWORD AsyncWaitOnMaskFunc(W32DRDEV_ASYNCIO_PARAMS *params);
    static _ThreadPoolFunc _AsyncWaitOnMaskFunc;    
#else
    static  HANDLE   _StartWaitOnMaskFunc(W32DRDEV_OVERLAPPEDIO_PARAMS *params, 
                                        DWORD *status);
    HANDLE   StartWaitOnMaskFunc(W32DRDEV_OVERLAPPEDIO_PARAMS *params, 
                                        DWORD *status);
#endif

    //
    //  Fetch initial COM values for a particular port from the INI's.
    //
#ifndef OS_WINCE
    static BOOL GetIniCommValues(IN LPTSTR pName, IN LPDCB pdcb);
#endif

public:

    //
    //  Constructor/Destructor
    //
    W32DrPRT(ProcObj *processObject, const DRSTRING portName, 
            ULONG deviceID, const TCHAR *devicePath);
    ~W32DrPRT();

    //
    //  Set a serial port to its initial state.
    //
    static VOID InitializeSerialPort(TCHAR *portName, HANDLE portHandle);

    //
    //  Return the size (in bytes) of a device announce packet for
    //  this device.
    //
    virtual ULONG GetDevAnnounceDataSize() 
    {
        return DrPRT::GetDevAnnounceDataSize();
    }

    //
    //  Add a device announce packet for this device to the input 
    //  buffer. 
    //
    virtual VOID GetDevAnnounceData(IN PRDPDR_DEVICE_ANNOUNCE buf) 
    {
        DrPRT::GetDevAnnounceData(buf, GetID(), GetDeviceType());
    }

    //
    //  Return whether this class instance is valid.
    //
    virtual BOOL IsValid()           
    {
        return(W32DrDevice::IsValid() && DrPRT::IsValid());
    }

    //
    //  Get basic information about the device.
    //
    virtual DRSTRING  GetName() 
    {
        return DrPRT::GetName();
    }

    //
    //  Return the class name.
    //
    virtual DRSTRING ClassName()  { return TEXT("W32DrPRT"); }
};


///////////////////////////////////////////////////////////////
//
//	W32DrPRT Inline Functions
//

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\w32proc.cpp ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    w32proc.cpp

Abstract:

    Contains the parent of the Win32 IO processing class hierarchy
    for TS Device Redirection, W32ProcObj.

Author:

    madan appiah (madana) 16-Sep-1998

Revision History:

--*/

#include <precom.h>

#define TRC_FILE  "w32proc"

#include "rdpdrcom.h"
#include <winsock.h>
#include "dbt.h"

#include "w32proc.h"
#include "w32drprn.h"
#include "w32drman.h"
#include "w32drlpt.h"
#include "w32drcom.h"
#include "w32drive.h"
#include "drconfig.h"
#include "drdbg.h"
#include "thrpool.h"


W32ProcObj::W32ProcObj( VCManager *pVCM ) : ProcObj(pVCM)
/*++

Routine Description:

    Constructor

Arguments:

    pVCM    -   Virtual Channel IO Manager

Return Value:

    NA

 --*/
{
    DC_BEGIN_FN("W32ProcObj::W32ProcObj");

    //
    //  Initialize the member variables.
    //
    _pWorkerThread              = NULL;
    _bWin9xFlag                 = FALSE;
    _hRdpDrModuleHandle         = NULL;
    _bLocalDevicesScanned       = FALSE;
    _isShuttingDown             = FALSE;

    //
    //  Unit-Test Functions that Tests Thread Pools in the Background
    //
#if DBG
    //ThreadPoolTestInit();
#endif

    DC_END_FN();
}


W32ProcObj::~W32ProcObj(
    VOID
    )
/*++

Routine Description:

    Destructor for the W32ProcObj object.

Arguments:

    none.

Return Value:

    None

 --*/
{
    DC_BEGIN_FN("W32ProcObj::~W32ProcObj");

    //
    //  Shutdown the worker thread and cleanup if we are not already shut down.
    //
    if ((_pWorkerThread != NULL) && (_pWorkerThread->shutDownFlag == FALSE)) {
        Shutdown();
    }

    DC_END_FN();
    return;
}

ULONG
W32ProcObj::GetDWordParameter(
    LPTSTR pszValueName,
    PULONG pulValue
    )
/*++

Routine Description:

    Reads a parameter ULONG value from the registry.

Arguments:

    pszValueName - pointer to the value name string.

    pulValue - pointer to an ULONG parameter location.

Return Value:

    Windows Error Code.

 --*/
{
    ULONG ulError;
    HKEY hRootKey = HKEY_CURRENT_USER;
    HKEY hKey = NULL;
    ULONG ulType;
    ULONG ulValueDataSize;

    DC_BEGIN_FN("W32ProcObj::GetDWordParameter");

TryAgain:

    ulError =
        RegOpenKeyEx(
            hRootKey,
            REG_RDPDR_PARAMETER_PATH,
            0L,
            KEY_READ,
            &hKey);

    if (ulError != ERROR_SUCCESS) {

        TRC_ALT((TB, _T("RegOpenKeyEx() failed, %ld."), ulError));

        if( hRootKey == HKEY_CURRENT_USER ) {

            //
            // try with HKEY_LOCAL_MACHINE.
            //

            hRootKey = HKEY_LOCAL_MACHINE;
            goto TryAgain;
        }

        goto Cleanup;
    }

    ulValueDataSize = sizeof(ULONG);
    ulError =
        RegQueryValueEx(
            hKey,
            pszValueName,
            NULL,
            &ulType,
            (PBYTE)pulValue,
            &ulValueDataSize);

    if (ulError != ERROR_SUCCESS) {

        TRC_ALT((TB, _T("RegQueryValueEx() failed, %ld."), ulError));

        if( hRootKey == HKEY_CURRENT_USER ) {

            //
            // try with HKEY_LOCAL_MACHINE.
            //

            hRootKey = HKEY_LOCAL_MACHINE;
            RegCloseKey( hKey );
            hKey = NULL;

            goto TryAgain;
        }

        goto Cleanup;
    }

    ASSERT(ulType == REG_DWORD);
    ASSERT(ulValueDataSize == sizeof(ULONG));

    TRC_NRM((TB, _T("Parameter Value, %lx."), *pulValue));

    //
    // successfully done.
    //

Cleanup:

    if( hKey != NULL ) {
        RegCloseKey( hKey );
    }

    DC_END_FN();
    return( ulError );
}

ULONG W32ProcObj::GetStringParameter(
    IN LPTSTR valueName,
    OUT DRSTRING value,
    IN ULONG maxSize
    )
/*++

Routine Description:

    Return Configurable string parameter.

Arguments:

    valueName   -   Name of value to retrieve.
    value       -   Storage location for retrieved value.
    maxSize     -   Number of bytes available in the "value" data 
                    area.

Return Value:

    Windows Error Code.

 --*/
{
    ULONG ulError;
    HKEY hRootKey;
    HKEY hKey = NULL;
    ULONG ulType;
    
    DC_BEGIN_FN("W32ProcObj::GetStringParameter");

    //
    //  Start with HKCU.
    //
    hRootKey = HKEY_CURRENT_USER;

TryAgain:

    //
    //  Open the reg key.
    //
    ulError =
        RegOpenKeyEx(
            hRootKey,
            REG_RDPDR_PARAMETER_PATH,
            0L,
            KEY_READ,
            &hKey);

    if (ulError != ERROR_SUCCESS) {

        TRC_ERR((TB, _T("RegOpenKeyEx %ld."), ulError));

        //
        //  Try with HKEY_LOCAL_MACHINE.
        //
        if( hRootKey == HKEY_CURRENT_USER ) {
            hRootKey = HKEY_LOCAL_MACHINE;
            goto TryAgain;
        }
        goto Cleanup;
    }

    //
    //  Query the value.
    //
    ulError =
        RegQueryValueEx(
            hKey,
            valueName,
            NULL,
            &ulType,
            (PBYTE)value,
            &maxSize);

    if (ulError != ERROR_SUCCESS) {

        TRC_ERR((TB, _T("RegQueryValueEx %ld."), ulError));

        //
        // Try with HKEY_LOCAL_MACHINE.
        //
        if( hRootKey == HKEY_CURRENT_USER ) {
            hRootKey = HKEY_LOCAL_MACHINE;
            RegCloseKey( hKey );
            hKey = NULL;
            goto TryAgain;
        }
        goto Cleanup;
    }

    ASSERT(ulType == REG_SZ);

    TRC_NRM((TB, _T("Returning %s"), value));

    //
    // Successfully done.
    //
Cleanup:

    if( hKey != NULL ) {
        RegCloseKey( hKey );
    }

    DC_END_FN();
    return ulError;
}

ULONG W32ProcObj::Initialize()
/*++

Routine Description:

    Initialize an instance of this class.

Arguments:

Return Value:

    ERROR_SUCCESS on success.  Windows error status, otherwise.

 --*/
{
    ULONG status = ERROR_SUCCESS;

    DC_BEGIN_FN("W32ProcObj::Initialize");

    //
    //  We are not shutting down.
    //
    _isShuttingDown = FALSE;

    //
    //  Find out which version of the OS is being run.
    //
    OSVERSIONINFO osVersion;;
    osVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx(&osVersion)) {
        status = GetLastError();        
        TRC_ERR((TB, _T("GetVersionEx:  %08X"), status));
        SetValid(FALSE);
        goto CLEANUPANDEXIT;
    }

    //
    //  Are we a 9x OS?
    //
    if (osVersion.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) {
        _bWin9xFlag = TRUE;
    }

    //
    //  Get the background thread timeout value from the registry,
    //  if it is defined.
    //
    if (GetDWordParameter(
                REGISTRY_BACKGROUNDTHREAD_TIMEOUT_NAME, 
                &_threadTimeout
                ) != ERROR_SUCCESS) {
        _threadTimeout = REGISTRY_BACKGROUNDTHREAD_TIMEOUT_DEFAULT;
    }
    TRC_NRM((TB, _T("Thread timeout is %08X"), _threadTimeout));

    //
    //  Instantiate the thread pool.
    //
    _threadPool = new ThreadPool(THRPOOL_DEFAULTMINTHREADS, 
                                 THRPOOL_DEFAULTMAXTHREADS, _threadTimeout);   
    if (_threadPool == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        TRC_ERR((TB, L"Error allocating thread pool."));
        SetValid(FALSE);
        goto CLEANUPANDEXIT;
    }
    status = _threadPool->Initialize();
    if (status != ERROR_SUCCESS) {
        delete _threadPool;
        _threadPool = NULL;
        SetValid(FALSE);
        goto CLEANUPANDEXIT;
    }

    //
    //  Create and resume the worker thread.
    //
    status = CreateWorkerThreadEntry(&_pWorkerThread);
    if (status != ERROR_SUCCESS) {
        SetValid(FALSE);
        goto CLEANUPANDEXIT;
    }
    if (ResumeThread(_pWorkerThread->hWorkerThread) == 0xFFFFFFFF ) {
        SetValid(FALSE);
        status = GetLastError();
        TRC_ERR((TB, _T("ResumeThread: %08X"), status));
        goto CLEANUPANDEXIT;
    }

    //
    //  Call the parent's init function.
    //
    status = ProcObj::Initialize();
    if (status != ERROR_SUCCESS) {
        goto CLEANUPANDEXIT;
    }

CLEANUPANDEXIT:

    DC_END_FN();

    return status;
}

VOID
W32ProcObj::Shutdown()

/*++

Routine Description:

    Triggers the _hShutdownEvent event to terminate the worker thread and 
    cleans up all resources.

Arguments:

Return Value:

    None

 --*/

{
    ULONG i;
    DWORD waitResult;

    DC_BEGIN_FN("W32ProcObj::Shutdown");

#if DBG
    //ThreadPoolTestShutdown();
#endif

    //
    //  Indicate that the object is in a shutdown state.
    //
    _isShuttingDown = TRUE;

    //
    //  Wait for the worker thread to shut down.
    //
    if (_pWorkerThread != NULL) {

        //
        //  Trigger worker thread shutdown and record that we are shutting down.
        //
        _pWorkerThread->shutDownFlag = TRUE;
        SetEvent(_pWorkerThread->controlEvent);

        //
        //  Wait for it to shut down.  DebugBreak if we hit the timeout, even in
        //  free builds.  By default, the timeout is infinite.
        //
        if (_pWorkerThread->hWorkerThread != NULL) {

            TRC_NRM((TB, _T("Waiting for worker thread to shut down.")));
            waitResult = WaitForSingleObject(
                            _pWorkerThread->hWorkerThread,
                            _threadTimeout
                            );
            if (waitResult == WAIT_TIMEOUT) {
                TRC_ERR((TB, _T("Thread timeout")));
                DebugBreak();
            }
            else if (waitResult != WAIT_OBJECT_0) {
                TRC_ERR((TB, _T("WaitForSingleObject:  %08X"), waitResult));
                ASSERT(FALSE);
            }
        }
        
        //
        //  Remove all the threads in the thread pool.
        //
        if (_threadPool != NULL) {
            _threadPool->RemoveAllThreads();                    
        }

        //
        //  Finish all outstanding IO requests and clean up respective
        //  request contexts.  First object is the control event.  Second
        //  object is the operation dispatch queue data ready event.
        //
        for (i=2; i<_pWorkerThread->waitableObjectCount; i++) {

            PASYNCIOREQCONTEXT reqContext = _pWorkerThread->waitingReqs[i];
            ASSERT(reqContext != NULL);
            if (reqContext->ioCompleteFunc != NULL) {
                reqContext->ioCompleteFunc(reqContext->clientContext, 
                                        ERROR_CANCELLED);
            }
            delete reqContext;        
        }

        //
        //  Finish any pending operations in the worker thread's opearation 
        //  dispatch queue.
        //

        //
        //  Clean up the control event and release the worker thread info. struct.
        //
        ASSERT(_pWorkerThread->controlEvent != NULL);
        CloseHandle(_pWorkerThread->controlEvent);
        if (_pWorkerThread->dispatchQueue != NULL) {
            delete _pWorkerThread->dispatchQueue;
        }
        delete _pWorkerThread;
        _pWorkerThread = NULL;
    }

    //
    //  Let go of the thread pool.
    //
    if (_threadPool != NULL) {
        delete _threadPool;        
        _threadPool = NULL;
    }

    //
    //  Release attached DLL's
    //
    if (_hRdpDrModuleHandle != NULL) {
        FreeLibrary( _hRdpDrModuleHandle );
        _hRdpDrModuleHandle = NULL;
    }

    DC_END_FN();
    return;
}

VOID 
W32ProcObj::AnnounceDevicesToServer()
/*++

Routine Description:

    Enumerate devices and announce them to the server.

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("W32ProcObj::AnnounceDevicesToServer");

    DispatchAsyncIORequest(
                    (RDPAsyncFunc_StartIO)W32ProcObj::_AnnounceDevicesToServerFunc,
                    NULL,
                    NULL,
                    this
                    );
}

HANDLE W32ProcObj::_AnnounceDevicesToServerFunc(
    W32ProcObj *obj, 
    DWORD *status
    )
/*++

Routine Description:
    
    Enumerate devices and announce them to the server from the 
    worker thread.

Arguments:

    obj     -   Relevant W32ProcObj instance.
    status  -   Return status.

Return Value:

    NULL

 --*/
{
    obj->AnnounceDevicesToServerFunc(status);
    return NULL;
}
VOID W32ProcObj::AnnounceDevicesToServerFunc(
    DWORD *status
    )
{
    DC_BEGIN_FN("W32ProcObj::AnnounceDevicesToServerFunc");

    ULONG count, i;
    PRDPDR_HEADER pPacketHeader = NULL;
    INT sz;

    ASSERT(_initialized);

    *status = ERROR_SUCCESS;

    //
    //  If we haven't already scanned for local devices.
    //
    if (!_bLocalDevicesScanned) {
        _bLocalDevicesScanned = TRUE;    

        //
        //  Invoke the enum functions.
        //
        count = DeviceEnumFunctionsCount();
        for (i=0; i<count; i++) {

            //  Bail out if the shutdown flag is set.
            if (_pWorkerThread->shutDownFlag == TRUE) {
                TRC_NRM((TB, _T("Bailing out because shutdown flag is set.")));
                *status = WAIT_TIMEOUT;
                goto CLEANUPANDEXIT;
            }

            ASSERT(_DeviceEnumFunctions[i] != NULL);
            _DeviceEnumFunctions[i](this, _deviceMgr);
        }
    }

    //
    //  Send the announce packet to the server.  _pVCMgr cleans
    //  up the packet on failure and on success.
    //
    pPacketHeader = GenerateAnnouncePacket(&sz, FALSE);
    if (pPacketHeader) {
        pPacketHeader->Component = RDPDR_CTYP_CORE;
        pPacketHeader->PacketId = DR_CORE_DEVICELIST_ANNOUNCE;
        _pVCMgr->ChannelWriteEx(pPacketHeader, sz);
    }

CLEANUPANDEXIT:
    
    DC_END_FN();
}

DWORD W32ProcObj::DispatchAsyncIORequest(
                IN RDPAsyncFunc_StartIO ioStartFunc,
                IN OPTIONAL RDPAsyncFunc_IOComplete ioCompleteFunc,
                IN OPTIONAL RDPAsyncFunc_IOCancel ioCancelFunc,
                IN OPTIONAL PVOID clientContext
                )
/*++

Routine Description:

    Dispatch an asynchronous IO function.

Arguments:

    startFunc       -   Points to the function that will be called to initiate the IO.  
    finishFunc      -   Optionally, points to the function that will be called once
                        the IO has completed.
    clientContext   -   Optional client information to be associated with the
                        IO request.
Return Value:

    ERROR_SUCCESS or Windows error code.

 --*/
{
    PASYNCIOREQCONTEXT reqContext;
    DWORD result;

    DC_BEGIN_FN("W32ProcObj::DispatchAsyncIORequest");

    //
    //  Assert that we are valid.
    //
    ASSERT(IsValid());
    if (!IsValid()) {
        DC_END_FN();
        return ERROR_INVALID_FUNCTION;
    }

    //
    //  Instantiate the IO request context.
    //
    result = ERROR_SUCCESS;
    reqContext = new ASYNCIOREQCONTEXT();
    if (reqContext == NULL) {
        TRC_ERR((TB, _T("Alloc failed.")));
        result = ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    //  Fill it in.
    //
    if (result == ERROR_SUCCESS) {
        reqContext->ioStartFunc    =   ioStartFunc;
        reqContext->ioCompleteFunc =   ioCompleteFunc;
        reqContext->ioCancelFunc   =   ioCancelFunc;
        reqContext->clientContext  =   clientContext;
        reqContext->instance       =   this;
    }

    //
    //  Shove it into the worker thread's operation dispatch queue.
    //
    if (result == ERROR_SUCCESS) {
        if (!_pWorkerThread->dispatchQueue->Enqueue(
                        (W32DispatchQueueFunc)_DispatchAsyncIORequest_Private, 
                        reqContext
                        )) {
            result = GetLastError();
            delete reqContext;
        }
    }

    DC_END_FN();
    return result;
}

VOID W32ProcObj::DispatchAsyncIORequest_Private(
            IN PASYNCIOREQCONTEXT reqContext,
            IN BOOL cancelled
            )
/*++

Routine Description:

    Handler for asynchronous IO request dispatching.

Arguments:

    reqContext -    Request context for this function.
    cancelled  -    True if the queued request was cancelled and we need
                    to clean up.

Return Value:

 --*/
{
    HANDLE waitableObject;
    DWORD result;

    DC_BEGIN_FN("W32ProcObj::DispatchAsyncIORequest_Private");

    //
    //  If we are being cancelled, call the cancel function.  Otherwise, start the
    //  IO transaction.
    //
    if (!cancelled) {
        waitableObject = reqContext->ioStartFunc(reqContext->clientContext, &result);
    }
    else {
        TRC_NRM((TB, _T("Cancelling.")));
        if (reqContext->ioCancelFunc != NULL) {
            reqContext->ioCancelFunc(reqContext->clientContext);
        }
        waitableObject = NULL;
        result = ERROR_CANCELLED;
    }

    //
    //  If we have a waitable object then add it to our list.
    //
    if (waitableObject != NULL) {
        result = AddWaitableObjectToWorkerThread(
                                    _pWorkerThread, 
                                    waitableObject, 
                                    reqContext
                                    );

        //
        //  If we couldn't add the waitable object because we have
        //  exceeded our max, then requeue the request, but do not
        //  signal new data in the queue.  We will check for new
        //  data as soon as the waitable object count goes below the
        //  max.
        //
        if (result == ERROR_INVALID_INDEX) {
            if (!_pWorkerThread->dispatchQueue->Requeue(
                        (W32DispatchQueueFunc)_DispatchAsyncIORequest_Private,
                        reqContext, FALSE)) {

                result = GetLastError();

            }
            else {
                result = ERROR_SUCCESS;
            }
        }
    }
    
    //
    //  Complete if IO is not pending and clean up the request context.
    //
    if (waitableObject == NULL) {
        if (!cancelled) {
            if (reqContext->ioCompleteFunc != NULL) {
                reqContext->ioCompleteFunc(reqContext->clientContext, result);
            }
        }
        delete reqContext;
    }

    DC_END_FN();
}

ULONG
W32ProcObj::CreateWorkerThreadEntry(
    PTHREAD_INFO *ppThreadInfo
    )
/*++

Routine Description:

    Create a worker thread entry and start the worker thread.

Arguments:

    ppThreadInfo - pointer a location where the newly created thread info is
                    returned.

Return Value:

    Windows Status Code.

 --*/
{
    ULONG ulRetCode;
    PTHREAD_INFO pThreadInfo = NULL;

    DC_BEGIN_FN("W32ProcObj::CreateWorkerThreadEntry");

    //
    //  Initialize return value.
    //
    *ppThreadInfo = NULL;

    //
    //  Create the associated thread data structure.
    //
    pThreadInfo = new THREAD_INFO();
    if (pThreadInfo == NULL) {
        TRC_ERR((TB, _T("Failed to alloc thread chain info structure.")));
        ulRetCode = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    //  Instantiate the dispatch queue.
    //
    pThreadInfo->dispatchQueue = new W32DispatchQueue();
    if (pThreadInfo->dispatchQueue == NULL) {
        TRC_ERR((TB, _T("Failed to alloc thread chain info structure.")));
        ulRetCode = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    ulRetCode = pThreadInfo->dispatchQueue->Initialize();
    if (ulRetCode != ERROR_SUCCESS) {
        delete pThreadInfo->dispatchQueue;
        delete pThreadInfo;
        pThreadInfo = NULL;
        goto Cleanup;
    }

    //
    //  Create the control event and zero out the shutdown flag.
    //
    pThreadInfo->shutDownFlag = FALSE;
    pThreadInfo->controlEvent = CreateEvent(NULL, TRUE, FALSE, NULL);    
    if (pThreadInfo->controlEvent == NULL) {
        TRC_ERR((TB, _T("CreateEvent %ld."), GetLastError()));
        delete pThreadInfo->dispatchQueue;
        delete pThreadInfo;
        pThreadInfo = NULL;
        ulRetCode = GetLastError();
        goto Cleanup;
    }

    //
    //  Init waiting object info array.
    //
    memset(pThreadInfo->waitableObjects, 0, sizeof(pThreadInfo->waitableObjects));
    memset(pThreadInfo->waitingReqs, 0, sizeof(pThreadInfo->waitingReqs));

    //
    //  Set the first waitable object as the controller event object for
    //  worker thread shutdown.
    //
    pThreadInfo->waitableObjects[0] = pThreadInfo->controlEvent;
    pThreadInfo->waitableObjectCount = 1;

    //
    //  Set the second waitable object as the waitable event for the operation
    //  dispatch queue.
    //
    pThreadInfo->waitableObjects[1] = pThreadInfo->dispatchQueue->GetWaitableObject();
    pThreadInfo->waitableObjectCount++;

    //
    //  Create the worker thread.
    //
    pThreadInfo->hWorkerThread = CreateThread(
                                        NULL, 0, _ObjectWorkerThread,
                                        this, CREATE_SUSPENDED, 
                                        &pThreadInfo->ulThreadId
                                        );

    //
    //  If failure.
    //
    if (pThreadInfo->hWorkerThread == NULL) {
        ulRetCode = GetLastError();
        TRC_ERR((TB, _T("CreateThread failed, %d."), ulRetCode));
        goto Cleanup;
    }

    //
    //  Success!
    //
    ulRetCode = ERROR_SUCCESS;

    //
    //  Set the return value.
    //
    *ppThreadInfo = pThreadInfo;

    //
    //  Set the thread pointer to NULL so we don't clean up.
    //
    pThreadInfo = NULL;

Cleanup:

    //
    //  Clean up on error.
    //
    if (pThreadInfo != NULL) {
        if (pThreadInfo->dispatchQueue != NULL) {
            delete pThreadInfo->dispatchQueue;
        }
        ASSERT(ulRetCode != ERROR_SUCCESS);
        ASSERT(pThreadInfo->controlEvent != NULL);
        CloseHandle(pThreadInfo->controlEvent);  
        delete pThreadInfo;
    }

    DC_END_FN();

    return ulRetCode;
}

VOID
W32ProcObj::ProcessWorkerThreadObject(
    PTHREAD_INFO pThreadInfo,
    ULONG offset
    )
/*++

Routine Description:

    Process a signalled worker thread waitable object.

Arguments:

    pThreadInfo - pointer to the thread info structure that triggered this even.

    offset  - offset of object that is signaled.

Return Value:

    None

 --*/
 {
    HANDLE          hWaitableObject;
    PASYNCIOREQCONTEXT reqContext;

    DC_BEGIN_FN("W32ProcObj::ProcessWorkerThreadObject");

    //
    //  Check the validity of the waitable object. 
    //
    if (offset >= pThreadInfo->waitableObjectCount) {
        ASSERT(FALSE);
        goto Cleanup;
    }

    //
    //  Get the parms for this waitable object.
    //
    hWaitableObject = pThreadInfo->waitableObjects[offset];
    reqContext      = pThreadInfo->waitingReqs[offset];

    //
    //  Invoke the completion function and clean up the request context.
    //
    if (reqContext->ioCompleteFunc != NULL) {
        reqContext->ioCompleteFunc(reqContext->clientContext, ERROR_SUCCESS);
    }
    delete reqContext;

    //
    //  Move the last items to the now vacant spot and decrement the count.
    //
    pThreadInfo->waitableObjects[offset] =
        pThreadInfo->waitableObjects[pThreadInfo->waitableObjectCount - 1];
    pThreadInfo->waitingReqs[offset] =
        pThreadInfo->waitingReqs[pThreadInfo->waitableObjectCount - 1];

    //
    //  Clear the unused spot.
    //
    memset(&pThreadInfo->waitingReqs[pThreadInfo->waitableObjectCount - 1],
           0,sizeof(pThreadInfo->waitingReqs[pThreadInfo->waitableObjectCount - 1]));
    memset(&pThreadInfo->waitableObjects[pThreadInfo->waitableObjectCount - 1],
           0,sizeof(pThreadInfo->waitableObjects[pThreadInfo->waitableObjectCount - 1]));
    pThreadInfo->waitableObjectCount--;

    //
    //  Check to see if there are any operations in the queue that are pending
    //  dispatch.  This can happen if an operation was requeued because we
    //  exceeded the maximum number of waitable objects.
    //
    CheckForQueuedOperations(pThreadInfo);

Cleanup:

    DC_END_FN();
    return;
}

ULONG
W32ProcObj::ObjectWorkerThread(
    VOID
    )
/*++

Routine Description:

    Worker Thread that manages waitable objects and their associated
    callbacks.  This function allows us to do the bulk of the work for
    this module in the background so our impact on the client is minimal.

Arguments:

    None.

Return Value:

    None

 --*/

{
    ULONG waitResult;
    ULONG objectOffset;
    W32DispatchQueueFunc func;
    PVOID clientData;
   
    DC_BEGIN_FN("W32ProcObj::ObjectWorkerThread");

    //
    //  Loop Forever.
    //
    for (;;) {

        TRC_NRM((TB, _T("Entering wait with %d objects."), 
                _pWorkerThread->waitableObjectCount));

        //
        //  Wait for all the waitable objects.
        //
#ifndef OS_WINCE
        waitResult = WaitForMultipleObjectsEx(
                                    _pWorkerThread->waitableObjectCount,
                                    _pWorkerThread->waitableObjects,
                                    FALSE,
                                    INFINITE,
                                    FALSE
                                    );
#else
        waitResult = WaitForMultipleObjects(
                                    _pWorkerThread->waitableObjectCount,
                                    _pWorkerThread->waitableObjects,
                                    FALSE,
                                    INFINITE
                                    );
#endif

        //
        //  If the signalled object is the control object or the queue dispatch queue
        //  data ready object then we need to check for shutdown and for data in the
        //  dispatch queue.
        //
        objectOffset = waitResult - WAIT_OBJECT_0;
        if ((waitResult == WAIT_FAILED) ||
            (objectOffset == 0) ||
            (objectOffset == 1)) {
            if (_pWorkerThread->shutDownFlag) {
                TRC_NRM((TB, _T("Shutting down.")));
                break;
            }
            else {
                CheckForQueuedOperations(_pWorkerThread);
            }
        }
        else {
            if (objectOffset < _pWorkerThread->waitableObjectCount) {
                ProcessWorkerThreadObject(_pWorkerThread, objectOffset);
            }
            else {
                ASSERT(FALSE);
            }
        }
    }

    //
    //  Cancel any outstanding IO requests.
    //
    TRC_NRM((TB, _T("Canceling outstanding IO.")));
    while (_pWorkerThread->dispatchQueue->Dequeue(&func, &clientData)) {
        func(clientData, TRUE);
    }    

    DC_END_FN();
    return 0;
}
DWORD WINAPI
W32ProcObj::_ObjectWorkerThread(
    LPVOID lpParam
    )
{
    return ((W32ProcObj *)lpParam)->ObjectWorkerThread();
}

VOID W32ProcObj::_DispatchAsyncIORequest_Private(
            IN PASYNCIOREQCONTEXT reqContext,
            IN BOOL cancelled
            ) 
{ 
    reqContext->instance->DispatchAsyncIORequest_Private(
                            reqContext,
                            cancelled); 
}

DWORD W32ProcObj::AddWaitableObjectToWorkerThread(
            IN PTHREAD_INFO threadInfo,
            IN HANDLE waitableObject,
            IN PASYNCIOREQCONTEXT reqContext
            )
/*++

Routine Description:

    Add a waitable object to a worker thread.

Arguments:

    threadInfo      -   Worker thread context.
    waitableObject  -   Waitable object. 
    reqContext      -   Context for the IO request.

Return Value:

    Returns ERROR_SUCCESS on success.  Returns ERROR_INVALID_INDEX if there
    isn't currently room for another waitable object in the specified
    thread.  Otherwise, windows error code is returned.

 --*/
{
    ULONG waitableObjectCount = threadInfo->waitableObjectCount;

    DC_BEGIN_FN("W32ProcObj::AddWaitableObjectToWorkerThread");

    //
    //  Make sure we don't run out of waitable objects.
    //
    if (waitableObjectCount < MAXIMUM_WAIT_OBJECTS) {
        ASSERT(threadInfo->waitableObjects[waitableObjectCount] == NULL);
        threadInfo->waitableObjects[waitableObjectCount] = waitableObject;
        threadInfo->waitingReqs[waitableObjectCount]     = reqContext;
        threadInfo->waitableObjectCount++;
        DC_END_FN();
        return ERROR_SUCCESS;
    }
    else {
        DC_END_FN();
        return ERROR_INVALID_INDEX;
    }
}

VOID
W32ProcObj::GetClientComputerName(
    PBYTE   pbBuffer,
    PULONG  pulBufferLen,
    PBOOL   pbUnicodeFlag,
    PULONG  pulCodePage
    )
/*++

Routine Description:

    Get Client Computer Name.

Arguments:

    pbBuffer - pointer to a buffer where the computer name is returned.

    pulBufferLen - length of the above buffer.

    pbUnicodeFlag - pointer a BOOL location which is SET if the unicode returned
        computer name is returned.

    pulCodePage - pointer to a ULONG where the codepage value is returned if
        ansi computer.

Return Value:

    Window Error Code.

 --*/
{
    ULONG ulLen;

    DC_BEGIN_FN("W32ProcObj::GetClientComputerName");

    //
    // check to see we have sufficient buffer.
    //

    ASSERT(*pulBufferLen >= ((MAX_COMPUTERNAME_LENGTH + 1) * sizeof(WCHAR)));

#ifndef OS_WINCE
    if( _bWin9xFlag == TRUE ) {

        //
        // get ansi computer name.
        //

        CHAR achAnsiComputerName[MAX_COMPUTERNAME_LENGTH + 1];

        ulLen = sizeof(achAnsiComputerName);
        ulLen = GetComputerNameA( (LPSTR)achAnsiComputerName, &ulLen);

        if( ulLen != 0 ) {
            //
            //  Convert the string to unicode.
            //
            RDPConvertToUnicode(
                (LPSTR)achAnsiComputerName,
                (LPWSTR)pbBuffer,
                *pulBufferLen );
        }
    }
    else {

        //
        // get unicode computer name.
        //
        ULONG numChars = *pulBufferLen / sizeof(TCHAR);
        ulLen = GetComputerNameW( (LPWSTR)pbBuffer, &numChars );
        *pulBufferLen = numChars * sizeof(TCHAR);
    }
#else
    
    //
    // get ansi computer name.
    //

    CHAR achAnsiComputerName[MAX_COMPUTERNAME_LENGTH + 1];

    if (gethostname(achAnsiComputerName, sizeof(achAnsiComputerName)) == 0) 
    {
        ulLen =  strlen(achAnsiComputerName);
    }
    else {
        ulLen = 0;
    }


    if( ulLen != 0 ) {
        //
        //  Convert the string to unicode.
        //
        RDPConvertToUnicode(
            (LPSTR)achAnsiComputerName,
            (LPWSTR)pbBuffer,
            *pulBufferLen );
    }

#endif
    if( ulLen == 0 ) {

        ULONG ulError;
        ulError = GetLastError();

        ASSERT(ulError != ERROR_BUFFER_OVERFLOW);

        TRC_ERR((TB, _T("GetComputerNameA() failed, %ld."), ulError));
        *(LPWSTR)pbBuffer = L'\0';
    }

    //
    // set return parameters.
    //

    *pbUnicodeFlag = TRUE;
    *pulCodePage = 0;

    *pulBufferLen = ((wcslen((LPWSTR)pbBuffer) + 1) * sizeof(WCHAR));

Cleanup:

    DC_END_FN();
    return;
}

VOID
W32ProcObj::CheckForQueuedOperations(
    IN PTHREAD_INFO thread
    )
/*++

Routine Description:

    Check the operation dispatch queue for queued operations.

Arguments:
    
    thread  -   Is the thread form which to dequeue the next operation.      
    
Return Value:

    ERROR_SUCCESS on success.  Otherwise, Windows error code is returned.

 --*/
{
    W32DispatchQueueFunc func;
    PVOID clientData;

    DC_BEGIN_FN("W32ProcObj::CheckForQueuedOperations");

    while (thread->dispatchQueue->Dequeue(&func, &clientData)) {
        func(clientData, FALSE);
    }

    DC_END_FN();
}



void 
W32ProcObj::OnDeviceChange(
    IN WPARAM wParam, 
    IN LPARAM lParam)
/*++

Routine Description:

    On Device Change notification

Arguments:
    
    wParam  device change notification type
    lParam  device change info
    
Return Value:

    N/A
    
 --*/

{
    W32DeviceChangeParam *param = NULL;
    BYTE *devBuffer = NULL;
    DEV_BROADCAST_HDR *pDBHdr;
    DWORD status = ERROR_OUTOFMEMORY;

    DC_BEGIN_FN("W32ProcObj::OnDeviceChange");

    //
    //  We only care about device arrival and removal.
    //
    if (wParam == DBT_DEVICEARRIVAL || wParam == DBT_DEVICEREMOVECOMPLETE) {
        pDBHdr = (DEV_BROADCAST_HDR *)lParam;

        if (pDBHdr != NULL && pDBHdr->dbch_devicetype == DBT_DEVTYP_VOLUME) {
            DEV_BROADCAST_VOLUME * pDBVol = (DEV_BROADCAST_VOLUME *)lParam;
            
            if (!(pDBVol->dbcv_flags & DBTF_MEDIA)) {
                
                devBuffer = new BYTE[pDBHdr->dbch_size];
                
            
                if (devBuffer != NULL) {
                    memcpy(devBuffer, (void*)lParam, pDBHdr->dbch_size);
                    param = new W32DeviceChangeParam(this, wParam, (LPARAM)devBuffer);
                    
                
                    if (param != NULL) {
                        
                        status = DispatchAsyncIORequest(
                                        (RDPAsyncFunc_StartIO)W32ProcObj::_OnDeviceChangeFunc,
                                        NULL,
                                        NULL,
                                        param
                                        );
                    }
                    else {
                        status = GetLastError();
                    }
                }
            
                //
                //  Clean up
                //
                if (status != ERROR_SUCCESS) {
                    if (param != NULL) {
                        delete param;
                    }
                    if (devBuffer != NULL) {
                        delete devBuffer;
                    }
                }
            }
        }
    }
    
    DC_END_FN();
}

HANDLE W32ProcObj::_OnDeviceChangeFunc(
    W32DeviceChangeParam *param, 
    DWORD *status
    )
/*++

Routine Description:
    
    Handle device change notification from the worker thread.

Arguments:

    param   -   Relevant W32DeviceChangeParam
    status  -   Return status.

Return Value:

    NULL

 --*/
{
    DC_BEGIN_FN("_OnDeviceChangeFunc");

    ASSERT(param != NULL);
    param->_instance->OnDeviceChangeFunc(status, param->_wParam, param->_lParam);

    DC_END_FN();

    delete ((void *)(param->_lParam));
    delete param;
    return NULL;
}

void 
W32ProcObj::OnDeviceChangeFunc(
    DWORD *status,
    IN WPARAM wParam, 
    IN LPARAM lParam)
/*++

Routine Description:

    On Device Change notification

Arguments:
    
    status  return status
    wParam  device change notification type
    lParam  device change info
    
Return Value:

    N/A
    
 --*/

{
    DEV_BROADCAST_HDR *pDBHdr;
    PRDPDR_HEADER pPacketHeader = NULL;
    
    INT sz;

    DC_BEGIN_FN("OnDeviceChangeFunc");

    ASSERT(_initialized);

    *status = ERROR_SUCCESS;

    pDBHdr = (DEV_BROADCAST_HDR *)lParam;
    switch (wParam) {
        //
        //  Device arrival
        //
        case DBT_DEVICEARRIVAL:

        //
        //  This is a volume device arrival message
        //
        if (pDBHdr->dbch_devicetype == DBT_DEVTYP_VOLUME) {
            DEV_BROADCAST_VOLUME * pDBVol = (DEV_BROADCAST_VOLUME *)lParam;
            
            if (!(pDBVol->dbcv_flags & DBTF_MEDIA)) {
            
                DWORD unitMask = pDBVol->dbcv_unitmask;
    
                W32Drive::EnumerateDrives(this, _deviceMgr, unitMask);
    
                pPacketHeader = GenerateAnnouncePacket(&sz, TRUE);
                if (pPacketHeader) {
                    pPacketHeader->Component = RDPDR_CTYP_CORE;
                    pPacketHeader->PacketId = DR_CORE_DEVICELIST_ANNOUNCE;
                    _pVCMgr->ChannelWrite(pPacketHeader, sz);
                }
            }
        }

        break;

        //
        //  Device removal
        //
        case DBT_DEVICEREMOVECOMPLETE:

        //
        //  This is a volume device removal message
        //
        if (pDBHdr->dbch_devicetype == DBT_DEVTYP_VOLUME) {

            DEV_BROADCAST_VOLUME * pDBVol = (DEV_BROADCAST_VOLUME *)lParam;

            if (!(pDBVol->dbcv_flags & DBTF_MEDIA)) {
                DWORD unitMask = pDBVol->dbcv_unitmask;
                
                W32Drive::RemoveDrives(this, _deviceMgr, unitMask);
                
                pPacketHeader = GenerateDeviceRemovePacket(&sz);
                if (pPacketHeader) {
                    pPacketHeader->Component = RDPDR_CTYP_CORE;
                    pPacketHeader->PacketId = DR_CORE_DEVICELIST_REMOVE;
                    _pVCMgr->ChannelWrite(pPacketHeader, sz);
                }
            }
        }
    
        break;

        default:
        return;
    }

    DC_END_FN();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\w32scard.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    w32drive

Abstract:

    This module defines a child of the client-side RDP
    device redirection, the "w32scard" W32SCard to provide
    smart card redirection on 32bit windows

Author:

    Reid Kuhn   7/25/00

Revision History:

--*/

#ifndef __W32SCARD_H__
#define __W32SCARD_H__

#include <rdpdr.h>
#include <w32scard.h>

#include "drobject.h"
#include "drdevasc.h"
#include "scredir.h"

#ifdef OS_WINCE
#include <winscard.h>
#endif

#ifdef OS_WINCE
typedef WAITORTIMERCALLBACKFUNC WAITORTIMERCALLBACK;
#endif

#ifndef OS_WINCE

typedef LONG (WINAPI * PFN_SCardFreeMemory)(SCARDCONTEXT, LPCVOID);
typedef LONG (WINAPI * PFN_SCardState)(SCARDHANDLE, LPDWORD, LPDWORD, LPBYTE, LPDWORD);
typedef BOOL (WINAPI * PFN_RegisterWaitForSingleObject)(PHANDLE, HANDLE, WAITORTIMERCALLBACK, PVOID, ULONG, ULONG);
typedef BOOL (WINAPI * PFN_UnregisterWaitEx)(HANDLE, HANDLE);

#endif

typedef LONG (WINAPI * PFN_SCardEstablishContext)(DWORD, LPCVOID, LPCVOID, LPSCARDCONTEXT);
typedef LONG (WINAPI * PFN_SCardReleaseContext)(SCARDCONTEXT);
typedef LONG (WINAPI * PFN_SCardIsValidContext)(SCARDCONTEXT);
typedef LONG (WINAPI * PFN_SCardListReaderGroupsA)(SCARDCONTEXT, LPSTR, LPDWORD);
typedef LONG (WINAPI * PFN_SCardListReaderGroupsW)(SCARDCONTEXT, LPWSTR, LPDWORD);
typedef LONG (WINAPI * PFN_SCardListReadersA)(SCARDCONTEXT, LPCSTR, LPSTR, LPDWORD);
typedef LONG (WINAPI * PFN_SCardListReadersW)(SCARDCONTEXT, LPCWSTR, LPWSTR, LPDWORD);
typedef LONG (WINAPI * PFN_SCardIntroduceReaderGroupA)(SCARDCONTEXT, LPCSTR);
typedef LONG (WINAPI * PFN_SCardIntroduceReaderGroupW)(SCARDCONTEXT, LPCWSTR);
typedef LONG (WINAPI * PFN_SCardForgetReaderGroupA)(SCARDCONTEXT, LPCSTR);
typedef LONG (WINAPI * PFN_SCardForgetReaderGroupW)(SCARDCONTEXT, LPCWSTR);
typedef LONG (WINAPI * PFN_SCardIntroduceReaderA)(SCARDCONTEXT, LPCSTR, LPCSTR);
typedef LONG (WINAPI * PFN_SCardIntroduceReaderW)(SCARDCONTEXT, LPCWSTR, LPCWSTR);
typedef LONG (WINAPI * PFN_SCardForgetReaderA)(SCARDCONTEXT, LPCSTR);
typedef LONG (WINAPI * PFN_SCardForgetReaderW)(SCARDCONTEXT, LPCWSTR);
typedef LONG (WINAPI * PFN_SCardAddReaderToGroupA)(SCARDCONTEXT, LPCSTR, LPCSTR);
typedef LONG (WINAPI * PFN_SCardAddReaderToGroupW)(SCARDCONTEXT, LPCWSTR, LPCWSTR);
typedef LONG (WINAPI * PFN_SCardRemoveReaderFromGroupA)(SCARDCONTEXT, LPCSTR, LPCSTR);
typedef LONG (WINAPI * PFN_SCardRemoveReaderFromGroupW)(SCARDCONTEXT, LPCWSTR, LPCWSTR);
typedef LONG (WINAPI * PFN_SCardFreeMemory)(SCARDCONTEXT, LPCVOID);
typedef LONG (WINAPI * PFN_SCardLocateCardsA)(SCARDCONTEXT, LPCSTR, LPSCARD_READERSTATE_A, DWORD);
typedef LONG (WINAPI * PFN_SCardLocateCardsW)(SCARDCONTEXT, LPCWSTR, LPSCARD_READERSTATE_W, DWORD);
typedef LONG (WINAPI * PFN_SCardLocateCardsByATRA)(SCARDCONTEXT, LPSCARD_ATRMASK, DWORD, LPSCARD_READERSTATE_A, DWORD);
typedef LONG (WINAPI * PFN_SCardLocateCardsByATRW)(SCARDCONTEXT, LPSCARD_ATRMASK, DWORD, LPSCARD_READERSTATE_W, DWORD);
typedef LONG (WINAPI * PFN_SCardGetStatusChangeA)(SCARDCONTEXT, DWORD, LPSCARD_READERSTATE_A, DWORD);
typedef LONG (WINAPI * PFN_SCardGetStatusChangeW)(SCARDCONTEXT, DWORD, LPSCARD_READERSTATE_W, DWORD);
typedef LONG (WINAPI * PFN_SCardCancel)(SCARDCONTEXT);
typedef LONG (WINAPI * PFN_SCardConnectA)(SCARDCONTEXT, LPCSTR, DWORD, DWORD, LPSCARDHANDLE, LPDWORD);
typedef LONG (WINAPI * PFN_SCardConnectW)(SCARDCONTEXT, LPCWSTR, DWORD, DWORD, LPSCARDHANDLE, LPDWORD);
typedef LONG (WINAPI * PFN_SCardReconnect)(SCARDHANDLE, DWORD, DWORD, DWORD, LPDWORD);
typedef LONG (WINAPI * PFN_SCardDisconnect)(SCARDHANDLE, DWORD);
typedef LONG (WINAPI * PFN_SCardBeginTransaction)(SCARDHANDLE);
typedef LONG (WINAPI * PFN_SCardEndTransaction)(SCARDHANDLE, DWORD);
typedef LONG (WINAPI * PFN_SCardStatusA)(SCARDHANDLE, LPSTR, LPDWORD, LPDWORD, LPDWORD, LPBYTE, LPDWORD);
typedef LONG (WINAPI * PFN_SCardStatusW)(SCARDHANDLE, LPWSTR, LPDWORD, LPDWORD, LPDWORD, LPBYTE, LPDWORD);
typedef LONG (WINAPI * PFN_SCardTransmit)(SCARDHANDLE, LPCSCARD_IO_REQUEST, LPCBYTE, DWORD, LPSCARD_IO_REQUEST, LPBYTE, LPDWORD);
typedef LONG (WINAPI * PFN_SCardControl)(SCARDHANDLE, DWORD,LPCVOID, DWORD, LPVOID, DWORD, LPDWORD);
typedef LONG (WINAPI * PFN_SCardGetAttrib)(SCARDHANDLE, DWORD, LPBYTE, LPDWORD);
typedef LONG (WINAPI * PFN_SCardSetAttrib)(SCARDHANDLE, DWORD, LPCBYTE, DWORD);

///////////////////////////////////////////////////////////////
//
//  Defines and Macros
//

// The SCard device name, and path
#define SZ_SCARD_DEVICE_NAME    (TEXT(DR_SMARTCARD_SUBSYSTEM))

class W32SCard;

typedef struct _SCARDHANDLECALLSTRUCT
{
    W32SCard                *pTHIS;
    DWORD                   dwCallType;
    PRDPDR_IOREQUEST_PACKET pIoRequestPacket;
    HMODULE                 hModExtraRefCount;
    HANDLE                  hThread;
} SCARDHANDLECALLSTRUCT;


//class DrFile;
//////////////////////////////////////////////////////////////
//
//  W32SCard Class Declaration
//
//
class W32SCard : public W32DrDeviceAsync
{
private:

    DRSTRING                    _deviceName;
    DrFile                      *_pFileObj;
    SCARDCONTEXT                *_rgSCardContextList;
    DWORD                       _dwSCardContextListSize;
    HANDLE                      *_rghThreadList;
    DWORD                       _dwThreadListSize;
    CRITICAL_SECTION            _csContextList;
    CRITICAL_SECTION            _csThreadList;
    CRITICAL_SECTION            _csWaitForStartedEvent;
    BOOL                        _fInDestructor;
    BOOL                        _fFlushing;
    HMODULE                     _hModWinscard;
    BOOL                        _fCritSecsInitialized;

#ifndef OS_WINCE
    BOOL                        _fCloseStartedEvent;
    HMODULE                     _hModKernel32;
    HANDLE                      _hStartedEvent;
    HANDLE                      _hRegisterWaitForStartedEvent;
#endif

    PRDPDR_IOREQUEST_PACKET     *_rgIORequestList;
    DWORD                       _dwIORequestListSize;

protected:

    BOOL                        _fNewFailed;

    HMODULE AddRefCurrentModule();
    BOOL AddSCardContextToList(SCARDCONTEXT SCardContext);
    void RemoveSCardContextFromList(SCARDCONTEXT SCardContext);

    HANDLE GetCurrentThreadHandle(void);
    BOOL AddThreadToList(HANDLE hThread);
    void RemoveThreadFromList(HANDLE hThread);

    BOOL AddIORequestToList(PRDPDR_IOREQUEST_PACKET pIORequestPacket);

    BOOL BindToSCardFunctions();

    //
    // Setup device property
    //
    virtual VOID SetDeviceProperty() { _deviceProperty.SetSeekProperty(FALSE); }

    virtual VOID FlushIRPs();

    VOID DefaultIORequestMsgHandleWrapper(
                        IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                        IN NTSTATUS serverReturnStatus
                        );

    //
    //  Async IO Management Functions
    //
    virtual HANDLE StartFSFunc(W32DRDEV_ASYNCIO_PARAMS *params,
                               DWORD *status);
    static  HANDLE _StartFSFunc(W32DRDEV_ASYNCIO_PARAMS *params,
                                DWORD *status);
    virtual DWORD AsyncDirCtrlFunc(W32DRDEV_ASYNCIO_PARAMS *params);
    static  DWORD _AsyncDirCtrlFunc(W32DRDEV_ASYNCIO_PARAMS *params);

    virtual DWORD AsyncNotifyChangeDir(W32DRDEV_ASYNCIO_PARAMS *params);

    LONG AllocateAndCopyATRMasksForCall(
                DWORD                       cAtrs,
                LocateCards_ATRMask         *rgATRMasksFromDecode,
                SCARD_ATRMASK               **prgATRMasksForCall);

    void LocateCardsByATRA(
                PRDPDR_IOREQUEST_PACKET     pIoRequestPacket);

    void LocateCardsByATRW(
                PRDPDR_IOREQUEST_PACKET     pIoRequestPacket);

#ifndef OS_WINCE
    void State(
                SCARDHANDLECALLSTRUCT       *pSCardHandleCall);

#endif

    void AllocateAndChannelWriteReplyPacket(
                PRDPDR_IOREQUEST_PACKET     pIoRequestPacket,
                char                        *pEncodedBuffer,
                unsigned long               cbEncodedBuffer);

    LONG DecodeContextCall(
                PRDPDR_IOREQUEST_PACKET     pIoRequestPacket,
                SCARDCONTEXT                *pSCardContext);

    LONG DecodeContextAndStringCallA(
                PRDPDR_IOREQUEST_PACKET     pIoRequestPacket,
                SCARDCONTEXT                *pSCardContext,
                LPSTR                       *ppsz);

    LONG DecodeContextAndStringCallW(
                PRDPDR_IOREQUEST_PACKET     pIoRequestPacket,
                SCARDCONTEXT                *pSCardContext,
                LPWSTR                      *ppwsz);

    void EncodeAndChannelWriteLongReturn(
                PRDPDR_IOREQUEST_PACKET     pIoRequestPacket,
                LONG                        lReturn);

    void HandleContextCallWithLongReturn(
                PRDPDR_IOREQUEST_PACKET     pIoRequestPacket,
                DWORD                       dwCallType);

    void EncodeAndChannelWriteLongAndMultiStringReturn(
                PRDPDR_IOREQUEST_PACKET     pIoRequestPacket,
                LONG                        lReturn,
                BYTE                        *pb,
                DWORD                       cch,
                BOOL                        fUnicode);

    void EstablishContext(
                PRDPDR_IOREQUEST_PACKET     pIoRequestPacket);

    void ListReaderGroups(
                PRDPDR_IOREQUEST_PACKET     pIoRequestPacket,
                DWORD                       dwCallType);

    void ListReaders(
                PRDPDR_IOREQUEST_PACKET     pIoRequestPacket,
                DWORD                       dwCallType);

    void IntroduceReaderGroup(
                PRDPDR_IOREQUEST_PACKET     pIoRequestPacket,
                DWORD                       dwCallType);

    void HandleContextAndStringCallWithLongReturn(
                PRDPDR_IOREQUEST_PACKET     pIoRequestPacket,
                DWORD                       dwCallType);

    void HandleContextAndTwoStringCallWithLongReturn(
                PRDPDR_IOREQUEST_PACKET     pIoRequestPacket,
                DWORD                       dwCallType);

    LONG AllocateAndCopyReaderStateStructsForCallA(
                DWORD                       cReaders,
                ReaderStateA                *rgReaderStatesFromDecode,
                LPSCARD_READERSTATE_A       *prgReadersStatesForSCardCall);

    LONG AllocateAndCopyReaderStateStructsForCallW(
                DWORD                       cReaders,
                ReaderStateW                *rgReaderStatesFromDecode,
                LPSCARD_READERSTATE_W       *prgReadersStatesForSCardCall);

    LONG AllocateAndCopyReaderStateStructsForReturnA(
                DWORD                       cReaders,
                LPSCARD_READERSTATE_A       rgReaderStatesFromSCardCall,
                ReaderState_Return          **prgReaderStatesForReturn);

    LONG AllocateAndCopyReaderStateStructsForReturnW(
                DWORD                       cReaders,
                LPSCARD_READERSTATE_W       rgReaderStatesFromSCardCall,
                ReaderState_Return          **prgReaderStatesForReturn);

    void LocateCardsA(
                PRDPDR_IOREQUEST_PACKET     pIoRequestPacket);

    void LocateCardsW(
                PRDPDR_IOREQUEST_PACKET     pIoRequestPacket);

    static DWORD WINAPI GetStatusChangeThreadProc(
                LPVOID                      lpParameter);

    void GetStatusChangeWrapper(
                PRDPDR_IOREQUEST_PACKET     pIoRequestPacket,
                DWORD                       dwCallType);

    void GetStatusChangeA(
                PRDPDR_IOREQUEST_PACKET     pIoRequestPacket);

    void GetStatusChangeW(
                PRDPDR_IOREQUEST_PACKET     pIoRequestPacket);


    void Connect(
                SCARDHANDLECALLSTRUCT       *pSCardHandleCall,
                DWORD                       dwCallType);

    void Reconnect(
                SCARDHANDLECALLSTRUCT       *pSCardHandleCall);

    void HandleHCardAndDispositionCall(
                SCARDHANDLECALLSTRUCT       *pSCardHandleCall,
                DWORD                       dwCallType);

    void Status(
                SCARDHANDLECALLSTRUCT       *pSCardHandleCall,
                DWORD                       dwCallType);

    void Transmit(
                SCARDHANDLECALLSTRUCT       *pSCardHandleCall);

    void Control(
                SCARDHANDLECALLSTRUCT       *pSCardHandleCall);

    void GetAttrib(
                SCARDHANDLECALLSTRUCT       *pSCardHandleCall);

    void SetAttrib(
                SCARDHANDLECALLSTRUCT       *pSCardHandleCall);


    static DWORD WINAPI SCardHandleCall_ThreadProc(
                LPVOID                      lpParameter);

#ifndef OS_WINCE
    static DWORD WINAPI WaitForStartedEventThreadProc(
                LPVOID                      lpParameter);

    void GetStartedEvent();

    void ReleaseStartedEvent();
#endif

    void AccessStartedEvent(
                PRDPDR_IOREQUEST_PACKET     pIoRequestPacket);



public:

    //
    //  Constructor
    //
    W32SCard(
        ProcObj *processObject,
        ULONG   deviceID,
        const   TCHAR *deviceName,
        const   TCHAR *devicePath);

    virtual ~W32SCard();

    void WaitForStartedEvent(BOOLEAN TimerOrWaitFired);

    //
    //  Add a device announce packet for this device to the input
    //  buffer.
    //
    virtual ULONG GetDevAnnounceDataSize();
    virtual VOID GetDevAnnounceData(IN PRDPDR_DEVICE_ANNOUNCE buf);

    static DWORD Enumerate(ProcObj *procObj, DrDeviceMgr *deviceMgr);

    virtual DRSTRING GetName()
    {
        return _deviceName;
    };

    //  Get the device type.  See "Device Types" section of rdpdr.h
    virtual ULONG GetDeviceType()   { return RDPDR_DTYP_SMARTCARD; }

    //
    //  Return the class name.
    //
    virtual DRSTRING ClassName()  { return TEXT("W32SCard"); }

    virtual VOID MsgIrpDeviceControl(
                    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
                    IN UINT32 packetLen
                    );

private:
    //
    // Dynamically bound SCard function pointers
    //
#ifndef OS_WINCE
    PFN_SCardFreeMemory pfnSCardFreeMemory;
    PFN_SCardState pfnSCardState;
    PFN_RegisterWaitForSingleObject pfnRegisterWaitForSingleObject;
    PFN_UnregisterWaitEx pfnUnregisterWaitEx;
#endif

    PFN_SCardEstablishContext pfnSCardEstablishContext;
    PFN_SCardReleaseContext pfnSCardReleaseContext;
    PFN_SCardIsValidContext pfnSCardIsValidContext;
    PFN_SCardListReaderGroupsA pfnSCardListReaderGroupsA;
    PFN_SCardListReaderGroupsW pfnSCardListReaderGroupsW;
    PFN_SCardListReadersA pfnSCardListReadersA;
    PFN_SCardListReadersW pfnSCardListReadersW;
    PFN_SCardIntroduceReaderGroupA pfnSCardIntroduceReaderGroupA;
    PFN_SCardIntroduceReaderGroupW pfnSCardIntroduceReaderGroupW;
    PFN_SCardForgetReaderGroupA pfnSCardForgetReaderGroupA;
    PFN_SCardForgetReaderGroupW pfnSCardForgetReaderGroupW;
    PFN_SCardIntroduceReaderA pfnSCardIntroduceReaderA;
    PFN_SCardIntroduceReaderW pfnSCardIntroduceReaderW;
    PFN_SCardForgetReaderA pfnSCardForgetReaderA;
    PFN_SCardForgetReaderW pfnSCardForgetReaderW;
    PFN_SCardAddReaderToGroupA pfnSCardAddReaderToGroupA;
    PFN_SCardAddReaderToGroupW pfnSCardAddReaderToGroupW;
    PFN_SCardRemoveReaderFromGroupA pfnSCardRemoveReaderFromGroupA;
    PFN_SCardRemoveReaderFromGroupW pfnSCardRemoveReaderFromGroupW;
    PFN_SCardLocateCardsA pfnSCardLocateCardsA;
    PFN_SCardLocateCardsW pfnSCardLocateCardsW;
    PFN_SCardLocateCardsByATRA pfnSCardLocateCardsByATRA;
    PFN_SCardLocateCardsByATRW pfnSCardLocateCardsByATRW;
    PFN_SCardGetStatusChangeA pfnSCardGetStatusChangeA;
    PFN_SCardGetStatusChangeW pfnSCardGetStatusChangeW;
    PFN_SCardCancel pfnSCardCancel;
    PFN_SCardConnectA pfnSCardConnectA;
    PFN_SCardConnectW pfnSCardConnectW;
    PFN_SCardReconnect pfnSCardReconnect;
    PFN_SCardDisconnect pfnSCardDisconnect;
    PFN_SCardBeginTransaction pfnSCardBeginTransaction;
    PFN_SCardEndTransaction pfnSCardEndTransaction;
    PFN_SCardStatusA pfnSCardStatusA;
    PFN_SCardStatusW pfnSCardStatusW;
    PFN_SCardTransmit pfnSCardTransmit;
    PFN_SCardControl pfnSCardControl;
    PFN_SCardGetAttrib pfnSCardGetAttrib;
    PFN_SCardSetAttrib pfnSCardSetAttrib;
#ifndef OS_WINCE

    BOOL _fUseRegisterWaitFuncs;

#endif
};

#endif // W32SCARD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\w32proc.h ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    
    w32proc.h

Abstract:

    Contains the parent of the Win32 IO processing class hierarchy
    for TS Device Redirection, W32ProcObj.

Author:

    Madan Appiah (madana) 17-Sep-1998

Revision History:

--*/

#ifndef __W32PROC_H__
#define __W32PROC_H__

#include "proc.h"
#include "w32drprn.h"
#include "w32dispq.h"
#include "thrpool.h"

///////////////////////////////////////////////////////////////
//
//  Registry Key and Value Names.
//

#define REGISTRY_KEY_NAME_SIZE              MAX_PATH
#define REGISTRY_VALUE_NAME_SIZE            64
#define REGISTRY_DATA_SIZE                  256
#ifndef OS_WINCE
#define REGISTRY_ALLOC_DATA_SIZE            (8 * 1024)
#else
#define REGISTRY_ALLOC_DATA_SIZE            (4 * 1024)
#endif

//  Parent key for device redirection registry values.
#define REG_RDPDR_PARAMETER_PATH    \
    _T("Software\\Microsoft\\Terminal Server Client\\Default\\AddIns\\RDPDR")


///////////////////////////////////////////////////////////////
//
//  Configurable Value Names and Defaults
//
#define REGISTRY_BACKGROUNDTHREAD_TIMEOUT_NAME      _T("ThreadTimeOut")
#define REGISTRY_BACKGROUNDTHREAD_TIMEOUT_DEFAULT   INFINITE


///////////////////////////////////////////////////////////////
//
//  Other Defines
//

#define RDPDR_MODULE_NAME           _T("rdpdr.dll")

#define KERNEL32_MODULE_NAME        _T("kernel32.dll")
#define QUEUE_USER_APC_PROC_NAME    _T("QueueUserAPC")

#define MAX_INTEGER_STRING_SIZE     32


class W32ProcObj;

class W32DeviceChangeParam {
public:
    W32ProcObj *_instance;
    WPARAM _wParam;
    LPARAM _lParam;

    W32DeviceChangeParam(W32ProcObj *procObj, WPARAM wParam, LPARAM lParam) {
        _instance = procObj;
        _wParam = wParam;
        _lParam = lParam;
    }
};

///////////////////////////////////////////////////////////////
//
//  W32ProcObj
//
//  W32ProcObj is the parent device IO processing class for 
//  Win32 TS Device Redirection.
//

class W32ProcObj : public ProcObj {

private:

    //
    //  Asynchronous IO Request Context   
    //
    typedef struct _AsyncIOReqContext {
        RDPAsyncFunc_StartIO    ioStartFunc;
        RDPAsyncFunc_IOComplete ioCompleteFunc;
        RDPAsyncFunc_IOCancel   ioCancelFunc;
        PVOID                   clientContext;
        W32ProcObj             *instance;
    } ASYNCIOREQCONTEXT, *PASYNCIOREQCONTEXT;

    //
    //  Worker Thread Info 
    //
    typedef struct _ThreadInfo {

        // Handle to the thread owning this data
        HANDLE  hWorkerThread;   

        // Thread ID
        ULONG   ulThreadId;       

        // Waitable Object Array and Corresponding IO Requests
        HANDLE waitableObjects[MAXIMUM_WAIT_OBJECTS];
        PASYNCIOREQCONTEXT waitingReqs[MAXIMUM_WAIT_OBJECTS];

        //  Number of Waitable Objects and Corresponding Requests being Tracked
        ULONG   waitableObjectCount;           

        //  Synchronization event for controlling this thread.
        HANDLE  controlEvent;

        //  If set, then the background thread should shut down.
        BOOL    shutDownFlag;

        //  The dispatch queue for a single thread instance.
        W32DispatchQueue *dispatchQueue;

        //  Constructor
        _ThreadInfo() : hWorkerThread(NULL), ulThreadId(0), waitableObjectCount(0) 
        {
            memset(&waitableObjects[0], 0, sizeof(waitableObjects));
            memset(&waitingReqs[0], 0, sizeof(waitingReqs));
        }
        ~_ThreadInfo() 
        { 
            if (hWorkerThread != NULL) {
                CloseHandle(hWorkerThread); 
                hWorkerThread = NULL;
            }
        }

    } THREAD_INFO, *PTHREAD_INFO ;

    BOOL ProcessIORequestPacket( PRDPDR_IOREQUEST_PACKET pIoRequestPacket );
    ULONG GetClientID( VOID );

    //
    //  True if devices have been scanned for redirection.
    //
    BOOL    _bLocalDevicesScanned;

    //
    //  The object is shutting down.
    //
    BOOL    _isShuttingDown;

    //
    //  The thread pool
    //
    ThreadPool  *_threadPool;   

    //
    //  Background Worker Thread Handle
    //
    PTHREAD_INFO _pWorkerThread; 

    //
    //  Background Thread Timeout
    //
    DWORD   _threadTimeout;

    //
    //  Win9x system flag. TRUE if the system is Win9x
    //  FALSE otherwise.
    //
    BOOL _bWin9xFlag;
    HINSTANCE _hRdpDrModuleHandle;

    //
    //  Initialize a worker thread.
    //
    ULONG CreateWorkerThreadEntry(PTHREAD_INFO *ppThreadInfo);

    //
    //  Handle a signaled worker thread object that is associated with some kind
    //  of asynchronous request.
    //
    VOID ProcessWorkerThreadObject(PTHREAD_INFO pThreadInfo, ULONG offset);

    //
    //  Shutdown an instance of this class.
    //
    VOID Shutdown();

    //
    //  Handler for asynchronous IO request dispatching.
    //
    static VOID _DispatchAsyncIORequest_Private(
                            PASYNCIOREQCONTEXT reqContext,
                            BOOL cancelled
                            );
    VOID DispatchAsyncIORequest_Private(
                            PASYNCIOREQCONTEXT reqContext,
                            BOOL cancelled
                            );

    //
    //  Track another waitable object in the worker thread.
    //
    DWORD AddWaitableObjectToWorkerThread(PTHREAD_INFO threadInfo,
                                HANDLE waitableObject,
                                PASYNCIOREQCONTEXT reqContext
                                );

    //
    //  Main Worker Thread Function.  Static version invokes
    //  instance-specific version.
    //
    static DWORD WINAPI _ObjectWorkerThread(LPVOID lpParam);
    ULONG ObjectWorkerThread(VOID);

    //
    //  Check the operation dispatch queue for queued operations.
    //
    VOID CheckForQueuedOperations(PTHREAD_INFO thread);

    //
    //  Enumerate devices and announce them to the server from the 
    //  worker thread.
    //
    virtual VOID AnnounceDevicesToServer();
    static HANDLE _AnnounceDevicesToServerFunc(W32ProcObj *obj, DWORD *status);
    VOID AnnounceDevicesToServerFunc(DWORD *status);

   //
   // Handle device change notification from a worker thread
   //
   static HANDLE _OnDeviceChangeFunc(W32DeviceChangeParam *param, DWORD *status);
   VOID OnDeviceChangeFunc(DWORD *status, IN WPARAM wParam, IN LPARAM lParam);

protected:

    //
    //  Return the client's host name.
    //
    virtual VOID GetClientComputerName(
        PBYTE   pbBuffer,
        PULONG  pulBufferLen,
        PBOOL   pbUnicodeFlag,
        PULONG  pulCodePage
        );

public:

    //
    //  Constructor/Destructor
    //
    W32ProcObj(VCManager *pVCM);
    virtual ~W32ProcObj();

    //
    //  Initialize an instance of this class.
    //
    virtual ULONG Initialize();

    //
    //  Dispatch an asynchronous IO function.
    //
    //  startFunc points to the function that will be called to initiate the IO.  
    //  finishFunc, optionally, points to the function that will be called once
    //  the IO has completed.
    //
    virtual DWORD DispatchAsyncIORequest(
                IN RDPAsyncFunc_StartIO ioStartFunc,
                IN OPTIONAL RDPAsyncFunc_IOComplete ioCompleteFunc = NULL,
                IN OPTIONAL RDPAsyncFunc_IOCancel ioCancelFunc = NULL,
                IN OPTIONAL PVOID clientContext = NULL
                );

    //
    //  Return Configurable Parameters.
    //
    virtual ULONG GetDWordParameter(LPTSTR lpszValueName, 
                                    PULONG lpdwValue);
    virtual ULONG GetStringParameter(LPTSTR valueName,
                                    OUT DRSTRING value,
                                    IN ULONG maxSize);


    //
    //  Return a reference to the thread pool.
    //
    ThreadPool  &GetThreadPool() {
        return *_threadPool;
    }

    //
    //  Returns whether the proc obj is in the middle of shutting down.
    //
    virtual BOOL IsShuttingDown() {
        return _isShuttingDown;
    }

    //
    //  Return whether the platform is 9x.
    //
    virtual BOOL Is9x() {
        return _bWin9xFlag;
    }

    //
    //  Return the class name.
    //
    virtual DRSTRING ClassName()  { return TEXT("W32ProcObj"); }

    virtual void OnDeviceChange(WPARAM wParam, LPARAM lParam);    

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\w32drprn.cpp ===
/*++

    Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    w32drprn

Abstract:

    This module defines the parent for the Win32 client-side RDP
    printer redirection "device" class hierarchy, W32DrPRN.

Author:

    Tad Brockway 3/23/99

Revision History:

--*/

#include <precom.h>

#define TRC_FILE  "W32DrPRN"

#include <string.h>
#include "w32drprn.h"
#include "w32utl.h"
#include "drobjmgr.h"
#include "w32drman.h"
#include "w32proc.h"
#include "drdbg.h"
#ifdef OS_WINCE
#include "ceconfig.h"
#endif

DWORD W32DrPRN::_maxCacheDataSize = DEFAULT_MAXCACHELEN;

///////////////////////////////////////////////////////////////
//
//  W32DrPRN Members
//

W32DrPRN::W32DrPRN(ProcObj *processObject, const DRSTRING printerName, 
                 const DRSTRING driverName, const DRSTRING portName, 
                 const DRSTRING pnpName,
                 BOOL isDefaultPrinter, ULONG deviceID, 
                 const TCHAR *devicePath) :
            W32DrDeviceAsync(processObject, deviceID, devicePath), 
            DrPRN(printerName, driverName, pnpName, isDefaultPrinter)
/*++

Routine Description:

    Constructor

Arguments:

    printerName -   Name of printing device.
    driverName  -   Name of print driver name.
    portName    -   Name of client-side printing port.
    pnpName     -   PnP ID String
    default     -   Is this the default printer?
    id          -   Unique device identifier for printing device.
    devicePath  -   Path to the device.

Return Value:

    NA

 --*/
{
    //
    //  Record the port name.
    //
    SetPortName(portName);
}

W32DrPRN *
W32DrPRN::ResolveCachedPrinter(
    IN ProcObj *procObj, 
    IN DrDeviceMgr *deviceMgr,
    IN HKEY hParentKey,
    IN LPTSTR printerName
    )
/*++

Routine Description:

    Open the subkey of hParentKey associated with the specified
    printer name and instantiate a manual printer or find an existing
    automatic printer object in the device manager, depending on the
    type of cached data found.

Arguments:

    procObj     -   Associated Processing Object.
    hParentKey  -   Parent key of printer key.
    printerName -   Name of printer ... and name of printer subkey.

Return Value:

    None.

 --*/
{
    W32DrPRN *prnDevice = NULL;
    DWORD cachedDataSize;
    LPTSTR regValueName;
    LONG result;
    HKEY hPrinterKey;
    DWORD ulType;
    BOOL isManual = FALSE;


    DC_BEGIN_FN("W32DrPRN::ResolveCachedPrinter");

    //
    //  Open the key for the cached printer.
    //
    result = RegCreateKeyEx(
                hParentKey, printerName, 0L,
                NULL, REG_OPTION_NON_VOLATILE,
                KEY_ALL_ACCESS, NULL,
                &hPrinterKey, NULL
                );
    if (result != ERROR_SUCCESS) {
        TRC_ERR((TB, _T("RegCreateKeyEx failed:  %ld."),result));
        hPrinterKey = NULL;
        goto CleanUpAndExit;
    }

    //
    //  See if the value name for the cached printer data is for
    //  a manual printer.
    //
    regValueName = (LPTSTR)REG_RDPDR_PRINTER_CACHE_DATA;
    cachedDataSize = 0;
#ifndef OS_WINCE
    result = RegQueryValueEx(hPrinterKey, regValueName,
                        NULL, &ulType, NULL, &cachedDataSize
                        );
    //
    // Check for hacks
    //
    if (cachedDataSize >= GetMaxCacheDataSize() * 1000) {
        ASSERT(FALSE);
        goto CleanUpAndExit;
    }

#else
    cachedDataSize = GetCachedDataSize(hPrinterKey);
#endif
    //
    //  If no manual printer then check for an automatic printer.
    //
    if (result == ERROR_FILE_NOT_FOUND) {

        regValueName = (LPTSTR)REG_RDPDR_AUTO_PRN_CACHE_DATA;
        cachedDataSize = 0;
        result = RegQueryValueEx(hPrinterKey, regValueName,
                            NULL, &ulType, NULL, &cachedDataSize
                            );

        //
        //  If the entry exists and has some data associated with it
        //  then see if we have a corresponding automatic printer to
        //  add the data to.
        //
        if ((result == ERROR_SUCCESS) && (cachedDataSize > 0)) {
            prnDevice = (W32DrPRN *)deviceMgr->GetObject(
                                (LPTSTR)printerName, 
                                RDPDR_DTYP_PRINT
                                );
            if (prnDevice != NULL) {
                ASSERT(!STRICMP(prnDevice->ClassName(), TEXT("W32DrAutoPrn")));
            }
        }
        else {
            prnDevice = NULL;
        }
    }
    //
    //  Otherwise, if there is some actual cached data then instantiate
    //  a manual printer object and add it to the device manager.
    //
    else if ((result == ERROR_SUCCESS) && (cachedDataSize > 0)) {
        TCHAR UniquePortName[MAX_PATH];
        ULONG DeviceId;

        isManual = TRUE;

        // 
        //  The unique port name is going to be passed to the server
        //  as preferred dos name (max 7 characters long).  As we want to
        //  keep a unique dos name for each printer device, we need 
        //  to fake our own port name.
        //
        DeviceId = deviceMgr->GetUniqueObjectID();
        
        StringCchPrintf(UniquePortName,
                        SIZE_TCHARS(UniquePortName),
                        TEXT("PRN%ld"), DeviceId);
        UniquePortName[7] = TEXT('\0');

#ifndef OS_WINCE
        prnDevice = new W32DrManualPrn(procObj, printerName, TEXT(""),
                                    UniquePortName, FALSE, 
                                    DeviceId);
#else
        //check of it is the default printer
        BOOL fDefault = FALSE;
        HKEY hk = NULL;
        WCHAR szWDefault[PREFERRED_DOS_NAME_SIZE];
        UCHAR szADefault[PREFERRED_DOS_NAME_SIZE];
        DWORD dwSize = sizeof(szWDefault);
        if ( (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_RDPDR_WINCE_DEFAULT_PRN, 0, 0, &hk))  && 
             (ERROR_SUCCESS == RegQueryValueEx(hk, NULL, NULL, &ulType, (LPBYTE )szWDefault, &dwSize)) && 
             (ulType == REG_SZ) && (dwSize < sizeof(szWDefault)) && 
             (WideCharToMultiByte(GetACP(), 0, szWDefault, -1, (char *)szADefault, sizeof(szADefault), NULL, NULL) > 0) )
        {
            UCHAR szPort[PREFERRED_DOS_NAME_SIZE] = {0};
            dwSize = sizeof(szPort);
            RegQueryValueEx(hPrinterKey, regValueName, NULL, &ulType, szPort, &dwSize);
            fDefault = (0 == _stricmp((char *)szADefault, (char *)szPort));
        }
        if (hk)
            RegCloseKey(hk);

        prnDevice = new W32DrManualPrn(procObj, printerName, TEXT(""),
                                    UniquePortName, fDefault, 
                                    DeviceId);
#endif

        if (prnDevice != NULL) {
            prnDevice->Initialize();
            if (!prnDevice->IsValid() || 
                (deviceMgr->AddObject(prnDevice) != ERROR_SUCCESS)) {
                delete prnDevice;
                prnDevice = NULL;
            }
        }
        else {
            TRC_ERR((TB, _T("Out of memory when crating manual printer.")));
        }
    }
    else {
        TRC_NRM((TB, _T("Can't resolve printer %s."),printerName));
        prnDevice = NULL;
    }

    //
    //  If ended up with a printer device object then add the cached data.
    //
    if ((prnDevice != NULL) && 
        (prnDevice->SetCachedDataSize(cachedDataSize) == ERROR_SUCCESS)) {

        //
        //  Read the cached data.
        //
#ifndef OS_WINCE
        result = RegQueryValueEx(hPrinterKey, regValueName,
                                NULL, &ulType, prnDevice->GetCachedDataPtr(), 
                                &cachedDataSize
                                );
#else
        ulType = REG_BINARY;
        result = ReadCachedData(hPrinterKey, 
                                prnDevice->GetCachedDataPtr(), 
                                &cachedDataSize
                                );
#endif

        //
        //  Let the printer device object know that we are done recovering 
        //  cached data.
        //
        if (result == ERROR_SUCCESS) {
            //
            //  Make sure the found data is binary data.
            //
            ASSERT(ulType == REG_BINARY);
            if (ulType == REG_BINARY) {
                prnDevice->CachedDataRestored();
            }
            else {
                result = ERROR_INVALID_DATA;
            }
        }
        else {
            TRC_NRM((TB, _T("RegQueryValueEx failed:  %ld."),result));
        }

        //
        //  On error processing the cached data.
        //
        if ((result != ERROR_SUCCESS) || (!prnDevice->IsValid())) {
            //
            //  For a manual printer, we should close and delete its reg key.
            //
            if (isManual) {
                TRC_ALT((TB, _T("Deleting manual printer %s on cache data error."), 
                        printerName));
                ASSERT(hPrinterKey != NULL);
                RegCloseKey(hPrinterKey);
                hPrinterKey = NULL;
                RegDeleteKey(hParentKey, printerName);
            }
            //
            //  If the printer is an auto printer, zero the cached data for this device 
            //  on error and delete the reg value, but we should still redirect the 
            //  printer.
            //
            else {
                prnDevice->SetCachedDataSize(0);
                RegDeleteValue(hPrinterKey, regValueName);
            }
        }
    }


    //
    //  See if our resulting printer is valid after all this processing.  If not, 
    //  it should be whacked and removed from the device object list.
    //
    if ((prnDevice != NULL) && !prnDevice->IsValid()) {
        TRC_ERR((TB, _T("Whacking invalid printer device %s."), printerName));
        deviceMgr->RemoveObject(prnDevice->GetID());
        delete prnDevice;
        prnDevice = NULL;
    }

CleanUpAndExit:

    //
    //  Close the printer registry key.
    //
    if (hPrinterKey != NULL) {
        RegCloseKey(hPrinterKey);
    }

    DC_END_FN();
    return prnDevice;
}

VOID
W32DrPRN::ProcessPrinterCacheInfo(
    IN PRDPDR_PRINTER_CACHEDATA_PACKET pCachePacket,
    IN UINT32 maxDataLen
    )
/*++

Routine Description:

    Process device cache info packet from the server.

Arguments:

    pCachePacket - Pointer to the cache info packet from server.
    maxDataLen - Maximum data length for this packet

Return Value:

    NA

 --*/
{
    DC_BEGIN_FN("DrPRN::ProcessPrinterCacheInfo");
    //
    // Compute the valid maximum length that any of the events have
    //
    maxDataLen -= sizeof(RDPDR_PRINTER_CACHEDATA_PACKET);
    switch ( pCachePacket->EventId ) 
    {
        case RDPDR_ADD_PRINTER_EVENT :
            AddPrinterCacheInfo(
                    (PRDPDR_PRINTER_ADD_CACHEDATA)(pCachePacket + 1), maxDataLen);
        break;

        case RDPDR_DELETE_PRINTER_EVENT :
            DeletePrinterCacheInfo(
                    (PRDPDR_PRINTER_DELETE_CACHEDATA)(pCachePacket + 1), maxDataLen);
        break;

        case RDPDR_UPDATE_PRINTER_EVENT :
            UpdatePrinterCacheInfo(
                    (PRDPDR_PRINTER_UPDATE_CACHEDATA)(pCachePacket + 1), maxDataLen);
        break;

        case RDPDR_RENAME_PRINTER_EVENT :
            RenamePrinterCacheInfo(
                    (PRDPDR_PRINTER_RENAME_CACHEDATA)(pCachePacket + 1), maxDataLen);
        break;
        default:
            TRC_ALT((TB, _T("Unhandled %ld."), pCachePacket->EventId));
        break;
    }

    //
    //  Clean up the server message because the transaction is complete. 
    //
    delete pCachePacket;
    DC_END_FN();
}

ULONG
W32DrPRN::AddPrinterCacheInfo(
    PRDPDR_PRINTER_ADD_CACHEDATA pAddPrinterData,
    UINT32 maxDataLen
    )
/*++

Routine Description:

    Writes device cache info to the registry.

Arguments:

    pAddPrinterData - pointer to the RDPDR_PRINTER_ADD_CACHEDATA structure.
    maxDataLen - Maximum data length for this data
    
Return Value:

    Windows Error Code.

 --*/
{
    ULONG ulError;
    LPTSTR pszKeyName;
    LPWSTR pszUnicodeKeyString;
    PBYTE lpStringData;

    HKEY hKey = NULL;
    HKEY hPrinterKey = NULL;
    ULONG ulDisposition;
    ULONG ulPrinterData;

    DC_BEGIN_FN("W32DrPRN::AddPrinterCacheInfo");

    ASSERT(pAddPrinterData->PrinterNameLen != 0);

    if( pAddPrinterData->PrinterNameLen == 0 ) {
        ulError = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    ulPrinterData =
        sizeof(RDPDR_PRINTER_ADD_CACHEDATA) +
            pAddPrinterData->PnPNameLen +
            pAddPrinterData->DriverLen +
            pAddPrinterData->PrinterNameLen +
            pAddPrinterData->CachedFieldsLen;

    //
    // Make sure that the data length is valid.
    // Make sure that the cache info doesn't exceed
    // the max configured length
    //
    //
    if(ulPrinterData > maxDataLen ||
       ulPrinterData > GetMaxCacheDataSize() * 1000) {
        ulError = ERROR_INVALID_DATA;
        TRC_ERR((TB, _T("Cache Data Length is invalid - %ld"), ulError));
        ASSERT(FALSE);
        goto Cleanup;
    }
    //
    //  Prepare registry key name.
    //
    lpStringData = (PBYTE)(pAddPrinterData + 1);
    pszUnicodeKeyString = (LPWSTR)
        (lpStringData +
            pAddPrinterData->PnPNameLen +
            pAddPrinterData->DriverLen);

#ifdef UNICODE
    pszKeyName = pszUnicodeKeyString;
#else
    //
    //  Convert the unicode string to ansi.
    //
    CHAR achAnsiKeyName[MAX_PATH];

    RDPConvertToAnsi(
        pszUnicodeKeyString,
        (LPSTR)achAnsiKeyName,
        sizeof(achAnsiKeyName) );

    pszKeyName = (LPSTR)achAnsiKeyName;
#endif

    //
    //  Open rdpdr cached printers key.
    //
    ulError =
        RegCreateKeyEx(
            HKEY_CURRENT_USER,
            REG_RDPDR_CACHED_PRINTERS,
            0L,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,
            &hKey,
            &ulDisposition);
    if (ulError != ERROR_SUCCESS) {
        TRC_ERR((TB, _T("RegCreateKeyEx %ld."), ulError));
        goto Cleanup;
    }

    //
    //  Create/Open registry key.
    //
    ulError =
        RegCreateKeyEx(
            hKey,
            pszKeyName,
            0L,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,
            &hPrinterKey,
            &ulDisposition);
    if (ulError != ERROR_SUCCESS) {

        TRC_ERR((TB, _T("RegCreateKeyEx %ld."), ulError));
        goto Cleanup;
    }

    //
    //  Write cache data.
    //
    ulError =
        RegSetValueEx(
            hPrinterKey,
            REG_RDPDR_PRINTER_CACHE_DATA,
            NULL,
            REG_BINARY,
            (PBYTE)pAddPrinterData,
            ulPrinterData
            );
    if (ulError != ERROR_SUCCESS) {
        TRC_ERR((TB, _T("RegSetValueEx() failed, %ld."), ulError));
        goto Cleanup;
    }

    //
    //  We are done.
    //
Cleanup:
    if( hPrinterKey != NULL ) {
        RegCloseKey( hPrinterKey );
    }
    if( hKey != NULL ) {
        RegCloseKey( hKey );
    }

    DC_END_FN();

    return ulError;
}

ULONG
W32DrPRN::DeletePrinterCacheInfo(
    PRDPDR_PRINTER_DELETE_CACHEDATA pDeletePrinterData,
    UINT32 maxDataLen
    )
/*++

Routine Description:

    Delete device cache info from the registry.

Arguments:

    pDeletePrinterData - pointer to the RDPDR_PRINTER_DELETE_CACHEDATA structure.
    maxDataLen - Maximum data length for this data
    
Return Value:

    Windows Error Code.

 --*/
{
    ULONG ulError;
    LPTSTR pszKeyName;
    LPWSTR pszUnicodeKeyString;

    HKEY hKey = NULL;
    ULONG ulDisposition;

    DC_BEGIN_FN("W32DrPRN::DeletePrinterCacheInfo");

    ASSERT(pDeletePrinterData->PrinterNameLen != 0);

    if( pDeletePrinterData->PrinterNameLen == 0 ) {
        ulError = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }
    ULONG ulPrinterData = 
        sizeof(RDPDR_PRINTER_DELETE_CACHEDATA) + 
        pDeletePrinterData->PrinterNameLen;
    //
    // Make sure that the data length is valid
    //
    if(ulPrinterData > maxDataLen ||
       ulPrinterData > GetMaxCacheDataSize() * 1000) {
        ulError = ERROR_INVALID_DATA;
        TRC_ERR((TB, _T("Cache Data Length is invalid - %ld"), ulError));
        ASSERT(FALSE);
        goto Cleanup;
    }
    //
    // prepare registry key name.
    //
    pszUnicodeKeyString = (LPWSTR)(pDeletePrinterData + 1);

#ifdef UNICODE

    pszKeyName = pszUnicodeKeyString;

#else // UNICODE

    //
    // convert the unicode string to ansi.
    //

    CHAR achAnsiKeyName[MAX_PATH];

    RDPConvertToAnsi(
        pszUnicodeKeyString,
        (LPSTR)achAnsiKeyName,
        sizeof(achAnsiKeyName) );

    pszKeyName = (LPSTR)achAnsiKeyName;

#endif // UNICODE

    //
    // open rdpdr cached printers key.
    //

    ulError =
        RegCreateKeyEx(
            HKEY_CURRENT_USER,
            REG_RDPDR_CACHED_PRINTERS,
            0L,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,
            &hKey,
            &ulDisposition);

    if (ulError != ERROR_SUCCESS) {

        TRC_ERR((TB, _T("RegCreateKeyEx() failed, %ld."), ulError));
        goto Cleanup;
    }

    //
    // delete registry key.
    //
    // Note : assumed, no sub-key presends.
    //

    ulError = RegDeleteKey( hKey, pszKeyName );

    if (ulError != ERROR_SUCCESS) {

        TRC_ERR((TB, _T("RegDeleteKey() failed, %ld."), ulError));
        goto Cleanup;
    }

Cleanup:

    if( hKey != NULL ) {
        RegCloseKey( hKey );
    }

    DC_END_FN();
    return ulError;
}

ULONG
W32DrPRN::RenamePrinterCacheInfo(
    PRDPDR_PRINTER_RENAME_CACHEDATA pRenamePrinterData,
    UINT32 maxDataLen    
    )
/*++

Routine Description:

    Rename device cache info in the registry.

Arguments:

    pRenamePrinterData - pointer to the RDPDR_PRINTER_RENAME_CACHEDATA
        structure.
    maxDataLen - Maximum data length for this data
    
Return Value:

    Windows Error Code.

 --*/
{
    DC_BEGIN_FN("W32DrPRN::RenamePrinterCacheInfo");

    ULONG ulError;

    LPTSTR pszOldKeyName;
    LPTSTR pszNewKeyName;
    LPWSTR pszOldUnicodeKeyString;
    LPWSTR pszNewUnicodeKeyString;

    HKEY hKey = NULL;
    HKEY hOldKey = NULL;
    HKEY hNewKey = NULL;
    ULONG ulDisposition;
    ULONG ulType;

    ULONG ulPrinterDataLen;
    ULONG ulAllocPrinterDataLen = REGISTRY_ALLOC_DATA_SIZE;
    PBYTE pbPrinterData = NULL;
    BOOL bBufferExpanded = FALSE;

    BOOL bAutoPrinter = FALSE;
    LPTSTR pszValueStr;

    pszValueStr = (LPTSTR)REG_RDPDR_PRINTER_CACHE_DATA;

    ASSERT(pRenamePrinterData->OldPrinterNameLen != 0);

    ASSERT(pRenamePrinterData->NewPrinterNameLen != 0);

    if( pRenamePrinterData->OldPrinterNameLen == 0 ) {
        ulError = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if( pRenamePrinterData->NewPrinterNameLen == 0 ) {
        ulError = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    ULONG ulPrinterData = 
        sizeof(RDPDR_PRINTER_RENAME_CACHEDATA) + 
        pRenamePrinterData->OldPrinterNameLen +
        pRenamePrinterData->NewPrinterNameLen;

    //
    // Make sure that the data length is valid
    //
    if(ulPrinterData > maxDataLen ||
       ulPrinterData > GetMaxCacheDataSize() * 1000) {
        ulError = ERROR_INVALID_DATA;
        TRC_ERR((TB, _T("Cache Data Length is invalid - %ld"), ulError));
        ASSERT(FALSE);
        goto Cleanup;
    }
    //
    // prepare registry key name.
    //

    pszOldUnicodeKeyString = (LPWSTR)(pRenamePrinterData + 1);
    pszNewUnicodeKeyString = (LPWSTR)
        ((PBYTE)pszOldUnicodeKeyString +
        pRenamePrinterData->OldPrinterNameLen);

    TRC_ERR((TB, _T("pszOldUnicodeKeyString is %ws."), pszOldUnicodeKeyString));
    TRC_ERR((TB, _T("pszNewUnicodeKeyString is %ws."), pszNewUnicodeKeyString));

    // 
    // No change in queue name.
    //
    if( _wcsicmp(pszOldUnicodeKeyString, pszNewUnicodeKeyString) == 0 ) {
        ulError = ERROR_SUCCESS;
        goto Cleanup;
    }

#ifdef UNICODE

    pszOldKeyName = pszOldUnicodeKeyString;
    pszNewKeyName = pszNewUnicodeKeyString;

#else // UNICODE

    //
    // convert the unicode string to ansi.
    //

    CHAR achOldAnsiKeyName[MAX_PATH];
    CHAR achNewAnsiKeyName[MAX_PATH];

    RDPConvertToAnsi(
        pszOldUnicodeKeyString,
        (LPSTR)achOldAnsiKeyName,
        sizeof(achOldAnsiKeyName) );

    pszOldKeyName = (LPSTR)achOldAnsiKeyName;

    RDPConvertToAnsi(
        pszNewUnicodeKeyString,
        (LPSTR)achNewAnsiKeyName,
        sizeof(achNewAnsiKeyName) );

    pszNewKeyName = (LPSTR)achNewAnsiKeyName;

    

#endif // UNICODE

    //
    // open rdpdr cached printers key.
    //

    ulError =
        RegCreateKeyEx(
            HKEY_CURRENT_USER,
            REG_RDPDR_CACHED_PRINTERS,
            0L,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,
            &hKey,
            &ulDisposition);

    if (ulError != ERROR_SUCCESS) {

        TRC_ERR((TB, _T("RegCreateKeyEx() failed, %ld."), ulError));
        goto Cleanup;
    }

    //
    // Open old Key.
    //

    ulError =
        RegOpenKeyEx(
            hKey,
            pszOldKeyName,
            0L,
            KEY_ALL_ACCESS,
            &hOldKey);

    if (ulError != ERROR_SUCCESS) {

        TRC_ERR((TB, _T("RegOpenKeyEx() failed, %ld."), ulError));
        goto Cleanup;
    }

    //
    // read cache data.
    //

ReadAgain:

    pbPrinterData = new BYTE[ulAllocPrinterDataLen];
    if( pbPrinterData == NULL ) {
        ulError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }


    ulPrinterDataLen = ulAllocPrinterDataLen;
    ulError =
        RegQueryValueEx(
            hOldKey,
            pszValueStr,
            NULL,
            &ulType,
            pbPrinterData,
            &ulPrinterDataLen);

    TRC_ERR((TB, _T("RegQueryValueEx returned: %ld."), ulError));

    if (ulError != ERROR_SUCCESS) {
        if( ulError == ERROR_MORE_DATA ) {

            //
            // do the buffer expansion only once to aviod infinite look
            // in case of registry corruption or so.
            //

            if( !bBufferExpanded ) {

                ASSERT(ulPrinterDataLen > ulAllocPrinterDataLen);

                //
                // need bigger buffer.
                // Compute new buffer size.
                //

                ulAllocPrinterDataLen =
                    ((ulPrinterDataLen / REGISTRY_ALLOC_DATA_SIZE) + 1) *
                    REGISTRY_ALLOC_DATA_SIZE;

                //
                // free old buffer.
                //

                delete pbPrinterData;
                pbPrinterData = NULL;

                ASSERT(ulAllocPrinterDataLen >= ulPrinterDataLen);

                bBufferExpanded = TRUE;
                goto ReadAgain;
            }
        }
        else {
            //
            // It could be auto printer. Try again.
            //
            if (!bAutoPrinter) {
                bAutoPrinter = TRUE;
                pszValueStr = (LPTSTR)REG_RDPDR_AUTO_PRN_CACHE_DATA;

                //
                // free old buffer
                //

                delete pbPrinterData;
                pbPrinterData = NULL;

                goto ReadAgain;
            }
        }
    }

    if (ulError != ERROR_SUCCESS) {

        TRC_ERR((TB, _T("RegQueryValueEx() failed, %ld."), ulError));
        goto Cleanup;
    }

    ASSERT(ulType == REG_BINARY);

    if( ulType != REG_BINARY ) {

        TRC_ERR((TB, _T("RegQueryValueEx returns wrong type, %ld."), ulType));
        goto Cleanup;
    }

    //
    // Update the printer name in the cache info
    //
    ulError = DrPRN::UpdatePrinterNameInCacheData(
        &pbPrinterData,
        &ulPrinterDataLen,
        (PBYTE)pszNewUnicodeKeyString,
        pRenamePrinterData->NewPrinterNameLen);

    //
    // Let's not worry about the success/failure of the above function.
    // We will anyway right the cache information to the new key
    //

    //
    // write the data to the new key.
    //

    //
    // open new key.
    //

    ulError =
        RegCreateKeyEx(
            hKey,
            pszNewKeyName,
            0L,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,
            &hNewKey,
            &ulDisposition);

    if (ulError != ERROR_SUCCESS) {

        TRC_ERR((TB, _T("RegCreateKeyEx() failed, %ld."), ulError));
        goto Cleanup;
    }

    ASSERT(ulDisposition != REG_OPENED_EXISTING_KEY);

    ulError =
        RegSetValueEx(
            hNewKey,
            pszValueStr,
            NULL,
            ulType,
            pbPrinterData,
            ulPrinterDataLen);

    if (ulError != ERROR_SUCCESS) {

        TRC_ERR((TB, _T("RegSetValueEx() failed, %ld."), ulError));
        goto Cleanup;
    }

    //
    // Try to rename the local printer
    //
    if (bAutoPrinter) {
        RenamePrinter(pszOldKeyName, pszNewKeyName);
    }
    //
    // now delete old registry key.
    //
    // Note : assumed, no sub-key presends.
    //

    ulError = RegCloseKey( hOldKey );
    if (ulError != ERROR_SUCCESS) {

        TRC_ERR((TB, _T("RegCloseKey() failed, %ld."), ulError));
        goto Cleanup;
    }

    hOldKey = NULL;

    ulError = RegDeleteKey( hKey, pszOldKeyName );

    if (ulError != ERROR_SUCCESS) {

        TRC_ERR((TB, _T("RegDeleteKey() failed, %ld."), ulError));
        goto Cleanup;
    }

Cleanup:

    if( hKey != NULL ) {
        RegCloseKey( hKey );
    }

    if( hOldKey != NULL ) {
        RegCloseKey( hOldKey );
    }

    if( hNewKey != NULL ) {
        RegCloseKey( hNewKey );
    }

    if (pbPrinterData) {
        delete pbPrinterData;
    }

    DC_END_FN();
    return ulError;
}

ULONG
W32DrPRN::UpdatePrinterCacheInfo(
    PRDPDR_PRINTER_UPDATE_CACHEDATA pUpdatePrinterData,
    UINT32 maxDataLen    
    )
/*++

Routine Description:

    Update device cache info in the registry.

Arguments:

    pUpdatePrinterData - pointer to the RDPDR_PRINTER_UPDATE_CACHEDATA
        structure.
    maxDataLen - Maximum data length for this data
    
Return Value:

    Windows Error Code.

 --*/
{
    DC_BEGIN_FN("W32DrPRN::UpdatePrinterCacheInfo");
    ULONG ulError;
    LPTSTR pszKeyName;
    LPWSTR pszUnicodeKeyString;

    HKEY hKey = NULL;
    HKEY hPrinterKey = NULL;
    ULONG ulDisposition;
    ULONG ulConfigDataLen;
    PBYTE pbConfigData;

    ULONG ulPrinterDataLen;
    ULONG ulAllocPrinterDataLen = REGISTRY_ALLOC_DATA_SIZE;
    PBYTE pbPrinterData = NULL;

    BOOL bAutoPrinter = FALSE;

    ASSERT(pUpdatePrinterData->PrinterNameLen != 0);

    if( pUpdatePrinterData->PrinterNameLen == 0 ) {
        ulError = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    ulPrinterDataLen = 
        sizeof(RDPDR_PRINTER_UPDATE_CACHEDATA) + 
        pUpdatePrinterData->PrinterNameLen +
        pUpdatePrinterData->ConfigDataLen;

    //
    // Make sure that the data length is valid
    //
    if(ulPrinterDataLen > maxDataLen || 
       ulPrinterDataLen > GetMaxCacheDataSize() * 1000) {
        ulError = ERROR_INVALID_DATA;
        TRC_ERR((TB, _T("Cache Data Length is invalid - %ld"), ulError));
        ASSERT(FALSE);
        goto Cleanup;
    }

    //
    // prepare registry key name.
    //


    pszUnicodeKeyString = (LPWSTR)(pUpdatePrinterData + 1);

#ifdef UNICODE

    pszKeyName = pszUnicodeKeyString;

#else // UNICODE

    //
    // convert the unicode string to ansi.
    //

    CHAR achAnsiKeyName[MAX_PATH];

    RDPConvertToAnsi(
        pszUnicodeKeyString,
        (LPSTR)achAnsiKeyName,
        sizeof(achAnsiKeyName) );

    pszKeyName = (LPSTR)achAnsiKeyName;

#endif // UNICODE

    //
    // open rdpdr cached printers key.
    //

    ulError =
        RegCreateKeyEx(
            HKEY_CURRENT_USER,
            REG_RDPDR_CACHED_PRINTERS,
            0L,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,
            &hKey,
            &ulDisposition);

    if (ulError != ERROR_SUCCESS) {

        TRC_ERR((TB, _T("RegCreateKeyEx() failed, %ld."), ulError));
        goto Cleanup;
    }

    //
    // update registry data.
    //

    //
    // Open registry key.
    //

    ulError =
        RegCreateKeyEx(
            hKey,
            pszKeyName,
            0L,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,
            &hPrinterKey,
            &ulDisposition);

    if (ulError != ERROR_SUCCESS) {
        TRC_ERR((TB, _T("RegCreateKeyEx() failed, %ld."), ulError));
        goto Cleanup;
    }

    if( ulDisposition != REG_OPENED_EXISTING_KEY ) {

        //
        // we do not find a cache entry, so it must be automatic printer
        // cache data.
        //

        bAutoPrinter = TRUE;
        TRC_NRM((TB, _T("Created new Key, Auto cache printer detected.")));
    }

    if( !bAutoPrinter ) {

        //
        // read old cache data.
        //

        ULONG ulType;

#ifndef OS_WINCE
        do {

            pbPrinterData = new BYTE[ulAllocPrinterDataLen];
            if( pbPrinterData == NULL ) {
                ulError = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            ulPrinterDataLen = ulAllocPrinterDataLen;
            ulError =
                RegQueryValueEx(
                    hPrinterKey,
                    (PTCHAR)REG_RDPDR_PRINTER_CACHE_DATA,
                    NULL,
                    &ulType,
                    pbPrinterData,
                    &ulPrinterDataLen);

            if( ulError == ERROR_MORE_DATA ) {

                ASSERT(ulPrinterDataLen > ulAllocPrinterDataLen);

                //
                // need bigger buffer.
                // Compute new buffer size.
                //

                ulAllocPrinterDataLen =
                    ((ulPrinterDataLen / REGISTRY_ALLOC_DATA_SIZE) + 1) *
                        REGISTRY_ALLOC_DATA_SIZE;

                //
                // free old buffer.
                //

                delete pbPrinterData;
                pbPrinterData = NULL;

                ASSERT(ulAllocPrinterDataLen >= ulPrinterDataLen);
            }
            else if( ulError == ERROR_FILE_NOT_FOUND ) {

                //
                // we do not find a cache entry, so it must be automatic
                // printer cache data.
                //

                TRC_NRM((TB, _T("No Old Cache data, Auto cache printer detected.")));
                bAutoPrinter = TRUE;
                ulError = ERROR_SUCCESS;
                ulType = REG_BINARY;
            }

        } while ( ulError == ERROR_MORE_DATA );
#else
        ulPrinterDataLen = GetCachedDataSize(hPrinterKey);
        pbPrinterData = new BYTE[ulPrinterDataLen];
        if( pbPrinterData == NULL ) {
            ulError = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
        ulType = REG_BINARY;
        ulError = ReadCachedData(hPrinterKey, pbPrinterData, &ulPrinterDataLen);
#endif
    

        if (ulError != ERROR_SUCCESS) {
            TRC_ERR((TB, _T("RegQueryValueEx() failed, %ld."), ulError));
            goto Cleanup;
        }

        ASSERT(ulType == REG_BINARY);
    }

    if( !bAutoPrinter ) {

        //
        // update the printer data.
        //

        ulConfigDataLen = pUpdatePrinterData->ConfigDataLen;
        pbConfigData =
            (PBYTE)(pUpdatePrinterData + 1) +
                pUpdatePrinterData->PrinterNameLen;

        ulError =
            DrPRN::UpdatePrinterCacheData(
                &pbPrinterData,
                &ulPrinterDataLen,
                pbConfigData,
                ulConfigDataLen );

        if (ulError != ERROR_SUCCESS) {
            TRC_ERR((TB, _T("UpdatePrinterCacheData() failed, %ld."), ulError));
            goto Cleanup;
        }

        //
        // write cache data.
        //

#ifndef OS_WINCE
        ulError =
            RegSetValueEx(
                hPrinterKey,
                REG_RDPDR_PRINTER_CACHE_DATA,
                NULL,
                REG_BINARY,
                pbPrinterData,
                ulPrinterDataLen );
#else
        ulError = WriteCachedData(hPrinterKey, pbPrinterData, ulPrinterDataLen);
#endif
    }
    else {

        pbConfigData = (PBYTE)(pUpdatePrinterData+1);
        pbConfigData += pUpdatePrinterData->PrinterNameLen;

        //
        // write cache data.
        //

        ulError =
            RegSetValueEx(
                hPrinterKey,
                REG_RDPDR_AUTO_PRN_CACHE_DATA,
                NULL,
                REG_BINARY,
                pbConfigData,
                pUpdatePrinterData->ConfigDataLen );
    }

    if (ulError != ERROR_SUCCESS) {

        TRC_ERR((TB, _T("RegSetValueEx() failed, %ld."), ulError));
        goto Cleanup;
    }

    //
    // we are done.
    //

Cleanup:

    if( hPrinterKey != NULL ) {
        RegCloseKey( hPrinterKey );
    }

    if( hKey != NULL ) {
        RegCloseKey( hKey );
    }

    //
    // delete data buffers.
    //

    delete pbPrinterData;

    DC_END_FN();
    return ulError;
}

VOID
W32DrPRN::RenamePrinter(
    LPTSTR pwszOldname,
    LPTSTR pwszNewname
    )
{
    DC_BEGIN_FN("W32DrPRN::RenamePrinter");

    ASSERT(pwszOldname != NULL);

    ASSERT(pwszNewname != NULL);

    if (!(pwszOldname && pwszNewname)) {
        DC_END_FN();
        return;
    }

#ifndef OS_WINCE

    HANDLE hPrinter = NULL;
    BOOL bRunningOn9x = TRUE;
    OSVERSIONINFO osVersion;

    PRINTER_INFO_2 * ppi2 = NULL;
    PRINTER_INFO_2A * ppi2a = NULL; //ansi version
    DWORD size = 0;

    if (!OpenPrinter(pwszOldname, &hPrinter, NULL)) {
        TRC_ERR((TB, _T("OpenPrinter() failed, %ld."), GetLastError()));
        goto Cleanup;
    }

    //
    // We don't have GetPrinter/SetPrinter wrappers
    // so just call either the A or W api's depending on the platform
    // this works because we treat the returned data as an opaque
    // blob and pass it from one API to the next.
    //
    // Doing it this way is more efficient than calling wrappers
    // that would do a _lot_ of uncessary conversions. Although
    // it does make the code a little bit bigger.
    //
    //
    osVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (GetVersionEx(&osVersion)) {
        if (osVersion.dwPlatformId == VER_PLATFORM_WIN32_NT) {
            bRunningOn9x = FALSE;
        }
    }
    else
    {
        TRC_ERR((TB, _T("GetVersionEx:  %08X"), GetLastError()));
    }

    //
    // Code is duplicated to into two large separate
    // branches to reduce number of overall branches
    //
    if(!bRunningOn9x)
    {
        //Not win9x, use UNICODE API's
        if (!GetPrinter(
                hPrinter,
                2,
                (LPBYTE)ppi2,
                0,
                &size)) {

            if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
                TRC_ERR((TB, _T("GetPrinter() failed, %ld."), GetLastError()));
                goto Cleanup;
            }

            ppi2 = (PRINTER_INFO_2 *) new BYTE [size];

            if (ppi2 != NULL) {
                if (!GetPrinter(
                        hPrinter,
                        2,
                        (LPBYTE)ppi2,
                        size,
                        &size)) {

                    TRC_ERR((TB, _T("GetPrinter() failed, %ld."), GetLastError()));
                    goto Cleanup;
                }
            }
            else {
                TRC_ERR((TB, _T("GetPrinter() failed, %ld."), GetLastError()));
                goto Cleanup;
            }

            //
            // replace the name
            //
            ppi2->pPrinterName = pwszNewname;
            ppi2->pSecurityDescriptor = NULL; //we don't want to modify the security descriptors.
    
            if (!SetPrinter(hPrinter, 2, (LPBYTE)ppi2, 0)) {
                TRC_ERR((TB, _T("SetPrinter() failed, %ld."), GetLastError()));
            }
        }
    }
    else
    {
        //Do this in ANSI mode
        if (!GetPrinterA(
                hPrinter,
                2,
                (LPBYTE)ppi2a,
                0,
                &size)) {

            if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
                TRC_ERR((TB, _T("GetPrinter() failed, %ld."), GetLastError()));
                goto Cleanup;
            }

            ppi2a = (PRINTER_INFO_2A *) new BYTE [size];

            if (ppi2 != NULL) {
                if (!GetPrinterA(
                        hPrinter,
                        2,
                        (LPBYTE)ppi2a,
                        size,
                        &size)) {

                    TRC_ERR((TB, _T("GetPrinter() failed, %ld."), GetLastError()));
                    goto Cleanup;
                }
            }
            else {
                TRC_ERR((TB, _T("GetPrinter() failed, %ld."), GetLastError()));
                goto Cleanup;
            }

            //
            // replace the name
            //
            CHAR ansiPrinterName[2048];
            RDPConvertToAnsi( pwszNewname, ansiPrinterName,
                              sizeof(ansiPrinterName) );
            ppi2a->pPrinterName = ansiPrinterName;
            ppi2a->pSecurityDescriptor = NULL; //we don't want to modify the security descriptors.
    
            if (!SetPrinterA(hPrinter, 2, (LPBYTE)ppi2a, 0)) {
                TRC_ERR((TB, _T("SetPrinter() failed, %ld."), GetLastError()));
            }
        }
    }

Cleanup:
    if (hPrinter != NULL) {
        ClosePrinter(hPrinter);
    }

    if (ppi2) {
        delete[] ppi2;
    }
    else if (ppi2a)
    {
        //can't have gone through both UNICODE and ANSI branches
        delete[] ppi2a;
    }

#endif //!OS_WINCE

    DC_END_FN();
}

ULONG 
W32DrPRN::GetDevAnnounceDataSize()
/*++

Routine Description:

    Return the size (in bytes) of a device announce packet for
    this device.

Arguments:

    NA

Return Value:

    The size (in bytes) of a device announce packet for this device.

 --*/
{
    ULONG size = 0;

    DC_BEGIN_FN("W32DrPRN::GetDevAnnounceDataSize");

    ASSERT(IsValid());
    if (!IsValid()) { return 0; }

    size = 0;

    //
    //  Add the base announce size.
    //
    size += sizeof(RDPDR_DEVICE_ANNOUNCE);

    //
    //  Add the printer announce header.
    //
    size += sizeof(RDPDR_PRINTERDEVICE_ANNOUNCE);

    //
    //  Include printer name.
    //
    size += ((STRLEN(_printerName) + 1) * sizeof(WCHAR));

    //
    //  Include printer driver name.
    //
    size += ((STRLEN(_driverName) + 1) * sizeof(WCHAR));

    //
    //  Include cached data.
    //
    size += _cachedDataSize;

    DC_END_FN();

    return size;
}

VOID 
W32DrPRN::GetDevAnnounceData(
    IN PRDPDR_DEVICE_ANNOUNCE pDeviceAnnounce
    )
/*++

Routine Description:

    Add a device announce packet for this device to the input buffer. 

Arguments:

    pDeviceAnnounce -   Device Packet to Append Device Data To
    deviceType      -   Device Type Identifier
    deviceID        -   Identifier for Device

Return Value:

    NA

 --*/
{
    PRDPDR_PRINTERDEVICE_ANNOUNCE pPrinterAnnounce;
    PBYTE pbStringData;

    DC_BEGIN_FN("W32DrPRN::GetDevAnnounceData");

    ASSERT(IsValid());
    if (!IsValid()) { return; }

    //
    //  Record the device ID.
    //
    pDeviceAnnounce->DeviceType = GetDeviceType();
    pDeviceAnnounce->DeviceId   = GetID();

    //
    //  Record the port name in ANSI.
    //
#ifdef UNICODE
    RDPConvertToAnsi(GetPortName(), (LPSTR)pDeviceAnnounce->PreferredDosName,
                  sizeof(pDeviceAnnounce->PreferredDosName)
                  );
#else
    STRCPY((char *)pDeviceAnnounce->PreferredDosName, GetPortName());
#endif

    //
    //  Get pointers to printer-specific data.
    //
    pPrinterAnnounce =
        (PRDPDR_PRINTERDEVICE_ANNOUNCE)(pDeviceAnnounce + 1);

    //
    //  Embedded data pointer.
    //
    pbStringData = (PBYTE)(pPrinterAnnounce + 1);

    //
    //  Flags
    //
    pPrinterAnnounce->Flags = 0;
    if (_isDefault) {
        pPrinterAnnounce->Flags |= RDPDR_PRINTER_ANNOUNCE_FLAG_DEFAULTPRINTER;
    }

    if (_isNetwork) {
        pPrinterAnnounce->Flags |= RDPDR_PRINTER_ANNOUNCE_FLAG_NETWORKPRINTER;
    }

    if (_isTSqueue) {
        pPrinterAnnounce->Flags |= RDPDR_PRINTER_ANNOUNCE_FLAG_TSPRINTER;
    }

    //
    //  ANSI Code Page
    //
    pPrinterAnnounce->CodePage = 0;

    //
    //  Misc. Field Lengths
    //
    pPrinterAnnounce->PnPNameLen = 0;
    pPrinterAnnounce->CachedFieldsLen = 0;

    //
    //  Copy the driver name.
    //
    if (GetDriverName() != NULL) {
#if defined(UNICODE)
        //
        //  Unicode to Unicode just requires a memcpy.
        //
        pPrinterAnnounce->DriverLen = ((STRLEN(GetDriverName()) + 1) *
                                      sizeof(WCHAR));
        memcpy(pbStringData, _driverName, pPrinterAnnounce->DriverLen);
#else
        //
        //  On Win32 ANSI, we will convert to Unicode.
        //
        pPrinterAnnounce->DriverLen = ((STRLEN(GetDriverName()) + 1) *
                                      sizeof(WCHAR));
        RDPConvertToUnicode(_driverName, (LPWSTR)pbStringData, 
                        pPrinterAnnounce->DriverLen );
#endif
        pbStringData += pPrinterAnnounce->DriverLen;
    }
    else {
        pPrinterAnnounce->DriverLen = 0;
    }

    //
    //  Copy the printer name.
    //
    if (GetPrinterName() != NULL) {
#if defined(UNICODE)
        //
        //  Unicode to Unicode just requires a memcpy.
        //
        pPrinterAnnounce->PrinterNameLen = (STRLEN(_printerName) + 1) *
                                        sizeof(WCHAR);
        memcpy(pbStringData, _printerName, pPrinterAnnounce->PrinterNameLen );
#else
        //
        //  On Win32 ANSI, we will convert to Unicode.
        //
        pPrinterAnnounce->PrinterNameLen = (STRLEN(_printerName) + 1) *
                                        sizeof(WCHAR);
        RDPConvertToUnicode(_printerName, (LPWSTR)pbStringData,
                        pPrinterAnnounce->PrinterNameLen );
#endif
        pbStringData += pPrinterAnnounce->PrinterNameLen;
    }
    else  {
        pPrinterAnnounce->PrinterNameLen = 0;
    }

    //
    //  Copy the cached data.
    //
    if (_cachedData != NULL) {

        pPrinterAnnounce->CachedFieldsLen = _cachedDataSize;

        memcpy(pbStringData, _cachedData, (size_t)_cachedDataSize);

        pbStringData += _cachedDataSize;
    }

    //
    //  Computer the length of the data area that follows the device announce
    //  header.
    //
    pDeviceAnnounce->DeviceDataLength =
        (ULONG)(pbStringData - (PBYTE)pPrinterAnnounce);


    DC_END_FN();
}


#ifdef OS_WINCE
ULONG
W32DrPRN::GetCachedDataSize(
    HKEY hPrinterKey
    )
{
    DC_BEGIN_FN("W32DrPRN::GetCachedDataSize");

    TRC_ASSERT((hPrinterKey != NULL), (TB,_T("hPrinterKey is NULL")));

    DWORD dwRet = ERROR_SUCCESS;
    DWORD dwTotSize = 0;
    WCHAR szValueName[MAX_PATH];
    for (DWORD dwIndex = 0; dwRet == ERROR_SUCCESS; dwIndex++)
    {
        DWORD dwType;
        DWORD dwSize = 0;
        wsprintf(szValueName, L"%s%d", REG_RDPDR_PRINTER_CACHE_DATA, dwIndex);
        dwRet = RegQueryValueEx(hPrinterKey, szValueName, NULL, &dwType, NULL, &dwSize);
        if ((dwRet == ERROR_SUCCESS) && (dwType == REG_BINARY) )             
        {
            dwTotSize += dwSize;
        }
    }

    DC_END_FN();

    return dwTotSize;
}

ULONG
W32DrPRN::ReadCachedData(
    HKEY hPrinterKey,
    UCHAR *pBuf, 
    ULONG *pulSize
    )
{
    DC_BEGIN_FN("W32DrPRN::ReadCachedData");

    TRC_ASSERT((hPrinterKey != NULL), (TB,_T("hPrinterKey is NULL")));
    TRC_ASSERT(((pBuf != NULL) && (pulSize != NULL)), (TB,_T("Invalid parameters pBuf = 0x%08x, pulSize=0x%08x"), pBuf, pulSize));

    DWORD dwRet = ERROR_SUCCESS;
    DWORD dwRemaining = *pulSize;
    WCHAR szValueName[MAX_PATH];
    
    for (DWORD dwIndex = 0; dwRet == ERROR_SUCCESS; dwIndex++)
    {
        DWORD dwType;
        DWORD dwSize = dwRemaining;
    
        wsprintf(szValueName, L"%s%d", REG_RDPDR_PRINTER_CACHE_DATA, dwIndex);
        dwRet = RegQueryValueEx(hPrinterKey, szValueName, NULL, &dwType, pBuf, &dwSize);
        if ((dwRet == ERROR_SUCCESS) && (dwType == REG_BINARY) )             
        {
            dwRemaining -= dwSize;
            pBuf += dwSize;
        }
    }
    *pulSize -= dwRemaining;
    return (*pulSize > 0) ? ERROR_SUCCESS : dwRet;  
}

ULONG
W32DrPRN::WriteCachedData(
    HKEY hPrinterKey,
    UCHAR *pBuf, 
    ULONG ulSize
    )
{
    DC_BEGIN_FN("W32DrPRN::WriteCachedData");

    TRC_ASSERT((hPrinterKey != NULL), (TB,_T("hPrinterKey is NULL")));
    TRC_ASSERT((pBuf != NULL), (TB,_T("pBuf is NULL!")));

    DWORD dwRet = ERROR_SUCCESS;
    DWORD dwRemaining = ulSize;
    WCHAR szValueName[MAX_PATH];
    
    for (DWORD dwIndex = 0; dwRemaining > 0; dwIndex++)
    {
        DWORD dwSize = (dwRemaining >= 4096) ? 4096 : dwRemaining;
    
        wsprintf(szValueName, L"%s%d", REG_RDPDR_PRINTER_CACHE_DATA, dwIndex);
        dwRet = RegSetValueEx(hPrinterKey, szValueName, NULL, REG_BINARY, pBuf, dwSize);
        if (dwRet == ERROR_SUCCESS)          
        {
            dwRemaining -= dwSize;
            pBuf += dwSize;
        }
        else
        {
            TRC_ERR((TB, _T("Error -  RegQueryValueEx on %s failed"), szValueName));
            for (DWORD dw=0; dw<dwIndex; dw++)
            {
                wsprintf(szValueName, L"%s%d", REG_RDPDR_PRINTER_CACHE_DATA, dw);
                RegDeleteValue(hPrinterKey, szValueName);
            }
            return dwRet;
        }

    }
    DC_END_FN();
    return ERROR_SUCCESS;   
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\w32drprt.cpp ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    w32drprt

Abstract:

    This module defines the parent for the Win32 client-side RDP
    Port Redirection "device" class hierarchy, W32DrPRT.

Author:

    Tad Brockway 4/21/99

Revision History:

--*/

#include <precom.h>

#define TRC_FILE  "W32DrPRT"

#include "w32drprt.h"
#include "proc.h"
#include "drdbg.h"
#include "utl.h"

#ifdef OS_WINCE
#include "wceinc.h"
#endif

#if DBG
#include "tracecom.h"
#endif

//
//  COM port initialization default values.
//
//  These value are copied from 
//   \\muroc\slm\proj\win\src\CORE\SPOOL32\SPOOLSS\newdll\localmon.c
//
#define WRITE_TOTAL_TIMEOUT     60000   // 60 seconds  localmon.c uses 3 seconds, but
                                        // this doesn't work in 9x.  An application that
                                        // is aware that it is opening a serial device 
                                        // will override this, so it only really applies
                                        // to serial printer redirection.
#define READ_TOTAL_TIMEOUT      5000    // 5 seconds
#define READ_INTERVAL_TIMEOUT   200     // 0.2 second


///////////////////////////////////////////////////////////////
//
//	W32DrPRT Members
//
//  Subclass off of the async parent device in CE because 
//  overlapped IO is not supported.  Non-overlapped IO doesn't 
//  work right with the NT serial driver, so we need to use
//  overlapped IO in this case.
//

W32DrPRT::W32DrPRT(ProcObj *processObject, const DRSTRING portName, 
                   ULONG deviceID, const TCHAR *devicePath) : 
#ifdef OS_WINCE
            W32DrDeviceAsync(processObject, deviceID, devicePath),
#else
            W32DrDeviceOverlapped(processObject, deviceID, devicePath),
#endif
            DrPRT(portName, processObject)
/*++

Routine Description:

    Constructor

Arguments:

    processObject   -   Associated Process Object
    portName        -   Name of the port.
    deviceID        -   Device ID for the port.
    devicePath      -   Path that can be opened via CreateFile for port.

Return Value:

    NA

 --*/
{
    DC_BEGIN_FN("W32DrPRT::W32DrPRT");

    //
    //  Do nothing for now.
    //

    DC_END_FN();
}

W32DrPRT::~W32DrPRT()
/*++

Routine Description:

    Destructor

Arguments:

    NA

Return Value:

    NA

 --*/
{
    DC_BEGIN_FN("W32DrPRT::~W32DrPRT");

    //
    //  Do nothing for now.
    //

    DC_END_FN();
}

DRPORTHANDLE W32DrPRT::GetPortHandle(ULONG FileId) 
/*++

Routine Description:

    Get Port's Open Handle

Arguments:

    File Id from server

Return Value:

    NA

 --*/

{
    DrFile *pFile;

    pFile = _FileMgr->GetObject(FileId);

    if (pFile) {
        return pFile->GetFileHandle();
    }
    else {
        return INVALID_TSPORTHANDLE;
    }
}

VOID 
W32DrPRT::MsgIrpDeviceControl(
    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
    IN UINT32 packetLen
    )
/*++

Routine Description:

    Handles Port IOCTL's

Arguments:

    pIoRequestPacket    -   Request packet received from server.
    packetLen           -   Length of teh packet

Return Value:

    The size (in bytes) of a device announce packet for this device.

 --*/
{
    DC_BEGIN_FN("W32DrPRT::MsgIrpDeviceControl");

    //
    //  Give the parent DrPRT class a shot at decoding the IOCTL
    //  into the correct COMM function.
    //
    if (MsgIrpDeviceControlTranslate(pIoRequestPacket)) {
        TRC_DBG((TB, _T("Successfully decoded IOCTL.")));
    }
    //
    //  Otherwise, we will just pass it on to the driver.
    //
    else {
        DispatchIOCTLDirectlyToDriver(pIoRequestPacket);
    }
    DC_END_FN();
}

#ifndef OS_WINCE
HANDLE 
W32DrPRT::StartWaitOnMaskFunc(
    IN W32DRDEV_OVERLAPPEDIO_PARAMS *params,
    OUT DWORD *status
    )
/*++

Routine Description:

    Asynchronously handle a "wait on mask" function.  

Arguments:

    params  -   Context for the IO request.
    status  -   Return status for IO request in the form of a windows
                error code.

Return Value:

    NA

 --*/
{
    PRDPDR_IOCOMPLETION_PACKET pReplyPacket = NULL;
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    ULONG replyPacketSize = 0;
    LPDWORD serverEventMask;
    PBYTE outputBuf;
    HANDLE FileHandle;

    DC_BEGIN_FN("W32DrPRT::StartWaitOnMaskFunc");

    *status = ERROR_SUCCESS;

    //  Assert the integrity of the IO context
    ASSERT(params->magicNo == GOODMEMMAGICNUMBER);

    //
    //  Get the IO request.
    //
    pIoRequest = &params->pIoRequestPacket->IoRequest;

    // 
    //  Get Port Handle
    //
    FileHandle = GetPortHandle(pIoRequest->FileId);

    //
    //  Allocate reply buffer.
    //
    replyPacketSize = DR_IOCTL_REPLYBUFSIZE(pIoRequest);
    pReplyPacket = DrUTL_AllocIOCompletePacket(
                                params->pIoRequestPacket, 
                                replyPacketSize
                                );
    if (pReplyPacket == NULL) {
        *status = ERROR_NOT_ENOUGH_MEMORY;
        TRC_ERR((TB, _T("Failed to alloc %ld bytes."), replyPacketSize));
        goto Cleanup;
    }

    //
    //  Save the reply packet info to the context for this IO operation.
    //
    params->pIoReplyPacket      = pReplyPacket;
    params->IoReplyPacketSize   = replyPacketSize;

    //
    //  Create an event for the overlapped IO.
    //
    memset(&params->overlapped, 0, sizeof(params->overlapped));
    params->overlapped.hEvent = CreateEvent(
                                NULL,   // no attribute.
                                TRUE,   // manual reset.
                                FALSE,  // initially not signalled.
                                NULL    // no name.
                                );
    if (params->overlapped.hEvent == NULL) {
        TRC_ERR((TB, _T("Failed to create event")));
        *status = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    //  Get a pointer to the output buffer and server's event mask.
    //
    outputBuf = pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBuffer;
    serverEventMask = (LPDWORD)outputBuf;

    //
    //  Use WaitCommEvent to handle the request.
    //
    ASSERT(FileHandle != INVALID_HANDLE_VALUE);
    if (!WaitCommEvent(FileHandle, serverEventMask, &params->overlapped)) {
        //
        //  If IO is pending.
        //
        *status = GetLastError();
        if (*status == ERROR_IO_PENDING) {
            TRC_NRM((TB, _T("Pending IO.")));
        }
        else {
            TRC_ERR((TB, _T("Error %ld."), *status));
            goto Cleanup;
        }
    }
    else {
        TRC_NRM((TB, _T("Completed synchronously.")));
        *status = ERROR_SUCCESS;
    }

Cleanup:

    //
    //  If IO is pending, return the handle to the pending IO.
    //
    if (*status == ERROR_IO_PENDING) {
        DC_END_FN();
        return params->overlapped.hEvent;
    }
    //
    //  Otherwise, return NULL so that the CompleteIOFunc can be called
    //  to send the results to the server.
    //
    else {
        if (params->overlapped.hEvent != NULL) {
            CloseHandle(params->overlapped.hEvent);
            params->overlapped.hEvent = NULL;
        }

        DC_END_FN();
        return NULL;
    }
}
HANDLE 
W32DrPRT::_StartWaitOnMaskFunc(
    IN W32DRDEV_OVERLAPPEDIO_PARAMS *params,
    OUT DWORD *status
    )
{
    return ((W32DrPRT*)params->pObject)->StartWaitOnMaskFunc(params, status);
}

#else   //  Windows CE

HANDLE 
W32DrPRT::StartWaitOnMaskFunc(
    IN W32DRDEV_ASYNCIO_PARAMS *params,
    OUT DWORD *status
    )
/*++

Routine Description:

    Asynchronously handle a "wait on mask" function.  Can't use overlapped
    IO in CE, so we will use a pooled thread.

Arguments:

    params  -   Context for the IO request.
    status  -   Return status for IO request in the form of a windows
                error code.

Return Value:

    NA

 --*/
{
    PRDPDR_IOCOMPLETION_PACKET pReplyPacket = NULL;
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    ULONG replyPacketSize = 0;

    DC_BEGIN_FN("W32DrPRT::_StartWaitOnMaskFunc");

    *status = ERROR_SUCCESS;

    //  Assert the integrity of the IO context
    ASSERT(params->magicNo == GOODMEMMAGICNUMBER);

    //
    //  Get the IO request.
    //
    pIoRequest = &params->pIoRequestPacket->IoRequest;

    //
    //  Allocate reply buffer.
    //
    replyPacketSize = DR_IOCTL_REPLYBUFSIZE(pIoRequest);
    pReplyPacket = DrUTL_AllocIOCompletePacket(params->pIoRequestPacket, 
                                            replyPacketSize) ;
    if (pReplyPacket == NULL) {
        *status = ERROR_NOT_ENOUGH_MEMORY;
        TRC_ERR((TB, _T("Failed to alloc %ld bytes."), replyPacketSize));
        goto Cleanup;
    }

    //
    //  Save the reply packet info to the context for this IO operation.
    //
    params->pIoReplyPacket      = pReplyPacket;
    params->IoReplyPacketSize   = replyPacketSize;

    //
    //  Hand a read request off to the thread pool.
    //
    params->completionEvent = CreateEvent(
                                NULL,   // no attribute.
                                TRUE,   // manual reset.
                                FALSE,  // initially not signalled.
                                NULL    // no name.
                                );
    if (params->completionEvent == NULL) {
        *status = GetLastError();
        TRC_ERR((TB, _T("Error in CreateEvent:  %08X."), *status));
    }
    else {
        params->thrPoolReq = _threadPool->SubmitRequest(
                                _AsyncWaitOnMaskFunc, params, 
                                params->completionEvent
                                );

        if (params->thrPoolReq == INVALID_THREADPOOLREQUEST) {
            *status = ERROR_SERVICE_NO_THREAD;
        }
    }

Cleanup:

    //
    //  If IO is pending, return the handle to the pending IO.
    //
    if (params->thrPoolReq != INVALID_THREADPOOLREQUEST) {
        *status = ERROR_IO_PENDING;
        DC_END_FN();
        return params->completionEvent;
    }
    //
    //  Otherwise, clean up the event handle and return NULL so that the 
    //  CompleteIOFunc can be called to send the results to the server.
    //
    else {

        if (params->completionEvent != NULL) {
            CloseHandle(params->completionEvent);
            params->completionEvent = NULL;
        }

        DC_END_FN();
        return NULL;
    }
}
HANDLE 
W32DrPRT::_StartWaitOnMaskFunc(
    IN W32DRDEV_ASYNCIO_PARAMS *params,
    OUT DWORD *status
    )
{
    return ((W32DrPRT*)params->pObject)->StartWaitOnMaskFunc(params, status);
}

DWORD  
W32DrPRT::AsyncWaitOnMaskFunc(
    IN W32DRDEV_ASYNCIO_PARAMS *params
    )
/*++

Routine Description:

    Start an asynchronous "wait on mask operation."  Can't use 
    overlapped IO for this function, so we run it in a pooled thread.

Arguments:

    params  -   Context for the IO request.

Return Value:

    Returns a handle the pending IO object if the operation did not 
    complete.  Otherwise, NULL is returned.

 --*/
{
    DWORD status;
    PRDPDR_IOCOMPLETION_PACKET pReplyPacket;
    LPDWORD serverEventMask;
    PBYTE outputBuf;
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    HANDLE FileHandle;

    DC_BEGIN_FN("W32DrPRT::AsyncWaitOnMaskFunc");

    //
    //  Assert the integrity of the IO context
    //
    ASSERT(params->magicNo == GOODMEMMAGICNUMBER);

    //
    //  Get the IO request.
    //
    pIoRequest = &params->pIoRequestPacket->IoRequest;

    // 
    //  Get Port Handle
    //
    FileHandle = GetPortHandle(pIoRequest->FileId);

    //
    //  Get a pointer to the output buffer and server's event mask.
    //
    pReplyPacket = params->pIoReplyPacket;
    outputBuf = pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBuffer;
    serverEventMask = (LPDWORD)outputBuf;

    //
    //  Use WaitCommEvent to handle the request.
    //
    ASSERT(FileHandle != INVALID_HANDLE_VALUE);

    if (!WaitCommEvent(FileHandle, serverEventMask, NULL)) {
        status = GetLastError();
        TRC_ERR((TB, _T("Error %ld."), status));
    }
    else {
        TRC_NRM((TB, _T("Completed successfully.")));
        status = ERROR_SUCCESS;
    }

    DC_END_FN();
    return status;
}
DWORD 
W32DrPRT::_AsyncWaitOnMaskFunc(
    IN PVOID params,
    IN HANDLE cancelEvent
    )
{
    return ((W32DrPRT*)(((W32DRDEV_ASYNCIO_PARAMS *)params)->pObject))->AsyncWaitOnMaskFunc(
        (W32DRDEV_ASYNCIO_PARAMS *)params);
}
#endif

void 
W32DrPRT::SerialSetTimeouts(
    IN PRDPDR_IOREQUEST_PACKET pIoReq
    )
/*++

Routine Description:

    Handle Serial Port Set Timeouts Request from Server.

Arguments:

    pIoReq  -   Request packet received from server.

Return Value:

    NA
    
 --*/
{
    PBYTE inputBuf;
    NTSTATUS status = STATUS_SUCCESS;
    COMMTIMEOUTS commTimeouts;
    PSERIAL_TIMEOUTS newTimeouts;
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    HANDLE FileHandle;

    DC_BEGIN_FN("W32DrPRT::SerialSetTimeouts");

    TRACEREQ(pIoReq);

    //
    //  Get the IO request.
    //
    pIoRequest = &pIoReq->IoRequest;

    // 
    //  Get Port Handle
    //
    FileHandle = GetPortHandle(pIoRequest->FileId);

    ASSERT(FileHandle != INVALID_HANDLE_VALUE);

    //
    //  Check the size of the incoming request.
    //
    status = DrUTL_CheckIOBufInputSize(pIoReq, sizeof(SERIAL_TIMEOUTS));   
    
    //
    //  Get a pointer to the input buffer.
    //
    inputBuf = (PBYTE)(pIoReq + 1);

    //
    //  Error check the timeout settings.
    //
    if (status == STATUS_SUCCESS) {
        newTimeouts = (PSERIAL_TIMEOUTS)inputBuf;
        if ((newTimeouts->ReadIntervalTimeout == MAXULONG) &&
            (newTimeouts->ReadTotalTimeoutMultiplier == MAXULONG) &&
            (newTimeouts->ReadTotalTimeoutConstant == MAXULONG)) {
            TRC_ERR((TB, _T("Invalid timeout parameters.")));
            status = STATUS_INVALID_PARAMETER;
        }
    }

    //
    //  Set the new timeouts.
    //
    if (status == STATUS_SUCCESS) {

        commTimeouts.ReadIntervalTimeout         = newTimeouts->ReadIntervalTimeout;
        commTimeouts.ReadTotalTimeoutMultiplier  = newTimeouts->ReadTotalTimeoutMultiplier;
        commTimeouts.ReadTotalTimeoutConstant    = newTimeouts->ReadTotalTimeoutConstant;
        commTimeouts.WriteTotalTimeoutMultiplier = newTimeouts->WriteTotalTimeoutMultiplier;
        commTimeouts.WriteTotalTimeoutConstant   = newTimeouts->WriteTotalTimeoutConstant;

        if (!SetCommTimeouts(FileHandle, &commTimeouts)) {
            DWORD err = GetLastError();
            TRC_ALT((TB, _T("SetCommTimeouts failed with %08x"), err));
            status = TranslateWinError(err);
        }
    }

    //
    //  Send the results to the server.
    //
    TRACERESP_WITHPARAMS(pIoReq, NULL, 0, status);	
    DefaultIORequestMsgHandle(pIoReq, status); 

    DC_END_FN();
}

void 
W32DrPRT::SerialGetTimeouts(
    IN PRDPDR_IOREQUEST_PACKET pIoReq
    )
/*++

Routine Description:

    Handle Serial Port Get Timeouts Request from Server.

Arguments:

    pIoReq  -   Request packet received from server.

Return Value:

    NA
    
 --*/
{
    PRDPDR_IOCOMPLETION_PACKET pReplyPacket = NULL;
    NTSTATUS status = STATUS_SUCCESS;
    ULONG replyPacketSize;
    PBYTE outputBuf;
    PSERIAL_TIMEOUTS st;
    COMMTIMEOUTS ct;
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    HANDLE FileHandle;

    DC_BEGIN_FN("W32DrPRT::SerialGetTimeouts");

    TRACEREQ(pIoReq);

    //
    //  Get the IO request.
    //
    pIoRequest = &pIoReq->IoRequest;

    // 
    //  Get Port Handle
    //
    FileHandle = GetPortHandle(pIoRequest->FileId);
    ASSERT(FileHandle != INVALID_HANDLE_VALUE);

    //
    //  Check the size of the output buffer.
    //
    status = DrUTL_CheckIOBufOutputSize(pIoReq, sizeof(SERIAL_TIMEOUTS));

    //
    //  Allocate reply buffer.
    //
    if (status == STATUS_SUCCESS) {
        status = DrUTL_AllocateReplyBuf(pIoReq, &pReplyPacket, &replyPacketSize);
    }

    //
    //  Get the current timeout values.
    //
    if (status == STATUS_SUCCESS) {
        //
        //  Get a pointer to the output buffer and the server timeout values.
        //
        outputBuf = pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBuffer;
        st = (PSERIAL_TIMEOUTS)outputBuf;

        //
        //  Get the client timeout values.
        //
        if (GetCommTimeouts(FileHandle, &ct)) {

            st->ReadIntervalTimeout = ct.ReadIntervalTimeout;
            st->ReadTotalTimeoutMultiplier  = ct.ReadTotalTimeoutMultiplier;
            st->ReadTotalTimeoutConstant    = ct.ReadTotalTimeoutConstant;
            st->WriteTotalTimeoutMultiplier = ct.WriteTotalTimeoutMultiplier;
            st->WriteTotalTimeoutConstant   = ct.WriteTotalTimeoutConstant;
            pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBufferLength 
                    = sizeof(SERIAL_TIMEOUTS); 
        }
        else {
            DWORD err = GetLastError();
            TRC_ALT((TB, _T("GetCommTimeouts failed with %08x"), err));
            status = TranslateWinError(err);
            pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBufferLength 
                    = 0;
            replyPacketSize = (ULONG)FIELD_OFFSET(
                    RDPDR_IOCOMPLETION_PACKET, 
                    IoCompletion.Parameters.DeviceIoControl.OutputBuffer);
        }
    
        //
        //  Finish the response and send it.
        //
        pReplyPacket->IoCompletion.IoStatus = status;
        TRACERESP(pIoReq, pReplyPacket);		
        ProcessObject()->GetVCMgr().ChannelWrite(pReplyPacket, replyPacketSize);
    }
    else {
        //
        //  Send the results to the server.
        //
        TRACERESP_WITHPARAMS(pIoReq, NULL, 0, status);
        DefaultIORequestMsgHandle(pIoReq, status); 
    }

    DC_END_FN();
}

void 
W32DrPRT::SerialSetChars(
    IN PRDPDR_IOREQUEST_PACKET pIoReq
    )
/*++

Routine Description:

    Handle Serial Port Set Chars Request from Server.

Arguments:

    pIoReq  -   Request packet received from server.

Return Value:

    NA
    
 --*/
{
    PBYTE inputBuf;
    NTSTATUS status = STATUS_SUCCESS;
    DCB dcb;
    PSERIAL_CHARS serverChars;
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    HANDLE FileHandle;

    DC_BEGIN_FN("W32DrPRT::SerialSetChars");

    TRACEREQ(pIoReq);

    //
    //  Get the IO request.
    //
    pIoRequest = &pIoReq->IoRequest;

    // 
    //  Get Port Handle
    //
    FileHandle = GetPortHandle(pIoRequest->FileId);
    ASSERT(FileHandle != INVALID_HANDLE_VALUE);

    //
    //  Check the size of the incoming request.
    //
    status = DrUTL_CheckIOBufInputSize(pIoReq, sizeof(SERIAL_CHARS));   

    //
    //  Get a pointer to the input buffer and the server serial characters
    //  buffer.
    //
    inputBuf = (PBYTE)(pIoReq + 1);
    serverChars = (PSERIAL_CHARS)inputBuf;

    //
    //  Get the current DCB.
    //
    if (status == STATUS_SUCCESS) {
        if (!GetCommState(FileHandle, &dcb)) {
            DWORD err = GetLastError();
            TRC_ALT((TB, _T("GetCommState failed with %08x"), err));
            status = TranslateWinError(err);
        }
    }

    //
    //  Set the comm chars and update the DCB.
    //
    if (status == STATUS_SUCCESS) {

        dcb.XonChar     = serverChars->XonChar;
        dcb.XoffChar    = serverChars->XoffChar;  
        dcb.ErrorChar   = serverChars->ErrorChar; 
        dcb.ErrorChar   = serverChars->BreakChar; 
        dcb.EofChar     = serverChars->EofChar;   
        dcb.EvtChar     = serverChars->EventChar; 

        if (!SetCommState(FileHandle, &dcb)) {
            DWORD err = GetLastError();
            TRC_ALT((TB, _T("SetCommState failed with %08x"), err));
            status = TranslateWinError(err);
        }
    }

    //
    //  Send the results to the server.
    //
    TRACERESP_WITHPARAMS(pIoReq, NULL, 0, status);	
    DefaultIORequestMsgHandle(pIoReq, status); 

    DC_END_FN();
}

void 
W32DrPRT::SerialGetChars(
    IN PRDPDR_IOREQUEST_PACKET pIoReq
    )
/*++

Routine Description:

    Handle Serial Port Get Chars Request from Server.

Arguments:

    pIoReq  -   Request packet received from server.

Return Value:

    NA
    
 --*/
{
    PRDPDR_IOCOMPLETION_PACKET pReplyPacket = NULL;
    NTSTATUS status = STATUS_SUCCESS;
    DCB dcb;
    ULONG replyPacketSize;
    PBYTE outputBuf;
    PSERIAL_CHARS serverChars;
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    HANDLE FileHandle;

    DC_BEGIN_FN("W32DrPRT::SerialGetChars");

    TRACEREQ(pIoReq);

    //
    //  Get the IO request.
    //
    pIoRequest = &pIoReq->IoRequest;

    // 
    //  Get Port Handle
    //
    FileHandle = GetPortHandle(pIoRequest->FileId);
    ASSERT(FileHandle != INVALID_HANDLE_VALUE);

    //
    //  Check the size of the output buffer.
    //
    status = DrUTL_CheckIOBufOutputSize(pIoReq, sizeof(SERIAL_CHARS));

    //
    //  Allocate reply buffer.
    //
    if (status == STATUS_SUCCESS) {
        status = DrUTL_AllocateReplyBuf(pIoReq, &pReplyPacket, &replyPacketSize);
    }

    //
    //  Get the current DCB and grab the control character params.
    //
    if (status == STATUS_SUCCESS) {
        //
        //  Get a pointer to the output buffer and control charcter params.
        //
        outputBuf = pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBuffer;
        serverChars = (PSERIAL_CHARS)outputBuf;

        if (GetCommState(FileHandle, &dcb)) {

            serverChars->XonChar     = dcb.XonChar;
            serverChars->XoffChar    = dcb.XoffChar;
            serverChars->ErrorChar   = dcb.ErrorChar;
            serverChars->BreakChar   = dcb.ErrorChar;
            serverChars->EofChar     = dcb.EofChar;
            serverChars->EventChar   = dcb.EvtChar;

            pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBufferLength 
                    = sizeof(SERIAL_CHARS); 
        }
        else {
            DWORD err = GetLastError();
            TRC_ALT((TB, _T("GetCommState failed with %08x"), err));
            status = TranslateWinError(err);

            pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBufferLength 
                    = 0; 
            replyPacketSize = (ULONG)FIELD_OFFSET(
                    RDPDR_IOCOMPLETION_PACKET, 
                    IoCompletion.Parameters.DeviceIoControl.OutputBuffer);
        }
    
        //
        //  Finish the response and send it.
        //
        pReplyPacket->IoCompletion.IoStatus = status;
        TRACERESP(pIoReq, pReplyPacket);		
        ProcessObject()->GetVCMgr().ChannelWrite(pReplyPacket, replyPacketSize);
    }
    else {
        //
        //  Send the results to the server.
        //
        TRACERESP_WITHPARAMS(pIoReq, NULL, 0, status);
        DefaultIORequestMsgHandle(pIoReq, status); 
    }

    DC_END_FN();
}


void 
W32DrPRT::SerialResetDevice(
    IN PRDPDR_IOREQUEST_PACKET pIoReq
    )
/*++

Routine Description:

    Handle Serial Port Reset Device Request from Server.

Arguments:

    pIoReq  -   Request packet received from server.

Return Value:

    NA
    
 --*/
{
    DC_BEGIN_FN("W32DrPRT::SerialResetDevice");

    TRACEREQ(pIoReq);

    //
    //  Send the escape code to the serial port.
    //
    SerialHandleEscapeCode(pIoReq, RESETDEV);

    DC_END_FN();
}

void 
W32DrPRT::SerialSetQueueSize(
    IN PRDPDR_IOREQUEST_PACKET pIoReq
    )
/*++

Routine Description:

    Handle Serial Port Set Queue Size Request from Server.

Arguments:

    pIoReq  -   Request packet received from server.

Return Value:

    NA
    
 --*/
{
    PBYTE inputBuf;
    NTSTATUS status = STATUS_SUCCESS;
    PSERIAL_QUEUE_SIZE serverQueueSize;
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    HANDLE FileHandle;

    DC_BEGIN_FN("W32DrPRT::SerialSetQueueSize");

    TRACEREQ(pIoReq);

    //
    //  Get the IO request.
    //
    pIoRequest = &pIoReq->IoRequest;

    // 
    //  Get Port Handle
    //
    FileHandle = GetPortHandle(pIoRequest->FileId);
    ASSERT(FileHandle != INVALID_HANDLE_VALUE);

    //
    //  Check the size of the incoming request.
    //
    status = DrUTL_CheckIOBufInputSize(pIoReq, sizeof(SERIAL_QUEUE_SIZE));   

    //
    //  Get a pointer to the input buffer and the server serial characters
    //  buffer.
    //
    inputBuf = (PBYTE)(pIoReq + 1);
    serverQueueSize = (PSERIAL_QUEUE_SIZE)inputBuf;

    //
    //  Set the queue size.
    //
    if (status == STATUS_SUCCESS) {

        if (!SetupComm(FileHandle, serverQueueSize->InSize, 
                        serverQueueSize->OutSize)) {
            DWORD err = GetLastError();
            TRC_ALT((TB, _T("SetCommState failed with %08x"), err));
            status = TranslateWinError(err);
        }
    }

    //
    //  Send the results to the server.
    //
    TRACERESP_WITHPARAMS(pIoReq, NULL, 0, status);	
    DefaultIORequestMsgHandle(pIoReq, status); 
    DC_END_FN();
}   

void 
W32DrPRT::SerialGetWaitMask(
    IN PRDPDR_IOREQUEST_PACKET pIoReq
    )
/*++

Routine Description

    Handle Serial Port Get Wait Mask Request from Server.

Arguments:

    pIoReq  -   Request packet received from server.

Return Value:

    NA
    
 --*/
{
    PRDPDR_IOCOMPLETION_PACKET pReplyPacket = NULL;
    NTSTATUS status = STATUS_SUCCESS;   
    ULONG replyPacketSize;
    PBYTE outputBuf;
    ULONG *serverWaitMask;
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    HANDLE FileHandle;

    DC_BEGIN_FN("W32DrPRT::SerialGetWaitMask");

    TRACEREQ(pIoReq);

    //
    //  Get the IO request.
    //
    pIoRequest = &pIoReq->IoRequest;

    // 
    //  Get Port Handle
    //
    FileHandle = GetPortHandle(pIoRequest->FileId);
    ASSERT(FileHandle != INVALID_HANDLE_VALUE);

    //
    //  Check the size of the output buffer.
    //
    status = DrUTL_CheckIOBufOutputSize(pIoReq, sizeof(ULONG));

    //
    //  Allocate reply buffer.
    //
    if (status == STATUS_SUCCESS) {
        status = DrUTL_AllocateReplyBuf(pIoReq, &pReplyPacket, &replyPacketSize);
    }

    //
    //  Get the current wait mask.
    //
    if (status == STATUS_SUCCESS) {
        //
        //  Get a pointer to the output buffer server's wait mask.
        //
        outputBuf = pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBuffer;
        serverWaitMask = (ULONG *)outputBuf;

        if (GetCommMask(FileHandle, serverWaitMask)) {
            pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBufferLength 
                    = sizeof(ULONG); 
        }
        else {
            DWORD err = GetLastError();
            TRC_ALT((TB, _T("GetCommMask failed with %08x"), err));
            status = TranslateWinError(err);
            pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBufferLength 
                    = 0; 
            replyPacketSize = (ULONG)FIELD_OFFSET(
                    RDPDR_IOCOMPLETION_PACKET, 
                    IoCompletion.Parameters.DeviceIoControl.OutputBuffer);
        }
        
        //
        //  Finish the response and send it.
        //
        pReplyPacket->IoCompletion.IoStatus = status;
        TRACERESP(pIoReq, pReplyPacket);		
        ProcessObject()->GetVCMgr().ChannelWrite(pReplyPacket, replyPacketSize);
    }
    else {
        //
        //  Send the results to the server.
        //
        TRACERESP_WITHPARAMS(pIoReq, NULL, 0, status);
        DefaultIORequestMsgHandle(pIoReq, status); 
    }

    DC_END_FN();
}

void 
W32DrPRT::SerialSetWaitMask(
    IN PRDPDR_IOREQUEST_PACKET pIoReq
    )
/*++

Routine Description:

    Handle Serial Port Set Wait Mask Request from Server.

Arguments:

    pIoReq  -   Request packet received from server.

Return Value:

    NA
    
 --*/
{
    PBYTE inputBuf;
    NTSTATUS status = STATUS_SUCCESS;
    ULONG *serverWaitMask;
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    HANDLE FileHandle;

    DC_BEGIN_FN("W32DrPRT::SerialSetWaitMask");

    TRACEREQ(pIoReq);

    //
    //  Get the IO request.
    //
    pIoRequest = &pIoReq->IoRequest;

    // 
    //  Get Port Handle
    //
    FileHandle = GetPortHandle(pIoRequest->FileId);
    ASSERT(FileHandle != INVALID_HANDLE_VALUE);

    //
    //  Check the size of the incoming request.
    //
    status = DrUTL_CheckIOBufInputSize(pIoReq, sizeof(ULONG));   

    //
    //  Get a pointer to the input buffer server's wait mask.
    //
    inputBuf = (PBYTE)(pIoReq + 1);
    serverWaitMask = (ULONG *)inputBuf;

    //
    //  Set the mask.
    //
    if (status == STATUS_SUCCESS) {
        if (!SetCommMask(FileHandle, *serverWaitMask)) {
            DWORD err = GetLastError();
            TRC_ALT((TB, _T("SetCommMask failed with %08x"), err));
            status = TranslateWinError(err);
        }
    }

    //
    //  Send the results to the server.
    //
    TRACERESP_WITHPARAMS(pIoReq, NULL, 0, status);	
    DefaultIORequestMsgHandle(pIoReq, status); 

    DC_END_FN();
}

void 
W32DrPRT::SerialWaitOnMask(
    IN PRDPDR_IOREQUEST_PACKET pIoReq
    )
/*++

Routine Description:

    Handle Serial Port Wait on Mask Request from Server.

Arguments:

    pIoReq  -   Request packet received from server.

Return Value:

    NA
    
 --*/
{
    DWORD status;
#ifdef OS_WINCE
    W32DRDEV_ASYNCIO_PARAMS *params = NULL;
#else
    W32DRDEV_OVERLAPPEDIO_PARAMS *params = NULL;    
#endif

    DWORD ntStatus;

    DC_BEGIN_FN("W32DrPRT::SerialWaitOnMask");

    TRACEREQ(pIoReq);

    //
    //  Check the size of the output buffer.
    //
    status = DrUTL_CheckIOBufOutputSize(pIoReq, sizeof(DWORD));   

    //
    //  Allocate and dispatch an asynchronous IO request.
    //
    if (status == ERROR_SUCCESS) {
#ifdef OS_WINCE
        params = new W32DRDEV_ASYNCIO_PARAMS(this, pIoReq);
#else
        params = new W32DRDEV_OVERLAPPEDIO_PARAMS(this, pIoReq);
#endif
        if (params != NULL ) {
            status = ProcessObject()->DispatchAsyncIORequest(
                                    (RDPAsyncFunc_StartIO)
                                        W32DrPRT::_StartWaitOnMaskFunc,
                                    (RDPAsyncFunc_IOComplete)_CompleteIOFunc,
                                    (RDPAsyncFunc_IOCancel)_CancelIOFunc,
                                    params
                                    );
        }
        else {
            TRC_ERR((TB, _T("Memory alloc failed.")));
            status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    //
    //  Translate to a Windows error status.
    //
    ntStatus = TranslateWinError(status);

    //
    //  Clean up on error.
    //
    if (status != ERROR_SUCCESS) {
        if (params != NULL) {
            delete params;
        }
        
        //
        //  Send the results to the server.
        //
        DefaultIORequestMsgHandle(pIoReq, ntStatus);         
    }

    TRACERESP_WITHPARAMS(pIoReq, NULL, 0, ntStatus);	
    DC_END_FN();
}

void 
W32DrPRT::SerialPurge(
    IN PRDPDR_IOREQUEST_PACKET pIoReq
    )
/*++

Routine Description:

    Handle Serial Port Serial Purge Request from Server.

Arguments:

    pIoReq  -   Request packet received from server.

Return Value:

    NA
    
 --*/
{
    PBYTE inputBuf;
    NTSTATUS status = STATUS_SUCCESS;
    DWORD *purgeFlags;
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    HANDLE FileHandle;

    DC_BEGIN_FN("W32DrPRT::SerialPurge");

    TRACEREQ(pIoReq);

    //
    //  Get the IO request.
    //
    pIoRequest = &pIoReq->IoRequest;

    // 
    //  Get Port Handle
    //
    FileHandle = GetPortHandle(pIoRequest->FileId);
    ASSERT(FileHandle != INVALID_HANDLE_VALUE);

    //
    //  Check the size of the incoming request.
    //
    status = DrUTL_CheckIOBufInputSize(pIoReq, sizeof(DWORD));   

    //
    //  Get a pointer to the input buffer and purge flags.
    //
    inputBuf = (PBYTE)(pIoReq + 1);
    purgeFlags = (DWORD *)inputBuf;

    //
    //  Purge.
    //
    if (status == STATUS_SUCCESS) {
        if (!PurgeComm(FileHandle, *purgeFlags)) {
            DWORD err = GetLastError();
            TRC_ALT((TB, _T("PurgeComm failed with %08x"), err));
            status = TranslateWinError(err);
        }
    }

    //
    //  Send the results to the server.
    //
    TRACERESP_WITHPARAMS(pIoReq, NULL, 0, status);	
    DefaultIORequestMsgHandle(pIoReq, status); 

    DC_END_FN();
}

void 
W32DrPRT::SerialGetHandflow(
    IN PRDPDR_IOREQUEST_PACKET pIoReq
    )
/*++

Routine Description:

    Handle Serial Port Get Handflow Request from Server.

Arguments:

    pIoReq  -   Request packet received from server.

Return Value:

    NA
    
 --*/
{
    PRDPDR_IOCOMPLETION_PACKET pReplyPacket = NULL;
    NTSTATUS status = STATUS_SUCCESS;
    DCB dcb;
    ULONG replyPacketSize;
    PBYTE outputBuf;
    PSERIAL_HANDFLOW handFlow;
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    HANDLE FileHandle;

    DC_BEGIN_FN("W32DrPRT::SerialGetHandflow");

    TRACEREQ(pIoReq);

    //
    //  Get the IO request.
    //
    pIoRequest = &pIoReq->IoRequest;

    // 
    //  Get Port Handle
    //
    FileHandle = GetPortHandle(pIoRequest->FileId);
    ASSERT(FileHandle != INVALID_HANDLE_VALUE);

    //
    //  Check the size of the output buffer.
    //
    status = DrUTL_CheckIOBufOutputSize(pIoReq, sizeof(SERIAL_HANDFLOW));

    //
    //  Allocate reply buffer.
    //
    if (status == STATUS_SUCCESS) {
        status = DrUTL_AllocateReplyBuf(pIoReq, &pReplyPacket, &replyPacketSize);
    }

    //
    //  Get the current DCB.
    //
    if (status == STATUS_SUCCESS) {
        //
        //  Get a pointer to the output buffer server's serial hand flow struct.
        //
        outputBuf = pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBuffer;
        handFlow = (PSERIAL_HANDFLOW)outputBuf;

        if (GetCommState(FileHandle, &dcb)) {
            //
            //  Set the hand flow fields based on the current value of fields
            //  in the DCB.
            //

            memset(handFlow, 0, sizeof(SERIAL_HANDFLOW));

            //
            //  RTS Settings
            //
            handFlow->FlowReplace &= ~SERIAL_RTS_MASK;
            switch (dcb.fRtsControl) {
                case RTS_CONTROL_DISABLE:
                    break;
                case RTS_CONTROL_ENABLE:
                    handFlow->FlowReplace |= SERIAL_RTS_CONTROL;
                    break;
                case RTS_CONTROL_HANDSHAKE:
                    handFlow->FlowReplace |= SERIAL_RTS_HANDSHAKE;
                    break;
                case RTS_CONTROL_TOGGLE:
                    handFlow->FlowReplace |= SERIAL_TRANSMIT_TOGGLE;
                    break;
                default:
                    //  Don't think this should ever happen?
                    ASSERT(FALSE);
            }
    
            //
            //  DTR Settings
            //  
            handFlow->ControlHandShake &= ~SERIAL_DTR_MASK;
            switch (dcb.fDtrControl) {
                case DTR_CONTROL_DISABLE:
                    break;
                case DTR_CONTROL_ENABLE:
                    handFlow->ControlHandShake |= SERIAL_DTR_CONTROL;
                    break;
                case DTR_CONTROL_HANDSHAKE:
                    handFlow->ControlHandShake |= SERIAL_DTR_HANDSHAKE;
                    break;
                default:
                    //  Don't think this should ever happen?
                    ASSERT(FALSE);
            }
    
            if (dcb.fDsrSensitivity) {
                handFlow->ControlHandShake |= SERIAL_DSR_SENSITIVITY;
            }
    
            if (dcb.fOutxCtsFlow) {
                handFlow->ControlHandShake |= SERIAL_CTS_HANDSHAKE;
            }
    
            if (dcb.fOutxDsrFlow) {
                handFlow->ControlHandShake |= SERIAL_DSR_HANDSHAKE;
            }
    
            if (dcb.fOutX) {
                handFlow->FlowReplace |= SERIAL_AUTO_TRANSMIT;
            }
    
            if (dcb.fInX) {
                handFlow->FlowReplace |= SERIAL_AUTO_RECEIVE;
            }
    
            if (dcb.fNull) {
                handFlow->FlowReplace |= SERIAL_NULL_STRIPPING;
            }
    
            if (dcb.fErrorChar) {
                handFlow->FlowReplace |= SERIAL_ERROR_CHAR;
            }
    
            if (dcb.fTXContinueOnXoff) {
                handFlow->FlowReplace |= SERIAL_XOFF_CONTINUE;
            }
    
            if (dcb.fAbortOnError) {
                handFlow->ControlHandShake |= SERIAL_ERROR_ABORT;
            }

            pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBufferLength 
                    = sizeof(SERIAL_HANDFLOW); 
        }
        else {
            DWORD err = GetLastError();
            TRC_ALT((TB, _T("GetCommState failed with %08x"), err));
            status = TranslateWinError(err);
            pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBufferLength 
                    = 0;
            replyPacketSize = (ULONG)FIELD_OFFSET(
                    RDPDR_IOCOMPLETION_PACKET, 
                    IoCompletion.Parameters.DeviceIoControl.OutputBuffer);
        }        

        //
        //  Finish the response and send it.
        //
        pReplyPacket->IoCompletion.IoStatus = status;
        TRACERESP(pIoReq, pReplyPacket);
        ProcessObject()->GetVCMgr().ChannelWrite(pReplyPacket, replyPacketSize);
    }
    else {
        //
        //  Send the results to the server.
        //
        TRACERESP_WITHPARAMS(pIoReq, NULL, 0, status);
        DefaultIORequestMsgHandle(pIoReq, status); 
    }
    
    DC_END_FN();
}

void 
W32DrPRT::SerialSetHandflow(
    IN PRDPDR_IOREQUEST_PACKET pIoReq
    )
/*++

Routine Description:

    Handle Serial Port Set Handflow Request from Server.

Arguments:

    pIoReq  -   Request packet received from server.

Return Value:

    NA
    
 --*/
{
    PBYTE inputBuf;
    NTSTATUS status = STATUS_SUCCESS;
    DCB dcb;
    PSERIAL_HANDFLOW handFlow;
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    HANDLE FileHandle;

    DC_BEGIN_FN("W32DrPRT::SerialSetHandflow");

    //
    //  Check the size of the incoming request.
    //
    status = DrUTL_CheckIOBufInputSize(pIoReq, sizeof(SERIAL_HANDFLOW));   

    TRACEREQ(pIoReq);

    //
    //  Get the IO request.
    //
    pIoRequest = &pIoReq->IoRequest;

    // 
    //  Get Port Handle
    //
    FileHandle = GetPortHandle(pIoRequest->FileId);
    ASSERT(FileHandle != INVALID_HANDLE_VALUE);

    //
    //  Get a pointer to the input buffer and the server serial characters
    //  buffer.
    //
    inputBuf = (PBYTE)(pIoReq + 1);
    handFlow = (PSERIAL_HANDFLOW)inputBuf;

    //
    //  Get the current DCB.
    //
    if (status == STATUS_SUCCESS) {
        if (!GetCommState(FileHandle, &dcb)) {
            DWORD err = GetLastError();
            TRC_ALT((TB, _T("GetCommState failed with %08x"), err));
            status = TranslateWinError(err);
        }
    }

    //
    //  Update the DCB based on the new server-side handflow values.
    //
    if (status == STATUS_SUCCESS) {
        if (handFlow->ControlHandShake & SERIAL_CTS_HANDSHAKE) {
            dcb.fOutxCtsFlow = TRUE;
        }

        if (handFlow->ControlHandShake & SERIAL_DSR_HANDSHAKE) {
            dcb.fOutxDsrFlow = TRUE;
        }

        if (handFlow->FlowReplace & SERIAL_AUTO_TRANSMIT) {
            dcb.fOutX = TRUE;
        }

        if (handFlow->FlowReplace & SERIAL_AUTO_RECEIVE) {
            dcb.fInX = TRUE;
        }

        if (handFlow->FlowReplace & SERIAL_NULL_STRIPPING) {
            dcb.fNull = TRUE;
        }

        if (handFlow->FlowReplace & SERIAL_ERROR_CHAR) {
            dcb.fErrorChar = TRUE;
        }

        if (handFlow->FlowReplace & SERIAL_XOFF_CONTINUE) {
            dcb.fTXContinueOnXoff = TRUE;
        }

        if (handFlow->ControlHandShake & SERIAL_ERROR_ABORT) {
            dcb.fAbortOnError = TRUE;
        }

        switch (handFlow->FlowReplace & SERIAL_RTS_MASK) {
            case 0:
                dcb.fRtsControl = RTS_CONTROL_DISABLE;
                break;
            case SERIAL_RTS_CONTROL:
                dcb.fRtsControl = RTS_CONTROL_ENABLE;
                break;
            case SERIAL_RTS_HANDSHAKE:
                dcb.fRtsControl = RTS_CONTROL_HANDSHAKE;
                break;
            case SERIAL_TRANSMIT_TOGGLE:
                dcb.fRtsControl = RTS_CONTROL_TOGGLE;
                break;
        }

        switch (handFlow->ControlHandShake & SERIAL_DTR_MASK) {
            case 0:
                dcb.fDtrControl = DTR_CONTROL_DISABLE;
                break;
            case SERIAL_DTR_CONTROL:
                dcb.fDtrControl = DTR_CONTROL_ENABLE;
                break;
            case SERIAL_DTR_HANDSHAKE:
                dcb.fDtrControl = DTR_CONTROL_HANDSHAKE;
                break;
        }

        dcb.fDsrSensitivity =
            (handFlow->ControlHandShake & SERIAL_DSR_SENSITIVITY)?(TRUE):(FALSE);
        dcb.XonLim = (WORD)handFlow->XonLimit;
        dcb.XoffLim = (WORD)handFlow->XoffLimit;
    }

    //
    //  Update the DCB.
    //
    if (status == STATUS_SUCCESS) {
        if (!SetCommState(FileHandle, &dcb)) {
            DWORD err = GetLastError();
            TRC_NRM((TB, _T("SetCommState failed with %08x"), err));
            status = TranslateWinError(err);
        }
    }

    //
    //  Send the results to the server.
    //
    TRACERESP_WITHPARAMS(pIoReq, NULL, 0, status);	
    DefaultIORequestMsgHandle(pIoReq, status); 

    DC_END_FN();
}

void 
W32DrPRT::SerialGetModemStatus(
    IN PRDPDR_IOREQUEST_PACKET pIoReq
    )
/*++

Routine Description:

    Handle Serial Port Get Modem Status Request from Server.

Arguments:

    pIoReq  -   Request packet received from server.

Return Value:

    NA
    
 --*/
{
    PRDPDR_IOCOMPLETION_PACKET pReplyPacket = NULL;
    NTSTATUS status = STATUS_SUCCESS;
    ULONG replyPacketSize;
    PBYTE outputBuf;
    LPDWORD modemStatus;
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    HANDLE FileHandle;

    DC_BEGIN_FN("W32DrPRT::SerialGetModemStatus");

    TRACEREQ(pIoReq);

    //
    //  Get the IO request.
    //
    pIoRequest = &pIoReq->IoRequest;

    // 
    //  Get Port Handle
    //
    FileHandle = GetPortHandle(pIoRequest->FileId);
    ASSERT(FileHandle != INVALID_HANDLE_VALUE);

    //
    //  Check the size of the output buffer.
    //
    status = DrUTL_CheckIOBufOutputSize(pIoReq, sizeof(DWORD));

    //
    //  Allocate reply buffer.
    //
    if (status == STATUS_SUCCESS) {
        status = DrUTL_AllocateReplyBuf(pIoReq, &pReplyPacket, &replyPacketSize);
    }

    //
    //  Get the current modem status.
    //
    if (status == STATUS_SUCCESS) {
        //
        //  Get a pointer to the output buffer server's modem status.
        //
        outputBuf = pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBuffer;
        modemStatus = (LPDWORD)outputBuf;

        if (GetCommModemStatus(FileHandle, modemStatus)) {
            TRC_NRM((TB, _T("GetCommModemStatus result: 0x%08x"), *modemStatus));

            pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBufferLength 
                    = sizeof(DWORD); 
        }
        else {
            DWORD err = GetLastError();
            TRC_ERR((TB, _T("GetCommModemStatus failed with 0x%08x"), err));
            status = TranslateWinError(err);
            pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBufferLength
                    = 0;
            replyPacketSize = (ULONG)FIELD_OFFSET(
                    RDPDR_IOCOMPLETION_PACKET, 
                    IoCompletion.Parameters.DeviceIoControl.OutputBuffer);
        }        

        //
        //  Finish the response and send it.
        //
        pReplyPacket->IoCompletion.IoStatus = status;
        TRACERESP(pIoReq, pReplyPacket);
        ProcessObject()->GetVCMgr().ChannelWrite(pReplyPacket, replyPacketSize);
    }
    else {
        //
        //  Send the results to the server.
        //
        TRACERESP_WITHPARAMS(pIoReq, NULL, 0, status);
        DefaultIORequestMsgHandle(pIoReq, status); 
    }

    

    DC_END_FN();
}

void 
W32DrPRT::SerialGetDTRRTS(
    IN PRDPDR_IOREQUEST_PACKET pIoReq
    )
/*++

Routine Description:

    Handle Serial Port Get DTRRRTS Request from Server.

Arguments:

    pIoReq  -   Request packet received from server.

Return Value:

    NA
    
 --*/
{
    //
    //  This IOCTL is not supported by Win32 COMM functions.  What 
    //  else can we do, but pass it directly to the driver.  We should ASSERT 
    //  to find out under which circumstances this happens, however.
    //
    DC_BEGIN_FN("W32DrPRT::SerialGetDTRRTS");

    TRACEREQ(pIoReq);

    ASSERT(FALSE);
    DispatchIOCTLDirectlyToDriver(pIoReq);
    DC_END_FN();
}

void 
W32DrPRT::SerialGetCommStatus(
    IN PRDPDR_IOREQUEST_PACKET pIoReq
    )
/*++

Routine Description:

    Handle Serial Port Get Comm Status Request from Server.

Arguments:

    pIoReq  -   Request packet received from server.

Return Value:

    NA
    
 --*/
{
    PRDPDR_IOCOMPLETION_PACKET pReplyPacket = NULL;
    NTSTATUS status = STATUS_SUCCESS;
    ULONG replyPacketSize;
    PBYTE outputBuf;
    PSERIAL_STATUS serverCommStatus;
    COMSTAT localStatus;
    DWORD errors;
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    HANDLE FileHandle;

    DC_BEGIN_FN("W32DrPRT::SerialGetCommStatus");

    TRACEREQ(pIoReq);

    //
    //  Get the IO request.
    //
    pIoRequest = &pIoReq->IoRequest;

    // 
    //  Get Port Handle
    //
    FileHandle = GetPortHandle(pIoRequest->FileId);
    ASSERT(FileHandle != INVALID_HANDLE_VALUE);

    //
    //  Check the size of the output buffer.
    //
    status = DrUTL_CheckIOBufOutputSize(pIoReq, sizeof(SERIAL_STATUS));

    //
    //  Allocate reply buffer.
    //
    if (status == STATUS_SUCCESS) {
        status = DrUTL_AllocateReplyBuf(pIoReq, &pReplyPacket, &replyPacketSize);
    }

    //
    //  Get the current communications status (via the ClearCommError API).
    //
    if (status == STATUS_SUCCESS) {
        //
        //  Get a pointer to the output buffer server's modem status.
        //
        outputBuf = pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBuffer;
        serverCommStatus = (PSERIAL_STATUS)outputBuf;

        if (ClearCommError(FileHandle, &errors, &localStatus)) {
            //
            //  Convert to server-representation of communication status.  
            //

            serverCommStatus->HoldReasons = 0;
            if (localStatus.fCtsHold) {
                serverCommStatus->HoldReasons |= SERIAL_TX_WAITING_FOR_CTS;
            }
    
            if (localStatus.fDsrHold) {
                serverCommStatus->HoldReasons |= SERIAL_TX_WAITING_FOR_DSR;
            }
    
            if (localStatus.fRlsdHold) {
                serverCommStatus->HoldReasons |= SERIAL_TX_WAITING_FOR_DCD;
            }
    
            if (localStatus.fXoffHold) {
                serverCommStatus->HoldReasons |= SERIAL_TX_WAITING_FOR_XON;
            }
    
            if (localStatus.fXoffSent) {
                serverCommStatus->HoldReasons |= SERIAL_TX_WAITING_XOFF_SENT;
            }
    
            serverCommStatus->EofReceived       =   (BOOLEAN)localStatus.fEof;
            serverCommStatus->WaitForImmediate  =   (BOOLEAN)localStatus.fTxim;
            serverCommStatus->AmountInInQueue   =   localStatus.cbInQue;
            serverCommStatus->AmountInOutQueue  =   localStatus.cbOutQue;
    
            serverCommStatus->Errors = 0;
            if (errors & CE_BREAK) {
                serverCommStatus->Errors |= SERIAL_ERROR_BREAK;
            }
    
            if (errors & CE_FRAME) {
                serverCommStatus->Errors |= SERIAL_ERROR_FRAMING;
            }
    
            if (errors & CE_OVERRUN) {
                serverCommStatus->Errors |= SERIAL_ERROR_OVERRUN;
            }
    
            if (errors & CE_RXOVER) {
                serverCommStatus->Errors |= SERIAL_ERROR_QUEUEOVERRUN;
            }
    
            if (errors & CE_RXPARITY) {
                serverCommStatus->Errors |= SERIAL_ERROR_PARITY;
            }

            pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBufferLength 
                    = sizeof(SERIAL_STATUS); 
        }
        else {
            DWORD err = GetLastError();
            TRC_ALT((TB, _T("ClearCommError failed with %08x"), err));
            status = TranslateWinError(err);
            pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBufferLength 
                    = 0;
            replyPacketSize = (ULONG)FIELD_OFFSET(
                    RDPDR_IOCOMPLETION_PACKET, 
                    IoCompletion.Parameters.DeviceIoControl.OutputBuffer);
        }
    
        //
        //  Finish the response and send it.
        //
        pReplyPacket->IoCompletion.IoStatus = status;
        TRACERESP(pIoReq, pReplyPacket);
        ProcessObject()->GetVCMgr().ChannelWrite(pReplyPacket, replyPacketSize);
    }
    else {
        //
        //  Send the results to the server.
        //
        TRACERESP_WITHPARAMS(pIoReq, NULL, 0, status);
        DefaultIORequestMsgHandle(pIoReq, status); 
    }

    DC_END_FN();
}

void 
W32DrPRT::SerialGetProperties(
    IN PRDPDR_IOREQUEST_PACKET pIoReq
    )
/*++

Routine Description:

    Handle Serial Port Get Properties Request from Server.

Arguments:

    pIoReq  -   Request packet received from server.

Return Value:

    NA
    
 --*/
{
    PRDPDR_IOCOMPLETION_PACKET pReplyPacket = NULL;
    NTSTATUS status = STATUS_SUCCESS;
    ULONG replyPacketSize;
    PBYTE outputBuf;
    PSERIAL_COMMPROP serverProperties;
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    HANDLE FileHandle;

    DC_BEGIN_FN("W32DrPRT::SerialGetProperties");

    TRACEREQ(pIoReq);

    //
    //  Make sure that the windows defines and the NT defines are
    //  still in sync.
    //
    // Asserts are broken up because if the assert msg string is
    // too long it causes a compile error
    ASSERT((SERIAL_PCF_DTRDSR        == PCF_DTRDSR) &&
           (SERIAL_PCF_RTSCTS        == PCF_RTSCTS) &&
           (SERIAL_PCF_CD            == PCF_RLSD) &&
           (SERIAL_PCF_PARITY_CHECK  == PCF_PARITY_CHECK) &&
           (SERIAL_PCF_XONXOFF       == PCF_XONXOFF) &&
           (SERIAL_PCF_SETXCHAR      == PCF_SETXCHAR) &&
           (SERIAL_PCF_TOTALTIMEOUTS == PCF_TOTALTIMEOUTS) &&
           (SERIAL_PCF_INTTIMEOUTS   == PCF_INTTIMEOUTS) &&
           (SERIAL_PCF_SPECIALCHARS  == PCF_SPECIALCHARS) &&
           (SERIAL_PCF_16BITMODE     == PCF_16BITMODE) &&
           (SERIAL_SP_PARITY         == SP_PARITY) &&
           (SERIAL_SP_BAUD           == SP_BAUD) &&
           (SERIAL_SP_DATABITS       == SP_DATABITS) &&
           (SERIAL_SP_STOPBITS       == SP_STOPBITS) &&
           (SERIAL_SP_HANDSHAKING    == SP_HANDSHAKING) &&
           (SERIAL_SP_PARITY_CHECK   == SP_PARITY_CHECK) &&
           (SERIAL_SP_CARRIER_DETECT == SP_RLSD));
    ASSERT((SERIAL_BAUD_075          == BAUD_075) &&
           (SERIAL_BAUD_110          == BAUD_110) &&
           (SERIAL_BAUD_134_5        == BAUD_134_5) &&
           (SERIAL_BAUD_150          == BAUD_150) &&
           (SERIAL_BAUD_300          == BAUD_300) &&
           (SERIAL_BAUD_600          == BAUD_600) &&
           (SERIAL_BAUD_1200         == BAUD_1200) &&
           (SERIAL_BAUD_1800         == BAUD_1800) &&
           (SERIAL_BAUD_2400         == BAUD_2400) &&
           (SERIAL_BAUD_4800         == BAUD_4800) &&
           (SERIAL_BAUD_7200         == BAUD_7200) &&
           (SERIAL_BAUD_9600         == BAUD_9600) &&
           (SERIAL_BAUD_14400        == BAUD_14400) &&
           (SERIAL_BAUD_19200        == BAUD_19200) &&
           (SERIAL_BAUD_38400        == BAUD_38400) &&
           (SERIAL_BAUD_56K          == BAUD_56K) &&
           (SERIAL_BAUD_57600        == BAUD_57600) &&
           (SERIAL_BAUD_115200       == BAUD_115200) &&
           (SERIAL_BAUD_USER         == BAUD_USER) &&
           (SERIAL_DATABITS_5        == DATABITS_5) &&
           (SERIAL_DATABITS_6        == DATABITS_6) &&
           (SERIAL_DATABITS_7        == DATABITS_7) &&
           (SERIAL_DATABITS_8        == DATABITS_8) &&
           (SERIAL_DATABITS_16       == DATABITS_16));
    ASSERT((SERIAL_DATABITS_16X      == DATABITS_16X) &&
           (SERIAL_STOPBITS_10       == STOPBITS_10) &&
           (SERIAL_STOPBITS_15       == STOPBITS_15) &&
           (SERIAL_STOPBITS_20       == STOPBITS_20) &&
           (SERIAL_PARITY_NONE       == PARITY_NONE) &&
           (SERIAL_PARITY_ODD        == PARITY_ODD) &&
           (SERIAL_PARITY_EVEN       == PARITY_EVEN) &&
           (SERIAL_PARITY_MARK       == PARITY_MARK) &&
           (SERIAL_PARITY_SPACE      == PARITY_SPACE));
    ASSERT((SERIAL_SP_UNSPECIFIED    == PST_UNSPECIFIED) &&
           (SERIAL_SP_RS232          == PST_RS232) &&
           (SERIAL_SP_PARALLEL       == PST_PARALLELPORT) &&
           (SERIAL_SP_RS422          == PST_RS422) &&
           (SERIAL_SP_RS423          == PST_RS423) &&
           (SERIAL_SP_RS449          == PST_RS449) &&
           (SERIAL_SP_FAX            == PST_FAX) &&
           (SERIAL_SP_SCANNER        == PST_SCANNER) &&
           (SERIAL_SP_BRIDGE         == PST_NETWORK_BRIDGE) &&
           (SERIAL_SP_LAT            == PST_LAT) &&
           (SERIAL_SP_TELNET         == PST_TCPIP_TELNET) &&
           (SERIAL_SP_X25            == PST_X25));
    ASSERT(sizeof(SERIAL_COMMPROP) == sizeof(COMMPROP));

    //
    //  Get the IO request.
    //
    pIoRequest = &pIoReq->IoRequest;

    // 
    //  Get Port Handle
    //
    FileHandle = GetPortHandle(pIoRequest->FileId);    
    ASSERT(FileHandle != INVALID_HANDLE_VALUE);

    //
    //  Check the size of the output buffer.
    //
    status = DrUTL_CheckIOBufOutputSize(pIoReq, sizeof(SERIAL_COMMPROP));

    //
    //  Allocate reply buffer.
    //
    if (status == STATUS_SUCCESS) {
        status = DrUTL_AllocateReplyBuf(pIoReq, &pReplyPacket, &replyPacketSize);
    }

    //
    //  Get the current properties.
    //
    if (status == STATUS_SUCCESS) {
        //
        //  Get a pointer to the output buffer server's communication properties
        //
        outputBuf = pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBuffer;
        serverProperties = (PSERIAL_COMMPROP)outputBuf;

        if (GetCommProperties(FileHandle, (LPCOMMPROP)serverProperties)) {
            pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBufferLength 
                    = sizeof(SERIAL_COMMPROP); 
        }
        else {
            DWORD err = GetLastError();
            TRC_ALT((TB, _T("GetCommProperties failed with %08x"), err));
            status = TranslateWinError(err);
            pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBufferLength 
                    = 0;
            replyPacketSize = (ULONG)FIELD_OFFSET(
                    RDPDR_IOCOMPLETION_PACKET, 
                    IoCompletion.Parameters.DeviceIoControl.OutputBuffer);
        }
        
        //
        //  Finish the response and send it.
        //
        pReplyPacket->IoCompletion.IoStatus = status;
        TRACERESP(pIoReq, pReplyPacket);
        ProcessObject()->GetVCMgr().ChannelWrite(pReplyPacket, replyPacketSize);
    }
    else {
        //
        //  Send the results to the server.
        //
        TRACERESP_WITHPARAMS(pIoReq, NULL, 0, status);
        DefaultIORequestMsgHandle(pIoReq, status); 
    }
    DC_END_FN();
}

void 
W32DrPRT::SerialXoffCounter(
    IN PRDPDR_IOREQUEST_PACKET pIoReq
    )
/*++

Routine Description:

    Handle Serial Port XOFF Request from Server.

Arguments:

    pIoReq  -   Request packet received from server.

Return Value:

    NA
    
 --*/
{
    DC_BEGIN_FN("W32DrPRT::SerialXoffCounter");

    TRACEREQ(pIoReq);

    //
    //  This IOCTL is not supported by Win32 COMM functions.  What 
    //  else can we do, but pass it directly to the driver.  We should ASSERT 
    //  to find out under which circumstances this happens, however.
    //
    ASSERT(FALSE);
    DispatchIOCTLDirectlyToDriver(pIoReq);
    DC_END_FN();
}

void 
W32DrPRT::SerialLSRMSTInsert(
    IN PRDPDR_IOREQUEST_PACKET pIoReq
    )
/*++

Routine Description:

    Handle Serial Port LSRMST Insert Request from Server.

Arguments:

    pIoReq  -   Request packet received from server.

Return Value:

    NA
    
 --*/
{
    DC_BEGIN_FN("W32DrPRT::SerialLSRMSTInsert");

    TRACEREQ(pIoReq);

    //
    //  This IOCTL is not supported by Win32 COMM functions.  What 
    //  else can we do, but pass it directly to the driver.  We should ASSERT 
    //  to find out under which circumstances this happens, however.
    //
    ASSERT(FALSE);
    DispatchIOCTLDirectlyToDriver(pIoReq);
    DC_END_FN();
}

void
W32DrPRT::SerialConfigSize(
    IN PRDPDR_IOREQUEST_PACKET pIoReq
    )
/*++

Routine Description:

    Handle Serial Port Get Config Size Request from Server.

    We don't support the IOCTL that is used to fetch the
    configuration.  Neither does the NT serial driver ...
    
Arguments:

    pIoReq  -   Request packet received from server.

Return Value:

    NA
    
 --*/
{
    PRDPDR_IOCOMPLETION_PACKET pReplyPacket = NULL;
    NTSTATUS status = STATUS_SUCCESS;
#ifndef OS_WINCE
    DCB dcb;
#endif
    ULONG replyPacketSize;
    PBYTE outputBuf;
    ULONG *configSize;
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    HANDLE FileHandle;

    DC_BEGIN_FN("W32DrPRT::SerialConfigSize");

    TRACEREQ(pIoReq);

    //
    //  Get the IO request.
    //
    pIoRequest = &pIoReq->IoRequest;

    // 
    //  Get Port Handle
    //
    FileHandle = GetPortHandle(pIoRequest->FileId);
    ASSERT(FileHandle != INVALID_HANDLE_VALUE);

    //
    //  Check the size of the output buffer.
    //
    status = DrUTL_CheckIOBufOutputSize(pIoReq, sizeof(ULONG));

    //
    //  Allocate reply buffer.
    //
    if (status == STATUS_SUCCESS) {
        status = DrUTL_AllocateReplyBuf(pIoReq, &pReplyPacket, &replyPacketSize);
    }

    //
    //  Get the configuration size.
    //
    if (status == STATUS_SUCCESS) {
        //
        //  Get a pointer to the output buffer server's wait mask.
        //
        outputBuf = pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBuffer;
        configSize = (ULONG *)outputBuf;

#ifndef OS_WINCE
        if (GetCommConfig(FileHandle, NULL, configSize)) {
            pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBufferLength 
                = sizeof(ULONG); 
        }
        else {
            DWORD err = GetLastError();
            
            TRC_ALT((TB, _T("GetCommConfig failed with %08x"), err));
            status = TranslateWinError(err);
#else
            status = STATUS_NOT_SUPPORTED;
#endif
            pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBufferLength 
                = 0; 
            replyPacketSize = (ULONG)FIELD_OFFSET(
                    RDPDR_IOCOMPLETION_PACKET, 
                    IoCompletion.Parameters.DeviceIoControl.OutputBuffer);
#ifndef OS_WINCE
        }
#endif
        
        //
        //  Finish the response and send it.
        //
        pReplyPacket->IoCompletion.IoStatus = status;
        TRACERESP(pIoReq, pReplyPacket);
        ProcessObject()->GetVCMgr().ChannelWrite(pReplyPacket, replyPacketSize);
    }
    else {
        //
        //  Send the results to the server.
        //
        TRACERESP_WITHPARAMS(pIoReq, NULL, 0, status);
        DefaultIORequestMsgHandle(pIoReq, status); 
    }

    DC_END_FN();
}

void
W32DrPRT::SerialGetConfig(
    IN PRDPDR_IOREQUEST_PACKET pIoReq
    )
/*++

Routine Description:

    Handle Serial Port Get Config Request from Server.    
    
Arguments:

    pIoReq  -   Request packet received from server.

Return Value:

    NA
    
 --*/
{
    PRDPDR_IOCOMPLETION_PACKET pReplyPacket = NULL;
    NTSTATUS status = STATUS_SUCCESS;
    ULONG replyPacketSize;
    PBYTE outputBuf;
    ULONG configSize;
    PRDPDR_DEVICE_IOREQUEST pIoRequest;
    HANDLE FileHandle;

    DC_BEGIN_FN("W32DrPRT::SerialGetConfig");

    TRACEREQ(pIoReq);

    //
    //  Get the IO request.
    //
    pIoRequest = &pIoReq->IoRequest;

    // 
    //  Get Port Handle
    //
    FileHandle = GetPortHandle(pIoRequest->FileId);
    ASSERT(FileHandle != INVALID_HANDLE_VALUE);

    //
    //  Allocate reply buffer.
    //
    status = DrUTL_AllocateReplyBuf(pIoReq, &pReplyPacket, &replyPacketSize);
    
    //
    //  Get the configuration size.
    //
    if (status == STATUS_SUCCESS) {
        //
        //  Get a pointer to the output buffer server's wait mask.
        //
        outputBuf = pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBuffer;
        configSize = pIoRequest->Parameters.DeviceIoControl.OutputBufferLength;

#ifndef OS_WINCE
        if (GetCommConfig(FileHandle, (COMMCONFIG *)outputBuf, &configSize)) {
            pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBufferLength 
                = configSize; 
        }
        else {
            DWORD err = GetLastError();
            TRC_ALT((TB, _T("GetCommConfig failed with %08x"), err));
            status = TranslateWinError(err);
#else
            status = STATUS_NOT_SUPPORTED;
#endif
            pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBufferLength 
                = 0; 
            replyPacketSize = (ULONG)FIELD_OFFSET(
                    RDPDR_IOCOMPLETION_PACKET, 
                    IoCompletion.Parameters.DeviceIoControl.OutputBuffer);
#ifndef OS_WINCE
        }
#endif
    
        //
        //  Finish the response and send it.
        //
        pReplyPacket->IoCompletion.IoStatus = status;
        
        TRACERESP(pIoReq, pReplyPacket);
        ProcessObject()->GetVCMgr().ChannelWrite(pReplyPacket, replyPacketSize);
    }
    else {
        //
        //  Send the results to the server.
        //
        TRACERESP_WITHPARAMS(pIoReq, NULL, 0, status);
        DefaultIORequestMsgHandle(pIoReq, status); 
    }

    DC_END_FN();
}

void 
W32DrPRT::SerialGetStats(
    IN PRDPDR_IOREQUEST_PACKET pIoReq
    )
/*++

Routine Description:

    Handle Serial Port Get Stats Request from Server.

Arguments:

    pIoReq  -   Request packet received from server.

Return Value:

    NA
    
 --*/
{
    DC_BEGIN_FN("W32DrPRT::SerialGetStats");

    TRACEREQ(pIoReq);

    //
    //  This IOCTL is not supported by Win32 COMM functions.  What 
    //  else can we do, but pass it directly to the driver.  We should ASSERT 
    //  to find out under which circumstances this happens, however.
    //
    ASSERT(FALSE);
    DispatchIOCTLDirectlyToDriver(pIoReq);
    DC_END_FN();
}

void 
W32DrPRT::SerialClearStats(
    IN PRDPDR_IOREQUEST_PACKET pIoReq
    )
/*++

Routine Description:

    Handle Serial Port Clear Stats Request from Server.

Arguments:

    pIoReq  -   Request packet received from server.

Return Value:

    NA
    
 --*/
{
    DC_BEGIN_FN("W32DrPRT::SerialClearStats");

    TRACEREQ(pIoReq);
    
    //
    //  This IOCTL is not supported by Win32 COMM functions.  What 
    //  else can we do, but pass it directly to the driver.  We should ASSERT 
    //  to find out under which circumstances this happens, however.
    //
    ASSERT(FALSE);
    DispatchIOCTLDirectlyToDriver(pIoReq);
    DC_END_FN();
}

#ifndef OS_WINCE
BOOL
W32DrPRT::GetIniCommValues(
    LPTSTR  pName,
    LPDCB   pdcb
)
/*++

    It goes to win.ini [ports] section to get the comm (serial) port
    settings such as
    
    com1:=9600,n,8,1
    
    And build a DCB.

Code modified from 

    \\muroc\slm\proj\win\src\CORE\SPOOL32\SPOOLSS\newdll\localmon.c

--*/
{
    COMMCONFIG ccDummy;
    COMMCONFIG *pcc;
    DWORD dwSize;
    TCHAR buf[MAX_PATH];

    DC_BEGIN_FN("GetIniCommValues");

    int len = _tcslen(pName) - 1;
    BOOL ret = FALSE;
    HRESULT hr;

    hr = StringCchCopy(buf, SIZE_TCHARS(buf), pName);
    if (FAILED(hr)) {
        TRC_ERR((TB,_T("Failed to copy pName to temp buf: 0x%x"),hr));
        return FALSE;
    }
    if (buf[len] == _T(':'))
        buf[len] = 0;

    ccDummy.dwProviderSubType = PST_RS232;
    dwSize = sizeof(ccDummy);
    GetDefaultCommConfig(buf, &ccDummy, &dwSize);
    if (pcc = (COMMCONFIG *)LocalAlloc(LPTR, dwSize))
    {
        pcc->dwProviderSubType = PST_RS232;
        if (GetDefaultCommConfig(buf, pcc, &dwSize))
        {
            *pdcb = pcc->dcb;
            ret = TRUE;
        }
        LocalFree(pcc);
    }

    DC_END_FN();

    return ret;
}
#endif


VOID 
W32DrPRT::InitializeSerialPort(
    IN TCHAR *portName,
    IN HANDLE portHandle
    )
/*++

Routine Description:

    Set a serial port to its initial state.

Arguments:

    portName    - Port name.
    portHandle  - Handle to open serial port.

Return Value:

    This function always succeeds.  Subsequent operations will fail if
    the port cannot be properly initialized.
    
 --*/
{
    DCB dcb;
    COMMTIMEOUTS cto;

    DC_BEGIN_FN("W32DrPRT::InitializeSerialPort");

    //
    // Initialize serial port
    //
    if (!GetCommState(portHandle, &dcb)) {
        TRC_ERR((TB, _T("GetCommState() returns %ld"), GetLastError()));    
        goto CLEANUPANDEXIT;
    }

    if (!GetCommTimeouts(portHandle, &cto)) {
        TRC_ERR((TB, _T("GetCommTimeouts() returns %ld"), GetLastError()));
        goto CLEANUPANDEXIT;
    }

#ifndef OS_WINCE
    if (!GetIniCommValues(portName, &dcb)) {
        TRC_ERR((TB, _T("GetIniCommValues() returns %ld"), GetLastError()));
        goto CLEANUPANDEXIT;
    }
#endif

    cto.WriteTotalTimeoutConstant = WRITE_TOTAL_TIMEOUT;
    cto.ReadTotalTimeoutConstant = READ_TOTAL_TIMEOUT;
    cto.ReadIntervalTimeout = READ_INTERVAL_TIMEOUT;

    //
    //  Ignore error from following.
    //
    SetCommState(portHandle, &dcb);
    SetCommTimeouts(portHandle, &cto);
        
CLEANUPANDEXIT:
    
    DC_END_FN();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\newclient\rdpdr\w32scard.cpp ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

w32drive

Abstract:

This module defines a child of the client-side RDP
device redirection, the "w32scard" W32SCard to provide
SmartCard sub-system redirection on 32bit windows

Author:

reidk

Revision History:

--*/

#include <precom.h>

#define TRC_GROUP TRC_GROUP_NETWORK
#define TRC_FILE  "W32SCard"
#include <atrcapi.h>

#include <w32scard.h>
#include <delayimp.h>
#include "proc.h"
#include "drconfig.h"
#include "w32utl.h"
#include "utl.h"
#include "drfsfile.h"
#include "scredir.h"
#include "scioctl.h"
#include "winsmcrd.h"


#ifdef OS_WINCE

#include <wcescard.h>

#define LoadLibraryA(x) LoadLibrary(L##x)
#define pfnSCardFreeMemory(hcontext, pv)

#endif

#define _TRY_status(x)                                  \
                __try                                   \
                {                                       \
                    x;                                  \
                }                                       \
                __except(EXCEPTION_EXECUTE_HANDLER)     \
                {                                       \
                    status = STATUS_UNSUCCESSFUL;       \
                    goto ErrorReturn;                   \
                }

#define _TRY_lReturn(x)                                 \
                __try                                   \
                {                                       \
                    x;                                  \
                }                                       \
                __except(EXCEPTION_EXECUTE_HANDLER)     \
                {                                       \
                    lReturn = SCARD_E_UNEXPECTED;       \
                    goto ErrorReturn;                   \
                }

#define _TRY_2(x)   __try                               \
                {                                       \
                    x;                                  \
                }                                       \
                __except(EXCEPTION_EXECUTE_HANDLER){} // do nothing


#define SCARD_CONTEXT_LIST_ALLOC_SIZE       6
#define SCARD_THREAD_LIST_ALLOC_SIZE        6
#define SCARD_IOREQUEST_LIST_ALLOC_SIZE     6

#define ATR_COPY_SIZE                       36


void
SafeMesHandleFree(handle_t *ph)
{
    if (*ph != 0)
    {
        MesHandleFree(*ph);
        *ph = 0;
    }
}

//---------------------------------------------------------------------------------------
//
//  MIDL allocation routines
//
//---------------------------------------------------------------------------------------
void __RPC_FAR *__RPC_USER  MIDL_user_allocate(size_t size)
{
    return (HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, size));
}

void __RPC_USER  MIDL_user_free(void __RPC_FAR *pv)
{
    if (pv != NULL)
    {
        HeapFree(GetProcessHeap(), 0, pv);
    }
}


///////////////////////////////////////////////////////////////
//
//  W32SCard Methods
//
//

W32SCard::W32SCard(
    ProcObj *processObject,
    ULONG   deviceID,
    const   TCHAR *deviceName,
    const   TCHAR *devicePath) : W32DrDeviceAsync(processObject, deviceID, devicePath)
/*++

Routine Description:

    Constructor

Arguments:

    processObject   -   Associated process object.
    deviceName      -   Name of the drive.
    id              -   Device ID for the drive.
    devicePath      -   Path that can be opened by CreateFile
                        for drive.

Return Value:

    NA

--*/
{
    unsigned len;
    DWORD i;
    HRESULT hr;

    DC_BEGIN_FN("W32SCard::W32SCard");

    _deviceName = NULL;
    _pFileObj = NULL;
    _rgSCardContextList = NULL;
    _dwSCardContextListSize = 0;
    _rghThreadList = NULL;
    _dwThreadListSize = 0;
    _fInDestructor = FALSE;
    _fFlushing = FALSE;
    _hModWinscard = NULL;
    _fCritSecsInitialized = FALSE;
    _rgIORequestList = NULL;
    _dwIORequestListSize = 0;
    _fNewFailed = FALSE;

#ifndef OS_WINCE
    _hModKernel32 = NULL;
    _hStartedEvent = NULL;
    _hRegisterWaitForStartedEvent = NULL;
    _fCloseStartedEvent = FALSE;
    _fUseRegisterWaitFuncs = FALSE;
#endif

    SetDeviceProperty();

    //
    //  Initialize the critical sections.
    //
    __try
    {
        InitializeCriticalSection(&_csContextList);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        TRC_ERR((
            TB,
            _T("InitializeCriticalSection() failed - Exception Code: %lx"),
            GetExceptionCode()));

        goto InvalidObject;
    }

    __try
    {
        InitializeCriticalSection(&_csThreadList);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        TRC_ERR((
            TB,
            _T("InitializeCriticalSection() failed - Exception Code: %lx"),
            GetExceptionCode()));

        DeleteCriticalSection(&_csContextList);
        goto InvalidObject;
    }

    __try
    {
        InitializeCriticalSection(&_csWaitForStartedEvent);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        TRC_ERR((
            TB,
            _T("InitializeCriticalSection() failed - Exception Code: %lx"),
            GetExceptionCode()));

        DeleteCriticalSection(&_csContextList);
        DeleteCriticalSection(&_csThreadList);
        goto InvalidObject;
    }

    _fCritSecsInitialized = TRUE;

#ifdef OS_WINCE
    if ((gpCESCard = new CESCard()) == NULL)
    {
        TRC_ERR((TB, _T("Failed to create synchronization object") ));
        goto InvalidObject;
    }
#endif

    //
    // Load the SCard* function pointers
    //
    if (!BindToSCardFunctions())
    {
         goto InvalidObject;
    }

    //
    //  Record the drive name.
    //
    TRC_ASSERT((deviceName != NULL), (TB, _T("deviceName is NULL")));
    len = (STRLEN(deviceName) + 1);
    _deviceName = new TCHAR[len];
    if (_deviceName != NULL)
    {
        hr = StringCchCopy(_deviceName, len, deviceName);
        TRC_ASSERT(SUCCEEDED(hr),(TB,_T("Pre checked copy failed: 0x%x"), hr));
    }
    else
    {
        goto InvalidObject;
    }

    //
    // Initial allocation for context, thread, and IORequest lists
    //
    _rgSCardContextList = new SCARDCONTEXT[SCARD_CONTEXT_LIST_ALLOC_SIZE];
    _rghThreadList = new HANDLE[SCARD_THREAD_LIST_ALLOC_SIZE];
    _rgIORequestList = new PRDPDR_IOREQUEST_PACKET[SCARD_IOREQUEST_LIST_ALLOC_SIZE];
    if ((_rgSCardContextList == NULL)   ||
        (_rghThreadList == NULL)        ||
        (_rgIORequestList == NULL))
    {
        goto InvalidObject;
    }
    else
    {
        _dwSCardContextListSize = SCARD_CONTEXT_LIST_ALLOC_SIZE;
        _dwThreadListSize = SCARD_THREAD_LIST_ALLOC_SIZE;
        _dwIORequestListSize = SCARD_IOREQUEST_LIST_ALLOC_SIZE;

        memset(
            _rgSCardContextList,
            0,
            sizeof(SCARDCONTEXT) * SCARD_CONTEXT_LIST_ALLOC_SIZE);

        for (i=0; i<SCARD_THREAD_LIST_ALLOC_SIZE; i++)
        {
            _rghThreadList[i] = NULL;
        }

        for (i=0; i<SCARD_IOREQUEST_LIST_ALLOC_SIZE; i++)
        {
            _rgIORequestList[i] = NULL;
        }
    }

Return:

    DC_END_FN();
    return;

InvalidObject:

    _fNewFailed = TRUE;
    SetValid(FALSE);
    goto Return;
}


W32SCard::~W32SCard()
/*++

Routine Description:

    Destructor

Arguments:

    NA

Return Value:

    NA

--*/
{
    DC_BEGIN_FN("W32SCard::~W32SCard");

    _fInDestructor = TRUE;

#ifndef OS_WINCE
    PVOID pv;

    pv = InterlockedExchangePointer(&_hRegisterWaitForStartedEvent, NULL);
    if (pv != NULL)
    {
        pfnUnregisterWaitEx(pv, INVALID_HANDLE_VALUE);
    }
#endif

    if (IsValid())
    {
        FlushIRPs();
    }

    if (_deviceName != NULL)
    {
        delete[]_deviceName;
    }

    if (_pFileObj != NULL)
    {
        _pFileObj->Release();
    }

    if (_rgSCardContextList != NULL)
    {
        delete[]_rgSCardContextList;
    }

    if (_rghThreadList != NULL)
    {
        delete[]_rghThreadList;
    }

    if (_rgIORequestList != NULL)
    {
        delete[]_rgIORequestList;
    }

    if (_hModWinscard != NULL)
    {
        FreeLibrary(_hModWinscard);
    }

#ifndef OS_WINCE
    if (_hModKernel32 != NULL)
    {
        FreeLibrary(_hModKernel32);
    }

    if (_hStartedEvent != NULL)
    {
        ReleaseStartedEvent();;
    }
#endif

    if (_fCritSecsInitialized)
    {
        DeleteCriticalSection(&_csContextList);
        DeleteCriticalSection(&_csThreadList);
        DeleteCriticalSection(&_csWaitForStartedEvent);
    }

#ifdef OS_WINCE
    delete gpCESCard;
#endif

    DC_END_FN();
}

#ifndef OS_WINCE
extern LPCSTR g_szTscControlName;
#else
extern LPCWSTR g_szTscControlName;
#endif

HMODULE
W32SCard::AddRefCurrentModule()
{
#ifndef OS_WINCE
    return (LoadLibraryA(g_szTscControlName));
#else
    return LoadLibrary(g_szTscControlName);
#endif
}


VOID
W32SCard::FlushIRPs()
{
    DC_BEGIN_FN("W32SCard::FlushIRPs");

    DWORD   i, j;
    DWORD   dwNumThreads    = 0;
    HANDLE  *rgHandles      = NULL;

    _fFlushing = TRUE;

    EnterCriticalSection(&_csContextList);
    EnterCriticalSection(&_csThreadList);

    //
    // Clean up any oustanding threads that are blocked
    //
    if ((_rgSCardContextList != NULL) && (_rghThreadList != NULL))
    {
        //
        // Count number of blocked threads
        //
        dwNumThreads = 0;
        for (i=0; i<_dwThreadListSize; i++)
        {
            if (_rghThreadList[i] != NULL)
            {
                dwNumThreads++;
            }
        }

        //
        // Build an array of thread handles to wait for
        //
#ifdef OS_WINCE
      if (dwNumThreads > 0)
#endif
        rgHandles = new HANDLE[dwNumThreads];
        if (rgHandles != NULL)
        {
            dwNumThreads = 0;
            for (i=0; i<_dwThreadListSize; i++)
            {
                if (_rghThreadList[i] != NULL)
                {
#ifndef OS_WINCE
                    if (!DuplicateHandle(
                            GetCurrentProcess(),
                            _rghThreadList[i],
                            GetCurrentProcess(),
                            &(rgHandles[dwNumThreads]),
                            0,
                            FALSE,
                            DUPLICATE_SAME_ACCESS))
                    {
                        TRC_ERR((TB, _T("DuplicateHandle failed.")));

                        //
                        // Nothing we can do... just clean up the already
                        // duplicated handles
                        //
                        for (j=0; j<dwNumThreads; j++)
                        {
                            CloseHandle(rgHandles[j]);
                        }

                        //
                        // Setting dwNumThread to 0 will cause no wait
                        //
                        dwNumThreads = 0;

                        break;
                    }
#else   //CE does not support DuplicateHandle for threads
                    rgHandles[dwNumThreads] = _rghThreadList[i];
#endif

                    dwNumThreads++;
                }
            }
        }
        else
        {
            TRC_ERR((TB, _T("new failed.")));
        }

        //
        // Cancel any outstanding calls
        //
        for (i=0; i<_dwSCardContextListSize; i++)
        {
            if (_rgSCardContextList[i] != NULL)
            {
                pfnSCardCancel(_rgSCardContextList[i]);
            }
        }
    }

    LeaveCriticalSection(&_csContextList);
    LeaveCriticalSection(&_csThreadList);

    //
    // Do the wait
    //
    if (dwNumThreads > 0)
    {
#ifndef OS_WINCE
        if (WaitForMultipleObjects(
                dwNumThreads,
                rgHandles,
                TRUE,
                INFINITE) == WAIT_TIMEOUT)
        {
            TRC_ERR((TB, _T("WaitForMultipleObjects timed out")));
        }
#else
        //CE does not support waiting for all at once
        for (j=0; j<dwNumThreads; j++)
        {
            DWORD dwWait = WaitForSingleObject(rgHandles[j], 30 * 1000);
            if (dwWait != WAIT_OBJECT_0)
            {
                TRC_ERR((TB, _T("WaitForSingleObject 0x%08x returned 0x%08x. GLE=%d(0x%08x)"), rgHandles[j], dwWait, GetLastError(), GetLastError()));
            }
        }
#endif
    }

    //
    // Close the duplicate handles
    //
    for (i=0; i<dwNumThreads; i++)
    {
        CloseHandle(rgHandles[i]);
    }

#ifdef OS_WINCE
    gpCESCard->FlushIRPs();
#endif

    if (rgHandles != NULL)
    {
        delete[]rgHandles;
    }

    _fFlushing = FALSE;

    DC_END_FN();
}


DWORD
W32SCard::Enumerate(
    IN ProcObj *procObj,
    IN DrDeviceMgr *deviceMgr
)
/*++

Routine Description:

    Enumerate devices of this type by adding appropriate device
    instances to the device manager.

Arguments:

    procObj     -   Corresponding process object.
    deviceMgr   -   Device manager to add devices to.

Return Value:

    ERROR_SUCCESS on success.  Otherwise, an error code is returned.

--*/
{
    W32SCard        *pScardDeviceObj    = NULL;
    RDPDR_VERSION   serverVer;
    DrFile          *pFileObj           = NULL;
    OSVERSIONINFOA  osVersion;

    DC_BEGIN_FN("W32SCard::Enumerate");

    //
    // Make sure we are on an OS that we support
    //
    memset(&osVersion, 0x00, sizeof(osVersion));
    osVersion.dwOSVersionInfoSize    = sizeof(osVersion);
    if (!GetVersionExA(&osVersion))
    {
        TRC_ERR((TB, _T("GetVersionEx() failed")));
        return ERROR_SUCCESS; // don't blcok anything else from running
    }

    if (osVersion.dwMajorVersion < 5)
    {
        TRC_DBG((TB,_T("SmartCard redirection does not work on platforms below Win2k, bailing out")));
        return ERROR_SUCCESS;
    }

    if(!procObj->GetVCMgr().GetInitData()->fEnableSCardRedirection)
    {
        TRC_DBG((TB,_T("SmartCard redirection disabled, bailing out")));
        return ERROR_SUCCESS;
    }

    serverVer = procObj->serverVersion();

    //
    //  If the server doesn't support scard device redirection,
    //  then don't bother enumerate the scard device, simply
    //  return success
    //
    if (COMPARE_VERSION(serverVer.Minor, serverVer.Major,
                        RDPDR_MINOR_VERSION, RDPDR_MAJOR_VERSION) < 0)
    {
        TRC_NRM((TB, _T("Skipping scard device enumeration")));
        return ERROR_SUCCESS;
    }


    //
    // Create the scard device object
    //
    pScardDeviceObj = new W32SCard(
                                procObj,
                                deviceMgr->GetUniqueObjectID(),
                                SZ_SCARD_DEVICE_NAME,
                                SZ_SCARD_DEVICE_NAME);

    if (pScardDeviceObj == NULL)
    {
        TRC_ERR((TB, _T("new W32SCard() failed")));
    }
    else
    {
        if (!(pScardDeviceObj->_fNewFailed)) 
        {
            pScardDeviceObj->Initialize();
        }
        
        if (!pScardDeviceObj->IsValid())
        {
            TRC_ERR((TB, _T("new W32SCard object is not valid")));
            delete (pScardDeviceObj);
            pScardDeviceObj = NULL;
        }
        else
        {
            //
            // Create the single file object to be used for the Scard device object
            //
            // BTW, we can use INVALID_HANDLE_VALUE as the actual file handle since
            // we don't really use the DrFile object except for the FileId
            //
            pScardDeviceObj->_pFileObj = new DrFile(
                                                pScardDeviceObj,
                                                DR_SMARTCARD_FILEID,
                                                INVALID_HANDLE_VALUE);
            if (pScardDeviceObj->_pFileObj == NULL)
            {
                TRC_ERR((TB, _T("new DrFile() failed")));
                delete (pScardDeviceObj);
                pScardDeviceObj = NULL;
            }
            else
            {
                pScardDeviceObj->_pFileObj->AddRef();

                //
                // Add the Scard device to the device manager
                //
                if (deviceMgr->AddObject(pScardDeviceObj) != STATUS_SUCCESS)
                {
                    TRC_ERR((TB, _T("deviceMgr->AddObject() failed")));
                    delete (pScardDeviceObj);
                    pScardDeviceObj = NULL;
                }
            }
        }
    }

    DC_END_FN();

    return ERROR_SUCCESS;
}

ULONG
W32SCard::GetDevAnnounceDataSize()
/*++

Routine Description:

    Return the size (in bytes) of a device announce packet for
    this device.

Arguments:

    NA

Return Value:

    The size (in bytes) of a device announce packet for this device.

--*/
{
    ULONG size = 0;

    DC_BEGIN_FN("W32SCard::GetDevAnnounceDataSize");

    TRC_ASSERT((IsValid()), (TB, _T("Invalid W32SCard object")));
    if (!IsValid()) { return 0; }

    size = 0;

    //
    //  Add the base announce size.
    //
    size += sizeof(RDPDR_DEVICE_ANNOUNCE);

    DC_END_FN();

    return size;
}

VOID W32SCard::GetDevAnnounceData(
    IN PRDPDR_DEVICE_ANNOUNCE pDeviceAnnounce
)
/*++

Routine Description:

    Add a device announce packet for this device to the input buffer.

Arguments:

    pDeviceAnnounce -   Device Announce Buf for this Device

Return Value:

    NA

--*/
{
    DC_BEGIN_FN("W32SCard::GetDevAnnounceData");

    TRC_ASSERT((IsValid()), (TB, _T("Invalid W32SCcard object")));
    if (!IsValid()) {
        DC_END_FN();
        return;
    }

    pDeviceAnnounce->DeviceId = GetID();
    pDeviceAnnounce->DeviceType = GetDeviceType();
    pDeviceAnnounce->DeviceDataLength = 0;

    //
    //  Record the device name in ANSI.
    //

#ifdef UNICODE
    RDPConvertToAnsi(_deviceName, (LPSTR) pDeviceAnnounce->PreferredDosName,
                  sizeof(pDeviceAnnounce->PreferredDosName)
                  );
#else
    STRNCPY((char *)pDeviceAnnounce->PreferredDosName, _deviceName, PREFERRED_DOS_NAME_SIZE);
    pDeviceAnnounce->PreferredDosName[PREFERRED_DOS_NAME_SIZE - 1] = '\0';
#endif

    DC_END_FN();
}


//---------------------------------------------------------------------------------------
//
// These methods implement a list that is used for tracking all open SCardContexts,
// so that if we get disconnected with an open SCardContext that has blocked calls,
// we can call SCardCancel to get the threads back before the W32SCard object is
// fully deleted
//
//---------------------------------------------------------------------------------------
BOOL
W32SCard::AddSCardContextToList(
    SCARDCONTEXT SCardContext)
{
    DC_BEGIN_FN("W32SCard::AddSCardContextToList");

    DWORD           i           = 0;
    DWORD           dwOpenSlot  = 0xffffffff;
    SCARDCONTEXT    *pTemp      = NULL;
    BOOL            fRet        = TRUE;

    EnterCriticalSection(&_csContextList);

    //
    // See if there is already an entry for this context,
    // and keep track of the LAST open slot in case there isn't
    //
    for (i=0; i<_dwSCardContextListSize; i++)
    {
        if (_rgSCardContextList[i] == SCardContext)
        {
            //
            // already exists
            //
            goto Return;
        }
        else if (_rgSCardContextList[i] == NULL)
        {
            dwOpenSlot = i;
        }
    }

    //
    // check to see if an open slot was found
    //
    if (dwOpenSlot != 0xffffffff)
    {
        //
        // found
        //
        _rgSCardContextList[dwOpenSlot] = SCardContext;
    }
    else
    {
        //
        // need to allocate more space
        //
        pTemp = new SCARDCONTEXT[   _dwSCardContextListSize +
                                    SCARD_CONTEXT_LIST_ALLOC_SIZE];
        if (pTemp == NULL)
        {
            TRC_ERR((TB, _T("new failed")));
            fRet = FALSE;
            LeaveCriticalSection(&_csContextList);
            goto Return;
        }

        memset(
            pTemp,
            0,
            sizeof(SCARDCONTEXT) *
                (_dwSCardContextListSize + SCARD_CONTEXT_LIST_ALLOC_SIZE));

        //
        // populate newly allocated array with all current entries
        //
        for (i=0; i<_dwSCardContextListSize; i++)
        {
            pTemp[i] = _rgSCardContextList[i];
        }

        //
        // add the new entry
        //
        pTemp[_dwSCardContextListSize] = SCardContext;

        //
        // free old list
        //
        delete[]_rgSCardContextList;

        //
        // reset member pointer and size
        //
        _rgSCardContextList = pTemp;
        _dwSCardContextListSize += SCARD_CONTEXT_LIST_ALLOC_SIZE;
    }

    LeaveCriticalSection(&_csContextList);

Return:

    DC_END_FN();

    return (fRet);
}


void
W32SCard::RemoveSCardContextFromList(
    SCARDCONTEXT SCardContext)
{
    DC_BEGIN_FN("W32SCard::RemoveSCardContextFromList");

    DWORD   i = 0;

    EnterCriticalSection(&_csContextList);

    while (i < _dwSCardContextListSize)
    {
        if (_rgSCardContextList[i] == SCardContext)
        {
            pfnSCardCancel(_rgSCardContextList[i]);
            _rgSCardContextList[i] = NULL;
            break;
        }

        i++;
    }

    LeaveCriticalSection(&_csContextList);

Return:

    DC_END_FN();
}


//---------------------------------------------------------------------------------------
//
// These methods implement a list that is used for tracking all threads that are
// currently operating on a SCard* call.  The list is used during the W32SCard object
// destructor to wait on all the threads to return before allowing the object to be
// completely deleted.
//
//---------------------------------------------------------------------------------------

BOOL
W32SCard::AddThreadToList(HANDLE hThread)
{
    DC_BEGIN_FN("W32SCard::AddThreadToList");

    DWORD   i           = 0;
    HANDLE  *rghTemp    = NULL;
    BOOL    fRet        = TRUE;
    DWORD   dwNewSize   = 0;

    EnterCriticalSection(&_csThreadList);

    //
    // Search for an open slot
    //
    while (i < _dwThreadListSize)
    {
        if (_rghThreadList[i] == NULL)
        {
            //
            // open slot found
            //
            break;
        }

        i++;
    }

    //
    // check to see if an open slot was found
    //
    if (i < _dwThreadListSize)
    {
        //
        // found
        //
        _rghThreadList[i] = hThread;
    }
    else
    {
        //
        // need to allocate more space
        //
        dwNewSize = _dwThreadListSize + SCARD_THREAD_LIST_ALLOC_SIZE;
        rghTemp = new HANDLE[dwNewSize];
        if (rghTemp == NULL)
        {
            TRC_ERR((TB, _T("new failed")));
            fRet = FALSE;
            LeaveCriticalSection(&_csThreadList);
            goto Return;
        }

        //
        // populate newly allocated array with all current thread handles
        //
        for (i=0; i<_dwThreadListSize; i++)
        {
            rghTemp[i] = _rghThreadList[i];
        }

        //
        // Initialize new entries
        //
        for (i=_dwThreadListSize; i<dwNewSize; i++)
        {
            rghTemp[i] = NULL;
        }

        //
        // add the new entry
        //
        rghTemp[_dwThreadListSize] = hThread;

        //
        // free old list
        //
        delete[]_rghThreadList;

        //
        // reset member pointer and size
        //
        _rghThreadList = rghTemp;
        _dwThreadListSize += SCARD_THREAD_LIST_ALLOC_SIZE;
    }

    LeaveCriticalSection(&_csThreadList);

Return:

    DC_END_FN();

    return (fRet);
}


void
W32SCard::RemoveThreadFromList(HANDLE hThread)
{
    DC_BEGIN_FN("W32SCard::RemoveThreadFromList");

    DWORD   i = 0;

    EnterCriticalSection(&_csThreadList);

    while (i < _dwThreadListSize)
    {
        if (_rghThreadList[i] == hThread)
        {
            CloseHandle(_rghThreadList[i]);
            _rghThreadList[i] = NULL;

            break;
        }

        i++;
    }

    LeaveCriticalSection(&_csThreadList);

Return:

    DC_END_FN();
}


//---------------------------------------------------------------------------------------
//
// This method implements a list that is used for tracking IORequests waiting for the
// started event
//
//---------------------------------------------------------------------------------------

BOOL
W32SCard::AddIORequestToList(
    PRDPDR_IOREQUEST_PACKET pIoRequestPacket)
{
    DC_BEGIN_FN("W32SCard::AddIORequestToList");

    DWORD                   i           = 0;
    PRDPDR_IOREQUEST_PACKET *rghTemp    = NULL;
    BOOL                    fRet        = TRUE;
    DWORD                   dwNewSize   = 0;

    //
    // Only called in one place, which is wrapped in a CritSec, so no need for one here
    //

    //
    // Search for an open slot
    //
    while (i < _dwIORequestListSize)
    {
        if (_rgIORequestList[i] == NULL)
        {
            //
            // open slot found
            //
            break;
        }

        i++;
    }

    //
    // check to see if an open slot was found
    //
    if (i < _dwIORequestListSize)
    {
        //
        // found
        //
        _rgIORequestList[i] = pIoRequestPacket;
    }
    else
    {
        //
        // need to allocate more space
        //
        dwNewSize = _dwIORequestListSize + SCARD_IOREQUEST_LIST_ALLOC_SIZE;
        rghTemp = new PRDPDR_IOREQUEST_PACKET[dwNewSize];
        if (rghTemp == NULL)
        {
            TRC_ERR((TB, _T("new failed")));
            fRet = FALSE;
            goto Return;
        }

        //
        // populate newly allocated array with all current IoRequests
        //
        for (i=0; i<_dwIORequestListSize; i++)
        {
            rghTemp[i] = _rgIORequestList[i];
        }

        //
        // Initialize new entries
        //
        for (i=_dwIORequestListSize; i<dwNewSize; i++)
        {
            rghTemp[i] = NULL;
        }

        //
        // add the new entry
        //
        rghTemp[_dwIORequestListSize] = pIoRequestPacket;

        //
        // free old list
        //
        delete[]_rgIORequestList;

        //
        // reset member pointer and size
        //
        _rgIORequestList = rghTemp;
        _dwIORequestListSize += SCARD_IOREQUEST_LIST_ALLOC_SIZE;
    }

Return:

    DC_END_FN();

    return (fRet);
}




DWORD WINAPI
W32SCard::SCardHandleCall_ThreadProc(
    LPVOID lpParameter)
{
    DC_BEGIN_FN("W32SCard::SCardHandleCall_ThreadProc");

    LONG                    lReturn             = SCARD_S_SUCCESS;
    SCARDHANDLECALLSTRUCT   *pStruct            = (SCARDHANDLECALLSTRUCT *) lpParameter;
    W32SCard                *pTHIS              = pStruct->pTHIS;
    HANDLE                  hThread             = pStruct->hThread;
    HMODULE                 hModExtraRefCount   = pStruct->hModExtraRefCount;

    pStruct = (SCARDHANDLECALLSTRUCT *) lpParameter;

    //
    // pStruct->hThread will be NULL if it wasn't added to the thread list...
    // it wasn't added to the thread list then just get out.
    //
    if (pStruct->hThread == NULL)
    {
        FreeLibraryAndExitThread(pStruct->hModExtraRefCount, 0);
    }

    switch (pStruct->dwCallType)
    {
    case SCARD_IOCTL_CONNECTA:
        TRC_DBG((TB, _T("SCARD_IOCTL_CONNECTA")));
        pTHIS->Connect(
                    pStruct,
                    SCARD_IOCTL_CONNECTA);
        break;

    case SCARD_IOCTL_CONNECTW:
        TRC_DBG((TB, _T("SCARD_IOCTL_CONNECTW")));
        pTHIS->Connect(
                    pStruct,
                    SCARD_IOCTL_CONNECTW);
        break;

    case SCARD_IOCTL_RECONNECT:
        TRC_DBG((TB, _T("SCARD_IOCTL_RECONNECT")));
        pTHIS->Reconnect(
                    pStruct);
        break;

    case SCARD_IOCTL_DISCONNECT:
        TRC_DBG((TB, _T("SCARD_IOCTL_DISCONNECT")));
        pTHIS->HandleHCardAndDispositionCall(
                    pStruct,
                    SCARD_IOCTL_DISCONNECT);
        break;

    case SCARD_IOCTL_BEGINTRANSACTION:
        TRC_DBG((TB, _T("SCARD_IOCTL_BEGINTRANSACTION")));
        pTHIS->HandleHCardAndDispositionCall(
                    pStruct,
                    SCARD_IOCTL_BEGINTRANSACTION);
        break;

    case SCARD_IOCTL_ENDTRANSACTION:
        TRC_DBG((TB, _T("SCARD_IOCTL_ENDTRANSACTION")));
        pTHIS->HandleHCardAndDispositionCall(
                    pStruct,
                    SCARD_IOCTL_ENDTRANSACTION);
        break;

#ifndef OS_WINCE
    case SCARD_IOCTL_STATE:
        TRC_DBG((TB, _T("SCARD_IOCTL_STATE")));
        pTHIS->State(
                    pStruct);
        break;
#endif

    case SCARD_IOCTL_STATUSA:
        TRC_DBG((TB, _T("SCARD_IOCTL_STATUSA")));
        pTHIS->Status(
                    pStruct,
                    SCARD_IOCTL_STATUSA);
        break;

    case SCARD_IOCTL_STATUSW:
        TRC_DBG((TB, _T("SCARD_IOCTL_STATUSW")));
        pTHIS->Status(
                    pStruct,
                    SCARD_IOCTL_STATUSW);
        break;

    case SCARD_IOCTL_TRANSMIT:
        TRC_DBG((TB, _T("SCARD_IOCTL_TRANSMIT")));
        pTHIS->Transmit(
                    pStruct);
        break;

    case SCARD_IOCTL_CONTROL:
        TRC_DBG((TB, _T("SCARD_IOCTL_CONTROL")));
        pTHIS->Control(
                    pStruct);

        break;

    case SCARD_IOCTL_GETATTRIB:
        TRC_DBG((TB, _T("SCARD_IOCTL_GETATTRIB")));
        pTHIS->GetAttrib(
                    pStruct);
        break;

    case SCARD_IOCTL_SETATTRIB:
        TRC_DBG((TB, _T("SCARD_IOCTL_SETATTRIB")));
        pTHIS->SetAttrib(
                    pStruct);
        break;
    }
#if defined (OS_WINCE) && defined(DEBUG)
    PRDPDR_DEVICE_IOREQUEST pIoRequest = &(pStruct->pIoRequestPacket->IoRequest);
    TRC_DATA_DBG("Input buffer",(char *) (pIoRequest + 1),  pIoRequest->Parameters.DeviceIoControl.InputBufferLength);
#endif

    pTHIS->RemoveThreadFromList(hThread);
    FreeLibraryAndExitThread(hModExtraRefCount, 0);
    DC_END_FN();
#ifdef OS_WINCE
    return 0;
#endif
}


VOID
W32SCard::DefaultIORequestMsgHandleWrapper(
   IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
   IN NTSTATUS serverReturnStatus
   )
{
    if (!_fInDestructor && !_fFlushing)
    {
        DefaultIORequestMsgHandle(pIoRequestPacket, serverReturnStatus);
    }
    else
    {
        //
        // Just drop it on the floor if we are shutting down or flushing
        //
        delete(pIoRequestPacket);
    }
}


VOID
W32SCard::MsgIrpDeviceControl(
    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
    IN UINT32 packetLen
    )
/*++

Routine Description:

    Handle a file system control request from the server.

Arguments:

    pIoRequestPacket    -   Server IO request packet.
    packetLen           -   Length of the packet

Return Value:

    NA

--*/
{
    DC_BEGIN_FN("W32SCard::MsgIrpDeviceControl");

    PRDPDR_DEVICE_IOREQUEST pIoRequest          = &(pIoRequestPacket->IoRequest);
    HMODULE                 hModExtraRefCount   = NULL;
    SCARDHANDLECALLSTRUCT   *pStruct            = NULL;
    HANDLE                  hThread;
    DWORD                   dwThreadId;

    if (!pIoRequest->Parameters.DeviceIoControl.InputBufferLength)
    {
        // no data, get out
        return;
    }

    switch(pIoRequest->Parameters.DeviceIoControl.IoControlCode)
    {
    case SCARD_IOCTL_ESTABLISHCONTEXT:
        TRC_DBG((TB, _T("SCARD_IOCTL_ESTABLISHCONTEXT")));
        EstablishContext(pIoRequestPacket);
        break;

    case SCARD_IOCTL_RELEASECONTEXT:
        TRC_DBG((TB, _T("SCARD_IOCTL_RELEASECONTEXT")));
        HandleContextCallWithLongReturn(
                    pIoRequestPacket,
                    SCARD_IOCTL_RELEASECONTEXT);
        break;

    case SCARD_IOCTL_ISVALIDCONTEXT:
        TRC_DBG((TB, _T("SCARD_IOCTL_ISVALIDCONTEXT")));
        HandleContextCallWithLongReturn(
                    pIoRequestPacket,
                    SCARD_IOCTL_ISVALIDCONTEXT);
        break;

    case SCARD_IOCTL_LISTREADERGROUPSA:
        TRC_DBG((TB, _T("SCARD_IOCTL_LISTREADERGROUPSA")));
        ListReaderGroups(
                    pIoRequestPacket,
                    SCARD_IOCTL_LISTREADERGROUPSA);
        break;

    case SCARD_IOCTL_LISTREADERGROUPSW:
        TRC_DBG((TB, _T("SCARD_IOCTL_LISTREADERGROUPSW")));
        ListReaderGroups(
                    pIoRequestPacket,
                    SCARD_IOCTL_LISTREADERGROUPSW);
        break;

    case SCARD_IOCTL_LISTREADERSA:
        TRC_DBG((TB, _T("SCARD_IOCTL_LISTREADERSA")));
        ListReaders(
                    pIoRequestPacket,
                    SCARD_IOCTL_LISTREADERSA);
        break;

    case SCARD_IOCTL_LISTREADERSW:
        TRC_DBG((TB, _T("SCARD_IOCTL_LISTREADERSW")));
        ListReaders(
                    pIoRequestPacket,
                    SCARD_IOCTL_LISTREADERSW);
        break;

    case SCARD_IOCTL_INTRODUCEREADERGROUPA:
        TRC_DBG((TB, _T("SCARD_IOCTL_INTRODUCEREADERGROUPA")));
        HandleContextAndStringCallWithLongReturn(
                    pIoRequestPacket,
                    SCARD_IOCTL_INTRODUCEREADERGROUPA);
        break;

    case SCARD_IOCTL_INTRODUCEREADERGROUPW:
        TRC_DBG((TB, _T("SCARD_IOCTL_INTRODUCEREADERGROUPW")));
        HandleContextAndStringCallWithLongReturn(
                    pIoRequestPacket,
                    SCARD_IOCTL_INTRODUCEREADERGROUPW);
        break;

    case SCARD_IOCTL_FORGETREADERGROUPA:
        TRC_DBG((TB, _T("SCARD_IOCTL_FORGETREADERGROUPA")));
        HandleContextAndStringCallWithLongReturn(
                    pIoRequestPacket,
                    SCARD_IOCTL_FORGETREADERGROUPA);
        break;

    case SCARD_IOCTL_FORGETREADERGROUPW:
        TRC_DBG((TB, _T("SCARD_IOCTL_FORGETREADERGROUPW")));
        HandleContextAndStringCallWithLongReturn(
                    pIoRequestPacket,
                    SCARD_IOCTL_FORGETREADERGROUPW);
        break;

    case SCARD_IOCTL_INTRODUCEREADERA:
        TRC_DBG((TB, _T("SCARD_IOCTL_INTRODUCEREADERA")));
        HandleContextAndTwoStringCallWithLongReturn(
                    pIoRequestPacket,
                    SCARD_IOCTL_INTRODUCEREADERA);
        break;

    case SCARD_IOCTL_INTRODUCEREADERW:
        TRC_DBG((TB, _T("SCARD_IOCTL_INTRODUCEREADERW")));
        HandleContextAndTwoStringCallWithLongReturn(
                    pIoRequestPacket,
                    SCARD_IOCTL_INTRODUCEREADERW);
        break;

    case SCARD_IOCTL_FORGETREADERA:
        TRC_DBG((TB, _T("SCARD_IOCTL_FORGETREADERA")));
        HandleContextAndStringCallWithLongReturn(
                    pIoRequestPacket,
                    SCARD_IOCTL_FORGETREADERA);
        break;

    case SCARD_IOCTL_FORGETREADERW:
        TRC_DBG((TB, _T("SCARD_IOCTL_FORGETREADERW")));
        HandleContextAndStringCallWithLongReturn(
                    pIoRequestPacket,
                    SCARD_IOCTL_FORGETREADERW);
        break;

    case SCARD_IOCTL_ADDREADERTOGROUPA:
        TRC_DBG((TB, _T("SCARD_IOCTL_ADDREADERTOGROUPA")));
        HandleContextAndTwoStringCallWithLongReturn(
                    pIoRequestPacket,
                    SCARD_IOCTL_ADDREADERTOGROUPA);
        break;

    case SCARD_IOCTL_ADDREADERTOGROUPW:
        TRC_DBG((TB, _T("SCARD_IOCTL_ADDREADERTOGROUPW")));
        HandleContextAndTwoStringCallWithLongReturn(
                    pIoRequestPacket,
                    SCARD_IOCTL_ADDREADERTOGROUPW);
        break;

    case SCARD_IOCTL_REMOVEREADERFROMGROUPA:
        TRC_DBG((TB, _T("SCARD_IOCTL_REMOVEREADERFROMGROUPA")));
        HandleContextAndTwoStringCallWithLongReturn(
                    pIoRequestPacket,
                    SCARD_IOCTL_REMOVEREADERFROMGROUPA);
        break;

    case SCARD_IOCTL_REMOVEREADERFROMGROUPW:
        TRC_DBG((TB, _T("SCARD_IOCTL_REMOVEREADERFROMGROUPW")));
        HandleContextAndTwoStringCallWithLongReturn(
                    pIoRequestPacket,
                    SCARD_IOCTL_REMOVEREADERFROMGROUPW);
        break;

    case SCARD_IOCTL_LOCATECARDSA:
        TRC_DBG((TB, _T("SCARD_IOCTL_LOCATECARDSA")));
        LocateCardsA(pIoRequestPacket);
        break;

    case SCARD_IOCTL_LOCATECARDSW:
        TRC_DBG((TB, _T("SCARD_IOCTL_LOCATECARDSW")));
        LocateCardsW(pIoRequestPacket);
        break;

    case SCARD_IOCTL_LOCATECARDSBYATRA:
        TRC_DBG((TB, _T("SCARD_IOCTL_LOCATECARDSBYATRA")));
        LocateCardsByATRA(pIoRequestPacket);
        break;

    case SCARD_IOCTL_LOCATECARDSBYATRW:
        TRC_DBG((TB, _T("SCARD_IOCTL_LOCATECARDSBYATRW")));
        LocateCardsByATRW(pIoRequestPacket);
        break;

    case SCARD_IOCTL_GETSTATUSCHANGEA:
        TRC_DBG((TB, _T("SCARD_IOCTL_GETSTATUSCHANGEA")));
        GetStatusChangeWrapper(
                    pIoRequestPacket,
                    SCARD_IOCTL_GETSTATUSCHANGEA);
        break;

    case SCARD_IOCTL_GETSTATUSCHANGEW:
        TRC_DBG((TB, _T("SCARD_IOCTL_GETSTATUSCHANGEW")));
        GetStatusChangeWrapper(
                    pIoRequestPacket,
                    SCARD_IOCTL_GETSTATUSCHANGEW);
        break;

    case SCARD_IOCTL_CANCEL:
        TRC_DBG((TB, _T("SCARD_IOCTL_CANCEL")));
        HandleContextCallWithLongReturn(
                    pIoRequestPacket,
                    SCARD_IOCTL_CANCEL);
        break;

    //
    // Possibly blocking calls, so create a thread to make the call
    //
    case SCARD_IOCTL_CONNECTA:
    case SCARD_IOCTL_CONNECTW:
    case SCARD_IOCTL_RECONNECT:
    case SCARD_IOCTL_DISCONNECT:
    case SCARD_IOCTL_BEGINTRANSACTION:
    case SCARD_IOCTL_ENDTRANSACTION:
#ifndef OS_WINCE
    case SCARD_IOCTL_STATE:
#endif
    case SCARD_IOCTL_STATUSA:
    case SCARD_IOCTL_STATUSW:
    case SCARD_IOCTL_TRANSMIT:
    case SCARD_IOCTL_CONTROL:
    case SCARD_IOCTL_GETATTRIB:
    case SCARD_IOCTL_SETATTRIB:

        //
        // Get a ref count on our dll so that we know the dll
        // code won't disappear from underneath us.  The thread will
        // release this ref count when it exits
        //
        hModExtraRefCount = AddRefCurrentModule();
        if (hModExtraRefCount == NULL)
        {
            TRC_ERR((TB, _T("AddRefCurrentModule() failed.")));
            goto ErrorReturn;
        }

        //
        // Allocate the struct to pass to the thread
        //
        pStruct = (SCARDHANDLECALLSTRUCT *)
                    MIDL_user_allocate(sizeof(SCARDHANDLECALLSTRUCT));
        if (pStruct == NULL)
        {
            TRC_ERR((TB, _T("MIDL_user_allocate failed to alloc %ld bytes."), sizeof(SCARDHANDLECALLSTRUCT)));
            goto ErrorReturn;
        }
        pStruct->pTHIS = this;
        pStruct->dwCallType = pIoRequest->Parameters.DeviceIoControl.IoControlCode;
        pStruct->pIoRequestPacket = pIoRequestPacket;
        pStruct->hModExtraRefCount = hModExtraRefCount;
        pStruct->hThread = NULL;

        //
        // Create a thread that will do the actual work
        //
        EnterCriticalSection(&_csThreadList);

        //
        // If the object is currently being destroyed, then don't create a new thread.
        //
        if (_fInDestructor)
        {
            LeaveCriticalSection(&_csThreadList);
            goto ErrorReturn;
        }

        hThread = CreateThread(
                        NULL,
                        0,
                        SCardHandleCall_ThreadProc,
                        pStruct,
                        CREATE_SUSPENDED,
                        &dwThreadId);
        if (hThread == NULL)
        {
            TRC_ERR((TB, _T("CreateThread failed with %lx."), GetLastError()));
            LeaveCriticalSection(&_csThreadList);
            goto ErrorReturn;
        }

        if (!AddThreadToList(hThread))
        {
            LeaveCriticalSection(&_csThreadList);
            ResumeThread(hThread);
            WaitForSingleObject(hThread, INFINITE);
            CloseHandle(hThread);

            //
            // do this so we don't do an extra FreeLibrary. (since the thread actually
            // got created the thread istself will do the FreeLibrary).
            //
            hModExtraRefCount = NULL;
            goto ErrorReturn;
        }

        LeaveCriticalSection(&_csThreadList);

        //
        // Now let the thread go
        //
        pStruct->hThread = hThread;
        ResumeThread(hThread);

        //
        // return here and let the thread we just created
        // make the EncodeAndChannelWriteLongReturn call,
        // which will send the return the calling server
        //
        break;

    case SCARD_IOCTL_ACCESSSTARTEDEVENT:
        TRC_DBG((TB, _T("SCARD_IOCTL_ACCESSSTARTEDEVENT")));
        AccessStartedEvent(
                    pIoRequestPacket);
        break;

#ifdef OS_WINCE
    default:
        TRC_ERR((TB, _T("Unsupported ioctl=0x%x(%d) function = %d"), pIoRequest->Parameters.DeviceIoControl.IoControlCode,
            pIoRequest->Parameters.DeviceIoControl.IoControlCode, ((pIoRequest->Parameters.DeviceIoControl.IoControlCode & 0x3FFC) >> 2)));
        DefaultIORequestMsgHandleWrapper(pIoRequestPacket, STATUS_NOT_SUPPORTED);
        break;
#endif
    }
#if defined(OS_WINCE) && defined(DEBUG)
    if (hModExtraRefCount != NULL)
    {
        TRC_DATA_DBG("Input buffer",(char *) (pIoRequest + 1),  pIoRequest->Parameters.DeviceIoControl.InputBufferLength);
    }
#endif

Return:

    DC_END_FN();

    return;

ErrorReturn:

    if (hModExtraRefCount != NULL)
    {
        FreeLibrary(hModExtraRefCount);
    }

    MIDL_user_free(pStruct);

    DefaultIORequestMsgHandleWrapper(pIoRequestPacket, STATUS_NO_MEMORY);

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  W32SCard::AllocateAndChannelWriteReplyPacket
//
//---------------------------------------------------------------------------------------
void
W32SCard::AllocateAndChannelWriteReplyPacket(
    IN PRDPDR_IOREQUEST_PACKET  pIoRequestPacket,
    IN char                     *pbEncodedBuffer,
    IN unsigned long            cbEncodedBuffer)
{
    DC_BEGIN_FN("W32SCard::AllocateAndChannelWriteReplyPacket");

    NTSTATUS                    status          = STATUS_SUCCESS;
    PRDPDR_IOCOMPLETION_PACKET  pReplyPacket    = NULL;
    ULONG                       replyPacketSize = 0;

    //
    // If we are deleting this object, then just get out.
    //
    if (_fInDestructor || _fFlushing)
    {
        delete(pIoRequestPacket);
        return;
    }

    //
    //  Check the size of the output buffer.
    //
    status = DrUTL_CheckIOBufOutputSize(pIoRequestPacket, cbEncodedBuffer);

    //
    //  Allocate reply buffer
    //
    if (status == STATUS_SUCCESS)
    {
        status = DrUTL_AllocateReplyBuf(
                        pIoRequestPacket,
                        &pReplyPacket,
                        &replyPacketSize);
    }

    //
    // Write reply to channel
    //
    if (status == STATUS_SUCCESS)
    {
        memcpy(
            pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBuffer,
            pbEncodedBuffer,
            cbEncodedBuffer);

        pReplyPacket->IoCompletion.Parameters.DeviceIoControl.OutputBufferLength
            = cbEncodedBuffer;

        pReplyPacket->IoCompletion.IoStatus = STATUS_SUCCESS;

        //
        // in DrUTL_AllocateReplyBuf the replyPacketSize is set to the max size
        // allowed given the calling servers output buffer size, but we just need
        // cbEncodedBuffer size.  And, we know there is enough space since the
        // DrUTL_CheckIOBufOutputSize call succeeded
        //
        replyPacketSize =   cbEncodedBuffer +
                            (ULONG)FIELD_OFFSET(RDPDR_IOCOMPLETION_PACKET,
                                IoCompletion.Parameters.DeviceIoControl.OutputBuffer);

        ProcessObject()->GetVCMgr().ChannelWrite(pReplyPacket, replyPacketSize);
    }
    else
    {
        goto ErrorReturn;
    }

    delete(pIoRequestPacket);

Return:

    DC_END_FN();

    return;

ErrorReturn:

    DefaultIORequestMsgHandleWrapper(pIoRequestPacket, status);

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  W32SCard::DecodeContextCall
//
//---------------------------------------------------------------------------------------
LONG
W32SCard::DecodeContextCall(
    IN PRDPDR_IOREQUEST_PACKET  pIoRequestPacket,
    OUT SCARDCONTEXT            *pSCardContext)
{
    DC_BEGIN_FN("W32SCard::DecodeContextCall");

    RPC_STATUS                  rpcStatus   = RPC_S_OK;
    LONG                        lReturn     = SCARD_S_SUCCESS;
    handle_t                    hDec        = 0;
    Context_Call                ContextCall;
    PRDPDR_DEVICE_IOREQUEST     pIoRequest  = &(pIoRequestPacket->IoRequest);

    //
    // Do the decode
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) (pIoRequest + 1), // bytes are at end of struct
                        pIoRequest->Parameters.DeviceIoControl.InputBufferLength,
                        &hDec);
    if (rpcStatus != RPC_S_OK)
    {
        TRC_ERR((TB, _T("MesDecodeBufferHandleCreate failed with %lx."), rpcStatus));
        lReturn = SCARD_E_NO_MEMORY;
        goto ErrorReturn;
    }

    memset(&ContextCall, 0, sizeof(ContextCall));
    _TRY_lReturn(Context_Call_Decode(hDec, &ContextCall))

    //
    // Copy the decoded context to the callers memory
    //
    if (sizeof(SCARDCONTEXT) != ContextCall.Context.cbContext)
    {
        TRC_ERR((TB, _T("Invalid context from server")));
        lReturn = SCARD_E_INVALID_PARAMETER;
        goto ErrorReturn;
    }
    *pSCardContext = *((SCARDCONTEXT *) ContextCall.Context.pbContext);

    //
    // Free the resources used for decode of parameters
    //
    _TRY_2(Context_Call_Free(hDec, &ContextCall))

Return:

    SafeMesHandleFree(&hDec);

    DC_END_FN();

    return (lReturn);

ErrorReturn:

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  W32SCard::DecodeContextAndStringCallA
//
//---------------------------------------------------------------------------------------
LONG
W32SCard::DecodeContextAndStringCallA(
    IN PRDPDR_IOREQUEST_PACKET  pIoRequestPacket,
    OUT SCARDCONTEXT            *pSCardContext,
    OUT LPSTR                   *ppsz)
{
    DC_BEGIN_FN("W32SCard::DecodeContextAndStringCallA");

    RPC_STATUS                  rpcStatus               = RPC_S_OK;
    LONG                        lReturn                 = SCARD_S_SUCCESS;
    handle_t                    hDec                    = 0;
    BOOL                        fFreeDecode             = FALSE;
    ContextAndStringA_Call      ContextAndStringCallA;
    PRDPDR_DEVICE_IOREQUEST     pIoRequest              = &(pIoRequestPacket->IoRequest);
    UINT                        cbStrLen                = 0;
    HRESULT                     hr;

    //
    // Decode input parameters
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) (pIoRequest + 1), // bytes are at end of struct
                        pIoRequest->Parameters.DeviceIoControl.InputBufferLength,
                        &hDec);
    if (rpcStatus != RPC_S_OK)
    {
        TRC_ERR((TB, _T("MesDecodeBufferHandleCreate failed with %lx."), rpcStatus));
        lReturn = SCARD_E_NO_MEMORY;
        goto ErrorReturn;
    }

    memset(&ContextAndStringCallA, 0, sizeof(ContextAndStringCallA));
    _TRY_lReturn(ContextAndStringA_Call_Decode(hDec, &ContextAndStringCallA))
    fFreeDecode = TRUE;

    //
    // Copy the contents to the callers out params
    //
    if (ContextAndStringCallA.Context.pbContext != NULL)
    {
        if (sizeof(SCARDCONTEXT) != ContextAndStringCallA.Context.cbContext)
        {
            TRC_ERR((TB, _T("Invalid context from server")));
            lReturn = SCARD_E_INVALID_PARAMETER;
            goto ErrorReturn;
        }
        *pSCardContext = *((SCARDCONTEXT *) ContextAndStringCallA.Context.pbContext);
    }
    else
    {
        *pSCardContext = NULL;
    }

    if (ContextAndStringCallA.sz == NULL)
    {
        TRC_ERR((TB, _T("Invalid string from server")));
        lReturn = SCARD_E_INVALID_VALUE;
        goto ErrorReturn;
    }
    cbStrLen = (strlen(ContextAndStringCallA.sz) + 1) * sizeof(char);

    *ppsz = (LPSTR)
        MIDL_user_allocate(cbStrLen);

    if (*ppsz == NULL)
    {
        TRC_ERR((TB, _T("MIDL_user_allocate failed")));
        lReturn = SCARD_E_NO_MEMORY;
        goto ErrorReturn;
    }

    hr = StringCbCopyA(*ppsz, cbStrLen, ContextAndStringCallA.sz);
    TRC_ASSERT(SUCCEEDED(hr),(TB,_T("Pre checked copy failed: 0x%x"), hr));

Return:

    if (fFreeDecode)
    {
        _TRY_2(ContextAndStringA_Call_Free(hDec, &ContextAndStringCallA))
    }
    SafeMesHandleFree(&hDec);

    DC_END_FN();

    return (lReturn);

ErrorReturn:

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  W32SCard::DecodeContextAndStringCallW
//
//---------------------------------------------------------------------------------------
LONG
W32SCard::DecodeContextAndStringCallW(
    IN PRDPDR_IOREQUEST_PACKET  pIoRequestPacket,
    OUT SCARDCONTEXT            *pSCardContext,
    OUT LPWSTR                  *ppwsz)
{
    DC_BEGIN_FN("W32SCard::DecodeContextAndStringCallW");

    RPC_STATUS                  rpcStatus               = RPC_S_OK;
    LONG                        lReturn                 = SCARD_S_SUCCESS;
    handle_t                    hDec                    = 0;
    BOOL                        fFreeDecode             = FALSE;
    ContextAndStringW_Call      ContextAndStringCallW;
    PRDPDR_DEVICE_IOREQUEST     pIoRequest              = &(pIoRequestPacket->IoRequest);
    UINT                        cbStrLen                = 0;
    HRESULT                     hr;

    //
    // Decode input parameters
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) (pIoRequest + 1), // bytes are at end of struct
                        pIoRequest->Parameters.DeviceIoControl.InputBufferLength,
                        &hDec);
    if (rpcStatus != RPC_S_OK)
    {
        TRC_ERR((TB, _T("MesDecodeBufferHandleCreate failed with %lx."), rpcStatus));
        lReturn = SCARD_E_NO_MEMORY;
        goto ErrorReturn;
    }

    memset(&ContextAndStringCallW, 0, sizeof(ContextAndStringCallW));
    _TRY_lReturn(ContextAndStringW_Call_Decode(hDec, &ContextAndStringCallW))
    fFreeDecode = TRUE;

    //
    // Copy the contents to the callers out params
    //
    if (ContextAndStringCallW.Context.pbContext != NULL)
    {
        if (sizeof(SCARDCONTEXT) != ContextAndStringCallW.Context.cbContext)
        {
            TRC_ERR((TB, _T("Invalid context from server")));
            lReturn = SCARD_E_INVALID_PARAMETER;
            goto ErrorReturn;
        }
        *pSCardContext = *((SCARDCONTEXT *) ContextAndStringCallW.Context.pbContext);
    }
    else
    {
        *pSCardContext = NULL;
    }

    if (ContextAndStringCallW.sz == NULL)
    {
        TRC_ERR((TB, _T("Invalid string from server")));
        lReturn = SCARD_E_INVALID_VALUE;
        goto ErrorReturn;
    }

    cbStrLen = (wcslen(ContextAndStringCallW.sz) + 1) * sizeof(WCHAR);

    *ppwsz = (LPWSTR)
        MIDL_user_allocate(cbStrLen);

    if (*ppwsz == NULL)
    {
        TRC_ERR((TB, _T("MIDL_user_allocate failed")));
        lReturn = SCARD_E_NO_MEMORY;
        goto ErrorReturn;
    }

    hr = StringCbCopyW(*ppwsz, cbStrLen, ContextAndStringCallW.sz);
    TRC_ASSERT(SUCCEEDED(hr),(TB,_T("Pre checked copy failed: 0x%x"), hr));

Return:

    if (fFreeDecode)
    {
        _TRY_2(ContextAndStringW_Call_Free(hDec, &ContextAndStringCallW))
    }
    SafeMesHandleFree(&hDec);

    DC_END_FN();

    return (lReturn);

ErrorReturn:

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  W32SCard::EncodeAndChannelWriteLongReturn
//
//---------------------------------------------------------------------------------------
void
W32SCard::EncodeAndChannelWriteLongReturn(
    IN PRDPDR_IOREQUEST_PACKET  pIoRequestPacket,
    IN LONG                     lReturn)
{
    DC_BEGIN_FN("W32SCard::EncodeAndChannelWriteLongReturn");

    RPC_STATUS      rpcStatus           = RPC_S_OK;
    NTSTATUS        status              = STATUS_SUCCESS;
    char            *pbEncodedBuffer    = NULL;
    unsigned long   cbEncodedBuffer     = 0;
    handle_t        hEnc                = 0;
    Long_Return     LongReturn;

    //
    // Initialiaze struct to be encoded
    //
    LongReturn.ReturnCode = lReturn;

    //
    // Encode the return
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer,
                        &cbEncodedBuffer,
                        &hEnc);
    if (rpcStatus != RPC_S_OK)
    {
        TRC_ERR((TB, _T("MesEncodeDynBufferHandleCreate failed with %lx."), rpcStatus));
        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    _TRY_status(Long_Return_Encode(hEnc, &LongReturn))

    //
    // Send the return
    //
    AllocateAndChannelWriteReplyPacket(
                pIoRequestPacket,
                pbEncodedBuffer,
                cbEncodedBuffer);

    Return:

    SafeMesHandleFree(&hEnc);

    MIDL_user_free(pbEncodedBuffer);

    DC_END_FN();

    return;

ErrorReturn:

    DefaultIORequestMsgHandleWrapper(pIoRequestPacket, status);

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  W32SCard::EstablishContext
//
//---------------------------------------------------------------------------------------
void
W32SCard::EstablishContext(
    IN PRDPDR_IOREQUEST_PACKET  pIoRequestPacket)
{
    DC_BEGIN_FN("W32SCard::EstablishContext");

    RPC_STATUS                  rpcStatus               = RPC_S_OK;
    NTSTATUS                    status                  = STATUS_SUCCESS;
    char                        *pbEncodedBuffer        = NULL;
    unsigned long               cbEncodedBuffer         = 0;
    PRDPDR_IOCOMPLETION_PACKET  pReplyPacket            = NULL;
    ULONG                       replyPacketSize         = 0;
    handle_t                    hDec                    = 0;
    handle_t                    hEnc                    = 0;
    BOOL                        fFreeDecode             = FALSE;
    BOOL                        fFreeContext            = FALSE;
    EstablishContext_Call       EstablishContextCall;
    EstablishContext_Return     EstablishContextReturn;
#ifndef OS_WINCE
    DWORD                       dwScope;
#endif
    SCARDCONTEXT                SCardContext;
    PRDPDR_DEVICE_IOREQUEST     pIoRequest              = &(pIoRequestPacket->IoRequest);

    //
    // Decode parameters
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) (pIoRequest + 1), // bytes are at end of struct
                        pIoRequest->Parameters.DeviceIoControl.InputBufferLength,
                        &hDec);
    if (rpcStatus != RPC_S_OK)
    {
        TRC_ERR((TB, _T("MesDecodeBufferHandleCreate failed with %lx."), rpcStatus));
        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    memset(&EstablishContextCall, 0, sizeof(EstablishContextCall));
    _TRY_status(EstablishContext_Call_Decode(hDec, &EstablishContextCall))
    fFreeDecode = TRUE;

    //
    // Make the call to the SCard subsystem
    //
    memset(&EstablishContextReturn, 0, sizeof(EstablishContextReturn));
    EstablishContextReturn.ReturnCode =
        pfnSCardEstablishContext(
                EstablishContextCall.dwScope,
                NULL,
                NULL,
                &SCardContext);

    if (EstablishContextReturn.ReturnCode == SCARD_S_SUCCESS)
    {
        EstablishContextReturn.Context.pbContext = (BYTE *) &SCardContext;
        EstablishContextReturn.Context.cbContext = sizeof(SCARDCONTEXT);
        fFreeContext = TRUE;
    }

    //
    // Encode the return
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer,
                        &cbEncodedBuffer,
                        &hEnc);
    if (rpcStatus != RPC_S_OK)
    {
        TRC_ERR((TB, _T("MesEncodeDynBufferHandleCreate failed with %lx."), rpcStatus));
        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    _TRY_status(EstablishContext_Return_Encode(hEnc, &EstablishContextReturn))

    //
    // Add the new context to the list before returing to caller
    //
    if (!AddSCardContextToList(SCardContext))
    {
        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    AllocateAndChannelWriteReplyPacket(
                pIoRequestPacket,
                pbEncodedBuffer,
                cbEncodedBuffer);

Return:

    if (fFreeDecode)
    {
        _TRY_2(EstablishContext_Call_Free(hDec, &EstablishContextCall))
    }
    SafeMesHandleFree(&hDec);

    SafeMesHandleFree(&hEnc);

    MIDL_user_free(pbEncodedBuffer);

    DC_END_FN();

    return;

ErrorReturn:

    if (fFreeContext)
    {
        pfnSCardReleaseContext(SCardContext);
    }

    DefaultIORequestMsgHandleWrapper(pIoRequestPacket, status);

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  W32SCard::HandleContextCallWithLongReturn
//
//---------------------------------------------------------------------------------------
void
W32SCard::HandleContextCallWithLongReturn(
    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket,
    IN DWORD                    dwCallType)
{
    DC_BEGIN_FN("W32SCard::HandleContextCallWithLongReturn");

    NTSTATUS        status          = STATUS_SUCCESS;
    LONG            lReturn         = SCARD_S_SUCCESS;
    SCARDCONTEXT    SCardContext;

    //
    // Decode the context being released
    //
    lReturn = DecodeContextCall(pIoRequestPacket, &SCardContext);
    if (lReturn == SCARD_S_SUCCESS)
    {
        //
        // Make SCard subsystem call
        //
        switch(dwCallType)
        {
        case SCARD_IOCTL_RELEASECONTEXT:
#ifndef OS_WINCE
            lReturn = pfnSCardReleaseContext(SCardContext);
#endif
            RemoveSCardContextFromList(SCardContext);
#ifdef OS_WINCE
            lReturn = pfnSCardReleaseContext(SCardContext); //the context must be released after you cancel any operations on the card
#endif
            break;
        case SCARD_IOCTL_ISVALIDCONTEXT:
            lReturn = pfnSCardIsValidContext(SCardContext);
            break;

        case SCARD_IOCTL_CANCEL:
            lReturn = pfnSCardCancel(SCardContext);
            break;
        }
    }

    //
    // encode and write the return
    //
    EncodeAndChannelWriteLongReturn(pIoRequestPacket, lReturn);

Return:

    DC_END_FN();

    return;

ErrorReturn:

    DefaultIORequestMsgHandleWrapper(pIoRequestPacket, status);

    goto Return;

}


//---------------------------------------------------------------------------------------
//
//  W32SCard::EncodeAndChannelWriteLongAndMultiStringReturn
//
//---------------------------------------------------------------------------------------
void
W32SCard::EncodeAndChannelWriteLongAndMultiStringReturn(
    IN PRDPDR_IOREQUEST_PACKET  pIoRequestPacket,
    IN LONG                     lReturn,
    IN BYTE                     *pb,
    IN DWORD                    cch,
    IN BOOL                     fUnicode)
{
    DC_BEGIN_FN("W32SCard::EncodeAndChannelWriteLongAndMultiStringReturn");

    RPC_STATUS                          rpcStatus           = RPC_S_OK;
    NTSTATUS                            status              = STATUS_SUCCESS;
    char                                *pbEncodedBuffer    = NULL;
    unsigned long                       cbEncodedBuffer     = 0;
    handle_t                            h                   = 0;
    BOOL                                fFree               = FALSE;
    struct _LongAndMultiString_Return   LongAndMultiSzReturn;

    //
    // Initialiaze struct to be encoded
    //
    LongAndMultiSzReturn.ReturnCode = lReturn;
    LongAndMultiSzReturn.cBytes = fUnicode ? (cch * sizeof(WCHAR)) : cch;

    //
    // If we are just returning the byte count then send back a junk buffer
    //
    if (pb == NULL)
    {
        LongAndMultiSzReturn.msz = (BYTE *) MIDL_user_allocate(LongAndMultiSzReturn.cBytes);
        if (LongAndMultiSzReturn.msz == NULL)
        {
            status = STATUS_NO_MEMORY;
            goto ErrorReturn;
        }

        fFree = TRUE;
        memset(LongAndMultiSzReturn.msz, 0, LongAndMultiSzReturn.cBytes);
    }
    else
    {
        LongAndMultiSzReturn.msz = pb;
    }


    //
    // Encode the return
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer,
                        &cbEncodedBuffer,
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        TRC_ERR((TB, _T("MesEncodeDynBufferHandleCreate failed with %lx."), rpcStatus));
        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    _TRY_status(ListReaderGroups_Return_Encode(h, &LongAndMultiSzReturn))

    //
    // Send the return
    //
    AllocateAndChannelWriteReplyPacket(
                pIoRequestPacket,
                pbEncodedBuffer,
                cbEncodedBuffer);

Return:

    if (fFree)
    {
        MIDL_user_free(LongAndMultiSzReturn.msz);
    }

    SafeMesHandleFree(&h);

    MIDL_user_free(pbEncodedBuffer);

    DC_END_FN();

    return;

ErrorReturn:

    DefaultIORequestMsgHandleWrapper(pIoRequestPacket, status);

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  W32SCard::ListReaderGroups
//
//---------------------------------------------------------------------------------------
void
W32SCard::ListReaderGroups(
    IN PRDPDR_IOREQUEST_PACKET  pIoRequestPacket,
    IN DWORD                    dwCallType)
{
    DC_BEGIN_FN("W32SCard::ListReaderGroups");

    LONG                        lReturn                 = SCARD_S_SUCCESS;
    RPC_STATUS                  rpcStatus               = RPC_S_OK;
    NTSTATUS                    status                  = STATUS_SUCCESS;
    handle_t                    hDec                    = 0;
    SCARDCONTEXT                SCardContext;
    ListReaderGroups_Call       ListReaderGroupsCall;
    DWORD                       cch                     = 0;
    BYTE                        *pb                     = NULL;
    BOOL                        fFreeDecode             = FALSE;
    BOOL                        fDoAllocationLocally    = FALSE;
    PRDPDR_DEVICE_IOREQUEST     pIoRequest              = &(pIoRequestPacket->IoRequest);

    //
    // Decode parameters
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) (pIoRequest + 1), // bytes are at end of struct
                        pIoRequest->Parameters.DeviceIoControl.InputBufferLength,
                        &hDec);
    if (rpcStatus != RPC_S_OK)
    {
        TRC_ERR((TB, _T("MesDecodeBufferHandleCreate failed with %lx."), rpcStatus));
        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    memset(&ListReaderGroupsCall, 0, sizeof(ListReaderGroupsCall));
    _TRY_status(ListReaderGroups_Call_Decode(hDec, &ListReaderGroupsCall))
    fFreeDecode = TRUE;

    if (ListReaderGroupsCall.Context.pbContext != NULL)
    {
        if (sizeof(SCARDCONTEXT) == ListReaderGroupsCall.Context.cbContext)
        {
            SCardContext = *((SCARDCONTEXT *) ListReaderGroupsCall.Context.pbContext);
        }
        else
        {
            TRC_ERR((TB, _T("Invalid context sent from server.")));
            lReturn = SCARD_E_INVALID_PARAMETER;
        }
    }
    else
    {
        SCardContext = NULL;
    }

    cch = ListReaderGroupsCall.cchGroups;

    if (lReturn == SCARD_S_SUCCESS)
    {

        //
        // Allocate if not in SCARD_AUTOALLOCATE mode and not a size only call
        //
        fDoAllocationLocally =
                (!ListReaderGroupsCall.fmszGroupsIsNULL &&
                 (cch != SCARD_AUTOALLOCATE));

#ifdef OS_WINCE
        if (!fDoAllocationLocally)
        {
            lReturn = pfnSCardListReaderGroupsW(
                            SCardContext,
                            NULL,
                            &cch);
            if ((lReturn == SCARD_S_SUCCESS) && (cch > 0))
                fDoAllocationLocally = TRUE;
            else
            {
                TRC_ERR((TB, _T("SCardListReaderGroupsW failed")));
                status = STATUS_UNSUCCESSFUL;
                goto ErrorReturn;
            }
        }
#endif
        //
        // Make the ListReaderGroups call
        //
        if (dwCallType == SCARD_IOCTL_LISTREADERGROUPSA)
        {
            LPSTR psz = NULL;

            if (fDoAllocationLocally)
            {
                psz = (LPSTR) MIDL_user_allocate(cch * sizeof(CHAR));
                if (psz == NULL)
                {
                    TRC_ERR((TB, _T("MIDL_user_allocate failed")));
                    status = STATUS_NO_MEMORY;
                    goto ErrorReturn;
                }
            }

            lReturn = pfnSCardListReaderGroupsA(
                            SCardContext,
                            (cch == SCARD_AUTOALLOCATE) ? (LPSTR) &psz : psz,
                            &cch);

            pb = (LPBYTE) psz;
        }
        else
        {
            LPWSTR pwsz = NULL;

            if (fDoAllocationLocally)
            {
                pwsz = (LPWSTR) MIDL_user_allocate(cch * sizeof(WCHAR));
                if (pwsz == NULL)
                {
                    TRC_ERR((TB, _T("MIDL_user_allocate failed")));
                    status = STATUS_NO_MEMORY;
                    goto ErrorReturn;
                }
            }

            lReturn = pfnSCardListReaderGroupsW(
                            SCardContext,
                            (cch == SCARD_AUTOALLOCATE) ? (LPWSTR) &pwsz : pwsz,
                            &cch);

            pb = (LPBYTE) pwsz;
        }
    }

    //
    // If anything failed, make sure we don't return a string
    //
    if (lReturn != SCARD_S_SUCCESS)
    {
        if (fDoAllocationLocally)
        {
            MIDL_user_free(pb);
        }
        pb = NULL;
        cch = 0;
    }

    //
    // write the return to the channel
    //
    EncodeAndChannelWriteLongAndMultiStringReturn(
                pIoRequestPacket,
                lReturn,
                pb,
                cch,
                (dwCallType == SCARD_IOCTL_LISTREADERGROUPSA) ? FALSE : TRUE);

Return:

    if (pb != NULL)
    {
        //
        // Check to see whether we allocated or SCard allcated for us
        //
        if (fDoAllocationLocally)
        {
            MIDL_user_free(pb);
        }
        else
        {
            pfnSCardFreeMemory(SCardContext, pb);
        }
    }

    if (fFreeDecode)
    {
        _TRY_2(ListReaderGroups_Call_Free(hDec, &ListReaderGroupsCall))
    }
    SafeMesHandleFree(&hDec);

    DC_END_FN();

    return;

ErrorReturn:

    DefaultIORequestMsgHandleWrapper(pIoRequestPacket, status);

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  W32SCard::ListReaderGroups
//
//---------------------------------------------------------------------------------------
void
W32SCard::ListReaders(
    IN PRDPDR_IOREQUEST_PACKET  pIoRequestPacket,
    IN DWORD                    dwCallType)
{
    DC_BEGIN_FN("W32SCard::ListReaders");

    LONG                        lReturn                 = SCARD_S_SUCCESS;
    RPC_STATUS                  rpcStatus               = RPC_S_OK;
    NTSTATUS                    status                  = STATUS_SUCCESS;
    handle_t                    hDec                    = 0;
    SCARDCONTEXT                SCardContext;
    ListReaders_Call            ListReadersCall;
    DWORD                       cch                     = 0;
    BYTE                        *pb                     = NULL;
    BOOL                        fFreeDecode             = FALSE;
    BOOL                        fDoAllocationLocally    = FALSE;
    PRDPDR_DEVICE_IOREQUEST     pIoRequest              = &(pIoRequestPacket->IoRequest);

    //
    // Decode parameters
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) (pIoRequest + 1), // bytes are at end of struct
                        pIoRequest->Parameters.DeviceIoControl.InputBufferLength,
                        &hDec);
    if (rpcStatus != RPC_S_OK)
    {
        TRC_ERR((TB, _T("MesDecodeBufferHandleCreate failed with %lx."), rpcStatus));
        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    memset(&ListReadersCall, 0, sizeof(ListReadersCall));
    _TRY_status(ListReaders_Call_Decode(hDec, &ListReadersCall))
    fFreeDecode = TRUE;

    if (ListReadersCall.Context.pbContext != NULL)
    {
        if (sizeof(SCARDCONTEXT) == ListReadersCall.Context.cbContext)
        {
            SCardContext = *((SCARDCONTEXT *) ListReadersCall.Context.pbContext);
        }
        else
        {
            TRC_ERR((TB, _T("Invalid context sent from server.")));
            lReturn = SCARD_E_INVALID_PARAMETER;
        }
    }
    else
    {
        SCardContext = NULL;
    }

    cch = ListReadersCall.cchReaders;

    if (lReturn == SCARD_S_SUCCESS)
    {
        //
        // Allocate if not in SCARD_AUTOALLOCATE mode and not a size only call
        //
        fDoAllocationLocally =
                (!ListReadersCall.fmszReadersIsNULL &&
                 (cch != SCARD_AUTOALLOCATE));

        //
        // Make the ListReaders call
        //
        if (dwCallType == SCARD_IOCTL_LISTREADERSA)
        {
            LPSTR psz = NULL;

#ifdef OS_WINCE
            if (!fDoAllocationLocally)
            {
                lReturn = pfnSCardListReadersA(
                                SCardContext,
                                (LPSTR) ListReadersCall.mszGroups,
                                NULL,
                                &cch);
                if ((lReturn == SCARD_S_SUCCESS) && (cch > 0))
                    fDoAllocationLocally = TRUE;
                else
                {
                    TRC_DBG((TB, _T("SCardListReadersA failed")));
                    status = STATUS_UNSUCCESSFUL;
                    goto ErrorReturn;
                }
            }
#endif
            if (fDoAllocationLocally)
            {
                psz = (LPSTR) MIDL_user_allocate(cch * sizeof(CHAR));
                if (psz == NULL)
                {
                    TRC_ERR((TB, _T("MIDL_user_allocate failed")));
                    status = STATUS_NO_MEMORY;
                    goto ErrorReturn;
                }
            }

            lReturn = pfnSCardListReadersA(
                            SCardContext,
                            (LPSTR) ListReadersCall.mszGroups,
                            (cch == SCARD_AUTOALLOCATE) ? (LPSTR) &psz : psz,
                            &cch);

            pb = (LPBYTE) psz;
        }
        else
        {
            LPWSTR pwsz = NULL;

#ifdef OS_WINCE
            if (!fDoAllocationLocally)
            {
                lReturn = pfnSCardListReadersW(
                                SCardContext,
                                SCARD_ALL_READERS,
                                NULL,
                                &cch);
                if ((lReturn == SCARD_S_SUCCESS) && (cch > 0))
                    fDoAllocationLocally = TRUE;
                else
                {
                    TRC_NRM((TB, _T("SCardListReadersW failed")));
                    status = STATUS_UNSUCCESSFUL;
                    goto ErrorReturn;
                }
            }
#endif

            if (fDoAllocationLocally)
            {
                pwsz = (LPWSTR) MIDL_user_allocate(cch * sizeof(WCHAR));
                if (pwsz == NULL)
                {
                    TRC_ERR((TB, _T("MIDL_user_allocate failed")));
                    status = STATUS_NO_MEMORY;
                    goto ErrorReturn;
                }
            }

            lReturn = pfnSCardListReadersW(
                            SCardContext,
#ifndef OS_WINCE
                            (LPWSTR) ListReadersCall.mszGroups,
#else
                            SCARD_ALL_READERS,
#endif
                            (cch == SCARD_AUTOALLOCATE) ? (LPWSTR) &pwsz : pwsz,
                            &cch);

            pb = (LPBYTE) pwsz;
        }
    }

    //
    // If anything failed, make sure we don't return a string
    //
    if (lReturn != SCARD_S_SUCCESS)
    {
        if (fDoAllocationLocally)
        {
            MIDL_user_free(pb);
        }
        pb = NULL;
        cch = 0;
    }

    //
    // write the return to the channel
    //
    EncodeAndChannelWriteLongAndMultiStringReturn(
                pIoRequestPacket,
                lReturn,
                pb,
                cch,
                (dwCallType == SCARD_IOCTL_LISTREADERSA) ? FALSE : TRUE);

Return:

    if (pb != NULL)
    {
        //
        // Check to see whether we allocated or SCard allcated for us
        //
        if (fDoAllocationLocally)
        {
            MIDL_user_free(pb);
        }
        else
        {
#ifndef OS_WINCE
            pfnSCardFreeMemory(SCardContext, pb);
#else
            TRC_ASSERT(FALSE, (TB, _T("Shouldnt get here")));
#endif
        }
    }

    if (fFreeDecode)
    {
        _TRY_2(ListReaders_Call_Free(hDec, &ListReadersCall))
    }
    SafeMesHandleFree(&hDec);

    DC_END_FN();

    return;

ErrorReturn:

    DefaultIORequestMsgHandleWrapper(pIoRequestPacket, status);

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  W32SCard::HandleContextAndStringCallWithLongReturn
//
//---------------------------------------------------------------------------------------
void
W32SCard::HandleContextAndStringCallWithLongReturn(
    IN PRDPDR_IOREQUEST_PACKET  pIoRequestPacket,
    IN DWORD                    dwCallType)
{
    DC_BEGIN_FN("W32SCard::HandleContextAndStringCallWithLongReturn");

    LONG                        lReturn                 = SCARD_S_SUCCESS;
    NTSTATUS                    status                  = STATUS_SUCCESS;
    SCARDCONTEXT                SCardContext;
    LPSTR                       sz                      = NULL;
    LPWSTR                      wsz                     = NULL;
    BOOL                        fASCIICall;
    PRDPDR_DEVICE_IOREQUEST     pIoRequest              = &(pIoRequestPacket->IoRequest);

    fASCIICall = (  (dwCallType == SCARD_IOCTL_INTRODUCEREADERGROUPA)   ||
                    (dwCallType == SCARD_IOCTL_FORGETREADERGROUPA)      ||
                    (dwCallType == SCARD_IOCTL_FORGETREADERA));

    //
    // Decode input params
    //
    if (fASCIICall)
    {
        lReturn = DecodeContextAndStringCallA(
                            pIoRequestPacket,
                            &SCardContext,
                            &sz);
    }
    else
    {
        lReturn = DecodeContextAndStringCallW(
                            pIoRequestPacket,
                            &SCardContext,
                            &wsz);
    }

    if (lReturn == SCARD_S_SUCCESS)
    {
        //
        // Make the SCard* call
        //
        switch (dwCallType)
        {
        case SCARD_IOCTL_INTRODUCEREADERGROUPA:

            lReturn = pfnSCardIntroduceReaderGroupA(
                            SCardContext,
                            sz);
            break;

        case SCARD_IOCTL_INTRODUCEREADERGROUPW:

            lReturn = pfnSCardIntroduceReaderGroupW(
                            SCardContext,
                            wsz);

            break;

        case SCARD_IOCTL_FORGETREADERGROUPA:

            lReturn = pfnSCardForgetReaderGroupA(
                            SCardContext,
                            sz);
            break;

        case SCARD_IOCTL_FORGETREADERGROUPW:

            lReturn = pfnSCardForgetReaderGroupW(
                            SCardContext,
                            wsz);

            break;

        case SCARD_IOCTL_FORGETREADERA:

            lReturn = pfnSCardForgetReaderA(
                            SCardContext,
                            sz);
            break;

        case SCARD_IOCTL_FORGETREADERW:

            lReturn = pfnSCardForgetReaderW(
                            SCardContext,
                            wsz);

            break;
        }
    }

    //
    // send the return
    //
    EncodeAndChannelWriteLongReturn(pIoRequestPacket, lReturn);

Return:

    MIDL_user_free(sz);
    MIDL_user_free(wsz);

    DC_END_FN();

    return;

ErrorReturn:

    DefaultIORequestMsgHandleWrapper(pIoRequestPacket, status);

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  W32SCard::HandleContextAndTwoStringCallWithLongReturn
//
//---------------------------------------------------------------------------------------
void
W32SCard::HandleContextAndTwoStringCallWithLongReturn(
    IN PRDPDR_IOREQUEST_PACKET  pIoRequestPacket,
    IN DWORD                    dwCallType)
{
    DC_BEGIN_FN("W32SCard::HandleContextAndTwoStringCallWithLongReturn");

    RPC_STATUS                  rpcStatus               = RPC_S_OK;
    LONG                        lReturn                 = SCARD_S_SUCCESS;
    NTSTATUS                    status                  = STATUS_SUCCESS;
    SCARDCONTEXT                SCardContext;
    handle_t                    hDec                    = 0;
    ContextAndTwoStringA_Call   ContextAndTwoStringCallA;
    ContextAndTwoStringW_Call   ContextAndTwoStringCallW;
    BOOL                        fASCIICall;
    PRDPDR_DEVICE_IOREQUEST     pIoRequest              = &(pIoRequestPacket->IoRequest);

    //
    // Decode input parameters
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) (pIoRequest + 1), // bytes are at end of struct
                        pIoRequest->Parameters.DeviceIoControl.InputBufferLength,
                        &hDec);
    if (rpcStatus != RPC_S_OK)
    {
        TRC_ERR((TB, _T("MesDecodeBufferHandleCreate failed with %lx."), rpcStatus));
        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    fASCIICall = (  (dwCallType == SCARD_IOCTL_INTRODUCEREADERA)    ||
                    (dwCallType == SCARD_IOCTL_ADDREADERTOGROUPA)   ||
                    (dwCallType == SCARD_IOCTL_REMOVEREADERFROMGROUPA));

    if (fASCIICall)
    {
        memset(&ContextAndTwoStringCallA, 0, sizeof(ContextAndTwoStringCallA));
        _TRY_status(ContextAndTwoStringA_Call_Decode(hDec, &ContextAndTwoStringCallA))

        if (sizeof(SCARDCONTEXT) == ContextAndTwoStringCallA.Context.cbContext)
        {
            SCardContext = *((SCARDCONTEXT *) ContextAndTwoStringCallA.Context.pbContext);
        }
        else
        {
            TRC_ERR((TB, _T("Invalid context sent from server.")));
            lReturn = SCARD_E_INVALID_PARAMETER;
        }
    }
    else
    {
        memset(&ContextAndTwoStringCallW, 0, sizeof(ContextAndTwoStringCallW));
        _TRY_status(ContextAndTwoStringW_Call_Decode(hDec, &ContextAndTwoStringCallW))

        if (sizeof(SCARDCONTEXT) == ContextAndTwoStringCallW.Context.cbContext)
        {
            SCardContext = *((SCARDCONTEXT *) ContextAndTwoStringCallW.Context.pbContext);
        }
        else
        {
            TRC_ERR((TB, _T("Invalid context sent from server.")));
            lReturn = SCARD_E_INVALID_PARAMETER;
        }
    }

    //
    // Check for NULL input strings
    //
    switch (dwCallType)
    {
    case SCARD_IOCTL_INTRODUCEREADERA:
    case SCARD_IOCTL_ADDREADERTOGROUPA:
    case SCARD_IOCTL_REMOVEREADERFROMGROUPA:

        if ((ContextAndTwoStringCallA.sz1 == NULL) ||
            (ContextAndTwoStringCallA.sz2 == NULL))
        {
            lReturn = SCARD_E_INVALID_VALUE;
        }
        break;

    case SCARD_IOCTL_INTRODUCEREADERW:
    case SCARD_IOCTL_ADDREADERTOGROUPW:
    case SCARD_IOCTL_REMOVEREADERFROMGROUPW:

        if ((ContextAndTwoStringCallW.sz1 == NULL) ||
            (ContextAndTwoStringCallW.sz2 == NULL))
        {
            lReturn = SCARD_E_INVALID_VALUE;
        }

        break;
    }

    if (lReturn == SCARD_S_SUCCESS)
    {
        //
        // Make the SCard* call
        //
        switch (dwCallType)
        {
        case SCARD_IOCTL_INTRODUCEREADERA:

            lReturn = pfnSCardIntroduceReaderA(
                            SCardContext,
                            ContextAndTwoStringCallA.sz1,
                            ContextAndTwoStringCallA.sz2);
            break;

        case SCARD_IOCTL_INTRODUCEREADERW:

            lReturn = pfnSCardIntroduceReaderW(
                            SCardContext,
                            ContextAndTwoStringCallW.sz1,
                            ContextAndTwoStringCallW.sz2);

            break;

        case SCARD_IOCTL_ADDREADERTOGROUPA:

            lReturn = pfnSCardAddReaderToGroupA(
                            SCardContext,
                            ContextAndTwoStringCallA.sz1,
                            ContextAndTwoStringCallA.sz2);

            break;

        case SCARD_IOCTL_ADDREADERTOGROUPW:

            lReturn = pfnSCardAddReaderToGroupW(
                            SCardContext,
                            ContextAndTwoStringCallW.sz1,
                            ContextAndTwoStringCallW.sz2);

            break;

        case SCARD_IOCTL_REMOVEREADERFROMGROUPA:

            lReturn = pfnSCardRemoveReaderFromGroupA(
                            SCardContext,
                            ContextAndTwoStringCallA.sz1,
                            ContextAndTwoStringCallA.sz2);

            break;

        case SCARD_IOCTL_REMOVEREADERFROMGROUPW:

            lReturn = pfnSCardRemoveReaderFromGroupW(
                            SCardContext,
                            ContextAndTwoStringCallW.sz1,
                            ContextAndTwoStringCallW.sz2);

            break;
        }
    }

    //
    // Free up resources used for decode
    //
    if (fASCIICall)
    {
        _TRY_2(ContextAndTwoStringA_Call_Free(hDec, &ContextAndTwoStringCallA))
    }
    else
    {
        _TRY_2(ContextAndTwoStringW_Call_Free(hDec, &ContextAndTwoStringCallW))
    }

    //
    // send the return
    //
    EncodeAndChannelWriteLongReturn(pIoRequestPacket, lReturn);

Return:

    SafeMesHandleFree(&hDec);

    DC_END_FN();

    return;

ErrorReturn:

    DefaultIORequestMsgHandleWrapper(pIoRequestPacket, status);

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  W32SCard::AllocateAndCopyReaderStateStructsForCall*
//
//---------------------------------------------------------------------------------------
LONG
W32SCard::AllocateAndCopyReaderStateStructsForCallA(
    IN DWORD                    cReaders,
    IN ReaderStateA             *rgReaderStatesFromDecode,
    OUT LPSCARD_READERSTATE_A   *prgReadersStatesForSCardCall)
{
    DC_BEGIN_FN("W32SCard::AllocateAndCopyReaderStateStructsForCallA");

    LPSCARD_READERSTATE_A   rgReadersStatesForSCardCall = NULL;
    DWORD                   i;

    rgReadersStatesForSCardCall = (LPSCARD_READERSTATE_A)
                        MIDL_user_allocate(cReaders * sizeof(SCARD_READERSTATE_A));
    if (rgReadersStatesForSCardCall == NULL)
    {
        TRC_ERR((TB, _T("MIDL_user_allocate failed")));
        return (SCARD_E_NO_MEMORY);
    }

    memset(rgReadersStatesForSCardCall, 0, cReaders * sizeof(SCARD_READERSTATE_A));

    for (i=0; i<cReaders; i++)
    {
        rgReadersStatesForSCardCall[i].dwCurrentState =
                rgReaderStatesFromDecode[i].Common.dwCurrentState;
        rgReadersStatesForSCardCall[i].dwEventState =
                rgReaderStatesFromDecode[i].Common.dwEventState;
        rgReadersStatesForSCardCall[i].cbAtr =
                rgReaderStatesFromDecode[i].Common.cbAtr;
        memcpy(
            rgReadersStatesForSCardCall[i].rgbAtr,
            rgReaderStatesFromDecode[i].Common.rgbAtr,
            ATR_COPY_SIZE);

        //
        // just reference string in decoded struct instead of copying.
        // this means the decode can't be free'd until the SCard* call is made
        //
        rgReadersStatesForSCardCall[i].szReader =
                rgReaderStatesFromDecode[i].szReader;
    }

    *prgReadersStatesForSCardCall = rgReadersStatesForSCardCall;

    DC_END_FN();

    return (SCARD_S_SUCCESS);
}

LONG
W32SCard::AllocateAndCopyReaderStateStructsForCallW(
    IN DWORD                    cReaders,
    IN ReaderStateW             *rgReaderStatesFromDecode,
    OUT LPSCARD_READERSTATE_W   *prgReadersStatesForSCardCall)
{
    DC_BEGIN_FN("W32SCard::AllocateAndCopyReaderStateStructsForCallW");

    LPSCARD_READERSTATE_W   rgReadersStatesForSCardCall = NULL;
    DWORD                   i;

    rgReadersStatesForSCardCall = (LPSCARD_READERSTATE_W)
                        MIDL_user_allocate(cReaders * sizeof(SCARD_READERSTATE_W));
    if (rgReadersStatesForSCardCall == NULL)
    {
        TRC_ERR((TB, _T("MIDL_user_allocate failed")));
        return (SCARD_E_NO_MEMORY);
    }

    memset(rgReadersStatesForSCardCall, 0, cReaders * sizeof(SCARD_READERSTATE_W));

    for (i=0; i<cReaders; i++)
    {
        rgReadersStatesForSCardCall[i].dwCurrentState =
                rgReaderStatesFromDecode[i].Common.dwCurrentState;
        rgReadersStatesForSCardCall[i].dwEventState =
                rgReaderStatesFromDecode[i].Common.dwEventState;
        rgReadersStatesForSCardCall[i].cbAtr =
                rgReaderStatesFromDecode[i].Common.cbAtr;
        memcpy(
            rgReadersStatesForSCardCall[i].rgbAtr,
            rgReaderStatesFromDecode[i].Common.rgbAtr,
            ATR_COPY_SIZE);

        //
        // just reference string in decoded struct instead of copying.
        // this means the decode can't be free'd until the SCard* call is made
        //
        rgReadersStatesForSCardCall[i].szReader =
                rgReaderStatesFromDecode[i].szReader;
    }

    *prgReadersStatesForSCardCall = rgReadersStatesForSCardCall;

    DC_END_FN();

    return (SCARD_S_SUCCESS);
}


//---------------------------------------------------------------------------------------
//
//  W32SCard::AllocateAndCopyATRMasksForCall
//
//---------------------------------------------------------------------------------------
LONG
W32SCard::AllocateAndCopyATRMasksForCall(
    IN DWORD                    cAtrs,
    IN LocateCards_ATRMask      *rgATRMasksFromDecode,
    OUT SCARD_ATRMASK           **prgATRMasksForCall)
{
    DC_BEGIN_FN("W32SCard::AllocateAndCopyATRMasksForCall");

    SCARD_ATRMASK   *rgATRMasksForCall = NULL;
    DWORD           i;

    rgATRMasksForCall = (SCARD_ATRMASK *)
                        MIDL_user_allocate(cAtrs * sizeof(SCARD_ATRMASK));
    if (rgATRMasksForCall == NULL)
    {
        TRC_ERR((TB, _T("MIDL_user_allocate failed")));
        return (SCARD_E_NO_MEMORY);
    }

    memset(rgATRMasksForCall, 0, cAtrs * sizeof(SCARD_ATRMASK));

    for (i=0; i<cAtrs; i++)
    {
        rgATRMasksForCall[i].cbAtr = rgATRMasksFromDecode[i].cbAtr;

        memcpy(
            rgATRMasksForCall[i].rgbAtr,
            rgATRMasksFromDecode[i].rgbAtr,
            ATR_COPY_SIZE);

        memcpy(
            rgATRMasksForCall[i].rgbMask,
            rgATRMasksFromDecode[i].rgbMask,
            ATR_COPY_SIZE);
    }

    *prgATRMasksForCall = rgATRMasksForCall;

    DC_END_FN();

    return (SCARD_S_SUCCESS);
}


//---------------------------------------------------------------------------------------
//
//  W32SCard::AllocateAndCopyReaderStateStructsForReturn*
//
//---------------------------------------------------------------------------------------
LONG
W32SCard::AllocateAndCopyReaderStateStructsForReturnA(
    IN DWORD                    cReaders,
    IN LPSCARD_READERSTATE_A    rgReaderStatesFromSCardCall,
    OUT ReaderState_Return      **prgReaderStatesForReturn)
{
    DC_BEGIN_FN("W32SCard::AllocateAndCopyReaderStateStructsForReturnA");

    ReaderState_Return  *rgReaderStatesForReturn = NULL;
    DWORD               i;

    rgReaderStatesForReturn = (ReaderState_Return *)
                        MIDL_user_allocate(cReaders * sizeof(ReaderState_Return));
    if (rgReaderStatesForReturn == NULL)
    {
        TRC_ERR((TB, _T("MIDL_user_allocate failed")));
        return (SCARD_E_NO_MEMORY);
    }

    for (i=0; i<cReaders; i++)
    {
        rgReaderStatesForReturn[i].dwCurrentState =
                rgReaderStatesFromSCardCall[i].dwCurrentState;
        rgReaderStatesForReturn[i].dwEventState =
                rgReaderStatesFromSCardCall[i].dwEventState;
        rgReaderStatesForReturn[i].cbAtr =
                rgReaderStatesFromSCardCall[i].cbAtr;
        memcpy(
            rgReaderStatesForReturn[i].rgbAtr,
            rgReaderStatesFromSCardCall[i].rgbAtr,
            ATR_COPY_SIZE);
    }

    *prgReaderStatesForReturn = rgReaderStatesForReturn;

    DC_END_FN();

    return (SCARD_S_SUCCESS);
}

LONG
W32SCard::AllocateAndCopyReaderStateStructsForReturnW(
    IN DWORD                    cReaders,
    IN LPSCARD_READERSTATE_W    rgReaderStatesFromSCardCall,
    OUT ReaderState_Return      **prgReaderStatesForReturn)
{
    DC_BEGIN_FN("W32SCard::AllocateAndCopyReaderStateStructsForReturnW");

    ReaderState_Return  *rgReaderStatesForReturn = NULL;
    DWORD               i;

    rgReaderStatesForReturn = (ReaderState_Return *)
                        MIDL_user_allocate(cReaders * sizeof(ReaderState_Return));
    if (rgReaderStatesForReturn == NULL)
    {
        TRC_ERR((TB, _T("MIDL_user_allocate failed")));
        return (SCARD_E_NO_MEMORY);
    }

    for (i=0; i<cReaders; i++)
    {
        rgReaderStatesForReturn[i].dwCurrentState =
                rgReaderStatesFromSCardCall[i].dwCurrentState;
        rgReaderStatesForReturn[i].dwEventState =
                rgReaderStatesFromSCardCall[i].dwEventState;
        rgReaderStatesForReturn[i].cbAtr =
                rgReaderStatesFromSCardCall[i].cbAtr;
        memcpy(
            rgReaderStatesForReturn[i].rgbAtr,
            rgReaderStatesFromSCardCall[i].rgbAtr,
            ATR_COPY_SIZE);
    }

    *prgReaderStatesForReturn = rgReaderStatesForReturn;

    DC_END_FN();

    return (SCARD_S_SUCCESS);
}


//---------------------------------------------------------------------------------------
//
//  W32SCard::LocateCardsA
//
//---------------------------------------------------------------------------------------
void
W32SCard::LocateCardsA(
    IN PRDPDR_IOREQUEST_PACKET  pIoRequestPacket)
{
    DC_BEGIN_FN("W32SCard::LocateCardsA");

    RPC_STATUS              rpcStatus               = RPC_S_OK;
    NTSTATUS                status                  = STATUS_SUCCESS;
    char                    *pbEncodedBuffer        = NULL;
    unsigned long           cbEncodedBuffer         = 0;
    handle_t                hDec                    = 0;
    handle_t                hEnc                    = 0;
    SCARDCONTEXT            SCardContext;
    LocateCardsA_Call       LocateCardsCallA;
    LocateCards_Return      LocateCardsReturn;
    LPSCARD_READERSTATE_A   rgReaderStatesA         = NULL;
    BOOL                    fFreeDecode             = FALSE;
    PRDPDR_DEVICE_IOREQUEST pIoRequest              = &(pIoRequestPacket->IoRequest);

    memset(&LocateCardsReturn, 0, sizeof(LocateCardsReturn));
    LocateCardsReturn.ReturnCode = SCARD_S_SUCCESS;

    //
    // Decode input parameters
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) (pIoRequest + 1), // bytes are at end of struct
                        pIoRequest->Parameters.DeviceIoControl.InputBufferLength,
                        &hDec);
    if (rpcStatus != RPC_S_OK)
    {
        TRC_ERR((TB, _T("MesDecodeBufferHandleCreate failed with %lx."), rpcStatus));
        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    //
    // Decode and copy the input params
    //
    memset(&LocateCardsCallA, 0, sizeof(LocateCardsCallA));
    _TRY_status(LocateCardsA_Call_Decode(hDec, &LocateCardsCallA))
    fFreeDecode = TRUE;

    if (sizeof(SCARDCONTEXT) == LocateCardsCallA.Context.cbContext)
    {
        SCardContext = *((SCARDCONTEXT *) LocateCardsCallA.Context.pbContext);
    }
    else
    {
        TRC_ERR((TB, _T("Invalid context sent from server.")));
        LocateCardsReturn.ReturnCode = SCARD_E_INVALID_PARAMETER;
    }

    if (LocateCardsReturn.ReturnCode == SCARD_S_SUCCESS)
    {
        LocateCardsReturn.ReturnCode =
            AllocateAndCopyReaderStateStructsForCallA(
                        LocateCardsCallA.cReaders,
                        LocateCardsCallA.rgReaderStates,
                        &rgReaderStatesA);
    }

    if (LocateCardsReturn.ReturnCode == SCARD_S_SUCCESS)
    {
        //
        // Make the call
        //
        LocateCardsReturn.ReturnCode =
                pfnSCardLocateCardsA(
                        SCardContext,
                        (LPCSTR) LocateCardsCallA.mszCards,
                        rgReaderStatesA,
                        LocateCardsCallA.cReaders);
    }

    //
    // encode the return
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer,
                        &cbEncodedBuffer,
                        &hEnc);
    if (rpcStatus != RPC_S_OK)
    {
        TRC_ERR((TB, _T("MesEncodeDynBufferHandleCreate failed with %lx."), rpcStatus));
        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    if (LocateCardsReturn.ReturnCode == SCARD_S_SUCCESS)
    {
        LocateCardsReturn.ReturnCode  =
            AllocateAndCopyReaderStateStructsForReturnA(
                            LocateCardsCallA.cReaders,
                            rgReaderStatesA,
                            &(LocateCardsReturn.rgReaderStates));

        if (LocateCardsReturn.ReturnCode == SCARD_S_SUCCESS)
        {
            LocateCardsReturn.cReaders = LocateCardsCallA.cReaders;
        }
    }
    _TRY_status(LocateCards_Return_Encode(hEnc, &LocateCardsReturn))

    //
    // Send return
    //
    AllocateAndChannelWriteReplyPacket(
                pIoRequestPacket,
                pbEncodedBuffer,
                cbEncodedBuffer);

Return:

    if (fFreeDecode)
    {
        _TRY_2(LocateCardsA_Call_Free(hDec, &LocateCardsCallA))
    }
    SafeMesHandleFree(&hDec);

    SafeMesHandleFree(&hEnc);

    MIDL_user_free(rgReaderStatesA);
    MIDL_user_free(LocateCardsReturn.rgReaderStates);
    MIDL_user_free(pbEncodedBuffer);

    DC_END_FN();

    return;

ErrorReturn:

    DefaultIORequestMsgHandleWrapper(pIoRequestPacket, status);

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  W32SCard::LocateCardsW
//
//---------------------------------------------------------------------------------------
void
W32SCard::LocateCardsW(
    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket)
{
    DC_BEGIN_FN("W32SCard::LocateCardsW");

    RPC_STATUS              rpcStatus               = RPC_S_OK;
    NTSTATUS                status                  = STATUS_SUCCESS;
    char                    *pbEncodedBuffer        = NULL;
    unsigned long           cbEncodedBuffer         = 0;
    handle_t                hDec                    = 0;
    handle_t                hEnc                    = 0;
    SCARDCONTEXT            SCardContext;
    LocateCardsW_Call       LocateCardsCallW;
    LocateCards_Return      LocateCardsReturn;
    LPSCARD_READERSTATE_W   rgReaderStatesW         = NULL;
    BOOL                    fFreeDecode             = FALSE;
    PRDPDR_DEVICE_IOREQUEST pIoRequest              = &(pIoRequestPacket->IoRequest);

    memset(&LocateCardsReturn, 0, sizeof(LocateCardsReturn));
    LocateCardsReturn.ReturnCode = SCARD_S_SUCCESS;

    //
    // Decode input parameters
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) (pIoRequest + 1), // bytes are at end of struct
                        pIoRequest->Parameters.DeviceIoControl.InputBufferLength,
                        &hDec);
    if (rpcStatus != RPC_S_OK)
    {
        TRC_ERR((TB, _T("MesDecodeBufferHandleCreate failed with %lx."), rpcStatus));
        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    //
    // Decode and copy the input params
    //
    memset(&LocateCardsCallW, 0, sizeof(LocateCardsCallW));
    _TRY_status(LocateCardsW_Call_Decode(hDec, &LocateCardsCallW))
    fFreeDecode = TRUE;

    if (sizeof(SCARDCONTEXT) == LocateCardsCallW.Context.cbContext)
    {
        SCardContext = *((SCARDCONTEXT *) LocateCardsCallW.Context.pbContext);
    }
    else
    {
        TRC_ERR((TB, _T("Invalid context sent from server.")));
        LocateCardsReturn.ReturnCode = SCARD_E_INVALID_PARAMETER;
    }

    if (LocateCardsReturn.ReturnCode == SCARD_S_SUCCESS)
    {
        LocateCardsReturn.ReturnCode =
            AllocateAndCopyReaderStateStructsForCallW(
                        LocateCardsCallW.cReaders,
                        LocateCardsCallW.rgReaderStates,
                        &rgReaderStatesW);
    }

    if (LocateCardsReturn.ReturnCode == SCARD_S_SUCCESS)
    {
        //
        // Make the call
        //
        LocateCardsReturn.ReturnCode =
                pfnSCardLocateCardsW(
                        SCardContext,
                        (LPCWSTR) LocateCardsCallW.mszCards,
                        rgReaderStatesW,
                        LocateCardsCallW.cReaders);
    }

    //
    // encode the return
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer,
                        &cbEncodedBuffer,
                        &hEnc);
    if (rpcStatus != RPC_S_OK)
    {
        TRC_ERR((TB, _T("MesEncodeDynBufferHandleCreate failed with %lx."), rpcStatus));
        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    if (LocateCardsReturn.ReturnCode == SCARD_S_SUCCESS)
    {
        LocateCardsReturn.ReturnCode =
            AllocateAndCopyReaderStateStructsForReturnW(
                            LocateCardsCallW.cReaders,
                            rgReaderStatesW,
                            &(LocateCardsReturn.rgReaderStates));

        if (LocateCardsReturn.ReturnCode == SCARD_S_SUCCESS)
        {
            LocateCardsReturn.cReaders = LocateCardsCallW.cReaders;
        }
    }
    _TRY_status(LocateCards_Return_Encode(hEnc, &LocateCardsReturn))

    //
    // Send return
    //
    AllocateAndChannelWriteReplyPacket(
                pIoRequestPacket,
                pbEncodedBuffer,
                cbEncodedBuffer);

Return:

    if (fFreeDecode)
    {
        _TRY_2(LocateCardsW_Call_Free(hDec, &LocateCardsCallW))
    }
    SafeMesHandleFree(&hDec);

    SafeMesHandleFree(&hEnc);

    MIDL_user_free(rgReaderStatesW);
    MIDL_user_free(LocateCardsReturn.rgReaderStates);
    MIDL_user_free(pbEncodedBuffer);

    DC_END_FN();

    return;

ErrorReturn:

    DefaultIORequestMsgHandleWrapper(pIoRequestPacket, status);

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  W32SCard::LocateCardsByATRA
//
//---------------------------------------------------------------------------------------
void
W32SCard::LocateCardsByATRA(
    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket)
{
    DC_BEGIN_FN("W32SCard::LocateCardsByATRA");

    RPC_STATUS              rpcStatus               = RPC_S_OK;
    NTSTATUS                status                  = STATUS_SUCCESS;
    char                    *pbEncodedBuffer        = NULL;
    unsigned long           cbEncodedBuffer         = 0;
    handle_t                hDec                    = 0;
    handle_t                hEnc                    = 0;
    SCARDCONTEXT            SCardContext;
    LocateCardsByATRA_Call  LocateCardsByATRCallA;
    LocateCards_Return      LocateCardsReturn;
    LPSCARD_READERSTATE_A   rgReaderStatesA         = NULL;
    SCARD_ATRMASK           *rgATRMasksForCall      = NULL;
    PRDPDR_DEVICE_IOREQUEST pIoRequest              = &(pIoRequestPacket->IoRequest);

    memset(&LocateCardsReturn, 0, sizeof(LocateCardsReturn));
    LocateCardsReturn.ReturnCode = SCARD_S_SUCCESS;

    //
    // Decode input parameters
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) (pIoRequest + 1), // bytes are at end of struct
                        pIoRequest->Parameters.DeviceIoControl.InputBufferLength,
                        &hDec);
    if (rpcStatus != RPC_S_OK)
    {
        TRC_ERR((TB, _T("MesDecodeBufferHandleCreate failed with %lx."), rpcStatus));
        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    //
    // Decode and copy the input params
    //
    memset(&LocateCardsByATRCallA, 0, sizeof(LocateCardsByATRCallA));
    _TRY_status(LocateCardsByATRA_Call_Decode(hDec, &LocateCardsByATRCallA))

    if (sizeof(SCARDCONTEXT) == LocateCardsByATRCallA.Context.cbContext)
    {
        SCardContext = *((SCARDCONTEXT *) LocateCardsByATRCallA.Context.pbContext);
    }
    else
    {
        TRC_ERR((TB, _T("Invalid context sent from server.")));
        LocateCardsReturn.ReturnCode = SCARD_E_INVALID_PARAMETER;
    }

    if (LocateCardsReturn.ReturnCode == SCARD_S_SUCCESS)
    {
        LocateCardsReturn.ReturnCode =
            AllocateAndCopyATRMasksForCall(
                        LocateCardsByATRCallA.cAtrs,
                        LocateCardsByATRCallA.rgAtrMasks,
                        &rgATRMasksForCall);
    }

    if (LocateCardsReturn.ReturnCode == SCARD_S_SUCCESS)
    {
        LocateCardsReturn.ReturnCode =
            AllocateAndCopyReaderStateStructsForCallA(
                        LocateCardsByATRCallA.cReaders,
                        LocateCardsByATRCallA.rgReaderStates,
                        &rgReaderStatesA);
    }

    if (LocateCardsReturn.ReturnCode == SCARD_S_SUCCESS)
    {
        //
        // Make the call... if it is available
        //
#ifndef OS_WINCE
        if (pfnSCardLocateCardsByATRW != NULL)
#else
        if (pfnSCardLocateCardsByATRA != NULL)
#endif
        {
            LocateCardsReturn.ReturnCode =
                    pfnSCardLocateCardsByATRA(
                            SCardContext,
                            rgATRMasksForCall,
                            LocateCardsByATRCallA.cAtrs,
                            rgReaderStatesA,
                            LocateCardsByATRCallA.cReaders);
         }
         else
         {
            LocateCardsReturn.ReturnCode = ERROR_CALL_NOT_IMPLEMENTED;
         }
    }

    //
    // encode the return
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer,
                        &cbEncodedBuffer,
                        &hEnc);
    if (rpcStatus != RPC_S_OK)
    {
        TRC_ERR((TB, _T("MesEncodeDynBufferHandleCreate failed with %lx."), rpcStatus));
        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    if (LocateCardsReturn.ReturnCode == SCARD_S_SUCCESS)
    {
        LocateCardsReturn.ReturnCode =
            AllocateAndCopyReaderStateStructsForReturnA(
                            LocateCardsByATRCallA.cReaders,
                            rgReaderStatesA,
                            &(LocateCardsReturn.rgReaderStates));

        if (LocateCardsReturn.ReturnCode == SCARD_S_SUCCESS)
        {
            LocateCardsReturn.cReaders = LocateCardsByATRCallA.cReaders;
        }
    }

    _TRY_status(LocateCards_Return_Encode(hEnc, &LocateCardsReturn))

    //
    // Send return
    //
    AllocateAndChannelWriteReplyPacket(
                pIoRequestPacket,
                pbEncodedBuffer,
                cbEncodedBuffer);

Return:

    SafeMesHandleFree(&hDec);

    SafeMesHandleFree(&hEnc);

    MIDL_user_free(rgReaderStatesA);
    MIDL_user_free(LocateCardsReturn.rgReaderStates);
    MIDL_user_free(rgATRMasksForCall);
    MIDL_user_free(pbEncodedBuffer);

    DC_END_FN();

    return;

ErrorReturn:

    DefaultIORequestMsgHandleWrapper(pIoRequestPacket, status);

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  W32SCard::LocateCardsByATRW
//
//---------------------------------------------------------------------------------------
void
W32SCard::LocateCardsByATRW(
    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket)
{
    DC_BEGIN_FN("W32SCard::LocateCardsByATRW");

    RPC_STATUS              rpcStatus               = RPC_S_OK;
    NTSTATUS                status                  = STATUS_SUCCESS;
    char                    *pbEncodedBuffer        = NULL;
    unsigned long           cbEncodedBuffer         = 0;
    handle_t                hDec                    = 0;
    handle_t                hEnc                    = 0;
    SCARDCONTEXT            SCardContext;
    LocateCardsByATRW_Call  LocateCardsByATRCallW;
    LocateCards_Return      LocateCardsReturn;
    LPSCARD_READERSTATE_W   rgReaderStatesW         = NULL;
    SCARD_ATRMASK           *rgATRMasksForCall      = NULL;
    PRDPDR_DEVICE_IOREQUEST pIoRequest              = &(pIoRequestPacket->IoRequest);

    memset(&LocateCardsReturn, 0, sizeof(LocateCardsReturn));
    LocateCardsReturn.ReturnCode = SCARD_S_SUCCESS;

    //
    // Decode input parameters
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) (pIoRequest + 1), // bytes are at end of struct
                        pIoRequest->Parameters.DeviceIoControl.InputBufferLength,
                        &hDec);
    if (rpcStatus != RPC_S_OK)
    {
        TRC_ERR((TB, _T("MesDecodeBufferHandleCreate failed with %lx."), rpcStatus));
        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    //
    // Decode and copy the input params
    //
    memset(&LocateCardsByATRCallW, 0, sizeof(LocateCardsByATRCallW));
    _TRY_status(LocateCardsByATRW_Call_Decode(hDec, &LocateCardsByATRCallW))

    if (sizeof(SCARDCONTEXT) == LocateCardsByATRCallW.Context.cbContext)
    {
        SCardContext = *((SCARDCONTEXT *) LocateCardsByATRCallW.Context.pbContext);
    }
    else
    {
        TRC_ERR((TB, _T("Invalid context sent from server.")));
        LocateCardsReturn.ReturnCode = SCARD_E_INVALID_PARAMETER;
    }

    if (LocateCardsReturn.ReturnCode == SCARD_S_SUCCESS)
    {
        LocateCardsReturn.ReturnCode =
            AllocateAndCopyATRMasksForCall(
                        LocateCardsByATRCallW.cAtrs,
                        LocateCardsByATRCallW.rgAtrMasks,
                        &rgATRMasksForCall);
    }

    if (LocateCardsReturn.ReturnCode == SCARD_S_SUCCESS)
    {
        LocateCardsReturn.ReturnCode =
            AllocateAndCopyReaderStateStructsForCallW(
                        LocateCardsByATRCallW.cReaders,
                        LocateCardsByATRCallW.rgReaderStates,
                        &rgReaderStatesW);
    }

    if (LocateCardsReturn.ReturnCode == SCARD_S_SUCCESS)
    {
        //
        // Make the call... if it is available
        //
        if (pfnSCardLocateCardsByATRW != NULL)
        {
            LocateCardsReturn.ReturnCode =
                    pfnSCardLocateCardsByATRW(
                            SCardContext,
                            rgATRMasksForCall,
                            LocateCardsByATRCallW.cAtrs,
                            rgReaderStatesW,
                            LocateCardsByATRCallW.cReaders);
         }
         else
         {
            LocateCardsReturn.ReturnCode = ERROR_CALL_NOT_IMPLEMENTED;
         }
    }

    //
    // encode the return
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer,
                        &cbEncodedBuffer,
                        &hEnc);
    if (rpcStatus != RPC_S_OK)
    {
        TRC_ERR((TB, _T("MesEncodeDynBufferHandleCreate failed with %lx."), rpcStatus));
        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    if (LocateCardsReturn.ReturnCode == SCARD_S_SUCCESS)
    {
        LocateCardsReturn.ReturnCode =
            AllocateAndCopyReaderStateStructsForReturnW(
                            LocateCardsByATRCallW.cReaders,
                            rgReaderStatesW,
                            &(LocateCardsReturn.rgReaderStates));

        if (LocateCardsReturn.ReturnCode == SCARD_S_SUCCESS)
        {
            LocateCardsReturn.cReaders = LocateCardsByATRCallW.cReaders;
        }
    }

    _TRY_status(LocateCards_Return_Encode(hEnc, &LocateCardsReturn))

    //
    // Send return
    //
    AllocateAndChannelWriteReplyPacket(
                pIoRequestPacket,
                pbEncodedBuffer,
                cbEncodedBuffer);

Return:

    SafeMesHandleFree(&hDec);

    SafeMesHandleFree(&hEnc);

    MIDL_user_free(rgReaderStatesW);
    MIDL_user_free(LocateCardsReturn.rgReaderStates);
    MIDL_user_free(rgATRMasksForCall);
    MIDL_user_free(pbEncodedBuffer);

    DC_END_FN();

    return;

ErrorReturn:

    DefaultIORequestMsgHandleWrapper(pIoRequestPacket, status);

    goto Return;
}



//---------------------------------------------------------------------------------------
//
//  W32SCard::GetStatusChangeThreadProc and W32SCard::GetStatusChangeWrapper
//
//---------------------------------------------------------------------------------------
typedef struct _GETSTATUSCHANGESTRUCT
{
    W32SCard                *pTHIS;
    PRDPDR_IOREQUEST_PACKET pIoRequestPacket;
    DWORD                   dwCallType;
    HMODULE                 hModExtraRefCount;
    HANDLE                  hThread;
} GETSTATUSCHANGESTRUCT;


DWORD WINAPI
W32SCard::GetStatusChangeThreadProc(
    LPVOID lpParameter)
{
    GETSTATUSCHANGESTRUCT   *pGetStatusChangeStruct = (GETSTATUSCHANGESTRUCT *) lpParameter;
    W32SCard                *pTHIS                  = pGetStatusChangeStruct->pTHIS;
    HANDLE                  hThread                 = NULL;
    HMODULE                 hModExtraRefCount       = NULL;

    //
    // pGetStatusChangeStruct->hThread will be NULL if it wasn't added to the thread
    // list... if it wasn't added to the thread list then just get out.
    //
    if (pGetStatusChangeStruct->hThread == NULL)
    {
        FreeLibraryAndExitThread(pGetStatusChangeStruct->hModExtraRefCount, 0);
    }

    if (pGetStatusChangeStruct->dwCallType == SCARD_IOCTL_GETSTATUSCHANGEA)
    {
        pTHIS->GetStatusChangeA(pGetStatusChangeStruct->pIoRequestPacket);
    }
    else
    {
        pTHIS->GetStatusChangeW(pGetStatusChangeStruct->pIoRequestPacket);
    }

    hThread = pGetStatusChangeStruct->hThread;
    hModExtraRefCount = pGetStatusChangeStruct->hModExtraRefCount;
    MIDL_user_free(pGetStatusChangeStruct);

    pTHIS->RemoveThreadFromList(hThread);
    FreeLibraryAndExitThread(hModExtraRefCount, 0);
#ifdef OS_WINCE
    return 0;
#endif
}


void
W32SCard::GetStatusChangeWrapper(
    IN PRDPDR_IOREQUEST_PACKET  pIoRequestPacket,
    IN DWORD                    dwCallType)
{
    DC_BEGIN_FN("W32SCard::GetStatusChangeWrapper");

    LONG                    lReturn                 = SCARD_S_SUCCESS;
    HMODULE                 hModExtraRefCount       = NULL;
    GETSTATUSCHANGESTRUCT   *pGetStatusChangeStruct = NULL;
    DWORD                   dwThreadId;
    HANDLE                  hThread;

    //
    // Get a ref count on our dll so that we know the dll
    // code won't disappear from underneath us.  The thread will
    // release this ref count when it exits
    //
    hModExtraRefCount = AddRefCurrentModule();
    if (hModExtraRefCount == NULL)
    {
        lReturn = SCARD_E_UNEXPECTED;
        goto ImmediateReturn;
    }

    //
    // Create a thread to the actual work of the GetStatusChange call
    //
    // Need to do this since the call can block
    //
    pGetStatusChangeStruct = (GETSTATUSCHANGESTRUCT *)
            MIDL_user_allocate(sizeof(GETSTATUSCHANGESTRUCT));
    if (pGetStatusChangeStruct == NULL)
    {
        TRC_ERR((TB, _T("MIDL_user_allocate failed")));
        lReturn = SCARD_E_NO_MEMORY;
        goto ImmediateReturn;
    }
    pGetStatusChangeStruct->pTHIS = this;
    pGetStatusChangeStruct->pIoRequestPacket = pIoRequestPacket;
    pGetStatusChangeStruct->dwCallType = dwCallType;
    pGetStatusChangeStruct->hModExtraRefCount = hModExtraRefCount;
    pGetStatusChangeStruct->hThread = NULL;

    EnterCriticalSection(&_csThreadList);

    //
    // If the object is currently being destroyed, then don't create a new thread.
    //
    if (_fInDestructor)
    {
        LeaveCriticalSection(&_csThreadList);
        goto ImmediateReturn;
    }

    hThread = CreateThread(
                    NULL,
                    0,
                    GetStatusChangeThreadProc,
                    pGetStatusChangeStruct,
                    CREATE_SUSPENDED,
                    &dwThreadId);
    if (hThread == NULL)
    {
        lReturn = SCARD_E_UNEXPECTED;
        LeaveCriticalSection(&_csThreadList);
        goto ImmediateReturn;
    }

    if (!AddThreadToList(hThread))
    {
        LeaveCriticalSection(&_csThreadList);
        ResumeThread(hThread);
        WaitForSingleObject(hThread, INFINITE);
        CloseHandle(hThread);
        goto ImmediateReturn;
    }

    LeaveCriticalSection(&_csThreadList);

    //
    // Now let the thread go
    //
    pGetStatusChangeStruct->hThread = hThread;
    ResumeThread(hThread);

    //
    // Return here and let the thread that was just created
    // do the real work.
    //
Return:

    DC_END_FN();

    return;

ImmediateReturn:

    if (hModExtraRefCount != NULL)
    {
        FreeLibrary(hModExtraRefCount);
    }

    MIDL_user_free(pGetStatusChangeStruct);

    EncodeAndChannelWriteLongReturn(
                        pIoRequestPacket,
                        lReturn);

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  W32SCard::GetStatusChangeA
//
//---------------------------------------------------------------------------------------
void
W32SCard::GetStatusChangeA(
    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket)
{
    DC_BEGIN_FN("W32SCard::GetStatusChangeA");

    RPC_STATUS              rpcStatus               = RPC_S_OK;
    NTSTATUS                status                  = STATUS_SUCCESS;
    char                    *pbEncodedBuffer        = NULL;
    unsigned long           cbEncodedBuffer         = 0;
    handle_t                hDec                    = 0;
    handle_t                hEnc                    = 0;
    SCARDCONTEXT            SCardContext;
    GetStatusChangeA_Call   GetStatusChangeCallA;
    GetStatusChange_Return  GetStatusChangeReturn;
    LPSCARD_READERSTATE_A   rgReaderStatesA         = NULL;
    BOOL                    fFreeDecode             = FALSE;
    PRDPDR_DEVICE_IOREQUEST pIoRequest              = &(pIoRequestPacket->IoRequest);

    memset(&GetStatusChangeReturn, 0, sizeof(GetStatusChangeReturn));
    GetStatusChangeReturn.ReturnCode = SCARD_S_SUCCESS;

    //
    // Decode input parameters
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) (pIoRequest + 1), // bytes are at end of struct
                        pIoRequest->Parameters.DeviceIoControl.InputBufferLength,
                        &hDec);
    if (rpcStatus != RPC_S_OK)
    {
        TRC_ERR((TB, _T("MesDecodeBufferHandleCreate failed with %lx."), rpcStatus));
        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    //
    // Decode and copy the input params
    //
    memset(&GetStatusChangeCallA, 0, sizeof(GetStatusChangeCallA));
    _TRY_status(GetStatusChangeA_Call_Decode(hDec, &GetStatusChangeCallA))
    fFreeDecode = TRUE;

    if (sizeof(SCARDCONTEXT) == GetStatusChangeCallA.Context.cbContext)
    {
        SCardContext = *((SCARDCONTEXT *) GetStatusChangeCallA.Context.pbContext);
    }
    else
    {
        TRC_ERR((TB, _T("Invalid context sent from server.")));
        GetStatusChangeReturn.ReturnCode = SCARD_E_INVALID_PARAMETER;
    }

    if (GetStatusChangeReturn.ReturnCode == SCARD_S_SUCCESS)
    {
        GetStatusChangeReturn.ReturnCode =
            AllocateAndCopyReaderStateStructsForCallA(
                        GetStatusChangeCallA.cReaders,
                        GetStatusChangeCallA.rgReaderStates,
                        &rgReaderStatesA);
    }

    if (GetStatusChangeReturn.ReturnCode == SCARD_S_SUCCESS)
    {
        //
        // Make the call
        //
        GetStatusChangeReturn.ReturnCode =
                pfnSCardGetStatusChangeA(
                        SCardContext,
                        GetStatusChangeCallA.dwTimeOut,
                        rgReaderStatesA,
                        GetStatusChangeCallA.cReaders);
    }
#ifdef OS_WINCE
    if (GetStatusChangeReturn.ReturnCode != SCARD_S_SUCCESS)
    {
        for (DWORD i=0; i<GetStatusChangeCallA.cReaders; i++)
        {
            if (strcmp(rgReaderStatesA[i].szReader, SCPNP_NOTIFICATIONA) == 0)
            {
                rgReaderStatesA[i].dwEventState = SCARD_STATE_CHANGED | 0x00010000; //the desktop returns this value. what is it defined to?
                GetStatusChangeReturn.ReturnCode = SCARD_S_SUCCESS;
            }
        }
    }
#endif

    //
    // encode the return
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer,
                        &cbEncodedBuffer,
                        &hEnc);
    if (rpcStatus != RPC_S_OK)
    {
        TRC_ERR((TB, _T("MesEncodeDynBufferHandleCreate failed with %lx."), rpcStatus));
        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    if (GetStatusChangeReturn.ReturnCode == SCARD_S_SUCCESS)
    {
        GetStatusChangeReturn.ReturnCode
                = AllocateAndCopyReaderStateStructsForReturnA(
                            GetStatusChangeCallA.cReaders,
                            rgReaderStatesA,
                            &(GetStatusChangeReturn.rgReaderStates));

        if (GetStatusChangeReturn.ReturnCode == SCARD_S_SUCCESS)
        {
            GetStatusChangeReturn.cReaders = GetStatusChangeCallA.cReaders;
        }
    }
    _TRY_status(GetStatusChange_Return_Encode(hEnc, &GetStatusChangeReturn))

    //
    // Send return
    //
    AllocateAndChannelWriteReplyPacket(
                pIoRequestPacket,
                pbEncodedBuffer,
                cbEncodedBuffer);

Return:

    if (fFreeDecode)
    {
        _TRY_2(GetStatusChangeA_Call_Free(hDec, &GetStatusChangeCallA))
    }
    SafeMesHandleFree(&hDec);

    SafeMesHandleFree(&hEnc);

    MIDL_user_free(rgReaderStatesA);
    MIDL_user_free(GetStatusChangeReturn.rgReaderStates);
    MIDL_user_free(pbEncodedBuffer);

    DC_END_FN();

    return;

ErrorReturn:

    DefaultIORequestMsgHandleWrapper(pIoRequestPacket, status);

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  W32SCard::GetStatusChangeW
//
//---------------------------------------------------------------------------------------
void
W32SCard::GetStatusChangeW(
    IN PRDPDR_IOREQUEST_PACKET pIoRequestPacket)
{
    DC_BEGIN_FN("W32SCard::GetStatusChangeW");

    RPC_STATUS              rpcStatus               = RPC_S_OK;
    NTSTATUS                status                  = STATUS_SUCCESS;
    char                    *pbEncodedBuffer        = NULL;
    unsigned long           cbEncodedBuffer         = 0;
    handle_t                hDec                    = 0;
    handle_t                hEnc                    = 0;
    SCARDCONTEXT            SCardContext;
    GetStatusChangeW_Call   GetStatusChangeCallW;
    GetStatusChange_Return  GetStatusChangeReturn;
    LPSCARD_READERSTATE_W   rgReaderStatesW         = NULL;
    BOOL                    fFreeDecode             = FALSE;
    PRDPDR_DEVICE_IOREQUEST pIoRequest              = &(pIoRequestPacket->IoRequest);

    memset(&GetStatusChangeReturn, 0, sizeof(GetStatusChangeReturn));
    GetStatusChangeReturn.ReturnCode = SCARD_S_SUCCESS;

    //
    // Decode input parameters
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) (pIoRequest + 1), // bytes are at end of struct
                        pIoRequest->Parameters.DeviceIoControl.InputBufferLength,
                        &hDec);
    if (rpcStatus != RPC_S_OK)
    {
        TRC_ERR((TB, _T("MesDecodeBufferHandleCreate failed with %lx."), rpcStatus));
        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    //
    // Decode and copy the input params
    //
    memset(&GetStatusChangeCallW, 0, sizeof(GetStatusChangeCallW));
    _TRY_status(GetStatusChangeW_Call_Decode(hDec, &GetStatusChangeCallW))
    fFreeDecode = TRUE;

    if (sizeof(SCARDCONTEXT) == GetStatusChangeCallW.Context.cbContext)
    {
        SCardContext = *((SCARDCONTEXT *) GetStatusChangeCallW.Context.pbContext);
    }
    else
    {
        TRC_ERR((TB, _T("Invalid context sent from server.")));
        GetStatusChangeReturn.ReturnCode = SCARD_E_INVALID_PARAMETER;
    }

    if (GetStatusChangeReturn.ReturnCode == SCARD_S_SUCCESS)
    {
        GetStatusChangeReturn.ReturnCode =
                AllocateAndCopyReaderStateStructsForCallW(
                        GetStatusChangeCallW.cReaders,
                        GetStatusChangeCallW.rgReaderStates,
                        &rgReaderStatesW);
    }

    if (GetStatusChangeReturn.ReturnCode == SCARD_S_SUCCESS)
    {
        //
        // Make the call
        //
        GetStatusChangeReturn.ReturnCode =
                pfnSCardGetStatusChangeW(
                        SCardContext,
                        GetStatusChangeCallW.dwTimeOut,
                        rgReaderStatesW,
                        GetStatusChangeCallW.cReaders);
    }

#ifdef OS_WINCE
    if (GetStatusChangeReturn.ReturnCode != SCARD_S_SUCCESS)
    {
        for (DWORD i=0; i<GetStatusChangeCallW.cReaders; i++)
        {
            if (lstrcmp(rgReaderStatesW[i].szReader, SCPNP_NOTIFICATION) == 0)
            {
                rgReaderStatesW[i].dwEventState = SCARD_STATE_CHANGED | 0x00010000; //the desktop returns this value. what is it defined to?
                GetStatusChangeReturn.ReturnCode = SCARD_S_SUCCESS;
            }
        }
    }
#endif

    //
    // encode the return
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer,
                        &cbEncodedBuffer,
                        &hEnc);
    if (rpcStatus != RPC_S_OK)
    {
        TRC_ERR((TB, _T("MesEncodeDynBufferHandleCreate failed with %lx."), rpcStatus));
        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    if (GetStatusChangeReturn.ReturnCode == SCARD_S_SUCCESS)
    {
        GetStatusChangeReturn.ReturnCode =
            AllocateAndCopyReaderStateStructsForReturnW(
                            GetStatusChangeCallW.cReaders,
                            rgReaderStatesW,
                            &(GetStatusChangeReturn.rgReaderStates));

        if (GetStatusChangeReturn.ReturnCode == SCARD_S_SUCCESS)
        {
           GetStatusChangeReturn.cReaders = GetStatusChangeCallW.cReaders;
        }
    }

    _TRY_status(GetStatusChange_Return_Encode(hEnc, &GetStatusChangeReturn))

    //
    // Send return
    //
    AllocateAndChannelWriteReplyPacket(
                pIoRequestPacket,
                pbEncodedBuffer,
                cbEncodedBuffer);

Return:

    if (fFreeDecode)
    {
        _TRY_2(GetStatusChangeW_Call_Free(hDec, &GetStatusChangeCallW))
    }
    SafeMesHandleFree(&hDec);

    SafeMesHandleFree(&hEnc);

    MIDL_user_free(rgReaderStatesW);
    MIDL_user_free(GetStatusChangeReturn.rgReaderStates);
    MIDL_user_free(pbEncodedBuffer);

    DC_END_FN();

    return;

ErrorReturn:

    DefaultIORequestMsgHandleWrapper(pIoRequestPacket, status);

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  W32SCard::Connect
//
//---------------------------------------------------------------------------------------
void
W32SCard::Connect(
    IN SCARDHANDLECALLSTRUCT    *pSCardHandleCall,
    IN DWORD                    dwCallType)
{
    DC_BEGIN_FN("W32SCard::Connect");

    RPC_STATUS              rpcStatus               = RPC_S_OK;
    NTSTATUS                status                  = STATUS_SUCCESS;
    char                    *pbEncodedBuffer        = NULL;
    unsigned long           cbEncodedBuffer         = 0;
    handle_t                hDec                    = 0;
    handle_t                hEnc                    = 0;
    SCARDCONTEXT            SCardContext;
    ConnectA_Call           ConnectCallA;
    ConnectW_Call           ConnectCallW;
    Connect_Return          ConnectReturn;
    BOOL                    fFreeDecode             = FALSE;
    BOOL                    fFreeHandle             = FALSE;
    SCARDHANDLE             SCardHandle;
    PRDPDR_IOREQUEST_PACKET pIoRequestPacket        = pSCardHandleCall->pIoRequestPacket;
    PRDPDR_DEVICE_IOREQUEST pIoRequest              = &(pIoRequestPacket->IoRequest);

    memset(&ConnectReturn, 0, sizeof(ConnectReturn));
    ConnectReturn.ReturnCode = SCARD_S_SUCCESS;

    //
    // Decode input parameters
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) (pIoRequest + 1), // bytes are at end of struct
                        pIoRequest->Parameters.DeviceIoControl.InputBufferLength,
                        &hDec);
    if (rpcStatus != RPC_S_OK)
    {
        TRC_ERR((TB, _T("MesDecodeBufferHandleCreate failed with %lx."), rpcStatus));
        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    //
    // Decode input params and make the call to SCard*
    //
    if (dwCallType == SCARD_IOCTL_CONNECTA)
    {
        memset(&ConnectCallA, 0, sizeof(ConnectCallA));
        _TRY_status(ConnectA_Call_Decode(hDec, &ConnectCallA))
        fFreeDecode = TRUE;

        if (sizeof(SCARDCONTEXT) != ConnectCallA.Common.Context.cbContext)
        {
            TRC_ERR((TB, _T("Invalid parameter sent from server.")));
            ConnectReturn.ReturnCode = SCARD_E_INVALID_PARAMETER;
        }
        else if (ConnectCallA.szReader == NULL)
        {
            TRC_ERR((TB, _T("Invalid parameter sent from server.")));
            ConnectReturn.ReturnCode = SCARD_E_INVALID_VALUE;
        }
        else
        {
            SCardContext = *((SCARDCONTEXT *) ConnectCallA.Common.Context.pbContext);

            ConnectReturn.ReturnCode =
                pfnSCardConnectA(
                        SCardContext,
                        ConnectCallA.szReader,
                        ConnectCallA.Common.dwShareMode,
                        ConnectCallA.Common.dwPreferredProtocols,
                        &SCardHandle,
                        &ConnectReturn.dwActiveProtocol);
        }
    }
    else
    {
        memset(&ConnectCallW, 0, sizeof(ConnectCallW));
        _TRY_status(ConnectW_Call_Decode(hDec, &ConnectCallW))
        fFreeDecode = TRUE;

        if (sizeof(SCARDCONTEXT) != ConnectCallW.Common.Context.cbContext)
        {
            TRC_ERR((TB, _T("Invalid parameter sent from server.")));
            ConnectReturn.ReturnCode = SCARD_E_INVALID_PARAMETER;
        }
        else if (ConnectCallW.szReader == NULL)
        {
            TRC_ERR((TB, _T("Invalid parameter sent from server.")));
            ConnectReturn.ReturnCode = SCARD_E_INVALID_VALUE;
        }
        else
        {
            SCardContext = *((SCARDCONTEXT *) ConnectCallW.Common.Context.pbContext);

            ConnectReturn.ReturnCode =
                pfnSCardConnectW(
                        SCardContext,
                        ConnectCallW.szReader,
                        ConnectCallW.Common.dwShareMode,
                        ConnectCallW.Common.dwPreferredProtocols,
                        &SCardHandle,
                        &ConnectReturn.dwActiveProtocol);
        }
    }

    if (ConnectReturn.ReturnCode == SCARD_S_SUCCESS)
    {
        ConnectReturn.hCard.Context.pbContext = 0;
        ConnectReturn.hCard.Context.pbContext = NULL;
        ConnectReturn.hCard.pbHandle = (BYTE *) &SCardHandle;
        ConnectReturn.hCard.cbHandle = sizeof(SCARDHANDLE);
        fFreeHandle = TRUE;
    }

    //
    // encode the return
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer,
                        &cbEncodedBuffer,
                        &hEnc);
    if (rpcStatus != RPC_S_OK)
    {
        TRC_ERR((TB, _T("MesEncodeDynBufferHandleCreate failed with %lx."), rpcStatus));
        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    _TRY_status(Connect_Return_Encode(hEnc, &ConnectReturn))

    //
    // Send return
    //
    AllocateAndChannelWriteReplyPacket(
                pIoRequestPacket,
                pbEncodedBuffer,
                cbEncodedBuffer);

Return:

    if (fFreeDecode)
    {
        if (dwCallType == SCARD_IOCTL_CONNECTA)
        {
            _TRY_2(ConnectA_Call_Free(hDec, &ConnectCallA))
        }
        else
        {
            _TRY_2(ConnectW_Call_Free(hDec, &ConnectCallW))
        }
    }
    SafeMesHandleFree(&hDec);

    SafeMesHandleFree(&hEnc);

    MIDL_user_free(pbEncodedBuffer);

    MIDL_user_free(pSCardHandleCall);

    DC_END_FN();

    return;

ErrorReturn:

    if (fFreeHandle)
    {
        pfnSCardDisconnect(SCardHandle, SCARD_LEAVE_CARD);
    }

    DefaultIORequestMsgHandleWrapper(pIoRequestPacket, status);

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  W32SCard::Reconnect
//
//---------------------------------------------------------------------------------------
void
W32SCard::Reconnect(
    IN SCARDHANDLECALLSTRUCT    *pSCardHandleCall)
{
    DC_BEGIN_FN("W32SCard::Reconnect");

    RPC_STATUS              rpcStatus               = RPC_S_OK;
    NTSTATUS                status                  = STATUS_SUCCESS;
    char                    *pbEncodedBuffer        = NULL;
    unsigned long           cbEncodedBuffer         = 0;
    handle_t                hDec                    = 0;
    handle_t                hEnc                    = 0;
    SCARDHANDLE             SCardHandle;
    Reconnect_Call          ReconnectCall;
    Reconnect_Return        ReconnectReturn;
    BOOL                    fFreeDecode             = FALSE;
    PRDPDR_IOREQUEST_PACKET pIoRequestPacket        = pSCardHandleCall->pIoRequestPacket;
    PRDPDR_DEVICE_IOREQUEST pIoRequest              = &(pIoRequestPacket->IoRequest);

    memset(&ReconnectReturn, 0, sizeof(ReconnectReturn));
    ReconnectReturn.ReturnCode = SCARD_S_SUCCESS;

    //
    // Decode input parameters
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) (pIoRequest + 1), // bytes are at end of struct
                        pIoRequest->Parameters.DeviceIoControl.InputBufferLength,
                        &hDec);
    if (rpcStatus != RPC_S_OK)
    {
        TRC_ERR((TB, _T("MesDecodeBufferHandleCreate failed with %lx."), rpcStatus));
        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    //
    // Decode input params and make the call to SCard*
    //
    memset(&ReconnectCall, 0, sizeof(ReconnectCall));
    _TRY_status(Reconnect_Call_Decode(hDec, &ReconnectCall))
    fFreeDecode = TRUE;

    if (sizeof(SCARDHANDLE) == ReconnectCall.hCard.cbHandle)
    {
        SCardHandle = *((SCARDHANDLE *) ReconnectCall.hCard.pbHandle);

        ReconnectReturn.ReturnCode =
            pfnSCardReconnect(
                    SCardHandle,
                    ReconnectCall.dwShareMode,
                    ReconnectCall.dwPreferredProtocols,
                    ReconnectCall.dwInitialization,
                    &ReconnectReturn.dwActiveProtocol);
    }
    else
    {
        TRC_ERR((TB, _T("Invalid handle sent from server.")));
        ReconnectReturn.ReturnCode = SCARD_E_INVALID_PARAMETER;
    }

    //
    // encode the return
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer,
                        &cbEncodedBuffer,
                        &hEnc);
    if (rpcStatus != RPC_S_OK)
    {
        TRC_ERR((TB, _T("MesEncodeDynBufferHandleCreate failed with %lx."), rpcStatus));
        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    _TRY_status(Reconnect_Return_Encode(hEnc, &ReconnectReturn))

    //
    // Send return
    //
    AllocateAndChannelWriteReplyPacket(
                pIoRequestPacket,
                pbEncodedBuffer,
                cbEncodedBuffer);

Return:

    if (fFreeDecode)
    {
        _TRY_2(Reconnect_Call_Free(hDec, &ReconnectCall))
    }
    SafeMesHandleFree(&hDec);

    SafeMesHandleFree(&hEnc);

    MIDL_user_free(pbEncodedBuffer);

    MIDL_user_free(pSCardHandleCall);

    DC_END_FN();

    return;

ErrorReturn:

    DefaultIORequestMsgHandleWrapper(pIoRequestPacket, status);

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  W32SCard::HandleHCardAndDispositionCall
//
//---------------------------------------------------------------------------------------
void
W32SCard::HandleHCardAndDispositionCall(
    IN SCARDHANDLECALLSTRUCT    *pSCardHandleCall,
    IN DWORD                    dwCallType)
{
    DC_BEGIN_FN("W32SCard::HandleHCardAndDispositionCall");

    LONG                        lReturn                 = SCARD_S_SUCCESS;
    RPC_STATUS                  rpcStatus               = RPC_S_OK;
    NTSTATUS                    status                  = STATUS_SUCCESS;
    handle_t                    hDec                    = 0;
    SCARDHANDLE                 SCardHandle;
    DWORD                       dwDisposition;
    HCardAndDisposition_Call    HCardAndDispositionCall;
    PRDPDR_IOREQUEST_PACKET     pIoRequestPacket        = pSCardHandleCall->pIoRequestPacket;
    PRDPDR_DEVICE_IOREQUEST     pIoRequest              = &(pIoRequestPacket->IoRequest);

    //
    // Decode input parameters
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) (pIoRequest + 1), // bytes are at end of struct
                        pIoRequest->Parameters.DeviceIoControl.InputBufferLength,
                        &hDec);
    if (rpcStatus != RPC_S_OK)
    {
        TRC_ERR((TB, _T("MesDecodeBufferHandleCreate failed with %lx."), rpcStatus));
        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    memset(&HCardAndDispositionCall, 0, sizeof(HCardAndDispositionCall));
    _TRY_status(HCardAndDisposition_Call_Decode(hDec, &HCardAndDispositionCall))

    if (sizeof(SCARDHANDLE) == HCardAndDispositionCall.hCard.cbHandle)
    {
        SCardHandle = *((SCARDHANDLE *) HCardAndDispositionCall.hCard.pbHandle);
        dwDisposition = HCardAndDispositionCall.dwDisposition;
    }
    else
    {
        TRC_ERR((TB, _T("Invalid handle sent from server.")));
        lReturn = SCARD_E_INVALID_PARAMETER;
    }

    //
    // Free up resources used by decode
    //
    _TRY_2(HCardAndDisposition_Call_Free(hDec, &HCardAndDispositionCall))
    SafeMesHandleFree(&hDec);

    if (lReturn == SCARD_S_SUCCESS)
    {
        //
        // Make SCard subsystem call
        //
        switch(dwCallType)
        {
        case SCARD_IOCTL_DISCONNECT:
            lReturn = pfnSCardDisconnect(SCardHandle, dwDisposition);
            break;
        case SCARD_IOCTL_BEGINTRANSACTION:
            lReturn = pfnSCardBeginTransaction(SCardHandle);
            break;
        case SCARD_IOCTL_ENDTRANSACTION:
            lReturn = pfnSCardEndTransaction(SCardHandle, dwDisposition);
            break;
        }
    }

    //
    // encode and write the return
    //
    EncodeAndChannelWriteLongReturn(pIoRequestPacket, lReturn);

Return:

    MIDL_user_free(pSCardHandleCall);

    DC_END_FN();

    return;

ErrorReturn:

    DefaultIO